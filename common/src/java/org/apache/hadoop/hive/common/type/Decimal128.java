begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Copyright (c) Microsoft Corporation  *  * Licensed under the Apache License, Version 2.0 (the "License");  * you may not use this file except in compliance with the License.  * You may obtain a copy of the License at  *  * http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|common
operator|.
name|type
package|;
end_package

begin_import
import|import
name|java
operator|.
name|math
operator|.
name|BigDecimal
import|;
end_import

begin_import
import|import
name|java
operator|.
name|math
operator|.
name|MathContext
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|IntBuffer
import|;
end_import

begin_comment
comment|/**  * This code was originally written for Microsoft PolyBase.  *<p>  * A 128-bit fixed-length Decimal value in the ANSI SQL Numeric semantics,  * representing unscaledValue / 10**scale where scale is 0 or positive.  *</p>  *<p>  * This class is similar to {@link java.math.BigDecimal}, but a few things  * differ to conform to the SQL Numeric semantics.  *</p>  *<p>  * Scale of this object is specified by the user, not automatically determined  * like {@link java.math.BigDecimal}. This means that underflow is possible  * depending on the scale. {@link java.math.BigDecimal} controls rounding  * behaviors by MathContext, possibly throwing errors. But, underflow is NOT an  * error in ANSI SQL Numeric. "CAST(0.000000000....0001 AS DECIMAL(38,1))" is  * "0.0" without an error.  *</p>  *<p>  * Because this object is fixed-length, overflow is also possible. Overflow IS  * an error in ANSI SQL Numeric. "CAST(10000 AS DECIMAL(38,38))" throws overflow  * error.  *</p>  *<p>  * Each arithmetic operator takes scale as a parameter to control its behavior.  * It's user's (or query optimizer's) responsibility to give an appropriate  * scale parameter.  *</p>  *<p>  * Finally, this class performs MUCH faster than java.math.BigDecimal for a few  * reasons. Its behavior is simple because of the designs above. This class is  * fixed-length without array expansion and re-allocation. This class is  * mutable, allowing reuse of the same object without re-allocation. This class  * and {@link UnsignedInt128} are designed such that minimal heap-object  * allocations are required for most operations. The only exception is division.  * Even this class requires a few object allocations for division, though much  * fewer than BigDecimal.  *</p>  */
end_comment

begin_class
specifier|public
specifier|final
class|class
name|Decimal128
extends|extends
name|Number
implements|implements
name|Comparable
argument_list|<
name|Decimal128
argument_list|>
block|{
comment|/** Maximum value for #scale. */
specifier|public
specifier|static
specifier|final
name|short
name|MAX_SCALE
init|=
literal|38
decl_stmt|;
comment|/** Minimum value for #scale. */
specifier|public
specifier|static
specifier|final
name|short
name|MIN_SCALE
init|=
literal|0
decl_stmt|;
comment|/** Maximum value that can be represented in this class. */
specifier|public
specifier|static
specifier|final
name|Decimal128
name|MAX_VALUE
init|=
operator|new
name|Decimal128
argument_list|(
name|UnsignedInt128
operator|.
name|TEN_TO_THIRTYEIGHT
argument_list|,
operator|(
name|short
operator|)
literal|0
argument_list|,
literal|false
argument_list|)
decl_stmt|;
comment|/** Minimum value that can be represented in this class. */
specifier|public
specifier|static
specifier|final
name|Decimal128
name|MIN_VALUE
init|=
operator|new
name|Decimal128
argument_list|(
name|UnsignedInt128
operator|.
name|TEN_TO_THIRTYEIGHT
argument_list|,
operator|(
name|short
operator|)
literal|0
argument_list|,
literal|true
argument_list|)
decl_stmt|;
comment|/** For Serializable. */
specifier|private
specifier|static
specifier|final
name|long
name|serialVersionUID
init|=
literal|1L
decl_stmt|;
comment|/**    * The unscaled value of this Decimal128, as returned by    * {@link #getUnscaledValue()}.    *    * @serial    * @see #getUnscaledValue()    */
specifier|private
specifier|final
name|UnsignedInt128
name|unscaledValue
decl_stmt|;
comment|/**    * The scale of this Decimal128, as returned by {@link #getScale()}. Unlike    * java.math.BigDecimal, the scale is always zero or positive. The possible    * value range is 0 to 38.    *    * @serial    * @see #getScale()    */
specifier|private
name|short
name|scale
decl_stmt|;
comment|/**    * -1 means negative, 0 means zero, 1 means positive.    *    * @serial    * @see #getSignum()    */
specifier|private
name|byte
name|signum
decl_stmt|;
comment|/**    * Determines the number of ints to store one value.    *    * @param precision    *          precision (0-38)    * @return the number of ints to store one value    */
specifier|public
specifier|static
name|int
name|getIntsPerElement
parameter_list|(
name|int
name|precision
parameter_list|)
block|{
return|return
name|UnsignedInt128
operator|.
name|getIntsPerElement
argument_list|(
name|precision
argument_list|)
operator|+
literal|1
return|;
comment|// +1 for
comment|// scale/signum
block|}
comment|/** Construct a zero. */
specifier|public
name|Decimal128
parameter_list|()
block|{
name|this
operator|.
name|unscaledValue
operator|=
operator|new
name|UnsignedInt128
argument_list|()
expr_stmt|;
name|this
operator|.
name|scale
operator|=
literal|0
expr_stmt|;
name|this
operator|.
name|signum
operator|=
literal|0
expr_stmt|;
block|}
comment|/**    * Copy constructor.    *    * @param o    *          object to copy from    */
specifier|public
name|Decimal128
parameter_list|(
name|Decimal128
name|o
parameter_list|)
block|{
name|this
operator|.
name|unscaledValue
operator|=
operator|new
name|UnsignedInt128
argument_list|(
name|o
operator|.
name|unscaledValue
argument_list|)
expr_stmt|;
name|this
operator|.
name|scale
operator|=
name|o
operator|.
name|scale
expr_stmt|;
name|this
operator|.
name|signum
operator|=
name|o
operator|.
name|signum
expr_stmt|;
block|}
comment|/**    * Translates a {@code double} into a {@code Decimal128} in the given scaling.    * Note that, unlike java.math.BigDecimal, the scaling is given as the    * parameter, not automatically detected. This is one of the differences    * between ANSI SQL Numeric and Java's BigDecimal. See class comments for more    * details.    *<p>    * Unchecked exceptions: ArithmeticException if {@code val} overflows in the    * scaling. NumberFormatException if {@code val} is infinite or NaN.    *</p>    *    * @param val    *          {@code double} value to be converted to {@code Decimal128}.    * @param scale    *          scale of the {@code Decimal128}.    */
specifier|public
name|Decimal128
parameter_list|(
name|double
name|val
parameter_list|,
name|short
name|scale
parameter_list|)
block|{
name|this
argument_list|()
expr_stmt|;
name|update
argument_list|(
name|val
argument_list|,
name|scale
argument_list|)
expr_stmt|;
block|}
comment|/**    * Translates a {@code UnsignedInt128} unscaled value, an {@code int} scale,    * and sign flag into a {@code Decimal128} . The value of the    * {@code Decimal128} is<tt>(unscaledVal&times; 10<sup>-scale</sup>)</tt>.    *    * @param unscaledVal    *          unscaled value of the {@code Decimal128}.    * @param scale    *          scale of the {@code Decimal128}.    * @param negative    *          whether the value is negative    */
specifier|public
name|Decimal128
parameter_list|(
name|UnsignedInt128
name|unscaledVal
parameter_list|,
name|short
name|scale
parameter_list|,
name|boolean
name|negative
parameter_list|)
block|{
name|checkScaleRange
argument_list|(
name|scale
argument_list|)
expr_stmt|;
name|this
operator|.
name|unscaledValue
operator|=
operator|new
name|UnsignedInt128
argument_list|(
name|unscaledVal
argument_list|)
expr_stmt|;
name|this
operator|.
name|scale
operator|=
name|scale
expr_stmt|;
if|if
condition|(
name|unscaledValue
operator|.
name|isZero
argument_list|()
condition|)
block|{
name|this
operator|.
name|signum
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|this
operator|.
name|signum
operator|=
name|negative
condition|?
operator|(
name|byte
operator|)
operator|-
literal|1
else|:
operator|(
name|byte
operator|)
literal|1
expr_stmt|;
block|}
name|this
operator|.
name|unscaledValue
operator|.
name|throwIfExceedsTenToThirtyEight
argument_list|()
expr_stmt|;
block|}
comment|/**    * Translates a {@code long} into a {@code Decimal128}. The scale of the    * {@code Decimal128} is zero.    *    * @param val    *          {@code long} value to be converted to {@code Decimal128}.    */
specifier|public
name|Decimal128
parameter_list|(
name|long
name|val
parameter_list|)
block|{
name|this
argument_list|(
name|val
argument_list|,
operator|(
name|short
operator|)
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/**    * Translates a {@code long} into a {@code Decimal128} with the given scaling.    *    * @param val    *          {@code long} value to be converted to {@code Decimal128}.    * @param scale    *          scale of the {@code Decimal128}.    */
specifier|public
name|Decimal128
parameter_list|(
name|long
name|val
parameter_list|,
name|short
name|scale
parameter_list|)
block|{
name|this
argument_list|()
expr_stmt|;
name|update
argument_list|(
name|val
argument_list|,
name|scale
argument_list|)
expr_stmt|;
block|}
comment|/**    * Constructs from the given string.    *    * @param str    *          string    * @param scale    *          scale of the {@code Decimal128}.    */
specifier|public
name|Decimal128
parameter_list|(
name|String
name|str
parameter_list|,
name|short
name|scale
parameter_list|)
block|{
name|this
argument_list|()
expr_stmt|;
name|update
argument_list|(
name|str
argument_list|,
name|scale
argument_list|)
expr_stmt|;
block|}
comment|/**    * Constructs from the given string with given offset and length.    *    * @param str    *          string    * @param offset    *          offset    * @param length    *          length    * @param scale    *          scale of the {@code Decimal128}.    */
specifier|public
name|Decimal128
parameter_list|(
name|char
index|[]
name|str
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|length
parameter_list|,
name|short
name|scale
parameter_list|)
block|{
name|this
argument_list|()
expr_stmt|;
name|update
argument_list|(
name|str
argument_list|,
name|offset
argument_list|,
name|length
argument_list|,
name|scale
argument_list|)
expr_stmt|;
block|}
comment|/** Reset the value of this object to zero. */
specifier|public
name|void
name|zeroClear
parameter_list|()
block|{
name|this
operator|.
name|unscaledValue
operator|.
name|zeroClear
argument_list|()
expr_stmt|;
name|this
operator|.
name|signum
operator|=
literal|0
expr_stmt|;
block|}
comment|/** @return whether this value represents zero. */
specifier|public
name|boolean
name|isZero
parameter_list|()
block|{
assert|assert
operator|(
operator|(
name|this
operator|.
name|signum
operator|==
literal|0
operator|&&
name|this
operator|.
name|unscaledValue
operator|.
name|isZero
argument_list|()
operator|)
operator|||
operator|(
name|this
operator|.
name|signum
operator|!=
literal|0
operator|&&
operator|!
name|this
operator|.
name|unscaledValue
operator|.
name|isZero
argument_list|()
operator|)
operator|)
assert|;
return|return
name|this
operator|.
name|signum
operator|==
literal|0
return|;
block|}
comment|/**    * Copy the value of given object.    *    * @param o    *          object to copy from    */
specifier|public
name|void
name|update
parameter_list|(
name|Decimal128
name|o
parameter_list|)
block|{
name|this
operator|.
name|unscaledValue
operator|.
name|update
argument_list|(
name|o
operator|.
name|unscaledValue
argument_list|)
expr_stmt|;
name|this
operator|.
name|scale
operator|=
name|o
operator|.
name|scale
expr_stmt|;
name|this
operator|.
name|signum
operator|=
name|o
operator|.
name|signum
expr_stmt|;
block|}
comment|/**    * Update the value of this object with the given {@code long}. The scale of    * the {@code Decimal128} is zero.    *    * @param val    *          {@code long} value to be set to {@code Decimal128}.    */
specifier|public
name|void
name|update
parameter_list|(
name|long
name|val
parameter_list|)
block|{
name|update
argument_list|(
name|val
argument_list|,
operator|(
name|short
operator|)
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/**    * Update the value of this object with the given {@code long} with the given    * scal.    *    * @param val    *          {@code long} value to be set to {@code Decimal128}.    * @param scale    *          scale of the {@code Decimal128}.    */
specifier|public
name|void
name|update
parameter_list|(
name|long
name|val
parameter_list|,
name|short
name|scale
parameter_list|)
block|{
name|this
operator|.
name|scale
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|val
operator|<
literal|0L
condition|)
block|{
name|this
operator|.
name|unscaledValue
operator|.
name|update
argument_list|(
operator|-
name|val
argument_list|)
expr_stmt|;
name|this
operator|.
name|signum
operator|=
operator|-
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|val
operator|==
literal|0L
condition|)
block|{
name|zeroClear
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|this
operator|.
name|unscaledValue
operator|.
name|update
argument_list|(
name|val
argument_list|)
expr_stmt|;
name|this
operator|.
name|signum
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|scale
operator|!=
literal|0
condition|)
block|{
name|changeScaleDestructive
argument_list|(
name|scale
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Update the value of this object with the given {@code double}. in the given    * scaling. Note that, unlike java.math.BigDecimal, the scaling is given as    * the parameter, not automatically detected. This is one of the differences    * between ANSI SQL Numeric and Java's BigDecimal. See class comments for more    * details.    *<p>    * Unchecked exceptions: ArithmeticException if {@code val} overflows in the    * scaling. NumberFormatException if {@code val} is infinite or NaN.    *</p>    *    * @param val    *          {@code double} value to be converted to {@code Decimal128}.    * @param scale    *          scale of the {@code Decimal128}.    */
specifier|public
name|void
name|update
parameter_list|(
name|double
name|val
parameter_list|,
name|short
name|scale
parameter_list|)
block|{
if|if
condition|(
name|Double
operator|.
name|isInfinite
argument_list|(
name|val
argument_list|)
operator|||
name|Double
operator|.
name|isNaN
argument_list|(
name|val
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|NumberFormatException
argument_list|(
literal|"Infinite or NaN"
argument_list|)
throw|;
block|}
name|checkScaleRange
argument_list|(
name|scale
argument_list|)
expr_stmt|;
name|this
operator|.
name|scale
operator|=
name|scale
expr_stmt|;
comment|// Translate the double into sign, exponent and significand, according
comment|// to the formulae in JLS, Section 20.10.22.
name|long
name|valBits
init|=
name|Double
operator|.
name|doubleToLongBits
argument_list|(
name|val
argument_list|)
decl_stmt|;
name|byte
name|sign
init|=
operator|(
operator|(
name|valBits
operator|>>
literal|63
operator|)
operator|==
literal|0
condition|?
operator|(
name|byte
operator|)
literal|1
else|:
operator|(
name|byte
operator|)
operator|-
literal|1
operator|)
decl_stmt|;
name|short
name|exponent
init|=
call|(
name|short
call|)
argument_list|(
operator|(
name|valBits
operator|>>
literal|52
operator|)
operator|&
literal|0x7ffL
argument_list|)
decl_stmt|;
name|long
name|significand
init|=
operator|(
name|exponent
operator|==
literal|0
condition|?
operator|(
name|valBits
operator|&
operator|(
operator|(
literal|1L
operator|<<
literal|52
operator|)
operator|-
literal|1
operator|)
operator|)
operator|<<
literal|1
else|:
operator|(
name|valBits
operator|&
operator|(
operator|(
literal|1L
operator|<<
literal|52
operator|)
operator|-
literal|1
operator|)
operator|)
operator||
operator|(
literal|1L
operator|<<
literal|52
operator|)
operator|)
decl_stmt|;
name|exponent
operator|-=
literal|1075
expr_stmt|;
comment|// zero check
if|if
condition|(
name|significand
operator|==
literal|0
condition|)
block|{
name|zeroClear
argument_list|()
expr_stmt|;
return|return;
block|}
name|this
operator|.
name|signum
operator|=
name|sign
expr_stmt|;
comment|// Normalize
while|while
condition|(
operator|(
name|significand
operator|&
literal|1
operator|)
operator|==
literal|0
condition|)
block|{
comment|// i.e., significand is even
name|significand
operator|>>=
literal|1
expr_stmt|;
name|exponent
operator|++
expr_stmt|;
block|}
comment|// so far same as java.math.BigDecimal, but the scaling below is
comment|// specific to ANSI SQL Numeric.
comment|// first, underflow is NOT an error in ANSI SQL Numeric.
comment|// CAST(0.000000000....0001 AS DECIMAL(38,1)) is "0.0" without an error.
comment|// second, overflow IS an error in ANSI SQL Numeric.
comment|// CAST(10000 AS DECIMAL(38,38)) throws overflow error.
comment|// val == sign * significand * 2**exponent.
comment|// this == sign * unscaledValue / 10**scale.
comment|// so, to make val==this, we need to scale it up/down such that:
comment|// unscaledValue = significand * 2**exponent * 10**scale
comment|// Notice that we must do the scaling carefully to check overflow and
comment|// preserve precision.
name|this
operator|.
name|unscaledValue
operator|.
name|update
argument_list|(
name|significand
argument_list|)
expr_stmt|;
if|if
condition|(
name|exponent
operator|>=
literal|0
condition|)
block|{
comment|// both parts are scaling up. easy. Just check overflow.
name|this
operator|.
name|unscaledValue
operator|.
name|shiftLeftDestructiveCheckOverflow
argument_list|(
name|exponent
argument_list|)
expr_stmt|;
name|this
operator|.
name|unscaledValue
operator|.
name|scaleUpTenDestructive
argument_list|(
name|scale
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// 2**exponent part is scaling down while 10**scale is scaling up.
comment|// Now it's tricky.
comment|// unscaledValue = significand * 10**scale / 2**twoScaleDown
name|short
name|twoScaleDown
init|=
operator|(
name|short
operator|)
operator|-
name|exponent
decl_stmt|;
if|if
condition|(
name|scale
operator|>=
name|twoScaleDown
condition|)
block|{
comment|// make both scaling up as follows
comment|// unscaledValue = significand * 5**(scale) *
comment|// 2**(scale-twoScaleDown)
name|this
operator|.
name|unscaledValue
operator|.
name|shiftLeftDestructiveCheckOverflow
argument_list|(
name|scale
operator|-
name|twoScaleDown
argument_list|)
expr_stmt|;
name|this
operator|.
name|unscaledValue
operator|.
name|scaleUpFiveDestructive
argument_list|(
name|scale
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// Gosh, really both scaling up and down.
comment|// unscaledValue = significand * 5**(scale) /
comment|// 2**(twoScaleDown-scale)
comment|// To check overflow while preserving precision, we need to do a
comment|// real multiplication
name|this
operator|.
name|unscaledValue
operator|.
name|multiplyShiftDestructive
argument_list|(
name|SqlMathUtil
operator|.
name|POWER_FIVES_INT128
index|[
name|scale
index|]
argument_list|,
call|(
name|short
call|)
argument_list|(
name|twoScaleDown
operator|-
name|scale
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**    * Updates the value of this object by reading from ByteBuffer, using the    * required number of ints for the given precision.    *    * @param buf    *          ByteBuffer to read values from    * @param precision    *          0 to 38. Decimal digits.    */
specifier|public
name|void
name|update
parameter_list|(
name|IntBuffer
name|buf
parameter_list|,
name|int
name|precision
parameter_list|)
block|{
name|int
name|scaleAndSignum
init|=
name|buf
operator|.
name|get
argument_list|()
decl_stmt|;
name|this
operator|.
name|scale
operator|=
call|(
name|short
call|)
argument_list|(
name|scaleAndSignum
operator|>>
literal|16
argument_list|)
expr_stmt|;
name|this
operator|.
name|signum
operator|=
call|(
name|byte
call|)
argument_list|(
name|scaleAndSignum
operator|&
literal|0xFF
argument_list|)
expr_stmt|;
name|this
operator|.
name|unscaledValue
operator|.
name|update
argument_list|(
name|buf
argument_list|,
name|precision
argument_list|)
expr_stmt|;
assert|assert
operator|(
operator|(
name|signum
operator|==
literal|0
operator|)
operator|==
name|unscaledValue
operator|.
name|isZero
argument_list|()
operator|)
assert|;
block|}
comment|/**    * Updates the value of this object by reading from ByteBuffer, receiving    * 128+32 bits data (full ranges).    *    * @param buf    *          ByteBuffer to read values from    */
specifier|public
name|void
name|update128
parameter_list|(
name|IntBuffer
name|buf
parameter_list|)
block|{
name|int
name|scaleAndSignum
init|=
name|buf
operator|.
name|get
argument_list|()
decl_stmt|;
name|this
operator|.
name|scale
operator|=
call|(
name|short
call|)
argument_list|(
name|scaleAndSignum
operator|>>
literal|16
argument_list|)
expr_stmt|;
name|this
operator|.
name|signum
operator|=
call|(
name|byte
call|)
argument_list|(
name|scaleAndSignum
operator|&
literal|0xFF
argument_list|)
expr_stmt|;
name|this
operator|.
name|unscaledValue
operator|.
name|update128
argument_list|(
name|buf
argument_list|)
expr_stmt|;
assert|assert
operator|(
operator|(
name|signum
operator|==
literal|0
operator|)
operator|==
name|unscaledValue
operator|.
name|isZero
argument_list|()
operator|)
assert|;
block|}
comment|/**    * Updates the value of this object by reading from ByteBuffer, receiving only    * 96+32 bits data.    *    * @param buf    *          ByteBuffer to read values from    */
specifier|public
name|void
name|update96
parameter_list|(
name|IntBuffer
name|buf
parameter_list|)
block|{
name|int
name|scaleAndSignum
init|=
name|buf
operator|.
name|get
argument_list|()
decl_stmt|;
name|this
operator|.
name|scale
operator|=
call|(
name|short
call|)
argument_list|(
name|scaleAndSignum
operator|>>
literal|16
argument_list|)
expr_stmt|;
name|this
operator|.
name|signum
operator|=
call|(
name|byte
call|)
argument_list|(
name|scaleAndSignum
operator|&
literal|0xFF
argument_list|)
expr_stmt|;
name|this
operator|.
name|unscaledValue
operator|.
name|update96
argument_list|(
name|buf
argument_list|)
expr_stmt|;
assert|assert
operator|(
operator|(
name|signum
operator|==
literal|0
operator|)
operator|==
name|unscaledValue
operator|.
name|isZero
argument_list|()
operator|)
assert|;
block|}
comment|/**    * Updates the value of this object by reading from ByteBuffer, receiving only    * 64+32 bits data.    *    * @param buf    *          ByteBuffer to read values from    */
specifier|public
name|void
name|update64
parameter_list|(
name|IntBuffer
name|buf
parameter_list|)
block|{
name|int
name|scaleAndSignum
init|=
name|buf
operator|.
name|get
argument_list|()
decl_stmt|;
name|this
operator|.
name|scale
operator|=
call|(
name|short
call|)
argument_list|(
name|scaleAndSignum
operator|>>
literal|16
argument_list|)
expr_stmt|;
name|this
operator|.
name|signum
operator|=
call|(
name|byte
call|)
argument_list|(
name|scaleAndSignum
operator|&
literal|0xFF
argument_list|)
expr_stmt|;
name|this
operator|.
name|unscaledValue
operator|.
name|update64
argument_list|(
name|buf
argument_list|)
expr_stmt|;
assert|assert
operator|(
operator|(
name|signum
operator|==
literal|0
operator|)
operator|==
name|unscaledValue
operator|.
name|isZero
argument_list|()
operator|)
assert|;
block|}
comment|/**    * Updates the value of this object by reading from ByteBuffer, receiving only    * 32+32 bits data.    *    * @param buf    *          ByteBuffer to read values from    */
specifier|public
name|void
name|update32
parameter_list|(
name|IntBuffer
name|buf
parameter_list|)
block|{
name|int
name|scaleAndSignum
init|=
name|buf
operator|.
name|get
argument_list|()
decl_stmt|;
name|this
operator|.
name|scale
operator|=
call|(
name|short
call|)
argument_list|(
name|scaleAndSignum
operator|>>
literal|16
argument_list|)
expr_stmt|;
name|this
operator|.
name|signum
operator|=
call|(
name|byte
call|)
argument_list|(
name|scaleAndSignum
operator|&
literal|0xFF
argument_list|)
expr_stmt|;
name|this
operator|.
name|unscaledValue
operator|.
name|update32
argument_list|(
name|buf
argument_list|)
expr_stmt|;
assert|assert
operator|(
operator|(
name|signum
operator|==
literal|0
operator|)
operator|==
name|unscaledValue
operator|.
name|isZero
argument_list|()
operator|)
assert|;
block|}
comment|/**    * Updates the value of this object by reading from the given array, using the    * required number of ints for the given precision.    *    * @param array    *          array to read values from    * @param offset    *          offset of the long array    * @param precision    *          0 to 38. Decimal digits.    */
specifier|public
name|void
name|update
parameter_list|(
name|int
index|[]
name|array
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|precision
parameter_list|)
block|{
name|int
name|scaleAndSignum
init|=
name|array
index|[
name|offset
index|]
decl_stmt|;
name|this
operator|.
name|scale
operator|=
call|(
name|short
call|)
argument_list|(
name|scaleAndSignum
operator|>>
literal|16
argument_list|)
expr_stmt|;
name|this
operator|.
name|signum
operator|=
call|(
name|byte
call|)
argument_list|(
name|scaleAndSignum
operator|&
literal|0xFF
argument_list|)
expr_stmt|;
name|this
operator|.
name|unscaledValue
operator|.
name|update
argument_list|(
name|array
argument_list|,
name|offset
operator|+
literal|1
argument_list|,
name|precision
argument_list|)
expr_stmt|;
block|}
comment|/**    * Updates the value of this object by reading from the given integers,    * receiving 128+32 bits of data (full range).    *    * @param array    *          array to read from    * @param offset    *          offset of the int array    */
specifier|public
name|void
name|update128
parameter_list|(
name|int
index|[]
name|array
parameter_list|,
name|int
name|offset
parameter_list|)
block|{
name|int
name|scaleAndSignum
init|=
name|array
index|[
name|offset
index|]
decl_stmt|;
name|this
operator|.
name|scale
operator|=
call|(
name|short
call|)
argument_list|(
name|scaleAndSignum
operator|>>
literal|16
argument_list|)
expr_stmt|;
name|this
operator|.
name|signum
operator|=
call|(
name|byte
call|)
argument_list|(
name|scaleAndSignum
operator|&
literal|0xFF
argument_list|)
expr_stmt|;
name|this
operator|.
name|unscaledValue
operator|.
name|update128
argument_list|(
name|array
argument_list|,
name|offset
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/**    * Updates the value of this object by reading from the given integers,    * receiving only 96+32 bits data.    *    * @param array    *          array to read from    * @param offset    *          offset of the int array    */
specifier|public
name|void
name|update96
parameter_list|(
name|int
index|[]
name|array
parameter_list|,
name|int
name|offset
parameter_list|)
block|{
name|int
name|scaleAndSignum
init|=
name|array
index|[
name|offset
index|]
decl_stmt|;
name|this
operator|.
name|scale
operator|=
call|(
name|short
call|)
argument_list|(
name|scaleAndSignum
operator|>>
literal|16
argument_list|)
expr_stmt|;
name|this
operator|.
name|signum
operator|=
call|(
name|byte
call|)
argument_list|(
name|scaleAndSignum
operator|&
literal|0xFF
argument_list|)
expr_stmt|;
name|this
operator|.
name|unscaledValue
operator|.
name|update96
argument_list|(
name|array
argument_list|,
name|offset
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/**    * Updates the value of this object by reading from the given integers,    * receiving only 64+32 bits data.    *    * @param array    *          array to read from    * @param offset    *          offset of the int array    */
specifier|public
name|void
name|update64
parameter_list|(
name|int
index|[]
name|array
parameter_list|,
name|int
name|offset
parameter_list|)
block|{
name|int
name|scaleAndSignum
init|=
name|array
index|[
name|offset
index|]
decl_stmt|;
name|this
operator|.
name|scale
operator|=
call|(
name|short
call|)
argument_list|(
name|scaleAndSignum
operator|>>
literal|16
argument_list|)
expr_stmt|;
name|this
operator|.
name|signum
operator|=
call|(
name|byte
call|)
argument_list|(
name|scaleAndSignum
operator|&
literal|0xFF
argument_list|)
expr_stmt|;
name|this
operator|.
name|unscaledValue
operator|.
name|update64
argument_list|(
name|array
argument_list|,
name|offset
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/**    * Updates the value of this object by reading from the given integers,    * receiving only 32+32 bits data.    *    * @param array    *          array to read from    * @param offset    *          offset of the int array    */
specifier|public
name|void
name|update32
parameter_list|(
name|int
index|[]
name|array
parameter_list|,
name|int
name|offset
parameter_list|)
block|{
name|int
name|scaleAndSignum
init|=
name|array
index|[
name|offset
index|]
decl_stmt|;
name|this
operator|.
name|scale
operator|=
call|(
name|short
call|)
argument_list|(
name|scaleAndSignum
operator|>>
literal|16
argument_list|)
expr_stmt|;
name|this
operator|.
name|signum
operator|=
call|(
name|byte
call|)
argument_list|(
name|scaleAndSignum
operator|&
literal|0xFF
argument_list|)
expr_stmt|;
name|this
operator|.
name|unscaledValue
operator|.
name|update32
argument_list|(
name|array
argument_list|,
name|offset
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/**    * Updates the value of this object with the given string.    *    * @param str    *          string    * @param scale    *          scale of the {@code Decimal128}.    */
specifier|public
name|void
name|update
parameter_list|(
name|String
name|str
parameter_list|,
name|short
name|scale
parameter_list|)
block|{
name|update
argument_list|(
name|str
operator|.
name|toCharArray
argument_list|()
argument_list|,
literal|0
argument_list|,
name|str
operator|.
name|length
argument_list|()
argument_list|,
name|scale
argument_list|)
expr_stmt|;
block|}
comment|/**    * Updates the value of this object from the given string with given offset    * and length.    *    * @param str    *          string    * @param offset    *          offset    * @param length    *          length    * @param scale    *          scale of the {@code Decimal128}.    */
specifier|public
name|void
name|update
parameter_list|(
name|char
index|[]
name|str
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|length
parameter_list|,
name|short
name|scale
parameter_list|)
block|{
specifier|final
name|int
name|end
init|=
name|offset
operator|+
name|length
decl_stmt|;
assert|assert
operator|(
name|end
operator|<=
name|str
operator|.
name|length
operator|)
assert|;
name|int
name|cursor
init|=
name|offset
decl_stmt|;
comment|// sign mark
name|boolean
name|negative
init|=
literal|false
decl_stmt|;
if|if
condition|(
name|str
index|[
name|cursor
index|]
operator|==
literal|'+'
condition|)
block|{
operator|++
name|cursor
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|str
index|[
name|cursor
index|]
operator|==
literal|'-'
condition|)
block|{
name|negative
operator|=
literal|true
expr_stmt|;
operator|++
name|cursor
expr_stmt|;
block|}
comment|// Skip leading zeros and compute number of digits in magnitude
while|while
condition|(
name|cursor
operator|<
name|end
operator|&&
name|str
index|[
name|cursor
index|]
operator|==
literal|'0'
condition|)
block|{
operator|++
name|cursor
expr_stmt|;
block|}
name|this
operator|.
name|scale
operator|=
name|scale
expr_stmt|;
name|zeroClear
argument_list|()
expr_stmt|;
if|if
condition|(
name|cursor
operator|==
name|end
condition|)
block|{
return|return;
block|}
comment|// "1234567" => unscaledValue=1234567, negative=false,
comment|// fractionalDigits=0
comment|// "-1234567.89" => unscaledValue=123456789, negative=true,
comment|// fractionalDigits=2
comment|// "12.3E7" => unscaledValue=123, negative=false, fractionalDigits=1,
comment|// exponent=7
comment|// ".123E-7" => unscaledValue=123, negative=false, fractionalDigits=3,
comment|// exponent=-7
name|int
name|accumulated
init|=
literal|0
decl_stmt|;
name|int
name|accumulatedCount
init|=
literal|0
decl_stmt|;
name|boolean
name|fractional
init|=
literal|false
decl_stmt|;
comment|// after "."?
name|int
name|fractionalDigits
init|=
literal|0
decl_stmt|;
name|int
name|exponent
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|cursor
operator|<
name|end
condition|)
block|{
if|if
condition|(
name|str
index|[
name|cursor
index|]
operator|==
literal|'.'
condition|)
block|{
if|if
condition|(
name|fractional
condition|)
block|{
comment|// two dots??
throw|throw
operator|new
name|NumberFormatException
argument_list|(
literal|"Invalid string:"
operator|+
operator|new
name|String
argument_list|(
name|str
argument_list|,
name|offset
argument_list|,
name|length
argument_list|)
argument_list|)
throw|;
block|}
name|fractional
operator|=
literal|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|str
index|[
name|cursor
index|]
operator|>=
literal|'0'
operator|&&
name|str
index|[
name|cursor
index|]
operator|<=
literal|'9'
condition|)
block|{
if|if
condition|(
name|accumulatedCount
operator|==
literal|9
condition|)
block|{
name|this
operator|.
name|unscaledValue
operator|.
name|scaleUpTenDestructive
argument_list|(
operator|(
name|short
operator|)
name|accumulatedCount
argument_list|)
expr_stmt|;
name|this
operator|.
name|unscaledValue
operator|.
name|addDestructive
argument_list|(
name|accumulated
argument_list|)
expr_stmt|;
name|accumulated
operator|=
literal|0
expr_stmt|;
name|accumulatedCount
operator|=
literal|0
expr_stmt|;
block|}
name|int
name|digit
init|=
name|str
index|[
name|cursor
index|]
operator|-
literal|'0'
decl_stmt|;
name|accumulated
operator|=
name|accumulated
operator|*
literal|10
operator|+
name|digit
expr_stmt|;
operator|++
name|accumulatedCount
expr_stmt|;
if|if
condition|(
name|fractional
condition|)
block|{
operator|++
name|fractionalDigits
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|str
index|[
name|cursor
index|]
operator|==
literal|'e'
operator|||
name|str
index|[
name|cursor
index|]
operator|==
literal|'E'
condition|)
block|{
comment|// exponent part
operator|++
name|cursor
expr_stmt|;
name|boolean
name|exponentNagative
init|=
literal|false
decl_stmt|;
if|if
condition|(
name|str
index|[
name|cursor
index|]
operator|==
literal|'+'
condition|)
block|{
operator|++
name|cursor
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|str
index|[
name|cursor
index|]
operator|==
literal|'-'
condition|)
block|{
name|exponentNagative
operator|=
literal|true
expr_stmt|;
operator|++
name|cursor
expr_stmt|;
block|}
while|while
condition|(
name|cursor
operator|<
name|end
condition|)
block|{
if|if
condition|(
name|str
index|[
name|cursor
index|]
operator|>=
literal|'0'
operator|&&
name|str
index|[
name|cursor
index|]
operator|<=
literal|'9'
condition|)
block|{
name|int
name|exponentDigit
init|=
name|str
index|[
name|cursor
index|]
operator|-
literal|'0'
decl_stmt|;
name|exponent
operator|*=
literal|10
expr_stmt|;
name|exponent
operator|+=
name|exponentDigit
expr_stmt|;
block|}
operator|++
name|cursor
expr_stmt|;
block|}
if|if
condition|(
name|exponentNagative
condition|)
block|{
name|exponent
operator|=
operator|-
name|exponent
expr_stmt|;
block|}
block|}
else|else
block|{
throw|throw
operator|new
name|NumberFormatException
argument_list|(
literal|"Invalid string:"
operator|+
operator|new
name|String
argument_list|(
name|str
argument_list|,
name|offset
argument_list|,
name|length
argument_list|)
argument_list|)
throw|;
block|}
operator|++
name|cursor
expr_stmt|;
block|}
if|if
condition|(
name|accumulatedCount
operator|>
literal|0
condition|)
block|{
name|this
operator|.
name|unscaledValue
operator|.
name|scaleUpTenDestructive
argument_list|(
operator|(
name|short
operator|)
name|accumulatedCount
argument_list|)
expr_stmt|;
name|this
operator|.
name|unscaledValue
operator|.
name|addDestructive
argument_list|(
name|accumulated
argument_list|)
expr_stmt|;
block|}
name|int
name|scaleAdjust
init|=
name|scale
operator|-
name|fractionalDigits
operator|+
name|exponent
decl_stmt|;
if|if
condition|(
name|scaleAdjust
operator|>
literal|0
condition|)
block|{
name|this
operator|.
name|unscaledValue
operator|.
name|scaleUpTenDestructive
argument_list|(
operator|(
name|short
operator|)
name|scaleAdjust
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|scaleAdjust
operator|<
literal|0
condition|)
block|{
name|this
operator|.
name|unscaledValue
operator|.
name|scaleDownTenDestructive
argument_list|(
operator|(
name|short
operator|)
operator|-
name|scaleAdjust
argument_list|)
expr_stmt|;
block|}
name|this
operator|.
name|signum
operator|=
call|(
name|byte
call|)
argument_list|(
name|this
operator|.
name|unscaledValue
operator|.
name|isZero
argument_list|()
condition|?
literal|0
else|:
operator|(
name|negative
condition|?
operator|-
literal|1
else|:
literal|1
operator|)
argument_list|)
expr_stmt|;
block|}
comment|/**    * Serialize this object to the given array, putting the required number of    * ints for the given precision.    *    * @param array    *          array to write values to    * @param offset    *          offset of the int array    * @param precision    *          0 to 38. Decimal digits.    */
specifier|public
name|void
name|serializeTo
parameter_list|(
name|int
index|[]
name|array
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|precision
parameter_list|)
block|{
name|array
index|[
name|offset
index|]
operator|=
operator|(
operator|(
name|scale
operator|<<
literal|16
operator|)
operator||
operator|(
name|signum
operator|&
literal|0xFF
operator|)
operator|)
expr_stmt|;
name|this
operator|.
name|unscaledValue
operator|.
name|serializeTo
argument_list|(
name|array
argument_list|,
name|offset
operator|+
literal|1
argument_list|,
name|precision
argument_list|)
expr_stmt|;
block|}
comment|/**    * Serialize this object to the given integers, putting 128+32 bits of data    * (full range).    *    * @param array    *          array to write values to    * @param offset    *          offset of the int array    */
specifier|public
name|void
name|serializeTo128
parameter_list|(
name|int
index|[]
name|array
parameter_list|,
name|int
name|offset
parameter_list|)
block|{
name|array
index|[
name|offset
index|]
operator|=
operator|(
operator|(
name|scale
operator|<<
literal|16
operator|)
operator||
operator|(
name|signum
operator|&
literal|0xFF
operator|)
operator|)
expr_stmt|;
name|this
operator|.
name|unscaledValue
operator|.
name|serializeTo128
argument_list|(
name|array
argument_list|,
name|offset
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/**    * Serialize this object to the given integers, putting only 96+32 bits of    * data.    *    * @param array    *          array to write values to    * @param offset    *          offset of the int array    */
specifier|public
name|void
name|serializeTo96
parameter_list|(
name|int
index|[]
name|array
parameter_list|,
name|int
name|offset
parameter_list|)
block|{
name|array
index|[
name|offset
index|]
operator|=
operator|(
operator|(
name|scale
operator|<<
literal|16
operator|)
operator||
operator|(
name|signum
operator|&
literal|0xFF
operator|)
operator|)
expr_stmt|;
name|this
operator|.
name|unscaledValue
operator|.
name|serializeTo96
argument_list|(
name|array
argument_list|,
name|offset
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/**    * Serialize this object to the given integers, putting only 64+32 bits of    * data.    *    * @param array    *          array to write values to    * @param offset    *          offset of the int array    */
specifier|public
name|void
name|serializeTo64
parameter_list|(
name|int
index|[]
name|array
parameter_list|,
name|int
name|offset
parameter_list|)
block|{
name|array
index|[
name|offset
index|]
operator|=
operator|(
operator|(
name|scale
operator|<<
literal|16
operator|)
operator||
operator|(
name|signum
operator|&
literal|0xFF
operator|)
operator|)
expr_stmt|;
name|this
operator|.
name|unscaledValue
operator|.
name|serializeTo64
argument_list|(
name|array
argument_list|,
name|offset
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/**    * Serialize this object to the given integers, putting only 32+32 bits of    * data.    *    * @param array    *          array to write values to    * @param offset    *          offset of the int array    */
specifier|public
name|void
name|serializeTo32
parameter_list|(
name|int
index|[]
name|array
parameter_list|,
name|int
name|offset
parameter_list|)
block|{
name|array
index|[
name|offset
index|]
operator|=
operator|(
operator|(
name|scale
operator|<<
literal|16
operator|)
operator||
operator|(
name|signum
operator|&
literal|0xFF
operator|)
operator|)
expr_stmt|;
name|this
operator|.
name|unscaledValue
operator|.
name|serializeTo32
argument_list|(
name|array
argument_list|,
name|offset
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/**    * Serialize this object to the given ByteBuffer, putting the required number    * of ints for the given precision.    *    * @param buf    *          ByteBuffer to write values to    * @param precision    *          0 to 38. Decimal digits.    */
specifier|public
name|void
name|serializeTo
parameter_list|(
name|IntBuffer
name|buf
parameter_list|,
name|int
name|precision
parameter_list|)
block|{
name|buf
operator|.
name|put
argument_list|(
operator|(
name|scale
operator|<<
literal|16
operator|)
operator||
operator|(
name|signum
operator|&
literal|0xFF
operator|)
argument_list|)
expr_stmt|;
name|this
operator|.
name|unscaledValue
operator|.
name|serializeTo
argument_list|(
name|buf
argument_list|,
name|precision
argument_list|)
expr_stmt|;
block|}
comment|/**    * Serialize this object to the given ByteBuffer, putting 128+32 bits of data    * (full range).    *    * @param buf    *          ByteBuffer to write values to    */
specifier|public
name|void
name|serializeTo128
parameter_list|(
name|IntBuffer
name|buf
parameter_list|)
block|{
name|buf
operator|.
name|put
argument_list|(
operator|(
name|scale
operator|<<
literal|16
operator|)
operator||
operator|(
name|signum
operator|&
literal|0xFF
operator|)
argument_list|)
expr_stmt|;
name|this
operator|.
name|unscaledValue
operator|.
name|serializeTo128
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
comment|/**    * Serialize this object to the given ByteBuffer, putting only 96+32 bits of    * data.    *    * @param buf    *          ByteBuffer to write values to    */
specifier|public
name|void
name|serializeTo96
parameter_list|(
name|IntBuffer
name|buf
parameter_list|)
block|{
name|buf
operator|.
name|put
argument_list|(
operator|(
name|scale
operator|<<
literal|16
operator|)
operator||
operator|(
name|signum
operator|&
literal|0xFF
operator|)
argument_list|)
expr_stmt|;
name|this
operator|.
name|unscaledValue
operator|.
name|serializeTo96
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
comment|/**    * Serialize this object to the given ByteBuffer, putting only 64+32 bits of    * data.    *    * @param buf    *          ByteBuffer to write values to    */
specifier|public
name|void
name|serializeTo64
parameter_list|(
name|IntBuffer
name|buf
parameter_list|)
block|{
name|buf
operator|.
name|put
argument_list|(
operator|(
name|scale
operator|<<
literal|16
operator|)
operator||
operator|(
name|signum
operator|&
literal|0xFF
operator|)
argument_list|)
expr_stmt|;
name|this
operator|.
name|unscaledValue
operator|.
name|serializeTo64
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
comment|/**    * Serialize this object to the given ByteBuffer, putting only 32+32 bits of    * data.    *    * @param buf    *          ByteBuffer to write values to    */
specifier|public
name|void
name|serializeTo32
parameter_list|(
name|IntBuffer
name|buf
parameter_list|)
block|{
name|buf
operator|.
name|put
argument_list|(
operator|(
name|scale
operator|<<
literal|16
operator|)
operator||
operator|(
name|signum
operator|&
literal|0xFF
operator|)
argument_list|)
expr_stmt|;
name|this
operator|.
name|unscaledValue
operator|.
name|serializeTo32
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
comment|/**    * Changes the scaling of this {@code Decimal128}, preserving the represented    * value. This method is destructive.    *<p>    * This method is NOT just a setter for #scale. It also adjusts the unscaled    * value to preserve the represented value.    *</p>    *<p>    * When the given scaling is larger than the current scaling, this method    * shrinks the unscaled value accordingly. It will NOT throw any error even if    * underflow happens.    *</p>    *<p>    * When the given scaling is smaller than the current scaling, this method    * expands the unscaled value accordingly. It does throw an error if overflow    * happens.    *</p>    *<p>    * Unchecked exceptions: ArithmeticException a negative value is specified or    * overflow.    *</p>    *    * @param scale    *          new scale. must be 0 or positive.    */
specifier|public
name|void
name|changeScaleDestructive
parameter_list|(
name|short
name|scale
parameter_list|)
block|{
if|if
condition|(
name|scale
operator|==
name|this
operator|.
name|scale
condition|)
block|{
return|return;
block|}
name|checkScaleRange
argument_list|(
name|scale
argument_list|)
expr_stmt|;
name|short
name|scaleDown
init|=
call|(
name|short
call|)
argument_list|(
name|this
operator|.
name|scale
operator|-
name|scale
argument_list|)
decl_stmt|;
if|if
condition|(
name|scaleDown
operator|>
literal|0
condition|)
block|{
name|this
operator|.
name|unscaledValue
operator|.
name|scaleDownTenDestructive
argument_list|(
name|scaleDown
argument_list|)
expr_stmt|;
if|if
condition|(
name|this
operator|.
name|unscaledValue
operator|.
name|isZero
argument_list|()
condition|)
block|{
name|this
operator|.
name|signum
operator|=
literal|0
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|scaleDown
operator|<
literal|0
condition|)
block|{
name|this
operator|.
name|unscaledValue
operator|.
name|scaleUpTenDestructive
argument_list|(
operator|(
name|short
operator|)
operator|-
name|scaleDown
argument_list|)
expr_stmt|;
block|}
name|this
operator|.
name|scale
operator|=
name|scale
expr_stmt|;
name|this
operator|.
name|unscaledValue
operator|.
name|throwIfExceedsTenToThirtyEight
argument_list|()
expr_stmt|;
block|}
comment|/**    * Calculates addition and puts the result into the given object. Both    * operands are first scaled up/down to the specified scale, then this method    * performs the operation. This method is static and not destructive (except    * the result object).    *<p>    * Unchecked exceptions: ArithmeticException an invalid scale is specified or    * overflow.    *</p>    *    * @param left    *          left operand    * @param right    *          right operand    * @param scale    *          scale of the result. must be 0 or positive.    * @param result    *          object to receive the calculation result    */
specifier|public
specifier|static
name|void
name|add
parameter_list|(
name|Decimal128
name|left
parameter_list|,
name|Decimal128
name|right
parameter_list|,
name|Decimal128
name|result
parameter_list|,
name|short
name|scale
parameter_list|)
block|{
name|result
operator|.
name|update
argument_list|(
name|left
argument_list|)
expr_stmt|;
name|result
operator|.
name|addDestructive
argument_list|(
name|right
argument_list|,
name|scale
argument_list|)
expr_stmt|;
block|}
comment|/**    * Calculates addition and stores the result into this object. This method is    * destructive.    *<p>    * Unchecked exceptions: ArithmeticException an invalid scale is specified or    * overflow.    *</p>    *    * @param right    *          right operand    * @param scale    *          scale of the result. must be 0 or positive.    */
specifier|public
name|void
name|addDestructive
parameter_list|(
name|Decimal128
name|right
parameter_list|,
name|short
name|scale
parameter_list|)
block|{
name|this
operator|.
name|changeScaleDestructive
argument_list|(
name|scale
argument_list|)
expr_stmt|;
if|if
condition|(
name|right
operator|.
name|signum
operator|==
literal|0
condition|)
block|{
return|return;
block|}
if|if
condition|(
name|this
operator|.
name|signum
operator|==
literal|0
condition|)
block|{
name|this
operator|.
name|update
argument_list|(
name|right
argument_list|)
expr_stmt|;
name|this
operator|.
name|changeScaleDestructive
argument_list|(
name|scale
argument_list|)
expr_stmt|;
return|return;
block|}
name|short
name|rightScaleTen
init|=
call|(
name|short
call|)
argument_list|(
name|scale
operator|-
name|right
operator|.
name|scale
argument_list|)
decl_stmt|;
if|if
condition|(
name|this
operator|.
name|signum
operator|==
name|right
operator|.
name|signum
condition|)
block|{
comment|// if same sign, just add up the absolute values
name|this
operator|.
name|unscaledValue
operator|.
name|addDestructiveScaleTen
argument_list|(
name|right
operator|.
name|unscaledValue
argument_list|,
name|rightScaleTen
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|byte
name|cmp
init|=
name|UnsignedInt128
operator|.
name|differenceScaleTen
argument_list|(
name|this
operator|.
name|unscaledValue
argument_list|,
name|right
operator|.
name|unscaledValue
argument_list|,
name|this
operator|.
name|unscaledValue
argument_list|,
name|rightScaleTen
argument_list|)
decl_stmt|;
if|if
condition|(
name|cmp
operator|==
literal|0
condition|)
block|{
name|this
operator|.
name|signum
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cmp
operator|<
literal|0
condition|)
block|{
comment|// right's signum wins
name|this
operator|.
name|signum
operator|=
name|right
operator|.
name|signum
expr_stmt|;
block|}
comment|// if left's signum wins, we don't need to do anything
block|}
name|this
operator|.
name|unscaledValue
operator|.
name|throwIfExceedsTenToThirtyEight
argument_list|()
expr_stmt|;
block|}
comment|/**    * Calculates subtraction and puts the result into the given object. Both    * operands are first scaled up/down to the specified scale, then this method    * performs the operation. This method is static and not destructive (except    * the result object).    *<p>    * Unchecked exceptions: ArithmeticException an invalid scale is specified or    * overflow.    *</p>    *    * @param left    *          left operand    * @param right    *          right operand    * @param result    *          object to receive the calculation result    * @param scale    *          scale of the result. must be 0 or positive.    */
specifier|public
specifier|static
name|void
name|subtract
parameter_list|(
name|Decimal128
name|left
parameter_list|,
name|Decimal128
name|right
parameter_list|,
name|Decimal128
name|result
parameter_list|,
name|short
name|scale
parameter_list|)
block|{
name|result
operator|.
name|update
argument_list|(
name|left
argument_list|)
expr_stmt|;
name|result
operator|.
name|subtractDestructive
argument_list|(
name|right
argument_list|,
name|scale
argument_list|)
expr_stmt|;
block|}
comment|/**    * Calculates subtraction and stores the result into this object. This method    * is destructive.    *<p>    * Unchecked exceptions: ArithmeticException an invalid scale is specified or    * overflow.    *</p>    *    * @param right    *          right operand    * @param scale    *          scale of the result. must be 0 or positive.    */
specifier|public
name|void
name|subtractDestructive
parameter_list|(
name|Decimal128
name|right
parameter_list|,
name|short
name|scale
parameter_list|)
block|{
name|this
operator|.
name|changeScaleDestructive
argument_list|(
name|scale
argument_list|)
expr_stmt|;
if|if
condition|(
name|right
operator|.
name|signum
operator|==
literal|0
condition|)
block|{
return|return;
block|}
if|if
condition|(
name|this
operator|.
name|signum
operator|==
literal|0
condition|)
block|{
name|this
operator|.
name|update
argument_list|(
name|right
argument_list|)
expr_stmt|;
name|this
operator|.
name|changeScaleDestructive
argument_list|(
name|scale
argument_list|)
expr_stmt|;
name|this
operator|.
name|negateDestructive
argument_list|()
expr_stmt|;
return|return;
block|}
name|short
name|rightScaleTen
init|=
call|(
name|short
call|)
argument_list|(
name|scale
operator|-
name|right
operator|.
name|scale
argument_list|)
decl_stmt|;
if|if
condition|(
name|this
operator|.
name|signum
operator|!=
name|right
operator|.
name|signum
condition|)
block|{
comment|// if different sign, just add up the absolute values
name|this
operator|.
name|unscaledValue
operator|.
name|addDestructiveScaleTen
argument_list|(
name|right
operator|.
name|unscaledValue
argument_list|,
name|rightScaleTen
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|byte
name|cmp
init|=
name|UnsignedInt128
operator|.
name|differenceScaleTen
argument_list|(
name|this
operator|.
name|unscaledValue
argument_list|,
name|right
operator|.
name|unscaledValue
argument_list|,
name|this
operator|.
name|unscaledValue
argument_list|,
name|rightScaleTen
argument_list|)
decl_stmt|;
if|if
condition|(
name|cmp
operator|==
literal|0
condition|)
block|{
name|this
operator|.
name|signum
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cmp
operator|<
literal|0
condition|)
block|{
comment|// right's signum wins (notice the negation, because we are
comment|// subtracting right)
name|this
operator|.
name|signum
operator|=
operator|(
name|byte
operator|)
operator|-
name|right
operator|.
name|signum
expr_stmt|;
block|}
comment|// if left's signum wins, we don't need to do anything
block|}
name|this
operator|.
name|unscaledValue
operator|.
name|throwIfExceedsTenToThirtyEight
argument_list|()
expr_stmt|;
block|}
comment|/**    * Calculates multiplication and puts the result into the given object. Both    * operands are first scaled up/down to the specified scale, then this method    * performs the operation. This method is static and not destructive (except    * the result object).    *<p>    * Unchecked exceptions: ArithmeticException an invalid scale is specified or    * overflow.    *</p>    *    * @param left    *          left operand    * @param right    *          right operand    * @param result    *          object to receive the calculation result    * @param scale    *          scale of the result. must be 0 or positive.    */
specifier|public
specifier|static
name|void
name|multiply
parameter_list|(
name|Decimal128
name|left
parameter_list|,
name|Decimal128
name|right
parameter_list|,
name|Decimal128
name|result
parameter_list|,
name|short
name|scale
parameter_list|)
block|{
if|if
condition|(
name|result
operator|==
name|left
operator|||
name|result
operator|==
name|right
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"result object cannot be left or right operand"
argument_list|)
throw|;
block|}
name|result
operator|.
name|update
argument_list|(
name|left
argument_list|)
expr_stmt|;
name|result
operator|.
name|multiplyDestructive
argument_list|(
name|right
argument_list|,
name|scale
argument_list|)
expr_stmt|;
block|}
comment|/**    * Performs multiplication, changing the scale of this object to the specified    * value.    *    * @param right    *          right operand. this object is not modified.    * @param newScale    *          scale of the result. must be 0 or positive.    */
specifier|public
name|void
name|multiplyDestructive
parameter_list|(
name|Decimal128
name|right
parameter_list|,
name|short
name|newScale
parameter_list|)
block|{
if|if
condition|(
name|this
operator|.
name|signum
operator|==
literal|0
operator|||
name|right
operator|.
name|signum
operator|==
literal|0
condition|)
block|{
name|this
operator|.
name|zeroClear
argument_list|()
expr_stmt|;
name|this
operator|.
name|scale
operator|=
name|newScale
expr_stmt|;
return|return;
block|}
comment|// this = this.mag / 10**this.scale
comment|// right = right.mag / 10**right.scale
comment|// this * right = this.mag * right.mag / 10**(this.scale + right.scale)
comment|// so, we need to scale down (this.scale + right.scale - newScale)
name|short
name|currentTotalScale
init|=
call|(
name|short
call|)
argument_list|(
name|this
operator|.
name|scale
operator|+
name|right
operator|.
name|scale
argument_list|)
decl_stmt|;
name|short
name|scaleBack
init|=
call|(
name|short
call|)
argument_list|(
name|currentTotalScale
operator|-
name|newScale
argument_list|)
decl_stmt|;
if|if
condition|(
name|scaleBack
operator|>
literal|0
condition|)
block|{
comment|// we do the scaling down _during_ multiplication to avoid
comment|// unnecessary overflow.
comment|// note that even this could overflow if newScale is too small.
name|this
operator|.
name|unscaledValue
operator|.
name|multiplyScaleDownTenDestructive
argument_list|(
name|right
operator|.
name|unscaledValue
argument_list|,
name|scaleBack
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// in this case, we are actually scaling up.
comment|// we don't have to do complicated things because doing scaling-up
comment|// after
comment|// multiplication doesn't affect overflow (it doesn't happen or
comment|// happens anyways).
name|this
operator|.
name|unscaledValue
operator|.
name|multiplyDestructive
argument_list|(
name|right
operator|.
name|unscaledValue
argument_list|)
expr_stmt|;
name|this
operator|.
name|unscaledValue
operator|.
name|scaleUpTenDestructive
argument_list|(
operator|(
name|short
operator|)
operator|-
name|scaleBack
argument_list|)
expr_stmt|;
block|}
name|this
operator|.
name|scale
operator|=
name|newScale
expr_stmt|;
name|this
operator|.
name|signum
operator|=
call|(
name|byte
call|)
argument_list|(
name|this
operator|.
name|signum
operator|*
name|right
operator|.
name|signum
argument_list|)
expr_stmt|;
if|if
condition|(
name|this
operator|.
name|unscaledValue
operator|.
name|isZero
argument_list|()
condition|)
block|{
name|this
operator|.
name|signum
operator|=
literal|0
expr_stmt|;
comment|// because of scaling down, this could happen
block|}
name|this
operator|.
name|unscaledValue
operator|.
name|throwIfExceedsTenToThirtyEight
argument_list|()
expr_stmt|;
block|}
comment|/**    * Performs division and puts the result into the given object. Both operands    * are first scaled up/down to the specified scale, then this method performs    * the operation. This method is static and not destructive (except the result    * object).    *<p>    * Unchecked exceptions: ArithmeticException an invalid scale is specified or    * overflow.    *</p>    *    * @param left    *          left operand    * @param right    *          right operand    * @param quotient    *          result object to receive the calculation result    * @param scale    *          scale of the result. must be 0 or positive.    */
specifier|public
specifier|static
name|void
name|divide
parameter_list|(
name|Decimal128
name|left
parameter_list|,
name|Decimal128
name|right
parameter_list|,
name|Decimal128
name|quotient
parameter_list|,
name|short
name|scale
parameter_list|)
block|{
if|if
condition|(
name|quotient
operator|==
name|left
operator|||
name|quotient
operator|==
name|right
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"result object cannot be left or right operand"
argument_list|)
throw|;
block|}
name|quotient
operator|.
name|update
argument_list|(
name|left
argument_list|)
expr_stmt|;
name|quotient
operator|.
name|divideDestructive
argument_list|(
name|right
argument_list|,
name|scale
argument_list|)
expr_stmt|;
block|}
comment|/**    * As of 1/20/2014 this has a known bug in division. See    * TestDecimal128.testKnownPriorErrors(). Keeping this source    * code available since eventually it is better to fix this.    * The fix employed now is to replace this code with code that    * uses Java BigDecimal divide.    *    * Performs division, changing the scale of this object to the specified    * value.    *<p>    * Unchecked exceptions: ArithmeticException an invalid scale is specified or    * overflow.    *</p>    *    * @param right    *          right operand. this object is not modified.    * @param newScale    *          scale of the result. must be 0 or positive.    * @param remainder    *          object to receive remainder    */
specifier|public
name|void
name|divideDestructiveNativeDecimal128
parameter_list|(
name|Decimal128
name|right
parameter_list|,
name|short
name|newScale
parameter_list|,
name|Decimal128
name|remainder
parameter_list|)
block|{
if|if
condition|(
name|right
operator|.
name|signum
operator|==
literal|0
condition|)
block|{
name|SqlMathUtil
operator|.
name|throwZeroDivisionException
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|this
operator|.
name|signum
operator|==
literal|0
condition|)
block|{
name|this
operator|.
name|scale
operator|=
name|newScale
expr_stmt|;
name|remainder
operator|.
name|update
argument_list|(
name|this
argument_list|)
expr_stmt|;
return|return;
block|}
comment|// this = this.mag / 10**this.scale
comment|// right = right.mag / 10**right.scale
comment|// this / right = (this.mag / right.mag) / 10**(this.scale -
comment|// right.scale)
comment|// so, we need to scale down (this.scale - right.scale - newScale)
name|short
name|scaleBack
init|=
call|(
name|short
call|)
argument_list|(
name|this
operator|.
name|scale
operator|-
name|right
operator|.
name|scale
operator|-
name|newScale
argument_list|)
decl_stmt|;
if|if
condition|(
name|scaleBack
operator|>=
literal|0
condition|)
block|{
comment|// it's easier then because we simply do division and then scale
comment|// down.
name|this
operator|.
name|unscaledValue
operator|.
name|divideDestructive
argument_list|(
name|right
operator|.
name|unscaledValue
argument_list|,
name|remainder
operator|.
name|unscaledValue
argument_list|)
expr_stmt|;
name|this
operator|.
name|unscaledValue
operator|.
name|scaleDownTenDestructive
argument_list|(
name|scaleBack
argument_list|)
expr_stmt|;
name|remainder
operator|.
name|unscaledValue
operator|.
name|scaleDownTenDestructive
argument_list|(
name|scaleBack
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// in this case, we have to scale up _BEFORE_ division. otherwise we
comment|// might lose precision. this is costly, but inevitable.
name|this
operator|.
name|unscaledValue
operator|.
name|divideScaleUpTenDestructive
argument_list|(
name|right
operator|.
name|unscaledValue
argument_list|,
operator|(
name|short
operator|)
operator|-
name|scaleBack
argument_list|,
name|remainder
operator|.
name|unscaledValue
argument_list|)
expr_stmt|;
block|}
name|this
operator|.
name|scale
operator|=
name|newScale
expr_stmt|;
name|this
operator|.
name|signum
operator|=
call|(
name|byte
call|)
argument_list|(
name|this
operator|.
name|unscaledValue
operator|.
name|isZero
argument_list|()
condition|?
literal|0
else|:
operator|(
name|this
operator|.
name|signum
operator|*
name|right
operator|.
name|signum
operator|)
argument_list|)
expr_stmt|;
name|remainder
operator|.
name|scale
operator|=
name|scale
expr_stmt|;
name|remainder
operator|.
name|signum
operator|=
call|(
name|byte
call|)
argument_list|(
name|remainder
operator|.
name|unscaledValue
operator|.
name|isZero
argument_list|()
condition|?
literal|0
else|:
literal|1
argument_list|)
expr_stmt|;
comment|// remainder
comment|// is
comment|// always
comment|// positive
name|this
operator|.
name|unscaledValue
operator|.
name|throwIfExceedsTenToThirtyEight
argument_list|()
expr_stmt|;
block|}
comment|/**    * Divide the target object by right, and scale the result to newScale.    *    * This uses HiveDecimal to get a correct answer with the same rounding    * behavior as HiveDecimal, but it is expensive.    *    * In the future, a native implementation could be faster.    */
specifier|public
name|void
name|divideDestructive
parameter_list|(
name|Decimal128
name|right
parameter_list|,
name|short
name|newScale
parameter_list|)
block|{
name|HiveDecimal
name|rightHD
init|=
name|HiveDecimal
operator|.
name|create
argument_list|(
name|right
operator|.
name|toBigDecimal
argument_list|()
argument_list|)
decl_stmt|;
name|HiveDecimal
name|thisHD
init|=
name|HiveDecimal
operator|.
name|create
argument_list|(
name|this
operator|.
name|toBigDecimal
argument_list|()
argument_list|)
decl_stmt|;
name|HiveDecimal
name|result
init|=
name|thisHD
operator|.
name|divide
argument_list|(
name|rightHD
argument_list|)
decl_stmt|;
name|this
operator|.
name|update
argument_list|(
name|result
operator|.
name|bigDecimalValue
argument_list|()
operator|.
name|toPlainString
argument_list|()
argument_list|,
name|newScale
argument_list|)
expr_stmt|;
name|this
operator|.
name|unscaledValue
operator|.
name|throwIfExceedsTenToThirtyEight
argument_list|()
expr_stmt|;
block|}
comment|/**    * Makes this {@code Decimal128} a positive number. Unlike    * java.math.BigDecimal, this method is destructive.    */
specifier|public
name|void
name|absDestructive
parameter_list|()
block|{
if|if
condition|(
name|this
operator|.
name|signum
operator|<
literal|0
condition|)
block|{
name|this
operator|.
name|signum
operator|=
literal|1
expr_stmt|;
block|}
block|}
comment|/**    * Reverses the sign of this {@code Decimal128}. Unlike java.math.BigDecimal,    * this method is destructive.    */
specifier|public
name|void
name|negateDestructive
parameter_list|()
block|{
name|this
operator|.
name|signum
operator|=
call|(
name|byte
call|)
argument_list|(
operator|-
name|this
operator|.
name|signum
argument_list|)
expr_stmt|;
block|}
comment|/**    * Calculate the square root of this value in double precision.    *<p>    * Note that this does NOT perform the calculation in infinite accuracy.    * Although this sounds weird, it's at least how SQLServer does it. The SQL    * below demonstrates that SQLServer actually converts it into FLOAT (Java's    * double).    *</p>    *<code>    * create table bb (col1 DECIMAL(38,36), col2 DECIMAL (38,36));    * insert into bb values(1.00435134913958923485982394892384,1.00345982739817298323423423);    * select sqrt(col1) as cola,sqrt(col2) colb into asdasd from bb;    * sp_columns asdasd;    *</code>    *<p>    * This SQL tells that the result is in FLOAT data type. One justification is    * that, because DECIMAL is at most 38 digits, double precision is enough for    * sqrt/pow.    *</p>    *<p>    * This method does not modify this object.    *</p>    *<p>    * This method throws exception if this value is negative rather than    * returning NaN. This is the SQL semantics (at least in SQLServer).    *</p>    *    * @return square root of this value    */
specifier|public
name|double
name|sqrtAsDouble
parameter_list|()
block|{
if|if
condition|(
name|this
operator|.
name|signum
operator|==
literal|0
condition|)
block|{
return|return
literal|0
return|;
block|}
elseif|else
if|if
condition|(
name|this
operator|.
name|signum
operator|<
literal|0
condition|)
block|{
throw|throw
operator|new
name|ArithmeticException
argument_list|(
literal|"sqrt will not be a real number"
argument_list|)
throw|;
block|}
name|double
name|val
init|=
name|doubleValue
argument_list|()
decl_stmt|;
return|return
name|Math
operator|.
name|sqrt
argument_list|(
name|val
argument_list|)
return|;
block|}
comment|/**    *<p>    * Calculate the power of this value in double precision. Note that this does    * NOT perform the calculation in infinite accuracy. Although this sounds    * weird, it's at least how SQLServer does it. The SQL below demonstrates that    * SQLServer actually converts it into FLOAT (Java's double).    *</p>    *<code>    * create table bb (col1 DECIMAL(38,36), col2 DECIMAL (38,36));    * insert into bb values(1.00435134913958923485982394892384,1.00345982739817298323423423);    * select power(col1, col2);    *</code>    *<p>    * This SQL returns '1.004366436877081000000000000000000000', which is merely    * a power calculated in double precision (    * "java.lang.Math.pow(1.00435134913958923485982394892384d, 1.00345982739817298323423423d)"    * returns 1.0043664368770813), and then scaled into DECIMAL. The same thing    * happens even when "n" is a positive integer. One justification is that,    * because DECIMAL is at most 38 digits, double precision is enough for    * sqrt/pow.    *</p>    *<p>    * This method does not modify this object.    *</p>    *<p>    * This method throws exception if the calculated value is Infinite. This is    * the SQL semantics (at least in SQLServer).    *</p>    *    * @param n    *          power to raise this object. Unlike    *          {@link java.math.BigDecimal#pow(int)}, this can receive a    *          fractional number. Instead, this method calculates the value in    *          double precision.    * @return power of this value    */
specifier|public
name|double
name|powAsDouble
parameter_list|(
name|double
name|n
parameter_list|)
block|{
if|if
condition|(
name|this
operator|.
name|signum
operator|==
literal|0
condition|)
block|{
return|return
literal|0
return|;
block|}
name|double
name|val
init|=
name|doubleValue
argument_list|()
decl_stmt|;
name|double
name|result
init|=
name|Math
operator|.
name|pow
argument_list|(
name|val
argument_list|,
name|n
argument_list|)
decl_stmt|;
if|if
condition|(
name|Double
operator|.
name|isInfinite
argument_list|(
name|result
argument_list|)
operator|||
name|Double
operator|.
name|isNaN
argument_list|(
name|result
argument_list|)
condition|)
block|{
name|SqlMathUtil
operator|.
name|throwOverflowException
argument_list|()
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
comment|/**    * Returns the signum of this {@code Decimal128}.    *    * @return -1, 0, or 1 as the value of this {@code Decimal128} is negative,    *         zero, or positive.    */
specifier|public
name|byte
name|getSignum
parameter_list|()
block|{
return|return
name|signum
return|;
block|}
comment|/**    * Returns the<i>scale</i> of this {@code Decimal128}. The scale is the    * positive number of digits to the right of the decimal point.    *    * @return the scale of this {@code Decimal128}.    */
specifier|public
name|short
name|getScale
parameter_list|()
block|{
return|return
name|scale
return|;
block|}
comment|/**    * Returns unscaled value of this {@code Decimal128}. Be careful because    * changes on the returned object will affect the object. It is not    * recommended to modify the object this method returns.    *    * @return the unscaled value of this {@code Decimal128}.    */
specifier|public
name|UnsignedInt128
name|getUnscaledValue
parameter_list|()
block|{
return|return
name|unscaledValue
return|;
block|}
comment|// Comparison Operations
comment|/**    * Compares this {@code Decimal128} with the specified {@code Decimal128}. Two    * {@code Decimal128} objects that are equal in value but have a different    * scale (like 2.0 and 2.00) are considered equal by this method. This method    * is provided in preference to individual methods for each of the six boolean    * comparison operators ({@literal<}, ==, {@literal>}, {@literal>=}, !=,    * {@literal<=}). The suggested idiom for performing these comparisons is:    * {@code (x.compareTo(y)}&lt;<i>op</i>&gt; {@code 0)}, where    *&lt;<i>op</i>&gt; is one of the six comparison operators.    *    * @param val    *          {@code Decimal128} to which this {@code Decimal128} is to be    *          compared.    * @return a negative integer, zero, or a positive integer as this    *         {@code Decimal128} is numerically less than, equal to, or greater    *         than {@code val}.    */
annotation|@
name|Override
specifier|public
name|int
name|compareTo
parameter_list|(
name|Decimal128
name|val
parameter_list|)
block|{
if|if
condition|(
name|val
operator|==
name|this
condition|)
block|{
return|return
literal|0
return|;
block|}
if|if
condition|(
name|this
operator|.
name|signum
operator|!=
name|val
operator|.
name|signum
condition|)
block|{
return|return
name|this
operator|.
name|signum
operator|-
name|val
operator|.
name|signum
return|;
block|}
name|int
name|cmp
decl_stmt|;
if|if
condition|(
name|this
operator|.
name|scale
operator|>=
name|val
operator|.
name|scale
condition|)
block|{
name|cmp
operator|=
name|this
operator|.
name|unscaledValue
operator|.
name|compareToScaleTen
argument_list|(
name|val
operator|.
name|unscaledValue
argument_list|,
call|(
name|short
call|)
argument_list|(
name|this
operator|.
name|scale
operator|-
name|val
operator|.
name|scale
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|cmp
operator|=
name|val
operator|.
name|unscaledValue
operator|.
name|compareToScaleTen
argument_list|(
name|this
operator|.
name|unscaledValue
argument_list|,
call|(
name|short
call|)
argument_list|(
name|val
operator|.
name|scale
operator|-
name|this
operator|.
name|scale
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|cmp
operator|*
name|this
operator|.
name|signum
return|;
block|}
comment|/**    * Compares this {@code Decimal128} with the specified {@code Object} for    * equality. Unlike {@link #compareTo(Decimal128) compareTo}, this method    * considers two {@code Decimal128} objects equal only if they are equal in    * value and scale (thus 2.0 is not equal to 2.00 when compared by this    * method). This somewhat confusing behavior is, however, same as    * java.math.BigDecimal.    *    * @param x    *          {@code Object} to which this {@code Decimal128} is to be compared.    * @return {@code true} if and only if the specified {@code Object} is a    *         {@code Decimal128} whose value and scale are equal to this    *         {@code Decimal128}'s.    * @see #compareTo(java.math.Decimal128)    * @see #hashCode    */
annotation|@
name|Override
specifier|public
name|boolean
name|equals
parameter_list|(
name|Object
name|x
parameter_list|)
block|{
if|if
condition|(
name|x
operator|==
name|this
condition|)
block|{
return|return
literal|true
return|;
block|}
if|if
condition|(
operator|!
operator|(
name|x
operator|instanceof
name|Decimal128
operator|)
condition|)
block|{
return|return
literal|false
return|;
block|}
name|Decimal128
name|xDec
init|=
operator|(
name|Decimal128
operator|)
name|x
decl_stmt|;
if|if
condition|(
name|scale
operator|!=
name|xDec
operator|.
name|scale
condition|)
block|{
return|return
literal|false
return|;
block|}
if|if
condition|(
name|signum
operator|!=
name|xDec
operator|.
name|signum
condition|)
block|{
return|return
literal|false
return|;
block|}
return|return
name|unscaledValue
operator|.
name|equals
argument_list|(
name|xDec
operator|.
name|unscaledValue
argument_list|)
return|;
block|}
comment|/**    * Returns the hash code for this {@code Decimal128}. Note that two    * {@code Decimal128} objects that are numerically equal but differ in scale    * (like 2.0 and 2.00) will generally<i>not</i> have the same hash code. This    * somewhat confusing behavior is, however, same as java.math.BigDecimal.    *    * @return hash code for this {@code Decimal128}.    * @see #equals(Object)    */
annotation|@
name|Override
specifier|public
name|int
name|hashCode
parameter_list|()
block|{
if|if
condition|(
name|signum
operator|==
literal|0
condition|)
block|{
return|return
literal|0
return|;
block|}
return|return
name|signum
operator|*
operator|(
name|scale
operator|*
literal|31
operator|+
name|unscaledValue
operator|.
name|hashCode
argument_list|()
operator|)
return|;
block|}
comment|/**    * Converts this {@code Decimal128} to a {@code long}. This conversion is    * analogous to the<i>narrowing primitive conversion</i> from {@code double}    * to {@code short} as defined in section 5.1.3 of<cite>The Java&trade;    * Language Specification</cite>: any fractional part of this    * {@code Decimal128} will be discarded, and if the resulting "    * {@code UnsignedInt128}" is too big to fit in a {@code long}, only the    * low-order 64 bits are returned. Note that this conversion can lose    * information about the overall magnitude and precision of this    * {@code Decimal128} value.    *    * @return this {@code Decimal128} converted to a {@code long}.    */
annotation|@
name|Override
specifier|public
name|long
name|longValue
parameter_list|()
block|{
if|if
condition|(
name|signum
operator|==
literal|0
condition|)
block|{
return|return
literal|0L
return|;
block|}
name|long
name|ret
decl_stmt|;
name|UnsignedInt128
name|tmp
decl_stmt|;
if|if
condition|(
name|scale
operator|==
literal|0
condition|)
block|{
name|ret
operator|=
name|this
operator|.
name|unscaledValue
operator|.
name|getV1
argument_list|()
expr_stmt|;
name|ret
operator|<<=
literal|32L
expr_stmt|;
name|ret
operator||=
name|SqlMathUtil
operator|.
name|LONG_MASK
operator|&
name|this
operator|.
name|unscaledValue
operator|.
name|getV0
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|tmp
operator|=
operator|new
name|UnsignedInt128
argument_list|(
name|this
operator|.
name|unscaledValue
argument_list|)
expr_stmt|;
name|tmp
operator|.
name|scaleDownTenDestructive
argument_list|(
name|scale
argument_list|)
expr_stmt|;
name|ret
operator|=
name|tmp
operator|.
name|getV1
argument_list|()
expr_stmt|;
name|ret
operator|<<=
literal|32L
expr_stmt|;
name|ret
operator||=
name|SqlMathUtil
operator|.
name|LONG_MASK
operator|&
name|tmp
operator|.
name|getV0
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|signum
operator|>=
literal|0
condition|)
block|{
return|return
name|ret
return|;
block|}
else|else
block|{
return|return
operator|-
name|ret
return|;
block|}
block|}
comment|/**    * Converts this {@code Decimal128} to an {@code int}. This conversion is    * analogous to the<i>narrowing primitive conversion</i> from {@code double}    * to {@code short} as defined in section 5.1.3 of<cite>The Java&trade;    * Language Specification</cite>: any fractional part of this    * {@code Decimal128} will be discarded, and if the resulting "    * {@code UnsignedInt128}" is too big to fit in an {@code int}, only the    * low-order 32 bits are returned. Note that this conversion can lose    * information about the overall magnitude and precision of this    * {@code Decimal128} value.    *    * @return this {@code Decimal128} converted to an {@code int}.    */
annotation|@
name|Override
specifier|public
name|int
name|intValue
parameter_list|()
block|{
if|if
condition|(
name|signum
operator|==
literal|0
condition|)
block|{
return|return
literal|0
return|;
block|}
name|int
name|ret
decl_stmt|;
if|if
condition|(
name|scale
operator|==
literal|0
condition|)
block|{
name|ret
operator|=
name|this
operator|.
name|unscaledValue
operator|.
name|getV0
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|UnsignedInt128
name|tmp
init|=
operator|new
name|UnsignedInt128
argument_list|(
name|this
operator|.
name|unscaledValue
argument_list|)
decl_stmt|;
name|tmp
operator|.
name|scaleDownTenDestructive
argument_list|(
name|scale
argument_list|)
expr_stmt|;
name|ret
operator|=
name|tmp
operator|.
name|getV0
argument_list|()
expr_stmt|;
block|}
return|return
name|SqlMathUtil
operator|.
name|setSignBitInt
argument_list|(
name|ret
argument_list|,
name|signum
operator|>
literal|0
argument_list|)
return|;
block|}
comment|/**    * Converts this {@code Decimal128} to a {@code float}. This conversion is    * similar to the<i>narrowing primitive conversion</i> from {@code double} to    * {@code float} as defined in section 5.1.3 of<cite>The Java&trade; Language    * Specification</cite>: if this {@code Decimal128} has too great a magnitude    * to represent as a {@code float}, it will be converted to    * {@link Float#NEGATIVE_INFINITY} or {@link Float#POSITIVE_INFINITY} as    * appropriate. Note that even when the return value is finite, this    * conversion can lose information about the precision of the    * {@code Decimal128} value.    *    * @return this {@code Decimal128} converted to a {@code float}.    */
annotation|@
name|Override
specifier|public
name|float
name|floatValue
parameter_list|()
block|{
comment|// if this function is frequently used, we need to optimize this.
return|return
name|Float
operator|.
name|parseFloat
argument_list|(
name|toFormalString
argument_list|()
argument_list|)
return|;
block|}
comment|/**    * Converts this {@code Decimal128} to a {@code double}. This conversion is    * similar to the<i>narrowing primitive conversion</i> from {@code double} to    * {@code float} as defined in section 5.1.3 of<cite>The Java&trade; Language    * Specification</cite>: if this {@code Decimal128} has too great a magnitude    * represent as a {@code double}, it will be converted to    * {@link Double#NEGATIVE_INFINITY} or {@link Double#POSITIVE_INFINITY} as    * appropriate. Note that even when the return value is finite, this    * conversion can lose information about the precision of the    * {@code Decimal128} value.    *    * @return this {@code Decimal128} converted to a {@code double}.    */
annotation|@
name|Override
specifier|public
name|double
name|doubleValue
parameter_list|()
block|{
comment|// if this function is frequently used, we need to optimize this.
return|return
name|Double
operator|.
name|parseDouble
argument_list|(
name|toFormalString
argument_list|()
argument_list|)
return|;
block|}
comment|/**    * Converts this object to {@link BigDecimal}. This method is not supposed to    * be used in a performance-sensitive place.    *    * @return {@link BigDecimal} object equivalent to this object.    */
specifier|public
name|BigDecimal
name|toBigDecimal
parameter_list|()
block|{
comment|// if this function is frequently used, we need to optimize this.
return|return
operator|new
name|BigDecimal
argument_list|(
name|toFormalString
argument_list|()
argument_list|)
return|;
block|}
comment|/**    * Throws an exception if the value of this object exceeds the maximum value    * for the given precision. Remember that underflow is not an error, but    * overflow is an immediate error.    *    * @param precision    *          maximum precision    */
specifier|public
name|void
name|checkPrecisionOverflow
parameter_list|(
name|int
name|precision
parameter_list|)
block|{
if|if
condition|(
name|precision
operator|<=
literal|0
operator|||
name|precision
operator|>
literal|38
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Invalid precision "
operator|+
name|precision
argument_list|)
throw|;
block|}
if|if
condition|(
name|this
operator|.
name|unscaledValue
operator|.
name|compareTo
argument_list|(
name|SqlMathUtil
operator|.
name|POWER_TENS_INT128
index|[
name|precision
index|]
argument_list|)
operator|>=
literal|0
condition|)
block|{
name|SqlMathUtil
operator|.
name|throwOverflowException
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Throws an exception if the given scale is invalid for this object.    *    * @param scale    *          scale value    */
specifier|private
specifier|static
name|void
name|checkScaleRange
parameter_list|(
name|short
name|scale
parameter_list|)
block|{
if|if
condition|(
name|scale
operator|<
name|MIN_SCALE
condition|)
block|{
throw|throw
operator|new
name|ArithmeticException
argument_list|(
literal|"Decimal128 does not support negative scaling"
argument_list|)
throw|;
block|}
if|if
condition|(
name|scale
operator|>
name|MAX_SCALE
condition|)
block|{
throw|throw
operator|new
name|ArithmeticException
argument_list|(
literal|"Beyond possible Decimal128 scaling"
argument_list|)
throw|;
block|}
block|}
comment|/**    * Returns the formal string representation of this value. Unlike the debug    * string returned by {@link #toString()}, this method returns a string that    * can be used to re-construct this object. Remember, toString() is only for    * debugging.    *    * @return string representation of this value    */
specifier|public
name|String
name|toFormalString
parameter_list|()
block|{
if|if
condition|(
name|this
operator|.
name|signum
operator|==
literal|0
condition|)
block|{
return|return
literal|"0"
return|;
block|}
name|StringBuilder
name|buf
init|=
operator|new
name|StringBuilder
argument_list|(
literal|50
argument_list|)
decl_stmt|;
if|if
condition|(
name|this
operator|.
name|signum
operator|<
literal|0
condition|)
block|{
name|buf
operator|.
name|append
argument_list|(
literal|'-'
argument_list|)
expr_stmt|;
block|}
name|String
name|unscaled
init|=
name|this
operator|.
name|unscaledValue
operator|.
name|toFormalString
argument_list|()
decl_stmt|;
if|if
condition|(
name|unscaled
operator|.
name|length
argument_list|()
operator|>
name|this
operator|.
name|scale
condition|)
block|{
comment|// write out integer part first
comment|// then write out fractional part
name|buf
operator|.
name|append
argument_list|(
name|unscaled
argument_list|,
literal|0
argument_list|,
name|unscaled
operator|.
name|length
argument_list|()
operator|-
name|this
operator|.
name|scale
argument_list|)
expr_stmt|;
if|if
condition|(
name|this
operator|.
name|scale
operator|>
literal|0
condition|)
block|{
name|buf
operator|.
name|append
argument_list|(
literal|'.'
argument_list|)
expr_stmt|;
name|buf
operator|.
name|append
argument_list|(
name|unscaled
argument_list|,
name|unscaled
operator|.
name|length
argument_list|()
operator|-
name|this
operator|.
name|scale
argument_list|,
name|unscaled
operator|.
name|length
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// no integer part
name|buf
operator|.
name|append
argument_list|(
literal|'0'
argument_list|)
expr_stmt|;
if|if
condition|(
name|this
operator|.
name|scale
operator|>
literal|0
condition|)
block|{
comment|// fractional part has, starting with zeros
name|buf
operator|.
name|append
argument_list|(
literal|'.'
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
name|unscaled
operator|.
name|length
argument_list|()
init|;
name|i
operator|<
name|this
operator|.
name|scale
condition|;
operator|++
name|i
control|)
block|{
name|buf
operator|.
name|append
argument_list|(
literal|'0'
argument_list|)
expr_stmt|;
block|}
name|buf
operator|.
name|append
argument_list|(
name|unscaled
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|new
name|String
argument_list|(
name|buf
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
name|toFormalString
argument_list|()
operator|+
literal|"(Decimal128: scale="
operator|+
name|scale
operator|+
literal|", signum="
operator|+
name|signum
operator|+
literal|", BigDecimal.toString="
operator|+
name|toBigDecimal
argument_list|()
operator|.
name|toString
argument_list|()
operator|+
literal|", unscaledValue=["
operator|+
name|unscaledValue
operator|.
name|toString
argument_list|()
operator|+
literal|"])"
return|;
block|}
comment|/**    * Vectorized execution uses the smallest possible positive non-zero    * value to prevent possible later zero-divide exceptions. Set the field    * to this value (1 in the internal unsigned 128 bit int).    */
specifier|public
name|void
name|setNullDataValue
parameter_list|()
block|{
name|unscaledValue
operator|.
name|update
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/**    * Update the value to a decimal value with the decimal point equal to    * val but with the decimal point inserted scale    * digits from the right. Behavior is undefined if scale is> 38 or< 0.    *    * For example, updateFixedPoint(123456789L, (short) 3) changes the target    * to the value 123456.789 with scale 3.    */
specifier|public
name|void
name|updateFixedPoint
parameter_list|(
name|long
name|val
parameter_list|,
name|short
name|scale
parameter_list|)
block|{
name|this
operator|.
name|scale
operator|=
name|scale
expr_stmt|;
if|if
condition|(
name|val
operator|<
literal|0L
condition|)
block|{
name|this
operator|.
name|unscaledValue
operator|.
name|update
argument_list|(
operator|-
name|val
argument_list|)
expr_stmt|;
name|this
operator|.
name|signum
operator|=
operator|-
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|val
operator|==
literal|0L
condition|)
block|{
name|zeroClear
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|this
operator|.
name|unscaledValue
operator|.
name|update
argument_list|(
name|val
argument_list|)
expr_stmt|;
name|this
operator|.
name|signum
operator|=
literal|1
expr_stmt|;
block|}
block|}
block|}
end_class

end_unit

