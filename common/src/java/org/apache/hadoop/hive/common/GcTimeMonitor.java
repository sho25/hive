begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|common
package|;
end_package

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Lists
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_comment
comment|/**  * Based on org.apache.hadoop.util.GcTimeMonitor. However, this class detects  * GC pauses using the same method as JvmPauseMonitor (by comparing the actual  * and expected thread sleep time) rather than by reading information from  * GarbageCollectionMXBean. The latter may sometimes report time spent in  * concurrent GC operations rather than GC pauses. This may result in inaccurate  * results when trying to estimate the time that the JVM is "frozen" due to GC.  *  * This class monitors the percentage of time the JVM is paused in GC within  * the specified observation window, say 1 minute. The user can provide a  * hook which will be called whenever this percentage exceeds the specified  * threshold.  */
end_comment

begin_class
specifier|public
class|class
name|GcTimeMonitor
extends|extends
name|Thread
block|{
specifier|private
specifier|final
name|long
name|maxGcTimePercentage
decl_stmt|;
specifier|private
specifier|final
name|long
name|observationWindowNanos
decl_stmt|,
name|sleepIntervalMs
decl_stmt|;
specifier|private
specifier|final
name|GcTimeAlertHandler
name|alertHandler
decl_stmt|;
comment|// Ring buffers containing GC timings and timestamps when timings were taken
specifier|private
specifier|final
name|TsAndData
index|[]
name|gcDataBuf
decl_stmt|;
specifier|private
name|int
name|bufSize
decl_stmt|,
name|startIdx
decl_stmt|,
name|endIdx
decl_stmt|;
specifier|private
name|long
name|startTimeNanos
decl_stmt|;
specifier|private
specifier|final
name|GcData
name|curData
init|=
operator|new
name|GcData
argument_list|()
decl_stmt|;
specifier|private
specifier|volatile
name|boolean
name|shouldRun
init|=
literal|true
decl_stmt|;
comment|/**    * Create an instance of GCTimeMonitor. Once it's started, it will stay alive    * and monitor GC time percentage until shutdown() is called. If you don't    * put a limit on the number of GCTimeMonitor instances that you create, and    * alertHandler != null, you should necessarily call shutdown() once the given    * instance is not needed. Otherwise, you may create a memory leak, because    * each running GCTimeMonitor will keep its alertHandler object in memory,    * which in turn may reference and keep in memory many more other objects.    *    * @param observationWindowMs the interval over which the percentage    *   of GC time should be calculated. A practical value would be somewhere    *   between 30 sec and several minutes.    * @param sleepIntervalMs how frequently this thread should wake up to check    *   GC timings. This is also a frequency with which alertHandler will be    *   invoked if GC time percentage exceeds the specified limit. A practical    *   value would likely be 500..1000 ms.    * @param maxGcTimePercentage A GC time percentage limit (0..100) within    *   observationWindowMs. Once this is exceeded, alertHandler will be    *   invoked every sleepIntervalMs milliseconds until GC time percentage    *   falls below this limit.    * @param alertHandler a single method in this interface is invoked when GC    *   time percentage exceeds the specified limit.    */
specifier|public
name|GcTimeMonitor
parameter_list|(
name|long
name|observationWindowMs
parameter_list|,
name|long
name|sleepIntervalMs
parameter_list|,
name|int
name|maxGcTimePercentage
parameter_list|,
name|GcTimeAlertHandler
name|alertHandler
parameter_list|)
block|{
name|Preconditions
operator|.
name|checkArgument
argument_list|(
name|observationWindowMs
operator|>
literal|0
argument_list|)
expr_stmt|;
name|Preconditions
operator|.
name|checkArgument
argument_list|(
name|sleepIntervalMs
operator|>
literal|0
operator|&&
name|sleepIntervalMs
operator|<
name|observationWindowMs
argument_list|)
expr_stmt|;
name|Preconditions
operator|.
name|checkArgument
argument_list|(
name|maxGcTimePercentage
operator|>=
literal|0
operator|&&
name|maxGcTimePercentage
operator|<=
literal|100
argument_list|)
expr_stmt|;
name|this
operator|.
name|observationWindowNanos
operator|=
name|observationWindowMs
operator|*
literal|1000000
expr_stmt|;
name|this
operator|.
name|sleepIntervalMs
operator|=
name|sleepIntervalMs
expr_stmt|;
name|this
operator|.
name|maxGcTimePercentage
operator|=
name|maxGcTimePercentage
expr_stmt|;
name|this
operator|.
name|alertHandler
operator|=
name|alertHandler
expr_stmt|;
name|bufSize
operator|=
call|(
name|int
call|)
argument_list|(
name|observationWindowMs
operator|/
name|sleepIntervalMs
operator|+
literal|2
argument_list|)
expr_stmt|;
comment|// Prevent the user from accidentally creating an abnormally big buffer,
comment|// which will result in slow calculations and likely inaccuracy.
name|Preconditions
operator|.
name|checkArgument
argument_list|(
name|bufSize
operator|<=
literal|128
operator|*
literal|1024
argument_list|)
expr_stmt|;
name|gcDataBuf
operator|=
operator|new
name|TsAndData
index|[
name|bufSize
index|]
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|bufSize
condition|;
name|i
operator|++
control|)
block|{
name|gcDataBuf
index|[
name|i
index|]
operator|=
operator|new
name|TsAndData
argument_list|()
expr_stmt|;
block|}
name|this
operator|.
name|setDaemon
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|this
operator|.
name|setName
argument_list|(
literal|"GcTimeMonitor obsWindow = "
operator|+
name|observationWindowMs
operator|+
literal|", sleepInterval = "
operator|+
name|sleepIntervalMs
operator|+
literal|", maxGcTimePerc = "
operator|+
name|maxGcTimePercentage
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|run
parameter_list|()
block|{
name|startTimeNanos
operator|=
name|System
operator|.
name|nanoTime
argument_list|()
expr_stmt|;
name|gcDataBuf
index|[
name|startIdx
index|]
operator|.
name|setValues
argument_list|(
name|startTimeNanos
argument_list|,
literal|0
argument_list|)
expr_stmt|;
while|while
condition|(
name|shouldRun
condition|)
block|{
name|long
name|intervalStartTsNanos
init|=
name|System
operator|.
name|nanoTime
argument_list|()
decl_stmt|;
try|try
block|{
name|Thread
operator|.
name|sleep
argument_list|(
name|sleepIntervalMs
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|ie
parameter_list|)
block|{
return|return;
block|}
name|long
name|intervalEndTsNanos
init|=
name|System
operator|.
name|nanoTime
argument_list|()
decl_stmt|;
name|calculateGCTimePercentageWithinObservedInterval
argument_list|(
name|intervalStartTsNanos
argument_list|,
name|intervalEndTsNanos
argument_list|)
expr_stmt|;
if|if
condition|(
name|alertHandler
operator|!=
literal|null
operator|&&
name|curData
operator|.
name|gcTimePercentage
operator|>
name|maxGcTimePercentage
condition|)
block|{
name|alertHandler
operator|.
name|alert
argument_list|(
name|curData
operator|.
name|clone
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
specifier|public
name|void
name|shutdown
parameter_list|()
block|{
name|shouldRun
operator|=
literal|false
expr_stmt|;
block|}
comment|/** Returns a copy of the most recent data measured by this monitor. */
specifier|public
name|GcData
name|getLatestGcData
parameter_list|()
block|{
return|return
name|curData
operator|.
name|clone
argument_list|()
return|;
block|}
specifier|private
name|void
name|calculateGCTimePercentageWithinObservedInterval
parameter_list|(
name|long
name|intervalStartTsNanos
parameter_list|,
name|long
name|intervalEndTsNanos
parameter_list|)
block|{
name|long
name|gcTimeWithinSleepIntervalNanos
init|=
name|intervalEndTsNanos
operator|-
name|intervalStartTsNanos
operator|-
name|sleepIntervalMs
operator|*
literal|1000000
decl_stmt|;
name|long
name|totalGcTimeNanos
init|=
name|curData
operator|.
name|totalGcTimeNanos
operator|+
name|gcTimeWithinSleepIntervalNanos
decl_stmt|;
name|long
name|gcMonitorRunTimeNanos
init|=
name|intervalEndTsNanos
operator|-
name|startTimeNanos
decl_stmt|;
name|endIdx
operator|=
operator|(
name|endIdx
operator|+
literal|1
operator|)
operator|%
name|bufSize
expr_stmt|;
name|gcDataBuf
index|[
name|endIdx
index|]
operator|.
name|setValues
argument_list|(
name|intervalEndTsNanos
argument_list|,
name|gcTimeWithinSleepIntervalNanos
argument_list|)
expr_stmt|;
comment|// Update the observation window so that it covers the last observationWindowNanos
comment|// period. For that, move startIdx forward until we reach the first buffer entry with
comment|// timestamp within the observation window.
name|long
name|startObsWindowTsNanos
init|=
name|intervalEndTsNanos
operator|-
name|observationWindowNanos
decl_stmt|;
while|while
condition|(
name|gcDataBuf
index|[
name|startIdx
index|]
operator|.
name|tsNanos
operator|<
name|startObsWindowTsNanos
operator|&&
name|startIdx
operator|!=
name|endIdx
condition|)
block|{
name|startIdx
operator|=
operator|(
name|startIdx
operator|+
literal|1
operator|)
operator|%
name|bufSize
expr_stmt|;
block|}
comment|// Calculate total GC time within observationWindowMs.
comment|// We should be careful about GC time that passed before the first timestamp
comment|// in our observation window.
name|long
name|gcTimeWithinObservationWindowNanos
init|=
name|Math
operator|.
name|min
argument_list|(
name|gcDataBuf
index|[
name|startIdx
index|]
operator|.
name|gcPauseNanos
argument_list|,
name|gcDataBuf
index|[
name|startIdx
index|]
operator|.
name|tsNanos
operator|-
name|startObsWindowTsNanos
argument_list|)
decl_stmt|;
if|if
condition|(
name|startIdx
operator|!=
name|endIdx
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
operator|(
name|startIdx
operator|+
literal|1
operator|)
operator|%
name|bufSize
init|;
name|i
operator|!=
name|endIdx
condition|;
name|i
operator|=
operator|(
name|i
operator|+
literal|1
operator|)
operator|%
name|bufSize
control|)
block|{
name|gcTimeWithinObservationWindowNanos
operator|+=
name|gcDataBuf
index|[
name|i
index|]
operator|.
name|gcPauseNanos
expr_stmt|;
block|}
block|}
name|curData
operator|.
name|update
argument_list|(
name|gcMonitorRunTimeNanos
argument_list|,
name|totalGcTimeNanos
argument_list|,
call|(
name|int
call|)
argument_list|(
name|gcTimeWithinObservationWindowNanos
operator|*
literal|100
operator|/
name|Math
operator|.
name|min
argument_list|(
name|observationWindowNanos
argument_list|,
name|gcMonitorRunTimeNanos
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**    * The user can provide an instance of a class implementing this interface    * when initializing a GcTimeMonitor to receive alerts when GC time    * percentage exceeds the specified threshold.    */
specifier|public
interface|interface
name|GcTimeAlertHandler
block|{
name|void
name|alert
parameter_list|(
name|GcData
name|gcData
parameter_list|)
function_decl|;
block|}
comment|/** Encapsulates data about GC pauses measured at the specific timestamp. */
specifier|public
specifier|static
class|class
name|GcData
implements|implements
name|Cloneable
block|{
specifier|private
name|long
name|gcMonitorRunTimeNanos
decl_stmt|,
name|totalGcTimeNanos
decl_stmt|;
specifier|private
name|int
name|gcTimePercentage
decl_stmt|;
comment|/** Returns the time since the start of the associated GcTimeMonitor. */
specifier|public
name|long
name|getGcMonitorRunTimeMs
parameter_list|()
block|{
return|return
name|gcMonitorRunTimeNanos
operator|/
literal|1000000
return|;
block|}
comment|/** Returns accumulated GC time since this JVM started. */
specifier|public
name|long
name|getAccumulatedGcTimeMs
parameter_list|()
block|{
return|return
name|totalGcTimeNanos
operator|/
literal|1000000
return|;
block|}
comment|/**      * Returns the percentage (0..100) of time that the JVM spent in GC pauses      * within the observation window of the associated GcTimeMonitor.      */
specifier|public
name|int
name|getGcTimePercentage
parameter_list|()
block|{
return|return
name|gcTimePercentage
return|;
block|}
specifier|private
specifier|synchronized
name|void
name|update
parameter_list|(
name|long
name|gcMonitorRunTimeNanos
parameter_list|,
name|long
name|totalGcTimeNanos
parameter_list|,
name|int
name|inGcTimePercentage
parameter_list|)
block|{
name|this
operator|.
name|gcMonitorRunTimeNanos
operator|=
name|gcMonitorRunTimeNanos
expr_stmt|;
name|this
operator|.
name|totalGcTimeNanos
operator|=
name|totalGcTimeNanos
expr_stmt|;
name|this
operator|.
name|gcTimePercentage
operator|=
name|inGcTimePercentage
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
specifier|synchronized
name|GcData
name|clone
parameter_list|()
block|{
try|try
block|{
return|return
operator|(
name|GcData
operator|)
name|super
operator|.
name|clone
argument_list|()
return|;
block|}
catch|catch
parameter_list|(
name|CloneNotSupportedException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
block|}
specifier|private
specifier|static
class|class
name|TsAndData
block|{
specifier|private
name|long
name|tsNanos
decl_stmt|;
comment|// Timestamp when this measurement was taken
specifier|private
name|long
name|gcPauseNanos
decl_stmt|;
comment|// Total GC pause time within the interval between ts
comment|// and the timestamp of the previous measurement.
name|void
name|setValues
parameter_list|(
name|long
name|tsNanos
parameter_list|,
name|long
name|gcPauseNanos
parameter_list|)
block|{
name|this
operator|.
name|tsNanos
operator|=
name|tsNanos
expr_stmt|;
name|this
operator|.
name|gcPauseNanos
operator|=
name|gcPauseNanos
expr_stmt|;
block|}
block|}
comment|/**    * Simple 'main' to facilitate manual testing of the pause monitor.    *    * This main function just leaks memory. Running this class will quickly    * result in a "GC hell" and subsequent alerts from the GcTimeMonitor.    */
specifier|public
specifier|static
name|void
name|main
parameter_list|(
name|String
index|[]
name|args
parameter_list|)
throws|throws
name|Exception
block|{
operator|new
name|GcTimeMonitor
argument_list|(
literal|20
operator|*
literal|1000
argument_list|,
literal|500
argument_list|,
literal|20
argument_list|,
operator|new
name|GcTimeMonitor
operator|.
name|GcTimeAlertHandler
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|void
name|alert
parameter_list|(
name|GcData
name|gcData
parameter_list|)
block|{
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"GcTimeMonitor alert. Current GC time percentage = "
operator|+
name|gcData
operator|.
name|getGcTimePercentage
argument_list|()
operator|+
literal|", total run time = "
operator|+
operator|(
name|gcData
operator|.
name|getGcMonitorRunTimeMs
argument_list|()
operator|/
literal|1000
operator|)
operator|+
literal|" sec"
operator|+
literal|", total GC time = "
operator|+
operator|(
name|gcData
operator|.
name|getAccumulatedGcTimeMs
argument_list|()
operator|/
literal|1000
operator|)
operator|+
literal|" sec"
argument_list|)
expr_stmt|;
block|}
block|}
argument_list|)
operator|.
name|start
argument_list|()
expr_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|list
init|=
name|Lists
operator|.
name|newArrayList
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
condition|;
name|i
operator|++
control|)
block|{
name|list
operator|.
name|add
argument_list|(
literal|"This is a long string to fill memory quickly "
operator|+
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|%
literal|100000
operator|==
literal|0
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"Added "
operator|+
name|i
operator|+
literal|" strings"
argument_list|)
expr_stmt|;
name|Thread
operator|.
name|sleep
argument_list|(
literal|100
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_class

end_unit

