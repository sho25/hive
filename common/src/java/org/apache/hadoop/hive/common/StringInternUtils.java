begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed under the Apache License, Version 2.0 (the "License");  * you may not use this file except in compliance with the License.  * You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|common
package|;
end_package

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|Path
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|reflect
operator|.
name|Field
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|URI
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ListIterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_comment
comment|/**  * Collection of utilities for string interning, common across Hive.  * We use the standard String.intern() call, that performs very well  * (no problems with PermGen overflowing, etc.) starting from JDK 7.  */
end_comment

begin_class
specifier|public
class|class
name|StringInternUtils
block|{
comment|// When a URI instance is initialized, it creates a bunch of private String
comment|// fields, never bothering about their possible duplication. It would be
comment|// best if we could tell URI constructor to intern these strings right away.
comment|// Without this option, we can only use reflection to "fix" strings in these
comment|// fields after a URI has been created.
specifier|private
specifier|static
name|Class
name|uriClass
init|=
name|URI
operator|.
name|class
decl_stmt|;
specifier|private
specifier|static
name|Field
name|stringField
decl_stmt|,
name|schemeField
decl_stmt|,
name|authorityField
decl_stmt|,
name|hostField
decl_stmt|,
name|pathField
decl_stmt|,
name|fragmentField
decl_stmt|,
name|schemeSpecificPartField
decl_stmt|;
static|static
block|{
try|try
block|{
name|stringField
operator|=
name|uriClass
operator|.
name|getDeclaredField
argument_list|(
literal|"string"
argument_list|)
expr_stmt|;
name|schemeField
operator|=
name|uriClass
operator|.
name|getDeclaredField
argument_list|(
literal|"scheme"
argument_list|)
expr_stmt|;
name|authorityField
operator|=
name|uriClass
operator|.
name|getDeclaredField
argument_list|(
literal|"authority"
argument_list|)
expr_stmt|;
name|hostField
operator|=
name|uriClass
operator|.
name|getDeclaredField
argument_list|(
literal|"host"
argument_list|)
expr_stmt|;
name|pathField
operator|=
name|uriClass
operator|.
name|getDeclaredField
argument_list|(
literal|"path"
argument_list|)
expr_stmt|;
name|fragmentField
operator|=
name|uriClass
operator|.
name|getDeclaredField
argument_list|(
literal|"fragment"
argument_list|)
expr_stmt|;
name|schemeSpecificPartField
operator|=
name|uriClass
operator|.
name|getDeclaredField
argument_list|(
literal|"schemeSpecificPart"
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|NoSuchFieldException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
name|e
argument_list|)
throw|;
block|}
comment|// Note that the calls below will throw an exception if a Java SecurityManager
comment|// is installed and configured to forbid invoking setAccessible(). In practice
comment|// this is not a problem in Hive.
name|stringField
operator|.
name|setAccessible
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|schemeField
operator|.
name|setAccessible
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|authorityField
operator|.
name|setAccessible
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|hostField
operator|.
name|setAccessible
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|pathField
operator|.
name|setAccessible
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|fragmentField
operator|.
name|setAccessible
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|schemeSpecificPartField
operator|.
name|setAccessible
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
specifier|public
specifier|static
name|URI
name|internStringsInUri
parameter_list|(
name|URI
name|uri
parameter_list|)
block|{
if|if
condition|(
name|uri
operator|==
literal|null
condition|)
return|return
literal|null
return|;
try|try
block|{
name|String
name|string
init|=
operator|(
name|String
operator|)
name|stringField
operator|.
name|get
argument_list|(
name|uri
argument_list|)
decl_stmt|;
if|if
condition|(
name|string
operator|!=
literal|null
condition|)
name|stringField
operator|.
name|set
argument_list|(
name|uri
argument_list|,
name|string
operator|.
name|intern
argument_list|()
argument_list|)
expr_stmt|;
name|String
name|scheme
init|=
operator|(
name|String
operator|)
name|schemeField
operator|.
name|get
argument_list|(
name|uri
argument_list|)
decl_stmt|;
if|if
condition|(
name|scheme
operator|!=
literal|null
condition|)
name|schemeField
operator|.
name|set
argument_list|(
name|uri
argument_list|,
name|scheme
operator|.
name|intern
argument_list|()
argument_list|)
expr_stmt|;
name|String
name|authority
init|=
operator|(
name|String
operator|)
name|authorityField
operator|.
name|get
argument_list|(
name|uri
argument_list|)
decl_stmt|;
if|if
condition|(
name|authority
operator|!=
literal|null
condition|)
name|authorityField
operator|.
name|set
argument_list|(
name|uri
argument_list|,
name|authority
operator|.
name|intern
argument_list|()
argument_list|)
expr_stmt|;
name|String
name|host
init|=
operator|(
name|String
operator|)
name|hostField
operator|.
name|get
argument_list|(
name|uri
argument_list|)
decl_stmt|;
if|if
condition|(
name|host
operator|!=
literal|null
condition|)
name|hostField
operator|.
name|set
argument_list|(
name|uri
argument_list|,
name|host
operator|.
name|intern
argument_list|()
argument_list|)
expr_stmt|;
name|String
name|path
init|=
operator|(
name|String
operator|)
name|pathField
operator|.
name|get
argument_list|(
name|uri
argument_list|)
decl_stmt|;
if|if
condition|(
name|path
operator|!=
literal|null
condition|)
name|pathField
operator|.
name|set
argument_list|(
name|uri
argument_list|,
name|path
operator|.
name|intern
argument_list|()
argument_list|)
expr_stmt|;
name|String
name|fragment
init|=
operator|(
name|String
operator|)
name|fragmentField
operator|.
name|get
argument_list|(
name|uri
argument_list|)
decl_stmt|;
if|if
condition|(
name|fragment
operator|!=
literal|null
condition|)
name|fragmentField
operator|.
name|set
argument_list|(
name|uri
argument_list|,
name|fragment
operator|.
name|intern
argument_list|()
argument_list|)
expr_stmt|;
name|String
name|schemeSpecificPart
init|=
operator|(
name|String
operator|)
name|schemeSpecificPartField
operator|.
name|get
argument_list|(
name|uri
argument_list|)
decl_stmt|;
if|if
condition|(
name|schemeSpecificPart
operator|!=
literal|null
condition|)
name|schemeSpecificPartField
operator|.
name|set
argument_list|(
name|uri
argument_list|,
name|schemeSpecificPart
operator|.
name|intern
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
name|e
argument_list|)
throw|;
block|}
return|return
name|uri
return|;
block|}
specifier|public
specifier|static
name|Path
name|internUriStringsInPath
parameter_list|(
name|Path
name|path
parameter_list|)
block|{
if|if
condition|(
name|path
operator|!=
literal|null
condition|)
name|internStringsInUri
argument_list|(
name|path
operator|.
name|toUri
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|path
return|;
block|}
specifier|public
specifier|static
name|Path
index|[]
name|internUriStringsInPathArray
parameter_list|(
name|Path
index|[]
name|paths
parameter_list|)
block|{
if|if
condition|(
name|paths
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|Path
name|path
range|:
name|paths
control|)
block|{
name|internUriStringsInPath
argument_list|(
name|path
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|paths
return|;
block|}
comment|/**    * This method interns all the strings in the given list in place. That is,    * it iterates over the list, replaces each element with the interned copy    * and eventually returns the same list.    *    * Note that the provided List implementation should return an iterator    * (via list.listIterator()) method, and that iterator should implement    * the set(Object) method. That's what all List implementations in the JDK    * provide. However, if some custom List implementation doesn't have this    * functionality, this method will return without interning its elements.    */
specifier|public
specifier|static
name|List
argument_list|<
name|String
argument_list|>
name|internStringsInList
parameter_list|(
name|List
argument_list|<
name|String
argument_list|>
name|list
parameter_list|)
block|{
if|if
condition|(
name|list
operator|!=
literal|null
condition|)
block|{
try|try
block|{
name|ListIterator
argument_list|<
name|String
argument_list|>
name|it
init|=
name|list
operator|.
name|listIterator
argument_list|()
decl_stmt|;
while|while
condition|(
name|it
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|it
operator|.
name|set
argument_list|(
name|it
operator|.
name|next
argument_list|()
operator|.
name|intern
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|UnsupportedOperationException
name|e
parameter_list|)
block|{ }
comment|// set() not implemented - ignore
block|}
return|return
name|list
return|;
block|}
comment|/** Interns all the strings in the given array in place, returning the same array */
specifier|public
specifier|static
name|String
index|[]
name|internStringsInArray
parameter_list|(
name|String
index|[]
name|strings
parameter_list|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|strings
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|strings
index|[
name|i
index|]
operator|!=
literal|null
condition|)
block|{
name|strings
index|[
name|i
index|]
operator|=
name|strings
index|[
name|i
index|]
operator|.
name|intern
argument_list|()
expr_stmt|;
block|}
block|}
return|return
name|strings
return|;
block|}
specifier|public
specifier|static
parameter_list|<
name|K
parameter_list|>
name|Map
argument_list|<
name|K
argument_list|,
name|String
argument_list|>
name|internValuesInMap
parameter_list|(
name|Map
argument_list|<
name|K
argument_list|,
name|String
argument_list|>
name|map
parameter_list|)
block|{
if|if
condition|(
name|map
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|K
name|key
range|:
name|map
operator|.
name|keySet
argument_list|()
control|)
block|{
name|String
name|value
init|=
name|map
operator|.
name|get
argument_list|(
name|key
argument_list|)
decl_stmt|;
if|if
condition|(
name|value
operator|!=
literal|null
condition|)
block|{
name|map
operator|.
name|put
argument_list|(
name|key
argument_list|,
name|value
operator|.
name|intern
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
name|map
return|;
block|}
specifier|public
specifier|static
name|String
name|internIfNotNull
parameter_list|(
name|String
name|s
parameter_list|)
block|{
if|if
condition|(
name|s
operator|!=
literal|null
condition|)
name|s
operator|=
name|s
operator|.
name|intern
argument_list|()
expr_stmt|;
return|return
name|s
return|;
block|}
block|}
end_class

end_unit

