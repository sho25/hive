begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Copyright (c) Microsoft Corporation  *  * Licensed under the Apache License, Version 2.0 (the "License");  * you may not use this file except in compliance with the License.  * You may obtain a copy of the License at  *  * http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|common
operator|.
name|type
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|Serializable
import|;
end_import

begin_import
import|import
name|java
operator|.
name|math
operator|.
name|BigInteger
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|ByteBuffer
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|IntBuffer
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hive
operator|.
name|common
operator|.
name|util
operator|.
name|Decimal128FastBuffer
import|;
end_import

begin_comment
comment|/**  * This code was originally written for Microsoft PolyBase.  *  * Represents an unsigned 128-bit integer. This is the basis for  * {@link Decimal128} and {@link SignedInt128}. This object is much faster and  * more compact than BigInteger, but has many limitations below.  *<ul>  *<li>Always consumes 128 bits (4 int32) even if the values is, say, 3.</li>  *<li>Cannot handle values larger than 10**38.</li>  *<li>Does not support some of arithmetic operations that is not required in  * SQL (e.g., exact POWER/SQRT).</li>  *</ul>  */
end_comment

begin_class
specifier|public
specifier|final
class|class
name|UnsignedInt128
implements|implements
name|Comparable
argument_list|<
name|UnsignedInt128
argument_list|>
implements|,
name|Serializable
block|{
comment|/** Number of ints to store this object. */
specifier|public
specifier|static
specifier|final
name|int
name|INT_COUNT
init|=
literal|4
decl_stmt|;
comment|/** Number of bytes to store this object. */
specifier|public
specifier|static
specifier|final
name|int
name|BYTE_SIZE
init|=
literal|4
operator|*
name|INT_COUNT
decl_stmt|;
comment|/** Can hold up to 10^38. */
specifier|public
specifier|static
specifier|final
name|int
name|MAX_DIGITS
init|=
literal|38
decl_stmt|;
comment|/** Maximum value that can be represented in this class. */
specifier|public
specifier|static
specifier|final
name|UnsignedInt128
name|MAX_VALUE
init|=
operator|new
name|UnsignedInt128
argument_list|(
literal|0xFFFFFFFF
argument_list|,
literal|0xFFFFFFFF
argument_list|,
literal|0xFFFFFFFF
argument_list|,
literal|0xFFFFFFFF
argument_list|)
decl_stmt|;
comment|/** Minimum value that can be represented in this class. */
specifier|public
specifier|static
specifier|final
name|UnsignedInt128
name|MIN_VALUE
init|=
operator|new
name|UnsignedInt128
argument_list|(
literal|0
argument_list|)
decl_stmt|;
comment|/** A special value representing 10**38. */
specifier|public
specifier|static
specifier|final
name|UnsignedInt128
name|TEN_TO_THIRTYEIGHT
init|=
operator|new
name|UnsignedInt128
argument_list|(
literal|0
argument_list|,
literal|0x98a2240
argument_list|,
literal|0x5a86c47a
argument_list|,
literal|0x4b3b4ca8
argument_list|)
decl_stmt|;
comment|/**    * Int32 elements as little-endian (v[0] is least significant) unsigned    * integers.    */
specifier|private
name|int
index|[]
name|v
init|=
operator|new
name|int
index|[
name|INT_COUNT
index|]
decl_stmt|;
comment|/**    * Number of leading non-zero elements in {@link #v}. For example, if the    * value of this object is 123 (v0=123, v1=v2=v3=0), then 1. 0 to 4. 0 means    * that this object represents zero.    *    * @see #updateCount()    */
specifier|private
name|byte
name|count
decl_stmt|;
comment|/**    * Determines the number of ints to store one value.    *    * @param precision    *          precision (0-38)    * @return the number of ints to store one value    */
specifier|public
specifier|static
name|int
name|getIntsPerElement
parameter_list|(
name|int
name|precision
parameter_list|)
block|{
assert|assert
operator|(
name|precision
operator|>=
literal|0
operator|&&
name|precision
operator|<=
literal|38
operator|)
assert|;
if|if
condition|(
name|precision
operator|<=
literal|9
condition|)
block|{
return|return
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|precision
operator|<=
literal|19
condition|)
block|{
return|return
literal|2
return|;
block|}
elseif|else
if|if
condition|(
name|precision
operator|<=
literal|28
condition|)
block|{
return|return
literal|3
return|;
block|}
return|return
literal|4
return|;
block|}
comment|/** Creates an instance that represents zero. */
specifier|public
name|UnsignedInt128
parameter_list|()
block|{
name|zeroClear
argument_list|()
expr_stmt|;
block|}
comment|/**    * Copy constructor.    *    * @param o    *          The instance to copy from    */
specifier|public
name|UnsignedInt128
parameter_list|(
name|UnsignedInt128
name|o
parameter_list|)
block|{
name|update
argument_list|(
name|o
argument_list|)
expr_stmt|;
block|}
comment|/**    * Creates an instance that has the given values.    *    * @param v0    *          v0    * @param v1    *          v1    * @param v2    *          v2    * @param v3    *          v3    */
specifier|public
name|UnsignedInt128
parameter_list|(
name|int
name|v0
parameter_list|,
name|int
name|v1
parameter_list|,
name|int
name|v2
parameter_list|,
name|int
name|v3
parameter_list|)
block|{
name|update
argument_list|(
name|v0
argument_list|,
name|v1
argument_list|,
name|v2
argument_list|,
name|v3
argument_list|)
expr_stmt|;
block|}
comment|/**    * Constructs from the given long value.    *    * @param v    *          long value    */
specifier|public
name|UnsignedInt128
parameter_list|(
name|long
name|v
parameter_list|)
block|{
name|update
argument_list|(
name|v
argument_list|)
expr_stmt|;
block|}
comment|/**    * Constructs from the given string.    *    * @param str    *          string    */
specifier|public
name|UnsignedInt128
parameter_list|(
name|String
name|str
parameter_list|)
block|{
name|update
argument_list|(
name|str
argument_list|)
expr_stmt|;
block|}
comment|/**    * Constructs from the given string with given offset and length.    *    * @param str    *          string    * @param offset    *          offset    * @param length    *          length    */
specifier|public
name|UnsignedInt128
parameter_list|(
name|char
index|[]
name|str
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|length
parameter_list|)
block|{
name|update
argument_list|(
name|str
argument_list|,
name|offset
argument_list|,
name|length
argument_list|)
expr_stmt|;
block|}
comment|/**    * Constructs from the given BigInteger    *    * @param bigInt    *          java BigInteger    */
specifier|public
name|UnsignedInt128
parameter_list|(
name|BigInteger
name|bigInt
parameter_list|)
block|{
name|update
argument_list|(
name|bigInt
argument_list|)
expr_stmt|;
block|}
comment|/**    * Updates the value of this object from the given {@link BigInteger}.    * Only positive BigIntegers are expected and behavior is undefined for    * negative BigIntegers.    *    * @param bigInt    *          java BigInteger    */
specifier|public
name|void
name|update
parameter_list|(
name|BigInteger
name|bigInt
parameter_list|)
block|{
name|int
name|v0
init|=
name|bigInt
operator|.
name|intValue
argument_list|()
decl_stmt|;
name|int
name|v1
init|=
name|bigInt
operator|.
name|shiftRight
argument_list|(
literal|32
argument_list|)
operator|.
name|intValue
argument_list|()
decl_stmt|;
name|int
name|v2
init|=
name|bigInt
operator|.
name|shiftRight
argument_list|(
literal|64
argument_list|)
operator|.
name|intValue
argument_list|()
decl_stmt|;
name|int
name|v3
init|=
name|bigInt
operator|.
name|shiftRight
argument_list|(
literal|96
argument_list|)
operator|.
name|intValue
argument_list|()
decl_stmt|;
name|update
argument_list|(
name|v0
argument_list|,
name|v1
argument_list|,
name|v2
argument_list|,
name|v3
argument_list|)
expr_stmt|;
block|}
comment|/** @return v[0] */
specifier|public
name|int
name|getV0
parameter_list|()
block|{
return|return
name|v
index|[
literal|0
index|]
return|;
block|}
comment|/** @return v[1] */
specifier|public
name|int
name|getV1
parameter_list|()
block|{
return|return
name|v
index|[
literal|1
index|]
return|;
block|}
comment|/** @return v[2] */
specifier|public
name|int
name|getV2
parameter_list|()
block|{
return|return
name|v
index|[
literal|2
index|]
return|;
block|}
comment|/** @return v[3] */
specifier|public
name|int
name|getV3
parameter_list|()
block|{
return|return
name|v
index|[
literal|3
index|]
return|;
block|}
comment|/**    * Setter for v0.    *    * @param val    *          value to set    */
specifier|public
name|void
name|setV0
parameter_list|(
name|int
name|val
parameter_list|)
block|{
name|v
index|[
literal|0
index|]
operator|=
name|val
expr_stmt|;
name|updateCount
argument_list|()
expr_stmt|;
block|}
comment|/**    * Setter for v1.    *    * @param val    *          value to set    */
specifier|public
name|void
name|setV1
parameter_list|(
name|int
name|val
parameter_list|)
block|{
name|v
index|[
literal|1
index|]
operator|=
name|val
expr_stmt|;
name|updateCount
argument_list|()
expr_stmt|;
block|}
comment|/**    * Setter for v2.    *    * @param val    *          value to set    */
specifier|public
name|void
name|setV2
parameter_list|(
name|int
name|val
parameter_list|)
block|{
name|v
index|[
literal|2
index|]
operator|=
name|val
expr_stmt|;
name|updateCount
argument_list|()
expr_stmt|;
block|}
comment|/**    * Setter for v3.    *    * @param val    *          value to set    */
specifier|public
name|void
name|setV3
parameter_list|(
name|int
name|val
parameter_list|)
block|{
name|v
index|[
literal|3
index|]
operator|=
name|val
expr_stmt|;
name|updateCount
argument_list|()
expr_stmt|;
block|}
comment|/**    * Returns if we overflowed 10**38, but not 2**128. This code is equivalent to    * CSsNumeric::FGt10_38 in SQLServer (numeric.cpp). However, be aware that the    * elements are signed ints, not UI4 in SQLServer.    *    * @return whether this value is equal to or larger than 10**38    */
specifier|public
name|boolean
name|exceedsTenToThirtyEight
parameter_list|()
block|{
comment|// 10**38=
comment|// v[0]=0(0),v[1]=160047680(98a2240),v[2]=1518781562(5a86c47a),v[3]=1262177448(4b3b4ca8)
comment|// check most significant part first
if|if
condition|(
name|v
index|[
literal|3
index|]
operator|!=
literal|0x4b3b4ca8
condition|)
block|{
return|return
operator|(
name|v
index|[
literal|3
index|]
operator|<
literal|0
operator|||
name|v
index|[
literal|3
index|]
operator|>
literal|0x4b3b4ca8
operator|)
return|;
block|}
comment|// check second most significant part
if|if
condition|(
name|v
index|[
literal|2
index|]
operator|!=
literal|0x5a86c47a
condition|)
block|{
return|return
operator|(
name|v
index|[
literal|2
index|]
operator|<
literal|0
operator|||
name|v
index|[
literal|2
index|]
operator|>
literal|0x5a86c47a
operator|)
return|;
block|}
return|return
operator|(
name|v
index|[
literal|1
index|]
operator|<
literal|0
operator|||
name|v
index|[
literal|1
index|]
operator|>
literal|0x098a2240
operator|)
return|;
block|}
comment|/**    * Used to check overflows. This is NOT used in {@link UnsignedInt128} itself    * because this overflow semantics is Decimal's. (throws - but not a checked    * exception) ArithmeticException if this value is equal to or exceed 10**38.    */
specifier|public
name|void
name|throwIfExceedsTenToThirtyEight
parameter_list|()
block|{
if|if
condition|(
name|exceedsTenToThirtyEight
argument_list|()
condition|)
block|{
name|SqlMathUtil
operator|.
name|throwOverflowException
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Returns the value of this object as long, throwing error if the value    * exceeds long.    *    * @return the value this object represents    */
specifier|public
name|long
name|asLong
parameter_list|()
block|{
if|if
condition|(
name|this
operator|.
name|count
operator|>
literal|2
operator|||
name|v
index|[
literal|1
index|]
operator|<
literal|0
condition|)
block|{
name|SqlMathUtil
operator|.
name|throwOverflowException
argument_list|()
expr_stmt|;
block|}
return|return
operator|(
operator|(
operator|(
name|long
operator|)
name|v
index|[
literal|1
index|]
operator|)
operator|<<
literal|32L
operator|)
operator||
name|v
index|[
literal|0
index|]
return|;
block|}
comment|/** Make the value to zero. */
specifier|public
name|void
name|zeroClear
parameter_list|()
block|{
name|this
operator|.
name|v
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|this
operator|.
name|v
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|this
operator|.
name|v
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
name|this
operator|.
name|v
index|[
literal|3
index|]
operator|=
literal|0
expr_stmt|;
name|this
operator|.
name|count
operator|=
literal|0
expr_stmt|;
block|}
comment|/** @return whether the value is zero */
specifier|public
name|boolean
name|isZero
parameter_list|()
block|{
return|return
name|this
operator|.
name|count
operator|==
literal|0
return|;
block|}
comment|/** @return whether the value is one */
specifier|public
name|boolean
name|isOne
parameter_list|()
block|{
return|return
name|this
operator|.
name|v
index|[
literal|0
index|]
operator|==
literal|1
operator|&&
name|this
operator|.
name|count
operator|==
literal|1
return|;
block|}
comment|/** @return whether 32bits int is enough to represent this value */
specifier|public
name|boolean
name|fitsInt32
parameter_list|()
block|{
return|return
name|this
operator|.
name|count
operator|<=
literal|1
return|;
block|}
comment|/**    * Copy from the given object.    *    * @param o    *          The instance to copy from    */
specifier|public
name|void
name|update
parameter_list|(
name|UnsignedInt128
name|o
parameter_list|)
block|{
name|update
argument_list|(
name|o
operator|.
name|v
index|[
literal|0
index|]
argument_list|,
name|o
operator|.
name|v
index|[
literal|1
index|]
argument_list|,
name|o
operator|.
name|v
index|[
literal|2
index|]
argument_list|,
name|o
operator|.
name|v
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
block|}
comment|/**    * Updates the value of this object with the given long value.    *    * @param v    *          long value    */
specifier|public
name|void
name|update
parameter_list|(
name|long
name|v
parameter_list|)
block|{
assert|assert
operator|(
name|v
operator|>=
literal|0
operator|)
assert|;
name|update
argument_list|(
operator|(
name|int
operator|)
name|v
argument_list|,
call|(
name|int
call|)
argument_list|(
name|v
operator|>>
literal|32
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/**    * Updates the value of this object with the given values.    *    * @param v0    *          v0    * @param v1    *          v1    * @param v2    *          v2    * @param v3    *          v3    */
specifier|public
name|void
name|update
parameter_list|(
name|int
name|v0
parameter_list|,
name|int
name|v1
parameter_list|,
name|int
name|v2
parameter_list|,
name|int
name|v3
parameter_list|)
block|{
name|this
operator|.
name|v
index|[
literal|0
index|]
operator|=
name|v0
expr_stmt|;
name|this
operator|.
name|v
index|[
literal|1
index|]
operator|=
name|v1
expr_stmt|;
name|this
operator|.
name|v
index|[
literal|2
index|]
operator|=
name|v2
expr_stmt|;
name|this
operator|.
name|v
index|[
literal|3
index|]
operator|=
name|v3
expr_stmt|;
name|updateCount
argument_list|()
expr_stmt|;
block|}
comment|/**    * Updates the value of this object by reading from ByteBuffer, using the    * required number of ints for the given precision.    *    * @param buf    *          ByteBuffer to read values from    * @param precision    *          0 to 38. Decimal digits.    */
specifier|public
name|void
name|update
parameter_list|(
name|IntBuffer
name|buf
parameter_list|,
name|int
name|precision
parameter_list|)
block|{
switch|switch
condition|(
name|getIntsPerElement
argument_list|(
name|precision
argument_list|)
condition|)
block|{
case|case
literal|1
case|:
name|update32
argument_list|(
name|buf
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|update64
argument_list|(
name|buf
argument_list|)
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|update96
argument_list|(
name|buf
argument_list|)
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|update128
argument_list|(
name|buf
argument_list|)
expr_stmt|;
break|break;
default|default:
throw|throw
operator|new
name|RuntimeException
argument_list|()
throw|;
block|}
block|}
comment|/**    * Updates the value of this object by reading from ByteBuffer, receiving 128    * bits data (full ranges).    *    * @param buf    *          ByteBuffer to read values from    */
specifier|public
name|void
name|update128
parameter_list|(
name|IntBuffer
name|buf
parameter_list|)
block|{
name|buf
operator|.
name|get
argument_list|(
name|v
argument_list|,
literal|0
argument_list|,
name|INT_COUNT
argument_list|)
expr_stmt|;
name|updateCount
argument_list|()
expr_stmt|;
block|}
comment|/**    * Updates the value of this object by reading from ByteBuffer, receiving only    * 96 bits data.    *    * @param buf    *          ByteBuffer to read values from    */
specifier|public
name|void
name|update96
parameter_list|(
name|IntBuffer
name|buf
parameter_list|)
block|{
name|buf
operator|.
name|get
argument_list|(
name|v
argument_list|,
literal|0
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|v
index|[
literal|3
index|]
operator|=
literal|0
expr_stmt|;
name|updateCount
argument_list|()
expr_stmt|;
block|}
comment|/**    * Updates the value of this object by reading from ByteBuffer, receiving only    * 64 bits data.    *    * @param buf    *          ByteBuffer to read values from    */
specifier|public
name|void
name|update64
parameter_list|(
name|IntBuffer
name|buf
parameter_list|)
block|{
name|buf
operator|.
name|get
argument_list|(
name|v
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|v
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
name|v
index|[
literal|3
index|]
operator|=
literal|0
expr_stmt|;
name|updateCount
argument_list|()
expr_stmt|;
block|}
comment|/**    * Updates the value of this object by reading from ByteBuffer, receiving only    * 32 bits data.    *    * @param buf    *          ByteBuffer to read values from    */
specifier|public
name|void
name|update32
parameter_list|(
name|IntBuffer
name|buf
parameter_list|)
block|{
name|v
index|[
literal|0
index|]
operator|=
name|buf
operator|.
name|get
argument_list|()
expr_stmt|;
name|v
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|v
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
name|v
index|[
literal|3
index|]
operator|=
literal|0
expr_stmt|;
name|updateCount
argument_list|()
expr_stmt|;
block|}
comment|/**    * Updates the value of this object by reading from the given array, using the    * required number of ints for the given precision.    *    * @param array    *          array to read values from    * @param offset    *          offset of the long array    * @param precision    *          0 to 38. Decimal digits.    */
specifier|public
name|void
name|update
parameter_list|(
name|int
index|[]
name|array
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|precision
parameter_list|)
block|{
switch|switch
condition|(
name|getIntsPerElement
argument_list|(
name|precision
argument_list|)
condition|)
block|{
case|case
literal|1
case|:
name|update32
argument_list|(
name|array
argument_list|,
name|offset
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|update64
argument_list|(
name|array
argument_list|,
name|offset
argument_list|)
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|update96
argument_list|(
name|array
argument_list|,
name|offset
argument_list|)
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|update128
argument_list|(
name|array
argument_list|,
name|offset
argument_list|)
expr_stmt|;
break|break;
default|default:
throw|throw
operator|new
name|RuntimeException
argument_list|()
throw|;
block|}
block|}
comment|/**    * Updates the value of this object by reading from the given array, receiving    * 128 bits data (full ranges).    *    * @param array    *          array to read values from    * @param offset    *          offset of the long array    */
specifier|public
name|void
name|update128
parameter_list|(
name|int
index|[]
name|array
parameter_list|,
name|int
name|offset
parameter_list|)
block|{
name|System
operator|.
name|arraycopy
argument_list|(
name|array
argument_list|,
name|offset
argument_list|,
name|v
argument_list|,
literal|0
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|updateCount
argument_list|()
expr_stmt|;
block|}
comment|/**    * Updates the value of this object by reading from the given array, receiving    * only 96 bits data.    *    * @param array    *          array to read values from    * @param offset    *          offset of the long array    */
specifier|public
name|void
name|update96
parameter_list|(
name|int
index|[]
name|array
parameter_list|,
name|int
name|offset
parameter_list|)
block|{
name|System
operator|.
name|arraycopy
argument_list|(
name|array
argument_list|,
name|offset
argument_list|,
name|v
argument_list|,
literal|0
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|v
index|[
literal|3
index|]
operator|=
literal|0
expr_stmt|;
name|updateCount
argument_list|()
expr_stmt|;
block|}
comment|/**    * Updates the value of this object by reading from the given array, receiving    * only 64 bits data.    *    * @param array    *          array to read values from    * @param offset    *          offset of the long array    */
specifier|public
name|void
name|update64
parameter_list|(
name|int
index|[]
name|array
parameter_list|,
name|int
name|offset
parameter_list|)
block|{
name|System
operator|.
name|arraycopy
argument_list|(
name|array
argument_list|,
name|offset
argument_list|,
name|v
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|v
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
name|v
index|[
literal|3
index|]
operator|=
literal|0
expr_stmt|;
name|updateCount
argument_list|()
expr_stmt|;
block|}
comment|/**    * Updates the value of this object by reading from the given array, receiving    * only 32 bits data.    *    * @param array    *          array to read values from    * @param offset    *          offset of the long array    */
specifier|public
name|void
name|update32
parameter_list|(
name|int
index|[]
name|array
parameter_list|,
name|int
name|offset
parameter_list|)
block|{
name|v
index|[
literal|0
index|]
operator|=
name|array
index|[
name|offset
index|]
expr_stmt|;
name|v
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|v
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
name|v
index|[
literal|3
index|]
operator|=
literal|0
expr_stmt|;
name|updateCount
argument_list|()
expr_stmt|;
block|}
comment|/**    * Updates the value of this object with the given string.    *    * @param str    *          string    */
specifier|public
name|void
name|update
parameter_list|(
name|String
name|str
parameter_list|)
block|{
name|update
argument_list|(
name|str
operator|.
name|toCharArray
argument_list|()
argument_list|,
literal|0
argument_list|,
name|str
operator|.
name|length
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/**    * Updates the value of this object from the given string with given offset    * and length.    *    * @param str    *          string    * @param offset    *          offset    * @param length    *          length    */
specifier|public
name|void
name|update
parameter_list|(
name|char
index|[]
name|str
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|length
parameter_list|)
block|{
comment|// Skip leading zeros and compute number of digits in magnitude
specifier|final
name|int
name|end
init|=
name|offset
operator|+
name|length
decl_stmt|;
assert|assert
operator|(
name|end
operator|<=
name|str
operator|.
name|length
operator|)
assert|;
name|int
name|cursor
init|=
name|offset
decl_stmt|;
while|while
condition|(
name|cursor
operator|<
name|end
operator|&&
name|str
index|[
name|cursor
index|]
operator|==
literal|'0'
condition|)
block|{
operator|++
name|cursor
expr_stmt|;
block|}
if|if
condition|(
name|cursor
operator|==
name|end
condition|)
block|{
name|zeroClear
argument_list|()
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|end
operator|-
name|cursor
operator|>
name|MAX_DIGITS
condition|)
block|{
name|SqlMathUtil
operator|.
name|throwOverflowException
argument_list|()
expr_stmt|;
block|}
name|int
name|accumulated
init|=
literal|0
decl_stmt|;
name|int
name|accumulatedCount
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|cursor
operator|<
name|end
condition|)
block|{
if|if
condition|(
name|str
index|[
name|cursor
index|]
operator|<
literal|'0'
operator|||
name|str
index|[
name|cursor
index|]
operator|>
literal|'9'
condition|)
block|{
throw|throw
operator|new
name|NumberFormatException
argument_list|(
literal|"Invalid string:"
operator|+
operator|new
name|String
argument_list|(
name|str
argument_list|,
name|offset
argument_list|,
name|length
argument_list|)
argument_list|)
throw|;
block|}
if|if
condition|(
name|accumulatedCount
operator|==
literal|9
condition|)
block|{
name|scaleUpTenDestructive
argument_list|(
operator|(
name|short
operator|)
name|accumulatedCount
argument_list|)
expr_stmt|;
name|addDestructive
argument_list|(
name|accumulated
argument_list|)
expr_stmt|;
name|accumulated
operator|=
literal|0
expr_stmt|;
name|accumulatedCount
operator|=
literal|0
expr_stmt|;
block|}
name|int
name|digit
init|=
name|str
index|[
name|cursor
index|]
operator|-
literal|'0'
decl_stmt|;
name|accumulated
operator|=
name|accumulated
operator|*
literal|10
operator|+
name|digit
expr_stmt|;
operator|++
name|accumulatedCount
expr_stmt|;
operator|++
name|cursor
expr_stmt|;
block|}
if|if
condition|(
name|accumulatedCount
operator|>
literal|0
condition|)
block|{
name|scaleUpTenDestructive
argument_list|(
operator|(
name|short
operator|)
name|accumulatedCount
argument_list|)
expr_stmt|;
name|addDestructive
argument_list|(
name|accumulated
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Serialize this object to the given ByteBuffer, putting the required number    * of ints for the given precision.    *    * @param buf    *          ByteBuffer to write values to    * @param precision    *          0 to 38. Decimal digits.    */
specifier|public
name|void
name|serializeTo
parameter_list|(
name|IntBuffer
name|buf
parameter_list|,
name|int
name|precision
parameter_list|)
block|{
name|buf
operator|.
name|put
argument_list|(
name|v
argument_list|,
literal|0
argument_list|,
name|getIntsPerElement
argument_list|(
name|precision
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**    * Serialize this object to the given ByteBuffer, putting 128 bits data (full    * ranges).    *    * @param buf    *          ByteBuffer to write values to    */
specifier|public
name|void
name|serializeTo128
parameter_list|(
name|IntBuffer
name|buf
parameter_list|)
block|{
name|buf
operator|.
name|put
argument_list|(
name|v
argument_list|,
literal|0
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
comment|/**    * Serialize this object to the given ByteBuffer, putting only 96 bits data.    *    * @param buf    *          ByteBuffer to write values to    */
specifier|public
name|void
name|serializeTo96
parameter_list|(
name|IntBuffer
name|buf
parameter_list|)
block|{
assert|assert
operator|(
name|v
index|[
literal|3
index|]
operator|==
literal|0
operator|)
assert|;
name|buf
operator|.
name|put
argument_list|(
name|v
argument_list|,
literal|0
argument_list|,
literal|3
argument_list|)
expr_stmt|;
block|}
comment|/**    * Serialize this object to the given ByteBuffer, putting only 64 bits data.    *    * @param buf    *          ByteBuffer to write values to    */
specifier|public
name|void
name|serializeTo64
parameter_list|(
name|IntBuffer
name|buf
parameter_list|)
block|{
assert|assert
operator|(
name|v
index|[
literal|2
index|]
operator|==
literal|0
operator|)
assert|;
assert|assert
operator|(
name|v
index|[
literal|3
index|]
operator|==
literal|0
operator|)
assert|;
name|buf
operator|.
name|put
argument_list|(
name|v
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
comment|/**    * Serialize this object to the given ByteBuffer, putting only 32 bits data.    *    * @param buf    *          ByteBuffer to write values to    */
specifier|public
name|void
name|serializeTo32
parameter_list|(
name|IntBuffer
name|buf
parameter_list|)
block|{
assert|assert
operator|(
name|v
index|[
literal|1
index|]
operator|==
literal|0
operator|)
assert|;
assert|assert
operator|(
name|v
index|[
literal|2
index|]
operator|==
literal|0
operator|)
assert|;
assert|assert
operator|(
name|v
index|[
literal|3
index|]
operator|==
literal|0
operator|)
assert|;
name|buf
operator|.
name|put
argument_list|(
name|v
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
comment|/**    * Serialize this object to the given array, putting the required number of    * ints for the given precision.    *    * @param array    *          array to write values to    * @param offset    *          offset of the int array    * @param precision    *          0 to 38. Decimal digits.    */
specifier|public
name|void
name|serializeTo
parameter_list|(
name|int
index|[]
name|array
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|precision
parameter_list|)
block|{
name|System
operator|.
name|arraycopy
argument_list|(
name|v
argument_list|,
literal|0
argument_list|,
name|array
argument_list|,
name|offset
argument_list|,
name|getIntsPerElement
argument_list|(
name|precision
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**    * Serialize this object to the given array, putting 128 bits data (full    * ranges).    *    * @param array    *          array to write values to    * @param offset    *          offset of the int array    */
specifier|public
name|void
name|serializeTo128
parameter_list|(
name|int
index|[]
name|array
parameter_list|,
name|int
name|offset
parameter_list|)
block|{
name|System
operator|.
name|arraycopy
argument_list|(
name|v
argument_list|,
literal|0
argument_list|,
name|array
argument_list|,
name|offset
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
comment|/**    * Serialize this object to the given array, putting only 96 bits data.    *    * @param array    *          array to write values to    * @param offset    *          offset of the int array    */
specifier|public
name|void
name|serializeTo96
parameter_list|(
name|int
index|[]
name|array
parameter_list|,
name|int
name|offset
parameter_list|)
block|{
assert|assert
operator|(
name|v
index|[
literal|3
index|]
operator|==
literal|0
operator|)
assert|;
name|System
operator|.
name|arraycopy
argument_list|(
name|v
argument_list|,
literal|0
argument_list|,
name|array
argument_list|,
name|offset
argument_list|,
literal|3
argument_list|)
expr_stmt|;
block|}
comment|/**    * Serialize this object to the given array, putting only 64 bits data.    *    * @param array    *          array to write values to    * @param offset    *          offset of the int array    */
specifier|public
name|void
name|serializeTo64
parameter_list|(
name|int
index|[]
name|array
parameter_list|,
name|int
name|offset
parameter_list|)
block|{
assert|assert
operator|(
name|v
index|[
literal|2
index|]
operator|==
literal|0
operator|)
assert|;
assert|assert
operator|(
name|v
index|[
literal|3
index|]
operator|==
literal|0
operator|)
assert|;
name|System
operator|.
name|arraycopy
argument_list|(
name|v
argument_list|,
literal|0
argument_list|,
name|array
argument_list|,
name|offset
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
comment|/**    * Serialize this object to the given array, putting only 32 bits data.    *    * @param array    *          array to write values to    * @param offset    *          offset of the int array    */
specifier|public
name|void
name|serializeTo32
parameter_list|(
name|int
index|[]
name|array
parameter_list|,
name|int
name|offset
parameter_list|)
block|{
assert|assert
operator|(
name|v
index|[
literal|1
index|]
operator|==
literal|0
operator|)
assert|;
assert|assert
operator|(
name|v
index|[
literal|2
index|]
operator|==
literal|0
operator|)
assert|;
assert|assert
operator|(
name|v
index|[
literal|3
index|]
operator|==
literal|0
operator|)
assert|;
name|array
index|[
literal|0
index|]
operator|=
name|v
index|[
literal|0
index|]
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|int
name|compareTo
parameter_list|(
name|UnsignedInt128
name|o
parameter_list|)
block|{
return|return
name|compareTo
argument_list|(
name|o
operator|.
name|v
argument_list|)
return|;
block|}
comment|/**    * @see #compareTo(UnsignedInt128)    * @param o    *          the object to be compared.    * @return a negative integer, zero, or a positive integer as this object is    *         less than, equal to, or greater than the specified object.    */
specifier|public
name|int
name|compareTo
parameter_list|(
name|int
index|[]
name|o
parameter_list|)
block|{
return|return
name|compareTo
argument_list|(
name|o
index|[
literal|0
index|]
argument_list|,
name|o
index|[
literal|1
index|]
argument_list|,
name|o
index|[
literal|2
index|]
argument_list|,
name|o
index|[
literal|3
index|]
argument_list|)
return|;
block|}
comment|/**    * @see #compareTo(UnsignedInt128)    * @param o0    *          o0    * @param o1    *          o1    * @param o2    *          o2    * @param o3    *          o3    * @return a negative integer, zero, or a positive integer as this object is    *         less than, equal to, or greater than the specified object.    */
specifier|public
name|int
name|compareTo
parameter_list|(
name|int
name|o0
parameter_list|,
name|int
name|o1
parameter_list|,
name|int
name|o2
parameter_list|,
name|int
name|o3
parameter_list|)
block|{
if|if
condition|(
name|v
index|[
literal|3
index|]
operator|!=
name|o3
condition|)
block|{
return|return
name|SqlMathUtil
operator|.
name|compareUnsignedInt
argument_list|(
name|v
index|[
literal|3
index|]
argument_list|,
name|o3
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|v
index|[
literal|2
index|]
operator|!=
name|o2
condition|)
block|{
return|return
name|SqlMathUtil
operator|.
name|compareUnsignedInt
argument_list|(
name|v
index|[
literal|2
index|]
argument_list|,
name|o2
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|v
index|[
literal|1
index|]
operator|!=
name|o1
condition|)
block|{
return|return
name|SqlMathUtil
operator|.
name|compareUnsignedInt
argument_list|(
name|v
index|[
literal|1
index|]
argument_list|,
name|o1
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|SqlMathUtil
operator|.
name|compareUnsignedInt
argument_list|(
name|v
index|[
literal|0
index|]
argument_list|,
name|o0
argument_list|)
return|;
block|}
block|}
comment|/**    * Compares with the given object after scaling up/down it for 10**scaleUp.    * This method is not destructive. Used from {@link Decimal128}.    *    * @param o    *          the object to compare with    * @param tenScale    *          power of 10 to scale up (if positive) or down (if negative) the    *          given object.    * @return a negative integer, zero, or a positive integer as this object is    *         less than, equal to, or greater than the specified object.    */
specifier|public
name|int
name|compareToScaleTen
parameter_list|(
name|UnsignedInt128
name|o
parameter_list|,
name|short
name|tenScale
parameter_list|)
block|{
comment|// easier case. take a quick path
if|if
condition|(
name|tenScale
operator|==
literal|0
condition|)
block|{
return|return
name|compareTo
argument_list|(
name|o
argument_list|)
return|;
block|}
comment|// if o is zero, easy.
if|if
condition|(
name|o
operator|.
name|isZero
argument_list|()
condition|)
block|{
return|return
name|this
operator|.
name|isZero
argument_list|()
condition|?
literal|0
else|:
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|this
operator|.
name|isZero
argument_list|()
condition|)
block|{
comment|// if this is zero, we need to check if o might become zero after
comment|// scaling down.
comment|// this is not easy because there might be rounding.
if|if
condition|(
name|tenScale
operator|>
literal|0
condition|)
block|{
comment|// scaling up, so o is definitely larger
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|tenScale
operator|<
operator|-
name|SqlMathUtil
operator|.
name|MAX_POWER_TEN_INT128
condition|)
block|{
comment|// any value will become zero. even no possibility of rounding
return|return
literal|0
return|;
block|}
else|else
block|{
comment|// compare with 5 * 10**-tenScale
comment|// example: tenScale=-1. o will be zero after scaling if o>=5.
name|boolean
name|oZero
init|=
name|o
operator|.
name|compareTo
argument_list|(
name|SqlMathUtil
operator|.
name|ROUND_POWER_TENS_INT128
index|[
operator|-
name|tenScale
index|]
argument_list|)
operator|<
literal|0
decl_stmt|;
return|return
name|oZero
condition|?
literal|0
else|:
operator|-
literal|1
return|;
block|}
block|}
comment|// another quick path
if|if
condition|(
name|this
operator|.
name|fitsInt32
argument_list|()
operator|&&
name|o
operator|.
name|fitsInt32
argument_list|()
operator|&&
name|tenScale
operator|<=
name|SqlMathUtil
operator|.
name|MAX_POWER_TEN_INT31
condition|)
block|{
name|long
name|v0Long
init|=
name|this
operator|.
name|v
index|[
literal|0
index|]
operator|&
name|SqlMathUtil
operator|.
name|LONG_MASK
decl_stmt|;
name|long
name|o0
decl_stmt|;
if|if
condition|(
name|tenScale
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|tenScale
operator|<
operator|-
name|SqlMathUtil
operator|.
name|MAX_POWER_TEN_INT31
condition|)
block|{
comment|// this scales down o.v[0] to 0 because 2^32 = 4.2E9. No
comment|// possibility of rounding.
name|o0
operator|=
literal|0L
expr_stmt|;
block|}
else|else
block|{
comment|// divide by 10**-tenScale. check for rounding.
name|o0
operator|=
operator|(
name|o
operator|.
name|v
index|[
literal|0
index|]
operator|&
name|SqlMathUtil
operator|.
name|LONG_MASK
operator|)
operator|/
name|SqlMathUtil
operator|.
name|POWER_TENS_INT31
index|[
operator|-
name|tenScale
index|]
expr_stmt|;
name|long
name|remainder
init|=
operator|(
name|o
operator|.
name|v
index|[
literal|0
index|]
operator|&
name|SqlMathUtil
operator|.
name|LONG_MASK
operator|)
operator|%
name|SqlMathUtil
operator|.
name|POWER_TENS_INT31
index|[
operator|-
name|tenScale
index|]
decl_stmt|;
if|if
condition|(
name|remainder
operator|>=
name|SqlMathUtil
operator|.
name|ROUND_POWER_TENS_INT31
index|[
operator|-
name|tenScale
index|]
condition|)
block|{
assert|assert
operator|(
name|o0
operator|>=
literal|0
operator|)
assert|;
operator|++
name|o0
expr_stmt|;
comment|// this is safe because o0 is positive
block|}
block|}
block|}
else|else
block|{
comment|// tenScale<= SqlMathUtil.MAX_POWER_TEN_INT31
comment|// so, we can make this as a long comparison
name|o0
operator|=
operator|(
name|o
operator|.
name|v
index|[
literal|0
index|]
operator|&
name|SqlMathUtil
operator|.
name|LONG_MASK
operator|)
operator|*
operator|(
name|SqlMathUtil
operator|.
name|POWER_TENS_INT31
index|[
name|tenScale
index|]
operator|&
name|SqlMathUtil
operator|.
name|LONG_MASK
operator|)
expr_stmt|;
block|}
return|return
name|SqlMathUtil
operator|.
name|compareUnsignedLong
argument_list|(
name|v0Long
argument_list|,
name|o0
argument_list|)
return|;
block|}
comment|// unfortunately no quick path. let's do scale up/down
name|int
index|[]
name|ov
init|=
name|o
operator|.
name|v
operator|.
name|clone
argument_list|()
decl_stmt|;
if|if
condition|(
name|tenScale
operator|<
literal|0
condition|)
block|{
comment|// scale down. does rounding
name|scaleDownTenArray4RoundUp
argument_list|(
name|ov
argument_list|,
operator|(
name|short
operator|)
operator|-
name|tenScale
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// scale up
name|boolean
name|overflow
init|=
name|scaleUpTenArray
argument_list|(
name|ov
argument_list|,
name|tenScale
argument_list|)
decl_stmt|;
if|if
condition|(
name|overflow
condition|)
block|{
comment|// overflow is not an error here. it just means "this" is
comment|// smaller
return|return
operator|-
literal|1
return|;
block|}
block|}
return|return
name|compareTo
argument_list|(
name|ov
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|int
name|hashCode
parameter_list|()
block|{
comment|// note: v[0] ^ v[1] ^ v[2] ^ v[3] would cause too many hash collisions
return|return
operator|(
name|v
index|[
literal|0
index|]
operator|*
literal|0x2AB19E23
operator|)
operator|+
operator|(
name|v
index|[
literal|1
index|]
operator|*
literal|0x4918EACB
operator|)
operator|+
operator|(
name|v
index|[
literal|2
index|]
operator|*
literal|0xF03051A7
operator|)
operator|+
name|v
index|[
literal|3
index|]
return|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|equals
parameter_list|(
name|Object
name|obj
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|obj
operator|instanceof
name|UnsignedInt128
operator|)
condition|)
block|{
return|return
literal|false
return|;
block|}
return|return
name|equals
argument_list|(
operator|(
name|UnsignedInt128
operator|)
name|obj
argument_list|)
return|;
block|}
comment|/**    * Specialized version.    *    * @see #equals(Object)    * @param o    *          the object to compare with    * @return whether this object is equal to the given object    */
specifier|public
name|boolean
name|equals
parameter_list|(
name|UnsignedInt128
name|o
parameter_list|)
block|{
return|return
name|this
operator|.
name|v
index|[
literal|0
index|]
operator|==
name|o
operator|.
name|v
index|[
literal|0
index|]
operator|&&
name|this
operator|.
name|v
index|[
literal|1
index|]
operator|==
name|o
operator|.
name|v
index|[
literal|1
index|]
operator|&&
name|this
operator|.
name|v
index|[
literal|2
index|]
operator|==
name|o
operator|.
name|v
index|[
literal|2
index|]
operator|&&
name|this
operator|.
name|v
index|[
literal|3
index|]
operator|==
name|o
operator|.
name|v
index|[
literal|3
index|]
return|;
block|}
comment|/**    * Specialized version.    *    * @see #equals(Object)    * @param o0    *          o0    * @param o1    *          o1    * @param o2    *          o2    * @param o3    *          o3    * @return whether this object is equal to the given object    */
specifier|public
name|boolean
name|equals
parameter_list|(
name|int
name|o0
parameter_list|,
name|int
name|o1
parameter_list|,
name|int
name|o2
parameter_list|,
name|int
name|o3
parameter_list|)
block|{
return|return
name|this
operator|.
name|v
index|[
literal|0
index|]
operator|==
name|o0
operator|&&
name|this
operator|.
name|v
index|[
literal|1
index|]
operator|==
name|o1
operator|&&
name|this
operator|.
name|v
index|[
literal|2
index|]
operator|==
name|o2
operator|&&
name|this
operator|.
name|v
index|[
literal|3
index|]
operator|==
name|o3
return|;
block|}
annotation|@
name|Override
specifier|protected
name|Object
name|clone
parameter_list|()
throws|throws
name|CloneNotSupportedException
block|{
return|return
operator|new
name|UnsignedInt128
argument_list|(
name|this
argument_list|)
return|;
block|}
comment|/**    * Convert this object to {@link BigInteger}. Do not use this method in a    * performance sensitive place.    *    * @return BigInteger to represent this object    */
specifier|public
name|BigInteger
name|toBigIntegerSlow
parameter_list|()
block|{
name|BigInteger
name|bigInt
init|=
name|BigInteger
operator|.
name|valueOf
argument_list|(
name|v
index|[
literal|3
index|]
operator|&
name|SqlMathUtil
operator|.
name|LONG_MASK
argument_list|)
decl_stmt|;
name|bigInt
operator|=
name|bigInt
operator|.
name|shiftLeft
argument_list|(
literal|32
argument_list|)
expr_stmt|;
name|bigInt
operator|=
name|bigInt
operator|.
name|add
argument_list|(
name|BigInteger
operator|.
name|valueOf
argument_list|(
name|v
index|[
literal|2
index|]
operator|&
name|SqlMathUtil
operator|.
name|LONG_MASK
argument_list|)
argument_list|)
expr_stmt|;
name|bigInt
operator|=
name|bigInt
operator|.
name|shiftLeft
argument_list|(
literal|32
argument_list|)
expr_stmt|;
name|bigInt
operator|=
name|bigInt
operator|.
name|add
argument_list|(
name|BigInteger
operator|.
name|valueOf
argument_list|(
name|v
index|[
literal|1
index|]
operator|&
name|SqlMathUtil
operator|.
name|LONG_MASK
argument_list|)
argument_list|)
expr_stmt|;
name|bigInt
operator|=
name|bigInt
operator|.
name|shiftLeft
argument_list|(
literal|32
argument_list|)
expr_stmt|;
name|bigInt
operator|=
name|bigInt
operator|.
name|add
argument_list|(
name|BigInteger
operator|.
name|valueOf
argument_list|(
name|v
index|[
literal|0
index|]
operator|&
name|SqlMathUtil
operator|.
name|LONG_MASK
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|bigInt
return|;
block|}
comment|/**    * Returns the formal string representation of this value. Unlike the debug    * string returned by {@link #toString()}, this method returns a string that    * can be used to re-construct this object. Remember, toString() is only for    * debugging.    *    * @return string representation of this value    */
specifier|public
name|String
name|toFormalString
parameter_list|()
block|{
name|char
index|[]
name|buf
init|=
operator|new
name|char
index|[
name|MAX_DIGITS
operator|+
literal|1
index|]
decl_stmt|;
name|int
name|bufCount
init|=
literal|0
decl_stmt|;
name|int
name|nonZeroBufCount
init|=
literal|0
decl_stmt|;
specifier|final
name|int
name|tenScale
init|=
name|SqlMathUtil
operator|.
name|MAX_POWER_TEN_INT31
decl_stmt|;
specifier|final
name|int
name|tenPower
init|=
name|SqlMathUtil
operator|.
name|POWER_TENS_INT31
index|[
name|tenScale
index|]
decl_stmt|;
name|UnsignedInt128
name|tmp
init|=
operator|new
name|UnsignedInt128
argument_list|(
name|this
argument_list|)
decl_stmt|;
while|while
condition|(
operator|!
name|tmp
operator|.
name|isZero
argument_list|()
condition|)
block|{
name|int
name|remainder
init|=
name|tmp
operator|.
name|divideDestructive
argument_list|(
name|tenPower
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|tenScale
operator|&&
name|bufCount
operator|<
name|buf
operator|.
name|length
condition|;
operator|++
name|i
control|)
block|{
name|int
name|digit
init|=
name|remainder
operator|%
literal|10
decl_stmt|;
name|remainder
operator|/=
literal|10
expr_stmt|;
name|buf
index|[
name|bufCount
index|]
operator|=
call|(
name|char
call|)
argument_list|(
name|digit
operator|+
literal|'0'
argument_list|)
expr_stmt|;
operator|++
name|bufCount
expr_stmt|;
if|if
condition|(
name|digit
operator|!=
literal|0
condition|)
block|{
name|nonZeroBufCount
operator|=
name|bufCount
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|bufCount
operator|==
literal|0
condition|)
block|{
return|return
literal|"0"
return|;
block|}
else|else
block|{
name|char
index|[]
name|reversed
init|=
operator|new
name|char
index|[
name|nonZeroBufCount
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|nonZeroBufCount
condition|;
operator|++
name|i
control|)
block|{
name|reversed
index|[
name|i
index|]
operator|=
name|buf
index|[
name|nonZeroBufCount
operator|-
name|i
operator|-
literal|1
index|]
expr_stmt|;
block|}
return|return
operator|new
name|String
argument_list|(
name|reversed
argument_list|)
return|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|String
name|toString
parameter_list|()
block|{
name|StringBuilder
name|str
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|str
operator|.
name|append
argument_list|(
literal|"Int128: count="
operator|+
name|count
operator|+
literal|","
argument_list|)
expr_stmt|;
name|str
operator|.
name|append
argument_list|(
literal|"v[0]="
operator|+
name|v
index|[
literal|0
index|]
operator|+
literal|"(0x"
operator|+
name|Integer
operator|.
name|toHexString
argument_list|(
name|v
index|[
literal|0
index|]
argument_list|)
operator|+
literal|"), "
argument_list|)
expr_stmt|;
name|str
operator|.
name|append
argument_list|(
literal|"v[1]="
operator|+
name|v
index|[
literal|1
index|]
operator|+
literal|"(0x"
operator|+
name|Integer
operator|.
name|toHexString
argument_list|(
name|v
index|[
literal|1
index|]
argument_list|)
operator|+
literal|"), "
argument_list|)
expr_stmt|;
name|str
operator|.
name|append
argument_list|(
literal|"v[2]="
operator|+
name|v
index|[
literal|2
index|]
operator|+
literal|"(0x"
operator|+
name|Integer
operator|.
name|toHexString
argument_list|(
name|v
index|[
literal|2
index|]
argument_list|)
operator|+
literal|"), "
argument_list|)
expr_stmt|;
name|str
operator|.
name|append
argument_list|(
literal|"v[3]="
operator|+
name|v
index|[
literal|3
index|]
operator|+
literal|"(0x"
operator|+
name|Integer
operator|.
name|toHexString
argument_list|(
name|v
index|[
literal|3
index|]
argument_list|)
operator|+
literal|"), "
argument_list|)
expr_stmt|;
name|str
operator|.
name|append
argument_list|(
literal|"BigInteger#toString="
operator|+
name|toBigIntegerSlow
argument_list|()
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
return|return
operator|new
name|String
argument_list|(
name|str
argument_list|)
return|;
block|}
comment|/**    * Adds the given value to this value. This version is destructive, meaning it    * modifies this object.    *    * @param right    *          the value to add    */
specifier|public
name|void
name|addDestructive
parameter_list|(
name|UnsignedInt128
name|right
parameter_list|)
block|{
name|addDestructive
argument_list|(
name|right
operator|.
name|v
argument_list|)
expr_stmt|;
block|}
comment|/**    * Adds the given value to this value. This version is destructive, meaning it    * modifies this object.    *    * @param r    *          the value to add    */
specifier|public
name|void
name|addDestructive
parameter_list|(
name|int
index|[]
name|r
parameter_list|)
block|{
name|long
name|sum
init|=
literal|0L
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|INT_COUNT
condition|;
operator|++
name|i
control|)
block|{
name|sum
operator|=
operator|(
name|this
operator|.
name|v
index|[
name|i
index|]
operator|&
name|SqlMathUtil
operator|.
name|LONG_MASK
operator|)
operator|+
operator|(
name|r
index|[
name|i
index|]
operator|&
name|SqlMathUtil
operator|.
name|LONG_MASK
operator|)
operator|+
operator|(
name|sum
operator|>>>
literal|32
operator|)
expr_stmt|;
name|this
operator|.
name|v
index|[
name|i
index|]
operator|=
operator|(
name|int
operator|)
name|sum
expr_stmt|;
block|}
name|updateCount
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|sum
operator|>>
literal|32
operator|)
operator|!=
literal|0
condition|)
block|{
name|SqlMathUtil
operator|.
name|throwOverflowException
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Adds the given value to this value. This version is destructive, meaning it    * modifies this object.    *    * @param r    *          the value to add    */
specifier|public
name|void
name|addDestructive
parameter_list|(
name|int
name|r
parameter_list|)
block|{
if|if
condition|(
operator|(
name|this
operator|.
name|v
index|[
literal|0
index|]
operator|&
name|SqlMathUtil
operator|.
name|LONG_MASK
operator|)
operator|+
operator|(
name|r
operator|&
name|SqlMathUtil
operator|.
name|LONG_MASK
operator|)
operator|>=
operator|(
literal|1L
operator|<<
literal|32L
operator|)
condition|)
block|{
name|this
operator|.
name|v
index|[
literal|0
index|]
operator|+=
name|r
expr_stmt|;
if|if
condition|(
name|this
operator|.
name|v
index|[
literal|1
index|]
operator|==
name|SqlMathUtil
operator|.
name|FULLBITS_32
condition|)
block|{
name|this
operator|.
name|v
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|this
operator|.
name|v
index|[
literal|2
index|]
operator|==
name|SqlMathUtil
operator|.
name|FULLBITS_32
condition|)
block|{
name|this
operator|.
name|v
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|this
operator|.
name|v
index|[
literal|3
index|]
operator|==
name|SqlMathUtil
operator|.
name|FULLBITS_32
condition|)
block|{
name|SqlMathUtil
operator|.
name|throwOverflowException
argument_list|()
expr_stmt|;
block|}
else|else
block|{
operator|++
name|this
operator|.
name|v
index|[
literal|3
index|]
expr_stmt|;
block|}
block|}
else|else
block|{
operator|++
name|this
operator|.
name|v
index|[
literal|2
index|]
expr_stmt|;
block|}
block|}
else|else
block|{
operator|++
name|this
operator|.
name|v
index|[
literal|1
index|]
expr_stmt|;
block|}
block|}
else|else
block|{
name|this
operator|.
name|v
index|[
literal|0
index|]
operator|+=
name|r
expr_stmt|;
block|}
name|updateCount
argument_list|()
expr_stmt|;
block|}
comment|/**    * Adds one to this value. This version is destructive, meaning it modifies    * this object.    */
specifier|public
name|void
name|incrementDestructive
parameter_list|()
block|{
name|incrementArray
argument_list|(
name|v
argument_list|)
expr_stmt|;
name|updateCount
argument_list|()
expr_stmt|;
block|}
comment|/**    * Subtracts one from this value. This version is destructive, meaning it    * modifies this object.    */
specifier|public
name|void
name|decrementDestructive
parameter_list|()
block|{
name|decrementArray
argument_list|(
name|v
argument_list|)
expr_stmt|;
name|updateCount
argument_list|()
expr_stmt|;
block|}
comment|/**    * Adds the given value after scaling to this value. this := this + (right *    * 10**tenScale). This version is destructive, meaning it modifies this    * object.    *    * @param right    *          the value to add    * @param tenScale    *          number of ten-based scaling. could be either positive or negative.    */
specifier|public
name|void
name|addDestructiveScaleTen
parameter_list|(
name|UnsignedInt128
name|right
parameter_list|,
name|short
name|tenScale
parameter_list|)
block|{
if|if
condition|(
name|tenScale
operator|==
literal|0
condition|)
block|{
name|addDestructive
argument_list|(
name|right
argument_list|)
expr_stmt|;
return|return;
block|}
comment|// scale up/down
specifier|final
name|int
index|[]
name|r
init|=
name|right
operator|.
name|v
operator|.
name|clone
argument_list|()
decl_stmt|;
if|if
condition|(
name|tenScale
operator|<
literal|0
condition|)
block|{
comment|// scale down
name|scaleDownTenArray4RoundUp
argument_list|(
name|r
argument_list|,
operator|(
name|short
operator|)
operator|-
name|tenScale
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|tenScale
operator|>
literal|0
condition|)
block|{
comment|// scale up
name|boolean
name|overflow
init|=
name|scaleUpTenArray
argument_list|(
name|r
argument_list|,
name|tenScale
argument_list|)
decl_stmt|;
if|if
condition|(
name|overflow
condition|)
block|{
name|SqlMathUtil
operator|.
name|throwOverflowException
argument_list|()
expr_stmt|;
block|}
block|}
name|addDestructive
argument_list|(
name|r
argument_list|)
expr_stmt|;
block|}
comment|/**    * Subtracts the given value from this value. In other words, this := this -    * right. This method will throw overflow exception if right operand is larger    * than this value. This version is destructive, meaning it modifies this    * object.    *    * @param right    *          the value to subtract    */
specifier|public
name|void
name|subtractDestructive
parameter_list|(
name|UnsignedInt128
name|right
parameter_list|)
block|{
name|subtractDestructive
argument_list|(
name|right
operator|.
name|v
argument_list|)
expr_stmt|;
block|}
comment|/**    * Subtracts the given value from this value. In other words, this := this -    * right. This method doesn't work if right operand is larger than this value.    * This version is destructive, meaning it modifies this object.    *    * @param r    *          the value to subtract    */
specifier|public
name|void
name|subtractDestructive
parameter_list|(
name|int
index|[]
name|r
parameter_list|)
block|{
name|long
name|sum
init|=
literal|0L
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|INT_COUNT
condition|;
operator|++
name|i
control|)
block|{
name|sum
operator|=
operator|(
name|this
operator|.
name|v
index|[
name|i
index|]
operator|&
name|SqlMathUtil
operator|.
name|LONG_MASK
operator|)
operator|-
operator|(
name|r
index|[
name|i
index|]
operator|&
name|SqlMathUtil
operator|.
name|LONG_MASK
operator|)
operator|-
operator|(
operator|(
name|int
operator|)
operator|-
operator|(
name|sum
operator|>>
literal|32
operator|)
operator|)
expr_stmt|;
name|this
operator|.
name|v
index|[
name|i
index|]
operator|=
operator|(
name|int
operator|)
name|sum
expr_stmt|;
block|}
name|updateCount
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|sum
operator|>>
literal|32
operator|)
operator|!=
literal|0
condition|)
block|{
name|SqlMathUtil
operator|.
name|throwOverflowException
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Calculates absolute difference (remember that this is unsigned) of left and    * right operator.<code>result := abs (left - right)</code> This is the core    * implementation of subtract and signed add.    *    * @param left    *          left operand    * @param right    *          right operand    * @param result    *          the object to receive the result. can be same object as left or    *          right.    * @return signum of the result. -1 if left was smaller than right, 1 if    *         larger, 0 if same (result is zero).    */
specifier|public
specifier|static
name|byte
name|difference
parameter_list|(
name|UnsignedInt128
name|left
parameter_list|,
name|UnsignedInt128
name|right
parameter_list|,
name|UnsignedInt128
name|result
parameter_list|)
block|{
return|return
name|differenceInternal
argument_list|(
name|left
argument_list|,
name|right
operator|.
name|v
argument_list|,
name|result
argument_list|)
return|;
block|}
comment|/**    * Calculates absolute difference of left and right operator after ten-based    * scaling on right.    *<code>result := abs (left - (right * 10**tenScale))</code> This is the core    * implementation of subtract.    *    * @param left    *          left operand    * @param right    *          right operand    * @param result    *          the object to receive the result. can be same object as left or    *          right.    * @param tenScale    *          number of ten-based scaling. could be either positive or negative.    * @return signum of the result. -1 if left was smaller than right, 1 if    *         larger, 0 if same (result is zero).    */
specifier|public
specifier|static
name|byte
name|differenceScaleTen
parameter_list|(
name|UnsignedInt128
name|left
parameter_list|,
name|UnsignedInt128
name|right
parameter_list|,
name|UnsignedInt128
name|result
parameter_list|,
name|short
name|tenScale
parameter_list|)
block|{
if|if
condition|(
name|tenScale
operator|==
literal|0
condition|)
block|{
return|return
name|difference
argument_list|(
name|left
argument_list|,
name|right
argument_list|,
name|result
argument_list|)
return|;
block|}
comment|// scale up/down
name|int
index|[]
name|r
init|=
name|right
operator|.
name|v
operator|.
name|clone
argument_list|()
decl_stmt|;
if|if
condition|(
name|tenScale
operator|<
literal|0
condition|)
block|{
comment|// scale down
name|scaleDownTenArray4RoundUp
argument_list|(
name|r
argument_list|,
operator|(
name|short
operator|)
operator|-
name|tenScale
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// scale up
name|boolean
name|overflow
init|=
name|scaleUpTenArray
argument_list|(
name|r
argument_list|,
name|tenScale
argument_list|)
decl_stmt|;
if|if
condition|(
name|overflow
condition|)
block|{
name|SqlMathUtil
operator|.
name|throwOverflowException
argument_list|()
expr_stmt|;
block|}
block|}
return|return
name|differenceInternal
argument_list|(
name|left
argument_list|,
name|r
argument_list|,
name|result
argument_list|)
return|;
block|}
comment|/**    * Multiplies this value with the given integer value. This version is    * destructive, meaning it modifies this object.    *    * @param right    *          the value to multiply    */
specifier|public
name|void
name|multiplyDestructive
parameter_list|(
name|int
name|right
parameter_list|)
block|{
if|if
condition|(
name|right
operator|==
literal|0
condition|)
block|{
name|zeroClear
argument_list|()
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|right
operator|==
literal|1
condition|)
block|{
return|return;
block|}
name|long
name|sum
init|=
literal|0L
decl_stmt|;
name|long
name|rightUnsigned
init|=
name|right
operator|&
name|SqlMathUtil
operator|.
name|LONG_MASK
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|INT_COUNT
condition|;
operator|++
name|i
control|)
block|{
name|sum
operator|=
operator|(
name|this
operator|.
name|v
index|[
name|i
index|]
operator|&
name|SqlMathUtil
operator|.
name|LONG_MASK
operator|)
operator|*
name|rightUnsigned
operator|+
operator|(
name|sum
operator|>>>
literal|32
operator|)
expr_stmt|;
name|this
operator|.
name|v
index|[
name|i
index|]
operator|=
operator|(
name|int
operator|)
name|sum
expr_stmt|;
block|}
name|updateCount
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|sum
operator|>>
literal|32
operator|)
operator|!=
literal|0
condition|)
block|{
name|SqlMathUtil
operator|.
name|throwOverflowException
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Multiplies this value with the given value. This version is destructive,    * meaning it modifies this object.    *    * @param right    *          the value to multiply    */
specifier|public
name|void
name|multiplyDestructive
parameter_list|(
name|UnsignedInt128
name|right
parameter_list|)
block|{
if|if
condition|(
name|this
operator|.
name|fitsInt32
argument_list|()
operator|&&
name|right
operator|.
name|fitsInt32
argument_list|()
condition|)
block|{
name|multiplyDestructiveFitsInt32
argument_list|(
name|right
argument_list|,
operator|(
name|short
operator|)
literal|0
argument_list|,
operator|(
name|short
operator|)
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
name|multiplyArrays4And4To4NoOverflow
argument_list|(
name|this
operator|.
name|v
argument_list|,
name|right
operator|.
name|v
argument_list|)
expr_stmt|;
name|updateCount
argument_list|()
expr_stmt|;
block|}
comment|/**    * Multiplies this value with the given value, followed by right bit shifts to    * scale it back to this object. This is used from division. This version is    * destructive, meaning it modifies this object.    *    * @param right    *          the value to multiply    * @param rightShifts    *          the number of right-shifts after multiplication    */
specifier|public
name|void
name|multiplyShiftDestructive
parameter_list|(
name|UnsignedInt128
name|right
parameter_list|,
name|short
name|rightShifts
parameter_list|)
block|{
if|if
condition|(
name|this
operator|.
name|fitsInt32
argument_list|()
operator|&&
name|right
operator|.
name|fitsInt32
argument_list|()
condition|)
block|{
name|multiplyDestructiveFitsInt32
argument_list|(
name|right
argument_list|,
name|rightShifts
argument_list|,
operator|(
name|short
operator|)
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
name|int
index|[]
name|z
init|=
name|multiplyArrays4And4To8
argument_list|(
name|this
operator|.
name|v
argument_list|,
name|right
operator|.
name|v
argument_list|)
decl_stmt|;
name|shiftRightArray
argument_list|(
name|rightShifts
argument_list|,
name|z
argument_list|,
name|this
operator|.
name|v
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|updateCount
argument_list|()
expr_stmt|;
block|}
comment|/**    * Multiply this value with the given value, followed by ten-based scale down.    * This method does the two operations without cutting off, so it preserves    * accuracy without throwing a wrong overflow exception.    *    * @param right    *          right operand    * @param tenScale    *          distance to scale down    */
specifier|public
name|void
name|multiplyScaleDownTenDestructive
parameter_list|(
name|UnsignedInt128
name|right
parameter_list|,
name|short
name|tenScale
parameter_list|)
block|{
assert|assert
operator|(
name|tenScale
operator|>=
literal|0
operator|)
assert|;
if|if
condition|(
name|this
operator|.
name|fitsInt32
argument_list|()
operator|&&
name|right
operator|.
name|fitsInt32
argument_list|()
condition|)
block|{
name|multiplyDestructiveFitsInt32
argument_list|(
name|right
argument_list|,
operator|(
name|short
operator|)
literal|0
argument_list|,
name|tenScale
argument_list|)
expr_stmt|;
return|return;
block|}
name|int
index|[]
name|z
init|=
name|multiplyArrays4And4To8
argument_list|(
name|this
operator|.
name|v
argument_list|,
name|right
operator|.
name|v
argument_list|)
decl_stmt|;
comment|// Then, scale back.
name|scaleDownTenArray8RoundUp
argument_list|(
name|z
argument_list|,
name|tenScale
argument_list|)
expr_stmt|;
name|update
argument_list|(
name|z
index|[
literal|0
index|]
argument_list|,
name|z
index|[
literal|1
index|]
argument_list|,
name|z
index|[
literal|2
index|]
argument_list|,
name|z
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
block|}
comment|/**    * Divides this value with the given value. This version is destructive,    * meaning it modifies this object.    *    * @param right    *          the value to divide    * @param remainder    *          object to receive remainder    */
specifier|public
name|void
name|divideDestructive
parameter_list|(
name|UnsignedInt128
name|right
parameter_list|,
name|UnsignedInt128
name|remainder
parameter_list|)
block|{
if|if
condition|(
name|right
operator|.
name|isZero
argument_list|()
condition|)
block|{
assert|assert
operator|(
name|right
operator|.
name|isZero
argument_list|()
operator|)
assert|;
name|SqlMathUtil
operator|.
name|throwZeroDivisionException
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|right
operator|.
name|count
operator|==
literal|1
condition|)
block|{
assert|assert
operator|(
name|right
operator|.
name|v
index|[
literal|1
index|]
operator|==
literal|0
operator|)
assert|;
assert|assert
operator|(
name|right
operator|.
name|v
index|[
literal|2
index|]
operator|==
literal|0
operator|)
assert|;
assert|assert
operator|(
name|right
operator|.
name|v
index|[
literal|3
index|]
operator|==
literal|0
operator|)
assert|;
name|int
name|rem
init|=
name|divideDestructive
argument_list|(
name|right
operator|.
name|v
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
name|remainder
operator|.
name|update
argument_list|(
name|rem
argument_list|)
expr_stmt|;
return|return;
block|}
name|int
index|[]
name|quotient
init|=
operator|new
name|int
index|[
literal|5
index|]
decl_stmt|;
name|int
index|[]
name|rem
init|=
name|SqlMathUtil
operator|.
name|divideMultiPrecision
argument_list|(
name|this
operator|.
name|v
argument_list|,
name|right
operator|.
name|v
argument_list|,
name|quotient
argument_list|)
decl_stmt|;
name|update
argument_list|(
name|quotient
index|[
literal|0
index|]
argument_list|,
name|quotient
index|[
literal|1
index|]
argument_list|,
name|quotient
index|[
literal|2
index|]
argument_list|,
name|quotient
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
name|remainder
operator|.
name|update
argument_list|(
name|rem
index|[
literal|0
index|]
argument_list|,
name|rem
index|[
literal|1
index|]
argument_list|,
name|rem
index|[
literal|2
index|]
argument_list|,
name|rem
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
block|}
comment|/**    * Scale up this object for 10**tenScale and then divides this value with the    * given value. This version is destructive, meaning it modifies this object.    *    * @param right    *          the value to divide    * @param tenScale    *          ten-based scale up distance    * @param remainder    *          object to receive remainder    */
specifier|public
name|void
name|divideScaleUpTenDestructive
parameter_list|(
name|UnsignedInt128
name|right
parameter_list|,
name|short
name|tenScale
parameter_list|,
name|UnsignedInt128
name|remainder
parameter_list|)
block|{
comment|// in this case, we have to scale up _BEFORE_ division. otherwise we
comment|// might lose precision.
if|if
condition|(
name|tenScale
operator|>
name|SqlMathUtil
operator|.
name|MAX_POWER_TEN_INT128
condition|)
block|{
comment|// in this case, the result will be surely more than 128 bit even
comment|// after division
name|SqlMathUtil
operator|.
name|throwOverflowException
argument_list|()
expr_stmt|;
block|}
name|int
index|[]
name|scaledUp
init|=
name|multiplyConstructive256
argument_list|(
name|SqlMathUtil
operator|.
name|POWER_TENS_INT128
index|[
name|tenScale
index|]
argument_list|)
decl_stmt|;
name|int
index|[]
name|quotient
init|=
operator|new
name|int
index|[
literal|5
index|]
decl_stmt|;
name|int
index|[]
name|rem
init|=
name|SqlMathUtil
operator|.
name|divideMultiPrecision
argument_list|(
name|scaledUp
argument_list|,
name|right
operator|.
name|v
argument_list|,
name|quotient
argument_list|)
decl_stmt|;
name|update
argument_list|(
name|quotient
index|[
literal|0
index|]
argument_list|,
name|quotient
index|[
literal|1
index|]
argument_list|,
name|quotient
index|[
literal|2
index|]
argument_list|,
name|quotient
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
name|remainder
operator|.
name|update
argument_list|(
name|rem
index|[
literal|0
index|]
argument_list|,
name|rem
index|[
literal|1
index|]
argument_list|,
name|rem
index|[
literal|2
index|]
argument_list|,
name|rem
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
block|}
comment|/**    * Divides this value with the given value. This version is destructive,    * meaning it modifies this object.    *    * @param right    *          the value to divide    * @return remainder    */
specifier|public
name|int
name|divideDestructive
parameter_list|(
name|int
name|right
parameter_list|)
block|{
assert|assert
operator|(
name|right
operator|>=
literal|0
operator|)
assert|;
name|long
name|rightUnsigned
init|=
name|right
operator|&
name|SqlMathUtil
operator|.
name|LONG_MASK
decl_stmt|;
name|long
name|quotient
decl_stmt|;
name|long
name|remainder
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
name|INT_COUNT
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
operator|--
name|i
control|)
block|{
name|remainder
operator|=
operator|(
operator|(
name|this
operator|.
name|v
index|[
name|i
index|]
operator|&
name|SqlMathUtil
operator|.
name|LONG_MASK
operator|)
operator|+
operator|(
name|remainder
operator|<<
literal|32
operator|)
operator|)
expr_stmt|;
name|quotient
operator|=
name|remainder
operator|/
name|rightUnsigned
expr_stmt|;
name|remainder
operator|%=
name|rightUnsigned
expr_stmt|;
name|this
operator|.
name|v
index|[
name|i
index|]
operator|=
operator|(
name|int
operator|)
name|quotient
expr_stmt|;
block|}
name|updateCount
argument_list|()
expr_stmt|;
return|return
operator|(
name|int
operator|)
name|remainder
return|;
block|}
comment|/**    * Divides this value with the given value. This version is destructive,    * meaning it modifies this object.    *    * @param right    *          the value to divide    * @return remainder    */
specifier|public
name|long
name|divideDestructive
parameter_list|(
name|long
name|right
parameter_list|)
block|{
assert|assert
operator|(
name|right
operator|>=
literal|0
operator|)
assert|;
name|long
name|quotient
decl_stmt|;
name|long
name|remainder
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
name|INT_COUNT
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
operator|--
name|i
control|)
block|{
name|remainder
operator|=
operator|(
operator|(
name|this
operator|.
name|v
index|[
name|i
index|]
operator|&
name|SqlMathUtil
operator|.
name|LONG_MASK
operator|)
operator|+
operator|(
name|remainder
operator|<<
literal|32
operator|)
operator|)
expr_stmt|;
name|quotient
operator|=
name|remainder
operator|/
name|right
expr_stmt|;
name|remainder
operator|%=
name|right
expr_stmt|;
name|this
operator|.
name|v
index|[
name|i
index|]
operator|=
operator|(
name|int
operator|)
name|quotient
expr_stmt|;
block|}
name|updateCount
argument_list|()
expr_stmt|;
return|return
name|remainder
return|;
block|}
comment|/**    * Right-shift for the given number of bits. This version is destructive,    * meaning it modifies this object.    *    * @param bits    *          the number of bits. must be positive    * @param roundUp    *          whether to round up the most significant bit that was discarded    */
specifier|public
name|void
name|shiftRightDestructive
parameter_list|(
name|int
name|bits
parameter_list|,
name|boolean
name|roundUp
parameter_list|)
block|{
assert|assert
operator|(
name|bits
operator|>=
literal|0
operator|)
assert|;
name|shiftRightDestructive
argument_list|(
name|bits
operator|/
literal|32
argument_list|,
name|bits
operator|%
literal|32
argument_list|,
name|roundUp
argument_list|)
expr_stmt|;
block|}
comment|/**    * Left-shift for the given number of bits. This method does not throw an    * error even if overflow happens. This version is destructive, meaning it    * modifies this object.    *    * @param bits    *          the number of bits. must be positive    */
specifier|public
name|void
name|shiftLeftDestructive
parameter_list|(
name|int
name|bits
parameter_list|)
block|{
assert|assert
operator|(
name|bits
operator|>=
literal|0
operator|)
assert|;
name|shiftLeftDestructive
argument_list|(
name|bits
operator|/
literal|32
argument_list|,
name|bits
operator|%
literal|32
argument_list|)
expr_stmt|;
block|}
comment|/**    * Left-shift for the given number of bits. This method throws an error even    * if overflow happens. This version is destructive, meaning it modifies this    * object.    *    * @param bits    *          the number of bits. must be positive    */
specifier|public
name|void
name|shiftLeftDestructiveCheckOverflow
parameter_list|(
name|int
name|bits
parameter_list|)
block|{
if|if
condition|(
name|bitLength
argument_list|()
operator|+
name|bits
operator|>=
literal|128
condition|)
block|{
name|SqlMathUtil
operator|.
name|throwOverflowException
argument_list|()
expr_stmt|;
block|}
name|shiftLeftDestructive
argument_list|(
name|bits
argument_list|)
expr_stmt|;
block|}
comment|/**    * Scale down the value for 10**tenScale (this := this / 10**tenScale). This    * method rounds-up, eg 44/10=4, 45/10=5. This version is destructive, meaning    * it modifies this object.    *    * @param tenScale    *          scaling. must be positive    */
specifier|public
name|void
name|scaleDownTenDestructive
parameter_list|(
name|short
name|tenScale
parameter_list|)
block|{
if|if
condition|(
name|tenScale
operator|==
literal|0
condition|)
block|{
return|return;
block|}
if|if
condition|(
name|tenScale
operator|<
literal|0
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|()
throw|;
block|}
if|if
condition|(
name|isZero
argument_list|()
condition|)
block|{
return|return;
block|}
name|scaleDownTenArray4RoundUp
argument_list|(
name|v
argument_list|,
name|tenScale
argument_list|)
expr_stmt|;
name|updateCount
argument_list|()
expr_stmt|;
block|}
comment|/**    * Scale down the value for 5**tenScale (this := this / 5**tenScale). This    * method rounds-up, eg 42/5=8, 43/5=9. This version is destructive, meaning    * it modifies this object.    *    * @param fiveScale    *          scaling. must be positive    */
specifier|public
name|void
name|scaleDownFiveDestructive
parameter_list|(
name|short
name|fiveScale
parameter_list|)
block|{
if|if
condition|(
name|fiveScale
operator|==
literal|0
condition|)
block|{
return|return;
block|}
if|if
condition|(
name|fiveScale
operator|<
literal|0
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|()
throw|;
block|}
if|if
condition|(
name|isZero
argument_list|()
condition|)
block|{
return|return;
block|}
name|scaleDownFiveArrayRoundUp
argument_list|(
name|v
argument_list|,
name|fiveScale
argument_list|)
expr_stmt|;
name|updateCount
argument_list|()
expr_stmt|;
block|}
comment|/**    * Scale up the value for 10**tenScale (this := this * 10**tenScale). Scaling    * up DOES throw an error when an overflow occurs. For example, 42.scaleUp(1)    * = 420, 42.scaleUp(40) = ArithmeticException. This version is destructive,    * meaning it modifies this object.    *    * @param tenScale    *          scaling. must be positive    */
specifier|public
name|void
name|scaleUpTenDestructive
parameter_list|(
name|short
name|tenScale
parameter_list|)
block|{
if|if
condition|(
name|tenScale
operator|==
literal|0
condition|)
block|{
return|return;
block|}
if|if
condition|(
name|tenScale
operator|<
literal|0
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|()
throw|;
block|}
if|if
condition|(
name|isZero
argument_list|()
condition|)
block|{
return|return;
block|}
comment|// First, scale up with 2. Check overflow
name|shiftLeftDestructiveCheckOverflow
argument_list|(
name|tenScale
argument_list|)
expr_stmt|;
comment|// Then, scale up with 5
name|scaleUpFiveDestructive
argument_list|(
name|tenScale
argument_list|)
expr_stmt|;
block|}
comment|/**    * Scale up the value for 5**tenScale (this := this * 5**tenScale). Scaling up    * DOES throw an error when an overflow occurs. This version is destructive,    * meaning it modifies this object.    *    * @param fiveScale    *          scaling. must be positive    */
specifier|public
name|void
name|scaleUpFiveDestructive
parameter_list|(
name|short
name|fiveScale
parameter_list|)
block|{
if|if
condition|(
name|fiveScale
operator|==
literal|0
condition|)
block|{
return|return;
block|}
if|if
condition|(
name|fiveScale
operator|<
literal|0
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|()
throw|;
block|}
if|if
condition|(
name|isZero
argument_list|()
condition|)
block|{
return|return;
block|}
comment|// Scale up with 5. This is done via #multiplyDestructive(int).
while|while
condition|(
name|fiveScale
operator|>
literal|0
condition|)
block|{
name|int
name|powerFive
init|=
name|Math
operator|.
name|min
argument_list|(
name|fiveScale
argument_list|,
name|SqlMathUtil
operator|.
name|MAX_POWER_FIVE_INT31
argument_list|)
decl_stmt|;
name|multiplyDestructive
argument_list|(
name|SqlMathUtil
operator|.
name|POWER_FIVES_INT31
index|[
name|powerFive
index|]
argument_list|)
expr_stmt|;
name|fiveScale
operator|-=
name|powerFive
expr_stmt|;
block|}
block|}
comment|/**    * This version returns the result as a new object, not modifying the give    * objects.    *    * @param right    *          right operand    * @return operation result as a new object    */
specifier|public
name|UnsignedInt128
name|addConstructive
parameter_list|(
name|UnsignedInt128
name|right
parameter_list|)
block|{
name|UnsignedInt128
name|ret
init|=
operator|new
name|UnsignedInt128
argument_list|(
name|this
argument_list|)
decl_stmt|;
name|ret
operator|.
name|addDestructive
argument_list|(
name|right
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
comment|/**    * This version returns the result as a new object, not modifying the give    * objects.    *    * @return operation result as a new object    */
specifier|public
name|UnsignedInt128
name|incrementConstructive
parameter_list|()
block|{
name|UnsignedInt128
name|ret
init|=
operator|new
name|UnsignedInt128
argument_list|(
name|this
argument_list|)
decl_stmt|;
name|ret
operator|.
name|incrementDestructive
argument_list|()
expr_stmt|;
return|return
name|ret
return|;
block|}
comment|/**    * This version returns the result as a new object, not modifying the give    * objects. This method doesn't work if right operand is larger than this    * value.    *    * @param right    *          right operand    * @return operation result as a new object    */
specifier|public
name|UnsignedInt128
name|subtractConstructive
parameter_list|(
name|UnsignedInt128
name|right
parameter_list|)
block|{
name|UnsignedInt128
name|ret
init|=
operator|new
name|UnsignedInt128
argument_list|(
name|this
argument_list|)
decl_stmt|;
name|ret
operator|.
name|subtractDestructive
argument_list|(
name|right
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
comment|/**    * This version returns the result as a new object, not modifying the give    * objects. This method doesn't work if right operand is larger than this    * value.    *    * @return operation result as a new object    */
specifier|public
name|UnsignedInt128
name|decrementConstructive
parameter_list|()
block|{
name|UnsignedInt128
name|ret
init|=
operator|new
name|UnsignedInt128
argument_list|(
name|this
argument_list|)
decl_stmt|;
name|ret
operator|.
name|decrementDestructive
argument_list|()
expr_stmt|;
return|return
name|ret
return|;
block|}
comment|/**    * This version returns the result as a new object, not modifying the give    * objects.    *    * @param right    *          right operand    * @return operation result as a new object    */
specifier|public
name|UnsignedInt128
name|multiplyConstructive
parameter_list|(
name|int
name|right
parameter_list|)
block|{
name|UnsignedInt128
name|ret
init|=
operator|new
name|UnsignedInt128
argument_list|(
name|this
argument_list|)
decl_stmt|;
name|ret
operator|.
name|multiplyDestructive
argument_list|(
name|right
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
comment|/**    * This version returns the result as a new object, not modifying the give    * objects.    *    * @param right    *          right operand    * @return operation result as a new object    */
specifier|public
name|UnsignedInt128
name|multiplyConstructive
parameter_list|(
name|UnsignedInt128
name|right
parameter_list|)
block|{
name|UnsignedInt128
name|ret
init|=
operator|new
name|UnsignedInt128
argument_list|(
name|this
argument_list|)
decl_stmt|;
name|ret
operator|.
name|multiplyDestructive
argument_list|(
name|right
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
comment|/**    * This version returns the result of multiplication as 256bit data.    *    * @param right    *          right operand    * @return operation result as 256bit data    */
specifier|public
name|int
index|[]
name|multiplyConstructive256
parameter_list|(
name|UnsignedInt128
name|right
parameter_list|)
block|{
return|return
name|multiplyArrays4And4To8
argument_list|(
name|this
operator|.
name|v
argument_list|,
name|right
operator|.
name|v
argument_list|)
return|;
block|}
comment|/**    * This version returns the result as a new object, not modifying the give    * objects. Note that this method cannot receive remainder. Use destructive    * version for it.    *    * @param right    *          right operand    * @return operation result as a new object    */
specifier|public
name|UnsignedInt128
name|divideConstructive
parameter_list|(
name|int
name|right
parameter_list|)
block|{
name|UnsignedInt128
name|ret
init|=
operator|new
name|UnsignedInt128
argument_list|(
name|this
argument_list|)
decl_stmt|;
name|ret
operator|.
name|divideDestructive
argument_list|(
name|right
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
comment|/**    * This version returns the result as a new object, not modifying the give    * objects.    *    * @param right    *          right operand    * @param remainder    *          object to receive remainder    * @return operation result as a new object    */
specifier|public
name|UnsignedInt128
name|divideConstructive
parameter_list|(
name|UnsignedInt128
name|right
parameter_list|,
name|UnsignedInt128
name|remainder
parameter_list|)
block|{
name|UnsignedInt128
name|ret
init|=
operator|new
name|UnsignedInt128
argument_list|(
name|this
argument_list|)
decl_stmt|;
name|ret
operator|.
name|divideDestructive
argument_list|(
name|right
argument_list|,
name|remainder
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
comment|/**    * This version returns the result as a new object, not modifying the give    * objects.    *    * @param bits    *          the number of bits. must be positive    * @param roundUp    *          whether to round up the most significant bit that was discarded    * @return operation result as a new object    */
specifier|public
name|UnsignedInt128
name|shiftRightConstructive
parameter_list|(
name|int
name|bits
parameter_list|,
name|boolean
name|roundUp
parameter_list|)
block|{
name|UnsignedInt128
name|ret
init|=
operator|new
name|UnsignedInt128
argument_list|(
name|this
argument_list|)
decl_stmt|;
name|ret
operator|.
name|shiftRightDestructive
argument_list|(
name|bits
argument_list|,
name|roundUp
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
comment|/**    * This version returns the result as a new object, not modifying the give    * objects.    *    * @param bits    *          the number of bits. must be positive    * @return operation result as a new object    */
specifier|public
name|UnsignedInt128
name|shiftLeftConstructive
parameter_list|(
name|int
name|bits
parameter_list|)
block|{
name|UnsignedInt128
name|ret
init|=
operator|new
name|UnsignedInt128
argument_list|(
name|this
argument_list|)
decl_stmt|;
name|ret
operator|.
name|shiftLeftDestructive
argument_list|(
name|bits
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
specifier|private
name|short
name|bitLength
parameter_list|()
block|{
return|return
name|SqlMathUtil
operator|.
name|bitLength
argument_list|(
name|v
index|[
literal|0
index|]
argument_list|,
name|v
index|[
literal|1
index|]
argument_list|,
name|v
index|[
literal|2
index|]
argument_list|,
name|v
index|[
literal|3
index|]
argument_list|)
return|;
block|}
specifier|private
name|void
name|shiftRightDestructive
parameter_list|(
name|int
name|wordShifts
parameter_list|,
name|int
name|bitShiftsInWord
parameter_list|,
name|boolean
name|roundUp
parameter_list|)
block|{
if|if
condition|(
name|wordShifts
operator|==
literal|0
operator|&&
name|bitShiftsInWord
operator|==
literal|0
condition|)
block|{
return|return;
block|}
assert|assert
operator|(
name|wordShifts
operator|>=
literal|0
operator|)
assert|;
assert|assert
operator|(
name|bitShiftsInWord
operator|>=
literal|0
operator|)
assert|;
assert|assert
operator|(
name|bitShiftsInWord
operator|<
literal|32
operator|)
assert|;
if|if
condition|(
name|wordShifts
operator|>=
literal|4
condition|)
block|{
name|zeroClear
argument_list|()
expr_stmt|;
return|return;
block|}
specifier|final
name|int
name|shiftRestore
init|=
literal|32
operator|-
name|bitShiftsInWord
decl_stmt|;
comment|// check this because "123<< 32" will be 123.
specifier|final
name|boolean
name|noRestore
init|=
name|bitShiftsInWord
operator|==
literal|0
decl_stmt|;
specifier|final
name|int
name|roundCarryNoRestoreMask
init|=
literal|1
operator|<<
literal|31
decl_stmt|;
specifier|final
name|int
name|roundCarryMask
init|=
operator|(
literal|1
operator|<<
operator|(
name|bitShiftsInWord
operator|-
literal|1
operator|)
operator|)
decl_stmt|;
name|boolean
name|roundCarry
decl_stmt|;
name|int
name|z0
init|=
literal|0
decl_stmt|,
name|z1
init|=
literal|0
decl_stmt|,
name|z2
init|=
literal|0
decl_stmt|,
name|z3
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|wordShifts
condition|)
block|{
case|case
literal|3
case|:
name|roundCarry
operator|=
operator|(
name|noRestore
condition|?
operator|(
name|this
operator|.
name|v
index|[
literal|2
index|]
operator|&
name|roundCarryNoRestoreMask
operator|)
else|:
operator|(
name|this
operator|.
name|v
index|[
literal|3
index|]
operator|&
name|roundCarryMask
operator|)
operator|)
operator|!=
literal|0
expr_stmt|;
name|z0
operator|=
name|this
operator|.
name|v
index|[
literal|3
index|]
operator|>>>
name|bitShiftsInWord
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|roundCarry
operator|=
operator|(
name|noRestore
condition|?
operator|(
name|this
operator|.
name|v
index|[
literal|1
index|]
operator|&
name|roundCarryNoRestoreMask
operator|)
else|:
operator|(
name|this
operator|.
name|v
index|[
literal|2
index|]
operator|&
name|roundCarryMask
operator|)
operator|)
operator|!=
literal|0
expr_stmt|;
name|z1
operator|=
name|this
operator|.
name|v
index|[
literal|3
index|]
operator|>>>
name|bitShiftsInWord
expr_stmt|;
name|z0
operator|=
operator|(
name|noRestore
condition|?
literal|0
else|:
name|this
operator|.
name|v
index|[
literal|3
index|]
operator|<<
name|shiftRestore
operator|)
operator||
operator|(
name|this
operator|.
name|v
index|[
literal|2
index|]
operator|>>>
name|bitShiftsInWord
operator|)
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|roundCarry
operator|=
operator|(
name|noRestore
condition|?
operator|(
name|this
operator|.
name|v
index|[
literal|0
index|]
operator|&
name|roundCarryNoRestoreMask
operator|)
else|:
operator|(
name|this
operator|.
name|v
index|[
literal|1
index|]
operator|&
name|roundCarryMask
operator|)
operator|)
operator|!=
literal|0
expr_stmt|;
name|z2
operator|=
name|this
operator|.
name|v
index|[
literal|3
index|]
operator|>>>
name|bitShiftsInWord
expr_stmt|;
name|z1
operator|=
operator|(
name|noRestore
condition|?
literal|0
else|:
name|this
operator|.
name|v
index|[
literal|3
index|]
operator|<<
name|shiftRestore
operator|)
operator||
operator|(
name|this
operator|.
name|v
index|[
literal|2
index|]
operator|>>>
name|bitShiftsInWord
operator|)
expr_stmt|;
name|z0
operator|=
operator|(
name|noRestore
condition|?
literal|0
else|:
name|this
operator|.
name|v
index|[
literal|2
index|]
operator|<<
name|shiftRestore
operator|)
operator||
operator|(
name|this
operator|.
name|v
index|[
literal|1
index|]
operator|>>>
name|bitShiftsInWord
operator|)
expr_stmt|;
break|break;
case|case
literal|0
case|:
name|roundCarry
operator|=
operator|(
name|noRestore
condition|?
literal|0
else|:
operator|(
name|this
operator|.
name|v
index|[
literal|0
index|]
operator|&
name|roundCarryMask
operator|)
operator|)
operator|!=
literal|0
expr_stmt|;
name|z3
operator|=
name|this
operator|.
name|v
index|[
literal|3
index|]
operator|>>>
name|bitShiftsInWord
expr_stmt|;
name|z2
operator|=
operator|(
name|noRestore
condition|?
literal|0
else|:
name|this
operator|.
name|v
index|[
literal|3
index|]
operator|<<
name|shiftRestore
operator|)
operator||
operator|(
name|this
operator|.
name|v
index|[
literal|2
index|]
operator|>>>
name|bitShiftsInWord
operator|)
expr_stmt|;
name|z1
operator|=
operator|(
name|noRestore
condition|?
literal|0
else|:
name|this
operator|.
name|v
index|[
literal|2
index|]
operator|<<
name|shiftRestore
operator|)
operator||
operator|(
name|this
operator|.
name|v
index|[
literal|1
index|]
operator|>>>
name|bitShiftsInWord
operator|)
expr_stmt|;
name|z0
operator|=
operator|(
name|noRestore
condition|?
literal|0
else|:
name|this
operator|.
name|v
index|[
literal|1
index|]
operator|<<
name|shiftRestore
operator|)
operator||
operator|(
name|this
operator|.
name|v
index|[
literal|0
index|]
operator|>>>
name|bitShiftsInWord
operator|)
expr_stmt|;
break|break;
default|default:
assert|assert
operator|(
literal|false
operator|)
assert|;
throw|throw
operator|new
name|RuntimeException
argument_list|()
throw|;
block|}
name|update
argument_list|(
name|z0
argument_list|,
name|z1
argument_list|,
name|z2
argument_list|,
name|z3
argument_list|)
expr_stmt|;
comment|// round up
if|if
condition|(
name|roundUp
operator|&&
name|roundCarry
condition|)
block|{
name|incrementDestructive
argument_list|()
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|shiftLeftDestructive
parameter_list|(
name|int
name|wordShifts
parameter_list|,
name|int
name|bitShiftsInWord
parameter_list|)
block|{
if|if
condition|(
name|wordShifts
operator|==
literal|0
operator|&&
name|bitShiftsInWord
operator|==
literal|0
condition|)
block|{
return|return;
block|}
assert|assert
operator|(
name|wordShifts
operator|>=
literal|0
operator|)
assert|;
assert|assert
operator|(
name|bitShiftsInWord
operator|>=
literal|0
operator|)
assert|;
assert|assert
operator|(
name|bitShiftsInWord
operator|<
literal|32
operator|)
assert|;
if|if
condition|(
name|wordShifts
operator|>=
literal|4
condition|)
block|{
name|zeroClear
argument_list|()
expr_stmt|;
return|return;
block|}
specifier|final
name|int
name|shiftRestore
init|=
literal|32
operator|-
name|bitShiftsInWord
decl_stmt|;
comment|// check this because "123<< 32" will be 123.
specifier|final
name|boolean
name|noRestore
init|=
name|bitShiftsInWord
operator|==
literal|0
decl_stmt|;
name|int
name|z0
init|=
literal|0
decl_stmt|,
name|z1
init|=
literal|0
decl_stmt|,
name|z2
init|=
literal|0
decl_stmt|,
name|z3
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|wordShifts
condition|)
block|{
case|case
literal|3
case|:
name|z3
operator|=
name|this
operator|.
name|v
index|[
literal|0
index|]
operator|<<
name|bitShiftsInWord
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|z2
operator|=
operator|(
name|this
operator|.
name|v
index|[
literal|0
index|]
operator|<<
name|bitShiftsInWord
operator|)
expr_stmt|;
name|z3
operator|=
operator|(
name|noRestore
condition|?
literal|0
else|:
name|this
operator|.
name|v
index|[
literal|0
index|]
operator|>>>
name|shiftRestore
operator|)
operator||
name|this
operator|.
name|v
index|[
literal|1
index|]
operator|<<
name|bitShiftsInWord
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|z1
operator|=
operator|(
name|this
operator|.
name|v
index|[
literal|0
index|]
operator|<<
name|bitShiftsInWord
operator|)
expr_stmt|;
name|z2
operator|=
operator|(
name|noRestore
condition|?
literal|0
else|:
name|this
operator|.
name|v
index|[
literal|0
index|]
operator|>>>
name|shiftRestore
operator|)
operator||
operator|(
name|this
operator|.
name|v
index|[
literal|1
index|]
operator|<<
name|bitShiftsInWord
operator|)
expr_stmt|;
name|z3
operator|=
operator|(
name|noRestore
condition|?
literal|0
else|:
name|this
operator|.
name|v
index|[
literal|1
index|]
operator|>>>
name|shiftRestore
operator|)
operator||
name|this
operator|.
name|v
index|[
literal|2
index|]
operator|<<
name|bitShiftsInWord
expr_stmt|;
break|break;
case|case
literal|0
case|:
name|z0
operator|=
operator|(
name|this
operator|.
name|v
index|[
literal|0
index|]
operator|<<
name|bitShiftsInWord
operator|)
expr_stmt|;
name|z1
operator|=
operator|(
name|noRestore
condition|?
literal|0
else|:
name|this
operator|.
name|v
index|[
literal|0
index|]
operator|>>>
name|shiftRestore
operator|)
operator||
operator|(
name|this
operator|.
name|v
index|[
literal|1
index|]
operator|<<
name|bitShiftsInWord
operator|)
expr_stmt|;
name|z2
operator|=
operator|(
name|noRestore
condition|?
literal|0
else|:
name|this
operator|.
name|v
index|[
literal|1
index|]
operator|>>>
name|shiftRestore
operator|)
operator||
operator|(
name|this
operator|.
name|v
index|[
literal|2
index|]
operator|<<
name|bitShiftsInWord
operator|)
expr_stmt|;
name|z3
operator|=
operator|(
name|noRestore
condition|?
literal|0
else|:
name|this
operator|.
name|v
index|[
literal|2
index|]
operator|>>>
name|shiftRestore
operator|)
operator||
name|this
operator|.
name|v
index|[
literal|3
index|]
operator|<<
name|bitShiftsInWord
expr_stmt|;
break|break;
default|default:
assert|assert
operator|(
literal|false
operator|)
assert|;
block|}
name|update
argument_list|(
name|z0
argument_list|,
name|z1
argument_list|,
name|z2
argument_list|,
name|z3
argument_list|)
expr_stmt|;
block|}
comment|/**    * Multiplies this value with the given value.    *    * @param left    *          the value to multiply. in AND out.    * @param right    *          the value to multiply. in    */
specifier|private
specifier|static
name|void
name|multiplyArrays4And4To4NoOverflow
parameter_list|(
name|int
index|[]
name|left
parameter_list|,
name|int
index|[]
name|right
parameter_list|)
block|{
assert|assert
operator|(
name|left
operator|.
name|length
operator|==
literal|4
operator|)
assert|;
assert|assert
operator|(
name|right
operator|.
name|length
operator|==
literal|4
operator|)
assert|;
name|long
name|product
decl_stmt|;
name|product
operator|=
operator|(
name|right
index|[
literal|0
index|]
operator|&
name|SqlMathUtil
operator|.
name|LONG_MASK
operator|)
operator|*
operator|(
name|left
index|[
literal|0
index|]
operator|&
name|SqlMathUtil
operator|.
name|LONG_MASK
operator|)
expr_stmt|;
name|int
name|z0
init|=
operator|(
name|int
operator|)
name|product
decl_stmt|;
name|product
operator|=
operator|(
name|right
index|[
literal|0
index|]
operator|&
name|SqlMathUtil
operator|.
name|LONG_MASK
operator|)
operator|*
operator|(
name|left
index|[
literal|1
index|]
operator|&
name|SqlMathUtil
operator|.
name|LONG_MASK
operator|)
operator|+
operator|(
name|right
index|[
literal|1
index|]
operator|&
name|SqlMathUtil
operator|.
name|LONG_MASK
operator|)
operator|*
operator|(
name|left
index|[
literal|0
index|]
operator|&
name|SqlMathUtil
operator|.
name|LONG_MASK
operator|)
operator|+
operator|(
name|product
operator|>>>
literal|32
operator|)
expr_stmt|;
name|int
name|z1
init|=
operator|(
name|int
operator|)
name|product
decl_stmt|;
name|product
operator|=
operator|(
name|right
index|[
literal|0
index|]
operator|&
name|SqlMathUtil
operator|.
name|LONG_MASK
operator|)
operator|*
operator|(
name|left
index|[
literal|2
index|]
operator|&
name|SqlMathUtil
operator|.
name|LONG_MASK
operator|)
operator|+
operator|(
name|right
index|[
literal|1
index|]
operator|&
name|SqlMathUtil
operator|.
name|LONG_MASK
operator|)
operator|*
operator|(
name|left
index|[
literal|1
index|]
operator|&
name|SqlMathUtil
operator|.
name|LONG_MASK
operator|)
operator|+
operator|(
name|right
index|[
literal|2
index|]
operator|&
name|SqlMathUtil
operator|.
name|LONG_MASK
operator|)
operator|*
operator|(
name|left
index|[
literal|0
index|]
operator|&
name|SqlMathUtil
operator|.
name|LONG_MASK
operator|)
operator|+
operator|(
name|product
operator|>>>
literal|32
operator|)
expr_stmt|;
name|int
name|z2
init|=
operator|(
name|int
operator|)
name|product
decl_stmt|;
comment|// v[3]
name|product
operator|=
operator|(
name|right
index|[
literal|0
index|]
operator|&
name|SqlMathUtil
operator|.
name|LONG_MASK
operator|)
operator|*
operator|(
name|left
index|[
literal|3
index|]
operator|&
name|SqlMathUtil
operator|.
name|LONG_MASK
operator|)
operator|+
operator|(
name|right
index|[
literal|1
index|]
operator|&
name|SqlMathUtil
operator|.
name|LONG_MASK
operator|)
operator|*
operator|(
name|left
index|[
literal|2
index|]
operator|&
name|SqlMathUtil
operator|.
name|LONG_MASK
operator|)
operator|+
operator|(
name|right
index|[
literal|2
index|]
operator|&
name|SqlMathUtil
operator|.
name|LONG_MASK
operator|)
operator|*
operator|(
name|left
index|[
literal|1
index|]
operator|&
name|SqlMathUtil
operator|.
name|LONG_MASK
operator|)
operator|+
operator|(
name|right
index|[
literal|3
index|]
operator|&
name|SqlMathUtil
operator|.
name|LONG_MASK
operator|)
operator|*
operator|(
name|left
index|[
literal|0
index|]
operator|&
name|SqlMathUtil
operator|.
name|LONG_MASK
operator|)
operator|+
operator|(
name|product
operator|>>>
literal|32
operator|)
expr_stmt|;
name|int
name|z3
init|=
operator|(
name|int
operator|)
name|product
decl_stmt|;
if|if
condition|(
operator|(
name|product
operator|>>>
literal|32
operator|)
operator|!=
literal|0
condition|)
block|{
name|SqlMathUtil
operator|.
name|throwOverflowException
argument_list|()
expr_stmt|;
block|}
comment|// the combinations below definitely result in overflow
if|if
condition|(
operator|(
name|right
index|[
literal|3
index|]
operator|!=
literal|0
operator|&&
operator|(
name|left
index|[
literal|3
index|]
operator|!=
literal|0
operator|||
name|left
index|[
literal|2
index|]
operator|!=
literal|0
operator|||
name|left
index|[
literal|1
index|]
operator|!=
literal|0
operator|)
operator|)
operator|||
operator|(
name|right
index|[
literal|2
index|]
operator|!=
literal|0
operator|&&
operator|(
name|left
index|[
literal|3
index|]
operator|!=
literal|0
operator|||
name|left
index|[
literal|2
index|]
operator|!=
literal|0
operator|)
operator|)
operator|||
operator|(
name|right
index|[
literal|1
index|]
operator|!=
literal|0
operator|&&
name|left
index|[
literal|3
index|]
operator|!=
literal|0
operator|)
condition|)
block|{
name|SqlMathUtil
operator|.
name|throwOverflowException
argument_list|()
expr_stmt|;
block|}
name|left
index|[
literal|0
index|]
operator|=
name|z0
expr_stmt|;
name|left
index|[
literal|1
index|]
operator|=
name|z1
expr_stmt|;
name|left
index|[
literal|2
index|]
operator|=
name|z2
expr_stmt|;
name|left
index|[
literal|3
index|]
operator|=
name|z3
expr_stmt|;
block|}
specifier|private
specifier|static
name|int
index|[]
name|multiplyArrays4And4To8
parameter_list|(
name|int
index|[]
name|left
parameter_list|,
name|int
index|[]
name|right
parameter_list|)
block|{
assert|assert
operator|(
name|left
operator|.
name|length
operator|==
literal|4
operator|)
assert|;
assert|assert
operator|(
name|right
operator|.
name|length
operator|==
literal|4
operator|)
assert|;
name|long
name|product
decl_stmt|;
comment|// this method could go beyond the integer ranges until we scale back
comment|// so, we need twice more variables.
name|int
index|[]
name|z
init|=
operator|new
name|int
index|[
literal|8
index|]
decl_stmt|;
name|product
operator|=
operator|(
name|right
index|[
literal|0
index|]
operator|&
name|SqlMathUtil
operator|.
name|LONG_MASK
operator|)
operator|*
operator|(
name|left
index|[
literal|0
index|]
operator|&
name|SqlMathUtil
operator|.
name|LONG_MASK
operator|)
expr_stmt|;
name|z
index|[
literal|0
index|]
operator|=
operator|(
name|int
operator|)
name|product
expr_stmt|;
name|product
operator|=
operator|(
name|right
index|[
literal|0
index|]
operator|&
name|SqlMathUtil
operator|.
name|LONG_MASK
operator|)
operator|*
operator|(
name|left
index|[
literal|1
index|]
operator|&
name|SqlMathUtil
operator|.
name|LONG_MASK
operator|)
operator|+
operator|(
name|right
index|[
literal|1
index|]
operator|&
name|SqlMathUtil
operator|.
name|LONG_MASK
operator|)
operator|*
operator|(
name|left
index|[
literal|0
index|]
operator|&
name|SqlMathUtil
operator|.
name|LONG_MASK
operator|)
operator|+
operator|(
name|product
operator|>>>
literal|32
operator|)
expr_stmt|;
name|z
index|[
literal|1
index|]
operator|=
operator|(
name|int
operator|)
name|product
expr_stmt|;
name|product
operator|=
operator|(
name|right
index|[
literal|0
index|]
operator|&
name|SqlMathUtil
operator|.
name|LONG_MASK
operator|)
operator|*
operator|(
name|left
index|[
literal|2
index|]
operator|&
name|SqlMathUtil
operator|.
name|LONG_MASK
operator|)
operator|+
operator|(
name|right
index|[
literal|1
index|]
operator|&
name|SqlMathUtil
operator|.
name|LONG_MASK
operator|)
operator|*
operator|(
name|left
index|[
literal|1
index|]
operator|&
name|SqlMathUtil
operator|.
name|LONG_MASK
operator|)
operator|+
operator|(
name|right
index|[
literal|2
index|]
operator|&
name|SqlMathUtil
operator|.
name|LONG_MASK
operator|)
operator|*
operator|(
name|left
index|[
literal|0
index|]
operator|&
name|SqlMathUtil
operator|.
name|LONG_MASK
operator|)
operator|+
operator|(
name|product
operator|>>>
literal|32
operator|)
expr_stmt|;
name|z
index|[
literal|2
index|]
operator|=
operator|(
name|int
operator|)
name|product
expr_stmt|;
name|product
operator|=
operator|(
name|right
index|[
literal|0
index|]
operator|&
name|SqlMathUtil
operator|.
name|LONG_MASK
operator|)
operator|*
operator|(
name|left
index|[
literal|3
index|]
operator|&
name|SqlMathUtil
operator|.
name|LONG_MASK
operator|)
operator|+
operator|(
name|right
index|[
literal|1
index|]
operator|&
name|SqlMathUtil
operator|.
name|LONG_MASK
operator|)
operator|*
operator|(
name|left
index|[
literal|2
index|]
operator|&
name|SqlMathUtil
operator|.
name|LONG_MASK
operator|)
operator|+
operator|(
name|right
index|[
literal|2
index|]
operator|&
name|SqlMathUtil
operator|.
name|LONG_MASK
operator|)
operator|*
operator|(
name|left
index|[
literal|1
index|]
operator|&
name|SqlMathUtil
operator|.
name|LONG_MASK
operator|)
operator|+
operator|(
name|right
index|[
literal|3
index|]
operator|&
name|SqlMathUtil
operator|.
name|LONG_MASK
operator|)
operator|*
operator|(
name|left
index|[
literal|0
index|]
operator|&
name|SqlMathUtil
operator|.
name|LONG_MASK
operator|)
operator|+
operator|(
name|product
operator|>>>
literal|32
operator|)
expr_stmt|;
name|z
index|[
literal|3
index|]
operator|=
operator|(
name|int
operator|)
name|product
expr_stmt|;
name|product
operator|=
operator|(
name|right
index|[
literal|1
index|]
operator|&
name|SqlMathUtil
operator|.
name|LONG_MASK
operator|)
operator|*
operator|(
name|left
index|[
literal|3
index|]
operator|&
name|SqlMathUtil
operator|.
name|LONG_MASK
operator|)
operator|+
operator|(
name|right
index|[
literal|2
index|]
operator|&
name|SqlMathUtil
operator|.
name|LONG_MASK
operator|)
operator|*
operator|(
name|left
index|[
literal|2
index|]
operator|&
name|SqlMathUtil
operator|.
name|LONG_MASK
operator|)
operator|+
operator|(
name|right
index|[
literal|3
index|]
operator|&
name|SqlMathUtil
operator|.
name|LONG_MASK
operator|)
operator|*
operator|(
name|left
index|[
literal|1
index|]
operator|&
name|SqlMathUtil
operator|.
name|LONG_MASK
operator|)
operator|+
operator|(
name|product
operator|>>>
literal|32
operator|)
expr_stmt|;
name|z
index|[
literal|4
index|]
operator|=
operator|(
name|int
operator|)
name|product
expr_stmt|;
name|product
operator|=
operator|(
name|right
index|[
literal|2
index|]
operator|&
name|SqlMathUtil
operator|.
name|LONG_MASK
operator|)
operator|*
operator|(
name|left
index|[
literal|3
index|]
operator|&
name|SqlMathUtil
operator|.
name|LONG_MASK
operator|)
operator|+
operator|(
name|right
index|[
literal|3
index|]
operator|&
name|SqlMathUtil
operator|.
name|LONG_MASK
operator|)
operator|*
operator|(
name|left
index|[
literal|2
index|]
operator|&
name|SqlMathUtil
operator|.
name|LONG_MASK
operator|)
operator|+
operator|(
name|product
operator|>>>
literal|32
operator|)
expr_stmt|;
name|z
index|[
literal|5
index|]
operator|=
operator|(
name|int
operator|)
name|product
expr_stmt|;
comment|// v[1], v[0]
name|product
operator|=
operator|(
name|right
index|[
literal|3
index|]
operator|&
name|SqlMathUtil
operator|.
name|LONG_MASK
operator|)
operator|*
operator|(
name|left
index|[
literal|3
index|]
operator|&
name|SqlMathUtil
operator|.
name|LONG_MASK
operator|)
operator|+
operator|(
name|product
operator|>>>
literal|32
operator|)
expr_stmt|;
name|z
index|[
literal|6
index|]
operator|=
operator|(
name|int
operator|)
name|product
expr_stmt|;
name|z
index|[
literal|7
index|]
operator|=
call|(
name|int
call|)
argument_list|(
name|product
operator|>>>
literal|32
argument_list|)
expr_stmt|;
return|return
name|z
return|;
block|}
specifier|private
specifier|static
name|void
name|incrementArray
parameter_list|(
name|int
index|[]
name|array
parameter_list|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|INT_COUNT
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|array
index|[
name|i
index|]
operator|!=
name|SqlMathUtil
operator|.
name|FULLBITS_32
condition|)
block|{
name|array
index|[
name|i
index|]
operator|=
call|(
name|int
call|)
argument_list|(
operator|(
name|array
index|[
name|i
index|]
operator|&
name|SqlMathUtil
operator|.
name|LONG_MASK
operator|)
operator|+
literal|1L
argument_list|)
expr_stmt|;
break|break;
block|}
name|array
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|i
operator|==
name|INT_COUNT
operator|-
literal|1
condition|)
block|{
name|SqlMathUtil
operator|.
name|throwOverflowException
argument_list|()
expr_stmt|;
block|}
block|}
block|}
specifier|private
specifier|static
name|void
name|decrementArray
parameter_list|(
name|int
index|[]
name|array
parameter_list|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|INT_COUNT
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|array
index|[
name|i
index|]
operator|!=
literal|0
condition|)
block|{
name|array
index|[
name|i
index|]
operator|=
call|(
name|int
call|)
argument_list|(
operator|(
name|array
index|[
name|i
index|]
operator|&
name|SqlMathUtil
operator|.
name|LONG_MASK
operator|)
operator|-
literal|1L
argument_list|)
expr_stmt|;
break|break;
block|}
name|array
index|[
name|i
index|]
operator|=
name|SqlMathUtil
operator|.
name|FULLBITS_32
expr_stmt|;
if|if
condition|(
name|i
operator|==
name|INT_COUNT
operator|-
literal|1
condition|)
block|{
name|SqlMathUtil
operator|.
name|throwOverflowException
argument_list|()
expr_stmt|;
block|}
block|}
block|}
comment|/** common implementation of difference. */
specifier|private
specifier|static
name|byte
name|differenceInternal
parameter_list|(
name|UnsignedInt128
name|left
parameter_list|,
name|int
index|[]
name|r
parameter_list|,
name|UnsignedInt128
name|result
parameter_list|)
block|{
name|int
name|cmp
init|=
name|left
operator|.
name|compareTo
argument_list|(
name|r
argument_list|)
decl_stmt|;
if|if
condition|(
name|cmp
operator|==
literal|0
condition|)
block|{
name|result
operator|.
name|zeroClear
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
name|long
name|sum
init|=
literal|0L
decl_stmt|;
if|if
condition|(
name|cmp
operator|>
literal|0
condition|)
block|{
comment|// left is larger
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|INT_COUNT
condition|;
operator|++
name|i
control|)
block|{
name|sum
operator|=
operator|(
name|left
operator|.
name|v
index|[
name|i
index|]
operator|&
name|SqlMathUtil
operator|.
name|LONG_MASK
operator|)
operator|-
operator|(
name|r
index|[
name|i
index|]
operator|&
name|SqlMathUtil
operator|.
name|LONG_MASK
operator|)
operator|-
operator|(
operator|(
name|int
operator|)
operator|-
operator|(
name|sum
operator|>>
literal|32
operator|)
operator|)
expr_stmt|;
name|result
operator|.
name|v
index|[
name|i
index|]
operator|=
operator|(
name|int
operator|)
name|sum
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// right is larger
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|INT_COUNT
condition|;
operator|++
name|i
control|)
block|{
name|sum
operator|=
operator|(
name|r
index|[
name|i
index|]
operator|&
name|SqlMathUtil
operator|.
name|LONG_MASK
operator|)
operator|-
operator|(
name|left
operator|.
name|v
index|[
name|i
index|]
operator|&
name|SqlMathUtil
operator|.
name|LONG_MASK
operator|)
operator|-
operator|(
operator|(
name|int
operator|)
operator|-
operator|(
name|sum
operator|>>
literal|32
operator|)
operator|)
expr_stmt|;
name|result
operator|.
name|v
index|[
name|i
index|]
operator|=
operator|(
name|int
operator|)
name|sum
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|sum
operator|>>
literal|32
operator|)
operator|!=
literal|0
condition|)
block|{
name|SqlMathUtil
operator|.
name|throwOverflowException
argument_list|()
expr_stmt|;
block|}
name|result
operator|.
name|updateCount
argument_list|()
expr_stmt|;
return|return
name|cmp
operator|>
literal|0
condition|?
operator|(
name|byte
operator|)
literal|1
else|:
operator|(
name|byte
operator|)
operator|-
literal|1
return|;
block|}
comment|/**    * @see #compareTo(UnsignedInt128)    */
specifier|private
specifier|static
name|int
name|compareTo
parameter_list|(
name|int
name|l0
parameter_list|,
name|int
name|l1
parameter_list|,
name|int
name|l2
parameter_list|,
name|int
name|l3
parameter_list|,
name|int
name|r0
parameter_list|,
name|int
name|r1
parameter_list|,
name|int
name|r2
parameter_list|,
name|int
name|r3
parameter_list|)
block|{
if|if
condition|(
name|l3
operator|!=
name|r3
condition|)
block|{
return|return
name|SqlMathUtil
operator|.
name|compareUnsignedInt
argument_list|(
name|l3
argument_list|,
name|r3
argument_list|)
return|;
block|}
if|if
condition|(
name|l2
operator|!=
name|r2
condition|)
block|{
return|return
name|SqlMathUtil
operator|.
name|compareUnsignedInt
argument_list|(
name|l2
argument_list|,
name|r2
argument_list|)
return|;
block|}
if|if
condition|(
name|l1
operator|!=
name|r1
condition|)
block|{
return|return
name|SqlMathUtil
operator|.
name|compareUnsignedInt
argument_list|(
name|l1
argument_list|,
name|r1
argument_list|)
return|;
block|}
if|if
condition|(
name|l0
operator|!=
name|r0
condition|)
block|{
return|return
name|SqlMathUtil
operator|.
name|compareUnsignedInt
argument_list|(
name|l0
argument_list|,
name|r0
argument_list|)
return|;
block|}
return|return
literal|0
return|;
block|}
comment|/**    * @param array    * @param tenScale    * @return Whether it overflowed    */
specifier|private
specifier|static
name|boolean
name|scaleUpTenArray
parameter_list|(
name|int
index|[]
name|array
parameter_list|,
name|short
name|tenScale
parameter_list|)
block|{
while|while
condition|(
name|tenScale
operator|>
literal|0
condition|)
block|{
name|long
name|sum
init|=
literal|0L
decl_stmt|;
name|int
name|powerTen
init|=
name|Math
operator|.
name|min
argument_list|(
name|tenScale
argument_list|,
name|SqlMathUtil
operator|.
name|MAX_POWER_TEN_INT31
argument_list|)
decl_stmt|;
name|tenScale
operator|-=
name|powerTen
expr_stmt|;
specifier|final
name|long
name|rightUnsigned
init|=
name|SqlMathUtil
operator|.
name|POWER_TENS_INT31
index|[
name|powerTen
index|]
operator|&
name|SqlMathUtil
operator|.
name|LONG_MASK
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|INT_COUNT
condition|;
operator|++
name|i
control|)
block|{
name|sum
operator|=
operator|(
name|array
index|[
name|i
index|]
operator|&
name|SqlMathUtil
operator|.
name|LONG_MASK
operator|)
operator|*
name|rightUnsigned
operator|+
operator|(
name|sum
operator|>>>
literal|32
operator|)
expr_stmt|;
name|array
index|[
name|i
index|]
operator|=
operator|(
name|int
operator|)
name|sum
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|sum
operator|>>
literal|32
operator|)
operator|!=
literal|0
condition|)
block|{
comment|// overflow means this is smaller
return|return
literal|true
return|;
block|}
block|}
return|return
literal|false
return|;
block|}
comment|/**    * Scales down the given array (4 elements) for 10**tenScale. This method is    * only used from add/subtract/compare, and most likely with smaller tenScale.    * So, this method is not as optimized as    * {@link #scaleDownTenArray8RoundUp(int[], short)}.    *    * @param array    *          array to scale down. in AND out. length must be 4.    * @param tenScale    *          distance to scale down    */
specifier|private
specifier|static
name|void
name|scaleDownTenArray4RoundUp
parameter_list|(
name|int
index|[]
name|array
parameter_list|,
name|short
name|tenScale
parameter_list|)
block|{
name|scaleDownFiveArray
argument_list|(
name|array
argument_list|,
name|tenScale
argument_list|)
expr_stmt|;
name|shiftRightArray
argument_list|(
name|tenScale
argument_list|,
name|array
argument_list|,
name|array
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
comment|/**    * Scales down the given array (8 elements) for 10**tenScale. This method is    * frequently called from multiply(), so highly optimized. It's lengthy, but    * this is inevitable to avoid array/object creation.<h2>Summary of this    * method</h2>    *<p>    * This method employs division by inverse multiplication (except easy cases).    * because all inverses of powers of tens are pre-calculated, this is much    * faster than doing divisions. The matrix multiplication benchmark hit 3x    * performance with this. because the inverse is a little bit smaller than    * real value, the result is same or smaller than accurate answer, not larger.    * we take care of it after the first multiplication.    *</p>    *<p>    * Then, multiply it with power of tens (which is accurate) to correct +1    * error and rounding up. let D = array - z * power: if D>= power/2, then    * ++z. Otherwise, do nothing.    *</p>    *    * @param array    *          array to scale down. in AND out. length must be 8.    * @param tenScale    *          distance to scale down    */
specifier|private
specifier|static
name|void
name|scaleDownTenArray8RoundUp
parameter_list|(
name|int
index|[]
name|array
parameter_list|,
name|short
name|tenScale
parameter_list|)
block|{
assert|assert
operator|(
name|array
operator|.
name|length
operator|==
literal|8
operator|)
assert|;
if|if
condition|(
name|tenScale
operator|>
name|MAX_DIGITS
condition|)
block|{
comment|// then definitely this will end up zero.
name|Arrays
operator|.
name|fill
argument_list|(
name|array
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|tenScale
operator|<=
name|SqlMathUtil
operator|.
name|MAX_POWER_TEN_INT31
condition|)
block|{
name|int
name|divisor
init|=
name|SqlMathUtil
operator|.
name|POWER_TENS_INT31
index|[
name|tenScale
index|]
decl_stmt|;
assert|assert
operator|(
name|divisor
operator|>
literal|0
operator|)
assert|;
name|boolean
name|round
init|=
name|divideCheckRound
argument_list|(
name|array
argument_list|,
name|divisor
argument_list|)
decl_stmt|;
if|if
condition|(
name|round
condition|)
block|{
name|incrementArray
argument_list|(
name|array
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
comment|// division by inverse multiplication.
specifier|final
name|int
index|[]
name|inverse
init|=
name|SqlMathUtil
operator|.
name|INVERSE_POWER_TENS_INT128
index|[
name|tenScale
index|]
operator|.
name|v
decl_stmt|;
specifier|final
name|int
name|inverseWordShift
init|=
name|SqlMathUtil
operator|.
name|INVERSE_POWER_TENS_INT128_WORD_SHIFTS
index|[
name|tenScale
index|]
decl_stmt|;
assert|assert
operator|(
name|inverseWordShift
operator|<=
literal|3
operator|)
assert|;
assert|assert
operator|(
name|inverse
index|[
literal|3
index|]
operator|!=
literal|0
operator|)
assert|;
for|for
control|(
name|int
name|i
init|=
literal|5
operator|+
name|inverseWordShift
init|;
name|i
operator|<
literal|8
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|array
index|[
name|i
index|]
operator|!=
literal|0
condition|)
block|{
name|SqlMathUtil
operator|.
name|throwOverflowException
argument_list|()
expr_stmt|;
comment|// because inverse[3] is
comment|// not zero
block|}
block|}
name|int
name|z4
init|=
literal|0
decl_stmt|,
name|z5
init|=
literal|0
decl_stmt|,
name|z6
init|=
literal|0
decl_stmt|,
name|z7
init|=
literal|0
decl_stmt|;
comment|// because inverse is scaled 2^128,
comment|// these will become v0-v3
name|int
name|z8
init|=
literal|0
decl_stmt|,
name|z9
init|=
literal|0
decl_stmt|,
name|z10
init|=
literal|0
decl_stmt|;
comment|// for wordshift
name|long
name|product
init|=
literal|0L
decl_stmt|;
name|product
operator|+=
operator|(
name|inverse
index|[
literal|0
index|]
operator|&
name|SqlMathUtil
operator|.
name|LONG_MASK
operator|)
operator|*
operator|(
name|array
index|[
literal|4
index|]
operator|&
name|SqlMathUtil
operator|.
name|LONG_MASK
operator|)
operator|+
operator|(
name|inverse
index|[
literal|1
index|]
operator|&
name|SqlMathUtil
operator|.
name|LONG_MASK
operator|)
operator|*
operator|(
name|array
index|[
literal|3
index|]
operator|&
name|SqlMathUtil
operator|.
name|LONG_MASK
operator|)
operator|+
operator|(
name|inverse
index|[
literal|2
index|]
operator|&
name|SqlMathUtil
operator|.
name|LONG_MASK
operator|)
operator|*
operator|(
name|array
index|[
literal|2
index|]
operator|&
name|SqlMathUtil
operator|.
name|LONG_MASK
operator|)
operator|+
operator|(
name|inverse
index|[
literal|3
index|]
operator|&
name|SqlMathUtil
operator|.
name|LONG_MASK
operator|)
operator|*
operator|(
name|array
index|[
literal|1
index|]
operator|&
name|SqlMathUtil
operator|.
name|LONG_MASK
operator|)
expr_stmt|;
name|z4
operator|=
operator|(
name|int
operator|)
name|product
expr_stmt|;
name|product
operator|>>>=
literal|32
expr_stmt|;
name|product
operator|+=
operator|(
name|inverse
index|[
literal|0
index|]
operator|&
name|SqlMathUtil
operator|.
name|LONG_MASK
operator|)
operator|*
operator|(
name|array
index|[
literal|5
index|]
operator|&
name|SqlMathUtil
operator|.
name|LONG_MASK
operator|)
operator|+
operator|(
name|inverse
index|[
literal|1
index|]
operator|&
name|SqlMathUtil
operator|.
name|LONG_MASK
operator|)
operator|*
operator|(
name|array
index|[
literal|4
index|]
operator|&
name|SqlMathUtil
operator|.
name|LONG_MASK
operator|)
operator|+
operator|(
name|inverse
index|[
literal|2
index|]
operator|&
name|SqlMathUtil
operator|.
name|LONG_MASK
operator|)
operator|*
operator|(
name|array
index|[
literal|3
index|]
operator|&
name|SqlMathUtil
operator|.
name|LONG_MASK
operator|)
operator|+
operator|(
name|inverse
index|[
literal|3
index|]
operator|&
name|SqlMathUtil
operator|.
name|LONG_MASK
operator|)
operator|*
operator|(
name|array
index|[
literal|2
index|]
operator|&
name|SqlMathUtil
operator|.
name|LONG_MASK
operator|)
expr_stmt|;
name|z5
operator|=
operator|(
name|int
operator|)
name|product
expr_stmt|;
name|product
operator|>>>=
literal|32
expr_stmt|;
name|product
operator|+=
operator|(
name|inverse
index|[
literal|0
index|]
operator|&
name|SqlMathUtil
operator|.
name|LONG_MASK
operator|)
operator|*
operator|(
name|array
index|[
literal|6
index|]
operator|&
name|SqlMathUtil
operator|.
name|LONG_MASK
operator|)
operator|+
operator|(
name|inverse
index|[
literal|1
index|]
operator|&
name|SqlMathUtil
operator|.
name|LONG_MASK
operator|)
operator|*
operator|(
name|array
index|[
literal|5
index|]
operator|&
name|SqlMathUtil
operator|.
name|LONG_MASK
operator|)
operator|+
operator|(
name|inverse
index|[
literal|2
index|]
operator|&
name|SqlMathUtil
operator|.
name|LONG_MASK
operator|)
operator|*
operator|(
name|array
index|[
literal|4
index|]
operator|&
name|SqlMathUtil
operator|.
name|LONG_MASK
operator|)
operator|+
operator|(
name|inverse
index|[
literal|3
index|]
operator|&
name|SqlMathUtil
operator|.
name|LONG_MASK
operator|)
operator|*
operator|(
name|array
index|[
literal|3
index|]
operator|&
name|SqlMathUtil
operator|.
name|LONG_MASK
operator|)
expr_stmt|;
name|z6
operator|=
operator|(
name|int
operator|)
name|product
expr_stmt|;
name|product
operator|>>>=
literal|32
expr_stmt|;
name|product
operator|+=
operator|(
name|inverse
index|[
literal|0
index|]
operator|&
name|SqlMathUtil
operator|.
name|LONG_MASK
operator|)
operator|*
operator|(
name|array
index|[
literal|7
index|]
operator|&
name|SqlMathUtil
operator|.
name|LONG_MASK
operator|)
operator|+
operator|(
name|inverse
index|[
literal|1
index|]
operator|&
name|SqlMathUtil
operator|.
name|LONG_MASK
operator|)
operator|*
operator|(
name|array
index|[
literal|6
index|]
operator|&
name|SqlMathUtil
operator|.
name|LONG_MASK
operator|)
operator|+
operator|(
name|inverse
index|[
literal|2
index|]
operator|&
name|SqlMathUtil
operator|.
name|LONG_MASK
operator|)
operator|*
operator|(
name|array
index|[
literal|5
index|]
operator|&
name|SqlMathUtil
operator|.
name|LONG_MASK
operator|)
operator|+
operator|(
name|inverse
index|[
literal|3
index|]
operator|&
name|SqlMathUtil
operator|.
name|LONG_MASK
operator|)
operator|*
operator|(
name|array
index|[
literal|4
index|]
operator|&
name|SqlMathUtil
operator|.
name|LONG_MASK
operator|)
expr_stmt|;
name|z7
operator|=
operator|(
name|int
operator|)
name|product
expr_stmt|;
name|product
operator|>>>=
literal|32
expr_stmt|;
if|if
condition|(
name|inverseWordShift
operator|>=
literal|1
condition|)
block|{
name|product
operator|+=
operator|(
name|inverse
index|[
literal|1
index|]
operator|&
name|SqlMathUtil
operator|.
name|LONG_MASK
operator|)
operator|*
operator|(
name|array
index|[
literal|7
index|]
operator|&
name|SqlMathUtil
operator|.
name|LONG_MASK
operator|)
operator|+
operator|(
name|inverse
index|[
literal|2
index|]
operator|&
name|SqlMathUtil
operator|.
name|LONG_MASK
operator|)
operator|*
operator|(
name|array
index|[
literal|6
index|]
operator|&
name|SqlMathUtil
operator|.
name|LONG_MASK
operator|)
operator|+
operator|(
name|inverse
index|[
literal|3
index|]
operator|&
name|SqlMathUtil
operator|.
name|LONG_MASK
operator|)
operator|*
operator|(
name|array
index|[
literal|5
index|]
operator|&
name|SqlMathUtil
operator|.
name|LONG_MASK
operator|)
expr_stmt|;
name|z8
operator|=
operator|(
name|int
operator|)
name|product
expr_stmt|;
name|product
operator|>>>=
literal|32
expr_stmt|;
if|if
condition|(
name|inverseWordShift
operator|>=
literal|2
condition|)
block|{
name|product
operator|+=
operator|(
name|inverse
index|[
literal|2
index|]
operator|&
name|SqlMathUtil
operator|.
name|LONG_MASK
operator|)
operator|*
operator|(
name|array
index|[
literal|7
index|]
operator|&
name|SqlMathUtil
operator|.
name|LONG_MASK
operator|)
operator|+
operator|(
name|inverse
index|[
literal|3
index|]
operator|&
name|SqlMathUtil
operator|.
name|LONG_MASK
operator|)
operator|*
operator|(
name|array
index|[
literal|6
index|]
operator|&
name|SqlMathUtil
operator|.
name|LONG_MASK
operator|)
expr_stmt|;
name|z9
operator|=
operator|(
name|int
operator|)
name|product
expr_stmt|;
name|product
operator|>>>=
literal|32
expr_stmt|;
if|if
condition|(
name|inverseWordShift
operator|>=
literal|3
condition|)
block|{
name|product
operator|+=
operator|(
name|inverse
index|[
literal|3
index|]
operator|&
name|SqlMathUtil
operator|.
name|LONG_MASK
operator|)
operator|*
operator|(
name|array
index|[
literal|7
index|]
operator|&
name|SqlMathUtil
operator|.
name|LONG_MASK
operator|)
expr_stmt|;
name|z10
operator|=
operator|(
name|int
operator|)
name|product
expr_stmt|;
name|product
operator|>>>=
literal|32
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|product
operator|!=
literal|0
condition|)
block|{
name|SqlMathUtil
operator|.
name|throwOverflowException
argument_list|()
expr_stmt|;
block|}
comment|// if inverse is word-shifted for accuracy, shift it back here.
switch|switch
condition|(
name|inverseWordShift
condition|)
block|{
case|case
literal|1
case|:
name|z4
operator|=
name|z5
expr_stmt|;
name|z5
operator|=
name|z6
expr_stmt|;
name|z6
operator|=
name|z7
expr_stmt|;
name|z7
operator|=
name|z8
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|z4
operator|=
name|z6
expr_stmt|;
name|z5
operator|=
name|z7
expr_stmt|;
name|z6
operator|=
name|z8
expr_stmt|;
name|z7
operator|=
name|z9
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|z4
operator|=
name|z7
expr_stmt|;
name|z5
operator|=
name|z8
expr_stmt|;
name|z6
operator|=
name|z9
expr_stmt|;
name|z7
operator|=
name|z10
expr_stmt|;
break|break;
default|default:
break|break;
block|}
comment|// now, correct +1 error and rounding up.
specifier|final
name|int
index|[]
name|power
init|=
name|SqlMathUtil
operator|.
name|POWER_TENS_INT128
index|[
name|tenScale
index|]
operator|.
name|v
decl_stmt|;
specifier|final
name|int
index|[]
name|half
init|=
name|SqlMathUtil
operator|.
name|ROUND_POWER_TENS_INT128
index|[
name|tenScale
index|]
operator|.
name|v
decl_stmt|;
name|int
name|d0
decl_stmt|,
name|d1
decl_stmt|,
name|d2
decl_stmt|,
name|d3
decl_stmt|,
name|d4
decl_stmt|;
name|product
operator|=
operator|(
name|array
index|[
literal|0
index|]
operator|&
name|SqlMathUtil
operator|.
name|LONG_MASK
operator|)
operator|-
operator|(
name|power
index|[
literal|0
index|]
operator|&
name|SqlMathUtil
operator|.
name|LONG_MASK
operator|)
operator|*
operator|(
name|z4
operator|&
name|SqlMathUtil
operator|.
name|LONG_MASK
operator|)
expr_stmt|;
name|d0
operator|=
operator|(
name|int
operator|)
name|product
expr_stmt|;
name|product
operator|=
operator|(
name|array
index|[
literal|1
index|]
operator|&
name|SqlMathUtil
operator|.
name|LONG_MASK
operator|)
operator|-
operator|(
name|power
index|[
literal|0
index|]
operator|&
name|SqlMathUtil
operator|.
name|LONG_MASK
operator|)
operator|*
operator|(
name|z5
operator|&
name|SqlMathUtil
operator|.
name|LONG_MASK
operator|)
operator|-
operator|(
name|power
index|[
literal|1
index|]
operator|&
name|SqlMathUtil
operator|.
name|LONG_MASK
operator|)
operator|*
operator|(
name|z4
operator|&
name|SqlMathUtil
operator|.
name|LONG_MASK
operator|)
operator|-
operator|(
operator|(
name|int
operator|)
operator|-
operator|(
name|product
operator|>>
literal|32
operator|)
operator|)
expr_stmt|;
name|d1
operator|=
operator|(
name|int
operator|)
name|product
expr_stmt|;
name|product
operator|=
operator|(
name|array
index|[
literal|2
index|]
operator|&
name|SqlMathUtil
operator|.
name|LONG_MASK
operator|)
operator|-
operator|(
name|power
index|[
literal|0
index|]
operator|&
name|SqlMathUtil
operator|.
name|LONG_MASK
operator|)
operator|*
operator|(
name|z6
operator|&
name|SqlMathUtil
operator|.
name|LONG_MASK
operator|)
operator|-
operator|(
name|power
index|[
literal|1
index|]
operator|&
name|SqlMathUtil
operator|.
name|LONG_MASK
operator|)
operator|*
operator|(
name|z5
operator|&
name|SqlMathUtil
operator|.
name|LONG_MASK
operator|)
operator|-
operator|(
name|power
index|[
literal|2
index|]
operator|&
name|SqlMathUtil
operator|.
name|LONG_MASK
operator|)
operator|*
operator|(
name|z4
operator|&
name|SqlMathUtil
operator|.
name|LONG_MASK
operator|)
operator|-
operator|(
operator|(
name|int
operator|)
operator|-
operator|(
name|product
operator|>>
literal|32
operator|)
operator|)
expr_stmt|;
name|d2
operator|=
operator|(
name|int
operator|)
name|product
expr_stmt|;
name|product
operator|=
operator|(
name|array
index|[
literal|3
index|]
operator|&
name|SqlMathUtil
operator|.
name|LONG_MASK
operator|)
operator|-
operator|(
name|power
index|[
literal|0
index|]
operator|&
name|SqlMathUtil
operator|.
name|LONG_MASK
operator|)
operator|*
operator|(
name|z7
operator|&
name|SqlMathUtil
operator|.
name|LONG_MASK
operator|)
operator|-
operator|(
name|power
index|[
literal|1
index|]
operator|&
name|SqlMathUtil
operator|.
name|LONG_MASK
operator|)
operator|*
operator|(
name|z6
operator|&
name|SqlMathUtil
operator|.
name|LONG_MASK
operator|)
operator|-
operator|(
name|power
index|[
literal|2
index|]
operator|&
name|SqlMathUtil
operator|.
name|LONG_MASK
operator|)
operator|*
operator|(
name|z5
operator|&
name|SqlMathUtil
operator|.
name|LONG_MASK
operator|)
operator|-
operator|(
name|power
index|[
literal|3
index|]
operator|&
name|SqlMathUtil
operator|.
name|LONG_MASK
operator|)
operator|*
operator|(
name|z4
operator|&
name|SqlMathUtil
operator|.
name|LONG_MASK
operator|)
operator|-
operator|(
operator|(
name|int
operator|)
operator|-
operator|(
name|product
operator|>>
literal|32
operator|)
operator|)
expr_stmt|;
name|d3
operator|=
operator|(
name|int
operator|)
name|product
expr_stmt|;
name|product
operator|=
operator|(
name|array
index|[
literal|4
index|]
operator|&
name|SqlMathUtil
operator|.
name|LONG_MASK
operator|)
operator|-
operator|(
name|power
index|[
literal|1
index|]
operator|&
name|SqlMathUtil
operator|.
name|LONG_MASK
operator|)
operator|*
operator|(
name|z7
operator|&
name|SqlMathUtil
operator|.
name|LONG_MASK
operator|)
operator|-
operator|(
name|power
index|[
literal|2
index|]
operator|&
name|SqlMathUtil
operator|.
name|LONG_MASK
operator|)
operator|*
operator|(
name|z6
operator|&
name|SqlMathUtil
operator|.
name|LONG_MASK
operator|)
operator|-
operator|(
name|power
index|[
literal|3
index|]
operator|&
name|SqlMathUtil
operator|.
name|LONG_MASK
operator|)
operator|*
operator|(
name|z5
operator|&
name|SqlMathUtil
operator|.
name|LONG_MASK
operator|)
operator|-
operator|(
operator|(
name|int
operator|)
operator|-
operator|(
name|product
operator|>>
literal|32
operator|)
operator|)
expr_stmt|;
name|d4
operator|=
operator|(
name|int
operator|)
name|product
expr_stmt|;
comment|// If the difference is larger than 2^128 (d4 != 0), then D is
comment|// definitely larger than power, so increment.
comment|// otherwise, compare it with power and half.
name|boolean
name|increment
init|=
operator|(
name|d4
operator|!=
literal|0
operator|)
operator|||
operator|(
name|compareTo
argument_list|(
name|d0
argument_list|,
name|d1
argument_list|,
name|d2
argument_list|,
name|d3
argument_list|,
name|half
index|[
literal|0
index|]
argument_list|,
name|half
index|[
literal|1
index|]
argument_list|,
name|half
index|[
literal|2
index|]
argument_list|,
name|half
index|[
literal|3
index|]
argument_list|)
operator|>=
literal|0
operator|)
decl_stmt|;
name|array
index|[
literal|0
index|]
operator|=
name|z4
expr_stmt|;
name|array
index|[
literal|1
index|]
operator|=
name|z5
expr_stmt|;
name|array
index|[
literal|2
index|]
operator|=
name|z6
expr_stmt|;
name|array
index|[
literal|3
index|]
operator|=
name|z7
expr_stmt|;
if|if
condition|(
name|increment
condition|)
block|{
name|incrementArray
argument_list|(
name|array
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Scales down the given array for 5**fiveScale.    *    * @param array    *          array to scale down    * @param fiveScale    *          distance to scale down    * @return Whether it requires incrementing if rounding    */
specifier|private
specifier|static
name|boolean
name|scaleDownFiveArray
parameter_list|(
name|int
index|[]
name|array
parameter_list|,
name|short
name|fiveScale
parameter_list|)
block|{
while|while
condition|(
literal|true
condition|)
block|{
name|int
name|powerFive
init|=
name|Math
operator|.
name|min
argument_list|(
name|fiveScale
argument_list|,
name|SqlMathUtil
operator|.
name|MAX_POWER_FIVE_INT31
argument_list|)
decl_stmt|;
name|fiveScale
operator|-=
name|powerFive
expr_stmt|;
name|int
name|divisor
init|=
name|SqlMathUtil
operator|.
name|POWER_FIVES_INT31
index|[
name|powerFive
index|]
decl_stmt|;
assert|assert
operator|(
name|divisor
operator|>
literal|0
operator|)
assert|;
if|if
condition|(
name|fiveScale
operator|==
literal|0
condition|)
block|{
return|return
name|divideCheckRound
argument_list|(
name|array
argument_list|,
name|divisor
argument_list|)
return|;
block|}
else|else
block|{
name|divideCheckRound
argument_list|(
name|array
argument_list|,
name|divisor
argument_list|)
expr_stmt|;
block|}
block|}
block|}
specifier|private
specifier|static
name|boolean
name|divideCheckRound
parameter_list|(
name|int
index|[]
name|array
parameter_list|,
name|int
name|divisor
parameter_list|)
block|{
name|long
name|remainder
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
name|array
operator|.
name|length
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
operator|--
name|i
control|)
block|{
name|remainder
operator|=
operator|(
operator|(
name|array
index|[
name|i
index|]
operator|&
name|SqlMathUtil
operator|.
name|LONG_MASK
operator|)
operator|+
operator|(
name|remainder
operator|<<
literal|32
operator|)
operator|)
expr_stmt|;
name|array
index|[
name|i
index|]
operator|=
call|(
name|int
call|)
argument_list|(
name|remainder
operator|/
name|divisor
argument_list|)
expr_stmt|;
name|remainder
operator|%=
name|divisor
expr_stmt|;
block|}
return|return
operator|(
name|remainder
operator|>=
operator|(
name|divisor
operator|>>
literal|1
operator|)
operator|)
return|;
block|}
specifier|private
specifier|static
name|void
name|scaleDownFiveArrayRoundUp
parameter_list|(
name|int
index|[]
name|array
parameter_list|,
name|short
name|tenScale
parameter_list|)
block|{
name|boolean
name|rounding
init|=
name|scaleDownFiveArray
argument_list|(
name|array
argument_list|,
name|tenScale
argument_list|)
decl_stmt|;
if|if
condition|(
name|rounding
condition|)
block|{
name|incrementArray
argument_list|(
name|array
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Internal method to apply the result of multiplication with right-shifting.    * This method does round the value while right-shifting (SQL Numeric    * semantics).    *    * @param rightShifts    *          distance of right-shifts    */
specifier|private
specifier|static
name|void
name|shiftRightArray
parameter_list|(
name|int
name|rightShifts
parameter_list|,
name|int
index|[]
name|z
parameter_list|,
name|int
index|[]
name|result
parameter_list|,
name|boolean
name|round
parameter_list|)
block|{
assert|assert
operator|(
name|rightShifts
operator|>=
literal|0
operator|)
assert|;
if|if
condition|(
name|rightShifts
operator|==
literal|0
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|INT_COUNT
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|z
index|[
name|i
operator|+
name|INT_COUNT
index|]
operator|!=
literal|0
condition|)
block|{
name|SqlMathUtil
operator|.
name|throwOverflowException
argument_list|()
expr_stmt|;
block|}
block|}
name|result
index|[
literal|0
index|]
operator|=
name|z
index|[
literal|0
index|]
expr_stmt|;
name|result
index|[
literal|1
index|]
operator|=
name|z
index|[
literal|1
index|]
expr_stmt|;
name|result
index|[
literal|2
index|]
operator|=
name|z
index|[
literal|2
index|]
expr_stmt|;
name|result
index|[
literal|3
index|]
operator|=
name|z
index|[
literal|3
index|]
expr_stmt|;
block|}
else|else
block|{
specifier|final
name|int
name|wordShifts
init|=
name|rightShifts
operator|/
literal|32
decl_stmt|;
specifier|final
name|int
name|bitShiftsInWord
init|=
name|rightShifts
operator|%
literal|32
decl_stmt|;
specifier|final
name|int
name|shiftRestore
init|=
literal|32
operator|-
name|bitShiftsInWord
decl_stmt|;
comment|// check this because "123<< 32" will be 123.
specifier|final
name|boolean
name|noRestore
init|=
name|bitShiftsInWord
operator|==
literal|0
decl_stmt|;
comment|// overflow checks
if|if
condition|(
name|z
operator|.
name|length
operator|>
name|INT_COUNT
condition|)
block|{
if|if
condition|(
name|wordShifts
operator|+
name|INT_COUNT
operator|<
name|z
operator|.
name|length
operator|&&
operator|(
name|z
index|[
name|wordShifts
operator|+
name|INT_COUNT
index|]
operator|>>>
name|bitShiftsInWord
operator|)
operator|!=
literal|0
condition|)
block|{
name|SqlMathUtil
operator|.
name|throwOverflowException
argument_list|()
expr_stmt|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<
name|INT_COUNT
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|i
operator|+
name|wordShifts
operator|<
name|z
operator|.
name|length
operator|-
name|INT_COUNT
operator|&&
name|z
index|[
name|i
operator|+
name|wordShifts
operator|+
name|INT_COUNT
index|]
operator|!=
literal|0
condition|)
block|{
name|SqlMathUtil
operator|.
name|throwOverflowException
argument_list|()
expr_stmt|;
block|}
block|}
block|}
comment|// check round-ups before settings values to result.
comment|// be aware that result could be the same object as z.
name|boolean
name|roundCarry
init|=
literal|false
decl_stmt|;
if|if
condition|(
name|round
condition|)
block|{
if|if
condition|(
name|bitShiftsInWord
operator|==
literal|0
condition|)
block|{
assert|assert
operator|(
name|wordShifts
operator|>
literal|0
operator|)
assert|;
name|roundCarry
operator|=
name|z
index|[
name|wordShifts
operator|-
literal|1
index|]
operator|<
literal|0
expr_stmt|;
block|}
else|else
block|{
name|roundCarry
operator|=
operator|(
name|z
index|[
name|wordShifts
index|]
operator|&
operator|(
literal|1
operator|<<
operator|(
name|bitShiftsInWord
operator|-
literal|1
operator|)
operator|)
operator|)
operator|!=
literal|0
expr_stmt|;
block|}
block|}
comment|// extract the values.
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|INT_COUNT
condition|;
operator|++
name|i
control|)
block|{
name|int
name|val
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|noRestore
operator|&&
name|i
operator|+
name|wordShifts
operator|+
literal|1
operator|<
name|z
operator|.
name|length
condition|)
block|{
name|val
operator|=
name|z
index|[
name|i
operator|+
name|wordShifts
operator|+
literal|1
index|]
operator|<<
name|shiftRestore
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|+
name|wordShifts
operator|<
name|z
operator|.
name|length
condition|)
block|{
name|val
operator||=
operator|(
name|z
index|[
name|i
operator|+
name|wordShifts
index|]
operator|>>>
name|bitShiftsInWord
operator|)
expr_stmt|;
block|}
name|result
index|[
name|i
index|]
operator|=
name|val
expr_stmt|;
block|}
if|if
condition|(
name|roundCarry
condition|)
block|{
name|incrementArray
argument_list|(
name|result
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**    * helper method for multiplication. used when either left/right fits int32.    */
specifier|private
name|void
name|multiplyDestructiveFitsInt32
parameter_list|(
name|UnsignedInt128
name|right
parameter_list|,
name|short
name|rightShifts
parameter_list|,
name|short
name|tenScaleDown
parameter_list|)
block|{
assert|assert
operator|(
name|this
operator|.
name|fitsInt32
argument_list|()
operator|&&
name|right
operator|.
name|fitsInt32
argument_list|()
operator|)
assert|;
assert|assert
operator|(
name|rightShifts
operator|==
literal|0
operator|||
name|tenScaleDown
operator|==
literal|0
operator|)
assert|;
comment|// only one of them
if|if
condition|(
name|this
operator|.
name|isZero
argument_list|()
condition|)
block|{
return|return;
comment|// zero. no need to shift/scale
block|}
elseif|else
if|if
condition|(
name|right
operator|.
name|isZero
argument_list|()
condition|)
block|{
name|zeroClear
argument_list|()
expr_stmt|;
return|return;
comment|// zero. no need to shift/scale
block|}
elseif|else
if|if
condition|(
name|this
operator|.
name|isOne
argument_list|()
condition|)
block|{
name|this
operator|.
name|update
argument_list|(
name|right
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|this
operator|.
name|multiplyDestructive
argument_list|(
name|right
operator|.
name|v
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rightShifts
operator|>
literal|0
condition|)
block|{
name|this
operator|.
name|shiftRightDestructive
argument_list|(
name|rightShifts
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|tenScaleDown
operator|>
literal|0
condition|)
block|{
name|this
operator|.
name|scaleDownTenDestructive
argument_list|(
name|tenScaleDown
argument_list|)
expr_stmt|;
block|}
block|}
comment|/** Updates the value of {@link #count} by checking {@link #v}. */
specifier|private
name|void
name|updateCount
parameter_list|()
block|{
if|if
condition|(
name|v
index|[
literal|3
index|]
operator|!=
literal|0
condition|)
block|{
name|this
operator|.
name|count
operator|=
operator|(
name|byte
operator|)
literal|4
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|v
index|[
literal|2
index|]
operator|!=
literal|0
condition|)
block|{
name|this
operator|.
name|count
operator|=
operator|(
name|byte
operator|)
literal|3
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|v
index|[
literal|1
index|]
operator|!=
literal|0
condition|)
block|{
name|this
operator|.
name|count
operator|=
operator|(
name|byte
operator|)
literal|2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|v
index|[
literal|0
index|]
operator|!=
literal|0
condition|)
block|{
name|this
operator|.
name|count
operator|=
operator|(
name|byte
operator|)
literal|1
expr_stmt|;
block|}
else|else
block|{
name|this
operator|.
name|count
operator|=
operator|(
name|byte
operator|)
literal|0
expr_stmt|;
block|}
block|}
comment|/*(non-Javadoc)    * Serializes one int part into the given @{link #ByteBuffer}     *  considering two's complement for negatives.    */
specifier|private
specifier|static
name|void
name|fastSerializeIntPartForHiveDecimal
parameter_list|(
name|ByteBuffer
name|buf
parameter_list|,
name|int
name|pos
parameter_list|,
name|int
name|value
parameter_list|,
name|byte
name|signum
parameter_list|,
name|boolean
name|isFirstNonZero
parameter_list|)
block|{
if|if
condition|(
name|signum
operator|==
operator|-
literal|1
operator|&&
name|value
operator|!=
literal|0
condition|)
block|{
name|value
operator|=
operator|(
name|isFirstNonZero
condition|?
operator|-
name|value
else|:
operator|~
name|value
operator|)
expr_stmt|;
block|}
name|buf
operator|.
name|putInt
argument_list|(
name|pos
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
comment|/* (non-Javadoc)      * Serializes this value into the format used by @{link #java.math.BigInteger}      * This is used for fast assignment of a Decimal128 to a HiveDecimalWritable internal storage.      * See OpenJDK BigInteger.toByteArray for a reference implementation.       * @param scratch      * @param signum      * @return      */
specifier|public
name|int
name|fastSerializeForHiveDecimal
parameter_list|(
name|Decimal128FastBuffer
name|scratch
parameter_list|,
name|byte
name|signum
parameter_list|)
block|{
name|int
name|bufferUsed
init|=
name|this
operator|.
name|count
decl_stmt|;
name|ByteBuffer
name|buf
init|=
name|scratch
operator|.
name|getByteBuffer
argument_list|(
name|bufferUsed
argument_list|)
decl_stmt|;
name|buf
operator|.
name|put
argument_list|(
literal|0
argument_list|,
call|(
name|byte
call|)
argument_list|(
name|signum
operator|==
literal|1
condition|?
literal|0
else|:
name|signum
argument_list|)
argument_list|)
expr_stmt|;
name|int
name|pos
init|=
literal|1
decl_stmt|;
name|int
name|firstNonZero
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|firstNonZero
operator|<
name|this
operator|.
name|count
operator|&&
name|v
index|[
name|firstNonZero
index|]
operator|==
literal|0
condition|)
block|{
operator|++
name|firstNonZero
expr_stmt|;
block|}
switch|switch
condition|(
name|this
operator|.
name|count
condition|)
block|{
case|case
literal|4
case|:
name|fastSerializeIntPartForHiveDecimal
argument_list|(
name|buf
argument_list|,
name|pos
argument_list|,
name|v
index|[
literal|3
index|]
argument_list|,
name|signum
argument_list|,
name|firstNonZero
operator|==
literal|3
argument_list|)
expr_stmt|;
name|pos
operator|+=
literal|4
expr_stmt|;
comment|// intentional fall through
case|case
literal|3
case|:
name|fastSerializeIntPartForHiveDecimal
argument_list|(
name|buf
argument_list|,
name|pos
argument_list|,
name|v
index|[
literal|2
index|]
argument_list|,
name|signum
argument_list|,
name|firstNonZero
operator|==
literal|2
argument_list|)
expr_stmt|;
name|pos
operator|+=
literal|4
expr_stmt|;
comment|// intentional fall through
case|case
literal|2
case|:
name|fastSerializeIntPartForHiveDecimal
argument_list|(
name|buf
argument_list|,
name|pos
argument_list|,
name|v
index|[
literal|1
index|]
argument_list|,
name|signum
argument_list|,
name|firstNonZero
operator|==
literal|1
argument_list|)
expr_stmt|;
name|pos
operator|+=
literal|4
expr_stmt|;
comment|// intentional fall through
case|case
literal|1
case|:
name|fastSerializeIntPartForHiveDecimal
argument_list|(
name|buf
argument_list|,
name|pos
argument_list|,
name|v
index|[
literal|0
index|]
argument_list|,
name|signum
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
return|return
name|bufferUsed
return|;
block|}
comment|/**    * Updates this value from a serialized unscaled {@link java.math.BigInteger} representation.    * This is used for fast update of a Decimal128 from a HiveDecimalWritable internal storage.    * @param internalStorage    * @return    */
specifier|public
name|byte
name|fastUpdateFromInternalStorage
parameter_list|(
name|byte
index|[]
name|internalStorage
parameter_list|)
block|{
name|byte
name|signum
init|=
literal|0
decl_stmt|;
name|int
name|skip
init|=
literal|0
decl_stmt|;
name|this
operator|.
name|count
operator|=
literal|0
expr_stmt|;
comment|// Skip over any leading 0s or 0xFFs
name|byte
name|firstByte
init|=
name|internalStorage
index|[
literal|0
index|]
decl_stmt|;
if|if
condition|(
name|firstByte
operator|==
literal|0
operator|||
name|firstByte
operator|==
operator|-
literal|1
condition|)
block|{
while|while
condition|(
operator|(
name|skip
operator|<
name|internalStorage
operator|.
name|length
operator|)
operator|&&
operator|(
name|internalStorage
index|[
name|skip
index|]
operator|==
name|firstByte
operator|)
condition|)
block|{
operator|++
name|skip
expr_stmt|;
block|}
block|}
if|if
condition|(
name|skip
operator|==
name|internalStorage
operator|.
name|length
condition|)
block|{
comment|// The entire storage is 0x00s or 0xFFs
comment|// 0x00s means is 0
comment|// 0xFFs means is -1
assert|assert
operator|(
name|firstByte
operator|==
literal|0
operator|||
name|firstByte
operator|==
operator|-
literal|1
operator|)
assert|;
if|if
condition|(
name|firstByte
operator|==
operator|-
literal|1
condition|)
block|{
name|signum
operator|=
operator|-
literal|1
expr_stmt|;
name|this
operator|.
name|count
operator|=
literal|1
expr_stmt|;
name|this
operator|.
name|v
index|[
literal|0
index|]
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|signum
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// We skipped over leading 0x00s and 0xFFs
comment|// Important, signum is given by the firstByte, not by byte[keep]!
name|signum
operator|=
operator|(
name|firstByte
operator|<
literal|0
operator|)
condition|?
operator|(
name|byte
operator|)
operator|-
literal|1
else|:
operator|(
name|byte
operator|)
literal|1
expr_stmt|;
comment|// Now we read the big-endian compacted two's complement int parts
comment|// Compacted means they are stripped of leading 0x00s and 0xFFs
comment|// This is why we do the intLength/pos tricks bellow
comment|// 'length' is all the bytes we have to read, after we skip 'skip'
comment|// 'pos' is where to start reading the current int
comment|// 'intLength' is how many bytes we read for the current int
name|int
name|length
init|=
name|internalStorage
operator|.
name|length
operator|-
name|skip
decl_stmt|;
name|int
name|pos
init|=
name|skip
decl_stmt|;
name|int
name|intLength
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|length
condition|)
block|{
case|case
literal|16
case|:
operator|++
name|intLength
expr_stmt|;
comment|//intentional fall through
case|case
literal|15
case|:
operator|++
name|intLength
expr_stmt|;
case|case
literal|14
case|:
operator|++
name|intLength
expr_stmt|;
case|case
literal|13
case|:
operator|++
name|intLength
expr_stmt|;
name|v
index|[
literal|3
index|]
operator|=
name|fastUpdateIntFromInternalStorage
argument_list|(
name|internalStorage
argument_list|,
name|signum
argument_list|,
name|pos
argument_list|,
name|intLength
argument_list|)
expr_stmt|;
operator|++
name|this
operator|.
name|count
expr_stmt|;
name|pos
operator|+=
name|intLength
expr_stmt|;
name|intLength
operator|=
literal|0
expr_stmt|;
comment|//intentional fall through
case|case
literal|12
case|:
operator|++
name|intLength
expr_stmt|;
comment|//intentional fall through
case|case
literal|11
case|:
operator|++
name|intLength
expr_stmt|;
case|case
literal|10
case|:
operator|++
name|intLength
expr_stmt|;
case|case
literal|9
case|:
operator|++
name|intLength
expr_stmt|;
name|v
index|[
literal|2
index|]
operator|=
name|fastUpdateIntFromInternalStorage
argument_list|(
name|internalStorage
argument_list|,
name|signum
argument_list|,
name|pos
argument_list|,
name|intLength
argument_list|)
expr_stmt|;
operator|++
name|this
operator|.
name|count
expr_stmt|;
name|pos
operator|+=
name|intLength
expr_stmt|;
name|intLength
operator|=
literal|0
expr_stmt|;
comment|//intentional fall through
case|case
literal|8
case|:
operator|++
name|intLength
expr_stmt|;
comment|//intentional fall through
case|case
literal|7
case|:
operator|++
name|intLength
expr_stmt|;
case|case
literal|6
case|:
operator|++
name|intLength
expr_stmt|;
case|case
literal|5
case|:
operator|++
name|intLength
expr_stmt|;
name|v
index|[
literal|1
index|]
operator|=
name|fastUpdateIntFromInternalStorage
argument_list|(
name|internalStorage
argument_list|,
name|signum
argument_list|,
name|pos
argument_list|,
name|intLength
argument_list|)
expr_stmt|;
operator|++
name|this
operator|.
name|count
expr_stmt|;
name|pos
operator|+=
name|intLength
expr_stmt|;
name|intLength
operator|=
literal|0
expr_stmt|;
comment|//intentional fall through
case|case
literal|4
case|:
operator|++
name|intLength
expr_stmt|;
comment|//intentional fall through
case|case
literal|3
case|:
operator|++
name|intLength
expr_stmt|;
case|case
literal|2
case|:
operator|++
name|intLength
expr_stmt|;
case|case
literal|1
case|:
operator|++
name|intLength
expr_stmt|;
name|v
index|[
literal|0
index|]
operator|=
name|fastUpdateIntFromInternalStorage
argument_list|(
name|internalStorage
argument_list|,
name|signum
argument_list|,
name|pos
argument_list|,
name|intLength
argument_list|)
expr_stmt|;
operator|++
name|this
operator|.
name|count
expr_stmt|;
break|break;
default|default:
comment|// This should not happen
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Impossible HiveDecimal internal storage length!"
argument_list|)
throw|;
block|}
if|if
condition|(
name|signum
operator|==
operator|-
literal|1
condition|)
block|{
comment|// So far we've read the one's complement
comment|// add 1 to turn it into two's complement
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|this
operator|.
name|count
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|v
index|[
name|i
index|]
operator|!=
literal|0
condition|)
block|{
name|v
index|[
name|i
index|]
operator|=
call|(
name|int
call|)
argument_list|(
operator|(
name|v
index|[
name|i
index|]
operator|&
literal|0xFFFFFFFFL
operator|)
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|v
index|[
name|i
index|]
operator|!=
literal|0
condition|)
block|{
break|break;
block|}
block|}
block|}
block|}
block|}
return|return
name|signum
return|;
block|}
comment|/**      * reads one int part from the two's complement Big-Endian compacted representation,      * starting from index pos      * @param internalStorage {@link java.math.BigInteger} serialized representation      * @param pos      * @return      */
specifier|private
name|int
name|fastUpdateIntFromInternalStorage
parameter_list|(
name|byte
index|[]
name|internalStorage
parameter_list|,
name|byte
name|signum
parameter_list|,
name|int
name|pos
parameter_list|,
name|int
name|length
parameter_list|)
block|{
comment|// due to the way we use the allocation-free cast from HiveDecimalWriter to decimal128,
comment|// we do not have the luxury of a ByteBuffer...
name|byte
name|b0
decl_stmt|,
name|b1
decl_stmt|,
name|b2
decl_stmt|,
name|b3
decl_stmt|;
if|if
condition|(
name|signum
operator|==
operator|-
literal|1
condition|)
block|{
name|b1
operator|=
name|b2
operator|=
name|b3
operator|=
operator|(
name|byte
operator|)
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
name|b1
operator|=
name|b2
operator|=
name|b3
operator|=
literal|0
expr_stmt|;
block|}
switch|switch
condition|(
name|length
condition|)
block|{
case|case
literal|4
case|:
name|b3
operator|=
name|internalStorage
index|[
name|pos
index|]
expr_stmt|;
operator|++
name|pos
expr_stmt|;
comment|//intentional fall through
case|case
literal|3
case|:
name|b2
operator|=
name|internalStorage
index|[
name|pos
index|]
expr_stmt|;
operator|++
name|pos
expr_stmt|;
comment|//intentional fall through
case|case
literal|2
case|:
name|b1
operator|=
name|internalStorage
index|[
name|pos
index|]
expr_stmt|;
operator|++
name|pos
expr_stmt|;
comment|//intentional fall through
case|case
literal|1
case|:
name|b0
operator|=
name|internalStorage
index|[
name|pos
index|]
expr_stmt|;
break|break;
default|default:
comment|// this should never happen
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Impossible HiveDecimal internal storage position!"
argument_list|)
throw|;
block|}
name|int
name|value
init|=
operator|(
operator|(
name|int
operator|)
name|b0
operator|&
literal|0x000000FF
operator|)
operator||
operator|(
operator|(
operator|(
name|int
operator|)
name|b1
operator|<<
literal|8
operator|)
operator|&
literal|0x0000FF00
operator|)
operator||
operator|(
operator|(
operator|(
name|int
operator|)
name|b2
operator|<<
literal|16
operator|)
operator|&
literal|0x00FF0000
operator|)
operator||
operator|(
operator|(
operator|(
name|int
operator|)
name|b3
operator|<<
literal|24
operator|)
operator|&
literal|0xFF000000
operator|)
decl_stmt|;
if|if
condition|(
name|signum
operator|==
operator|-
literal|1
operator|&&
name|value
operator|!=
literal|0
condition|)
block|{
comment|// Make one's complement, masked only for the bytes read
name|int
name|mask
init|=
operator|-
literal|1
operator|>>>
operator|(
literal|8
operator|*
operator|(
literal|4
operator|-
name|length
operator|)
operator|)
decl_stmt|;
name|value
operator|=
operator|~
name|value
operator|&
name|mask
expr_stmt|;
block|}
return|return
name|value
return|;
block|}
specifier|public
name|int
index|[]
name|getV
parameter_list|()
block|{
return|return
name|v
return|;
block|}
comment|/**    * This setter is only for de-serialization, should not be used otherwise.    */
specifier|public
name|void
name|setV
parameter_list|(
name|int
index|[]
name|v
parameter_list|)
block|{
name|this
operator|.
name|v
index|[
literal|0
index|]
operator|=
name|v
index|[
literal|0
index|]
expr_stmt|;
name|this
operator|.
name|v
index|[
literal|1
index|]
operator|=
name|v
index|[
literal|1
index|]
expr_stmt|;
name|this
operator|.
name|v
index|[
literal|2
index|]
operator|=
name|v
index|[
literal|2
index|]
expr_stmt|;
name|this
operator|.
name|v
index|[
literal|3
index|]
operator|=
name|v
index|[
literal|3
index|]
expr_stmt|;
name|updateCount
argument_list|()
expr_stmt|;
block|}
specifier|public
name|byte
name|getCount
parameter_list|()
block|{
return|return
name|count
return|;
block|}
comment|/**    * This setter is only for de-serialization, should not be used otherwise.    */
specifier|public
name|void
name|setCount
parameter_list|(
name|byte
name|count
parameter_list|)
block|{
name|this
operator|.
name|count
operator|=
name|count
expr_stmt|;
block|}
block|}
end_class

end_unit

