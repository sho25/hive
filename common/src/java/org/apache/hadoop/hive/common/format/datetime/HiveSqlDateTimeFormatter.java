begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|common
operator|.
name|format
operator|.
name|datetime
package|;
end_package

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|ImmutableList
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|ImmutableMap
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|lang
operator|.
name|StringUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|lang
operator|.
name|WordUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|common
operator|.
name|type
operator|.
name|Date
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|common
operator|.
name|type
operator|.
name|Timestamp
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|Serializable
import|;
end_import

begin_import
import|import
name|java
operator|.
name|time
operator|.
name|DateTimeException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|time
operator|.
name|DayOfWeek
import|;
end_import

begin_import
import|import
name|java
operator|.
name|time
operator|.
name|Instant
import|;
end_import

begin_import
import|import
name|java
operator|.
name|time
operator|.
name|LocalDateTime
import|;
end_import

begin_import
import|import
name|java
operator|.
name|time
operator|.
name|Month
import|;
end_import

begin_import
import|import
name|java
operator|.
name|time
operator|.
name|ZoneOffset
import|;
end_import

begin_import
import|import
name|java
operator|.
name|time
operator|.
name|format
operator|.
name|DateTimeFormatter
import|;
end_import

begin_import
import|import
name|java
operator|.
name|time
operator|.
name|format
operator|.
name|TextStyle
import|;
end_import

begin_import
import|import
name|java
operator|.
name|time
operator|.
name|temporal
operator|.
name|ChronoField
import|;
end_import

begin_import
import|import
name|java
operator|.
name|time
operator|.
name|temporal
operator|.
name|ChronoUnit
import|;
end_import

begin_import
import|import
name|java
operator|.
name|time
operator|.
name|temporal
operator|.
name|IsoFields
import|;
end_import

begin_import
import|import
name|java
operator|.
name|time
operator|.
name|temporal
operator|.
name|TemporalField
import|;
end_import

begin_import
import|import
name|java
operator|.
name|time
operator|.
name|temporal
operator|.
name|TemporalUnit
import|;
end_import

begin_import
import|import
name|java
operator|.
name|time
operator|.
name|temporal
operator|.
name|WeekFields
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Locale
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|regex
operator|.
name|Matcher
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|regex
operator|.
name|Pattern
import|;
end_import

begin_comment
comment|/**  * Formatter using SQL:2016 datetime patterns.  *  * For all tokens:  * - Patterns are case-insensitive, except AM/PM, T/Z and nested strings. See these sections for more  *   details.  * - For string to datetime conversion, no duplicate format tokens are allowed, including tokens  *   that have the same meaning but different lengths ("Y" and "YY" conflict) or different  *   behaviors ("RR" and "YY" conflict).  *  * For all numeric tokens:  * - The "expected length" of input/output is the number of tokens in the character (e.g. "YYY": 3,  *   "Y": 1, and so on), with some exceptions (see map SPECIAL_LENGTHS).  * - For string to datetime conversion, inputs of fewer digits than expected are accepted if  *   followed by a delimiter, e.g. format="YYYY-MM-DD", input="19-1-1", output=2019-01-01 00:00:00.  *   This is modified by format modifier FX (format exact). See FX for details.  * - For datetime to string conversion, output is left padded with zeros, e.g. format="DD SSSSS",  *   input=2019-01-01 00:00:03, output="01 00003".  *   This is modified by format modifier FM (fill mode). See FM for details.  *  *  * Accepted format tokens:  * Note: - "|" means "or".  *       - "Delimiter" for numeric tokens means any non-numeric character or end of input.  *       - The words token and pattern are used interchangeably.  *  * A.1. Numeric temporal tokens  * YYYY  * 4-digit year  * - For string to datetime conversion, prefix digits for 1, 2, and 3-digit inputs are obtained  *   from current date  *   E.g. input=‘9-01-01’, pattern =‘YYYY-MM-DD’, current year=2020, output=2029-01-01 00:00:00  *  * YYY  * Last 3 digits of a year  * - Gets the prefix digit from current date.  * - Can accept fewer digits than 3, similarly to YYYY.  *  * YY  * Last 2 digits of a year  * - Gets the 2 prefix digits from current date.  * - Can accept fewer digits than 2, similarly to YYYY.  *  * Y  * Last digit of a year  * - Gets the 3 prefix digits from current date.  *  * RRRR  * 4-digit rounded year  * - String to datetime conversion:  *   - If 2 digits are provided then acts like RR.  *   - If 1,3 or 4 digits provided then acts like YYYY.  * - For datetime to string conversion, acts like YYYY.  *  * RR  * 2-digit rounded year  * -String to datetime conversion:  *   - Semantics:  *     Input:     Last 2 digits of current year:   First 2 digits of output:  *     0 to 49    00 to 49                         First 2 digits of current year  *     0 to 49    50 to 99                         First 2 digits of current year + 1  *     50 to 99   00 to 49                         First 2 digits of current year - 1  *     50 to 99   50 to 99                         First 2 digits of current year  *   - If 1-digit year is provided followed by a delimiter, falls back to YYYY with 1-digit year  *     input.  * - For datetime to string conversion, acts like YY.  *  * MM  * Month (1-12)  * - For string to datetime conversion, conflicts with DDD, MONTH, MON.  *  * DD  * Day of month (1-31)  * - For string to datetime conversion, conflicts with DDD.  *  * DDD  * Day of year (1-366)  * - For string to datetime conversion, conflicts with DD and MM.  *  * HH  * Hour of day (1-12)  * - If no AM/PM provided then defaults to AM.  * - In string to datetime conversion, conflicts with SSSSS and HH24.  *  * HH12  * Hour of day (1-12)  * See HH.  *  * HH24  * Hour of day (0-23)  * - In string to datetime conversion, conflicts with SSSSS, HH12 and AM/PM.  *  * MI  * Minute of hour (0-59)  * - In string to datetime conversion, conflicts with SSSSS.  *  * SS  * Second of minute (0-59)  * - In string to datetime conversion, conflicts with SSSSS.  *  * SSSSS  * Second of Day (0-86399)  * - In string to datetime conversion, conflicts with SS, HH, HH12, HH24, MI, AM/PM.  *  * FF[1..9]  * Fraction of second  * - 1..9 indicates the number of decimal digits. "FF" (no number of digits specified) is also  *   accepted.  * - In datetime to string conversion, "FF" will omit trailing zeros, or output "0" if subsecond  *   value is 0.  * - In string to datetime conversion, fewer digits than expected are accepted if followed by a  *   delimiter. "FF" acts like "FF9".  *  * AM|A.M.|PM|P.M.  * Meridiem indicator (or AM/PM)  * - Datetime to string conversion:  *   - AM and PM mean the exact same thing in the pattern.  *     e.g. input=2019-01-01 20:00, format=“AM”, output=“PM”.  *   - Retains the exact format (capitalization and length) provided in the pattern string. If p.m.  *     is in the pattern, we expect a.m. or p.m. in the output; if AM is in the pattern, we expect  *     AM or PM in the output. If the case is mixed (Am or aM) then the output case will match the  *     case of the pattern's first character (Am => AM, aM => am).  * - String to datetime conversion:  *   - Conflicts with HH24 and SSSSS.  *   - It doesn't matter which meridian indicator is in the pattern.  *     E.g. input="2019-01-01 11:00 p.m.", pattern="YYYY-MM-DD HH12:MI AM",  *          output=2019-01-01 23:00:00  *   - If FX is enabled, input length has to match the pattern's length. e.g. pattern=AM input=A.M.  *     is not accepted, but input=pm is.  * - Not listed as a character temporal because of special status: does not get padded with spaces  *   upon formatting, and case is handled differently at datetime to string conversion.  *  * D  * Day of week (1-7)  * - 1 means Sunday, 2 means Monday, and so on.  * - Not allowed in string to datetime conversion.  *  * Q  * Quarter of year (1-4)  * - Not allowed in string to datetime conversion.  *  * WW  * Aligned week of year (1-53)  * - 1st week begins on January 1st and ends on January 7th, and so on.  * - Not allowed in string to datetime conversion.  *  * W  * Aligned week of month (1-5)  * - 1st week starts on the 1st of the month and ends on the 7th, and so on.  * - Not allowed in string to datetime conversion.  *  * IYYY  * 4-digit ISO 8601 week-numbering year  * - Returns the year relating to the ISO week number (IW), which is the full week (Monday to  *   Sunday) which contains January 4 of the Gregorian year.  * - Behaves similarly to YYYY in that for datetime to string conversion, prefix digits for 1, 2,  *   and 3-digit inputs are obtained from current week-numbering year.  * - For string to datetime conversion, requires IW and ID|DAY|DY. Conflicts with all other date  *   patterns (see "List of Date-Based Patterns").  *  * IYY  * Last 3 digits of ISO 8601 week-numbering year  * - See IYYY.  * - Behaves similarly to YYY in that for datetime to string conversion, prefix digit is obtained  *   from current week-numbering year and can accept 1 or 2-digit input.  *  * IY  * Last 2 digits of ISO 8601 week-numbering year  * - See IYYY.  * - Behaves similarly to YY in that for datetime to string conversion, prefix digits are obtained  *   from current week-numbering year and can accept 1-digit input.  *  * I  * Last digit of ISO 8601 week-numbering year  * - See IYYY.  * - Behaves similarly to Y in that for datetime to string conversion, prefix digits are obtained  *   from current week-numbering year.  *  * IW  * ISO 8601 week of year (1-53)  * - Begins on the Monday closest to January 1 of the year.  * - For string to datetime conversion, if the input week does not exist in the input year, an  *   error will be thrown. e.g. the 2019 week-year has 52 weeks; with pattern="iyyy-iw-id"  *   input="2019-53-2" is not accepted.  * - For string to datetime conversion, requires IYYY|IYY|IY|I and ID|DAY|DY. Conflicts with all other  *   date patterns (see "List of Date-Based Patterns").  *  * ID  * ISO 8601 day of week (1-7)  * - 1 is Monday, and so on.  * - For string to datetime conversion, requires IYYY|IYY|IY|I and IW. Conflicts with all other  *   date patterns (see "List of Date-Based Patterns").  *  * A.2. Character temporals  * Temporal elements, but spelled out.  * - For datetime to string conversion, the pattern's case must match one of the listed formats  *   (e.g. mOnTh is not accepted) to avoid ambiguity. Output is right padded with trailing spaces  *   unless the pattern is marked with the fill mode modifier (FM).  * - For string to datetime conversion, the case of the pattern does not matter.  *  * MONTH|Month|month  * Name of month of year  * - For datetime to string conversion, will include trailing spaces up to length 9 (length of  *   longest month of year name: "September"). Case is taken into account according to the  *   following example (pattern => output):  *   - MONTH => JANUARY  *   - Month => January  *   - month => january  * - For string to datetime conversion, neither the case of the pattern nor the case of the input  *   are taken into account.  * - For string to datetime conversion, conflicts with MM and MON.  *  *  * MON|Mon|mon  * Abbreviated name of month of year  * - For datetime to string conversion, case is taken into account according to the following  *   example (pattern => output):  *   - MON => JAN  *   - Mon => Jan  *   - mon => jan  * - For string to datetime conversion, neither the case of the pattern nor the case of the input  *   are taken into account.  * - For string to datetime conversion, conflicts with MM and MONTH.  *  *  * DAY|Day|day  * Name of day of week  * - For datetime to string conversion, will include trailing spaces until length is 9 (length of  *   longest day of week name: "Wednesday"). Case is taken into account according to the following  *   example (pattern => output):  *   - DAY = SUNDAY  *   - Day = Sunday  *   - day = sunday  * - For string to datetime conversion, neither the case of the pattern nor the case of the input  *   are taken into account.  * - Not allowed in string to datetime conversion except with IYYY|IYY|IY|I and IW.  *  * DY|Dy|dy  * Abbreviated name of day of week  * - For datetime to string conversion, case is taken into account according to the following  *   example (pattern => output):  *   - DY = SUN  *   - Dy = Sun  *   - dy = sun  * - For string to datetime conversion, neither the case of the pattern nor the case of the input  *   are taken into account.  * - Not allowed in string to datetime conversion except with IYYY|IYY|IY|I and IW.  *  * B. Time zone tokens  * TZH  * Time zone offset hour (-15 to +15)  * - 3-character-long input is expected: 1 character for the sign and 2 digits for the value.  *   e.g. “+10”, “-05”  * - 2-digit input is accepted without the sign, e.g. “04”.  * - Both these 2 and 3-digit versions are accepted even if not followed by separators.  * - Disabled for timestamp to string and date to string conversion, as timestamp and date are time  *   zone agnostic.  *  * TZM  * Time zone offset minute (0-59)  * - For string to datetime conversion:  *   - TZH token is required.  *   - Unsigned; sign comes from TZH.  *   - Therefore time zone offsets like “-30” minutes should be expressed thus: input=“-00:30”  *     pattern=“TZH:TZM”.  * - Disabled for timestamp to string and date to string conversion, as timestamp and date are time  *   zone agnostic.  *  * C. Separators  * -|.|/|,|'|;|:|<space>  * Separator  * - Uses loose matching. Existence of a sequence of separators in the format should match the  *   existence of a sequence of separators in the input regardless of the types of the separator or  *   the length of the sequence where length> 1. E.g. input=“2019-. ;10/10”, pattern=“YYYY-MM-DD”  *   is valid; input=“20191010”, pattern=“YYYY-MM-DD” is not valid.  * - If the last separator character in the separator substring is "-" and is immediately followed  *   by a time zone hour (tzh) token, it's a negative sign and not counted as a separator, UNLESS  *   this is the only possible separator character in the separator substring (in which case it is  *   not counted as the tzh's negative sign).  * - If the whole pattern string is delimited by single quotes (''), then the apostrophe separator  *   (') must be escaped with a single backslash: (\').  *  * D. ISO 8601 delimiters  * T|Z  * ISO 8601 delimiter  * - Serves as a delimiter.  * - Function is to support formats like “YYYY-MM-DDTHH24:MI:SS.FF9Z”, “YYYY-MM-DD-HH24:MI:SSZ”  * - For datetime to string conversion, output is always capitalized ("T"), even if lowercase ("t")  *   is provided in the pattern.  * - For string to datetime conversion, case of input and pattern may differ.  *  * E. Nested strings (Text)  * – Surround with double quotes (") in the pattern. Note, if the whole pattern string is delimited  *   by double quotes, then the double quotes must be escaped with a single backslash: (\").  * - In order to include a literal double quote character within the nested string, the double  *   quote character must be escaped with a double backslash: (\\”). If the whole pattern string is  *   delimited by double quotes, then escape with a triple backslash: (\\\")  * - If the whole pattern string is delimited by single quotes, literal single  *   quotes/apostrophes (') in the nested string must be escaped with a single backslash: (\')  * - For datetime to string conversion, we simply include the string in the output, preserving the  *   characters' case.  * - For string to datetime conversion, the information is lost as the nested string won’t be part  *   of the resulting datetime object. However, the nested string has to match the related part of  *   the input string, except case may differ.  *  * F. Format modifier tokens  * FM  * Fill mode modifier  * - Default for string to datetime conversion. Inputs of fewer digits than expected are accepted  *   if followed by a delimiter:  *   e.g. format="YYYY-MM-DD", input="19-1-1", output=2019-01-01 00:00:00  * - For datetime to string conversion, padding (trailing spaces for text data and leading zeroes  *   for numeric data) is omitted for the temporal element immediately following an "FM" in the  *   pattern string. If the element following is not a temporal element (for example, if "FM"  *   precedes a separator), an error will be thrown.  *   e.g. pattern=FMHH12:MI:FMSS, input=2019-01-01 01:01:01, output=1:01:1  * - Modifies FX so that lack of leading zeroes are accepted for the element immediately following  *   an "FM" in the pattern string.  *  * FX  * Format exact modifier  * - Default for datetime to string conversion. Numeric output is left padded with zeros, and  *   non-numeric output except for AM/PM is right padded with spaces up to expected length.  * - Applies to the whole pattern.  * - Rules applied at string to datetime conversion:  *   - Separators must match exactly, down to the character.  *   - Numeric input can't omit leading zeroes. This rule does not apply to elements (tokens)  *     immediately preceded by an "FM."  *   - AM/PM input length has to match the pattern's length. e.g. pattern=AM input=A.M. is not  *     accepted, but input=pm is.  *  * Appendix:  * List of Date-Based Patterns  * These are patterns that help define a date as opposed to a time.  * YYYY, YYY, YY, Y, RRRR, RR,  * MM, MON, MONTH,  * DD, DDD, D, DY, DAY,  * Q, WW, W,  * IYYY, IYY, IY, I, IW, ID  */
end_comment

begin_class
specifier|public
class|class
name|HiveSqlDateTimeFormatter
implements|implements
name|Serializable
block|{
specifier|private
specifier|static
specifier|final
name|int
name|LONGEST_TOKEN_LENGTH
init|=
literal|5
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|int
name|LONGEST_ACCEPTED_PATTERN
init|=
literal|100
decl_stmt|;
comment|// for sanity's sake
specifier|private
specifier|static
specifier|final
name|int
name|NANOS_MAX_LENGTH
init|=
literal|9
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|int
name|AM
init|=
literal|0
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|int
name|PM
init|=
literal|1
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|DateTimeFormatter
name|MONTH_FORMATTER
init|=
name|DateTimeFormatter
operator|.
name|ofPattern
argument_list|(
literal|"MMM"
argument_list|)
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|DateTimeFormatter
name|DAY_OF_WEEK_FORMATTER
init|=
name|DateTimeFormatter
operator|.
name|ofPattern
argument_list|(
literal|"EEE"
argument_list|)
decl_stmt|;
specifier|private
name|String
name|pattern
decl_stmt|;
specifier|private
name|List
argument_list|<
name|Token
argument_list|>
name|tokens
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
specifier|private
name|boolean
name|formatExact
init|=
literal|false
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|TemporalField
argument_list|>
name|NUMERIC_TEMPORAL_TOKENS
init|=
name|ImmutableMap
operator|.
expr|<
name|String
decl_stmt|,
name|TemporalField
decl|>
name|builder
argument_list|()
decl|.
name|put
argument_list|(
literal|"yyyy"
argument_list|,
name|ChronoField
operator|.
name|YEAR
argument_list|)
decl|.
name|put
argument_list|(
literal|"yyy"
argument_list|,
name|ChronoField
operator|.
name|YEAR
argument_list|)
decl|.
name|put
argument_list|(
literal|"yy"
argument_list|,
name|ChronoField
operator|.
name|YEAR
argument_list|)
decl|.
name|put
argument_list|(
literal|"y"
argument_list|,
name|ChronoField
operator|.
name|YEAR
argument_list|)
decl|.
name|put
argument_list|(
literal|"rrrr"
argument_list|,
name|ChronoField
operator|.
name|YEAR
argument_list|)
decl|.
name|put
argument_list|(
literal|"rr"
argument_list|,
name|ChronoField
operator|.
name|YEAR
argument_list|)
decl|.
name|put
argument_list|(
literal|"mm"
argument_list|,
name|ChronoField
operator|.
name|MONTH_OF_YEAR
argument_list|)
decl|.
name|put
argument_list|(
literal|"d"
argument_list|,
name|WeekFields
operator|.
name|SUNDAY_START
operator|.
name|dayOfWeek
argument_list|()
argument_list|)
decl|.
name|put
argument_list|(
literal|"dd"
argument_list|,
name|ChronoField
operator|.
name|DAY_OF_MONTH
argument_list|)
decl|.
name|put
argument_list|(
literal|"ddd"
argument_list|,
name|ChronoField
operator|.
name|DAY_OF_YEAR
argument_list|)
decl|.
name|put
argument_list|(
literal|"hh"
argument_list|,
name|ChronoField
operator|.
name|HOUR_OF_AMPM
argument_list|)
decl|.
name|put
argument_list|(
literal|"hh12"
argument_list|,
name|ChronoField
operator|.
name|HOUR_OF_AMPM
argument_list|)
decl|.
name|put
argument_list|(
literal|"hh24"
argument_list|,
name|ChronoField
operator|.
name|HOUR_OF_DAY
argument_list|)
decl|.
name|put
argument_list|(
literal|"mi"
argument_list|,
name|ChronoField
operator|.
name|MINUTE_OF_HOUR
argument_list|)
decl|.
name|put
argument_list|(
literal|"ss"
argument_list|,
name|ChronoField
operator|.
name|SECOND_OF_MINUTE
argument_list|)
decl|.
name|put
argument_list|(
literal|"sssss"
argument_list|,
name|ChronoField
operator|.
name|SECOND_OF_DAY
argument_list|)
decl|.
name|put
argument_list|(
literal|"ff1"
argument_list|,
name|ChronoField
operator|.
name|NANO_OF_SECOND
argument_list|)
decl|.
name|put
argument_list|(
literal|"ff2"
argument_list|,
name|ChronoField
operator|.
name|NANO_OF_SECOND
argument_list|)
decl|.
name|put
argument_list|(
literal|"ff3"
argument_list|,
name|ChronoField
operator|.
name|NANO_OF_SECOND
argument_list|)
decl|.
name|put
argument_list|(
literal|"ff4"
argument_list|,
name|ChronoField
operator|.
name|NANO_OF_SECOND
argument_list|)
decl|.
name|put
argument_list|(
literal|"ff5"
argument_list|,
name|ChronoField
operator|.
name|NANO_OF_SECOND
argument_list|)
decl|.
name|put
argument_list|(
literal|"ff6"
argument_list|,
name|ChronoField
operator|.
name|NANO_OF_SECOND
argument_list|)
decl|.
name|put
argument_list|(
literal|"ff7"
argument_list|,
name|ChronoField
operator|.
name|NANO_OF_SECOND
argument_list|)
decl|.
name|put
argument_list|(
literal|"ff8"
argument_list|,
name|ChronoField
operator|.
name|NANO_OF_SECOND
argument_list|)
decl|.
name|put
argument_list|(
literal|"ff9"
argument_list|,
name|ChronoField
operator|.
name|NANO_OF_SECOND
argument_list|)
decl|.
name|put
argument_list|(
literal|"ff"
argument_list|,
name|ChronoField
operator|.
name|NANO_OF_SECOND
argument_list|)
decl|.
name|put
argument_list|(
literal|"a.m."
argument_list|,
name|ChronoField
operator|.
name|AMPM_OF_DAY
argument_list|)
decl|.
name|put
argument_list|(
literal|"am"
argument_list|,
name|ChronoField
operator|.
name|AMPM_OF_DAY
argument_list|)
decl|.
name|put
argument_list|(
literal|"p.m."
argument_list|,
name|ChronoField
operator|.
name|AMPM_OF_DAY
argument_list|)
decl|.
name|put
argument_list|(
literal|"pm"
argument_list|,
name|ChronoField
operator|.
name|AMPM_OF_DAY
argument_list|)
decl|.
name|put
argument_list|(
literal|"ww"
argument_list|,
name|ChronoField
operator|.
name|ALIGNED_WEEK_OF_YEAR
argument_list|)
decl|.
name|put
argument_list|(
literal|"w"
argument_list|,
name|ChronoField
operator|.
name|ALIGNED_WEEK_OF_MONTH
argument_list|)
decl|.
name|put
argument_list|(
literal|"q"
argument_list|,
name|IsoFields
operator|.
name|QUARTER_OF_YEAR
argument_list|)
decl|.
name|put
argument_list|(
literal|"iyyy"
argument_list|,
name|IsoFields
operator|.
name|WEEK_BASED_YEAR
argument_list|)
decl|.
name|put
argument_list|(
literal|"iyy"
argument_list|,
name|IsoFields
operator|.
name|WEEK_BASED_YEAR
argument_list|)
decl|.
name|put
argument_list|(
literal|"iy"
argument_list|,
name|IsoFields
operator|.
name|WEEK_BASED_YEAR
argument_list|)
decl|.
name|put
argument_list|(
literal|"i"
argument_list|,
name|IsoFields
operator|.
name|WEEK_BASED_YEAR
argument_list|)
decl|.
name|put
argument_list|(
literal|"iw"
argument_list|,
name|IsoFields
operator|.
name|WEEK_OF_WEEK_BASED_YEAR
argument_list|)
decl|.
name|put
argument_list|(
literal|"id"
argument_list|,
name|ChronoField
operator|.
name|DAY_OF_WEEK
argument_list|)
decl|.
name|build
argument_list|()
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|TemporalField
argument_list|>
name|CHARACTER_TEMPORAL_TOKENS
init|=
name|ImmutableMap
operator|.
expr|<
name|String
decl_stmt|,
name|TemporalField
decl|>
name|builder
argument_list|()
decl|.
name|put
argument_list|(
literal|"mon"
argument_list|,
name|ChronoField
operator|.
name|MONTH_OF_YEAR
argument_list|)
decl|.
name|put
argument_list|(
literal|"month"
argument_list|,
name|ChronoField
operator|.
name|MONTH_OF_YEAR
argument_list|)
decl|.
name|put
argument_list|(
literal|"day"
argument_list|,
name|ChronoField
operator|.
name|DAY_OF_WEEK
argument_list|)
decl|.
name|put
argument_list|(
literal|"dy"
argument_list|,
name|ChronoField
operator|.
name|DAY_OF_WEEK
argument_list|)
decl|.
name|build
argument_list|()
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|TemporalUnit
argument_list|>
name|TIME_ZONE_TOKENS
init|=
name|ImmutableMap
operator|.
expr|<
name|String
decl_stmt|,
name|TemporalUnit
decl|>
name|builder
argument_list|()
decl|.
name|put
argument_list|(
literal|"tzh"
argument_list|,
name|ChronoUnit
operator|.
name|HOURS
argument_list|)
decl|.
name|put
argument_list|(
literal|"tzm"
argument_list|,
name|ChronoUnit
operator|.
name|MINUTES
argument_list|)
decl|.
name|build
argument_list|()
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|List
argument_list|<
name|String
argument_list|>
name|VALID_ISO_8601_DELIMITERS
init|=
name|ImmutableList
operator|.
name|of
argument_list|(
literal|"t"
argument_list|,
literal|"z"
argument_list|)
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|List
argument_list|<
name|String
argument_list|>
name|VALID_SEPARATORS
init|=
name|ImmutableList
operator|.
name|of
argument_list|(
literal|"-"
argument_list|,
literal|":"
argument_list|,
literal|" "
argument_list|,
literal|"."
argument_list|,
literal|"/"
argument_list|,
literal|";"
argument_list|,
literal|"\'"
argument_list|,
literal|","
argument_list|)
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|List
argument_list|<
name|String
argument_list|>
name|VALID_FORMAT_MODIFIERS
init|=
name|ImmutableList
operator|.
name|of
argument_list|(
literal|"fm"
argument_list|,
literal|"fx"
argument_list|)
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|Integer
argument_list|>
name|SPECIAL_LENGTHS
init|=
name|ImmutableMap
operator|.
expr|<
name|String
decl_stmt|,
name|Integer
decl|>
name|builder
argument_list|()
decl|.
name|put
argument_list|(
literal|"hh12"
argument_list|,
literal|2
argument_list|)
decl|.
name|put
argument_list|(
literal|"hh24"
argument_list|,
literal|2
argument_list|)
decl|.
name|put
argument_list|(
literal|"tzm"
argument_list|,
literal|2
argument_list|)
decl|.
name|put
argument_list|(
literal|"am"
argument_list|,
literal|4
argument_list|)
decl|.
name|put
argument_list|(
literal|"pm"
argument_list|,
literal|4
argument_list|)
decl|.
name|put
argument_list|(
literal|"ff1"
argument_list|,
literal|1
argument_list|)
decl|.
name|put
argument_list|(
literal|"ff2"
argument_list|,
literal|2
argument_list|)
decl|.
name|put
argument_list|(
literal|"ff3"
argument_list|,
literal|3
argument_list|)
decl|.
name|put
argument_list|(
literal|"ff4"
argument_list|,
literal|4
argument_list|)
decl|.
name|put
argument_list|(
literal|"ff5"
argument_list|,
literal|5
argument_list|)
decl|.
name|put
argument_list|(
literal|"ff6"
argument_list|,
literal|6
argument_list|)
decl|.
name|put
argument_list|(
literal|"ff7"
argument_list|,
literal|7
argument_list|)
decl|.
name|put
argument_list|(
literal|"ff8"
argument_list|,
literal|8
argument_list|)
decl|.
name|put
argument_list|(
literal|"ff9"
argument_list|,
literal|9
argument_list|)
decl|.
name|put
argument_list|(
literal|"ff"
argument_list|,
literal|9
argument_list|)
decl|.
name|put
argument_list|(
literal|"month"
argument_list|,
literal|9
argument_list|)
decl|.
name|put
argument_list|(
literal|"day"
argument_list|,
literal|9
argument_list|)
decl|.
name|put
argument_list|(
literal|"dy"
argument_list|,
literal|3
argument_list|)
decl|.
name|build
argument_list|()
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|List
argument_list|<
name|TemporalField
argument_list|>
name|ISO_8601_TEMPORAL_FIELDS
init|=
name|ImmutableList
operator|.
name|of
argument_list|(
name|ChronoField
operator|.
name|DAY_OF_WEEK
argument_list|,
name|IsoFields
operator|.
name|WEEK_OF_WEEK_BASED_YEAR
argument_list|,
name|IsoFields
operator|.
name|WEEK_BASED_YEAR
argument_list|)
decl_stmt|;
comment|/**    * Represents broad categories of tokens.    */
specifier|public
enum|enum
name|TokenType
block|{
name|NUMERIC_TEMPORAL
block|,
name|CHARACTER_TEMPORAL
block|,
name|SEPARATOR
block|,
name|TIMEZONE
block|,
name|ISO_8601_DELIMITER
block|,
name|TEXT
block|}
comment|/**    * Token representation.    */
specifier|public
specifier|static
class|class
name|Token
implements|implements
name|Serializable
block|{
name|TokenType
name|type
decl_stmt|;
name|TemporalField
name|temporalField
decl_stmt|;
comment|// for type TEMPORAL e.g. ChronoField.YEAR
name|TemporalUnit
name|temporalUnit
decl_stmt|;
comment|// for type TIMEZONE e.g. ChronoUnit.HOURS
name|String
name|string
decl_stmt|;
comment|// pattern string, e.g. "yyy"
name|int
name|length
decl_stmt|;
comment|// length (e.g. YYY: 3, FF8: 8)
name|boolean
name|fillMode
decl_stmt|;
comment|//FM, applies to type TEMPORAL only (later should apply to TIMEZONE as well)
specifier|public
name|Token
parameter_list|(
name|TokenType
name|tokenType
parameter_list|,
name|TemporalField
name|temporalField
parameter_list|,
name|String
name|string
parameter_list|,
name|int
name|length
parameter_list|,
name|boolean
name|fillMode
parameter_list|)
block|{
name|this
argument_list|(
name|tokenType
argument_list|,
name|temporalField
argument_list|,
literal|null
argument_list|,
name|string
argument_list|,
name|length
argument_list|,
name|fillMode
argument_list|)
expr_stmt|;
block|}
specifier|public
name|Token
parameter_list|(
name|TemporalUnit
name|temporalUnit
parameter_list|,
name|String
name|string
parameter_list|,
name|int
name|length
parameter_list|,
name|boolean
name|fillMode
parameter_list|)
block|{
name|this
argument_list|(
name|TokenType
operator|.
name|TIMEZONE
argument_list|,
literal|null
argument_list|,
name|temporalUnit
argument_list|,
name|string
argument_list|,
name|length
argument_list|,
name|fillMode
argument_list|)
expr_stmt|;
block|}
specifier|public
name|Token
parameter_list|(
name|TokenType
name|tokenType
parameter_list|,
name|String
name|string
parameter_list|)
block|{
name|this
argument_list|(
name|tokenType
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
name|string
argument_list|,
name|string
operator|.
name|length
argument_list|()
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
specifier|public
name|Token
parameter_list|(
name|TokenType
name|tokenType
parameter_list|,
name|TemporalField
name|temporalField
parameter_list|,
name|TemporalUnit
name|temporalUnit
parameter_list|,
name|String
name|string
parameter_list|,
name|int
name|length
parameter_list|,
name|boolean
name|fillMode
parameter_list|)
block|{
name|this
operator|.
name|type
operator|=
name|tokenType
expr_stmt|;
name|this
operator|.
name|temporalField
operator|=
name|temporalField
expr_stmt|;
name|this
operator|.
name|temporalUnit
operator|=
name|temporalUnit
expr_stmt|;
name|this
operator|.
name|string
operator|=
name|string
expr_stmt|;
name|this
operator|.
name|length
operator|=
name|length
expr_stmt|;
name|this
operator|.
name|fillMode
operator|=
name|fillMode
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|toString
parameter_list|()
block|{
name|StringBuilder
name|sb
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|sb
operator|.
name|append
argument_list|(
name|string
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|" type: "
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|temporalField
operator|!=
literal|null
condition|)
block|{
name|sb
operator|.
name|append
argument_list|(
literal|" temporalField: "
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
name|temporalField
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|temporalUnit
operator|!=
literal|null
condition|)
block|{
name|sb
operator|.
name|append
argument_list|(
literal|" temporalUnit: "
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
name|temporalUnit
argument_list|)
expr_stmt|;
block|}
return|return
name|sb
operator|.
name|toString
argument_list|()
return|;
block|}
specifier|public
name|void
name|removeBackslashes
parameter_list|()
block|{
name|string
operator|=
name|string
operator|.
name|replaceAll
argument_list|(
literal|"\\\\"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|length
operator|=
name|string
operator|.
name|length
argument_list|()
expr_stmt|;
block|}
block|}
specifier|public
name|HiveSqlDateTimeFormatter
parameter_list|(
name|String
name|pattern
parameter_list|,
name|boolean
name|forParsing
parameter_list|)
block|{
name|setPattern
argument_list|(
name|pattern
argument_list|,
name|forParsing
argument_list|)
expr_stmt|;
block|}
comment|/**    * Parse and perhaps verify the pattern.    */
specifier|private
name|void
name|setPattern
parameter_list|(
name|String
name|pattern
parameter_list|,
name|boolean
name|forParsing
parameter_list|)
block|{
assert|assert
name|pattern
operator|.
name|length
argument_list|()
operator|<
name|LONGEST_ACCEPTED_PATTERN
operator|:
literal|"The input format is too long"
assert|;
name|this
operator|.
name|pattern
operator|=
name|pattern
expr_stmt|;
name|parsePatternToTokens
argument_list|(
name|pattern
argument_list|)
expr_stmt|;
comment|// throw IllegalArgumentException if pattern is invalid
if|if
condition|(
name|forParsing
condition|)
block|{
name|verifyForParse
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|verifyForFormat
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Parse pattern to list of tokens.    */
specifier|private
name|void
name|parsePatternToTokens
parameter_list|(
name|String
name|pattern
parameter_list|)
block|{
name|tokens
operator|.
name|clear
argument_list|()
expr_stmt|;
name|String
name|originalPattern
init|=
name|pattern
decl_stmt|;
name|pattern
operator|=
name|pattern
operator|.
name|toLowerCase
argument_list|()
expr_stmt|;
comment|// indexes of the substring we will check (includes begin, does not include end)
name|int
name|begin
init|=
literal|0
decl_stmt|,
name|end
init|=
literal|0
decl_stmt|;
name|String
name|candidate
decl_stmt|;
name|Token
name|lastAddedToken
init|=
literal|null
decl_stmt|;
name|boolean
name|fillMode
init|=
literal|false
decl_stmt|;
while|while
condition|(
name|begin
operator|<
name|pattern
operator|.
name|length
argument_list|()
condition|)
block|{
comment|// if begin hasn't progressed, then pattern is not parsable
if|if
condition|(
name|begin
operator|!=
name|end
condition|)
block|{
name|tokens
operator|.
name|clear
argument_list|()
expr_stmt|;
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Bad date/time conversion pattern: "
operator|+
name|pattern
argument_list|)
throw|;
block|}
comment|// find next token
for|for
control|(
name|int
name|i
init|=
name|LONGEST_TOKEN_LENGTH
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|end
operator|=
name|begin
operator|+
name|i
expr_stmt|;
if|if
condition|(
name|end
operator|>
name|pattern
operator|.
name|length
argument_list|()
condition|)
block|{
comment|// don't go past the end of the pattern string
continue|continue;
block|}
name|candidate
operator|=
name|pattern
operator|.
name|substring
argument_list|(
name|begin
argument_list|,
name|end
argument_list|)
expr_stmt|;
if|if
condition|(
name|isSeparator
argument_list|(
name|candidate
argument_list|)
condition|)
block|{
name|lastAddedToken
operator|=
name|parseSeparatorToken
argument_list|(
name|candidate
argument_list|,
name|lastAddedToken
argument_list|,
name|fillMode
argument_list|,
name|begin
argument_list|)
expr_stmt|;
name|begin
operator|=
name|end
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|isIso8601Delimiter
argument_list|(
name|candidate
argument_list|)
condition|)
block|{
name|lastAddedToken
operator|=
name|parseIso8601DelimiterToken
argument_list|(
name|candidate
argument_list|,
name|fillMode
argument_list|,
name|begin
argument_list|)
expr_stmt|;
name|begin
operator|=
name|end
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|isNumericTemporalToken
argument_list|(
name|candidate
argument_list|)
condition|)
block|{
name|lastAddedToken
operator|=
name|parseTemporalToken
argument_list|(
name|originalPattern
argument_list|,
name|candidate
argument_list|,
name|fillMode
argument_list|,
name|begin
argument_list|)
expr_stmt|;
name|fillMode
operator|=
literal|false
expr_stmt|;
name|begin
operator|=
name|end
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|isCharacterTemporalToken
argument_list|(
name|candidate
argument_list|)
condition|)
block|{
name|lastAddedToken
operator|=
name|parseCharacterTemporalToken
argument_list|(
name|originalPattern
argument_list|,
name|candidate
argument_list|,
name|fillMode
argument_list|,
name|begin
argument_list|)
expr_stmt|;
name|fillMode
operator|=
literal|false
expr_stmt|;
name|begin
operator|=
name|end
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|isTimeZoneToken
argument_list|(
name|candidate
argument_list|)
condition|)
block|{
name|lastAddedToken
operator|=
name|parseTimeZoneToken
argument_list|(
name|candidate
argument_list|,
name|fillMode
argument_list|,
name|begin
argument_list|)
expr_stmt|;
name|begin
operator|=
name|end
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|isTextToken
argument_list|(
name|candidate
argument_list|)
condition|)
block|{
name|lastAddedToken
operator|=
name|parseTextToken
argument_list|(
name|originalPattern
argument_list|,
name|fillMode
argument_list|,
name|begin
argument_list|)
expr_stmt|;
name|end
operator|=
name|begin
operator|+
name|lastAddedToken
operator|.
name|length
operator|+
literal|2
expr_stmt|;
comment|// skip 2 quotation marks
name|lastAddedToken
operator|.
name|removeBackslashes
argument_list|()
expr_stmt|;
name|begin
operator|=
name|end
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|isFormatModifierToken
argument_list|(
name|candidate
argument_list|)
condition|)
block|{
name|checkFillModeOff
argument_list|(
name|fillMode
argument_list|,
name|begin
argument_list|)
expr_stmt|;
name|fillMode
operator|=
name|isFm
argument_list|(
name|candidate
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|fillMode
condition|)
block|{
name|formatExact
operator|=
literal|true
expr_stmt|;
block|}
name|begin
operator|=
name|end
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
specifier|private
name|boolean
name|isSeparator
parameter_list|(
name|String
name|candidate
parameter_list|)
block|{
return|return
name|candidate
operator|.
name|length
argument_list|()
operator|==
literal|1
operator|&&
name|VALID_SEPARATORS
operator|.
name|contains
argument_list|(
name|candidate
argument_list|)
return|;
block|}
specifier|private
name|boolean
name|isIso8601Delimiter
parameter_list|(
name|String
name|candidate
parameter_list|)
block|{
return|return
name|candidate
operator|.
name|length
argument_list|()
operator|==
literal|1
operator|&&
name|VALID_ISO_8601_DELIMITERS
operator|.
name|contains
argument_list|(
name|candidate
argument_list|)
return|;
block|}
specifier|private
name|boolean
name|isNumericTemporalToken
parameter_list|(
name|String
name|candidate
parameter_list|)
block|{
return|return
name|NUMERIC_TEMPORAL_TOKENS
operator|.
name|containsKey
argument_list|(
name|candidate
argument_list|)
return|;
block|}
specifier|private
name|boolean
name|isCharacterTemporalToken
parameter_list|(
name|String
name|candidate
parameter_list|)
block|{
return|return
name|CHARACTER_TEMPORAL_TOKENS
operator|.
name|containsKey
argument_list|(
name|candidate
argument_list|)
return|;
block|}
specifier|private
name|boolean
name|isTimeZoneToken
parameter_list|(
name|String
name|pattern
parameter_list|)
block|{
return|return
name|TIME_ZONE_TOKENS
operator|.
name|containsKey
argument_list|(
name|pattern
argument_list|)
return|;
block|}
specifier|private
name|boolean
name|isTextToken
parameter_list|(
name|String
name|candidate
parameter_list|)
block|{
return|return
name|candidate
operator|.
name|startsWith
argument_list|(
literal|"\""
argument_list|)
return|;
block|}
specifier|private
name|boolean
name|isFormatModifierToken
parameter_list|(
name|String
name|candidate
parameter_list|)
block|{
return|return
name|candidate
operator|.
name|length
argument_list|()
operator|==
literal|2
operator|&&
name|VALID_FORMAT_MODIFIERS
operator|.
name|contains
argument_list|(
name|candidate
argument_list|)
return|;
block|}
specifier|private
name|boolean
name|isFm
parameter_list|(
name|String
name|candidate
parameter_list|)
block|{
return|return
literal|"fm"
operator|.
name|equals
argument_list|(
name|candidate
argument_list|)
return|;
block|}
specifier|private
name|Token
name|parseSeparatorToken
parameter_list|(
name|String
name|candidate
parameter_list|,
name|Token
name|lastAddedToken
parameter_list|,
name|boolean
name|fillMode
parameter_list|,
name|int
name|begin
parameter_list|)
block|{
name|checkFillModeOff
argument_list|(
name|fillMode
argument_list|,
name|begin
argument_list|)
expr_stmt|;
comment|// try to clump separator with immediately preceding separators (e.g. "---" counts as one
comment|// separator)
if|if
condition|(
name|lastAddedToken
operator|!=
literal|null
operator|&&
name|lastAddedToken
operator|.
name|type
operator|==
name|TokenType
operator|.
name|SEPARATOR
condition|)
block|{
name|lastAddedToken
operator|.
name|string
operator|+=
name|candidate
expr_stmt|;
name|lastAddedToken
operator|.
name|length
operator|+=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|lastAddedToken
operator|=
operator|new
name|Token
argument_list|(
name|TokenType
operator|.
name|SEPARATOR
argument_list|,
name|candidate
argument_list|)
expr_stmt|;
name|tokens
operator|.
name|add
argument_list|(
name|lastAddedToken
argument_list|)
expr_stmt|;
block|}
return|return
name|lastAddedToken
return|;
block|}
specifier|private
name|Token
name|parseIso8601DelimiterToken
parameter_list|(
name|String
name|candidate
parameter_list|,
name|boolean
name|fillMode
parameter_list|,
name|int
name|begin
parameter_list|)
block|{
name|checkFillModeOff
argument_list|(
name|fillMode
argument_list|,
name|begin
argument_list|)
expr_stmt|;
name|Token
name|lastAddedToken
decl_stmt|;
name|lastAddedToken
operator|=
operator|new
name|Token
argument_list|(
name|TokenType
operator|.
name|ISO_8601_DELIMITER
argument_list|,
name|candidate
operator|.
name|toUpperCase
argument_list|()
argument_list|)
expr_stmt|;
name|tokens
operator|.
name|add
argument_list|(
name|lastAddedToken
argument_list|)
expr_stmt|;
return|return
name|lastAddedToken
return|;
block|}
specifier|private
name|Token
name|parseTemporalToken
parameter_list|(
name|String
name|originalPattern
parameter_list|,
name|String
name|candidate
parameter_list|,
name|boolean
name|fillMode
parameter_list|,
name|int
name|begin
parameter_list|)
block|{
comment|// for AM/PM, keep original case
if|if
condition|(
name|NUMERIC_TEMPORAL_TOKENS
operator|.
name|get
argument_list|(
name|candidate
argument_list|)
operator|==
name|ChronoField
operator|.
name|AMPM_OF_DAY
condition|)
block|{
name|int
name|subStringEnd
init|=
name|begin
operator|+
name|candidate
operator|.
name|length
argument_list|()
decl_stmt|;
name|candidate
operator|=
name|originalPattern
operator|.
name|substring
argument_list|(
name|begin
argument_list|,
name|subStringEnd
argument_list|)
expr_stmt|;
block|}
name|Token
name|lastAddedToken
init|=
operator|new
name|Token
argument_list|(
name|TokenType
operator|.
name|NUMERIC_TEMPORAL
argument_list|,
name|NUMERIC_TEMPORAL_TOKENS
operator|.
name|get
argument_list|(
name|candidate
operator|.
name|toLowerCase
argument_list|()
argument_list|)
argument_list|,
name|candidate
argument_list|,
name|getTokenStringLength
argument_list|(
name|candidate
argument_list|)
argument_list|,
name|fillMode
argument_list|)
decl_stmt|;
name|tokens
operator|.
name|add
argument_list|(
name|lastAddedToken
argument_list|)
expr_stmt|;
return|return
name|lastAddedToken
return|;
block|}
specifier|private
name|Token
name|parseCharacterTemporalToken
parameter_list|(
name|String
name|originalPattern
parameter_list|,
name|String
name|candidate
parameter_list|,
name|boolean
name|fillMode
parameter_list|,
name|int
name|begin
parameter_list|)
block|{
comment|// keep original case
name|candidate
operator|=
name|originalPattern
operator|.
name|substring
argument_list|(
name|begin
argument_list|,
name|begin
operator|+
name|candidate
operator|.
name|length
argument_list|()
argument_list|)
expr_stmt|;
name|Token
name|lastAddedToken
init|=
operator|new
name|Token
argument_list|(
name|TokenType
operator|.
name|CHARACTER_TEMPORAL
argument_list|,
name|CHARACTER_TEMPORAL_TOKENS
operator|.
name|get
argument_list|(
name|candidate
operator|.
name|toLowerCase
argument_list|()
argument_list|)
argument_list|,
name|candidate
argument_list|,
name|getTokenStringLength
argument_list|(
name|candidate
argument_list|)
argument_list|,
name|fillMode
argument_list|)
decl_stmt|;
name|tokens
operator|.
name|add
argument_list|(
name|lastAddedToken
argument_list|)
expr_stmt|;
return|return
name|lastAddedToken
return|;
block|}
specifier|private
name|Token
name|parseTimeZoneToken
parameter_list|(
name|String
name|candidate
parameter_list|,
name|boolean
name|fillMode
parameter_list|,
name|int
name|begin
parameter_list|)
block|{
name|checkFillModeOff
argument_list|(
name|fillMode
argument_list|,
name|begin
argument_list|)
expr_stmt|;
name|Token
name|lastAddedToken
init|=
operator|new
name|Token
argument_list|(
name|TIME_ZONE_TOKENS
operator|.
name|get
argument_list|(
name|candidate
argument_list|)
argument_list|,
name|candidate
argument_list|,
name|getTokenStringLength
argument_list|(
name|candidate
argument_list|)
argument_list|,
literal|false
argument_list|)
decl_stmt|;
name|tokens
operator|.
name|add
argument_list|(
name|lastAddedToken
argument_list|)
expr_stmt|;
return|return
name|lastAddedToken
return|;
block|}
specifier|private
name|Token
name|parseTextToken
parameter_list|(
name|String
name|fullPattern
parameter_list|,
name|boolean
name|fillMode
parameter_list|,
name|int
name|begin
parameter_list|)
block|{
name|checkFillModeOff
argument_list|(
name|fillMode
argument_list|,
name|begin
argument_list|)
expr_stmt|;
name|int
name|end
init|=
name|begin
decl_stmt|;
do|do
block|{
name|end
operator|=
name|fullPattern
operator|.
name|indexOf
argument_list|(
literal|'\"'
argument_list|,
name|end
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|end
operator|==
operator|-
literal|1
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Missing closing double quote (\") opened at index "
operator|+
name|begin
argument_list|)
throw|;
block|}
comment|// if double quote is escaped with a backslash, keep looking for the closing quotation mark
block|}
do|while
condition|(
literal|"\\"
operator|.
name|equals
argument_list|(
name|fullPattern
operator|.
name|substring
argument_list|(
name|end
operator|-
literal|1
argument_list|,
name|end
argument_list|)
argument_list|)
condition|)
do|;
name|Token
name|lastAddedToken
init|=
operator|new
name|Token
argument_list|(
name|TokenType
operator|.
name|TEXT
argument_list|,
name|fullPattern
operator|.
name|substring
argument_list|(
name|begin
operator|+
literal|1
argument_list|,
name|end
argument_list|)
argument_list|)
decl_stmt|;
name|tokens
operator|.
name|add
argument_list|(
name|lastAddedToken
argument_list|)
expr_stmt|;
return|return
name|lastAddedToken
return|;
block|}
specifier|private
name|void
name|checkFillModeOff
parameter_list|(
name|boolean
name|fillMode
parameter_list|,
name|int
name|index
parameter_list|)
block|{
if|if
condition|(
name|fillMode
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Bad date/time conversion pattern: "
operator|+
name|pattern
operator|+
literal|". Error at index "
operator|+
name|index
operator|+
literal|": Fill mode modifier (FM) must "
operator|+
literal|"be followed by a temporal token."
argument_list|)
throw|;
block|}
block|}
specifier|private
name|int
name|getTokenStringLength
parameter_list|(
name|String
name|candidate
parameter_list|)
block|{
name|Integer
name|length
init|=
name|SPECIAL_LENGTHS
operator|.
name|get
argument_list|(
name|candidate
operator|.
name|toLowerCase
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|length
operator|!=
literal|null
condition|)
block|{
return|return
name|length
return|;
block|}
return|return
name|candidate
operator|.
name|length
argument_list|()
return|;
block|}
comment|/**    * Make sure the generated list of tokens is valid for parsing strings to datetime objects.    */
specifier|private
name|void
name|verifyForParse
parameter_list|()
block|{
comment|// create a list of tokens' temporal fields
name|ArrayList
argument_list|<
name|TemporalField
argument_list|>
name|temporalFields
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|ArrayList
argument_list|<
name|TemporalUnit
argument_list|>
name|timeZoneTemporalUnits
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|int
name|roundYearCount
init|=
literal|0
decl_stmt|,
name|yearCount
init|=
literal|0
decl_stmt|;
name|boolean
name|containsIsoFields
init|=
literal|false
decl_stmt|,
name|containsGregorianFields
init|=
literal|false
decl_stmt|;
for|for
control|(
name|Token
name|token
range|:
name|tokens
control|)
block|{
if|if
condition|(
name|token
operator|.
name|temporalField
operator|!=
literal|null
condition|)
block|{
name|temporalFields
operator|.
name|add
argument_list|(
name|token
operator|.
name|temporalField
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|.
name|temporalField
operator|==
name|ChronoField
operator|.
name|YEAR
condition|)
block|{
if|if
condition|(
name|token
operator|.
name|string
operator|.
name|startsWith
argument_list|(
literal|"r"
argument_list|)
condition|)
block|{
name|roundYearCount
operator|+=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|yearCount
operator|+=
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|token
operator|.
name|temporalField
operator|.
name|isDateBased
argument_list|()
operator|&&
name|token
operator|.
name|temporalField
operator|!=
name|ChronoField
operator|.
name|DAY_OF_WEEK
condition|)
block|{
if|if
condition|(
name|ISO_8601_TEMPORAL_FIELDS
operator|.
name|contains
argument_list|(
name|token
operator|.
name|temporalField
argument_list|)
condition|)
block|{
name|containsIsoFields
operator|=
literal|true
expr_stmt|;
block|}
else|else
block|{
name|containsGregorianFields
operator|=
literal|true
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|token
operator|.
name|temporalUnit
operator|!=
literal|null
condition|)
block|{
name|timeZoneTemporalUnits
operator|.
name|add
argument_list|(
name|token
operator|.
name|temporalUnit
argument_list|)
expr_stmt|;
block|}
block|}
comment|//check for illegal temporal fields
if|if
condition|(
name|temporalFields
operator|.
name|contains
argument_list|(
name|IsoFields
operator|.
name|QUARTER_OF_YEAR
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Illegal field: q ("
operator|+
name|IsoFields
operator|.
name|QUARTER_OF_YEAR
operator|+
literal|")"
argument_list|)
throw|;
block|}
if|if
condition|(
name|temporalFields
operator|.
name|contains
argument_list|(
name|WeekFields
operator|.
name|SUNDAY_START
operator|.
name|dayOfWeek
argument_list|()
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Illegal field: d ("
operator|+
name|WeekFields
operator|.
name|SUNDAY_START
operator|.
name|dayOfWeek
argument_list|()
operator|+
literal|")"
argument_list|)
throw|;
block|}
if|if
condition|(
name|temporalFields
operator|.
name|contains
argument_list|(
name|ChronoField
operator|.
name|DAY_OF_WEEK
argument_list|)
operator|&&
name|containsGregorianFields
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Illegal field: dy/day ("
operator|+
name|ChronoField
operator|.
name|DAY_OF_WEEK
operator|+
literal|")"
argument_list|)
throw|;
block|}
if|if
condition|(
name|temporalFields
operator|.
name|contains
argument_list|(
name|ChronoField
operator|.
name|ALIGNED_WEEK_OF_MONTH
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Illegal field: w ("
operator|+
name|ChronoField
operator|.
name|ALIGNED_WEEK_OF_MONTH
operator|+
literal|")"
argument_list|)
throw|;
block|}
if|if
condition|(
name|temporalFields
operator|.
name|contains
argument_list|(
name|ChronoField
operator|.
name|ALIGNED_WEEK_OF_YEAR
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Illegal field: ww ("
operator|+
name|ChronoField
operator|.
name|ALIGNED_WEEK_OF_YEAR
operator|+
literal|")"
argument_list|)
throw|;
block|}
if|if
condition|(
name|containsGregorianFields
operator|&&
name|containsIsoFields
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Pattern cannot contain both ISO and Gregorian tokens"
argument_list|)
throw|;
block|}
if|if
condition|(
operator|!
operator|(
name|temporalFields
operator|.
name|contains
argument_list|(
name|ChronoField
operator|.
name|YEAR
argument_list|)
operator|||
name|temporalFields
operator|.
name|contains
argument_list|(
name|IsoFields
operator|.
name|WEEK_BASED_YEAR
argument_list|)
operator|)
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Missing year token."
argument_list|)
throw|;
block|}
if|if
condition|(
name|containsGregorianFields
operator|&&
operator|!
operator|(
name|temporalFields
operator|.
name|contains
argument_list|(
name|ChronoField
operator|.
name|MONTH_OF_YEAR
argument_list|)
operator|&&
name|temporalFields
operator|.
name|contains
argument_list|(
name|ChronoField
operator|.
name|DAY_OF_MONTH
argument_list|)
operator|||
name|temporalFields
operator|.
name|contains
argument_list|(
name|ChronoField
operator|.
name|DAY_OF_YEAR
argument_list|)
operator|)
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Missing day of year or (month of year + day of month)"
operator|+
literal|" tokens."
argument_list|)
throw|;
block|}
if|if
condition|(
name|containsIsoFields
operator|&&
operator|!
operator|(
name|temporalFields
operator|.
name|contains
argument_list|(
name|IsoFields
operator|.
name|WEEK_OF_WEEK_BASED_YEAR
argument_list|)
operator|&&
name|temporalFields
operator|.
name|contains
argument_list|(
name|ChronoField
operator|.
name|DAY_OF_WEEK
argument_list|)
operator|)
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Missing week of year (iw) or day of week (id) tokens."
argument_list|)
throw|;
block|}
if|if
condition|(
name|roundYearCount
operator|>
literal|0
operator|&&
name|yearCount
operator|>
literal|0
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Invalid duplication of format element: Both year and"
operator|+
literal|"round year are provided"
argument_list|)
throw|;
block|}
for|for
control|(
name|TemporalField
name|tokenType
range|:
name|temporalFields
control|)
block|{
if|if
condition|(
name|Collections
operator|.
name|frequency
argument_list|(
name|temporalFields
argument_list|,
name|tokenType
argument_list|)
operator|>
literal|1
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Invalid duplication of format element: multiple "
operator|+
name|tokenType
operator|.
name|toString
argument_list|()
operator|+
literal|" tokens provided."
argument_list|)
throw|;
block|}
block|}
if|if
condition|(
name|temporalFields
operator|.
name|contains
argument_list|(
name|ChronoField
operator|.
name|AMPM_OF_DAY
argument_list|)
operator|&&
operator|!
operator|(
name|temporalFields
operator|.
name|contains
argument_list|(
name|ChronoField
operator|.
name|HOUR_OF_DAY
argument_list|)
operator|||
name|temporalFields
operator|.
name|contains
argument_list|(
name|ChronoField
operator|.
name|HOUR_OF_AMPM
argument_list|)
operator|)
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"AM/PM provided but missing hour token."
argument_list|)
throw|;
block|}
if|if
condition|(
name|temporalFields
operator|.
name|contains
argument_list|(
name|ChronoField
operator|.
name|AMPM_OF_DAY
argument_list|)
operator|&&
name|temporalFields
operator|.
name|contains
argument_list|(
name|ChronoField
operator|.
name|HOUR_OF_DAY
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Conflict between median indicator and hour token."
argument_list|)
throw|;
block|}
if|if
condition|(
name|temporalFields
operator|.
name|contains
argument_list|(
name|ChronoField
operator|.
name|HOUR_OF_AMPM
argument_list|)
operator|&&
name|temporalFields
operator|.
name|contains
argument_list|(
name|ChronoField
operator|.
name|HOUR_OF_DAY
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Conflict between hour of day and hour of am/pm token."
argument_list|)
throw|;
block|}
if|if
condition|(
name|temporalFields
operator|.
name|contains
argument_list|(
name|ChronoField
operator|.
name|DAY_OF_YEAR
argument_list|)
operator|&&
operator|(
name|temporalFields
operator|.
name|contains
argument_list|(
name|ChronoField
operator|.
name|DAY_OF_MONTH
argument_list|)
operator|||
name|temporalFields
operator|.
name|contains
argument_list|(
name|ChronoField
operator|.
name|MONTH_OF_YEAR
argument_list|)
operator|)
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Day of year provided with day or month token."
argument_list|)
throw|;
block|}
if|if
condition|(
name|temporalFields
operator|.
name|contains
argument_list|(
name|ChronoField
operator|.
name|SECOND_OF_DAY
argument_list|)
operator|&&
operator|(
name|temporalFields
operator|.
name|contains
argument_list|(
name|ChronoField
operator|.
name|HOUR_OF_DAY
argument_list|)
operator|||
name|temporalFields
operator|.
name|contains
argument_list|(
name|ChronoField
operator|.
name|HOUR_OF_AMPM
argument_list|)
operator|||
name|temporalFields
operator|.
name|contains
argument_list|(
name|ChronoField
operator|.
name|MINUTE_OF_HOUR
argument_list|)
operator|||
name|temporalFields
operator|.
name|contains
argument_list|(
name|ChronoField
operator|.
name|SECOND_OF_MINUTE
argument_list|)
operator|)
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Second of day token conflicts with other token(s)."
argument_list|)
throw|;
block|}
if|if
condition|(
name|timeZoneTemporalUnits
operator|.
name|contains
argument_list|(
name|ChronoUnit
operator|.
name|MINUTES
argument_list|)
operator|&&
operator|!
name|timeZoneTemporalUnits
operator|.
name|contains
argument_list|(
name|ChronoUnit
operator|.
name|HOURS
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Time zone minute token provided without time zone hour token."
argument_list|)
throw|;
block|}
block|}
comment|/**    * Make sure the generated list of tokens is valid for formatting datetime objects to strings.    */
specifier|private
name|void
name|verifyForFormat
parameter_list|()
block|{
for|for
control|(
name|Token
name|token
range|:
name|tokens
control|)
block|{
if|if
condition|(
name|token
operator|.
name|type
operator|==
name|TokenType
operator|.
name|TIMEZONE
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
name|token
operator|.
name|string
operator|.
name|toUpperCase
argument_list|()
operator|+
literal|" not a valid format for "
operator|+
literal|"timestamp or date."
argument_list|)
throw|;
block|}
if|if
condition|(
name|token
operator|.
name|type
operator|==
name|TokenType
operator|.
name|CHARACTER_TEMPORAL
condition|)
block|{
name|String
name|s
init|=
name|token
operator|.
name|string
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|s
operator|.
name|equals
argument_list|(
name|s
operator|.
name|toUpperCase
argument_list|()
argument_list|)
operator|||
name|s
operator|.
name|equals
argument_list|(
name|capitalize
argument_list|(
name|s
argument_list|)
argument_list|)
operator|||
name|s
operator|.
name|equals
argument_list|(
name|s
operator|.
name|toLowerCase
argument_list|()
argument_list|)
operator|)
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Ambiguous capitalization of token "
operator|+
name|s
operator|+
literal|". Accepted "
operator|+
literal|"forms are "
operator|+
name|s
operator|.
name|toUpperCase
argument_list|()
operator|+
literal|", "
operator|+
name|capitalize
argument_list|(
name|s
argument_list|)
operator|+
literal|", or "
operator|+
name|s
operator|.
name|toLowerCase
argument_list|()
operator|+
literal|"."
argument_list|)
throw|;
block|}
block|}
block|}
block|}
specifier|public
name|String
name|format
parameter_list|(
name|Timestamp
name|ts
parameter_list|)
block|{
name|StringBuilder
name|fullOutputSb
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|String
name|outputString
init|=
literal|null
decl_stmt|;
name|int
name|value
decl_stmt|;
name|LocalDateTime
name|localDateTime
init|=
name|LocalDateTime
operator|.
name|ofEpochSecond
argument_list|(
name|ts
operator|.
name|toEpochSecond
argument_list|()
argument_list|,
name|ts
operator|.
name|getNanos
argument_list|()
argument_list|,
name|ZoneOffset
operator|.
name|UTC
argument_list|)
decl_stmt|;
for|for
control|(
name|Token
name|token
range|:
name|tokens
control|)
block|{
switch|switch
condition|(
name|token
operator|.
name|type
condition|)
block|{
case|case
name|NUMERIC_TEMPORAL
case|:
case|case
name|CHARACTER_TEMPORAL
case|:
try|try
block|{
name|value
operator|=
name|localDateTime
operator|.
name|get
argument_list|(
name|token
operator|.
name|temporalField
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|.
name|type
operator|==
name|TokenType
operator|.
name|NUMERIC_TEMPORAL
condition|)
block|{
name|outputString
operator|=
name|formatNumericTemporal
argument_list|(
name|value
argument_list|,
name|token
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|outputString
operator|=
name|formatCharacterTemporal
argument_list|(
name|value
argument_list|,
name|token
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|DateTimeException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
name|token
operator|.
name|temporalField
operator|+
literal|" couldn't be obtained from "
operator|+
literal|"LocalDateTime "
operator|+
name|localDateTime
argument_list|,
name|e
argument_list|)
throw|;
block|}
break|break;
case|case
name|TIMEZONE
case|:
comment|//invalid for timestamp and date
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
name|token
operator|.
name|string
operator|.
name|toUpperCase
argument_list|()
operator|+
literal|" not a valid format for "
operator|+
literal|"timestamp or date."
argument_list|)
throw|;
case|case
name|SEPARATOR
case|:
case|case
name|TEXT
case|:
name|outputString
operator|=
name|token
operator|.
name|string
expr_stmt|;
break|break;
case|case
name|ISO_8601_DELIMITER
case|:
name|outputString
operator|=
name|token
operator|.
name|string
operator|.
name|toUpperCase
argument_list|()
expr_stmt|;
break|break;
default|default:
comment|// won't happen
block|}
name|fullOutputSb
operator|.
name|append
argument_list|(
name|outputString
argument_list|)
expr_stmt|;
block|}
return|return
name|fullOutputSb
operator|.
name|toString
argument_list|()
return|;
block|}
specifier|public
name|String
name|format
parameter_list|(
name|Date
name|date
parameter_list|)
block|{
return|return
name|format
argument_list|(
name|Timestamp
operator|.
name|ofEpochSecond
argument_list|(
name|date
operator|.
name|toEpochSecond
argument_list|()
argument_list|)
argument_list|)
return|;
block|}
specifier|private
name|String
name|formatNumericTemporal
parameter_list|(
name|int
name|value
parameter_list|,
name|Token
name|token
parameter_list|)
block|{
name|String
name|output
decl_stmt|;
if|if
condition|(
name|token
operator|.
name|temporalField
operator|==
name|ChronoField
operator|.
name|AMPM_OF_DAY
condition|)
block|{
name|output
operator|=
name|value
operator|==
literal|0
condition|?
literal|"a"
else|:
literal|"p"
expr_stmt|;
name|output
operator|+=
name|token
operator|.
name|string
operator|.
name|length
argument_list|()
operator|==
literal|2
condition|?
literal|"m"
else|:
literal|".m."
expr_stmt|;
if|if
condition|(
name|token
operator|.
name|string
operator|.
name|startsWith
argument_list|(
literal|"A"
argument_list|)
operator|||
name|token
operator|.
name|string
operator|.
name|startsWith
argument_list|(
literal|"P"
argument_list|)
condition|)
block|{
name|output
operator|=
name|output
operator|.
name|toUpperCase
argument_list|()
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// it's a numeric value
if|if
condition|(
name|token
operator|.
name|temporalField
operator|==
name|ChronoField
operator|.
name|HOUR_OF_AMPM
operator|&&
name|value
operator|==
literal|0
condition|)
block|{
name|value
operator|=
literal|12
expr_stmt|;
block|}
try|try
block|{
name|output
operator|=
name|String
operator|.
name|valueOf
argument_list|(
name|value
argument_list|)
expr_stmt|;
name|output
operator|=
name|padOrTruncateNumericTemporal
argument_list|(
name|token
argument_list|,
name|output
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Value: "
operator|+
name|value
operator|+
literal|" couldn't be cast to string."
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
return|return
name|output
return|;
block|}
specifier|private
name|String
name|formatCharacterTemporal
parameter_list|(
name|int
name|value
parameter_list|,
name|Token
name|token
parameter_list|)
block|{
name|String
name|output
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|token
operator|.
name|temporalField
operator|==
name|ChronoField
operator|.
name|MONTH_OF_YEAR
condition|)
block|{
name|output
operator|=
name|Month
operator|.
name|of
argument_list|(
name|value
argument_list|)
operator|.
name|getDisplayName
argument_list|(
name|TextStyle
operator|.
name|FULL
argument_list|,
name|Locale
operator|.
name|US
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|token
operator|.
name|temporalField
operator|==
name|ChronoField
operator|.
name|DAY_OF_WEEK
condition|)
block|{
name|output
operator|=
name|DayOfWeek
operator|.
name|of
argument_list|(
name|value
argument_list|)
operator|.
name|getDisplayName
argument_list|(
name|TextStyle
operator|.
name|FULL
argument_list|,
name|Locale
operator|.
name|US
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|output
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"TemporalField: "
operator|+
name|token
operator|.
name|temporalField
operator|+
literal|" not valid for "
operator|+
literal|"character formatting."
argument_list|)
throw|;
block|}
comment|// set length
if|if
condition|(
name|output
operator|.
name|length
argument_list|()
operator|>
name|token
operator|.
name|length
condition|)
block|{
name|output
operator|=
name|output
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|token
operator|.
name|length
argument_list|)
expr_stmt|;
comment|// truncate to length
block|}
elseif|else
if|if
condition|(
operator|!
name|token
operator|.
name|fillMode
operator|&&
name|output
operator|.
name|length
argument_list|()
operator|<
name|token
operator|.
name|length
condition|)
block|{
name|output
operator|=
name|StringUtils
operator|.
name|rightPad
argument_list|(
name|output
argument_list|,
name|token
operator|.
name|length
argument_list|)
expr_stmt|;
comment|//pad to size
block|}
comment|// set case
if|if
condition|(
name|Character
operator|.
name|isUpperCase
argument_list|(
name|token
operator|.
name|string
operator|.
name|charAt
argument_list|(
literal|1
argument_list|)
argument_list|)
condition|)
block|{
name|output
operator|=
name|output
operator|.
name|toUpperCase
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|Character
operator|.
name|isLowerCase
argument_list|(
name|token
operator|.
name|string
operator|.
name|charAt
argument_list|(
literal|0
argument_list|)
argument_list|)
condition|)
block|{
name|output
operator|=
name|output
operator|.
name|toLowerCase
argument_list|()
expr_stmt|;
block|}
return|return
name|output
return|;
block|}
comment|/**    * To match token.length, pad left with zeroes or truncate.    * Omit padding if fill mode (FM) modifier on.    */
specifier|private
name|String
name|padOrTruncateNumericTemporal
parameter_list|(
name|Token
name|token
parameter_list|,
name|String
name|output
parameter_list|)
block|{
comment|//exception
if|if
condition|(
name|token
operator|.
name|temporalField
operator|==
name|ChronoField
operator|.
name|NANO_OF_SECOND
condition|)
block|{
name|output
operator|=
name|StringUtils
operator|.
name|leftPad
argument_list|(
name|output
argument_list|,
literal|9
argument_list|,
literal|'0'
argument_list|)
expr_stmt|;
comment|// pad left to length 9
if|if
condition|(
name|output
operator|.
name|length
argument_list|()
operator|>
name|token
operator|.
name|length
condition|)
block|{
name|output
operator|=
name|output
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|token
operator|.
name|length
argument_list|)
expr_stmt|;
comment|// truncate right to size
block|}
if|if
condition|(
name|token
operator|.
name|string
operator|.
name|equalsIgnoreCase
argument_list|(
literal|"ff"
argument_list|)
condition|)
block|{
name|output
operator|=
name|output
operator|.
name|replaceAll
argument_list|(
literal|"0*$"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
comment|//truncate trailing 0's
block|}
comment|// the rule
block|}
else|else
block|{
if|if
condition|(
name|output
operator|.
name|length
argument_list|()
operator|<
name|token
operator|.
name|length
operator|&&
operator|!
name|token
operator|.
name|fillMode
condition|)
block|{
name|output
operator|=
name|StringUtils
operator|.
name|leftPad
argument_list|(
name|output
argument_list|,
name|token
operator|.
name|length
argument_list|,
literal|'0'
argument_list|)
expr_stmt|;
comment|// pad left
block|}
elseif|else
if|if
condition|(
name|output
operator|.
name|length
argument_list|()
operator|>
name|token
operator|.
name|length
condition|)
block|{
name|output
operator|=
name|output
operator|.
name|substring
argument_list|(
name|output
operator|.
name|length
argument_list|()
operator|-
name|token
operator|.
name|length
argument_list|)
expr_stmt|;
comment|// truncate left
block|}
if|if
condition|(
name|token
operator|.
name|fillMode
condition|)
block|{
name|output
operator|=
name|output
operator|.
name|replaceAll
argument_list|(
literal|"^0*"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
comment|//truncate leading 0's
block|}
block|}
if|if
condition|(
name|output
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|output
operator|=
literal|"0"
expr_stmt|;
block|}
return|return
name|output
return|;
block|}
specifier|public
name|Timestamp
name|parseTimestamp
parameter_list|(
name|String
name|fullInput
parameter_list|)
block|{
name|LocalDateTime
name|ldt
init|=
name|LocalDateTime
operator|.
name|ofInstant
argument_list|(
name|Instant
operator|.
name|EPOCH
argument_list|,
name|ZoneOffset
operator|.
name|UTC
argument_list|)
decl_stmt|;
name|String
name|substring
decl_stmt|;
name|int
name|index
init|=
literal|0
decl_stmt|;
name|int
name|value
decl_stmt|;
name|int
name|timeZoneSign
init|=
literal|0
decl_stmt|,
name|timeZoneHours
init|=
literal|0
decl_stmt|,
name|timeZoneMinutes
init|=
literal|0
decl_stmt|;
name|int
name|iyyy
init|=
literal|0
decl_stmt|,
name|iw
init|=
literal|0
decl_stmt|;
for|for
control|(
name|Token
name|token
range|:
name|tokens
control|)
block|{
switch|switch
condition|(
name|token
operator|.
name|type
condition|)
block|{
case|case
name|NUMERIC_TEMPORAL
case|:
case|case
name|CHARACTER_TEMPORAL
case|:
if|if
condition|(
name|token
operator|.
name|type
operator|==
name|TokenType
operator|.
name|NUMERIC_TEMPORAL
condition|)
block|{
name|substring
operator|=
name|getNextNumericSubstring
argument_list|(
name|fullInput
argument_list|,
name|index
argument_list|,
name|token
argument_list|)
expr_stmt|;
comment|// e.g. yy-m -> yy
name|value
operator|=
name|parseNumericTemporal
argument_list|(
name|substring
argument_list|,
name|token
argument_list|)
expr_stmt|;
comment|// e.g. 18->2018
block|}
else|else
block|{
name|substring
operator|=
name|getNextCharacterSubstring
argument_list|(
name|fullInput
argument_list|,
name|index
argument_list|,
name|token
argument_list|)
expr_stmt|;
comment|//e.g. Marcharch -> March
name|value
operator|=
name|parseCharacterTemporal
argument_list|(
name|substring
argument_list|,
name|token
argument_list|)
expr_stmt|;
comment|// e.g. July->07
block|}
try|try
block|{
name|ldt
operator|=
name|ldt
operator|.
name|with
argument_list|(
name|token
operator|.
name|temporalField
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|DateTimeException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Value "
operator|+
name|value
operator|+
literal|" not valid for token "
operator|+
name|token
operator|.
name|toString
argument_list|()
argument_list|)
throw|;
block|}
comment|//update IYYY and IW if necessary
if|if
condition|(
name|token
operator|.
name|temporalField
operator|==
name|IsoFields
operator|.
name|WEEK_BASED_YEAR
condition|)
block|{
name|iyyy
operator|=
name|value
expr_stmt|;
block|}
if|if
condition|(
name|token
operator|.
name|temporalField
operator|==
name|IsoFields
operator|.
name|WEEK_OF_WEEK_BASED_YEAR
condition|)
block|{
name|iw
operator|=
name|value
expr_stmt|;
block|}
name|index
operator|+=
name|substring
operator|.
name|length
argument_list|()
expr_stmt|;
break|break;
case|case
name|TIMEZONE
case|:
if|if
condition|(
name|token
operator|.
name|temporalUnit
operator|==
name|ChronoUnit
operator|.
name|HOURS
condition|)
block|{
name|String
name|nextCharacter
init|=
name|fullInput
operator|.
name|substring
argument_list|(
name|index
argument_list|,
name|index
operator|+
literal|1
argument_list|)
decl_stmt|;
name|timeZoneSign
operator|=
literal|"-"
operator|.
name|equals
argument_list|(
name|nextCharacter
argument_list|)
condition|?
operator|-
literal|1
else|:
literal|1
expr_stmt|;
if|if
condition|(
literal|"-"
operator|.
name|equals
argument_list|(
name|nextCharacter
argument_list|)
operator|||
literal|"+"
operator|.
name|equals
argument_list|(
name|nextCharacter
argument_list|)
condition|)
block|{
name|index
operator|++
expr_stmt|;
block|}
comment|// parse next two digits
name|substring
operator|=
name|getNextNumericSubstring
argument_list|(
name|fullInput
argument_list|,
name|index
argument_list|,
name|index
operator|+
literal|2
argument_list|,
name|token
argument_list|)
expr_stmt|;
try|try
block|{
name|timeZoneHours
operator|=
name|Integer
operator|.
name|parseInt
argument_list|(
name|substring
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|NumberFormatException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Couldn't parse substring \""
operator|+
name|substring
operator|+
literal|"\" with token "
operator|+
name|token
operator|+
literal|" to int. Pattern is "
operator|+
name|pattern
argument_list|,
name|e
argument_list|)
throw|;
block|}
if|if
condition|(
name|timeZoneHours
argument_list|<
operator|-
literal|15
operator|||
name|timeZoneHours
argument_list|>
literal|15
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Couldn't parse substring \""
operator|+
name|substring
operator|+
literal|"\" to TZH because TZH range is -15 to +15. Pattern is "
operator|+
name|pattern
argument_list|)
throw|;
block|}
block|}
else|else
block|{
comment|// time zone minutes
name|substring
operator|=
name|getNextNumericSubstring
argument_list|(
name|fullInput
argument_list|,
name|index
argument_list|,
name|token
argument_list|)
expr_stmt|;
try|try
block|{
name|timeZoneMinutes
operator|=
name|Integer
operator|.
name|parseInt
argument_list|(
name|substring
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|NumberFormatException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Couldn't parse substring \""
operator|+
name|substring
operator|+
literal|"\" with token "
operator|+
name|token
operator|+
literal|" to int. Pattern is "
operator|+
name|pattern
argument_list|,
name|e
argument_list|)
throw|;
block|}
if|if
condition|(
name|timeZoneMinutes
argument_list|<
literal|0
operator|||
name|timeZoneMinutes
argument_list|>
literal|59
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Couldn't parse substring \""
operator|+
name|substring
operator|+
literal|"\" to TZM because TZM range is 0 to 59. Pattern is "
operator|+
name|pattern
argument_list|)
throw|;
block|}
block|}
name|index
operator|+=
name|substring
operator|.
name|length
argument_list|()
expr_stmt|;
break|break;
case|case
name|SEPARATOR
case|:
name|index
operator|=
name|parseSeparator
argument_list|(
name|fullInput
argument_list|,
name|index
argument_list|,
name|token
argument_list|)
expr_stmt|;
break|break;
case|case
name|ISO_8601_DELIMITER
case|:
case|case
name|TEXT
case|:
name|index
operator|=
name|parseText
argument_list|(
name|fullInput
argument_list|,
name|index
argument_list|,
name|token
argument_list|)
expr_stmt|;
default|default:
comment|//do nothing
block|}
block|}
comment|// anything left unparsed at end of string? throw error
if|if
condition|(
operator|!
name|fullInput
operator|.
name|substring
argument_list|(
name|index
argument_list|)
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Leftover input after parsing: "
operator|+
name|fullInput
operator|.
name|substring
argument_list|(
name|index
argument_list|)
operator|+
literal|" in string "
operator|+
name|fullInput
argument_list|)
throw|;
block|}
name|checkForInvalidIsoWeek
argument_list|(
name|iyyy
argument_list|,
name|iw
argument_list|)
expr_stmt|;
return|return
name|Timestamp
operator|.
name|ofEpochSecond
argument_list|(
name|ldt
operator|.
name|toEpochSecond
argument_list|(
name|ZoneOffset
operator|.
name|UTC
argument_list|)
argument_list|,
name|ldt
operator|.
name|getNano
argument_list|()
argument_list|)
return|;
block|}
comment|/**    * Check for WEEK_OF_WEEK_BASED_YEAR (iw) value 53 when WEEK_BASED_YEAR (iyyy) does not have 53    * weeks.    */
specifier|private
name|void
name|checkForInvalidIsoWeek
parameter_list|(
name|int
name|iyyy
parameter_list|,
name|int
name|iw
parameter_list|)
block|{
if|if
condition|(
name|iyyy
operator|==
literal|0
condition|)
block|{
return|return;
block|}
name|LocalDateTime
name|ldt
init|=
name|LocalDateTime
operator|.
name|ofInstant
argument_list|(
name|Instant
operator|.
name|EPOCH
argument_list|,
name|ZoneOffset
operator|.
name|UTC
argument_list|)
decl_stmt|;
name|ldt
operator|=
name|ldt
operator|.
name|with
argument_list|(
name|IsoFields
operator|.
name|WEEK_BASED_YEAR
argument_list|,
name|iyyy
argument_list|)
expr_stmt|;
name|ldt
operator|=
name|ldt
operator|.
name|with
argument_list|(
name|IsoFields
operator|.
name|WEEK_OF_WEEK_BASED_YEAR
argument_list|,
name|iw
argument_list|)
expr_stmt|;
if|if
condition|(
name|ldt
operator|.
name|getYear
argument_list|()
operator|!=
name|iyyy
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"ISO year "
operator|+
name|iyyy
operator|+
literal|" does not have "
operator|+
name|iw
operator|+
literal|" weeks."
argument_list|)
throw|;
block|}
block|}
specifier|public
name|Date
name|parseDate
parameter_list|(
name|String
name|input
parameter_list|)
block|{
return|return
name|Date
operator|.
name|ofEpochMilli
argument_list|(
name|parseTimestamp
argument_list|(
name|input
argument_list|)
operator|.
name|toEpochMilli
argument_list|()
argument_list|)
return|;
block|}
comment|/**    * Return the next substring to parse. Length is either specified or token.length, but a    * separator or an ISO-8601 delimiter can cut the substring short. (e.g. if the token pattern is    * "YYYY" we expect the next 4 characters to be 4 numbers. However, if it is "976/" then we    * return "976" because a separator cuts it short.)    */
specifier|private
name|String
name|getNextNumericSubstring
parameter_list|(
name|String
name|s
parameter_list|,
name|int
name|begin
parameter_list|,
name|Token
name|token
parameter_list|)
block|{
return|return
name|getNextNumericSubstring
argument_list|(
name|s
argument_list|,
name|begin
argument_list|,
name|begin
operator|+
name|token
operator|.
name|length
argument_list|,
name|token
argument_list|)
return|;
block|}
specifier|private
name|String
name|getNextNumericSubstring
parameter_list|(
name|String
name|s
parameter_list|,
name|int
name|begin
parameter_list|,
name|int
name|end
parameter_list|,
name|Token
name|token
parameter_list|)
block|{
if|if
condition|(
name|end
operator|>
name|s
operator|.
name|length
argument_list|()
condition|)
block|{
name|end
operator|=
name|s
operator|.
name|length
argument_list|()
expr_stmt|;
block|}
name|s
operator|=
name|s
operator|.
name|substring
argument_list|(
name|begin
argument_list|,
name|end
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|.
name|temporalField
operator|==
name|ChronoField
operator|.
name|AMPM_OF_DAY
condition|)
block|{
if|if
condition|(
name|s
operator|.
name|charAt
argument_list|(
literal|1
argument_list|)
operator|==
literal|'m'
operator|||
name|s
operator|.
name|charAt
argument_list|(
literal|1
argument_list|)
operator|==
literal|'M'
condition|)
block|{
comment|// length 2
return|return
name|s
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
literal|2
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|s
return|;
block|}
block|}
comment|// if it's a character temporal, the first non-letter character is a delimiter
if|if
condition|(
name|token
operator|.
name|type
operator|==
name|TokenType
operator|.
name|CHARACTER_TEMPORAL
operator|&&
name|s
operator|.
name|matches
argument_list|(
literal|".*[^A-Za-z].*"
argument_list|)
condition|)
block|{
name|s
operator|=
name|s
operator|.
name|split
argument_list|(
literal|"[^A-Za-z]"
argument_list|,
literal|2
argument_list|)
index|[
literal|0
index|]
expr_stmt|;
comment|// if it's a numeric element, next non-numeric character is a delimiter. Don't worry about
comment|// AM/PM since we've already handled that case.
block|}
elseif|else
if|if
condition|(
operator|(
name|token
operator|.
name|type
operator|==
name|TokenType
operator|.
name|NUMERIC_TEMPORAL
operator|||
name|token
operator|.
name|type
operator|==
name|TokenType
operator|.
name|TIMEZONE
operator|)
operator|&&
name|s
operator|.
name|matches
argument_list|(
literal|".*\\D.*"
argument_list|)
condition|)
block|{
name|s
operator|=
name|s
operator|.
name|split
argument_list|(
literal|"\\D"
argument_list|,
literal|2
argument_list|)
index|[
literal|0
index|]
expr_stmt|;
block|}
return|return
name|s
return|;
block|}
comment|/**    * Get the integer value of a temporal substring.    */
specifier|private
name|int
name|parseNumericTemporal
parameter_list|(
name|String
name|substring
parameter_list|,
name|Token
name|token
parameter_list|)
block|{
name|checkFormatExact
argument_list|(
name|substring
argument_list|,
name|token
argument_list|)
expr_stmt|;
comment|// exceptions to the rule
if|if
condition|(
name|token
operator|.
name|temporalField
operator|==
name|ChronoField
operator|.
name|AMPM_OF_DAY
condition|)
block|{
return|return
name|substring
operator|.
name|toLowerCase
argument_list|()
operator|.
name|startsWith
argument_list|(
literal|"a"
argument_list|)
condition|?
name|AM
else|:
name|PM
return|;
block|}
elseif|else
if|if
condition|(
name|token
operator|.
name|temporalField
operator|==
name|ChronoField
operator|.
name|HOUR_OF_AMPM
operator|&&
literal|"12"
operator|.
name|equals
argument_list|(
name|substring
argument_list|)
condition|)
block|{
name|substring
operator|=
literal|"0"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|token
operator|.
name|temporalField
operator|==
name|ChronoField
operator|.
name|YEAR
operator|||
name|token
operator|.
name|temporalField
operator|==
name|IsoFields
operator|.
name|WEEK_BASED_YEAR
condition|)
block|{
name|String
name|currentYearString
decl_stmt|;
if|if
condition|(
name|token
operator|.
name|temporalField
operator|==
name|ChronoField
operator|.
name|YEAR
condition|)
block|{
name|currentYearString
operator|=
name|String
operator|.
name|valueOf
argument_list|(
name|LocalDateTime
operator|.
name|now
argument_list|()
operator|.
name|getYear
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|currentYearString
operator|=
name|String
operator|.
name|valueOf
argument_list|(
name|LocalDateTime
operator|.
name|now
argument_list|()
operator|.
name|get
argument_list|(
name|IsoFields
operator|.
name|WEEK_BASED_YEAR
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|//deal with round years
if|if
condition|(
name|token
operator|.
name|string
operator|.
name|startsWith
argument_list|(
literal|"r"
argument_list|)
operator|&&
name|substring
operator|.
name|length
argument_list|()
operator|==
literal|2
condition|)
block|{
name|int
name|currFirst2Digits
init|=
name|Integer
operator|.
name|parseInt
argument_list|(
name|currentYearString
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
literal|2
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|currLast2Digits
init|=
name|Integer
operator|.
name|parseInt
argument_list|(
name|currentYearString
operator|.
name|substring
argument_list|(
literal|2
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|valLast2Digits
init|=
name|Integer
operator|.
name|parseInt
argument_list|(
name|substring
argument_list|)
decl_stmt|;
if|if
condition|(
name|valLast2Digits
operator|<
literal|50
operator|&&
name|currLast2Digits
operator|>=
literal|50
condition|)
block|{
name|currFirst2Digits
operator|+=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|valLast2Digits
operator|>=
literal|50
operator|&&
name|currLast2Digits
operator|<
literal|50
condition|)
block|{
name|currFirst2Digits
operator|-=
literal|1
expr_stmt|;
block|}
name|substring
operator|=
name|String
operator|.
name|valueOf
argument_list|(
name|currFirst2Digits
argument_list|)
operator|+
name|substring
expr_stmt|;
block|}
else|else
block|{
comment|// fill in prefix digits with current date
name|substring
operator|=
name|currentYearString
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
literal|4
operator|-
name|substring
operator|.
name|length
argument_list|()
argument_list|)
operator|+
name|substring
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|token
operator|.
name|temporalField
operator|==
name|ChronoField
operator|.
name|NANO_OF_SECOND
condition|)
block|{
name|int
name|i
init|=
name|Integer
operator|.
name|min
argument_list|(
name|token
operator|.
name|length
argument_list|,
name|substring
operator|.
name|length
argument_list|()
argument_list|)
decl_stmt|;
name|substring
operator|+=
name|StringUtils
operator|.
name|repeat
argument_list|(
literal|"0"
argument_list|,
name|NANOS_MAX_LENGTH
operator|-
name|i
argument_list|)
expr_stmt|;
block|}
comment|// the rule
try|try
block|{
return|return
name|Integer
operator|.
name|parseInt
argument_list|(
name|substring
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|NumberFormatException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Couldn't parse substring \""
operator|+
name|substring
operator|+
literal|"\" with token "
operator|+
name|token
operator|+
literal|" to integer. Pattern is "
operator|+
name|pattern
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
specifier|private
specifier|static
specifier|final
name|String
name|MONTH_REGEX
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|String
name|DAY_OF_WEEK_REGEX
decl_stmt|;
static|static
block|{
name|StringBuilder
name|sb
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|String
name|or
init|=
literal|""
decl_stmt|;
for|for
control|(
name|Month
name|month
range|:
name|Month
operator|.
name|values
argument_list|()
control|)
block|{
name|sb
operator|.
name|append
argument_list|(
name|or
argument_list|)
operator|.
name|append
argument_list|(
name|month
argument_list|)
expr_stmt|;
name|or
operator|=
literal|"|"
expr_stmt|;
block|}
name|MONTH_REGEX
operator|=
name|sb
operator|.
name|toString
argument_list|()
expr_stmt|;
name|sb
operator|=
operator|new
name|StringBuilder
argument_list|()
expr_stmt|;
name|or
operator|=
literal|""
expr_stmt|;
for|for
control|(
name|DayOfWeek
name|dayOfWeek
range|:
name|DayOfWeek
operator|.
name|values
argument_list|()
control|)
block|{
name|sb
operator|.
name|append
argument_list|(
name|or
argument_list|)
operator|.
name|append
argument_list|(
name|dayOfWeek
argument_list|)
expr_stmt|;
name|or
operator|=
literal|"|"
expr_stmt|;
block|}
name|DAY_OF_WEEK_REGEX
operator|=
name|sb
operator|.
name|toString
argument_list|()
expr_stmt|;
block|}
specifier|private
name|String
name|getNextCharacterSubstring
parameter_list|(
name|String
name|fullInput
parameter_list|,
name|int
name|index
parameter_list|,
name|Token
name|token
parameter_list|)
block|{
name|int
name|end
init|=
name|index
operator|+
name|token
operator|.
name|length
decl_stmt|;
if|if
condition|(
name|end
operator|>
name|fullInput
operator|.
name|length
argument_list|()
condition|)
block|{
name|end
operator|=
name|fullInput
operator|.
name|length
argument_list|()
expr_stmt|;
block|}
name|String
name|substring
init|=
name|fullInput
operator|.
name|substring
argument_list|(
name|index
argument_list|,
name|end
argument_list|)
decl_stmt|;
if|if
condition|(
name|token
operator|.
name|length
operator|==
literal|3
condition|)
block|{
comment|//dy, mon
return|return
name|substring
return|;
block|}
comment|// patterns day, month
name|String
name|regex
decl_stmt|;
if|if
condition|(
name|token
operator|.
name|temporalField
operator|==
name|ChronoField
operator|.
name|MONTH_OF_YEAR
condition|)
block|{
name|regex
operator|=
name|MONTH_REGEX
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|token
operator|.
name|temporalField
operator|==
name|ChronoField
operator|.
name|DAY_OF_WEEK
condition|)
block|{
name|regex
operator|=
name|DAY_OF_WEEK_REGEX
expr_stmt|;
block|}
else|else
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Error at index "
operator|+
name|index
operator|+
literal|": "
operator|+
name|token
operator|+
literal|" not a "
operator|+
literal|"character temporal with length not 3"
argument_list|)
throw|;
block|}
name|Matcher
name|matcher
init|=
name|Pattern
operator|.
name|compile
argument_list|(
name|regex
argument_list|,
name|Pattern
operator|.
name|CASE_INSENSITIVE
argument_list|)
operator|.
name|matcher
argument_list|(
name|substring
argument_list|)
decl_stmt|;
if|if
condition|(
name|matcher
operator|.
name|find
argument_list|()
condition|)
block|{
return|return
name|substring
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|matcher
operator|.
name|end
argument_list|()
argument_list|)
return|;
block|}
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Couldn't find "
operator|+
name|token
operator|.
name|string
operator|+
literal|" in substring "
operator|+
name|substring
operator|+
literal|" at index "
operator|+
name|index
argument_list|)
throw|;
block|}
specifier|private
name|int
name|parseCharacterTemporal
parameter_list|(
name|String
name|substring
parameter_list|,
name|Token
name|token
parameter_list|)
block|{
try|try
block|{
if|if
condition|(
name|token
operator|.
name|temporalField
operator|==
name|ChronoField
operator|.
name|MONTH_OF_YEAR
condition|)
block|{
if|if
condition|(
name|token
operator|.
name|length
operator|==
literal|3
condition|)
block|{
return|return
name|Month
operator|.
name|from
argument_list|(
name|MONTH_FORMATTER
operator|.
name|parse
argument_list|(
name|capitalize
argument_list|(
name|substring
argument_list|)
argument_list|)
argument_list|)
operator|.
name|getValue
argument_list|()
return|;
block|}
else|else
block|{
return|return
name|Month
operator|.
name|valueOf
argument_list|(
name|substring
operator|.
name|toUpperCase
argument_list|()
argument_list|)
operator|.
name|getValue
argument_list|()
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|token
operator|.
name|temporalField
operator|==
name|ChronoField
operator|.
name|DAY_OF_WEEK
condition|)
block|{
if|if
condition|(
name|token
operator|.
name|length
operator|==
literal|3
condition|)
block|{
return|return
name|DayOfWeek
operator|.
name|from
argument_list|(
name|DAY_OF_WEEK_FORMATTER
operator|.
name|parse
argument_list|(
name|capitalize
argument_list|(
name|substring
argument_list|)
argument_list|)
argument_list|)
operator|.
name|getValue
argument_list|()
return|;
block|}
else|else
block|{
return|return
name|DayOfWeek
operator|.
name|valueOf
argument_list|(
name|substring
operator|.
name|toUpperCase
argument_list|()
argument_list|)
operator|.
name|getValue
argument_list|()
return|;
block|}
block|}
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Couldn't parse substring \""
operator|+
name|substring
operator|+
literal|"\" with token "
operator|+
name|token
operator|+
literal|" to integer."
operator|+
literal|"Pattern is "
operator|+
name|pattern
argument_list|,
name|e
argument_list|)
throw|;
block|}
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"token: ("
operator|+
name|token
operator|+
literal|") isn't a valid character temporal. Pattern is "
operator|+
name|pattern
argument_list|)
throw|;
block|}
comment|/**    * @throws IllegalArgumentException if input length doesn't match expected (token) length    */
specifier|private
name|void
name|checkFormatExact
parameter_list|(
name|String
name|substring
parameter_list|,
name|Token
name|token
parameter_list|)
block|{
comment|// AM/PM defaults to length 4 but make it 2 for FX check if the pattern actually has length 2
if|if
condition|(
name|formatExact
operator|&&
name|token
operator|.
name|temporalField
operator|==
name|ChronoField
operator|.
name|AMPM_OF_DAY
condition|)
block|{
name|token
operator|.
name|length
operator|=
name|token
operator|.
name|string
operator|.
name|length
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|formatExact
operator|&&
operator|!
operator|(
name|token
operator|.
name|fillMode
operator|||
name|token
operator|.
name|temporalField
operator|==
name|ChronoField
operator|.
name|NANO_OF_SECOND
operator|)
operator|&&
name|token
operator|.
name|length
operator|!=
name|substring
operator|.
name|length
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"FX on and expected token length "
operator|+
name|token
operator|.
name|length
operator|+
literal|" for token "
operator|+
name|token
operator|.
name|toString
argument_list|()
operator|+
literal|" does not match substring ("
operator|+
name|substring
operator|+
literal|") length "
operator|+
name|substring
operator|.
name|length
argument_list|()
argument_list|)
throw|;
block|}
block|}
comment|/**    * Parse the next separator(s). At least one separator character is expected. Separator    * characters are interchangeable.    *    * Caveat: If the last separator character in the separator substring is "-" and is immediately    *     followed by a time zone hour (tzh) token, it's a negative sign and not counted as a    *     separator, UNLESS this is the only separator character in the separator substring (in    *     which case it is not counted as the negative sign).    *    * @throws IllegalArgumentException if separator is missing or if FX is on and separator doesn't    * match the expected separator pattern exactly    */
specifier|private
name|int
name|parseSeparator
parameter_list|(
name|String
name|fullInput
parameter_list|,
name|int
name|index
parameter_list|,
name|Token
name|token
parameter_list|)
block|{
name|int
name|begin
init|=
name|index
decl_stmt|;
name|String
name|s
decl_stmt|;
name|StringBuilder
name|separatorsFound
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
while|while
condition|(
name|index
operator|<
name|fullInput
operator|.
name|length
argument_list|()
operator|&&
name|VALID_SEPARATORS
operator|.
name|contains
argument_list|(
name|fullInput
operator|.
name|substring
argument_list|(
name|index
argument_list|,
name|index
operator|+
literal|1
argument_list|)
argument_list|)
condition|)
block|{
name|s
operator|=
name|fullInput
operator|.
name|substring
argument_list|(
name|index
argument_list|,
name|index
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|isLastCharacterOfSeparator
argument_list|(
name|index
argument_list|,
name|fullInput
argument_list|)
operator|||
operator|!
operator|(
literal|"-"
operator|.
name|equals
argument_list|(
name|s
argument_list|)
operator|&&
operator|(
name|nextTokenIs
argument_list|(
literal|"tzh"
argument_list|,
name|token
argument_list|)
operator|)
operator|)
operator|||
name|separatorsFound
operator|.
name|length
argument_list|()
operator|==
literal|0
condition|)
block|{
name|separatorsFound
operator|.
name|append
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
name|index
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|separatorsFound
operator|.
name|length
argument_list|()
operator|==
literal|0
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Missing separator at index "
operator|+
name|index
argument_list|)
throw|;
block|}
if|if
condition|(
name|formatExact
operator|&&
operator|!
name|token
operator|.
name|string
operator|.
name|equals
argument_list|(
name|separatorsFound
operator|.
name|toString
argument_list|()
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"FX on and separator found: "
operator|+
name|separatorsFound
operator|.
name|toString
argument_list|()
operator|+
literal|" doesn't match expected separator: "
operator|+
name|token
operator|.
name|string
argument_list|)
throw|;
block|}
return|return
name|begin
operator|+
name|separatorsFound
operator|.
name|length
argument_list|()
return|;
block|}
specifier|private
name|int
name|parseText
parameter_list|(
name|String
name|fullInput
parameter_list|,
name|int
name|index
parameter_list|,
name|Token
name|token
parameter_list|)
block|{
name|String
name|substring
decl_stmt|;
name|substring
operator|=
name|fullInput
operator|.
name|substring
argument_list|(
name|index
argument_list|,
name|index
operator|+
name|token
operator|.
name|length
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|token
operator|.
name|string
operator|.
name|equalsIgnoreCase
argument_list|(
name|substring
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Wrong input at index "
operator|+
name|index
operator|+
literal|": Expected: \""
operator|+
name|token
operator|.
name|string
operator|+
literal|"\" but got: \""
operator|+
name|substring
operator|+
literal|"\" for token: "
operator|+
name|token
argument_list|)
throw|;
block|}
return|return
name|index
operator|+
name|token
operator|.
name|length
return|;
block|}
comment|/**    * Is the next character something other than a separator?    */
specifier|private
name|boolean
name|isLastCharacterOfSeparator
parameter_list|(
name|int
name|index
parameter_list|,
name|String
name|string
parameter_list|)
block|{
if|if
condition|(
name|index
operator|==
name|string
operator|.
name|length
argument_list|()
operator|-
literal|1
condition|)
block|{
comment|// if we're at the end of the string, yes
return|return
literal|true
return|;
block|}
return|return
operator|!
name|VALID_SEPARATORS
operator|.
name|contains
argument_list|(
name|string
operator|.
name|substring
argument_list|(
name|index
operator|+
literal|1
argument_list|,
name|index
operator|+
literal|2
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Does the temporalUnit/temporalField of the next token match the pattern's?    */
specifier|private
name|boolean
name|nextTokenIs
parameter_list|(
name|String
name|pattern
parameter_list|,
name|Token
name|currentToken
parameter_list|)
block|{
comment|// make sure currentToken isn't the last one
if|if
condition|(
name|tokens
operator|.
name|indexOf
argument_list|(
name|currentToken
argument_list|)
operator|==
name|tokens
operator|.
name|size
argument_list|()
operator|-
literal|1
condition|)
block|{
return|return
literal|false
return|;
block|}
name|Token
name|nextToken
init|=
name|tokens
operator|.
name|get
argument_list|(
name|tokens
operator|.
name|indexOf
argument_list|(
name|currentToken
argument_list|)
operator|+
literal|1
argument_list|)
decl_stmt|;
name|pattern
operator|=
name|pattern
operator|.
name|toLowerCase
argument_list|()
expr_stmt|;
return|return
operator|(
name|isTimeZoneToken
argument_list|(
name|pattern
argument_list|)
operator|&&
name|TIME_ZONE_TOKENS
operator|.
name|get
argument_list|(
name|pattern
argument_list|)
operator|==
name|nextToken
operator|.
name|temporalUnit
operator|||
name|isNumericTemporalToken
argument_list|(
name|pattern
argument_list|)
operator|&&
name|NUMERIC_TEMPORAL_TOKENS
operator|.
name|get
argument_list|(
name|pattern
argument_list|)
operator|==
name|nextToken
operator|.
name|temporalField
operator|||
name|isCharacterTemporalToken
argument_list|(
name|pattern
argument_list|)
operator|&&
name|CHARACTER_TEMPORAL_TOKENS
operator|.
name|get
argument_list|(
name|pattern
argument_list|)
operator|==
name|nextToken
operator|.
name|temporalField
operator|)
return|;
block|}
specifier|public
name|String
name|getPattern
parameter_list|()
block|{
return|return
name|pattern
return|;
block|}
comment|/**    * @return a copy of token list    */
specifier|protected
name|List
argument_list|<
name|Token
argument_list|>
name|getTokens
parameter_list|()
block|{
return|return
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|tokens
argument_list|)
return|;
block|}
specifier|private
specifier|static
name|String
name|capitalize
parameter_list|(
name|String
name|substring
parameter_list|)
block|{
return|return
name|WordUtils
operator|.
name|capitalize
argument_list|(
name|substring
operator|.
name|toLowerCase
argument_list|()
argument_list|)
return|;
block|}
block|}
end_class

end_unit

