begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|common
operator|.
name|format
operator|.
name|datetime
package|;
end_package

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|ImmutableList
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|ImmutableMap
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|lang
operator|.
name|StringUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|common
operator|.
name|type
operator|.
name|Date
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|common
operator|.
name|type
operator|.
name|Timestamp
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|Serializable
import|;
end_import

begin_import
import|import
name|java
operator|.
name|time
operator|.
name|DateTimeException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|time
operator|.
name|Duration
import|;
end_import

begin_import
import|import
name|java
operator|.
name|time
operator|.
name|Instant
import|;
end_import

begin_import
import|import
name|java
operator|.
name|time
operator|.
name|LocalDateTime
import|;
end_import

begin_import
import|import
name|java
operator|.
name|time
operator|.
name|ZoneOffset
import|;
end_import

begin_import
import|import
name|java
operator|.
name|time
operator|.
name|temporal
operator|.
name|ChronoField
import|;
end_import

begin_import
import|import
name|java
operator|.
name|time
operator|.
name|temporal
operator|.
name|ChronoUnit
import|;
end_import

begin_import
import|import
name|java
operator|.
name|time
operator|.
name|temporal
operator|.
name|TemporalField
import|;
end_import

begin_import
import|import
name|java
operator|.
name|time
operator|.
name|temporal
operator|.
name|TemporalUnit
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|TimeZone
import|;
end_import

begin_comment
comment|/**  * Formatter using SQL:2016 datetime patterns.  *  * For all tokens:  * - Patterns are case-insensitive, except AM/PM and T/Z. See these sections for more details.  * - For string to datetime conversion, no duplicate format tokens are allowed, including tokens  *   that have the same meaning but different lengths ("Y" and "YY" conflict) or different  *   behaviors ("RR" and "YY" conflict).  *  * For all numeric tokens:  * - The "expected length" of input/output is the number of tokens in the character (e.g. "YYY": 3,  *   "Y": 1, and so on), with some exceptions (see map SPECIAL_LENGTHS).  * - For string to datetime conversion, inputs of fewer digits than expected are accepted if  *   followed by a delimiter, e.g. format="YYYY-MM-DD", input="19-1-1", output=2019-01-01 00:00:00.  * - For datetime to string conversion, output is left padded with zeros, e.g. format="DD SSSSS",  *   input=2019-01-01 00:00:03, output="01 00003".  *  *  * Accepted format tokens:  * Note: "|" means "or". "Delimiter" means a separator, tokens T or Z, or end of input.  *  * A. Temporal tokens  * YYYY  * 4-digit year  * - For string to datetime conversion, prefix digits for 1, 2, and 3-digit inputs are obtained  *   from current date  *   E.g. input=‘9-01-01’, pattern =‘YYYY-MM-DD’, current year=2020, output=2029-01-01 00:00:00  *  *  * YYY  * Last 3 digits of a year  * - Gets the prefix digit from current date.  * - Can accept fewer digits than 3, similarly to YYYY.  *  * YY  * Last 2 digits of a year  * - Gets the 2 prefix digits from current date.  * - Can accept fewer digits than 2, similarly to YYYY.  *  * Y  * Last digit of a year  * - Gets the 3 prefix digits from current date.  *  * RRRR  * 4-digit rounded year  * - String to datetime conversion:  *   - If 2 digits are provided then acts like RR.  *   - If 1,3 or 4 digits provided then acts like YYYY.  * - For datetime to string conversion, acts like YYYY.  *  * RR  * 2-digit rounded year  * -String to datetime conversion:  *   - Semantics:  *     Input:     Last 2 digits of current year:   First 2 digits of output:  *     0 to 49    00 to 49                         First 2 digits of current year  *     0 to 49    50 to 99                         First 2 digits of current year + 1  *     50 to 99   00 to 49                         First 2 digits of current year - 1  *     50 to 99   50 to 99                         First 2 digits of current year  *   - If 1-digit year is provided followed by a delimiter, falls back to YYYY with 1-digit year  *     input.  * - For datetime to string conversion, acts like YY.  *  * MM  * Month (1-12)  * - For string to datetime conversion, conflicts with DDD.  *  * DD  * Day of month (1-31)  * - For string to datetime conversion, conflicts with DDD.  *  * DDD  * Day of year (1-366)  * - For string to datetime conversion, conflicts with DD and MM.  *  * HH  * Hour of day (1-12)  * - If no AM/PM provided then defaults to AM.  * - In string to datetime conversion, conflicts with SSSSS and HH24.  *  * HH12  * Hour of day (1-12)  * See HH.  *  * HH24  * Hour of day (0-23)  * - In string to datetime conversion, conflicts with SSSSS, HH12 and AM/PM.  *  * MI  * Minute of hour (0-59)  * - In string to datetime conversion, conflicts with SSSSS.  *  * SS  * Second of minute (0-59)  * - In string to datetime conversion, conflicts with SSSSS.  *  * SSSSS  * Second of Day (0-86399)  * - In string to datetime conversion, conflicts with SS, HH, HH12, HH24, MI, AM/PM.  *  * FF[1..9]  * Fraction of second  * - 1..9 indicates the number of decimal digits. "FF" (no number of digits specified) is also  *   accepted.  * - In datetime to string conversion, "FF" will omit trailing zeros, or output "0" if subsecond  *   value is 0.  * - In string to datetime conversion, fewer digits than expected are accepted if followed by a  *   delimiter. "FF" acts like "FF9".  *  * AM|A.M.  * Meridiem indicator or AM/PM  * - Datetime to string conversion:  *   - AM and PM mean the exact same thing in the pattern.  *     e.g. input=2019-01-01 20:00, format=“AM”, output=“PM”.  *   - Retains the exact format (capitalization and length) provided in the pattern string. If p.m.  *     is in the pattern, we expect a.m. or p.m. in the output; if AM is in the pattern, we expect  *     AM or PM in the output.  * - String to datetime conversion:  *   - Conflicts with HH24 and SSSSS.  *   - It doesn’t matter which meridian indicator is in the pattern.  *     E.g. input="2019-01-01 11:00 p.m.", pattern="YYYY-MM-DD HH12:MI AM",  *          output=2019-01-01 23:00:00  *  * PM|P.M.  * Meridiem indicator  * See AM|A.M.  *  * B. Time zone tokens  * TZH  * Time zone offset hour (-15 to +15)  * - 3-character-long input is expected: 1 character for the sign and 2 digits for the value.  *   e.g. “+10”, “-05”  * - 2-digit input is accepted without the sign, e.g. “04”.  * - Both these 2 and 3-digit versions are accepted even if not followed by separators.  * - Disabled for timestamp to string and date to string conversion, as timestamp and date are time  *   zone agnostic.  *  * TZM  * Time zone offset minute (0-59)  * - For string to datetime conversion:  *   - TZH token is required.  *   - Unsigned; sign comes from TZH.  *   - Therefore time zone offsets like “-30” minutes should be expressed thus: input=“-00:30”  *     pattern=“TZH:TZM”.  * - Disabled for timestamp to string and date to string conversion, as timestamp and date are time  *   zone agnostic.  *  * C. Separators  * -|.|/|,|'|;|:|<space>  * Separator  * - Uses loose matching. Existence of a sequence of separators in the format should match the  *   existence of a sequence of separators in the input regardless of the types of the separator or  *   the length of the sequence where length> 1. E.g. input=“2019-. ;10/10”, pattern=“YYYY-MM-DD”  *   is valid; input=“20191010”, pattern=“YYYY-MM-DD” is not valid.  * - If the last separator character in the separator substring is "-" and is immediately followed  *   by a time zone hour (tzh) token, it's a negative sign and not counted as a separator, UNLESS  *   this is the only possible separator character in the separator substring (in which case it is  *   not counted as the tzh's negative sign).  *  * D. ISO 8601 delimiters  * T  * ISO 8601 delimiter  * - Serves as a delimiter.  * - Function is to support formats like “YYYY-MM-DDTHH24:MI:SS.FF9Z”, “YYYY-MM-DD-HH24:MI:SSZ”  * - For datetime to string conversion, output is always capitalized ("T"), even if lowercase ("t")  *   is provided in the pattern.  *  * Z  * ISO 8601 delimiter  * See T.  */
end_comment

begin_class
specifier|public
class|class
name|HiveSqlDateTimeFormatter
implements|implements
name|Serializable
block|{
specifier|private
specifier|static
specifier|final
name|int
name|LONGEST_TOKEN_LENGTH
init|=
literal|5
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|int
name|LONGEST_ACCEPTED_PATTERN
init|=
literal|100
decl_stmt|;
comment|// for sanity's sake
specifier|private
specifier|static
specifier|final
name|long
name|MINUTES_PER_HOUR
init|=
literal|60
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|int
name|NANOS_MAX_LENGTH
init|=
literal|9
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|int
name|AM
init|=
literal|0
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|int
name|PM
init|=
literal|1
decl_stmt|;
specifier|private
name|String
name|pattern
decl_stmt|;
specifier|private
name|List
argument_list|<
name|Token
argument_list|>
name|tokens
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|TemporalField
argument_list|>
name|TEMPORAL_TOKENS
init|=
name|ImmutableMap
operator|.
expr|<
name|String
decl_stmt|,
name|TemporalField
decl|>
name|builder
argument_list|()
decl|.
name|put
argument_list|(
literal|"yyyy"
argument_list|,
name|ChronoField
operator|.
name|YEAR
argument_list|)
decl|.
name|put
argument_list|(
literal|"yyy"
argument_list|,
name|ChronoField
operator|.
name|YEAR
argument_list|)
decl|.
name|put
argument_list|(
literal|"yy"
argument_list|,
name|ChronoField
operator|.
name|YEAR
argument_list|)
decl|.
name|put
argument_list|(
literal|"y"
argument_list|,
name|ChronoField
operator|.
name|YEAR
argument_list|)
decl|.
name|put
argument_list|(
literal|"rrrr"
argument_list|,
name|ChronoField
operator|.
name|YEAR
argument_list|)
decl|.
name|put
argument_list|(
literal|"rr"
argument_list|,
name|ChronoField
operator|.
name|YEAR
argument_list|)
decl|.
name|put
argument_list|(
literal|"mm"
argument_list|,
name|ChronoField
operator|.
name|MONTH_OF_YEAR
argument_list|)
decl|.
name|put
argument_list|(
literal|"dd"
argument_list|,
name|ChronoField
operator|.
name|DAY_OF_MONTH
argument_list|)
decl|.
name|put
argument_list|(
literal|"ddd"
argument_list|,
name|ChronoField
operator|.
name|DAY_OF_YEAR
argument_list|)
decl|.
name|put
argument_list|(
literal|"hh"
argument_list|,
name|ChronoField
operator|.
name|HOUR_OF_AMPM
argument_list|)
decl|.
name|put
argument_list|(
literal|"hh12"
argument_list|,
name|ChronoField
operator|.
name|HOUR_OF_AMPM
argument_list|)
decl|.
name|put
argument_list|(
literal|"hh24"
argument_list|,
name|ChronoField
operator|.
name|HOUR_OF_DAY
argument_list|)
decl|.
name|put
argument_list|(
literal|"mi"
argument_list|,
name|ChronoField
operator|.
name|MINUTE_OF_HOUR
argument_list|)
decl|.
name|put
argument_list|(
literal|"ss"
argument_list|,
name|ChronoField
operator|.
name|SECOND_OF_MINUTE
argument_list|)
decl|.
name|put
argument_list|(
literal|"sssss"
argument_list|,
name|ChronoField
operator|.
name|SECOND_OF_DAY
argument_list|)
decl|.
name|put
argument_list|(
literal|"ff1"
argument_list|,
name|ChronoField
operator|.
name|NANO_OF_SECOND
argument_list|)
decl|.
name|put
argument_list|(
literal|"ff2"
argument_list|,
name|ChronoField
operator|.
name|NANO_OF_SECOND
argument_list|)
decl|.
name|put
argument_list|(
literal|"ff3"
argument_list|,
name|ChronoField
operator|.
name|NANO_OF_SECOND
argument_list|)
decl|.
name|put
argument_list|(
literal|"ff4"
argument_list|,
name|ChronoField
operator|.
name|NANO_OF_SECOND
argument_list|)
decl|.
name|put
argument_list|(
literal|"ff5"
argument_list|,
name|ChronoField
operator|.
name|NANO_OF_SECOND
argument_list|)
decl|.
name|put
argument_list|(
literal|"ff6"
argument_list|,
name|ChronoField
operator|.
name|NANO_OF_SECOND
argument_list|)
decl|.
name|put
argument_list|(
literal|"ff7"
argument_list|,
name|ChronoField
operator|.
name|NANO_OF_SECOND
argument_list|)
decl|.
name|put
argument_list|(
literal|"ff8"
argument_list|,
name|ChronoField
operator|.
name|NANO_OF_SECOND
argument_list|)
decl|.
name|put
argument_list|(
literal|"ff9"
argument_list|,
name|ChronoField
operator|.
name|NANO_OF_SECOND
argument_list|)
decl|.
name|put
argument_list|(
literal|"ff"
argument_list|,
name|ChronoField
operator|.
name|NANO_OF_SECOND
argument_list|)
decl|.
name|put
argument_list|(
literal|"a.m."
argument_list|,
name|ChronoField
operator|.
name|AMPM_OF_DAY
argument_list|)
decl|.
name|put
argument_list|(
literal|"am"
argument_list|,
name|ChronoField
operator|.
name|AMPM_OF_DAY
argument_list|)
decl|.
name|put
argument_list|(
literal|"p.m."
argument_list|,
name|ChronoField
operator|.
name|AMPM_OF_DAY
argument_list|)
decl|.
name|put
argument_list|(
literal|"pm"
argument_list|,
name|ChronoField
operator|.
name|AMPM_OF_DAY
argument_list|)
decl|.
name|build
argument_list|()
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|TemporalUnit
argument_list|>
name|TIME_ZONE_TOKENS
init|=
name|ImmutableMap
operator|.
expr|<
name|String
decl_stmt|,
name|TemporalUnit
decl|>
name|builder
argument_list|()
decl|.
name|put
argument_list|(
literal|"tzh"
argument_list|,
name|ChronoUnit
operator|.
name|HOURS
argument_list|)
decl|.
name|put
argument_list|(
literal|"tzm"
argument_list|,
name|ChronoUnit
operator|.
name|MINUTES
argument_list|)
decl|.
name|build
argument_list|()
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|List
argument_list|<
name|String
argument_list|>
name|VALID_ISO_8601_DELIMITERS
init|=
name|ImmutableList
operator|.
name|of
argument_list|(
literal|"t"
argument_list|,
literal|"z"
argument_list|)
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|List
argument_list|<
name|String
argument_list|>
name|VALID_SEPARATORS
init|=
name|ImmutableList
operator|.
name|of
argument_list|(
literal|"-"
argument_list|,
literal|":"
argument_list|,
literal|" "
argument_list|,
literal|"."
argument_list|,
literal|"/"
argument_list|,
literal|";"
argument_list|,
literal|"\'"
argument_list|,
literal|","
argument_list|)
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|Integer
argument_list|>
name|SPECIAL_LENGTHS
init|=
name|ImmutableMap
operator|.
expr|<
name|String
decl_stmt|,
name|Integer
decl|>
name|builder
argument_list|()
decl|.
name|put
argument_list|(
literal|"hh12"
argument_list|,
literal|2
argument_list|)
decl|.
name|put
argument_list|(
literal|"hh24"
argument_list|,
literal|2
argument_list|)
decl|.
name|put
argument_list|(
literal|"tzm"
argument_list|,
literal|2
argument_list|)
decl|.
name|put
argument_list|(
literal|"am"
argument_list|,
literal|4
argument_list|)
decl|.
name|put
argument_list|(
literal|"pm"
argument_list|,
literal|4
argument_list|)
decl|.
name|put
argument_list|(
literal|"ff1"
argument_list|,
literal|1
argument_list|)
decl|.
name|put
argument_list|(
literal|"ff2"
argument_list|,
literal|2
argument_list|)
decl|.
name|put
argument_list|(
literal|"ff3"
argument_list|,
literal|3
argument_list|)
decl|.
name|put
argument_list|(
literal|"ff4"
argument_list|,
literal|4
argument_list|)
decl|.
name|put
argument_list|(
literal|"ff5"
argument_list|,
literal|5
argument_list|)
decl|.
name|put
argument_list|(
literal|"ff6"
argument_list|,
literal|6
argument_list|)
decl|.
name|put
argument_list|(
literal|"ff7"
argument_list|,
literal|7
argument_list|)
decl|.
name|put
argument_list|(
literal|"ff8"
argument_list|,
literal|8
argument_list|)
decl|.
name|put
argument_list|(
literal|"ff9"
argument_list|,
literal|9
argument_list|)
decl|.
name|put
argument_list|(
literal|"ff"
argument_list|,
literal|9
argument_list|)
decl|.
name|build
argument_list|()
decl_stmt|;
comment|/**    * Represents broad categories of tokens.    */
specifier|public
enum|enum
name|TokenType
block|{
name|TEMPORAL
block|,
name|SEPARATOR
block|,
name|TIMEZONE
block|,
name|ISO_8601_DELIMITER
block|}
comment|/**    * Token representation.    */
specifier|public
specifier|static
class|class
name|Token
implements|implements
name|Serializable
block|{
name|TokenType
name|type
decl_stmt|;
name|TemporalField
name|temporalField
decl_stmt|;
comment|// for type TEMPORAL e.g. ChronoField.YEAR
name|TemporalUnit
name|temporalUnit
decl_stmt|;
comment|// for type TIMEZONE e.g. ChronoUnit.HOURS
name|String
name|string
decl_stmt|;
comment|// pattern string, e.g. "yyy"
name|int
name|length
decl_stmt|;
comment|// length (e.g. YYY: 3, FF8: 8)
specifier|public
name|Token
parameter_list|(
name|TemporalField
name|temporalField
parameter_list|,
name|String
name|string
parameter_list|,
name|int
name|length
parameter_list|)
block|{
name|this
argument_list|(
name|TokenType
operator|.
name|TEMPORAL
argument_list|,
name|temporalField
argument_list|,
literal|null
argument_list|,
name|string
argument_list|,
name|length
argument_list|)
expr_stmt|;
block|}
specifier|public
name|Token
parameter_list|(
name|TemporalUnit
name|temporalUnit
parameter_list|,
name|String
name|string
parameter_list|,
name|int
name|length
parameter_list|)
block|{
name|this
argument_list|(
name|TokenType
operator|.
name|TIMEZONE
argument_list|,
literal|null
argument_list|,
name|temporalUnit
argument_list|,
name|string
argument_list|,
name|length
argument_list|)
expr_stmt|;
block|}
specifier|public
name|Token
parameter_list|(
name|TokenType
name|tokenType
parameter_list|,
name|String
name|string
parameter_list|)
block|{
name|this
argument_list|(
name|tokenType
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
name|string
argument_list|,
name|string
operator|.
name|length
argument_list|()
argument_list|)
expr_stmt|;
block|}
specifier|public
name|Token
parameter_list|(
name|TokenType
name|tokenType
parameter_list|,
name|TemporalField
name|temporalField
parameter_list|,
name|TemporalUnit
name|temporalUnit
parameter_list|,
name|String
name|string
parameter_list|,
name|int
name|length
parameter_list|)
block|{
name|this
operator|.
name|type
operator|=
name|tokenType
expr_stmt|;
name|this
operator|.
name|temporalField
operator|=
name|temporalField
expr_stmt|;
name|this
operator|.
name|temporalUnit
operator|=
name|temporalUnit
expr_stmt|;
name|this
operator|.
name|string
operator|=
name|string
expr_stmt|;
name|this
operator|.
name|length
operator|=
name|length
expr_stmt|;
block|}
specifier|public
name|String
name|toString
parameter_list|()
block|{
name|StringBuilder
name|sb
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|sb
operator|.
name|append
argument_list|(
name|string
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|" type: "
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|temporalField
operator|!=
literal|null
condition|)
block|{
name|sb
operator|.
name|append
argument_list|(
literal|" temporalField: "
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
name|temporalField
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|temporalUnit
operator|!=
literal|null
condition|)
block|{
name|sb
operator|.
name|append
argument_list|(
literal|" temporalUnit: "
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
name|temporalUnit
argument_list|)
expr_stmt|;
block|}
return|return
name|sb
operator|.
name|toString
argument_list|()
return|;
block|}
block|}
specifier|public
name|HiveSqlDateTimeFormatter
parameter_list|(
name|String
name|pattern
parameter_list|,
name|boolean
name|forParsing
parameter_list|)
block|{
name|setPattern
argument_list|(
name|pattern
argument_list|,
name|forParsing
argument_list|)
expr_stmt|;
block|}
comment|/**    * Parse and perhaps verify the pattern.    */
specifier|private
name|void
name|setPattern
parameter_list|(
name|String
name|pattern
parameter_list|,
name|boolean
name|forParsing
parameter_list|)
block|{
assert|assert
name|pattern
operator|.
name|length
argument_list|()
operator|<
name|LONGEST_ACCEPTED_PATTERN
operator|:
literal|"The input format is too long"
assert|;
name|this
operator|.
name|pattern
operator|=
name|pattern
expr_stmt|;
name|parsePatternToTokens
argument_list|(
name|pattern
argument_list|)
expr_stmt|;
comment|// throw IllegalArgumentException if pattern is invalid
if|if
condition|(
name|forParsing
condition|)
block|{
name|verifyForParse
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|verifyForFormat
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Parse pattern to list of tokens.    */
specifier|private
name|String
name|parsePatternToTokens
parameter_list|(
name|String
name|pattern
parameter_list|)
block|{
name|tokens
operator|.
name|clear
argument_list|()
expr_stmt|;
name|String
name|originalPattern
init|=
name|pattern
decl_stmt|;
name|pattern
operator|=
name|pattern
operator|.
name|toLowerCase
argument_list|()
expr_stmt|;
comment|// indexes of the substring we will check (includes begin, does not include end)
name|int
name|begin
init|=
literal|0
decl_stmt|,
name|end
init|=
literal|0
decl_stmt|;
name|String
name|candidate
decl_stmt|;
name|Token
name|lastAddedToken
init|=
literal|null
decl_stmt|;
while|while
condition|(
name|begin
operator|<
name|pattern
operator|.
name|length
argument_list|()
condition|)
block|{
comment|// if begin hasn't progressed, then pattern is not parsable
if|if
condition|(
name|begin
operator|!=
name|end
condition|)
block|{
name|tokens
operator|.
name|clear
argument_list|()
expr_stmt|;
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Bad date/time conversion pattern: "
operator|+
name|pattern
argument_list|)
throw|;
block|}
comment|// find next token
for|for
control|(
name|int
name|i
init|=
name|LONGEST_TOKEN_LENGTH
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|end
operator|=
name|begin
operator|+
name|i
expr_stmt|;
if|if
condition|(
name|end
operator|>
name|pattern
operator|.
name|length
argument_list|()
condition|)
block|{
comment|// don't go past the end of the pattern string
continue|continue;
block|}
name|candidate
operator|=
name|pattern
operator|.
name|substring
argument_list|(
name|begin
argument_list|,
name|end
argument_list|)
expr_stmt|;
if|if
condition|(
name|isSeparator
argument_list|(
name|candidate
argument_list|)
condition|)
block|{
name|lastAddedToken
operator|=
name|parseSeparatorToken
argument_list|(
name|candidate
argument_list|,
name|lastAddedToken
argument_list|)
expr_stmt|;
name|begin
operator|=
name|end
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|isIso8601Delimiter
argument_list|(
name|candidate
argument_list|)
condition|)
block|{
name|lastAddedToken
operator|=
name|parseIso8601DelimiterToken
argument_list|(
name|candidate
argument_list|)
expr_stmt|;
name|begin
operator|=
name|end
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|isTemporalToken
argument_list|(
name|candidate
argument_list|)
condition|)
block|{
name|lastAddedToken
operator|=
name|parseTemporalToken
argument_list|(
name|originalPattern
argument_list|,
name|begin
argument_list|,
name|candidate
argument_list|)
expr_stmt|;
name|begin
operator|=
name|end
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|isTimeZoneToken
argument_list|(
name|candidate
argument_list|)
condition|)
block|{
name|lastAddedToken
operator|=
name|parseTimeZoneToken
argument_list|(
name|candidate
argument_list|)
expr_stmt|;
name|begin
operator|=
name|end
expr_stmt|;
break|break;
block|}
block|}
block|}
return|return
name|pattern
return|;
block|}
specifier|private
name|boolean
name|isSeparator
parameter_list|(
name|String
name|candidate
parameter_list|)
block|{
return|return
name|candidate
operator|.
name|length
argument_list|()
operator|==
literal|1
operator|&&
name|VALID_SEPARATORS
operator|.
name|contains
argument_list|(
name|candidate
argument_list|)
return|;
block|}
specifier|private
name|boolean
name|isIso8601Delimiter
parameter_list|(
name|String
name|candidate
parameter_list|)
block|{
return|return
name|candidate
operator|.
name|length
argument_list|()
operator|==
literal|1
operator|&&
name|VALID_ISO_8601_DELIMITERS
operator|.
name|contains
argument_list|(
name|candidate
argument_list|)
return|;
block|}
specifier|private
name|boolean
name|isTemporalToken
parameter_list|(
name|String
name|candidate
parameter_list|)
block|{
return|return
name|TEMPORAL_TOKENS
operator|.
name|containsKey
argument_list|(
name|candidate
argument_list|)
return|;
block|}
specifier|private
name|boolean
name|isTimeZoneToken
parameter_list|(
name|String
name|pattern
parameter_list|)
block|{
return|return
name|TIME_ZONE_TOKENS
operator|.
name|containsKey
argument_list|(
name|pattern
argument_list|)
return|;
block|}
specifier|private
name|Token
name|parseSeparatorToken
parameter_list|(
name|String
name|candidate
parameter_list|,
name|Token
name|lastAddedToken
parameter_list|)
block|{
comment|// try to clump separator with immediately preceding separators (e.g. "---" counts as one
comment|// separator)
if|if
condition|(
name|lastAddedToken
operator|!=
literal|null
operator|&&
name|lastAddedToken
operator|.
name|type
operator|==
name|TokenType
operator|.
name|SEPARATOR
condition|)
block|{
name|lastAddedToken
operator|.
name|string
operator|+=
name|candidate
expr_stmt|;
name|lastAddedToken
operator|.
name|length
operator|+=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|lastAddedToken
operator|=
operator|new
name|Token
argument_list|(
name|TokenType
operator|.
name|SEPARATOR
argument_list|,
name|candidate
argument_list|)
expr_stmt|;
name|tokens
operator|.
name|add
argument_list|(
name|lastAddedToken
argument_list|)
expr_stmt|;
block|}
return|return
name|lastAddedToken
return|;
block|}
specifier|private
name|Token
name|parseIso8601DelimiterToken
parameter_list|(
name|String
name|candidate
parameter_list|)
block|{
name|Token
name|lastAddedToken
decl_stmt|;
name|lastAddedToken
operator|=
operator|new
name|Token
argument_list|(
name|TokenType
operator|.
name|ISO_8601_DELIMITER
argument_list|,
name|candidate
operator|.
name|toUpperCase
argument_list|()
argument_list|)
expr_stmt|;
name|tokens
operator|.
name|add
argument_list|(
name|lastAddedToken
argument_list|)
expr_stmt|;
return|return
name|lastAddedToken
return|;
block|}
specifier|private
name|Token
name|parseTemporalToken
parameter_list|(
name|String
name|originalPattern
parameter_list|,
name|int
name|begin
parameter_list|,
name|String
name|candidate
parameter_list|)
block|{
name|Token
name|lastAddedToken
decl_stmt|;
comment|// for AM/PM, keep original case
if|if
condition|(
name|TEMPORAL_TOKENS
operator|.
name|get
argument_list|(
name|candidate
argument_list|)
operator|==
name|ChronoField
operator|.
name|AMPM_OF_DAY
condition|)
block|{
name|int
name|subStringEnd
init|=
name|begin
operator|+
name|candidate
operator|.
name|length
argument_list|()
decl_stmt|;
name|candidate
operator|=
name|originalPattern
operator|.
name|substring
argument_list|(
name|begin
argument_list|,
name|subStringEnd
argument_list|)
expr_stmt|;
block|}
name|lastAddedToken
operator|=
operator|new
name|Token
argument_list|(
name|TEMPORAL_TOKENS
operator|.
name|get
argument_list|(
name|candidate
operator|.
name|toLowerCase
argument_list|()
argument_list|)
argument_list|,
name|candidate
argument_list|,
name|getTokenStringLength
argument_list|(
name|candidate
operator|.
name|toLowerCase
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|tokens
operator|.
name|add
argument_list|(
name|lastAddedToken
argument_list|)
expr_stmt|;
return|return
name|lastAddedToken
return|;
block|}
specifier|private
name|Token
name|parseTimeZoneToken
parameter_list|(
name|String
name|candidate
parameter_list|)
block|{
name|Token
name|lastAddedToken
decl_stmt|;
name|lastAddedToken
operator|=
operator|new
name|Token
argument_list|(
name|TIME_ZONE_TOKENS
operator|.
name|get
argument_list|(
name|candidate
argument_list|)
argument_list|,
name|candidate
argument_list|,
name|getTokenStringLength
argument_list|(
name|candidate
argument_list|)
argument_list|)
expr_stmt|;
name|tokens
operator|.
name|add
argument_list|(
name|lastAddedToken
argument_list|)
expr_stmt|;
return|return
name|lastAddedToken
return|;
block|}
specifier|private
name|int
name|getTokenStringLength
parameter_list|(
name|String
name|candidate
parameter_list|)
block|{
name|Integer
name|length
init|=
name|SPECIAL_LENGTHS
operator|.
name|get
argument_list|(
name|candidate
argument_list|)
decl_stmt|;
if|if
condition|(
name|length
operator|!=
literal|null
condition|)
block|{
return|return
name|length
return|;
block|}
return|return
name|candidate
operator|.
name|length
argument_list|()
return|;
block|}
comment|/**    * Make sure the generated list of tokens is valid for parsing strings to datetime objects.    */
specifier|private
name|void
name|verifyForParse
parameter_list|()
block|{
comment|// create a list of tokens' temporal fields
name|ArrayList
argument_list|<
name|TemporalField
argument_list|>
name|temporalFields
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|ArrayList
argument_list|<
name|TemporalUnit
argument_list|>
name|timeZoneTemporalUnits
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|int
name|roundYearCount
init|=
literal|0
decl_stmt|,
name|yearCount
init|=
literal|0
decl_stmt|;
for|for
control|(
name|Token
name|token
range|:
name|tokens
control|)
block|{
if|if
condition|(
name|token
operator|.
name|temporalField
operator|!=
literal|null
condition|)
block|{
name|temporalFields
operator|.
name|add
argument_list|(
name|token
operator|.
name|temporalField
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|.
name|temporalField
operator|==
name|ChronoField
operator|.
name|YEAR
condition|)
block|{
if|if
condition|(
name|token
operator|.
name|string
operator|.
name|startsWith
argument_list|(
literal|"r"
argument_list|)
condition|)
block|{
name|roundYearCount
operator|+=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|yearCount
operator|+=
literal|1
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|token
operator|.
name|temporalUnit
operator|!=
literal|null
condition|)
block|{
name|timeZoneTemporalUnits
operator|.
name|add
argument_list|(
name|token
operator|.
name|temporalUnit
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
operator|(
name|temporalFields
operator|.
name|contains
argument_list|(
name|ChronoField
operator|.
name|YEAR
argument_list|)
operator|)
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Missing year token."
argument_list|)
throw|;
block|}
if|if
condition|(
operator|!
operator|(
name|temporalFields
operator|.
name|contains
argument_list|(
name|ChronoField
operator|.
name|MONTH_OF_YEAR
argument_list|)
operator|&&
name|temporalFields
operator|.
name|contains
argument_list|(
name|ChronoField
operator|.
name|DAY_OF_MONTH
argument_list|)
operator|||
name|temporalFields
operator|.
name|contains
argument_list|(
name|ChronoField
operator|.
name|DAY_OF_YEAR
argument_list|)
operator|)
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Missing day of year or (month of year + day of month)"
operator|+
literal|" tokens."
argument_list|)
throw|;
block|}
if|if
condition|(
name|roundYearCount
operator|>
literal|0
operator|&&
name|yearCount
operator|>
literal|0
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Invalid duplication of format element: Both year and"
operator|+
literal|"round year are provided"
argument_list|)
throw|;
block|}
for|for
control|(
name|TemporalField
name|tokenType
range|:
name|temporalFields
control|)
block|{
if|if
condition|(
name|Collections
operator|.
name|frequency
argument_list|(
name|temporalFields
argument_list|,
name|tokenType
argument_list|)
operator|>
literal|1
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Invalid duplication of format element: multiple "
operator|+
name|tokenType
operator|.
name|toString
argument_list|()
operator|+
literal|" tokens provided."
argument_list|)
throw|;
block|}
block|}
if|if
condition|(
name|temporalFields
operator|.
name|contains
argument_list|(
name|ChronoField
operator|.
name|AMPM_OF_DAY
argument_list|)
operator|&&
operator|!
operator|(
name|temporalFields
operator|.
name|contains
argument_list|(
name|ChronoField
operator|.
name|HOUR_OF_DAY
argument_list|)
operator|||
name|temporalFields
operator|.
name|contains
argument_list|(
name|ChronoField
operator|.
name|HOUR_OF_AMPM
argument_list|)
operator|)
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"AM/PM provided but missing hour token."
argument_list|)
throw|;
block|}
if|if
condition|(
name|temporalFields
operator|.
name|contains
argument_list|(
name|ChronoField
operator|.
name|AMPM_OF_DAY
argument_list|)
operator|&&
name|temporalFields
operator|.
name|contains
argument_list|(
name|ChronoField
operator|.
name|HOUR_OF_DAY
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Conflict between median indicator and hour token."
argument_list|)
throw|;
block|}
if|if
condition|(
name|temporalFields
operator|.
name|contains
argument_list|(
name|ChronoField
operator|.
name|HOUR_OF_AMPM
argument_list|)
operator|&&
name|temporalFields
operator|.
name|contains
argument_list|(
name|ChronoField
operator|.
name|HOUR_OF_DAY
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Conflict between hour of day and hour of am/pm token."
argument_list|)
throw|;
block|}
if|if
condition|(
name|temporalFields
operator|.
name|contains
argument_list|(
name|ChronoField
operator|.
name|DAY_OF_YEAR
argument_list|)
operator|&&
operator|(
name|temporalFields
operator|.
name|contains
argument_list|(
name|ChronoField
operator|.
name|DAY_OF_MONTH
argument_list|)
operator|||
name|temporalFields
operator|.
name|contains
argument_list|(
name|ChronoField
operator|.
name|MONTH_OF_YEAR
argument_list|)
operator|)
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Day of year provided with day or month token."
argument_list|)
throw|;
block|}
if|if
condition|(
name|temporalFields
operator|.
name|contains
argument_list|(
name|ChronoField
operator|.
name|SECOND_OF_DAY
argument_list|)
operator|&&
operator|(
name|temporalFields
operator|.
name|contains
argument_list|(
name|ChronoField
operator|.
name|HOUR_OF_DAY
argument_list|)
operator|||
name|temporalFields
operator|.
name|contains
argument_list|(
name|ChronoField
operator|.
name|HOUR_OF_AMPM
argument_list|)
operator|||
name|temporalFields
operator|.
name|contains
argument_list|(
name|ChronoField
operator|.
name|MINUTE_OF_HOUR
argument_list|)
operator|||
name|temporalFields
operator|.
name|contains
argument_list|(
name|ChronoField
operator|.
name|SECOND_OF_MINUTE
argument_list|)
operator|)
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Second of day token conflicts with other token(s)."
argument_list|)
throw|;
block|}
if|if
condition|(
name|timeZoneTemporalUnits
operator|.
name|contains
argument_list|(
name|ChronoUnit
operator|.
name|MINUTES
argument_list|)
operator|&&
operator|!
name|timeZoneTemporalUnits
operator|.
name|contains
argument_list|(
name|ChronoUnit
operator|.
name|HOURS
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Time zone minute token provided without time zone hour token."
argument_list|)
throw|;
block|}
block|}
comment|/**    * Make sure the generated list of tokens is valid for formatting datetime objects to strings.    */
specifier|private
name|void
name|verifyForFormat
parameter_list|()
block|{
for|for
control|(
name|Token
name|token
range|:
name|tokens
control|)
block|{
if|if
condition|(
name|token
operator|.
name|type
operator|==
name|TokenType
operator|.
name|TIMEZONE
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
name|token
operator|.
name|string
operator|.
name|toUpperCase
argument_list|()
operator|+
literal|" not a valid format for "
operator|+
literal|"timestamp or date."
argument_list|)
throw|;
block|}
block|}
block|}
specifier|public
name|String
name|format
parameter_list|(
name|Timestamp
name|ts
parameter_list|)
block|{
name|StringBuilder
name|fullOutputSb
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|String
name|outputString
init|=
literal|null
decl_stmt|;
name|int
name|value
decl_stmt|;
name|LocalDateTime
name|localDateTime
init|=
name|LocalDateTime
operator|.
name|ofEpochSecond
argument_list|(
name|ts
operator|.
name|toEpochSecond
argument_list|()
argument_list|,
name|ts
operator|.
name|getNanos
argument_list|()
argument_list|,
name|ZoneOffset
operator|.
name|UTC
argument_list|)
decl_stmt|;
for|for
control|(
name|Token
name|token
range|:
name|tokens
control|)
block|{
switch|switch
condition|(
name|token
operator|.
name|type
condition|)
block|{
case|case
name|TEMPORAL
case|:
try|try
block|{
name|value
operator|=
name|localDateTime
operator|.
name|get
argument_list|(
name|token
operator|.
name|temporalField
argument_list|)
expr_stmt|;
name|outputString
operator|=
name|formatTemporal
argument_list|(
name|value
argument_list|,
name|token
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|DateTimeException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
name|token
operator|.
name|temporalField
operator|+
literal|" couldn't be obtained from "
operator|+
literal|"LocalDateTime "
operator|+
name|localDateTime
argument_list|,
name|e
argument_list|)
throw|;
block|}
break|break;
case|case
name|TIMEZONE
case|:
comment|//invalid for timestamp and date
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
name|token
operator|.
name|string
operator|.
name|toUpperCase
argument_list|()
operator|+
literal|" not a valid format for "
operator|+
literal|"timestamp or date."
argument_list|)
throw|;
case|case
name|SEPARATOR
case|:
name|outputString
operator|=
name|token
operator|.
name|string
expr_stmt|;
break|break;
case|case
name|ISO_8601_DELIMITER
case|:
name|outputString
operator|=
name|token
operator|.
name|string
operator|.
name|toUpperCase
argument_list|()
expr_stmt|;
break|break;
default|default:
comment|// won't happen
block|}
name|fullOutputSb
operator|.
name|append
argument_list|(
name|outputString
argument_list|)
expr_stmt|;
block|}
return|return
name|fullOutputSb
operator|.
name|toString
argument_list|()
return|;
block|}
specifier|public
name|String
name|format
parameter_list|(
name|Date
name|date
parameter_list|)
block|{
return|return
name|format
argument_list|(
name|Timestamp
operator|.
name|ofEpochSecond
argument_list|(
name|date
operator|.
name|toEpochSecond
argument_list|()
argument_list|)
argument_list|)
return|;
block|}
specifier|private
name|String
name|formatTemporal
parameter_list|(
name|int
name|value
parameter_list|,
name|Token
name|token
parameter_list|)
block|{
name|String
name|output
decl_stmt|;
if|if
condition|(
name|token
operator|.
name|temporalField
operator|==
name|ChronoField
operator|.
name|AMPM_OF_DAY
condition|)
block|{
name|output
operator|=
name|value
operator|==
literal|0
condition|?
literal|"a"
else|:
literal|"p"
expr_stmt|;
name|output
operator|+=
name|token
operator|.
name|string
operator|.
name|length
argument_list|()
operator|==
literal|2
condition|?
literal|"m"
else|:
literal|".m."
expr_stmt|;
if|if
condition|(
name|token
operator|.
name|string
operator|.
name|startsWith
argument_list|(
literal|"A"
argument_list|)
operator|||
name|token
operator|.
name|string
operator|.
name|startsWith
argument_list|(
literal|"P"
argument_list|)
condition|)
block|{
name|output
operator|=
name|output
operator|.
name|toUpperCase
argument_list|()
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// it's a numeric value
if|if
condition|(
name|token
operator|.
name|temporalField
operator|==
name|ChronoField
operator|.
name|HOUR_OF_AMPM
operator|&&
name|value
operator|==
literal|0
condition|)
block|{
name|value
operator|=
literal|12
expr_stmt|;
block|}
try|try
block|{
name|output
operator|=
name|String
operator|.
name|valueOf
argument_list|(
name|value
argument_list|)
expr_stmt|;
name|output
operator|=
name|padOrTruncateNumericTemporal
argument_list|(
name|token
argument_list|,
name|output
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Value: "
operator|+
name|value
operator|+
literal|" couldn't be cast to string."
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
return|return
name|output
return|;
block|}
comment|/**    * To match token.length, pad left with zeroes or truncate.    */
specifier|private
name|String
name|padOrTruncateNumericTemporal
parameter_list|(
name|Token
name|token
parameter_list|,
name|String
name|output
parameter_list|)
block|{
if|if
condition|(
name|output
operator|.
name|length
argument_list|()
operator|<
name|token
operator|.
name|length
condition|)
block|{
name|output
operator|=
name|StringUtils
operator|.
name|leftPad
argument_list|(
name|output
argument_list|,
name|token
operator|.
name|length
argument_list|,
literal|'0'
argument_list|)
expr_stmt|;
comment|// pad left
block|}
elseif|else
if|if
condition|(
name|output
operator|.
name|length
argument_list|()
operator|>
name|token
operator|.
name|length
condition|)
block|{
if|if
condition|(
name|token
operator|.
name|temporalField
operator|==
name|ChronoField
operator|.
name|NANO_OF_SECOND
condition|)
block|{
name|output
operator|=
name|output
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|token
operator|.
name|length
argument_list|)
expr_stmt|;
comment|// truncate right
block|}
else|else
block|{
name|output
operator|=
name|output
operator|.
name|substring
argument_list|(
name|output
operator|.
name|length
argument_list|()
operator|-
name|token
operator|.
name|length
argument_list|)
expr_stmt|;
comment|// truncate left
block|}
block|}
if|if
condition|(
name|token
operator|.
name|temporalField
operator|==
name|ChronoField
operator|.
name|NANO_OF_SECOND
operator|&&
name|token
operator|.
name|string
operator|.
name|equalsIgnoreCase
argument_list|(
literal|"ff"
argument_list|)
condition|)
block|{
name|output
operator|=
name|output
operator|.
name|replaceAll
argument_list|(
literal|"0*$"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
comment|//truncate trailing 0's
if|if
condition|(
name|output
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|output
operator|=
literal|"0"
expr_stmt|;
block|}
block|}
return|return
name|output
return|;
block|}
comment|/**    * Left here for timestamp with local time zone.    */
specifier|private
name|String
name|formatTimeZone
parameter_list|(
name|TimeZone
name|timeZone
parameter_list|,
name|LocalDateTime
name|localDateTime
parameter_list|,
name|Token
name|token
parameter_list|)
block|{
name|ZoneOffset
name|offset
init|=
name|timeZone
operator|.
name|toZoneId
argument_list|()
operator|.
name|getRules
argument_list|()
operator|.
name|getOffset
argument_list|(
name|localDateTime
argument_list|)
decl_stmt|;
name|Duration
name|seconds
init|=
name|Duration
operator|.
name|of
argument_list|(
name|offset
operator|.
name|get
argument_list|(
name|ChronoField
operator|.
name|OFFSET_SECONDS
argument_list|)
argument_list|,
name|ChronoUnit
operator|.
name|SECONDS
argument_list|)
decl_stmt|;
if|if
condition|(
name|token
operator|.
name|string
operator|.
name|equals
argument_list|(
literal|"tzh"
argument_list|)
condition|)
block|{
name|long
name|hours
init|=
name|seconds
operator|.
name|toHours
argument_list|()
decl_stmt|;
name|String
name|s
init|=
operator|(
name|hours
operator|>=
literal|0
operator|)
condition|?
literal|"+"
else|:
literal|"-"
decl_stmt|;
name|s
operator|+=
operator|(
name|Math
operator|.
name|abs
argument_list|(
name|hours
argument_list|)
operator|<
literal|10
operator|)
condition|?
literal|"0"
else|:
literal|""
expr_stmt|;
name|s
operator|+=
name|String
operator|.
name|valueOf
argument_list|(
name|Math
operator|.
name|abs
argument_list|(
name|hours
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|s
return|;
block|}
else|else
block|{
name|long
name|minutes
init|=
name|Math
operator|.
name|abs
argument_list|(
name|seconds
operator|.
name|toMinutes
argument_list|()
operator|%
name|MINUTES_PER_HOUR
argument_list|)
decl_stmt|;
name|String
name|s
init|=
name|String
operator|.
name|valueOf
argument_list|(
name|minutes
argument_list|)
decl_stmt|;
if|if
condition|(
name|s
operator|.
name|length
argument_list|()
operator|==
literal|1
condition|)
block|{
name|s
operator|=
literal|"0"
operator|+
name|s
expr_stmt|;
block|}
return|return
name|s
return|;
block|}
block|}
specifier|public
name|Timestamp
name|parseTimestamp
parameter_list|(
name|String
name|fullInput
parameter_list|)
block|{
name|LocalDateTime
name|ldt
init|=
name|LocalDateTime
operator|.
name|ofInstant
argument_list|(
name|Instant
operator|.
name|EPOCH
argument_list|,
name|ZoneOffset
operator|.
name|UTC
argument_list|)
decl_stmt|;
name|String
name|substring
decl_stmt|;
name|int
name|index
init|=
literal|0
decl_stmt|;
name|int
name|value
decl_stmt|;
name|int
name|timeZoneSign
init|=
literal|0
decl_stmt|,
name|timeZoneHours
init|=
literal|0
decl_stmt|,
name|timeZoneMinutes
init|=
literal|0
decl_stmt|;
for|for
control|(
name|Token
name|token
range|:
name|tokens
control|)
block|{
switch|switch
condition|(
name|token
operator|.
name|type
condition|)
block|{
case|case
name|TEMPORAL
case|:
name|substring
operator|=
name|getNextSubstring
argument_list|(
name|fullInput
argument_list|,
name|index
argument_list|,
name|token
argument_list|)
expr_stmt|;
comment|// e.g. yy-m -> yy
name|value
operator|=
name|parseTemporal
argument_list|(
name|substring
argument_list|,
name|token
argument_list|)
expr_stmt|;
comment|// e.g. 18->2018, July->07
try|try
block|{
name|ldt
operator|=
name|ldt
operator|.
name|with
argument_list|(
name|token
operator|.
name|temporalField
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|DateTimeException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Value "
operator|+
name|value
operator|+
literal|" not valid for token "
operator|+
name|token
operator|.
name|toString
argument_list|()
argument_list|)
throw|;
block|}
name|index
operator|+=
name|substring
operator|.
name|length
argument_list|()
expr_stmt|;
break|break;
case|case
name|TIMEZONE
case|:
if|if
condition|(
name|token
operator|.
name|temporalUnit
operator|==
name|ChronoUnit
operator|.
name|HOURS
condition|)
block|{
name|String
name|nextCharacter
init|=
name|fullInput
operator|.
name|substring
argument_list|(
name|index
argument_list|,
name|index
operator|+
literal|1
argument_list|)
decl_stmt|;
name|timeZoneSign
operator|=
literal|"-"
operator|.
name|equals
argument_list|(
name|nextCharacter
argument_list|)
condition|?
operator|-
literal|1
else|:
literal|1
expr_stmt|;
if|if
condition|(
literal|"-"
operator|.
name|equals
argument_list|(
name|nextCharacter
argument_list|)
operator|||
literal|"+"
operator|.
name|equals
argument_list|(
name|nextCharacter
argument_list|)
condition|)
block|{
name|index
operator|++
expr_stmt|;
block|}
comment|// parse next two digits
name|substring
operator|=
name|getNextSubstring
argument_list|(
name|fullInput
argument_list|,
name|index
argument_list|,
name|index
operator|+
literal|2
argument_list|,
name|token
argument_list|)
expr_stmt|;
try|try
block|{
name|timeZoneHours
operator|=
name|Integer
operator|.
name|parseInt
argument_list|(
name|substring
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|NumberFormatException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Couldn't parse substring \""
operator|+
name|substring
operator|+
literal|"\" with token "
operator|+
name|token
operator|+
literal|" to int. Pattern is "
operator|+
name|pattern
argument_list|,
name|e
argument_list|)
throw|;
block|}
if|if
condition|(
name|timeZoneHours
argument_list|<
operator|-
literal|15
operator|||
name|timeZoneHours
argument_list|>
literal|15
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Couldn't parse substring \""
operator|+
name|substring
operator|+
literal|"\" to TZH because TZH range is -15 to +15. Pattern is "
operator|+
name|pattern
argument_list|)
throw|;
block|}
block|}
else|else
block|{
comment|// time zone minutes
name|substring
operator|=
name|getNextSubstring
argument_list|(
name|fullInput
argument_list|,
name|index
argument_list|,
name|token
argument_list|)
expr_stmt|;
try|try
block|{
name|timeZoneMinutes
operator|=
name|Integer
operator|.
name|parseInt
argument_list|(
name|substring
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|NumberFormatException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Couldn't parse substring \""
operator|+
name|substring
operator|+
literal|"\" with token "
operator|+
name|token
operator|+
literal|" to int. Pattern is "
operator|+
name|pattern
argument_list|,
name|e
argument_list|)
throw|;
block|}
if|if
condition|(
name|timeZoneMinutes
argument_list|<
literal|0
operator|||
name|timeZoneMinutes
argument_list|>
literal|59
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Couldn't parse substring \""
operator|+
name|substring
operator|+
literal|"\" to TZM because TZM range is 0 to 59. Pattern is "
operator|+
name|pattern
argument_list|)
throw|;
block|}
block|}
name|index
operator|+=
name|substring
operator|.
name|length
argument_list|()
expr_stmt|;
break|break;
case|case
name|SEPARATOR
case|:
name|index
operator|=
name|parseSeparator
argument_list|(
name|fullInput
argument_list|,
name|index
argument_list|,
name|token
argument_list|)
expr_stmt|;
break|break;
case|case
name|ISO_8601_DELIMITER
case|:
name|index
operator|=
name|parseIso8601Delimiter
argument_list|(
name|fullInput
argument_list|,
name|index
argument_list|,
name|token
argument_list|)
expr_stmt|;
default|default:
comment|//do nothing
block|}
block|}
comment|// anything left unparsed at end of string? throw error
if|if
condition|(
operator|!
name|fullInput
operator|.
name|substring
argument_list|(
name|index
argument_list|)
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Leftover input after parsing: "
operator|+
name|fullInput
operator|.
name|substring
argument_list|(
name|index
argument_list|)
operator|+
literal|" in string "
operator|+
name|fullInput
argument_list|)
throw|;
block|}
return|return
name|Timestamp
operator|.
name|ofEpochSecond
argument_list|(
name|ldt
operator|.
name|toEpochSecond
argument_list|(
name|ZoneOffset
operator|.
name|UTC
argument_list|)
argument_list|,
name|ldt
operator|.
name|getNano
argument_list|()
argument_list|)
return|;
block|}
specifier|public
name|Date
name|parseDate
parameter_list|(
name|String
name|input
parameter_list|)
block|{
return|return
name|Date
operator|.
name|ofEpochMilli
argument_list|(
name|parseTimestamp
argument_list|(
name|input
argument_list|)
operator|.
name|toEpochMilli
argument_list|()
argument_list|)
return|;
block|}
comment|/**    * Return the next substring to parse. Length is either specified or token.length, but a    * separator or an ISO-8601 delimiter can cut the substring short. (e.g. if the token pattern is    * "YYYY" we expect the next 4 characters to be 4 numbers. However, if it is "976/" then we    * return "976" because a separator cuts it short.)    */
specifier|private
name|String
name|getNextSubstring
parameter_list|(
name|String
name|s
parameter_list|,
name|int
name|begin
parameter_list|,
name|Token
name|token
parameter_list|)
block|{
return|return
name|getNextSubstring
argument_list|(
name|s
argument_list|,
name|begin
argument_list|,
name|begin
operator|+
name|token
operator|.
name|length
argument_list|,
name|token
argument_list|)
return|;
block|}
specifier|private
name|String
name|getNextSubstring
parameter_list|(
name|String
name|s
parameter_list|,
name|int
name|begin
parameter_list|,
name|int
name|end
parameter_list|,
name|Token
name|token
parameter_list|)
block|{
if|if
condition|(
name|end
operator|>
name|s
operator|.
name|length
argument_list|()
condition|)
block|{
name|end
operator|=
name|s
operator|.
name|length
argument_list|()
expr_stmt|;
block|}
name|s
operator|=
name|s
operator|.
name|substring
argument_list|(
name|begin
argument_list|,
name|end
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|.
name|temporalField
operator|==
name|ChronoField
operator|.
name|AMPM_OF_DAY
condition|)
block|{
if|if
condition|(
name|s
operator|.
name|charAt
argument_list|(
literal|1
argument_list|)
operator|==
literal|'m'
operator|||
name|s
operator|.
name|charAt
argument_list|(
literal|1
argument_list|)
operator|==
literal|'M'
condition|)
block|{
comment|// length 2
return|return
name|s
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
literal|2
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|s
return|;
block|}
block|}
for|for
control|(
name|String
name|sep
range|:
name|VALID_SEPARATORS
control|)
block|{
if|if
condition|(
name|s
operator|.
name|contains
argument_list|(
name|sep
argument_list|)
condition|)
block|{
name|s
operator|=
name|s
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|s
operator|.
name|indexOf
argument_list|(
name|sep
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|// TODO this will cause problems with DAY (for example, Thursday starts with T)
for|for
control|(
name|String
name|delimiter
range|:
name|VALID_ISO_8601_DELIMITERS
control|)
block|{
if|if
condition|(
name|s
operator|.
name|toLowerCase
argument_list|()
operator|.
name|contains
argument_list|(
name|delimiter
argument_list|)
condition|)
block|{
name|s
operator|=
name|s
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|s
operator|.
name|toLowerCase
argument_list|()
operator|.
name|indexOf
argument_list|(
name|delimiter
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|s
return|;
block|}
comment|/**    * Get the integer value of a temporal substring.    */
specifier|private
name|int
name|parseTemporal
parameter_list|(
name|String
name|substring
parameter_list|,
name|Token
name|token
parameter_list|)
block|{
comment|// exceptions to the rule
if|if
condition|(
name|token
operator|.
name|temporalField
operator|==
name|ChronoField
operator|.
name|AMPM_OF_DAY
condition|)
block|{
return|return
name|substring
operator|.
name|toLowerCase
argument_list|()
operator|.
name|startsWith
argument_list|(
literal|"a"
argument_list|)
condition|?
name|AM
else|:
name|PM
return|;
block|}
elseif|else
if|if
condition|(
name|token
operator|.
name|temporalField
operator|==
name|ChronoField
operator|.
name|HOUR_OF_AMPM
operator|&&
literal|"12"
operator|.
name|equals
argument_list|(
name|substring
argument_list|)
condition|)
block|{
name|substring
operator|=
literal|"0"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|token
operator|.
name|temporalField
operator|==
name|ChronoField
operator|.
name|YEAR
condition|)
block|{
name|String
name|currentYearString
init|=
name|String
operator|.
name|valueOf
argument_list|(
name|LocalDateTime
operator|.
name|now
argument_list|()
operator|.
name|getYear
argument_list|()
argument_list|)
decl_stmt|;
comment|//deal with round years
if|if
condition|(
name|token
operator|.
name|string
operator|.
name|startsWith
argument_list|(
literal|"r"
argument_list|)
operator|&&
name|substring
operator|.
name|length
argument_list|()
operator|==
literal|2
condition|)
block|{
name|int
name|currFirst2Digits
init|=
name|Integer
operator|.
name|parseInt
argument_list|(
name|currentYearString
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
literal|2
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|currLast2Digits
init|=
name|Integer
operator|.
name|parseInt
argument_list|(
name|currentYearString
operator|.
name|substring
argument_list|(
literal|2
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|valLast2Digits
init|=
name|Integer
operator|.
name|parseInt
argument_list|(
name|substring
argument_list|)
decl_stmt|;
if|if
condition|(
name|valLast2Digits
operator|<
literal|50
operator|&&
name|currLast2Digits
operator|>=
literal|50
condition|)
block|{
name|currFirst2Digits
operator|+=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|valLast2Digits
operator|>=
literal|50
operator|&&
name|currLast2Digits
operator|<
literal|50
condition|)
block|{
name|currFirst2Digits
operator|-=
literal|1
expr_stmt|;
block|}
name|substring
operator|=
name|String
operator|.
name|valueOf
argument_list|(
name|currFirst2Digits
argument_list|)
operator|+
name|substring
expr_stmt|;
block|}
else|else
block|{
comment|// fill in prefix digits with current date
name|substring
operator|=
name|currentYearString
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
literal|4
operator|-
name|substring
operator|.
name|length
argument_list|()
argument_list|)
operator|+
name|substring
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|token
operator|.
name|temporalField
operator|==
name|ChronoField
operator|.
name|NANO_OF_SECOND
condition|)
block|{
name|int
name|i
init|=
name|Integer
operator|.
name|min
argument_list|(
name|token
operator|.
name|length
argument_list|,
name|substring
operator|.
name|length
argument_list|()
argument_list|)
decl_stmt|;
name|substring
operator|+=
name|StringUtils
operator|.
name|repeat
argument_list|(
literal|"0"
argument_list|,
name|NANOS_MAX_LENGTH
operator|-
name|i
argument_list|)
expr_stmt|;
block|}
comment|// the rule
try|try
block|{
return|return
name|Integer
operator|.
name|parseInt
argument_list|(
name|substring
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|NumberFormatException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Couldn't parse substring \""
operator|+
name|substring
operator|+
literal|"\" with token "
operator|+
name|token
operator|+
literal|" to integer. Pattern is "
operator|+
name|pattern
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
comment|/**    * Parse the next separator(s). At least one separator character is expected. Separator    * characters are interchangeable.    *    * Caveat: If the last separator character in the separator substring is "-" and is immediately    *     followed by a time zone hour (tzh) token, it's a negative sign and not counted as a    *     separator, UNLESS this is the only separator character in the separator substring (in    *     which case it is not counted as the negative sign).    *    * @throws IllegalArgumentException if separator is missing    */
specifier|private
name|int
name|parseSeparator
parameter_list|(
name|String
name|fullInput
parameter_list|,
name|int
name|index
parameter_list|,
name|Token
name|token
parameter_list|)
block|{
name|int
name|separatorsFound
init|=
literal|0
decl_stmt|;
name|int
name|begin
init|=
name|index
decl_stmt|;
while|while
condition|(
name|index
operator|<
name|fullInput
operator|.
name|length
argument_list|()
operator|&&
name|VALID_SEPARATORS
operator|.
name|contains
argument_list|(
name|fullInput
operator|.
name|substring
argument_list|(
name|index
argument_list|,
name|index
operator|+
literal|1
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|isLastCharacterOfSeparator
argument_list|(
name|index
argument_list|,
name|fullInput
argument_list|)
operator|||
operator|!
operator|(
literal|"-"
operator|.
name|equals
argument_list|(
name|fullInput
operator|.
name|substring
argument_list|(
name|index
argument_list|,
name|index
operator|+
literal|1
argument_list|)
argument_list|)
operator|&&
operator|(
name|nextTokenIs
argument_list|(
literal|"tzh"
argument_list|,
name|token
argument_list|)
operator|)
operator|)
operator|||
name|separatorsFound
operator|==
literal|0
condition|)
block|{
name|separatorsFound
operator|++
expr_stmt|;
block|}
name|index
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|separatorsFound
operator|==
literal|0
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Missing separator at index "
operator|+
name|index
argument_list|)
throw|;
block|}
return|return
name|begin
operator|+
name|separatorsFound
return|;
block|}
specifier|private
name|int
name|parseIso8601Delimiter
parameter_list|(
name|String
name|fullInput
parameter_list|,
name|int
name|index
parameter_list|,
name|Token
name|token
parameter_list|)
block|{
name|String
name|substring
decl_stmt|;
name|substring
operator|=
name|fullInput
operator|.
name|substring
argument_list|(
name|index
argument_list|,
name|index
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|.
name|string
operator|.
name|equalsIgnoreCase
argument_list|(
name|substring
argument_list|)
condition|)
block|{
name|index
operator|++
expr_stmt|;
block|}
else|else
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Missing ISO 8601 delimiter "
operator|+
name|token
operator|.
name|string
operator|.
name|toUpperCase
argument_list|()
argument_list|)
throw|;
block|}
return|return
name|index
return|;
block|}
comment|/**    * Is the next character something other than a separator?    */
specifier|private
name|boolean
name|isLastCharacterOfSeparator
parameter_list|(
name|int
name|index
parameter_list|,
name|String
name|string
parameter_list|)
block|{
if|if
condition|(
name|index
operator|==
name|string
operator|.
name|length
argument_list|()
operator|-
literal|1
condition|)
block|{
comment|// if we're at the end of the string, yes
return|return
literal|true
return|;
block|}
return|return
operator|!
name|VALID_SEPARATORS
operator|.
name|contains
argument_list|(
name|string
operator|.
name|substring
argument_list|(
name|index
operator|+
literal|1
argument_list|,
name|index
operator|+
literal|2
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Does the temporalUnit/temporalField of the next token match the pattern's?    */
specifier|private
name|boolean
name|nextTokenIs
parameter_list|(
name|String
name|pattern
parameter_list|,
name|Token
name|currentToken
parameter_list|)
block|{
comment|// make sure currentToken isn't the last one
if|if
condition|(
name|tokens
operator|.
name|indexOf
argument_list|(
name|currentToken
argument_list|)
operator|==
name|tokens
operator|.
name|size
argument_list|()
operator|-
literal|1
condition|)
block|{
return|return
literal|false
return|;
block|}
name|Token
name|nextToken
init|=
name|tokens
operator|.
name|get
argument_list|(
name|tokens
operator|.
name|indexOf
argument_list|(
name|currentToken
argument_list|)
operator|+
literal|1
argument_list|)
decl_stmt|;
name|pattern
operator|=
name|pattern
operator|.
name|toLowerCase
argument_list|()
expr_stmt|;
return|return
operator|(
name|isTimeZoneToken
argument_list|(
name|pattern
argument_list|)
operator|&&
name|TIME_ZONE_TOKENS
operator|.
name|get
argument_list|(
name|pattern
argument_list|)
operator|==
name|nextToken
operator|.
name|temporalUnit
operator|||
name|isTemporalToken
argument_list|(
name|pattern
argument_list|)
operator|&&
name|TEMPORAL_TOKENS
operator|.
name|get
argument_list|(
name|pattern
argument_list|)
operator|==
name|nextToken
operator|.
name|temporalField
operator|)
return|;
block|}
specifier|public
name|String
name|getPattern
parameter_list|()
block|{
return|return
name|pattern
return|;
block|}
comment|/**    * @return a copy of token list    */
specifier|protected
name|List
argument_list|<
name|Token
argument_list|>
name|getTokens
parameter_list|()
block|{
return|return
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|tokens
argument_list|)
return|;
block|}
block|}
end_class

end_unit

