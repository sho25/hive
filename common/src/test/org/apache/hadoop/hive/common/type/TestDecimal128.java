begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Copyright (c) Microsoft Corporation  *  * Licensed under the Apache License, Version 2.0 (the "License");  * you may not use this file except in compliance with the License.  * You may obtain a copy of the License at  *  * http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|common
operator|.
name|type
package|;
end_package

begin_import
import|import static
name|org
operator|.
name|junit
operator|.
name|Assert
operator|.
name|*
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Random
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|After
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|Before
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|Test
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|common
operator|.
name|type
operator|.
name|UnsignedInt128
import|;
end_import

begin_comment
comment|/**  * This code was originally written for Microsoft PolyBase.  */
end_comment

begin_class
specifier|public
class|class
name|TestDecimal128
block|{
specifier|private
name|Decimal128
name|zero
decl_stmt|;
specifier|private
name|Decimal128
name|one
decl_stmt|;
specifier|private
name|Decimal128
name|two
decl_stmt|;
annotation|@
name|Before
specifier|public
name|void
name|setUp
parameter_list|()
throws|throws
name|Exception
block|{
name|zero
operator|=
operator|new
name|Decimal128
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|one
operator|=
operator|new
name|Decimal128
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|two
operator|=
operator|new
name|Decimal128
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
annotation|@
name|After
specifier|public
name|void
name|tearDown
parameter_list|()
throws|throws
name|Exception
block|{   }
annotation|@
name|Test
specifier|public
name|void
name|testCalculateTenThirtyEight
parameter_list|()
block|{
comment|// find 10^38
name|Decimal128
name|ten
init|=
operator|new
name|Decimal128
argument_list|(
literal|10
argument_list|,
operator|(
name|short
operator|)
literal|0
argument_list|)
decl_stmt|;
name|Decimal128
name|val
init|=
operator|new
name|Decimal128
argument_list|(
literal|1
argument_list|,
operator|(
name|short
operator|)
literal|0
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
literal|38
condition|;
operator|++
name|i
control|)
block|{
name|val
operator|.
name|multiplyDestructive
argument_list|(
name|ten
argument_list|,
operator|(
name|short
operator|)
literal|0
argument_list|)
expr_stmt|;
block|}
comment|// verify it
name|String
name|s
init|=
name|val
operator|.
name|toFormalString
argument_list|()
decl_stmt|;
name|assertEquals
argument_list|(
literal|"100000000000000000000000000000000000000"
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|boolean
name|overflow
init|=
literal|false
decl_stmt|;
comment|// show that it is is an overflow for precision 38
try|try
block|{
name|val
operator|.
name|checkPrecisionOverflow
argument_list|(
literal|38
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|overflow
operator|=
literal|true
expr_stmt|;
block|}
name|assertTrue
argument_list|(
name|overflow
argument_list|)
expr_stmt|;
comment|// subtract one
name|val
operator|.
name|subtractDestructive
argument_list|(
name|one
argument_list|,
operator|(
name|short
operator|)
literal|0
argument_list|)
expr_stmt|;
name|overflow
operator|=
literal|false
expr_stmt|;
comment|// show that it does not overflow for precision 38
try|try
block|{
name|val
operator|.
name|checkPrecisionOverflow
argument_list|(
literal|38
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|overflow
operator|=
literal|true
expr_stmt|;
block|}
name|assertFalse
argument_list|(
name|overflow
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testHashCode
parameter_list|()
block|{
name|assertTrue
argument_list|(
name|one
operator|.
name|hashCode
argument_list|()
operator|!=
name|two
operator|.
name|hashCode
argument_list|()
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|zero
operator|.
name|hashCode
argument_list|()
operator|!=
name|one
operator|.
name|hashCode
argument_list|()
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|zero
operator|.
name|hashCode
argument_list|()
operator|!=
name|two
operator|.
name|hashCode
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|zero
operator|.
name|hashCode
argument_list|()
argument_list|,
operator|new
name|Decimal128
argument_list|(
literal|0
argument_list|)
operator|.
name|hashCode
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|one
operator|.
name|hashCode
argument_list|()
argument_list|,
operator|new
name|Decimal128
argument_list|(
literal|1
argument_list|)
operator|.
name|hashCode
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|two
operator|.
name|hashCode
argument_list|()
argument_list|,
operator|new
name|Decimal128
argument_list|(
literal|2
argument_list|)
operator|.
name|hashCode
argument_list|()
argument_list|)
expr_stmt|;
comment|// scaled value might be not equal, but after scaling it should.
name|Decimal128
name|oneScaled
init|=
operator|new
name|Decimal128
argument_list|(
literal|1L
argument_list|,
operator|(
name|short
operator|)
literal|3
argument_list|)
decl_stmt|;
name|oneScaled
operator|.
name|changeScaleDestructive
argument_list|(
operator|(
name|short
operator|)
literal|0
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|one
operator|.
name|hashCode
argument_list|()
argument_list|,
name|oneScaled
operator|.
name|hashCode
argument_list|()
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testEquals
parameter_list|()
block|{
name|assertTrue
argument_list|(
operator|!
name|one
operator|.
name|equals
argument_list|(
name|two
argument_list|)
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
operator|!
name|zero
operator|.
name|equals
argument_list|(
name|one
argument_list|)
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
operator|!
name|zero
operator|.
name|equals
argument_list|(
name|two
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|zero
argument_list|,
operator|new
name|Decimal128
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|one
argument_list|,
operator|new
name|Decimal128
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|two
argument_list|,
operator|new
name|Decimal128
argument_list|(
literal|2
argument_list|)
argument_list|)
expr_stmt|;
comment|// scaled value might be not equal, but after scaling it should.
name|Decimal128
name|oneScaled
init|=
operator|new
name|Decimal128
argument_list|(
literal|1L
argument_list|,
operator|(
name|short
operator|)
literal|3
argument_list|)
decl_stmt|;
name|oneScaled
operator|.
name|changeScaleDestructive
argument_list|(
operator|(
name|short
operator|)
literal|0
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|one
argument_list|,
name|oneScaled
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testCompareTo
parameter_list|()
block|{
name|assertTrue
argument_list|(
name|one
operator|.
name|compareTo
argument_list|(
name|two
argument_list|)
operator|<
literal|0
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|two
operator|.
name|compareTo
argument_list|(
name|one
argument_list|)
operator|>
literal|0
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|one
operator|.
name|compareTo
argument_list|(
name|zero
argument_list|)
operator|>
literal|0
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|zero
operator|.
name|compareTo
argument_list|(
name|two
argument_list|)
operator|<
literal|0
argument_list|)
expr_stmt|;
comment|// compare to must compare with scaling up/down.
name|Decimal128
name|oneScaled
init|=
operator|new
name|Decimal128
argument_list|(
literal|1L
argument_list|,
operator|(
name|short
operator|)
literal|3
argument_list|)
decl_stmt|;
name|assertTrue
argument_list|(
name|one
operator|.
name|compareTo
argument_list|(
name|oneScaled
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
comment|// exact numbers (power of 2) can do the same
name|Decimal128
name|d1
init|=
operator|new
name|Decimal128
argument_list|(
literal|2.0d
argument_list|,
operator|(
name|short
operator|)
literal|6
argument_list|)
decl_stmt|;
name|Decimal128
name|d2
init|=
operator|new
name|Decimal128
argument_list|(
literal|2.0d
argument_list|,
operator|(
name|short
operator|)
literal|3
argument_list|)
decl_stmt|;
name|assertTrue
argument_list|(
name|d1
operator|.
name|compareTo
argument_list|(
name|d2
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
comment|// but, if the value is rounded by more scaling,
comment|// they will be different values.
name|Decimal128
name|d3
init|=
operator|new
name|Decimal128
argument_list|(
literal|2.0d
operator|/
literal|3.0d
argument_list|,
operator|(
name|short
operator|)
literal|5
argument_list|)
decl_stmt|;
name|Decimal128
name|d4
init|=
operator|new
name|Decimal128
argument_list|(
literal|2.0d
operator|/
literal|3.0d
argument_list|,
operator|(
name|short
operator|)
literal|8
argument_list|)
decl_stmt|;
name|assertTrue
argument_list|(
name|d3
operator|.
name|compareTo
argument_list|(
name|d4
argument_list|)
operator|!=
literal|0
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testText
parameter_list|()
block|{
name|assertEquals
argument_list|(
literal|"1"
argument_list|,
name|one
operator|.
name|toFormalString
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|0
argument_list|,
operator|new
name|Decimal128
argument_list|(
literal|"1"
argument_list|,
operator|(
name|short
operator|)
literal|0
argument_list|)
operator|.
name|compareTo
argument_list|(
name|one
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"2"
argument_list|,
name|two
operator|.
name|toFormalString
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|0
argument_list|,
operator|new
name|Decimal128
argument_list|(
literal|"2"
argument_list|,
operator|(
name|short
operator|)
literal|0
argument_list|)
operator|.
name|compareTo
argument_list|(
name|two
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"0"
argument_list|,
name|zero
operator|.
name|toFormalString
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|0
argument_list|,
operator|new
name|Decimal128
argument_list|(
literal|"0"
argument_list|,
operator|(
name|short
operator|)
literal|0
argument_list|)
operator|.
name|compareTo
argument_list|(
name|zero
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"1.000"
argument_list|,
operator|new
name|Decimal128
argument_list|(
literal|1L
argument_list|,
operator|(
name|short
operator|)
literal|3
argument_list|)
operator|.
name|toFormalString
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|0
argument_list|,
operator|new
name|Decimal128
argument_list|(
literal|"1"
argument_list|,
operator|(
name|short
operator|)
literal|3
argument_list|)
operator|.
name|compareTo
argument_list|(
name|one
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"2.000000"
argument_list|,
operator|new
name|Decimal128
argument_list|(
literal|2.0d
argument_list|,
operator|(
name|short
operator|)
literal|6
argument_list|)
operator|.
name|toFormalString
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"2.000"
argument_list|,
operator|new
name|Decimal128
argument_list|(
literal|2.0d
argument_list|,
operator|(
name|short
operator|)
literal|3
argument_list|)
operator|.
name|toFormalString
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|0
argument_list|,
operator|new
name|Decimal128
argument_list|(
literal|"2.0"
argument_list|,
operator|(
name|short
operator|)
literal|6
argument_list|)
operator|.
name|compareTo
argument_list|(
name|two
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|0
argument_list|,
operator|new
name|Decimal128
argument_list|(
literal|"2.0"
argument_list|,
operator|(
name|short
operator|)
literal|3
argument_list|)
operator|.
name|compareTo
argument_list|(
name|two
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"1.3330"
argument_list|,
operator|new
name|Decimal128
argument_list|(
literal|"1.333"
argument_list|,
operator|(
name|short
operator|)
literal|4
argument_list|)
operator|.
name|toFormalString
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"1.333000"
argument_list|,
operator|new
name|Decimal128
argument_list|(
literal|"1.333"
argument_list|,
operator|(
name|short
operator|)
literal|6
argument_list|)
operator|.
name|toFormalString
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"1.333"
argument_list|,
operator|new
name|Decimal128
argument_list|(
literal|"1.333"
argument_list|,
operator|(
name|short
operator|)
literal|3
argument_list|)
operator|.
name|toFormalString
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"1.33"
argument_list|,
operator|new
name|Decimal128
argument_list|(
literal|"1.333"
argument_list|,
operator|(
name|short
operator|)
literal|2
argument_list|)
operator|.
name|toFormalString
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"1.33"
argument_list|,
operator|new
name|Decimal128
argument_list|(
literal|"1.333"
argument_list|,
operator|(
name|short
operator|)
literal|2
argument_list|)
operator|.
name|toFormalString
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"0.13330"
argument_list|,
operator|new
name|Decimal128
argument_list|(
literal|"1333E-4"
argument_list|,
operator|(
name|short
operator|)
literal|5
argument_list|)
operator|.
name|toFormalString
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"0.01333"
argument_list|,
operator|new
name|Decimal128
argument_list|(
literal|"1333E-5"
argument_list|,
operator|(
name|short
operator|)
literal|5
argument_list|)
operator|.
name|toFormalString
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"13330000.00"
argument_list|,
operator|new
name|Decimal128
argument_list|(
literal|"1333E4"
argument_list|,
operator|(
name|short
operator|)
literal|2
argument_list|)
operator|.
name|toFormalString
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"123456789012345678901234.56789"
argument_list|,
operator|new
name|Decimal128
argument_list|(
literal|"123456789012345678901234567.8901234E-3"
argument_list|,
operator|(
name|short
operator|)
literal|5
argument_list|)
operator|.
name|toFormalString
argument_list|()
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testAdd
parameter_list|()
block|{
name|Decimal128
name|result
init|=
operator|new
name|Decimal128
argument_list|()
decl_stmt|;
name|Decimal128
operator|.
name|add
argument_list|(
name|one
argument_list|,
name|two
argument_list|,
name|result
argument_list|,
operator|(
name|short
operator|)
literal|2
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|0
argument_list|,
operator|new
name|Decimal128
argument_list|(
literal|3L
argument_list|,
operator|(
name|short
operator|)
literal|0
argument_list|)
operator|.
name|compareTo
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
name|Decimal128
operator|.
name|add
argument_list|(
name|two
argument_list|,
name|two
argument_list|,
name|result
argument_list|,
operator|(
name|short
operator|)
literal|1
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|0
argument_list|,
operator|new
name|Decimal128
argument_list|(
literal|4L
argument_list|,
operator|(
name|short
operator|)
literal|0
argument_list|)
operator|.
name|compareTo
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
name|long
name|l1
init|=
literal|123456789012345L
decl_stmt|;
name|long
name|l2
init|=
literal|987654321097L
decl_stmt|;
name|long
name|sum
init|=
name|l1
operator|+
name|l2
decl_stmt|;
name|Decimal128
name|left
init|=
operator|new
name|Decimal128
argument_list|(
name|l1
argument_list|,
operator|(
name|short
operator|)
literal|3
argument_list|)
decl_stmt|;
name|Decimal128
name|right
init|=
operator|new
name|Decimal128
argument_list|(
name|l2
argument_list|,
operator|(
name|short
operator|)
literal|5
argument_list|)
decl_stmt|;
name|Decimal128
operator|.
name|add
argument_list|(
name|left
argument_list|,
name|right
argument_list|,
name|result
argument_list|,
operator|(
name|short
operator|)
literal|2
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|0
argument_list|,
operator|new
name|Decimal128
argument_list|(
name|sum
argument_list|,
operator|(
name|short
operator|)
literal|0
argument_list|)
operator|.
name|compareTo
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
name|Decimal128
operator|.
name|add
argument_list|(
name|right
argument_list|,
name|left
argument_list|,
name|result
argument_list|,
operator|(
name|short
operator|)
literal|2
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|0
argument_list|,
operator|new
name|Decimal128
argument_list|(
name|sum
argument_list|,
operator|(
name|short
operator|)
literal|0
argument_list|)
operator|.
name|compareTo
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testSubtract
parameter_list|()
block|{
name|Decimal128
name|result
init|=
operator|new
name|Decimal128
argument_list|()
decl_stmt|;
name|Decimal128
operator|.
name|subtract
argument_list|(
name|one
argument_list|,
name|two
argument_list|,
name|result
argument_list|,
operator|(
name|short
operator|)
literal|2
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|0
argument_list|,
operator|new
name|Decimal128
argument_list|(
operator|-
literal|1L
argument_list|,
operator|(
name|short
operator|)
literal|0
argument_list|)
operator|.
name|compareTo
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
name|Decimal128
operator|.
name|subtract
argument_list|(
name|two
argument_list|,
name|one
argument_list|,
name|result
argument_list|,
operator|(
name|short
operator|)
literal|2
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|0
argument_list|,
operator|new
name|Decimal128
argument_list|(
literal|1L
argument_list|,
operator|(
name|short
operator|)
literal|0
argument_list|)
operator|.
name|compareTo
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
name|Decimal128
operator|.
name|subtract
argument_list|(
name|two
argument_list|,
name|two
argument_list|,
name|result
argument_list|,
operator|(
name|short
operator|)
literal|1
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|0
argument_list|,
name|zero
operator|.
name|compareTo
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|0
argument_list|,
name|result
operator|.
name|getSignum
argument_list|()
argument_list|)
expr_stmt|;
name|long
name|l1
init|=
literal|123456789012345L
decl_stmt|;
name|long
name|l2
init|=
literal|987654321097L
decl_stmt|;
name|long
name|sub
init|=
name|l1
operator|-
name|l2
decl_stmt|;
name|Decimal128
name|left
init|=
operator|new
name|Decimal128
argument_list|(
name|l1
argument_list|,
operator|(
name|short
operator|)
literal|3
argument_list|)
decl_stmt|;
name|Decimal128
name|right
init|=
operator|new
name|Decimal128
argument_list|(
name|l2
argument_list|,
operator|(
name|short
operator|)
literal|5
argument_list|)
decl_stmt|;
name|Decimal128
operator|.
name|subtract
argument_list|(
name|left
argument_list|,
name|right
argument_list|,
name|result
argument_list|,
operator|(
name|short
operator|)
literal|2
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|0
argument_list|,
operator|new
name|Decimal128
argument_list|(
name|sub
argument_list|,
operator|(
name|short
operator|)
literal|0
argument_list|)
operator|.
name|compareTo
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
name|Decimal128
operator|.
name|subtract
argument_list|(
name|right
argument_list|,
name|left
argument_list|,
name|result
argument_list|,
operator|(
name|short
operator|)
literal|2
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|0
argument_list|,
operator|new
name|Decimal128
argument_list|(
operator|-
name|sub
argument_list|,
operator|(
name|short
operator|)
literal|0
argument_list|)
operator|.
name|compareTo
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
name|Decimal128
name|val
init|=
operator|new
name|Decimal128
argument_list|(
literal|"1.123"
argument_list|,
operator|(
name|short
operator|)
literal|3
argument_list|)
decl_stmt|;
name|val
operator|.
name|addDestructive
argument_list|(
operator|new
name|Decimal128
argument_list|(
literal|"4.321"
argument_list|,
operator|(
name|short
operator|)
literal|3
argument_list|)
argument_list|,
operator|(
name|short
operator|)
literal|3
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"5.444"
argument_list|,
name|val
operator|.
name|toFormalString
argument_list|()
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testMultiply
parameter_list|()
block|{
name|Decimal128
name|result
init|=
operator|new
name|Decimal128
argument_list|()
decl_stmt|;
name|Decimal128
operator|.
name|multiply
argument_list|(
name|one
argument_list|,
name|two
argument_list|,
name|result
argument_list|,
operator|(
name|short
operator|)
literal|2
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|0
argument_list|,
name|two
operator|.
name|compareTo
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
name|Decimal128
operator|.
name|multiply
argument_list|(
name|two
argument_list|,
name|two
argument_list|,
name|result
argument_list|,
operator|(
name|short
operator|)
literal|2
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|0
argument_list|,
operator|new
name|Decimal128
argument_list|(
literal|4L
argument_list|,
operator|(
name|short
operator|)
literal|0
argument_list|)
operator|.
name|compareTo
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
name|long
name|l1
init|=
literal|123456789012345L
decl_stmt|;
name|long
name|l2
init|=
literal|987654321097L
decl_stmt|;
name|Decimal128
name|left
init|=
operator|new
name|Decimal128
argument_list|(
name|l1
argument_list|,
operator|(
name|short
operator|)
literal|0
argument_list|)
decl_stmt|;
name|Decimal128
name|right
init|=
operator|new
name|Decimal128
argument_list|(
name|l2
argument_list|,
operator|(
name|short
operator|)
literal|0
argument_list|)
decl_stmt|;
name|UnsignedInt128
name|unscaled
init|=
operator|new
name|UnsignedInt128
argument_list|(
name|l1
argument_list|)
operator|.
name|multiplyConstructive
argument_list|(
operator|new
name|UnsignedInt128
argument_list|(
name|l2
argument_list|)
argument_list|)
decl_stmt|;
name|Decimal128
name|ans
init|=
operator|new
name|Decimal128
argument_list|(
name|unscaled
argument_list|,
operator|(
name|short
operator|)
literal|0
argument_list|,
literal|false
argument_list|)
decl_stmt|;
name|Decimal128
operator|.
name|multiply
argument_list|(
name|left
argument_list|,
name|right
argument_list|,
name|result
argument_list|,
operator|(
name|short
operator|)
literal|0
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|0
argument_list|,
name|ans
operator|.
name|compareTo
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
name|Decimal128
operator|.
name|multiply
argument_list|(
name|right
argument_list|,
name|left
argument_list|,
name|result
argument_list|,
operator|(
name|short
operator|)
literal|0
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|0
argument_list|,
name|ans
operator|.
name|compareTo
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
name|Decimal128
operator|.
name|multiply
argument_list|(
operator|new
name|Decimal128
argument_list|(
literal|1.123d
argument_list|,
operator|(
name|short
operator|)
literal|10
argument_list|)
argument_list|,
operator|new
name|Decimal128
argument_list|(
literal|4.321d
argument_list|,
operator|(
name|short
operator|)
literal|10
argument_list|)
argument_list|,
name|result
argument_list|,
operator|(
name|short
operator|)
literal|10
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|1.123d
operator|*
literal|4.321d
argument_list|,
name|result
operator|.
name|doubleValue
argument_list|()
argument_list|,
literal|0.00001d
argument_list|)
expr_stmt|;
comment|// because only 10 fractional digits, it's not this much accurate
name|assertNotEquals
argument_list|(
literal|1.123d
operator|*
literal|4.321d
argument_list|,
name|result
operator|.
name|doubleValue
argument_list|()
argument_list|,
literal|0.00000000000000001d
argument_list|)
expr_stmt|;
name|Decimal128
operator|.
name|multiply
argument_list|(
operator|new
name|Decimal128
argument_list|(
literal|1.123d
argument_list|,
operator|(
name|short
operator|)
literal|2
argument_list|)
argument_list|,
operator|new
name|Decimal128
argument_list|(
literal|4.321d
argument_list|,
operator|(
name|short
operator|)
literal|2
argument_list|)
argument_list|,
name|result
argument_list|,
operator|(
name|short
operator|)
literal|2
argument_list|)
expr_stmt|;
comment|// this time even more inaccurate
name|assertEquals
argument_list|(
literal|1.123d
operator|*
literal|4.321d
argument_list|,
name|result
operator|.
name|doubleValue
argument_list|()
argument_list|,
literal|1.0d
argument_list|)
expr_stmt|;
name|assertNotEquals
argument_list|(
literal|1.123d
operator|*
literal|4.321d
argument_list|,
name|result
operator|.
name|doubleValue
argument_list|()
argument_list|,
literal|0.000001d
argument_list|)
expr_stmt|;
name|Decimal128
name|val
init|=
operator|new
name|Decimal128
argument_list|(
literal|"1.123"
argument_list|,
operator|(
name|short
operator|)
literal|3
argument_list|)
decl_stmt|;
name|val
operator|.
name|multiplyDestructive
argument_list|(
operator|new
name|Decimal128
argument_list|(
literal|"4.321"
argument_list|,
operator|(
name|short
operator|)
literal|3
argument_list|)
argument_list|,
operator|(
name|short
operator|)
literal|6
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"4.852483"
argument_list|,
name|val
operator|.
name|toFormalString
argument_list|()
argument_list|)
expr_stmt|;
name|Decimal128
name|val1
init|=
operator|new
name|Decimal128
argument_list|(
literal|"1.0001"
argument_list|,
operator|(
name|short
operator|)
literal|4
argument_list|)
decl_stmt|;
name|val1
operator|.
name|multiplyDestructive
argument_list|(
operator|new
name|Decimal128
argument_list|(
literal|"1.0001"
argument_list|,
operator|(
name|short
operator|)
literal|4
argument_list|)
argument_list|,
operator|(
name|short
operator|)
literal|8
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"1.00020001"
argument_list|,
name|val1
operator|.
name|toFormalString
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// Assert that a and b are not the same, within epsilon tolerance.
specifier|private
name|void
name|assertNotEquals
parameter_list|(
name|double
name|a
parameter_list|,
name|double
name|b
parameter_list|,
name|double
name|epsilon
parameter_list|)
block|{
name|assertTrue
argument_list|(
name|Math
operator|.
name|abs
argument_list|(
name|a
operator|-
name|b
argument_list|)
operator|>
name|epsilon
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testDivide
parameter_list|()
block|{
name|Decimal128
name|quotient
init|=
operator|new
name|Decimal128
argument_list|()
decl_stmt|;
name|Decimal128
operator|.
name|divide
argument_list|(
name|two
argument_list|,
name|one
argument_list|,
name|quotient
argument_list|,
operator|(
name|short
operator|)
literal|2
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|0
argument_list|,
name|quotient
operator|.
name|compareTo
argument_list|(
name|two
argument_list|)
argument_list|)
expr_stmt|;
name|Decimal128
operator|.
name|divide
argument_list|(
name|two
argument_list|,
name|two
argument_list|,
name|quotient
argument_list|,
operator|(
name|short
operator|)
literal|2
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|0
argument_list|,
name|quotient
operator|.
name|compareTo
argument_list|(
name|one
argument_list|)
argument_list|)
expr_stmt|;
name|Decimal128
name|three
init|=
operator|new
name|Decimal128
argument_list|(
literal|3
argument_list|)
decl_stmt|;
name|Decimal128
name|four
init|=
operator|new
name|Decimal128
argument_list|(
literal|4
argument_list|)
decl_stmt|;
name|Decimal128
operator|.
name|divide
argument_list|(
name|three
argument_list|,
name|four
argument_list|,
name|quotient
argument_list|,
operator|(
name|short
operator|)
literal|2
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"0.75"
argument_list|,
name|quotient
operator|.
name|toFormalString
argument_list|()
argument_list|)
expr_stmt|;
name|Decimal128
operator|.
name|divide
argument_list|(
name|three
argument_list|,
name|four
argument_list|,
name|quotient
argument_list|,
operator|(
name|short
operator|)
literal|1
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"0.8"
argument_list|,
name|quotient
operator|.
name|toFormalString
argument_list|()
argument_list|)
expr_stmt|;
name|Decimal128
operator|.
name|divide
argument_list|(
name|three
argument_list|,
name|four
argument_list|,
name|quotient
argument_list|,
operator|(
name|short
operator|)
literal|0
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"1"
argument_list|,
name|quotient
operator|.
name|toFormalString
argument_list|()
argument_list|)
expr_stmt|;
name|Decimal128
name|two
init|=
operator|new
name|Decimal128
argument_list|(
literal|2
argument_list|)
decl_stmt|;
name|Decimal128
operator|.
name|divide
argument_list|(
name|two
argument_list|,
name|three
argument_list|,
name|quotient
argument_list|,
operator|(
name|short
operator|)
literal|4
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"0.6667"
argument_list|,
name|quotient
operator|.
name|toFormalString
argument_list|()
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testRandomMultiplyDivideInverse
parameter_list|()
block|{
specifier|final
name|int
name|N
init|=
literal|100000
decl_stmt|;
specifier|final
name|long
name|MASK56
init|=
literal|0x00FFFFFFFFFFFFL
decl_stmt|;
comment|// 56 bit mask to generate positive 56 bit longs
comment|// from random signed longs
name|int
name|seed
init|=
literal|897089790
decl_stmt|;
name|Random
name|rand
init|=
operator|new
name|Random
argument_list|(
name|seed
argument_list|)
decl_stmt|;
name|long
name|l1
decl_stmt|,
name|l2
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<=
name|N
condition|;
name|i
operator|++
control|)
block|{
name|l1
operator|=
name|rand
operator|.
name|nextLong
argument_list|()
operator|&
name|MASK56
expr_stmt|;
name|l2
operator|=
name|rand
operator|.
name|nextLong
argument_list|()
operator|&
name|MASK56
expr_stmt|;
name|verifyMultiplyDivideInverse
argument_list|(
name|l1
argument_list|,
name|l2
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Verify that a * b / b == a    * for decimal division for scale 0 with integer inputs.    *    * Not valid if abs(a * b)>= 10**38.    */
specifier|private
name|void
name|verifyMultiplyDivideInverse
parameter_list|(
name|long
name|a
parameter_list|,
name|long
name|b
parameter_list|)
block|{
specifier|final
name|short
name|scale
init|=
literal|0
decl_stmt|;
comment|// ignore zero-divide cases
if|if
condition|(
name|b
operator|==
literal|0
condition|)
block|{
return|return;
block|}
name|Decimal128
name|decA
init|=
operator|new
name|Decimal128
argument_list|(
name|a
argument_list|,
name|scale
argument_list|)
decl_stmt|;
name|Decimal128
name|decB
init|=
operator|new
name|Decimal128
argument_list|(
name|b
argument_list|,
name|scale
argument_list|)
decl_stmt|;
name|decA
operator|.
name|multiplyDestructive
argument_list|(
name|decB
argument_list|,
name|scale
argument_list|)
expr_stmt|;
name|decA
operator|.
name|checkPrecisionOverflow
argument_list|(
literal|38
argument_list|)
expr_stmt|;
comment|// caller must make sure product of inputs is not too big
name|decA
operator|.
name|divideDestructive
argument_list|(
name|decB
argument_list|,
name|scale
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"Error for a = "
operator|+
name|Long
operator|.
name|toString
argument_list|(
name|a
argument_list|)
operator|+
literal|", b = "
operator|+
name|Long
operator|.
name|toString
argument_list|(
name|b
argument_list|)
argument_list|,
operator|new
name|Decimal128
argument_list|(
name|a
argument_list|,
name|scale
argument_list|)
argument_list|,
name|decA
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testRandomAddSubtractInverse
parameter_list|()
block|{
specifier|final
name|int
name|N
init|=
literal|1000000
decl_stmt|;
name|int
name|seed
init|=
literal|1427480960
decl_stmt|;
name|Random
name|rand
init|=
operator|new
name|Random
argument_list|(
name|seed
argument_list|)
decl_stmt|;
name|long
name|l1
decl_stmt|,
name|l2
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<=
name|N
condition|;
name|i
operator|++
control|)
block|{
name|l1
operator|=
name|rand
operator|.
name|nextLong
argument_list|()
expr_stmt|;
name|l2
operator|=
name|rand
operator|.
name|nextLong
argument_list|()
expr_stmt|;
name|verifyAddSubtractInverse
argument_list|(
name|l1
argument_list|,
name|l2
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Verify that (a + b) - b == a    * for decimal add and subtract for scale 0 with long integer inputs.    */
specifier|private
name|void
name|verifyAddSubtractInverse
parameter_list|(
name|long
name|a
parameter_list|,
name|long
name|b
parameter_list|)
block|{
specifier|final
name|short
name|scale
init|=
literal|0
decl_stmt|;
name|Decimal128
name|decA
init|=
operator|new
name|Decimal128
argument_list|(
name|a
argument_list|,
name|scale
argument_list|)
decl_stmt|;
name|Decimal128
name|decB
init|=
operator|new
name|Decimal128
argument_list|(
name|b
argument_list|,
name|scale
argument_list|)
decl_stmt|;
name|decA
operator|.
name|addDestructive
argument_list|(
name|decB
argument_list|,
name|scale
argument_list|)
expr_stmt|;
name|decA
operator|.
name|subtractDestructive
argument_list|(
name|decB
argument_list|,
name|scale
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"Error for a = "
operator|+
name|Long
operator|.
name|toString
argument_list|(
name|a
argument_list|)
operator|+
literal|", b = "
operator|+
name|Long
operator|.
name|toString
argument_list|(
name|b
argument_list|)
argument_list|,
operator|new
name|Decimal128
argument_list|(
name|a
argument_list|,
name|scale
argument_list|)
argument_list|,
name|decA
argument_list|)
expr_stmt|;
block|}
comment|/**    * During earlier code testing, if we found errors, test them here as regression tests.    */
annotation|@
name|Test
specifier|public
name|void
name|testKnownPriorErrors
parameter_list|()
block|{
comment|// Regression test for defect reported in HIVE-6243
name|long
name|a
init|=
literal|213474114411690L
decl_stmt|;
name|long
name|b
init|=
literal|5062120663L
decl_stmt|;
name|verifyMultiplyDivideInverse
argument_list|(
name|a
argument_list|,
name|b
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testPiNewton
parameter_list|()
block|{
comment|// see http://en.wikipedia.org/wiki/Approximations_of_%CF%80
comment|// Below is the simple Newton's equation
specifier|final
name|int
name|LOOPS
init|=
literal|100
decl_stmt|;
specifier|final
name|short
name|SCALE
init|=
literal|33
decl_stmt|;
name|Decimal128
name|current
init|=
operator|new
name|Decimal128
argument_list|(
literal|1
argument_list|,
name|SCALE
argument_list|)
decl_stmt|;
name|Decimal128
name|multiplier
init|=
operator|new
name|Decimal128
argument_list|()
decl_stmt|;
name|Decimal128
name|dividor
init|=
operator|new
name|Decimal128
argument_list|()
decl_stmt|;
name|Decimal128
name|one
init|=
operator|new
name|Decimal128
argument_list|(
literal|1
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
name|LOOPS
init|;
name|i
operator|>
literal|0
condition|;
operator|--
name|i
control|)
block|{
name|multiplier
operator|.
name|update
argument_list|(
name|i
argument_list|,
name|SCALE
argument_list|)
expr_stmt|;
name|current
operator|.
name|multiplyDestructive
argument_list|(
name|multiplier
argument_list|,
name|SCALE
argument_list|)
expr_stmt|;
name|dividor
operator|.
name|update
argument_list|(
literal|1
operator|+
literal|2
operator|*
name|i
argument_list|,
name|SCALE
argument_list|)
expr_stmt|;
name|current
operator|.
name|divideDestructive
argument_list|(
name|dividor
argument_list|,
name|SCALE
argument_list|)
expr_stmt|;
name|current
operator|.
name|addDestructive
argument_list|(
name|one
argument_list|,
name|SCALE
argument_list|)
expr_stmt|;
block|}
name|current
operator|.
name|multiplyDestructive
argument_list|(
operator|new
name|Decimal128
argument_list|(
literal|2
argument_list|)
argument_list|,
name|SCALE
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|current
operator|.
name|toFormalString
argument_list|()
operator|.
name|startsWith
argument_list|(
literal|"3.141592653589793238"
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testPiArcsine
parameter_list|()
block|{
comment|// This one uses the arcsin method. Involves more multiplications/divisions.
comment|// pi=Sum (3 * 2n!/(16^n * (2n+1) * n! * n!))
comment|// =Sum (3 * ((n+1)(n+2)...2n)/n!*16^n/(2n+1))
comment|// =Sum (3 / (2n+1) * (n+1)/16 * (n+2)/32... * 2n/16(n+1))
comment|// (note that it is split so that each term is not overflown)
specifier|final
name|int
name|LOOPS
init|=
literal|50
decl_stmt|;
specifier|final
name|short
name|SCALE
init|=
literal|30
decl_stmt|;
name|Decimal128
name|total
init|=
operator|new
name|Decimal128
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|Decimal128
name|multiplier
init|=
operator|new
name|Decimal128
argument_list|()
decl_stmt|;
name|Decimal128
name|dividor
init|=
operator|new
name|Decimal128
argument_list|()
decl_stmt|;
name|Decimal128
name|current
init|=
operator|new
name|Decimal128
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|LOOPS
condition|;
operator|++
name|i
control|)
block|{
name|current
operator|.
name|update
argument_list|(
literal|3
argument_list|,
name|SCALE
argument_list|)
expr_stmt|;
name|dividor
operator|.
name|update
argument_list|(
literal|2
operator|*
name|i
operator|+
literal|1
argument_list|,
name|SCALE
argument_list|)
expr_stmt|;
name|current
operator|.
name|divideDestructive
argument_list|(
name|dividor
argument_list|,
name|SCALE
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|1
init|;
name|j
operator|<=
name|i
condition|;
operator|++
name|j
control|)
block|{
name|multiplier
operator|.
name|update
argument_list|(
name|i
operator|+
name|j
argument_list|,
name|SCALE
argument_list|)
expr_stmt|;
name|dividor
operator|.
name|update
argument_list|(
literal|16
operator|*
name|j
argument_list|,
name|SCALE
argument_list|)
expr_stmt|;
name|current
operator|.
name|multiplyDestructive
argument_list|(
name|multiplier
argument_list|,
name|SCALE
argument_list|)
expr_stmt|;
name|current
operator|.
name|divideDestructive
argument_list|(
name|dividor
argument_list|,
name|SCALE
argument_list|)
expr_stmt|;
block|}
name|total
operator|.
name|addDestructive
argument_list|(
name|current
argument_list|,
name|SCALE
argument_list|)
expr_stmt|;
block|}
name|assertTrue
argument_list|(
name|total
operator|.
name|toFormalString
argument_list|()
operator|.
name|startsWith
argument_list|(
literal|"3.141592653589793238462"
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testDoubleValue
parameter_list|()
block|{
name|Decimal128
name|quotient
init|=
operator|new
name|Decimal128
argument_list|()
decl_stmt|;
name|Decimal128
name|three
init|=
operator|new
name|Decimal128
argument_list|(
literal|3
argument_list|)
decl_stmt|;
name|Decimal128
name|four
init|=
operator|new
name|Decimal128
argument_list|(
literal|9
argument_list|)
decl_stmt|;
name|Decimal128
operator|.
name|divide
argument_list|(
name|three
argument_list|,
name|four
argument_list|,
name|quotient
argument_list|,
operator|(
name|short
operator|)
literal|38
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|0.33333333333333333333333333d
argument_list|,
name|quotient
operator|.
name|doubleValue
argument_list|()
argument_list|,
literal|0.0000000000000000000000001d
argument_list|)
expr_stmt|;
name|Decimal128
name|minusThree
init|=
operator|new
name|Decimal128
argument_list|(
operator|-
literal|3
argument_list|)
decl_stmt|;
name|Decimal128
operator|.
name|divide
argument_list|(
name|minusThree
argument_list|,
name|four
argument_list|,
name|quotient
argument_list|,
operator|(
name|short
operator|)
literal|38
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
operator|-
literal|0.33333333333333333333333333d
argument_list|,
name|quotient
operator|.
name|doubleValue
argument_list|()
argument_list|,
literal|0.0000000000000000000000001d
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testFloatValue
parameter_list|()
block|{
name|Decimal128
name|quotient
init|=
operator|new
name|Decimal128
argument_list|()
decl_stmt|;
name|Decimal128
name|three
init|=
operator|new
name|Decimal128
argument_list|(
literal|3
argument_list|)
decl_stmt|;
name|Decimal128
name|four
init|=
operator|new
name|Decimal128
argument_list|(
literal|9
argument_list|)
decl_stmt|;
name|Decimal128
operator|.
name|divide
argument_list|(
name|three
argument_list|,
name|four
argument_list|,
name|quotient
argument_list|,
operator|(
name|short
operator|)
literal|38
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|0.3333333333333333f
argument_list|,
name|quotient
operator|.
name|floatValue
argument_list|()
argument_list|,
literal|0.00000000001f
argument_list|)
expr_stmt|;
name|Decimal128
name|minusThree
init|=
operator|new
name|Decimal128
argument_list|(
operator|-
literal|3
argument_list|)
decl_stmt|;
name|Decimal128
operator|.
name|divide
argument_list|(
name|minusThree
argument_list|,
name|four
argument_list|,
name|quotient
argument_list|,
operator|(
name|short
operator|)
literal|38
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
operator|-
literal|0.333333333333333f
argument_list|,
name|quotient
operator|.
name|floatValue
argument_list|()
argument_list|,
literal|0.00000000001f
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testSqrtAsDouble
parameter_list|()
block|{
name|Decimal128
name|val1
init|=
operator|new
name|Decimal128
argument_list|(
literal|"1.00435134913958923485982394892384"
argument_list|,
operator|(
name|short
operator|)
literal|36
argument_list|)
decl_stmt|;
name|Decimal128
name|val2
init|=
operator|new
name|Decimal128
argument_list|(
literal|"1.00345982739817298323423423"
argument_list|,
operator|(
name|short
operator|)
literal|36
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
literal|1.00217331292526d
argument_list|,
name|val1
operator|.
name|sqrtAsDouble
argument_list|()
argument_list|,
literal|0.000000000000001d
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|1.00172841998127d
argument_list|,
name|val2
operator|.
name|sqrtAsDouble
argument_list|()
argument_list|,
literal|0.000000000000001d
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testPowAsDouble
parameter_list|()
block|{
name|Decimal128
name|val1
init|=
operator|new
name|Decimal128
argument_list|(
literal|"1.00435134913958923485982394892384"
argument_list|,
operator|(
name|short
operator|)
literal|36
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
literal|1.004366436877081d
argument_list|,
name|val1
operator|.
name|powAsDouble
argument_list|(
literal|1.00345982739817298323423423d
argument_list|)
argument_list|,
literal|0.000000000000001d
argument_list|)
expr_stmt|;
name|Decimal128
name|val2
init|=
operator|new
name|Decimal128
argument_list|(
literal|"1.001"
argument_list|,
operator|(
name|short
operator|)
literal|36
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
literal|1.0100451202102512d
argument_list|,
name|val2
operator|.
name|powAsDouble
argument_list|(
literal|10
argument_list|)
argument_list|,
literal|0.000000000000001d
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testPrecisionOverflow
parameter_list|()
block|{
operator|new
name|Decimal128
argument_list|(
literal|"1.004"
argument_list|,
operator|(
name|short
operator|)
literal|3
argument_list|)
operator|.
name|checkPrecisionOverflow
argument_list|(
literal|4
argument_list|)
expr_stmt|;
try|try
block|{
operator|new
name|Decimal128
argument_list|(
literal|"1.004"
argument_list|,
operator|(
name|short
operator|)
literal|3
argument_list|)
operator|.
name|checkPrecisionOverflow
argument_list|(
literal|3
argument_list|)
expr_stmt|;
name|fail
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|ArithmeticException
name|ex
parameter_list|)
block|{     }
try|try
block|{
operator|new
name|Decimal128
argument_list|(
literal|"1.004"
argument_list|,
operator|(
name|short
operator|)
literal|3
argument_list|)
operator|.
name|checkPrecisionOverflow
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|fail
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|ArithmeticException
name|ex
parameter_list|)
block|{     }
operator|new
name|Decimal128
argument_list|(
literal|"1.004"
argument_list|,
operator|(
name|short
operator|)
literal|3
argument_list|)
operator|.
name|checkPrecisionOverflow
argument_list|(
literal|38
argument_list|)
expr_stmt|;
operator|new
name|Decimal128
argument_list|(
literal|"-3322"
argument_list|,
operator|(
name|short
operator|)
literal|0
argument_list|)
operator|.
name|checkPrecisionOverflow
argument_list|(
literal|4
argument_list|)
expr_stmt|;
try|try
block|{
operator|new
name|Decimal128
argument_list|(
literal|"-3322"
argument_list|,
operator|(
name|short
operator|)
literal|0
argument_list|)
operator|.
name|checkPrecisionOverflow
argument_list|(
literal|3
argument_list|)
expr_stmt|;
name|fail
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|ArithmeticException
name|ex
parameter_list|)
block|{     }
operator|new
name|Decimal128
argument_list|(
literal|"-3322"
argument_list|,
operator|(
name|short
operator|)
literal|1
argument_list|)
operator|.
name|checkPrecisionOverflow
argument_list|(
literal|5
argument_list|)
expr_stmt|;
try|try
block|{
operator|new
name|Decimal128
argument_list|(
literal|"-3322"
argument_list|,
operator|(
name|short
operator|)
literal|1
argument_list|)
operator|.
name|checkPrecisionOverflow
argument_list|(
literal|4
argument_list|)
expr_stmt|;
name|fail
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|ArithmeticException
name|ex
parameter_list|)
block|{     }
comment|// Try the extremes of precision and scale.
comment|// digit  measuring stick:
comment|//                12345678901234567890123456789012345678
operator|new
name|Decimal128
argument_list|(
literal|"0.99999999999999999999999999999999999999"
argument_list|,
operator|(
name|short
operator|)
literal|38
argument_list|)
operator|.
name|checkPrecisionOverflow
argument_list|(
literal|38
argument_list|)
expr_stmt|;
try|try
block|{
operator|new
name|Decimal128
argument_list|(
literal|"0.99999999999999999999999999999999999999"
argument_list|,
operator|(
name|short
operator|)
literal|38
argument_list|)
operator|.
name|checkPrecisionOverflow
argument_list|(
literal|37
argument_list|)
expr_stmt|;
name|fail
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|ArithmeticException
name|ex
parameter_list|)
block|{     }
operator|new
name|Decimal128
argument_list|(
literal|"99999999999999999999999999999999999999"
argument_list|,
operator|(
name|short
operator|)
literal|0
argument_list|)
operator|.
name|checkPrecisionOverflow
argument_list|(
literal|38
argument_list|)
expr_stmt|;
try|try
block|{
operator|new
name|Decimal128
argument_list|(
literal|"99999999999999999999999999999999999999"
argument_list|,
operator|(
name|short
operator|)
literal|0
argument_list|)
operator|.
name|checkPrecisionOverflow
argument_list|(
literal|37
argument_list|)
expr_stmt|;
name|fail
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|ArithmeticException
name|ex
parameter_list|)
block|{     }
block|}
block|}
end_class

end_unit

