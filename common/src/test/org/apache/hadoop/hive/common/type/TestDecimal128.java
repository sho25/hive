begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Copyright (c) Microsoft Corporation  *  * Licensed under the Apache License, Version 2.0 (the "License");  * you may not use this file except in compliance with the License.  * You may obtain a copy of the License at  *  * http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|common
operator|.
name|type
package|;
end_package

begin_import
import|import static
name|org
operator|.
name|junit
operator|.
name|Assert
operator|.
name|*
import|;
end_import

begin_import
import|import
name|java
operator|.
name|math
operator|.
name|BigDecimal
import|;
end_import

begin_import
import|import
name|java
operator|.
name|math
operator|.
name|MathContext
import|;
end_import

begin_import
import|import
name|java
operator|.
name|math
operator|.
name|RoundingMode
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Random
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|After
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|Before
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|Test
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|common
operator|.
name|type
operator|.
name|UnsignedInt128
import|;
end_import

begin_comment
comment|/**  * This code was originally written for Microsoft PolyBase.  */
end_comment

begin_class
specifier|public
class|class
name|TestDecimal128
block|{
specifier|private
name|Decimal128
name|zero
decl_stmt|;
specifier|private
name|Decimal128
name|one
decl_stmt|;
specifier|private
name|Decimal128
name|two
decl_stmt|;
annotation|@
name|Before
specifier|public
name|void
name|setUp
parameter_list|()
throws|throws
name|Exception
block|{
name|zero
operator|=
operator|new
name|Decimal128
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|one
operator|=
operator|new
name|Decimal128
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|two
operator|=
operator|new
name|Decimal128
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
annotation|@
name|After
specifier|public
name|void
name|tearDown
parameter_list|()
throws|throws
name|Exception
block|{   }
annotation|@
name|Test
specifier|public
name|void
name|testCalculateTenThirtySeven
parameter_list|()
block|{
comment|// find 10^37
name|Decimal128
name|ten
init|=
operator|new
name|Decimal128
argument_list|(
literal|10
argument_list|,
operator|(
name|short
operator|)
literal|0
argument_list|)
decl_stmt|;
name|Decimal128
name|val
init|=
operator|new
name|Decimal128
argument_list|(
literal|1
argument_list|,
operator|(
name|short
operator|)
literal|0
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
literal|37
condition|;
operator|++
name|i
control|)
block|{
name|val
operator|.
name|multiplyDestructive
argument_list|(
name|ten
argument_list|,
operator|(
name|short
operator|)
literal|0
argument_list|)
expr_stmt|;
block|}
comment|// verify it
name|String
name|s
init|=
name|val
operator|.
name|toFormalString
argument_list|()
decl_stmt|;
name|assertEquals
argument_list|(
literal|"10000000000000000000000000000000000000"
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|boolean
name|overflow
init|=
literal|false
decl_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testHashCode
parameter_list|()
block|{
name|assertTrue
argument_list|(
name|one
operator|.
name|hashCode
argument_list|()
operator|!=
name|two
operator|.
name|hashCode
argument_list|()
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|zero
operator|.
name|hashCode
argument_list|()
operator|!=
name|one
operator|.
name|hashCode
argument_list|()
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|zero
operator|.
name|hashCode
argument_list|()
operator|!=
name|two
operator|.
name|hashCode
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|zero
operator|.
name|hashCode
argument_list|()
argument_list|,
operator|new
name|Decimal128
argument_list|(
literal|0
argument_list|)
operator|.
name|hashCode
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|one
operator|.
name|hashCode
argument_list|()
argument_list|,
operator|new
name|Decimal128
argument_list|(
literal|1
argument_list|)
operator|.
name|hashCode
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|two
operator|.
name|hashCode
argument_list|()
argument_list|,
operator|new
name|Decimal128
argument_list|(
literal|2
argument_list|)
operator|.
name|hashCode
argument_list|()
argument_list|)
expr_stmt|;
comment|// scaled value might be not equal, but after scaling it should.
name|Decimal128
name|oneScaled
init|=
operator|new
name|Decimal128
argument_list|(
literal|1L
argument_list|,
operator|(
name|short
operator|)
literal|3
argument_list|)
decl_stmt|;
name|oneScaled
operator|.
name|changeScaleDestructive
argument_list|(
operator|(
name|short
operator|)
literal|0
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|one
operator|.
name|hashCode
argument_list|()
argument_list|,
name|oneScaled
operator|.
name|hashCode
argument_list|()
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testEquals
parameter_list|()
block|{
name|assertTrue
argument_list|(
operator|!
name|one
operator|.
name|equals
argument_list|(
name|two
argument_list|)
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
operator|!
name|zero
operator|.
name|equals
argument_list|(
name|one
argument_list|)
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
operator|!
name|zero
operator|.
name|equals
argument_list|(
name|two
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|zero
argument_list|,
operator|new
name|Decimal128
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|one
argument_list|,
operator|new
name|Decimal128
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|two
argument_list|,
operator|new
name|Decimal128
argument_list|(
literal|2
argument_list|)
argument_list|)
expr_stmt|;
comment|// scaled value might be not equal, but after scaling it should.
name|Decimal128
name|oneScaled
init|=
operator|new
name|Decimal128
argument_list|(
literal|1L
argument_list|,
operator|(
name|short
operator|)
literal|3
argument_list|)
decl_stmt|;
name|oneScaled
operator|.
name|changeScaleDestructive
argument_list|(
operator|(
name|short
operator|)
literal|0
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|one
argument_list|,
name|oneScaled
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testCompareTo
parameter_list|()
block|{
name|assertTrue
argument_list|(
name|one
operator|.
name|compareTo
argument_list|(
name|two
argument_list|)
operator|<
literal|0
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|two
operator|.
name|compareTo
argument_list|(
name|one
argument_list|)
operator|>
literal|0
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|one
operator|.
name|compareTo
argument_list|(
name|zero
argument_list|)
operator|>
literal|0
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|zero
operator|.
name|compareTo
argument_list|(
name|two
argument_list|)
operator|<
literal|0
argument_list|)
expr_stmt|;
comment|// compare to must compare with scaling up/down.
name|Decimal128
name|oneScaled
init|=
operator|new
name|Decimal128
argument_list|(
literal|1L
argument_list|,
operator|(
name|short
operator|)
literal|3
argument_list|)
decl_stmt|;
name|assertTrue
argument_list|(
name|one
operator|.
name|compareTo
argument_list|(
name|oneScaled
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
comment|// exact numbers (power of 2) can do the same
name|Decimal128
name|d1
init|=
operator|new
name|Decimal128
argument_list|(
literal|2.0d
argument_list|,
operator|(
name|short
operator|)
literal|6
argument_list|)
decl_stmt|;
name|Decimal128
name|d2
init|=
operator|new
name|Decimal128
argument_list|(
literal|2.0d
argument_list|,
operator|(
name|short
operator|)
literal|3
argument_list|)
decl_stmt|;
name|assertTrue
argument_list|(
name|d1
operator|.
name|compareTo
argument_list|(
name|d2
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
comment|// but, if the value is rounded by more scaling,
comment|// they will be different values.
name|Decimal128
name|d3
init|=
operator|new
name|Decimal128
argument_list|(
literal|2.0d
operator|/
literal|3.0d
argument_list|,
operator|(
name|short
operator|)
literal|5
argument_list|)
decl_stmt|;
name|Decimal128
name|d4
init|=
operator|new
name|Decimal128
argument_list|(
literal|2.0d
operator|/
literal|3.0d
argument_list|,
operator|(
name|short
operator|)
literal|8
argument_list|)
decl_stmt|;
name|assertTrue
argument_list|(
name|d3
operator|.
name|compareTo
argument_list|(
name|d4
argument_list|)
operator|!=
literal|0
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testText
parameter_list|()
block|{
name|assertEquals
argument_list|(
literal|"1"
argument_list|,
name|one
operator|.
name|toFormalString
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|0
argument_list|,
operator|new
name|Decimal128
argument_list|(
literal|"1"
argument_list|,
operator|(
name|short
operator|)
literal|0
argument_list|)
operator|.
name|compareTo
argument_list|(
name|one
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"2"
argument_list|,
name|two
operator|.
name|toFormalString
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|0
argument_list|,
operator|new
name|Decimal128
argument_list|(
literal|"2"
argument_list|,
operator|(
name|short
operator|)
literal|0
argument_list|)
operator|.
name|compareTo
argument_list|(
name|two
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"0"
argument_list|,
name|zero
operator|.
name|toFormalString
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|0
argument_list|,
operator|new
name|Decimal128
argument_list|(
literal|"0"
argument_list|,
operator|(
name|short
operator|)
literal|0
argument_list|)
operator|.
name|compareTo
argument_list|(
name|zero
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"1.000"
argument_list|,
operator|new
name|Decimal128
argument_list|(
literal|1L
argument_list|,
operator|(
name|short
operator|)
literal|3
argument_list|)
operator|.
name|toFormalString
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|0
argument_list|,
operator|new
name|Decimal128
argument_list|(
literal|"1"
argument_list|,
operator|(
name|short
operator|)
literal|3
argument_list|)
operator|.
name|compareTo
argument_list|(
name|one
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"2.000000"
argument_list|,
operator|new
name|Decimal128
argument_list|(
literal|2.0d
argument_list|,
operator|(
name|short
operator|)
literal|6
argument_list|)
operator|.
name|toFormalString
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"2.000"
argument_list|,
operator|new
name|Decimal128
argument_list|(
literal|2.0d
argument_list|,
operator|(
name|short
operator|)
literal|3
argument_list|)
operator|.
name|toFormalString
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|0
argument_list|,
operator|new
name|Decimal128
argument_list|(
literal|"2.0"
argument_list|,
operator|(
name|short
operator|)
literal|6
argument_list|)
operator|.
name|compareTo
argument_list|(
name|two
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|0
argument_list|,
operator|new
name|Decimal128
argument_list|(
literal|"2.0"
argument_list|,
operator|(
name|short
operator|)
literal|3
argument_list|)
operator|.
name|compareTo
argument_list|(
name|two
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"1.3330"
argument_list|,
operator|new
name|Decimal128
argument_list|(
literal|"1.333"
argument_list|,
operator|(
name|short
operator|)
literal|4
argument_list|)
operator|.
name|toFormalString
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"1.333000"
argument_list|,
operator|new
name|Decimal128
argument_list|(
literal|"1.333"
argument_list|,
operator|(
name|short
operator|)
literal|6
argument_list|)
operator|.
name|toFormalString
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"1.333"
argument_list|,
operator|new
name|Decimal128
argument_list|(
literal|"1.333"
argument_list|,
operator|(
name|short
operator|)
literal|3
argument_list|)
operator|.
name|toFormalString
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"1.33"
argument_list|,
operator|new
name|Decimal128
argument_list|(
literal|"1.333"
argument_list|,
operator|(
name|short
operator|)
literal|2
argument_list|)
operator|.
name|toFormalString
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"1.33"
argument_list|,
operator|new
name|Decimal128
argument_list|(
literal|"1.333"
argument_list|,
operator|(
name|short
operator|)
literal|2
argument_list|)
operator|.
name|toFormalString
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"0.13330"
argument_list|,
operator|new
name|Decimal128
argument_list|(
literal|"1333E-4"
argument_list|,
operator|(
name|short
operator|)
literal|5
argument_list|)
operator|.
name|toFormalString
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"0.01333"
argument_list|,
operator|new
name|Decimal128
argument_list|(
literal|"1333E-5"
argument_list|,
operator|(
name|short
operator|)
literal|5
argument_list|)
operator|.
name|toFormalString
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"13330000.00"
argument_list|,
operator|new
name|Decimal128
argument_list|(
literal|"1333E4"
argument_list|,
operator|(
name|short
operator|)
literal|2
argument_list|)
operator|.
name|toFormalString
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"123456789012345678901234.56789"
argument_list|,
operator|new
name|Decimal128
argument_list|(
literal|"123456789012345678901234567.8901234E-3"
argument_list|,
operator|(
name|short
operator|)
literal|5
argument_list|)
operator|.
name|toFormalString
argument_list|()
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testAdd
parameter_list|()
block|{
name|Decimal128
name|result
init|=
operator|new
name|Decimal128
argument_list|()
decl_stmt|;
name|Decimal128
operator|.
name|add
argument_list|(
name|one
argument_list|,
name|two
argument_list|,
name|result
argument_list|,
operator|(
name|short
operator|)
literal|2
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|0
argument_list|,
operator|new
name|Decimal128
argument_list|(
literal|3L
argument_list|,
operator|(
name|short
operator|)
literal|0
argument_list|)
operator|.
name|compareTo
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
name|Decimal128
operator|.
name|add
argument_list|(
name|two
argument_list|,
name|two
argument_list|,
name|result
argument_list|,
operator|(
name|short
operator|)
literal|1
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|0
argument_list|,
operator|new
name|Decimal128
argument_list|(
literal|4L
argument_list|,
operator|(
name|short
operator|)
literal|0
argument_list|)
operator|.
name|compareTo
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
name|long
name|l1
init|=
literal|123456789012345L
decl_stmt|;
name|long
name|l2
init|=
literal|987654321097L
decl_stmt|;
name|long
name|sum
init|=
name|l1
operator|+
name|l2
decl_stmt|;
name|Decimal128
name|left
init|=
operator|new
name|Decimal128
argument_list|(
name|l1
argument_list|,
operator|(
name|short
operator|)
literal|3
argument_list|)
decl_stmt|;
name|Decimal128
name|right
init|=
operator|new
name|Decimal128
argument_list|(
name|l2
argument_list|,
operator|(
name|short
operator|)
literal|5
argument_list|)
decl_stmt|;
name|Decimal128
operator|.
name|add
argument_list|(
name|left
argument_list|,
name|right
argument_list|,
name|result
argument_list|,
operator|(
name|short
operator|)
literal|2
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|0
argument_list|,
operator|new
name|Decimal128
argument_list|(
name|sum
argument_list|,
operator|(
name|short
operator|)
literal|0
argument_list|)
operator|.
name|compareTo
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
name|Decimal128
operator|.
name|add
argument_list|(
name|right
argument_list|,
name|left
argument_list|,
name|result
argument_list|,
operator|(
name|short
operator|)
literal|2
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|0
argument_list|,
operator|new
name|Decimal128
argument_list|(
name|sum
argument_list|,
operator|(
name|short
operator|)
literal|0
argument_list|)
operator|.
name|compareTo
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testSubtract
parameter_list|()
block|{
name|Decimal128
name|result
init|=
operator|new
name|Decimal128
argument_list|()
decl_stmt|;
name|Decimal128
operator|.
name|subtract
argument_list|(
name|one
argument_list|,
name|two
argument_list|,
name|result
argument_list|,
operator|(
name|short
operator|)
literal|2
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|0
argument_list|,
operator|new
name|Decimal128
argument_list|(
operator|-
literal|1L
argument_list|,
operator|(
name|short
operator|)
literal|0
argument_list|)
operator|.
name|compareTo
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
name|Decimal128
operator|.
name|subtract
argument_list|(
name|two
argument_list|,
name|one
argument_list|,
name|result
argument_list|,
operator|(
name|short
operator|)
literal|2
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|0
argument_list|,
operator|new
name|Decimal128
argument_list|(
literal|1L
argument_list|,
operator|(
name|short
operator|)
literal|0
argument_list|)
operator|.
name|compareTo
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
name|Decimal128
operator|.
name|subtract
argument_list|(
name|two
argument_list|,
name|two
argument_list|,
name|result
argument_list|,
operator|(
name|short
operator|)
literal|1
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|0
argument_list|,
name|zero
operator|.
name|compareTo
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|0
argument_list|,
name|result
operator|.
name|getSignum
argument_list|()
argument_list|)
expr_stmt|;
name|long
name|l1
init|=
literal|123456789012345L
decl_stmt|;
name|long
name|l2
init|=
literal|987654321097L
decl_stmt|;
name|long
name|sub
init|=
name|l1
operator|-
name|l2
decl_stmt|;
name|Decimal128
name|left
init|=
operator|new
name|Decimal128
argument_list|(
name|l1
argument_list|,
operator|(
name|short
operator|)
literal|3
argument_list|)
decl_stmt|;
name|Decimal128
name|right
init|=
operator|new
name|Decimal128
argument_list|(
name|l2
argument_list|,
operator|(
name|short
operator|)
literal|5
argument_list|)
decl_stmt|;
name|Decimal128
operator|.
name|subtract
argument_list|(
name|left
argument_list|,
name|right
argument_list|,
name|result
argument_list|,
operator|(
name|short
operator|)
literal|2
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|0
argument_list|,
operator|new
name|Decimal128
argument_list|(
name|sub
argument_list|,
operator|(
name|short
operator|)
literal|0
argument_list|)
operator|.
name|compareTo
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
name|Decimal128
operator|.
name|subtract
argument_list|(
name|right
argument_list|,
name|left
argument_list|,
name|result
argument_list|,
operator|(
name|short
operator|)
literal|2
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|0
argument_list|,
operator|new
name|Decimal128
argument_list|(
operator|-
name|sub
argument_list|,
operator|(
name|short
operator|)
literal|0
argument_list|)
operator|.
name|compareTo
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
name|Decimal128
name|val
init|=
operator|new
name|Decimal128
argument_list|(
literal|"1.123"
argument_list|,
operator|(
name|short
operator|)
literal|3
argument_list|)
decl_stmt|;
name|val
operator|.
name|addDestructive
argument_list|(
operator|new
name|Decimal128
argument_list|(
literal|"4.321"
argument_list|,
operator|(
name|short
operator|)
literal|3
argument_list|)
argument_list|,
operator|(
name|short
operator|)
literal|3
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"5.444"
argument_list|,
name|val
operator|.
name|toFormalString
argument_list|()
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testMultiply
parameter_list|()
block|{
name|Decimal128
name|result
init|=
operator|new
name|Decimal128
argument_list|()
decl_stmt|;
name|Decimal128
operator|.
name|multiply
argument_list|(
name|one
argument_list|,
name|two
argument_list|,
name|result
argument_list|,
operator|(
name|short
operator|)
literal|2
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|0
argument_list|,
name|two
operator|.
name|compareTo
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
name|Decimal128
operator|.
name|multiply
argument_list|(
name|two
argument_list|,
name|two
argument_list|,
name|result
argument_list|,
operator|(
name|short
operator|)
literal|2
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|0
argument_list|,
operator|new
name|Decimal128
argument_list|(
literal|4L
argument_list|,
operator|(
name|short
operator|)
literal|0
argument_list|)
operator|.
name|compareTo
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
name|long
name|l1
init|=
literal|123456789012345L
decl_stmt|;
name|long
name|l2
init|=
literal|987654321097L
decl_stmt|;
name|Decimal128
name|left
init|=
operator|new
name|Decimal128
argument_list|(
name|l1
argument_list|,
operator|(
name|short
operator|)
literal|0
argument_list|)
decl_stmt|;
name|Decimal128
name|right
init|=
operator|new
name|Decimal128
argument_list|(
name|l2
argument_list|,
operator|(
name|short
operator|)
literal|0
argument_list|)
decl_stmt|;
name|UnsignedInt128
name|unscaled
init|=
operator|new
name|UnsignedInt128
argument_list|(
name|l1
argument_list|)
operator|.
name|multiplyConstructive
argument_list|(
operator|new
name|UnsignedInt128
argument_list|(
name|l2
argument_list|)
argument_list|)
decl_stmt|;
name|Decimal128
name|ans
init|=
operator|new
name|Decimal128
argument_list|(
name|unscaled
argument_list|,
operator|(
name|short
operator|)
literal|0
argument_list|,
literal|false
argument_list|)
decl_stmt|;
name|Decimal128
operator|.
name|multiply
argument_list|(
name|left
argument_list|,
name|right
argument_list|,
name|result
argument_list|,
operator|(
name|short
operator|)
literal|0
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|0
argument_list|,
name|ans
operator|.
name|compareTo
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
name|Decimal128
operator|.
name|multiply
argument_list|(
name|right
argument_list|,
name|left
argument_list|,
name|result
argument_list|,
operator|(
name|short
operator|)
literal|0
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|0
argument_list|,
name|ans
operator|.
name|compareTo
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
name|Decimal128
operator|.
name|multiply
argument_list|(
operator|new
name|Decimal128
argument_list|(
literal|1.123d
argument_list|,
operator|(
name|short
operator|)
literal|10
argument_list|)
argument_list|,
operator|new
name|Decimal128
argument_list|(
literal|4.321d
argument_list|,
operator|(
name|short
operator|)
literal|10
argument_list|)
argument_list|,
name|result
argument_list|,
operator|(
name|short
operator|)
literal|10
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|1.123d
operator|*
literal|4.321d
argument_list|,
name|result
operator|.
name|doubleValue
argument_list|()
argument_list|,
literal|0.00001d
argument_list|)
expr_stmt|;
comment|// because only 10 fractional digits, it's not this much accurate
name|assertNotEquals
argument_list|(
literal|1.123d
operator|*
literal|4.321d
argument_list|,
name|result
operator|.
name|doubleValue
argument_list|()
argument_list|,
literal|0.00000000000000001d
argument_list|)
expr_stmt|;
name|Decimal128
operator|.
name|multiply
argument_list|(
operator|new
name|Decimal128
argument_list|(
literal|1.123d
argument_list|,
operator|(
name|short
operator|)
literal|2
argument_list|)
argument_list|,
operator|new
name|Decimal128
argument_list|(
literal|4.321d
argument_list|,
operator|(
name|short
operator|)
literal|2
argument_list|)
argument_list|,
name|result
argument_list|,
operator|(
name|short
operator|)
literal|2
argument_list|)
expr_stmt|;
comment|// this time even more inaccurate
name|assertEquals
argument_list|(
literal|1.123d
operator|*
literal|4.321d
argument_list|,
name|result
operator|.
name|doubleValue
argument_list|()
argument_list|,
literal|1.0d
argument_list|)
expr_stmt|;
name|assertNotEquals
argument_list|(
literal|1.123d
operator|*
literal|4.321d
argument_list|,
name|result
operator|.
name|doubleValue
argument_list|()
argument_list|,
literal|0.000001d
argument_list|)
expr_stmt|;
name|Decimal128
name|val
init|=
operator|new
name|Decimal128
argument_list|(
literal|"1.123"
argument_list|,
operator|(
name|short
operator|)
literal|3
argument_list|)
decl_stmt|;
name|val
operator|.
name|multiplyDestructive
argument_list|(
operator|new
name|Decimal128
argument_list|(
literal|"4.321"
argument_list|,
operator|(
name|short
operator|)
literal|3
argument_list|)
argument_list|,
operator|(
name|short
operator|)
literal|6
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"4.852483"
argument_list|,
name|val
operator|.
name|toFormalString
argument_list|()
argument_list|)
expr_stmt|;
name|Decimal128
name|val1
init|=
operator|new
name|Decimal128
argument_list|(
literal|"1.0001"
argument_list|,
operator|(
name|short
operator|)
literal|4
argument_list|)
decl_stmt|;
name|val1
operator|.
name|multiplyDestructive
argument_list|(
operator|new
name|Decimal128
argument_list|(
literal|"1.0001"
argument_list|,
operator|(
name|short
operator|)
literal|4
argument_list|)
argument_list|,
operator|(
name|short
operator|)
literal|8
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"1.00020001"
argument_list|,
name|val1
operator|.
name|toFormalString
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// Assert that a and b are not the same, within epsilon tolerance.
specifier|private
name|void
name|assertNotEquals
parameter_list|(
name|double
name|a
parameter_list|,
name|double
name|b
parameter_list|,
name|double
name|epsilon
parameter_list|)
block|{
name|assertTrue
argument_list|(
name|Math
operator|.
name|abs
argument_list|(
name|a
operator|-
name|b
argument_list|)
operator|>
name|epsilon
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testDivide
parameter_list|()
block|{
name|Decimal128
name|quotient
init|=
operator|new
name|Decimal128
argument_list|()
decl_stmt|;
name|Decimal128
operator|.
name|divide
argument_list|(
name|two
argument_list|,
name|one
argument_list|,
name|quotient
argument_list|,
operator|(
name|short
operator|)
literal|2
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|0
argument_list|,
name|quotient
operator|.
name|compareTo
argument_list|(
name|two
argument_list|)
argument_list|)
expr_stmt|;
name|Decimal128
operator|.
name|divide
argument_list|(
name|two
argument_list|,
name|two
argument_list|,
name|quotient
argument_list|,
operator|(
name|short
operator|)
literal|2
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|0
argument_list|,
name|quotient
operator|.
name|compareTo
argument_list|(
name|one
argument_list|)
argument_list|)
expr_stmt|;
name|Decimal128
name|three
init|=
operator|new
name|Decimal128
argument_list|(
literal|3
argument_list|)
decl_stmt|;
name|Decimal128
name|four
init|=
operator|new
name|Decimal128
argument_list|(
literal|4
argument_list|)
decl_stmt|;
name|Decimal128
operator|.
name|divide
argument_list|(
name|three
argument_list|,
name|four
argument_list|,
name|quotient
argument_list|,
operator|(
name|short
operator|)
literal|2
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"0.75"
argument_list|,
name|quotient
operator|.
name|toFormalString
argument_list|()
argument_list|)
expr_stmt|;
name|Decimal128
operator|.
name|divide
argument_list|(
name|three
argument_list|,
name|four
argument_list|,
name|quotient
argument_list|,
operator|(
name|short
operator|)
literal|1
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"0.8"
argument_list|,
name|quotient
operator|.
name|toFormalString
argument_list|()
argument_list|)
expr_stmt|;
name|Decimal128
operator|.
name|divide
argument_list|(
name|three
argument_list|,
name|four
argument_list|,
name|quotient
argument_list|,
operator|(
name|short
operator|)
literal|0
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"1"
argument_list|,
name|quotient
operator|.
name|toFormalString
argument_list|()
argument_list|)
expr_stmt|;
name|Decimal128
name|two
init|=
operator|new
name|Decimal128
argument_list|(
literal|2
argument_list|)
decl_stmt|;
name|Decimal128
operator|.
name|divide
argument_list|(
name|two
argument_list|,
name|three
argument_list|,
name|quotient
argument_list|,
operator|(
name|short
operator|)
literal|4
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"0.6667"
argument_list|,
name|quotient
operator|.
name|toFormalString
argument_list|()
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testRandomMultiplyDivideInverse
parameter_list|()
block|{
specifier|final
name|int
name|N
init|=
literal|100000
decl_stmt|;
specifier|final
name|long
name|MASK56
init|=
literal|0x00FFFFFFFFFFFFL
decl_stmt|;
comment|// 56 bit mask to generate positive 56 bit longs
comment|// from random signed longs
name|int
name|seed
init|=
literal|897089790
decl_stmt|;
name|Random
name|rand
init|=
operator|new
name|Random
argument_list|(
name|seed
argument_list|)
decl_stmt|;
name|long
name|l1
decl_stmt|,
name|l2
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<=
name|N
condition|;
name|i
operator|++
control|)
block|{
name|l1
operator|=
name|rand
operator|.
name|nextLong
argument_list|()
operator|&
name|MASK56
expr_stmt|;
name|l2
operator|=
name|rand
operator|.
name|nextLong
argument_list|()
operator|&
name|MASK56
expr_stmt|;
name|verifyMultiplyDivideInverse
argument_list|(
name|l1
argument_list|,
name|l2
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Verify that a * b / b == a    * for decimal division for scale 0 with integer inputs.    *    * Not valid if abs(a * b)>= 10**38.    */
specifier|private
name|void
name|verifyMultiplyDivideInverse
parameter_list|(
name|long
name|a
parameter_list|,
name|long
name|b
parameter_list|)
block|{
specifier|final
name|short
name|scale
init|=
literal|0
decl_stmt|;
comment|// ignore zero-divide cases
if|if
condition|(
name|b
operator|==
literal|0
condition|)
block|{
return|return;
block|}
name|Decimal128
name|decA
init|=
operator|new
name|Decimal128
argument_list|(
name|a
argument_list|,
name|scale
argument_list|)
decl_stmt|;
name|Decimal128
name|decB
init|=
operator|new
name|Decimal128
argument_list|(
name|b
argument_list|,
name|scale
argument_list|)
decl_stmt|;
name|decA
operator|.
name|multiplyDestructive
argument_list|(
name|decB
argument_list|,
name|scale
argument_list|)
expr_stmt|;
name|decA
operator|.
name|checkPrecisionOverflow
argument_list|(
literal|38
argument_list|)
expr_stmt|;
comment|// caller must make sure product of inputs is not too big
name|decA
operator|.
name|divideDestructive
argument_list|(
name|decB
argument_list|,
name|scale
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"Error for a = "
operator|+
name|Long
operator|.
name|toString
argument_list|(
name|a
argument_list|)
operator|+
literal|", b = "
operator|+
name|Long
operator|.
name|toString
argument_list|(
name|b
argument_list|)
argument_list|,
operator|new
name|Decimal128
argument_list|(
name|a
argument_list|,
name|scale
argument_list|)
argument_list|,
name|decA
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testRandomAddSubtractInverse
parameter_list|()
block|{
specifier|final
name|int
name|N
init|=
literal|1000000
decl_stmt|;
name|int
name|seed
init|=
literal|1427480960
decl_stmt|;
name|Random
name|rand
init|=
operator|new
name|Random
argument_list|(
name|seed
argument_list|)
decl_stmt|;
name|long
name|l1
decl_stmt|,
name|l2
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<=
name|N
condition|;
name|i
operator|++
control|)
block|{
name|l1
operator|=
name|rand
operator|.
name|nextLong
argument_list|()
expr_stmt|;
name|l2
operator|=
name|rand
operator|.
name|nextLong
argument_list|()
expr_stmt|;
name|verifyAddSubtractInverse
argument_list|(
name|l1
argument_list|,
name|l2
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Verify that (a + b) - b == a    * for decimal add and subtract for scale 0 with long integer inputs.    */
specifier|private
name|void
name|verifyAddSubtractInverse
parameter_list|(
name|long
name|a
parameter_list|,
name|long
name|b
parameter_list|)
block|{
specifier|final
name|short
name|scale
init|=
literal|0
decl_stmt|;
name|Decimal128
name|decA
init|=
operator|new
name|Decimal128
argument_list|(
name|a
argument_list|,
name|scale
argument_list|)
decl_stmt|;
name|Decimal128
name|decB
init|=
operator|new
name|Decimal128
argument_list|(
name|b
argument_list|,
name|scale
argument_list|)
decl_stmt|;
name|decA
operator|.
name|addDestructive
argument_list|(
name|decB
argument_list|,
name|scale
argument_list|)
expr_stmt|;
name|decA
operator|.
name|subtractDestructive
argument_list|(
name|decB
argument_list|,
name|scale
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"Error for a = "
operator|+
name|Long
operator|.
name|toString
argument_list|(
name|a
argument_list|)
operator|+
literal|", b = "
operator|+
name|Long
operator|.
name|toString
argument_list|(
name|b
argument_list|)
argument_list|,
operator|new
name|Decimal128
argument_list|(
name|a
argument_list|,
name|scale
argument_list|)
argument_list|,
name|decA
argument_list|)
expr_stmt|;
block|}
comment|/**    * During earlier code testing, if we found errors, test them here as regression tests.    */
annotation|@
name|Test
specifier|public
name|void
name|testKnownPriorErrors
parameter_list|()
block|{
comment|// Regression test for defect reported in HIVE-6243
name|long
name|a
init|=
literal|213474114411690L
decl_stmt|;
name|long
name|b
init|=
literal|5062120663L
decl_stmt|;
name|verifyMultiplyDivideInverse
argument_list|(
name|a
argument_list|,
name|b
argument_list|)
expr_stmt|;
comment|// Regression test for defect reported in HIVE-6399
name|String
name|a2
init|=
literal|"-605044214913338382"
decl_stmt|;
comment|// 18 digits
name|String
name|b2
init|=
literal|"55269579109718297360"
decl_stmt|;
comment|// 20 digits
comment|// -33440539101030154945490585226577271520 is expected result
name|verifyHighPrecisionMultiplySingle
argument_list|(
name|a2
argument_list|,
name|b2
argument_list|)
expr_stmt|;
block|}
comment|// Test a set of random adds at high precision.
annotation|@
name|Test
specifier|public
name|void
name|testHighPrecisionDecimal128Add
parameter_list|()
block|{
specifier|final
name|int
name|N
init|=
literal|10000
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|N
condition|;
name|i
operator|++
control|)
block|{
name|verifyHighPrecisionAddSingle
argument_list|()
expr_stmt|;
block|}
block|}
comment|// Test one random hi-precision decimal add.
specifier|private
name|void
name|verifyHighPrecisionAddSingle
parameter_list|()
block|{
name|Decimal128
name|a
decl_stmt|,
name|b
decl_stmt|,
name|r
decl_stmt|;
name|String
name|sA
decl_stmt|,
name|sB
decl_stmt|;
name|a
operator|=
operator|new
name|Decimal128
argument_list|()
expr_stmt|;
name|sA
operator|=
name|makeNumericString
argument_list|(
literal|37
argument_list|)
expr_stmt|;
name|a
operator|.
name|update
argument_list|(
name|sA
argument_list|,
operator|(
name|short
operator|)
literal|0
argument_list|)
expr_stmt|;
name|b
operator|=
operator|new
name|Decimal128
argument_list|()
expr_stmt|;
name|sB
operator|=
name|makeNumericString
argument_list|(
literal|37
argument_list|)
expr_stmt|;
name|b
operator|.
name|update
argument_list|(
name|sB
argument_list|,
operator|(
name|short
operator|)
literal|0
argument_list|)
expr_stmt|;
name|r
operator|=
operator|new
name|Decimal128
argument_list|()
expr_stmt|;
name|r
operator|.
name|addDestructive
argument_list|(
name|a
argument_list|,
operator|(
name|short
operator|)
literal|0
argument_list|)
expr_stmt|;
name|r
operator|.
name|addDestructive
argument_list|(
name|b
argument_list|,
operator|(
name|short
operator|)
literal|0
argument_list|)
expr_stmt|;
name|String
name|res1
init|=
name|r
operator|.
name|toFormalString
argument_list|()
decl_stmt|;
comment|// Now do the add with Java BigDecimal
name|BigDecimal
name|bdA
init|=
operator|new
name|BigDecimal
argument_list|(
name|sA
argument_list|)
decl_stmt|;
name|BigDecimal
name|bdB
init|=
operator|new
name|BigDecimal
argument_list|(
name|sB
argument_list|)
decl_stmt|;
name|BigDecimal
name|bdR
init|=
name|bdA
operator|.
name|add
argument_list|(
name|bdB
argument_list|)
decl_stmt|;
name|String
name|res2
init|=
name|bdR
operator|.
name|toPlainString
argument_list|()
decl_stmt|;
comment|// Compare the results
name|String
name|message
init|=
literal|"For operation "
operator|+
name|a
operator|.
name|toFormalString
argument_list|()
operator|+
literal|" + "
operator|+
name|b
operator|.
name|toFormalString
argument_list|()
decl_stmt|;
name|assertEquals
argument_list|(
name|message
argument_list|,
name|res2
argument_list|,
name|res1
argument_list|)
expr_stmt|;
block|}
comment|// Test a set of random subtracts at high precision.
annotation|@
name|Test
specifier|public
name|void
name|testHighPrecisionDecimal128Subtract
parameter_list|()
block|{
specifier|final
name|int
name|N
init|=
literal|10000
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|N
condition|;
name|i
operator|++
control|)
block|{
name|verifyHighPrecisionSubtractSingle
argument_list|()
expr_stmt|;
block|}
block|}
comment|// Test one random high-precision subtract.
specifier|private
name|void
name|verifyHighPrecisionSubtractSingle
parameter_list|()
block|{
name|Decimal128
name|a
decl_stmt|,
name|b
decl_stmt|,
name|r
decl_stmt|;
name|String
name|sA
decl_stmt|,
name|sB
decl_stmt|;
name|a
operator|=
operator|new
name|Decimal128
argument_list|()
expr_stmt|;
name|sA
operator|=
name|makeNumericString
argument_list|(
literal|37
argument_list|)
expr_stmt|;
name|a
operator|.
name|update
argument_list|(
name|sA
argument_list|,
operator|(
name|short
operator|)
literal|0
argument_list|)
expr_stmt|;
name|b
operator|=
operator|new
name|Decimal128
argument_list|()
expr_stmt|;
name|sB
operator|=
name|makeNumericString
argument_list|(
literal|37
argument_list|)
expr_stmt|;
name|b
operator|.
name|update
argument_list|(
name|sB
argument_list|,
operator|(
name|short
operator|)
literal|0
argument_list|)
expr_stmt|;
name|r
operator|=
operator|new
name|Decimal128
argument_list|()
expr_stmt|;
name|r
operator|.
name|addDestructive
argument_list|(
name|a
argument_list|,
operator|(
name|short
operator|)
literal|0
argument_list|)
expr_stmt|;
name|r
operator|.
name|subtractDestructive
argument_list|(
name|b
argument_list|,
operator|(
name|short
operator|)
literal|0
argument_list|)
expr_stmt|;
name|String
name|res1
init|=
name|r
operator|.
name|toFormalString
argument_list|()
decl_stmt|;
comment|// Now do the add with Java BigDecimal
name|BigDecimal
name|bdA
init|=
operator|new
name|BigDecimal
argument_list|(
name|sA
argument_list|)
decl_stmt|;
name|BigDecimal
name|bdB
init|=
operator|new
name|BigDecimal
argument_list|(
name|sB
argument_list|)
decl_stmt|;
name|BigDecimal
name|bdR
init|=
name|bdA
operator|.
name|subtract
argument_list|(
name|bdB
argument_list|)
decl_stmt|;
name|String
name|res2
init|=
name|bdR
operator|.
name|toPlainString
argument_list|()
decl_stmt|;
comment|// Compare the results
name|String
name|message
init|=
literal|"For operation "
operator|+
name|a
operator|.
name|toFormalString
argument_list|()
operator|+
literal|" - "
operator|+
name|b
operator|.
name|toFormalString
argument_list|()
decl_stmt|;
name|assertEquals
argument_list|(
name|message
argument_list|,
name|res2
argument_list|,
name|res1
argument_list|)
expr_stmt|;
block|}
comment|// Test a set of random multiplications at high precision.
annotation|@
name|Test
specifier|public
name|void
name|testHighPrecisionDecimal128Multiply
parameter_list|()
block|{
specifier|final
name|int
name|N
init|=
literal|10000
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|N
condition|;
name|i
operator|++
control|)
block|{
name|verifyHighPrecisionMultiplySingle
argument_list|()
expr_stmt|;
block|}
block|}
comment|// Test a single, high-precision multiply of random inputs.
specifier|private
name|void
name|verifyHighPrecisionMultiplySingle
parameter_list|()
block|{
name|Decimal128
name|a
decl_stmt|,
name|b
decl_stmt|,
name|r
decl_stmt|;
name|String
name|sA
decl_stmt|,
name|sB
decl_stmt|;
name|Random
name|rand
init|=
operator|new
name|Random
argument_list|()
decl_stmt|;
name|int
name|aDigits
init|=
name|rand
operator|.
name|nextInt
argument_list|(
literal|37
argument_list|)
operator|+
literal|1
decl_stmt|;
comment|// number of digits in a (1..37)
name|int
name|bDigits
init|=
literal|38
operator|-
name|aDigits
decl_stmt|;
comment|// number of digits in b (1..37)
name|assertTrue
argument_list|(
name|aDigits
operator|+
name|bDigits
operator|==
literal|38
operator|&&
name|aDigits
operator|>
literal|0
operator|&&
name|bDigits
operator|>
literal|0
argument_list|)
expr_stmt|;
name|a
operator|=
operator|new
name|Decimal128
argument_list|()
expr_stmt|;
name|sA
operator|=
name|makeNumericString
argument_list|(
name|aDigits
argument_list|)
expr_stmt|;
name|a
operator|.
name|update
argument_list|(
name|sA
argument_list|,
operator|(
name|short
operator|)
literal|0
argument_list|)
expr_stmt|;
name|b
operator|=
operator|new
name|Decimal128
argument_list|()
expr_stmt|;
name|sB
operator|=
name|makeNumericString
argument_list|(
name|bDigits
argument_list|)
expr_stmt|;
name|b
operator|.
name|update
argument_list|(
name|sB
argument_list|,
operator|(
name|short
operator|)
literal|0
argument_list|)
expr_stmt|;
name|r
operator|=
operator|new
name|Decimal128
argument_list|()
expr_stmt|;
name|r
operator|.
name|addDestructive
argument_list|(
name|a
argument_list|,
operator|(
name|short
operator|)
literal|0
argument_list|)
expr_stmt|;
name|r
operator|.
name|multiplyDestructive
argument_list|(
name|b
argument_list|,
operator|(
name|short
operator|)
literal|0
argument_list|)
expr_stmt|;
name|String
name|res1
init|=
name|r
operator|.
name|toFormalString
argument_list|()
decl_stmt|;
comment|// Now do the operation with Java BigDecimal
name|BigDecimal
name|bdA
init|=
operator|new
name|BigDecimal
argument_list|(
name|sA
argument_list|)
decl_stmt|;
name|BigDecimal
name|bdB
init|=
operator|new
name|BigDecimal
argument_list|(
name|sB
argument_list|)
decl_stmt|;
name|BigDecimal
name|bdR
init|=
name|bdA
operator|.
name|multiply
argument_list|(
name|bdB
argument_list|)
decl_stmt|;
name|String
name|res2
init|=
name|bdR
operator|.
name|toPlainString
argument_list|()
decl_stmt|;
comment|// Compare the results
name|String
name|message
init|=
literal|"For operation "
operator|+
name|a
operator|.
name|toFormalString
argument_list|()
operator|+
literal|" * "
operator|+
name|b
operator|.
name|toFormalString
argument_list|()
decl_stmt|;
name|assertEquals
argument_list|(
name|message
argument_list|,
name|res2
argument_list|,
name|res1
argument_list|)
expr_stmt|;
block|}
comment|// Test a single, high-precision multiply of random inputs.
comment|// Arguments must be integers with optional - sign, represented as strings.
comment|// Arguments must have 1 to 37 digits and the number of total digits
comment|// must be<= 38.
specifier|private
name|void
name|verifyHighPrecisionMultiplySingle
parameter_list|(
name|String
name|argA
parameter_list|,
name|String
name|argB
parameter_list|)
block|{
name|Decimal128
name|a
decl_stmt|,
name|b
decl_stmt|,
name|r
decl_stmt|;
name|String
name|sA
decl_stmt|,
name|sB
decl_stmt|;
comment|// verify number of digits is<= 38 and each number has 1 or more digits
name|int
name|aDigits
init|=
name|argA
operator|.
name|length
argument_list|()
decl_stmt|;
name|aDigits
operator|-=
name|argA
operator|.
name|charAt
argument_list|(
literal|0
argument_list|)
operator|==
literal|'-'
condition|?
literal|1
else|:
literal|0
expr_stmt|;
name|int
name|bDigits
init|=
name|argB
operator|.
name|length
argument_list|()
decl_stmt|;
name|bDigits
operator|-=
name|argB
operator|.
name|charAt
argument_list|(
literal|0
argument_list|)
operator|==
literal|'-'
condition|?
literal|1
else|:
literal|0
expr_stmt|;
name|assertTrue
argument_list|(
name|aDigits
operator|+
name|bDigits
operator|<=
literal|38
operator|&&
name|aDigits
operator|>
literal|0
operator|&&
name|bDigits
operator|>
literal|0
argument_list|)
expr_stmt|;
name|a
operator|=
operator|new
name|Decimal128
argument_list|()
expr_stmt|;
name|sA
operator|=
name|argA
expr_stmt|;
name|a
operator|.
name|update
argument_list|(
name|sA
argument_list|,
operator|(
name|short
operator|)
literal|0
argument_list|)
expr_stmt|;
name|b
operator|=
operator|new
name|Decimal128
argument_list|()
expr_stmt|;
name|sB
operator|=
name|argB
expr_stmt|;
name|b
operator|.
name|update
argument_list|(
name|sB
argument_list|,
operator|(
name|short
operator|)
literal|0
argument_list|)
expr_stmt|;
name|r
operator|=
operator|new
name|Decimal128
argument_list|()
expr_stmt|;
name|r
operator|.
name|addDestructive
argument_list|(
name|a
argument_list|,
operator|(
name|short
operator|)
literal|0
argument_list|)
expr_stmt|;
name|r
operator|.
name|multiplyDestructive
argument_list|(
name|b
argument_list|,
operator|(
name|short
operator|)
literal|0
argument_list|)
expr_stmt|;
name|String
name|res1
init|=
name|r
operator|.
name|toFormalString
argument_list|()
decl_stmt|;
comment|// Now do the operation with Java BigDecimal
name|BigDecimal
name|bdA
init|=
operator|new
name|BigDecimal
argument_list|(
name|sA
argument_list|)
decl_stmt|;
name|BigDecimal
name|bdB
init|=
operator|new
name|BigDecimal
argument_list|(
name|sB
argument_list|)
decl_stmt|;
name|BigDecimal
name|bdR
init|=
name|bdA
operator|.
name|multiply
argument_list|(
name|bdB
argument_list|)
decl_stmt|;
name|String
name|res2
init|=
name|bdR
operator|.
name|toPlainString
argument_list|()
decl_stmt|;
comment|// Compare the results
name|String
name|message
init|=
literal|"For operation "
operator|+
name|a
operator|.
name|toFormalString
argument_list|()
operator|+
literal|" * "
operator|+
name|b
operator|.
name|toFormalString
argument_list|()
decl_stmt|;
name|assertEquals
argument_list|(
name|message
argument_list|,
name|res2
argument_list|,
name|res1
argument_list|)
expr_stmt|;
block|}
comment|// Test a set of random divisions at high precision.
annotation|@
name|Test
specifier|public
name|void
name|testHighPrecisionDecimal128Divide
parameter_list|()
block|{
specifier|final
name|int
name|N
init|=
literal|10000
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|N
condition|;
name|i
operator|++
control|)
block|{
name|verifyHighPrecisionDivideSingle
argument_list|()
expr_stmt|;
block|}
block|}
comment|// Test a single, high-precision divide of random inputs.
specifier|private
name|void
name|verifyHighPrecisionDivideSingle
parameter_list|()
block|{
name|Decimal128
name|a
decl_stmt|,
name|b
decl_stmt|,
name|r
decl_stmt|;
name|String
name|sA
decl_stmt|,
name|sB
decl_stmt|;
name|Random
name|rand
init|=
operator|new
name|Random
argument_list|()
decl_stmt|;
name|int
name|aDigits
init|=
name|rand
operator|.
name|nextInt
argument_list|(
literal|37
argument_list|)
operator|+
literal|1
decl_stmt|;
comment|// number of digits in a (1..37)
name|int
name|bDigits
init|=
literal|38
operator|-
name|aDigits
decl_stmt|;
comment|// number of digits in b (1..37)
name|int
name|temp
decl_stmt|;
comment|// make sure b will have less digits than A
if|if
condition|(
name|bDigits
operator|>
name|aDigits
condition|)
block|{
name|temp
operator|=
name|aDigits
expr_stmt|;
name|aDigits
operator|=
name|bDigits
expr_stmt|;
name|bDigits
operator|=
name|temp
expr_stmt|;
block|}
if|if
condition|(
name|bDigits
operator|==
name|aDigits
condition|)
block|{
return|return;
block|}
name|assertTrue
argument_list|(
name|aDigits
operator|+
name|bDigits
operator|==
literal|38
operator|&&
name|aDigits
operator|>
literal|0
operator|&&
name|bDigits
operator|>
literal|0
argument_list|)
expr_stmt|;
name|a
operator|=
operator|new
name|Decimal128
argument_list|()
expr_stmt|;
name|sA
operator|=
name|makeNumericString
argument_list|(
name|aDigits
argument_list|)
expr_stmt|;
name|a
operator|.
name|update
argument_list|(
name|sA
argument_list|,
operator|(
name|short
operator|)
literal|0
argument_list|)
expr_stmt|;
name|b
operator|=
operator|new
name|Decimal128
argument_list|()
expr_stmt|;
name|sB
operator|=
name|makeNumericString
argument_list|(
name|bDigits
argument_list|)
expr_stmt|;
name|b
operator|.
name|update
argument_list|(
name|sB
argument_list|,
operator|(
name|short
operator|)
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|b
operator|.
name|isZero
argument_list|()
condition|)
block|{
comment|// don't do zero-divide if one comes up at random
return|return;
block|}
name|r
operator|=
operator|new
name|Decimal128
argument_list|()
expr_stmt|;
name|r
operator|.
name|addDestructive
argument_list|(
name|a
argument_list|,
operator|(
name|short
operator|)
literal|0
argument_list|)
expr_stmt|;
name|r
operator|.
name|divideDestructive
argument_list|(
name|b
argument_list|,
operator|(
name|short
operator|)
literal|0
argument_list|)
expr_stmt|;
name|String
name|res1
init|=
name|r
operator|.
name|toFormalString
argument_list|()
decl_stmt|;
comment|// Now do the operation with Java BigDecimal
name|BigDecimal
name|bdA
init|=
operator|new
name|BigDecimal
argument_list|(
name|sA
argument_list|)
decl_stmt|;
name|BigDecimal
name|bdB
init|=
operator|new
name|BigDecimal
argument_list|(
name|sB
argument_list|)
decl_stmt|;
name|BigDecimal
name|bdR
init|=
name|bdA
operator|.
name|divide
argument_list|(
name|bdB
argument_list|,
literal|0
argument_list|,
name|RoundingMode
operator|.
name|HALF_UP
argument_list|)
decl_stmt|;
name|String
name|res2
init|=
name|bdR
operator|.
name|toPlainString
argument_list|()
decl_stmt|;
comment|// Compare the results
name|String
name|message
init|=
literal|"For operation "
operator|+
name|a
operator|.
name|toFormalString
argument_list|()
operator|+
literal|" / "
operator|+
name|b
operator|.
name|toFormalString
argument_list|()
decl_stmt|;
name|assertEquals
argument_list|(
name|message
argument_list|,
name|res2
argument_list|,
name|res1
argument_list|)
expr_stmt|;
block|}
comment|/* Return a random number with length digits, as a string. Results may be    * negative or positive.    */
specifier|private
name|String
name|makeNumericString
parameter_list|(
name|int
name|length
parameter_list|)
block|{
name|Random
name|r
init|=
operator|new
name|Random
argument_list|()
decl_stmt|;
name|StringBuilder
name|b
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|length
condition|;
name|i
operator|++
control|)
block|{
name|b
operator|.
name|append
argument_list|(
name|r
operator|.
name|nextInt
argument_list|(
literal|10
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// choose a random sign
name|String
name|sign
init|=
name|r
operator|.
name|nextInt
argument_list|(
literal|2
argument_list|)
operator|==
literal|0
condition|?
literal|"-"
else|:
literal|""
decl_stmt|;
return|return
name|sign
operator|+
name|b
operator|.
name|toString
argument_list|()
return|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testPiNewton
parameter_list|()
block|{
comment|// see http://en.wikipedia.org/wiki/Approximations_of_%CF%80
comment|// Below is the simple Newton's equation
specifier|final
name|int
name|LOOPS
init|=
literal|100
decl_stmt|;
specifier|final
name|short
name|SCALE
init|=
literal|33
decl_stmt|;
name|Decimal128
name|current
init|=
operator|new
name|Decimal128
argument_list|(
literal|1
argument_list|,
name|SCALE
argument_list|)
decl_stmt|;
name|Decimal128
name|multiplier
init|=
operator|new
name|Decimal128
argument_list|()
decl_stmt|;
name|Decimal128
name|dividor
init|=
operator|new
name|Decimal128
argument_list|()
decl_stmt|;
name|Decimal128
name|one
init|=
operator|new
name|Decimal128
argument_list|(
literal|1
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
name|LOOPS
init|;
name|i
operator|>
literal|0
condition|;
operator|--
name|i
control|)
block|{
name|multiplier
operator|.
name|update
argument_list|(
name|i
argument_list|,
name|SCALE
argument_list|)
expr_stmt|;
name|current
operator|.
name|multiplyDestructive
argument_list|(
name|multiplier
argument_list|,
name|SCALE
argument_list|)
expr_stmt|;
name|dividor
operator|.
name|update
argument_list|(
literal|1
operator|+
literal|2
operator|*
name|i
argument_list|,
name|SCALE
argument_list|)
expr_stmt|;
name|current
operator|.
name|divideDestructive
argument_list|(
name|dividor
argument_list|,
name|SCALE
argument_list|)
expr_stmt|;
name|current
operator|.
name|addDestructive
argument_list|(
name|one
argument_list|,
name|SCALE
argument_list|)
expr_stmt|;
block|}
name|current
operator|.
name|multiplyDestructive
argument_list|(
operator|new
name|Decimal128
argument_list|(
literal|2
argument_list|)
argument_list|,
name|SCALE
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|current
operator|.
name|toFormalString
argument_list|()
operator|.
name|startsWith
argument_list|(
literal|"3.141592653589793238"
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testPiArcsine
parameter_list|()
block|{
comment|// This one uses the arcsin method. Involves more multiplications/divisions.
comment|// pi=Sum (3 * 2n!/(16^n * (2n+1) * n! * n!))
comment|// =Sum (3 * ((n+1)(n+2)...2n)/n!*16^n/(2n+1))
comment|// =Sum (3 / (2n+1) * (n+1)/16 * (n+2)/32... * 2n/16(n+1))
comment|// (note that it is split so that each term is not overflown)
specifier|final
name|int
name|LOOPS
init|=
literal|50
decl_stmt|;
specifier|final
name|short
name|SCALE
init|=
literal|30
decl_stmt|;
name|Decimal128
name|total
init|=
operator|new
name|Decimal128
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|Decimal128
name|multiplier
init|=
operator|new
name|Decimal128
argument_list|()
decl_stmt|;
name|Decimal128
name|dividor
init|=
operator|new
name|Decimal128
argument_list|()
decl_stmt|;
name|Decimal128
name|current
init|=
operator|new
name|Decimal128
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|LOOPS
condition|;
operator|++
name|i
control|)
block|{
name|current
operator|.
name|update
argument_list|(
literal|3
argument_list|,
name|SCALE
argument_list|)
expr_stmt|;
name|dividor
operator|.
name|update
argument_list|(
literal|2
operator|*
name|i
operator|+
literal|1
argument_list|,
name|SCALE
argument_list|)
expr_stmt|;
name|current
operator|.
name|divideDestructive
argument_list|(
name|dividor
argument_list|,
name|SCALE
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|1
init|;
name|j
operator|<=
name|i
condition|;
operator|++
name|j
control|)
block|{
name|multiplier
operator|.
name|update
argument_list|(
name|i
operator|+
name|j
argument_list|,
name|SCALE
argument_list|)
expr_stmt|;
name|dividor
operator|.
name|update
argument_list|(
literal|16
operator|*
name|j
argument_list|,
name|SCALE
argument_list|)
expr_stmt|;
name|current
operator|.
name|multiplyDestructive
argument_list|(
name|multiplier
argument_list|,
name|SCALE
argument_list|)
expr_stmt|;
name|current
operator|.
name|divideDestructive
argument_list|(
name|dividor
argument_list|,
name|SCALE
argument_list|)
expr_stmt|;
block|}
name|total
operator|.
name|addDestructive
argument_list|(
name|current
argument_list|,
name|SCALE
argument_list|)
expr_stmt|;
block|}
name|assertTrue
argument_list|(
name|total
operator|.
name|toFormalString
argument_list|()
operator|.
name|startsWith
argument_list|(
literal|"3.141592653589793238462"
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testDoubleValue
parameter_list|()
block|{
name|Decimal128
name|quotient
init|=
operator|new
name|Decimal128
argument_list|()
decl_stmt|;
name|Decimal128
name|three
init|=
operator|new
name|Decimal128
argument_list|(
literal|3
argument_list|)
decl_stmt|;
name|Decimal128
name|four
init|=
operator|new
name|Decimal128
argument_list|(
literal|9
argument_list|)
decl_stmt|;
name|Decimal128
operator|.
name|divide
argument_list|(
name|three
argument_list|,
name|four
argument_list|,
name|quotient
argument_list|,
operator|(
name|short
operator|)
literal|38
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|0.33333333333333333333333333d
argument_list|,
name|quotient
operator|.
name|doubleValue
argument_list|()
argument_list|,
literal|0.0000000000000000000000001d
argument_list|)
expr_stmt|;
name|Decimal128
name|minusThree
init|=
operator|new
name|Decimal128
argument_list|(
operator|-
literal|3
argument_list|)
decl_stmt|;
name|Decimal128
operator|.
name|divide
argument_list|(
name|minusThree
argument_list|,
name|four
argument_list|,
name|quotient
argument_list|,
operator|(
name|short
operator|)
literal|38
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
operator|-
literal|0.33333333333333333333333333d
argument_list|,
name|quotient
operator|.
name|doubleValue
argument_list|()
argument_list|,
literal|0.0000000000000000000000001d
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testFloatValue
parameter_list|()
block|{
name|Decimal128
name|quotient
init|=
operator|new
name|Decimal128
argument_list|()
decl_stmt|;
name|Decimal128
name|three
init|=
operator|new
name|Decimal128
argument_list|(
literal|3
argument_list|)
decl_stmt|;
name|Decimal128
name|four
init|=
operator|new
name|Decimal128
argument_list|(
literal|9
argument_list|)
decl_stmt|;
name|Decimal128
operator|.
name|divide
argument_list|(
name|three
argument_list|,
name|four
argument_list|,
name|quotient
argument_list|,
operator|(
name|short
operator|)
literal|38
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|0.3333333333333333f
argument_list|,
name|quotient
operator|.
name|floatValue
argument_list|()
argument_list|,
literal|0.00000000001f
argument_list|)
expr_stmt|;
name|Decimal128
name|minusThree
init|=
operator|new
name|Decimal128
argument_list|(
operator|-
literal|3
argument_list|)
decl_stmt|;
name|Decimal128
operator|.
name|divide
argument_list|(
name|minusThree
argument_list|,
name|four
argument_list|,
name|quotient
argument_list|,
operator|(
name|short
operator|)
literal|38
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
operator|-
literal|0.333333333333333f
argument_list|,
name|quotient
operator|.
name|floatValue
argument_list|()
argument_list|,
literal|0.00000000001f
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testSqrtAsDouble
parameter_list|()
block|{
name|Decimal128
name|val1
init|=
operator|new
name|Decimal128
argument_list|(
literal|"1.00435134913958923485982394892384"
argument_list|,
operator|(
name|short
operator|)
literal|36
argument_list|)
decl_stmt|;
name|Decimal128
name|val2
init|=
operator|new
name|Decimal128
argument_list|(
literal|"1.00345982739817298323423423"
argument_list|,
operator|(
name|short
operator|)
literal|36
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
literal|1.00217331292526d
argument_list|,
name|val1
operator|.
name|sqrtAsDouble
argument_list|()
argument_list|,
literal|0.000000000000001d
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|1.00172841998127d
argument_list|,
name|val2
operator|.
name|sqrtAsDouble
argument_list|()
argument_list|,
literal|0.000000000000001d
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testPowAsDouble
parameter_list|()
block|{
name|Decimal128
name|val1
init|=
operator|new
name|Decimal128
argument_list|(
literal|"1.00435134913958923485982394892384"
argument_list|,
operator|(
name|short
operator|)
literal|36
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
literal|1.004366436877081d
argument_list|,
name|val1
operator|.
name|powAsDouble
argument_list|(
literal|1.00345982739817298323423423d
argument_list|)
argument_list|,
literal|0.000000000000001d
argument_list|)
expr_stmt|;
name|Decimal128
name|val2
init|=
operator|new
name|Decimal128
argument_list|(
literal|"1.001"
argument_list|,
operator|(
name|short
operator|)
literal|36
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
literal|1.0100451202102512d
argument_list|,
name|val2
operator|.
name|powAsDouble
argument_list|(
literal|10
argument_list|)
argument_list|,
literal|0.000000000000001d
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testPrecisionOverflow
parameter_list|()
block|{
operator|new
name|Decimal128
argument_list|(
literal|"1.004"
argument_list|,
operator|(
name|short
operator|)
literal|3
argument_list|)
operator|.
name|checkPrecisionOverflow
argument_list|(
literal|4
argument_list|)
expr_stmt|;
try|try
block|{
operator|new
name|Decimal128
argument_list|(
literal|"1.004"
argument_list|,
operator|(
name|short
operator|)
literal|3
argument_list|)
operator|.
name|checkPrecisionOverflow
argument_list|(
literal|3
argument_list|)
expr_stmt|;
name|fail
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|ArithmeticException
name|ex
parameter_list|)
block|{     }
try|try
block|{
operator|new
name|Decimal128
argument_list|(
literal|"1.004"
argument_list|,
operator|(
name|short
operator|)
literal|3
argument_list|)
operator|.
name|checkPrecisionOverflow
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|fail
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|ArithmeticException
name|ex
parameter_list|)
block|{     }
operator|new
name|Decimal128
argument_list|(
literal|"1.004"
argument_list|,
operator|(
name|short
operator|)
literal|3
argument_list|)
operator|.
name|checkPrecisionOverflow
argument_list|(
literal|38
argument_list|)
expr_stmt|;
operator|new
name|Decimal128
argument_list|(
literal|"-3322"
argument_list|,
operator|(
name|short
operator|)
literal|0
argument_list|)
operator|.
name|checkPrecisionOverflow
argument_list|(
literal|4
argument_list|)
expr_stmt|;
try|try
block|{
operator|new
name|Decimal128
argument_list|(
literal|"-3322"
argument_list|,
operator|(
name|short
operator|)
literal|0
argument_list|)
operator|.
name|checkPrecisionOverflow
argument_list|(
literal|3
argument_list|)
expr_stmt|;
name|fail
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|ArithmeticException
name|ex
parameter_list|)
block|{     }
operator|new
name|Decimal128
argument_list|(
literal|"-3322"
argument_list|,
operator|(
name|short
operator|)
literal|1
argument_list|)
operator|.
name|checkPrecisionOverflow
argument_list|(
literal|5
argument_list|)
expr_stmt|;
try|try
block|{
operator|new
name|Decimal128
argument_list|(
literal|"-3322"
argument_list|,
operator|(
name|short
operator|)
literal|1
argument_list|)
operator|.
name|checkPrecisionOverflow
argument_list|(
literal|4
argument_list|)
expr_stmt|;
name|fail
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|ArithmeticException
name|ex
parameter_list|)
block|{     }
comment|// Try the extremes of precision and scale.
comment|// digit  measuring stick:
comment|//                12345678901234567890123456789012345678
operator|new
name|Decimal128
argument_list|(
literal|"0.99999999999999999999999999999999999999"
argument_list|,
operator|(
name|short
operator|)
literal|38
argument_list|)
operator|.
name|checkPrecisionOverflow
argument_list|(
literal|38
argument_list|)
expr_stmt|;
try|try
block|{
operator|new
name|Decimal128
argument_list|(
literal|"0.99999999999999999999999999999999999999"
argument_list|,
operator|(
name|short
operator|)
literal|38
argument_list|)
operator|.
name|checkPrecisionOverflow
argument_list|(
literal|37
argument_list|)
expr_stmt|;
name|fail
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|ArithmeticException
name|ex
parameter_list|)
block|{     }
operator|new
name|Decimal128
argument_list|(
literal|"99999999999999999999999999999999999999"
argument_list|,
operator|(
name|short
operator|)
literal|0
argument_list|)
operator|.
name|checkPrecisionOverflow
argument_list|(
literal|38
argument_list|)
expr_stmt|;
try|try
block|{
operator|new
name|Decimal128
argument_list|(
literal|"99999999999999999999999999999999999999"
argument_list|,
operator|(
name|short
operator|)
literal|0
argument_list|)
operator|.
name|checkPrecisionOverflow
argument_list|(
literal|37
argument_list|)
expr_stmt|;
name|fail
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|ArithmeticException
name|ex
parameter_list|)
block|{     }
block|}
annotation|@
name|Test
specifier|public
name|void
name|testToLong
parameter_list|()
block|{
name|Decimal128
name|d
init|=
operator|new
name|Decimal128
argument_list|(
literal|"1.25"
argument_list|,
operator|(
name|short
operator|)
literal|2
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
literal|1
argument_list|,
name|d
operator|.
name|longValue
argument_list|()
argument_list|)
expr_stmt|;
name|d
operator|.
name|update
argument_list|(
literal|"4294967295"
argument_list|,
operator|(
name|short
operator|)
literal|0
argument_list|)
expr_stmt|;
comment|// 2^32-1
name|assertEquals
argument_list|(
literal|4294967295L
argument_list|,
name|d
operator|.
name|longValue
argument_list|()
argument_list|)
expr_stmt|;
name|d
operator|.
name|update
argument_list|(
literal|"4294967296"
argument_list|,
operator|(
name|short
operator|)
literal|0
argument_list|)
expr_stmt|;
comment|// 2^32 -- needs 2 32 bit words
name|assertEquals
argument_list|(
literal|4294967296L
argument_list|,
name|d
operator|.
name|longValue
argument_list|()
argument_list|)
expr_stmt|;
name|d
operator|.
name|update
argument_list|(
literal|"-4294967295"
argument_list|,
operator|(
name|short
operator|)
literal|0
argument_list|)
expr_stmt|;
comment|// -(2^32-1)
name|assertEquals
argument_list|(
operator|-
literal|4294967295L
argument_list|,
name|d
operator|.
name|longValue
argument_list|()
argument_list|)
expr_stmt|;
name|d
operator|.
name|update
argument_list|(
literal|"-4294967296"
argument_list|,
operator|(
name|short
operator|)
literal|0
argument_list|)
expr_stmt|;
comment|// -(2^32)
name|assertEquals
argument_list|(
operator|-
literal|4294967296L
argument_list|,
name|d
operator|.
name|longValue
argument_list|()
argument_list|)
expr_stmt|;
name|d
operator|.
name|update
argument_list|(
literal|"4294967295.01"
argument_list|,
operator|(
name|short
operator|)
literal|2
argument_list|)
expr_stmt|;
comment|// 2^32-1 + .01
name|assertEquals
argument_list|(
literal|4294967295L
argument_list|,
name|d
operator|.
name|longValue
argument_list|()
argument_list|)
expr_stmt|;
name|d
operator|.
name|update
argument_list|(
literal|"4294967296.01"
argument_list|,
operator|(
name|short
operator|)
literal|2
argument_list|)
expr_stmt|;
comment|// 2^32 + .01
name|assertEquals
argument_list|(
literal|4294967296L
argument_list|,
name|d
operator|.
name|longValue
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
end_class

end_unit

