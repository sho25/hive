begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|vector
operator|.
name|aggregation
package|;
end_package

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|reflect
operator|.
name|Constructor
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Random
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|java
operator|.
name|sql
operator|.
name|Timestamp
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|common
operator|.
name|type
operator|.
name|DataTypePhysicalVariation
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|vector
operator|.
name|VectorRandomBatchSource
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|vector
operator|.
name|VectorRandomRowSource
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|vector
operator|.
name|VectorRandomRowSource
operator|.
name|GenerationSpec
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|vector
operator|.
name|expressions
operator|.
name|aggregates
operator|.
name|VectorAggregateExpression
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|ExprNodeColumnDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|ExprNodeDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|udf
operator|.
name|generic
operator|.
name|GenericUDAFCount
operator|.
name|GenericUDAFCountEvaluator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|udf
operator|.
name|generic
operator|.
name|GenericUDAFEvaluator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|udf
operator|.
name|generic
operator|.
name|GenericUDAFVariance
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|udf
operator|.
name|generic
operator|.
name|GenericUDAFEvaluator
operator|.
name|AggregationBuffer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|objectinspector
operator|.
name|ObjectInspector
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|objectinspector
operator|.
name|primitive
operator|.
name|WritableShortObjectInspector
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|typeinfo
operator|.
name|CharTypeInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|typeinfo
operator|.
name|DecimalTypeInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|typeinfo
operator|.
name|TypeInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|typeinfo
operator|.
name|TypeInfoFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|typeinfo
operator|.
name|TypeInfoUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|typeinfo
operator|.
name|VarcharTypeInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|io
operator|.
name|HiveDecimalWritable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|io
operator|.
name|ShortWritable
import|;
end_import

begin_import
import|import
name|junit
operator|.
name|framework
operator|.
name|Assert
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|Ignore
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|Test
import|;
end_import

begin_class
specifier|public
class|class
name|TestVectorAggregation
extends|extends
name|AggregationBase
block|{
annotation|@
name|Test
specifier|public
name|void
name|testAvgIntegers
parameter_list|()
throws|throws
name|Exception
block|{
name|Random
name|random
init|=
operator|new
name|Random
argument_list|(
literal|7743
argument_list|)
decl_stmt|;
name|doIntegerTests
argument_list|(
literal|"avg"
argument_list|,
name|random
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testAvgFloating
parameter_list|()
throws|throws
name|Exception
block|{
name|Random
name|random
init|=
operator|new
name|Random
argument_list|(
literal|7743
argument_list|)
decl_stmt|;
name|doFloatingTests
argument_list|(
literal|"avg"
argument_list|,
name|random
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testAvgDecimal
parameter_list|()
throws|throws
name|Exception
block|{
name|Random
name|random
init|=
operator|new
name|Random
argument_list|(
literal|7743
argument_list|)
decl_stmt|;
name|doDecimalTests
argument_list|(
literal|"avg"
argument_list|,
name|random
argument_list|,
comment|/* tryDecimal64 */
literal|false
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testAvgDecimal64
parameter_list|()
throws|throws
name|Exception
block|{
name|Random
name|random
init|=
operator|new
name|Random
argument_list|(
literal|7743
argument_list|)
decl_stmt|;
name|doDecimalTests
argument_list|(
literal|"avg"
argument_list|,
name|random
argument_list|,
comment|/* tryDecimal64 */
literal|true
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testAvgTimestamp
parameter_list|()
throws|throws
name|Exception
block|{
name|Random
name|random
init|=
operator|new
name|Random
argument_list|(
literal|7743
argument_list|)
decl_stmt|;
name|doTests
argument_list|(
name|random
argument_list|,
literal|"avg"
argument_list|,
name|TypeInfoFactory
operator|.
name|timestampTypeInfo
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testCount
parameter_list|()
throws|throws
name|Exception
block|{
name|Random
name|random
init|=
operator|new
name|Random
argument_list|(
literal|7743
argument_list|)
decl_stmt|;
name|doTests
argument_list|(
name|random
argument_list|,
literal|"count"
argument_list|,
name|TypeInfoFactory
operator|.
name|shortTypeInfo
argument_list|)
expr_stmt|;
name|doTests
argument_list|(
name|random
argument_list|,
literal|"count"
argument_list|,
name|TypeInfoFactory
operator|.
name|longTypeInfo
argument_list|)
expr_stmt|;
name|doTests
argument_list|(
name|random
argument_list|,
literal|"count"
argument_list|,
name|TypeInfoFactory
operator|.
name|doubleTypeInfo
argument_list|)
expr_stmt|;
name|doTests
argument_list|(
name|random
argument_list|,
literal|"count"
argument_list|,
operator|new
name|DecimalTypeInfo
argument_list|(
literal|18
argument_list|,
literal|10
argument_list|)
argument_list|)
expr_stmt|;
name|doTests
argument_list|(
name|random
argument_list|,
literal|"count"
argument_list|,
name|TypeInfoFactory
operator|.
name|stringTypeInfo
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testCountStar
parameter_list|()
throws|throws
name|Exception
block|{
name|Random
name|random
init|=
operator|new
name|Random
argument_list|(
literal|7743
argument_list|)
decl_stmt|;
name|doTests
argument_list|(
name|random
argument_list|,
literal|"count"
argument_list|,
name|TypeInfoFactory
operator|.
name|shortTypeInfo
argument_list|,
literal|true
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|doTests
argument_list|(
name|random
argument_list|,
literal|"count"
argument_list|,
name|TypeInfoFactory
operator|.
name|longTypeInfo
argument_list|,
literal|true
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|doTests
argument_list|(
name|random
argument_list|,
literal|"count"
argument_list|,
name|TypeInfoFactory
operator|.
name|doubleTypeInfo
argument_list|,
literal|true
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|doTests
argument_list|(
name|random
argument_list|,
literal|"count"
argument_list|,
operator|new
name|DecimalTypeInfo
argument_list|(
literal|18
argument_list|,
literal|10
argument_list|)
argument_list|,
literal|true
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|doTests
argument_list|(
name|random
argument_list|,
literal|"count"
argument_list|,
name|TypeInfoFactory
operator|.
name|stringTypeInfo
argument_list|,
literal|true
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testMax
parameter_list|()
throws|throws
name|Exception
block|{
name|Random
name|random
init|=
operator|new
name|Random
argument_list|(
literal|7743
argument_list|)
decl_stmt|;
name|doIntegerTests
argument_list|(
literal|"max"
argument_list|,
name|random
argument_list|)
expr_stmt|;
name|doFloatingTests
argument_list|(
literal|"max"
argument_list|,
name|random
argument_list|)
expr_stmt|;
name|doDecimalTests
argument_list|(
literal|"max"
argument_list|,
name|random
argument_list|,
comment|/* tryDecimal64 */
literal|false
argument_list|)
expr_stmt|;
name|doDecimalTests
argument_list|(
literal|"max"
argument_list|,
name|random
argument_list|,
comment|/* tryDecimal64 */
literal|true
argument_list|)
expr_stmt|;
name|doTests
argument_list|(
name|random
argument_list|,
literal|"max"
argument_list|,
name|TypeInfoFactory
operator|.
name|timestampTypeInfo
argument_list|)
expr_stmt|;
name|doTests
argument_list|(
name|random
argument_list|,
literal|"max"
argument_list|,
name|TypeInfoFactory
operator|.
name|intervalDayTimeTypeInfo
argument_list|)
expr_stmt|;
name|doStringFamilyTests
argument_list|(
literal|"max"
argument_list|,
name|random
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testMin
parameter_list|()
throws|throws
name|Exception
block|{
name|Random
name|random
init|=
operator|new
name|Random
argument_list|(
literal|7743
argument_list|)
decl_stmt|;
name|doIntegerTests
argument_list|(
literal|"min"
argument_list|,
name|random
argument_list|)
expr_stmt|;
name|doFloatingTests
argument_list|(
literal|"min"
argument_list|,
name|random
argument_list|)
expr_stmt|;
name|doDecimalTests
argument_list|(
literal|"min"
argument_list|,
name|random
argument_list|,
comment|/* tryDecimal64 */
literal|false
argument_list|)
expr_stmt|;
name|doDecimalTests
argument_list|(
literal|"min"
argument_list|,
name|random
argument_list|,
comment|/* tryDecimal64 */
literal|true
argument_list|)
expr_stmt|;
name|doTests
argument_list|(
name|random
argument_list|,
literal|"min"
argument_list|,
name|TypeInfoFactory
operator|.
name|timestampTypeInfo
argument_list|)
expr_stmt|;
name|doTests
argument_list|(
name|random
argument_list|,
literal|"min"
argument_list|,
name|TypeInfoFactory
operator|.
name|intervalDayTimeTypeInfo
argument_list|)
expr_stmt|;
name|doStringFamilyTests
argument_list|(
literal|"min"
argument_list|,
name|random
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testSum
parameter_list|()
throws|throws
name|Exception
block|{
name|Random
name|random
init|=
operator|new
name|Random
argument_list|(
literal|7743
argument_list|)
decl_stmt|;
name|doTests
argument_list|(
name|random
argument_list|,
literal|"sum"
argument_list|,
name|TypeInfoFactory
operator|.
name|shortTypeInfo
argument_list|)
expr_stmt|;
name|doTests
argument_list|(
name|random
argument_list|,
literal|"sum"
argument_list|,
name|TypeInfoFactory
operator|.
name|longTypeInfo
argument_list|)
expr_stmt|;
name|doTests
argument_list|(
name|random
argument_list|,
literal|"sum"
argument_list|,
name|TypeInfoFactory
operator|.
name|doubleTypeInfo
argument_list|)
expr_stmt|;
name|doDecimalTests
argument_list|(
literal|"sum"
argument_list|,
name|random
argument_list|,
comment|/* tryDecimal64 */
literal|false
argument_list|)
expr_stmt|;
name|doDecimalTests
argument_list|(
literal|"sum"
argument_list|,
name|random
argument_list|,
comment|/* tryDecimal64 */
literal|true
argument_list|)
expr_stmt|;
name|doTests
argument_list|(
name|random
argument_list|,
literal|"sum"
argument_list|,
name|TypeInfoFactory
operator|.
name|timestampTypeInfo
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Ignore
annotation|@
name|Test
specifier|public
name|void
name|testBloomFilter
parameter_list|()
throws|throws
name|Exception
block|{
name|Random
name|random
init|=
operator|new
name|Random
argument_list|(
literal|7743
argument_list|)
decl_stmt|;
name|doIntegerTests
argument_list|(
literal|"bloom_filter"
argument_list|,
name|random
argument_list|)
expr_stmt|;
name|doFloatingTests
argument_list|(
literal|"bloom_filter"
argument_list|,
name|random
argument_list|)
expr_stmt|;
name|doDecimalTests
argument_list|(
literal|"bloom_filter"
argument_list|,
name|random
argument_list|,
comment|/* tryDecimal64 */
literal|false
argument_list|)
expr_stmt|;
name|doTests
argument_list|(
name|random
argument_list|,
literal|"bloom_filter"
argument_list|,
name|TypeInfoFactory
operator|.
name|timestampTypeInfo
argument_list|)
expr_stmt|;
name|doStringFamilyTests
argument_list|(
literal|"bloom_filter"
argument_list|,
name|random
argument_list|)
expr_stmt|;
block|}
specifier|private
specifier|final
specifier|static
name|Set
argument_list|<
name|String
argument_list|>
name|varianceNames
init|=
operator|new
name|HashSet
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
static|static
block|{
comment|// Don't include synonyms.
name|varianceNames
operator|.
name|add
argument_list|(
literal|"variance"
argument_list|)
expr_stmt|;
name|varianceNames
operator|.
name|add
argument_list|(
literal|"var_samp"
argument_list|)
expr_stmt|;
name|varianceNames
operator|.
name|add
argument_list|(
literal|"std"
argument_list|)
expr_stmt|;
name|varianceNames
operator|.
name|add
argument_list|(
literal|"stddev_samp"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testVarianceIntegers
parameter_list|()
throws|throws
name|Exception
block|{
name|Random
name|random
init|=
operator|new
name|Random
argument_list|(
literal|7743
argument_list|)
decl_stmt|;
for|for
control|(
name|String
name|aggregationName
range|:
name|varianceNames
control|)
block|{
name|doIntegerTests
argument_list|(
name|aggregationName
argument_list|,
name|random
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Test
specifier|public
name|void
name|testVarianceFloating
parameter_list|()
throws|throws
name|Exception
block|{
name|Random
name|random
init|=
operator|new
name|Random
argument_list|(
literal|7743
argument_list|)
decl_stmt|;
for|for
control|(
name|String
name|aggregationName
range|:
name|varianceNames
control|)
block|{
name|doFloatingTests
argument_list|(
name|aggregationName
argument_list|,
name|random
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Test
specifier|public
name|void
name|testVarianceDecimal
parameter_list|()
throws|throws
name|Exception
block|{
name|Random
name|random
init|=
operator|new
name|Random
argument_list|(
literal|7743
argument_list|)
decl_stmt|;
for|for
control|(
name|String
name|aggregationName
range|:
name|varianceNames
control|)
block|{
name|doDecimalTests
argument_list|(
name|aggregationName
argument_list|,
name|random
argument_list|,
comment|/* tryDecimal64 */
literal|false
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Test
specifier|public
name|void
name|testVarianceTimestamp
parameter_list|()
throws|throws
name|Exception
block|{
name|Random
name|random
init|=
operator|new
name|Random
argument_list|(
literal|7743
argument_list|)
decl_stmt|;
for|for
control|(
name|String
name|aggregationName
range|:
name|varianceNames
control|)
block|{
name|doTests
argument_list|(
name|random
argument_list|,
name|aggregationName
argument_list|,
name|TypeInfoFactory
operator|.
name|timestampTypeInfo
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
specifier|static
name|TypeInfo
index|[]
name|integerTypeInfos
init|=
operator|new
name|TypeInfo
index|[]
block|{
name|TypeInfoFactory
operator|.
name|byteTypeInfo
block|,
name|TypeInfoFactory
operator|.
name|shortTypeInfo
block|,
name|TypeInfoFactory
operator|.
name|intTypeInfo
block|,
name|TypeInfoFactory
operator|.
name|longTypeInfo
block|}
decl_stmt|;
comment|// We have test failures with FLOAT.  Ignoring this issue for now.
specifier|private
specifier|static
name|TypeInfo
index|[]
name|floatingTypeInfos
init|=
operator|new
name|TypeInfo
index|[]
block|{
comment|// TypeInfoFactory.floatTypeInfo,
name|TypeInfoFactory
operator|.
name|doubleTypeInfo
block|}
decl_stmt|;
specifier|private
name|void
name|doIntegerTests
parameter_list|(
name|String
name|aggregationName
parameter_list|,
name|Random
name|random
parameter_list|)
throws|throws
name|Exception
block|{
for|for
control|(
name|TypeInfo
name|typeInfo
range|:
name|integerTypeInfos
control|)
block|{
name|doTests
argument_list|(
name|random
argument_list|,
name|aggregationName
argument_list|,
name|typeInfo
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|doFloatingTests
parameter_list|(
name|String
name|aggregationName
parameter_list|,
name|Random
name|random
parameter_list|)
throws|throws
name|Exception
block|{
for|for
control|(
name|TypeInfo
name|typeInfo
range|:
name|floatingTypeInfos
control|)
block|{
name|doTests
argument_list|(
name|random
argument_list|,
name|aggregationName
argument_list|,
name|typeInfo
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
specifier|static
name|TypeInfo
index|[]
name|decimalTypeInfos
init|=
operator|new
name|TypeInfo
index|[]
block|{
operator|new
name|DecimalTypeInfo
argument_list|(
literal|38
argument_list|,
literal|18
argument_list|)
block|,
operator|new
name|DecimalTypeInfo
argument_list|(
literal|25
argument_list|,
literal|2
argument_list|)
block|,
operator|new
name|DecimalTypeInfo
argument_list|(
literal|19
argument_list|,
literal|4
argument_list|)
block|,
operator|new
name|DecimalTypeInfo
argument_list|(
literal|18
argument_list|,
literal|10
argument_list|)
block|,
operator|new
name|DecimalTypeInfo
argument_list|(
literal|17
argument_list|,
literal|3
argument_list|)
block|,
operator|new
name|DecimalTypeInfo
argument_list|(
literal|12
argument_list|,
literal|2
argument_list|)
block|,
operator|new
name|DecimalTypeInfo
argument_list|(
literal|7
argument_list|,
literal|1
argument_list|)
block|}
decl_stmt|;
specifier|private
name|void
name|doDecimalTests
parameter_list|(
name|String
name|aggregationName
parameter_list|,
name|Random
name|random
parameter_list|,
name|boolean
name|tryDecimal64
parameter_list|)
throws|throws
name|Exception
block|{
for|for
control|(
name|TypeInfo
name|typeInfo
range|:
name|decimalTypeInfos
control|)
block|{
name|doTests
argument_list|(
name|random
argument_list|,
name|aggregationName
argument_list|,
name|typeInfo
argument_list|,
comment|/* isCountStar */
literal|false
argument_list|,
name|tryDecimal64
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
specifier|static
name|TypeInfo
index|[]
name|stringFamilyTypeInfos
init|=
operator|new
name|TypeInfo
index|[]
block|{
name|TypeInfoFactory
operator|.
name|stringTypeInfo
block|,
operator|new
name|CharTypeInfo
argument_list|(
literal|25
argument_list|)
block|,
operator|new
name|CharTypeInfo
argument_list|(
literal|10
argument_list|)
block|,
operator|new
name|VarcharTypeInfo
argument_list|(
literal|20
argument_list|)
block|,
operator|new
name|VarcharTypeInfo
argument_list|(
literal|15
argument_list|)
block|}
decl_stmt|;
specifier|private
name|void
name|doStringFamilyTests
parameter_list|(
name|String
name|aggregationName
parameter_list|,
name|Random
name|random
parameter_list|)
throws|throws
name|Exception
block|{
for|for
control|(
name|TypeInfo
name|typeInfo
range|:
name|stringFamilyTypeInfos
control|)
block|{
name|doTests
argument_list|(
name|random
argument_list|,
name|aggregationName
argument_list|,
name|typeInfo
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
name|boolean
name|checkDecimal64
parameter_list|(
name|boolean
name|tryDecimal64
parameter_list|,
name|TypeInfo
name|typeInfo
parameter_list|)
block|{
if|if
condition|(
operator|!
name|tryDecimal64
operator|||
operator|!
operator|(
name|typeInfo
operator|instanceof
name|DecimalTypeInfo
operator|)
condition|)
block|{
return|return
literal|false
return|;
block|}
name|DecimalTypeInfo
name|decimalTypeInfo
init|=
operator|(
name|DecimalTypeInfo
operator|)
name|typeInfo
decl_stmt|;
name|boolean
name|result
init|=
name|HiveDecimalWritable
operator|.
name|isPrecisionDecimal64
argument_list|(
name|decimalTypeInfo
operator|.
name|getPrecision
argument_list|()
argument_list|)
decl_stmt|;
return|return
name|result
return|;
block|}
specifier|public
specifier|static
name|int
name|getLinearRandomNumber
parameter_list|(
name|Random
name|random
parameter_list|,
name|int
name|maxSize
parameter_list|)
block|{
comment|//Get a linearly multiplied random number
name|int
name|randomMultiplier
init|=
name|maxSize
operator|*
operator|(
name|maxSize
operator|+
literal|1
operator|)
operator|/
literal|2
decl_stmt|;
name|int
name|randomInt
init|=
name|random
operator|.
name|nextInt
argument_list|(
name|randomMultiplier
argument_list|)
decl_stmt|;
comment|//Linearly iterate through the possible values to find the correct one
name|int
name|linearRandomNumber
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
name|maxSize
init|;
name|randomInt
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|randomInt
operator|-=
name|i
expr_stmt|;
name|linearRandomNumber
operator|++
expr_stmt|;
block|}
return|return
name|linearRandomNumber
return|;
block|}
specifier|private
specifier|static
specifier|final
name|int
name|TEST_ROW_COUNT
init|=
literal|100000
decl_stmt|;
specifier|private
name|void
name|doMerge
parameter_list|(
name|GenericUDAFEvaluator
operator|.
name|Mode
name|mergeUdafEvaluatorMode
parameter_list|,
name|Random
name|random
parameter_list|,
name|String
name|aggregationName
parameter_list|,
name|TypeInfo
name|typeInfo
parameter_list|,
name|GenerationSpec
name|keyGenerationSpec
parameter_list|,
name|List
argument_list|<
name|String
argument_list|>
name|columns
parameter_list|,
name|String
index|[]
name|columnNames
parameter_list|,
name|int
name|dataAggrMaxKeyCount
parameter_list|,
name|int
name|reductionFactor
parameter_list|,
name|TypeInfo
name|partial1OutputTypeInfo
parameter_list|,
name|Object
index|[]
name|partial1ResultsArray
parameter_list|)
throws|throws
name|Exception
block|{
name|List
argument_list|<
name|GenerationSpec
argument_list|>
name|mergeAggrGenerationSpecList
init|=
operator|new
name|ArrayList
argument_list|<
name|GenerationSpec
argument_list|>
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|DataTypePhysicalVariation
argument_list|>
name|mergeDataTypePhysicalVariationList
init|=
operator|new
name|ArrayList
argument_list|<
name|DataTypePhysicalVariation
argument_list|>
argument_list|()
decl_stmt|;
name|mergeAggrGenerationSpecList
operator|.
name|add
argument_list|(
name|keyGenerationSpec
argument_list|)
expr_stmt|;
name|mergeDataTypePhysicalVariationList
operator|.
name|add
argument_list|(
name|DataTypePhysicalVariation
operator|.
name|NONE
argument_list|)
expr_stmt|;
comment|// Use OMIT for both.  We will fill in the data from the PARTIAL1 results.
name|GenerationSpec
name|mergeGenerationSpec
init|=
name|GenerationSpec
operator|.
name|createOmitGeneration
argument_list|(
name|partial1OutputTypeInfo
argument_list|)
decl_stmt|;
name|mergeAggrGenerationSpecList
operator|.
name|add
argument_list|(
name|mergeGenerationSpec
argument_list|)
expr_stmt|;
name|mergeDataTypePhysicalVariationList
operator|.
name|add
argument_list|(
name|DataTypePhysicalVariation
operator|.
name|NONE
argument_list|)
expr_stmt|;
name|ExprNodeColumnDesc
name|mergeCol1Expr
init|=
operator|new
name|ExprNodeColumnDesc
argument_list|(
name|partial1OutputTypeInfo
argument_list|,
literal|"col1"
argument_list|,
literal|"table"
argument_list|,
literal|false
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|ExprNodeDesc
argument_list|>
name|mergeParameters
init|=
operator|new
name|ArrayList
argument_list|<
name|ExprNodeDesc
argument_list|>
argument_list|()
decl_stmt|;
name|mergeParameters
operator|.
name|add
argument_list|(
name|mergeCol1Expr
argument_list|)
expr_stmt|;
specifier|final
name|int
name|mergeParameterCount
init|=
name|mergeParameters
operator|.
name|size
argument_list|()
decl_stmt|;
name|ObjectInspector
index|[]
name|mergeParameterObjectInspectors
init|=
operator|new
name|ObjectInspector
index|[
name|mergeParameterCount
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|mergeParameterCount
condition|;
name|i
operator|++
control|)
block|{
name|TypeInfo
name|paramTypeInfo
init|=
name|mergeParameters
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|getTypeInfo
argument_list|()
decl_stmt|;
name|mergeParameterObjectInspectors
index|[
name|i
index|]
operator|=
name|TypeInfoUtils
operator|.
name|getStandardWritableObjectInspectorFromTypeInfo
argument_list|(
name|paramTypeInfo
argument_list|)
expr_stmt|;
block|}
name|VectorRandomRowSource
name|mergeRowSource
init|=
operator|new
name|VectorRandomRowSource
argument_list|()
decl_stmt|;
name|mergeRowSource
operator|.
name|initGenerationSpecSchema
argument_list|(
name|random
argument_list|,
name|mergeAggrGenerationSpecList
argument_list|,
comment|/* maxComplexDepth */
literal|0
argument_list|,
comment|/* allowNull */
literal|false
argument_list|,
name|mergeDataTypePhysicalVariationList
argument_list|)
expr_stmt|;
name|Object
index|[]
index|[]
name|mergeRandomRows
init|=
name|mergeRowSource
operator|.
name|randomRows
argument_list|(
name|TEST_ROW_COUNT
argument_list|)
decl_stmt|;
comment|// Reduce the key range to cause there to be work for each PARTIAL2 key.
specifier|final
name|int
name|mergeMaxKeyCount
init|=
name|dataAggrMaxKeyCount
operator|/
name|reductionFactor
decl_stmt|;
name|Object
index|[]
name|partial1Results
init|=
operator|(
name|Object
index|[]
operator|)
name|partial1ResultsArray
index|[
literal|0
index|]
decl_stmt|;
name|short
name|partial1Key
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|mergeRandomRows
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
comment|// Find a non-NULL entry...
while|while
condition|(
literal|true
condition|)
block|{
if|if
condition|(
name|partial1Key
operator|>=
name|dataAggrMaxKeyCount
condition|)
block|{
name|partial1Key
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|partial1Results
index|[
name|partial1Key
index|]
operator|!=
literal|null
condition|)
block|{
break|break;
block|}
name|partial1Key
operator|++
expr_stmt|;
block|}
specifier|final
name|short
name|mergeKey
init|=
call|(
name|short
call|)
argument_list|(
name|partial1Key
operator|%
name|mergeMaxKeyCount
argument_list|)
decl_stmt|;
name|mergeRandomRows
index|[
name|i
index|]
index|[
literal|0
index|]
operator|=
operator|new
name|ShortWritable
argument_list|(
name|mergeKey
argument_list|)
expr_stmt|;
name|mergeRandomRows
index|[
name|i
index|]
index|[
literal|1
index|]
operator|=
name|partial1Results
index|[
name|partial1Key
index|]
expr_stmt|;
name|partial1Key
operator|++
expr_stmt|;
block|}
name|VectorRandomBatchSource
name|mergeBatchSource
init|=
name|VectorRandomBatchSource
operator|.
name|createInterestingBatches
argument_list|(
name|random
argument_list|,
name|mergeRowSource
argument_list|,
name|mergeRandomRows
argument_list|,
literal|null
argument_list|)
decl_stmt|;
comment|// We need to pass the original TypeInfo in for initializing the evaluator.
name|GenericUDAFEvaluator
name|mergeEvaluator
init|=
name|getEvaluator
argument_list|(
name|aggregationName
argument_list|,
name|typeInfo
argument_list|)
decl_stmt|;
comment|/*     System.out.println(         "*DEBUG* GenericUDAFEvaluator for " + aggregationName + ", " + typeInfo.getTypeName() + ": " +             mergeEvaluator.getClass().getSimpleName());     */
comment|// The only way to get the return object inspector (and its return type) is to
comment|// initialize it...
name|ObjectInspector
name|mergeReturnOI
init|=
name|mergeEvaluator
operator|.
name|init
argument_list|(
name|mergeUdafEvaluatorMode
argument_list|,
name|mergeParameterObjectInspectors
argument_list|)
decl_stmt|;
name|TypeInfo
name|mergeOutputTypeInfo
init|=
name|TypeInfoUtils
operator|.
name|getTypeInfoFromObjectInspector
argument_list|(
name|mergeReturnOI
argument_list|)
decl_stmt|;
name|Object
index|[]
name|mergeResultsArray
init|=
operator|new
name|Object
index|[
name|AggregationTestMode
operator|.
name|count
index|]
decl_stmt|;
name|executeAggregationTests
argument_list|(
name|aggregationName
argument_list|,
name|partial1OutputTypeInfo
argument_list|,
name|mergeEvaluator
argument_list|,
name|mergeOutputTypeInfo
argument_list|,
name|mergeUdafEvaluatorMode
argument_list|,
name|mergeMaxKeyCount
argument_list|,
name|columns
argument_list|,
name|columnNames
argument_list|,
name|mergeParameters
argument_list|,
name|mergeRandomRows
argument_list|,
name|mergeRowSource
argument_list|,
name|mergeBatchSource
argument_list|,
comment|/* tryDecimal64 */
literal|false
argument_list|,
name|mergeResultsArray
argument_list|)
expr_stmt|;
name|verifyAggregationResults
argument_list|(
name|partial1OutputTypeInfo
argument_list|,
name|mergeOutputTypeInfo
argument_list|,
name|mergeMaxKeyCount
argument_list|,
name|mergeUdafEvaluatorMode
argument_list|,
name|mergeResultsArray
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|doTests
parameter_list|(
name|Random
name|random
parameter_list|,
name|String
name|aggregationName
parameter_list|,
name|TypeInfo
name|typeInfo
parameter_list|)
throws|throws
name|Exception
block|{
name|doTests
argument_list|(
name|random
argument_list|,
name|aggregationName
argument_list|,
name|typeInfo
argument_list|,
literal|false
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|doTests
parameter_list|(
name|Random
name|random
parameter_list|,
name|String
name|aggregationName
parameter_list|,
name|TypeInfo
name|typeInfo
parameter_list|,
name|boolean
name|isCountStar
parameter_list|,
name|boolean
name|tryDecimal64
parameter_list|)
throws|throws
name|Exception
block|{
name|List
argument_list|<
name|GenerationSpec
argument_list|>
name|dataAggrGenerationSpecList
init|=
operator|new
name|ArrayList
argument_list|<
name|GenerationSpec
argument_list|>
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|DataTypePhysicalVariation
argument_list|>
name|explicitDataTypePhysicalVariationList
init|=
operator|new
name|ArrayList
argument_list|<
name|DataTypePhysicalVariation
argument_list|>
argument_list|()
decl_stmt|;
name|TypeInfo
name|keyTypeInfo
init|=
name|TypeInfoFactory
operator|.
name|shortTypeInfo
decl_stmt|;
name|GenerationSpec
name|keyGenerationSpec
init|=
name|GenerationSpec
operator|.
name|createOmitGeneration
argument_list|(
name|keyTypeInfo
argument_list|)
decl_stmt|;
name|dataAggrGenerationSpecList
operator|.
name|add
argument_list|(
name|keyGenerationSpec
argument_list|)
expr_stmt|;
name|explicitDataTypePhysicalVariationList
operator|.
name|add
argument_list|(
name|DataTypePhysicalVariation
operator|.
name|NONE
argument_list|)
expr_stmt|;
specifier|final
name|boolean
name|decimal64Enable
init|=
name|checkDecimal64
argument_list|(
name|tryDecimal64
argument_list|,
name|typeInfo
argument_list|)
decl_stmt|;
name|GenerationSpec
name|generationSpec
init|=
name|GenerationSpec
operator|.
name|createSameType
argument_list|(
name|typeInfo
argument_list|)
decl_stmt|;
name|dataAggrGenerationSpecList
operator|.
name|add
argument_list|(
name|generationSpec
argument_list|)
expr_stmt|;
name|explicitDataTypePhysicalVariationList
operator|.
name|add
argument_list|(
name|decimal64Enable
condition|?
name|DataTypePhysicalVariation
operator|.
name|DECIMAL_64
else|:
name|DataTypePhysicalVariation
operator|.
name|NONE
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|columns
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
name|columns
operator|.
name|add
argument_list|(
literal|"col0"
argument_list|)
expr_stmt|;
name|columns
operator|.
name|add
argument_list|(
literal|"col1"
argument_list|)
expr_stmt|;
name|ExprNodeColumnDesc
name|dataAggrCol1Expr
init|=
operator|new
name|ExprNodeColumnDesc
argument_list|(
name|typeInfo
argument_list|,
literal|"col1"
argument_list|,
literal|"table"
argument_list|,
literal|false
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|ExprNodeDesc
argument_list|>
name|dataAggrParameters
init|=
operator|new
name|ArrayList
argument_list|<
name|ExprNodeDesc
argument_list|>
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|isCountStar
condition|)
block|{
name|dataAggrParameters
operator|.
name|add
argument_list|(
name|dataAggrCol1Expr
argument_list|)
expr_stmt|;
block|}
specifier|final
name|int
name|dataAggrParameterCount
init|=
name|dataAggrParameters
operator|.
name|size
argument_list|()
decl_stmt|;
name|ObjectInspector
index|[]
name|dataAggrParameterObjectInspectors
init|=
operator|new
name|ObjectInspector
index|[
name|dataAggrParameterCount
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|dataAggrParameterCount
condition|;
name|i
operator|++
control|)
block|{
name|TypeInfo
name|paramTypeInfo
init|=
name|dataAggrParameters
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|getTypeInfo
argument_list|()
decl_stmt|;
name|dataAggrParameterObjectInspectors
index|[
name|i
index|]
operator|=
name|TypeInfoUtils
operator|.
name|getStandardWritableObjectInspectorFromTypeInfo
argument_list|(
name|paramTypeInfo
argument_list|)
expr_stmt|;
block|}
name|String
index|[]
name|columnNames
init|=
name|columns
operator|.
name|toArray
argument_list|(
operator|new
name|String
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
specifier|final
name|int
name|dataAggrMaxKeyCount
init|=
literal|20000
decl_stmt|;
specifier|final
name|int
name|reductionFactor
init|=
literal|16
decl_stmt|;
name|ObjectInspector
name|keyObjectInspector
init|=
name|VectorRandomRowSource
operator|.
name|getObjectInspector
argument_list|(
name|keyTypeInfo
argument_list|)
decl_stmt|;
comment|/*      * PARTIAL1.      */
name|VectorRandomRowSource
name|partial1RowSource
init|=
operator|new
name|VectorRandomRowSource
argument_list|()
decl_stmt|;
name|boolean
name|allowNull
init|=
operator|!
name|aggregationName
operator|.
name|equals
argument_list|(
literal|"bloom_filter"
argument_list|)
decl_stmt|;
name|partial1RowSource
operator|.
name|initGenerationSpecSchema
argument_list|(
name|random
argument_list|,
name|dataAggrGenerationSpecList
argument_list|,
comment|/* maxComplexDepth */
literal|0
argument_list|,
name|allowNull
argument_list|,
name|explicitDataTypePhysicalVariationList
argument_list|)
expr_stmt|;
name|Object
index|[]
index|[]
name|partial1RandomRows
init|=
name|partial1RowSource
operator|.
name|randomRows
argument_list|(
name|TEST_ROW_COUNT
argument_list|)
decl_stmt|;
specifier|final
name|int
name|partial1RowCount
init|=
name|partial1RandomRows
operator|.
name|length
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|partial1RowCount
condition|;
name|i
operator|++
control|)
block|{
specifier|final
name|short
name|shortKey
init|=
operator|(
name|short
operator|)
name|getLinearRandomNumber
argument_list|(
name|random
argument_list|,
name|dataAggrMaxKeyCount
argument_list|)
decl_stmt|;
name|partial1RandomRows
index|[
name|i
index|]
index|[
literal|0
index|]
operator|=
operator|(
operator|(
name|WritableShortObjectInspector
operator|)
name|keyObjectInspector
operator|)
operator|.
name|create
argument_list|(
operator|(
name|short
operator|)
name|shortKey
argument_list|)
expr_stmt|;
block|}
name|VectorRandomBatchSource
name|partial1BatchSource
init|=
name|VectorRandomBatchSource
operator|.
name|createInterestingBatches
argument_list|(
name|random
argument_list|,
name|partial1RowSource
argument_list|,
name|partial1RandomRows
argument_list|,
literal|null
argument_list|)
decl_stmt|;
name|GenericUDAFEvaluator
name|partial1Evaluator
init|=
name|getEvaluator
argument_list|(
name|aggregationName
argument_list|,
name|typeInfo
argument_list|)
decl_stmt|;
if|if
condition|(
name|isCountStar
condition|)
block|{
name|Assert
operator|.
name|assertTrue
argument_list|(
name|partial1Evaluator
operator|instanceof
name|GenericUDAFCountEvaluator
argument_list|)
expr_stmt|;
name|GenericUDAFCountEvaluator
name|countEvaluator
init|=
operator|(
name|GenericUDAFCountEvaluator
operator|)
name|partial1Evaluator
decl_stmt|;
name|countEvaluator
operator|.
name|setCountAllColumns
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
comment|/*     System.out.println(         "*DEBUG* GenericUDAFEvaluator for " + aggregationName + ", " + typeInfo.getTypeName() + ": " +             partial1Evaluator.getClass().getSimpleName());     */
comment|// The only way to get the return object inspector (and its return type) is to
comment|// initialize it...
specifier|final
name|GenericUDAFEvaluator
operator|.
name|Mode
name|partial1UdafEvaluatorMode
init|=
name|GenericUDAFEvaluator
operator|.
name|Mode
operator|.
name|PARTIAL1
decl_stmt|;
name|ObjectInspector
name|partial1ReturnOI
init|=
name|partial1Evaluator
operator|.
name|init
argument_list|(
name|partial1UdafEvaluatorMode
argument_list|,
name|dataAggrParameterObjectInspectors
argument_list|)
decl_stmt|;
name|TypeInfo
name|partial1OutputTypeInfo
init|=
name|TypeInfoUtils
operator|.
name|getTypeInfoFromObjectInspector
argument_list|(
name|partial1ReturnOI
argument_list|)
decl_stmt|;
name|Object
index|[]
name|partial1ResultsArray
init|=
operator|new
name|Object
index|[
name|AggregationTestMode
operator|.
name|count
index|]
decl_stmt|;
name|executeAggregationTests
argument_list|(
name|aggregationName
argument_list|,
name|typeInfo
argument_list|,
name|partial1Evaluator
argument_list|,
name|partial1OutputTypeInfo
argument_list|,
name|partial1UdafEvaluatorMode
argument_list|,
name|dataAggrMaxKeyCount
argument_list|,
name|columns
argument_list|,
name|columnNames
argument_list|,
name|dataAggrParameters
argument_list|,
name|partial1RandomRows
argument_list|,
name|partial1RowSource
argument_list|,
name|partial1BatchSource
argument_list|,
name|tryDecimal64
argument_list|,
name|partial1ResultsArray
argument_list|)
expr_stmt|;
name|verifyAggregationResults
argument_list|(
name|typeInfo
argument_list|,
name|partial1OutputTypeInfo
argument_list|,
name|dataAggrMaxKeyCount
argument_list|,
name|partial1UdafEvaluatorMode
argument_list|,
name|partial1ResultsArray
argument_list|)
expr_stmt|;
specifier|final
name|boolean
name|hasDifferentCompleteExpr
decl_stmt|;
if|if
condition|(
name|varianceNames
operator|.
name|contains
argument_list|(
name|aggregationName
argument_list|)
condition|)
block|{
name|hasDifferentCompleteExpr
operator|=
literal|true
expr_stmt|;
block|}
else|else
block|{
switch|switch
condition|(
name|aggregationName
condition|)
block|{
case|case
literal|"avg"
case|:
name|hasDifferentCompleteExpr
operator|=
literal|true
expr_stmt|;
break|break;
case|case
literal|"bloom_filter"
case|:
case|case
literal|"count"
case|:
case|case
literal|"max"
case|:
case|case
literal|"min"
case|:
case|case
literal|"sum"
case|:
name|hasDifferentCompleteExpr
operator|=
literal|false
expr_stmt|;
break|break;
default|default:
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Unexpected aggregation name "
operator|+
name|aggregationName
argument_list|)
throw|;
block|}
block|}
if|if
condition|(
name|hasDifferentCompleteExpr
condition|)
block|{
comment|/*        * COMPLETE.        */
name|VectorRandomRowSource
name|completeRowSource
init|=
operator|new
name|VectorRandomRowSource
argument_list|()
decl_stmt|;
name|completeRowSource
operator|.
name|initGenerationSpecSchema
argument_list|(
name|random
argument_list|,
name|dataAggrGenerationSpecList
argument_list|,
comment|/* maxComplexDepth */
literal|0
argument_list|,
comment|/* allowNull */
literal|true
argument_list|,
name|explicitDataTypePhysicalVariationList
argument_list|)
expr_stmt|;
name|Object
index|[]
index|[]
name|completeRandomRows
init|=
name|completeRowSource
operator|.
name|randomRows
argument_list|(
name|TEST_ROW_COUNT
argument_list|)
decl_stmt|;
specifier|final
name|int
name|completeRowCount
init|=
name|completeRandomRows
operator|.
name|length
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|completeRowCount
condition|;
name|i
operator|++
control|)
block|{
specifier|final
name|short
name|shortKey
init|=
operator|(
name|short
operator|)
name|getLinearRandomNumber
argument_list|(
name|random
argument_list|,
name|dataAggrMaxKeyCount
argument_list|)
decl_stmt|;
name|completeRandomRows
index|[
name|i
index|]
index|[
literal|0
index|]
operator|=
operator|(
operator|(
name|WritableShortObjectInspector
operator|)
name|keyObjectInspector
operator|)
operator|.
name|create
argument_list|(
operator|(
name|short
operator|)
name|shortKey
argument_list|)
expr_stmt|;
block|}
name|VectorRandomBatchSource
name|completeBatchSource
init|=
name|VectorRandomBatchSource
operator|.
name|createInterestingBatches
argument_list|(
name|random
argument_list|,
name|completeRowSource
argument_list|,
name|completeRandomRows
argument_list|,
literal|null
argument_list|)
decl_stmt|;
name|GenericUDAFEvaluator
name|completeEvaluator
init|=
name|getEvaluator
argument_list|(
name|aggregationName
argument_list|,
name|typeInfo
argument_list|)
decl_stmt|;
comment|/*       System.out.println(           "*DEBUG* GenericUDAFEvaluator for " + aggregationName + ", " + typeInfo.getTypeName() + ": " +               completeEvaluator.getClass().getSimpleName());       */
comment|// The only way to get the return object inspector (and its return type) is to
comment|// initialize it...
specifier|final
name|GenericUDAFEvaluator
operator|.
name|Mode
name|completeUdafEvaluatorMode
init|=
name|GenericUDAFEvaluator
operator|.
name|Mode
operator|.
name|COMPLETE
decl_stmt|;
name|ObjectInspector
name|completeReturnOI
init|=
name|completeEvaluator
operator|.
name|init
argument_list|(
name|completeUdafEvaluatorMode
argument_list|,
name|dataAggrParameterObjectInspectors
argument_list|)
decl_stmt|;
name|TypeInfo
name|completeOutputTypeInfo
init|=
name|TypeInfoUtils
operator|.
name|getTypeInfoFromObjectInspector
argument_list|(
name|completeReturnOI
argument_list|)
decl_stmt|;
name|Object
index|[]
name|completeResultsArray
init|=
operator|new
name|Object
index|[
name|AggregationTestMode
operator|.
name|count
index|]
decl_stmt|;
name|executeAggregationTests
argument_list|(
name|aggregationName
argument_list|,
name|typeInfo
argument_list|,
name|completeEvaluator
argument_list|,
name|completeOutputTypeInfo
argument_list|,
name|completeUdafEvaluatorMode
argument_list|,
name|dataAggrMaxKeyCount
argument_list|,
name|columns
argument_list|,
name|columnNames
argument_list|,
name|dataAggrParameters
argument_list|,
name|completeRandomRows
argument_list|,
name|completeRowSource
argument_list|,
name|completeBatchSource
argument_list|,
name|tryDecimal64
argument_list|,
name|completeResultsArray
argument_list|)
expr_stmt|;
name|verifyAggregationResults
argument_list|(
name|typeInfo
argument_list|,
name|completeOutputTypeInfo
argument_list|,
name|dataAggrMaxKeyCount
argument_list|,
name|completeUdafEvaluatorMode
argument_list|,
name|completeResultsArray
argument_list|)
expr_stmt|;
block|}
specifier|final
name|boolean
name|hasDifferentPartial2Expr
decl_stmt|;
if|if
condition|(
name|varianceNames
operator|.
name|contains
argument_list|(
name|aggregationName
argument_list|)
condition|)
block|{
name|hasDifferentPartial2Expr
operator|=
literal|true
expr_stmt|;
block|}
else|else
block|{
switch|switch
condition|(
name|aggregationName
condition|)
block|{
case|case
literal|"avg"
case|:
name|hasDifferentPartial2Expr
operator|=
literal|true
expr_stmt|;
break|break;
case|case
literal|"bloom_filter"
case|:
case|case
literal|"count"
case|:
case|case
literal|"max"
case|:
case|case
literal|"min"
case|:
case|case
literal|"sum"
case|:
name|hasDifferentPartial2Expr
operator|=
literal|false
expr_stmt|;
break|break;
default|default:
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Unexpected aggregation name "
operator|+
name|aggregationName
argument_list|)
throw|;
block|}
block|}
if|if
condition|(
name|hasDifferentPartial2Expr
condition|)
block|{
comment|/*        * PARTIAL2.        */
specifier|final
name|GenericUDAFEvaluator
operator|.
name|Mode
name|mergeUdafEvaluatorMode
init|=
name|GenericUDAFEvaluator
operator|.
name|Mode
operator|.
name|PARTIAL2
decl_stmt|;
name|doMerge
argument_list|(
name|mergeUdafEvaluatorMode
argument_list|,
name|random
argument_list|,
name|aggregationName
argument_list|,
name|typeInfo
argument_list|,
name|keyGenerationSpec
argument_list|,
name|columns
argument_list|,
name|columnNames
argument_list|,
name|dataAggrMaxKeyCount
argument_list|,
name|reductionFactor
argument_list|,
name|partial1OutputTypeInfo
argument_list|,
name|partial1ResultsArray
argument_list|)
expr_stmt|;
block|}
specifier|final
name|boolean
name|hasDifferentFinalExpr
decl_stmt|;
if|if
condition|(
name|varianceNames
operator|.
name|contains
argument_list|(
name|aggregationName
argument_list|)
condition|)
block|{
name|hasDifferentFinalExpr
operator|=
literal|true
expr_stmt|;
block|}
else|else
block|{
switch|switch
condition|(
name|aggregationName
condition|)
block|{
case|case
literal|"avg"
case|:
name|hasDifferentFinalExpr
operator|=
literal|true
expr_stmt|;
break|break;
case|case
literal|"bloom_filter"
case|:
case|case
literal|"count"
case|:
name|hasDifferentFinalExpr
operator|=
literal|true
expr_stmt|;
break|break;
case|case
literal|"max"
case|:
case|case
literal|"min"
case|:
case|case
literal|"sum"
case|:
name|hasDifferentFinalExpr
operator|=
literal|false
expr_stmt|;
break|break;
default|default:
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Unexpected aggregation name "
operator|+
name|aggregationName
argument_list|)
throw|;
block|}
block|}
if|if
condition|(
name|hasDifferentFinalExpr
condition|)
block|{
comment|/*        * FINAL.        */
specifier|final
name|GenericUDAFEvaluator
operator|.
name|Mode
name|mergeUdafEvaluatorMode
init|=
name|GenericUDAFEvaluator
operator|.
name|Mode
operator|.
name|FINAL
decl_stmt|;
name|doMerge
argument_list|(
name|mergeUdafEvaluatorMode
argument_list|,
name|random
argument_list|,
name|aggregationName
argument_list|,
name|typeInfo
argument_list|,
name|keyGenerationSpec
argument_list|,
name|columns
argument_list|,
name|columnNames
argument_list|,
name|dataAggrMaxKeyCount
argument_list|,
name|reductionFactor
argument_list|,
name|partial1OutputTypeInfo
argument_list|,
name|partial1ResultsArray
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_class

end_unit

