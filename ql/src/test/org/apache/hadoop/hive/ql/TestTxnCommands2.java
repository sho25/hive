begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|File
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|reflect
operator|.
name|Field
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Comparator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|TimeUnit
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicBoolean
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FileStatus
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FileSystem
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FileUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|Path
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|common
operator|.
name|FileUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|common
operator|.
name|ValidTxnWriteIdList
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|conf
operator|.
name|HiveConf
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|metastore
operator|.
name|api
operator|.
name|CommitTxnRequest
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|metastore
operator|.
name|api
operator|.
name|CompactionRequest
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|metastore
operator|.
name|api
operator|.
name|CompactionType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|metastore
operator|.
name|api
operator|.
name|MetaException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|metastore
operator|.
name|api
operator|.
name|OpenTxnRequest
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|metastore
operator|.
name|api
operator|.
name|OpenTxnsResponse
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|metastore
operator|.
name|api
operator|.
name|ShowCompactRequest
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|metastore
operator|.
name|api
operator|.
name|ShowCompactResponse
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|metastore
operator|.
name|api
operator|.
name|ShowCompactResponseElement
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|metastore
operator|.
name|txn
operator|.
name|AcidCompactionHistoryService
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|metastore
operator|.
name|txn
operator|.
name|TxnDbUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|metastore
operator|.
name|txn
operator|.
name|TxnStore
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|metastore
operator|.
name|txn
operator|.
name|TxnUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|io
operator|.
name|AcidOutputFormat
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|io
operator|.
name|AcidUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|io
operator|.
name|BucketCodec
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|io
operator|.
name|HiveInputFormat
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|lockmgr
operator|.
name|HiveTxnManager
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|lockmgr
operator|.
name|TxnManagerFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|processors
operator|.
name|CommandProcessorResponse
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|session
operator|.
name|SessionState
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|metastore
operator|.
name|txn
operator|.
name|AcidOpenTxnsCounterService
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|txn
operator|.
name|compactor
operator|.
name|Cleaner
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|txn
operator|.
name|compactor
operator|.
name|CompactorThread
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|txn
operator|.
name|compactor
operator|.
name|Initiator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|txn
operator|.
name|compactor
operator|.
name|Worker
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapred
operator|.
name|JobConf
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|orc
operator|.
name|OrcFile
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|orc
operator|.
name|Reader
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|orc
operator|.
name|TypeDescription
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|After
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|Assert
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|Before
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|Ignore
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|Rule
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|Test
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|rules
operator|.
name|ExpectedException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|rules
operator|.
name|TestName
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_class
specifier|public
class|class
name|TestTxnCommands2
block|{
specifier|static
specifier|final
specifier|private
name|Logger
name|LOG
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|TestTxnCommands2
operator|.
name|class
argument_list|)
decl_stmt|;
specifier|protected
specifier|static
specifier|final
name|String
name|TEST_DATA_DIR
init|=
operator|new
name|File
argument_list|(
name|System
operator|.
name|getProperty
argument_list|(
literal|"java.io.tmpdir"
argument_list|)
operator|+
name|File
operator|.
name|separator
operator|+
name|TestTxnCommands2
operator|.
name|class
operator|.
name|getCanonicalName
argument_list|()
operator|+
literal|"-"
operator|+
name|System
operator|.
name|currentTimeMillis
argument_list|()
argument_list|)
operator|.
name|getPath
argument_list|()
operator|.
name|replaceAll
argument_list|(
literal|"\\\\"
argument_list|,
literal|"/"
argument_list|)
decl_stmt|;
specifier|protected
specifier|static
specifier|final
name|String
name|TEST_WAREHOUSE_DIR
init|=
name|TEST_DATA_DIR
operator|+
literal|"/warehouse"
decl_stmt|;
comment|//bucket count for test tables; set it to 1 for easier debugging
specifier|static
name|int
name|BUCKET_COUNT
init|=
literal|2
decl_stmt|;
annotation|@
name|Rule
specifier|public
name|TestName
name|testName
init|=
operator|new
name|TestName
argument_list|()
decl_stmt|;
specifier|protected
name|HiveConf
name|hiveConf
decl_stmt|;
specifier|protected
name|Driver
name|d
decl_stmt|;
specifier|protected
enum|enum
name|Table
block|{
name|ACIDTBL
argument_list|(
literal|"acidTbl"
argument_list|)
block|,
name|ACIDTBLPART
argument_list|(
literal|"acidTblPart"
argument_list|,
literal|"p"
argument_list|)
block|,
name|NONACIDORCTBL
argument_list|(
literal|"nonAcidOrcTbl"
argument_list|)
block|,
name|NONACIDPART
argument_list|(
literal|"nonAcidPart"
argument_list|,
literal|"p"
argument_list|)
block|,
name|NONACIDPART2
argument_list|(
literal|"nonAcidPart2"
argument_list|,
literal|"p2"
argument_list|)
block|,
name|ACIDNESTEDPART
argument_list|(
literal|"acidNestedPart"
argument_list|,
literal|"p,q"
argument_list|)
block|,
name|MMTBL
argument_list|(
literal|"mmTbl"
argument_list|)
block|;
specifier|private
specifier|final
name|String
name|name
decl_stmt|;
specifier|private
specifier|final
name|String
name|partitionColumns
decl_stmt|;
annotation|@
name|Override
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
name|name
return|;
block|}
name|String
name|getPartitionColumns
parameter_list|()
block|{
return|return
name|partitionColumns
return|;
block|}
name|Table
parameter_list|(
name|String
name|name
parameter_list|)
block|{
name|this
argument_list|(
name|name
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
name|Table
parameter_list|(
name|String
name|name
parameter_list|,
name|String
name|partitionColumns
parameter_list|)
block|{
name|this
operator|.
name|name
operator|=
name|name
expr_stmt|;
name|this
operator|.
name|partitionColumns
operator|=
name|partitionColumns
expr_stmt|;
block|}
block|}
annotation|@
name|Rule
specifier|public
name|ExpectedException
name|expectedException
init|=
name|ExpectedException
operator|.
name|none
argument_list|()
decl_stmt|;
annotation|@
name|Before
specifier|public
name|void
name|setUp
parameter_list|()
throws|throws
name|Exception
block|{
name|setUpWithTableProperties
argument_list|(
literal|"'transactional'='true'"
argument_list|)
expr_stmt|;
block|}
name|void
name|setUpWithTableProperties
parameter_list|(
name|String
name|tableProperties
parameter_list|)
throws|throws
name|Exception
block|{
name|hiveConf
operator|=
operator|new
name|HiveConf
argument_list|(
name|this
operator|.
name|getClass
argument_list|()
argument_list|)
expr_stmt|;
name|Path
name|workDir
init|=
operator|new
name|Path
argument_list|(
name|System
operator|.
name|getProperty
argument_list|(
literal|"test.tmp.dir"
argument_list|,
literal|"target"
operator|+
name|File
operator|.
name|separator
operator|+
literal|"test"
operator|+
name|File
operator|.
name|separator
operator|+
literal|"tmp"
argument_list|)
argument_list|)
decl_stmt|;
name|hiveConf
operator|.
name|set
argument_list|(
literal|"mapred.local.dir"
argument_list|,
name|workDir
operator|+
name|File
operator|.
name|separator
operator|+
name|this
operator|.
name|getClass
argument_list|()
operator|.
name|getSimpleName
argument_list|()
operator|+
name|File
operator|.
name|separator
operator|+
literal|"mapred"
operator|+
name|File
operator|.
name|separator
operator|+
literal|"local"
argument_list|)
expr_stmt|;
name|hiveConf
operator|.
name|set
argument_list|(
literal|"mapred.system.dir"
argument_list|,
name|workDir
operator|+
name|File
operator|.
name|separator
operator|+
name|this
operator|.
name|getClass
argument_list|()
operator|.
name|getSimpleName
argument_list|()
operator|+
name|File
operator|.
name|separator
operator|+
literal|"mapred"
operator|+
name|File
operator|.
name|separator
operator|+
literal|"system"
argument_list|)
expr_stmt|;
name|hiveConf
operator|.
name|set
argument_list|(
literal|"mapreduce.jobtracker.staging.root.dir"
argument_list|,
name|workDir
operator|+
name|File
operator|.
name|separator
operator|+
name|this
operator|.
name|getClass
argument_list|()
operator|.
name|getSimpleName
argument_list|()
operator|+
name|File
operator|.
name|separator
operator|+
literal|"mapred"
operator|+
name|File
operator|.
name|separator
operator|+
literal|"staging"
argument_list|)
expr_stmt|;
name|hiveConf
operator|.
name|set
argument_list|(
literal|"mapred.temp.dir"
argument_list|,
name|workDir
operator|+
name|File
operator|.
name|separator
operator|+
name|this
operator|.
name|getClass
argument_list|()
operator|.
name|getSimpleName
argument_list|()
operator|+
name|File
operator|.
name|separator
operator|+
literal|"mapred"
operator|+
name|File
operator|.
name|separator
operator|+
literal|"temp"
argument_list|)
expr_stmt|;
name|hiveConf
operator|.
name|set
argument_list|(
name|HiveConf
operator|.
name|ConfVars
operator|.
name|PREEXECHOOKS
operator|.
name|varname
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|hiveConf
operator|.
name|set
argument_list|(
name|HiveConf
operator|.
name|ConfVars
operator|.
name|POSTEXECHOOKS
operator|.
name|varname
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|hiveConf
operator|.
name|set
argument_list|(
name|HiveConf
operator|.
name|ConfVars
operator|.
name|METASTOREWAREHOUSE
operator|.
name|varname
argument_list|,
name|TEST_WAREHOUSE_DIR
argument_list|)
expr_stmt|;
name|hiveConf
operator|.
name|setVar
argument_list|(
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVEINPUTFORMAT
argument_list|,
name|HiveInputFormat
operator|.
name|class
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
name|hiveConf
operator|.
name|setVar
argument_list|(
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVE_AUTHORIZATION_MANAGER
argument_list|,
literal|"org.apache.hadoop.hive.ql.security.authorization.plugin.sqlstd.SQLStdHiveAuthorizerFactory"
argument_list|)
expr_stmt|;
name|hiveConf
operator|.
name|setBoolVar
argument_list|(
name|HiveConf
operator|.
name|ConfVars
operator|.
name|MERGE_CARDINALITY_VIOLATION_CHECK
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|hiveConf
operator|.
name|setBoolVar
argument_list|(
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVESTATSCOLAUTOGATHER
argument_list|,
literal|false
argument_list|)
expr_stmt|;
comment|//TestTxnCommands2WithSplitUpdateAndVectorization has the vectorized version
comment|//of these tests.
name|hiveConf
operator|.
name|setBoolVar
argument_list|(
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVE_VECTORIZATION_ENABLED
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|TxnDbUtil
operator|.
name|setConfValues
argument_list|(
name|hiveConf
argument_list|)
expr_stmt|;
name|TxnDbUtil
operator|.
name|prepDb
argument_list|(
name|hiveConf
argument_list|)
expr_stmt|;
name|File
name|f
init|=
operator|new
name|File
argument_list|(
name|TEST_WAREHOUSE_DIR
argument_list|)
decl_stmt|;
if|if
condition|(
name|f
operator|.
name|exists
argument_list|()
condition|)
block|{
name|FileUtil
operator|.
name|fullyDelete
argument_list|(
name|f
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
operator|new
name|File
argument_list|(
name|TEST_WAREHOUSE_DIR
argument_list|)
operator|.
name|mkdirs
argument_list|()
operator|)
condition|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Could not create "
operator|+
name|TEST_WAREHOUSE_DIR
argument_list|)
throw|;
block|}
name|SessionState
name|ss
init|=
name|SessionState
operator|.
name|start
argument_list|(
name|hiveConf
argument_list|)
decl_stmt|;
name|ss
operator|.
name|applyAuthorizationPolicy
argument_list|()
expr_stmt|;
name|d
operator|=
operator|new
name|Driver
argument_list|(
operator|new
name|QueryState
operator|.
name|Builder
argument_list|()
operator|.
name|withHiveConf
argument_list|(
name|hiveConf
argument_list|)
operator|.
name|nonIsolated
argument_list|()
operator|.
name|build
argument_list|()
argument_list|,
literal|null
argument_list|)
expr_stmt|;
name|d
operator|.
name|setMaxRows
argument_list|(
literal|10000
argument_list|)
expr_stmt|;
name|dropTables
argument_list|()
expr_stmt|;
name|runStatementOnDriver
argument_list|(
literal|"create table "
operator|+
name|Table
operator|.
name|ACIDTBL
operator|+
literal|"(a int, b int) clustered by (a) into "
operator|+
name|BUCKET_COUNT
operator|+
literal|" buckets stored as orc TBLPROPERTIES ("
operator|+
name|tableProperties
operator|+
literal|")"
argument_list|)
expr_stmt|;
name|runStatementOnDriver
argument_list|(
literal|"create table "
operator|+
name|Table
operator|.
name|ACIDTBLPART
operator|+
literal|"(a int, b int) partitioned by (p string) clustered by (a) into "
operator|+
name|BUCKET_COUNT
operator|+
literal|" buckets stored as orc TBLPROPERTIES ("
operator|+
name|tableProperties
operator|+
literal|")"
argument_list|)
expr_stmt|;
name|runStatementOnDriver
argument_list|(
literal|"create table "
operator|+
name|Table
operator|.
name|NONACIDORCTBL
operator|+
literal|"(a int, b int) clustered by (a) into "
operator|+
name|BUCKET_COUNT
operator|+
literal|" buckets stored as orc TBLPROPERTIES ('transactional'='false')"
argument_list|)
expr_stmt|;
name|runStatementOnDriver
argument_list|(
literal|"create table "
operator|+
name|Table
operator|.
name|NONACIDPART
operator|+
literal|"(a int, b int) partitioned by (p string) stored as orc TBLPROPERTIES ('transactional'='false')"
argument_list|)
expr_stmt|;
name|runStatementOnDriver
argument_list|(
literal|"create table "
operator|+
name|Table
operator|.
name|NONACIDPART2
operator|+
literal|"(a2 int, b2 int) partitioned by (p2 string) stored as orc TBLPROPERTIES ('transactional'='false')"
argument_list|)
expr_stmt|;
name|runStatementOnDriver
argument_list|(
literal|"create table "
operator|+
name|Table
operator|.
name|ACIDNESTEDPART
operator|+
literal|"(a int, b int) partitioned by (p int, q int) clustered by (a) into "
operator|+
name|BUCKET_COUNT
operator|+
literal|" buckets stored as orc TBLPROPERTIES ("
operator|+
name|tableProperties
operator|+
literal|")"
argument_list|)
expr_stmt|;
name|runStatementOnDriver
argument_list|(
literal|"create table "
operator|+
name|Table
operator|.
name|MMTBL
operator|+
literal|"(a int, b int) TBLPROPERTIES ('transactional'='true', 'transactional_properties'='insert_only')"
argument_list|)
expr_stmt|;
block|}
specifier|protected
name|void
name|dropTables
parameter_list|()
throws|throws
name|Exception
block|{
for|for
control|(
name|Table
name|t
range|:
name|Table
operator|.
name|values
argument_list|()
control|)
block|{
name|runStatementOnDriver
argument_list|(
literal|"drop table if exists "
operator|+
name|t
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|After
specifier|public
name|void
name|tearDown
parameter_list|()
throws|throws
name|Exception
block|{
try|try
block|{
if|if
condition|(
name|d
operator|!=
literal|null
condition|)
block|{
name|dropTables
argument_list|()
expr_stmt|;
name|d
operator|.
name|close
argument_list|()
expr_stmt|;
name|d
operator|.
name|destroy
argument_list|()
expr_stmt|;
name|d
operator|=
literal|null
expr_stmt|;
block|}
name|TxnDbUtil
operator|.
name|cleanDb
argument_list|(
name|hiveConf
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|FileUtils
operator|.
name|deleteDirectory
argument_list|(
operator|new
name|File
argument_list|(
name|TEST_DATA_DIR
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Test
specifier|public
name|void
name|testOrcPPD
parameter_list|()
throws|throws
name|Exception
block|{
name|testOrcPPD
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testOrcNoPPD
parameter_list|()
throws|throws
name|Exception
block|{
name|testOrcPPD
argument_list|(
literal|false
argument_list|)
expr_stmt|;
block|}
comment|/**    * this is run 2 times: 1 with PPD on, 1 with off    * Also, the queries are such that if we were to push predicate down to an update/delete delta,    * the test would produce wrong results    * @param enablePPD    * @throws Exception    */
specifier|private
name|void
name|testOrcPPD
parameter_list|(
name|boolean
name|enablePPD
parameter_list|)
throws|throws
name|Exception
block|{
name|boolean
name|originalPpd
init|=
name|hiveConf
operator|.
name|getBoolVar
argument_list|(
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVEOPTINDEXFILTER
argument_list|)
decl_stmt|;
name|hiveConf
operator|.
name|setBoolVar
argument_list|(
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVEOPTINDEXFILTER
argument_list|,
name|enablePPD
argument_list|)
expr_stmt|;
comment|//enables ORC PPD
comment|//create delta_0001_0001_0000 (should push predicate here)
name|runStatementOnDriver
argument_list|(
literal|"insert into "
operator|+
name|Table
operator|.
name|ACIDTBL
operator|+
literal|"(a,b) "
operator|+
name|makeValuesClause
argument_list|(
operator|new
name|int
index|[]
index|[]
block|{
block|{
literal|1
block|,
literal|2
block|}
block|,
block|{
literal|3
block|,
literal|4
block|}
block|}
argument_list|)
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|explain
decl_stmt|;
name|String
name|query
init|=
literal|"update "
operator|+
name|Table
operator|.
name|ACIDTBL
operator|+
literal|" set b = 5 where a = 3"
decl_stmt|;
if|if
condition|(
name|enablePPD
condition|)
block|{
name|explain
operator|=
name|runStatementOnDriver
argument_list|(
literal|"explain "
operator|+
name|query
argument_list|)
expr_stmt|;
comment|/*       here is a portion of the above "explain".  The "filterExpr:" in the TableScan is the pushed predicate       w/o PPD, the line is simply not there, otherwise the plan is the same        Map Operator Tree:,          TableScan,           alias: acidtbl,           filterExpr: (a = 3) (type: boolean),             Filter Operator,              predicate: (a = 3) (type: boolean),              Select Operator,              ...        */
name|assertExplainHasString
argument_list|(
literal|"filterExpr: (a = 3)"
argument_list|,
name|explain
argument_list|,
literal|"PPD wasn't pushed"
argument_list|)
expr_stmt|;
block|}
comment|//create delta_0002_0002_0000 (can't push predicate)
name|runStatementOnDriver
argument_list|(
name|query
argument_list|)
expr_stmt|;
name|query
operator|=
literal|"select a,b from "
operator|+
name|Table
operator|.
name|ACIDTBL
operator|+
literal|" where b = 4 order by a,b"
expr_stmt|;
if|if
condition|(
name|enablePPD
condition|)
block|{
comment|/*at this point we have 2 delta files, 1 for insert 1 for update       * we should push predicate into 1st one but not 2nd.  If the following 'select' were to       * push into the 'update' delta, we'd filter out {3,5} before doing merge and thus      * produce {3,4} as the value for 2nd row.  The right result is 0-rows.*/
name|explain
operator|=
name|runStatementOnDriver
argument_list|(
literal|"explain "
operator|+
name|query
argument_list|)
expr_stmt|;
name|assertExplainHasString
argument_list|(
literal|"filterExpr: (b = 4)"
argument_list|,
name|explain
argument_list|,
literal|"PPD wasn't pushed"
argument_list|)
expr_stmt|;
block|}
name|List
argument_list|<
name|String
argument_list|>
name|rs0
init|=
name|runStatementOnDriver
argument_list|(
name|query
argument_list|)
decl_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
literal|"Read failed"
argument_list|,
literal|0
argument_list|,
name|rs0
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|runStatementOnDriver
argument_list|(
literal|"alter table "
operator|+
name|Table
operator|.
name|ACIDTBL
operator|+
literal|" compact 'MAJOR'"
argument_list|)
expr_stmt|;
name|runWorker
argument_list|(
name|hiveConf
argument_list|)
expr_stmt|;
comment|//now we have base_0001 file
name|int
index|[]
index|[]
name|tableData2
init|=
block|{
block|{
literal|1
block|,
literal|7
block|}
block|,
block|{
literal|5
block|,
literal|6
block|}
block|,
block|{
literal|7
block|,
literal|8
block|}
block|,
block|{
literal|9
block|,
literal|10
block|}
block|}
decl_stmt|;
name|runStatementOnDriver
argument_list|(
literal|"insert into "
operator|+
name|Table
operator|.
name|ACIDTBL
operator|+
literal|"(a,b) "
operator|+
name|makeValuesClause
argument_list|(
name|tableData2
argument_list|)
argument_list|)
expr_stmt|;
comment|//now we have delta_0003_0003_0000 with inserts only (ok to push predicate)
if|if
condition|(
name|enablePPD
condition|)
block|{
name|explain
operator|=
name|runStatementOnDriver
argument_list|(
literal|"explain delete from "
operator|+
name|Table
operator|.
name|ACIDTBL
operator|+
literal|" where a=7 and b=8"
argument_list|)
expr_stmt|;
name|assertExplainHasString
argument_list|(
literal|"filterExpr: ((a = 7) and (b = 8))"
argument_list|,
name|explain
argument_list|,
literal|"PPD wasn't pushed"
argument_list|)
expr_stmt|;
block|}
name|runStatementOnDriver
argument_list|(
literal|"delete from "
operator|+
name|Table
operator|.
name|ACIDTBL
operator|+
literal|" where a=7 and b=8"
argument_list|)
expr_stmt|;
comment|//now we have delta_0004_0004_0000 with delete events
comment|/*(can't push predicate to 'delete' delta)     * if we were to push to 'delete' delta, we'd filter out all rows since the 'row' is always NULL for     * delete events and we'd produce data as if the delete never happened*/
name|query
operator|=
literal|"select a,b from "
operator|+
name|Table
operator|.
name|ACIDTBL
operator|+
literal|" where a> 1 order by a,b"
expr_stmt|;
if|if
condition|(
name|enablePPD
condition|)
block|{
name|explain
operator|=
name|runStatementOnDriver
argument_list|(
literal|"explain "
operator|+
name|query
argument_list|)
expr_stmt|;
name|assertExplainHasString
argument_list|(
literal|"filterExpr: (a> 1)"
argument_list|,
name|explain
argument_list|,
literal|"PPD wasn't pushed"
argument_list|)
expr_stmt|;
block|}
name|List
argument_list|<
name|String
argument_list|>
name|rs1
init|=
name|runStatementOnDriver
argument_list|(
name|query
argument_list|)
decl_stmt|;
name|int
index|[]
index|[]
name|resultData
init|=
operator|new
name|int
index|[]
index|[]
block|{
block|{
literal|3
block|,
literal|5
block|}
block|,
block|{
literal|5
block|,
literal|6
block|}
block|,
block|{
literal|9
block|,
literal|10
block|}
block|}
decl_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
literal|"Update failed"
argument_list|,
name|stringifyValues
argument_list|(
name|resultData
argument_list|)
argument_list|,
name|rs1
argument_list|)
expr_stmt|;
name|hiveConf
operator|.
name|setBoolVar
argument_list|(
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVEOPTINDEXFILTER
argument_list|,
name|originalPpd
argument_list|)
expr_stmt|;
block|}
specifier|static
name|void
name|assertExplainHasString
parameter_list|(
name|String
name|string
parameter_list|,
name|List
argument_list|<
name|String
argument_list|>
name|queryPlan
parameter_list|,
name|String
name|errMsg
parameter_list|)
block|{
for|for
control|(
name|String
name|line
range|:
name|queryPlan
control|)
block|{
if|if
condition|(
name|line
operator|!=
literal|null
operator|&&
name|line
operator|.
name|contains
argument_list|(
name|string
argument_list|)
condition|)
block|{
return|return;
block|}
block|}
name|Assert
operator|.
name|assertFalse
argument_list|(
name|errMsg
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testAlterTable
parameter_list|()
throws|throws
name|Exception
block|{
name|int
index|[]
index|[]
name|tableData
init|=
block|{
block|{
literal|1
block|,
literal|2
block|}
block|}
decl_stmt|;
name|runStatementOnDriver
argument_list|(
literal|"insert into "
operator|+
name|Table
operator|.
name|ACIDTBL
operator|+
literal|"(a,b) "
operator|+
name|makeValuesClause
argument_list|(
name|tableData
argument_list|)
argument_list|)
expr_stmt|;
name|runStatementOnDriver
argument_list|(
literal|"alter table "
operator|+
name|Table
operator|.
name|ACIDTBL
operator|+
literal|" compact 'MAJOR'"
argument_list|)
expr_stmt|;
name|runWorker
argument_list|(
name|hiveConf
argument_list|)
expr_stmt|;
name|int
index|[]
index|[]
name|tableData2
init|=
block|{
block|{
literal|5
block|,
literal|6
block|}
block|}
decl_stmt|;
name|runStatementOnDriver
argument_list|(
literal|"insert into "
operator|+
name|Table
operator|.
name|ACIDTBL
operator|+
literal|"(a,b) "
operator|+
name|makeValuesClause
argument_list|(
name|tableData2
argument_list|)
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|rs1
init|=
name|runStatementOnDriver
argument_list|(
literal|"select a,b from "
operator|+
name|Table
operator|.
name|ACIDTBL
operator|+
literal|" where b> 0 order by a,b"
argument_list|)
decl_stmt|;
name|runStatementOnDriver
argument_list|(
literal|"alter table "
operator|+
name|Table
operator|.
name|ACIDTBL
operator|+
literal|" add columns(c int)"
argument_list|)
expr_stmt|;
name|int
index|[]
index|[]
name|moreTableData
init|=
block|{
block|{
literal|7
block|,
literal|8
block|,
literal|9
block|}
block|}
decl_stmt|;
name|runStatementOnDriver
argument_list|(
literal|"insert into "
operator|+
name|Table
operator|.
name|ACIDTBL
operator|+
literal|"(a,b,c) "
operator|+
name|makeValuesClause
argument_list|(
name|moreTableData
argument_list|)
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|rs0
init|=
name|runStatementOnDriver
argument_list|(
literal|"select a,b,c from "
operator|+
name|Table
operator|.
name|ACIDTBL
operator|+
literal|" where a> 0 order by a,b,c"
argument_list|)
decl_stmt|;
block|}
comment|//  @Ignore("not needed but useful for testing")
annotation|@
name|Test
specifier|public
name|void
name|testNonAcidInsert
parameter_list|()
throws|throws
name|Exception
block|{
name|runStatementOnDriver
argument_list|(
literal|"insert into "
operator|+
name|Table
operator|.
name|NONACIDORCTBL
operator|+
literal|"(a,b) values(1,2)"
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|rs
init|=
name|runStatementOnDriver
argument_list|(
literal|"select a,b from "
operator|+
name|Table
operator|.
name|NONACIDORCTBL
argument_list|)
decl_stmt|;
name|runStatementOnDriver
argument_list|(
literal|"insert into "
operator|+
name|Table
operator|.
name|NONACIDORCTBL
operator|+
literal|"(a,b) values(2,3)"
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|rs1
init|=
name|runStatementOnDriver
argument_list|(
literal|"select a,b from "
operator|+
name|Table
operator|.
name|NONACIDORCTBL
argument_list|)
decl_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testOriginalFileReaderWhenNonAcidConvertedToAcid
parameter_list|()
throws|throws
name|Exception
block|{
comment|// 1. Insert five rows to Non-ACID table.
name|runStatementOnDriver
argument_list|(
literal|"insert into "
operator|+
name|Table
operator|.
name|NONACIDORCTBL
operator|+
literal|"(a,b) values(1,2),(3,4),(5,6),(7,8),(9,10)"
argument_list|)
expr_stmt|;
comment|// 2. Convert NONACIDORCTBL to ACID table.  //todo: remove trans_prop after HIVE-17089
name|runStatementOnDriver
argument_list|(
literal|"alter table "
operator|+
name|Table
operator|.
name|NONACIDORCTBL
operator|+
literal|" SET TBLPROPERTIES ('transactional'='true', 'transactional_properties'='default')"
argument_list|)
expr_stmt|;
name|runStatementOnDriver
argument_list|(
literal|"update "
operator|+
name|Table
operator|.
name|NONACIDORCTBL
operator|+
literal|" set b = b*2 where b in (4,10)"
argument_list|)
expr_stmt|;
name|runStatementOnDriver
argument_list|(
literal|"delete from "
operator|+
name|Table
operator|.
name|NONACIDORCTBL
operator|+
literal|" where a = 7"
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|rs
init|=
name|runStatementOnDriver
argument_list|(
literal|"select a,b from "
operator|+
name|Table
operator|.
name|NONACIDORCTBL
operator|+
literal|" order by a,b"
argument_list|)
decl_stmt|;
name|int
index|[]
index|[]
name|resultData
init|=
operator|new
name|int
index|[]
index|[]
block|{
block|{
literal|1
block|,
literal|2
block|}
block|,
block|{
literal|3
block|,
literal|8
block|}
block|,
block|{
literal|5
block|,
literal|6
block|}
block|,
block|{
literal|9
block|,
literal|20
block|}
block|}
decl_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
name|stringifyValues
argument_list|(
name|resultData
argument_list|)
argument_list|,
name|rs
argument_list|)
expr_stmt|;
comment|// 3. Perform a major compaction.
name|runStatementOnDriver
argument_list|(
literal|"alter table "
operator|+
name|Table
operator|.
name|NONACIDORCTBL
operator|+
literal|" compact 'MAJOR'"
argument_list|)
expr_stmt|;
name|runWorker
argument_list|(
name|hiveConf
argument_list|)
expr_stmt|;
name|TxnStore
name|txnHandler
init|=
name|TxnUtils
operator|.
name|getTxnStore
argument_list|(
name|hiveConf
argument_list|)
decl_stmt|;
name|ShowCompactResponse
name|resp
init|=
name|txnHandler
operator|.
name|showCompact
argument_list|(
operator|new
name|ShowCompactRequest
argument_list|()
argument_list|)
decl_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
literal|"Unexpected number of compactions in history"
argument_list|,
literal|1
argument_list|,
name|resp
operator|.
name|getCompactsSize
argument_list|()
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
literal|"Unexpected 0 compaction state"
argument_list|,
name|TxnStore
operator|.
name|CLEANING_RESPONSE
argument_list|,
name|resp
operator|.
name|getCompacts
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|getState
argument_list|()
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertTrue
argument_list|(
name|resp
operator|.
name|getCompacts
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|getHadoopJobId
argument_list|()
operator|.
name|startsWith
argument_list|(
literal|"job_local"
argument_list|)
argument_list|)
expr_stmt|;
comment|// 3. Perform a delete.
name|runStatementOnDriver
argument_list|(
literal|"delete from "
operator|+
name|Table
operator|.
name|NONACIDORCTBL
operator|+
literal|" where a = 1"
argument_list|)
expr_stmt|;
name|rs
operator|=
name|runStatementOnDriver
argument_list|(
literal|"select a,b from "
operator|+
name|Table
operator|.
name|NONACIDORCTBL
operator|+
literal|" order by a,b"
argument_list|)
expr_stmt|;
name|resultData
operator|=
operator|new
name|int
index|[]
index|[]
block|{
block|{
literal|3
block|,
literal|8
block|}
block|,
block|{
literal|5
block|,
literal|6
block|}
block|,
block|{
literal|9
block|,
literal|20
block|}
block|}
expr_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
name|stringifyValues
argument_list|(
name|resultData
argument_list|)
argument_list|,
name|rs
argument_list|)
expr_stmt|;
block|}
comment|/**    * see HIVE-16177    * See also {@link TestTxnCommands#testNonAcidToAcidConversion01()}    * {@link TestTxnNoBuckets#testCTAS()}    */
annotation|@
name|Test
specifier|public
name|void
name|testNonAcidToAcidConversion02
parameter_list|()
throws|throws
name|Exception
block|{
comment|//create 2 rows in a file 000001_0 (and an empty 000000_0)
name|runStatementOnDriver
argument_list|(
literal|"insert into "
operator|+
name|Table
operator|.
name|NONACIDORCTBL
operator|+
literal|"(a,b) values(1,2),(1,3)"
argument_list|)
expr_stmt|;
comment|//create 2 rows in a file 000000_0_copy1 and 2 rows in a file 000001_0_copy1
name|runStatementOnDriver
argument_list|(
literal|"insert into "
operator|+
name|Table
operator|.
name|NONACIDORCTBL
operator|+
literal|"(a,b) values(0,12),(0,13),(1,4),(1,5)"
argument_list|)
expr_stmt|;
comment|//create 1 row in a file 000001_0_copy2 (and empty 000000_0_copy2?)
name|runStatementOnDriver
argument_list|(
literal|"insert into "
operator|+
name|Table
operator|.
name|NONACIDORCTBL
operator|+
literal|"(a,b) values(1,6)"
argument_list|)
expr_stmt|;
comment|//convert the table to Acid  //todo: remove trans_prop after HIVE-17089
name|runStatementOnDriver
argument_list|(
literal|"alter table "
operator|+
name|Table
operator|.
name|NONACIDORCTBL
operator|+
literal|" SET TBLPROPERTIES ('transactional'='true', 'transactional_properties'='default')"
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|rs1
init|=
name|runStatementOnDriver
argument_list|(
literal|"describe "
operator|+
name|Table
operator|.
name|NONACIDORCTBL
argument_list|)
decl_stmt|;
comment|//create a some of delta directories
name|runStatementOnDriver
argument_list|(
literal|"insert into "
operator|+
name|Table
operator|.
name|NONACIDORCTBL
operator|+
literal|"(a,b) values(0,15),(1,16)"
argument_list|)
expr_stmt|;
name|runStatementOnDriver
argument_list|(
literal|"update "
operator|+
name|Table
operator|.
name|NONACIDORCTBL
operator|+
literal|" set b = 120 where a = 0 and b = 12"
argument_list|)
expr_stmt|;
name|runStatementOnDriver
argument_list|(
literal|"insert into "
operator|+
name|Table
operator|.
name|NONACIDORCTBL
operator|+
literal|"(a,b) values(0,17)"
argument_list|)
expr_stmt|;
name|runStatementOnDriver
argument_list|(
literal|"delete from "
operator|+
name|Table
operator|.
name|NONACIDORCTBL
operator|+
literal|" where a = 1 and b = 3"
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|rs
init|=
name|runStatementOnDriver
argument_list|(
literal|"select ROW__ID, a, b, INPUT__FILE__NAME from "
operator|+
name|Table
operator|.
name|NONACIDORCTBL
operator|+
literal|" order by a,b"
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|warn
argument_list|(
literal|"before compact"
argument_list|)
expr_stmt|;
for|for
control|(
name|String
name|s
range|:
name|rs
control|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
name|Assert
operator|.
name|assertEquals
argument_list|(
literal|536870912
argument_list|,
name|BucketCodec
operator|.
name|V1
operator|.
name|encode
argument_list|(
operator|new
name|AcidOutputFormat
operator|.
name|Options
argument_list|(
name|hiveConf
argument_list|)
operator|.
name|bucket
argument_list|(
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
literal|536936448
argument_list|,
name|BucketCodec
operator|.
name|V1
operator|.
name|encode
argument_list|(
operator|new
name|AcidOutputFormat
operator|.
name|Options
argument_list|(
name|hiveConf
argument_list|)
operator|.
name|bucket
argument_list|(
literal|1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/*      * All ROW__IDs are unique on read after conversion to acid      * ROW__IDs are exactly the same before and after compaction      * Also check the file name (only) after compaction for completeness      * Note: order of rows in a file ends up being the reverse of order in values clause (why?!)      */
name|String
index|[]
index|[]
name|expected
init|=
block|{
block|{
literal|"{\"writeid\":0,\"bucketid\":536936448,\"rowid\":4}\t0\t13"
block|,
literal|"bucket_00001"
block|}
block|,
block|{
literal|"{\"writeid\":10000001,\"bucketid\":536936448,\"rowid\":1}\t0\t15"
block|,
literal|"bucket_00001"
block|}
block|,
block|{
literal|"{\"writeid\":10000003,\"bucketid\":536936448,\"rowid\":0}\t0\t17"
block|,
literal|"bucket_00001"
block|}
block|,
block|{
literal|"{\"writeid\":10000002,\"bucketid\":536936448,\"rowid\":0}\t0\t120"
block|,
literal|"bucket_00001"
block|}
block|,
block|{
literal|"{\"writeid\":0,\"bucketid\":536936448,\"rowid\":1}\t1\t2"
block|,
literal|"bucket_00001"
block|}
block|,
block|{
literal|"{\"writeid\":0,\"bucketid\":536936448,\"rowid\":3}\t1\t4"
block|,
literal|"bucket_00001"
block|}
block|,
block|{
literal|"{\"writeid\":0,\"bucketid\":536936448,\"rowid\":2}\t1\t5"
block|,
literal|"bucket_00001"
block|}
block|,
block|{
literal|"{\"writeid\":0,\"bucketid\":536936448,\"rowid\":6}\t1\t6"
block|,
literal|"bucket_00001"
block|}
block|,
block|{
literal|"{\"writeid\":10000001,\"bucketid\":536936448,\"rowid\":0}\t1\t16"
block|,
literal|"bucket_00001"
block|}
block|}
decl_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
literal|"Unexpected row count before compaction"
argument_list|,
name|expected
operator|.
name|length
argument_list|,
name|rs
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|expected
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|Assert
operator|.
name|assertTrue
argument_list|(
literal|"Actual line "
operator|+
name|i
operator|+
literal|" bc: "
operator|+
name|rs
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|+
literal|"; expected "
operator|+
name|expected
index|[
name|i
index|]
index|[
literal|0
index|]
argument_list|,
name|rs
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|startsWith
argument_list|(
name|expected
index|[
name|i
index|]
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|//run Compaction
name|runStatementOnDriver
argument_list|(
literal|"alter table "
operator|+
name|TestTxnCommands2
operator|.
name|Table
operator|.
name|NONACIDORCTBL
operator|+
literal|" compact 'major'"
argument_list|)
expr_stmt|;
name|TestTxnCommands2
operator|.
name|runWorker
argument_list|(
name|hiveConf
argument_list|)
expr_stmt|;
name|rs
operator|=
name|runStatementOnDriver
argument_list|(
literal|"select ROW__ID, a, b, INPUT__FILE__NAME from "
operator|+
name|Table
operator|.
name|NONACIDORCTBL
operator|+
literal|" order by a,b"
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|warn
argument_list|(
literal|"after compact"
argument_list|)
expr_stmt|;
for|for
control|(
name|String
name|s
range|:
name|rs
control|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
name|Assert
operator|.
name|assertEquals
argument_list|(
literal|"Unexpected row count after compaction"
argument_list|,
name|expected
operator|.
name|length
argument_list|,
name|rs
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|expected
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|Assert
operator|.
name|assertTrue
argument_list|(
literal|"Actual line "
operator|+
name|i
operator|+
literal|" ac: "
operator|+
name|rs
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|,
name|rs
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|startsWith
argument_list|(
name|expected
index|[
name|i
index|]
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertTrue
argument_list|(
literal|"Actual line(bucket) "
operator|+
name|i
operator|+
literal|" ac: "
operator|+
name|rs
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|,
name|rs
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|endsWith
argument_list|(
name|expected
index|[
name|i
index|]
index|[
literal|1
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|//make sure they are the same before and after compaction
block|}
comment|/**    * In current implementation of ACID, altering the value of transactional_properties or trying to    * set a value for previously unset value for an acid table will throw an exception.    * @throws Exception    */
annotation|@
name|Test
specifier|public
name|void
name|testFailureOnAlteringTransactionalProperties
parameter_list|()
throws|throws
name|Exception
block|{
name|expectedException
operator|.
name|expect
argument_list|(
name|RuntimeException
operator|.
name|class
argument_list|)
expr_stmt|;
name|expectedException
operator|.
name|expectMessage
argument_list|(
literal|"TBLPROPERTIES with 'transactional_properties' cannot be altered after the table is created"
argument_list|)
expr_stmt|;
name|runStatementOnDriver
argument_list|(
literal|"create table acidTblLegacy (a int, b int) clustered by (a) into "
operator|+
name|BUCKET_COUNT
operator|+
literal|" buckets stored as orc TBLPROPERTIES ('transactional'='true')"
argument_list|)
expr_stmt|;
name|runStatementOnDriver
argument_list|(
literal|"alter table acidTblLegacy SET TBLPROPERTIES ('transactional_properties' = 'insert_only')"
argument_list|)
expr_stmt|;
block|}
comment|/**    * Test the query correctness and directory layout for ACID table conversion    * 1. Insert a row to Non-ACID table    * 2. Convert Non-ACID to ACID table    * 3. Insert a row to ACID table    * 4. Perform Major compaction    * 5. Clean    * @throws Exception    */
annotation|@
name|Test
specifier|public
name|void
name|testNonAcidToAcidConversion1
parameter_list|()
throws|throws
name|Exception
block|{
name|FileSystem
name|fs
init|=
name|FileSystem
operator|.
name|get
argument_list|(
name|hiveConf
argument_list|)
decl_stmt|;
name|FileStatus
index|[]
name|status
decl_stmt|;
comment|// 1. Insert a row to Non-ACID table
name|runStatementOnDriver
argument_list|(
literal|"insert into "
operator|+
name|Table
operator|.
name|NONACIDORCTBL
operator|+
literal|"(a,b) values(1,2)"
argument_list|)
expr_stmt|;
name|status
operator|=
name|fs
operator|.
name|listStatus
argument_list|(
operator|new
name|Path
argument_list|(
name|TEST_WAREHOUSE_DIR
operator|+
literal|"/"
operator|+
operator|(
name|Table
operator|.
name|NONACIDORCTBL
operator|)
operator|.
name|toString
argument_list|()
operator|.
name|toLowerCase
argument_list|()
argument_list|)
argument_list|,
name|FileUtils
operator|.
name|HIDDEN_FILES_PATH_FILTER
argument_list|)
expr_stmt|;
comment|// There should be 2 original bucket files in the location (000000_0 and 000001_0)
name|Assert
operator|.
name|assertEquals
argument_list|(
name|BUCKET_COUNT
argument_list|,
name|status
operator|.
name|length
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|status
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|Assert
operator|.
name|assertTrue
argument_list|(
name|status
index|[
name|i
index|]
operator|.
name|getPath
argument_list|()
operator|.
name|getName
argument_list|()
operator|.
name|matches
argument_list|(
literal|"00000[01]_0"
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|List
argument_list|<
name|String
argument_list|>
name|rs
init|=
name|runStatementOnDriver
argument_list|(
literal|"select a,b from "
operator|+
name|Table
operator|.
name|NONACIDORCTBL
argument_list|)
decl_stmt|;
name|int
index|[]
index|[]
name|resultData
init|=
operator|new
name|int
index|[]
index|[]
block|{
block|{
literal|1
block|,
literal|2
block|}
block|}
decl_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
name|stringifyValues
argument_list|(
name|resultData
argument_list|)
argument_list|,
name|rs
argument_list|)
expr_stmt|;
name|rs
operator|=
name|runStatementOnDriver
argument_list|(
literal|"select count(*) from "
operator|+
name|Table
operator|.
name|NONACIDORCTBL
argument_list|)
expr_stmt|;
name|int
name|resultCount
init|=
literal|1
decl_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
name|resultCount
argument_list|,
name|Integer
operator|.
name|parseInt
argument_list|(
name|rs
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|// 2. Convert NONACIDORCTBL to ACID table
name|runStatementOnDriver
argument_list|(
literal|"alter table "
operator|+
name|Table
operator|.
name|NONACIDORCTBL
operator|+
literal|" SET TBLPROPERTIES ('transactional'='true')"
argument_list|)
expr_stmt|;
name|status
operator|=
name|fs
operator|.
name|listStatus
argument_list|(
operator|new
name|Path
argument_list|(
name|TEST_WAREHOUSE_DIR
operator|+
literal|"/"
operator|+
operator|(
name|Table
operator|.
name|NONACIDORCTBL
operator|)
operator|.
name|toString
argument_list|()
operator|.
name|toLowerCase
argument_list|()
argument_list|)
argument_list|,
name|FileUtils
operator|.
name|HIDDEN_FILES_PATH_FILTER
argument_list|)
expr_stmt|;
comment|// Everything should be same as before
name|Assert
operator|.
name|assertEquals
argument_list|(
name|BUCKET_COUNT
argument_list|,
name|status
operator|.
name|length
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|status
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|Assert
operator|.
name|assertTrue
argument_list|(
name|status
index|[
name|i
index|]
operator|.
name|getPath
argument_list|()
operator|.
name|getName
argument_list|()
operator|.
name|matches
argument_list|(
literal|"00000[01]_0"
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|rs
operator|=
name|runStatementOnDriver
argument_list|(
literal|"select a,b from "
operator|+
name|Table
operator|.
name|NONACIDORCTBL
argument_list|)
expr_stmt|;
name|resultData
operator|=
operator|new
name|int
index|[]
index|[]
block|{
block|{
literal|1
block|,
literal|2
block|}
block|}
expr_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
name|stringifyValues
argument_list|(
name|resultData
argument_list|)
argument_list|,
name|rs
argument_list|)
expr_stmt|;
name|rs
operator|=
name|runStatementOnDriver
argument_list|(
literal|"select count(*) from "
operator|+
name|Table
operator|.
name|NONACIDORCTBL
argument_list|)
expr_stmt|;
name|resultCount
operator|=
literal|1
expr_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
name|resultCount
argument_list|,
name|Integer
operator|.
name|parseInt
argument_list|(
name|rs
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|// 3. Insert another row to newly-converted ACID table
name|runStatementOnDriver
argument_list|(
literal|"insert into "
operator|+
name|Table
operator|.
name|NONACIDORCTBL
operator|+
literal|"(a,b) values(3,4)"
argument_list|)
expr_stmt|;
name|status
operator|=
name|fs
operator|.
name|listStatus
argument_list|(
operator|new
name|Path
argument_list|(
name|TEST_WAREHOUSE_DIR
operator|+
literal|"/"
operator|+
operator|(
name|Table
operator|.
name|NONACIDORCTBL
operator|)
operator|.
name|toString
argument_list|()
operator|.
name|toLowerCase
argument_list|()
argument_list|)
argument_list|,
name|FileUtils
operator|.
name|HIDDEN_FILES_PATH_FILTER
argument_list|)
expr_stmt|;
comment|// There should be 2 original bucket files (000000_0 and 000001_0), plus a new delta directory.
comment|// The delta directory should also have only 1 bucket file (bucket_00001)
name|Assert
operator|.
name|assertEquals
argument_list|(
literal|3
argument_list|,
name|status
operator|.
name|length
argument_list|)
expr_stmt|;
name|boolean
name|sawNewDelta
init|=
literal|false
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|status
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|status
index|[
name|i
index|]
operator|.
name|getPath
argument_list|()
operator|.
name|getName
argument_list|()
operator|.
name|matches
argument_list|(
literal|"delta_.*"
argument_list|)
condition|)
block|{
name|sawNewDelta
operator|=
literal|true
expr_stmt|;
name|FileStatus
index|[]
name|buckets
init|=
name|fs
operator|.
name|listStatus
argument_list|(
name|status
index|[
name|i
index|]
operator|.
name|getPath
argument_list|()
argument_list|,
name|FileUtils
operator|.
name|HIDDEN_FILES_PATH_FILTER
argument_list|)
decl_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
literal|1
argument_list|,
name|buckets
operator|.
name|length
argument_list|)
expr_stmt|;
comment|// only one bucket file
name|Assert
operator|.
name|assertTrue
argument_list|(
name|buckets
index|[
literal|0
index|]
operator|.
name|getPath
argument_list|()
operator|.
name|getName
argument_list|()
operator|.
name|matches
argument_list|(
literal|"bucket_00000"
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|Assert
operator|.
name|assertTrue
argument_list|(
name|status
index|[
name|i
index|]
operator|.
name|getPath
argument_list|()
operator|.
name|getName
argument_list|()
operator|.
name|matches
argument_list|(
literal|"00000[01]_0"
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|Assert
operator|.
name|assertTrue
argument_list|(
name|sawNewDelta
argument_list|)
expr_stmt|;
name|rs
operator|=
name|runStatementOnDriver
argument_list|(
literal|"select a,b from "
operator|+
name|Table
operator|.
name|NONACIDORCTBL
operator|+
literal|" order by a,b"
argument_list|)
expr_stmt|;
name|resultData
operator|=
operator|new
name|int
index|[]
index|[]
block|{
block|{
literal|1
block|,
literal|2
block|}
block|,
block|{
literal|3
block|,
literal|4
block|}
block|}
expr_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
name|stringifyValues
argument_list|(
name|resultData
argument_list|)
argument_list|,
name|rs
argument_list|)
expr_stmt|;
name|rs
operator|=
name|runStatementOnDriver
argument_list|(
literal|"select count(*) from "
operator|+
name|Table
operator|.
name|NONACIDORCTBL
argument_list|)
expr_stmt|;
name|resultCount
operator|=
literal|2
expr_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
name|resultCount
argument_list|,
name|Integer
operator|.
name|parseInt
argument_list|(
name|rs
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|// 4. Perform a major compaction
name|runStatementOnDriver
argument_list|(
literal|"alter table "
operator|+
name|Table
operator|.
name|NONACIDORCTBL
operator|+
literal|" compact 'MAJOR'"
argument_list|)
expr_stmt|;
name|runWorker
argument_list|(
name|hiveConf
argument_list|)
expr_stmt|;
comment|// There should be 1 new directory: base_xxxxxxx.
comment|// Original bucket files and delta directory should stay until Cleaner kicks in.
name|status
operator|=
name|fs
operator|.
name|listStatus
argument_list|(
operator|new
name|Path
argument_list|(
name|TEST_WAREHOUSE_DIR
operator|+
literal|"/"
operator|+
operator|(
name|Table
operator|.
name|NONACIDORCTBL
operator|)
operator|.
name|toString
argument_list|()
operator|.
name|toLowerCase
argument_list|()
argument_list|)
argument_list|,
name|FileUtils
operator|.
name|HIDDEN_FILES_PATH_FILTER
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
literal|4
argument_list|,
name|status
operator|.
name|length
argument_list|)
expr_stmt|;
name|boolean
name|sawNewBase
init|=
literal|false
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|status
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|status
index|[
name|i
index|]
operator|.
name|getPath
argument_list|()
operator|.
name|getName
argument_list|()
operator|.
name|matches
argument_list|(
literal|"base_.*"
argument_list|)
condition|)
block|{
name|sawNewBase
operator|=
literal|true
expr_stmt|;
name|FileStatus
index|[]
name|buckets
init|=
name|fs
operator|.
name|listStatus
argument_list|(
name|status
index|[
name|i
index|]
operator|.
name|getPath
argument_list|()
argument_list|,
name|FileUtils
operator|.
name|HIDDEN_FILES_PATH_FILTER
argument_list|)
decl_stmt|;
name|Arrays
operator|.
name|sort
argument_list|(
name|buckets
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
literal|2
argument_list|,
name|buckets
operator|.
name|length
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertTrue
argument_list|(
name|buckets
index|[
literal|0
index|]
operator|.
name|getPath
argument_list|()
operator|.
name|getName
argument_list|()
operator|.
name|matches
argument_list|(
literal|"bucket_0000[01]"
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|Assert
operator|.
name|assertTrue
argument_list|(
name|sawNewBase
argument_list|)
expr_stmt|;
name|rs
operator|=
name|runStatementOnDriver
argument_list|(
literal|"select a,b from "
operator|+
name|Table
operator|.
name|NONACIDORCTBL
argument_list|)
expr_stmt|;
name|resultData
operator|=
operator|new
name|int
index|[]
index|[]
block|{
block|{
literal|3
block|,
literal|4
block|}
block|,
block|{
literal|1
block|,
literal|2
block|}
block|}
expr_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
name|stringifyValuesNoSort
argument_list|(
name|resultData
argument_list|)
argument_list|,
name|rs
argument_list|)
expr_stmt|;
name|rs
operator|=
name|runStatementOnDriver
argument_list|(
literal|"select count(*) from "
operator|+
name|Table
operator|.
name|NONACIDORCTBL
argument_list|)
expr_stmt|;
name|resultCount
operator|=
literal|2
expr_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
name|resultCount
argument_list|,
name|Integer
operator|.
name|parseInt
argument_list|(
name|rs
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|// 5. Let Cleaner delete obsolete files/dirs
comment|// Note, here we create a fake directory along with fake files as original directories/files
name|String
name|fakeFile0
init|=
name|TEST_WAREHOUSE_DIR
operator|+
literal|"/"
operator|+
operator|(
name|Table
operator|.
name|NONACIDORCTBL
operator|)
operator|.
name|toString
argument_list|()
operator|.
name|toLowerCase
argument_list|()
operator|+
literal|"/subdir/000000_0"
decl_stmt|;
name|String
name|fakeFile1
init|=
name|TEST_WAREHOUSE_DIR
operator|+
literal|"/"
operator|+
operator|(
name|Table
operator|.
name|NONACIDORCTBL
operator|)
operator|.
name|toString
argument_list|()
operator|.
name|toLowerCase
argument_list|()
operator|+
literal|"/subdir/000000_1"
decl_stmt|;
name|fs
operator|.
name|create
argument_list|(
operator|new
name|Path
argument_list|(
name|fakeFile0
argument_list|)
argument_list|)
expr_stmt|;
name|fs
operator|.
name|create
argument_list|(
operator|new
name|Path
argument_list|(
name|fakeFile1
argument_list|)
argument_list|)
expr_stmt|;
name|status
operator|=
name|fs
operator|.
name|listStatus
argument_list|(
operator|new
name|Path
argument_list|(
name|TEST_WAREHOUSE_DIR
operator|+
literal|"/"
operator|+
operator|(
name|Table
operator|.
name|NONACIDORCTBL
operator|)
operator|.
name|toString
argument_list|()
operator|.
name|toLowerCase
argument_list|()
argument_list|)
argument_list|,
name|FileUtils
operator|.
name|HIDDEN_FILES_PATH_FILTER
argument_list|)
expr_stmt|;
comment|// Before Cleaner, there should be 5 items:
comment|// 2 original files, 1 original directory, 1 base directory and 1 delta directory
name|Assert
operator|.
name|assertEquals
argument_list|(
literal|5
argument_list|,
name|status
operator|.
name|length
argument_list|)
expr_stmt|;
name|runCleaner
argument_list|(
name|hiveConf
argument_list|)
expr_stmt|;
comment|// There should be only 1 directory left: base_xxxxxxx.
comment|// Original bucket files and delta directory should have been cleaned up.
name|status
operator|=
name|fs
operator|.
name|listStatus
argument_list|(
operator|new
name|Path
argument_list|(
name|TEST_WAREHOUSE_DIR
operator|+
literal|"/"
operator|+
operator|(
name|Table
operator|.
name|NONACIDORCTBL
operator|)
operator|.
name|toString
argument_list|()
operator|.
name|toLowerCase
argument_list|()
argument_list|)
argument_list|,
name|FileUtils
operator|.
name|HIDDEN_FILES_PATH_FILTER
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
literal|1
argument_list|,
name|status
operator|.
name|length
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertTrue
argument_list|(
name|status
index|[
literal|0
index|]
operator|.
name|getPath
argument_list|()
operator|.
name|getName
argument_list|()
operator|.
name|matches
argument_list|(
literal|"base_.*"
argument_list|)
argument_list|)
expr_stmt|;
name|FileStatus
index|[]
name|buckets
init|=
name|fs
operator|.
name|listStatus
argument_list|(
name|status
index|[
literal|0
index|]
operator|.
name|getPath
argument_list|()
argument_list|,
name|FileUtils
operator|.
name|HIDDEN_FILES_PATH_FILTER
argument_list|)
decl_stmt|;
name|Arrays
operator|.
name|sort
argument_list|(
name|buckets
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
literal|2
argument_list|,
name|buckets
operator|.
name|length
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertTrue
argument_list|(
name|buckets
index|[
literal|0
index|]
operator|.
name|getPath
argument_list|()
operator|.
name|getName
argument_list|()
operator|.
name|matches
argument_list|(
literal|"bucket_0000[01]"
argument_list|)
argument_list|)
expr_stmt|;
name|rs
operator|=
name|runStatementOnDriver
argument_list|(
literal|"select a,b from "
operator|+
name|Table
operator|.
name|NONACIDORCTBL
argument_list|)
expr_stmt|;
name|resultData
operator|=
operator|new
name|int
index|[]
index|[]
block|{
block|{
literal|3
block|,
literal|4
block|}
block|,
block|{
literal|1
block|,
literal|2
block|}
block|}
expr_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
name|stringifyValuesNoSort
argument_list|(
name|resultData
argument_list|)
argument_list|,
name|rs
argument_list|)
expr_stmt|;
name|rs
operator|=
name|runStatementOnDriver
argument_list|(
literal|"select count(*) from "
operator|+
name|Table
operator|.
name|NONACIDORCTBL
argument_list|)
expr_stmt|;
name|resultCount
operator|=
literal|2
expr_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
name|resultCount
argument_list|,
name|Integer
operator|.
name|parseInt
argument_list|(
name|rs
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**    * Test the query correctness and directory layout for ACID table conversion    * 1. Insert a row to Non-ACID table    * 2. Convert Non-ACID to ACID table    * 3. Update the existing row in ACID table    * 4. Perform Major compaction    * 5. Clean    * @throws Exception    */
annotation|@
name|Test
specifier|public
name|void
name|testNonAcidToAcidConversion2
parameter_list|()
throws|throws
name|Exception
block|{
name|FileSystem
name|fs
init|=
name|FileSystem
operator|.
name|get
argument_list|(
name|hiveConf
argument_list|)
decl_stmt|;
name|FileStatus
index|[]
name|status
decl_stmt|;
comment|// 1. Insert a row to Non-ACID table
name|runStatementOnDriver
argument_list|(
literal|"insert into "
operator|+
name|Table
operator|.
name|NONACIDORCTBL
operator|+
literal|"(a,b) values(1,2)"
argument_list|)
expr_stmt|;
name|status
operator|=
name|fs
operator|.
name|listStatus
argument_list|(
operator|new
name|Path
argument_list|(
name|TEST_WAREHOUSE_DIR
operator|+
literal|"/"
operator|+
operator|(
name|Table
operator|.
name|NONACIDORCTBL
operator|)
operator|.
name|toString
argument_list|()
operator|.
name|toLowerCase
argument_list|()
argument_list|)
argument_list|,
name|FileUtils
operator|.
name|HIDDEN_FILES_PATH_FILTER
argument_list|)
expr_stmt|;
comment|// There should be 2 original bucket files in the location (000000_0 and 000001_0)
name|Assert
operator|.
name|assertEquals
argument_list|(
name|BUCKET_COUNT
argument_list|,
name|status
operator|.
name|length
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|status
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|Assert
operator|.
name|assertTrue
argument_list|(
name|status
index|[
name|i
index|]
operator|.
name|getPath
argument_list|()
operator|.
name|getName
argument_list|()
operator|.
name|matches
argument_list|(
literal|"00000[01]_0"
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|List
argument_list|<
name|String
argument_list|>
name|rs
init|=
name|runStatementOnDriver
argument_list|(
literal|"select a,b from "
operator|+
name|Table
operator|.
name|NONACIDORCTBL
argument_list|)
decl_stmt|;
name|int
index|[]
index|[]
name|resultData
init|=
operator|new
name|int
index|[]
index|[]
block|{
block|{
literal|1
block|,
literal|2
block|}
block|}
decl_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
name|stringifyValues
argument_list|(
name|resultData
argument_list|)
argument_list|,
name|rs
argument_list|)
expr_stmt|;
name|rs
operator|=
name|runStatementOnDriver
argument_list|(
literal|"select count(*) from "
operator|+
name|Table
operator|.
name|NONACIDORCTBL
argument_list|)
expr_stmt|;
name|int
name|resultCount
init|=
literal|1
decl_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
name|resultCount
argument_list|,
name|Integer
operator|.
name|parseInt
argument_list|(
name|rs
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|// 2. Convert NONACIDORCTBL to ACID table
name|runStatementOnDriver
argument_list|(
literal|"alter table "
operator|+
name|Table
operator|.
name|NONACIDORCTBL
operator|+
literal|" SET TBLPROPERTIES ('transactional'='true')"
argument_list|)
expr_stmt|;
name|status
operator|=
name|fs
operator|.
name|listStatus
argument_list|(
operator|new
name|Path
argument_list|(
name|TEST_WAREHOUSE_DIR
operator|+
literal|"/"
operator|+
operator|(
name|Table
operator|.
name|NONACIDORCTBL
operator|)
operator|.
name|toString
argument_list|()
operator|.
name|toLowerCase
argument_list|()
argument_list|)
argument_list|,
name|FileUtils
operator|.
name|HIDDEN_FILES_PATH_FILTER
argument_list|)
expr_stmt|;
comment|// Everything should be same as before
name|Assert
operator|.
name|assertEquals
argument_list|(
name|BUCKET_COUNT
argument_list|,
name|status
operator|.
name|length
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|status
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|Assert
operator|.
name|assertTrue
argument_list|(
name|status
index|[
name|i
index|]
operator|.
name|getPath
argument_list|()
operator|.
name|getName
argument_list|()
operator|.
name|matches
argument_list|(
literal|"00000[01]_0"
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|rs
operator|=
name|runStatementOnDriver
argument_list|(
literal|"select a,b from "
operator|+
name|Table
operator|.
name|NONACIDORCTBL
argument_list|)
expr_stmt|;
name|resultData
operator|=
operator|new
name|int
index|[]
index|[]
block|{
block|{
literal|1
block|,
literal|2
block|}
block|}
expr_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
name|stringifyValues
argument_list|(
name|resultData
argument_list|)
argument_list|,
name|rs
argument_list|)
expr_stmt|;
name|rs
operator|=
name|runStatementOnDriver
argument_list|(
literal|"select count(*) from "
operator|+
name|Table
operator|.
name|NONACIDORCTBL
argument_list|)
expr_stmt|;
name|resultCount
operator|=
literal|1
expr_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
name|resultCount
argument_list|,
name|Integer
operator|.
name|parseInt
argument_list|(
name|rs
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|// 3. Update the existing row in newly-converted ACID table
name|runStatementOnDriver
argument_list|(
literal|"update "
operator|+
name|Table
operator|.
name|NONACIDORCTBL
operator|+
literal|" set b=3 where a=1"
argument_list|)
expr_stmt|;
name|status
operator|=
name|fs
operator|.
name|listStatus
argument_list|(
operator|new
name|Path
argument_list|(
name|TEST_WAREHOUSE_DIR
operator|+
literal|"/"
operator|+
operator|(
name|Table
operator|.
name|NONACIDORCTBL
operator|)
operator|.
name|toString
argument_list|()
operator|.
name|toLowerCase
argument_list|()
argument_list|)
argument_list|,
name|FileUtils
operator|.
name|HIDDEN_FILES_PATH_FILTER
argument_list|)
expr_stmt|;
comment|// There should be 2 original bucket files (000000_0 and 000001_0), plus one delta directory
comment|// and one delete_delta directory. When split-update is enabled, an update event is split into
comment|// a combination of delete and insert, that generates the delete_delta directory.
comment|// The delta directory should also have 2 bucket files (bucket_00000 and bucket_00001)
comment|// and so should the delete_delta directory.
name|Assert
operator|.
name|assertEquals
argument_list|(
literal|4
argument_list|,
name|status
operator|.
name|length
argument_list|)
expr_stmt|;
name|boolean
name|sawNewDelta
init|=
literal|false
decl_stmt|;
name|boolean
name|sawNewDeleteDelta
init|=
literal|false
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|status
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|status
index|[
name|i
index|]
operator|.
name|getPath
argument_list|()
operator|.
name|getName
argument_list|()
operator|.
name|matches
argument_list|(
literal|"delta_.*"
argument_list|)
condition|)
block|{
name|sawNewDelta
operator|=
literal|true
expr_stmt|;
name|FileStatus
index|[]
name|buckets
init|=
name|fs
operator|.
name|listStatus
argument_list|(
name|status
index|[
name|i
index|]
operator|.
name|getPath
argument_list|()
argument_list|,
name|FileUtils
operator|.
name|HIDDEN_FILES_PATH_FILTER
argument_list|)
decl_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
name|BUCKET_COUNT
operator|-
literal|1
argument_list|,
name|buckets
operator|.
name|length
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertTrue
argument_list|(
name|buckets
index|[
literal|0
index|]
operator|.
name|getPath
argument_list|()
operator|.
name|getName
argument_list|()
operator|.
name|matches
argument_list|(
literal|"bucket_0000[01]"
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|status
index|[
name|i
index|]
operator|.
name|getPath
argument_list|()
operator|.
name|getName
argument_list|()
operator|.
name|matches
argument_list|(
literal|"delete_delta_.*"
argument_list|)
condition|)
block|{
name|sawNewDeleteDelta
operator|=
literal|true
expr_stmt|;
name|FileStatus
index|[]
name|buckets
init|=
name|fs
operator|.
name|listStatus
argument_list|(
name|status
index|[
name|i
index|]
operator|.
name|getPath
argument_list|()
argument_list|,
name|FileUtils
operator|.
name|HIDDEN_FILES_PATH_FILTER
argument_list|)
decl_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
name|BUCKET_COUNT
operator|-
literal|1
argument_list|,
name|buckets
operator|.
name|length
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertTrue
argument_list|(
name|buckets
index|[
literal|0
index|]
operator|.
name|getPath
argument_list|()
operator|.
name|getName
argument_list|()
operator|.
name|matches
argument_list|(
literal|"bucket_0000[01]"
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|Assert
operator|.
name|assertTrue
argument_list|(
name|status
index|[
name|i
index|]
operator|.
name|getPath
argument_list|()
operator|.
name|getName
argument_list|()
operator|.
name|matches
argument_list|(
literal|"00000[01]_0"
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|Assert
operator|.
name|assertTrue
argument_list|(
name|sawNewDelta
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertTrue
argument_list|(
name|sawNewDeleteDelta
argument_list|)
expr_stmt|;
name|rs
operator|=
name|runStatementOnDriver
argument_list|(
literal|"select a,b from "
operator|+
name|Table
operator|.
name|NONACIDORCTBL
argument_list|)
expr_stmt|;
name|resultData
operator|=
operator|new
name|int
index|[]
index|[]
block|{
block|{
literal|1
block|,
literal|3
block|}
block|}
expr_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
name|stringifyValues
argument_list|(
name|resultData
argument_list|)
argument_list|,
name|rs
argument_list|)
expr_stmt|;
name|rs
operator|=
name|runStatementOnDriver
argument_list|(
literal|"select count(*) from "
operator|+
name|Table
operator|.
name|NONACIDORCTBL
argument_list|)
expr_stmt|;
name|resultCount
operator|=
literal|1
expr_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
name|resultCount
argument_list|,
name|Integer
operator|.
name|parseInt
argument_list|(
name|rs
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|// 4. Perform a major compaction
name|runStatementOnDriver
argument_list|(
literal|"alter table "
operator|+
name|Table
operator|.
name|NONACIDORCTBL
operator|+
literal|" compact 'MAJOR'"
argument_list|)
expr_stmt|;
name|runWorker
argument_list|(
name|hiveConf
argument_list|)
expr_stmt|;
comment|// There should be 1 new directory: base_0000001.
comment|// Original bucket files and delta directory should stay until Cleaner kicks in.
name|status
operator|=
name|fs
operator|.
name|listStatus
argument_list|(
operator|new
name|Path
argument_list|(
name|TEST_WAREHOUSE_DIR
operator|+
literal|"/"
operator|+
operator|(
name|Table
operator|.
name|NONACIDORCTBL
operator|)
operator|.
name|toString
argument_list|()
operator|.
name|toLowerCase
argument_list|()
argument_list|)
argument_list|,
name|FileUtils
operator|.
name|HIDDEN_FILES_PATH_FILTER
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
literal|5
argument_list|,
name|status
operator|.
name|length
argument_list|)
expr_stmt|;
name|boolean
name|sawNewBase
init|=
literal|false
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|status
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|status
index|[
name|i
index|]
operator|.
name|getPath
argument_list|()
operator|.
name|getName
argument_list|()
operator|.
name|matches
argument_list|(
literal|"base_.*"
argument_list|)
condition|)
block|{
name|sawNewBase
operator|=
literal|true
expr_stmt|;
name|FileStatus
index|[]
name|buckets
init|=
name|fs
operator|.
name|listStatus
argument_list|(
name|status
index|[
name|i
index|]
operator|.
name|getPath
argument_list|()
argument_list|,
name|FileUtils
operator|.
name|HIDDEN_FILES_PATH_FILTER
argument_list|)
decl_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
name|BUCKET_COUNT
operator|-
literal|1
argument_list|,
name|buckets
operator|.
name|length
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertTrue
argument_list|(
name|buckets
index|[
literal|0
index|]
operator|.
name|getPath
argument_list|()
operator|.
name|getName
argument_list|()
operator|.
name|matches
argument_list|(
literal|"bucket_00001"
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|Assert
operator|.
name|assertTrue
argument_list|(
name|sawNewBase
argument_list|)
expr_stmt|;
name|rs
operator|=
name|runStatementOnDriver
argument_list|(
literal|"select a,b from "
operator|+
name|Table
operator|.
name|NONACIDORCTBL
argument_list|)
expr_stmt|;
name|resultData
operator|=
operator|new
name|int
index|[]
index|[]
block|{
block|{
literal|1
block|,
literal|3
block|}
block|}
expr_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
name|stringifyValues
argument_list|(
name|resultData
argument_list|)
argument_list|,
name|rs
argument_list|)
expr_stmt|;
name|rs
operator|=
name|runStatementOnDriver
argument_list|(
literal|"select count(*) from "
operator|+
name|Table
operator|.
name|NONACIDORCTBL
argument_list|)
expr_stmt|;
name|resultCount
operator|=
literal|1
expr_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
name|resultCount
argument_list|,
name|Integer
operator|.
name|parseInt
argument_list|(
name|rs
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|// 5. Let Cleaner delete obsolete files/dirs
name|status
operator|=
name|fs
operator|.
name|listStatus
argument_list|(
operator|new
name|Path
argument_list|(
name|TEST_WAREHOUSE_DIR
operator|+
literal|"/"
operator|+
operator|(
name|Table
operator|.
name|NONACIDORCTBL
operator|)
operator|.
name|toString
argument_list|()
operator|.
name|toLowerCase
argument_list|()
argument_list|)
argument_list|,
name|FileUtils
operator|.
name|HIDDEN_FILES_PATH_FILTER
argument_list|)
expr_stmt|;
comment|// Before Cleaner, there should be 5 items:
comment|// 2 original files, 1 delta directory, 1 delete_delta directory and 1 base directory
name|Assert
operator|.
name|assertEquals
argument_list|(
literal|5
argument_list|,
name|status
operator|.
name|length
argument_list|)
expr_stmt|;
name|runCleaner
argument_list|(
name|hiveConf
argument_list|)
expr_stmt|;
comment|// There should be only 1 directory left: base_0000001.
comment|// Original bucket files, delta directory and delete_delta should have been cleaned up.
name|status
operator|=
name|fs
operator|.
name|listStatus
argument_list|(
operator|new
name|Path
argument_list|(
name|TEST_WAREHOUSE_DIR
operator|+
literal|"/"
operator|+
operator|(
name|Table
operator|.
name|NONACIDORCTBL
operator|)
operator|.
name|toString
argument_list|()
operator|.
name|toLowerCase
argument_list|()
argument_list|)
argument_list|,
name|FileUtils
operator|.
name|HIDDEN_FILES_PATH_FILTER
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
literal|1
argument_list|,
name|status
operator|.
name|length
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertTrue
argument_list|(
name|status
index|[
literal|0
index|]
operator|.
name|getPath
argument_list|()
operator|.
name|getName
argument_list|()
operator|.
name|matches
argument_list|(
literal|"base_.*"
argument_list|)
argument_list|)
expr_stmt|;
name|FileStatus
index|[]
name|buckets
init|=
name|fs
operator|.
name|listStatus
argument_list|(
name|status
index|[
literal|0
index|]
operator|.
name|getPath
argument_list|()
argument_list|,
name|FileUtils
operator|.
name|HIDDEN_FILES_PATH_FILTER
argument_list|)
decl_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
name|BUCKET_COUNT
operator|-
literal|1
argument_list|,
name|buckets
operator|.
name|length
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertTrue
argument_list|(
name|buckets
index|[
literal|0
index|]
operator|.
name|getPath
argument_list|()
operator|.
name|getName
argument_list|()
operator|.
name|matches
argument_list|(
literal|"bucket_00001"
argument_list|)
argument_list|)
expr_stmt|;
name|rs
operator|=
name|runStatementOnDriver
argument_list|(
literal|"select a,b from "
operator|+
name|Table
operator|.
name|NONACIDORCTBL
argument_list|)
expr_stmt|;
name|resultData
operator|=
operator|new
name|int
index|[]
index|[]
block|{
block|{
literal|1
block|,
literal|3
block|}
block|}
expr_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
name|stringifyValues
argument_list|(
name|resultData
argument_list|)
argument_list|,
name|rs
argument_list|)
expr_stmt|;
name|rs
operator|=
name|runStatementOnDriver
argument_list|(
literal|"select count(*) from "
operator|+
name|Table
operator|.
name|NONACIDORCTBL
argument_list|)
expr_stmt|;
name|resultCount
operator|=
literal|1
expr_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
name|resultCount
argument_list|,
name|Integer
operator|.
name|parseInt
argument_list|(
name|rs
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**    * Test the query correctness and directory layout for ACID table conversion    * 1. Insert a row to Non-ACID table    * 2. Convert Non-ACID to ACID table    * 3. Perform Major compaction    * 4. Insert a new row to ACID table    * 5. Perform another Major compaction    * 6. Clean    * @throws Exception    */
annotation|@
name|Test
specifier|public
name|void
name|testNonAcidToAcidConversion3
parameter_list|()
throws|throws
name|Exception
block|{
name|FileSystem
name|fs
init|=
name|FileSystem
operator|.
name|get
argument_list|(
name|hiveConf
argument_list|)
decl_stmt|;
name|FileStatus
index|[]
name|status
decl_stmt|;
comment|// 1. Insert a row to Non-ACID table
name|runStatementOnDriver
argument_list|(
literal|"insert into "
operator|+
name|Table
operator|.
name|NONACIDORCTBL
operator|+
literal|"(a,b) values(1,2)"
argument_list|)
expr_stmt|;
name|status
operator|=
name|fs
operator|.
name|listStatus
argument_list|(
operator|new
name|Path
argument_list|(
name|TEST_WAREHOUSE_DIR
operator|+
literal|"/"
operator|+
operator|(
name|Table
operator|.
name|NONACIDORCTBL
operator|)
operator|.
name|toString
argument_list|()
operator|.
name|toLowerCase
argument_list|()
argument_list|)
argument_list|,
name|FileUtils
operator|.
name|HIDDEN_FILES_PATH_FILTER
argument_list|)
expr_stmt|;
comment|// There should be 2 original bucket files in the location (000000_0 and 000001_0)
name|Assert
operator|.
name|assertEquals
argument_list|(
name|BUCKET_COUNT
argument_list|,
name|status
operator|.
name|length
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|status
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|Assert
operator|.
name|assertTrue
argument_list|(
name|status
index|[
name|i
index|]
operator|.
name|getPath
argument_list|()
operator|.
name|getName
argument_list|()
operator|.
name|matches
argument_list|(
literal|"00000[01]_0"
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|List
argument_list|<
name|String
argument_list|>
name|rs
init|=
name|runStatementOnDriver
argument_list|(
literal|"select a,b from "
operator|+
name|Table
operator|.
name|NONACIDORCTBL
argument_list|)
decl_stmt|;
name|int
index|[]
index|[]
name|resultData
init|=
operator|new
name|int
index|[]
index|[]
block|{
block|{
literal|1
block|,
literal|2
block|}
block|}
decl_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
name|stringifyValues
argument_list|(
name|resultData
argument_list|)
argument_list|,
name|rs
argument_list|)
expr_stmt|;
name|rs
operator|=
name|runStatementOnDriver
argument_list|(
literal|"select count(*) from "
operator|+
name|Table
operator|.
name|NONACIDORCTBL
argument_list|)
expr_stmt|;
name|int
name|resultCount
init|=
literal|1
decl_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
name|resultCount
argument_list|,
name|Integer
operator|.
name|parseInt
argument_list|(
name|rs
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|// 2. Convert NONACIDORCTBL to ACID table
name|runStatementOnDriver
argument_list|(
literal|"alter table "
operator|+
name|Table
operator|.
name|NONACIDORCTBL
operator|+
literal|" SET TBLPROPERTIES ('transactional'='true')"
argument_list|)
expr_stmt|;
name|status
operator|=
name|fs
operator|.
name|listStatus
argument_list|(
operator|new
name|Path
argument_list|(
name|TEST_WAREHOUSE_DIR
operator|+
literal|"/"
operator|+
operator|(
name|Table
operator|.
name|NONACIDORCTBL
operator|)
operator|.
name|toString
argument_list|()
operator|.
name|toLowerCase
argument_list|()
argument_list|)
argument_list|,
name|FileUtils
operator|.
name|HIDDEN_FILES_PATH_FILTER
argument_list|)
expr_stmt|;
comment|// Everything should be same as before
name|Assert
operator|.
name|assertEquals
argument_list|(
name|BUCKET_COUNT
argument_list|,
name|status
operator|.
name|length
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|status
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|Assert
operator|.
name|assertTrue
argument_list|(
name|status
index|[
name|i
index|]
operator|.
name|getPath
argument_list|()
operator|.
name|getName
argument_list|()
operator|.
name|matches
argument_list|(
literal|"00000[01]_0"
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|rs
operator|=
name|runStatementOnDriver
argument_list|(
literal|"select a,b from "
operator|+
name|Table
operator|.
name|NONACIDORCTBL
argument_list|)
expr_stmt|;
name|resultData
operator|=
operator|new
name|int
index|[]
index|[]
block|{
block|{
literal|1
block|,
literal|2
block|}
block|}
expr_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
name|stringifyValues
argument_list|(
name|resultData
argument_list|)
argument_list|,
name|rs
argument_list|)
expr_stmt|;
name|rs
operator|=
name|runStatementOnDriver
argument_list|(
literal|"select count(*) from "
operator|+
name|Table
operator|.
name|NONACIDORCTBL
argument_list|)
expr_stmt|;
name|resultCount
operator|=
literal|1
expr_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
name|resultCount
argument_list|,
name|Integer
operator|.
name|parseInt
argument_list|(
name|rs
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|// 3. Perform a major compaction
name|runStatementOnDriver
argument_list|(
literal|"alter table "
operator|+
name|Table
operator|.
name|NONACIDORCTBL
operator|+
literal|" compact 'MAJOR'"
argument_list|)
expr_stmt|;
name|runWorker
argument_list|(
name|hiveConf
argument_list|)
expr_stmt|;
comment|// There should be 1 new directory: base_-9223372036854775808
comment|// Original bucket files should stay until Cleaner kicks in.
name|status
operator|=
name|fs
operator|.
name|listStatus
argument_list|(
operator|new
name|Path
argument_list|(
name|TEST_WAREHOUSE_DIR
operator|+
literal|"/"
operator|+
operator|(
name|Table
operator|.
name|NONACIDORCTBL
operator|)
operator|.
name|toString
argument_list|()
operator|.
name|toLowerCase
argument_list|()
argument_list|)
argument_list|,
name|FileUtils
operator|.
name|HIDDEN_FILES_PATH_FILTER
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
literal|3
argument_list|,
name|status
operator|.
name|length
argument_list|)
expr_stmt|;
name|boolean
name|sawNewBase
init|=
literal|false
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|status
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|status
index|[
name|i
index|]
operator|.
name|getPath
argument_list|()
operator|.
name|getName
argument_list|()
operator|.
name|matches
argument_list|(
literal|"base_.*"
argument_list|)
condition|)
block|{
comment|//should be base_-9223372036854775808_v0000022 but 22 is a txn id not write id so it makes
comment|//the tests fragile
name|Assert
operator|.
name|assertTrue
argument_list|(
name|status
index|[
name|i
index|]
operator|.
name|getPath
argument_list|()
operator|.
name|getName
argument_list|()
operator|.
name|startsWith
argument_list|(
literal|"base_-9223372036854775808_v0000022"
argument_list|)
argument_list|)
expr_stmt|;
name|sawNewBase
operator|=
literal|true
expr_stmt|;
name|FileStatus
index|[]
name|buckets
init|=
name|fs
operator|.
name|listStatus
argument_list|(
name|status
index|[
name|i
index|]
operator|.
name|getPath
argument_list|()
argument_list|,
name|FileUtils
operator|.
name|HIDDEN_FILES_PATH_FILTER
argument_list|)
decl_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
name|BUCKET_COUNT
operator|-
literal|1
argument_list|,
name|buckets
operator|.
name|length
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
literal|"bucket_00001"
argument_list|,
name|buckets
index|[
literal|0
index|]
operator|.
name|getPath
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
name|Assert
operator|.
name|assertTrue
argument_list|(
name|sawNewBase
argument_list|)
expr_stmt|;
name|rs
operator|=
name|runStatementOnDriver
argument_list|(
literal|"select a,b from "
operator|+
name|Table
operator|.
name|NONACIDORCTBL
argument_list|)
expr_stmt|;
name|resultData
operator|=
operator|new
name|int
index|[]
index|[]
block|{
block|{
literal|1
block|,
literal|2
block|}
block|}
expr_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
name|stringifyValues
argument_list|(
name|resultData
argument_list|)
argument_list|,
name|rs
argument_list|)
expr_stmt|;
name|rs
operator|=
name|runStatementOnDriver
argument_list|(
literal|"select count(*) from "
operator|+
name|Table
operator|.
name|NONACIDORCTBL
argument_list|)
expr_stmt|;
name|resultCount
operator|=
literal|1
expr_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
name|resultCount
argument_list|,
name|Integer
operator|.
name|parseInt
argument_list|(
name|rs
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|// 4. Update the existing row, and insert another row to newly-converted ACID table
name|runStatementOnDriver
argument_list|(
literal|"update "
operator|+
name|Table
operator|.
name|NONACIDORCTBL
operator|+
literal|" set b=3 where a=1"
argument_list|)
expr_stmt|;
name|runStatementOnDriver
argument_list|(
literal|"insert into "
operator|+
name|Table
operator|.
name|NONACIDORCTBL
operator|+
literal|"(a,b) values(3,4)"
argument_list|)
expr_stmt|;
name|status
operator|=
name|fs
operator|.
name|listStatus
argument_list|(
operator|new
name|Path
argument_list|(
name|TEST_WAREHOUSE_DIR
operator|+
literal|"/"
operator|+
operator|(
name|Table
operator|.
name|NONACIDORCTBL
operator|)
operator|.
name|toString
argument_list|()
operator|.
name|toLowerCase
argument_list|()
argument_list|)
argument_list|,
name|FileUtils
operator|.
name|HIDDEN_FILES_PATH_FILTER
argument_list|)
expr_stmt|;
name|Arrays
operator|.
name|sort
argument_list|(
name|status
argument_list|)
expr_stmt|;
comment|// make sure delta_0000001_0000001_0000 appears before delta_0000002_0000002_0000
comment|// There should be 2 original bucket files (000000_0 and 000001_0), a base directory,
comment|// plus two new delta directories and one delete_delta directory that would be created due to
comment|// the update statement (remember split-update U=D+I)!
name|Assert
operator|.
name|assertEquals
argument_list|(
literal|6
argument_list|,
name|status
operator|.
name|length
argument_list|)
expr_stmt|;
name|int
name|numDelta
init|=
literal|0
decl_stmt|;
name|int
name|numDeleteDelta
init|=
literal|0
decl_stmt|;
name|sawNewBase
operator|=
literal|false
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|status
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|status
index|[
name|i
index|]
operator|.
name|getPath
argument_list|()
operator|.
name|getName
argument_list|()
operator|.
name|matches
argument_list|(
literal|"delta_.*"
argument_list|)
condition|)
block|{
name|numDelta
operator|++
expr_stmt|;
name|FileStatus
index|[]
name|buckets
init|=
name|fs
operator|.
name|listStatus
argument_list|(
name|status
index|[
name|i
index|]
operator|.
name|getPath
argument_list|()
argument_list|,
name|FileUtils
operator|.
name|HIDDEN_FILES_PATH_FILTER
argument_list|)
decl_stmt|;
name|Arrays
operator|.
name|sort
argument_list|(
name|buckets
argument_list|)
expr_stmt|;
if|if
condition|(
name|numDelta
operator|==
literal|1
condition|)
block|{
name|Assert
operator|.
name|assertEquals
argument_list|(
literal|"delta_10000001_10000001_0000"
argument_list|,
name|status
index|[
name|i
index|]
operator|.
name|getPath
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
name|BUCKET_COUNT
operator|-
literal|1
argument_list|,
name|buckets
operator|.
name|length
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
literal|"bucket_00001"
argument_list|,
name|buckets
index|[
literal|0
index|]
operator|.
name|getPath
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|numDelta
operator|==
literal|2
condition|)
block|{
name|Assert
operator|.
name|assertEquals
argument_list|(
literal|"delta_10000002_10000002_0000"
argument_list|,
name|status
index|[
name|i
index|]
operator|.
name|getPath
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
literal|1
argument_list|,
name|buckets
operator|.
name|length
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
literal|"bucket_00000"
argument_list|,
name|buckets
index|[
literal|0
index|]
operator|.
name|getPath
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|status
index|[
name|i
index|]
operator|.
name|getPath
argument_list|()
operator|.
name|getName
argument_list|()
operator|.
name|matches
argument_list|(
literal|"delete_delta_.*"
argument_list|)
condition|)
block|{
name|numDeleteDelta
operator|++
expr_stmt|;
name|FileStatus
index|[]
name|buckets
init|=
name|fs
operator|.
name|listStatus
argument_list|(
name|status
index|[
name|i
index|]
operator|.
name|getPath
argument_list|()
argument_list|,
name|FileUtils
operator|.
name|HIDDEN_FILES_PATH_FILTER
argument_list|)
decl_stmt|;
name|Arrays
operator|.
name|sort
argument_list|(
name|buckets
argument_list|)
expr_stmt|;
if|if
condition|(
name|numDeleteDelta
operator|==
literal|1
condition|)
block|{
name|Assert
operator|.
name|assertEquals
argument_list|(
literal|"delete_delta_10000001_10000001_0000"
argument_list|,
name|status
index|[
name|i
index|]
operator|.
name|getPath
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
name|BUCKET_COUNT
operator|-
literal|1
argument_list|,
name|buckets
operator|.
name|length
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
literal|"bucket_00001"
argument_list|,
name|buckets
index|[
literal|0
index|]
operator|.
name|getPath
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|status
index|[
name|i
index|]
operator|.
name|getPath
argument_list|()
operator|.
name|getName
argument_list|()
operator|.
name|matches
argument_list|(
literal|"base_.*"
argument_list|)
condition|)
block|{
name|Assert
operator|.
name|assertTrue
argument_list|(
literal|"base_-9223372036854775808"
argument_list|,
name|status
index|[
name|i
index|]
operator|.
name|getPath
argument_list|()
operator|.
name|getName
argument_list|()
operator|.
name|startsWith
argument_list|(
literal|"base_-9223372036854775808_v0000022"
argument_list|)
argument_list|)
expr_stmt|;
comment|//_v0000022
name|sawNewBase
operator|=
literal|true
expr_stmt|;
name|FileStatus
index|[]
name|buckets
init|=
name|fs
operator|.
name|listStatus
argument_list|(
name|status
index|[
name|i
index|]
operator|.
name|getPath
argument_list|()
argument_list|,
name|FileUtils
operator|.
name|HIDDEN_FILES_PATH_FILTER
argument_list|)
decl_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
name|BUCKET_COUNT
operator|-
literal|1
argument_list|,
name|buckets
operator|.
name|length
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
literal|"bucket_00001"
argument_list|,
name|buckets
index|[
literal|0
index|]
operator|.
name|getPath
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|Assert
operator|.
name|assertTrue
argument_list|(
name|status
index|[
name|i
index|]
operator|.
name|getPath
argument_list|()
operator|.
name|getName
argument_list|()
operator|.
name|matches
argument_list|(
literal|"00000[01]_0"
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|Assert
operator|.
name|assertEquals
argument_list|(
literal|2
argument_list|,
name|numDelta
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
literal|1
argument_list|,
name|numDeleteDelta
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertTrue
argument_list|(
name|sawNewBase
argument_list|)
expr_stmt|;
name|rs
operator|=
name|runStatementOnDriver
argument_list|(
literal|"select a,b from "
operator|+
name|Table
operator|.
name|NONACIDORCTBL
argument_list|)
expr_stmt|;
name|resultData
operator|=
operator|new
name|int
index|[]
index|[]
block|{
block|{
literal|1
block|,
literal|3
block|}
block|,
block|{
literal|3
block|,
literal|4
block|}
block|}
expr_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
name|stringifyValues
argument_list|(
name|resultData
argument_list|)
argument_list|,
name|rs
argument_list|)
expr_stmt|;
name|rs
operator|=
name|runStatementOnDriver
argument_list|(
literal|"select count(*) from "
operator|+
name|Table
operator|.
name|NONACIDORCTBL
argument_list|)
expr_stmt|;
name|resultCount
operator|=
literal|2
expr_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
name|resultCount
argument_list|,
name|Integer
operator|.
name|parseInt
argument_list|(
name|rs
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|// 5. Perform another major compaction
name|runStatementOnDriver
argument_list|(
literal|"alter table "
operator|+
name|Table
operator|.
name|NONACIDORCTBL
operator|+
literal|" compact 'MAJOR'"
argument_list|)
expr_stmt|;
name|runWorker
argument_list|(
name|hiveConf
argument_list|)
expr_stmt|;
comment|// There should be 1 new base directory: base_0000001
comment|// Original bucket files, delta directories, delete_delta directories and the
comment|// previous base directory should stay until Cleaner kicks in.
name|status
operator|=
name|fs
operator|.
name|listStatus
argument_list|(
operator|new
name|Path
argument_list|(
name|TEST_WAREHOUSE_DIR
operator|+
literal|"/"
operator|+
operator|(
name|Table
operator|.
name|NONACIDORCTBL
operator|)
operator|.
name|toString
argument_list|()
operator|.
name|toLowerCase
argument_list|()
argument_list|)
argument_list|,
name|FileUtils
operator|.
name|HIDDEN_FILES_PATH_FILTER
argument_list|)
expr_stmt|;
name|Arrays
operator|.
name|sort
argument_list|(
name|status
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
literal|7
argument_list|,
name|status
operator|.
name|length
argument_list|)
expr_stmt|;
name|int
name|numBase
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|status
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|status
index|[
name|i
index|]
operator|.
name|getPath
argument_list|()
operator|.
name|getName
argument_list|()
operator|.
name|matches
argument_list|(
literal|"base_.*"
argument_list|)
condition|)
block|{
name|numBase
operator|++
expr_stmt|;
name|FileStatus
index|[]
name|buckets
init|=
name|fs
operator|.
name|listStatus
argument_list|(
name|status
index|[
name|i
index|]
operator|.
name|getPath
argument_list|()
argument_list|,
name|FileUtils
operator|.
name|HIDDEN_FILES_PATH_FILTER
argument_list|)
decl_stmt|;
name|Arrays
operator|.
name|sort
argument_list|(
name|buckets
argument_list|)
expr_stmt|;
if|if
condition|(
name|numBase
operator|==
literal|1
condition|)
block|{
name|Assert
operator|.
name|assertEquals
argument_list|(
literal|"base_-9223372036854775808_v0000022"
argument_list|,
name|status
index|[
name|i
index|]
operator|.
name|getPath
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
name|BUCKET_COUNT
operator|-
literal|1
argument_list|,
name|buckets
operator|.
name|length
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
literal|"bucket_00001"
argument_list|,
name|buckets
index|[
literal|0
index|]
operator|.
name|getPath
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|numBase
operator|==
literal|2
condition|)
block|{
comment|// The new base dir now has two bucket files, since the delta dir has two bucket files
name|Assert
operator|.
name|assertEquals
argument_list|(
literal|"base_10000002_v0000030"
argument_list|,
name|status
index|[
name|i
index|]
operator|.
name|getPath
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
literal|2
argument_list|,
name|buckets
operator|.
name|length
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
literal|"bucket_00000"
argument_list|,
name|buckets
index|[
literal|0
index|]
operator|.
name|getPath
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|Assert
operator|.
name|assertEquals
argument_list|(
literal|2
argument_list|,
name|numBase
argument_list|)
expr_stmt|;
name|rs
operator|=
name|runStatementOnDriver
argument_list|(
literal|"select a,b from "
operator|+
name|Table
operator|.
name|NONACIDORCTBL
argument_list|)
expr_stmt|;
name|resultData
operator|=
operator|new
name|int
index|[]
index|[]
block|{
block|{
literal|3
block|,
literal|4
block|}
block|,
block|{
literal|1
block|,
literal|3
block|}
block|}
expr_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
name|stringifyValuesNoSort
argument_list|(
name|resultData
argument_list|)
argument_list|,
name|rs
argument_list|)
expr_stmt|;
name|rs
operator|=
name|runStatementOnDriver
argument_list|(
literal|"select count(*) from "
operator|+
name|Table
operator|.
name|NONACIDORCTBL
argument_list|)
expr_stmt|;
name|resultCount
operator|=
literal|2
expr_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
name|resultCount
argument_list|,
name|Integer
operator|.
name|parseInt
argument_list|(
name|rs
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|// 6. Let Cleaner delete obsolete files/dirs
name|status
operator|=
name|fs
operator|.
name|listStatus
argument_list|(
operator|new
name|Path
argument_list|(
name|TEST_WAREHOUSE_DIR
operator|+
literal|"/"
operator|+
operator|(
name|Table
operator|.
name|NONACIDORCTBL
operator|)
operator|.
name|toString
argument_list|()
operator|.
name|toLowerCase
argument_list|()
argument_list|)
argument_list|,
name|FileUtils
operator|.
name|HIDDEN_FILES_PATH_FILTER
argument_list|)
expr_stmt|;
comment|// Before Cleaner, there should be 6 items:
comment|// 2 original files, 2 delta directories, 1 delete_delta directory and 2 base directories
name|Assert
operator|.
name|assertEquals
argument_list|(
literal|7
argument_list|,
name|status
operator|.
name|length
argument_list|)
expr_stmt|;
name|runCleaner
argument_list|(
name|hiveConf
argument_list|)
expr_stmt|;
comment|// There should be only 1 directory left: base_0000001.
comment|// Original bucket files, delta directories and previous base directory should have been cleaned up.
name|status
operator|=
name|fs
operator|.
name|listStatus
argument_list|(
operator|new
name|Path
argument_list|(
name|TEST_WAREHOUSE_DIR
operator|+
literal|"/"
operator|+
operator|(
name|Table
operator|.
name|NONACIDORCTBL
operator|)
operator|.
name|toString
argument_list|()
operator|.
name|toLowerCase
argument_list|()
argument_list|)
argument_list|,
name|FileUtils
operator|.
name|HIDDEN_FILES_PATH_FILTER
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
literal|1
argument_list|,
name|status
operator|.
name|length
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
literal|"base_10000002_v0000030"
argument_list|,
name|status
index|[
literal|0
index|]
operator|.
name|getPath
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
name|FileStatus
index|[]
name|buckets
init|=
name|fs
operator|.
name|listStatus
argument_list|(
name|status
index|[
literal|0
index|]
operator|.
name|getPath
argument_list|()
argument_list|,
name|FileUtils
operator|.
name|HIDDEN_FILES_PATH_FILTER
argument_list|)
decl_stmt|;
name|Arrays
operator|.
name|sort
argument_list|(
name|buckets
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
literal|2
argument_list|,
name|buckets
operator|.
name|length
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
literal|"bucket_00000"
argument_list|,
name|buckets
index|[
literal|0
index|]
operator|.
name|getPath
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
name|rs
operator|=
name|runStatementOnDriver
argument_list|(
literal|"select a,b from "
operator|+
name|Table
operator|.
name|NONACIDORCTBL
argument_list|)
expr_stmt|;
name|resultData
operator|=
operator|new
name|int
index|[]
index|[]
block|{
block|{
literal|3
block|,
literal|4
block|}
block|,
block|{
literal|1
block|,
literal|3
block|}
block|}
expr_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
name|stringifyValuesNoSort
argument_list|(
name|resultData
argument_list|)
argument_list|,
name|rs
argument_list|)
expr_stmt|;
name|rs
operator|=
name|runStatementOnDriver
argument_list|(
literal|"select count(*) from "
operator|+
name|Table
operator|.
name|NONACIDORCTBL
argument_list|)
expr_stmt|;
name|resultCount
operator|=
literal|2
expr_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
name|resultCount
argument_list|,
name|Integer
operator|.
name|parseInt
argument_list|(
name|rs
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testValidTxnsBookkeeping
parameter_list|()
throws|throws
name|Exception
block|{
comment|// 1. Run a query against a non-ACID table, and we shouldn't have txn logged in conf
name|runStatementOnDriver
argument_list|(
literal|"select * from "
operator|+
name|Table
operator|.
name|NONACIDORCTBL
argument_list|)
expr_stmt|;
name|String
name|value
init|=
name|hiveConf
operator|.
name|get
argument_list|(
name|ValidTxnWriteIdList
operator|.
name|VALID_TABLES_WRITEIDS_KEY
argument_list|)
decl_stmt|;
name|Assert
operator|.
name|assertNull
argument_list|(
literal|"The entry should be null for query that doesn't involve ACID tables"
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testSimpleRead
parameter_list|()
throws|throws
name|Exception
block|{
name|hiveConf
operator|.
name|setVar
argument_list|(
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVEFETCHTASKCONVERSION
argument_list|,
literal|"more"
argument_list|)
expr_stmt|;
name|int
index|[]
index|[]
name|tableData
init|=
block|{
block|{
literal|1
block|,
literal|2
block|}
block|,
block|{
literal|3
block|,
literal|3
block|}
block|}
decl_stmt|;
name|runStatementOnDriver
argument_list|(
literal|"insert into "
operator|+
name|Table
operator|.
name|ACIDTBL
operator|+
literal|" "
operator|+
name|makeValuesClause
argument_list|(
name|tableData
argument_list|)
argument_list|)
expr_stmt|;
name|int
index|[]
index|[]
name|tableData2
init|=
block|{
block|{
literal|5
block|,
literal|3
block|}
block|}
decl_stmt|;
comment|//this will cause next txn to be marked aborted but the data is still written to disk
name|hiveConf
operator|.
name|setBoolVar
argument_list|(
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVETESTMODEROLLBACKTXN
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|runStatementOnDriver
argument_list|(
literal|"insert into "
operator|+
name|Table
operator|.
name|ACIDTBL
operator|+
literal|" "
operator|+
name|makeValuesClause
argument_list|(
name|tableData2
argument_list|)
argument_list|)
expr_stmt|;
assert|assert
name|hiveConf
operator|.
name|get
argument_list|(
name|ValidTxnWriteIdList
operator|.
name|VALID_TABLES_WRITEIDS_KEY
argument_list|)
operator|==
literal|null
operator|:
literal|"previous txn should've cleaned it"
assert|;
comment|//so now if HIVEFETCHTASKCONVERSION were to use a stale value, it would use a
comment|//ValidWriteIdList with HWM=MAX_LONG, i.e. include the data for aborted txn
name|List
argument_list|<
name|String
argument_list|>
name|rs
init|=
name|runStatementOnDriver
argument_list|(
literal|"select * from "
operator|+
name|Table
operator|.
name|ACIDTBL
argument_list|)
decl_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
literal|"Extra data"
argument_list|,
literal|2
argument_list|,
name|rs
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testUpdateMixedCase
parameter_list|()
throws|throws
name|Exception
block|{
name|int
index|[]
index|[]
name|tableData
init|=
block|{
block|{
literal|1
block|,
literal|2
block|}
block|,
block|{
literal|3
block|,
literal|3
block|}
block|,
block|{
literal|5
block|,
literal|3
block|}
block|}
decl_stmt|;
name|runStatementOnDriver
argument_list|(
literal|"insert into "
operator|+
name|Table
operator|.
name|ACIDTBL
operator|+
literal|"(a,b) "
operator|+
name|makeValuesClause
argument_list|(
name|tableData
argument_list|)
argument_list|)
expr_stmt|;
name|runStatementOnDriver
argument_list|(
literal|"update "
operator|+
name|Table
operator|.
name|ACIDTBL
operator|+
literal|" set B = 7 where A=1"
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|rs
init|=
name|runStatementOnDriver
argument_list|(
literal|"select a,b from "
operator|+
name|Table
operator|.
name|ACIDTBL
operator|+
literal|" order by a,b"
argument_list|)
decl_stmt|;
name|int
index|[]
index|[]
name|updatedData
init|=
block|{
block|{
literal|1
block|,
literal|7
block|}
block|,
block|{
literal|3
block|,
literal|3
block|}
block|,
block|{
literal|5
block|,
literal|3
block|}
block|}
decl_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
literal|"Update failed"
argument_list|,
name|stringifyValues
argument_list|(
name|updatedData
argument_list|)
argument_list|,
name|rs
argument_list|)
expr_stmt|;
name|runStatementOnDriver
argument_list|(
literal|"update "
operator|+
name|Table
operator|.
name|ACIDTBL
operator|+
literal|" set B = B + 1 where A=1"
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|rs2
init|=
name|runStatementOnDriver
argument_list|(
literal|"select a,b from "
operator|+
name|Table
operator|.
name|ACIDTBL
operator|+
literal|" order by a,b"
argument_list|)
decl_stmt|;
name|int
index|[]
index|[]
name|updatedData2
init|=
block|{
block|{
literal|1
block|,
literal|8
block|}
block|,
block|{
literal|3
block|,
literal|3
block|}
block|,
block|{
literal|5
block|,
literal|3
block|}
block|}
decl_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
literal|"Update failed"
argument_list|,
name|stringifyValues
argument_list|(
name|updatedData2
argument_list|)
argument_list|,
name|rs2
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testDeleteIn
parameter_list|()
throws|throws
name|Exception
block|{
name|int
index|[]
index|[]
name|tableData
init|=
block|{
block|{
literal|1
block|,
literal|2
block|}
block|,
block|{
literal|3
block|,
literal|2
block|}
block|,
block|{
literal|5
block|,
literal|2
block|}
block|,
block|{
literal|1
block|,
literal|3
block|}
block|,
block|{
literal|3
block|,
literal|3
block|}
block|,
block|{
literal|5
block|,
literal|3
block|}
block|}
decl_stmt|;
name|runStatementOnDriver
argument_list|(
literal|"insert into "
operator|+
name|Table
operator|.
name|ACIDTBL
operator|+
literal|"(a,b) "
operator|+
name|makeValuesClause
argument_list|(
name|tableData
argument_list|)
argument_list|)
expr_stmt|;
name|runStatementOnDriver
argument_list|(
literal|"insert into "
operator|+
name|Table
operator|.
name|NONACIDORCTBL
operator|+
literal|"(a,b) values(1,7),(3,7)"
argument_list|)
expr_stmt|;
comment|//todo: once multistatement txns are supported, add a test to run next 2 statements in a single txn
name|runStatementOnDriver
argument_list|(
literal|"delete from "
operator|+
name|Table
operator|.
name|ACIDTBL
operator|+
literal|" where a in(select a from "
operator|+
name|Table
operator|.
name|NONACIDORCTBL
operator|+
literal|")"
argument_list|)
expr_stmt|;
name|runStatementOnDriver
argument_list|(
literal|"insert into "
operator|+
name|Table
operator|.
name|ACIDTBL
operator|+
literal|"(a,b) select a,b from "
operator|+
name|Table
operator|.
name|NONACIDORCTBL
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|rs
init|=
name|runStatementOnDriver
argument_list|(
literal|"select a,b from "
operator|+
name|Table
operator|.
name|ACIDTBL
operator|+
literal|" order by a,b"
argument_list|)
decl_stmt|;
name|int
index|[]
index|[]
name|updatedData
init|=
block|{
block|{
literal|1
block|,
literal|7
block|}
block|,
block|{
literal|3
block|,
literal|7
block|}
block|,
block|{
literal|5
block|,
literal|2
block|}
block|,
block|{
literal|5
block|,
literal|3
block|}
block|}
decl_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
literal|"Bulk update failed"
argument_list|,
name|stringifyValues
argument_list|(
name|updatedData
argument_list|)
argument_list|,
name|rs
argument_list|)
expr_stmt|;
name|runStatementOnDriver
argument_list|(
literal|"update "
operator|+
name|Table
operator|.
name|ACIDTBL
operator|+
literal|" set b=19 where b in(select b from "
operator|+
name|Table
operator|.
name|NONACIDORCTBL
operator|+
literal|" where a = 3)"
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|rs2
init|=
name|runStatementOnDriver
argument_list|(
literal|"select a,b from "
operator|+
name|Table
operator|.
name|ACIDTBL
operator|+
literal|" order by a,b"
argument_list|)
decl_stmt|;
name|int
index|[]
index|[]
name|updatedData2
init|=
block|{
block|{
literal|1
block|,
literal|19
block|}
block|,
block|{
literal|3
block|,
literal|19
block|}
block|,
block|{
literal|5
block|,
literal|2
block|}
block|,
block|{
literal|5
block|,
literal|3
block|}
block|}
decl_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
literal|"Bulk update2 failed"
argument_list|,
name|stringifyValues
argument_list|(
name|updatedData2
argument_list|)
argument_list|,
name|rs2
argument_list|)
expr_stmt|;
block|}
comment|/**    * Test update that hits multiple partitions (i.e. requries dynamic partition insert to process)    * @throws Exception    */
annotation|@
name|Test
specifier|public
name|void
name|updateDeletePartitioned
parameter_list|()
throws|throws
name|Exception
block|{
name|int
index|[]
index|[]
name|tableData
init|=
block|{
block|{
literal|1
block|,
literal|2
block|}
block|,
block|{
literal|3
block|,
literal|4
block|}
block|,
block|{
literal|5
block|,
literal|6
block|}
block|}
decl_stmt|;
name|runStatementOnDriver
argument_list|(
literal|"insert into "
operator|+
name|Table
operator|.
name|ACIDTBLPART
operator|+
literal|" partition(p=1) (a,b) "
operator|+
name|makeValuesClause
argument_list|(
name|tableData
argument_list|)
argument_list|)
expr_stmt|;
name|runStatementOnDriver
argument_list|(
literal|"insert into "
operator|+
name|Table
operator|.
name|ACIDTBLPART
operator|+
literal|" partition(p=2) (a,b) "
operator|+
name|makeValuesClause
argument_list|(
name|tableData
argument_list|)
argument_list|)
expr_stmt|;
name|TxnStore
name|txnHandler
init|=
name|TxnUtils
operator|.
name|getTxnStore
argument_list|(
name|hiveConf
argument_list|)
decl_stmt|;
name|txnHandler
operator|.
name|compact
argument_list|(
operator|new
name|CompactionRequest
argument_list|(
literal|"default"
argument_list|,
name|Table
operator|.
name|ACIDTBLPART
operator|.
name|name
argument_list|()
argument_list|,
name|CompactionType
operator|.
name|MAJOR
argument_list|)
argument_list|)
expr_stmt|;
name|runWorker
argument_list|(
name|hiveConf
argument_list|)
expr_stmt|;
name|runCleaner
argument_list|(
name|hiveConf
argument_list|)
expr_stmt|;
name|runStatementOnDriver
argument_list|(
literal|"update "
operator|+
name|Table
operator|.
name|ACIDTBLPART
operator|+
literal|" set b = b + 1 where a = 3"
argument_list|)
expr_stmt|;
name|txnHandler
operator|.
name|compact
argument_list|(
operator|new
name|CompactionRequest
argument_list|(
literal|"default"
argument_list|,
name|Table
operator|.
name|ACIDTBLPART
operator|.
name|toString
argument_list|()
argument_list|,
name|CompactionType
operator|.
name|MAJOR
argument_list|)
argument_list|)
expr_stmt|;
name|runWorker
argument_list|(
name|hiveConf
argument_list|)
expr_stmt|;
name|runCleaner
argument_list|(
name|hiveConf
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|rs
init|=
name|runStatementOnDriver
argument_list|(
literal|"select p,a,b from "
operator|+
name|Table
operator|.
name|ACIDTBLPART
operator|+
literal|" order by p, a, b"
argument_list|)
decl_stmt|;
name|int
index|[]
index|[]
name|expectedData
init|=
block|{
block|{
literal|1
block|,
literal|1
block|,
literal|2
block|}
block|,
block|{
literal|1
block|,
literal|3
block|,
literal|5
block|}
block|,
block|{
literal|1
block|,
literal|5
block|,
literal|6
block|}
block|,
block|{
literal|2
block|,
literal|1
block|,
literal|2
block|}
block|,
block|{
literal|2
block|,
literal|3
block|,
literal|5
block|}
block|,
block|{
literal|2
block|,
literal|5
block|,
literal|6
block|}
block|}
decl_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
literal|"Update "
operator|+
name|Table
operator|.
name|ACIDTBLPART
operator|+
literal|" didn't match:"
argument_list|,
name|stringifyValues
argument_list|(
name|expectedData
argument_list|)
argument_list|,
name|rs
argument_list|)
expr_stmt|;
block|}
comment|/**    * https://issues.apache.org/jira/browse/HIVE-17391    */
annotation|@
name|Test
specifier|public
name|void
name|testEmptyInTblproperties
parameter_list|()
throws|throws
name|Exception
block|{
name|runStatementOnDriver
argument_list|(
literal|"create table t1 "
operator|+
literal|"(a int, b int) stored as orc TBLPROPERTIES ('serialization.null.format'='', 'transactional'='true')"
argument_list|)
expr_stmt|;
name|runStatementOnDriver
argument_list|(
literal|"insert into t1 "
operator|+
literal|"(a,b) values(1,7),(3,7)"
argument_list|)
expr_stmt|;
name|runStatementOnDriver
argument_list|(
literal|"update t1"
operator|+
literal|" set b = -2 where b = 2"
argument_list|)
expr_stmt|;
name|runStatementOnDriver
argument_list|(
literal|"alter table t1 "
operator|+
literal|" compact 'MAJOR'"
argument_list|)
expr_stmt|;
name|runWorker
argument_list|(
name|hiveConf
argument_list|)
expr_stmt|;
name|TxnStore
name|txnHandler
init|=
name|TxnUtils
operator|.
name|getTxnStore
argument_list|(
name|hiveConf
argument_list|)
decl_stmt|;
name|ShowCompactResponse
name|resp
init|=
name|txnHandler
operator|.
name|showCompact
argument_list|(
operator|new
name|ShowCompactRequest
argument_list|()
argument_list|)
decl_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
literal|"Unexpected number of compactions in history"
argument_list|,
literal|1
argument_list|,
name|resp
operator|.
name|getCompactsSize
argument_list|()
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
literal|"Unexpected 0 compaction state"
argument_list|,
name|TxnStore
operator|.
name|CLEANING_RESPONSE
argument_list|,
name|resp
operator|.
name|getCompacts
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|getState
argument_list|()
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertTrue
argument_list|(
name|resp
operator|.
name|getCompacts
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|getHadoopJobId
argument_list|()
operator|.
name|startsWith
argument_list|(
literal|"job_local"
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**    * https://issues.apache.org/jira/browse/HIVE-10151    */
annotation|@
name|Test
specifier|public
name|void
name|testBucketizedInputFormat
parameter_list|()
throws|throws
name|Exception
block|{
name|int
index|[]
index|[]
name|tableData
init|=
block|{
block|{
literal|1
block|,
literal|2
block|}
block|}
decl_stmt|;
name|runStatementOnDriver
argument_list|(
literal|"insert into "
operator|+
name|Table
operator|.
name|ACIDTBLPART
operator|+
literal|" partition(p=1) (a,b) "
operator|+
name|makeValuesClause
argument_list|(
name|tableData
argument_list|)
argument_list|)
expr_stmt|;
name|runStatementOnDriver
argument_list|(
literal|"insert into "
operator|+
name|Table
operator|.
name|ACIDTBL
operator|+
literal|"(a,b) select a,b from "
operator|+
name|Table
operator|.
name|ACIDTBLPART
operator|+
literal|" where p = 1"
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|rs
init|=
name|runStatementOnDriver
argument_list|(
literal|"select a,b from "
operator|+
name|Table
operator|.
name|ACIDTBL
argument_list|)
decl_stmt|;
comment|//no order by as it's just 1 row
name|Assert
operator|.
name|assertEquals
argument_list|(
literal|"Insert into "
operator|+
name|Table
operator|.
name|ACIDTBL
operator|+
literal|" didn't match:"
argument_list|,
name|stringifyValues
argument_list|(
name|tableData
argument_list|)
argument_list|,
name|rs
argument_list|)
expr_stmt|;
name|runStatementOnDriver
argument_list|(
literal|"insert into "
operator|+
name|Table
operator|.
name|NONACIDORCTBL
operator|+
literal|"(a,b) select a,b from "
operator|+
name|Table
operator|.
name|ACIDTBLPART
operator|+
literal|" where p = 1"
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|rs2
init|=
name|runStatementOnDriver
argument_list|(
literal|"select a,b from "
operator|+
name|Table
operator|.
name|NONACIDORCTBL
argument_list|)
decl_stmt|;
comment|//no order by as it's just 1 row
name|Assert
operator|.
name|assertEquals
argument_list|(
literal|"Insert into "
operator|+
name|Table
operator|.
name|NONACIDORCTBL
operator|+
literal|" didn't match:"
argument_list|,
name|stringifyValues
argument_list|(
name|tableData
argument_list|)
argument_list|,
name|rs2
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testInsertOverwriteWithSelfJoin
parameter_list|()
throws|throws
name|Exception
block|{
name|int
index|[]
index|[]
name|part1Data
init|=
block|{
block|{
literal|1
block|,
literal|7
block|}
block|}
decl_stmt|;
name|runStatementOnDriver
argument_list|(
literal|"insert into "
operator|+
name|Table
operator|.
name|NONACIDORCTBL
operator|+
literal|"(a,b) "
operator|+
name|makeValuesClause
argument_list|(
name|part1Data
argument_list|)
argument_list|)
expr_stmt|;
comment|//this works because logically we need S lock on NONACIDORCTBL to read and X lock to write, but
comment|//LockRequestBuilder dedups locks on the same entity to only keep the highest level lock requested
name|runStatementOnDriver
argument_list|(
literal|"insert overwrite table "
operator|+
name|Table
operator|.
name|NONACIDORCTBL
operator|+
literal|" select 2, 9 from "
operator|+
name|Table
operator|.
name|NONACIDORCTBL
operator|+
literal|" T inner join "
operator|+
name|Table
operator|.
name|NONACIDORCTBL
operator|+
literal|" S on T.a=S.a"
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|rs
init|=
name|runStatementOnDriver
argument_list|(
literal|"select a,b from "
operator|+
name|Table
operator|.
name|NONACIDORCTBL
operator|+
literal|" order by a,b"
argument_list|)
decl_stmt|;
name|int
index|[]
index|[]
name|joinData
init|=
block|{
block|{
literal|2
block|,
literal|9
block|}
block|}
decl_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
literal|"Self join non-part insert overwrite failed"
argument_list|,
name|stringifyValues
argument_list|(
name|joinData
argument_list|)
argument_list|,
name|rs
argument_list|)
expr_stmt|;
name|int
index|[]
index|[]
name|part2Data
init|=
block|{
block|{
literal|1
block|,
literal|8
block|}
block|}
decl_stmt|;
name|runStatementOnDriver
argument_list|(
literal|"insert into "
operator|+
name|Table
operator|.
name|NONACIDPART
operator|+
literal|" partition(p=1) (a,b) "
operator|+
name|makeValuesClause
argument_list|(
name|part1Data
argument_list|)
argument_list|)
expr_stmt|;
name|runStatementOnDriver
argument_list|(
literal|"insert into "
operator|+
name|Table
operator|.
name|NONACIDPART
operator|+
literal|" partition(p=2) (a,b) "
operator|+
name|makeValuesClause
argument_list|(
name|part2Data
argument_list|)
argument_list|)
expr_stmt|;
comment|//here we need X lock on p=1 partition to write and S lock on 'table' to read which should
comment|//not block each other since they are part of the same txn
name|runStatementOnDriver
argument_list|(
literal|"insert overwrite table "
operator|+
name|Table
operator|.
name|NONACIDPART
operator|+
literal|" partition(p=1) select a,b from "
operator|+
name|Table
operator|.
name|NONACIDPART
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|rs2
init|=
name|runStatementOnDriver
argument_list|(
literal|"select a,b from "
operator|+
name|Table
operator|.
name|NONACIDPART
operator|+
literal|" order by a,b"
argument_list|)
decl_stmt|;
name|int
index|[]
index|[]
name|updatedData
init|=
block|{
block|{
literal|1
block|,
literal|7
block|}
block|,
block|{
literal|1
block|,
literal|8
block|}
block|,
block|{
literal|1
block|,
literal|8
block|}
block|}
decl_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
literal|"Insert overwrite partition failed"
argument_list|,
name|stringifyValues
argument_list|(
name|updatedData
argument_list|)
argument_list|,
name|rs2
argument_list|)
expr_stmt|;
comment|//insert overwrite not supported for ACID tables
block|}
specifier|private
specifier|static
name|void
name|checkCompactionState
parameter_list|(
name|CompactionsByState
name|expected
parameter_list|,
name|CompactionsByState
name|actual
parameter_list|)
block|{
name|Assert
operator|.
name|assertEquals
argument_list|(
name|TxnStore
operator|.
name|ATTEMPTED_RESPONSE
argument_list|,
name|expected
operator|.
name|attempted
argument_list|,
name|actual
operator|.
name|attempted
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
name|TxnStore
operator|.
name|FAILED_RESPONSE
argument_list|,
name|expected
operator|.
name|failed
argument_list|,
name|actual
operator|.
name|failed
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
name|TxnStore
operator|.
name|INITIATED_RESPONSE
argument_list|,
name|expected
operator|.
name|initiated
argument_list|,
name|actual
operator|.
name|initiated
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
name|TxnStore
operator|.
name|CLEANING_RESPONSE
argument_list|,
name|expected
operator|.
name|readyToClean
argument_list|,
name|actual
operator|.
name|readyToClean
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
name|TxnStore
operator|.
name|SUCCEEDED_RESPONSE
argument_list|,
name|expected
operator|.
name|succeeded
argument_list|,
name|actual
operator|.
name|succeeded
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
name|TxnStore
operator|.
name|WORKING_RESPONSE
argument_list|,
name|expected
operator|.
name|working
argument_list|,
name|actual
operator|.
name|working
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
literal|"total"
argument_list|,
name|expected
operator|.
name|total
argument_list|,
name|actual
operator|.
name|total
argument_list|)
expr_stmt|;
block|}
comment|/**    * HIVE-12353    * @throws Exception    */
annotation|@
name|Test
specifier|public
name|void
name|testInitiatorWithMultipleFailedCompactions
parameter_list|()
throws|throws
name|Exception
block|{
name|testInitiatorWithMultipleFailedCompactionsForVariousTblProperties
argument_list|(
literal|"'transactional'='true'"
argument_list|)
expr_stmt|;
block|}
name|void
name|testInitiatorWithMultipleFailedCompactionsForVariousTblProperties
parameter_list|(
name|String
name|tblProperties
parameter_list|)
throws|throws
name|Exception
block|{
name|String
name|tblName
init|=
literal|"hive12353"
decl_stmt|;
name|runStatementOnDriver
argument_list|(
literal|"drop table if exists "
operator|+
name|tblName
argument_list|)
expr_stmt|;
name|runStatementOnDriver
argument_list|(
literal|"CREATE TABLE "
operator|+
name|tblName
operator|+
literal|"(a INT, b STRING) "
operator|+
literal|" CLUSTERED BY(a) INTO 1 BUCKETS"
operator|+
comment|//currently ACID requires table to be bucketed
literal|" STORED AS ORC  TBLPROPERTIES ( "
operator|+
name|tblProperties
operator|+
literal|" )"
argument_list|)
expr_stmt|;
name|hiveConf
operator|.
name|setIntVar
argument_list|(
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVE_COMPACTOR_DELTA_NUM_THRESHOLD
argument_list|,
literal|4
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
literal|5
condition|;
name|i
operator|++
control|)
block|{
comment|//generate enough delta files so that Initiator can trigger auto compaction
name|runStatementOnDriver
argument_list|(
literal|"insert into "
operator|+
name|tblName
operator|+
literal|" values("
operator|+
operator|(
name|i
operator|+
literal|1
operator|)
operator|+
literal|", 'foo'),("
operator|+
operator|(
name|i
operator|+
literal|2
operator|)
operator|+
literal|", 'bar'),("
operator|+
operator|(
name|i
operator|+
literal|3
operator|)
operator|+
literal|", 'baz')"
argument_list|)
expr_stmt|;
block|}
name|hiveConf
operator|.
name|setBoolVar
argument_list|(
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVETESTMODEFAILCOMPACTION
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|int
name|numFailedCompactions
init|=
name|hiveConf
operator|.
name|getIntVar
argument_list|(
name|HiveConf
operator|.
name|ConfVars
operator|.
name|COMPACTOR_INITIATOR_FAILED_THRESHOLD
argument_list|)
decl_stmt|;
name|TxnStore
name|txnHandler
init|=
name|TxnUtils
operator|.
name|getTxnStore
argument_list|(
name|hiveConf
argument_list|)
decl_stmt|;
name|AtomicBoolean
name|stop
init|=
operator|new
name|AtomicBoolean
argument_list|(
literal|true
argument_list|)
decl_stmt|;
comment|//create failed compactions
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numFailedCompactions
condition|;
name|i
operator|++
control|)
block|{
comment|//each of these should fail
name|txnHandler
operator|.
name|compact
argument_list|(
operator|new
name|CompactionRequest
argument_list|(
literal|"default"
argument_list|,
name|tblName
argument_list|,
name|CompactionType
operator|.
name|MINOR
argument_list|)
argument_list|)
expr_stmt|;
name|runWorker
argument_list|(
name|hiveConf
argument_list|)
expr_stmt|;
block|}
comment|//this should not schedule a new compaction due to prior failures, but will create Attempted entry
name|Initiator
name|init
init|=
operator|new
name|Initiator
argument_list|()
decl_stmt|;
name|init
operator|.
name|setThreadId
argument_list|(
operator|(
name|int
operator|)
name|init
operator|.
name|getId
argument_list|()
argument_list|)
expr_stmt|;
name|init
operator|.
name|setConf
argument_list|(
name|hiveConf
argument_list|)
expr_stmt|;
name|init
operator|.
name|init
argument_list|(
name|stop
argument_list|,
operator|new
name|AtomicBoolean
argument_list|()
argument_list|)
expr_stmt|;
name|init
operator|.
name|run
argument_list|()
expr_stmt|;
name|int
name|numAttemptedCompactions
init|=
literal|1
decl_stmt|;
name|checkCompactionState
argument_list|(
operator|new
name|CompactionsByState
argument_list|(
name|numAttemptedCompactions
argument_list|,
name|numFailedCompactions
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|numFailedCompactions
operator|+
name|numAttemptedCompactions
argument_list|)
argument_list|,
name|countCompacts
argument_list|(
name|txnHandler
argument_list|)
argument_list|)
expr_stmt|;
name|hiveConf
operator|.
name|setTimeVar
argument_list|(
name|HiveConf
operator|.
name|ConfVars
operator|.
name|COMPACTOR_HISTORY_REAPER_INTERVAL
argument_list|,
literal|10
argument_list|,
name|TimeUnit
operator|.
name|MILLISECONDS
argument_list|)
expr_stmt|;
name|AcidCompactionHistoryService
name|compactionHistoryService
init|=
operator|new
name|AcidCompactionHistoryService
argument_list|()
decl_stmt|;
name|compactionHistoryService
operator|.
name|setConf
argument_list|(
name|hiveConf
argument_list|)
expr_stmt|;
name|compactionHistoryService
operator|.
name|run
argument_list|()
expr_stmt|;
name|checkCompactionState
argument_list|(
operator|new
name|CompactionsByState
argument_list|(
name|numAttemptedCompactions
argument_list|,
name|numFailedCompactions
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|numFailedCompactions
operator|+
name|numAttemptedCompactions
argument_list|)
argument_list|,
name|countCompacts
argument_list|(
name|txnHandler
argument_list|)
argument_list|)
expr_stmt|;
name|txnHandler
operator|.
name|compact
argument_list|(
operator|new
name|CompactionRequest
argument_list|(
literal|"default"
argument_list|,
name|tblName
argument_list|,
name|CompactionType
operator|.
name|MAJOR
argument_list|)
argument_list|)
expr_stmt|;
name|runWorker
argument_list|(
name|hiveConf
argument_list|)
expr_stmt|;
comment|//will fail
name|txnHandler
operator|.
name|compact
argument_list|(
operator|new
name|CompactionRequest
argument_list|(
literal|"default"
argument_list|,
name|tblName
argument_list|,
name|CompactionType
operator|.
name|MINOR
argument_list|)
argument_list|)
expr_stmt|;
name|runWorker
argument_list|(
name|hiveConf
argument_list|)
expr_stmt|;
comment|//will fail
name|init
operator|.
name|run
argument_list|()
expr_stmt|;
name|numAttemptedCompactions
operator|++
expr_stmt|;
name|init
operator|.
name|run
argument_list|()
expr_stmt|;
name|numAttemptedCompactions
operator|++
expr_stmt|;
name|checkCompactionState
argument_list|(
operator|new
name|CompactionsByState
argument_list|(
name|numAttemptedCompactions
argument_list|,
name|numFailedCompactions
operator|+
literal|2
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|numFailedCompactions
operator|+
literal|2
operator|+
name|numAttemptedCompactions
argument_list|)
argument_list|,
name|countCompacts
argument_list|(
name|txnHandler
argument_list|)
argument_list|)
expr_stmt|;
name|compactionHistoryService
operator|.
name|run
argument_list|()
expr_stmt|;
comment|//COMPACTOR_HISTORY_RETENTION_FAILED failed compacts left (and no other since we only have failed ones here)
name|checkCompactionState
argument_list|(
operator|new
name|CompactionsByState
argument_list|(
name|hiveConf
operator|.
name|getIntVar
argument_list|(
name|HiveConf
operator|.
name|ConfVars
operator|.
name|COMPACTOR_HISTORY_RETENTION_ATTEMPTED
argument_list|)
argument_list|,
name|hiveConf
operator|.
name|getIntVar
argument_list|(
name|HiveConf
operator|.
name|ConfVars
operator|.
name|COMPACTOR_HISTORY_RETENTION_FAILED
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|hiveConf
operator|.
name|getIntVar
argument_list|(
name|HiveConf
operator|.
name|ConfVars
operator|.
name|COMPACTOR_HISTORY_RETENTION_FAILED
argument_list|)
operator|+
name|hiveConf
operator|.
name|getIntVar
argument_list|(
name|HiveConf
operator|.
name|ConfVars
operator|.
name|COMPACTOR_HISTORY_RETENTION_ATTEMPTED
argument_list|)
argument_list|)
argument_list|,
name|countCompacts
argument_list|(
name|txnHandler
argument_list|)
argument_list|)
expr_stmt|;
name|hiveConf
operator|.
name|setBoolVar
argument_list|(
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVETESTMODEFAILCOMPACTION
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|txnHandler
operator|.
name|compact
argument_list|(
operator|new
name|CompactionRequest
argument_list|(
literal|"default"
argument_list|,
name|tblName
argument_list|,
name|CompactionType
operator|.
name|MINOR
argument_list|)
argument_list|)
expr_stmt|;
comment|//at this point "show compactions" should have (COMPACTOR_HISTORY_RETENTION_FAILED) failed + 1 initiated (explicitly by user)
name|checkCompactionState
argument_list|(
operator|new
name|CompactionsByState
argument_list|(
name|hiveConf
operator|.
name|getIntVar
argument_list|(
name|HiveConf
operator|.
name|ConfVars
operator|.
name|COMPACTOR_HISTORY_RETENTION_ATTEMPTED
argument_list|)
argument_list|,
name|hiveConf
operator|.
name|getIntVar
argument_list|(
name|HiveConf
operator|.
name|ConfVars
operator|.
name|COMPACTOR_HISTORY_RETENTION_FAILED
argument_list|)
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|hiveConf
operator|.
name|getIntVar
argument_list|(
name|HiveConf
operator|.
name|ConfVars
operator|.
name|COMPACTOR_HISTORY_RETENTION_FAILED
argument_list|)
operator|+
name|hiveConf
operator|.
name|getIntVar
argument_list|(
name|HiveConf
operator|.
name|ConfVars
operator|.
name|COMPACTOR_HISTORY_RETENTION_ATTEMPTED
argument_list|)
operator|+
literal|1
argument_list|)
argument_list|,
name|countCompacts
argument_list|(
name|txnHandler
argument_list|)
argument_list|)
expr_stmt|;
name|runWorker
argument_list|(
name|hiveConf
argument_list|)
expr_stmt|;
comment|//will succeed and transition to Initiated->Working->Ready for Cleaning
name|checkCompactionState
argument_list|(
operator|new
name|CompactionsByState
argument_list|(
name|hiveConf
operator|.
name|getIntVar
argument_list|(
name|HiveConf
operator|.
name|ConfVars
operator|.
name|COMPACTOR_HISTORY_RETENTION_ATTEMPTED
argument_list|)
argument_list|,
name|hiveConf
operator|.
name|getIntVar
argument_list|(
name|HiveConf
operator|.
name|ConfVars
operator|.
name|COMPACTOR_HISTORY_RETENTION_FAILED
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|hiveConf
operator|.
name|getIntVar
argument_list|(
name|HiveConf
operator|.
name|ConfVars
operator|.
name|COMPACTOR_HISTORY_RETENTION_FAILED
argument_list|)
operator|+
name|hiveConf
operator|.
name|getIntVar
argument_list|(
name|HiveConf
operator|.
name|ConfVars
operator|.
name|COMPACTOR_HISTORY_RETENTION_ATTEMPTED
argument_list|)
operator|+
literal|1
argument_list|)
argument_list|,
name|countCompacts
argument_list|(
name|txnHandler
argument_list|)
argument_list|)
expr_stmt|;
name|runCleaner
argument_list|(
name|hiveConf
argument_list|)
expr_stmt|;
comment|// transition to Success state
name|compactionHistoryService
operator|.
name|run
argument_list|()
expr_stmt|;
name|checkCompactionState
argument_list|(
operator|new
name|CompactionsByState
argument_list|(
name|hiveConf
operator|.
name|getIntVar
argument_list|(
name|HiveConf
operator|.
name|ConfVars
operator|.
name|COMPACTOR_HISTORY_RETENTION_ATTEMPTED
argument_list|)
argument_list|,
name|hiveConf
operator|.
name|getIntVar
argument_list|(
name|HiveConf
operator|.
name|ConfVars
operator|.
name|COMPACTOR_HISTORY_RETENTION_FAILED
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
name|hiveConf
operator|.
name|getIntVar
argument_list|(
name|HiveConf
operator|.
name|ConfVars
operator|.
name|COMPACTOR_HISTORY_RETENTION_FAILED
argument_list|)
operator|+
name|hiveConf
operator|.
name|getIntVar
argument_list|(
name|HiveConf
operator|.
name|ConfVars
operator|.
name|COMPACTOR_HISTORY_RETENTION_ATTEMPTED
argument_list|)
operator|+
literal|1
argument_list|)
argument_list|,
name|countCompacts
argument_list|(
name|txnHandler
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**    * Make sure there's no FileSystem$Cache$Key leak due to UGI use    * @throws Exception    */
annotation|@
name|Test
specifier|public
name|void
name|testFileSystemUnCaching
parameter_list|()
throws|throws
name|Exception
block|{
name|int
name|cacheSizeBefore
decl_stmt|;
name|int
name|cacheSizeAfter
decl_stmt|;
comment|// get the size of cache BEFORE
name|cacheSizeBefore
operator|=
name|getFileSystemCacheSize
argument_list|()
expr_stmt|;
comment|// Insert a row to ACID table
name|runStatementOnDriver
argument_list|(
literal|"insert into "
operator|+
name|Table
operator|.
name|ACIDTBL
operator|+
literal|"(a,b) values(1,2)"
argument_list|)
expr_stmt|;
comment|// Perform a major compaction
name|runStatementOnDriver
argument_list|(
literal|"alter table "
operator|+
name|Table
operator|.
name|ACIDTBL
operator|+
literal|" compact 'major'"
argument_list|)
expr_stmt|;
name|runWorker
argument_list|(
name|hiveConf
argument_list|)
expr_stmt|;
name|runCleaner
argument_list|(
name|hiveConf
argument_list|)
expr_stmt|;
comment|// get the size of cache AFTER
name|cacheSizeAfter
operator|=
name|getFileSystemCacheSize
argument_list|()
expr_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
name|cacheSizeBefore
argument_list|,
name|cacheSizeAfter
argument_list|)
expr_stmt|;
block|}
specifier|private
name|int
name|getFileSystemCacheSize
parameter_list|()
throws|throws
name|Exception
block|{
try|try
block|{
name|Field
name|cache
init|=
name|FileSystem
operator|.
name|class
operator|.
name|getDeclaredField
argument_list|(
literal|"CACHE"
argument_list|)
decl_stmt|;
name|cache
operator|.
name|setAccessible
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|Object
name|o
init|=
name|cache
operator|.
name|get
argument_list|(
literal|null
argument_list|)
decl_stmt|;
comment|// FileSystem.CACHE
name|Field
name|mapField
init|=
name|o
operator|.
name|getClass
argument_list|()
operator|.
name|getDeclaredField
argument_list|(
literal|"map"
argument_list|)
decl_stmt|;
name|mapField
operator|.
name|setAccessible
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|Map
name|map
init|=
operator|(
name|HashMap
operator|)
name|mapField
operator|.
name|get
argument_list|(
name|o
argument_list|)
decl_stmt|;
comment|// FileSystem.CACHE.map
return|return
name|map
operator|.
name|size
argument_list|()
return|;
block|}
catch|catch
parameter_list|(
name|NoSuchFieldException
name|e
parameter_list|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
specifier|private
specifier|static
class|class
name|CompactionsByState
block|{
specifier|private
name|int
name|attempted
decl_stmt|;
specifier|private
name|int
name|failed
decl_stmt|;
specifier|private
name|int
name|initiated
decl_stmt|;
specifier|private
name|int
name|readyToClean
decl_stmt|;
specifier|private
name|int
name|succeeded
decl_stmt|;
specifier|private
name|int
name|working
decl_stmt|;
specifier|private
name|int
name|total
decl_stmt|;
name|CompactionsByState
parameter_list|()
block|{
name|this
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|CompactionsByState
parameter_list|(
name|int
name|attempted
parameter_list|,
name|int
name|failed
parameter_list|,
name|int
name|initiated
parameter_list|,
name|int
name|readyToClean
parameter_list|,
name|int
name|succeeded
parameter_list|,
name|int
name|working
parameter_list|,
name|int
name|total
parameter_list|)
block|{
name|this
operator|.
name|attempted
operator|=
name|attempted
expr_stmt|;
name|this
operator|.
name|failed
operator|=
name|failed
expr_stmt|;
name|this
operator|.
name|initiated
operator|=
name|initiated
expr_stmt|;
name|this
operator|.
name|readyToClean
operator|=
name|readyToClean
expr_stmt|;
name|this
operator|.
name|succeeded
operator|=
name|succeeded
expr_stmt|;
name|this
operator|.
name|working
operator|=
name|working
expr_stmt|;
name|this
operator|.
name|total
operator|=
name|total
expr_stmt|;
block|}
block|}
specifier|private
specifier|static
name|CompactionsByState
name|countCompacts
parameter_list|(
name|TxnStore
name|txnHandler
parameter_list|)
throws|throws
name|MetaException
block|{
name|ShowCompactResponse
name|resp
init|=
name|txnHandler
operator|.
name|showCompact
argument_list|(
operator|new
name|ShowCompactRequest
argument_list|()
argument_list|)
decl_stmt|;
name|CompactionsByState
name|compactionsByState
init|=
operator|new
name|CompactionsByState
argument_list|()
decl_stmt|;
name|compactionsByState
operator|.
name|total
operator|=
name|resp
operator|.
name|getCompactsSize
argument_list|()
expr_stmt|;
for|for
control|(
name|ShowCompactResponseElement
name|compact
range|:
name|resp
operator|.
name|getCompacts
argument_list|()
control|)
block|{
if|if
condition|(
name|TxnStore
operator|.
name|FAILED_RESPONSE
operator|.
name|equals
argument_list|(
name|compact
operator|.
name|getState
argument_list|()
argument_list|)
condition|)
block|{
name|compactionsByState
operator|.
name|failed
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TxnStore
operator|.
name|CLEANING_RESPONSE
operator|.
name|equals
argument_list|(
name|compact
operator|.
name|getState
argument_list|()
argument_list|)
condition|)
block|{
name|compactionsByState
operator|.
name|readyToClean
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TxnStore
operator|.
name|INITIATED_RESPONSE
operator|.
name|equals
argument_list|(
name|compact
operator|.
name|getState
argument_list|()
argument_list|)
condition|)
block|{
name|compactionsByState
operator|.
name|initiated
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TxnStore
operator|.
name|SUCCEEDED_RESPONSE
operator|.
name|equals
argument_list|(
name|compact
operator|.
name|getState
argument_list|()
argument_list|)
condition|)
block|{
name|compactionsByState
operator|.
name|succeeded
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TxnStore
operator|.
name|WORKING_RESPONSE
operator|.
name|equals
argument_list|(
name|compact
operator|.
name|getState
argument_list|()
argument_list|)
condition|)
block|{
name|compactionsByState
operator|.
name|working
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TxnStore
operator|.
name|ATTEMPTED_RESPONSE
operator|.
name|equals
argument_list|(
name|compact
operator|.
name|getState
argument_list|()
argument_list|)
condition|)
block|{
name|compactionsByState
operator|.
name|attempted
operator|++
expr_stmt|;
block|}
else|else
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"Unexpected state: "
operator|+
name|compact
operator|.
name|getState
argument_list|()
argument_list|)
throw|;
block|}
block|}
return|return
name|compactionsByState
return|;
block|}
specifier|public
specifier|static
name|void
name|runWorker
parameter_list|(
name|HiveConf
name|hiveConf
parameter_list|)
throws|throws
name|MetaException
block|{
name|runCompactorThread
argument_list|(
name|hiveConf
argument_list|,
name|CompactorThreadType
operator|.
name|WORKER
argument_list|)
expr_stmt|;
block|}
specifier|public
specifier|static
name|void
name|runCleaner
parameter_list|(
name|HiveConf
name|hiveConf
parameter_list|)
throws|throws
name|MetaException
block|{
name|runCompactorThread
argument_list|(
name|hiveConf
argument_list|,
name|CompactorThreadType
operator|.
name|CLEANER
argument_list|)
expr_stmt|;
block|}
specifier|public
specifier|static
name|void
name|runInitiator
parameter_list|(
name|HiveConf
name|hiveConf
parameter_list|)
throws|throws
name|MetaException
block|{
name|runCompactorThread
argument_list|(
name|hiveConf
argument_list|,
name|CompactorThreadType
operator|.
name|INITIATOR
argument_list|)
expr_stmt|;
block|}
specifier|private
enum|enum
name|CompactorThreadType
block|{
name|INITIATOR
block|,
name|WORKER
block|,
name|CLEANER
block|}
specifier|private
specifier|static
name|void
name|runCompactorThread
parameter_list|(
name|HiveConf
name|hiveConf
parameter_list|,
name|CompactorThreadType
name|type
parameter_list|)
throws|throws
name|MetaException
block|{
name|AtomicBoolean
name|stop
init|=
operator|new
name|AtomicBoolean
argument_list|(
literal|true
argument_list|)
decl_stmt|;
name|CompactorThread
name|t
init|=
literal|null
decl_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|INITIATOR
case|:
name|t
operator|=
operator|new
name|Initiator
argument_list|()
expr_stmt|;
break|break;
case|case
name|WORKER
case|:
name|t
operator|=
operator|new
name|Worker
argument_list|()
expr_stmt|;
break|break;
case|case
name|CLEANER
case|:
name|t
operator|=
operator|new
name|Cleaner
argument_list|()
expr_stmt|;
break|break;
default|default:
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Unknown type: "
operator|+
name|type
argument_list|)
throw|;
block|}
name|t
operator|.
name|setThreadId
argument_list|(
operator|(
name|int
operator|)
name|t
operator|.
name|getId
argument_list|()
argument_list|)
expr_stmt|;
name|t
operator|.
name|setConf
argument_list|(
name|hiveConf
argument_list|)
expr_stmt|;
name|AtomicBoolean
name|looped
init|=
operator|new
name|AtomicBoolean
argument_list|()
decl_stmt|;
name|t
operator|.
name|init
argument_list|(
name|stop
argument_list|,
name|looped
argument_list|)
expr_stmt|;
name|t
operator|.
name|run
argument_list|()
expr_stmt|;
block|}
comment|/**    * HIVE-12352 has details    * @throws Exception    */
annotation|@
name|Test
specifier|public
name|void
name|writeBetweenWorkerAndCleaner
parameter_list|()
throws|throws
name|Exception
block|{
name|writeBetweenWorkerAndCleanerForVariousTblProperties
argument_list|(
literal|"'transactional'='true'"
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|writeBetweenWorkerAndCleanerForVariousTblProperties
parameter_list|(
name|String
name|tblProperties
parameter_list|)
throws|throws
name|Exception
block|{
name|String
name|tblName
init|=
literal|"hive12352"
decl_stmt|;
name|runStatementOnDriver
argument_list|(
literal|"drop table if exists "
operator|+
name|tblName
argument_list|)
expr_stmt|;
name|runStatementOnDriver
argument_list|(
literal|"CREATE TABLE "
operator|+
name|tblName
operator|+
literal|"(a INT, b STRING) "
operator|+
literal|" CLUSTERED BY(a) INTO 1 BUCKETS"
operator|+
comment|//currently ACID requires table to be bucketed
literal|" STORED AS ORC  TBLPROPERTIES ( "
operator|+
name|tblProperties
operator|+
literal|" )"
argument_list|)
expr_stmt|;
comment|//create some data
name|runStatementOnDriver
argument_list|(
literal|"insert into "
operator|+
name|tblName
operator|+
literal|" values(1, 'foo'),(2, 'bar'),(3, 'baz')"
argument_list|)
expr_stmt|;
name|runStatementOnDriver
argument_list|(
literal|"update "
operator|+
name|tblName
operator|+
literal|" set b = 'blah' where a = 3"
argument_list|)
expr_stmt|;
comment|//run Worker to execute compaction
name|TxnStore
name|txnHandler
init|=
name|TxnUtils
operator|.
name|getTxnStore
argument_list|(
name|hiveConf
argument_list|)
decl_stmt|;
name|txnHandler
operator|.
name|compact
argument_list|(
operator|new
name|CompactionRequest
argument_list|(
literal|"default"
argument_list|,
name|tblName
argument_list|,
name|CompactionType
operator|.
name|MINOR
argument_list|)
argument_list|)
expr_stmt|;
name|runWorker
argument_list|(
name|hiveConf
argument_list|)
expr_stmt|;
comment|//delete something, but make sure txn is rolled back
name|hiveConf
operator|.
name|setBoolVar
argument_list|(
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVETESTMODEROLLBACKTXN
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|runStatementOnDriver
argument_list|(
literal|"delete from "
operator|+
name|tblName
operator|+
literal|" where a = 1"
argument_list|)
expr_stmt|;
name|hiveConf
operator|.
name|setBoolVar
argument_list|(
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVETESTMODEROLLBACKTXN
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|expected
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|expected
operator|.
name|add
argument_list|(
literal|"1\tfoo"
argument_list|)
expr_stmt|;
name|expected
operator|.
name|add
argument_list|(
literal|"2\tbar"
argument_list|)
expr_stmt|;
name|expected
operator|.
name|add
argument_list|(
literal|"3\tblah"
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
literal|""
argument_list|,
name|expected
argument_list|,
name|runStatementOnDriver
argument_list|(
literal|"select a,b from "
operator|+
name|tblName
operator|+
literal|" order by a"
argument_list|)
argument_list|)
expr_stmt|;
name|runCleaner
argument_list|(
name|hiveConf
argument_list|)
expr_stmt|;
name|FileSystem
name|fs
init|=
name|FileSystem
operator|.
name|get
argument_list|(
name|hiveConf
argument_list|)
decl_stmt|;
name|FileStatus
index|[]
name|status
init|=
name|fs
operator|.
name|listStatus
argument_list|(
operator|new
name|Path
argument_list|(
name|TEST_WAREHOUSE_DIR
operator|+
literal|"/"
operator|+
name|tblName
operator|.
name|toLowerCase
argument_list|()
argument_list|)
argument_list|,
name|FileUtils
operator|.
name|HIDDEN_FILES_PATH_FILTER
argument_list|)
decl_stmt|;
name|Set
argument_list|<
name|String
argument_list|>
name|expectedDeltas
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|()
decl_stmt|;
name|expectedDeltas
operator|.
name|add
argument_list|(
literal|"delete_delta_0000001_0000002_v0000019"
argument_list|)
expr_stmt|;
name|expectedDeltas
operator|.
name|add
argument_list|(
literal|"delta_0000001_0000002_v0000019"
argument_list|)
expr_stmt|;
name|Set
argument_list|<
name|String
argument_list|>
name|actualDeltas
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|FileStatus
name|file
range|:
name|status
control|)
block|{
name|actualDeltas
operator|.
name|add
argument_list|(
name|file
operator|.
name|getPath
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|Assert
operator|.
name|assertEquals
argument_list|(
name|expectedDeltas
argument_list|,
name|actualDeltas
argument_list|)
expr_stmt|;
comment|//this seems odd, but we want to make sure that run CompactionTxnHandler.cleanEmptyAbortedTxns()
name|runInitiator
argument_list|(
name|hiveConf
argument_list|)
expr_stmt|;
comment|//and check that aborted delete operation didn't become committed
name|Assert
operator|.
name|assertEquals
argument_list|(
literal|""
argument_list|,
name|expected
argument_list|,
name|runStatementOnDriver
argument_list|(
literal|"select a,b from "
operator|+
name|tblName
operator|+
literal|" order by a"
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**    * Simulate the scenario when a heartbeat failed due to client errors such as no locks or no txns being found.    * When a heartbeat fails, the query should be failed too.    * @throws Exception    */
annotation|@
name|Test
specifier|public
name|void
name|testFailHeartbeater
parameter_list|()
throws|throws
name|Exception
block|{
comment|// Fail heartbeater, so that we can get a RuntimeException from the query.
comment|// More specifically, it's the original IOException thrown by either MR's or Tez's progress monitoring loop.
name|hiveConf
operator|.
name|setBoolVar
argument_list|(
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVETESTMODEFAILHEARTBEATER
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|Exception
name|exception
init|=
literal|null
decl_stmt|;
try|try
block|{
name|runStatementOnDriver
argument_list|(
literal|"insert into "
operator|+
name|Table
operator|.
name|ACIDTBL
operator|+
literal|"(a,b) "
operator|+
name|makeValuesClause
argument_list|(
operator|new
name|int
index|[]
index|[]
block|{
block|{
literal|1
block|,
literal|2
block|}
block|,
block|{
literal|3
block|,
literal|4
block|}
block|}
argument_list|)
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|RuntimeException
name|e
parameter_list|)
block|{
name|exception
operator|=
name|e
expr_stmt|;
block|}
name|Assert
operator|.
name|assertNotNull
argument_list|(
name|exception
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertTrue
argument_list|(
name|exception
operator|.
name|getMessage
argument_list|()
operator|.
name|contains
argument_list|(
literal|"HIVETESTMODEFAILHEARTBEATER=true"
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testOpenTxnsCounter
parameter_list|()
throws|throws
name|Exception
block|{
name|hiveConf
operator|.
name|setIntVar
argument_list|(
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVE_MAX_OPEN_TXNS
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|hiveConf
operator|.
name|setTimeVar
argument_list|(
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVE_COUNT_OPEN_TXNS_INTERVAL
argument_list|,
literal|10
argument_list|,
name|TimeUnit
operator|.
name|MILLISECONDS
argument_list|)
expr_stmt|;
name|TxnStore
name|txnHandler
init|=
name|TxnUtils
operator|.
name|getTxnStore
argument_list|(
name|hiveConf
argument_list|)
decl_stmt|;
name|OpenTxnsResponse
name|openTxnsResponse
init|=
name|txnHandler
operator|.
name|openTxns
argument_list|(
operator|new
name|OpenTxnRequest
argument_list|(
literal|3
argument_list|,
literal|"me"
argument_list|,
literal|"localhost"
argument_list|)
argument_list|)
decl_stmt|;
name|AcidOpenTxnsCounterService
name|openTxnsCounterService
init|=
operator|new
name|AcidOpenTxnsCounterService
argument_list|()
decl_stmt|;
name|openTxnsCounterService
operator|.
name|setConf
argument_list|(
name|hiveConf
argument_list|)
expr_stmt|;
name|openTxnsCounterService
operator|.
name|run
argument_list|()
expr_stmt|;
comment|// will update current number of open txns to 3
name|MetaException
name|exception
init|=
literal|null
decl_stmt|;
comment|// This should fail once it finds out the threshold has been reached
try|try
block|{
name|txnHandler
operator|.
name|openTxns
argument_list|(
operator|new
name|OpenTxnRequest
argument_list|(
literal|1
argument_list|,
literal|"you"
argument_list|,
literal|"localhost"
argument_list|)
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|MetaException
name|e
parameter_list|)
block|{
name|exception
operator|=
name|e
expr_stmt|;
block|}
name|Assert
operator|.
name|assertNotNull
argument_list|(
literal|"Opening new transaction shouldn't be allowed"
argument_list|,
name|exception
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertTrue
argument_list|(
name|exception
operator|.
name|getMessage
argument_list|()
operator|.
name|equals
argument_list|(
literal|"Maximum allowed number of open transactions has been reached. See hive.max.open.txns."
argument_list|)
argument_list|)
expr_stmt|;
comment|// After committing the initial txns, and updating current number of open txns back to 0,
comment|// new transactions should be allowed to open
for|for
control|(
name|long
name|txnid
range|:
name|openTxnsResponse
operator|.
name|getTxn_ids
argument_list|()
control|)
block|{
name|txnHandler
operator|.
name|commitTxn
argument_list|(
operator|new
name|CommitTxnRequest
argument_list|(
name|txnid
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|openTxnsCounterService
operator|.
name|run
argument_list|()
expr_stmt|;
comment|// will update current number of open txns back to 0
name|exception
operator|=
literal|null
expr_stmt|;
try|try
block|{
name|txnHandler
operator|.
name|openTxns
argument_list|(
operator|new
name|OpenTxnRequest
argument_list|(
literal|1
argument_list|,
literal|"him"
argument_list|,
literal|"localhost"
argument_list|)
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|MetaException
name|e
parameter_list|)
block|{
name|exception
operator|=
name|e
expr_stmt|;
block|}
name|Assert
operator|.
name|assertNull
argument_list|(
name|exception
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testCompactWithDelete
parameter_list|()
throws|throws
name|Exception
block|{
name|int
index|[]
index|[]
name|tableData
init|=
block|{
block|{
literal|1
block|,
literal|2
block|}
block|,
block|{
literal|3
block|,
literal|4
block|}
block|}
decl_stmt|;
name|runStatementOnDriver
argument_list|(
literal|"insert into "
operator|+
name|Table
operator|.
name|ACIDTBL
operator|+
literal|"(a,b) "
operator|+
name|makeValuesClause
argument_list|(
name|tableData
argument_list|)
argument_list|)
expr_stmt|;
name|runStatementOnDriver
argument_list|(
literal|"alter table "
operator|+
name|Table
operator|.
name|ACIDTBL
operator|+
literal|" compact 'MAJOR'"
argument_list|)
expr_stmt|;
name|runWorker
argument_list|(
name|hiveConf
argument_list|)
expr_stmt|;
name|runStatementOnDriver
argument_list|(
literal|"delete from "
operator|+
name|Table
operator|.
name|ACIDTBL
operator|+
literal|" where b = 4"
argument_list|)
expr_stmt|;
name|runStatementOnDriver
argument_list|(
literal|"update "
operator|+
name|Table
operator|.
name|ACIDTBL
operator|+
literal|" set b = -2 where b = 2"
argument_list|)
expr_stmt|;
name|runStatementOnDriver
argument_list|(
literal|"alter table "
operator|+
name|Table
operator|.
name|ACIDTBL
operator|+
literal|" compact 'MINOR'"
argument_list|)
expr_stmt|;
name|runWorker
argument_list|(
name|hiveConf
argument_list|)
expr_stmt|;
name|TxnStore
name|txnHandler
init|=
name|TxnUtils
operator|.
name|getTxnStore
argument_list|(
name|hiveConf
argument_list|)
decl_stmt|;
name|ShowCompactResponse
name|resp
init|=
name|txnHandler
operator|.
name|showCompact
argument_list|(
operator|new
name|ShowCompactRequest
argument_list|()
argument_list|)
decl_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
literal|"Unexpected number of compactions in history"
argument_list|,
literal|2
argument_list|,
name|resp
operator|.
name|getCompactsSize
argument_list|()
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
literal|"Unexpected 0 compaction state"
argument_list|,
name|TxnStore
operator|.
name|CLEANING_RESPONSE
argument_list|,
name|resp
operator|.
name|getCompacts
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|getState
argument_list|()
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
literal|"Unexpected 1 compaction state"
argument_list|,
name|TxnStore
operator|.
name|CLEANING_RESPONSE
argument_list|,
name|resp
operator|.
name|getCompacts
argument_list|()
operator|.
name|get
argument_list|(
literal|1
argument_list|)
operator|.
name|getState
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/**    * make sure Aborted txns don't red-flag a base_xxxx (HIVE-14350)    */
annotation|@
name|Test
specifier|public
name|void
name|testNoHistory
parameter_list|()
throws|throws
name|Exception
block|{
name|int
index|[]
index|[]
name|tableData
init|=
block|{
block|{
literal|1
block|,
literal|2
block|}
block|,
block|{
literal|3
block|,
literal|4
block|}
block|}
decl_stmt|;
name|runStatementOnDriver
argument_list|(
literal|"insert into "
operator|+
name|Table
operator|.
name|ACIDTBL
operator|+
literal|"(a,b) "
operator|+
name|makeValuesClause
argument_list|(
name|tableData
argument_list|)
argument_list|)
expr_stmt|;
name|hiveConf
operator|.
name|setBoolVar
argument_list|(
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVETESTMODEROLLBACKTXN
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|runStatementOnDriver
argument_list|(
literal|"insert into "
operator|+
name|Table
operator|.
name|ACIDTBL
operator|+
literal|"(a,b) "
operator|+
name|makeValuesClause
argument_list|(
name|tableData
argument_list|)
argument_list|)
expr_stmt|;
name|hiveConf
operator|.
name|setBoolVar
argument_list|(
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVETESTMODEROLLBACKTXN
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|runStatementOnDriver
argument_list|(
literal|"alter table "
operator|+
name|Table
operator|.
name|ACIDTBL
operator|+
literal|" compact 'MAJOR'"
argument_list|)
expr_stmt|;
name|runWorker
argument_list|(
name|hiveConf
argument_list|)
expr_stmt|;
name|runCleaner
argument_list|(
name|hiveConf
argument_list|)
expr_stmt|;
name|runStatementOnDriver
argument_list|(
literal|"select count(*) from "
operator|+
name|Table
operator|.
name|ACIDTBL
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testACIDwithSchemaEvolutionAndCompaction
parameter_list|()
throws|throws
name|Exception
block|{
name|testACIDwithSchemaEvolutionForVariousTblProperties
argument_list|(
literal|"'transactional'='true'"
argument_list|)
expr_stmt|;
block|}
specifier|protected
name|void
name|testACIDwithSchemaEvolutionForVariousTblProperties
parameter_list|(
name|String
name|tblProperties
parameter_list|)
throws|throws
name|Exception
block|{
name|String
name|tblName
init|=
literal|"acidWithSchemaEvol"
decl_stmt|;
name|int
name|numBuckets
init|=
literal|1
decl_stmt|;
name|runStatementOnDriver
argument_list|(
literal|"drop table if exists "
operator|+
name|tblName
argument_list|)
expr_stmt|;
name|runStatementOnDriver
argument_list|(
literal|"CREATE TABLE "
operator|+
name|tblName
operator|+
literal|"(a INT, b STRING) "
operator|+
literal|" CLUSTERED BY(a) INTO "
operator|+
name|numBuckets
operator|+
literal|" BUCKETS"
operator|+
comment|//currently ACID requires table to be bucketed
literal|" STORED AS ORC  TBLPROPERTIES ( "
operator|+
name|tblProperties
operator|+
literal|" )"
argument_list|)
expr_stmt|;
comment|// create some data
name|runStatementOnDriver
argument_list|(
literal|"insert into "
operator|+
name|tblName
operator|+
literal|" values(1, 'foo'),(2, 'bar'),(3, 'baz')"
argument_list|)
expr_stmt|;
name|runStatementOnDriver
argument_list|(
literal|"update "
operator|+
name|tblName
operator|+
literal|" set b = 'blah' where a = 3"
argument_list|)
expr_stmt|;
comment|// apply schema evolution by adding some columns
name|runStatementOnDriver
argument_list|(
literal|"alter table "
operator|+
name|tblName
operator|+
literal|" add columns(c int, d string)"
argument_list|)
expr_stmt|;
comment|// insert some data in new schema
name|runStatementOnDriver
argument_list|(
literal|"insert into "
operator|+
name|tblName
operator|+
literal|" values(4, 'acid', 100, 'orc'),"
operator|+
literal|"(5, 'llap', 200, 'tez')"
argument_list|)
expr_stmt|;
comment|// update old data with values for the new schema columns
name|runStatementOnDriver
argument_list|(
literal|"update "
operator|+
name|tblName
operator|+
literal|" set d = 'hive' where a<= 3"
argument_list|)
expr_stmt|;
name|runStatementOnDriver
argument_list|(
literal|"update "
operator|+
name|tblName
operator|+
literal|" set c = 999 where a<= 3"
argument_list|)
expr_stmt|;
comment|// read the entire data back and see if did everything right
name|List
argument_list|<
name|String
argument_list|>
name|rs
init|=
name|runStatementOnDriver
argument_list|(
literal|"select * from "
operator|+
name|tblName
operator|+
literal|" order by a"
argument_list|)
decl_stmt|;
name|String
index|[]
name|expectedResult
init|=
block|{
literal|"1\tfoo\t999\thive"
block|,
literal|"2\tbar\t999\thive"
block|,
literal|"3\tblah\t999\thive"
block|,
literal|"4\tacid\t100\torc"
block|,
literal|"5\tllap\t200\ttez"
block|}
decl_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
name|Arrays
operator|.
name|asList
argument_list|(
name|expectedResult
argument_list|)
argument_list|,
name|rs
argument_list|)
expr_stmt|;
comment|// now compact and see if compaction still preserves the data correctness
name|runStatementOnDriver
argument_list|(
literal|"alter table "
operator|+
name|tblName
operator|+
literal|" compact 'MAJOR'"
argument_list|)
expr_stmt|;
name|runWorker
argument_list|(
name|hiveConf
argument_list|)
expr_stmt|;
name|runCleaner
argument_list|(
name|hiveConf
argument_list|)
expr_stmt|;
comment|// Cleaner would remove the obsolete files.
comment|// Verify that there is now only 1 new directory: base_xxxxxxx and the rest have have been cleaned.
name|FileSystem
name|fs
init|=
name|FileSystem
operator|.
name|get
argument_list|(
name|hiveConf
argument_list|)
decl_stmt|;
name|FileStatus
index|[]
name|status
decl_stmt|;
name|status
operator|=
name|fs
operator|.
name|listStatus
argument_list|(
operator|new
name|Path
argument_list|(
name|TEST_WAREHOUSE_DIR
operator|+
literal|"/"
operator|+
name|tblName
operator|.
name|toString
argument_list|()
operator|.
name|toLowerCase
argument_list|()
argument_list|)
argument_list|,
name|FileUtils
operator|.
name|HIDDEN_FILES_PATH_FILTER
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
literal|1
argument_list|,
name|status
operator|.
name|length
argument_list|)
expr_stmt|;
name|boolean
name|sawNewBase
init|=
literal|false
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|status
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|status
index|[
name|i
index|]
operator|.
name|getPath
argument_list|()
operator|.
name|getName
argument_list|()
operator|.
name|matches
argument_list|(
literal|"base_.*"
argument_list|)
condition|)
block|{
name|sawNewBase
operator|=
literal|true
expr_stmt|;
name|FileStatus
index|[]
name|buckets
init|=
name|fs
operator|.
name|listStatus
argument_list|(
name|status
index|[
name|i
index|]
operator|.
name|getPath
argument_list|()
argument_list|,
name|FileUtils
operator|.
name|HIDDEN_FILES_PATH_FILTER
argument_list|)
decl_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
name|numBuckets
argument_list|,
name|buckets
operator|.
name|length
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertTrue
argument_list|(
name|buckets
index|[
literal|0
index|]
operator|.
name|getPath
argument_list|()
operator|.
name|getName
argument_list|()
operator|.
name|matches
argument_list|(
literal|"bucket_00000"
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|Assert
operator|.
name|assertTrue
argument_list|(
name|sawNewBase
argument_list|)
expr_stmt|;
name|rs
operator|=
name|runStatementOnDriver
argument_list|(
literal|"select * from "
operator|+
name|tblName
operator|+
literal|" order by a"
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
name|Arrays
operator|.
name|asList
argument_list|(
name|expectedResult
argument_list|)
argument_list|,
name|rs
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testETLSplitStrategyForACID
parameter_list|()
throws|throws
name|Exception
block|{
name|hiveConf
operator|.
name|setVar
argument_list|(
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVE_ORC_SPLIT_STRATEGY
argument_list|,
literal|"ETL"
argument_list|)
expr_stmt|;
name|hiveConf
operator|.
name|setBoolVar
argument_list|(
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVEOPTINDEXFILTER
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|runStatementOnDriver
argument_list|(
literal|"insert into "
operator|+
name|Table
operator|.
name|ACIDTBL
operator|+
literal|" values(1,2)"
argument_list|)
expr_stmt|;
name|runStatementOnDriver
argument_list|(
literal|"alter table "
operator|+
name|Table
operator|.
name|ACIDTBL
operator|+
literal|" compact 'MAJOR'"
argument_list|)
expr_stmt|;
name|runWorker
argument_list|(
name|hiveConf
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|rs
init|=
name|runStatementOnDriver
argument_list|(
literal|"select * from "
operator|+
name|Table
operator|.
name|ACIDTBL
operator|+
literal|" where a = 1"
argument_list|)
decl_stmt|;
name|int
index|[]
index|[]
name|resultData
init|=
operator|new
name|int
index|[]
index|[]
block|{
block|{
literal|1
block|,
literal|2
block|}
block|}
decl_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
name|stringifyValues
argument_list|(
name|resultData
argument_list|)
argument_list|,
name|rs
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testAcidWithSchemaEvolution
parameter_list|()
throws|throws
name|Exception
block|{
name|hiveConf
operator|.
name|setVar
argument_list|(
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVE_ORC_SPLIT_STRATEGY
argument_list|,
literal|"ETL"
argument_list|)
expr_stmt|;
name|String
name|tblName
init|=
literal|"acidTblWithSchemaEvol"
decl_stmt|;
name|runStatementOnDriver
argument_list|(
literal|"drop table if exists "
operator|+
name|tblName
argument_list|)
expr_stmt|;
name|runStatementOnDriver
argument_list|(
literal|"CREATE TABLE "
operator|+
name|tblName
operator|+
literal|"(a INT, b STRING) "
operator|+
literal|" CLUSTERED BY(a) INTO 2 BUCKETS"
operator|+
comment|//currently ACID requires table to be bucketed
literal|" STORED AS ORC TBLPROPERTIES ('transactional'='true')"
argument_list|)
expr_stmt|;
name|runStatementOnDriver
argument_list|(
literal|"INSERT INTO "
operator|+
name|tblName
operator|+
literal|" VALUES (1, 'foo'), (2, 'bar')"
argument_list|)
expr_stmt|;
comment|// Major compact to create a base that has ACID schema.
name|runStatementOnDriver
argument_list|(
literal|"ALTER TABLE "
operator|+
name|tblName
operator|+
literal|" COMPACT 'MAJOR'"
argument_list|)
expr_stmt|;
name|runWorker
argument_list|(
name|hiveConf
argument_list|)
expr_stmt|;
comment|// Alter table for perform schema evolution.
name|runStatementOnDriver
argument_list|(
literal|"ALTER TABLE "
operator|+
name|tblName
operator|+
literal|" ADD COLUMNS(c int)"
argument_list|)
expr_stmt|;
comment|// Validate there is an added NULL for column c.
name|List
argument_list|<
name|String
argument_list|>
name|rs
init|=
name|runStatementOnDriver
argument_list|(
literal|"SELECT * FROM "
operator|+
name|tblName
operator|+
literal|" ORDER BY a"
argument_list|)
decl_stmt|;
name|String
index|[]
name|expectedResult
init|=
block|{
literal|"1\tfoo\tNULL"
block|,
literal|"2\tbar\tNULL"
block|}
decl_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
name|Arrays
operator|.
name|asList
argument_list|(
name|expectedResult
argument_list|)
argument_list|,
name|rs
argument_list|)
expr_stmt|;
block|}
comment|/**    * Test that ACID works with multi-insert statement    */
annotation|@
name|Test
specifier|public
name|void
name|testMultiInsertStatement
parameter_list|()
throws|throws
name|Exception
block|{
name|int
index|[]
index|[]
name|sourceValsOdd
init|=
block|{
block|{
literal|5
block|,
literal|5
block|}
block|,
block|{
literal|11
block|,
literal|11
block|}
block|}
decl_stmt|;
name|int
index|[]
index|[]
name|sourceValsEven
init|=
block|{
block|{
literal|2
block|,
literal|2
block|}
block|}
decl_stmt|;
comment|//populate source
name|runStatementOnDriver
argument_list|(
literal|"insert into "
operator|+
name|Table
operator|.
name|NONACIDPART2
operator|+
literal|" PARTITION(p2='odd') "
operator|+
name|makeValuesClause
argument_list|(
name|sourceValsOdd
argument_list|)
argument_list|)
expr_stmt|;
name|runStatementOnDriver
argument_list|(
literal|"insert into "
operator|+
name|Table
operator|.
name|NONACIDPART2
operator|+
literal|" PARTITION(p2='even') "
operator|+
name|makeValuesClause
argument_list|(
name|sourceValsEven
argument_list|)
argument_list|)
expr_stmt|;
name|int
index|[]
index|[]
name|targetValsOdd
init|=
block|{
block|{
literal|5
block|,
literal|6
block|}
block|,
block|{
literal|7
block|,
literal|8
block|}
block|}
decl_stmt|;
name|int
index|[]
index|[]
name|targetValsEven
init|=
block|{
block|{
literal|2
block|,
literal|1
block|}
block|,
block|{
literal|4
block|,
literal|3
block|}
block|}
decl_stmt|;
comment|//populate target
name|runStatementOnDriver
argument_list|(
literal|"insert into "
operator|+
name|Table
operator|.
name|ACIDTBLPART
operator|+
literal|" PARTITION(p='odd') "
operator|+
name|makeValuesClause
argument_list|(
name|targetValsOdd
argument_list|)
argument_list|)
expr_stmt|;
name|runStatementOnDriver
argument_list|(
literal|"insert into "
operator|+
name|Table
operator|.
name|ACIDTBLPART
operator|+
literal|" PARTITION(p='even') "
operator|+
name|makeValuesClause
argument_list|(
name|targetValsEven
argument_list|)
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|r
init|=
name|runStatementOnDriver
argument_list|(
literal|"select a,b from "
operator|+
name|Table
operator|.
name|ACIDTBLPART
operator|+
literal|" order by a,b"
argument_list|)
decl_stmt|;
name|int
index|[]
index|[]
name|targetVals
init|=
block|{
block|{
literal|2
block|,
literal|1
block|}
block|,
block|{
literal|4
block|,
literal|3
block|}
block|,
block|{
literal|5
block|,
literal|6
block|}
block|,
block|{
literal|7
block|,
literal|8
block|}
block|}
decl_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
name|stringifyValues
argument_list|(
name|targetVals
argument_list|)
argument_list|,
name|r
argument_list|)
expr_stmt|;
comment|//currently multi-insrt doesn't allow same table/partition in> 1 output branch
name|String
name|s
init|=
literal|"from "
operator|+
name|Table
operator|.
name|ACIDTBLPART
operator|+
literal|"  target right outer join "
operator|+
name|Table
operator|.
name|NONACIDPART2
operator|+
literal|" source on target.a = source.a2 "
operator|+
literal|" INSERT INTO TABLE "
operator|+
name|Table
operator|.
name|ACIDTBLPART
operator|+
literal|" PARTITION(p='even') select source.a2, source.b2 where source.a2=target.a "
operator|+
literal|" insert into table "
operator|+
name|Table
operator|.
name|ACIDTBLPART
operator|+
literal|" PARTITION(p='odd') select source.a2,source.b2 where target.a is null"
decl_stmt|;
comment|//r = runStatementOnDriver("explain formatted " + s);
comment|//LOG.info("Explain formatted: " + r.toString());
name|runStatementOnDriver
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|r
operator|=
name|runStatementOnDriver
argument_list|(
literal|"select a,b from "
operator|+
name|Table
operator|.
name|ACIDTBLPART
operator|+
literal|" where p='even' order by a,b"
argument_list|)
expr_stmt|;
name|int
index|[]
index|[]
name|rExpected
init|=
block|{
block|{
literal|2
block|,
literal|1
block|}
block|,
block|{
literal|2
block|,
literal|2
block|}
block|,
block|{
literal|4
block|,
literal|3
block|}
block|,
block|{
literal|5
block|,
literal|5
block|}
block|}
decl_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
name|stringifyValues
argument_list|(
name|rExpected
argument_list|)
argument_list|,
name|r
argument_list|)
expr_stmt|;
name|r
operator|=
name|runStatementOnDriver
argument_list|(
literal|"select a,b from "
operator|+
name|Table
operator|.
name|ACIDTBLPART
operator|+
literal|" where p='odd' order by a,b"
argument_list|)
expr_stmt|;
name|int
index|[]
index|[]
name|rExpected2
init|=
block|{
block|{
literal|5
block|,
literal|6
block|}
block|,
block|{
literal|7
block|,
literal|8
block|}
block|,
block|{
literal|11
block|,
literal|11
block|}
block|}
decl_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
name|stringifyValues
argument_list|(
name|rExpected2
argument_list|)
argument_list|,
name|r
argument_list|)
expr_stmt|;
block|}
comment|/**    * check that we can specify insert columns    *    * Need to figure out semantics: what if a row from base expr ends up in both Update and Delete clauses we'll write    * Update event to 1 delta and Delete to another.  Given that we collapse events for same current txn for different stmt ids    * to the latest one, delete will win.    * In Acid 2.0 we'll end up with 2 Delete events for the same PK.  Logically should be OK, but may break Vectorized reader impl.... need to check    *    * 1:M from target to source results in ambiguous write to target - SQL Standard expects an error.  (I have an argument on how    * to solve this with minor mods to Join operator written down somewhere)    *    * Only need 1 Stats task for MERGE (currently we get 1 per branch).    * Should also eliminate Move task - that's a general ACID task    */
specifier|private
name|void
name|logResuts
parameter_list|(
name|List
argument_list|<
name|String
argument_list|>
name|r
parameter_list|,
name|String
name|header
parameter_list|,
name|String
name|prefix
parameter_list|)
block|{
name|LOG
operator|.
name|info
argument_list|(
name|prefix
operator|+
literal|" "
operator|+
name|header
argument_list|)
expr_stmt|;
name|StringBuilder
name|sb
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|int
name|numLines
init|=
literal|0
decl_stmt|;
for|for
control|(
name|String
name|line
range|:
name|r
control|)
block|{
name|numLines
operator|++
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
name|prefix
argument_list|)
operator|.
name|append
argument_list|(
name|line
argument_list|)
operator|.
name|append
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
name|LOG
operator|.
name|info
argument_list|(
name|sb
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
name|prefix
operator|+
literal|" Printed "
operator|+
name|numLines
operator|+
literal|" lines"
argument_list|)
expr_stmt|;
block|}
comment|/**    * This tests that we handle non-trivial ON clause correctly    * @throws Exception    */
annotation|@
name|Test
specifier|public
name|void
name|testMerge
parameter_list|()
throws|throws
name|Exception
block|{
name|int
index|[]
index|[]
name|baseValsOdd
init|=
block|{
block|{
literal|5
block|,
literal|5
block|}
block|,
block|{
literal|11
block|,
literal|11
block|}
block|}
decl_stmt|;
name|runStatementOnDriver
argument_list|(
literal|"insert into "
operator|+
name|Table
operator|.
name|NONACIDPART2
operator|+
literal|" PARTITION(p2='odd') "
operator|+
name|makeValuesClause
argument_list|(
name|baseValsOdd
argument_list|)
argument_list|)
expr_stmt|;
name|int
index|[]
index|[]
name|vals
init|=
block|{
block|{
literal|2
block|,
literal|1
block|}
block|,
block|{
literal|4
block|,
literal|3
block|}
block|,
block|{
literal|5
block|,
literal|6
block|}
block|,
block|{
literal|7
block|,
literal|8
block|}
block|}
decl_stmt|;
name|runStatementOnDriver
argument_list|(
literal|"insert into "
operator|+
name|Table
operator|.
name|ACIDTBL
operator|+
literal|" "
operator|+
name|makeValuesClause
argument_list|(
name|vals
argument_list|)
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|r
init|=
name|runStatementOnDriver
argument_list|(
literal|"select a,b from "
operator|+
name|Table
operator|.
name|ACIDTBL
operator|+
literal|" order by a,b"
argument_list|)
decl_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
name|stringifyValues
argument_list|(
name|vals
argument_list|)
argument_list|,
name|r
argument_list|)
expr_stmt|;
name|String
name|query
init|=
literal|"merge into "
operator|+
name|Table
operator|.
name|ACIDTBL
operator|+
literal|" using "
operator|+
name|Table
operator|.
name|NONACIDPART2
operator|+
literal|" source ON "
operator|+
name|Table
operator|.
name|ACIDTBL
operator|+
literal|".a = a2 and b + 1 = source.b2 + 1 "
operator|+
literal|"WHEN MATCHED THEN UPDATE set b = source.b2 "
operator|+
literal|"WHEN NOT MATCHED THEN INSERT VALUES(source.a2, source.b2)"
decl_stmt|;
name|runStatementOnDriver
argument_list|(
name|query
argument_list|)
expr_stmt|;
name|r
operator|=
name|runStatementOnDriver
argument_list|(
literal|"select a,b from "
operator|+
name|Table
operator|.
name|ACIDTBL
operator|+
literal|" order by a,b"
argument_list|)
expr_stmt|;
name|int
index|[]
index|[]
name|rExpected
init|=
block|{
block|{
literal|2
block|,
literal|1
block|}
block|,
block|{
literal|4
block|,
literal|3
block|}
block|,
block|{
literal|5
block|,
literal|5
block|}
block|,
block|{
literal|5
block|,
literal|6
block|}
block|,
block|{
literal|7
block|,
literal|8
block|}
block|,
block|{
literal|11
block|,
literal|11
block|}
block|}
decl_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
name|stringifyValues
argument_list|(
name|rExpected
argument_list|)
argument_list|,
name|r
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testMergeWithPredicate
parameter_list|()
throws|throws
name|Exception
block|{
name|int
index|[]
index|[]
name|baseValsOdd
init|=
block|{
block|{
literal|2
block|,
literal|2
block|}
block|,
block|{
literal|5
block|,
literal|5
block|}
block|,
block|{
literal|8
block|,
literal|8
block|}
block|,
block|{
literal|11
block|,
literal|11
block|}
block|}
decl_stmt|;
name|runStatementOnDriver
argument_list|(
literal|"insert into "
operator|+
name|Table
operator|.
name|NONACIDPART2
operator|+
literal|" PARTITION(p2='odd') "
operator|+
name|makeValuesClause
argument_list|(
name|baseValsOdd
argument_list|)
argument_list|)
expr_stmt|;
name|int
index|[]
index|[]
name|vals
init|=
block|{
block|{
literal|2
block|,
literal|1
block|}
block|,
block|{
literal|4
block|,
literal|3
block|}
block|,
block|{
literal|5
block|,
literal|6
block|}
block|,
block|{
literal|7
block|,
literal|8
block|}
block|}
decl_stmt|;
name|runStatementOnDriver
argument_list|(
literal|"insert into "
operator|+
name|Table
operator|.
name|ACIDTBL
operator|+
literal|" "
operator|+
name|makeValuesClause
argument_list|(
name|vals
argument_list|)
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|r
init|=
name|runStatementOnDriver
argument_list|(
literal|"select a,b from "
operator|+
name|Table
operator|.
name|ACIDTBL
operator|+
literal|" order by a,b"
argument_list|)
decl_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
name|stringifyValues
argument_list|(
name|vals
argument_list|)
argument_list|,
name|r
argument_list|)
expr_stmt|;
name|String
name|query
init|=
literal|"merge into "
operator|+
name|Table
operator|.
name|ACIDTBL
operator|+
literal|" t using "
operator|+
name|Table
operator|.
name|NONACIDPART2
operator|+
literal|" s ON t.a = s.a2 "
operator|+
literal|"WHEN MATCHED AND t.b between 1 and 3 THEN UPDATE set b = s.b2 "
operator|+
literal|"WHEN NOT MATCHED and s.b2>= 8 THEN INSERT VALUES(s.a2, s.b2)"
decl_stmt|;
name|runStatementOnDriver
argument_list|(
name|query
argument_list|)
expr_stmt|;
name|r
operator|=
name|runStatementOnDriver
argument_list|(
literal|"select a,b from "
operator|+
name|Table
operator|.
name|ACIDTBL
operator|+
literal|" order by a,b"
argument_list|)
expr_stmt|;
name|int
index|[]
index|[]
name|rExpected
init|=
block|{
block|{
literal|2
block|,
literal|2
block|}
block|,
block|{
literal|4
block|,
literal|3
block|}
block|,
block|{
literal|5
block|,
literal|6
block|}
block|,
block|{
literal|7
block|,
literal|8
block|}
block|,
block|{
literal|8
block|,
literal|8
block|}
block|,
block|{
literal|11
block|,
literal|11
block|}
block|}
decl_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
name|stringifyValues
argument_list|(
name|rExpected
argument_list|)
argument_list|,
name|r
argument_list|)
expr_stmt|;
name|assertUniqueID
argument_list|(
name|Table
operator|.
name|ACIDTBL
argument_list|)
expr_stmt|;
block|}
comment|/**    * Test combines update + insert clauses    * @throws Exception    */
annotation|@
name|Test
specifier|public
name|void
name|testMerge2
parameter_list|()
throws|throws
name|Exception
block|{
name|int
index|[]
index|[]
name|baseValsOdd
init|=
block|{
block|{
literal|5
block|,
literal|5
block|}
block|,
block|{
literal|11
block|,
literal|11
block|}
block|}
decl_stmt|;
name|int
index|[]
index|[]
name|baseValsEven
init|=
block|{
block|{
literal|2
block|,
literal|2
block|}
block|,
block|{
literal|4
block|,
literal|44
block|}
block|}
decl_stmt|;
name|runStatementOnDriver
argument_list|(
literal|"insert into "
operator|+
name|Table
operator|.
name|NONACIDPART2
operator|+
literal|" PARTITION(p2='odd') "
operator|+
name|makeValuesClause
argument_list|(
name|baseValsOdd
argument_list|)
argument_list|)
expr_stmt|;
name|runStatementOnDriver
argument_list|(
literal|"insert into "
operator|+
name|Table
operator|.
name|NONACIDPART2
operator|+
literal|" PARTITION(p2='even') "
operator|+
name|makeValuesClause
argument_list|(
name|baseValsEven
argument_list|)
argument_list|)
expr_stmt|;
name|int
index|[]
index|[]
name|vals
init|=
block|{
block|{
literal|2
block|,
literal|1
block|}
block|,
block|{
literal|4
block|,
literal|3
block|}
block|,
block|{
literal|5
block|,
literal|6
block|}
block|,
block|{
literal|7
block|,
literal|8
block|}
block|}
decl_stmt|;
name|runStatementOnDriver
argument_list|(
literal|"insert into "
operator|+
name|Table
operator|.
name|ACIDTBL
operator|+
literal|" "
operator|+
name|makeValuesClause
argument_list|(
name|vals
argument_list|)
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|r
init|=
name|runStatementOnDriver
argument_list|(
literal|"select a,b from "
operator|+
name|Table
operator|.
name|ACIDTBL
operator|+
literal|" order by a,b"
argument_list|)
decl_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
name|stringifyValues
argument_list|(
name|vals
argument_list|)
argument_list|,
name|r
argument_list|)
expr_stmt|;
name|String
name|query
init|=
literal|"merge into "
operator|+
name|Table
operator|.
name|ACIDTBL
operator|+
literal|" using "
operator|+
name|Table
operator|.
name|NONACIDPART2
operator|+
literal|" source ON "
operator|+
name|Table
operator|.
name|ACIDTBL
operator|+
literal|".a = source.a2 "
operator|+
literal|"WHEN MATCHED THEN UPDATE set b = source.b2 "
operator|+
literal|"WHEN NOT MATCHED THEN INSERT VALUES(source.a2, source.b2) "
decl_stmt|;
comment|//AND b< 1
name|r
operator|=
name|runStatementOnDriver
argument_list|(
name|query
argument_list|)
expr_stmt|;
comment|//r = runStatementOnDriver("explain  " + query);
comment|//logResuts(r, "Explain logical1", "");
name|r
operator|=
name|runStatementOnDriver
argument_list|(
literal|"select a,b from "
operator|+
name|Table
operator|.
name|ACIDTBL
operator|+
literal|" order by a,b"
argument_list|)
expr_stmt|;
name|int
index|[]
index|[]
name|rExpected
init|=
block|{
block|{
literal|2
block|,
literal|2
block|}
block|,
block|{
literal|4
block|,
literal|44
block|}
block|,
block|{
literal|5
block|,
literal|5
block|}
block|,
block|{
literal|7
block|,
literal|8
block|}
block|,
block|{
literal|11
block|,
literal|11
block|}
block|}
decl_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
name|stringifyValues
argument_list|(
name|rExpected
argument_list|)
argument_list|,
name|r
argument_list|)
expr_stmt|;
name|assertUniqueID
argument_list|(
name|Table
operator|.
name|ACIDTBL
argument_list|)
expr_stmt|;
block|}
comment|/**    * test combines delete + insert clauses    * @throws Exception    */
annotation|@
name|Test
specifier|public
name|void
name|testMerge3
parameter_list|()
throws|throws
name|Exception
block|{
name|int
index|[]
index|[]
name|baseValsOdd
init|=
block|{
block|{
literal|5
block|,
literal|5
block|}
block|,
block|{
literal|11
block|,
literal|11
block|}
block|}
decl_stmt|;
name|int
index|[]
index|[]
name|baseValsEven
init|=
block|{
block|{
literal|2
block|,
literal|2
block|}
block|,
block|{
literal|4
block|,
literal|44
block|}
block|}
decl_stmt|;
name|runStatementOnDriver
argument_list|(
literal|"insert into "
operator|+
name|Table
operator|.
name|NONACIDPART2
operator|+
literal|" PARTITION(p2='odd') "
operator|+
name|makeValuesClause
argument_list|(
name|baseValsOdd
argument_list|)
argument_list|)
expr_stmt|;
name|runStatementOnDriver
argument_list|(
literal|"insert into "
operator|+
name|Table
operator|.
name|NONACIDPART2
operator|+
literal|" PARTITION(p2='even') "
operator|+
name|makeValuesClause
argument_list|(
name|baseValsEven
argument_list|)
argument_list|)
expr_stmt|;
name|int
index|[]
index|[]
name|vals
init|=
block|{
block|{
literal|2
block|,
literal|1
block|}
block|,
block|{
literal|4
block|,
literal|3
block|}
block|,
block|{
literal|5
block|,
literal|6
block|}
block|,
block|{
literal|7
block|,
literal|8
block|}
block|}
decl_stmt|;
name|runStatementOnDriver
argument_list|(
literal|"insert into "
operator|+
name|Table
operator|.
name|ACIDTBL
operator|+
literal|" "
operator|+
name|makeValuesClause
argument_list|(
name|vals
argument_list|)
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|r
init|=
name|runStatementOnDriver
argument_list|(
literal|"select a,b from "
operator|+
name|Table
operator|.
name|ACIDTBL
operator|+
literal|" order by a,b"
argument_list|)
decl_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
name|stringifyValues
argument_list|(
name|vals
argument_list|)
argument_list|,
name|r
argument_list|)
expr_stmt|;
name|String
name|query
init|=
literal|"merge into "
operator|+
name|Table
operator|.
name|ACIDTBL
operator|+
literal|" using "
operator|+
name|Table
operator|.
name|NONACIDPART2
operator|+
literal|" source ON "
operator|+
name|Table
operator|.
name|ACIDTBL
operator|+
literal|".a = source.a2 "
operator|+
literal|"WHEN MATCHED THEN DELETE "
operator|+
literal|"WHEN NOT MATCHED THEN INSERT VALUES(source.a2, source.b2) "
decl_stmt|;
name|runStatementOnDriver
argument_list|(
name|query
argument_list|)
expr_stmt|;
name|r
operator|=
name|runStatementOnDriver
argument_list|(
literal|"select a,b from "
operator|+
name|Table
operator|.
name|ACIDTBL
operator|+
literal|" order by a,b"
argument_list|)
expr_stmt|;
name|int
index|[]
index|[]
name|rExpected
init|=
block|{
block|{
literal|7
block|,
literal|8
block|}
block|,
block|{
literal|11
block|,
literal|11
block|}
block|}
decl_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
name|stringifyValues
argument_list|(
name|rExpected
argument_list|)
argument_list|,
name|r
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testMultiInsert
parameter_list|()
throws|throws
name|Exception
block|{
name|runStatementOnDriver
argument_list|(
literal|"create temporary table if not exists data1 (x int)"
argument_list|)
expr_stmt|;
name|runStatementOnDriver
argument_list|(
literal|"insert into data1 values (1),(2),(1)"
argument_list|)
expr_stmt|;
name|d
operator|.
name|destroy
argument_list|()
expr_stmt|;
name|hiveConf
operator|.
name|setVar
argument_list|(
name|HiveConf
operator|.
name|ConfVars
operator|.
name|DYNAMICPARTITIONINGMODE
argument_list|,
literal|"nonstrict"
argument_list|)
expr_stmt|;
name|d
operator|=
operator|new
name|Driver
argument_list|(
name|hiveConf
argument_list|)
expr_stmt|;
name|runStatementOnDriver
argument_list|(
literal|" from data1 "
operator|+
literal|"insert into "
operator|+
name|Table
operator|.
name|ACIDTBLPART
operator|+
literal|" partition(p) select 0, 0, 'p' || x  "
operator|+
literal|"insert into "
operator|+
name|Table
operator|.
name|ACIDTBLPART
operator|+
literal|" partition(p='p1') select 0, 1"
argument_list|)
expr_stmt|;
comment|/**      * Using {@link BucketCodec.V0} the output      * is missing 1 of the (p1,0,1) rows because they have the same ROW__ID and only differ by      * StatementId so {@link org.apache.hadoop.hive.ql.io.orc.OrcRawRecordMerger} skips one.      * With split update (and V0), the data is read correctly (insert deltas are now the base) but we still      * should get duplicate ROW__IDs.      */
name|List
argument_list|<
name|String
argument_list|>
name|r
init|=
name|runStatementOnDriver
argument_list|(
literal|"select p,a,b from "
operator|+
name|Table
operator|.
name|ACIDTBLPART
operator|+
literal|" order by p, a, b"
argument_list|)
decl_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
literal|"[p1\t0\t0, p1\t0\t0, p1\t0\t1, p1\t0\t1, p1\t0\t1, p2\t0\t0]"
argument_list|,
name|r
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|assertUniqueID
argument_list|(
name|Table
operator|.
name|ACIDTBLPART
argument_list|)
expr_stmt|;
comment|/**      * this delete + select covers VectorizedOrcAcidRowBatchReader      */
name|runStatementOnDriver
argument_list|(
literal|"delete from "
operator|+
name|Table
operator|.
name|ACIDTBLPART
argument_list|)
expr_stmt|;
name|r
operator|=
name|runStatementOnDriver
argument_list|(
literal|"select p,a,b from "
operator|+
name|Table
operator|.
name|ACIDTBLPART
operator|+
literal|" order by p, a, b"
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
literal|"[]"
argument_list|,
name|r
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/**    * Investigating DP and WriteEntity, etc    * @throws Exception    */
annotation|@
name|Test
annotation|@
name|Ignore
specifier|public
name|void
name|testDynamicPartitions
parameter_list|()
throws|throws
name|Exception
block|{
name|d
operator|.
name|destroy
argument_list|()
expr_stmt|;
name|hiveConf
operator|.
name|setVar
argument_list|(
name|HiveConf
operator|.
name|ConfVars
operator|.
name|DYNAMICPARTITIONINGMODE
argument_list|,
literal|"nonstrict"
argument_list|)
expr_stmt|;
comment|//In DbTxnManager.acquireLocks() we have
comment|// 1 ReadEntity: default@values__tmp__table__1
comment|// 1 WriteEntity: default@acidtblpart Type=TABLE WriteType=INSERT isDP=false
name|runStatementOnDriver
argument_list|(
literal|"insert into "
operator|+
name|Table
operator|.
name|ACIDTBLPART
operator|+
literal|" partition(p) values(1,1,'p1'),(2,2,'p1'),(3,3,'p1'),(4,4,'p2')"
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|r1
init|=
name|runStatementOnDriver
argument_list|(
literal|"select count(*) from "
operator|+
name|Table
operator|.
name|ACIDTBLPART
argument_list|)
decl_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
literal|"4"
argument_list|,
name|r1
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
comment|//In DbTxnManager.acquireLocks() we have
comment|// 2 ReadEntity: [default@acidtblpart@p=p1, default@acidtblpart]
comment|// 1 WriteEntity: default@acidtblpart Type=TABLE WriteType=INSERT isDP=false
comment|//todo: side note on the above: LockRequestBuilder combines the both default@acidtblpart entries to 1
name|runStatementOnDriver
argument_list|(
literal|"insert into "
operator|+
name|Table
operator|.
name|ACIDTBLPART
operator|+
literal|" partition(p) select * from "
operator|+
name|Table
operator|.
name|ACIDTBLPART
operator|+
literal|" where p='p1'"
argument_list|)
expr_stmt|;
comment|//In DbTxnManager.acquireLocks() we have
comment|// 2 ReadEntity: [default@acidtblpart@p=p1, default@acidtblpart]
comment|// 1 WriteEntity: default@acidtblpart@p=p2 Type=PARTITION WriteType=INSERT isDP=false
name|runStatementOnDriver
argument_list|(
literal|"insert into "
operator|+
name|Table
operator|.
name|ACIDTBLPART
operator|+
literal|" partition(p='p2') select a,b from "
operator|+
name|Table
operator|.
name|ACIDTBLPART
operator|+
literal|" where p='p1'"
argument_list|)
expr_stmt|;
comment|//In UpdateDeleteSemanticAnalyzer, after super analyze
comment|// 3 ReadEntity: [default@acidtblpart, default@acidtblpart@p=p1, default@acidtblpart@p=p2]
comment|// 1 WriteEntity: [default@acidtblpart TABLE/INSERT]
comment|//after UDSA
comment|// Read [default@acidtblpart, default@acidtblpart@p=p1, default@acidtblpart@p=p2]
comment|// Write [default@acidtblpart@p=p1, default@acidtblpart@p=p2] - PARTITION/UPDATE, PARTITION/UPDATE
comment|//todo: Why acquire per partition locks - if you have many partitions that's hugely inefficient.
comment|//could acquire 1 table level Shared_write intead
name|runStatementOnDriver
argument_list|(
literal|"update "
operator|+
name|Table
operator|.
name|ACIDTBLPART
operator|+
literal|" set b = 1"
argument_list|)
expr_stmt|;
comment|//In UpdateDeleteSemanticAnalyzer, after super analyze
comment|// Read [default@acidtblpart, default@acidtblpart@p=p1]
comment|// Write default@acidtblpart TABLE/INSERT
comment|//after UDSA
comment|// Read [default@acidtblpart, default@acidtblpart@p=p1]
comment|// Write [default@acidtblpart@p=p1] PARTITION/UPDATE
comment|//todo: this causes a Read lock on the whole table - clearly overkill
comment|//for Update/Delete we always write exactly (at most actually) the partitions we read
name|runStatementOnDriver
argument_list|(
literal|"update "
operator|+
name|Table
operator|.
name|ACIDTBLPART
operator|+
literal|" set b = 1 where p='p1'"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testDynamicPartitionsMerge
parameter_list|()
throws|throws
name|Exception
block|{
name|d
operator|.
name|destroy
argument_list|()
expr_stmt|;
name|hiveConf
operator|.
name|setVar
argument_list|(
name|HiveConf
operator|.
name|ConfVars
operator|.
name|DYNAMICPARTITIONINGMODE
argument_list|,
literal|"nonstrict"
argument_list|)
expr_stmt|;
name|runStatementOnDriver
argument_list|(
literal|"insert into "
operator|+
name|Table
operator|.
name|ACIDTBLPART
operator|+
literal|" partition(p) values(1,1,'p1'),(2,2,'p1'),(3,3,'p1'),(4,4,'p2')"
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|r1
init|=
name|runStatementOnDriver
argument_list|(
literal|"select count(*) from "
operator|+
name|Table
operator|.
name|ACIDTBLPART
argument_list|)
decl_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
literal|"4"
argument_list|,
name|r1
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|int
index|[]
index|[]
name|sourceVals
init|=
block|{
block|{
literal|2
block|,
literal|15
block|}
block|,
block|{
literal|4
block|,
literal|44
block|}
block|,
block|{
literal|5
block|,
literal|5
block|}
block|,
block|{
literal|11
block|,
literal|11
block|}
block|}
decl_stmt|;
name|runStatementOnDriver
argument_list|(
literal|"insert into "
operator|+
name|Table
operator|.
name|NONACIDORCTBL
operator|+
literal|" "
operator|+
name|makeValuesClause
argument_list|(
name|sourceVals
argument_list|)
argument_list|)
expr_stmt|;
name|runStatementOnDriver
argument_list|(
literal|"merge into "
operator|+
name|Table
operator|.
name|ACIDTBLPART
operator|+
literal|" using "
operator|+
name|Table
operator|.
name|NONACIDORCTBL
operator|+
literal|" as s ON "
operator|+
name|Table
operator|.
name|ACIDTBLPART
operator|+
literal|".a = s.a "
operator|+
literal|"when matched then update set b = s.b "
operator|+
literal|"when not matched then insert values(s.a, s.b, 'new part')"
argument_list|)
expr_stmt|;
name|r1
operator|=
name|runStatementOnDriver
argument_list|(
literal|"select p,a,b from "
operator|+
name|Table
operator|.
name|ACIDTBLPART
operator|+
literal|" order by p, a, b"
argument_list|)
expr_stmt|;
name|String
name|result
init|=
name|r1
operator|.
name|toString
argument_list|()
decl_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
literal|"[new part\t5\t5, new part\t11\t11, p1\t1\t1, p1\t2\t15, p1\t3\t3, p2\t4\t44]"
argument_list|,
name|result
argument_list|)
expr_stmt|;
comment|//note: inserts go into 'new part'... so this won't fail
name|assertUniqueID
argument_list|(
name|Table
operator|.
name|ACIDTBLPART
argument_list|)
expr_stmt|;
block|}
comment|/**    * Using nested partitions and thus DummyPartition    * @throws Exception    */
annotation|@
name|Test
specifier|public
name|void
name|testDynamicPartitionsMerge2
parameter_list|()
throws|throws
name|Exception
block|{
name|d
operator|.
name|destroy
argument_list|()
expr_stmt|;
name|hiveConf
operator|.
name|setVar
argument_list|(
name|HiveConf
operator|.
name|ConfVars
operator|.
name|DYNAMICPARTITIONINGMODE
argument_list|,
literal|"nonstrict"
argument_list|)
expr_stmt|;
name|int
index|[]
index|[]
name|targetVals
init|=
block|{
block|{
literal|1
block|,
literal|1
block|,
literal|1
block|}
block|,
block|{
literal|2
block|,
literal|2
block|,
literal|2
block|}
block|,
block|{
literal|3
block|,
literal|3
block|,
literal|1
block|}
block|,
block|{
literal|4
block|,
literal|4
block|,
literal|2
block|}
block|}
decl_stmt|;
name|runStatementOnDriver
argument_list|(
literal|"insert into "
operator|+
name|Table
operator|.
name|ACIDNESTEDPART
operator|+
literal|" partition(p=1,q) "
operator|+
name|makeValuesClause
argument_list|(
name|targetVals
argument_list|)
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|r1
init|=
name|runStatementOnDriver
argument_list|(
literal|"select count(*) from "
operator|+
name|Table
operator|.
name|ACIDNESTEDPART
argument_list|)
decl_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
literal|"4"
argument_list|,
name|r1
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|int
index|[]
index|[]
name|sourceVals
init|=
block|{
block|{
literal|2
block|,
literal|15
block|}
block|,
block|{
literal|4
block|,
literal|44
block|}
block|,
block|{
literal|5
block|,
literal|5
block|}
block|,
block|{
literal|11
block|,
literal|11
block|}
block|}
decl_stmt|;
name|runStatementOnDriver
argument_list|(
literal|"insert into "
operator|+
name|Table
operator|.
name|NONACIDORCTBL
operator|+
literal|" "
operator|+
name|makeValuesClause
argument_list|(
name|sourceVals
argument_list|)
argument_list|)
expr_stmt|;
name|runStatementOnDriver
argument_list|(
literal|"merge into "
operator|+
name|Table
operator|.
name|ACIDNESTEDPART
operator|+
literal|" using "
operator|+
name|Table
operator|.
name|NONACIDORCTBL
operator|+
literal|" as s ON "
operator|+
name|Table
operator|.
name|ACIDNESTEDPART
operator|+
literal|".a = s.a "
operator|+
literal|"when matched then update set b = s.b "
operator|+
literal|"when not matched then insert values(s.a, s.b, 3,4)"
argument_list|)
expr_stmt|;
name|r1
operator|=
name|runStatementOnDriver
argument_list|(
literal|"select p,q,a,b from "
operator|+
name|Table
operator|.
name|ACIDNESTEDPART
operator|+
literal|" order by p,q, a, b"
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
name|stringifyValues
argument_list|(
operator|new
name|int
index|[]
index|[]
block|{
block|{
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|}
block|,
block|{
literal|1
block|,
literal|1
block|,
literal|3
block|,
literal|3
block|}
block|,
block|{
literal|1
block|,
literal|2
block|,
literal|2
block|,
literal|15
block|}
block|,
block|{
literal|1
block|,
literal|2
block|,
literal|4
block|,
literal|44
block|}
block|,
block|{
literal|3
block|,
literal|4
block|,
literal|5
block|,
literal|5
block|}
block|,
block|{
literal|3
block|,
literal|4
block|,
literal|11
block|,
literal|11
block|}
block|}
argument_list|)
argument_list|,
name|r1
argument_list|)
expr_stmt|;
comment|//insert of merge lands in part (3,4) - no updates land there
name|assertUniqueID
argument_list|(
name|Table
operator|.
name|ACIDNESTEDPART
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Ignore
argument_list|(
literal|"Covered elsewhere"
argument_list|)
annotation|@
name|Test
specifier|public
name|void
name|testMergeAliasedTarget
parameter_list|()
throws|throws
name|Exception
block|{
name|int
index|[]
index|[]
name|baseValsOdd
init|=
block|{
block|{
literal|2
block|,
literal|2
block|}
block|,
block|{
literal|4
block|,
literal|44
block|}
block|,
block|{
literal|5
block|,
literal|5
block|}
block|,
block|{
literal|11
block|,
literal|11
block|}
block|}
decl_stmt|;
name|runStatementOnDriver
argument_list|(
literal|"insert into "
operator|+
name|Table
operator|.
name|NONACIDORCTBL
operator|+
literal|" "
operator|+
name|makeValuesClause
argument_list|(
name|baseValsOdd
argument_list|)
argument_list|)
expr_stmt|;
name|int
index|[]
index|[]
name|vals
init|=
block|{
block|{
literal|2
block|,
literal|1
block|}
block|,
block|{
literal|4
block|,
literal|3
block|}
block|,
block|{
literal|5
block|,
literal|6
block|}
block|,
block|{
literal|7
block|,
literal|8
block|}
block|}
decl_stmt|;
name|runStatementOnDriver
argument_list|(
literal|"insert into "
operator|+
name|Table
operator|.
name|ACIDTBL
operator|+
literal|" "
operator|+
name|makeValuesClause
argument_list|(
name|vals
argument_list|)
argument_list|)
expr_stmt|;
name|String
name|query
init|=
literal|"merge into "
operator|+
name|Table
operator|.
name|ACIDTBL
operator|+
literal|" as target using "
operator|+
name|Table
operator|.
name|NONACIDORCTBL
operator|+
literal|" source ON target.a = source.a "
operator|+
literal|"WHEN MATCHED THEN update set b = 0 "
operator|+
literal|"WHEN NOT MATCHED THEN INSERT VALUES(source.a, source.b) "
decl_stmt|;
name|runStatementOnDriver
argument_list|(
name|query
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|r
init|=
name|runStatementOnDriver
argument_list|(
literal|"select a,b from "
operator|+
name|Table
operator|.
name|ACIDTBL
operator|+
literal|" order by a,b"
argument_list|)
decl_stmt|;
name|int
index|[]
index|[]
name|rExpected
init|=
block|{
block|{
literal|2
block|,
literal|0
block|}
block|,
block|{
literal|4
block|,
literal|0
block|}
block|,
block|{
literal|5
block|,
literal|0
block|}
block|,
block|{
literal|7
block|,
literal|8
block|}
block|,
block|{
literal|11
block|,
literal|11
block|}
block|}
decl_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
name|stringifyValues
argument_list|(
name|rExpected
argument_list|)
argument_list|,
name|r
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
annotation|@
name|Ignore
argument_list|(
literal|"Values clause with table constructor not yet supported"
argument_list|)
specifier|public
name|void
name|testValuesSource
parameter_list|()
throws|throws
name|Exception
block|{
name|int
index|[]
index|[]
name|targetVals
init|=
block|{
block|{
literal|2
block|,
literal|1
block|}
block|,
block|{
literal|4
block|,
literal|3
block|}
block|,
block|{
literal|5
block|,
literal|6
block|}
block|,
block|{
literal|7
block|,
literal|8
block|}
block|}
decl_stmt|;
name|runStatementOnDriver
argument_list|(
literal|"insert into "
operator|+
name|Table
operator|.
name|ACIDTBL
operator|+
literal|" "
operator|+
name|makeValuesClause
argument_list|(
name|targetVals
argument_list|)
argument_list|)
expr_stmt|;
name|String
name|query
init|=
literal|"merge into "
operator|+
name|Table
operator|.
name|ACIDTBL
operator|+
literal|" as t using (select * from (values (2,2),(4,44),(5,5),(11,11)) as F(a,b)) s ON t.a = s.a "
operator|+
literal|"WHEN MATCHED and s.a< 5 THEN DELETE "
operator|+
literal|"WHEN MATCHED AND s.a< 3 THEN update set b = 0 "
operator|+
literal|"WHEN NOT MATCHED THEN INSERT VALUES(s.a, s.b) "
decl_stmt|;
name|runStatementOnDriver
argument_list|(
name|query
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|r
init|=
name|runStatementOnDriver
argument_list|(
literal|"select a,b from "
operator|+
name|Table
operator|.
name|ACIDTBL
operator|+
literal|" order by a,b"
argument_list|)
decl_stmt|;
name|int
index|[]
index|[]
name|rExpected
init|=
block|{
block|{
literal|5
block|,
literal|6
block|}
block|,
block|{
literal|7
block|,
literal|8
block|}
block|,
block|{
literal|11
block|,
literal|11
block|}
block|}
decl_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
name|stringifyValues
argument_list|(
name|rExpected
argument_list|)
argument_list|,
name|r
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testBucketCodec
parameter_list|()
throws|throws
name|Exception
block|{
name|d
operator|.
name|destroy
argument_list|()
expr_stmt|;
comment|//insert data in "legacy" format
name|hiveConf
operator|.
name|setIntVar
argument_list|(
name|HiveConf
operator|.
name|ConfVars
operator|.
name|TESTMODE_BUCKET_CODEC_VERSION
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|d
operator|=
operator|new
name|Driver
argument_list|(
name|hiveConf
argument_list|)
expr_stmt|;
name|int
index|[]
index|[]
name|targetVals
init|=
block|{
block|{
literal|2
block|,
literal|1
block|}
block|,
block|{
literal|4
block|,
literal|3
block|}
block|,
block|{
literal|5
block|,
literal|6
block|}
block|,
block|{
literal|7
block|,
literal|8
block|}
block|}
decl_stmt|;
name|runStatementOnDriver
argument_list|(
literal|"insert into "
operator|+
name|Table
operator|.
name|ACIDTBL
operator|+
literal|" "
operator|+
name|makeValuesClause
argument_list|(
name|targetVals
argument_list|)
argument_list|)
expr_stmt|;
name|d
operator|.
name|destroy
argument_list|()
expr_stmt|;
name|hiveConf
operator|.
name|setIntVar
argument_list|(
name|HiveConf
operator|.
name|ConfVars
operator|.
name|TESTMODE_BUCKET_CODEC_VERSION
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|d
operator|=
operator|new
name|Driver
argument_list|(
name|hiveConf
argument_list|)
expr_stmt|;
comment|//do some operations with new format
name|runStatementOnDriver
argument_list|(
literal|"update "
operator|+
name|Table
operator|.
name|ACIDTBL
operator|+
literal|" set b=11 where a in (5,7)"
argument_list|)
expr_stmt|;
name|runStatementOnDriver
argument_list|(
literal|"insert into "
operator|+
name|Table
operator|.
name|ACIDTBL
operator|+
literal|" values(11,11)"
argument_list|)
expr_stmt|;
name|runStatementOnDriver
argument_list|(
literal|"delete from "
operator|+
name|Table
operator|.
name|ACIDTBL
operator|+
literal|" where a = 7"
argument_list|)
expr_stmt|;
comment|//make sure we get the right data back before/after compactions
name|List
argument_list|<
name|String
argument_list|>
name|r
init|=
name|runStatementOnDriver
argument_list|(
literal|"select a,b from "
operator|+
name|Table
operator|.
name|ACIDTBL
operator|+
literal|" order by a,b"
argument_list|)
decl_stmt|;
name|int
index|[]
index|[]
name|rExpected
init|=
block|{
block|{
literal|2
block|,
literal|1
block|}
block|,
block|{
literal|4
block|,
literal|3
block|}
block|,
block|{
literal|5
block|,
literal|11
block|}
block|,
block|{
literal|11
block|,
literal|11
block|}
block|}
decl_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
name|stringifyValues
argument_list|(
name|rExpected
argument_list|)
argument_list|,
name|r
argument_list|)
expr_stmt|;
name|runStatementOnDriver
argument_list|(
literal|"ALTER TABLE "
operator|+
name|Table
operator|.
name|ACIDTBL
operator|+
literal|" COMPACT 'MINOR'"
argument_list|)
expr_stmt|;
name|runWorker
argument_list|(
name|hiveConf
argument_list|)
expr_stmt|;
name|r
operator|=
name|runStatementOnDriver
argument_list|(
literal|"select a,b from "
operator|+
name|Table
operator|.
name|ACIDTBL
operator|+
literal|" order by a,b"
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
name|stringifyValues
argument_list|(
name|rExpected
argument_list|)
argument_list|,
name|r
argument_list|)
expr_stmt|;
name|runStatementOnDriver
argument_list|(
literal|"ALTER TABLE "
operator|+
name|Table
operator|.
name|ACIDTBL
operator|+
literal|" COMPACT 'MAJOR'"
argument_list|)
expr_stmt|;
name|runWorker
argument_list|(
name|hiveConf
argument_list|)
expr_stmt|;
name|r
operator|=
name|runStatementOnDriver
argument_list|(
literal|"select a,b from "
operator|+
name|Table
operator|.
name|ACIDTBL
operator|+
literal|" order by a,b"
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
name|stringifyValues
argument_list|(
name|rExpected
argument_list|)
argument_list|,
name|r
argument_list|)
expr_stmt|;
block|}
comment|/**    * Test the scenario when IOW comes in before a MAJOR compaction happens    * @throws Exception    */
annotation|@
name|Test
specifier|public
name|void
name|testInsertOverwrite1
parameter_list|()
throws|throws
name|Exception
block|{
name|FileSystem
name|fs
init|=
name|FileSystem
operator|.
name|get
argument_list|(
name|hiveConf
argument_list|)
decl_stmt|;
name|FileStatus
index|[]
name|status
decl_stmt|;
comment|// 1. Insert two rows to an ACID table
name|runStatementOnDriver
argument_list|(
literal|"insert into "
operator|+
name|Table
operator|.
name|ACIDTBL
operator|+
literal|"(a,b) values(1,2)"
argument_list|)
expr_stmt|;
name|runStatementOnDriver
argument_list|(
literal|"insert into "
operator|+
name|Table
operator|.
name|ACIDTBL
operator|+
literal|"(a,b) values(3,4)"
argument_list|)
expr_stmt|;
name|status
operator|=
name|fs
operator|.
name|listStatus
argument_list|(
operator|new
name|Path
argument_list|(
name|TEST_WAREHOUSE_DIR
operator|+
literal|"/"
operator|+
operator|(
name|Table
operator|.
name|ACIDTBL
operator|)
operator|.
name|toString
argument_list|()
operator|.
name|toLowerCase
argument_list|()
argument_list|)
argument_list|,
name|FileUtils
operator|.
name|HIDDEN_FILES_PATH_FILTER
argument_list|)
expr_stmt|;
comment|// There should be 2 delta dirs in the location
name|Assert
operator|.
name|assertEquals
argument_list|(
literal|2
argument_list|,
name|status
operator|.
name|length
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|status
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|Assert
operator|.
name|assertTrue
argument_list|(
name|status
index|[
name|i
index|]
operator|.
name|getPath
argument_list|()
operator|.
name|getName
argument_list|()
operator|.
name|matches
argument_list|(
literal|"delta_.*"
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// 2. INSERT OVERWRITE
comment|// Prepare data for the source table
name|runStatementOnDriver
argument_list|(
literal|"insert into "
operator|+
name|Table
operator|.
name|NONACIDORCTBL
operator|+
literal|"(a,b) values(5,6),(7,8)"
argument_list|)
expr_stmt|;
comment|// Insert overwrite ACID table from source table
name|runStatementOnDriver
argument_list|(
literal|"insert overwrite table "
operator|+
name|Table
operator|.
name|ACIDTBL
operator|+
literal|" select a,b from "
operator|+
name|Table
operator|.
name|NONACIDORCTBL
argument_list|)
expr_stmt|;
name|status
operator|=
name|fs
operator|.
name|listStatus
argument_list|(
operator|new
name|Path
argument_list|(
name|TEST_WAREHOUSE_DIR
operator|+
literal|"/"
operator|+
operator|(
name|Table
operator|.
name|ACIDTBL
operator|)
operator|.
name|toString
argument_list|()
operator|.
name|toLowerCase
argument_list|()
argument_list|)
argument_list|,
name|FileUtils
operator|.
name|HIDDEN_FILES_PATH_FILTER
argument_list|)
expr_stmt|;
comment|// There should be 2 delta dirs, plus a base dir in the location
name|Assert
operator|.
name|assertEquals
argument_list|(
literal|3
argument_list|,
name|status
operator|.
name|length
argument_list|)
expr_stmt|;
name|boolean
name|sawBase
init|=
literal|false
decl_stmt|;
name|String
name|baseDir
init|=
literal|""
decl_stmt|;
name|int
name|deltaCount
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|status
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|String
name|dirName
init|=
name|status
index|[
name|i
index|]
operator|.
name|getPath
argument_list|()
operator|.
name|getName
argument_list|()
decl_stmt|;
if|if
condition|(
name|dirName
operator|.
name|matches
argument_list|(
literal|"delta_.*"
argument_list|)
condition|)
block|{
name|deltaCount
operator|++
expr_stmt|;
block|}
else|else
block|{
name|sawBase
operator|=
literal|true
expr_stmt|;
name|baseDir
operator|=
name|dirName
expr_stmt|;
name|Assert
operator|.
name|assertTrue
argument_list|(
name|baseDir
operator|.
name|matches
argument_list|(
literal|"base_.*"
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|Assert
operator|.
name|assertEquals
argument_list|(
literal|2
argument_list|,
name|deltaCount
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertTrue
argument_list|(
name|sawBase
argument_list|)
expr_stmt|;
comment|// Verify query result
name|List
argument_list|<
name|String
argument_list|>
name|rs
init|=
name|runStatementOnDriver
argument_list|(
literal|"select a,b from "
operator|+
name|Table
operator|.
name|ACIDTBL
operator|+
literal|" order by a"
argument_list|)
decl_stmt|;
name|int
index|[]
index|[]
name|resultData
init|=
operator|new
name|int
index|[]
index|[]
block|{
block|{
literal|5
block|,
literal|6
block|}
block|,
block|{
literal|7
block|,
literal|8
block|}
block|}
decl_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
name|stringifyValues
argument_list|(
name|resultData
argument_list|)
argument_list|,
name|rs
argument_list|)
expr_stmt|;
comment|// 3. Perform a major compaction. Nothing should change. Both deltas and base dirs should have the same name.
comment|// Re-verify directory layout and query result by using the same logic as above
name|runStatementOnDriver
argument_list|(
literal|"alter table "
operator|+
name|Table
operator|.
name|ACIDTBL
operator|+
literal|" compact 'MAJOR'"
argument_list|)
expr_stmt|;
name|runWorker
argument_list|(
name|hiveConf
argument_list|)
expr_stmt|;
name|status
operator|=
name|fs
operator|.
name|listStatus
argument_list|(
operator|new
name|Path
argument_list|(
name|TEST_WAREHOUSE_DIR
operator|+
literal|"/"
operator|+
operator|(
name|Table
operator|.
name|ACIDTBL
operator|)
operator|.
name|toString
argument_list|()
operator|.
name|toLowerCase
argument_list|()
argument_list|)
argument_list|,
name|FileUtils
operator|.
name|HIDDEN_FILES_PATH_FILTER
argument_list|)
expr_stmt|;
comment|// There should be 2 delta dirs, plus a base dir in the location
name|Assert
operator|.
name|assertEquals
argument_list|(
literal|3
argument_list|,
name|status
operator|.
name|length
argument_list|)
expr_stmt|;
name|sawBase
operator|=
literal|false
expr_stmt|;
name|deltaCount
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|status
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|String
name|dirName
init|=
name|status
index|[
name|i
index|]
operator|.
name|getPath
argument_list|()
operator|.
name|getName
argument_list|()
decl_stmt|;
if|if
condition|(
name|dirName
operator|.
name|matches
argument_list|(
literal|"delta_.*"
argument_list|)
condition|)
block|{
name|deltaCount
operator|++
expr_stmt|;
block|}
else|else
block|{
name|sawBase
operator|=
literal|true
expr_stmt|;
name|Assert
operator|.
name|assertTrue
argument_list|(
name|dirName
operator|.
name|matches
argument_list|(
literal|"base_.*"
argument_list|)
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
name|baseDir
argument_list|,
name|dirName
argument_list|)
expr_stmt|;
block|}
block|}
name|Assert
operator|.
name|assertEquals
argument_list|(
literal|2
argument_list|,
name|deltaCount
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertTrue
argument_list|(
name|sawBase
argument_list|)
expr_stmt|;
comment|// Verify query result
name|rs
operator|=
name|runStatementOnDriver
argument_list|(
literal|"select a,b from "
operator|+
name|Table
operator|.
name|ACIDTBL
operator|+
literal|" order by a"
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
name|stringifyValues
argument_list|(
name|resultData
argument_list|)
argument_list|,
name|rs
argument_list|)
expr_stmt|;
comment|// 4. Run Cleaner. It should remove the 2 delta dirs.
name|runCleaner
argument_list|(
name|hiveConf
argument_list|)
expr_stmt|;
comment|// There should be only 1 directory left: base_xxxxxxx.
comment|// The delta dirs should have been cleaned up.
name|status
operator|=
name|fs
operator|.
name|listStatus
argument_list|(
operator|new
name|Path
argument_list|(
name|TEST_WAREHOUSE_DIR
operator|+
literal|"/"
operator|+
operator|(
name|Table
operator|.
name|ACIDTBL
operator|)
operator|.
name|toString
argument_list|()
operator|.
name|toLowerCase
argument_list|()
argument_list|)
argument_list|,
name|FileUtils
operator|.
name|HIDDEN_FILES_PATH_FILTER
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
literal|1
argument_list|,
name|status
operator|.
name|length
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertTrue
argument_list|(
name|status
index|[
literal|0
index|]
operator|.
name|getPath
argument_list|()
operator|.
name|getName
argument_list|()
operator|.
name|matches
argument_list|(
literal|"base_.*"
argument_list|)
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
name|baseDir
argument_list|,
name|status
index|[
literal|0
index|]
operator|.
name|getPath
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
comment|// Verify query result
name|rs
operator|=
name|runStatementOnDriver
argument_list|(
literal|"select a,b from "
operator|+
name|Table
operator|.
name|ACIDTBL
operator|+
literal|" order by a"
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
name|stringifyValues
argument_list|(
name|resultData
argument_list|)
argument_list|,
name|rs
argument_list|)
expr_stmt|;
block|}
comment|/**    * Test the scenario when IOW comes in after a MAJOR compaction happens    * @throws Exception    */
annotation|@
name|Test
specifier|public
name|void
name|testInsertOverwrite2
parameter_list|()
throws|throws
name|Exception
block|{
name|FileSystem
name|fs
init|=
name|FileSystem
operator|.
name|get
argument_list|(
name|hiveConf
argument_list|)
decl_stmt|;
name|FileStatus
index|[]
name|status
decl_stmt|;
comment|// 1. Insert two rows to an ACID table
name|runStatementOnDriver
argument_list|(
literal|"insert into "
operator|+
name|Table
operator|.
name|ACIDTBL
operator|+
literal|"(a,b) values(1,2)"
argument_list|)
expr_stmt|;
name|runStatementOnDriver
argument_list|(
literal|"insert into "
operator|+
name|Table
operator|.
name|ACIDTBL
operator|+
literal|"(a,b) values(3,4)"
argument_list|)
expr_stmt|;
name|status
operator|=
name|fs
operator|.
name|listStatus
argument_list|(
operator|new
name|Path
argument_list|(
name|TEST_WAREHOUSE_DIR
operator|+
literal|"/"
operator|+
operator|(
name|Table
operator|.
name|ACIDTBL
operator|)
operator|.
name|toString
argument_list|()
operator|.
name|toLowerCase
argument_list|()
argument_list|)
argument_list|,
name|FileUtils
operator|.
name|HIDDEN_FILES_PATH_FILTER
argument_list|)
expr_stmt|;
comment|// There should be 2 delta dirs in the location
name|Assert
operator|.
name|assertEquals
argument_list|(
literal|2
argument_list|,
name|status
operator|.
name|length
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|status
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|Assert
operator|.
name|assertTrue
argument_list|(
name|status
index|[
name|i
index|]
operator|.
name|getPath
argument_list|()
operator|.
name|getName
argument_list|()
operator|.
name|matches
argument_list|(
literal|"delta_.*"
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// 2. Perform a major compaction. There should be an extra base dir now.
name|runStatementOnDriver
argument_list|(
literal|"alter table "
operator|+
name|Table
operator|.
name|ACIDTBL
operator|+
literal|" compact 'MAJOR'"
argument_list|)
expr_stmt|;
name|runWorker
argument_list|(
name|hiveConf
argument_list|)
expr_stmt|;
name|status
operator|=
name|fs
operator|.
name|listStatus
argument_list|(
operator|new
name|Path
argument_list|(
name|TEST_WAREHOUSE_DIR
operator|+
literal|"/"
operator|+
operator|(
name|Table
operator|.
name|ACIDTBL
operator|)
operator|.
name|toString
argument_list|()
operator|.
name|toLowerCase
argument_list|()
argument_list|)
argument_list|,
name|FileUtils
operator|.
name|HIDDEN_FILES_PATH_FILTER
argument_list|)
expr_stmt|;
comment|// There should be 2 delta dirs, plus a base dir in the location
name|Assert
operator|.
name|assertEquals
argument_list|(
literal|3
argument_list|,
name|status
operator|.
name|length
argument_list|)
expr_stmt|;
name|boolean
name|sawBase
init|=
literal|false
decl_stmt|;
name|int
name|deltaCount
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|status
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|String
name|dirName
init|=
name|status
index|[
name|i
index|]
operator|.
name|getPath
argument_list|()
operator|.
name|getName
argument_list|()
decl_stmt|;
if|if
condition|(
name|dirName
operator|.
name|matches
argument_list|(
literal|"delta_.*"
argument_list|)
condition|)
block|{
name|deltaCount
operator|++
expr_stmt|;
block|}
else|else
block|{
name|sawBase
operator|=
literal|true
expr_stmt|;
name|Assert
operator|.
name|assertTrue
argument_list|(
name|dirName
operator|.
name|matches
argument_list|(
literal|"base_.*"
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|Assert
operator|.
name|assertEquals
argument_list|(
literal|2
argument_list|,
name|deltaCount
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertTrue
argument_list|(
name|sawBase
argument_list|)
expr_stmt|;
comment|// Verify query result
name|int
index|[]
index|[]
name|resultData
init|=
operator|new
name|int
index|[]
index|[]
block|{
block|{
literal|1
block|,
literal|2
block|}
block|,
block|{
literal|3
block|,
literal|4
block|}
block|}
decl_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|rs
init|=
name|runStatementOnDriver
argument_list|(
literal|"select a,b from "
operator|+
name|Table
operator|.
name|ACIDTBL
operator|+
literal|" order by a"
argument_list|)
decl_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
name|stringifyValues
argument_list|(
name|resultData
argument_list|)
argument_list|,
name|rs
argument_list|)
expr_stmt|;
comment|// 3. INSERT OVERWRITE
comment|// Prepare data for the source table
name|runStatementOnDriver
argument_list|(
literal|"insert into "
operator|+
name|Table
operator|.
name|NONACIDORCTBL
operator|+
literal|"(a,b) values(5,6),(7,8)"
argument_list|)
expr_stmt|;
comment|// Insert overwrite ACID table from source table
name|runStatementOnDriver
argument_list|(
literal|"insert overwrite table "
operator|+
name|Table
operator|.
name|ACIDTBL
operator|+
literal|" select a,b from "
operator|+
name|Table
operator|.
name|NONACIDORCTBL
argument_list|)
expr_stmt|;
name|status
operator|=
name|fs
operator|.
name|listStatus
argument_list|(
operator|new
name|Path
argument_list|(
name|TEST_WAREHOUSE_DIR
operator|+
literal|"/"
operator|+
operator|(
name|Table
operator|.
name|ACIDTBL
operator|)
operator|.
name|toString
argument_list|()
operator|.
name|toLowerCase
argument_list|()
argument_list|)
argument_list|,
name|FileUtils
operator|.
name|HIDDEN_FILES_PATH_FILTER
argument_list|)
expr_stmt|;
comment|// There should be 2 delta dirs, plus 2 base dirs in the location
name|Assert
operator|.
name|assertEquals
argument_list|(
literal|4
argument_list|,
name|status
operator|.
name|length
argument_list|)
expr_stmt|;
name|int
name|baseCount
init|=
literal|0
decl_stmt|;
name|deltaCount
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|status
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|String
name|dirName
init|=
name|status
index|[
name|i
index|]
operator|.
name|getPath
argument_list|()
operator|.
name|getName
argument_list|()
decl_stmt|;
if|if
condition|(
name|dirName
operator|.
name|matches
argument_list|(
literal|"delta_.*"
argument_list|)
condition|)
block|{
name|deltaCount
operator|++
expr_stmt|;
block|}
else|else
block|{
name|baseCount
operator|++
expr_stmt|;
block|}
block|}
name|Assert
operator|.
name|assertEquals
argument_list|(
literal|2
argument_list|,
name|deltaCount
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
literal|2
argument_list|,
name|baseCount
argument_list|)
expr_stmt|;
comment|// Verify query result
name|resultData
operator|=
operator|new
name|int
index|[]
index|[]
block|{
block|{
literal|5
block|,
literal|6
block|}
block|,
block|{
literal|7
block|,
literal|8
block|}
block|}
expr_stmt|;
name|rs
operator|=
name|runStatementOnDriver
argument_list|(
literal|"select a,b from "
operator|+
name|Table
operator|.
name|ACIDTBL
operator|+
literal|" order by a"
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
name|stringifyValues
argument_list|(
name|resultData
argument_list|)
argument_list|,
name|rs
argument_list|)
expr_stmt|;
comment|// 4. Perform another major compaction. Nothing should change. Both deltas and  both base dirs
comment|// should have the same name.
comment|// Re-verify directory layout and query result by using the same logic as above
name|runStatementOnDriver
argument_list|(
literal|"alter table "
operator|+
name|Table
operator|.
name|ACIDTBL
operator|+
literal|" compact 'MAJOR'"
argument_list|)
expr_stmt|;
name|runWorker
argument_list|(
name|hiveConf
argument_list|)
expr_stmt|;
name|status
operator|=
name|fs
operator|.
name|listStatus
argument_list|(
operator|new
name|Path
argument_list|(
name|TEST_WAREHOUSE_DIR
operator|+
literal|"/"
operator|+
operator|(
name|Table
operator|.
name|ACIDTBL
operator|)
operator|.
name|toString
argument_list|()
operator|.
name|toLowerCase
argument_list|()
argument_list|)
argument_list|,
name|FileUtils
operator|.
name|HIDDEN_FILES_PATH_FILTER
argument_list|)
expr_stmt|;
comment|// There should be 2 delta dirs, plus 2 base dirs in the location
name|Assert
operator|.
name|assertEquals
argument_list|(
literal|4
argument_list|,
name|status
operator|.
name|length
argument_list|)
expr_stmt|;
name|baseCount
operator|=
literal|0
expr_stmt|;
name|deltaCount
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|status
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|String
name|dirName
init|=
name|status
index|[
name|i
index|]
operator|.
name|getPath
argument_list|()
operator|.
name|getName
argument_list|()
decl_stmt|;
if|if
condition|(
name|dirName
operator|.
name|matches
argument_list|(
literal|"delta_.*"
argument_list|)
condition|)
block|{
name|deltaCount
operator|++
expr_stmt|;
block|}
else|else
block|{
name|Assert
operator|.
name|assertTrue
argument_list|(
name|dirName
operator|.
name|matches
argument_list|(
literal|"base_.*"
argument_list|)
argument_list|)
expr_stmt|;
name|baseCount
operator|++
expr_stmt|;
block|}
block|}
name|Assert
operator|.
name|assertEquals
argument_list|(
literal|2
argument_list|,
name|deltaCount
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
literal|2
argument_list|,
name|baseCount
argument_list|)
expr_stmt|;
comment|// Verify query result
name|rs
operator|=
name|runStatementOnDriver
argument_list|(
literal|"select a,b from "
operator|+
name|Table
operator|.
name|ACIDTBL
operator|+
literal|" order by a"
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
name|stringifyValues
argument_list|(
name|resultData
argument_list|)
argument_list|,
name|rs
argument_list|)
expr_stmt|;
comment|// 5. Run Cleaner. It should remove the 2 delta dirs and 1 old base dir.
name|runCleaner
argument_list|(
name|hiveConf
argument_list|)
expr_stmt|;
comment|// There should be only 1 directory left: base_xxxxxxx.
comment|// The delta dirs should have been cleaned up.
name|status
operator|=
name|fs
operator|.
name|listStatus
argument_list|(
operator|new
name|Path
argument_list|(
name|TEST_WAREHOUSE_DIR
operator|+
literal|"/"
operator|+
operator|(
name|Table
operator|.
name|ACIDTBL
operator|)
operator|.
name|toString
argument_list|()
operator|.
name|toLowerCase
argument_list|()
argument_list|)
argument_list|,
name|FileUtils
operator|.
name|HIDDEN_FILES_PATH_FILTER
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
literal|1
argument_list|,
name|status
operator|.
name|length
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertTrue
argument_list|(
name|status
index|[
literal|0
index|]
operator|.
name|getPath
argument_list|()
operator|.
name|getName
argument_list|()
operator|.
name|matches
argument_list|(
literal|"base_.*"
argument_list|)
argument_list|)
expr_stmt|;
comment|// Verify query result
name|rs
operator|=
name|runStatementOnDriver
argument_list|(
literal|"select a,b from "
operator|+
name|Table
operator|.
name|ACIDTBL
operator|+
literal|" order by a"
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
name|stringifyValues
argument_list|(
name|resultData
argument_list|)
argument_list|,
name|rs
argument_list|)
expr_stmt|;
block|}
comment|/**    * Test compaction for Micro-managed table    * 1. Regular compaction shouldn't impact any valid subdirectories of MM tables    * 2. Compactions will only remove subdirectories for aborted transactions of MM tables, if any    * @throws Exception    */
annotation|@
name|Test
specifier|public
name|void
name|testMmTableCompaction
parameter_list|()
throws|throws
name|Exception
block|{
comment|// 1. Insert some rows into MM table
name|runStatementOnDriver
argument_list|(
literal|"insert into "
operator|+
name|Table
operator|.
name|MMTBL
operator|+
literal|"(a,b) values(1,2)"
argument_list|)
expr_stmt|;
name|runStatementOnDriver
argument_list|(
literal|"insert into "
operator|+
name|Table
operator|.
name|MMTBL
operator|+
literal|"(a,b) values(3,4)"
argument_list|)
expr_stmt|;
comment|// There should be 2 delta directories
name|verifyDirAndResult
argument_list|(
literal|2
argument_list|)
expr_stmt|;
comment|// 2. Perform a MINOR compaction. Since nothing was aborted, subdirs should stay.
name|runStatementOnDriver
argument_list|(
literal|"alter table "
operator|+
name|Table
operator|.
name|MMTBL
operator|+
literal|" compact 'MINOR'"
argument_list|)
expr_stmt|;
name|runWorker
argument_list|(
name|hiveConf
argument_list|)
expr_stmt|;
name|verifyDirAndResult
argument_list|(
literal|2
argument_list|)
expr_stmt|;
comment|// 3. Let a transaction be aborted
name|hiveConf
operator|.
name|setBoolVar
argument_list|(
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVETESTMODEROLLBACKTXN
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|runStatementOnDriver
argument_list|(
literal|"insert into "
operator|+
name|Table
operator|.
name|MMTBL
operator|+
literal|"(a,b) values(5,6)"
argument_list|)
expr_stmt|;
name|hiveConf
operator|.
name|setBoolVar
argument_list|(
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVETESTMODEROLLBACKTXN
argument_list|,
literal|false
argument_list|)
expr_stmt|;
comment|// There should be 3 delta directories. The new one is the aborted one.
name|verifyDirAndResult
argument_list|(
literal|3
argument_list|)
expr_stmt|;
comment|// 4. Perform a MINOR compaction again. This time it will remove the subdir for aborted transaction.
name|runStatementOnDriver
argument_list|(
literal|"alter table "
operator|+
name|Table
operator|.
name|MMTBL
operator|+
literal|" compact 'MINOR'"
argument_list|)
expr_stmt|;
name|runWorker
argument_list|(
name|hiveConf
argument_list|)
expr_stmt|;
comment|// The worker should remove the subdir for aborted transaction
name|verifyDirAndResult
argument_list|(
literal|2
argument_list|)
expr_stmt|;
comment|// 5. Run Cleaner. Shouldn't impact anything.
name|runCleaner
argument_list|(
name|hiveConf
argument_list|)
expr_stmt|;
name|verifyDirAndResult
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
comment|/**    * Test cleaner for TXN_TO_WRITE_ID table.    * @throws Exception    */
annotation|@
name|Test
specifier|public
name|void
name|testCleanerForTxnToWriteId
parameter_list|()
throws|throws
name|Exception
block|{
name|int
index|[]
index|[]
name|tableData1
init|=
block|{
block|{
literal|1
block|,
literal|2
block|}
block|}
decl_stmt|;
name|int
index|[]
index|[]
name|tableData2
init|=
block|{
block|{
literal|2
block|,
literal|3
block|}
block|}
decl_stmt|;
name|int
index|[]
index|[]
name|tableData3
init|=
block|{
block|{
literal|3
block|,
literal|4
block|}
block|}
decl_stmt|;
name|runStatementOnDriver
argument_list|(
literal|"insert into "
operator|+
name|Table
operator|.
name|ACIDTBL
operator|+
literal|"(a,b) "
operator|+
name|makeValuesClause
argument_list|(
name|tableData1
argument_list|)
argument_list|)
expr_stmt|;
name|runStatementOnDriver
argument_list|(
literal|"insert into "
operator|+
name|Table
operator|.
name|ACIDTBL
operator|+
literal|"(a,b) "
operator|+
name|makeValuesClause
argument_list|(
name|tableData2
argument_list|)
argument_list|)
expr_stmt|;
name|runStatementOnDriver
argument_list|(
literal|"insert into "
operator|+
name|Table
operator|.
name|ACIDTBL
operator|+
literal|"(a,b) "
operator|+
name|makeValuesClause
argument_list|(
name|tableData3
argument_list|)
argument_list|)
expr_stmt|;
name|runStatementOnDriver
argument_list|(
literal|"insert into "
operator|+
name|Table
operator|.
name|ACIDTBLPART
operator|+
literal|" partition(p=1) (a,b) "
operator|+
name|makeValuesClause
argument_list|(
name|tableData1
argument_list|)
argument_list|)
expr_stmt|;
name|runStatementOnDriver
argument_list|(
literal|"insert into "
operator|+
name|Table
operator|.
name|ACIDTBLPART
operator|+
literal|" partition(p=2) (a,b) "
operator|+
name|makeValuesClause
argument_list|(
name|tableData2
argument_list|)
argument_list|)
expr_stmt|;
comment|// All inserts are committed and hence would expect in TXN_TO_WRITE_ID, 3 entries for acidTbl
comment|// and 2 entries for acidTblPart as each insert would have allocated a writeid.
comment|// Also MIN_HISTORY_LEVEL won't have any entries as no reference for open txns.
name|String
name|acidTblWhereClause
init|=
literal|" where t2w_database = "
operator|+
name|quoteString
argument_list|(
literal|"default"
argument_list|)
operator|+
literal|" and t2w_table = "
operator|+
name|quoteString
argument_list|(
name|Table
operator|.
name|ACIDTBL
operator|.
name|name
argument_list|()
operator|.
name|toLowerCase
argument_list|()
argument_list|)
decl_stmt|;
name|String
name|acidTblPartWhereClause
init|=
literal|" where t2w_database = "
operator|+
name|quoteString
argument_list|(
literal|"default"
argument_list|)
operator|+
literal|" and t2w_table = "
operator|+
name|quoteString
argument_list|(
name|Table
operator|.
name|ACIDTBLPART
operator|.
name|name
argument_list|()
operator|.
name|toLowerCase
argument_list|()
argument_list|)
decl_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
name|TxnDbUtil
operator|.
name|queryToString
argument_list|(
name|hiveConf
argument_list|,
literal|"select * from MIN_HISTORY_LEVEL"
argument_list|)
argument_list|,
literal|0
argument_list|,
name|TxnDbUtil
operator|.
name|countQueryAgent
argument_list|(
name|hiveConf
argument_list|,
literal|"select count(*) from MIN_HISTORY_LEVEL"
argument_list|)
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
name|TxnDbUtil
operator|.
name|queryToString
argument_list|(
name|hiveConf
argument_list|,
literal|"select * from TXN_TO_WRITE_ID"
operator|+
name|acidTblWhereClause
argument_list|)
argument_list|,
literal|3
argument_list|,
name|TxnDbUtil
operator|.
name|countQueryAgent
argument_list|(
name|hiveConf
argument_list|,
literal|"select count(*) from TXN_TO_WRITE_ID"
operator|+
name|acidTblWhereClause
argument_list|)
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
name|TxnDbUtil
operator|.
name|queryToString
argument_list|(
name|hiveConf
argument_list|,
literal|"select * from TXN_TO_WRITE_ID"
operator|+
name|acidTblPartWhereClause
argument_list|)
argument_list|,
literal|2
argument_list|,
name|TxnDbUtil
operator|.
name|countQueryAgent
argument_list|(
name|hiveConf
argument_list|,
literal|"select count(*) from TXN_TO_WRITE_ID"
operator|+
name|acidTblPartWhereClause
argument_list|)
argument_list|)
expr_stmt|;
name|TxnStore
name|txnHandler
init|=
name|TxnUtils
operator|.
name|getTxnStore
argument_list|(
name|hiveConf
argument_list|)
decl_stmt|;
name|txnHandler
operator|.
name|compact
argument_list|(
operator|new
name|CompactionRequest
argument_list|(
literal|"default"
argument_list|,
name|Table
operator|.
name|ACIDTBL
operator|.
name|name
argument_list|()
operator|.
name|toLowerCase
argument_list|()
argument_list|,
name|CompactionType
operator|.
name|MAJOR
argument_list|)
argument_list|)
expr_stmt|;
name|runWorker
argument_list|(
name|hiveConf
argument_list|)
expr_stmt|;
name|runCleaner
argument_list|(
name|hiveConf
argument_list|)
expr_stmt|;
name|txnHandler
operator|.
name|cleanTxnToWriteIdTable
argument_list|()
expr_stmt|;
comment|// After compaction/cleanup, all entries from TXN_TO_WRITE_ID should be cleaned up as all txns are committed.
name|Assert
operator|.
name|assertEquals
argument_list|(
name|TxnDbUtil
operator|.
name|queryToString
argument_list|(
name|hiveConf
argument_list|,
literal|"select * from TXN_TO_WRITE_ID"
argument_list|)
argument_list|,
literal|0
argument_list|,
name|TxnDbUtil
operator|.
name|countQueryAgent
argument_list|(
name|hiveConf
argument_list|,
literal|"select count(*) from TXN_TO_WRITE_ID"
argument_list|)
argument_list|)
expr_stmt|;
comment|// Following sequence of commit-abort-open-abort-commit.
name|int
index|[]
index|[]
name|tableData4
init|=
block|{
block|{
literal|4
block|,
literal|5
block|}
block|}
decl_stmt|;
name|int
index|[]
index|[]
name|tableData5
init|=
block|{
block|{
literal|5
block|,
literal|6
block|}
block|}
decl_stmt|;
name|runStatementOnDriver
argument_list|(
literal|"insert into "
operator|+
name|Table
operator|.
name|ACIDTBLPART
operator|+
literal|" partition(p=3) (a,b) "
operator|+
name|makeValuesClause
argument_list|(
name|tableData3
argument_list|)
argument_list|)
expr_stmt|;
name|hiveConf
operator|.
name|setBoolVar
argument_list|(
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVETESTMODEROLLBACKTXN
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|runStatementOnDriver
argument_list|(
literal|"insert into "
operator|+
name|Table
operator|.
name|ACIDTBL
operator|+
literal|"(a,b) "
operator|+
name|makeValuesClause
argument_list|(
name|tableData4
argument_list|)
argument_list|)
expr_stmt|;
name|hiveConf
operator|.
name|setBoolVar
argument_list|(
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVETESTMODEROLLBACKTXN
argument_list|,
literal|false
argument_list|)
expr_stmt|;
comment|// Keep an open txn which refers to the aborted txn.
name|Context
name|ctx
init|=
operator|new
name|Context
argument_list|(
name|hiveConf
argument_list|)
decl_stmt|;
name|HiveTxnManager
name|txnMgr
init|=
name|TxnManagerFactory
operator|.
name|getTxnManagerFactory
argument_list|()
operator|.
name|getTxnManager
argument_list|(
name|hiveConf
argument_list|)
decl_stmt|;
name|txnMgr
operator|.
name|openTxn
argument_list|(
name|ctx
argument_list|,
literal|"u1"
argument_list|)
expr_stmt|;
name|txnMgr
operator|.
name|getValidTxns
argument_list|()
expr_stmt|;
comment|// Start an INSERT statement transaction and roll back this transaction.
name|hiveConf
operator|.
name|setBoolVar
argument_list|(
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVETESTMODEROLLBACKTXN
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|runStatementOnDriver
argument_list|(
literal|"insert into "
operator|+
name|Table
operator|.
name|ACIDTBL
operator|+
literal|"(a,b) "
operator|+
name|makeValuesClause
argument_list|(
name|tableData5
argument_list|)
argument_list|)
expr_stmt|;
name|hiveConf
operator|.
name|setBoolVar
argument_list|(
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVETESTMODEROLLBACKTXN
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|runStatementOnDriver
argument_list|(
literal|"insert into "
operator|+
name|Table
operator|.
name|ACIDTBL
operator|+
literal|"(a,b) "
operator|+
name|makeValuesClause
argument_list|(
name|tableData5
argument_list|)
argument_list|)
expr_stmt|;
comment|// We would expect 4 entries in TXN_TO_WRITE_ID as each insert would have allocated a writeid
comment|// including aborted one.
comment|// Also MIN_HISTORY_LEVEL will have 1 entry for the open txn.
name|Assert
operator|.
name|assertEquals
argument_list|(
name|TxnDbUtil
operator|.
name|queryToString
argument_list|(
name|hiveConf
argument_list|,
literal|"select * from TXN_TO_WRITE_ID"
operator|+
name|acidTblWhereClause
argument_list|)
argument_list|,
literal|3
argument_list|,
name|TxnDbUtil
operator|.
name|countQueryAgent
argument_list|(
name|hiveConf
argument_list|,
literal|"select count(*) from TXN_TO_WRITE_ID"
operator|+
name|acidTblWhereClause
argument_list|)
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
name|TxnDbUtil
operator|.
name|queryToString
argument_list|(
name|hiveConf
argument_list|,
literal|"select * from TXN_TO_WRITE_ID"
operator|+
name|acidTblPartWhereClause
argument_list|)
argument_list|,
literal|1
argument_list|,
name|TxnDbUtil
operator|.
name|countQueryAgent
argument_list|(
name|hiveConf
argument_list|,
literal|"select count(*) from TXN_TO_WRITE_ID"
operator|+
name|acidTblPartWhereClause
argument_list|)
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
name|TxnDbUtil
operator|.
name|queryToString
argument_list|(
name|hiveConf
argument_list|,
literal|"select * from MIN_HISTORY_LEVEL"
argument_list|)
argument_list|,
literal|1
argument_list|,
name|TxnDbUtil
operator|.
name|countQueryAgent
argument_list|(
name|hiveConf
argument_list|,
literal|"select count(*) from MIN_HISTORY_LEVEL"
argument_list|)
argument_list|)
expr_stmt|;
comment|// The entry relevant to aborted txns shouldn't be removed from TXN_TO_WRITE_ID as
comment|// aborted txn would be removed from TXNS only after the compaction. Also, committed txn> open txn is retained.
comment|// As open txn doesn't allocate writeid, the 2 entries for aborted and committed should be retained.
name|txnHandler
operator|.
name|cleanEmptyAbortedTxns
argument_list|()
expr_stmt|;
name|txnHandler
operator|.
name|cleanTxnToWriteIdTable
argument_list|()
expr_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
name|TxnDbUtil
operator|.
name|queryToString
argument_list|(
name|hiveConf
argument_list|,
literal|"select * from TXN_TO_WRITE_ID"
operator|+
name|acidTblWhereClause
argument_list|)
argument_list|,
literal|3
argument_list|,
name|TxnDbUtil
operator|.
name|countQueryAgent
argument_list|(
name|hiveConf
argument_list|,
literal|"select count(*) from TXN_TO_WRITE_ID"
operator|+
name|acidTblWhereClause
argument_list|)
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
name|TxnDbUtil
operator|.
name|queryToString
argument_list|(
name|hiveConf
argument_list|,
literal|"select * from TXN_TO_WRITE_ID"
operator|+
name|acidTblPartWhereClause
argument_list|)
argument_list|,
literal|0
argument_list|,
name|TxnDbUtil
operator|.
name|countQueryAgent
argument_list|(
name|hiveConf
argument_list|,
literal|"select count(*) from TXN_TO_WRITE_ID"
operator|+
name|acidTblPartWhereClause
argument_list|)
argument_list|)
expr_stmt|;
comment|// The cleaner will removed aborted txns data/metadata but cannot remove aborted txn2 from TXN_TO_WRITE_ID
comment|// as there is a open txn< aborted txn2. The aborted txn1< open txn and will be removed.
comment|// Also, committed txn> open txn is retained.
comment|// MIN_HISTORY_LEVEL will have 1 entry for the open txn.
name|txnHandler
operator|.
name|compact
argument_list|(
operator|new
name|CompactionRequest
argument_list|(
literal|"default"
argument_list|,
name|Table
operator|.
name|ACIDTBL
operator|.
name|name
argument_list|()
operator|.
name|toLowerCase
argument_list|()
argument_list|,
name|CompactionType
operator|.
name|MAJOR
argument_list|)
argument_list|)
expr_stmt|;
name|runWorker
argument_list|(
name|hiveConf
argument_list|)
expr_stmt|;
name|runCleaner
argument_list|(
name|hiveConf
argument_list|)
expr_stmt|;
name|txnHandler
operator|.
name|cleanEmptyAbortedTxns
argument_list|()
expr_stmt|;
name|txnHandler
operator|.
name|cleanTxnToWriteIdTable
argument_list|()
expr_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
name|TxnDbUtil
operator|.
name|queryToString
argument_list|(
name|hiveConf
argument_list|,
literal|"select * from TXN_TO_WRITE_ID"
argument_list|)
argument_list|,
literal|2
argument_list|,
name|TxnDbUtil
operator|.
name|countQueryAgent
argument_list|(
name|hiveConf
argument_list|,
literal|"select count(*) from TXN_TO_WRITE_ID"
argument_list|)
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
name|TxnDbUtil
operator|.
name|queryToString
argument_list|(
name|hiveConf
argument_list|,
literal|"select * from MIN_HISTORY_LEVEL"
argument_list|)
argument_list|,
literal|1
argument_list|,
name|TxnDbUtil
operator|.
name|countQueryAgent
argument_list|(
name|hiveConf
argument_list|,
literal|"select count(*) from MIN_HISTORY_LEVEL"
argument_list|)
argument_list|)
expr_stmt|;
comment|// Commit the open txn, which lets the cleanup on TXN_TO_WRITE_ID.
comment|// Now all txns are removed from MIN_HISTORY_LEVEL. So, all entries from TXN_TO_WRITE_ID would be cleaned.
name|txnMgr
operator|.
name|commitTxn
argument_list|()
expr_stmt|;
name|txnHandler
operator|.
name|cleanTxnToWriteIdTable
argument_list|()
expr_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
name|TxnDbUtil
operator|.
name|queryToString
argument_list|(
name|hiveConf
argument_list|,
literal|"select * from TXN_TO_WRITE_ID"
argument_list|)
argument_list|,
literal|0
argument_list|,
name|TxnDbUtil
operator|.
name|countQueryAgent
argument_list|(
name|hiveConf
argument_list|,
literal|"select count(*) from TXN_TO_WRITE_ID"
argument_list|)
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
name|TxnDbUtil
operator|.
name|queryToString
argument_list|(
name|hiveConf
argument_list|,
literal|"select * from MIN_HISTORY_LEVEL"
argument_list|)
argument_list|,
literal|0
argument_list|,
name|TxnDbUtil
operator|.
name|countQueryAgent
argument_list|(
name|hiveConf
argument_list|,
literal|"select count(*) from MIN_HISTORY_LEVEL"
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|verifyDirAndResult
parameter_list|(
name|int
name|expectedDeltas
parameter_list|)
throws|throws
name|Exception
block|{
name|FileSystem
name|fs
init|=
name|FileSystem
operator|.
name|get
argument_list|(
name|hiveConf
argument_list|)
decl_stmt|;
comment|// Verify the content of subdirs
name|FileStatus
index|[]
name|status
init|=
name|fs
operator|.
name|listStatus
argument_list|(
operator|new
name|Path
argument_list|(
name|TEST_WAREHOUSE_DIR
operator|+
literal|"/"
operator|+
operator|(
name|Table
operator|.
name|MMTBL
operator|)
operator|.
name|toString
argument_list|()
operator|.
name|toLowerCase
argument_list|()
argument_list|)
argument_list|,
name|FileUtils
operator|.
name|HIDDEN_FILES_PATH_FILTER
argument_list|)
decl_stmt|;
name|int
name|sawDeltaTimes
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|status
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|Assert
operator|.
name|assertTrue
argument_list|(
name|status
index|[
name|i
index|]
operator|.
name|getPath
argument_list|()
operator|.
name|getName
argument_list|()
operator|.
name|matches
argument_list|(
literal|"delta_.*"
argument_list|)
argument_list|)
expr_stmt|;
name|sawDeltaTimes
operator|++
expr_stmt|;
name|FileStatus
index|[]
name|files
init|=
name|fs
operator|.
name|listStatus
argument_list|(
name|status
index|[
name|i
index|]
operator|.
name|getPath
argument_list|()
argument_list|,
name|FileUtils
operator|.
name|HIDDEN_FILES_PATH_FILTER
argument_list|)
decl_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
literal|1
argument_list|,
name|files
operator|.
name|length
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertTrue
argument_list|(
name|files
index|[
literal|0
index|]
operator|.
name|getPath
argument_list|()
operator|.
name|getName
argument_list|()
operator|.
name|equals
argument_list|(
literal|"000000_0"
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|Assert
operator|.
name|assertEquals
argument_list|(
name|expectedDeltas
argument_list|,
name|sawDeltaTimes
argument_list|)
expr_stmt|;
comment|// Verify query result
name|int
index|[]
index|[]
name|resultData
init|=
operator|new
name|int
index|[]
index|[]
block|{
block|{
literal|1
block|,
literal|2
block|}
block|,
block|{
literal|3
block|,
literal|4
block|}
block|}
decl_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|rs
init|=
name|runStatementOnDriver
argument_list|(
literal|"select a,b from "
operator|+
name|Table
operator|.
name|MMTBL
argument_list|)
decl_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
name|stringifyValues
argument_list|(
name|resultData
argument_list|)
argument_list|,
name|rs
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testAcidOrcWritePreservesFieldNames
parameter_list|()
throws|throws
name|Exception
block|{
comment|// with vectorization
name|String
name|tableName
init|=
literal|"acidorcwritefieldnames"
decl_stmt|;
name|hiveConf
operator|.
name|setBoolVar
argument_list|(
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVE_VECTORIZATION_ENABLED
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|runStatementOnDriver
argument_list|(
literal|"DROP TABLE IF EXISTS "
operator|+
name|tableName
argument_list|)
expr_stmt|;
name|runStatementOnDriver
argument_list|(
literal|"CREATE TABLE "
operator|+
name|tableName
operator|+
literal|" (a INT, b STRING) CLUSTERED BY (a) INTO "
operator|+
name|BUCKET_COUNT
operator|+
literal|" BUCKETS STORED AS ORC TBLPROPERTIES ('transactional'='true')"
argument_list|)
expr_stmt|;
name|runStatementOnDriver
argument_list|(
literal|"INSERT INTO "
operator|+
name|tableName
operator|+
literal|" VALUES (1, 'foo'), (2, 'bar')"
argument_list|)
expr_stmt|;
name|tableName
operator|=
literal|"acidorcwritefieldnames_complex"
expr_stmt|;
name|runStatementOnDriver
argument_list|(
literal|"DROP TABLE IF EXISTS "
operator|+
name|tableName
argument_list|)
expr_stmt|;
name|runStatementOnDriver
argument_list|(
literal|"CREATE TABLE "
operator|+
name|tableName
operator|+
literal|" (a INT, b STRING, s STRUCT<c:int, si:STRUCT<d:double,"
operator|+
literal|"e:float>>) CLUSTERED BY (a) INTO "
operator|+
name|BUCKET_COUNT
operator|+
literal|" BUCKETS STORED AS ORC TBLPROPERTIES ('transactional'='true')"
argument_list|)
expr_stmt|;
name|runStatementOnDriver
argument_list|(
literal|"INSERT INTO "
operator|+
name|tableName
operator|+
literal|" select a, b, named_struct('c',10,'si',"
operator|+
literal|"named_struct('d',cast(1.0 as double),'e',cast(2.0 as float))) from acidorcwritefieldnames"
argument_list|)
expr_stmt|;
name|FileSystem
name|fs
init|=
name|FileSystem
operator|.
name|get
argument_list|(
name|hiveConf
argument_list|)
decl_stmt|;
name|FileStatus
index|[]
name|fileStatuses
init|=
name|fs
operator|.
name|globStatus
argument_list|(
operator|new
name|Path
argument_list|(
name|TEST_WAREHOUSE_DIR
operator|+
literal|"/"
operator|+
name|tableName
operator|+
literal|"/"
operator|+
name|AcidUtils
operator|.
name|DELTA_PREFIX
operator|+
literal|"*/"
operator|+
name|AcidUtils
operator|.
name|BUCKET_PREFIX
operator|+
literal|"*"
argument_list|)
argument_list|)
decl_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
name|BUCKET_COUNT
argument_list|,
name|fileStatuses
operator|.
name|length
argument_list|)
expr_stmt|;
name|OrcFile
operator|.
name|ReaderOptions
name|readerOptions
init|=
name|OrcFile
operator|.
name|readerOptions
argument_list|(
name|hiveConf
argument_list|)
decl_stmt|;
for|for
control|(
name|FileStatus
name|fileStatus
range|:
name|fileStatuses
control|)
block|{
name|Reader
name|r
init|=
name|OrcFile
operator|.
name|createReader
argument_list|(
name|fileStatus
operator|.
name|getPath
argument_list|()
argument_list|,
name|readerOptions
argument_list|)
decl_stmt|;
name|TypeDescription
name|rowSchema
init|=
name|r
operator|.
name|getSchema
argument_list|()
operator|.
name|getChildren
argument_list|()
operator|.
name|get
argument_list|(
literal|5
argument_list|)
decl_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
literal|"struct<a:int,b:string,s:struct<c:int,si:struct<d:double,e:float>>>"
argument_list|,
name|rowSchema
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// without vectorization
name|tableName
operator|=
literal|"acidorcwritefieldnames"
expr_stmt|;
name|hiveConf
operator|.
name|setBoolVar
argument_list|(
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVE_VECTORIZATION_ENABLED
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|runStatementOnDriver
argument_list|(
literal|"DROP TABLE IF EXISTS "
operator|+
name|tableName
argument_list|)
expr_stmt|;
name|runStatementOnDriver
argument_list|(
literal|"CREATE TABLE "
operator|+
name|tableName
operator|+
literal|" (a INT, b STRING) CLUSTERED BY (a) INTO "
operator|+
name|BUCKET_COUNT
operator|+
literal|" BUCKETS STORED AS ORC TBLPROPERTIES ('transactional'='true')"
argument_list|)
expr_stmt|;
name|runStatementOnDriver
argument_list|(
literal|"INSERT INTO "
operator|+
name|tableName
operator|+
literal|" VALUES (1, 'foo'), (2, 'bar')"
argument_list|)
expr_stmt|;
name|tableName
operator|=
literal|"acidorcwritefieldnames_complex"
expr_stmt|;
name|runStatementOnDriver
argument_list|(
literal|"DROP TABLE IF EXISTS "
operator|+
name|tableName
argument_list|)
expr_stmt|;
name|runStatementOnDriver
argument_list|(
literal|"CREATE TABLE "
operator|+
name|tableName
operator|+
literal|" (a INT, b STRING, s STRUCT<c:int, si:STRUCT<d:double,"
operator|+
literal|"e:float>>) CLUSTERED BY (a) INTO "
operator|+
name|BUCKET_COUNT
operator|+
literal|" BUCKETS STORED AS ORC TBLPROPERTIES ('transactional'='true')"
argument_list|)
expr_stmt|;
name|runStatementOnDriver
argument_list|(
literal|"INSERT INTO "
operator|+
name|tableName
operator|+
literal|" select a, b, named_struct('c',10,'si',"
operator|+
literal|"named_struct('d',cast(1.0 as double),'e',cast(2.0 as float))) from acidorcwritefieldnames"
argument_list|)
expr_stmt|;
name|fs
operator|=
name|FileSystem
operator|.
name|get
argument_list|(
name|hiveConf
argument_list|)
expr_stmt|;
name|fileStatuses
operator|=
name|fs
operator|.
name|globStatus
argument_list|(
operator|new
name|Path
argument_list|(
name|TEST_WAREHOUSE_DIR
operator|+
literal|"/"
operator|+
name|tableName
operator|+
literal|"/"
operator|+
name|AcidUtils
operator|.
name|DELTA_PREFIX
operator|+
literal|"*/"
operator|+
name|AcidUtils
operator|.
name|BUCKET_PREFIX
operator|+
literal|"*"
argument_list|)
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
name|BUCKET_COUNT
argument_list|,
name|fileStatuses
operator|.
name|length
argument_list|)
expr_stmt|;
name|readerOptions
operator|=
name|OrcFile
operator|.
name|readerOptions
argument_list|(
name|hiveConf
argument_list|)
expr_stmt|;
for|for
control|(
name|FileStatus
name|fileStatus
range|:
name|fileStatuses
control|)
block|{
name|Reader
name|r
init|=
name|OrcFile
operator|.
name|createReader
argument_list|(
name|fileStatus
operator|.
name|getPath
argument_list|()
argument_list|,
name|readerOptions
argument_list|)
decl_stmt|;
name|TypeDescription
name|rowSchema
init|=
name|r
operator|.
name|getSchema
argument_list|()
operator|.
name|getChildren
argument_list|()
operator|.
name|get
argument_list|(
literal|5
argument_list|)
decl_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
literal|"struct<a:int,b:string,s:struct<c:int,si:struct<d:double,e:float>>>"
argument_list|,
name|rowSchema
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|hiveConf
operator|.
name|setBoolVar
argument_list|(
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVE_VECTORIZATION_ENABLED
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
comment|/**    * takes raw data and turns it into a string as if from Driver.getResults()    * sorts rows in dictionary order    */
specifier|static
name|List
argument_list|<
name|String
argument_list|>
name|stringifyValues
parameter_list|(
name|int
index|[]
index|[]
name|rowsIn
parameter_list|)
block|{
assert|assert
name|rowsIn
operator|.
name|length
operator|>
literal|0
assert|;
name|int
index|[]
index|[]
name|rows
init|=
name|rowsIn
operator|.
name|clone
argument_list|()
decl_stmt|;
name|Arrays
operator|.
name|sort
argument_list|(
name|rows
argument_list|,
operator|new
name|RowComp
argument_list|()
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|rs
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|int
index|[]
name|row
range|:
name|rows
control|)
block|{
assert|assert
name|row
operator|.
name|length
operator|>
literal|0
assert|;
name|StringBuilder
name|sb
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|value
range|:
name|row
control|)
block|{
name|sb
operator|.
name|append
argument_list|(
name|value
argument_list|)
operator|.
name|append
argument_list|(
literal|"\t"
argument_list|)
expr_stmt|;
block|}
name|sb
operator|.
name|setLength
argument_list|(
name|sb
operator|.
name|length
argument_list|()
operator|-
literal|1
argument_list|)
expr_stmt|;
name|rs
operator|.
name|add
argument_list|(
name|sb
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|rs
return|;
block|}
comment|/**    * This tests that delete_delta_x_y dirs will be not produced during minor compaction if no input delete events.    * See HIVE-20941.    * @throws Exception    */
annotation|@
name|Test
specifier|public
name|void
name|testDeleteEventsCompaction
parameter_list|()
throws|throws
name|Exception
block|{
name|int
index|[]
index|[]
name|tableData1
init|=
block|{
block|{
literal|1
block|,
literal|2
block|}
block|}
decl_stmt|;
name|int
index|[]
index|[]
name|tableData2
init|=
block|{
block|{
literal|2
block|,
literal|3
block|}
block|}
decl_stmt|;
name|int
index|[]
index|[]
name|tableData3
init|=
block|{
block|{
literal|3
block|,
literal|4
block|}
block|}
decl_stmt|;
name|runStatementOnDriver
argument_list|(
literal|"insert into "
operator|+
name|Table
operator|.
name|ACIDTBL
operator|+
literal|"(a,b) "
operator|+
name|makeValuesClause
argument_list|(
name|tableData1
argument_list|)
argument_list|)
expr_stmt|;
name|runStatementOnDriver
argument_list|(
literal|"insert into "
operator|+
name|Table
operator|.
name|ACIDTBL
operator|+
literal|"(a,b) "
operator|+
name|makeValuesClause
argument_list|(
name|tableData2
argument_list|)
argument_list|)
expr_stmt|;
name|runStatementOnDriver
argument_list|(
literal|"insert into "
operator|+
name|Table
operator|.
name|ACIDTBL
operator|+
literal|"(a,b) "
operator|+
name|makeValuesClause
argument_list|(
name|tableData3
argument_list|)
argument_list|)
expr_stmt|;
name|TxnStore
name|txnHandler
init|=
name|TxnUtils
operator|.
name|getTxnStore
argument_list|(
name|hiveConf
argument_list|)
decl_stmt|;
name|txnHandler
operator|.
name|compact
argument_list|(
operator|new
name|CompactionRequest
argument_list|(
literal|"default"
argument_list|,
name|Table
operator|.
name|ACIDTBL
operator|.
name|name
argument_list|()
operator|.
name|toLowerCase
argument_list|()
argument_list|,
name|CompactionType
operator|.
name|MINOR
argument_list|)
argument_list|)
expr_stmt|;
name|runWorker
argument_list|(
name|hiveConf
argument_list|)
expr_stmt|;
name|runCleaner
argument_list|(
name|hiveConf
argument_list|)
expr_stmt|;
name|FileSystem
name|fs
init|=
name|FileSystem
operator|.
name|get
argument_list|(
name|hiveConf
argument_list|)
decl_stmt|;
name|FileStatus
index|[]
name|fileStatuses
init|=
name|fs
operator|.
name|globStatus
argument_list|(
operator|new
name|Path
argument_list|(
name|TEST_WAREHOUSE_DIR
operator|+
literal|"/"
operator|+
name|Table
operator|.
name|ACIDTBL
operator|.
name|name
argument_list|()
operator|.
name|toLowerCase
argument_list|()
operator|+
literal|"/*"
argument_list|)
argument_list|)
decl_stmt|;
for|for
control|(
name|FileStatus
name|fileStatus
range|:
name|fileStatuses
control|)
block|{
name|Assert
operator|.
name|assertFalse
argument_list|(
name|fileStatus
operator|.
name|getPath
argument_list|()
operator|.
name|getName
argument_list|()
operator|.
name|startsWith
argument_list|(
name|AcidUtils
operator|.
name|DELETE_DELTA_PREFIX
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * takes raw data and turns it into a string as if from Driver.getResults()    * sorts rows in dictionary order    */
specifier|static
name|List
argument_list|<
name|String
argument_list|>
name|stringifyValuesNoSort
parameter_list|(
name|int
index|[]
index|[]
name|rowsIn
parameter_list|)
block|{
assert|assert
name|rowsIn
operator|.
name|length
operator|>
literal|0
assert|;
name|int
index|[]
index|[]
name|rows
init|=
name|rowsIn
operator|.
name|clone
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|rs
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|int
index|[]
name|row
range|:
name|rows
control|)
block|{
assert|assert
name|row
operator|.
name|length
operator|>
literal|0
assert|;
name|StringBuilder
name|sb
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|value
range|:
name|row
control|)
block|{
name|sb
operator|.
name|append
argument_list|(
name|value
argument_list|)
operator|.
name|append
argument_list|(
literal|"\t"
argument_list|)
expr_stmt|;
block|}
name|sb
operator|.
name|setLength
argument_list|(
name|sb
operator|.
name|length
argument_list|()
operator|-
literal|1
argument_list|)
expr_stmt|;
name|rs
operator|.
name|add
argument_list|(
name|sb
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|rs
return|;
block|}
specifier|static
class|class
name|RowComp
implements|implements
name|Comparator
argument_list|<
name|int
index|[]
argument_list|>
block|{
annotation|@
name|Override
specifier|public
name|int
name|compare
parameter_list|(
name|int
index|[]
name|row1
parameter_list|,
name|int
index|[]
name|row2
parameter_list|)
block|{
assert|assert
name|row1
operator|!=
literal|null
operator|&&
name|row2
operator|!=
literal|null
operator|&&
name|row1
operator|.
name|length
operator|==
name|row2
operator|.
name|length
assert|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|row1
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|int
name|comp
init|=
name|Integer
operator|.
name|compare
argument_list|(
name|row1
index|[
name|i
index|]
argument_list|,
name|row2
index|[
name|i
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
name|comp
operator|!=
literal|0
condition|)
block|{
return|return
name|comp
return|;
block|}
block|}
return|return
literal|0
return|;
block|}
block|}
specifier|static
name|String
name|makeValuesClause
parameter_list|(
name|int
index|[]
index|[]
name|rows
parameter_list|)
block|{
assert|assert
name|rows
operator|.
name|length
operator|>
literal|0
assert|;
name|StringBuilder
name|sb
init|=
operator|new
name|StringBuilder
argument_list|(
literal|" values"
argument_list|)
decl_stmt|;
for|for
control|(
name|int
index|[]
name|row
range|:
name|rows
control|)
block|{
assert|assert
name|row
operator|.
name|length
operator|>
literal|0
assert|;
if|if
condition|(
name|row
operator|.
name|length
operator|>
literal|1
condition|)
block|{
name|sb
operator|.
name|append
argument_list|(
literal|"("
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|int
name|value
range|:
name|row
control|)
block|{
name|sb
operator|.
name|append
argument_list|(
name|value
argument_list|)
operator|.
name|append
argument_list|(
literal|","
argument_list|)
expr_stmt|;
block|}
name|sb
operator|.
name|setLength
argument_list|(
name|sb
operator|.
name|length
argument_list|()
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|//remove trailing comma
if|if
condition|(
name|row
operator|.
name|length
operator|>
literal|1
condition|)
block|{
name|sb
operator|.
name|append
argument_list|(
literal|")"
argument_list|)
expr_stmt|;
block|}
name|sb
operator|.
name|append
argument_list|(
literal|","
argument_list|)
expr_stmt|;
block|}
name|sb
operator|.
name|setLength
argument_list|(
name|sb
operator|.
name|length
argument_list|()
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|//remove trailing comma
return|return
name|sb
operator|.
name|toString
argument_list|()
return|;
block|}
specifier|protected
name|List
argument_list|<
name|String
argument_list|>
name|runStatementOnDriver
parameter_list|(
name|String
name|stmt
parameter_list|)
throws|throws
name|Exception
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"+runStatementOnDriver("
operator|+
name|stmt
operator|+
literal|")"
argument_list|)
expr_stmt|;
name|CommandProcessorResponse
name|cpr
init|=
name|d
operator|.
name|run
argument_list|(
name|stmt
argument_list|)
decl_stmt|;
if|if
condition|(
name|cpr
operator|.
name|getResponseCode
argument_list|()
operator|!=
literal|0
condition|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
name|stmt
operator|+
literal|" failed: "
operator|+
name|cpr
argument_list|)
throw|;
block|}
name|List
argument_list|<
name|String
argument_list|>
name|rs
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
name|d
operator|.
name|getResults
argument_list|(
name|rs
argument_list|)
expr_stmt|;
return|return
name|rs
return|;
block|}
specifier|final
name|void
name|assertUniqueID
parameter_list|(
name|Table
name|table
parameter_list|)
throws|throws
name|Exception
block|{
name|String
name|partCols
init|=
name|table
operator|.
name|getPartitionColumns
argument_list|()
decl_stmt|;
comment|//check to make sure there are no duplicate ROW__IDs - HIVE-16832
name|StringBuilder
name|sb
init|=
operator|new
name|StringBuilder
argument_list|(
literal|"select "
argument_list|)
decl_stmt|;
if|if
condition|(
name|partCols
operator|!=
literal|null
operator|&&
name|partCols
operator|.
name|length
argument_list|()
operator|>
literal|0
condition|)
block|{
name|sb
operator|.
name|append
argument_list|(
name|partCols
argument_list|)
operator|.
name|append
argument_list|(
literal|","
argument_list|)
expr_stmt|;
block|}
name|sb
operator|.
name|append
argument_list|(
literal|" ROW__ID, count(*) from "
argument_list|)
operator|.
name|append
argument_list|(
name|table
argument_list|)
operator|.
name|append
argument_list|(
literal|" group by "
argument_list|)
expr_stmt|;
if|if
condition|(
name|partCols
operator|!=
literal|null
operator|&&
name|partCols
operator|.
name|length
argument_list|()
operator|>
literal|0
condition|)
block|{
name|sb
operator|.
name|append
argument_list|(
name|partCols
argument_list|)
operator|.
name|append
argument_list|(
literal|","
argument_list|)
expr_stmt|;
block|}
name|sb
operator|.
name|append
argument_list|(
literal|"ROW__ID having count(*)> 1"
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|r
init|=
name|runStatementOnDriver
argument_list|(
name|sb
operator|.
name|toString
argument_list|()
argument_list|)
decl_stmt|;
name|Assert
operator|.
name|assertTrue
argument_list|(
literal|"Duplicate ROW__ID: "
operator|+
name|r
operator|.
name|toString
argument_list|()
argument_list|,
name|r
operator|.
name|size
argument_list|()
operator|==
literal|0
argument_list|)
expr_stmt|;
block|}
specifier|static
name|String
name|quoteString
parameter_list|(
name|String
name|input
parameter_list|)
block|{
return|return
literal|"'"
operator|+
name|input
operator|+
literal|"'"
return|;
block|}
block|}
end_class

end_unit

