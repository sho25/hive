begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
package|;
end_package

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FileStatus
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FileSystem
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FileUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|Path
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|common
operator|.
name|FileUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|conf
operator|.
name|HiveConf
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|metastore
operator|.
name|txn
operator|.
name|TxnDbUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|processors
operator|.
name|CommandProcessorResponse
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|session
operator|.
name|SessionState
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|txn
operator|.
name|compactor
operator|.
name|Cleaner
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|txn
operator|.
name|compactor
operator|.
name|Worker
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|After
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|Assert
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|Before
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|Ignore
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|Rule
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|Test
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|rules
operator|.
name|TestName
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|File
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Comparator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicBoolean
import|;
end_import

begin_comment
comment|/**  * TODO: this should be merged with TestTxnCommands once that is checked in  * specifically the tests; the supporting code here is just a clone of TestTxnCommands  */
end_comment

begin_class
specifier|public
class|class
name|TestTxnCommands2
block|{
specifier|private
specifier|static
specifier|final
name|String
name|TEST_DATA_DIR
init|=
operator|new
name|File
argument_list|(
name|System
operator|.
name|getProperty
argument_list|(
literal|"java.io.tmpdir"
argument_list|)
operator|+
name|File
operator|.
name|separator
operator|+
name|TestTxnCommands2
operator|.
name|class
operator|.
name|getCanonicalName
argument_list|()
operator|+
literal|"-"
operator|+
name|System
operator|.
name|currentTimeMillis
argument_list|()
argument_list|)
operator|.
name|getPath
argument_list|()
operator|.
name|replaceAll
argument_list|(
literal|"\\\\"
argument_list|,
literal|"/"
argument_list|)
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|String
name|TEST_WAREHOUSE_DIR
init|=
name|TEST_DATA_DIR
operator|+
literal|"/warehouse"
decl_stmt|;
comment|//bucket count for test tables; set it to 1 for easier debugging
specifier|private
specifier|static
name|int
name|BUCKET_COUNT
init|=
literal|2
decl_stmt|;
annotation|@
name|Rule
specifier|public
name|TestName
name|testName
init|=
operator|new
name|TestName
argument_list|()
decl_stmt|;
specifier|private
name|HiveConf
name|hiveConf
decl_stmt|;
specifier|private
name|Driver
name|d
decl_stmt|;
specifier|private
specifier|static
enum|enum
name|Table
block|{
name|ACIDTBL
argument_list|(
literal|"acidTbl"
argument_list|)
block|,
name|ACIDTBLPART
argument_list|(
literal|"acidTblPart"
argument_list|)
block|,
name|NONACIDORCTBL
argument_list|(
literal|"nonAcidOrcTbl"
argument_list|)
block|,
name|NONACIDPART
argument_list|(
literal|"nonAcidPart"
argument_list|)
block|;
specifier|private
specifier|final
name|String
name|name
decl_stmt|;
annotation|@
name|Override
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
name|name
return|;
block|}
name|Table
parameter_list|(
name|String
name|name
parameter_list|)
block|{
name|this
operator|.
name|name
operator|=
name|name
expr_stmt|;
block|}
block|}
annotation|@
name|Before
specifier|public
name|void
name|setUp
parameter_list|()
throws|throws
name|Exception
block|{
name|tearDown
argument_list|()
expr_stmt|;
name|hiveConf
operator|=
operator|new
name|HiveConf
argument_list|(
name|this
operator|.
name|getClass
argument_list|()
argument_list|)
expr_stmt|;
name|hiveConf
operator|.
name|set
argument_list|(
name|HiveConf
operator|.
name|ConfVars
operator|.
name|PREEXECHOOKS
operator|.
name|varname
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|hiveConf
operator|.
name|set
argument_list|(
name|HiveConf
operator|.
name|ConfVars
operator|.
name|POSTEXECHOOKS
operator|.
name|varname
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|hiveConf
operator|.
name|set
argument_list|(
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVE_SUPPORT_CONCURRENCY
operator|.
name|varname
argument_list|,
literal|"false"
argument_list|)
expr_stmt|;
name|hiveConf
operator|.
name|set
argument_list|(
name|HiveConf
operator|.
name|ConfVars
operator|.
name|METASTOREWAREHOUSE
operator|.
name|varname
argument_list|,
name|TEST_WAREHOUSE_DIR
argument_list|)
expr_stmt|;
name|hiveConf
operator|.
name|setVar
argument_list|(
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVEMAPREDMODE
argument_list|,
literal|"nonstrict"
argument_list|)
expr_stmt|;
name|TxnDbUtil
operator|.
name|setConfValues
argument_list|(
name|hiveConf
argument_list|)
expr_stmt|;
name|TxnDbUtil
operator|.
name|prepDb
argument_list|()
expr_stmt|;
name|File
name|f
init|=
operator|new
name|File
argument_list|(
name|TEST_WAREHOUSE_DIR
argument_list|)
decl_stmt|;
if|if
condition|(
name|f
operator|.
name|exists
argument_list|()
condition|)
block|{
name|FileUtil
operator|.
name|fullyDelete
argument_list|(
name|f
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
operator|new
name|File
argument_list|(
name|TEST_WAREHOUSE_DIR
argument_list|)
operator|.
name|mkdirs
argument_list|()
operator|)
condition|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Could not create "
operator|+
name|TEST_WAREHOUSE_DIR
argument_list|)
throw|;
block|}
name|SessionState
operator|.
name|start
argument_list|(
operator|new
name|SessionState
argument_list|(
name|hiveConf
argument_list|)
argument_list|)
expr_stmt|;
name|d
operator|=
operator|new
name|Driver
argument_list|(
name|hiveConf
argument_list|)
expr_stmt|;
name|dropTables
argument_list|()
expr_stmt|;
name|runStatementOnDriver
argument_list|(
literal|"create table "
operator|+
name|Table
operator|.
name|ACIDTBL
operator|+
literal|"(a int, b int) clustered by (a) into "
operator|+
name|BUCKET_COUNT
operator|+
literal|" buckets stored as orc TBLPROPERTIES ('transactional'='true')"
argument_list|)
expr_stmt|;
name|runStatementOnDriver
argument_list|(
literal|"create table "
operator|+
name|Table
operator|.
name|ACIDTBLPART
operator|+
literal|"(a int, b int) partitioned by (p string) clustered by (a) into "
operator|+
name|BUCKET_COUNT
operator|+
literal|" buckets stored as orc TBLPROPERTIES ('transactional'='true')"
argument_list|)
expr_stmt|;
name|runStatementOnDriver
argument_list|(
literal|"create table "
operator|+
name|Table
operator|.
name|NONACIDORCTBL
operator|+
literal|"(a int, b int) clustered by (a) into "
operator|+
name|BUCKET_COUNT
operator|+
literal|" buckets stored as orc TBLPROPERTIES ('transactional'='false')"
argument_list|)
expr_stmt|;
name|runStatementOnDriver
argument_list|(
literal|"create table "
operator|+
name|Table
operator|.
name|NONACIDPART
operator|+
literal|"(a int, b int) partitioned by (p string) stored as orc TBLPROPERTIES ('transactional'='false')"
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|dropTables
parameter_list|()
throws|throws
name|Exception
block|{
for|for
control|(
name|Table
name|t
range|:
name|Table
operator|.
name|values
argument_list|()
control|)
block|{
name|runStatementOnDriver
argument_list|(
literal|"drop table if exists "
operator|+
name|t
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|After
specifier|public
name|void
name|tearDown
parameter_list|()
throws|throws
name|Exception
block|{
try|try
block|{
if|if
condition|(
name|d
operator|!=
literal|null
condition|)
block|{
name|dropTables
argument_list|()
expr_stmt|;
name|d
operator|.
name|destroy
argument_list|()
expr_stmt|;
name|d
operator|.
name|close
argument_list|()
expr_stmt|;
name|d
operator|=
literal|null
expr_stmt|;
block|}
name|TxnDbUtil
operator|.
name|cleanDb
argument_list|()
expr_stmt|;
block|}
finally|finally
block|{
name|FileUtils
operator|.
name|deleteDirectory
argument_list|(
operator|new
name|File
argument_list|(
name|TEST_DATA_DIR
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Test
specifier|public
name|void
name|testOrcPPD
parameter_list|()
throws|throws
name|Exception
block|{
name|testOrcPPD
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testOrcNoPPD
parameter_list|()
throws|throws
name|Exception
block|{
name|testOrcPPD
argument_list|(
literal|false
argument_list|)
expr_stmt|;
block|}
comment|/**    * this is run 2 times: 1 with PPD on, 1 with off    * Also, the queries are such that if we were to push predicate down to an update/delete delta,    * the test would produce wrong results    * @param enablePPD    * @throws Exception    */
specifier|private
name|void
name|testOrcPPD
parameter_list|(
name|boolean
name|enablePPD
parameter_list|)
throws|throws
name|Exception
block|{
name|boolean
name|originalPpd
init|=
name|hiveConf
operator|.
name|getBoolVar
argument_list|(
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVEOPTINDEXFILTER
argument_list|)
decl_stmt|;
name|hiveConf
operator|.
name|setBoolVar
argument_list|(
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVEOPTINDEXFILTER
argument_list|,
name|enablePPD
argument_list|)
expr_stmt|;
comment|//enables ORC PPD
comment|//create delta_0001_0001_0000 (should push predicate here)
name|runStatementOnDriver
argument_list|(
literal|"insert into "
operator|+
name|Table
operator|.
name|ACIDTBL
operator|+
literal|"(a,b) "
operator|+
name|makeValuesClause
argument_list|(
operator|new
name|int
index|[]
index|[]
block|{
block|{
literal|1
block|,
literal|2
block|}
block|,
block|{
literal|3
block|,
literal|4
block|}
block|}
argument_list|)
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|explain
decl_stmt|;
name|String
name|query
init|=
literal|"update "
operator|+
name|Table
operator|.
name|ACIDTBL
operator|+
literal|" set b = 5 where a = 3"
decl_stmt|;
if|if
condition|(
name|enablePPD
condition|)
block|{
name|explain
operator|=
name|runStatementOnDriver
argument_list|(
literal|"explain "
operator|+
name|query
argument_list|)
expr_stmt|;
comment|/*       here is a portion of the above "explain".  The "filterExpr:" in the TableScan is the pushed predicate       w/o PPD, the line is simply not there, otherwise the plan is the same        Map Operator Tree:,          TableScan,           alias: acidtbl,           filterExpr: (a = 3) (type: boolean),             Filter Operator,              predicate: (a = 3) (type: boolean),              Select Operator,              ...        */
name|assertPredicateIsPushed
argument_list|(
literal|"filterExpr: (a = 3)"
argument_list|,
name|explain
argument_list|)
expr_stmt|;
block|}
comment|//create delta_0002_0002_0000 (can't push predicate)
name|runStatementOnDriver
argument_list|(
name|query
argument_list|)
expr_stmt|;
name|query
operator|=
literal|"select a,b from "
operator|+
name|Table
operator|.
name|ACIDTBL
operator|+
literal|" where b = 4 order by a,b"
expr_stmt|;
if|if
condition|(
name|enablePPD
condition|)
block|{
comment|/*at this point we have 2 delta files, 1 for insert 1 for update       * we should push predicate into 1st one but not 2nd.  If the following 'select' were to       * push into the 'update' delta, we'd filter out {3,5} before doing merge and thus      * produce {3,4} as the value for 2nd row.  The right result is 0-rows.*/
name|explain
operator|=
name|runStatementOnDriver
argument_list|(
literal|"explain "
operator|+
name|query
argument_list|)
expr_stmt|;
name|assertPredicateIsPushed
argument_list|(
literal|"filterExpr: (b = 4)"
argument_list|,
name|explain
argument_list|)
expr_stmt|;
block|}
name|List
argument_list|<
name|String
argument_list|>
name|rs0
init|=
name|runStatementOnDriver
argument_list|(
name|query
argument_list|)
decl_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
literal|"Read failed"
argument_list|,
literal|0
argument_list|,
name|rs0
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|runStatementOnDriver
argument_list|(
literal|"alter table "
operator|+
name|Table
operator|.
name|ACIDTBL
operator|+
literal|" compact 'MAJOR'"
argument_list|)
expr_stmt|;
name|Worker
name|t
init|=
operator|new
name|Worker
argument_list|()
decl_stmt|;
name|t
operator|.
name|setThreadId
argument_list|(
operator|(
name|int
operator|)
name|t
operator|.
name|getId
argument_list|()
argument_list|)
expr_stmt|;
name|t
operator|.
name|setHiveConf
argument_list|(
name|hiveConf
argument_list|)
expr_stmt|;
name|AtomicBoolean
name|stop
init|=
operator|new
name|AtomicBoolean
argument_list|()
decl_stmt|;
name|AtomicBoolean
name|looped
init|=
operator|new
name|AtomicBoolean
argument_list|()
decl_stmt|;
name|stop
operator|.
name|set
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|t
operator|.
name|init
argument_list|(
name|stop
argument_list|,
name|looped
argument_list|)
expr_stmt|;
name|t
operator|.
name|run
argument_list|()
expr_stmt|;
comment|//now we have base_0001 file
name|int
index|[]
index|[]
name|tableData2
init|=
block|{
block|{
literal|1
block|,
literal|7
block|}
block|,
block|{
literal|5
block|,
literal|6
block|}
block|,
block|{
literal|7
block|,
literal|8
block|}
block|,
block|{
literal|9
block|,
literal|10
block|}
block|}
decl_stmt|;
name|runStatementOnDriver
argument_list|(
literal|"insert into "
operator|+
name|Table
operator|.
name|ACIDTBL
operator|+
literal|"(a,b) "
operator|+
name|makeValuesClause
argument_list|(
name|tableData2
argument_list|)
argument_list|)
expr_stmt|;
comment|//now we have delta_0003_0003_0000 with inserts only (ok to push predicate)
if|if
condition|(
name|enablePPD
condition|)
block|{
name|explain
operator|=
name|runStatementOnDriver
argument_list|(
literal|"explain delete from "
operator|+
name|Table
operator|.
name|ACIDTBL
operator|+
literal|" where a=7 and b=8"
argument_list|)
expr_stmt|;
name|assertPredicateIsPushed
argument_list|(
literal|"filterExpr: ((a = 7) and (b = 8))"
argument_list|,
name|explain
argument_list|)
expr_stmt|;
block|}
name|runStatementOnDriver
argument_list|(
literal|"delete from "
operator|+
name|Table
operator|.
name|ACIDTBL
operator|+
literal|" where a=7 and b=8"
argument_list|)
expr_stmt|;
comment|//now we have delta_0004_0004_0000 with delete events
comment|/*(can't push predicate to 'delete' delta)     * if we were to push to 'delete' delta, we'd filter out all rows since the 'row' is always NULL for     * delete events and we'd produce data as if the delete never happened*/
name|query
operator|=
literal|"select a,b from "
operator|+
name|Table
operator|.
name|ACIDTBL
operator|+
literal|" where a> 1 order by a,b"
expr_stmt|;
if|if
condition|(
name|enablePPD
condition|)
block|{
name|explain
operator|=
name|runStatementOnDriver
argument_list|(
literal|"explain "
operator|+
name|query
argument_list|)
expr_stmt|;
name|assertPredicateIsPushed
argument_list|(
literal|"filterExpr: (a> 1)"
argument_list|,
name|explain
argument_list|)
expr_stmt|;
block|}
name|List
argument_list|<
name|String
argument_list|>
name|rs1
init|=
name|runStatementOnDriver
argument_list|(
name|query
argument_list|)
decl_stmt|;
name|int
index|[]
index|[]
name|resultData
init|=
operator|new
name|int
index|[]
index|[]
block|{
block|{
literal|3
block|,
literal|5
block|}
block|,
block|{
literal|5
block|,
literal|6
block|}
block|,
block|{
literal|9
block|,
literal|10
block|}
block|}
decl_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
literal|"Update failed"
argument_list|,
name|stringifyValues
argument_list|(
name|resultData
argument_list|)
argument_list|,
name|rs1
argument_list|)
expr_stmt|;
name|hiveConf
operator|.
name|setBoolVar
argument_list|(
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVEOPTINDEXFILTER
argument_list|,
name|originalPpd
argument_list|)
expr_stmt|;
block|}
specifier|private
specifier|static
name|void
name|assertPredicateIsPushed
parameter_list|(
name|String
name|ppd
parameter_list|,
name|List
argument_list|<
name|String
argument_list|>
name|queryPlan
parameter_list|)
block|{
for|for
control|(
name|String
name|line
range|:
name|queryPlan
control|)
block|{
if|if
condition|(
name|line
operator|!=
literal|null
operator|&&
name|line
operator|.
name|contains
argument_list|(
name|ppd
argument_list|)
condition|)
block|{
return|return;
block|}
block|}
name|Assert
operator|.
name|assertFalse
argument_list|(
literal|"PPD '"
operator|+
name|ppd
operator|+
literal|"' wasn't pushed"
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Ignore
argument_list|(
literal|"alter table"
argument_list|)
annotation|@
name|Test
specifier|public
name|void
name|testAlterTable
parameter_list|()
throws|throws
name|Exception
block|{
name|int
index|[]
index|[]
name|tableData
init|=
block|{
block|{
literal|1
block|,
literal|2
block|}
block|}
decl_stmt|;
name|runStatementOnDriver
argument_list|(
literal|"insert into "
operator|+
name|Table
operator|.
name|ACIDTBL
operator|+
literal|"(a,b) "
operator|+
name|makeValuesClause
argument_list|(
name|tableData
argument_list|)
argument_list|)
expr_stmt|;
name|runStatementOnDriver
argument_list|(
literal|"alter table "
operator|+
name|Table
operator|.
name|ACIDTBL
operator|+
literal|" compact 'MAJOR'"
argument_list|)
expr_stmt|;
name|Worker
name|t
init|=
operator|new
name|Worker
argument_list|()
decl_stmt|;
name|t
operator|.
name|setThreadId
argument_list|(
operator|(
name|int
operator|)
name|t
operator|.
name|getId
argument_list|()
argument_list|)
expr_stmt|;
name|t
operator|.
name|setHiveConf
argument_list|(
name|hiveConf
argument_list|)
expr_stmt|;
name|AtomicBoolean
name|stop
init|=
operator|new
name|AtomicBoolean
argument_list|()
decl_stmt|;
name|AtomicBoolean
name|looped
init|=
operator|new
name|AtomicBoolean
argument_list|()
decl_stmt|;
name|stop
operator|.
name|set
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|t
operator|.
name|init
argument_list|(
name|stop
argument_list|,
name|looped
argument_list|)
expr_stmt|;
name|t
operator|.
name|run
argument_list|()
expr_stmt|;
name|int
index|[]
index|[]
name|tableData2
init|=
block|{
block|{
literal|5
block|,
literal|6
block|}
block|}
decl_stmt|;
name|runStatementOnDriver
argument_list|(
literal|"insert into "
operator|+
name|Table
operator|.
name|ACIDTBL
operator|+
literal|"(a,b) "
operator|+
name|makeValuesClause
argument_list|(
name|tableData2
argument_list|)
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|rs1
init|=
name|runStatementOnDriver
argument_list|(
literal|"select a,b from "
operator|+
name|Table
operator|.
name|ACIDTBL
operator|+
literal|" where b> 0 order by a,b"
argument_list|)
decl_stmt|;
name|runStatementOnDriver
argument_list|(
literal|"alter table "
operator|+
name|Table
operator|.
name|ACIDTBL
operator|+
literal|" add columns(c int)"
argument_list|)
expr_stmt|;
name|int
index|[]
index|[]
name|moreTableData
init|=
block|{
block|{
literal|7
block|,
literal|8
block|,
literal|9
block|}
block|}
decl_stmt|;
name|runStatementOnDriver
argument_list|(
literal|"insert into "
operator|+
name|Table
operator|.
name|ACIDTBL
operator|+
literal|"(a,b,c) "
operator|+
name|makeValuesClause
argument_list|(
name|moreTableData
argument_list|)
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|rs0
init|=
name|runStatementOnDriver
argument_list|(
literal|"select a,b,c from "
operator|+
name|Table
operator|.
name|ACIDTBL
operator|+
literal|" where a> 0 order by a,b,c"
argument_list|)
decl_stmt|;
block|}
annotation|@
name|Ignore
argument_list|(
literal|"not needed but useful for testing"
argument_list|)
annotation|@
name|Test
specifier|public
name|void
name|testNonAcidInsert
parameter_list|()
throws|throws
name|Exception
block|{
name|runStatementOnDriver
argument_list|(
literal|"insert into "
operator|+
name|Table
operator|.
name|NONACIDORCTBL
operator|+
literal|"(a,b) values(1,2)"
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|rs
init|=
name|runStatementOnDriver
argument_list|(
literal|"select a,b from "
operator|+
name|Table
operator|.
name|NONACIDORCTBL
argument_list|)
decl_stmt|;
name|runStatementOnDriver
argument_list|(
literal|"insert into "
operator|+
name|Table
operator|.
name|NONACIDORCTBL
operator|+
literal|"(a,b) values(2,3)"
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|rs1
init|=
name|runStatementOnDriver
argument_list|(
literal|"select a,b from "
operator|+
name|Table
operator|.
name|NONACIDORCTBL
argument_list|)
decl_stmt|;
block|}
comment|/**    * Test the query correctness and directory layout after ACID table conversion and MAJOR compaction    * @throws Exception    */
annotation|@
name|Test
specifier|public
name|void
name|testNonAcidToAcidConversionAndMajorCompaction
parameter_list|()
throws|throws
name|Exception
block|{
name|FileSystem
name|fs
init|=
name|FileSystem
operator|.
name|get
argument_list|(
name|hiveConf
argument_list|)
decl_stmt|;
name|FileStatus
index|[]
name|status
decl_stmt|;
comment|// 1. Insert a row to Non-ACID table
name|runStatementOnDriver
argument_list|(
literal|"insert into "
operator|+
name|Table
operator|.
name|NONACIDORCTBL
operator|+
literal|"(a,b) values(1,2)"
argument_list|)
expr_stmt|;
name|status
operator|=
name|fs
operator|.
name|listStatus
argument_list|(
operator|new
name|Path
argument_list|(
name|TEST_WAREHOUSE_DIR
operator|+
literal|"/"
operator|+
operator|(
name|Table
operator|.
name|NONACIDORCTBL
operator|)
operator|.
name|toString
argument_list|()
operator|.
name|toLowerCase
argument_list|()
argument_list|)
argument_list|,
name|FileUtils
operator|.
name|STAGING_DIR_PATH_FILTER
argument_list|)
expr_stmt|;
comment|// There should be 2 original bucket files in the location (000000_0 and 000001_0)
name|Assert
operator|.
name|assertEquals
argument_list|(
name|BUCKET_COUNT
argument_list|,
name|status
operator|.
name|length
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|status
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|Assert
operator|.
name|assertTrue
argument_list|(
name|status
index|[
name|i
index|]
operator|.
name|getPath
argument_list|()
operator|.
name|getName
argument_list|()
operator|.
name|matches
argument_list|(
literal|"00000[01]_0"
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|List
argument_list|<
name|String
argument_list|>
name|rs
init|=
name|runStatementOnDriver
argument_list|(
literal|"select a,b from "
operator|+
name|Table
operator|.
name|NONACIDORCTBL
argument_list|)
decl_stmt|;
name|int
index|[]
index|[]
name|resultData
init|=
operator|new
name|int
index|[]
index|[]
block|{
block|{
literal|1
block|,
literal|2
block|}
block|}
decl_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
name|stringifyValues
argument_list|(
name|resultData
argument_list|)
argument_list|,
name|rs
argument_list|)
expr_stmt|;
name|rs
operator|=
name|runStatementOnDriver
argument_list|(
literal|"select count(*) from "
operator|+
name|Table
operator|.
name|NONACIDORCTBL
argument_list|)
expr_stmt|;
name|int
name|resultCount
init|=
literal|1
decl_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
name|resultCount
argument_list|,
name|Integer
operator|.
name|parseInt
argument_list|(
name|rs
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|// 2. Convert NONACIDORCTBL to ACID table
name|runStatementOnDriver
argument_list|(
literal|"alter table "
operator|+
name|Table
operator|.
name|NONACIDORCTBL
operator|+
literal|" SET TBLPROPERTIES ('transactional'='true')"
argument_list|)
expr_stmt|;
name|status
operator|=
name|fs
operator|.
name|listStatus
argument_list|(
operator|new
name|Path
argument_list|(
name|TEST_WAREHOUSE_DIR
operator|+
literal|"/"
operator|+
operator|(
name|Table
operator|.
name|NONACIDORCTBL
operator|)
operator|.
name|toString
argument_list|()
operator|.
name|toLowerCase
argument_list|()
argument_list|)
argument_list|,
name|FileUtils
operator|.
name|STAGING_DIR_PATH_FILTER
argument_list|)
expr_stmt|;
comment|// Everything should be same as before
name|Assert
operator|.
name|assertEquals
argument_list|(
name|BUCKET_COUNT
argument_list|,
name|status
operator|.
name|length
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|status
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|Assert
operator|.
name|assertTrue
argument_list|(
name|status
index|[
name|i
index|]
operator|.
name|getPath
argument_list|()
operator|.
name|getName
argument_list|()
operator|.
name|matches
argument_list|(
literal|"00000[01]_0"
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|rs
operator|=
name|runStatementOnDriver
argument_list|(
literal|"select a,b from "
operator|+
name|Table
operator|.
name|NONACIDORCTBL
argument_list|)
expr_stmt|;
name|resultData
operator|=
operator|new
name|int
index|[]
index|[]
block|{
block|{
literal|1
block|,
literal|2
block|}
block|}
expr_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
name|stringifyValues
argument_list|(
name|resultData
argument_list|)
argument_list|,
name|rs
argument_list|)
expr_stmt|;
name|rs
operator|=
name|runStatementOnDriver
argument_list|(
literal|"select count(*) from "
operator|+
name|Table
operator|.
name|NONACIDORCTBL
argument_list|)
expr_stmt|;
name|resultCount
operator|=
literal|1
expr_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
name|resultCount
argument_list|,
name|Integer
operator|.
name|parseInt
argument_list|(
name|rs
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|// 3. Insert another row to newly-converted ACID table
name|runStatementOnDriver
argument_list|(
literal|"insert into "
operator|+
name|Table
operator|.
name|NONACIDORCTBL
operator|+
literal|"(a,b) values(3,4)"
argument_list|)
expr_stmt|;
name|status
operator|=
name|fs
operator|.
name|listStatus
argument_list|(
operator|new
name|Path
argument_list|(
name|TEST_WAREHOUSE_DIR
operator|+
literal|"/"
operator|+
operator|(
name|Table
operator|.
name|NONACIDORCTBL
operator|)
operator|.
name|toString
argument_list|()
operator|.
name|toLowerCase
argument_list|()
argument_list|)
argument_list|,
name|FileUtils
operator|.
name|STAGING_DIR_PATH_FILTER
argument_list|)
expr_stmt|;
comment|// There should be 2 original bucket files (000000_0 and 000001_0), plus a new delta directory.
comment|// The delta directory should also have 2 bucket files (bucket_00000 and bucket_00001)
name|Assert
operator|.
name|assertEquals
argument_list|(
literal|3
argument_list|,
name|status
operator|.
name|length
argument_list|)
expr_stmt|;
name|boolean
name|sawNewDelta
init|=
literal|false
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|status
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|status
index|[
name|i
index|]
operator|.
name|getPath
argument_list|()
operator|.
name|getName
argument_list|()
operator|.
name|matches
argument_list|(
literal|"delta_.*"
argument_list|)
condition|)
block|{
name|sawNewDelta
operator|=
literal|true
expr_stmt|;
name|FileStatus
index|[]
name|buckets
init|=
name|fs
operator|.
name|listStatus
argument_list|(
name|status
index|[
name|i
index|]
operator|.
name|getPath
argument_list|()
argument_list|,
name|FileUtils
operator|.
name|STAGING_DIR_PATH_FILTER
argument_list|)
decl_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
name|BUCKET_COUNT
argument_list|,
name|buckets
operator|.
name|length
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertTrue
argument_list|(
name|buckets
index|[
literal|0
index|]
operator|.
name|getPath
argument_list|()
operator|.
name|getName
argument_list|()
operator|.
name|matches
argument_list|(
literal|"bucket_0000[01]"
argument_list|)
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertTrue
argument_list|(
name|buckets
index|[
literal|1
index|]
operator|.
name|getPath
argument_list|()
operator|.
name|getName
argument_list|()
operator|.
name|matches
argument_list|(
literal|"bucket_0000[01]"
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|Assert
operator|.
name|assertTrue
argument_list|(
name|status
index|[
name|i
index|]
operator|.
name|getPath
argument_list|()
operator|.
name|getName
argument_list|()
operator|.
name|matches
argument_list|(
literal|"00000[01]_0"
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|Assert
operator|.
name|assertTrue
argument_list|(
name|sawNewDelta
argument_list|)
expr_stmt|;
name|rs
operator|=
name|runStatementOnDriver
argument_list|(
literal|"select a,b from "
operator|+
name|Table
operator|.
name|NONACIDORCTBL
argument_list|)
expr_stmt|;
name|resultData
operator|=
operator|new
name|int
index|[]
index|[]
block|{
block|{
literal|1
block|,
literal|2
block|}
block|,
block|{
literal|3
block|,
literal|4
block|}
block|}
expr_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
name|stringifyValues
argument_list|(
name|resultData
argument_list|)
argument_list|,
name|rs
argument_list|)
expr_stmt|;
name|rs
operator|=
name|runStatementOnDriver
argument_list|(
literal|"select count(*) from "
operator|+
name|Table
operator|.
name|NONACIDORCTBL
argument_list|)
expr_stmt|;
name|resultCount
operator|=
literal|2
expr_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
name|resultCount
argument_list|,
name|Integer
operator|.
name|parseInt
argument_list|(
name|rs
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|// 4. Perform a major compaction
name|runStatementOnDriver
argument_list|(
literal|"alter table "
operator|+
name|Table
operator|.
name|NONACIDORCTBL
operator|+
literal|" compact 'MAJOR'"
argument_list|)
expr_stmt|;
name|Worker
name|w
init|=
operator|new
name|Worker
argument_list|()
decl_stmt|;
name|w
operator|.
name|setThreadId
argument_list|(
operator|(
name|int
operator|)
name|w
operator|.
name|getId
argument_list|()
argument_list|)
expr_stmt|;
name|w
operator|.
name|setHiveConf
argument_list|(
name|hiveConf
argument_list|)
expr_stmt|;
name|AtomicBoolean
name|stop
init|=
operator|new
name|AtomicBoolean
argument_list|()
decl_stmt|;
name|AtomicBoolean
name|looped
init|=
operator|new
name|AtomicBoolean
argument_list|()
decl_stmt|;
name|stop
operator|.
name|set
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|w
operator|.
name|init
argument_list|(
name|stop
argument_list|,
name|looped
argument_list|)
expr_stmt|;
name|w
operator|.
name|run
argument_list|()
expr_stmt|;
comment|// There should be 1 new directory: base_xxxxxxx.
comment|// Original bucket files and delta directory should stay until Cleaner kicks in.
name|status
operator|=
name|fs
operator|.
name|listStatus
argument_list|(
operator|new
name|Path
argument_list|(
name|TEST_WAREHOUSE_DIR
operator|+
literal|"/"
operator|+
operator|(
name|Table
operator|.
name|NONACIDORCTBL
operator|)
operator|.
name|toString
argument_list|()
operator|.
name|toLowerCase
argument_list|()
argument_list|)
argument_list|,
name|FileUtils
operator|.
name|STAGING_DIR_PATH_FILTER
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
literal|4
argument_list|,
name|status
operator|.
name|length
argument_list|)
expr_stmt|;
name|boolean
name|sawNewBase
init|=
literal|false
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|status
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|status
index|[
name|i
index|]
operator|.
name|getPath
argument_list|()
operator|.
name|getName
argument_list|()
operator|.
name|matches
argument_list|(
literal|"base_.*"
argument_list|)
condition|)
block|{
name|sawNewBase
operator|=
literal|true
expr_stmt|;
name|FileStatus
index|[]
name|buckets
init|=
name|fs
operator|.
name|listStatus
argument_list|(
name|status
index|[
name|i
index|]
operator|.
name|getPath
argument_list|()
argument_list|,
name|FileUtils
operator|.
name|STAGING_DIR_PATH_FILTER
argument_list|)
decl_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
name|BUCKET_COUNT
argument_list|,
name|buckets
operator|.
name|length
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertTrue
argument_list|(
name|buckets
index|[
literal|0
index|]
operator|.
name|getPath
argument_list|()
operator|.
name|getName
argument_list|()
operator|.
name|matches
argument_list|(
literal|"bucket_0000[01]"
argument_list|)
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertTrue
argument_list|(
name|buckets
index|[
literal|1
index|]
operator|.
name|getPath
argument_list|()
operator|.
name|getName
argument_list|()
operator|.
name|matches
argument_list|(
literal|"bucket_0000[01]"
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|Assert
operator|.
name|assertTrue
argument_list|(
name|sawNewBase
argument_list|)
expr_stmt|;
name|rs
operator|=
name|runStatementOnDriver
argument_list|(
literal|"select a,b from "
operator|+
name|Table
operator|.
name|NONACIDORCTBL
argument_list|)
expr_stmt|;
name|resultData
operator|=
operator|new
name|int
index|[]
index|[]
block|{
block|{
literal|1
block|,
literal|2
block|}
block|,
block|{
literal|3
block|,
literal|4
block|}
block|}
expr_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
name|stringifyValues
argument_list|(
name|resultData
argument_list|)
argument_list|,
name|rs
argument_list|)
expr_stmt|;
name|rs
operator|=
name|runStatementOnDriver
argument_list|(
literal|"select count(*) from "
operator|+
name|Table
operator|.
name|NONACIDORCTBL
argument_list|)
expr_stmt|;
name|resultCount
operator|=
literal|2
expr_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
name|resultCount
argument_list|,
name|Integer
operator|.
name|parseInt
argument_list|(
name|rs
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|// 5. Let Cleaner delete obsolete files/dirs
comment|// Note, here we create a fake directory along with fake files as original directories/files
name|String
name|fakeFile0
init|=
name|TEST_WAREHOUSE_DIR
operator|+
literal|"/"
operator|+
operator|(
name|Table
operator|.
name|NONACIDORCTBL
operator|)
operator|.
name|toString
argument_list|()
operator|.
name|toLowerCase
argument_list|()
operator|+
literal|"/subdir/000000_0"
decl_stmt|;
name|String
name|fakeFile1
init|=
name|TEST_WAREHOUSE_DIR
operator|+
literal|"/"
operator|+
operator|(
name|Table
operator|.
name|NONACIDORCTBL
operator|)
operator|.
name|toString
argument_list|()
operator|.
name|toLowerCase
argument_list|()
operator|+
literal|"/subdir/000000_1"
decl_stmt|;
name|fs
operator|.
name|create
argument_list|(
operator|new
name|Path
argument_list|(
name|fakeFile0
argument_list|)
argument_list|)
expr_stmt|;
name|fs
operator|.
name|create
argument_list|(
operator|new
name|Path
argument_list|(
name|fakeFile1
argument_list|)
argument_list|)
expr_stmt|;
name|status
operator|=
name|fs
operator|.
name|listStatus
argument_list|(
operator|new
name|Path
argument_list|(
name|TEST_WAREHOUSE_DIR
operator|+
literal|"/"
operator|+
operator|(
name|Table
operator|.
name|NONACIDORCTBL
operator|)
operator|.
name|toString
argument_list|()
operator|.
name|toLowerCase
argument_list|()
argument_list|)
argument_list|,
name|FileUtils
operator|.
name|STAGING_DIR_PATH_FILTER
argument_list|)
expr_stmt|;
comment|// Before Cleaner, there should be 5 items:
comment|// 2 original files, 1 original directory, 1 base directory and 1 delta directory
name|Assert
operator|.
name|assertEquals
argument_list|(
literal|5
argument_list|,
name|status
operator|.
name|length
argument_list|)
expr_stmt|;
name|Cleaner
name|c
init|=
operator|new
name|Cleaner
argument_list|()
decl_stmt|;
name|c
operator|.
name|setThreadId
argument_list|(
operator|(
name|int
operator|)
name|c
operator|.
name|getId
argument_list|()
argument_list|)
expr_stmt|;
name|c
operator|.
name|setHiveConf
argument_list|(
name|hiveConf
argument_list|)
expr_stmt|;
name|stop
operator|=
operator|new
name|AtomicBoolean
argument_list|()
expr_stmt|;
name|looped
operator|=
operator|new
name|AtomicBoolean
argument_list|()
expr_stmt|;
name|stop
operator|.
name|set
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|c
operator|.
name|init
argument_list|(
name|stop
argument_list|,
name|looped
argument_list|)
expr_stmt|;
name|c
operator|.
name|run
argument_list|()
expr_stmt|;
comment|// There should be only 1 directory left: base_xxxxxxx.
comment|// Original bucket files and delta directory should have been cleaned up.
name|status
operator|=
name|fs
operator|.
name|listStatus
argument_list|(
operator|new
name|Path
argument_list|(
name|TEST_WAREHOUSE_DIR
operator|+
literal|"/"
operator|+
operator|(
name|Table
operator|.
name|NONACIDORCTBL
operator|)
operator|.
name|toString
argument_list|()
operator|.
name|toLowerCase
argument_list|()
argument_list|)
argument_list|,
name|FileUtils
operator|.
name|STAGING_DIR_PATH_FILTER
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
literal|1
argument_list|,
name|status
operator|.
name|length
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertTrue
argument_list|(
name|status
index|[
literal|0
index|]
operator|.
name|getPath
argument_list|()
operator|.
name|getName
argument_list|()
operator|.
name|matches
argument_list|(
literal|"base_.*"
argument_list|)
argument_list|)
expr_stmt|;
name|FileStatus
index|[]
name|buckets
init|=
name|fs
operator|.
name|listStatus
argument_list|(
name|status
index|[
literal|0
index|]
operator|.
name|getPath
argument_list|()
argument_list|,
name|FileUtils
operator|.
name|STAGING_DIR_PATH_FILTER
argument_list|)
decl_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
name|BUCKET_COUNT
argument_list|,
name|buckets
operator|.
name|length
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertTrue
argument_list|(
name|buckets
index|[
literal|0
index|]
operator|.
name|getPath
argument_list|()
operator|.
name|getName
argument_list|()
operator|.
name|matches
argument_list|(
literal|"bucket_0000[01]"
argument_list|)
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertTrue
argument_list|(
name|buckets
index|[
literal|1
index|]
operator|.
name|getPath
argument_list|()
operator|.
name|getName
argument_list|()
operator|.
name|matches
argument_list|(
literal|"bucket_0000[01]"
argument_list|)
argument_list|)
expr_stmt|;
name|rs
operator|=
name|runStatementOnDriver
argument_list|(
literal|"select a,b from "
operator|+
name|Table
operator|.
name|NONACIDORCTBL
argument_list|)
expr_stmt|;
name|resultData
operator|=
operator|new
name|int
index|[]
index|[]
block|{
block|{
literal|1
block|,
literal|2
block|}
block|,
block|{
literal|3
block|,
literal|4
block|}
block|}
expr_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
name|stringifyValues
argument_list|(
name|resultData
argument_list|)
argument_list|,
name|rs
argument_list|)
expr_stmt|;
name|rs
operator|=
name|runStatementOnDriver
argument_list|(
literal|"select count(*) from "
operator|+
name|Table
operator|.
name|NONACIDORCTBL
argument_list|)
expr_stmt|;
name|resultCount
operator|=
literal|2
expr_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
name|resultCount
argument_list|,
name|Integer
operator|.
name|parseInt
argument_list|(
name|rs
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testUpdateMixedCase
parameter_list|()
throws|throws
name|Exception
block|{
name|int
index|[]
index|[]
name|tableData
init|=
block|{
block|{
literal|1
block|,
literal|2
block|}
block|,
block|{
literal|3
block|,
literal|3
block|}
block|,
block|{
literal|5
block|,
literal|3
block|}
block|}
decl_stmt|;
name|runStatementOnDriver
argument_list|(
literal|"insert into "
operator|+
name|Table
operator|.
name|ACIDTBL
operator|+
literal|"(a,b) "
operator|+
name|makeValuesClause
argument_list|(
name|tableData
argument_list|)
argument_list|)
expr_stmt|;
name|runStatementOnDriver
argument_list|(
literal|"update "
operator|+
name|Table
operator|.
name|ACIDTBL
operator|+
literal|" set B = 7 where A=1"
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|rs
init|=
name|runStatementOnDriver
argument_list|(
literal|"select a,b from "
operator|+
name|Table
operator|.
name|ACIDTBL
operator|+
literal|" order by a,b"
argument_list|)
decl_stmt|;
name|int
index|[]
index|[]
name|updatedData
init|=
block|{
block|{
literal|1
block|,
literal|7
block|}
block|,
block|{
literal|3
block|,
literal|3
block|}
block|,
block|{
literal|5
block|,
literal|3
block|}
block|}
decl_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
literal|"Update failed"
argument_list|,
name|stringifyValues
argument_list|(
name|updatedData
argument_list|)
argument_list|,
name|rs
argument_list|)
expr_stmt|;
name|runStatementOnDriver
argument_list|(
literal|"update "
operator|+
name|Table
operator|.
name|ACIDTBL
operator|+
literal|" set B = B + 1 where A=1"
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|rs2
init|=
name|runStatementOnDriver
argument_list|(
literal|"select a,b from "
operator|+
name|Table
operator|.
name|ACIDTBL
operator|+
literal|" order by a,b"
argument_list|)
decl_stmt|;
name|int
index|[]
index|[]
name|updatedData2
init|=
block|{
block|{
literal|1
block|,
literal|8
block|}
block|,
block|{
literal|3
block|,
literal|3
block|}
block|,
block|{
literal|5
block|,
literal|3
block|}
block|}
decl_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
literal|"Update failed"
argument_list|,
name|stringifyValues
argument_list|(
name|updatedData2
argument_list|)
argument_list|,
name|rs2
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testDeleteIn
parameter_list|()
throws|throws
name|Exception
block|{
name|int
index|[]
index|[]
name|tableData
init|=
block|{
block|{
literal|1
block|,
literal|2
block|}
block|,
block|{
literal|3
block|,
literal|2
block|}
block|,
block|{
literal|5
block|,
literal|2
block|}
block|,
block|{
literal|1
block|,
literal|3
block|}
block|,
block|{
literal|3
block|,
literal|3
block|}
block|,
block|{
literal|5
block|,
literal|3
block|}
block|}
decl_stmt|;
name|runStatementOnDriver
argument_list|(
literal|"insert into "
operator|+
name|Table
operator|.
name|ACIDTBL
operator|+
literal|"(a,b) "
operator|+
name|makeValuesClause
argument_list|(
name|tableData
argument_list|)
argument_list|)
expr_stmt|;
name|runStatementOnDriver
argument_list|(
literal|"insert into "
operator|+
name|Table
operator|.
name|NONACIDORCTBL
operator|+
literal|"(a,b) values(1,7),(3,7)"
argument_list|)
expr_stmt|;
comment|//todo: once multistatement txns are supported, add a test to run next 2 statements in a single txn
name|runStatementOnDriver
argument_list|(
literal|"delete from "
operator|+
name|Table
operator|.
name|ACIDTBL
operator|+
literal|" where a in(select a from "
operator|+
name|Table
operator|.
name|NONACIDORCTBL
operator|+
literal|")"
argument_list|)
expr_stmt|;
name|runStatementOnDriver
argument_list|(
literal|"insert into "
operator|+
name|Table
operator|.
name|ACIDTBL
operator|+
literal|"(a,b) select a,b from "
operator|+
name|Table
operator|.
name|NONACIDORCTBL
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|rs
init|=
name|runStatementOnDriver
argument_list|(
literal|"select a,b from "
operator|+
name|Table
operator|.
name|ACIDTBL
operator|+
literal|" order by a,b"
argument_list|)
decl_stmt|;
name|int
index|[]
index|[]
name|updatedData
init|=
block|{
block|{
literal|1
block|,
literal|7
block|}
block|,
block|{
literal|3
block|,
literal|7
block|}
block|,
block|{
literal|5
block|,
literal|2
block|}
block|,
block|{
literal|5
block|,
literal|3
block|}
block|}
decl_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
literal|"Bulk update failed"
argument_list|,
name|stringifyValues
argument_list|(
name|updatedData
argument_list|)
argument_list|,
name|rs
argument_list|)
expr_stmt|;
name|runStatementOnDriver
argument_list|(
literal|"update "
operator|+
name|Table
operator|.
name|ACIDTBL
operator|+
literal|" set b=19 where b in(select b from "
operator|+
name|Table
operator|.
name|NONACIDORCTBL
operator|+
literal|" where a = 3)"
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|rs2
init|=
name|runStatementOnDriver
argument_list|(
literal|"select a,b from "
operator|+
name|Table
operator|.
name|ACIDTBL
operator|+
literal|" order by a,b"
argument_list|)
decl_stmt|;
name|int
index|[]
index|[]
name|updatedData2
init|=
block|{
block|{
literal|1
block|,
literal|19
block|}
block|,
block|{
literal|3
block|,
literal|19
block|}
block|,
block|{
literal|5
block|,
literal|2
block|}
block|,
block|{
literal|5
block|,
literal|3
block|}
block|}
decl_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
literal|"Bulk update2 failed"
argument_list|,
name|stringifyValues
argument_list|(
name|updatedData2
argument_list|)
argument_list|,
name|rs2
argument_list|)
expr_stmt|;
block|}
comment|/**    * https://issues.apache.org/jira/browse/HIVE-10151    */
annotation|@
name|Test
specifier|public
name|void
name|testBucketizedInputFormat
parameter_list|()
throws|throws
name|Exception
block|{
name|int
index|[]
index|[]
name|tableData
init|=
block|{
block|{
literal|1
block|,
literal|2
block|}
block|}
decl_stmt|;
name|runStatementOnDriver
argument_list|(
literal|"insert into "
operator|+
name|Table
operator|.
name|ACIDTBLPART
operator|+
literal|" partition(p=1) (a,b) "
operator|+
name|makeValuesClause
argument_list|(
name|tableData
argument_list|)
argument_list|)
expr_stmt|;
name|runStatementOnDriver
argument_list|(
literal|"insert into "
operator|+
name|Table
operator|.
name|ACIDTBL
operator|+
literal|"(a,b) select a,b from "
operator|+
name|Table
operator|.
name|ACIDTBLPART
operator|+
literal|" where p = 1"
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|rs
init|=
name|runStatementOnDriver
argument_list|(
literal|"select a,b from "
operator|+
name|Table
operator|.
name|ACIDTBL
argument_list|)
decl_stmt|;
comment|//no order by as it's just 1 row
name|Assert
operator|.
name|assertEquals
argument_list|(
literal|"Insert into "
operator|+
name|Table
operator|.
name|ACIDTBL
operator|+
literal|" didn't match:"
argument_list|,
name|stringifyValues
argument_list|(
name|tableData
argument_list|)
argument_list|,
name|rs
argument_list|)
expr_stmt|;
name|runStatementOnDriver
argument_list|(
literal|"insert into "
operator|+
name|Table
operator|.
name|NONACIDORCTBL
operator|+
literal|"(a,b) select a,b from "
operator|+
name|Table
operator|.
name|ACIDTBLPART
operator|+
literal|" where p = 1"
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|rs2
init|=
name|runStatementOnDriver
argument_list|(
literal|"select a,b from "
operator|+
name|Table
operator|.
name|NONACIDORCTBL
argument_list|)
decl_stmt|;
comment|//no order by as it's just 1 row
name|Assert
operator|.
name|assertEquals
argument_list|(
literal|"Insert into "
operator|+
name|Table
operator|.
name|NONACIDORCTBL
operator|+
literal|" didn't match:"
argument_list|,
name|stringifyValues
argument_list|(
name|tableData
argument_list|)
argument_list|,
name|rs2
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testInsertOverwriteWithSelfJoin
parameter_list|()
throws|throws
name|Exception
block|{
name|int
index|[]
index|[]
name|part1Data
init|=
block|{
block|{
literal|1
block|,
literal|7
block|}
block|}
decl_stmt|;
name|runStatementOnDriver
argument_list|(
literal|"insert into "
operator|+
name|Table
operator|.
name|NONACIDORCTBL
operator|+
literal|"(a,b) "
operator|+
name|makeValuesClause
argument_list|(
name|part1Data
argument_list|)
argument_list|)
expr_stmt|;
comment|//this works because logically we need S lock on NONACIDORCTBL to read and X lock to write, but
comment|//LockRequestBuilder dedups locks on the same entity to only keep the highest level lock requested
name|runStatementOnDriver
argument_list|(
literal|"insert overwrite table "
operator|+
name|Table
operator|.
name|NONACIDORCTBL
operator|+
literal|" select 2, 9 from "
operator|+
name|Table
operator|.
name|NONACIDORCTBL
operator|+
literal|" T inner join "
operator|+
name|Table
operator|.
name|NONACIDORCTBL
operator|+
literal|" S on T.a=S.a"
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|rs
init|=
name|runStatementOnDriver
argument_list|(
literal|"select a,b from "
operator|+
name|Table
operator|.
name|NONACIDORCTBL
operator|+
literal|" order by a,b"
argument_list|)
decl_stmt|;
name|int
index|[]
index|[]
name|joinData
init|=
block|{
block|{
literal|2
block|,
literal|9
block|}
block|}
decl_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
literal|"Self join non-part insert overwrite failed"
argument_list|,
name|stringifyValues
argument_list|(
name|joinData
argument_list|)
argument_list|,
name|rs
argument_list|)
expr_stmt|;
name|int
index|[]
index|[]
name|part2Data
init|=
block|{
block|{
literal|1
block|,
literal|8
block|}
block|}
decl_stmt|;
name|runStatementOnDriver
argument_list|(
literal|"insert into "
operator|+
name|Table
operator|.
name|NONACIDPART
operator|+
literal|" partition(p=1) (a,b) "
operator|+
name|makeValuesClause
argument_list|(
name|part1Data
argument_list|)
argument_list|)
expr_stmt|;
name|runStatementOnDriver
argument_list|(
literal|"insert into "
operator|+
name|Table
operator|.
name|NONACIDPART
operator|+
literal|" partition(p=2) (a,b) "
operator|+
name|makeValuesClause
argument_list|(
name|part2Data
argument_list|)
argument_list|)
expr_stmt|;
comment|//here we need X lock on p=1 partition to write and S lock on 'table' to read which should
comment|//not block each other since they are part of the same txn
name|runStatementOnDriver
argument_list|(
literal|"insert overwrite table "
operator|+
name|Table
operator|.
name|NONACIDPART
operator|+
literal|" partition(p=1) select a,b from "
operator|+
name|Table
operator|.
name|NONACIDPART
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|rs2
init|=
name|runStatementOnDriver
argument_list|(
literal|"select a,b from "
operator|+
name|Table
operator|.
name|NONACIDPART
operator|+
literal|" order by a,b"
argument_list|)
decl_stmt|;
name|int
index|[]
index|[]
name|updatedData
init|=
block|{
block|{
literal|1
block|,
literal|7
block|}
block|,
block|{
literal|1
block|,
literal|8
block|}
block|,
block|{
literal|1
block|,
literal|8
block|}
block|}
decl_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
literal|"Insert overwrite partition failed"
argument_list|,
name|stringifyValues
argument_list|(
name|updatedData
argument_list|)
argument_list|,
name|rs2
argument_list|)
expr_stmt|;
comment|//insert overwrite not supported for ACID tables
block|}
comment|/**    * takes raw data and turns it into a string as if from Driver.getResults()    * sorts rows in dictionary order    */
specifier|private
name|List
argument_list|<
name|String
argument_list|>
name|stringifyValues
parameter_list|(
name|int
index|[]
index|[]
name|rowsIn
parameter_list|)
block|{
assert|assert
name|rowsIn
operator|.
name|length
operator|>
literal|0
assert|;
name|int
index|[]
index|[]
name|rows
init|=
name|rowsIn
operator|.
name|clone
argument_list|()
decl_stmt|;
name|Arrays
operator|.
name|sort
argument_list|(
name|rows
argument_list|,
operator|new
name|RowComp
argument_list|()
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|rs
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|int
index|[]
name|row
range|:
name|rows
control|)
block|{
assert|assert
name|row
operator|.
name|length
operator|>
literal|0
assert|;
name|StringBuilder
name|sb
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|value
range|:
name|row
control|)
block|{
name|sb
operator|.
name|append
argument_list|(
name|value
argument_list|)
operator|.
name|append
argument_list|(
literal|"\t"
argument_list|)
expr_stmt|;
block|}
name|sb
operator|.
name|setLength
argument_list|(
name|sb
operator|.
name|length
argument_list|()
operator|-
literal|1
argument_list|)
expr_stmt|;
name|rs
operator|.
name|add
argument_list|(
name|sb
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|rs
return|;
block|}
specifier|private
specifier|static
specifier|final
class|class
name|RowComp
implements|implements
name|Comparator
argument_list|<
name|int
index|[]
argument_list|>
block|{
annotation|@
name|Override
specifier|public
name|int
name|compare
parameter_list|(
name|int
index|[]
name|row1
parameter_list|,
name|int
index|[]
name|row2
parameter_list|)
block|{
assert|assert
name|row1
operator|!=
literal|null
operator|&&
name|row2
operator|!=
literal|null
operator|&&
name|row1
operator|.
name|length
operator|==
name|row2
operator|.
name|length
assert|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|row1
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|int
name|comp
init|=
name|Integer
operator|.
name|compare
argument_list|(
name|row1
index|[
name|i
index|]
argument_list|,
name|row2
index|[
name|i
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
name|comp
operator|!=
literal|0
condition|)
block|{
return|return
name|comp
return|;
block|}
block|}
return|return
literal|0
return|;
block|}
block|}
specifier|private
name|String
name|makeValuesClause
parameter_list|(
name|int
index|[]
index|[]
name|rows
parameter_list|)
block|{
assert|assert
name|rows
operator|.
name|length
operator|>
literal|0
assert|;
name|StringBuilder
name|sb
init|=
operator|new
name|StringBuilder
argument_list|(
literal|"values"
argument_list|)
decl_stmt|;
for|for
control|(
name|int
index|[]
name|row
range|:
name|rows
control|)
block|{
assert|assert
name|row
operator|.
name|length
operator|>
literal|0
assert|;
if|if
condition|(
name|row
operator|.
name|length
operator|>
literal|1
condition|)
block|{
name|sb
operator|.
name|append
argument_list|(
literal|"("
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|int
name|value
range|:
name|row
control|)
block|{
name|sb
operator|.
name|append
argument_list|(
name|value
argument_list|)
operator|.
name|append
argument_list|(
literal|","
argument_list|)
expr_stmt|;
block|}
name|sb
operator|.
name|setLength
argument_list|(
name|sb
operator|.
name|length
argument_list|()
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|//remove trailing comma
if|if
condition|(
name|row
operator|.
name|length
operator|>
literal|1
condition|)
block|{
name|sb
operator|.
name|append
argument_list|(
literal|")"
argument_list|)
expr_stmt|;
block|}
name|sb
operator|.
name|append
argument_list|(
literal|","
argument_list|)
expr_stmt|;
block|}
name|sb
operator|.
name|setLength
argument_list|(
name|sb
operator|.
name|length
argument_list|()
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|//remove trailing comma
return|return
name|sb
operator|.
name|toString
argument_list|()
return|;
block|}
specifier|private
name|List
argument_list|<
name|String
argument_list|>
name|runStatementOnDriver
parameter_list|(
name|String
name|stmt
parameter_list|)
throws|throws
name|Exception
block|{
name|CommandProcessorResponse
name|cpr
init|=
name|d
operator|.
name|run
argument_list|(
name|stmt
argument_list|)
decl_stmt|;
if|if
condition|(
name|cpr
operator|.
name|getResponseCode
argument_list|()
operator|!=
literal|0
condition|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
name|stmt
operator|+
literal|" failed: "
operator|+
name|cpr
argument_list|)
throw|;
block|}
name|List
argument_list|<
name|String
argument_list|>
name|rs
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
name|d
operator|.
name|getResults
argument_list|(
name|rs
argument_list|)
expr_stmt|;
return|return
name|rs
return|;
block|}
block|}
end_class

end_unit

