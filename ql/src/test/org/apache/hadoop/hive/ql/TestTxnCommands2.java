begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|File
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|reflect
operator|.
name|Field
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Comparator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|TimeUnit
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicBoolean
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FileStatus
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FileSystem
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FileUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|Path
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|common
operator|.
name|FileUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|common
operator|.
name|ValidTxnList
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|conf
operator|.
name|HiveConf
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|metastore
operator|.
name|HouseKeeperService
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|metastore
operator|.
name|api
operator|.
name|CommitTxnRequest
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|metastore
operator|.
name|api
operator|.
name|CompactionRequest
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|metastore
operator|.
name|api
operator|.
name|CompactionType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|metastore
operator|.
name|api
operator|.
name|MetaException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|metastore
operator|.
name|api
operator|.
name|OpenTxnRequest
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|metastore
operator|.
name|api
operator|.
name|OpenTxnsResponse
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|metastore
operator|.
name|api
operator|.
name|ShowCompactRequest
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|metastore
operator|.
name|api
operator|.
name|ShowCompactResponse
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|metastore
operator|.
name|api
operator|.
name|ShowCompactResponseElement
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|metastore
operator|.
name|txn
operator|.
name|TxnDbUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|metastore
operator|.
name|txn
operator|.
name|TxnStore
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|metastore
operator|.
name|txn
operator|.
name|TxnUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|io
operator|.
name|HiveInputFormat
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|processors
operator|.
name|CommandProcessorResponse
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|session
operator|.
name|SessionState
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|txn
operator|.
name|AcidCompactionHistoryService
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|txn
operator|.
name|AcidOpenTxnsCounterService
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|txn
operator|.
name|compactor
operator|.
name|Cleaner
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|txn
operator|.
name|compactor
operator|.
name|Initiator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|txn
operator|.
name|compactor
operator|.
name|Worker
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|After
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|Assert
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|Before
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|Ignore
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|Rule
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|Test
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|rules
operator|.
name|TestName
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_comment
comment|/**  * TODO: this should be merged with TestTxnCommands once that is checked in  * specifically the tests; the supporting code here is just a clone of TestTxnCommands  */
end_comment

begin_class
specifier|public
class|class
name|TestTxnCommands2
block|{
specifier|static
specifier|final
specifier|private
name|Logger
name|LOG
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|TestTxnCommands2
operator|.
name|class
argument_list|)
decl_stmt|;
specifier|protected
specifier|static
specifier|final
name|String
name|TEST_DATA_DIR
init|=
operator|new
name|File
argument_list|(
name|System
operator|.
name|getProperty
argument_list|(
literal|"java.io.tmpdir"
argument_list|)
operator|+
name|File
operator|.
name|separator
operator|+
name|TestTxnCommands2
operator|.
name|class
operator|.
name|getCanonicalName
argument_list|()
operator|+
literal|"-"
operator|+
name|System
operator|.
name|currentTimeMillis
argument_list|()
argument_list|)
operator|.
name|getPath
argument_list|()
operator|.
name|replaceAll
argument_list|(
literal|"\\\\"
argument_list|,
literal|"/"
argument_list|)
decl_stmt|;
specifier|protected
specifier|static
specifier|final
name|String
name|TEST_WAREHOUSE_DIR
init|=
name|TEST_DATA_DIR
operator|+
literal|"/warehouse"
decl_stmt|;
comment|//bucket count for test tables; set it to 1 for easier debugging
specifier|protected
specifier|static
name|int
name|BUCKET_COUNT
init|=
literal|2
decl_stmt|;
annotation|@
name|Rule
specifier|public
name|TestName
name|testName
init|=
operator|new
name|TestName
argument_list|()
decl_stmt|;
specifier|protected
name|HiveConf
name|hiveConf
decl_stmt|;
specifier|protected
name|Driver
name|d
decl_stmt|;
specifier|protected
specifier|static
enum|enum
name|Table
block|{
name|ACIDTBL
argument_list|(
literal|"acidTbl"
argument_list|)
block|,
name|ACIDTBLPART
argument_list|(
literal|"acidTblPart"
argument_list|)
block|,
name|NONACIDORCTBL
argument_list|(
literal|"nonAcidOrcTbl"
argument_list|)
block|,
name|NONACIDPART
argument_list|(
literal|"nonAcidPart"
argument_list|)
block|,
name|NONACIDPART2
argument_list|(
literal|"nonAcidPart2"
argument_list|)
block|,
name|ACIDNESTEDPART
argument_list|(
literal|"acidNestedPart"
argument_list|)
block|;
specifier|private
specifier|final
name|String
name|name
decl_stmt|;
annotation|@
name|Override
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
name|name
return|;
block|}
name|Table
parameter_list|(
name|String
name|name
parameter_list|)
block|{
name|this
operator|.
name|name
operator|=
name|name
expr_stmt|;
block|}
block|}
annotation|@
name|Before
specifier|public
name|void
name|setUp
parameter_list|()
throws|throws
name|Exception
block|{
name|setUpWithTableProperties
argument_list|(
literal|"'transactional'='true'"
argument_list|)
expr_stmt|;
block|}
specifier|protected
name|void
name|setUpWithTableProperties
parameter_list|(
name|String
name|tableProperties
parameter_list|)
throws|throws
name|Exception
block|{
name|tearDown
argument_list|()
expr_stmt|;
name|hiveConf
operator|=
operator|new
name|HiveConf
argument_list|(
name|this
operator|.
name|getClass
argument_list|()
argument_list|)
expr_stmt|;
name|hiveConf
operator|.
name|set
argument_list|(
name|HiveConf
operator|.
name|ConfVars
operator|.
name|PREEXECHOOKS
operator|.
name|varname
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|hiveConf
operator|.
name|set
argument_list|(
name|HiveConf
operator|.
name|ConfVars
operator|.
name|POSTEXECHOOKS
operator|.
name|varname
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|hiveConf
operator|.
name|set
argument_list|(
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVE_SUPPORT_CONCURRENCY
operator|.
name|varname
argument_list|,
literal|"false"
argument_list|)
expr_stmt|;
name|hiveConf
operator|.
name|set
argument_list|(
name|HiveConf
operator|.
name|ConfVars
operator|.
name|METASTOREWAREHOUSE
operator|.
name|varname
argument_list|,
name|TEST_WAREHOUSE_DIR
argument_list|)
expr_stmt|;
name|hiveConf
operator|.
name|setVar
argument_list|(
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVEMAPREDMODE
argument_list|,
literal|"nonstrict"
argument_list|)
expr_stmt|;
name|hiveConf
operator|.
name|setVar
argument_list|(
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVEINPUTFORMAT
argument_list|,
name|HiveInputFormat
operator|.
name|class
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
name|hiveConf
operator|.
name|setVar
argument_list|(
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVE_AUTHORIZATION_MANAGER
argument_list|,
literal|"org.apache.hadoop.hive.ql.security.authorization.plugin.sqlstd.SQLStdHiveAuthorizerFactory"
argument_list|)
expr_stmt|;
name|TxnDbUtil
operator|.
name|setConfValues
argument_list|(
name|hiveConf
argument_list|)
expr_stmt|;
name|TxnDbUtil
operator|.
name|prepDb
argument_list|()
expr_stmt|;
name|File
name|f
init|=
operator|new
name|File
argument_list|(
name|TEST_WAREHOUSE_DIR
argument_list|)
decl_stmt|;
if|if
condition|(
name|f
operator|.
name|exists
argument_list|()
condition|)
block|{
name|FileUtil
operator|.
name|fullyDelete
argument_list|(
name|f
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
operator|new
name|File
argument_list|(
name|TEST_WAREHOUSE_DIR
argument_list|)
operator|.
name|mkdirs
argument_list|()
operator|)
condition|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Could not create "
operator|+
name|TEST_WAREHOUSE_DIR
argument_list|)
throw|;
block|}
name|SessionState
operator|.
name|start
argument_list|(
operator|new
name|SessionState
argument_list|(
name|hiveConf
argument_list|)
argument_list|)
expr_stmt|;
name|d
operator|=
operator|new
name|Driver
argument_list|(
name|hiveConf
argument_list|)
expr_stmt|;
name|d
operator|.
name|setMaxRows
argument_list|(
literal|10000
argument_list|)
expr_stmt|;
name|dropTables
argument_list|()
expr_stmt|;
name|runStatementOnDriver
argument_list|(
literal|"create table "
operator|+
name|Table
operator|.
name|ACIDTBL
operator|+
literal|"(a int, b int) clustered by (a) into "
operator|+
name|BUCKET_COUNT
operator|+
literal|" buckets stored as orc TBLPROPERTIES ("
operator|+
name|tableProperties
operator|+
literal|")"
argument_list|)
expr_stmt|;
name|runStatementOnDriver
argument_list|(
literal|"create table "
operator|+
name|Table
operator|.
name|ACIDTBLPART
operator|+
literal|"(a int, b int) partitioned by (p string) clustered by (a) into "
operator|+
name|BUCKET_COUNT
operator|+
literal|" buckets stored as orc TBLPROPERTIES ("
operator|+
name|tableProperties
operator|+
literal|")"
argument_list|)
expr_stmt|;
name|runStatementOnDriver
argument_list|(
literal|"create table "
operator|+
name|Table
operator|.
name|NONACIDORCTBL
operator|+
literal|"(a int, b int) clustered by (a) into "
operator|+
name|BUCKET_COUNT
operator|+
literal|" buckets stored as orc TBLPROPERTIES ('transactional'='false')"
argument_list|)
expr_stmt|;
name|runStatementOnDriver
argument_list|(
literal|"create table "
operator|+
name|Table
operator|.
name|NONACIDPART
operator|+
literal|"(a int, b int) partitioned by (p string) stored as orc TBLPROPERTIES ('transactional'='false')"
argument_list|)
expr_stmt|;
name|runStatementOnDriver
argument_list|(
literal|"create table "
operator|+
name|Table
operator|.
name|NONACIDPART2
operator|+
literal|"(a2 int, b2 int) partitioned by (p2 string) stored as orc TBLPROPERTIES ('transactional'='false')"
argument_list|)
expr_stmt|;
name|runStatementOnDriver
argument_list|(
literal|"create table "
operator|+
name|Table
operator|.
name|ACIDNESTEDPART
operator|+
literal|"(a int, b int) partitioned by (p int, q int) clustered by (a) into "
operator|+
name|BUCKET_COUNT
operator|+
literal|" buckets stored as orc TBLPROPERTIES ("
operator|+
name|tableProperties
operator|+
literal|")"
argument_list|)
expr_stmt|;
block|}
specifier|protected
name|void
name|dropTables
parameter_list|()
throws|throws
name|Exception
block|{
for|for
control|(
name|Table
name|t
range|:
name|Table
operator|.
name|values
argument_list|()
control|)
block|{
name|runStatementOnDriver
argument_list|(
literal|"drop table if exists "
operator|+
name|t
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|After
specifier|public
name|void
name|tearDown
parameter_list|()
throws|throws
name|Exception
block|{
try|try
block|{
if|if
condition|(
name|d
operator|!=
literal|null
condition|)
block|{
name|dropTables
argument_list|()
expr_stmt|;
name|d
operator|.
name|destroy
argument_list|()
expr_stmt|;
name|d
operator|.
name|close
argument_list|()
expr_stmt|;
name|d
operator|=
literal|null
expr_stmt|;
block|}
name|TxnDbUtil
operator|.
name|cleanDb
argument_list|()
expr_stmt|;
block|}
finally|finally
block|{
name|FileUtils
operator|.
name|deleteDirectory
argument_list|(
operator|new
name|File
argument_list|(
name|TEST_DATA_DIR
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Test
specifier|public
name|void
name|testOrcPPD
parameter_list|()
throws|throws
name|Exception
block|{
name|testOrcPPD
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testOrcNoPPD
parameter_list|()
throws|throws
name|Exception
block|{
name|testOrcPPD
argument_list|(
literal|false
argument_list|)
expr_stmt|;
block|}
comment|/**    * this is run 2 times: 1 with PPD on, 1 with off    * Also, the queries are such that if we were to push predicate down to an update/delete delta,    * the test would produce wrong results    * @param enablePPD    * @throws Exception    */
specifier|private
name|void
name|testOrcPPD
parameter_list|(
name|boolean
name|enablePPD
parameter_list|)
throws|throws
name|Exception
block|{
name|boolean
name|originalPpd
init|=
name|hiveConf
operator|.
name|getBoolVar
argument_list|(
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVEOPTINDEXFILTER
argument_list|)
decl_stmt|;
name|hiveConf
operator|.
name|setBoolVar
argument_list|(
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVEOPTINDEXFILTER
argument_list|,
name|enablePPD
argument_list|)
expr_stmt|;
comment|//enables ORC PPD
comment|//create delta_0001_0001_0000 (should push predicate here)
name|runStatementOnDriver
argument_list|(
literal|"insert into "
operator|+
name|Table
operator|.
name|ACIDTBL
operator|+
literal|"(a,b) "
operator|+
name|makeValuesClause
argument_list|(
operator|new
name|int
index|[]
index|[]
block|{
block|{
literal|1
block|,
literal|2
block|}
block|,
block|{
literal|3
block|,
literal|4
block|}
block|}
argument_list|)
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|explain
decl_stmt|;
name|String
name|query
init|=
literal|"update "
operator|+
name|Table
operator|.
name|ACIDTBL
operator|+
literal|" set b = 5 where a = 3"
decl_stmt|;
if|if
condition|(
name|enablePPD
condition|)
block|{
name|explain
operator|=
name|runStatementOnDriver
argument_list|(
literal|"explain "
operator|+
name|query
argument_list|)
expr_stmt|;
comment|/*       here is a portion of the above "explain".  The "filterExpr:" in the TableScan is the pushed predicate       w/o PPD, the line is simply not there, otherwise the plan is the same        Map Operator Tree:,          TableScan,           alias: acidtbl,           filterExpr: (a = 3) (type: boolean),             Filter Operator,              predicate: (a = 3) (type: boolean),              Select Operator,              ...        */
name|assertExplainHasString
argument_list|(
literal|"filterExpr: (a = 3)"
argument_list|,
name|explain
argument_list|,
literal|"PPD wasn't pushed"
argument_list|)
expr_stmt|;
block|}
comment|//create delta_0002_0002_0000 (can't push predicate)
name|runStatementOnDriver
argument_list|(
name|query
argument_list|)
expr_stmt|;
name|query
operator|=
literal|"select a,b from "
operator|+
name|Table
operator|.
name|ACIDTBL
operator|+
literal|" where b = 4 order by a,b"
expr_stmt|;
if|if
condition|(
name|enablePPD
condition|)
block|{
comment|/*at this point we have 2 delta files, 1 for insert 1 for update       * we should push predicate into 1st one but not 2nd.  If the following 'select' were to       * push into the 'update' delta, we'd filter out {3,5} before doing merge and thus      * produce {3,4} as the value for 2nd row.  The right result is 0-rows.*/
name|explain
operator|=
name|runStatementOnDriver
argument_list|(
literal|"explain "
operator|+
name|query
argument_list|)
expr_stmt|;
name|assertExplainHasString
argument_list|(
literal|"filterExpr: (b = 4)"
argument_list|,
name|explain
argument_list|,
literal|"PPD wasn't pushed"
argument_list|)
expr_stmt|;
block|}
name|List
argument_list|<
name|String
argument_list|>
name|rs0
init|=
name|runStatementOnDriver
argument_list|(
name|query
argument_list|)
decl_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
literal|"Read failed"
argument_list|,
literal|0
argument_list|,
name|rs0
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|runStatementOnDriver
argument_list|(
literal|"alter table "
operator|+
name|Table
operator|.
name|ACIDTBL
operator|+
literal|" compact 'MAJOR'"
argument_list|)
expr_stmt|;
name|Worker
name|t
init|=
operator|new
name|Worker
argument_list|()
decl_stmt|;
name|t
operator|.
name|setThreadId
argument_list|(
operator|(
name|int
operator|)
name|t
operator|.
name|getId
argument_list|()
argument_list|)
expr_stmt|;
name|t
operator|.
name|setHiveConf
argument_list|(
name|hiveConf
argument_list|)
expr_stmt|;
name|AtomicBoolean
name|stop
init|=
operator|new
name|AtomicBoolean
argument_list|()
decl_stmt|;
name|AtomicBoolean
name|looped
init|=
operator|new
name|AtomicBoolean
argument_list|()
decl_stmt|;
name|stop
operator|.
name|set
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|t
operator|.
name|init
argument_list|(
name|stop
argument_list|,
name|looped
argument_list|)
expr_stmt|;
name|t
operator|.
name|run
argument_list|()
expr_stmt|;
comment|//now we have base_0001 file
name|int
index|[]
index|[]
name|tableData2
init|=
block|{
block|{
literal|1
block|,
literal|7
block|}
block|,
block|{
literal|5
block|,
literal|6
block|}
block|,
block|{
literal|7
block|,
literal|8
block|}
block|,
block|{
literal|9
block|,
literal|10
block|}
block|}
decl_stmt|;
name|runStatementOnDriver
argument_list|(
literal|"insert into "
operator|+
name|Table
operator|.
name|ACIDTBL
operator|+
literal|"(a,b) "
operator|+
name|makeValuesClause
argument_list|(
name|tableData2
argument_list|)
argument_list|)
expr_stmt|;
comment|//now we have delta_0003_0003_0000 with inserts only (ok to push predicate)
if|if
condition|(
name|enablePPD
condition|)
block|{
name|explain
operator|=
name|runStatementOnDriver
argument_list|(
literal|"explain delete from "
operator|+
name|Table
operator|.
name|ACIDTBL
operator|+
literal|" where a=7 and b=8"
argument_list|)
expr_stmt|;
name|assertExplainHasString
argument_list|(
literal|"filterExpr: ((a = 7) and (b = 8))"
argument_list|,
name|explain
argument_list|,
literal|"PPD wasn't pushed"
argument_list|)
expr_stmt|;
block|}
name|runStatementOnDriver
argument_list|(
literal|"delete from "
operator|+
name|Table
operator|.
name|ACIDTBL
operator|+
literal|" where a=7 and b=8"
argument_list|)
expr_stmt|;
comment|//now we have delta_0004_0004_0000 with delete events
comment|/*(can't push predicate to 'delete' delta)     * if we were to push to 'delete' delta, we'd filter out all rows since the 'row' is always NULL for     * delete events and we'd produce data as if the delete never happened*/
name|query
operator|=
literal|"select a,b from "
operator|+
name|Table
operator|.
name|ACIDTBL
operator|+
literal|" where a> 1 order by a,b"
expr_stmt|;
if|if
condition|(
name|enablePPD
condition|)
block|{
name|explain
operator|=
name|runStatementOnDriver
argument_list|(
literal|"explain "
operator|+
name|query
argument_list|)
expr_stmt|;
name|assertExplainHasString
argument_list|(
literal|"filterExpr: (a> 1)"
argument_list|,
name|explain
argument_list|,
literal|"PPD wasn't pushed"
argument_list|)
expr_stmt|;
block|}
name|List
argument_list|<
name|String
argument_list|>
name|rs1
init|=
name|runStatementOnDriver
argument_list|(
name|query
argument_list|)
decl_stmt|;
name|int
index|[]
index|[]
name|resultData
init|=
operator|new
name|int
index|[]
index|[]
block|{
block|{
literal|3
block|,
literal|5
block|}
block|,
block|{
literal|5
block|,
literal|6
block|}
block|,
block|{
literal|9
block|,
literal|10
block|}
block|}
decl_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
literal|"Update failed"
argument_list|,
name|stringifyValues
argument_list|(
name|resultData
argument_list|)
argument_list|,
name|rs1
argument_list|)
expr_stmt|;
name|hiveConf
operator|.
name|setBoolVar
argument_list|(
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVEOPTINDEXFILTER
argument_list|,
name|originalPpd
argument_list|)
expr_stmt|;
block|}
specifier|static
name|void
name|assertExplainHasString
parameter_list|(
name|String
name|string
parameter_list|,
name|List
argument_list|<
name|String
argument_list|>
name|queryPlan
parameter_list|,
name|String
name|errMsg
parameter_list|)
block|{
for|for
control|(
name|String
name|line
range|:
name|queryPlan
control|)
block|{
if|if
condition|(
name|line
operator|!=
literal|null
operator|&&
name|line
operator|.
name|contains
argument_list|(
name|string
argument_list|)
condition|)
block|{
return|return;
block|}
block|}
name|Assert
operator|.
name|assertFalse
argument_list|(
name|errMsg
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testAlterTable
parameter_list|()
throws|throws
name|Exception
block|{
name|int
index|[]
index|[]
name|tableData
init|=
block|{
block|{
literal|1
block|,
literal|2
block|}
block|}
decl_stmt|;
name|runStatementOnDriver
argument_list|(
literal|"insert into "
operator|+
name|Table
operator|.
name|ACIDTBL
operator|+
literal|"(a,b) "
operator|+
name|makeValuesClause
argument_list|(
name|tableData
argument_list|)
argument_list|)
expr_stmt|;
name|runStatementOnDriver
argument_list|(
literal|"alter table "
operator|+
name|Table
operator|.
name|ACIDTBL
operator|+
literal|" compact 'MAJOR'"
argument_list|)
expr_stmt|;
name|Worker
name|t
init|=
operator|new
name|Worker
argument_list|()
decl_stmt|;
name|t
operator|.
name|setThreadId
argument_list|(
operator|(
name|int
operator|)
name|t
operator|.
name|getId
argument_list|()
argument_list|)
expr_stmt|;
name|t
operator|.
name|setHiveConf
argument_list|(
name|hiveConf
argument_list|)
expr_stmt|;
name|AtomicBoolean
name|stop
init|=
operator|new
name|AtomicBoolean
argument_list|()
decl_stmt|;
name|AtomicBoolean
name|looped
init|=
operator|new
name|AtomicBoolean
argument_list|()
decl_stmt|;
name|stop
operator|.
name|set
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|t
operator|.
name|init
argument_list|(
name|stop
argument_list|,
name|looped
argument_list|)
expr_stmt|;
name|t
operator|.
name|run
argument_list|()
expr_stmt|;
name|int
index|[]
index|[]
name|tableData2
init|=
block|{
block|{
literal|5
block|,
literal|6
block|}
block|}
decl_stmt|;
name|runStatementOnDriver
argument_list|(
literal|"insert into "
operator|+
name|Table
operator|.
name|ACIDTBL
operator|+
literal|"(a,b) "
operator|+
name|makeValuesClause
argument_list|(
name|tableData2
argument_list|)
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|rs1
init|=
name|runStatementOnDriver
argument_list|(
literal|"select a,b from "
operator|+
name|Table
operator|.
name|ACIDTBL
operator|+
literal|" where b> 0 order by a,b"
argument_list|)
decl_stmt|;
name|runStatementOnDriver
argument_list|(
literal|"alter table "
operator|+
name|Table
operator|.
name|ACIDTBL
operator|+
literal|" add columns(c int)"
argument_list|)
expr_stmt|;
name|int
index|[]
index|[]
name|moreTableData
init|=
block|{
block|{
literal|7
block|,
literal|8
block|,
literal|9
block|}
block|}
decl_stmt|;
name|runStatementOnDriver
argument_list|(
literal|"insert into "
operator|+
name|Table
operator|.
name|ACIDTBL
operator|+
literal|"(a,b,c) "
operator|+
name|makeValuesClause
argument_list|(
name|moreTableData
argument_list|)
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|rs0
init|=
name|runStatementOnDriver
argument_list|(
literal|"select a,b,c from "
operator|+
name|Table
operator|.
name|ACIDTBL
operator|+
literal|" where a> 0 order by a,b,c"
argument_list|)
decl_stmt|;
block|}
annotation|@
name|Ignore
argument_list|(
literal|"not needed but useful for testing"
argument_list|)
annotation|@
name|Test
specifier|public
name|void
name|testNonAcidInsert
parameter_list|()
throws|throws
name|Exception
block|{
name|runStatementOnDriver
argument_list|(
literal|"insert into "
operator|+
name|Table
operator|.
name|NONACIDORCTBL
operator|+
literal|"(a,b) values(1,2)"
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|rs
init|=
name|runStatementOnDriver
argument_list|(
literal|"select a,b from "
operator|+
name|Table
operator|.
name|NONACIDORCTBL
argument_list|)
decl_stmt|;
name|runStatementOnDriver
argument_list|(
literal|"insert into "
operator|+
name|Table
operator|.
name|NONACIDORCTBL
operator|+
literal|"(a,b) values(2,3)"
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|rs1
init|=
name|runStatementOnDriver
argument_list|(
literal|"select a,b from "
operator|+
name|Table
operator|.
name|NONACIDORCTBL
argument_list|)
decl_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testOriginalFileReaderWhenNonAcidConvertedToAcid
parameter_list|()
throws|throws
name|Exception
block|{
comment|// 1. Insert five rows to Non-ACID table.
name|runStatementOnDriver
argument_list|(
literal|"insert into "
operator|+
name|Table
operator|.
name|NONACIDORCTBL
operator|+
literal|"(a,b) values(1,2),(3,4),(5,6),(7,8),(9,10)"
argument_list|)
expr_stmt|;
comment|// 2. Convert NONACIDORCTBL to ACID table.
name|runStatementOnDriver
argument_list|(
literal|"alter table "
operator|+
name|Table
operator|.
name|NONACIDORCTBL
operator|+
literal|" SET TBLPROPERTIES ('transactional'='true')"
argument_list|)
expr_stmt|;
name|runStatementOnDriver
argument_list|(
literal|"update "
operator|+
name|Table
operator|.
name|NONACIDORCTBL
operator|+
literal|" set b = b*2 where b in (4,10)"
argument_list|)
expr_stmt|;
name|runStatementOnDriver
argument_list|(
literal|"delete from "
operator|+
name|Table
operator|.
name|NONACIDORCTBL
operator|+
literal|" where a = 7"
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|rs
init|=
name|runStatementOnDriver
argument_list|(
literal|"select a,b from "
operator|+
name|Table
operator|.
name|NONACIDORCTBL
operator|+
literal|" order by a,b"
argument_list|)
decl_stmt|;
name|int
index|[]
index|[]
name|resultData
init|=
operator|new
name|int
index|[]
index|[]
block|{
block|{
literal|1
block|,
literal|2
block|}
block|,
block|{
literal|3
block|,
literal|8
block|}
block|,
block|{
literal|5
block|,
literal|6
block|}
block|,
block|{
literal|9
block|,
literal|20
block|}
block|}
decl_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
name|stringifyValues
argument_list|(
name|resultData
argument_list|)
argument_list|,
name|rs
argument_list|)
expr_stmt|;
comment|// 3. Perform a major compaction.
name|runStatementOnDriver
argument_list|(
literal|"alter table "
operator|+
name|Table
operator|.
name|NONACIDORCTBL
operator|+
literal|" compact 'MAJOR'"
argument_list|)
expr_stmt|;
name|runWorker
argument_list|(
name|hiveConf
argument_list|)
expr_stmt|;
name|TxnStore
name|txnHandler
init|=
name|TxnUtils
operator|.
name|getTxnStore
argument_list|(
name|hiveConf
argument_list|)
decl_stmt|;
name|ShowCompactResponse
name|resp
init|=
name|txnHandler
operator|.
name|showCompact
argument_list|(
operator|new
name|ShowCompactRequest
argument_list|()
argument_list|)
decl_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
literal|"Unexpected number of compactions in history"
argument_list|,
literal|1
argument_list|,
name|resp
operator|.
name|getCompactsSize
argument_list|()
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
literal|"Unexpected 0 compaction state"
argument_list|,
name|TxnStore
operator|.
name|CLEANING_RESPONSE
argument_list|,
name|resp
operator|.
name|getCompacts
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|getState
argument_list|()
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertTrue
argument_list|(
name|resp
operator|.
name|getCompacts
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|getHadoopJobId
argument_list|()
operator|.
name|startsWith
argument_list|(
literal|"job_local"
argument_list|)
argument_list|)
expr_stmt|;
comment|// 3. Perform a delete.
name|runStatementOnDriver
argument_list|(
literal|"delete from "
operator|+
name|Table
operator|.
name|NONACIDORCTBL
operator|+
literal|" where a = 1"
argument_list|)
expr_stmt|;
name|rs
operator|=
name|runStatementOnDriver
argument_list|(
literal|"select a,b from "
operator|+
name|Table
operator|.
name|NONACIDORCTBL
operator|+
literal|" order by a,b"
argument_list|)
expr_stmt|;
name|resultData
operator|=
operator|new
name|int
index|[]
index|[]
block|{
block|{
literal|3
block|,
literal|8
block|}
block|,
block|{
literal|5
block|,
literal|6
block|}
block|,
block|{
literal|9
block|,
literal|20
block|}
block|}
expr_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
name|stringifyValues
argument_list|(
name|resultData
argument_list|)
argument_list|,
name|rs
argument_list|)
expr_stmt|;
block|}
comment|/**    * Test the query correctness and directory layout after ACID table conversion and MAJOR compaction    * 1. Insert a row to Non-ACID table    * 2. Convert Non-ACID to ACID table    * 3. Insert a row to ACID table    * 4. Perform Major compaction    * 5. Clean    * @throws Exception    */
annotation|@
name|Test
specifier|public
name|void
name|testNonAcidToAcidConversion1
parameter_list|()
throws|throws
name|Exception
block|{
name|FileSystem
name|fs
init|=
name|FileSystem
operator|.
name|get
argument_list|(
name|hiveConf
argument_list|)
decl_stmt|;
name|FileStatus
index|[]
name|status
decl_stmt|;
comment|// 1. Insert a row to Non-ACID table
name|runStatementOnDriver
argument_list|(
literal|"insert into "
operator|+
name|Table
operator|.
name|NONACIDORCTBL
operator|+
literal|"(a,b) values(1,2)"
argument_list|)
expr_stmt|;
name|status
operator|=
name|fs
operator|.
name|listStatus
argument_list|(
operator|new
name|Path
argument_list|(
name|TEST_WAREHOUSE_DIR
operator|+
literal|"/"
operator|+
operator|(
name|Table
operator|.
name|NONACIDORCTBL
operator|)
operator|.
name|toString
argument_list|()
operator|.
name|toLowerCase
argument_list|()
argument_list|)
argument_list|,
name|FileUtils
operator|.
name|STAGING_DIR_PATH_FILTER
argument_list|)
expr_stmt|;
comment|// There should be 2 original bucket files in the location (000000_0 and 000001_0)
name|Assert
operator|.
name|assertEquals
argument_list|(
name|BUCKET_COUNT
argument_list|,
name|status
operator|.
name|length
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|status
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|Assert
operator|.
name|assertTrue
argument_list|(
name|status
index|[
name|i
index|]
operator|.
name|getPath
argument_list|()
operator|.
name|getName
argument_list|()
operator|.
name|matches
argument_list|(
literal|"00000[01]_0"
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|List
argument_list|<
name|String
argument_list|>
name|rs
init|=
name|runStatementOnDriver
argument_list|(
literal|"select a,b from "
operator|+
name|Table
operator|.
name|NONACIDORCTBL
argument_list|)
decl_stmt|;
name|int
index|[]
index|[]
name|resultData
init|=
operator|new
name|int
index|[]
index|[]
block|{
block|{
literal|1
block|,
literal|2
block|}
block|}
decl_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
name|stringifyValues
argument_list|(
name|resultData
argument_list|)
argument_list|,
name|rs
argument_list|)
expr_stmt|;
name|rs
operator|=
name|runStatementOnDriver
argument_list|(
literal|"select count(*) from "
operator|+
name|Table
operator|.
name|NONACIDORCTBL
argument_list|)
expr_stmt|;
name|int
name|resultCount
init|=
literal|1
decl_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
name|resultCount
argument_list|,
name|Integer
operator|.
name|parseInt
argument_list|(
name|rs
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|// 2. Convert NONACIDORCTBL to ACID table
name|runStatementOnDriver
argument_list|(
literal|"alter table "
operator|+
name|Table
operator|.
name|NONACIDORCTBL
operator|+
literal|" SET TBLPROPERTIES ('transactional'='true')"
argument_list|)
expr_stmt|;
name|status
operator|=
name|fs
operator|.
name|listStatus
argument_list|(
operator|new
name|Path
argument_list|(
name|TEST_WAREHOUSE_DIR
operator|+
literal|"/"
operator|+
operator|(
name|Table
operator|.
name|NONACIDORCTBL
operator|)
operator|.
name|toString
argument_list|()
operator|.
name|toLowerCase
argument_list|()
argument_list|)
argument_list|,
name|FileUtils
operator|.
name|STAGING_DIR_PATH_FILTER
argument_list|)
expr_stmt|;
comment|// Everything should be same as before
name|Assert
operator|.
name|assertEquals
argument_list|(
name|BUCKET_COUNT
argument_list|,
name|status
operator|.
name|length
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|status
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|Assert
operator|.
name|assertTrue
argument_list|(
name|status
index|[
name|i
index|]
operator|.
name|getPath
argument_list|()
operator|.
name|getName
argument_list|()
operator|.
name|matches
argument_list|(
literal|"00000[01]_0"
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|rs
operator|=
name|runStatementOnDriver
argument_list|(
literal|"select a,b from "
operator|+
name|Table
operator|.
name|NONACIDORCTBL
argument_list|)
expr_stmt|;
name|resultData
operator|=
operator|new
name|int
index|[]
index|[]
block|{
block|{
literal|1
block|,
literal|2
block|}
block|}
expr_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
name|stringifyValues
argument_list|(
name|resultData
argument_list|)
argument_list|,
name|rs
argument_list|)
expr_stmt|;
name|rs
operator|=
name|runStatementOnDriver
argument_list|(
literal|"select count(*) from "
operator|+
name|Table
operator|.
name|NONACIDORCTBL
argument_list|)
expr_stmt|;
name|resultCount
operator|=
literal|1
expr_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
name|resultCount
argument_list|,
name|Integer
operator|.
name|parseInt
argument_list|(
name|rs
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|// 3. Insert another row to newly-converted ACID table
name|runStatementOnDriver
argument_list|(
literal|"insert into "
operator|+
name|Table
operator|.
name|NONACIDORCTBL
operator|+
literal|"(a,b) values(3,4)"
argument_list|)
expr_stmt|;
name|status
operator|=
name|fs
operator|.
name|listStatus
argument_list|(
operator|new
name|Path
argument_list|(
name|TEST_WAREHOUSE_DIR
operator|+
literal|"/"
operator|+
operator|(
name|Table
operator|.
name|NONACIDORCTBL
operator|)
operator|.
name|toString
argument_list|()
operator|.
name|toLowerCase
argument_list|()
argument_list|)
argument_list|,
name|FileUtils
operator|.
name|STAGING_DIR_PATH_FILTER
argument_list|)
expr_stmt|;
comment|// There should be 2 original bucket files (000000_0 and 000001_0), plus a new delta directory.
comment|// The delta directory should also have 2 bucket files (bucket_00000 and bucket_00001)
name|Assert
operator|.
name|assertEquals
argument_list|(
literal|3
argument_list|,
name|status
operator|.
name|length
argument_list|)
expr_stmt|;
name|boolean
name|sawNewDelta
init|=
literal|false
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|status
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|status
index|[
name|i
index|]
operator|.
name|getPath
argument_list|()
operator|.
name|getName
argument_list|()
operator|.
name|matches
argument_list|(
literal|"delta_.*"
argument_list|)
condition|)
block|{
name|sawNewDelta
operator|=
literal|true
expr_stmt|;
name|FileStatus
index|[]
name|buckets
init|=
name|fs
operator|.
name|listStatus
argument_list|(
name|status
index|[
name|i
index|]
operator|.
name|getPath
argument_list|()
argument_list|,
name|FileUtils
operator|.
name|STAGING_DIR_PATH_FILTER
argument_list|)
decl_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
name|BUCKET_COUNT
argument_list|,
name|buckets
operator|.
name|length
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertTrue
argument_list|(
name|buckets
index|[
literal|0
index|]
operator|.
name|getPath
argument_list|()
operator|.
name|getName
argument_list|()
operator|.
name|matches
argument_list|(
literal|"bucket_0000[01]"
argument_list|)
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertTrue
argument_list|(
name|buckets
index|[
literal|1
index|]
operator|.
name|getPath
argument_list|()
operator|.
name|getName
argument_list|()
operator|.
name|matches
argument_list|(
literal|"bucket_0000[01]"
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|Assert
operator|.
name|assertTrue
argument_list|(
name|status
index|[
name|i
index|]
operator|.
name|getPath
argument_list|()
operator|.
name|getName
argument_list|()
operator|.
name|matches
argument_list|(
literal|"00000[01]_0"
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|Assert
operator|.
name|assertTrue
argument_list|(
name|sawNewDelta
argument_list|)
expr_stmt|;
name|rs
operator|=
name|runStatementOnDriver
argument_list|(
literal|"select a,b from "
operator|+
name|Table
operator|.
name|NONACIDORCTBL
argument_list|)
expr_stmt|;
name|resultData
operator|=
operator|new
name|int
index|[]
index|[]
block|{
block|{
literal|1
block|,
literal|2
block|}
block|,
block|{
literal|3
block|,
literal|4
block|}
block|}
expr_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
name|stringifyValues
argument_list|(
name|resultData
argument_list|)
argument_list|,
name|rs
argument_list|)
expr_stmt|;
name|rs
operator|=
name|runStatementOnDriver
argument_list|(
literal|"select count(*) from "
operator|+
name|Table
operator|.
name|NONACIDORCTBL
argument_list|)
expr_stmt|;
name|resultCount
operator|=
literal|2
expr_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
name|resultCount
argument_list|,
name|Integer
operator|.
name|parseInt
argument_list|(
name|rs
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|// 4. Perform a major compaction
name|runStatementOnDriver
argument_list|(
literal|"alter table "
operator|+
name|Table
operator|.
name|NONACIDORCTBL
operator|+
literal|" compact 'MAJOR'"
argument_list|)
expr_stmt|;
name|runWorker
argument_list|(
name|hiveConf
argument_list|)
expr_stmt|;
comment|// There should be 1 new directory: base_xxxxxxx.
comment|// Original bucket files and delta directory should stay until Cleaner kicks in.
name|status
operator|=
name|fs
operator|.
name|listStatus
argument_list|(
operator|new
name|Path
argument_list|(
name|TEST_WAREHOUSE_DIR
operator|+
literal|"/"
operator|+
operator|(
name|Table
operator|.
name|NONACIDORCTBL
operator|)
operator|.
name|toString
argument_list|()
operator|.
name|toLowerCase
argument_list|()
argument_list|)
argument_list|,
name|FileUtils
operator|.
name|STAGING_DIR_PATH_FILTER
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
literal|4
argument_list|,
name|status
operator|.
name|length
argument_list|)
expr_stmt|;
name|boolean
name|sawNewBase
init|=
literal|false
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|status
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|status
index|[
name|i
index|]
operator|.
name|getPath
argument_list|()
operator|.
name|getName
argument_list|()
operator|.
name|matches
argument_list|(
literal|"base_.*"
argument_list|)
condition|)
block|{
name|sawNewBase
operator|=
literal|true
expr_stmt|;
name|FileStatus
index|[]
name|buckets
init|=
name|fs
operator|.
name|listStatus
argument_list|(
name|status
index|[
name|i
index|]
operator|.
name|getPath
argument_list|()
argument_list|,
name|FileUtils
operator|.
name|STAGING_DIR_PATH_FILTER
argument_list|)
decl_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
name|BUCKET_COUNT
argument_list|,
name|buckets
operator|.
name|length
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertTrue
argument_list|(
name|buckets
index|[
literal|0
index|]
operator|.
name|getPath
argument_list|()
operator|.
name|getName
argument_list|()
operator|.
name|matches
argument_list|(
literal|"bucket_0000[01]"
argument_list|)
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertTrue
argument_list|(
name|buckets
index|[
literal|1
index|]
operator|.
name|getPath
argument_list|()
operator|.
name|getName
argument_list|()
operator|.
name|matches
argument_list|(
literal|"bucket_0000[01]"
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|Assert
operator|.
name|assertTrue
argument_list|(
name|sawNewBase
argument_list|)
expr_stmt|;
name|rs
operator|=
name|runStatementOnDriver
argument_list|(
literal|"select a,b from "
operator|+
name|Table
operator|.
name|NONACIDORCTBL
argument_list|)
expr_stmt|;
name|resultData
operator|=
operator|new
name|int
index|[]
index|[]
block|{
block|{
literal|1
block|,
literal|2
block|}
block|,
block|{
literal|3
block|,
literal|4
block|}
block|}
expr_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
name|stringifyValues
argument_list|(
name|resultData
argument_list|)
argument_list|,
name|rs
argument_list|)
expr_stmt|;
name|rs
operator|=
name|runStatementOnDriver
argument_list|(
literal|"select count(*) from "
operator|+
name|Table
operator|.
name|NONACIDORCTBL
argument_list|)
expr_stmt|;
name|resultCount
operator|=
literal|2
expr_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
name|resultCount
argument_list|,
name|Integer
operator|.
name|parseInt
argument_list|(
name|rs
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|// 5. Let Cleaner delete obsolete files/dirs
comment|// Note, here we create a fake directory along with fake files as original directories/files
name|String
name|fakeFile0
init|=
name|TEST_WAREHOUSE_DIR
operator|+
literal|"/"
operator|+
operator|(
name|Table
operator|.
name|NONACIDORCTBL
operator|)
operator|.
name|toString
argument_list|()
operator|.
name|toLowerCase
argument_list|()
operator|+
literal|"/subdir/000000_0"
decl_stmt|;
name|String
name|fakeFile1
init|=
name|TEST_WAREHOUSE_DIR
operator|+
literal|"/"
operator|+
operator|(
name|Table
operator|.
name|NONACIDORCTBL
operator|)
operator|.
name|toString
argument_list|()
operator|.
name|toLowerCase
argument_list|()
operator|+
literal|"/subdir/000000_1"
decl_stmt|;
name|fs
operator|.
name|create
argument_list|(
operator|new
name|Path
argument_list|(
name|fakeFile0
argument_list|)
argument_list|)
expr_stmt|;
name|fs
operator|.
name|create
argument_list|(
operator|new
name|Path
argument_list|(
name|fakeFile1
argument_list|)
argument_list|)
expr_stmt|;
name|status
operator|=
name|fs
operator|.
name|listStatus
argument_list|(
operator|new
name|Path
argument_list|(
name|TEST_WAREHOUSE_DIR
operator|+
literal|"/"
operator|+
operator|(
name|Table
operator|.
name|NONACIDORCTBL
operator|)
operator|.
name|toString
argument_list|()
operator|.
name|toLowerCase
argument_list|()
argument_list|)
argument_list|,
name|FileUtils
operator|.
name|STAGING_DIR_PATH_FILTER
argument_list|)
expr_stmt|;
comment|// Before Cleaner, there should be 5 items:
comment|// 2 original files, 1 original directory, 1 base directory and 1 delta directory
name|Assert
operator|.
name|assertEquals
argument_list|(
literal|5
argument_list|,
name|status
operator|.
name|length
argument_list|)
expr_stmt|;
name|runCleaner
argument_list|(
name|hiveConf
argument_list|)
expr_stmt|;
comment|// There should be only 1 directory left: base_xxxxxxx.
comment|// Original bucket files and delta directory should have been cleaned up.
name|status
operator|=
name|fs
operator|.
name|listStatus
argument_list|(
operator|new
name|Path
argument_list|(
name|TEST_WAREHOUSE_DIR
operator|+
literal|"/"
operator|+
operator|(
name|Table
operator|.
name|NONACIDORCTBL
operator|)
operator|.
name|toString
argument_list|()
operator|.
name|toLowerCase
argument_list|()
argument_list|)
argument_list|,
name|FileUtils
operator|.
name|STAGING_DIR_PATH_FILTER
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
literal|1
argument_list|,
name|status
operator|.
name|length
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertTrue
argument_list|(
name|status
index|[
literal|0
index|]
operator|.
name|getPath
argument_list|()
operator|.
name|getName
argument_list|()
operator|.
name|matches
argument_list|(
literal|"base_.*"
argument_list|)
argument_list|)
expr_stmt|;
name|FileStatus
index|[]
name|buckets
init|=
name|fs
operator|.
name|listStatus
argument_list|(
name|status
index|[
literal|0
index|]
operator|.
name|getPath
argument_list|()
argument_list|,
name|FileUtils
operator|.
name|STAGING_DIR_PATH_FILTER
argument_list|)
decl_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
name|BUCKET_COUNT
argument_list|,
name|buckets
operator|.
name|length
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertTrue
argument_list|(
name|buckets
index|[
literal|0
index|]
operator|.
name|getPath
argument_list|()
operator|.
name|getName
argument_list|()
operator|.
name|matches
argument_list|(
literal|"bucket_0000[01]"
argument_list|)
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertTrue
argument_list|(
name|buckets
index|[
literal|1
index|]
operator|.
name|getPath
argument_list|()
operator|.
name|getName
argument_list|()
operator|.
name|matches
argument_list|(
literal|"bucket_0000[01]"
argument_list|)
argument_list|)
expr_stmt|;
name|rs
operator|=
name|runStatementOnDriver
argument_list|(
literal|"select a,b from "
operator|+
name|Table
operator|.
name|NONACIDORCTBL
argument_list|)
expr_stmt|;
name|resultData
operator|=
operator|new
name|int
index|[]
index|[]
block|{
block|{
literal|1
block|,
literal|2
block|}
block|,
block|{
literal|3
block|,
literal|4
block|}
block|}
expr_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
name|stringifyValues
argument_list|(
name|resultData
argument_list|)
argument_list|,
name|rs
argument_list|)
expr_stmt|;
name|rs
operator|=
name|runStatementOnDriver
argument_list|(
literal|"select count(*) from "
operator|+
name|Table
operator|.
name|NONACIDORCTBL
argument_list|)
expr_stmt|;
name|resultCount
operator|=
literal|2
expr_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
name|resultCount
argument_list|,
name|Integer
operator|.
name|parseInt
argument_list|(
name|rs
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**    * Test the query correctness and directory layout after ACID table conversion and MAJOR compaction    * 1. Insert a row to Non-ACID table    * 2. Convert Non-ACID to ACID table    * 3. Update the existing row in ACID table    * 4. Perform Major compaction    * 5. Clean    * @throws Exception    */
annotation|@
name|Test
specifier|public
name|void
name|testNonAcidToAcidConversion2
parameter_list|()
throws|throws
name|Exception
block|{
name|FileSystem
name|fs
init|=
name|FileSystem
operator|.
name|get
argument_list|(
name|hiveConf
argument_list|)
decl_stmt|;
name|FileStatus
index|[]
name|status
decl_stmt|;
comment|// 1. Insert a row to Non-ACID table
name|runStatementOnDriver
argument_list|(
literal|"insert into "
operator|+
name|Table
operator|.
name|NONACIDORCTBL
operator|+
literal|"(a,b) values(1,2)"
argument_list|)
expr_stmt|;
name|status
operator|=
name|fs
operator|.
name|listStatus
argument_list|(
operator|new
name|Path
argument_list|(
name|TEST_WAREHOUSE_DIR
operator|+
literal|"/"
operator|+
operator|(
name|Table
operator|.
name|NONACIDORCTBL
operator|)
operator|.
name|toString
argument_list|()
operator|.
name|toLowerCase
argument_list|()
argument_list|)
argument_list|,
name|FileUtils
operator|.
name|STAGING_DIR_PATH_FILTER
argument_list|)
expr_stmt|;
comment|// There should be 2 original bucket files in the location (000000_0 and 000001_0)
name|Assert
operator|.
name|assertEquals
argument_list|(
name|BUCKET_COUNT
argument_list|,
name|status
operator|.
name|length
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|status
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|Assert
operator|.
name|assertTrue
argument_list|(
name|status
index|[
name|i
index|]
operator|.
name|getPath
argument_list|()
operator|.
name|getName
argument_list|()
operator|.
name|matches
argument_list|(
literal|"00000[01]_0"
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|List
argument_list|<
name|String
argument_list|>
name|rs
init|=
name|runStatementOnDriver
argument_list|(
literal|"select a,b from "
operator|+
name|Table
operator|.
name|NONACIDORCTBL
argument_list|)
decl_stmt|;
name|int
index|[]
index|[]
name|resultData
init|=
operator|new
name|int
index|[]
index|[]
block|{
block|{
literal|1
block|,
literal|2
block|}
block|}
decl_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
name|stringifyValues
argument_list|(
name|resultData
argument_list|)
argument_list|,
name|rs
argument_list|)
expr_stmt|;
name|rs
operator|=
name|runStatementOnDriver
argument_list|(
literal|"select count(*) from "
operator|+
name|Table
operator|.
name|NONACIDORCTBL
argument_list|)
expr_stmt|;
name|int
name|resultCount
init|=
literal|1
decl_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
name|resultCount
argument_list|,
name|Integer
operator|.
name|parseInt
argument_list|(
name|rs
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|// 2. Convert NONACIDORCTBL to ACID table
name|runStatementOnDriver
argument_list|(
literal|"alter table "
operator|+
name|Table
operator|.
name|NONACIDORCTBL
operator|+
literal|" SET TBLPROPERTIES ('transactional'='true')"
argument_list|)
expr_stmt|;
name|status
operator|=
name|fs
operator|.
name|listStatus
argument_list|(
operator|new
name|Path
argument_list|(
name|TEST_WAREHOUSE_DIR
operator|+
literal|"/"
operator|+
operator|(
name|Table
operator|.
name|NONACIDORCTBL
operator|)
operator|.
name|toString
argument_list|()
operator|.
name|toLowerCase
argument_list|()
argument_list|)
argument_list|,
name|FileUtils
operator|.
name|STAGING_DIR_PATH_FILTER
argument_list|)
expr_stmt|;
comment|// Everything should be same as before
name|Assert
operator|.
name|assertEquals
argument_list|(
name|BUCKET_COUNT
argument_list|,
name|status
operator|.
name|length
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|status
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|Assert
operator|.
name|assertTrue
argument_list|(
name|status
index|[
name|i
index|]
operator|.
name|getPath
argument_list|()
operator|.
name|getName
argument_list|()
operator|.
name|matches
argument_list|(
literal|"00000[01]_0"
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|rs
operator|=
name|runStatementOnDriver
argument_list|(
literal|"select a,b from "
operator|+
name|Table
operator|.
name|NONACIDORCTBL
argument_list|)
expr_stmt|;
name|resultData
operator|=
operator|new
name|int
index|[]
index|[]
block|{
block|{
literal|1
block|,
literal|2
block|}
block|}
expr_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
name|stringifyValues
argument_list|(
name|resultData
argument_list|)
argument_list|,
name|rs
argument_list|)
expr_stmt|;
name|rs
operator|=
name|runStatementOnDriver
argument_list|(
literal|"select count(*) from "
operator|+
name|Table
operator|.
name|NONACIDORCTBL
argument_list|)
expr_stmt|;
name|resultCount
operator|=
literal|1
expr_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
name|resultCount
argument_list|,
name|Integer
operator|.
name|parseInt
argument_list|(
name|rs
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|// 3. Update the existing row in newly-converted ACID table
name|runStatementOnDriver
argument_list|(
literal|"update "
operator|+
name|Table
operator|.
name|NONACIDORCTBL
operator|+
literal|" set b=3 where a=1"
argument_list|)
expr_stmt|;
name|status
operator|=
name|fs
operator|.
name|listStatus
argument_list|(
operator|new
name|Path
argument_list|(
name|TEST_WAREHOUSE_DIR
operator|+
literal|"/"
operator|+
operator|(
name|Table
operator|.
name|NONACIDORCTBL
operator|)
operator|.
name|toString
argument_list|()
operator|.
name|toLowerCase
argument_list|()
argument_list|)
argument_list|,
name|FileUtils
operator|.
name|STAGING_DIR_PATH_FILTER
argument_list|)
expr_stmt|;
comment|// There should be 2 original bucket files (000000_0 and 000001_0), plus a new delta directory.
comment|// The delta directory should also have 2 bucket files (bucket_00000 and bucket_00001)
name|Assert
operator|.
name|assertEquals
argument_list|(
literal|3
argument_list|,
name|status
operator|.
name|length
argument_list|)
expr_stmt|;
name|boolean
name|sawNewDelta
init|=
literal|false
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|status
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|status
index|[
name|i
index|]
operator|.
name|getPath
argument_list|()
operator|.
name|getName
argument_list|()
operator|.
name|matches
argument_list|(
literal|"delta_.*"
argument_list|)
condition|)
block|{
name|sawNewDelta
operator|=
literal|true
expr_stmt|;
name|FileStatus
index|[]
name|buckets
init|=
name|fs
operator|.
name|listStatus
argument_list|(
name|status
index|[
name|i
index|]
operator|.
name|getPath
argument_list|()
argument_list|,
name|FileUtils
operator|.
name|STAGING_DIR_PATH_FILTER
argument_list|)
decl_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
name|BUCKET_COUNT
operator|-
literal|1
argument_list|,
name|buckets
operator|.
name|length
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertTrue
argument_list|(
name|buckets
index|[
literal|0
index|]
operator|.
name|getPath
argument_list|()
operator|.
name|getName
argument_list|()
operator|.
name|matches
argument_list|(
literal|"bucket_0000[01]"
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|Assert
operator|.
name|assertTrue
argument_list|(
name|status
index|[
name|i
index|]
operator|.
name|getPath
argument_list|()
operator|.
name|getName
argument_list|()
operator|.
name|matches
argument_list|(
literal|"00000[01]_0"
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|Assert
operator|.
name|assertTrue
argument_list|(
name|sawNewDelta
argument_list|)
expr_stmt|;
name|rs
operator|=
name|runStatementOnDriver
argument_list|(
literal|"select a,b from "
operator|+
name|Table
operator|.
name|NONACIDORCTBL
argument_list|)
expr_stmt|;
name|resultData
operator|=
operator|new
name|int
index|[]
index|[]
block|{
block|{
literal|1
block|,
literal|3
block|}
block|}
expr_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
name|stringifyValues
argument_list|(
name|resultData
argument_list|)
argument_list|,
name|rs
argument_list|)
expr_stmt|;
name|rs
operator|=
name|runStatementOnDriver
argument_list|(
literal|"select count(*) from "
operator|+
name|Table
operator|.
name|NONACIDORCTBL
argument_list|)
expr_stmt|;
name|resultCount
operator|=
literal|1
expr_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
name|resultCount
argument_list|,
name|Integer
operator|.
name|parseInt
argument_list|(
name|rs
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|// 4. Perform a major compaction
name|runStatementOnDriver
argument_list|(
literal|"alter table "
operator|+
name|Table
operator|.
name|NONACIDORCTBL
operator|+
literal|" compact 'MAJOR'"
argument_list|)
expr_stmt|;
name|runWorker
argument_list|(
name|hiveConf
argument_list|)
expr_stmt|;
comment|// There should be 1 new directory: base_0000001.
comment|// Original bucket files and delta directory should stay until Cleaner kicks in.
name|status
operator|=
name|fs
operator|.
name|listStatus
argument_list|(
operator|new
name|Path
argument_list|(
name|TEST_WAREHOUSE_DIR
operator|+
literal|"/"
operator|+
operator|(
name|Table
operator|.
name|NONACIDORCTBL
operator|)
operator|.
name|toString
argument_list|()
operator|.
name|toLowerCase
argument_list|()
argument_list|)
argument_list|,
name|FileUtils
operator|.
name|STAGING_DIR_PATH_FILTER
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
literal|4
argument_list|,
name|status
operator|.
name|length
argument_list|)
expr_stmt|;
name|boolean
name|sawNewBase
init|=
literal|false
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|status
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|status
index|[
name|i
index|]
operator|.
name|getPath
argument_list|()
operator|.
name|getName
argument_list|()
operator|.
name|matches
argument_list|(
literal|"base_.*"
argument_list|)
condition|)
block|{
name|sawNewBase
operator|=
literal|true
expr_stmt|;
name|FileStatus
index|[]
name|buckets
init|=
name|fs
operator|.
name|listStatus
argument_list|(
name|status
index|[
name|i
index|]
operator|.
name|getPath
argument_list|()
argument_list|,
name|FileUtils
operator|.
name|STAGING_DIR_PATH_FILTER
argument_list|)
decl_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
name|BUCKET_COUNT
operator|-
literal|1
argument_list|,
name|buckets
operator|.
name|length
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertTrue
argument_list|(
name|buckets
index|[
literal|0
index|]
operator|.
name|getPath
argument_list|()
operator|.
name|getName
argument_list|()
operator|.
name|matches
argument_list|(
literal|"bucket_00001"
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|Assert
operator|.
name|assertTrue
argument_list|(
name|sawNewBase
argument_list|)
expr_stmt|;
name|rs
operator|=
name|runStatementOnDriver
argument_list|(
literal|"select a,b from "
operator|+
name|Table
operator|.
name|NONACIDORCTBL
argument_list|)
expr_stmt|;
name|resultData
operator|=
operator|new
name|int
index|[]
index|[]
block|{
block|{
literal|1
block|,
literal|3
block|}
block|}
expr_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
name|stringifyValues
argument_list|(
name|resultData
argument_list|)
argument_list|,
name|rs
argument_list|)
expr_stmt|;
name|rs
operator|=
name|runStatementOnDriver
argument_list|(
literal|"select count(*) from "
operator|+
name|Table
operator|.
name|NONACIDORCTBL
argument_list|)
expr_stmt|;
name|resultCount
operator|=
literal|1
expr_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
name|resultCount
argument_list|,
name|Integer
operator|.
name|parseInt
argument_list|(
name|rs
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|// 5. Let Cleaner delete obsolete files/dirs
name|status
operator|=
name|fs
operator|.
name|listStatus
argument_list|(
operator|new
name|Path
argument_list|(
name|TEST_WAREHOUSE_DIR
operator|+
literal|"/"
operator|+
operator|(
name|Table
operator|.
name|NONACIDORCTBL
operator|)
operator|.
name|toString
argument_list|()
operator|.
name|toLowerCase
argument_list|()
argument_list|)
argument_list|,
name|FileUtils
operator|.
name|STAGING_DIR_PATH_FILTER
argument_list|)
expr_stmt|;
comment|// Before Cleaner, there should be 4 items:
comment|// 2 original files, 1 delta directory and 1 base directory
name|Assert
operator|.
name|assertEquals
argument_list|(
literal|4
argument_list|,
name|status
operator|.
name|length
argument_list|)
expr_stmt|;
name|runCleaner
argument_list|(
name|hiveConf
argument_list|)
expr_stmt|;
comment|// There should be only 1 directory left: base_0000001.
comment|// Original bucket files and delta directory should have been cleaned up.
name|status
operator|=
name|fs
operator|.
name|listStatus
argument_list|(
operator|new
name|Path
argument_list|(
name|TEST_WAREHOUSE_DIR
operator|+
literal|"/"
operator|+
operator|(
name|Table
operator|.
name|NONACIDORCTBL
operator|)
operator|.
name|toString
argument_list|()
operator|.
name|toLowerCase
argument_list|()
argument_list|)
argument_list|,
name|FileUtils
operator|.
name|STAGING_DIR_PATH_FILTER
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
literal|1
argument_list|,
name|status
operator|.
name|length
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertTrue
argument_list|(
name|status
index|[
literal|0
index|]
operator|.
name|getPath
argument_list|()
operator|.
name|getName
argument_list|()
operator|.
name|matches
argument_list|(
literal|"base_.*"
argument_list|)
argument_list|)
expr_stmt|;
name|FileStatus
index|[]
name|buckets
init|=
name|fs
operator|.
name|listStatus
argument_list|(
name|status
index|[
literal|0
index|]
operator|.
name|getPath
argument_list|()
argument_list|,
name|FileUtils
operator|.
name|STAGING_DIR_PATH_FILTER
argument_list|)
decl_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
name|BUCKET_COUNT
operator|-
literal|1
argument_list|,
name|buckets
operator|.
name|length
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertTrue
argument_list|(
name|buckets
index|[
literal|0
index|]
operator|.
name|getPath
argument_list|()
operator|.
name|getName
argument_list|()
operator|.
name|matches
argument_list|(
literal|"bucket_00001"
argument_list|)
argument_list|)
expr_stmt|;
name|rs
operator|=
name|runStatementOnDriver
argument_list|(
literal|"select a,b from "
operator|+
name|Table
operator|.
name|NONACIDORCTBL
argument_list|)
expr_stmt|;
name|resultData
operator|=
operator|new
name|int
index|[]
index|[]
block|{
block|{
literal|1
block|,
literal|3
block|}
block|}
expr_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
name|stringifyValues
argument_list|(
name|resultData
argument_list|)
argument_list|,
name|rs
argument_list|)
expr_stmt|;
name|rs
operator|=
name|runStatementOnDriver
argument_list|(
literal|"select count(*) from "
operator|+
name|Table
operator|.
name|NONACIDORCTBL
argument_list|)
expr_stmt|;
name|resultCount
operator|=
literal|1
expr_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
name|resultCount
argument_list|,
name|Integer
operator|.
name|parseInt
argument_list|(
name|rs
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**    * Test the query correctness and directory layout after ACID table conversion and MAJOR compaction    * 1. Insert a row to Non-ACID table    * 2. Convert Non-ACID to ACID table    * 3. Perform Major compaction    * 4. Insert a new row to ACID table    * 5. Perform another Major compaction    * 6. Clean    * @throws Exception    */
annotation|@
name|Test
specifier|public
name|void
name|testNonAcidToAcidConversion3
parameter_list|()
throws|throws
name|Exception
block|{
name|FileSystem
name|fs
init|=
name|FileSystem
operator|.
name|get
argument_list|(
name|hiveConf
argument_list|)
decl_stmt|;
name|FileStatus
index|[]
name|status
decl_stmt|;
comment|// 1. Insert a row to Non-ACID table
name|runStatementOnDriver
argument_list|(
literal|"insert into "
operator|+
name|Table
operator|.
name|NONACIDORCTBL
operator|+
literal|"(a,b) values(1,2)"
argument_list|)
expr_stmt|;
name|status
operator|=
name|fs
operator|.
name|listStatus
argument_list|(
operator|new
name|Path
argument_list|(
name|TEST_WAREHOUSE_DIR
operator|+
literal|"/"
operator|+
operator|(
name|Table
operator|.
name|NONACIDORCTBL
operator|)
operator|.
name|toString
argument_list|()
operator|.
name|toLowerCase
argument_list|()
argument_list|)
argument_list|,
name|FileUtils
operator|.
name|STAGING_DIR_PATH_FILTER
argument_list|)
expr_stmt|;
comment|// There should be 2 original bucket files in the location (000000_0 and 000001_0)
name|Assert
operator|.
name|assertEquals
argument_list|(
name|BUCKET_COUNT
argument_list|,
name|status
operator|.
name|length
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|status
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|Assert
operator|.
name|assertTrue
argument_list|(
name|status
index|[
name|i
index|]
operator|.
name|getPath
argument_list|()
operator|.
name|getName
argument_list|()
operator|.
name|matches
argument_list|(
literal|"00000[01]_0"
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|List
argument_list|<
name|String
argument_list|>
name|rs
init|=
name|runStatementOnDriver
argument_list|(
literal|"select a,b from "
operator|+
name|Table
operator|.
name|NONACIDORCTBL
argument_list|)
decl_stmt|;
name|int
index|[]
index|[]
name|resultData
init|=
operator|new
name|int
index|[]
index|[]
block|{
block|{
literal|1
block|,
literal|2
block|}
block|}
decl_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
name|stringifyValues
argument_list|(
name|resultData
argument_list|)
argument_list|,
name|rs
argument_list|)
expr_stmt|;
name|rs
operator|=
name|runStatementOnDriver
argument_list|(
literal|"select count(*) from "
operator|+
name|Table
operator|.
name|NONACIDORCTBL
argument_list|)
expr_stmt|;
name|int
name|resultCount
init|=
literal|1
decl_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
name|resultCount
argument_list|,
name|Integer
operator|.
name|parseInt
argument_list|(
name|rs
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|// 2. Convert NONACIDORCTBL to ACID table
name|runStatementOnDriver
argument_list|(
literal|"alter table "
operator|+
name|Table
operator|.
name|NONACIDORCTBL
operator|+
literal|" SET TBLPROPERTIES ('transactional'='true')"
argument_list|)
expr_stmt|;
name|status
operator|=
name|fs
operator|.
name|listStatus
argument_list|(
operator|new
name|Path
argument_list|(
name|TEST_WAREHOUSE_DIR
operator|+
literal|"/"
operator|+
operator|(
name|Table
operator|.
name|NONACIDORCTBL
operator|)
operator|.
name|toString
argument_list|()
operator|.
name|toLowerCase
argument_list|()
argument_list|)
argument_list|,
name|FileUtils
operator|.
name|STAGING_DIR_PATH_FILTER
argument_list|)
expr_stmt|;
comment|// Everything should be same as before
name|Assert
operator|.
name|assertEquals
argument_list|(
name|BUCKET_COUNT
argument_list|,
name|status
operator|.
name|length
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|status
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|Assert
operator|.
name|assertTrue
argument_list|(
name|status
index|[
name|i
index|]
operator|.
name|getPath
argument_list|()
operator|.
name|getName
argument_list|()
operator|.
name|matches
argument_list|(
literal|"00000[01]_0"
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|rs
operator|=
name|runStatementOnDriver
argument_list|(
literal|"select a,b from "
operator|+
name|Table
operator|.
name|NONACIDORCTBL
argument_list|)
expr_stmt|;
name|resultData
operator|=
operator|new
name|int
index|[]
index|[]
block|{
block|{
literal|1
block|,
literal|2
block|}
block|}
expr_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
name|stringifyValues
argument_list|(
name|resultData
argument_list|)
argument_list|,
name|rs
argument_list|)
expr_stmt|;
name|rs
operator|=
name|runStatementOnDriver
argument_list|(
literal|"select count(*) from "
operator|+
name|Table
operator|.
name|NONACIDORCTBL
argument_list|)
expr_stmt|;
name|resultCount
operator|=
literal|1
expr_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
name|resultCount
argument_list|,
name|Integer
operator|.
name|parseInt
argument_list|(
name|rs
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|// 3. Perform a major compaction
name|runStatementOnDriver
argument_list|(
literal|"alter table "
operator|+
name|Table
operator|.
name|NONACIDORCTBL
operator|+
literal|" compact 'MAJOR'"
argument_list|)
expr_stmt|;
name|runWorker
argument_list|(
name|hiveConf
argument_list|)
expr_stmt|;
comment|// There should be 1 new directory: base_-9223372036854775808
comment|// Original bucket files should stay until Cleaner kicks in.
name|status
operator|=
name|fs
operator|.
name|listStatus
argument_list|(
operator|new
name|Path
argument_list|(
name|TEST_WAREHOUSE_DIR
operator|+
literal|"/"
operator|+
operator|(
name|Table
operator|.
name|NONACIDORCTBL
operator|)
operator|.
name|toString
argument_list|()
operator|.
name|toLowerCase
argument_list|()
argument_list|)
argument_list|,
name|FileUtils
operator|.
name|STAGING_DIR_PATH_FILTER
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
literal|3
argument_list|,
name|status
operator|.
name|length
argument_list|)
expr_stmt|;
name|boolean
name|sawNewBase
init|=
literal|false
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|status
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|status
index|[
name|i
index|]
operator|.
name|getPath
argument_list|()
operator|.
name|getName
argument_list|()
operator|.
name|matches
argument_list|(
literal|"base_.*"
argument_list|)
condition|)
block|{
name|Assert
operator|.
name|assertEquals
argument_list|(
literal|"base_-9223372036854775808"
argument_list|,
name|status
index|[
name|i
index|]
operator|.
name|getPath
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
name|sawNewBase
operator|=
literal|true
expr_stmt|;
name|FileStatus
index|[]
name|buckets
init|=
name|fs
operator|.
name|listStatus
argument_list|(
name|status
index|[
name|i
index|]
operator|.
name|getPath
argument_list|()
argument_list|,
name|FileUtils
operator|.
name|STAGING_DIR_PATH_FILTER
argument_list|)
decl_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
name|BUCKET_COUNT
operator|-
literal|1
argument_list|,
name|buckets
operator|.
name|length
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
literal|"bucket_00001"
argument_list|,
name|buckets
index|[
literal|0
index|]
operator|.
name|getPath
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
name|Assert
operator|.
name|assertTrue
argument_list|(
name|sawNewBase
argument_list|)
expr_stmt|;
name|rs
operator|=
name|runStatementOnDriver
argument_list|(
literal|"select a,b from "
operator|+
name|Table
operator|.
name|NONACIDORCTBL
argument_list|)
expr_stmt|;
name|resultData
operator|=
operator|new
name|int
index|[]
index|[]
block|{
block|{
literal|1
block|,
literal|2
block|}
block|}
expr_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
name|stringifyValues
argument_list|(
name|resultData
argument_list|)
argument_list|,
name|rs
argument_list|)
expr_stmt|;
name|rs
operator|=
name|runStatementOnDriver
argument_list|(
literal|"select count(*) from "
operator|+
name|Table
operator|.
name|NONACIDORCTBL
argument_list|)
expr_stmt|;
name|resultCount
operator|=
literal|1
expr_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
name|resultCount
argument_list|,
name|Integer
operator|.
name|parseInt
argument_list|(
name|rs
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|// 4. Update the existing row, and insert another row to newly-converted ACID table
name|runStatementOnDriver
argument_list|(
literal|"update "
operator|+
name|Table
operator|.
name|NONACIDORCTBL
operator|+
literal|" set b=3 where a=1"
argument_list|)
expr_stmt|;
name|runStatementOnDriver
argument_list|(
literal|"insert into "
operator|+
name|Table
operator|.
name|NONACIDORCTBL
operator|+
literal|"(a,b) values(3,4)"
argument_list|)
expr_stmt|;
name|status
operator|=
name|fs
operator|.
name|listStatus
argument_list|(
operator|new
name|Path
argument_list|(
name|TEST_WAREHOUSE_DIR
operator|+
literal|"/"
operator|+
operator|(
name|Table
operator|.
name|NONACIDORCTBL
operator|)
operator|.
name|toString
argument_list|()
operator|.
name|toLowerCase
argument_list|()
argument_list|)
argument_list|,
name|FileUtils
operator|.
name|STAGING_DIR_PATH_FILTER
argument_list|)
expr_stmt|;
name|Arrays
operator|.
name|sort
argument_list|(
name|status
argument_list|)
expr_stmt|;
comment|// make sure delta_0000001_0000001_0000 appears before delta_0000002_0000002_0000
comment|// There should be 2 original bucket files (000000_0 and 000001_0), a base directory,
comment|// plus two new delta directories
name|Assert
operator|.
name|assertEquals
argument_list|(
literal|5
argument_list|,
name|status
operator|.
name|length
argument_list|)
expr_stmt|;
name|int
name|numDelta
init|=
literal|0
decl_stmt|;
name|sawNewBase
operator|=
literal|false
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|status
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|status
index|[
name|i
index|]
operator|.
name|getPath
argument_list|()
operator|.
name|getName
argument_list|()
operator|.
name|matches
argument_list|(
literal|"delta_.*"
argument_list|)
condition|)
block|{
name|numDelta
operator|++
expr_stmt|;
name|FileStatus
index|[]
name|buckets
init|=
name|fs
operator|.
name|listStatus
argument_list|(
name|status
index|[
name|i
index|]
operator|.
name|getPath
argument_list|()
argument_list|,
name|FileUtils
operator|.
name|STAGING_DIR_PATH_FILTER
argument_list|)
decl_stmt|;
name|Arrays
operator|.
name|sort
argument_list|(
name|buckets
argument_list|)
expr_stmt|;
if|if
condition|(
name|numDelta
operator|==
literal|1
condition|)
block|{
name|Assert
operator|.
name|assertEquals
argument_list|(
literal|"delta_0000001_0000001_0000"
argument_list|,
name|status
index|[
name|i
index|]
operator|.
name|getPath
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
name|BUCKET_COUNT
operator|-
literal|1
argument_list|,
name|buckets
operator|.
name|length
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
literal|"bucket_00001"
argument_list|,
name|buckets
index|[
literal|0
index|]
operator|.
name|getPath
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|numDelta
operator|==
literal|2
condition|)
block|{
name|Assert
operator|.
name|assertEquals
argument_list|(
literal|"delta_0000002_0000002_0000"
argument_list|,
name|status
index|[
name|i
index|]
operator|.
name|getPath
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
name|BUCKET_COUNT
argument_list|,
name|buckets
operator|.
name|length
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
literal|"bucket_00000"
argument_list|,
name|buckets
index|[
literal|0
index|]
operator|.
name|getPath
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
literal|"bucket_00001"
argument_list|,
name|buckets
index|[
literal|1
index|]
operator|.
name|getPath
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|status
index|[
name|i
index|]
operator|.
name|getPath
argument_list|()
operator|.
name|getName
argument_list|()
operator|.
name|matches
argument_list|(
literal|"base_.*"
argument_list|)
condition|)
block|{
name|Assert
operator|.
name|assertEquals
argument_list|(
literal|"base_-9223372036854775808"
argument_list|,
name|status
index|[
name|i
index|]
operator|.
name|getPath
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
name|sawNewBase
operator|=
literal|true
expr_stmt|;
name|FileStatus
index|[]
name|buckets
init|=
name|fs
operator|.
name|listStatus
argument_list|(
name|status
index|[
name|i
index|]
operator|.
name|getPath
argument_list|()
argument_list|,
name|FileUtils
operator|.
name|STAGING_DIR_PATH_FILTER
argument_list|)
decl_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
name|BUCKET_COUNT
operator|-
literal|1
argument_list|,
name|buckets
operator|.
name|length
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
literal|"bucket_00001"
argument_list|,
name|buckets
index|[
literal|0
index|]
operator|.
name|getPath
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|Assert
operator|.
name|assertTrue
argument_list|(
name|status
index|[
name|i
index|]
operator|.
name|getPath
argument_list|()
operator|.
name|getName
argument_list|()
operator|.
name|matches
argument_list|(
literal|"00000[01]_0"
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|Assert
operator|.
name|assertEquals
argument_list|(
literal|2
argument_list|,
name|numDelta
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertTrue
argument_list|(
name|sawNewBase
argument_list|)
expr_stmt|;
name|rs
operator|=
name|runStatementOnDriver
argument_list|(
literal|"select a,b from "
operator|+
name|Table
operator|.
name|NONACIDORCTBL
argument_list|)
expr_stmt|;
name|resultData
operator|=
operator|new
name|int
index|[]
index|[]
block|{
block|{
literal|1
block|,
literal|3
block|}
block|,
block|{
literal|3
block|,
literal|4
block|}
block|}
expr_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
name|stringifyValues
argument_list|(
name|resultData
argument_list|)
argument_list|,
name|rs
argument_list|)
expr_stmt|;
name|rs
operator|=
name|runStatementOnDriver
argument_list|(
literal|"select count(*) from "
operator|+
name|Table
operator|.
name|NONACIDORCTBL
argument_list|)
expr_stmt|;
name|resultCount
operator|=
literal|2
expr_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
name|resultCount
argument_list|,
name|Integer
operator|.
name|parseInt
argument_list|(
name|rs
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|// 5. Perform another major compaction
name|runStatementOnDriver
argument_list|(
literal|"alter table "
operator|+
name|Table
operator|.
name|NONACIDORCTBL
operator|+
literal|" compact 'MAJOR'"
argument_list|)
expr_stmt|;
name|runWorker
argument_list|(
name|hiveConf
argument_list|)
expr_stmt|;
comment|// There should be 1 new base directory: base_0000001
comment|// Original bucket files, delta directories and the previous base directory should stay until Cleaner kicks in.
name|status
operator|=
name|fs
operator|.
name|listStatus
argument_list|(
operator|new
name|Path
argument_list|(
name|TEST_WAREHOUSE_DIR
operator|+
literal|"/"
operator|+
operator|(
name|Table
operator|.
name|NONACIDORCTBL
operator|)
operator|.
name|toString
argument_list|()
operator|.
name|toLowerCase
argument_list|()
argument_list|)
argument_list|,
name|FileUtils
operator|.
name|STAGING_DIR_PATH_FILTER
argument_list|)
expr_stmt|;
name|Arrays
operator|.
name|sort
argument_list|(
name|status
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
literal|6
argument_list|,
name|status
operator|.
name|length
argument_list|)
expr_stmt|;
name|int
name|numBase
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|status
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|status
index|[
name|i
index|]
operator|.
name|getPath
argument_list|()
operator|.
name|getName
argument_list|()
operator|.
name|matches
argument_list|(
literal|"base_.*"
argument_list|)
condition|)
block|{
name|numBase
operator|++
expr_stmt|;
name|FileStatus
index|[]
name|buckets
init|=
name|fs
operator|.
name|listStatus
argument_list|(
name|status
index|[
name|i
index|]
operator|.
name|getPath
argument_list|()
argument_list|,
name|FileUtils
operator|.
name|STAGING_DIR_PATH_FILTER
argument_list|)
decl_stmt|;
name|Arrays
operator|.
name|sort
argument_list|(
name|buckets
argument_list|)
expr_stmt|;
if|if
condition|(
name|numBase
operator|==
literal|1
condition|)
block|{
name|Assert
operator|.
name|assertEquals
argument_list|(
literal|"base_-9223372036854775808"
argument_list|,
name|status
index|[
name|i
index|]
operator|.
name|getPath
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
name|BUCKET_COUNT
operator|-
literal|1
argument_list|,
name|buckets
operator|.
name|length
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
literal|"bucket_00001"
argument_list|,
name|buckets
index|[
literal|0
index|]
operator|.
name|getPath
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|numBase
operator|==
literal|2
condition|)
block|{
comment|// The new base dir now has two bucket files, since the delta dir has two bucket files
name|Assert
operator|.
name|assertEquals
argument_list|(
literal|"base_0000002"
argument_list|,
name|status
index|[
name|i
index|]
operator|.
name|getPath
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
name|BUCKET_COUNT
argument_list|,
name|buckets
operator|.
name|length
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
literal|"bucket_00000"
argument_list|,
name|buckets
index|[
literal|0
index|]
operator|.
name|getPath
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
literal|"bucket_00001"
argument_list|,
name|buckets
index|[
literal|1
index|]
operator|.
name|getPath
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|Assert
operator|.
name|assertEquals
argument_list|(
literal|2
argument_list|,
name|numBase
argument_list|)
expr_stmt|;
name|rs
operator|=
name|runStatementOnDriver
argument_list|(
literal|"select a,b from "
operator|+
name|Table
operator|.
name|NONACIDORCTBL
argument_list|)
expr_stmt|;
name|resultData
operator|=
operator|new
name|int
index|[]
index|[]
block|{
block|{
literal|1
block|,
literal|3
block|}
block|,
block|{
literal|3
block|,
literal|4
block|}
block|}
expr_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
name|stringifyValues
argument_list|(
name|resultData
argument_list|)
argument_list|,
name|rs
argument_list|)
expr_stmt|;
name|rs
operator|=
name|runStatementOnDriver
argument_list|(
literal|"select count(*) from "
operator|+
name|Table
operator|.
name|NONACIDORCTBL
argument_list|)
expr_stmt|;
name|resultCount
operator|=
literal|2
expr_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
name|resultCount
argument_list|,
name|Integer
operator|.
name|parseInt
argument_list|(
name|rs
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|// 6. Let Cleaner delete obsolete files/dirs
name|status
operator|=
name|fs
operator|.
name|listStatus
argument_list|(
operator|new
name|Path
argument_list|(
name|TEST_WAREHOUSE_DIR
operator|+
literal|"/"
operator|+
operator|(
name|Table
operator|.
name|NONACIDORCTBL
operator|)
operator|.
name|toString
argument_list|()
operator|.
name|toLowerCase
argument_list|()
argument_list|)
argument_list|,
name|FileUtils
operator|.
name|STAGING_DIR_PATH_FILTER
argument_list|)
expr_stmt|;
comment|// Before Cleaner, there should be 6 items:
comment|// 2 original files, 2 delta directories and 2 base directories
name|Assert
operator|.
name|assertEquals
argument_list|(
literal|6
argument_list|,
name|status
operator|.
name|length
argument_list|)
expr_stmt|;
name|runCleaner
argument_list|(
name|hiveConf
argument_list|)
expr_stmt|;
comment|// There should be only 1 directory left: base_0000001.
comment|// Original bucket files, delta directories and previous base directory should have been cleaned up.
name|status
operator|=
name|fs
operator|.
name|listStatus
argument_list|(
operator|new
name|Path
argument_list|(
name|TEST_WAREHOUSE_DIR
operator|+
literal|"/"
operator|+
operator|(
name|Table
operator|.
name|NONACIDORCTBL
operator|)
operator|.
name|toString
argument_list|()
operator|.
name|toLowerCase
argument_list|()
argument_list|)
argument_list|,
name|FileUtils
operator|.
name|STAGING_DIR_PATH_FILTER
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
literal|1
argument_list|,
name|status
operator|.
name|length
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
literal|"base_0000002"
argument_list|,
name|status
index|[
literal|0
index|]
operator|.
name|getPath
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
name|FileStatus
index|[]
name|buckets
init|=
name|fs
operator|.
name|listStatus
argument_list|(
name|status
index|[
literal|0
index|]
operator|.
name|getPath
argument_list|()
argument_list|,
name|FileUtils
operator|.
name|STAGING_DIR_PATH_FILTER
argument_list|)
decl_stmt|;
name|Arrays
operator|.
name|sort
argument_list|(
name|buckets
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
name|BUCKET_COUNT
argument_list|,
name|buckets
operator|.
name|length
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
literal|"bucket_00000"
argument_list|,
name|buckets
index|[
literal|0
index|]
operator|.
name|getPath
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
literal|"bucket_00001"
argument_list|,
name|buckets
index|[
literal|1
index|]
operator|.
name|getPath
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
name|rs
operator|=
name|runStatementOnDriver
argument_list|(
literal|"select a,b from "
operator|+
name|Table
operator|.
name|NONACIDORCTBL
argument_list|)
expr_stmt|;
name|resultData
operator|=
operator|new
name|int
index|[]
index|[]
block|{
block|{
literal|1
block|,
literal|3
block|}
block|,
block|{
literal|3
block|,
literal|4
block|}
block|}
expr_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
name|stringifyValues
argument_list|(
name|resultData
argument_list|)
argument_list|,
name|rs
argument_list|)
expr_stmt|;
name|rs
operator|=
name|runStatementOnDriver
argument_list|(
literal|"select count(*) from "
operator|+
name|Table
operator|.
name|NONACIDORCTBL
argument_list|)
expr_stmt|;
name|resultCount
operator|=
literal|2
expr_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
name|resultCount
argument_list|,
name|Integer
operator|.
name|parseInt
argument_list|(
name|rs
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testValidTxnsBookkeeping
parameter_list|()
throws|throws
name|Exception
block|{
comment|// 1. Run a query against a non-ACID table, and we shouldn't have txn logged in conf
name|runStatementOnDriver
argument_list|(
literal|"select * from "
operator|+
name|Table
operator|.
name|NONACIDORCTBL
argument_list|)
expr_stmt|;
name|String
name|value
init|=
name|hiveConf
operator|.
name|get
argument_list|(
name|ValidTxnList
operator|.
name|VALID_TXNS_KEY
argument_list|)
decl_stmt|;
name|Assert
operator|.
name|assertNull
argument_list|(
literal|"The entry should be null for query that doesn't involve ACID tables"
argument_list|,
name|value
argument_list|)
expr_stmt|;
comment|// 2. Run a query against an ACID table, and we should have txn logged in conf
name|runStatementOnDriver
argument_list|(
literal|"select * from "
operator|+
name|Table
operator|.
name|ACIDTBL
argument_list|)
expr_stmt|;
name|value
operator|=
name|hiveConf
operator|.
name|get
argument_list|(
name|ValidTxnList
operator|.
name|VALID_TXNS_KEY
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertNotNull
argument_list|(
literal|"The entry shouldn't be null for query that involves ACID tables"
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testSimpleRead
parameter_list|()
throws|throws
name|Exception
block|{
name|hiveConf
operator|.
name|setVar
argument_list|(
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVEFETCHTASKCONVERSION
argument_list|,
literal|"more"
argument_list|)
expr_stmt|;
name|int
index|[]
index|[]
name|tableData
init|=
block|{
block|{
literal|1
block|,
literal|2
block|}
block|,
block|{
literal|3
block|,
literal|3
block|}
block|}
decl_stmt|;
name|runStatementOnDriver
argument_list|(
literal|"insert into "
operator|+
name|Table
operator|.
name|ACIDTBL
operator|+
literal|" "
operator|+
name|makeValuesClause
argument_list|(
name|tableData
argument_list|)
argument_list|)
expr_stmt|;
name|int
index|[]
index|[]
name|tableData2
init|=
block|{
block|{
literal|5
block|,
literal|3
block|}
block|}
decl_stmt|;
name|runStatementOnDriver
argument_list|(
literal|"insert into "
operator|+
name|Table
operator|.
name|ACIDTBL
operator|+
literal|" "
operator|+
name|makeValuesClause
argument_list|(
name|tableData2
argument_list|)
argument_list|)
expr_stmt|;
name|hiveConf
operator|.
name|set
argument_list|(
name|ValidTxnList
operator|.
name|VALID_TXNS_KEY
argument_list|,
literal|"0:"
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|rs
init|=
name|runStatementOnDriver
argument_list|(
literal|"select * from "
operator|+
name|Table
operator|.
name|ACIDTBL
argument_list|)
decl_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
literal|"Missing data"
argument_list|,
literal|3
argument_list|,
name|rs
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testUpdateMixedCase
parameter_list|()
throws|throws
name|Exception
block|{
name|int
index|[]
index|[]
name|tableData
init|=
block|{
block|{
literal|1
block|,
literal|2
block|}
block|,
block|{
literal|3
block|,
literal|3
block|}
block|,
block|{
literal|5
block|,
literal|3
block|}
block|}
decl_stmt|;
name|runStatementOnDriver
argument_list|(
literal|"insert into "
operator|+
name|Table
operator|.
name|ACIDTBL
operator|+
literal|"(a,b) "
operator|+
name|makeValuesClause
argument_list|(
name|tableData
argument_list|)
argument_list|)
expr_stmt|;
name|runStatementOnDriver
argument_list|(
literal|"update "
operator|+
name|Table
operator|.
name|ACIDTBL
operator|+
literal|" set B = 7 where A=1"
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|rs
init|=
name|runStatementOnDriver
argument_list|(
literal|"select a,b from "
operator|+
name|Table
operator|.
name|ACIDTBL
operator|+
literal|" order by a,b"
argument_list|)
decl_stmt|;
name|int
index|[]
index|[]
name|updatedData
init|=
block|{
block|{
literal|1
block|,
literal|7
block|}
block|,
block|{
literal|3
block|,
literal|3
block|}
block|,
block|{
literal|5
block|,
literal|3
block|}
block|}
decl_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
literal|"Update failed"
argument_list|,
name|stringifyValues
argument_list|(
name|updatedData
argument_list|)
argument_list|,
name|rs
argument_list|)
expr_stmt|;
name|runStatementOnDriver
argument_list|(
literal|"update "
operator|+
name|Table
operator|.
name|ACIDTBL
operator|+
literal|" set B = B + 1 where A=1"
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|rs2
init|=
name|runStatementOnDriver
argument_list|(
literal|"select a,b from "
operator|+
name|Table
operator|.
name|ACIDTBL
operator|+
literal|" order by a,b"
argument_list|)
decl_stmt|;
name|int
index|[]
index|[]
name|updatedData2
init|=
block|{
block|{
literal|1
block|,
literal|8
block|}
block|,
block|{
literal|3
block|,
literal|3
block|}
block|,
block|{
literal|5
block|,
literal|3
block|}
block|}
decl_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
literal|"Update failed"
argument_list|,
name|stringifyValues
argument_list|(
name|updatedData2
argument_list|)
argument_list|,
name|rs2
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testDeleteIn
parameter_list|()
throws|throws
name|Exception
block|{
name|int
index|[]
index|[]
name|tableData
init|=
block|{
block|{
literal|1
block|,
literal|2
block|}
block|,
block|{
literal|3
block|,
literal|2
block|}
block|,
block|{
literal|5
block|,
literal|2
block|}
block|,
block|{
literal|1
block|,
literal|3
block|}
block|,
block|{
literal|3
block|,
literal|3
block|}
block|,
block|{
literal|5
block|,
literal|3
block|}
block|}
decl_stmt|;
name|runStatementOnDriver
argument_list|(
literal|"insert into "
operator|+
name|Table
operator|.
name|ACIDTBL
operator|+
literal|"(a,b) "
operator|+
name|makeValuesClause
argument_list|(
name|tableData
argument_list|)
argument_list|)
expr_stmt|;
name|runStatementOnDriver
argument_list|(
literal|"insert into "
operator|+
name|Table
operator|.
name|NONACIDORCTBL
operator|+
literal|"(a,b) values(1,7),(3,7)"
argument_list|)
expr_stmt|;
comment|//todo: once multistatement txns are supported, add a test to run next 2 statements in a single txn
name|runStatementOnDriver
argument_list|(
literal|"delete from "
operator|+
name|Table
operator|.
name|ACIDTBL
operator|+
literal|" where a in(select a from "
operator|+
name|Table
operator|.
name|NONACIDORCTBL
operator|+
literal|")"
argument_list|)
expr_stmt|;
name|runStatementOnDriver
argument_list|(
literal|"insert into "
operator|+
name|Table
operator|.
name|ACIDTBL
operator|+
literal|"(a,b) select a,b from "
operator|+
name|Table
operator|.
name|NONACIDORCTBL
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|rs
init|=
name|runStatementOnDriver
argument_list|(
literal|"select a,b from "
operator|+
name|Table
operator|.
name|ACIDTBL
operator|+
literal|" order by a,b"
argument_list|)
decl_stmt|;
name|int
index|[]
index|[]
name|updatedData
init|=
block|{
block|{
literal|1
block|,
literal|7
block|}
block|,
block|{
literal|3
block|,
literal|7
block|}
block|,
block|{
literal|5
block|,
literal|2
block|}
block|,
block|{
literal|5
block|,
literal|3
block|}
block|}
decl_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
literal|"Bulk update failed"
argument_list|,
name|stringifyValues
argument_list|(
name|updatedData
argument_list|)
argument_list|,
name|rs
argument_list|)
expr_stmt|;
name|runStatementOnDriver
argument_list|(
literal|"update "
operator|+
name|Table
operator|.
name|ACIDTBL
operator|+
literal|" set b=19 where b in(select b from "
operator|+
name|Table
operator|.
name|NONACIDORCTBL
operator|+
literal|" where a = 3)"
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|rs2
init|=
name|runStatementOnDriver
argument_list|(
literal|"select a,b from "
operator|+
name|Table
operator|.
name|ACIDTBL
operator|+
literal|" order by a,b"
argument_list|)
decl_stmt|;
name|int
index|[]
index|[]
name|updatedData2
init|=
block|{
block|{
literal|1
block|,
literal|19
block|}
block|,
block|{
literal|3
block|,
literal|19
block|}
block|,
block|{
literal|5
block|,
literal|2
block|}
block|,
block|{
literal|5
block|,
literal|3
block|}
block|}
decl_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
literal|"Bulk update2 failed"
argument_list|,
name|stringifyValues
argument_list|(
name|updatedData2
argument_list|)
argument_list|,
name|rs2
argument_list|)
expr_stmt|;
block|}
comment|/**    * Test update that hits multiple partitions (i.e. requries dynamic partition insert to process)    * @throws Exception    */
annotation|@
name|Test
specifier|public
name|void
name|updateDeletePartitioned
parameter_list|()
throws|throws
name|Exception
block|{
name|int
index|[]
index|[]
name|tableData
init|=
block|{
block|{
literal|1
block|,
literal|2
block|}
block|,
block|{
literal|3
block|,
literal|4
block|}
block|,
block|{
literal|5
block|,
literal|6
block|}
block|}
decl_stmt|;
name|runStatementOnDriver
argument_list|(
literal|"insert into "
operator|+
name|Table
operator|.
name|ACIDTBLPART
operator|+
literal|" partition(p=1) (a,b) "
operator|+
name|makeValuesClause
argument_list|(
name|tableData
argument_list|)
argument_list|)
expr_stmt|;
name|runStatementOnDriver
argument_list|(
literal|"insert into "
operator|+
name|Table
operator|.
name|ACIDTBLPART
operator|+
literal|" partition(p=2) (a,b) "
operator|+
name|makeValuesClause
argument_list|(
name|tableData
argument_list|)
argument_list|)
expr_stmt|;
name|TxnStore
name|txnHandler
init|=
name|TxnUtils
operator|.
name|getTxnStore
argument_list|(
name|hiveConf
argument_list|)
decl_stmt|;
name|txnHandler
operator|.
name|compact
argument_list|(
operator|new
name|CompactionRequest
argument_list|(
literal|"default"
argument_list|,
name|Table
operator|.
name|ACIDTBLPART
operator|.
name|name
argument_list|()
argument_list|,
name|CompactionType
operator|.
name|MAJOR
argument_list|)
argument_list|)
expr_stmt|;
name|runWorker
argument_list|(
name|hiveConf
argument_list|)
expr_stmt|;
name|runCleaner
argument_list|(
name|hiveConf
argument_list|)
expr_stmt|;
name|runStatementOnDriver
argument_list|(
literal|"update "
operator|+
name|Table
operator|.
name|ACIDTBLPART
operator|+
literal|" set b = b + 1 where a = 3"
argument_list|)
expr_stmt|;
name|txnHandler
operator|.
name|compact
argument_list|(
operator|new
name|CompactionRequest
argument_list|(
literal|"default"
argument_list|,
name|Table
operator|.
name|ACIDTBLPART
operator|.
name|toString
argument_list|()
argument_list|,
name|CompactionType
operator|.
name|MAJOR
argument_list|)
argument_list|)
expr_stmt|;
name|runWorker
argument_list|(
name|hiveConf
argument_list|)
expr_stmt|;
name|runCleaner
argument_list|(
name|hiveConf
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|rs
init|=
name|runStatementOnDriver
argument_list|(
literal|"select p,a,b from "
operator|+
name|Table
operator|.
name|ACIDTBLPART
operator|+
literal|" order by p, a, b"
argument_list|)
decl_stmt|;
name|int
index|[]
index|[]
name|expectedData
init|=
block|{
block|{
literal|1
block|,
literal|1
block|,
literal|2
block|}
block|,
block|{
literal|1
block|,
literal|3
block|,
literal|5
block|}
block|,
block|{
literal|1
block|,
literal|5
block|,
literal|6
block|}
block|,
block|{
literal|2
block|,
literal|1
block|,
literal|2
block|}
block|,
block|{
literal|2
block|,
literal|3
block|,
literal|5
block|}
block|,
block|{
literal|2
block|,
literal|5
block|,
literal|6
block|}
block|}
decl_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
literal|"Update "
operator|+
name|Table
operator|.
name|ACIDTBLPART
operator|+
literal|" didn't match:"
argument_list|,
name|stringifyValues
argument_list|(
name|expectedData
argument_list|)
argument_list|,
name|rs
argument_list|)
expr_stmt|;
block|}
comment|/**    * https://issues.apache.org/jira/browse/HIVE-10151    */
annotation|@
name|Test
specifier|public
name|void
name|testBucketizedInputFormat
parameter_list|()
throws|throws
name|Exception
block|{
name|int
index|[]
index|[]
name|tableData
init|=
block|{
block|{
literal|1
block|,
literal|2
block|}
block|}
decl_stmt|;
name|runStatementOnDriver
argument_list|(
literal|"insert into "
operator|+
name|Table
operator|.
name|ACIDTBLPART
operator|+
literal|" partition(p=1) (a,b) "
operator|+
name|makeValuesClause
argument_list|(
name|tableData
argument_list|)
argument_list|)
expr_stmt|;
name|runStatementOnDriver
argument_list|(
literal|"insert into "
operator|+
name|Table
operator|.
name|ACIDTBL
operator|+
literal|"(a,b) select a,b from "
operator|+
name|Table
operator|.
name|ACIDTBLPART
operator|+
literal|" where p = 1"
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|rs
init|=
name|runStatementOnDriver
argument_list|(
literal|"select a,b from "
operator|+
name|Table
operator|.
name|ACIDTBL
argument_list|)
decl_stmt|;
comment|//no order by as it's just 1 row
name|Assert
operator|.
name|assertEquals
argument_list|(
literal|"Insert into "
operator|+
name|Table
operator|.
name|ACIDTBL
operator|+
literal|" didn't match:"
argument_list|,
name|stringifyValues
argument_list|(
name|tableData
argument_list|)
argument_list|,
name|rs
argument_list|)
expr_stmt|;
name|runStatementOnDriver
argument_list|(
literal|"insert into "
operator|+
name|Table
operator|.
name|NONACIDORCTBL
operator|+
literal|"(a,b) select a,b from "
operator|+
name|Table
operator|.
name|ACIDTBLPART
operator|+
literal|" where p = 1"
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|rs2
init|=
name|runStatementOnDriver
argument_list|(
literal|"select a,b from "
operator|+
name|Table
operator|.
name|NONACIDORCTBL
argument_list|)
decl_stmt|;
comment|//no order by as it's just 1 row
name|Assert
operator|.
name|assertEquals
argument_list|(
literal|"Insert into "
operator|+
name|Table
operator|.
name|NONACIDORCTBL
operator|+
literal|" didn't match:"
argument_list|,
name|stringifyValues
argument_list|(
name|tableData
argument_list|)
argument_list|,
name|rs2
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testInsertOverwriteWithSelfJoin
parameter_list|()
throws|throws
name|Exception
block|{
name|int
index|[]
index|[]
name|part1Data
init|=
block|{
block|{
literal|1
block|,
literal|7
block|}
block|}
decl_stmt|;
name|runStatementOnDriver
argument_list|(
literal|"insert into "
operator|+
name|Table
operator|.
name|NONACIDORCTBL
operator|+
literal|"(a,b) "
operator|+
name|makeValuesClause
argument_list|(
name|part1Data
argument_list|)
argument_list|)
expr_stmt|;
comment|//this works because logically we need S lock on NONACIDORCTBL to read and X lock to write, but
comment|//LockRequestBuilder dedups locks on the same entity to only keep the highest level lock requested
name|runStatementOnDriver
argument_list|(
literal|"insert overwrite table "
operator|+
name|Table
operator|.
name|NONACIDORCTBL
operator|+
literal|" select 2, 9 from "
operator|+
name|Table
operator|.
name|NONACIDORCTBL
operator|+
literal|" T inner join "
operator|+
name|Table
operator|.
name|NONACIDORCTBL
operator|+
literal|" S on T.a=S.a"
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|rs
init|=
name|runStatementOnDriver
argument_list|(
literal|"select a,b from "
operator|+
name|Table
operator|.
name|NONACIDORCTBL
operator|+
literal|" order by a,b"
argument_list|)
decl_stmt|;
name|int
index|[]
index|[]
name|joinData
init|=
block|{
block|{
literal|2
block|,
literal|9
block|}
block|}
decl_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
literal|"Self join non-part insert overwrite failed"
argument_list|,
name|stringifyValues
argument_list|(
name|joinData
argument_list|)
argument_list|,
name|rs
argument_list|)
expr_stmt|;
name|int
index|[]
index|[]
name|part2Data
init|=
block|{
block|{
literal|1
block|,
literal|8
block|}
block|}
decl_stmt|;
name|runStatementOnDriver
argument_list|(
literal|"insert into "
operator|+
name|Table
operator|.
name|NONACIDPART
operator|+
literal|" partition(p=1) (a,b) "
operator|+
name|makeValuesClause
argument_list|(
name|part1Data
argument_list|)
argument_list|)
expr_stmt|;
name|runStatementOnDriver
argument_list|(
literal|"insert into "
operator|+
name|Table
operator|.
name|NONACIDPART
operator|+
literal|" partition(p=2) (a,b) "
operator|+
name|makeValuesClause
argument_list|(
name|part2Data
argument_list|)
argument_list|)
expr_stmt|;
comment|//here we need X lock on p=1 partition to write and S lock on 'table' to read which should
comment|//not block each other since they are part of the same txn
name|runStatementOnDriver
argument_list|(
literal|"insert overwrite table "
operator|+
name|Table
operator|.
name|NONACIDPART
operator|+
literal|" partition(p=1) select a,b from "
operator|+
name|Table
operator|.
name|NONACIDPART
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|rs2
init|=
name|runStatementOnDriver
argument_list|(
literal|"select a,b from "
operator|+
name|Table
operator|.
name|NONACIDPART
operator|+
literal|" order by a,b"
argument_list|)
decl_stmt|;
name|int
index|[]
index|[]
name|updatedData
init|=
block|{
block|{
literal|1
block|,
literal|7
block|}
block|,
block|{
literal|1
block|,
literal|8
block|}
block|,
block|{
literal|1
block|,
literal|8
block|}
block|}
decl_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
literal|"Insert overwrite partition failed"
argument_list|,
name|stringifyValues
argument_list|(
name|updatedData
argument_list|)
argument_list|,
name|rs2
argument_list|)
expr_stmt|;
comment|//insert overwrite not supported for ACID tables
block|}
specifier|private
specifier|static
name|void
name|checkCompactionState
parameter_list|(
name|CompactionsByState
name|expected
parameter_list|,
name|CompactionsByState
name|actual
parameter_list|)
block|{
name|Assert
operator|.
name|assertEquals
argument_list|(
name|TxnStore
operator|.
name|ATTEMPTED_RESPONSE
argument_list|,
name|expected
operator|.
name|attempted
argument_list|,
name|actual
operator|.
name|attempted
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
name|TxnStore
operator|.
name|FAILED_RESPONSE
argument_list|,
name|expected
operator|.
name|failed
argument_list|,
name|actual
operator|.
name|failed
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
name|TxnStore
operator|.
name|INITIATED_RESPONSE
argument_list|,
name|expected
operator|.
name|initiated
argument_list|,
name|actual
operator|.
name|initiated
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
name|TxnStore
operator|.
name|CLEANING_RESPONSE
argument_list|,
name|expected
operator|.
name|readyToClean
argument_list|,
name|actual
operator|.
name|readyToClean
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
name|TxnStore
operator|.
name|SUCCEEDED_RESPONSE
argument_list|,
name|expected
operator|.
name|succeeded
argument_list|,
name|actual
operator|.
name|succeeded
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
name|TxnStore
operator|.
name|WORKING_RESPONSE
argument_list|,
name|expected
operator|.
name|working
argument_list|,
name|actual
operator|.
name|working
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
literal|"total"
argument_list|,
name|expected
operator|.
name|total
argument_list|,
name|actual
operator|.
name|total
argument_list|)
expr_stmt|;
block|}
comment|/**    * HIVE-12353    * @throws Exception    */
annotation|@
name|Test
specifier|public
name|void
name|testInitiatorWithMultipleFailedCompactions
parameter_list|()
throws|throws
name|Exception
block|{
name|testInitiatorWithMultipleFailedCompactionsForVariousTblProperties
argument_list|(
literal|"'transactional'='true'"
argument_list|)
expr_stmt|;
block|}
name|void
name|testInitiatorWithMultipleFailedCompactionsForVariousTblProperties
parameter_list|(
name|String
name|tblProperties
parameter_list|)
throws|throws
name|Exception
block|{
name|String
name|tblName
init|=
literal|"hive12353"
decl_stmt|;
name|runStatementOnDriver
argument_list|(
literal|"drop table if exists "
operator|+
name|tblName
argument_list|)
expr_stmt|;
name|runStatementOnDriver
argument_list|(
literal|"CREATE TABLE "
operator|+
name|tblName
operator|+
literal|"(a INT, b STRING) "
operator|+
literal|" CLUSTERED BY(a) INTO 1 BUCKETS"
operator|+
comment|//currently ACID requires table to be bucketed
literal|" STORED AS ORC  TBLPROPERTIES ( "
operator|+
name|tblProperties
operator|+
literal|" )"
argument_list|)
expr_stmt|;
name|hiveConf
operator|.
name|setIntVar
argument_list|(
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVE_COMPACTOR_DELTA_NUM_THRESHOLD
argument_list|,
literal|4
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
literal|5
condition|;
name|i
operator|++
control|)
block|{
comment|//generate enough delta files so that Initiator can trigger auto compaction
name|runStatementOnDriver
argument_list|(
literal|"insert into "
operator|+
name|tblName
operator|+
literal|" values("
operator|+
operator|(
name|i
operator|+
literal|1
operator|)
operator|+
literal|", 'foo'),("
operator|+
operator|(
name|i
operator|+
literal|2
operator|)
operator|+
literal|", 'bar'),("
operator|+
operator|(
name|i
operator|+
literal|3
operator|)
operator|+
literal|", 'baz')"
argument_list|)
expr_stmt|;
block|}
name|hiveConf
operator|.
name|setBoolVar
argument_list|(
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVETESTMODEFAILCOMPACTION
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|int
name|numFailedCompactions
init|=
name|hiveConf
operator|.
name|getIntVar
argument_list|(
name|HiveConf
operator|.
name|ConfVars
operator|.
name|COMPACTOR_INITIATOR_FAILED_THRESHOLD
argument_list|)
decl_stmt|;
name|TxnStore
name|txnHandler
init|=
name|TxnUtils
operator|.
name|getTxnStore
argument_list|(
name|hiveConf
argument_list|)
decl_stmt|;
name|AtomicBoolean
name|stop
init|=
operator|new
name|AtomicBoolean
argument_list|(
literal|true
argument_list|)
decl_stmt|;
comment|//create failed compactions
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numFailedCompactions
condition|;
name|i
operator|++
control|)
block|{
comment|//each of these should fail
name|txnHandler
operator|.
name|compact
argument_list|(
operator|new
name|CompactionRequest
argument_list|(
literal|"default"
argument_list|,
name|tblName
argument_list|,
name|CompactionType
operator|.
name|MINOR
argument_list|)
argument_list|)
expr_stmt|;
name|runWorker
argument_list|(
name|hiveConf
argument_list|)
expr_stmt|;
block|}
comment|//this should not schedule a new compaction due to prior failures, but will create Attempted entry
name|Initiator
name|init
init|=
operator|new
name|Initiator
argument_list|()
decl_stmt|;
name|init
operator|.
name|setThreadId
argument_list|(
operator|(
name|int
operator|)
name|init
operator|.
name|getId
argument_list|()
argument_list|)
expr_stmt|;
name|init
operator|.
name|setHiveConf
argument_list|(
name|hiveConf
argument_list|)
expr_stmt|;
name|init
operator|.
name|init
argument_list|(
name|stop
argument_list|,
operator|new
name|AtomicBoolean
argument_list|()
argument_list|)
expr_stmt|;
name|init
operator|.
name|run
argument_list|()
expr_stmt|;
name|int
name|numAttemptedCompactions
init|=
literal|1
decl_stmt|;
name|checkCompactionState
argument_list|(
operator|new
name|CompactionsByState
argument_list|(
name|numAttemptedCompactions
argument_list|,
name|numFailedCompactions
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|numFailedCompactions
operator|+
name|numAttemptedCompactions
argument_list|)
argument_list|,
name|countCompacts
argument_list|(
name|txnHandler
argument_list|)
argument_list|)
expr_stmt|;
name|hiveConf
operator|.
name|setTimeVar
argument_list|(
name|HiveConf
operator|.
name|ConfVars
operator|.
name|COMPACTOR_HISTORY_REAPER_INTERVAL
argument_list|,
literal|10
argument_list|,
name|TimeUnit
operator|.
name|MILLISECONDS
argument_list|)
expr_stmt|;
name|AcidCompactionHistoryService
name|compactionHistoryService
init|=
operator|new
name|AcidCompactionHistoryService
argument_list|()
decl_stmt|;
name|runHouseKeeperService
argument_list|(
name|compactionHistoryService
argument_list|,
name|hiveConf
argument_list|)
expr_stmt|;
comment|//should not remove anything from history
name|checkCompactionState
argument_list|(
operator|new
name|CompactionsByState
argument_list|(
name|numAttemptedCompactions
argument_list|,
name|numFailedCompactions
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|numFailedCompactions
operator|+
name|numAttemptedCompactions
argument_list|)
argument_list|,
name|countCompacts
argument_list|(
name|txnHandler
argument_list|)
argument_list|)
expr_stmt|;
name|txnHandler
operator|.
name|compact
argument_list|(
operator|new
name|CompactionRequest
argument_list|(
literal|"default"
argument_list|,
name|tblName
argument_list|,
name|CompactionType
operator|.
name|MAJOR
argument_list|)
argument_list|)
expr_stmt|;
name|runWorker
argument_list|(
name|hiveConf
argument_list|)
expr_stmt|;
comment|//will fail
name|txnHandler
operator|.
name|compact
argument_list|(
operator|new
name|CompactionRequest
argument_list|(
literal|"default"
argument_list|,
name|tblName
argument_list|,
name|CompactionType
operator|.
name|MINOR
argument_list|)
argument_list|)
expr_stmt|;
name|runWorker
argument_list|(
name|hiveConf
argument_list|)
expr_stmt|;
comment|//will fail
name|init
operator|.
name|run
argument_list|()
expr_stmt|;
name|numAttemptedCompactions
operator|++
expr_stmt|;
name|init
operator|.
name|run
argument_list|()
expr_stmt|;
name|numAttemptedCompactions
operator|++
expr_stmt|;
name|checkCompactionState
argument_list|(
operator|new
name|CompactionsByState
argument_list|(
name|numAttemptedCompactions
argument_list|,
name|numFailedCompactions
operator|+
literal|2
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|numFailedCompactions
operator|+
literal|2
operator|+
name|numAttemptedCompactions
argument_list|)
argument_list|,
name|countCompacts
argument_list|(
name|txnHandler
argument_list|)
argument_list|)
expr_stmt|;
name|runHouseKeeperService
argument_list|(
name|compactionHistoryService
argument_list|,
name|hiveConf
argument_list|)
expr_stmt|;
comment|//should remove history so that we have
comment|//COMPACTOR_HISTORY_RETENTION_FAILED failed compacts left (and no other since we only have failed ones here)
name|checkCompactionState
argument_list|(
operator|new
name|CompactionsByState
argument_list|(
name|hiveConf
operator|.
name|getIntVar
argument_list|(
name|HiveConf
operator|.
name|ConfVars
operator|.
name|COMPACTOR_HISTORY_RETENTION_ATTEMPTED
argument_list|)
argument_list|,
name|hiveConf
operator|.
name|getIntVar
argument_list|(
name|HiveConf
operator|.
name|ConfVars
operator|.
name|COMPACTOR_HISTORY_RETENTION_FAILED
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|hiveConf
operator|.
name|getIntVar
argument_list|(
name|HiveConf
operator|.
name|ConfVars
operator|.
name|COMPACTOR_HISTORY_RETENTION_FAILED
argument_list|)
operator|+
name|hiveConf
operator|.
name|getIntVar
argument_list|(
name|HiveConf
operator|.
name|ConfVars
operator|.
name|COMPACTOR_HISTORY_RETENTION_ATTEMPTED
argument_list|)
argument_list|)
argument_list|,
name|countCompacts
argument_list|(
name|txnHandler
argument_list|)
argument_list|)
expr_stmt|;
name|hiveConf
operator|.
name|setBoolVar
argument_list|(
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVETESTMODEFAILCOMPACTION
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|txnHandler
operator|.
name|compact
argument_list|(
operator|new
name|CompactionRequest
argument_list|(
literal|"default"
argument_list|,
name|tblName
argument_list|,
name|CompactionType
operator|.
name|MINOR
argument_list|)
argument_list|)
expr_stmt|;
comment|//at this point "show compactions" should have (COMPACTOR_HISTORY_RETENTION_FAILED) failed + 1 initiated (explicitly by user)
name|checkCompactionState
argument_list|(
operator|new
name|CompactionsByState
argument_list|(
name|hiveConf
operator|.
name|getIntVar
argument_list|(
name|HiveConf
operator|.
name|ConfVars
operator|.
name|COMPACTOR_HISTORY_RETENTION_ATTEMPTED
argument_list|)
argument_list|,
name|hiveConf
operator|.
name|getIntVar
argument_list|(
name|HiveConf
operator|.
name|ConfVars
operator|.
name|COMPACTOR_HISTORY_RETENTION_FAILED
argument_list|)
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|hiveConf
operator|.
name|getIntVar
argument_list|(
name|HiveConf
operator|.
name|ConfVars
operator|.
name|COMPACTOR_HISTORY_RETENTION_FAILED
argument_list|)
operator|+
name|hiveConf
operator|.
name|getIntVar
argument_list|(
name|HiveConf
operator|.
name|ConfVars
operator|.
name|COMPACTOR_HISTORY_RETENTION_ATTEMPTED
argument_list|)
operator|+
literal|1
argument_list|)
argument_list|,
name|countCompacts
argument_list|(
name|txnHandler
argument_list|)
argument_list|)
expr_stmt|;
name|runWorker
argument_list|(
name|hiveConf
argument_list|)
expr_stmt|;
comment|//will succeed and transition to Initiated->Working->Ready for Cleaning
name|checkCompactionState
argument_list|(
operator|new
name|CompactionsByState
argument_list|(
name|hiveConf
operator|.
name|getIntVar
argument_list|(
name|HiveConf
operator|.
name|ConfVars
operator|.
name|COMPACTOR_HISTORY_RETENTION_ATTEMPTED
argument_list|)
argument_list|,
name|hiveConf
operator|.
name|getIntVar
argument_list|(
name|HiveConf
operator|.
name|ConfVars
operator|.
name|COMPACTOR_HISTORY_RETENTION_FAILED
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|hiveConf
operator|.
name|getIntVar
argument_list|(
name|HiveConf
operator|.
name|ConfVars
operator|.
name|COMPACTOR_HISTORY_RETENTION_FAILED
argument_list|)
operator|+
name|hiveConf
operator|.
name|getIntVar
argument_list|(
name|HiveConf
operator|.
name|ConfVars
operator|.
name|COMPACTOR_HISTORY_RETENTION_ATTEMPTED
argument_list|)
operator|+
literal|1
argument_list|)
argument_list|,
name|countCompacts
argument_list|(
name|txnHandler
argument_list|)
argument_list|)
expr_stmt|;
name|runCleaner
argument_list|(
name|hiveConf
argument_list|)
expr_stmt|;
comment|// transition to Success state
name|runHouseKeeperService
argument_list|(
name|compactionHistoryService
argument_list|,
name|hiveConf
argument_list|)
expr_stmt|;
comment|//should not purge anything as all items within retention sizes
name|checkCompactionState
argument_list|(
operator|new
name|CompactionsByState
argument_list|(
name|hiveConf
operator|.
name|getIntVar
argument_list|(
name|HiveConf
operator|.
name|ConfVars
operator|.
name|COMPACTOR_HISTORY_RETENTION_ATTEMPTED
argument_list|)
argument_list|,
name|hiveConf
operator|.
name|getIntVar
argument_list|(
name|HiveConf
operator|.
name|ConfVars
operator|.
name|COMPACTOR_HISTORY_RETENTION_FAILED
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
name|hiveConf
operator|.
name|getIntVar
argument_list|(
name|HiveConf
operator|.
name|ConfVars
operator|.
name|COMPACTOR_HISTORY_RETENTION_FAILED
argument_list|)
operator|+
name|hiveConf
operator|.
name|getIntVar
argument_list|(
name|HiveConf
operator|.
name|ConfVars
operator|.
name|COMPACTOR_HISTORY_RETENTION_ATTEMPTED
argument_list|)
operator|+
literal|1
argument_list|)
argument_list|,
name|countCompacts
argument_list|(
name|txnHandler
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**    * Make sure there's no FileSystem$Cache$Key leak due to UGI use    * @throws Exception    */
annotation|@
name|Test
specifier|public
name|void
name|testFileSystemUnCaching
parameter_list|()
throws|throws
name|Exception
block|{
name|int
name|cacheSizeBefore
decl_stmt|;
name|int
name|cacheSizeAfter
decl_stmt|;
comment|// get the size of cache BEFORE
name|cacheSizeBefore
operator|=
name|getFileSystemCacheSize
argument_list|()
expr_stmt|;
comment|// Insert a row to ACID table
name|runStatementOnDriver
argument_list|(
literal|"insert into "
operator|+
name|Table
operator|.
name|ACIDTBL
operator|+
literal|"(a,b) values(1,2)"
argument_list|)
expr_stmt|;
comment|// Perform a major compaction
name|runStatementOnDriver
argument_list|(
literal|"alter table "
operator|+
name|Table
operator|.
name|ACIDTBL
operator|+
literal|" compact 'major'"
argument_list|)
expr_stmt|;
name|runWorker
argument_list|(
name|hiveConf
argument_list|)
expr_stmt|;
name|runCleaner
argument_list|(
name|hiveConf
argument_list|)
expr_stmt|;
comment|// get the size of cache AFTER
name|cacheSizeAfter
operator|=
name|getFileSystemCacheSize
argument_list|()
expr_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
name|cacheSizeBefore
argument_list|,
name|cacheSizeAfter
argument_list|)
expr_stmt|;
block|}
specifier|private
name|int
name|getFileSystemCacheSize
parameter_list|()
throws|throws
name|Exception
block|{
try|try
block|{
name|Field
name|cache
init|=
name|FileSystem
operator|.
name|class
operator|.
name|getDeclaredField
argument_list|(
literal|"CACHE"
argument_list|)
decl_stmt|;
name|cache
operator|.
name|setAccessible
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|Object
name|o
init|=
name|cache
operator|.
name|get
argument_list|(
literal|null
argument_list|)
decl_stmt|;
comment|// FileSystem.CACHE
name|Field
name|mapField
init|=
name|o
operator|.
name|getClass
argument_list|()
operator|.
name|getDeclaredField
argument_list|(
literal|"map"
argument_list|)
decl_stmt|;
name|mapField
operator|.
name|setAccessible
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|Map
name|map
init|=
operator|(
name|HashMap
operator|)
name|mapField
operator|.
name|get
argument_list|(
name|o
argument_list|)
decl_stmt|;
comment|// FileSystem.CACHE.map
return|return
name|map
operator|.
name|size
argument_list|()
return|;
block|}
catch|catch
parameter_list|(
name|NoSuchFieldException
name|e
parameter_list|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
specifier|private
specifier|static
class|class
name|CompactionsByState
block|{
specifier|private
name|int
name|attempted
decl_stmt|;
specifier|private
name|int
name|failed
decl_stmt|;
specifier|private
name|int
name|initiated
decl_stmt|;
specifier|private
name|int
name|readyToClean
decl_stmt|;
specifier|private
name|int
name|succeeded
decl_stmt|;
specifier|private
name|int
name|working
decl_stmt|;
specifier|private
name|int
name|total
decl_stmt|;
name|CompactionsByState
parameter_list|()
block|{
name|this
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|CompactionsByState
parameter_list|(
name|int
name|attempted
parameter_list|,
name|int
name|failed
parameter_list|,
name|int
name|initiated
parameter_list|,
name|int
name|readyToClean
parameter_list|,
name|int
name|succeeded
parameter_list|,
name|int
name|working
parameter_list|,
name|int
name|total
parameter_list|)
block|{
name|this
operator|.
name|attempted
operator|=
name|attempted
expr_stmt|;
name|this
operator|.
name|failed
operator|=
name|failed
expr_stmt|;
name|this
operator|.
name|initiated
operator|=
name|initiated
expr_stmt|;
name|this
operator|.
name|readyToClean
operator|=
name|readyToClean
expr_stmt|;
name|this
operator|.
name|succeeded
operator|=
name|succeeded
expr_stmt|;
name|this
operator|.
name|working
operator|=
name|working
expr_stmt|;
name|this
operator|.
name|total
operator|=
name|total
expr_stmt|;
block|}
block|}
specifier|private
specifier|static
name|CompactionsByState
name|countCompacts
parameter_list|(
name|TxnStore
name|txnHandler
parameter_list|)
throws|throws
name|MetaException
block|{
name|ShowCompactResponse
name|resp
init|=
name|txnHandler
operator|.
name|showCompact
argument_list|(
operator|new
name|ShowCompactRequest
argument_list|()
argument_list|)
decl_stmt|;
name|CompactionsByState
name|compactionsByState
init|=
operator|new
name|CompactionsByState
argument_list|()
decl_stmt|;
name|compactionsByState
operator|.
name|total
operator|=
name|resp
operator|.
name|getCompactsSize
argument_list|()
expr_stmt|;
for|for
control|(
name|ShowCompactResponseElement
name|compact
range|:
name|resp
operator|.
name|getCompacts
argument_list|()
control|)
block|{
if|if
condition|(
name|TxnStore
operator|.
name|FAILED_RESPONSE
operator|.
name|equals
argument_list|(
name|compact
operator|.
name|getState
argument_list|()
argument_list|)
condition|)
block|{
name|compactionsByState
operator|.
name|failed
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TxnStore
operator|.
name|CLEANING_RESPONSE
operator|.
name|equals
argument_list|(
name|compact
operator|.
name|getState
argument_list|()
argument_list|)
condition|)
block|{
name|compactionsByState
operator|.
name|readyToClean
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TxnStore
operator|.
name|INITIATED_RESPONSE
operator|.
name|equals
argument_list|(
name|compact
operator|.
name|getState
argument_list|()
argument_list|)
condition|)
block|{
name|compactionsByState
operator|.
name|initiated
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TxnStore
operator|.
name|SUCCEEDED_RESPONSE
operator|.
name|equals
argument_list|(
name|compact
operator|.
name|getState
argument_list|()
argument_list|)
condition|)
block|{
name|compactionsByState
operator|.
name|succeeded
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TxnStore
operator|.
name|WORKING_RESPONSE
operator|.
name|equals
argument_list|(
name|compact
operator|.
name|getState
argument_list|()
argument_list|)
condition|)
block|{
name|compactionsByState
operator|.
name|working
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TxnStore
operator|.
name|ATTEMPTED_RESPONSE
operator|.
name|equals
argument_list|(
name|compact
operator|.
name|getState
argument_list|()
argument_list|)
condition|)
block|{
name|compactionsByState
operator|.
name|attempted
operator|++
expr_stmt|;
block|}
else|else
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"Unexpected state: "
operator|+
name|compact
operator|.
name|getState
argument_list|()
argument_list|)
throw|;
block|}
block|}
return|return
name|compactionsByState
return|;
block|}
specifier|public
specifier|static
name|void
name|runWorker
parameter_list|(
name|HiveConf
name|hiveConf
parameter_list|)
throws|throws
name|MetaException
block|{
name|AtomicBoolean
name|stop
init|=
operator|new
name|AtomicBoolean
argument_list|(
literal|true
argument_list|)
decl_stmt|;
name|Worker
name|t
init|=
operator|new
name|Worker
argument_list|()
decl_stmt|;
name|t
operator|.
name|setThreadId
argument_list|(
operator|(
name|int
operator|)
name|t
operator|.
name|getId
argument_list|()
argument_list|)
expr_stmt|;
name|t
operator|.
name|setHiveConf
argument_list|(
name|hiveConf
argument_list|)
expr_stmt|;
name|AtomicBoolean
name|looped
init|=
operator|new
name|AtomicBoolean
argument_list|()
decl_stmt|;
name|t
operator|.
name|init
argument_list|(
name|stop
argument_list|,
name|looped
argument_list|)
expr_stmt|;
name|t
operator|.
name|run
argument_list|()
expr_stmt|;
block|}
specifier|public
specifier|static
name|void
name|runCleaner
parameter_list|(
name|HiveConf
name|hiveConf
parameter_list|)
throws|throws
name|MetaException
block|{
name|AtomicBoolean
name|stop
init|=
operator|new
name|AtomicBoolean
argument_list|(
literal|true
argument_list|)
decl_stmt|;
name|Cleaner
name|t
init|=
operator|new
name|Cleaner
argument_list|()
decl_stmt|;
name|t
operator|.
name|setThreadId
argument_list|(
operator|(
name|int
operator|)
name|t
operator|.
name|getId
argument_list|()
argument_list|)
expr_stmt|;
name|t
operator|.
name|setHiveConf
argument_list|(
name|hiveConf
argument_list|)
expr_stmt|;
name|AtomicBoolean
name|looped
init|=
operator|new
name|AtomicBoolean
argument_list|()
decl_stmt|;
name|t
operator|.
name|init
argument_list|(
name|stop
argument_list|,
name|looped
argument_list|)
expr_stmt|;
name|t
operator|.
name|run
argument_list|()
expr_stmt|;
block|}
specifier|public
specifier|static
name|void
name|runHouseKeeperService
parameter_list|(
name|HouseKeeperService
name|houseKeeperService
parameter_list|,
name|HiveConf
name|conf
parameter_list|)
throws|throws
name|Exception
block|{
name|int
name|lastCount
init|=
name|houseKeeperService
operator|.
name|getIsAliveCounter
argument_list|()
decl_stmt|;
name|houseKeeperService
operator|.
name|start
argument_list|(
name|conf
argument_list|)
expr_stmt|;
name|int
name|maxIter
init|=
literal|10
decl_stmt|;
name|int
name|iterCount
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|houseKeeperService
operator|.
name|getIsAliveCounter
argument_list|()
operator|<=
name|lastCount
condition|)
block|{
if|if
condition|(
name|iterCount
operator|++
operator|>=
name|maxIter
condition|)
block|{
comment|//prevent test hangs
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"HouseKeeper didn't run after "
operator|+
operator|(
name|iterCount
operator|-
literal|1
operator|)
operator|+
literal|" waits"
argument_list|)
throw|;
block|}
try|try
block|{
name|Thread
operator|.
name|sleep
argument_list|(
literal|100
argument_list|)
expr_stmt|;
comment|//make sure it has run at least once
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|ex
parameter_list|)
block|{
comment|//...
block|}
block|}
name|houseKeeperService
operator|.
name|stop
argument_list|()
expr_stmt|;
block|}
comment|/**    * HIVE-12352 has details    * @throws Exception    */
annotation|@
name|Test
specifier|public
name|void
name|writeBetweenWorkerAndCleaner
parameter_list|()
throws|throws
name|Exception
block|{
name|writeBetweenWorkerAndCleanerForVariousTblProperties
argument_list|(
literal|"'transactional'='true'"
argument_list|)
expr_stmt|;
block|}
specifier|protected
name|void
name|writeBetweenWorkerAndCleanerForVariousTblProperties
parameter_list|(
name|String
name|tblProperties
parameter_list|)
throws|throws
name|Exception
block|{
name|String
name|tblName
init|=
literal|"hive12352"
decl_stmt|;
name|runStatementOnDriver
argument_list|(
literal|"drop table if exists "
operator|+
name|tblName
argument_list|)
expr_stmt|;
name|runStatementOnDriver
argument_list|(
literal|"CREATE TABLE "
operator|+
name|tblName
operator|+
literal|"(a INT, b STRING) "
operator|+
literal|" CLUSTERED BY(a) INTO 1 BUCKETS"
operator|+
comment|//currently ACID requires table to be bucketed
literal|" STORED AS ORC  TBLPROPERTIES ( "
operator|+
name|tblProperties
operator|+
literal|" )"
argument_list|)
expr_stmt|;
comment|//create some data
name|runStatementOnDriver
argument_list|(
literal|"insert into "
operator|+
name|tblName
operator|+
literal|" values(1, 'foo'),(2, 'bar'),(3, 'baz')"
argument_list|)
expr_stmt|;
name|runStatementOnDriver
argument_list|(
literal|"update "
operator|+
name|tblName
operator|+
literal|" set b = 'blah' where a = 3"
argument_list|)
expr_stmt|;
comment|//run Worker to execute compaction
name|TxnStore
name|txnHandler
init|=
name|TxnUtils
operator|.
name|getTxnStore
argument_list|(
name|hiveConf
argument_list|)
decl_stmt|;
name|txnHandler
operator|.
name|compact
argument_list|(
operator|new
name|CompactionRequest
argument_list|(
literal|"default"
argument_list|,
name|tblName
argument_list|,
name|CompactionType
operator|.
name|MINOR
argument_list|)
argument_list|)
expr_stmt|;
name|Worker
name|t
init|=
operator|new
name|Worker
argument_list|()
decl_stmt|;
name|t
operator|.
name|setThreadId
argument_list|(
operator|(
name|int
operator|)
name|t
operator|.
name|getId
argument_list|()
argument_list|)
expr_stmt|;
name|t
operator|.
name|setHiveConf
argument_list|(
name|hiveConf
argument_list|)
expr_stmt|;
name|AtomicBoolean
name|stop
init|=
operator|new
name|AtomicBoolean
argument_list|(
literal|true
argument_list|)
decl_stmt|;
name|AtomicBoolean
name|looped
init|=
operator|new
name|AtomicBoolean
argument_list|()
decl_stmt|;
name|t
operator|.
name|init
argument_list|(
name|stop
argument_list|,
name|looped
argument_list|)
expr_stmt|;
name|t
operator|.
name|run
argument_list|()
expr_stmt|;
comment|//delete something, but make sure txn is rolled back
name|hiveConf
operator|.
name|setBoolVar
argument_list|(
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVETESTMODEROLLBACKTXN
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|runStatementOnDriver
argument_list|(
literal|"delete from "
operator|+
name|tblName
operator|+
literal|" where a = 1"
argument_list|)
expr_stmt|;
name|hiveConf
operator|.
name|setBoolVar
argument_list|(
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVETESTMODEROLLBACKTXN
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|expected
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|expected
operator|.
name|add
argument_list|(
literal|"1\tfoo"
argument_list|)
expr_stmt|;
name|expected
operator|.
name|add
argument_list|(
literal|"2\tbar"
argument_list|)
expr_stmt|;
name|expected
operator|.
name|add
argument_list|(
literal|"3\tblah"
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
literal|""
argument_list|,
name|expected
argument_list|,
name|runStatementOnDriver
argument_list|(
literal|"select a,b from "
operator|+
name|tblName
operator|+
literal|" order by a"
argument_list|)
argument_list|)
expr_stmt|;
comment|//run Cleaner
name|Cleaner
name|c
init|=
operator|new
name|Cleaner
argument_list|()
decl_stmt|;
name|c
operator|.
name|setThreadId
argument_list|(
operator|(
name|int
operator|)
name|c
operator|.
name|getId
argument_list|()
argument_list|)
expr_stmt|;
name|c
operator|.
name|setHiveConf
argument_list|(
name|hiveConf
argument_list|)
expr_stmt|;
name|c
operator|.
name|init
argument_list|(
name|stop
argument_list|,
operator|new
name|AtomicBoolean
argument_list|()
argument_list|)
expr_stmt|;
name|c
operator|.
name|run
argument_list|()
expr_stmt|;
comment|//this seems odd, but we wan to make sure that to run CompactionTxnHandler.cleanEmptyAbortedTxns()
name|Initiator
name|i
init|=
operator|new
name|Initiator
argument_list|()
decl_stmt|;
name|i
operator|.
name|setThreadId
argument_list|(
operator|(
name|int
operator|)
name|i
operator|.
name|getId
argument_list|()
argument_list|)
expr_stmt|;
name|i
operator|.
name|setHiveConf
argument_list|(
name|hiveConf
argument_list|)
expr_stmt|;
name|i
operator|.
name|init
argument_list|(
name|stop
argument_list|,
operator|new
name|AtomicBoolean
argument_list|()
argument_list|)
expr_stmt|;
name|i
operator|.
name|run
argument_list|()
expr_stmt|;
comment|//check that aborted operation didn't become committed
name|Assert
operator|.
name|assertEquals
argument_list|(
literal|""
argument_list|,
name|expected
argument_list|,
name|runStatementOnDriver
argument_list|(
literal|"select a,b from "
operator|+
name|tblName
operator|+
literal|" order by a"
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**    * Simulate the scenario when a heartbeat failed due to client errors such as no locks or no txns being found.    * When a heartbeat fails, the query should be failed too.    * @throws Exception    */
annotation|@
name|Test
specifier|public
name|void
name|testFailHeartbeater
parameter_list|()
throws|throws
name|Exception
block|{
comment|// Fail heartbeater, so that we can get a RuntimeException from the query.
comment|// More specifically, it's the original IOException thrown by either MR's or Tez's progress monitoring loop.
name|hiveConf
operator|.
name|setBoolVar
argument_list|(
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVETESTMODEFAILHEARTBEATER
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|Exception
name|exception
init|=
literal|null
decl_stmt|;
try|try
block|{
name|runStatementOnDriver
argument_list|(
literal|"insert into "
operator|+
name|Table
operator|.
name|ACIDTBL
operator|+
literal|"(a,b) "
operator|+
name|makeValuesClause
argument_list|(
operator|new
name|int
index|[]
index|[]
block|{
block|{
literal|1
block|,
literal|2
block|}
block|,
block|{
literal|3
block|,
literal|4
block|}
block|}
argument_list|)
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|RuntimeException
name|e
parameter_list|)
block|{
name|exception
operator|=
name|e
expr_stmt|;
block|}
name|Assert
operator|.
name|assertNotNull
argument_list|(
name|exception
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertTrue
argument_list|(
name|exception
operator|.
name|getMessage
argument_list|()
operator|.
name|contains
argument_list|(
literal|"HIVETESTMODEFAILHEARTBEATER=true"
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testOpenTxnsCounter
parameter_list|()
throws|throws
name|Exception
block|{
name|hiveConf
operator|.
name|setIntVar
argument_list|(
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVE_MAX_OPEN_TXNS
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|hiveConf
operator|.
name|setTimeVar
argument_list|(
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVE_COUNT_OPEN_TXNS_INTERVAL
argument_list|,
literal|10
argument_list|,
name|TimeUnit
operator|.
name|MILLISECONDS
argument_list|)
expr_stmt|;
name|TxnStore
name|txnHandler
init|=
name|TxnUtils
operator|.
name|getTxnStore
argument_list|(
name|hiveConf
argument_list|)
decl_stmt|;
name|OpenTxnsResponse
name|openTxnsResponse
init|=
name|txnHandler
operator|.
name|openTxns
argument_list|(
operator|new
name|OpenTxnRequest
argument_list|(
literal|3
argument_list|,
literal|"me"
argument_list|,
literal|"localhost"
argument_list|)
argument_list|)
decl_stmt|;
name|AcidOpenTxnsCounterService
name|openTxnsCounterService
init|=
operator|new
name|AcidOpenTxnsCounterService
argument_list|()
decl_stmt|;
name|runHouseKeeperService
argument_list|(
name|openTxnsCounterService
argument_list|,
name|hiveConf
argument_list|)
expr_stmt|;
comment|// will update current number of open txns to 3
name|MetaException
name|exception
init|=
literal|null
decl_stmt|;
comment|// This should fail once it finds out the threshold has been reached
try|try
block|{
name|txnHandler
operator|.
name|openTxns
argument_list|(
operator|new
name|OpenTxnRequest
argument_list|(
literal|1
argument_list|,
literal|"you"
argument_list|,
literal|"localhost"
argument_list|)
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|MetaException
name|e
parameter_list|)
block|{
name|exception
operator|=
name|e
expr_stmt|;
block|}
name|Assert
operator|.
name|assertNotNull
argument_list|(
literal|"Opening new transaction shouldn't be allowed"
argument_list|,
name|exception
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertTrue
argument_list|(
name|exception
operator|.
name|getMessage
argument_list|()
operator|.
name|equals
argument_list|(
literal|"Maximum allowed number of open transactions has been reached. See hive.max.open.txns."
argument_list|)
argument_list|)
expr_stmt|;
comment|// After committing the initial txns, and updating current number of open txns back to 0,
comment|// new transactions should be allowed to open
for|for
control|(
name|long
name|txnid
range|:
name|openTxnsResponse
operator|.
name|getTxn_ids
argument_list|()
control|)
block|{
name|txnHandler
operator|.
name|commitTxn
argument_list|(
operator|new
name|CommitTxnRequest
argument_list|(
name|txnid
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|runHouseKeeperService
argument_list|(
name|openTxnsCounterService
argument_list|,
name|hiveConf
argument_list|)
expr_stmt|;
comment|// will update current number of open txns back to 0
name|exception
operator|=
literal|null
expr_stmt|;
try|try
block|{
name|txnHandler
operator|.
name|openTxns
argument_list|(
operator|new
name|OpenTxnRequest
argument_list|(
literal|1
argument_list|,
literal|"him"
argument_list|,
literal|"localhost"
argument_list|)
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|MetaException
name|e
parameter_list|)
block|{
name|exception
operator|=
name|e
expr_stmt|;
block|}
name|Assert
operator|.
name|assertNull
argument_list|(
name|exception
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testCompactWithDelete
parameter_list|()
throws|throws
name|Exception
block|{
name|int
index|[]
index|[]
name|tableData
init|=
block|{
block|{
literal|1
block|,
literal|2
block|}
block|,
block|{
literal|3
block|,
literal|4
block|}
block|}
decl_stmt|;
name|runStatementOnDriver
argument_list|(
literal|"insert into "
operator|+
name|Table
operator|.
name|ACIDTBL
operator|+
literal|"(a,b) "
operator|+
name|makeValuesClause
argument_list|(
name|tableData
argument_list|)
argument_list|)
expr_stmt|;
name|runStatementOnDriver
argument_list|(
literal|"alter table "
operator|+
name|Table
operator|.
name|ACIDTBL
operator|+
literal|" compact 'MAJOR'"
argument_list|)
expr_stmt|;
name|Worker
name|t
init|=
operator|new
name|Worker
argument_list|()
decl_stmt|;
name|t
operator|.
name|setThreadId
argument_list|(
operator|(
name|int
operator|)
name|t
operator|.
name|getId
argument_list|()
argument_list|)
expr_stmt|;
name|t
operator|.
name|setHiveConf
argument_list|(
name|hiveConf
argument_list|)
expr_stmt|;
name|AtomicBoolean
name|stop
init|=
operator|new
name|AtomicBoolean
argument_list|()
decl_stmt|;
name|AtomicBoolean
name|looped
init|=
operator|new
name|AtomicBoolean
argument_list|()
decl_stmt|;
name|stop
operator|.
name|set
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|t
operator|.
name|init
argument_list|(
name|stop
argument_list|,
name|looped
argument_list|)
expr_stmt|;
name|t
operator|.
name|run
argument_list|()
expr_stmt|;
name|runStatementOnDriver
argument_list|(
literal|"delete from "
operator|+
name|Table
operator|.
name|ACIDTBL
operator|+
literal|" where b = 4"
argument_list|)
expr_stmt|;
name|runStatementOnDriver
argument_list|(
literal|"update "
operator|+
name|Table
operator|.
name|ACIDTBL
operator|+
literal|" set b = -2 where b = 2"
argument_list|)
expr_stmt|;
name|runStatementOnDriver
argument_list|(
literal|"alter table "
operator|+
name|Table
operator|.
name|ACIDTBL
operator|+
literal|" compact 'MINOR'"
argument_list|)
expr_stmt|;
name|t
operator|.
name|run
argument_list|()
expr_stmt|;
name|TxnStore
name|txnHandler
init|=
name|TxnUtils
operator|.
name|getTxnStore
argument_list|(
name|hiveConf
argument_list|)
decl_stmt|;
name|ShowCompactResponse
name|resp
init|=
name|txnHandler
operator|.
name|showCompact
argument_list|(
operator|new
name|ShowCompactRequest
argument_list|()
argument_list|)
decl_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
literal|"Unexpected number of compactions in history"
argument_list|,
literal|2
argument_list|,
name|resp
operator|.
name|getCompactsSize
argument_list|()
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
literal|"Unexpected 0 compaction state"
argument_list|,
name|TxnStore
operator|.
name|CLEANING_RESPONSE
argument_list|,
name|resp
operator|.
name|getCompacts
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|getState
argument_list|()
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
literal|"Unexpected 1 compaction state"
argument_list|,
name|TxnStore
operator|.
name|CLEANING_RESPONSE
argument_list|,
name|resp
operator|.
name|getCompacts
argument_list|()
operator|.
name|get
argument_list|(
literal|1
argument_list|)
operator|.
name|getState
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/**    * make sure Aborted txns don't red-flag a base_xxxx (HIVE-14350)    */
annotation|@
name|Test
specifier|public
name|void
name|testNoHistory
parameter_list|()
throws|throws
name|Exception
block|{
name|int
index|[]
index|[]
name|tableData
init|=
block|{
block|{
literal|1
block|,
literal|2
block|}
block|,
block|{
literal|3
block|,
literal|4
block|}
block|}
decl_stmt|;
name|runStatementOnDriver
argument_list|(
literal|"insert into "
operator|+
name|Table
operator|.
name|ACIDTBL
operator|+
literal|"(a,b) "
operator|+
name|makeValuesClause
argument_list|(
name|tableData
argument_list|)
argument_list|)
expr_stmt|;
name|hiveConf
operator|.
name|setBoolVar
argument_list|(
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVETESTMODEROLLBACKTXN
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|runStatementOnDriver
argument_list|(
literal|"insert into "
operator|+
name|Table
operator|.
name|ACIDTBL
operator|+
literal|"(a,b) "
operator|+
name|makeValuesClause
argument_list|(
name|tableData
argument_list|)
argument_list|)
expr_stmt|;
name|hiveConf
operator|.
name|setBoolVar
argument_list|(
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVETESTMODEROLLBACKTXN
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|runStatementOnDriver
argument_list|(
literal|"alter table "
operator|+
name|Table
operator|.
name|ACIDTBL
operator|+
literal|" compact 'MAJOR'"
argument_list|)
expr_stmt|;
name|runWorker
argument_list|(
name|hiveConf
argument_list|)
expr_stmt|;
name|runCleaner
argument_list|(
name|hiveConf
argument_list|)
expr_stmt|;
name|runStatementOnDriver
argument_list|(
literal|"select count(*) from "
operator|+
name|Table
operator|.
name|ACIDTBL
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testACIDwithSchemaEvolutionAndCompaction
parameter_list|()
throws|throws
name|Exception
block|{
name|testACIDwithSchemaEvolutionForVariousTblProperties
argument_list|(
literal|"'transactional'='true'"
argument_list|)
expr_stmt|;
block|}
specifier|protected
name|void
name|testACIDwithSchemaEvolutionForVariousTblProperties
parameter_list|(
name|String
name|tblProperties
parameter_list|)
throws|throws
name|Exception
block|{
name|String
name|tblName
init|=
literal|"acidWithSchemaEvol"
decl_stmt|;
name|int
name|numBuckets
init|=
literal|1
decl_stmt|;
name|runStatementOnDriver
argument_list|(
literal|"drop table if exists "
operator|+
name|tblName
argument_list|)
expr_stmt|;
name|runStatementOnDriver
argument_list|(
literal|"CREATE TABLE "
operator|+
name|tblName
operator|+
literal|"(a INT, b STRING) "
operator|+
literal|" CLUSTERED BY(a) INTO "
operator|+
name|numBuckets
operator|+
literal|" BUCKETS"
operator|+
comment|//currently ACID requires table to be bucketed
literal|" STORED AS ORC  TBLPROPERTIES ( "
operator|+
name|tblProperties
operator|+
literal|" )"
argument_list|)
expr_stmt|;
comment|// create some data
name|runStatementOnDriver
argument_list|(
literal|"insert into "
operator|+
name|tblName
operator|+
literal|" values(1, 'foo'),(2, 'bar'),(3, 'baz')"
argument_list|)
expr_stmt|;
name|runStatementOnDriver
argument_list|(
literal|"update "
operator|+
name|tblName
operator|+
literal|" set b = 'blah' where a = 3"
argument_list|)
expr_stmt|;
comment|// apply schema evolution by adding some columns
name|runStatementOnDriver
argument_list|(
literal|"alter table "
operator|+
name|tblName
operator|+
literal|" add columns(c int, d string)"
argument_list|)
expr_stmt|;
comment|// insert some data in new schema
name|runStatementOnDriver
argument_list|(
literal|"insert into "
operator|+
name|tblName
operator|+
literal|" values(4, 'acid', 100, 'orc'),"
operator|+
literal|"(5, 'llap', 200, 'tez')"
argument_list|)
expr_stmt|;
comment|// update old data with values for the new schema columns
name|runStatementOnDriver
argument_list|(
literal|"update "
operator|+
name|tblName
operator|+
literal|" set d = 'hive' where a<= 3"
argument_list|)
expr_stmt|;
name|runStatementOnDriver
argument_list|(
literal|"update "
operator|+
name|tblName
operator|+
literal|" set c = 999 where a<= 3"
argument_list|)
expr_stmt|;
comment|// read the entire data back and see if did everything right
name|List
argument_list|<
name|String
argument_list|>
name|rs
init|=
name|runStatementOnDriver
argument_list|(
literal|"select * from "
operator|+
name|tblName
operator|+
literal|" order by a"
argument_list|)
decl_stmt|;
name|String
index|[]
name|expectedResult
init|=
block|{
literal|"1\tfoo\t999\thive"
block|,
literal|"2\tbar\t999\thive"
block|,
literal|"3\tblah\t999\thive"
block|,
literal|"4\tacid\t100\torc"
block|,
literal|"5\tllap\t200\ttez"
block|}
decl_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
name|Arrays
operator|.
name|asList
argument_list|(
name|expectedResult
argument_list|)
argument_list|,
name|rs
argument_list|)
expr_stmt|;
comment|// now compact and see if compaction still preserves the data correctness
name|runStatementOnDriver
argument_list|(
literal|"alter table "
operator|+
name|tblName
operator|+
literal|" compact 'MAJOR'"
argument_list|)
expr_stmt|;
name|runWorker
argument_list|(
name|hiveConf
argument_list|)
expr_stmt|;
name|runCleaner
argument_list|(
name|hiveConf
argument_list|)
expr_stmt|;
comment|// Cleaner would remove the obsolete files.
comment|// Verify that there is now only 1 new directory: base_xxxxxxx and the rest have have been cleaned.
name|FileSystem
name|fs
init|=
name|FileSystem
operator|.
name|get
argument_list|(
name|hiveConf
argument_list|)
decl_stmt|;
name|FileStatus
index|[]
name|status
decl_stmt|;
name|status
operator|=
name|fs
operator|.
name|listStatus
argument_list|(
operator|new
name|Path
argument_list|(
name|TEST_WAREHOUSE_DIR
operator|+
literal|"/"
operator|+
name|tblName
operator|.
name|toString
argument_list|()
operator|.
name|toLowerCase
argument_list|()
argument_list|)
argument_list|,
name|FileUtils
operator|.
name|STAGING_DIR_PATH_FILTER
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
literal|1
argument_list|,
name|status
operator|.
name|length
argument_list|)
expr_stmt|;
name|boolean
name|sawNewBase
init|=
literal|false
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|status
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|status
index|[
name|i
index|]
operator|.
name|getPath
argument_list|()
operator|.
name|getName
argument_list|()
operator|.
name|matches
argument_list|(
literal|"base_.*"
argument_list|)
condition|)
block|{
name|sawNewBase
operator|=
literal|true
expr_stmt|;
name|FileStatus
index|[]
name|buckets
init|=
name|fs
operator|.
name|listStatus
argument_list|(
name|status
index|[
name|i
index|]
operator|.
name|getPath
argument_list|()
argument_list|,
name|FileUtils
operator|.
name|STAGING_DIR_PATH_FILTER
argument_list|)
decl_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
name|numBuckets
argument_list|,
name|buckets
operator|.
name|length
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertTrue
argument_list|(
name|buckets
index|[
literal|0
index|]
operator|.
name|getPath
argument_list|()
operator|.
name|getName
argument_list|()
operator|.
name|matches
argument_list|(
literal|"bucket_00000"
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|Assert
operator|.
name|assertTrue
argument_list|(
name|sawNewBase
argument_list|)
expr_stmt|;
name|rs
operator|=
name|runStatementOnDriver
argument_list|(
literal|"select * from "
operator|+
name|tblName
operator|+
literal|" order by a"
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
name|Arrays
operator|.
name|asList
argument_list|(
name|expectedResult
argument_list|)
argument_list|,
name|rs
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testETLSplitStrategyForACID
parameter_list|()
throws|throws
name|Exception
block|{
name|hiveConf
operator|.
name|setVar
argument_list|(
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVE_ORC_SPLIT_STRATEGY
argument_list|,
literal|"ETL"
argument_list|)
expr_stmt|;
name|hiveConf
operator|.
name|setBoolVar
argument_list|(
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVEOPTINDEXFILTER
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|runStatementOnDriver
argument_list|(
literal|"insert into "
operator|+
name|Table
operator|.
name|ACIDTBL
operator|+
literal|" values(1,2)"
argument_list|)
expr_stmt|;
name|runStatementOnDriver
argument_list|(
literal|"alter table "
operator|+
name|Table
operator|.
name|ACIDTBL
operator|+
literal|" compact 'MAJOR'"
argument_list|)
expr_stmt|;
name|runWorker
argument_list|(
name|hiveConf
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|rs
init|=
name|runStatementOnDriver
argument_list|(
literal|"select * from "
operator|+
name|Table
operator|.
name|ACIDTBL
operator|+
literal|" where a = 1"
argument_list|)
decl_stmt|;
name|int
index|[]
index|[]
name|resultData
init|=
operator|new
name|int
index|[]
index|[]
block|{
block|{
literal|1
block|,
literal|2
block|}
block|}
decl_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
name|stringifyValues
argument_list|(
name|resultData
argument_list|)
argument_list|,
name|rs
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testAcidWithSchemaEvolution
parameter_list|()
throws|throws
name|Exception
block|{
name|hiveConf
operator|.
name|setVar
argument_list|(
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVE_ORC_SPLIT_STRATEGY
argument_list|,
literal|"ETL"
argument_list|)
expr_stmt|;
name|String
name|tblName
init|=
literal|"acidTblWithSchemaEvol"
decl_stmt|;
name|runStatementOnDriver
argument_list|(
literal|"drop table if exists "
operator|+
name|tblName
argument_list|)
expr_stmt|;
name|runStatementOnDriver
argument_list|(
literal|"CREATE TABLE "
operator|+
name|tblName
operator|+
literal|"(a INT, b STRING) "
operator|+
literal|" CLUSTERED BY(a) INTO 2 BUCKETS"
operator|+
comment|//currently ACID requires table to be bucketed
literal|" STORED AS ORC TBLPROPERTIES ('transactional'='true')"
argument_list|)
expr_stmt|;
name|runStatementOnDriver
argument_list|(
literal|"INSERT INTO "
operator|+
name|tblName
operator|+
literal|" VALUES (1, 'foo'), (2, 'bar')"
argument_list|)
expr_stmt|;
comment|// Major compact to create a base that has ACID schema.
name|runStatementOnDriver
argument_list|(
literal|"ALTER TABLE "
operator|+
name|tblName
operator|+
literal|" COMPACT 'MAJOR'"
argument_list|)
expr_stmt|;
name|runWorker
argument_list|(
name|hiveConf
argument_list|)
expr_stmt|;
comment|// Alter table for perform schema evolution.
name|runStatementOnDriver
argument_list|(
literal|"ALTER TABLE "
operator|+
name|tblName
operator|+
literal|" ADD COLUMNS(c int)"
argument_list|)
expr_stmt|;
comment|// Validate there is an added NULL for column c.
name|List
argument_list|<
name|String
argument_list|>
name|rs
init|=
name|runStatementOnDriver
argument_list|(
literal|"SELECT * FROM "
operator|+
name|tblName
operator|+
literal|" ORDER BY a"
argument_list|)
decl_stmt|;
name|String
index|[]
name|expectedResult
init|=
block|{
literal|"1\tfoo\tNULL"
block|,
literal|"2\tbar\tNULL"
block|}
decl_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
name|Arrays
operator|.
name|asList
argument_list|(
name|expectedResult
argument_list|)
argument_list|,
name|rs
argument_list|)
expr_stmt|;
block|}
comment|/**    * Test that ACID works with multi-insert statement    */
annotation|@
name|Test
specifier|public
name|void
name|testMultiInsertStatement
parameter_list|()
throws|throws
name|Exception
block|{
name|int
index|[]
index|[]
name|sourceValsOdd
init|=
block|{
block|{
literal|5
block|,
literal|5
block|}
block|,
block|{
literal|11
block|,
literal|11
block|}
block|}
decl_stmt|;
name|int
index|[]
index|[]
name|sourceValsEven
init|=
block|{
block|{
literal|2
block|,
literal|2
block|}
block|}
decl_stmt|;
comment|//populate source
name|runStatementOnDriver
argument_list|(
literal|"insert into "
operator|+
name|Table
operator|.
name|NONACIDPART2
operator|+
literal|" PARTITION(p2='odd') "
operator|+
name|makeValuesClause
argument_list|(
name|sourceValsOdd
argument_list|)
argument_list|)
expr_stmt|;
name|runStatementOnDriver
argument_list|(
literal|"insert into "
operator|+
name|Table
operator|.
name|NONACIDPART2
operator|+
literal|" PARTITION(p2='even') "
operator|+
name|makeValuesClause
argument_list|(
name|sourceValsEven
argument_list|)
argument_list|)
expr_stmt|;
name|int
index|[]
index|[]
name|targetValsOdd
init|=
block|{
block|{
literal|5
block|,
literal|6
block|}
block|,
block|{
literal|7
block|,
literal|8
block|}
block|}
decl_stmt|;
name|int
index|[]
index|[]
name|targetValsEven
init|=
block|{
block|{
literal|2
block|,
literal|1
block|}
block|,
block|{
literal|4
block|,
literal|3
block|}
block|}
decl_stmt|;
comment|//populate target
name|runStatementOnDriver
argument_list|(
literal|"insert into "
operator|+
name|Table
operator|.
name|ACIDTBLPART
operator|+
literal|" PARTITION(p='odd') "
operator|+
name|makeValuesClause
argument_list|(
name|targetValsOdd
argument_list|)
argument_list|)
expr_stmt|;
name|runStatementOnDriver
argument_list|(
literal|"insert into "
operator|+
name|Table
operator|.
name|ACIDTBLPART
operator|+
literal|" PARTITION(p='even') "
operator|+
name|makeValuesClause
argument_list|(
name|targetValsEven
argument_list|)
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|r
init|=
name|runStatementOnDriver
argument_list|(
literal|"select a,b from "
operator|+
name|Table
operator|.
name|ACIDTBLPART
operator|+
literal|" order by a,b"
argument_list|)
decl_stmt|;
name|int
index|[]
index|[]
name|targetVals
init|=
block|{
block|{
literal|2
block|,
literal|1
block|}
block|,
block|{
literal|4
block|,
literal|3
block|}
block|,
block|{
literal|5
block|,
literal|6
block|}
block|,
block|{
literal|7
block|,
literal|8
block|}
block|}
decl_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
name|stringifyValues
argument_list|(
name|targetVals
argument_list|)
argument_list|,
name|r
argument_list|)
expr_stmt|;
comment|//currently multi-insrt doesn't allow same table/partition in> 1 output branch
name|String
name|s
init|=
literal|"from "
operator|+
name|Table
operator|.
name|ACIDTBLPART
operator|+
literal|"  target right outer join "
operator|+
name|Table
operator|.
name|NONACIDPART2
operator|+
literal|" source on target.a = source.a2 "
operator|+
literal|" INSERT INTO TABLE "
operator|+
name|Table
operator|.
name|ACIDTBLPART
operator|+
literal|" PARTITION(p='even') select source.a2, source.b2 where source.a2=target.a "
operator|+
literal|" insert into table "
operator|+
name|Table
operator|.
name|ACIDTBLPART
operator|+
literal|" PARTITION(p='odd') select source.a2,source.b2 where target.a is null"
decl_stmt|;
comment|//r = runStatementOnDriver("explain formatted " + s);
comment|//LOG.info("Explain formatted: " + r.toString());
name|runStatementOnDriver
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|r
operator|=
name|runStatementOnDriver
argument_list|(
literal|"select a,b from "
operator|+
name|Table
operator|.
name|ACIDTBLPART
operator|+
literal|" where p='even' order by a,b"
argument_list|)
expr_stmt|;
name|int
index|[]
index|[]
name|rExpected
init|=
block|{
block|{
literal|2
block|,
literal|1
block|}
block|,
block|{
literal|2
block|,
literal|2
block|}
block|,
block|{
literal|4
block|,
literal|3
block|}
block|,
block|{
literal|5
block|,
literal|5
block|}
block|}
decl_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
name|stringifyValues
argument_list|(
name|rExpected
argument_list|)
argument_list|,
name|r
argument_list|)
expr_stmt|;
name|r
operator|=
name|runStatementOnDriver
argument_list|(
literal|"select a,b from "
operator|+
name|Table
operator|.
name|ACIDTBLPART
operator|+
literal|" where p='odd' order by a,b"
argument_list|)
expr_stmt|;
name|int
index|[]
index|[]
name|rExpected2
init|=
block|{
block|{
literal|5
block|,
literal|6
block|}
block|,
block|{
literal|7
block|,
literal|8
block|}
block|,
block|{
literal|11
block|,
literal|11
block|}
block|}
decl_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
name|stringifyValues
argument_list|(
name|rExpected2
argument_list|)
argument_list|,
name|r
argument_list|)
expr_stmt|;
block|}
comment|/**    * check that we can specify insert columns    *    * Need to figure out semantics: what if a row from base expr ends up in both Update and Delete clauses we'll write    * Update event to 1 delta and Delete to another.  Given that we collapse events for same current txn for different stmt ids    * to the latest one, delete will win.    * In Acid 2.0 we'll end up with 2 Delete events for the same PK.  Logically should be OK, but may break Vectorized reader impl.... need to check    *    * 1:M from target to source results in ambiguous write to target - SQL Standard expects an error.  (I have an argument on how    * to solve this with minor mods to Join operator written down somewhere)    *    * Only need 1 Stats task for MERGE (currently we get 1 per branch).    * Should also eliminate Move task - that's a general ACID task    */
specifier|private
name|void
name|logResuts
parameter_list|(
name|List
argument_list|<
name|String
argument_list|>
name|r
parameter_list|,
name|String
name|header
parameter_list|,
name|String
name|prefix
parameter_list|)
block|{
name|LOG
operator|.
name|info
argument_list|(
name|prefix
operator|+
literal|" "
operator|+
name|header
argument_list|)
expr_stmt|;
name|StringBuilder
name|sb
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|int
name|numLines
init|=
literal|0
decl_stmt|;
for|for
control|(
name|String
name|line
range|:
name|r
control|)
block|{
name|numLines
operator|++
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
name|prefix
argument_list|)
operator|.
name|append
argument_list|(
name|line
argument_list|)
operator|.
name|append
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
name|LOG
operator|.
name|info
argument_list|(
name|sb
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
name|prefix
operator|+
literal|" Printed "
operator|+
name|numLines
operator|+
literal|" lines"
argument_list|)
expr_stmt|;
block|}
comment|/**    * This tests that we handle non-trivial ON clause correctly    * @throws Exception    */
annotation|@
name|Test
specifier|public
name|void
name|testMerge
parameter_list|()
throws|throws
name|Exception
block|{
name|int
index|[]
index|[]
name|baseValsOdd
init|=
block|{
block|{
literal|5
block|,
literal|5
block|}
block|,
block|{
literal|11
block|,
literal|11
block|}
block|}
decl_stmt|;
name|runStatementOnDriver
argument_list|(
literal|"insert into "
operator|+
name|Table
operator|.
name|NONACIDPART2
operator|+
literal|" PARTITION(p2='odd') "
operator|+
name|makeValuesClause
argument_list|(
name|baseValsOdd
argument_list|)
argument_list|)
expr_stmt|;
name|int
index|[]
index|[]
name|vals
init|=
block|{
block|{
literal|2
block|,
literal|1
block|}
block|,
block|{
literal|4
block|,
literal|3
block|}
block|,
block|{
literal|5
block|,
literal|6
block|}
block|,
block|{
literal|7
block|,
literal|8
block|}
block|}
decl_stmt|;
name|runStatementOnDriver
argument_list|(
literal|"insert into "
operator|+
name|Table
operator|.
name|ACIDTBL
operator|+
literal|" "
operator|+
name|makeValuesClause
argument_list|(
name|vals
argument_list|)
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|r
init|=
name|runStatementOnDriver
argument_list|(
literal|"select a,b from "
operator|+
name|Table
operator|.
name|ACIDTBL
operator|+
literal|" order by a,b"
argument_list|)
decl_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
name|stringifyValues
argument_list|(
name|vals
argument_list|)
argument_list|,
name|r
argument_list|)
expr_stmt|;
name|String
name|query
init|=
literal|"merge into "
operator|+
name|Table
operator|.
name|ACIDTBL
operator|+
literal|" using "
operator|+
name|Table
operator|.
name|NONACIDPART2
operator|+
literal|" source ON "
operator|+
name|Table
operator|.
name|ACIDTBL
operator|+
literal|".a = a2 and b + 1 = source.b2 + 1 "
operator|+
literal|"WHEN MATCHED THEN UPDATE set b = source.b2 "
operator|+
literal|"WHEN NOT MATCHED THEN INSERT VALUES(source.a2, source.b2)"
decl_stmt|;
name|runStatementOnDriver
argument_list|(
name|query
argument_list|)
expr_stmt|;
name|r
operator|=
name|runStatementOnDriver
argument_list|(
literal|"select a,b from "
operator|+
name|Table
operator|.
name|ACIDTBL
operator|+
literal|" order by a,b"
argument_list|)
expr_stmt|;
name|int
index|[]
index|[]
name|rExpected
init|=
block|{
block|{
literal|2
block|,
literal|1
block|}
block|,
block|{
literal|4
block|,
literal|3
block|}
block|,
block|{
literal|5
block|,
literal|5
block|}
block|,
block|{
literal|5
block|,
literal|6
block|}
block|,
block|{
literal|7
block|,
literal|8
block|}
block|,
block|{
literal|11
block|,
literal|11
block|}
block|}
decl_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
name|stringifyValues
argument_list|(
name|rExpected
argument_list|)
argument_list|,
name|r
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testMergeWithPredicate
parameter_list|()
throws|throws
name|Exception
block|{
name|int
index|[]
index|[]
name|baseValsOdd
init|=
block|{
block|{
literal|2
block|,
literal|2
block|}
block|,
block|{
literal|5
block|,
literal|5
block|}
block|,
block|{
literal|8
block|,
literal|8
block|}
block|,
block|{
literal|11
block|,
literal|11
block|}
block|}
decl_stmt|;
name|runStatementOnDriver
argument_list|(
literal|"insert into "
operator|+
name|Table
operator|.
name|NONACIDPART2
operator|+
literal|" PARTITION(p2='odd') "
operator|+
name|makeValuesClause
argument_list|(
name|baseValsOdd
argument_list|)
argument_list|)
expr_stmt|;
name|int
index|[]
index|[]
name|vals
init|=
block|{
block|{
literal|2
block|,
literal|1
block|}
block|,
block|{
literal|4
block|,
literal|3
block|}
block|,
block|{
literal|5
block|,
literal|6
block|}
block|,
block|{
literal|7
block|,
literal|8
block|}
block|}
decl_stmt|;
name|runStatementOnDriver
argument_list|(
literal|"insert into "
operator|+
name|Table
operator|.
name|ACIDTBL
operator|+
literal|" "
operator|+
name|makeValuesClause
argument_list|(
name|vals
argument_list|)
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|r
init|=
name|runStatementOnDriver
argument_list|(
literal|"select a,b from "
operator|+
name|Table
operator|.
name|ACIDTBL
operator|+
literal|" order by a,b"
argument_list|)
decl_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
name|stringifyValues
argument_list|(
name|vals
argument_list|)
argument_list|,
name|r
argument_list|)
expr_stmt|;
name|String
name|query
init|=
literal|"merge into "
operator|+
name|Table
operator|.
name|ACIDTBL
operator|+
literal|" t using "
operator|+
name|Table
operator|.
name|NONACIDPART2
operator|+
literal|" s ON t.a = s.a2 "
operator|+
literal|"WHEN MATCHED AND t.b between 1 and 3 THEN UPDATE set b = s.b2 "
operator|+
literal|"WHEN NOT MATCHED and s.b2>= 11 THEN INSERT VALUES(s.a2, s.b2)"
decl_stmt|;
name|runStatementOnDriver
argument_list|(
name|query
argument_list|)
expr_stmt|;
name|r
operator|=
name|runStatementOnDriver
argument_list|(
literal|"select a,b from "
operator|+
name|Table
operator|.
name|ACIDTBL
operator|+
literal|" order by a,b"
argument_list|)
expr_stmt|;
name|int
index|[]
index|[]
name|rExpected
init|=
block|{
block|{
literal|2
block|,
literal|2
block|}
block|,
block|{
literal|4
block|,
literal|3
block|}
block|,
block|{
literal|5
block|,
literal|6
block|}
block|,
block|{
literal|7
block|,
literal|8
block|}
block|,
block|{
literal|11
block|,
literal|11
block|}
block|}
decl_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
name|stringifyValues
argument_list|(
name|rExpected
argument_list|)
argument_list|,
name|r
argument_list|)
expr_stmt|;
block|}
comment|/**    * Test combines update + insert clauses    * @throws Exception    */
annotation|@
name|Test
specifier|public
name|void
name|testMerge2
parameter_list|()
throws|throws
name|Exception
block|{
name|int
index|[]
index|[]
name|baseValsOdd
init|=
block|{
block|{
literal|5
block|,
literal|5
block|}
block|,
block|{
literal|11
block|,
literal|11
block|}
block|}
decl_stmt|;
name|int
index|[]
index|[]
name|baseValsEven
init|=
block|{
block|{
literal|2
block|,
literal|2
block|}
block|,
block|{
literal|4
block|,
literal|44
block|}
block|}
decl_stmt|;
name|runStatementOnDriver
argument_list|(
literal|"insert into "
operator|+
name|Table
operator|.
name|NONACIDPART2
operator|+
literal|" PARTITION(p2='odd') "
operator|+
name|makeValuesClause
argument_list|(
name|baseValsOdd
argument_list|)
argument_list|)
expr_stmt|;
name|runStatementOnDriver
argument_list|(
literal|"insert into "
operator|+
name|Table
operator|.
name|NONACIDPART2
operator|+
literal|" PARTITION(p2='even') "
operator|+
name|makeValuesClause
argument_list|(
name|baseValsEven
argument_list|)
argument_list|)
expr_stmt|;
name|int
index|[]
index|[]
name|vals
init|=
block|{
block|{
literal|2
block|,
literal|1
block|}
block|,
block|{
literal|4
block|,
literal|3
block|}
block|,
block|{
literal|5
block|,
literal|6
block|}
block|,
block|{
literal|7
block|,
literal|8
block|}
block|}
decl_stmt|;
name|runStatementOnDriver
argument_list|(
literal|"insert into "
operator|+
name|Table
operator|.
name|ACIDTBL
operator|+
literal|" "
operator|+
name|makeValuesClause
argument_list|(
name|vals
argument_list|)
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|r
init|=
name|runStatementOnDriver
argument_list|(
literal|"select a,b from "
operator|+
name|Table
operator|.
name|ACIDTBL
operator|+
literal|" order by a,b"
argument_list|)
decl_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
name|stringifyValues
argument_list|(
name|vals
argument_list|)
argument_list|,
name|r
argument_list|)
expr_stmt|;
name|String
name|query
init|=
literal|"merge into "
operator|+
name|Table
operator|.
name|ACIDTBL
operator|+
literal|" using "
operator|+
name|Table
operator|.
name|NONACIDPART2
operator|+
literal|" source ON "
operator|+
name|Table
operator|.
name|ACIDTBL
operator|+
literal|".a = source.a2 "
operator|+
literal|"WHEN MATCHED THEN UPDATE set b = source.b2 "
operator|+
literal|"WHEN NOT MATCHED THEN INSERT VALUES(source.a2, source.b2) "
decl_stmt|;
comment|//AND b< 1
name|r
operator|=
name|runStatementOnDriver
argument_list|(
name|query
argument_list|)
expr_stmt|;
comment|//r = runStatementOnDriver("explain  " + query);
comment|//logResuts(r, "Explain logical1", "");
name|r
operator|=
name|runStatementOnDriver
argument_list|(
literal|"select a,b from "
operator|+
name|Table
operator|.
name|ACIDTBL
operator|+
literal|" order by a,b"
argument_list|)
expr_stmt|;
name|int
index|[]
index|[]
name|rExpected
init|=
block|{
block|{
literal|2
block|,
literal|2
block|}
block|,
block|{
literal|4
block|,
literal|44
block|}
block|,
block|{
literal|5
block|,
literal|5
block|}
block|,
block|{
literal|7
block|,
literal|8
block|}
block|,
block|{
literal|11
block|,
literal|11
block|}
block|}
decl_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
name|stringifyValues
argument_list|(
name|rExpected
argument_list|)
argument_list|,
name|r
argument_list|)
expr_stmt|;
block|}
comment|/**    * test combines delete + insert clauses    * @throws Exception    */
annotation|@
name|Test
specifier|public
name|void
name|testMerge3
parameter_list|()
throws|throws
name|Exception
block|{
name|int
index|[]
index|[]
name|baseValsOdd
init|=
block|{
block|{
literal|5
block|,
literal|5
block|}
block|,
block|{
literal|11
block|,
literal|11
block|}
block|}
decl_stmt|;
name|int
index|[]
index|[]
name|baseValsEven
init|=
block|{
block|{
literal|2
block|,
literal|2
block|}
block|,
block|{
literal|4
block|,
literal|44
block|}
block|}
decl_stmt|;
name|runStatementOnDriver
argument_list|(
literal|"insert into "
operator|+
name|Table
operator|.
name|NONACIDPART2
operator|+
literal|" PARTITION(p2='odd') "
operator|+
name|makeValuesClause
argument_list|(
name|baseValsOdd
argument_list|)
argument_list|)
expr_stmt|;
name|runStatementOnDriver
argument_list|(
literal|"insert into "
operator|+
name|Table
operator|.
name|NONACIDPART2
operator|+
literal|" PARTITION(p2='even') "
operator|+
name|makeValuesClause
argument_list|(
name|baseValsEven
argument_list|)
argument_list|)
expr_stmt|;
name|int
index|[]
index|[]
name|vals
init|=
block|{
block|{
literal|2
block|,
literal|1
block|}
block|,
block|{
literal|4
block|,
literal|3
block|}
block|,
block|{
literal|5
block|,
literal|6
block|}
block|,
block|{
literal|7
block|,
literal|8
block|}
block|}
decl_stmt|;
name|runStatementOnDriver
argument_list|(
literal|"insert into "
operator|+
name|Table
operator|.
name|ACIDTBL
operator|+
literal|" "
operator|+
name|makeValuesClause
argument_list|(
name|vals
argument_list|)
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|r
init|=
name|runStatementOnDriver
argument_list|(
literal|"select a,b from "
operator|+
name|Table
operator|.
name|ACIDTBL
operator|+
literal|" order by a,b"
argument_list|)
decl_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
name|stringifyValues
argument_list|(
name|vals
argument_list|)
argument_list|,
name|r
argument_list|)
expr_stmt|;
name|String
name|query
init|=
literal|"merge into "
operator|+
name|Table
operator|.
name|ACIDTBL
operator|+
literal|" using "
operator|+
name|Table
operator|.
name|NONACIDPART2
operator|+
literal|" source ON "
operator|+
name|Table
operator|.
name|ACIDTBL
operator|+
literal|".a = source.a2 "
operator|+
literal|"WHEN MATCHED THEN DELETE "
operator|+
literal|"WHEN NOT MATCHED THEN INSERT VALUES(source.a2, source.b2) "
decl_stmt|;
name|runStatementOnDriver
argument_list|(
name|query
argument_list|)
expr_stmt|;
name|r
operator|=
name|runStatementOnDriver
argument_list|(
literal|"select a,b from "
operator|+
name|Table
operator|.
name|ACIDTBL
operator|+
literal|" order by a,b"
argument_list|)
expr_stmt|;
name|int
index|[]
index|[]
name|rExpected
init|=
block|{
block|{
literal|7
block|,
literal|8
block|}
block|,
block|{
literal|11
block|,
literal|11
block|}
block|}
decl_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
name|stringifyValues
argument_list|(
name|rExpected
argument_list|)
argument_list|,
name|r
argument_list|)
expr_stmt|;
block|}
comment|/**    * https://hortonworks.jira.com/browse/BUG-66580    * @throws Exception    */
annotation|@
name|Ignore
annotation|@
name|Test
specifier|public
name|void
name|testMultiInsert
parameter_list|()
throws|throws
name|Exception
block|{
name|runStatementOnDriver
argument_list|(
literal|"create table if not exists  srcpart (a int, b int, c int) "
operator|+
literal|"partitioned by (z int) clustered by (a) into 2 buckets "
operator|+
literal|"stored as orc tblproperties('transactional'='true')"
argument_list|)
expr_stmt|;
name|runStatementOnDriver
argument_list|(
literal|"create temporary table if not exists data1 (x int)"
argument_list|)
expr_stmt|;
comment|//    runStatementOnDriver("create temporary table if not exists data2 (x int)");
name|runStatementOnDriver
argument_list|(
literal|"insert into data1 values (1),(2),(3)"
argument_list|)
expr_stmt|;
comment|//    runStatementOnDriver("insert into data2 values (4),(5),(6)");
name|d
operator|.
name|destroy
argument_list|()
expr_stmt|;
name|hiveConf
operator|.
name|setVar
argument_list|(
name|HiveConf
operator|.
name|ConfVars
operator|.
name|DYNAMICPARTITIONINGMODE
argument_list|,
literal|"nonstrict"
argument_list|)
expr_stmt|;
name|d
operator|=
operator|new
name|Driver
argument_list|(
name|hiveConf
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|r
init|=
name|runStatementOnDriver
argument_list|(
literal|" from data1 "
operator|+
literal|"insert into srcpart partition(z) select 0,0,1,x  "
operator|+
literal|"insert into srcpart partition(z=1) select 0,0,1"
argument_list|)
decl_stmt|;
block|}
comment|/**    * Investigating DP and WriteEntity, etc    * @throws Exception    */
annotation|@
name|Test
annotation|@
name|Ignore
specifier|public
name|void
name|testDynamicPartitions
parameter_list|()
throws|throws
name|Exception
block|{
name|d
operator|.
name|destroy
argument_list|()
expr_stmt|;
name|hiveConf
operator|.
name|setVar
argument_list|(
name|HiveConf
operator|.
name|ConfVars
operator|.
name|DYNAMICPARTITIONINGMODE
argument_list|,
literal|"nonstrict"
argument_list|)
expr_stmt|;
comment|//In DbTxnManager.acquireLocks() we have
comment|// 1 ReadEntity: default@values__tmp__table__1
comment|// 1 WriteEntity: default@acidtblpart Type=TABLE WriteType=INSERT isDP=false
name|runStatementOnDriver
argument_list|(
literal|"insert into "
operator|+
name|Table
operator|.
name|ACIDTBLPART
operator|+
literal|" partition(p) values(1,1,'p1'),(2,2,'p1'),(3,3,'p1'),(4,4,'p2')"
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|r1
init|=
name|runStatementOnDriver
argument_list|(
literal|"select count(*) from "
operator|+
name|Table
operator|.
name|ACIDTBLPART
argument_list|)
decl_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
literal|"4"
argument_list|,
name|r1
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
comment|//In DbTxnManager.acquireLocks() we have
comment|// 2 ReadEntity: [default@acidtblpart@p=p1, default@acidtblpart]
comment|// 1 WriteEntity: default@acidtblpart Type=TABLE WriteType=INSERT isDP=false
comment|//todo: side note on the above: LockRequestBuilder combines the both default@acidtblpart entries to 1
name|runStatementOnDriver
argument_list|(
literal|"insert into "
operator|+
name|Table
operator|.
name|ACIDTBLPART
operator|+
literal|" partition(p) select * from "
operator|+
name|Table
operator|.
name|ACIDTBLPART
operator|+
literal|" where p='p1'"
argument_list|)
expr_stmt|;
comment|//In DbTxnManager.acquireLocks() we have
comment|// 2 ReadEntity: [default@acidtblpart@p=p1, default@acidtblpart]
comment|// 1 WriteEntity: default@acidtblpart@p=p2 Type=PARTITION WriteType=INSERT isDP=false
name|runStatementOnDriver
argument_list|(
literal|"insert into "
operator|+
name|Table
operator|.
name|ACIDTBLPART
operator|+
literal|" partition(p='p2') select a,b from "
operator|+
name|Table
operator|.
name|ACIDTBLPART
operator|+
literal|" where p='p1'"
argument_list|)
expr_stmt|;
comment|//In UpdateDeleteSemanticAnalyzer, after super analyze
comment|// 3 ReadEntity: [default@acidtblpart, default@acidtblpart@p=p1, default@acidtblpart@p=p2]
comment|// 1 WriteEntity: [default@acidtblpart TABLE/INSERT]
comment|//after UDSA
comment|// Read [default@acidtblpart, default@acidtblpart@p=p1, default@acidtblpart@p=p2]
comment|// Write [default@acidtblpart@p=p1, default@acidtblpart@p=p2] - PARTITION/UPDATE, PARTITION/UPDATE
comment|//todo: Why acquire per partition locks - if you have many partitions that's hugely inefficient.
comment|//could acquire 1 table level Shared_write intead
name|runStatementOnDriver
argument_list|(
literal|"update "
operator|+
name|Table
operator|.
name|ACIDTBLPART
operator|+
literal|" set b = 1"
argument_list|)
expr_stmt|;
comment|//In UpdateDeleteSemanticAnalyzer, after super analyze
comment|// Read [default@acidtblpart, default@acidtblpart@p=p1]
comment|// Write default@acidtblpart TABLE/INSERT
comment|//after UDSA
comment|// Read [default@acidtblpart, default@acidtblpart@p=p1]
comment|// Write [default@acidtblpart@p=p1] PARTITION/UPDATE
comment|//todo: this causes a Read lock on the whole table - clearly overkill
comment|//for Update/Delete we always write exactly (at most actually) the partitions we read
name|runStatementOnDriver
argument_list|(
literal|"update "
operator|+
name|Table
operator|.
name|ACIDTBLPART
operator|+
literal|" set b = 1 where p='p1'"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testDynamicPartitionsMerge
parameter_list|()
throws|throws
name|Exception
block|{
name|d
operator|.
name|destroy
argument_list|()
expr_stmt|;
name|hiveConf
operator|.
name|setVar
argument_list|(
name|HiveConf
operator|.
name|ConfVars
operator|.
name|DYNAMICPARTITIONINGMODE
argument_list|,
literal|"nonstrict"
argument_list|)
expr_stmt|;
name|runStatementOnDriver
argument_list|(
literal|"insert into "
operator|+
name|Table
operator|.
name|ACIDTBLPART
operator|+
literal|" partition(p) values(1,1,'p1'),(2,2,'p1'),(3,3,'p1'),(4,4,'p2')"
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|r1
init|=
name|runStatementOnDriver
argument_list|(
literal|"select count(*) from "
operator|+
name|Table
operator|.
name|ACIDTBLPART
argument_list|)
decl_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
literal|"4"
argument_list|,
name|r1
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|int
index|[]
index|[]
name|sourceVals
init|=
block|{
block|{
literal|2
block|,
literal|15
block|}
block|,
block|{
literal|4
block|,
literal|44
block|}
block|,
block|{
literal|5
block|,
literal|5
block|}
block|,
block|{
literal|11
block|,
literal|11
block|}
block|}
decl_stmt|;
name|runStatementOnDriver
argument_list|(
literal|"insert into "
operator|+
name|Table
operator|.
name|NONACIDORCTBL
operator|+
literal|" "
operator|+
name|makeValuesClause
argument_list|(
name|sourceVals
argument_list|)
argument_list|)
expr_stmt|;
name|runStatementOnDriver
argument_list|(
literal|"merge into "
operator|+
name|Table
operator|.
name|ACIDTBLPART
operator|+
literal|" using "
operator|+
name|Table
operator|.
name|NONACIDORCTBL
operator|+
literal|" as s ON "
operator|+
name|Table
operator|.
name|ACIDTBLPART
operator|+
literal|".a = s.a "
operator|+
literal|"when matched then update set b = s.b "
operator|+
literal|"when not matched then insert values(s.a, s.b, 'new part')"
argument_list|)
expr_stmt|;
name|r1
operator|=
name|runStatementOnDriver
argument_list|(
literal|"select p,a,b from "
operator|+
name|Table
operator|.
name|ACIDTBLPART
operator|+
literal|" order by p, a, b"
argument_list|)
expr_stmt|;
name|String
name|result
init|=
name|r1
operator|.
name|toString
argument_list|()
decl_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
literal|"[new part\t5\t5, new part\t11\t11, p1\t1\t1, p1\t2\t15, p1\t3\t3, p2\t4\t44]"
argument_list|,
name|result
argument_list|)
expr_stmt|;
block|}
comment|/**    * Using nested partitions and thus DummyPartition    * @throws Exception    */
annotation|@
name|Test
specifier|public
name|void
name|testDynamicPartitionsMerge2
parameter_list|()
throws|throws
name|Exception
block|{
name|d
operator|.
name|destroy
argument_list|()
expr_stmt|;
name|hiveConf
operator|.
name|setVar
argument_list|(
name|HiveConf
operator|.
name|ConfVars
operator|.
name|DYNAMICPARTITIONINGMODE
argument_list|,
literal|"nonstrict"
argument_list|)
expr_stmt|;
name|int
index|[]
index|[]
name|targetVals
init|=
block|{
block|{
literal|1
block|,
literal|1
block|,
literal|1
block|}
block|,
block|{
literal|2
block|,
literal|2
block|,
literal|2
block|}
block|,
block|{
literal|3
block|,
literal|3
block|,
literal|1
block|}
block|,
block|{
literal|4
block|,
literal|4
block|,
literal|2
block|}
block|}
decl_stmt|;
name|runStatementOnDriver
argument_list|(
literal|"insert into "
operator|+
name|Table
operator|.
name|ACIDNESTEDPART
operator|+
literal|" partition(p=1,q) "
operator|+
name|makeValuesClause
argument_list|(
name|targetVals
argument_list|)
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|r1
init|=
name|runStatementOnDriver
argument_list|(
literal|"select count(*) from "
operator|+
name|Table
operator|.
name|ACIDNESTEDPART
argument_list|)
decl_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
literal|"4"
argument_list|,
name|r1
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|int
index|[]
index|[]
name|sourceVals
init|=
block|{
block|{
literal|2
block|,
literal|15
block|}
block|,
block|{
literal|4
block|,
literal|44
block|}
block|,
block|{
literal|5
block|,
literal|5
block|}
block|,
block|{
literal|11
block|,
literal|11
block|}
block|}
decl_stmt|;
name|runStatementOnDriver
argument_list|(
literal|"insert into "
operator|+
name|Table
operator|.
name|NONACIDORCTBL
operator|+
literal|" "
operator|+
name|makeValuesClause
argument_list|(
name|sourceVals
argument_list|)
argument_list|)
expr_stmt|;
name|runStatementOnDriver
argument_list|(
literal|"merge into "
operator|+
name|Table
operator|.
name|ACIDNESTEDPART
operator|+
literal|" using "
operator|+
name|Table
operator|.
name|NONACIDORCTBL
operator|+
literal|" as s ON "
operator|+
name|Table
operator|.
name|ACIDNESTEDPART
operator|+
literal|".a = s.a "
operator|+
literal|"when matched then update set b = s.b "
operator|+
literal|"when not matched then insert values(s.a, s.b, 3,4)"
argument_list|)
expr_stmt|;
name|r1
operator|=
name|runStatementOnDriver
argument_list|(
literal|"select p,q,a,b from "
operator|+
name|Table
operator|.
name|ACIDNESTEDPART
operator|+
literal|" order by p,q, a, b"
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
name|stringifyValues
argument_list|(
operator|new
name|int
index|[]
index|[]
block|{
block|{
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|}
block|,
block|{
literal|1
block|,
literal|1
block|,
literal|3
block|,
literal|3
block|}
block|,
block|{
literal|1
block|,
literal|2
block|,
literal|2
block|,
literal|15
block|}
block|,
block|{
literal|1
block|,
literal|2
block|,
literal|4
block|,
literal|44
block|}
block|,
block|{
literal|3
block|,
literal|4
block|,
literal|5
block|,
literal|5
block|}
block|,
block|{
literal|3
block|,
literal|4
block|,
literal|11
block|,
literal|11
block|}
block|}
argument_list|)
argument_list|,
name|r1
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Ignore
argument_list|(
literal|"Covered elsewhere"
argument_list|)
annotation|@
name|Test
specifier|public
name|void
name|testMergeAliasedTarget
parameter_list|()
throws|throws
name|Exception
block|{
name|int
index|[]
index|[]
name|baseValsOdd
init|=
block|{
block|{
literal|2
block|,
literal|2
block|}
block|,
block|{
literal|4
block|,
literal|44
block|}
block|,
block|{
literal|5
block|,
literal|5
block|}
block|,
block|{
literal|11
block|,
literal|11
block|}
block|}
decl_stmt|;
name|runStatementOnDriver
argument_list|(
literal|"insert into "
operator|+
name|Table
operator|.
name|NONACIDORCTBL
operator|+
literal|" "
operator|+
name|makeValuesClause
argument_list|(
name|baseValsOdd
argument_list|)
argument_list|)
expr_stmt|;
name|int
index|[]
index|[]
name|vals
init|=
block|{
block|{
literal|2
block|,
literal|1
block|}
block|,
block|{
literal|4
block|,
literal|3
block|}
block|,
block|{
literal|5
block|,
literal|6
block|}
block|,
block|{
literal|7
block|,
literal|8
block|}
block|}
decl_stmt|;
name|runStatementOnDriver
argument_list|(
literal|"insert into "
operator|+
name|Table
operator|.
name|ACIDTBL
operator|+
literal|" "
operator|+
name|makeValuesClause
argument_list|(
name|vals
argument_list|)
argument_list|)
expr_stmt|;
name|String
name|query
init|=
literal|"merge into "
operator|+
name|Table
operator|.
name|ACIDTBL
operator|+
literal|" as target using "
operator|+
name|Table
operator|.
name|NONACIDORCTBL
operator|+
literal|" source ON target.a = source.a "
operator|+
literal|"WHEN MATCHED THEN update set b = 0 "
operator|+
literal|"WHEN NOT MATCHED THEN INSERT VALUES(source.a, source.b) "
decl_stmt|;
name|runStatementOnDriver
argument_list|(
name|query
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|r
init|=
name|runStatementOnDriver
argument_list|(
literal|"select a,b from "
operator|+
name|Table
operator|.
name|ACIDTBL
operator|+
literal|" order by a,b"
argument_list|)
decl_stmt|;
name|int
index|[]
index|[]
name|rExpected
init|=
block|{
block|{
literal|2
block|,
literal|0
block|}
block|,
block|{
literal|4
block|,
literal|0
block|}
block|,
block|{
literal|5
block|,
literal|0
block|}
block|,
block|{
literal|7
block|,
literal|8
block|}
block|,
block|{
literal|11
block|,
literal|11
block|}
block|}
decl_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
name|stringifyValues
argument_list|(
name|rExpected
argument_list|)
argument_list|,
name|r
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
annotation|@
name|Ignore
argument_list|(
literal|"Values clause with table constructor not yet supported"
argument_list|)
specifier|public
name|void
name|testValuesSource
parameter_list|()
throws|throws
name|Exception
block|{
name|int
index|[]
index|[]
name|targetVals
init|=
block|{
block|{
literal|2
block|,
literal|1
block|}
block|,
block|{
literal|4
block|,
literal|3
block|}
block|,
block|{
literal|5
block|,
literal|6
block|}
block|,
block|{
literal|7
block|,
literal|8
block|}
block|}
decl_stmt|;
name|runStatementOnDriver
argument_list|(
literal|"insert into "
operator|+
name|Table
operator|.
name|ACIDTBL
operator|+
literal|" "
operator|+
name|makeValuesClause
argument_list|(
name|targetVals
argument_list|)
argument_list|)
expr_stmt|;
name|String
name|query
init|=
literal|"merge into "
operator|+
name|Table
operator|.
name|ACIDTBL
operator|+
literal|" as t using (select * from (values (2,2),(4,44),(5,5),(11,11)) as F(a,b)) s ON t.a = s.a "
operator|+
literal|"WHEN MATCHED and s.a< 5 THEN DELETE "
operator|+
literal|"WHEN MATCHED AND s.a< 3 THEN update set b = 0 "
operator|+
literal|"WHEN NOT MATCHED THEN INSERT VALUES(s.a, s.b) "
decl_stmt|;
name|runStatementOnDriver
argument_list|(
name|query
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|r
init|=
name|runStatementOnDriver
argument_list|(
literal|"select a,b from "
operator|+
name|Table
operator|.
name|ACIDTBL
operator|+
literal|" order by a,b"
argument_list|)
decl_stmt|;
name|int
index|[]
index|[]
name|rExpected
init|=
block|{
block|{
literal|5
block|,
literal|6
block|}
block|,
block|{
literal|7
block|,
literal|8
block|}
block|,
block|{
literal|11
block|,
literal|11
block|}
block|}
decl_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
name|stringifyValues
argument_list|(
name|rExpected
argument_list|)
argument_list|,
name|r
argument_list|)
expr_stmt|;
block|}
comment|/**    * takes raw data and turns it into a string as if from Driver.getResults()    * sorts rows in dictionary order    */
specifier|static
name|List
argument_list|<
name|String
argument_list|>
name|stringifyValues
parameter_list|(
name|int
index|[]
index|[]
name|rowsIn
parameter_list|)
block|{
assert|assert
name|rowsIn
operator|.
name|length
operator|>
literal|0
assert|;
name|int
index|[]
index|[]
name|rows
init|=
name|rowsIn
operator|.
name|clone
argument_list|()
decl_stmt|;
name|Arrays
operator|.
name|sort
argument_list|(
name|rows
argument_list|,
operator|new
name|RowComp
argument_list|()
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|rs
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|int
index|[]
name|row
range|:
name|rows
control|)
block|{
assert|assert
name|row
operator|.
name|length
operator|>
literal|0
assert|;
name|StringBuilder
name|sb
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|value
range|:
name|row
control|)
block|{
name|sb
operator|.
name|append
argument_list|(
name|value
argument_list|)
operator|.
name|append
argument_list|(
literal|"\t"
argument_list|)
expr_stmt|;
block|}
name|sb
operator|.
name|setLength
argument_list|(
name|sb
operator|.
name|length
argument_list|()
operator|-
literal|1
argument_list|)
expr_stmt|;
name|rs
operator|.
name|add
argument_list|(
name|sb
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|rs
return|;
block|}
specifier|private
specifier|static
specifier|final
class|class
name|RowComp
implements|implements
name|Comparator
argument_list|<
name|int
index|[]
argument_list|>
block|{
annotation|@
name|Override
specifier|public
name|int
name|compare
parameter_list|(
name|int
index|[]
name|row1
parameter_list|,
name|int
index|[]
name|row2
parameter_list|)
block|{
assert|assert
name|row1
operator|!=
literal|null
operator|&&
name|row2
operator|!=
literal|null
operator|&&
name|row1
operator|.
name|length
operator|==
name|row2
operator|.
name|length
assert|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|row1
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|int
name|comp
init|=
name|Integer
operator|.
name|compare
argument_list|(
name|row1
index|[
name|i
index|]
argument_list|,
name|row2
index|[
name|i
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
name|comp
operator|!=
literal|0
condition|)
block|{
return|return
name|comp
return|;
block|}
block|}
return|return
literal|0
return|;
block|}
block|}
specifier|private
name|String
name|makeValuesClause
parameter_list|(
name|int
index|[]
index|[]
name|rows
parameter_list|)
block|{
assert|assert
name|rows
operator|.
name|length
operator|>
literal|0
assert|;
name|StringBuilder
name|sb
init|=
operator|new
name|StringBuilder
argument_list|(
literal|"values"
argument_list|)
decl_stmt|;
for|for
control|(
name|int
index|[]
name|row
range|:
name|rows
control|)
block|{
assert|assert
name|row
operator|.
name|length
operator|>
literal|0
assert|;
if|if
condition|(
name|row
operator|.
name|length
operator|>
literal|1
condition|)
block|{
name|sb
operator|.
name|append
argument_list|(
literal|"("
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|int
name|value
range|:
name|row
control|)
block|{
name|sb
operator|.
name|append
argument_list|(
name|value
argument_list|)
operator|.
name|append
argument_list|(
literal|","
argument_list|)
expr_stmt|;
block|}
name|sb
operator|.
name|setLength
argument_list|(
name|sb
operator|.
name|length
argument_list|()
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|//remove trailing comma
if|if
condition|(
name|row
operator|.
name|length
operator|>
literal|1
condition|)
block|{
name|sb
operator|.
name|append
argument_list|(
literal|")"
argument_list|)
expr_stmt|;
block|}
name|sb
operator|.
name|append
argument_list|(
literal|","
argument_list|)
expr_stmt|;
block|}
name|sb
operator|.
name|setLength
argument_list|(
name|sb
operator|.
name|length
argument_list|()
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|//remove trailing comma
return|return
name|sb
operator|.
name|toString
argument_list|()
return|;
block|}
specifier|protected
name|List
argument_list|<
name|String
argument_list|>
name|runStatementOnDriver
parameter_list|(
name|String
name|stmt
parameter_list|)
throws|throws
name|Exception
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"+runStatementOnDriver("
operator|+
name|stmt
operator|+
literal|")"
argument_list|)
expr_stmt|;
name|CommandProcessorResponse
name|cpr
init|=
name|d
operator|.
name|run
argument_list|(
name|stmt
argument_list|)
decl_stmt|;
if|if
condition|(
name|cpr
operator|.
name|getResponseCode
argument_list|()
operator|!=
literal|0
condition|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
name|stmt
operator|+
literal|" failed: "
operator|+
name|cpr
argument_list|)
throw|;
block|}
name|List
argument_list|<
name|String
argument_list|>
name|rs
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
name|d
operator|.
name|getResults
argument_list|(
name|rs
argument_list|)
expr_stmt|;
return|return
name|rs
return|;
block|}
block|}
end_class

end_unit

