begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|vector
operator|.
name|mapjoin
package|;
end_package

begin_import
import|import static
name|org
operator|.
name|junit
operator|.
name|Assert
operator|.
name|assertEquals
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|junit
operator|.
name|Assert
operator|.
name|assertTrue
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|lang
operator|.
name|ArrayUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|conf
operator|.
name|HiveConf
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|CompilationOpContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|MapJoinOperator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|persistence
operator|.
name|MapJoinBytesTableContainer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|persistence
operator|.
name|MapJoinObjectSerDeContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|persistence
operator|.
name|MapJoinTableContainer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|persistence
operator|.
name|MapJoinTableContainerSerDe
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|util
operator|.
name|collectoroperator
operator|.
name|CollectorTestOperator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|util
operator|.
name|collectoroperator
operator|.
name|CountCollectorTestOperator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|util
operator|.
name|collectoroperator
operator|.
name|CountVectorCollectorTestOperator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|util
operator|.
name|collectoroperator
operator|.
name|RowCollectorTestOperatorBase
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|util
operator|.
name|rowobjects
operator|.
name|RowTestObjects
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|util
operator|.
name|rowobjects
operator|.
name|RowTestObjectsMultiSet
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|vector
operator|.
name|BytesColumnVector
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|vector
operator|.
name|ColumnVector
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|vector
operator|.
name|DoubleColumnVector
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|vector
operator|.
name|LongColumnVector
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|vector
operator|.
name|VectorBatchDebug
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|vector
operator|.
name|VectorColumnOutputMapping
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|vector
operator|.
name|VectorColumnSourceMapping
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|vector
operator|.
name|VectorExtractRow
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|vector
operator|.
name|VectorMapJoinOperator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|vector
operator|.
name|VectorMapJoinOuterFilteredOperator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|vector
operator|.
name|VectorRandomBatchSource
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|vector
operator|.
name|VectorRandomRowSource
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|vector
operator|.
name|VectorizationContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|vector
operator|.
name|VectorizationContextRegion
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|vector
operator|.
name|VectorizedBatchUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|vector
operator|.
name|VectorizedRowBatch
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|vector
operator|.
name|VectorizedRowBatchCtx
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|vector
operator|.
name|util
operator|.
name|batchgen
operator|.
name|VectorBatchGenerator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|vector
operator|.
name|util
operator|.
name|batchgen
operator|.
name|VectorBatchGenerator
operator|.
name|GenerateType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|vector
operator|.
name|util
operator|.
name|batchgen
operator|.
name|VectorBatchGenerator
operator|.
name|GenerateType
operator|.
name|GenerateCategory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|vector
operator|.
name|mapjoin
operator|.
name|MapJoinTestConfig
operator|.
name|CreateMapJoinResult
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|vector
operator|.
name|mapjoin
operator|.
name|MapJoinTestConfig
operator|.
name|MapJoinTestImplementation
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|vector
operator|.
name|mapjoin
operator|.
name|MapJoinTestConfig
operator|.
name|TestMultiSetCollectorOperator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|vector
operator|.
name|mapjoin
operator|.
name|MapJoinTestConfig
operator|.
name|TestMultiSetVectorCollectorOperator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|vector
operator|.
name|mapjoin
operator|.
name|MapJoinTestDescription
operator|.
name|MapJoinPlanVariation
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|vector
operator|.
name|mapjoin
operator|.
name|MapJoinTestDescription
operator|.
name|SmallTableGenerationParameters
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|vector
operator|.
name|mapjoin
operator|.
name|MapJoinTestDescription
operator|.
name|SmallTableGenerationParameters
operator|.
name|ValueOption
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|vector
operator|.
name|mapjoin
operator|.
name|fast
operator|.
name|VectorMapJoinFastMultiKeyHashMap
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|vector
operator|.
name|mapjoin
operator|.
name|fast
operator|.
name|VectorMapJoinFastTableContainer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|vector
operator|.
name|mapjoin
operator|.
name|fast
operator|.
name|VerifyFastRow
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|metadata
operator|.
name|HiveException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|ExprNodeColumnDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|ExprNodeDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|ExprNodeGenericFuncDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|JoinCondDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|JoinDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|MapJoinDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|PlanUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|TableDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|VectorMapJoinDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|VectorMapJoinDesc
operator|.
name|HashTableImplementationType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|VectorMapJoinDesc
operator|.
name|HashTableKeyType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|VectorMapJoinDesc
operator|.
name|HashTableKind
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|VectorMapJoinDesc
operator|.
name|VectorMapJoinVariation
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|VectorMapJoinInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|api
operator|.
name|OperatorType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|udf
operator|.
name|generic
operator|.
name|GenericUDFOPEqual
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|AbstractSerDe
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|ByteStream
operator|.
name|Output
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|SerDeException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|SerDeUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|binarysortable
operator|.
name|fast
operator|.
name|BinarySortableSerializeWrite
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|lazybinary
operator|.
name|fast
operator|.
name|LazyBinarySerializeWrite
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|objectinspector
operator|.
name|ObjectInspectorFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|objectinspector
operator|.
name|ObjectInspectorUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|objectinspector
operator|.
name|PrimitiveObjectInspector
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|objectinspector
operator|.
name|PrimitiveObjectInspector
operator|.
name|PrimitiveCategory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|objectinspector
operator|.
name|StandardStructObjectInspector
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|objectinspector
operator|.
name|primitive
operator|.
name|PrimitiveObjectInspectorFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|typeinfo
operator|.
name|DecimalTypeInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|typeinfo
operator|.
name|TypeInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|typeinfo
operator|.
name|TypeInfoFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|BytesWritable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|Writable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hive
operator|.
name|common
operator|.
name|util
operator|.
name|HashCodeUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hive
operator|.
name|common
operator|.
name|util
operator|.
name|ReflectionUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|Test
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|Ignore
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
operator|.
name|Entry
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Random
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|SortedMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|TreeMap
import|;
end_import

begin_import
import|import
name|junit
operator|.
name|framework
operator|.
name|Assert
import|;
end_import

begin_class
specifier|public
class|class
name|TestMapJoinOperator
block|{
specifier|private
name|boolean
name|addLongHiveConfVariation
parameter_list|(
name|int
name|hiveConfVariation
parameter_list|,
name|HiveConf
name|hiveConf
parameter_list|)
block|{
comment|// Set defaults.
name|HiveConf
operator|.
name|setBoolVar
argument_list|(
name|hiveConf
argument_list|,
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVE_VECTORIZATION_MAPJOIN_NATIVE_MINMAX_ENABLED
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|HiveConf
operator|.
name|setIntVar
argument_list|(
name|hiveConf
argument_list|,
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVE_VECTORIZATION_MAPJOIN_NATIVE_OVERFLOW_REPEATED_THRESHOLD
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|hiveConfVariation
condition|)
block|{
case|case
literal|0
case|:
break|break;
case|case
literal|1
case|:
name|HiveConf
operator|.
name|setBoolVar
argument_list|(
name|hiveConf
argument_list|,
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVE_VECTORIZATION_MAPJOIN_NATIVE_MINMAX_ENABLED
argument_list|,
literal|true
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
comment|// Force generateHashMapResultLargeMultiValue to be used.
name|HiveConf
operator|.
name|setIntVar
argument_list|(
name|hiveConf
argument_list|,
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVE_VECTORIZATION_MAPJOIN_NATIVE_OVERFLOW_REPEATED_THRESHOLD
argument_list|,
literal|5
argument_list|)
expr_stmt|;
break|break;
default|default:
return|return
literal|false
return|;
block|}
return|return
literal|true
return|;
block|}
specifier|private
name|boolean
name|goodTestVariation
parameter_list|(
name|MapJoinTestDescription
name|testDesc
parameter_list|)
block|{
specifier|final
name|int
name|smallTableValueSize
init|=
name|testDesc
operator|.
name|smallTableRetainValueColumnNums
operator|.
name|length
decl_stmt|;
switch|switch
condition|(
name|testDesc
operator|.
name|vectorMapJoinVariation
condition|)
block|{
case|case
name|INNER
case|:
return|return
operator|(
name|smallTableValueSize
operator|>
literal|0
operator|)
return|;
case|case
name|INNER_BIG_ONLY
case|:
case|case
name|LEFT_SEMI
case|:
return|return
operator|(
name|smallTableValueSize
operator|==
literal|0
operator|)
return|;
case|case
name|OUTER
case|:
return|return
literal|true
return|;
case|case
name|FULL_OUTER
case|:
return|return
literal|true
return|;
default|default:
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Unexpected vectorMapJoinVariation "
operator|+
name|testDesc
operator|.
name|vectorMapJoinVariation
argument_list|)
throw|;
block|}
block|}
annotation|@
name|Ignore
annotation|@
name|Test
specifier|public
name|void
name|testLong0
parameter_list|()
throws|throws
name|Exception
block|{
name|long
name|seed
init|=
literal|234882L
decl_stmt|;
name|int
name|rowCount
init|=
literal|10
decl_stmt|;
name|int
name|hiveConfVariation
init|=
literal|0
decl_stmt|;
name|boolean
name|hiveConfVariationsDone
init|=
literal|false
decl_stmt|;
do|do
block|{
for|for
control|(
name|VectorMapJoinVariation
name|vectorMapJoinVariation
range|:
name|VectorMapJoinVariation
operator|.
name|values
argument_list|()
control|)
block|{
name|hiveConfVariationsDone
operator|=
name|doTestLong0
argument_list|(
name|seed
argument_list|,
name|rowCount
argument_list|,
name|hiveConfVariation
argument_list|,
name|vectorMapJoinVariation
argument_list|,
name|MapJoinPlanVariation
operator|.
name|DYNAMIC_PARTITION_HASH_JOIN
argument_list|)
expr_stmt|;
block|}
name|seed
operator|++
expr_stmt|;
name|hiveConfVariation
operator|++
expr_stmt|;
block|}
do|while
condition|(
operator|!
name|hiveConfVariationsDone
condition|)
do|;
block|}
specifier|private
name|boolean
name|doTestLong0
parameter_list|(
name|long
name|seed
parameter_list|,
name|int
name|rowCount
parameter_list|,
name|int
name|hiveConfVariation
parameter_list|,
name|VectorMapJoinVariation
name|vectorMapJoinVariation
parameter_list|,
name|MapJoinPlanVariation
name|mapJoinPlanVariation
parameter_list|)
throws|throws
name|Exception
block|{
name|HiveConf
name|hiveConf
init|=
operator|new
name|HiveConf
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|addLongHiveConfVariation
argument_list|(
name|hiveConfVariation
argument_list|,
name|hiveConf
argument_list|)
condition|)
block|{
return|return
literal|true
return|;
block|}
name|TypeInfo
index|[]
name|bigTableTypeInfos
init|=
literal|null
decl_stmt|;
name|int
index|[]
name|bigTableKeyColumnNums
init|=
literal|null
decl_stmt|;
name|TypeInfo
index|[]
name|smallTableValueTypeInfos
init|=
literal|null
decl_stmt|;
name|int
index|[]
name|smallTableRetainKeyColumnNums
init|=
literal|null
decl_stmt|;
name|SmallTableGenerationParameters
name|smallTableGenerationParameters
init|=
operator|new
name|SmallTableGenerationParameters
argument_list|()
decl_stmt|;
name|MapJoinTestDescription
name|testDesc
init|=
literal|null
decl_stmt|;
name|MapJoinTestData
name|testData
init|=
literal|null
decl_stmt|;
comment|// Big Table: long key, no value; Small Table: no key retained, date value
name|bigTableTypeInfos
operator|=
operator|new
name|TypeInfo
index|[]
block|{
name|TypeInfoFactory
operator|.
name|longTypeInfo
block|}
expr_stmt|;
name|bigTableKeyColumnNums
operator|=
operator|new
name|int
index|[]
block|{
literal|0
block|}
expr_stmt|;
name|smallTableRetainKeyColumnNums
operator|=
operator|new
name|int
index|[]
block|{}
expr_stmt|;
name|smallTableValueTypeInfos
operator|=
operator|new
name|TypeInfo
index|[]
block|{
name|TypeInfoFactory
operator|.
name|dateTypeInfo
block|}
expr_stmt|;
name|testDesc
operator|=
operator|new
name|MapJoinTestDescription
argument_list|(
name|hiveConf
argument_list|,
name|vectorMapJoinVariation
argument_list|,
name|bigTableTypeInfos
argument_list|,
name|bigTableKeyColumnNums
argument_list|,
name|smallTableValueTypeInfos
argument_list|,
name|smallTableRetainKeyColumnNums
argument_list|,
name|smallTableGenerationParameters
argument_list|,
name|mapJoinPlanVariation
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|goodTestVariation
argument_list|(
name|testDesc
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
name|testData
operator|=
operator|new
name|MapJoinTestData
argument_list|(
name|rowCount
argument_list|,
name|testDesc
argument_list|,
name|seed
argument_list|)
expr_stmt|;
name|executeTest
argument_list|(
name|testDesc
argument_list|,
name|testData
argument_list|,
literal|"testLong0"
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
annotation|@
name|Ignore
annotation|@
name|Test
specifier|public
name|void
name|testLong0_NoRegularKeys
parameter_list|()
throws|throws
name|Exception
block|{
name|long
name|seed
init|=
literal|234882L
decl_stmt|;
name|int
name|rowCount
init|=
literal|10
decl_stmt|;
name|int
name|hiveConfVariation
init|=
literal|0
decl_stmt|;
name|boolean
name|hiveConfVariationsDone
init|=
literal|false
decl_stmt|;
do|do
block|{
for|for
control|(
name|VectorMapJoinVariation
name|vectorMapJoinVariation
range|:
name|VectorMapJoinVariation
operator|.
name|values
argument_list|()
control|)
block|{
name|hiveConfVariationsDone
operator|=
name|doTestLong0_NoRegularKeys
argument_list|(
name|seed
argument_list|,
name|rowCount
argument_list|,
name|hiveConfVariation
argument_list|,
name|vectorMapJoinVariation
argument_list|,
name|MapJoinPlanVariation
operator|.
name|DYNAMIC_PARTITION_HASH_JOIN
argument_list|)
expr_stmt|;
block|}
name|seed
operator|++
expr_stmt|;
name|hiveConfVariation
operator|++
expr_stmt|;
block|}
do|while
condition|(
operator|!
name|hiveConfVariationsDone
condition|)
do|;
block|}
specifier|private
name|boolean
name|doTestLong0_NoRegularKeys
parameter_list|(
name|long
name|seed
parameter_list|,
name|int
name|rowCount
parameter_list|,
name|int
name|hiveConfVariation
parameter_list|,
name|VectorMapJoinVariation
name|vectorMapJoinVariation
parameter_list|,
name|MapJoinPlanVariation
name|mapJoinPlanVariation
parameter_list|)
throws|throws
name|Exception
block|{
name|HiveConf
name|hiveConf
init|=
operator|new
name|HiveConf
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|addLongHiveConfVariation
argument_list|(
name|hiveConfVariation
argument_list|,
name|hiveConf
argument_list|)
condition|)
block|{
return|return
literal|true
return|;
block|}
name|TypeInfo
index|[]
name|bigTableTypeInfos
init|=
literal|null
decl_stmt|;
name|int
index|[]
name|bigTableKeyColumnNums
init|=
literal|null
decl_stmt|;
name|TypeInfo
index|[]
name|smallTableValueTypeInfos
init|=
literal|null
decl_stmt|;
name|int
index|[]
name|smallTableRetainKeyColumnNums
init|=
literal|null
decl_stmt|;
name|SmallTableGenerationParameters
name|smallTableGenerationParameters
init|=
operator|new
name|SmallTableGenerationParameters
argument_list|()
decl_stmt|;
name|smallTableGenerationParameters
operator|.
name|setValueOption
argument_list|(
name|ValueOption
operator|.
name|NO_REGULAR_SMALL_KEYS
argument_list|)
expr_stmt|;
name|MapJoinTestDescription
name|testDesc
init|=
literal|null
decl_stmt|;
name|MapJoinTestData
name|testData
init|=
literal|null
decl_stmt|;
comment|// Big Table: long key, no value; Small Table: no key retained, date value
name|bigTableTypeInfos
operator|=
operator|new
name|TypeInfo
index|[]
block|{
name|TypeInfoFactory
operator|.
name|longTypeInfo
block|}
expr_stmt|;
name|bigTableKeyColumnNums
operator|=
operator|new
name|int
index|[]
block|{
literal|0
block|}
expr_stmt|;
name|smallTableRetainKeyColumnNums
operator|=
operator|new
name|int
index|[]
block|{}
expr_stmt|;
name|smallTableValueTypeInfos
operator|=
operator|new
name|TypeInfo
index|[]
block|{
name|TypeInfoFactory
operator|.
name|dateTypeInfo
block|}
expr_stmt|;
name|testDesc
operator|=
operator|new
name|MapJoinTestDescription
argument_list|(
name|hiveConf
argument_list|,
name|vectorMapJoinVariation
argument_list|,
name|bigTableTypeInfos
argument_list|,
name|bigTableKeyColumnNums
argument_list|,
name|smallTableValueTypeInfos
argument_list|,
name|smallTableRetainKeyColumnNums
argument_list|,
name|smallTableGenerationParameters
argument_list|,
name|mapJoinPlanVariation
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|goodTestVariation
argument_list|(
name|testDesc
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
name|testData
operator|=
operator|new
name|MapJoinTestData
argument_list|(
name|rowCount
argument_list|,
name|testDesc
argument_list|,
name|seed
argument_list|)
expr_stmt|;
name|executeTest
argument_list|(
name|testDesc
argument_list|,
name|testData
argument_list|,
literal|"doTestLong0_NoRegularKeys"
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
annotation|@
name|Ignore
annotation|@
name|Test
specifier|public
name|void
name|testLong1
parameter_list|()
throws|throws
name|Exception
block|{
name|long
name|seed
init|=
literal|234882L
decl_stmt|;
name|int
name|rowCount
init|=
literal|10
decl_stmt|;
name|int
name|hiveConfVariation
init|=
literal|0
decl_stmt|;
name|boolean
name|hiveConfVariationsDone
init|=
literal|false
decl_stmt|;
do|do
block|{
for|for
control|(
name|VectorMapJoinVariation
name|vectorMapJoinVariation
range|:
name|VectorMapJoinVariation
operator|.
name|values
argument_list|()
control|)
block|{
name|hiveConfVariationsDone
operator|=
name|doTestLong1
argument_list|(
name|seed
argument_list|,
name|rowCount
argument_list|,
name|hiveConfVariation
argument_list|,
name|vectorMapJoinVariation
argument_list|,
name|MapJoinPlanVariation
operator|.
name|DYNAMIC_PARTITION_HASH_JOIN
argument_list|)
expr_stmt|;
block|}
name|seed
operator|++
expr_stmt|;
name|hiveConfVariation
operator|++
expr_stmt|;
block|}
do|while
condition|(
operator|!
name|hiveConfVariationsDone
condition|)
do|;
block|}
specifier|public
name|boolean
name|doTestLong1
parameter_list|(
name|long
name|seed
parameter_list|,
name|int
name|rowCount
parameter_list|,
name|int
name|hiveConfVariation
parameter_list|,
name|VectorMapJoinVariation
name|vectorMapJoinVariation
parameter_list|,
name|MapJoinPlanVariation
name|mapJoinPlanVariation
parameter_list|)
throws|throws
name|Exception
block|{
name|HiveConf
name|hiveConf
init|=
operator|new
name|HiveConf
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|addLongHiveConfVariation
argument_list|(
name|hiveConfVariation
argument_list|,
name|hiveConf
argument_list|)
condition|)
block|{
return|return
literal|true
return|;
block|}
name|TypeInfo
index|[]
name|bigTableTypeInfos
init|=
literal|null
decl_stmt|;
name|int
index|[]
name|bigTableKeyColumnNums
init|=
literal|null
decl_stmt|;
name|TypeInfo
index|[]
name|smallTableValueTypeInfos
init|=
literal|null
decl_stmt|;
name|int
index|[]
name|smallTableRetainKeyColumnNums
init|=
literal|null
decl_stmt|;
name|SmallTableGenerationParameters
name|smallTableGenerationParameters
init|=
operator|new
name|SmallTableGenerationParameters
argument_list|()
decl_stmt|;
name|MapJoinTestDescription
name|testDesc
init|=
literal|null
decl_stmt|;
name|MapJoinTestData
name|testData
init|=
literal|null
decl_stmt|;
comment|// Big Table: int key, long value; Small Table: no key retained, string value
name|bigTableTypeInfos
operator|=
operator|new
name|TypeInfo
index|[]
block|{
name|TypeInfoFactory
operator|.
name|intTypeInfo
block|,
name|TypeInfoFactory
operator|.
name|longTypeInfo
block|}
expr_stmt|;
name|bigTableKeyColumnNums
operator|=
operator|new
name|int
index|[]
block|{
literal|0
block|}
expr_stmt|;
name|smallTableRetainKeyColumnNums
operator|=
operator|new
name|int
index|[]
block|{}
expr_stmt|;
name|smallTableValueTypeInfos
operator|=
operator|new
name|TypeInfo
index|[]
block|{
name|TypeInfoFactory
operator|.
name|stringTypeInfo
block|}
expr_stmt|;
name|testDesc
operator|=
operator|new
name|MapJoinTestDescription
argument_list|(
name|hiveConf
argument_list|,
name|vectorMapJoinVariation
argument_list|,
name|bigTableTypeInfos
argument_list|,
name|bigTableKeyColumnNums
argument_list|,
name|smallTableValueTypeInfos
argument_list|,
name|smallTableRetainKeyColumnNums
argument_list|,
name|smallTableGenerationParameters
argument_list|,
name|mapJoinPlanVariation
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|goodTestVariation
argument_list|(
name|testDesc
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
name|testData
operator|=
operator|new
name|MapJoinTestData
argument_list|(
name|rowCount
argument_list|,
name|testDesc
argument_list|,
name|seed
argument_list|)
expr_stmt|;
name|executeTest
argument_list|(
name|testDesc
argument_list|,
name|testData
argument_list|,
literal|"testLong1"
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testLong2
parameter_list|()
throws|throws
name|Exception
block|{
name|long
name|seed
init|=
literal|3553
decl_stmt|;
name|int
name|rowCount
init|=
literal|10
decl_stmt|;
name|int
name|hiveConfVariation
init|=
literal|0
decl_stmt|;
name|boolean
name|hiveConfVariationsDone
init|=
literal|false
decl_stmt|;
do|do
block|{
for|for
control|(
name|VectorMapJoinVariation
name|vectorMapJoinVariation
range|:
name|VectorMapJoinVariation
operator|.
name|values
argument_list|()
control|)
block|{
name|hiveConfVariationsDone
operator|=
name|doTestLong2
argument_list|(
name|seed
argument_list|,
name|rowCount
argument_list|,
name|hiveConfVariation
argument_list|,
name|vectorMapJoinVariation
argument_list|,
name|MapJoinPlanVariation
operator|.
name|DYNAMIC_PARTITION_HASH_JOIN
argument_list|)
expr_stmt|;
block|}
name|seed
operator|++
expr_stmt|;
name|hiveConfVariation
operator|++
expr_stmt|;
block|}
do|while
condition|(
operator|!
name|hiveConfVariationsDone
condition|)
do|;
block|}
specifier|public
name|boolean
name|doTestLong2
parameter_list|(
name|long
name|seed
parameter_list|,
name|int
name|rowCount
parameter_list|,
name|int
name|hiveConfVariation
parameter_list|,
name|VectorMapJoinVariation
name|vectorMapJoinVariation
parameter_list|,
name|MapJoinPlanVariation
name|mapJoinPlanVariation
parameter_list|)
throws|throws
name|Exception
block|{
name|HiveConf
name|hiveConf
init|=
operator|new
name|HiveConf
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|addLongHiveConfVariation
argument_list|(
name|hiveConfVariation
argument_list|,
name|hiveConf
argument_list|)
condition|)
block|{
return|return
literal|true
return|;
block|}
name|TypeInfo
index|[]
name|bigTableTypeInfos
init|=
literal|null
decl_stmt|;
name|int
index|[]
name|bigTableKeyColumnNums
init|=
literal|null
decl_stmt|;
name|TypeInfo
index|[]
name|smallTableValueTypeInfos
init|=
literal|null
decl_stmt|;
name|int
index|[]
name|smallTableRetainKeyColumnNums
init|=
literal|null
decl_stmt|;
name|SmallTableGenerationParameters
name|smallTableGenerationParameters
init|=
operator|new
name|SmallTableGenerationParameters
argument_list|()
decl_stmt|;
name|MapJoinTestDescription
name|testDesc
init|=
literal|null
decl_stmt|;
name|MapJoinTestData
name|testData
init|=
literal|null
decl_stmt|;
comment|// Big Table: short key, no value; Small Table: key retained, timestamp value
name|bigTableTypeInfos
operator|=
operator|new
name|TypeInfo
index|[]
block|{
name|TypeInfoFactory
operator|.
name|shortTypeInfo
block|}
expr_stmt|;
name|bigTableKeyColumnNums
operator|=
operator|new
name|int
index|[]
block|{
literal|0
block|}
expr_stmt|;
name|smallTableRetainKeyColumnNums
operator|=
operator|new
name|int
index|[]
block|{
literal|0
block|}
expr_stmt|;
name|smallTableValueTypeInfos
operator|=
operator|new
name|TypeInfo
index|[]
block|{
name|TypeInfoFactory
operator|.
name|timestampTypeInfo
block|}
expr_stmt|;
name|testDesc
operator|=
operator|new
name|MapJoinTestDescription
argument_list|(
name|hiveConf
argument_list|,
name|vectorMapJoinVariation
argument_list|,
name|bigTableTypeInfos
argument_list|,
name|bigTableKeyColumnNums
argument_list|,
name|smallTableValueTypeInfos
argument_list|,
name|smallTableRetainKeyColumnNums
argument_list|,
name|smallTableGenerationParameters
argument_list|,
name|mapJoinPlanVariation
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|goodTestVariation
argument_list|(
name|testDesc
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
name|testData
operator|=
operator|new
name|MapJoinTestData
argument_list|(
name|rowCount
argument_list|,
name|testDesc
argument_list|,
name|seed
argument_list|)
expr_stmt|;
name|executeTest
argument_list|(
name|testDesc
argument_list|,
name|testData
argument_list|,
literal|"testLong2"
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testLong3
parameter_list|()
throws|throws
name|Exception
block|{
name|long
name|seed
init|=
literal|9934
decl_stmt|;
name|int
name|rowCount
init|=
literal|10
decl_stmt|;
name|int
name|hiveConfVariation
init|=
literal|0
decl_stmt|;
name|boolean
name|hiveConfVariationsDone
init|=
literal|false
decl_stmt|;
do|do
block|{
for|for
control|(
name|VectorMapJoinVariation
name|vectorMapJoinVariation
range|:
name|VectorMapJoinVariation
operator|.
name|values
argument_list|()
control|)
block|{
name|hiveConfVariationsDone
operator|=
name|doTestLong3
argument_list|(
name|seed
argument_list|,
name|rowCount
argument_list|,
name|hiveConfVariation
argument_list|,
name|vectorMapJoinVariation
argument_list|,
name|MapJoinPlanVariation
operator|.
name|DYNAMIC_PARTITION_HASH_JOIN
argument_list|)
expr_stmt|;
block|}
name|seed
operator|++
expr_stmt|;
name|hiveConfVariation
operator|++
expr_stmt|;
block|}
do|while
condition|(
operator|!
name|hiveConfVariationsDone
condition|)
do|;
block|}
specifier|public
name|boolean
name|doTestLong3
parameter_list|(
name|long
name|seed
parameter_list|,
name|int
name|rowCount
parameter_list|,
name|int
name|hiveConfVariation
parameter_list|,
name|VectorMapJoinVariation
name|vectorMapJoinVariation
parameter_list|,
name|MapJoinPlanVariation
name|mapJoinPlanVariation
parameter_list|)
throws|throws
name|Exception
block|{
name|HiveConf
name|hiveConf
init|=
operator|new
name|HiveConf
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|addLongHiveConfVariation
argument_list|(
name|hiveConfVariation
argument_list|,
name|hiveConf
argument_list|)
condition|)
block|{
return|return
literal|true
return|;
block|}
name|TypeInfo
index|[]
name|bigTableTypeInfos
init|=
literal|null
decl_stmt|;
name|int
index|[]
name|bigTableKeyColumnNums
init|=
literal|null
decl_stmt|;
name|TypeInfo
index|[]
name|smallTableValueTypeInfos
init|=
literal|null
decl_stmt|;
name|int
index|[]
name|smallTableRetainKeyColumnNums
init|=
literal|null
decl_stmt|;
name|SmallTableGenerationParameters
name|smallTableGenerationParameters
init|=
operator|new
name|SmallTableGenerationParameters
argument_list|()
decl_stmt|;
name|MapJoinTestDescription
name|testDesc
init|=
literal|null
decl_stmt|;
name|MapJoinTestData
name|testData
init|=
literal|null
decl_stmt|;
comment|// Big Table: int key, string value; Small Table: key retained, decimal value
name|bigTableTypeInfos
operator|=
operator|new
name|TypeInfo
index|[]
block|{
name|TypeInfoFactory
operator|.
name|intTypeInfo
block|,
name|TypeInfoFactory
operator|.
name|stringTypeInfo
block|}
expr_stmt|;
name|bigTableKeyColumnNums
operator|=
operator|new
name|int
index|[]
block|{
literal|0
block|}
expr_stmt|;
name|smallTableRetainKeyColumnNums
operator|=
operator|new
name|int
index|[]
block|{
literal|0
block|}
expr_stmt|;
name|smallTableValueTypeInfos
operator|=
operator|new
name|TypeInfo
index|[]
block|{
operator|new
name|DecimalTypeInfo
argument_list|(
literal|38
argument_list|,
literal|18
argument_list|)
block|}
expr_stmt|;
name|testDesc
operator|=
operator|new
name|MapJoinTestDescription
argument_list|(
name|hiveConf
argument_list|,
name|vectorMapJoinVariation
argument_list|,
name|bigTableTypeInfos
argument_list|,
name|bigTableKeyColumnNums
argument_list|,
name|smallTableValueTypeInfos
argument_list|,
name|smallTableRetainKeyColumnNums
argument_list|,
name|smallTableGenerationParameters
argument_list|,
name|mapJoinPlanVariation
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|goodTestVariation
argument_list|(
name|testDesc
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
name|testData
operator|=
operator|new
name|MapJoinTestData
argument_list|(
name|rowCount
argument_list|,
name|testDesc
argument_list|,
name|seed
argument_list|)
expr_stmt|;
name|executeTest
argument_list|(
name|testDesc
argument_list|,
name|testData
argument_list|,
literal|"testLong3"
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testLong3_NoRegularKeys
parameter_list|()
throws|throws
name|Exception
block|{
name|long
name|seed
init|=
literal|9934
decl_stmt|;
name|int
name|rowCount
init|=
literal|10
decl_stmt|;
name|int
name|hiveConfVariation
init|=
literal|0
decl_stmt|;
name|boolean
name|hiveConfVariationsDone
init|=
literal|false
decl_stmt|;
do|do
block|{
for|for
control|(
name|VectorMapJoinVariation
name|vectorMapJoinVariation
range|:
name|VectorMapJoinVariation
operator|.
name|values
argument_list|()
control|)
block|{
name|hiveConfVariationsDone
operator|=
name|doTestLong3_NoRegularKeys
argument_list|(
name|seed
argument_list|,
name|rowCount
argument_list|,
name|hiveConfVariation
argument_list|,
name|vectorMapJoinVariation
argument_list|,
name|MapJoinPlanVariation
operator|.
name|DYNAMIC_PARTITION_HASH_JOIN
argument_list|)
expr_stmt|;
block|}
name|seed
operator|++
expr_stmt|;
name|hiveConfVariation
operator|++
expr_stmt|;
block|}
do|while
condition|(
operator|!
name|hiveConfVariationsDone
condition|)
do|;
block|}
specifier|public
name|boolean
name|doTestLong3_NoRegularKeys
parameter_list|(
name|long
name|seed
parameter_list|,
name|int
name|rowCount
parameter_list|,
name|int
name|hiveConfVariation
parameter_list|,
name|VectorMapJoinVariation
name|vectorMapJoinVariation
parameter_list|,
name|MapJoinPlanVariation
name|mapJoinPlanVariation
parameter_list|)
throws|throws
name|Exception
block|{
name|HiveConf
name|hiveConf
init|=
operator|new
name|HiveConf
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|addLongHiveConfVariation
argument_list|(
name|hiveConfVariation
argument_list|,
name|hiveConf
argument_list|)
condition|)
block|{
return|return
literal|true
return|;
block|}
name|TypeInfo
index|[]
name|bigTableTypeInfos
init|=
literal|null
decl_stmt|;
name|int
index|[]
name|bigTableKeyColumnNums
init|=
literal|null
decl_stmt|;
name|TypeInfo
index|[]
name|smallTableValueTypeInfos
init|=
literal|null
decl_stmt|;
name|int
index|[]
name|smallTableRetainKeyColumnNums
init|=
literal|null
decl_stmt|;
name|SmallTableGenerationParameters
name|smallTableGenerationParameters
init|=
operator|new
name|SmallTableGenerationParameters
argument_list|()
decl_stmt|;
name|smallTableGenerationParameters
operator|.
name|setValueOption
argument_list|(
name|ValueOption
operator|.
name|NO_REGULAR_SMALL_KEYS
argument_list|)
expr_stmt|;
name|MapJoinTestDescription
name|testDesc
init|=
literal|null
decl_stmt|;
name|MapJoinTestData
name|testData
init|=
literal|null
decl_stmt|;
comment|// Big Table: int key, string value; Small Table: key retained, decimal value
name|bigTableTypeInfos
operator|=
operator|new
name|TypeInfo
index|[]
block|{
name|TypeInfoFactory
operator|.
name|intTypeInfo
block|,
name|TypeInfoFactory
operator|.
name|stringTypeInfo
block|}
expr_stmt|;
name|bigTableKeyColumnNums
operator|=
operator|new
name|int
index|[]
block|{
literal|0
block|}
expr_stmt|;
name|smallTableRetainKeyColumnNums
operator|=
operator|new
name|int
index|[]
block|{
literal|0
block|}
expr_stmt|;
name|smallTableValueTypeInfos
operator|=
operator|new
name|TypeInfo
index|[]
block|{
operator|new
name|DecimalTypeInfo
argument_list|(
literal|38
argument_list|,
literal|18
argument_list|)
block|}
expr_stmt|;
name|testDesc
operator|=
operator|new
name|MapJoinTestDescription
argument_list|(
name|hiveConf
argument_list|,
name|vectorMapJoinVariation
argument_list|,
name|bigTableTypeInfos
argument_list|,
name|bigTableKeyColumnNums
argument_list|,
name|smallTableValueTypeInfos
argument_list|,
name|smallTableRetainKeyColumnNums
argument_list|,
name|smallTableGenerationParameters
argument_list|,
name|mapJoinPlanVariation
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|goodTestVariation
argument_list|(
name|testDesc
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
name|testData
operator|=
operator|new
name|MapJoinTestData
argument_list|(
name|rowCount
argument_list|,
name|testDesc
argument_list|,
name|seed
argument_list|)
expr_stmt|;
name|executeTest
argument_list|(
name|testDesc
argument_list|,
name|testData
argument_list|,
literal|"doTestLong3_NoRegularKeys"
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testLong4
parameter_list|()
throws|throws
name|Exception
block|{
name|long
name|seed
init|=
literal|3982
decl_stmt|;
name|int
name|rowCount
init|=
literal|10
decl_stmt|;
name|int
name|hiveConfVariation
init|=
literal|0
decl_stmt|;
name|boolean
name|hiveConfVariationsDone
init|=
literal|false
decl_stmt|;
do|do
block|{
for|for
control|(
name|VectorMapJoinVariation
name|vectorMapJoinVariation
range|:
name|VectorMapJoinVariation
operator|.
name|values
argument_list|()
control|)
block|{
name|hiveConfVariationsDone
operator|=
name|doTestLong4
argument_list|(
name|seed
argument_list|,
name|rowCount
argument_list|,
name|hiveConfVariation
argument_list|,
name|vectorMapJoinVariation
argument_list|,
name|MapJoinPlanVariation
operator|.
name|DYNAMIC_PARTITION_HASH_JOIN
argument_list|)
expr_stmt|;
block|}
name|seed
operator|++
expr_stmt|;
name|hiveConfVariation
operator|++
expr_stmt|;
block|}
do|while
condition|(
operator|!
name|hiveConfVariationsDone
condition|)
do|;
block|}
specifier|public
name|boolean
name|doTestLong4
parameter_list|(
name|long
name|seed
parameter_list|,
name|int
name|rowCount
parameter_list|,
name|int
name|hiveConfVariation
parameter_list|,
name|VectorMapJoinVariation
name|vectorMapJoinVariation
parameter_list|,
name|MapJoinPlanVariation
name|mapJoinPlanVariation
parameter_list|)
throws|throws
name|Exception
block|{
name|HiveConf
name|hiveConf
init|=
operator|new
name|HiveConf
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|addLongHiveConfVariation
argument_list|(
name|hiveConfVariation
argument_list|,
name|hiveConf
argument_list|)
condition|)
block|{
return|return
literal|true
return|;
block|}
name|TypeInfo
index|[]
name|bigTableTypeInfos
init|=
literal|null
decl_stmt|;
name|int
index|[]
name|bigTableKeyColumnNums
init|=
literal|null
decl_stmt|;
name|TypeInfo
index|[]
name|smallTableValueTypeInfos
init|=
literal|null
decl_stmt|;
name|int
index|[]
name|smallTableRetainKeyColumnNums
init|=
literal|null
decl_stmt|;
name|SmallTableGenerationParameters
name|smallTableGenerationParameters
init|=
operator|new
name|SmallTableGenerationParameters
argument_list|()
decl_stmt|;
name|MapJoinTestDescription
name|testDesc
init|=
literal|null
decl_stmt|;
name|MapJoinTestData
name|testData
init|=
literal|null
decl_stmt|;
comment|// Big Table: int key, no value; Small Table: no key retained, no value
comment|// (exercise INNER_BIGONLY, LEFT_SEMI)
name|bigTableTypeInfos
operator|=
operator|new
name|TypeInfo
index|[]
block|{
name|TypeInfoFactory
operator|.
name|intTypeInfo
block|}
expr_stmt|;
name|bigTableKeyColumnNums
operator|=
operator|new
name|int
index|[]
block|{
literal|0
block|}
expr_stmt|;
name|smallTableRetainKeyColumnNums
operator|=
operator|new
name|int
index|[]
block|{}
expr_stmt|;
name|smallTableValueTypeInfos
operator|=
operator|new
name|TypeInfo
index|[]
block|{}
expr_stmt|;
name|testDesc
operator|=
operator|new
name|MapJoinTestDescription
argument_list|(
name|hiveConf
argument_list|,
name|vectorMapJoinVariation
argument_list|,
name|bigTableTypeInfos
argument_list|,
name|bigTableKeyColumnNums
argument_list|,
name|smallTableValueTypeInfos
argument_list|,
name|smallTableRetainKeyColumnNums
argument_list|,
name|smallTableGenerationParameters
argument_list|,
name|mapJoinPlanVariation
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|goodTestVariation
argument_list|(
name|testDesc
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
name|testData
operator|=
operator|new
name|MapJoinTestData
argument_list|(
name|rowCount
argument_list|,
name|testDesc
argument_list|,
name|seed
argument_list|)
expr_stmt|;
name|executeTest
argument_list|(
name|testDesc
argument_list|,
name|testData
argument_list|,
literal|"testLong4"
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testLong5
parameter_list|()
throws|throws
name|Exception
block|{
name|long
name|seed
init|=
literal|3553
decl_stmt|;
name|int
name|rowCount
init|=
literal|10
decl_stmt|;
name|int
name|hiveConfVariation
init|=
literal|0
decl_stmt|;
name|boolean
name|hiveConfVariationsDone
init|=
literal|false
decl_stmt|;
do|do
block|{
for|for
control|(
name|VectorMapJoinVariation
name|vectorMapJoinVariation
range|:
name|VectorMapJoinVariation
operator|.
name|values
argument_list|()
control|)
block|{
name|hiveConfVariationsDone
operator|=
name|doTestLong5
argument_list|(
name|seed
argument_list|,
name|rowCount
argument_list|,
name|hiveConfVariation
argument_list|,
name|vectorMapJoinVariation
argument_list|,
name|MapJoinPlanVariation
operator|.
name|DYNAMIC_PARTITION_HASH_JOIN
argument_list|)
expr_stmt|;
block|}
name|seed
operator|++
expr_stmt|;
name|hiveConfVariation
operator|++
expr_stmt|;
block|}
do|while
condition|(
operator|!
name|hiveConfVariationsDone
condition|)
do|;
block|}
specifier|public
name|boolean
name|doTestLong5
parameter_list|(
name|long
name|seed
parameter_list|,
name|int
name|rowCount
parameter_list|,
name|int
name|hiveConfVariation
parameter_list|,
name|VectorMapJoinVariation
name|vectorMapJoinVariation
parameter_list|,
name|MapJoinPlanVariation
name|mapJoinPlanVariation
parameter_list|)
throws|throws
name|Exception
block|{
name|HiveConf
name|hiveConf
init|=
operator|new
name|HiveConf
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|addLongHiveConfVariation
argument_list|(
name|hiveConfVariation
argument_list|,
name|hiveConf
argument_list|)
condition|)
block|{
return|return
literal|true
return|;
block|}
name|TypeInfo
index|[]
name|bigTableTypeInfos
init|=
literal|null
decl_stmt|;
name|int
index|[]
name|bigTableKeyColumnNums
init|=
literal|null
decl_stmt|;
name|TypeInfo
index|[]
name|smallTableValueTypeInfos
init|=
literal|null
decl_stmt|;
name|int
index|[]
name|smallTableRetainKeyColumnNums
init|=
literal|null
decl_stmt|;
comment|// Cause there to be no regular FULL OUTER MapJoin MATCHes so only non-match Small Table
comment|// results.
name|SmallTableGenerationParameters
name|smallTableGenerationParameters
init|=
operator|new
name|SmallTableGenerationParameters
argument_list|()
decl_stmt|;
name|MapJoinTestDescription
name|testDesc
init|=
literal|null
decl_stmt|;
name|MapJoinTestData
name|testData
init|=
literal|null
decl_stmt|;
comment|// Big Table: long key, no value; Small Table: key retained, no value
comment|// (exercise INNER_BIGONLY, LEFT_SEMI)
name|bigTableTypeInfos
operator|=
operator|new
name|TypeInfo
index|[]
block|{
name|TypeInfoFactory
operator|.
name|longTypeInfo
block|}
expr_stmt|;
name|bigTableKeyColumnNums
operator|=
operator|new
name|int
index|[]
block|{
literal|0
block|}
expr_stmt|;
name|smallTableRetainKeyColumnNums
operator|=
operator|new
name|int
index|[]
block|{
literal|0
block|}
expr_stmt|;
name|smallTableValueTypeInfos
operator|=
operator|new
name|TypeInfo
index|[]
block|{}
expr_stmt|;
name|testDesc
operator|=
operator|new
name|MapJoinTestDescription
argument_list|(
name|hiveConf
argument_list|,
name|vectorMapJoinVariation
argument_list|,
name|bigTableTypeInfos
argument_list|,
name|bigTableKeyColumnNums
argument_list|,
name|smallTableValueTypeInfos
argument_list|,
name|smallTableRetainKeyColumnNums
argument_list|,
name|smallTableGenerationParameters
argument_list|,
name|mapJoinPlanVariation
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|goodTestVariation
argument_list|(
name|testDesc
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
name|testData
operator|=
operator|new
name|MapJoinTestData
argument_list|(
name|rowCount
argument_list|,
name|testDesc
argument_list|,
name|seed
argument_list|)
expr_stmt|;
name|executeTest
argument_list|(
name|testDesc
argument_list|,
name|testData
argument_list|,
literal|"testLong5"
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testLong6
parameter_list|()
throws|throws
name|Exception
block|{
name|long
name|seed
init|=
literal|9384
decl_stmt|;
name|int
name|rowCount
init|=
literal|10
decl_stmt|;
name|int
name|hiveConfVariation
init|=
literal|0
decl_stmt|;
name|boolean
name|hiveConfVariationsDone
init|=
literal|false
decl_stmt|;
do|do
block|{
for|for
control|(
name|VectorMapJoinVariation
name|vectorMapJoinVariation
range|:
name|VectorMapJoinVariation
operator|.
name|values
argument_list|()
control|)
block|{
name|hiveConfVariationsDone
operator|=
name|doTestLong6
argument_list|(
name|seed
argument_list|,
name|rowCount
argument_list|,
name|hiveConfVariation
argument_list|,
name|vectorMapJoinVariation
argument_list|,
name|MapJoinPlanVariation
operator|.
name|DYNAMIC_PARTITION_HASH_JOIN
argument_list|)
expr_stmt|;
block|}
name|seed
operator|++
expr_stmt|;
name|hiveConfVariation
operator|++
expr_stmt|;
block|}
do|while
condition|(
operator|!
name|hiveConfVariationsDone
condition|)
do|;
block|}
specifier|public
name|boolean
name|doTestLong6
parameter_list|(
name|long
name|seed
parameter_list|,
name|int
name|rowCount
parameter_list|,
name|int
name|hiveConfVariation
parameter_list|,
name|VectorMapJoinVariation
name|vectorMapJoinVariation
parameter_list|,
name|MapJoinPlanVariation
name|mapJoinPlanVariation
parameter_list|)
throws|throws
name|Exception
block|{
name|HiveConf
name|hiveConf
init|=
operator|new
name|HiveConf
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|addLongHiveConfVariation
argument_list|(
name|hiveConfVariation
argument_list|,
name|hiveConf
argument_list|)
condition|)
block|{
return|return
literal|true
return|;
block|}
name|TypeInfo
index|[]
name|bigTableTypeInfos
init|=
literal|null
decl_stmt|;
name|int
index|[]
name|bigTableKeyColumnNums
init|=
literal|null
decl_stmt|;
name|TypeInfo
index|[]
name|smallTableValueTypeInfos
init|=
literal|null
decl_stmt|;
name|int
index|[]
name|smallTableRetainKeyColumnNums
init|=
literal|null
decl_stmt|;
comment|// Cause there to be no regular FULL OUTER MapJoin MATCHes so only non-match Small Table
comment|// results.
name|SmallTableGenerationParameters
name|smallTableGenerationParameters
init|=
operator|new
name|SmallTableGenerationParameters
argument_list|()
decl_stmt|;
name|MapJoinTestDescription
name|testDesc
init|=
literal|null
decl_stmt|;
name|MapJoinTestData
name|testData
init|=
literal|null
decl_stmt|;
comment|// Big Table: long key, timestamp value; Small Table: key retained, no value
comment|// (exercise INNER_BIGONLY, LEFT_SEMI)
name|bigTableTypeInfos
operator|=
operator|new
name|TypeInfo
index|[]
block|{
name|TypeInfoFactory
operator|.
name|longTypeInfo
block|,
name|TypeInfoFactory
operator|.
name|timestampTypeInfo
block|}
expr_stmt|;
name|bigTableKeyColumnNums
operator|=
operator|new
name|int
index|[]
block|{
literal|0
block|}
expr_stmt|;
name|smallTableRetainKeyColumnNums
operator|=
operator|new
name|int
index|[]
block|{
literal|0
block|}
expr_stmt|;
name|smallTableValueTypeInfos
operator|=
operator|new
name|TypeInfo
index|[]
block|{}
expr_stmt|;
name|testDesc
operator|=
operator|new
name|MapJoinTestDescription
argument_list|(
name|hiveConf
argument_list|,
name|vectorMapJoinVariation
argument_list|,
name|bigTableTypeInfos
argument_list|,
name|bigTableKeyColumnNums
argument_list|,
name|smallTableValueTypeInfos
argument_list|,
name|smallTableRetainKeyColumnNums
argument_list|,
name|smallTableGenerationParameters
argument_list|,
name|mapJoinPlanVariation
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|goodTestVariation
argument_list|(
name|testDesc
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
name|testData
operator|=
operator|new
name|MapJoinTestData
argument_list|(
name|rowCount
argument_list|,
name|testDesc
argument_list|,
name|seed
argument_list|)
expr_stmt|;
name|executeTest
argument_list|(
name|testDesc
argument_list|,
name|testData
argument_list|,
literal|"testLong6"
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
specifier|private
name|boolean
name|addNonLongHiveConfVariation
parameter_list|(
name|int
name|hiveConfVariation
parameter_list|,
name|HiveConf
name|hiveConf
parameter_list|)
block|{
comment|// Set defaults.
name|HiveConf
operator|.
name|setIntVar
argument_list|(
name|hiveConf
argument_list|,
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVE_VECTORIZATION_MAPJOIN_NATIVE_OVERFLOW_REPEATED_THRESHOLD
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|hiveConfVariation
condition|)
block|{
case|case
literal|0
case|:
break|break;
case|case
literal|1
case|:
comment|// Force generateHashMapResultLargeMultiValue to be used.
name|HiveConf
operator|.
name|setIntVar
argument_list|(
name|hiveConf
argument_list|,
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVE_VECTORIZATION_MAPJOIN_NATIVE_OVERFLOW_REPEATED_THRESHOLD
argument_list|,
literal|5
argument_list|)
expr_stmt|;
break|break;
default|default:
return|return
literal|false
return|;
block|}
return|return
literal|true
return|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testMultiKey0
parameter_list|()
throws|throws
name|Exception
block|{
name|long
name|seed
init|=
literal|28322
decl_stmt|;
name|int
name|hiveConfVariation
init|=
literal|0
decl_stmt|;
name|boolean
name|hiveConfVariationsDone
init|=
literal|false
decl_stmt|;
do|do
block|{
for|for
control|(
name|VectorMapJoinVariation
name|vectorMapJoinVariation
range|:
name|VectorMapJoinVariation
operator|.
name|values
argument_list|()
control|)
block|{
name|hiveConfVariationsDone
operator|=
name|doTestMultiKey0
argument_list|(
name|seed
argument_list|,
name|hiveConfVariation
argument_list|,
name|vectorMapJoinVariation
argument_list|,
name|MapJoinPlanVariation
operator|.
name|DYNAMIC_PARTITION_HASH_JOIN
argument_list|)
expr_stmt|;
block|}
name|seed
operator|++
expr_stmt|;
name|hiveConfVariation
operator|++
expr_stmt|;
block|}
do|while
condition|(
operator|!
name|hiveConfVariationsDone
condition|)
do|;
block|}
specifier|public
name|boolean
name|doTestMultiKey0
parameter_list|(
name|long
name|seed
parameter_list|,
name|int
name|hiveConfVariation
parameter_list|,
name|VectorMapJoinVariation
name|vectorMapJoinVariation
parameter_list|,
name|MapJoinPlanVariation
name|mapJoinPlanVariation
parameter_list|)
throws|throws
name|Exception
block|{
name|int
name|rowCount
init|=
literal|10
decl_stmt|;
name|HiveConf
name|hiveConf
init|=
operator|new
name|HiveConf
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|addNonLongHiveConfVariation
argument_list|(
name|hiveConfVariation
argument_list|,
name|hiveConf
argument_list|)
condition|)
block|{
return|return
literal|true
return|;
block|}
name|TypeInfo
index|[]
name|bigTableTypeInfos
init|=
literal|null
decl_stmt|;
name|int
index|[]
name|bigTableKeyColumnNums
init|=
literal|null
decl_stmt|;
name|TypeInfo
index|[]
name|smallTableValueTypeInfos
init|=
literal|null
decl_stmt|;
name|int
index|[]
name|smallTableRetainKeyColumnNums
init|=
literal|null
decl_stmt|;
name|SmallTableGenerationParameters
name|smallTableGenerationParameters
init|=
operator|new
name|SmallTableGenerationParameters
argument_list|()
decl_stmt|;
name|MapJoinTestDescription
name|testDesc
init|=
literal|null
decl_stmt|;
name|MapJoinTestData
name|testData
init|=
literal|null
decl_stmt|;
comment|// Three key columns.
name|bigTableTypeInfos
operator|=
operator|new
name|TypeInfo
index|[]
block|{
name|TypeInfoFactory
operator|.
name|shortTypeInfo
block|,
name|TypeInfoFactory
operator|.
name|intTypeInfo
block|}
expr_stmt|;
name|bigTableKeyColumnNums
operator|=
operator|new
name|int
index|[]
block|{
literal|0
block|,
literal|1
block|}
expr_stmt|;
name|smallTableRetainKeyColumnNums
operator|=
operator|new
name|int
index|[]
block|{
literal|0
block|,
literal|1
block|}
expr_stmt|;
name|smallTableValueTypeInfos
operator|=
operator|new
name|TypeInfo
index|[]
block|{}
expr_stmt|;
comment|//----------------------------------------------------------------------------------------------
name|testDesc
operator|=
operator|new
name|MapJoinTestDescription
argument_list|(
name|hiveConf
argument_list|,
name|vectorMapJoinVariation
argument_list|,
name|bigTableTypeInfos
argument_list|,
name|bigTableKeyColumnNums
argument_list|,
name|smallTableValueTypeInfos
argument_list|,
name|smallTableRetainKeyColumnNums
argument_list|,
name|smallTableGenerationParameters
argument_list|,
name|mapJoinPlanVariation
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|goodTestVariation
argument_list|(
name|testDesc
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
comment|// Prepare data.  Good for ANY implementation variation.
name|testData
operator|=
operator|new
name|MapJoinTestData
argument_list|(
name|rowCount
argument_list|,
name|testDesc
argument_list|,
name|seed
argument_list|)
expr_stmt|;
name|executeTest
argument_list|(
name|testDesc
argument_list|,
name|testData
argument_list|,
literal|"testMultiKey0"
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testMultiKey1
parameter_list|()
throws|throws
name|Exception
block|{
name|long
name|seed
init|=
literal|87543
decl_stmt|;
name|int
name|hiveConfVariation
init|=
literal|0
decl_stmt|;
name|boolean
name|hiveConfVariationsDone
init|=
literal|false
decl_stmt|;
do|do
block|{
for|for
control|(
name|VectorMapJoinVariation
name|vectorMapJoinVariation
range|:
name|VectorMapJoinVariation
operator|.
name|values
argument_list|()
control|)
block|{
name|hiveConfVariationsDone
operator|=
name|doTestMultiKey1
argument_list|(
name|seed
argument_list|,
name|hiveConfVariation
argument_list|,
name|vectorMapJoinVariation
argument_list|,
name|MapJoinPlanVariation
operator|.
name|DYNAMIC_PARTITION_HASH_JOIN
argument_list|)
expr_stmt|;
block|}
name|seed
operator|++
expr_stmt|;
name|hiveConfVariation
operator|++
expr_stmt|;
block|}
do|while
condition|(
operator|!
name|hiveConfVariationsDone
condition|)
do|;
block|}
specifier|public
name|boolean
name|doTestMultiKey1
parameter_list|(
name|long
name|seed
parameter_list|,
name|int
name|hiveConfVariation
parameter_list|,
name|VectorMapJoinVariation
name|vectorMapJoinVariation
parameter_list|,
name|MapJoinPlanVariation
name|mapJoinPlanVariation
parameter_list|)
throws|throws
name|Exception
block|{
name|int
name|rowCount
init|=
literal|10
decl_stmt|;
name|HiveConf
name|hiveConf
init|=
operator|new
name|HiveConf
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|addNonLongHiveConfVariation
argument_list|(
name|hiveConfVariation
argument_list|,
name|hiveConf
argument_list|)
condition|)
block|{
return|return
literal|true
return|;
block|}
name|TypeInfo
index|[]
name|bigTableTypeInfos
init|=
literal|null
decl_stmt|;
name|int
index|[]
name|bigTableKeyColumnNums
init|=
literal|null
decl_stmt|;
name|TypeInfo
index|[]
name|smallTableValueTypeInfos
init|=
literal|null
decl_stmt|;
name|int
index|[]
name|smallTableRetainKeyColumnNums
init|=
literal|null
decl_stmt|;
name|SmallTableGenerationParameters
name|smallTableGenerationParameters
init|=
operator|new
name|SmallTableGenerationParameters
argument_list|()
decl_stmt|;
name|MapJoinTestDescription
name|testDesc
init|=
literal|null
decl_stmt|;
name|MapJoinTestData
name|testData
init|=
literal|null
decl_stmt|;
comment|// Three key columns.
name|bigTableTypeInfos
operator|=
operator|new
name|TypeInfo
index|[]
block|{
name|TypeInfoFactory
operator|.
name|timestampTypeInfo
block|,
name|TypeInfoFactory
operator|.
name|shortTypeInfo
block|,
name|TypeInfoFactory
operator|.
name|stringTypeInfo
block|}
expr_stmt|;
name|bigTableKeyColumnNums
operator|=
operator|new
name|int
index|[]
block|{
literal|0
block|,
literal|1
block|,
literal|2
block|}
expr_stmt|;
name|smallTableRetainKeyColumnNums
operator|=
operator|new
name|int
index|[]
block|{
literal|0
block|,
literal|1
block|,
literal|2
block|}
expr_stmt|;
name|smallTableValueTypeInfos
operator|=
operator|new
name|TypeInfo
index|[]
block|{
operator|new
name|DecimalTypeInfo
argument_list|(
literal|38
argument_list|,
literal|18
argument_list|)
block|}
expr_stmt|;
comment|//----------------------------------------------------------------------------------------------
name|testDesc
operator|=
operator|new
name|MapJoinTestDescription
argument_list|(
name|hiveConf
argument_list|,
name|vectorMapJoinVariation
argument_list|,
name|bigTableTypeInfos
argument_list|,
name|bigTableKeyColumnNums
argument_list|,
name|smallTableValueTypeInfos
argument_list|,
name|smallTableRetainKeyColumnNums
argument_list|,
name|smallTableGenerationParameters
argument_list|,
name|mapJoinPlanVariation
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|goodTestVariation
argument_list|(
name|testDesc
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
comment|// Prepare data.  Good for ANY implementation variation.
name|testData
operator|=
operator|new
name|MapJoinTestData
argument_list|(
name|rowCount
argument_list|,
name|testDesc
argument_list|,
name|seed
argument_list|)
expr_stmt|;
name|executeTest
argument_list|(
name|testDesc
argument_list|,
name|testData
argument_list|,
literal|"testMultiKey1"
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testMultiKey2
parameter_list|()
throws|throws
name|Exception
block|{
name|long
name|seed
init|=
literal|87543
decl_stmt|;
name|int
name|hiveConfVariation
init|=
literal|0
decl_stmt|;
name|boolean
name|hiveConfVariationsDone
init|=
literal|false
decl_stmt|;
do|do
block|{
for|for
control|(
name|VectorMapJoinVariation
name|vectorMapJoinVariation
range|:
name|VectorMapJoinVariation
operator|.
name|values
argument_list|()
control|)
block|{
name|hiveConfVariationsDone
operator|=
name|doTestMultiKey2
argument_list|(
name|seed
argument_list|,
name|hiveConfVariation
argument_list|,
name|vectorMapJoinVariation
argument_list|,
name|MapJoinPlanVariation
operator|.
name|DYNAMIC_PARTITION_HASH_JOIN
argument_list|)
expr_stmt|;
block|}
name|seed
operator|++
expr_stmt|;
name|hiveConfVariation
operator|++
expr_stmt|;
block|}
do|while
condition|(
operator|!
name|hiveConfVariationsDone
condition|)
do|;
block|}
specifier|public
name|boolean
name|doTestMultiKey2
parameter_list|(
name|long
name|seed
parameter_list|,
name|int
name|hiveConfVariation
parameter_list|,
name|VectorMapJoinVariation
name|vectorMapJoinVariation
parameter_list|,
name|MapJoinPlanVariation
name|mapJoinPlanVariation
parameter_list|)
throws|throws
name|Exception
block|{
name|int
name|rowCount
init|=
literal|10
decl_stmt|;
name|HiveConf
name|hiveConf
init|=
operator|new
name|HiveConf
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|addNonLongHiveConfVariation
argument_list|(
name|hiveConfVariation
argument_list|,
name|hiveConf
argument_list|)
condition|)
block|{
return|return
literal|true
return|;
block|}
name|TypeInfo
index|[]
name|bigTableTypeInfos
init|=
literal|null
decl_stmt|;
name|int
index|[]
name|bigTableKeyColumnNums
init|=
literal|null
decl_stmt|;
name|TypeInfo
index|[]
name|smallTableValueTypeInfos
init|=
literal|null
decl_stmt|;
name|int
index|[]
name|smallTableRetainKeyColumnNums
init|=
literal|null
decl_stmt|;
name|SmallTableGenerationParameters
name|smallTableGenerationParameters
init|=
operator|new
name|SmallTableGenerationParameters
argument_list|()
decl_stmt|;
name|MapJoinTestDescription
name|testDesc
init|=
literal|null
decl_stmt|;
name|MapJoinTestData
name|testData
init|=
literal|null
decl_stmt|;
comment|// Three key columns.
name|bigTableTypeInfos
operator|=
operator|new
name|TypeInfo
index|[]
block|{
name|TypeInfoFactory
operator|.
name|longTypeInfo
block|,
name|TypeInfoFactory
operator|.
name|shortTypeInfo
block|,
name|TypeInfoFactory
operator|.
name|stringTypeInfo
block|}
expr_stmt|;
name|bigTableKeyColumnNums
operator|=
operator|new
name|int
index|[]
block|{
literal|0
block|,
literal|1
block|,
literal|2
block|}
expr_stmt|;
name|smallTableRetainKeyColumnNums
operator|=
operator|new
name|int
index|[]
block|{
literal|0
block|,
literal|1
block|,
literal|2
block|}
expr_stmt|;
name|smallTableValueTypeInfos
operator|=
operator|new
name|TypeInfo
index|[]
block|{
name|TypeInfoFactory
operator|.
name|stringTypeInfo
block|}
expr_stmt|;
comment|//----------------------------------------------------------------------------------------------
name|testDesc
operator|=
operator|new
name|MapJoinTestDescription
argument_list|(
name|hiveConf
argument_list|,
name|vectorMapJoinVariation
argument_list|,
name|bigTableTypeInfos
argument_list|,
name|bigTableKeyColumnNums
argument_list|,
name|smallTableValueTypeInfos
argument_list|,
name|smallTableRetainKeyColumnNums
argument_list|,
name|smallTableGenerationParameters
argument_list|,
name|mapJoinPlanVariation
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|goodTestVariation
argument_list|(
name|testDesc
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
comment|// Prepare data.  Good for ANY implementation variation.
name|testData
operator|=
operator|new
name|MapJoinTestData
argument_list|(
name|rowCount
argument_list|,
name|testDesc
argument_list|,
name|seed
argument_list|)
expr_stmt|;
name|executeTest
argument_list|(
name|testDesc
argument_list|,
name|testData
argument_list|,
literal|"testMultiKey0"
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testMultiKey3
parameter_list|()
throws|throws
name|Exception
block|{
name|long
name|seed
init|=
literal|87543
decl_stmt|;
name|int
name|hiveConfVariation
init|=
literal|0
decl_stmt|;
name|boolean
name|hiveConfVariationsDone
init|=
literal|false
decl_stmt|;
do|do
block|{
for|for
control|(
name|VectorMapJoinVariation
name|vectorMapJoinVariation
range|:
name|VectorMapJoinVariation
operator|.
name|values
argument_list|()
control|)
block|{
name|hiveConfVariationsDone
operator|=
name|doTestMultiKey3
argument_list|(
name|seed
argument_list|,
name|hiveConfVariation
argument_list|,
name|vectorMapJoinVariation
argument_list|,
name|MapJoinPlanVariation
operator|.
name|DYNAMIC_PARTITION_HASH_JOIN
argument_list|)
expr_stmt|;
block|}
name|seed
operator|++
expr_stmt|;
name|hiveConfVariation
operator|++
expr_stmt|;
block|}
do|while
condition|(
operator|!
name|hiveConfVariationsDone
condition|)
do|;
block|}
specifier|public
name|boolean
name|doTestMultiKey3
parameter_list|(
name|long
name|seed
parameter_list|,
name|int
name|hiveConfVariation
parameter_list|,
name|VectorMapJoinVariation
name|vectorMapJoinVariation
parameter_list|,
name|MapJoinPlanVariation
name|mapJoinPlanVariation
parameter_list|)
throws|throws
name|Exception
block|{
name|int
name|rowCount
init|=
literal|10
decl_stmt|;
name|HiveConf
name|hiveConf
init|=
operator|new
name|HiveConf
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|addNonLongHiveConfVariation
argument_list|(
name|hiveConfVariation
argument_list|,
name|hiveConf
argument_list|)
condition|)
block|{
return|return
literal|true
return|;
block|}
name|TypeInfo
index|[]
name|bigTableTypeInfos
init|=
literal|null
decl_stmt|;
name|int
index|[]
name|bigTableKeyColumnNums
init|=
literal|null
decl_stmt|;
name|TypeInfo
index|[]
name|smallTableValueTypeInfos
init|=
literal|null
decl_stmt|;
name|int
index|[]
name|smallTableRetainKeyColumnNums
init|=
literal|null
decl_stmt|;
name|SmallTableGenerationParameters
name|smallTableGenerationParameters
init|=
operator|new
name|SmallTableGenerationParameters
argument_list|()
decl_stmt|;
name|MapJoinTestDescription
name|testDesc
init|=
literal|null
decl_stmt|;
name|MapJoinTestData
name|testData
init|=
literal|null
decl_stmt|;
comment|// Three key columns.
name|bigTableTypeInfos
operator|=
operator|new
name|TypeInfo
index|[]
block|{
name|TypeInfoFactory
operator|.
name|dateTypeInfo
block|,
name|TypeInfoFactory
operator|.
name|byteTypeInfo
block|}
expr_stmt|;
name|bigTableKeyColumnNums
operator|=
operator|new
name|int
index|[]
block|{
literal|0
block|,
literal|1
block|}
expr_stmt|;
name|smallTableRetainKeyColumnNums
operator|=
operator|new
name|int
index|[]
block|{
literal|0
block|,
literal|1
block|}
expr_stmt|;
name|smallTableValueTypeInfos
operator|=
operator|new
name|TypeInfo
index|[]
block|{}
expr_stmt|;
comment|//----------------------------------------------------------------------------------------------
name|testDesc
operator|=
operator|new
name|MapJoinTestDescription
argument_list|(
name|hiveConf
argument_list|,
name|vectorMapJoinVariation
argument_list|,
name|bigTableTypeInfos
argument_list|,
name|bigTableKeyColumnNums
argument_list|,
name|smallTableValueTypeInfos
argument_list|,
name|smallTableRetainKeyColumnNums
argument_list|,
name|smallTableGenerationParameters
argument_list|,
name|mapJoinPlanVariation
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|goodTestVariation
argument_list|(
name|testDesc
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
comment|// Prepare data.  Good for ANY implementation variation.
name|testData
operator|=
operator|new
name|MapJoinTestData
argument_list|(
name|rowCount
argument_list|,
name|testDesc
argument_list|,
name|seed
argument_list|)
expr_stmt|;
name|executeTest
argument_list|(
name|testDesc
argument_list|,
name|testData
argument_list|,
literal|"testMultiKey3"
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testString0
parameter_list|()
throws|throws
name|Exception
block|{
name|long
name|seed
init|=
literal|87543
decl_stmt|;
name|int
name|hiveConfVariation
init|=
literal|0
decl_stmt|;
name|boolean
name|hiveConfVariationsDone
init|=
literal|false
decl_stmt|;
do|do
block|{
for|for
control|(
name|VectorMapJoinVariation
name|vectorMapJoinVariation
range|:
name|VectorMapJoinVariation
operator|.
name|values
argument_list|()
control|)
block|{
name|hiveConfVariationsDone
operator|=
name|doTestString0
argument_list|(
name|seed
argument_list|,
name|hiveConfVariation
argument_list|,
name|vectorMapJoinVariation
argument_list|,
name|MapJoinPlanVariation
operator|.
name|DYNAMIC_PARTITION_HASH_JOIN
argument_list|)
expr_stmt|;
block|}
name|seed
operator|++
expr_stmt|;
name|hiveConfVariation
operator|++
expr_stmt|;
block|}
do|while
condition|(
operator|!
name|hiveConfVariationsDone
condition|)
do|;
block|}
specifier|public
name|boolean
name|doTestString0
parameter_list|(
name|long
name|seed
parameter_list|,
name|int
name|hiveConfVariation
parameter_list|,
name|VectorMapJoinVariation
name|vectorMapJoinVariation
parameter_list|,
name|MapJoinPlanVariation
name|mapJoinPlanVariation
parameter_list|)
throws|throws
name|Exception
block|{
name|int
name|rowCount
init|=
literal|10
decl_stmt|;
name|HiveConf
name|hiveConf
init|=
operator|new
name|HiveConf
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|addNonLongHiveConfVariation
argument_list|(
name|hiveConfVariation
argument_list|,
name|hiveConf
argument_list|)
condition|)
block|{
return|return
literal|true
return|;
block|}
name|TypeInfo
index|[]
name|bigTableTypeInfos
init|=
literal|null
decl_stmt|;
name|int
index|[]
name|bigTableKeyColumnNums
init|=
literal|null
decl_stmt|;
name|TypeInfo
index|[]
name|smallTableValueTypeInfos
init|=
literal|null
decl_stmt|;
name|int
index|[]
name|smallTableRetainKeyColumnNums
init|=
literal|null
decl_stmt|;
name|SmallTableGenerationParameters
name|smallTableGenerationParameters
init|=
operator|new
name|SmallTableGenerationParameters
argument_list|()
decl_stmt|;
name|MapJoinTestDescription
name|testDesc
init|=
literal|null
decl_stmt|;
name|MapJoinTestData
name|testData
init|=
literal|null
decl_stmt|;
comment|// One plain STRING key column.
name|bigTableTypeInfos
operator|=
operator|new
name|TypeInfo
index|[]
block|{
name|TypeInfoFactory
operator|.
name|stringTypeInfo
block|}
expr_stmt|;
name|bigTableKeyColumnNums
operator|=
operator|new
name|int
index|[]
block|{
literal|0
block|}
expr_stmt|;
name|smallTableRetainKeyColumnNums
operator|=
operator|new
name|int
index|[]
block|{
literal|0
block|}
expr_stmt|;
name|smallTableValueTypeInfos
operator|=
operator|new
name|TypeInfo
index|[]
block|{
name|TypeInfoFactory
operator|.
name|dateTypeInfo
block|,
name|TypeInfoFactory
operator|.
name|timestampTypeInfo
block|}
expr_stmt|;
comment|//----------------------------------------------------------------------------------------------
name|testDesc
operator|=
operator|new
name|MapJoinTestDescription
argument_list|(
name|hiveConf
argument_list|,
name|vectorMapJoinVariation
argument_list|,
name|bigTableTypeInfos
argument_list|,
name|bigTableKeyColumnNums
argument_list|,
name|smallTableValueTypeInfos
argument_list|,
name|smallTableRetainKeyColumnNums
argument_list|,
name|smallTableGenerationParameters
argument_list|,
name|mapJoinPlanVariation
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|goodTestVariation
argument_list|(
name|testDesc
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
comment|// Prepare data.  Good for ANY implementation variation.
name|testData
operator|=
operator|new
name|MapJoinTestData
argument_list|(
name|rowCount
argument_list|,
name|testDesc
argument_list|,
name|seed
argument_list|)
expr_stmt|;
name|executeTest
argument_list|(
name|testDesc
argument_list|,
name|testData
argument_list|,
literal|"testString0"
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testString1
parameter_list|()
throws|throws
name|Exception
block|{
name|long
name|seed
init|=
literal|3422
decl_stmt|;
name|int
name|hiveConfVariation
init|=
literal|0
decl_stmt|;
name|boolean
name|hiveConfVariationsDone
init|=
literal|false
decl_stmt|;
do|do
block|{
for|for
control|(
name|VectorMapJoinVariation
name|vectorMapJoinVariation
range|:
name|VectorMapJoinVariation
operator|.
name|values
argument_list|()
control|)
block|{
name|hiveConfVariationsDone
operator|=
name|doTestString1
argument_list|(
name|seed
argument_list|,
name|hiveConfVariation
argument_list|,
name|vectorMapJoinVariation
argument_list|,
name|MapJoinPlanVariation
operator|.
name|DYNAMIC_PARTITION_HASH_JOIN
argument_list|)
expr_stmt|;
block|}
name|seed
operator|++
expr_stmt|;
name|hiveConfVariation
operator|++
expr_stmt|;
block|}
do|while
condition|(
operator|!
name|hiveConfVariationsDone
condition|)
do|;
block|}
specifier|public
name|boolean
name|doTestString1
parameter_list|(
name|long
name|seed
parameter_list|,
name|int
name|hiveConfVariation
parameter_list|,
name|VectorMapJoinVariation
name|vectorMapJoinVariation
parameter_list|,
name|MapJoinPlanVariation
name|mapJoinPlanVariation
parameter_list|)
throws|throws
name|Exception
block|{
name|int
name|rowCount
init|=
literal|10
decl_stmt|;
name|HiveConf
name|hiveConf
init|=
operator|new
name|HiveConf
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|addNonLongHiveConfVariation
argument_list|(
name|hiveConfVariation
argument_list|,
name|hiveConf
argument_list|)
condition|)
block|{
return|return
literal|true
return|;
block|}
name|TypeInfo
index|[]
name|bigTableTypeInfos
init|=
literal|null
decl_stmt|;
name|int
index|[]
name|bigTableKeyColumnNums
init|=
literal|null
decl_stmt|;
name|TypeInfo
index|[]
name|smallTableValueTypeInfos
init|=
literal|null
decl_stmt|;
name|int
index|[]
name|smallTableRetainKeyColumnNums
init|=
literal|null
decl_stmt|;
name|SmallTableGenerationParameters
name|smallTableGenerationParameters
init|=
operator|new
name|SmallTableGenerationParameters
argument_list|()
decl_stmt|;
name|MapJoinTestDescription
name|testDesc
init|=
literal|null
decl_stmt|;
name|MapJoinTestData
name|testData
init|=
literal|null
decl_stmt|;
comment|// One BINARY key column.
name|bigTableTypeInfos
operator|=
operator|new
name|TypeInfo
index|[]
block|{
name|TypeInfoFactory
operator|.
name|binaryTypeInfo
block|}
expr_stmt|;
name|bigTableKeyColumnNums
operator|=
operator|new
name|int
index|[]
block|{
literal|0
block|}
expr_stmt|;
name|smallTableRetainKeyColumnNums
operator|=
operator|new
name|int
index|[]
block|{
literal|0
block|}
expr_stmt|;
name|smallTableValueTypeInfos
operator|=
operator|new
name|TypeInfo
index|[]
block|{
name|TypeInfoFactory
operator|.
name|shortTypeInfo
block|,
name|TypeInfoFactory
operator|.
name|floatTypeInfo
block|,
operator|new
name|DecimalTypeInfo
argument_list|(
literal|38
argument_list|,
literal|18
argument_list|)
block|}
expr_stmt|;
name|smallTableGenerationParameters
operator|=
operator|new
name|SmallTableGenerationParameters
argument_list|()
expr_stmt|;
comment|//----------------------------------------------------------------------------------------------
name|testDesc
operator|=
operator|new
name|MapJoinTestDescription
argument_list|(
name|hiveConf
argument_list|,
name|vectorMapJoinVariation
argument_list|,
name|bigTableTypeInfos
argument_list|,
name|bigTableKeyColumnNums
argument_list|,
name|smallTableValueTypeInfos
argument_list|,
name|smallTableRetainKeyColumnNums
argument_list|,
name|smallTableGenerationParameters
argument_list|,
name|mapJoinPlanVariation
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|goodTestVariation
argument_list|(
name|testDesc
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
comment|// Prepare data.  Good for ANY implementation variation.
name|testData
operator|=
operator|new
name|MapJoinTestData
argument_list|(
name|rowCount
argument_list|,
name|testDesc
argument_list|,
name|seed
argument_list|)
expr_stmt|;
name|executeTest
argument_list|(
name|testDesc
argument_list|,
name|testData
argument_list|,
literal|"testString1"
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
annotation|@
name|Test
specifier|public
name|void
name|testString2
parameter_list|()
throws|throws
name|Exception
block|{
name|long
name|seed
init|=
literal|7439
decl_stmt|;
name|int
name|hiveConfVariation
init|=
literal|0
decl_stmt|;
name|boolean
name|hiveConfVariationsDone
init|=
literal|false
decl_stmt|;
do|do
block|{
for|for
control|(
name|VectorMapJoinVariation
name|vectorMapJoinVariation
range|:
name|VectorMapJoinVariation
operator|.
name|values
argument_list|()
control|)
block|{
name|hiveConfVariationsDone
operator|=
name|doTestString2
argument_list|(
name|seed
argument_list|,
name|hiveConfVariation
argument_list|,
name|vectorMapJoinVariation
argument_list|,
name|MapJoinPlanVariation
operator|.
name|DYNAMIC_PARTITION_HASH_JOIN
argument_list|)
expr_stmt|;
block|}
name|seed
operator|++
expr_stmt|;
name|hiveConfVariation
operator|++
expr_stmt|;
block|}
do|while
condition|(
operator|!
name|hiveConfVariationsDone
condition|)
do|;
block|}
specifier|public
name|boolean
name|doTestString2
parameter_list|(
name|long
name|seed
parameter_list|,
name|int
name|hiveConfVariation
parameter_list|,
name|VectorMapJoinVariation
name|vectorMapJoinVariation
parameter_list|,
name|MapJoinPlanVariation
name|mapJoinPlanVariation
parameter_list|)
throws|throws
name|Exception
block|{
name|int
name|rowCount
init|=
literal|10
decl_stmt|;
name|HiveConf
name|hiveConf
init|=
operator|new
name|HiveConf
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|addNonLongHiveConfVariation
argument_list|(
name|hiveConfVariation
argument_list|,
name|hiveConf
argument_list|)
condition|)
block|{
return|return
literal|true
return|;
block|}
name|TypeInfo
index|[]
name|bigTableTypeInfos
init|=
literal|null
decl_stmt|;
name|int
index|[]
name|bigTableKeyColumnNums
init|=
literal|null
decl_stmt|;
name|TypeInfo
index|[]
name|smallTableValueTypeInfos
init|=
literal|null
decl_stmt|;
name|int
index|[]
name|smallTableRetainKeyColumnNums
init|=
literal|null
decl_stmt|;
name|SmallTableGenerationParameters
name|smallTableGenerationParameters
init|=
operator|new
name|SmallTableGenerationParameters
argument_list|()
decl_stmt|;
name|MapJoinTestDescription
name|testDesc
init|=
literal|null
decl_stmt|;
name|MapJoinTestData
name|testData
init|=
literal|null
decl_stmt|;
comment|// One STRING key column; Small Table value: NONE (tests INNER_BIG_ONLY, LEFT_SEMI).
name|bigTableTypeInfos
operator|=
operator|new
name|TypeInfo
index|[]
block|{
name|TypeInfoFactory
operator|.
name|stringTypeInfo
block|}
expr_stmt|;
name|bigTableKeyColumnNums
operator|=
operator|new
name|int
index|[]
block|{
literal|0
block|}
expr_stmt|;
name|smallTableRetainKeyColumnNums
operator|=
operator|new
name|int
index|[]
block|{
literal|0
block|}
expr_stmt|;
name|smallTableValueTypeInfos
operator|=
operator|new
name|TypeInfo
index|[]
block|{}
expr_stmt|;
name|smallTableGenerationParameters
operator|=
operator|new
name|SmallTableGenerationParameters
argument_list|()
expr_stmt|;
comment|//----------------------------------------------------------------------------------------------
name|testDesc
operator|=
operator|new
name|MapJoinTestDescription
argument_list|(
name|hiveConf
argument_list|,
name|vectorMapJoinVariation
argument_list|,
name|bigTableTypeInfos
argument_list|,
name|bigTableKeyColumnNums
argument_list|,
name|smallTableValueTypeInfos
argument_list|,
name|smallTableRetainKeyColumnNums
argument_list|,
name|smallTableGenerationParameters
argument_list|,
name|mapJoinPlanVariation
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|goodTestVariation
argument_list|(
name|testDesc
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
comment|// Prepare data.  Good for ANY implementation variation.
name|testData
operator|=
operator|new
name|MapJoinTestData
argument_list|(
name|rowCount
argument_list|,
name|testDesc
argument_list|,
name|seed
argument_list|)
expr_stmt|;
name|executeTest
argument_list|(
name|testDesc
argument_list|,
name|testData
argument_list|,
literal|"testString2"
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
specifier|private
name|void
name|addBigTableRetained
parameter_list|(
name|MapJoinTestDescription
name|testDesc
parameter_list|,
name|Object
index|[]
name|bigTableRowObjects
parameter_list|,
name|Object
index|[]
name|outputObjects
parameter_list|)
block|{
specifier|final
name|int
name|bigTableRetainColumnNumsLength
init|=
name|testDesc
operator|.
name|bigTableRetainColumnNums
operator|.
name|length
decl_stmt|;
for|for
control|(
name|int
name|o
init|=
literal|0
init|;
name|o
operator|<
name|bigTableRetainColumnNumsLength
condition|;
name|o
operator|++
control|)
block|{
name|outputObjects
index|[
name|o
index|]
operator|=
name|bigTableRowObjects
index|[
name|testDesc
operator|.
name|bigTableRetainColumnNums
index|[
name|o
index|]
index|]
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|addToOutput
parameter_list|(
name|MapJoinTestDescription
name|testDesc
parameter_list|,
name|RowTestObjectsMultiSet
name|expectedTestRowMultiSet
parameter_list|,
name|Object
index|[]
name|outputObjects
parameter_list|,
name|RowTestObjectsMultiSet
operator|.
name|RowFlag
name|rowFlag
parameter_list|)
block|{
for|for
control|(
name|int
name|c
init|=
literal|0
init|;
name|c
operator|<
name|outputObjects
operator|.
name|length
condition|;
name|c
operator|++
control|)
block|{
name|PrimitiveObjectInspector
name|primitiveObjInsp
init|=
operator|(
operator|(
name|PrimitiveObjectInspector
operator|)
name|testDesc
operator|.
name|outputObjectInspectors
index|[
name|c
index|]
operator|)
decl_stmt|;
name|Object
name|outputObject
init|=
name|outputObjects
index|[
name|c
index|]
decl_stmt|;
name|outputObjects
index|[
name|c
index|]
operator|=
name|primitiveObjInsp
operator|.
name|copyObject
argument_list|(
name|outputObject
argument_list|)
expr_stmt|;
block|}
name|expectedTestRowMultiSet
operator|.
name|add
argument_list|(
operator|new
name|RowTestObjects
argument_list|(
name|outputObjects
argument_list|)
argument_list|,
name|rowFlag
argument_list|)
expr_stmt|;
block|}
specifier|private
name|String
name|rowToCsvString
parameter_list|(
name|Object
index|[]
name|rowObjects
parameter_list|)
block|{
name|StringBuilder
name|sb
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|rowObjects
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|sb
operator|.
name|length
argument_list|()
operator|>
literal|0
condition|)
block|{
name|sb
operator|.
name|append
argument_list|(
literal|","
argument_list|)
expr_stmt|;
block|}
name|Object
name|obj
init|=
name|rowObjects
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|obj
operator|==
literal|null
condition|)
block|{
name|sb
operator|.
name|append
argument_list|(
literal|"\\N"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sb
operator|.
name|append
argument_list|(
name|obj
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|sb
operator|.
name|toString
argument_list|()
return|;
block|}
comment|/*    * Simulate the join by driving the test big table data by our test small table HashMap and    * create the expected output as a multi-set of TestRow (i.e. TestRow and occurrence count).    */
specifier|private
name|RowTestObjectsMultiSet
name|createExpectedTestRowMultiSet
parameter_list|(
name|MapJoinTestDescription
name|testDesc
parameter_list|,
name|MapJoinTestData
name|testData
parameter_list|)
throws|throws
name|HiveException
block|{
name|RowTestObjectsMultiSet
name|expectedTestRowMultiSet
init|=
operator|new
name|RowTestObjectsMultiSet
argument_list|()
decl_stmt|;
name|VectorExtractRow
name|vectorExtractRow
init|=
operator|new
name|VectorExtractRow
argument_list|()
decl_stmt|;
name|vectorExtractRow
operator|.
name|init
argument_list|(
name|testDesc
operator|.
name|bigTableTypeInfos
argument_list|)
expr_stmt|;
specifier|final
name|int
name|bigTableColumnCount
init|=
name|testDesc
operator|.
name|bigTableTypeInfos
operator|.
name|length
decl_stmt|;
name|Object
index|[]
name|bigTableRowObjects
init|=
operator|new
name|Object
index|[
name|bigTableColumnCount
index|]
decl_stmt|;
specifier|final
name|int
name|bigTableKeyColumnCount
init|=
name|testDesc
operator|.
name|bigTableKeyTypeInfos
operator|.
name|length
decl_stmt|;
name|Object
index|[]
name|bigTableKeyObjects
init|=
operator|new
name|Object
index|[
name|bigTableKeyColumnCount
index|]
decl_stmt|;
name|VectorRandomBatchSource
name|bigTableBatchSource
init|=
name|testData
operator|.
name|getBigTableBatchSource
argument_list|()
decl_stmt|;
name|VectorizedRowBatch
name|batch
init|=
name|testData
operator|.
name|getBigTableBatch
argument_list|()
decl_stmt|;
name|bigTableBatchSource
operator|.
name|resetBatchIteration
argument_list|()
expr_stmt|;
while|while
condition|(
name|bigTableBatchSource
operator|.
name|fillNextBatch
argument_list|(
name|batch
argument_list|)
condition|)
block|{
specifier|final
name|int
name|size
init|=
name|testData
operator|.
name|bigTableBatch
operator|.
name|size
decl_stmt|;
for|for
control|(
name|int
name|r
init|=
literal|0
init|;
name|r
operator|<
name|size
condition|;
name|r
operator|++
control|)
block|{
name|vectorExtractRow
operator|.
name|extractRow
argument_list|(
name|testData
operator|.
name|bigTableBatch
argument_list|,
name|r
argument_list|,
name|bigTableRowObjects
argument_list|)
expr_stmt|;
comment|// Form key object array
name|boolean
name|hasAnyNulls
init|=
literal|false
decl_stmt|;
comment|// NULLs may be present in {FULL|LEFT|RIGHT} OUTER joins.
for|for
control|(
name|int
name|k
init|=
literal|0
init|;
name|k
operator|<
name|bigTableKeyColumnCount
condition|;
name|k
operator|++
control|)
block|{
name|int
name|keyColumnNum
init|=
name|testDesc
operator|.
name|bigTableKeyColumnNums
index|[
name|k
index|]
decl_stmt|;
name|Object
name|keyObject
init|=
name|bigTableRowObjects
index|[
name|keyColumnNum
index|]
decl_stmt|;
if|if
condition|(
name|keyObject
operator|==
literal|null
condition|)
block|{
name|hasAnyNulls
operator|=
literal|true
expr_stmt|;
block|}
name|bigTableKeyObjects
index|[
name|k
index|]
operator|=
name|keyObject
expr_stmt|;
name|bigTableKeyObjects
index|[
name|k
index|]
operator|=
operator|(
operator|(
name|PrimitiveObjectInspector
operator|)
name|testDesc
operator|.
name|bigTableObjectInspectors
index|[
name|keyColumnNum
index|]
operator|)
operator|.
name|copyObject
argument_list|(
name|bigTableKeyObjects
index|[
name|k
index|]
argument_list|)
expr_stmt|;
block|}
name|RowTestObjects
name|testKey
init|=
operator|new
name|RowTestObjects
argument_list|(
name|bigTableKeyObjects
argument_list|)
decl_stmt|;
if|if
condition|(
name|testData
operator|.
name|smallTableKeyHashMap
operator|.
name|containsKey
argument_list|(
name|testKey
argument_list|)
operator|&&
operator|!
name|hasAnyNulls
condition|)
block|{
name|int
name|smallTableKeyIndex
init|=
name|testData
operator|.
name|smallTableKeyHashMap
operator|.
name|get
argument_list|(
name|testKey
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|testDesc
operator|.
name|vectorMapJoinVariation
condition|)
block|{
case|case
name|INNER
case|:
case|case
name|OUTER
case|:
case|case
name|FULL_OUTER
case|:
block|{
comment|// One row per value.
name|ArrayList
argument_list|<
name|RowTestObjects
argument_list|>
name|valueList
init|=
name|testData
operator|.
name|smallTableValues
operator|.
name|get
argument_list|(
name|smallTableKeyIndex
argument_list|)
decl_stmt|;
specifier|final
name|int
name|valueCount
init|=
name|valueList
operator|.
name|size
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|v
init|=
literal|0
init|;
name|v
operator|<
name|valueCount
condition|;
name|v
operator|++
control|)
block|{
name|Object
index|[]
name|outputObjects
init|=
operator|new
name|Object
index|[
name|testDesc
operator|.
name|outputColumnNames
operator|.
name|length
index|]
decl_stmt|;
name|addBigTableRetained
argument_list|(
name|testDesc
argument_list|,
name|bigTableRowObjects
argument_list|,
name|outputObjects
argument_list|)
expr_stmt|;
name|int
name|outputColumnNum
init|=
name|testDesc
operator|.
name|bigTableRetainColumnNums
operator|.
name|length
decl_stmt|;
specifier|final
name|int
name|smallTableRetainKeyColumnNumsLength
init|=
name|testDesc
operator|.
name|smallTableRetainKeyColumnNums
operator|.
name|length
decl_stmt|;
for|for
control|(
name|int
name|o
init|=
literal|0
init|;
name|o
operator|<
name|smallTableRetainKeyColumnNumsLength
condition|;
name|o
operator|++
control|)
block|{
name|outputObjects
index|[
name|outputColumnNum
operator|++
index|]
operator|=
name|bigTableKeyObjects
index|[
name|testDesc
operator|.
name|smallTableRetainKeyColumnNums
index|[
name|o
index|]
index|]
expr_stmt|;
block|}
name|Object
index|[]
name|valueRow
init|=
name|valueList
operator|.
name|get
argument_list|(
name|v
argument_list|)
operator|.
name|getRow
argument_list|()
decl_stmt|;
specifier|final
name|int
name|smallTableRetainValueColumnNumsLength
init|=
name|testDesc
operator|.
name|smallTableRetainValueColumnNums
operator|.
name|length
decl_stmt|;
for|for
control|(
name|int
name|o
init|=
literal|0
init|;
name|o
operator|<
name|smallTableRetainValueColumnNumsLength
condition|;
name|o
operator|++
control|)
block|{
name|outputObjects
index|[
name|outputColumnNum
operator|++
index|]
operator|=
name|valueRow
index|[
name|testDesc
operator|.
name|smallTableRetainValueColumnNums
index|[
name|o
index|]
index|]
expr_stmt|;
block|}
name|addToOutput
argument_list|(
name|testDesc
argument_list|,
name|expectedTestRowMultiSet
argument_list|,
name|outputObjects
argument_list|,
name|RowTestObjectsMultiSet
operator|.
name|RowFlag
operator|.
name|REGULAR
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|INNER_BIG_ONLY
case|:
case|case
name|LEFT_SEMI
case|:
block|{
name|Object
index|[]
name|outputObjects
init|=
operator|new
name|Object
index|[
name|testDesc
operator|.
name|outputColumnNames
operator|.
name|length
index|]
decl_stmt|;
name|addBigTableRetained
argument_list|(
name|testDesc
argument_list|,
name|bigTableRowObjects
argument_list|,
name|outputObjects
argument_list|)
expr_stmt|;
name|int
name|outputColumnNum
init|=
name|testDesc
operator|.
name|bigTableRetainColumnNums
operator|.
name|length
decl_stmt|;
specifier|final
name|int
name|smallTableRetainKeyColumnNumsLength
init|=
name|testDesc
operator|.
name|smallTableRetainKeyColumnNums
operator|.
name|length
decl_stmt|;
for|for
control|(
name|int
name|o
init|=
literal|0
init|;
name|o
operator|<
name|smallTableRetainKeyColumnNumsLength
condition|;
name|o
operator|++
control|)
block|{
name|outputObjects
index|[
name|outputColumnNum
operator|++
index|]
operator|=
name|bigTableKeyObjects
index|[
name|testDesc
operator|.
name|smallTableRetainKeyColumnNums
index|[
name|o
index|]
index|]
expr_stmt|;
block|}
name|addToOutput
argument_list|(
name|testDesc
argument_list|,
name|expectedTestRowMultiSet
argument_list|,
name|outputObjects
argument_list|,
name|RowTestObjectsMultiSet
operator|.
name|RowFlag
operator|.
name|REGULAR
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Unknown operator variation "
operator|+
name|testDesc
operator|.
name|vectorMapJoinVariation
argument_list|)
throw|;
block|}
block|}
else|else
block|{
comment|// Big Table non-match.
if|if
condition|(
name|testDesc
operator|.
name|vectorMapJoinVariation
operator|==
name|VectorMapJoinVariation
operator|.
name|OUTER
operator|||
name|testDesc
operator|.
name|vectorMapJoinVariation
operator|==
name|VectorMapJoinVariation
operator|.
name|FULL_OUTER
condition|)
block|{
comment|// We need to add a non-match row with nulls for small table values.
name|Object
index|[]
name|outputObjects
init|=
operator|new
name|Object
index|[
name|testDesc
operator|.
name|outputColumnNames
operator|.
name|length
index|]
decl_stmt|;
name|addBigTableRetained
argument_list|(
name|testDesc
argument_list|,
name|bigTableRowObjects
argument_list|,
name|outputObjects
argument_list|)
expr_stmt|;
name|int
name|outputColumnNum
init|=
name|testDesc
operator|.
name|bigTableRetainColumnNums
operator|.
name|length
decl_stmt|;
specifier|final
name|int
name|smallTableRetainKeyColumnNumsLength
init|=
name|testDesc
operator|.
name|smallTableRetainKeyColumnNums
operator|.
name|length
decl_stmt|;
for|for
control|(
name|int
name|o
init|=
literal|0
init|;
name|o
operator|<
name|smallTableRetainKeyColumnNumsLength
condition|;
name|o
operator|++
control|)
block|{
name|outputObjects
index|[
name|outputColumnNum
operator|++
index|]
operator|=
literal|null
expr_stmt|;
block|}
specifier|final
name|int
name|smallTableRetainValueColumnNumsLength
init|=
name|testDesc
operator|.
name|smallTableRetainValueColumnNums
operator|.
name|length
decl_stmt|;
for|for
control|(
name|int
name|o
init|=
literal|0
init|;
name|o
operator|<
name|smallTableRetainValueColumnNumsLength
condition|;
name|o
operator|++
control|)
block|{
name|outputObjects
index|[
name|outputColumnNum
operator|++
index|]
operator|=
literal|null
expr_stmt|;
block|}
name|addToOutput
argument_list|(
name|testDesc
argument_list|,
name|expectedTestRowMultiSet
argument_list|,
name|outputObjects
argument_list|,
name|RowTestObjectsMultiSet
operator|.
name|RowFlag
operator|.
name|LEFT_OUTER
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
if|if
condition|(
name|testDesc
operator|.
name|vectorMapJoinVariation
operator|==
name|VectorMapJoinVariation
operator|.
name|FULL_OUTER
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"*BENCHMARK* ----------------------------------------------------------------------"
argument_list|)
expr_stmt|;
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"*BENCHMARK* FULL OUTER non-match key count "
operator|+
name|testData
operator|.
name|fullOuterAdditionalSmallTableKeys
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
comment|// Fill in non-match Small Table key results.
for|for
control|(
name|RowTestObjects
name|smallTableKey
range|:
name|testData
operator|.
name|fullOuterAdditionalSmallTableKeys
control|)
block|{
comment|// System.out.println(
comment|//     "*BENCHMARK* fullOuterAdditionalSmallTableKey " + smallTableKey.toString());
name|int
name|smallTableKeyIndex
init|=
name|testData
operator|.
name|smallTableKeyHashMap
operator|.
name|get
argument_list|(
name|smallTableKey
argument_list|)
decl_stmt|;
comment|// One row per value.
name|ArrayList
argument_list|<
name|RowTestObjects
argument_list|>
name|valueList
init|=
name|testData
operator|.
name|smallTableValues
operator|.
name|get
argument_list|(
name|smallTableKeyIndex
argument_list|)
decl_stmt|;
specifier|final
name|int
name|valueCount
init|=
name|valueList
operator|.
name|size
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|v
init|=
literal|0
init|;
name|v
operator|<
name|valueCount
condition|;
name|v
operator|++
control|)
block|{
name|Object
index|[]
name|outputObjects
init|=
operator|new
name|Object
index|[
name|testDesc
operator|.
name|outputColumnNames
operator|.
name|length
index|]
decl_stmt|;
comment|// Non-match Small Table keys produce NULL Big Table columns.
specifier|final
name|int
name|bigTableRetainColumnNumsLength
init|=
name|testDesc
operator|.
name|bigTableRetainColumnNums
operator|.
name|length
decl_stmt|;
for|for
control|(
name|int
name|o
init|=
literal|0
init|;
name|o
operator|<
name|bigTableRetainColumnNumsLength
condition|;
name|o
operator|++
control|)
block|{
name|outputObjects
index|[
name|o
index|]
operator|=
literal|null
expr_stmt|;
block|}
name|int
name|outputColumnNum
init|=
name|testDesc
operator|.
name|bigTableRetainColumnNums
operator|.
name|length
decl_stmt|;
comment|// The output result may include 0, 1, or more small key columns...
name|Object
index|[]
name|smallKeyObjects
init|=
name|smallTableKey
operator|.
name|getRow
argument_list|()
decl_stmt|;
specifier|final
name|int
name|smallTableRetainKeyColumnNumsLength
init|=
name|testDesc
operator|.
name|smallTableRetainKeyColumnNums
operator|.
name|length
decl_stmt|;
for|for
control|(
name|int
name|o
init|=
literal|0
init|;
name|o
operator|<
name|smallTableRetainKeyColumnNumsLength
condition|;
name|o
operator|++
control|)
block|{
name|outputObjects
index|[
name|outputColumnNum
operator|++
index|]
operator|=
name|smallKeyObjects
index|[
name|testDesc
operator|.
name|smallTableRetainKeyColumnNums
index|[
name|o
index|]
index|]
expr_stmt|;
block|}
name|Object
index|[]
name|valueRow
init|=
name|valueList
operator|.
name|get
argument_list|(
name|v
argument_list|)
operator|.
name|getRow
argument_list|()
decl_stmt|;
specifier|final
name|int
name|smallTableRetainValueColumnNumsLength
init|=
name|testDesc
operator|.
name|smallTableRetainValueColumnNums
operator|.
name|length
decl_stmt|;
for|for
control|(
name|int
name|o
init|=
literal|0
init|;
name|o
operator|<
name|smallTableRetainValueColumnNumsLength
condition|;
name|o
operator|++
control|)
block|{
name|outputObjects
index|[
name|outputColumnNum
operator|++
index|]
operator|=
name|valueRow
index|[
name|testDesc
operator|.
name|smallTableRetainValueColumnNums
index|[
name|o
index|]
index|]
expr_stmt|;
block|}
name|addToOutput
argument_list|(
name|testDesc
argument_list|,
name|expectedTestRowMultiSet
argument_list|,
name|outputObjects
argument_list|,
name|RowTestObjectsMultiSet
operator|.
name|RowFlag
operator|.
name|FULL_OUTER
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
name|expectedTestRowMultiSet
return|;
block|}
specifier|private
name|void
name|generateBigAndSmallTableRowLogLines
parameter_list|(
name|MapJoinTestDescription
name|testDesc
parameter_list|,
name|MapJoinTestData
name|testData
parameter_list|)
throws|throws
name|HiveException
block|{
comment|// Generate Big Table rows log lines...
name|VectorExtractRow
name|vectorExtractRow
init|=
operator|new
name|VectorExtractRow
argument_list|()
decl_stmt|;
name|vectorExtractRow
operator|.
name|init
argument_list|(
name|testDesc
operator|.
name|bigTableTypeInfos
argument_list|)
expr_stmt|;
specifier|final
name|int
name|bigTableColumnCount
init|=
name|testDesc
operator|.
name|bigTableTypeInfos
operator|.
name|length
decl_stmt|;
name|Object
index|[]
name|bigTableRowObjects
init|=
operator|new
name|Object
index|[
name|bigTableColumnCount
index|]
decl_stmt|;
comment|/*     PrintStream big_ps;     try {       big_ps = new PrintStream("/Users/mmccline/VecFullOuterRefresh/out_big");     } catch (Exception e) {       throw new HiveException(e);     }     */
name|VectorRandomBatchSource
name|bigTableBatchSource
init|=
name|testData
operator|.
name|getBigTableBatchSource
argument_list|()
decl_stmt|;
name|VectorizedRowBatch
name|batch
init|=
name|testData
operator|.
name|getBigTableBatch
argument_list|()
decl_stmt|;
name|bigTableBatchSource
operator|.
name|resetBatchIteration
argument_list|()
expr_stmt|;
while|while
condition|(
name|bigTableBatchSource
operator|.
name|fillNextBatch
argument_list|(
name|batch
argument_list|)
condition|)
block|{
specifier|final
name|int
name|size
init|=
name|testData
operator|.
name|bigTableBatch
operator|.
name|size
decl_stmt|;
for|for
control|(
name|int
name|r
init|=
literal|0
init|;
name|r
operator|<
name|size
condition|;
name|r
operator|++
control|)
block|{
name|vectorExtractRow
operator|.
name|extractRow
argument_list|(
name|testData
operator|.
name|bigTableBatch
argument_list|,
name|r
argument_list|,
name|bigTableRowObjects
argument_list|)
expr_stmt|;
comment|// big_ps.println(rowToCsvString(bigTableRowObjects));
block|}
block|}
comment|// big_ps.close();
comment|/*     PrintStream small_ps;     try {       small_ps = new PrintStream("/Users/mmccline/VecFullOuterRefresh/out_small");     } catch (Exception e) {       throw new HiveException(e);     }     */
comment|// Generate Small Table rows log lines...
specifier|final
name|int
name|keyKeyColumnNumsLength
init|=
name|testDesc
operator|.
name|bigTableKeyColumnNums
operator|.
name|length
decl_stmt|;
specifier|final
name|int
name|smallTableRetainValueLength
init|=
name|testDesc
operator|.
name|smallTableRetainValueColumnNums
operator|.
name|length
decl_stmt|;
specifier|final
name|int
name|smallTableLength
init|=
name|keyKeyColumnNumsLength
operator|+
name|smallTableRetainValueLength
decl_stmt|;
for|for
control|(
name|Entry
argument_list|<
name|RowTestObjects
argument_list|,
name|Integer
argument_list|>
name|entry
range|:
name|testData
operator|.
name|smallTableKeyHashMap
operator|.
name|entrySet
argument_list|()
control|)
block|{
if|if
condition|(
name|smallTableRetainValueLength
operator|==
literal|0
condition|)
block|{
name|Object
index|[]
name|smallTableRowObjects
init|=
name|entry
operator|.
name|getKey
argument_list|()
operator|.
name|getRow
argument_list|()
decl_stmt|;
comment|// small_ps.println(rowToCsvString(smallTableRowObjects));
block|}
else|else
block|{
name|Integer
name|valueIndex
init|=
name|entry
operator|.
name|getValue
argument_list|()
decl_stmt|;
name|ArrayList
argument_list|<
name|RowTestObjects
argument_list|>
name|valueList
init|=
name|testData
operator|.
name|smallTableValues
operator|.
name|get
argument_list|(
name|valueIndex
argument_list|)
decl_stmt|;
specifier|final
name|int
name|valueCount
init|=
name|valueList
operator|.
name|size
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|v
init|=
literal|0
init|;
name|v
operator|<
name|valueCount
condition|;
name|v
operator|++
control|)
block|{
name|Object
index|[]
name|smallTableRowObjects
init|=
operator|new
name|Object
index|[
name|smallTableLength
index|]
decl_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|entry
operator|.
name|getKey
argument_list|()
operator|.
name|getRow
argument_list|()
argument_list|,
literal|0
argument_list|,
name|smallTableRowObjects
argument_list|,
literal|0
argument_list|,
name|keyKeyColumnNumsLength
argument_list|)
expr_stmt|;
name|int
name|outputColumnNum
init|=
name|keyKeyColumnNumsLength
decl_stmt|;
name|Object
index|[]
name|valueRow
init|=
name|valueList
operator|.
name|get
argument_list|(
name|v
argument_list|)
operator|.
name|getRow
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|o
init|=
literal|0
init|;
name|o
operator|<
name|smallTableRetainValueLength
condition|;
name|o
operator|++
control|)
block|{
name|smallTableRowObjects
index|[
name|outputColumnNum
operator|++
index|]
operator|=
name|valueRow
index|[
name|testDesc
operator|.
name|smallTableRetainValueColumnNums
index|[
name|o
index|]
index|]
expr_stmt|;
block|}
comment|// small_ps.println(rowToCsvString(smallTableRowObjects));
block|}
block|}
block|}
comment|// small_ps.close();
block|}
specifier|private
name|void
name|executeTest
parameter_list|(
name|MapJoinTestDescription
name|testDesc
parameter_list|,
name|MapJoinTestData
name|testData
parameter_list|,
name|String
name|title
parameter_list|)
throws|throws
name|Exception
block|{
comment|// So stack trace is self-explanatory.
switch|switch
condition|(
name|testDesc
operator|.
name|vectorMapJoinVariation
condition|)
block|{
case|case
name|INNER
case|:
name|executeTestInner
argument_list|(
name|testDesc
argument_list|,
name|testData
argument_list|,
name|title
argument_list|)
expr_stmt|;
break|break;
case|case
name|INNER_BIG_ONLY
case|:
name|executeTestInnerBigOnly
argument_list|(
name|testDesc
argument_list|,
name|testData
argument_list|,
name|title
argument_list|)
expr_stmt|;
break|break;
case|case
name|LEFT_SEMI
case|:
name|executeTestLeftSemi
argument_list|(
name|testDesc
argument_list|,
name|testData
argument_list|,
name|title
argument_list|)
expr_stmt|;
break|break;
case|case
name|OUTER
case|:
name|executeTestOuter
argument_list|(
name|testDesc
argument_list|,
name|testData
argument_list|,
name|title
argument_list|)
expr_stmt|;
break|break;
case|case
name|FULL_OUTER
case|:
name|executeTestFullOuter
argument_list|(
name|testDesc
argument_list|,
name|testData
argument_list|,
name|title
argument_list|)
expr_stmt|;
break|break;
default|default:
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Unexpected Vector MapJoin variation "
operator|+
name|testDesc
operator|.
name|vectorMapJoinVariation
argument_list|)
throw|;
block|}
block|}
specifier|private
name|void
name|executeTestInner
parameter_list|(
name|MapJoinTestDescription
name|testDesc
parameter_list|,
name|MapJoinTestData
name|testData
parameter_list|,
name|String
name|title
parameter_list|)
throws|throws
name|Exception
block|{
name|doExecuteTest
argument_list|(
name|testDesc
argument_list|,
name|testData
argument_list|,
name|title
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|executeTestInnerBigOnly
parameter_list|(
name|MapJoinTestDescription
name|testDesc
parameter_list|,
name|MapJoinTestData
name|testData
parameter_list|,
name|String
name|title
parameter_list|)
throws|throws
name|Exception
block|{
name|doExecuteTest
argument_list|(
name|testDesc
argument_list|,
name|testData
argument_list|,
name|title
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|executeTestLeftSemi
parameter_list|(
name|MapJoinTestDescription
name|testDesc
parameter_list|,
name|MapJoinTestData
name|testData
parameter_list|,
name|String
name|title
parameter_list|)
throws|throws
name|Exception
block|{
name|doExecuteTest
argument_list|(
name|testDesc
argument_list|,
name|testData
argument_list|,
name|title
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|executeTestOuter
parameter_list|(
name|MapJoinTestDescription
name|testDesc
parameter_list|,
name|MapJoinTestData
name|testData
parameter_list|,
name|String
name|title
parameter_list|)
throws|throws
name|Exception
block|{
name|doExecuteTest
argument_list|(
name|testDesc
argument_list|,
name|testData
argument_list|,
name|title
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|executeTestFullOuter
parameter_list|(
name|MapJoinTestDescription
name|testDesc
parameter_list|,
name|MapJoinTestData
name|testData
parameter_list|,
name|String
name|title
parameter_list|)
throws|throws
name|Exception
block|{
name|doExecuteTest
argument_list|(
name|testDesc
argument_list|,
name|testData
argument_list|,
name|title
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|doExecuteTest
parameter_list|(
name|MapJoinTestDescription
name|testDesc
parameter_list|,
name|MapJoinTestData
name|testData
parameter_list|,
name|String
name|title
parameter_list|)
throws|throws
name|Exception
block|{
name|RowTestObjectsMultiSet
name|expectedTestRowMultiSet
init|=
name|createExpectedTestRowMultiSet
argument_list|(
name|testDesc
argument_list|,
name|testData
argument_list|)
decl_stmt|;
name|generateBigAndSmallTableRowLogLines
argument_list|(
name|testDesc
argument_list|,
name|testData
argument_list|)
expr_stmt|;
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"*BENCHMARK* expectedTestRowMultiSet "
operator|+
literal|" totalKeyCount "
operator|+
name|expectedTestRowMultiSet
operator|.
name|getTotalKeyCount
argument_list|()
operator|+
literal|" totalValueCount "
operator|+
name|expectedTestRowMultiSet
operator|.
name|getTotalValueCount
argument_list|()
argument_list|)
expr_stmt|;
comment|// Execute all implementation variations.
for|for
control|(
name|MapJoinTestImplementation
name|mapJoinImplementation
range|:
name|MapJoinTestImplementation
operator|.
name|values
argument_list|()
control|)
block|{
if|if
condition|(
name|testDesc
operator|.
name|vectorMapJoinVariation
operator|==
name|VectorMapJoinVariation
operator|.
name|FULL_OUTER
operator|&&
name|mapJoinImplementation
operator|==
name|MapJoinTestImplementation
operator|.
name|ROW_MODE_HASH_MAP
condition|)
block|{
comment|// Key match tracking not supported in plain Java HashMap.
continue|continue;
block|}
switch|switch
condition|(
name|mapJoinImplementation
condition|)
block|{
case|case
name|ROW_MODE_HASH_MAP
case|:
name|executeRowModeHashMap
argument_list|(
name|testDesc
argument_list|,
name|testData
argument_list|,
name|expectedTestRowMultiSet
argument_list|,
name|title
argument_list|)
expr_stmt|;
break|break;
case|case
name|ROW_MODE_OPTIMIZED
case|:
name|executeRowModeOptimized
argument_list|(
name|testDesc
argument_list|,
name|testData
argument_list|,
name|expectedTestRowMultiSet
argument_list|,
name|title
argument_list|)
expr_stmt|;
break|break;
case|case
name|VECTOR_PASS_THROUGH
case|:
name|executeVectorPassThrough
argument_list|(
name|testDesc
argument_list|,
name|testData
argument_list|,
name|expectedTestRowMultiSet
argument_list|,
name|title
argument_list|)
expr_stmt|;
break|break;
case|case
name|NATIVE_VECTOR_OPTIMIZED
case|:
name|executeNativeVectorOptimized
argument_list|(
name|testDesc
argument_list|,
name|testData
argument_list|,
name|expectedTestRowMultiSet
argument_list|,
name|title
argument_list|)
expr_stmt|;
break|break;
case|case
name|NATIVE_VECTOR_FAST
case|:
name|executeNativeVectorFast
argument_list|(
name|testDesc
argument_list|,
name|testData
argument_list|,
name|expectedTestRowMultiSet
argument_list|,
name|title
argument_list|)
expr_stmt|;
break|break;
default|default:
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Unexpected vector map join test variation"
argument_list|)
throw|;
block|}
block|}
block|}
specifier|private
name|void
name|executeRowModeHashMap
parameter_list|(
name|MapJoinTestDescription
name|testDesc
parameter_list|,
name|MapJoinTestData
name|testData
parameter_list|,
name|RowTestObjectsMultiSet
name|expectedTestRowMultiSet
parameter_list|,
name|String
name|title
parameter_list|)
throws|throws
name|Exception
block|{
name|executeTestImplementation
argument_list|(
name|MapJoinTestImplementation
operator|.
name|ROW_MODE_HASH_MAP
argument_list|,
name|testDesc
argument_list|,
name|testData
argument_list|,
name|expectedTestRowMultiSet
argument_list|,
name|title
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|executeRowModeOptimized
parameter_list|(
name|MapJoinTestDescription
name|testDesc
parameter_list|,
name|MapJoinTestData
name|testData
parameter_list|,
name|RowTestObjectsMultiSet
name|expectedTestRowMultiSet
parameter_list|,
name|String
name|title
parameter_list|)
throws|throws
name|Exception
block|{
name|executeTestImplementation
argument_list|(
name|MapJoinTestImplementation
operator|.
name|ROW_MODE_OPTIMIZED
argument_list|,
name|testDesc
argument_list|,
name|testData
argument_list|,
name|expectedTestRowMultiSet
argument_list|,
name|title
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|executeVectorPassThrough
parameter_list|(
name|MapJoinTestDescription
name|testDesc
parameter_list|,
name|MapJoinTestData
name|testData
parameter_list|,
name|RowTestObjectsMultiSet
name|expectedTestRowMultiSet
parameter_list|,
name|String
name|title
parameter_list|)
throws|throws
name|Exception
block|{
name|executeTestImplementation
argument_list|(
name|MapJoinTestImplementation
operator|.
name|VECTOR_PASS_THROUGH
argument_list|,
name|testDesc
argument_list|,
name|testData
argument_list|,
name|expectedTestRowMultiSet
argument_list|,
name|title
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|executeNativeVectorOptimized
parameter_list|(
name|MapJoinTestDescription
name|testDesc
parameter_list|,
name|MapJoinTestData
name|testData
parameter_list|,
name|RowTestObjectsMultiSet
name|expectedTestRowMultiSet
parameter_list|,
name|String
name|title
parameter_list|)
throws|throws
name|Exception
block|{
name|executeTestImplementation
argument_list|(
name|MapJoinTestImplementation
operator|.
name|NATIVE_VECTOR_OPTIMIZED
argument_list|,
name|testDesc
argument_list|,
name|testData
argument_list|,
name|expectedTestRowMultiSet
argument_list|,
name|title
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|executeNativeVectorFast
parameter_list|(
name|MapJoinTestDescription
name|testDesc
parameter_list|,
name|MapJoinTestData
name|testData
parameter_list|,
name|RowTestObjectsMultiSet
name|expectedTestRowMultiSet
parameter_list|,
name|String
name|title
parameter_list|)
throws|throws
name|Exception
block|{
name|executeTestImplementation
argument_list|(
name|MapJoinTestImplementation
operator|.
name|NATIVE_VECTOR_FAST
argument_list|,
name|testDesc
argument_list|,
name|testData
argument_list|,
name|expectedTestRowMultiSet
argument_list|,
name|title
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|executeTestImplementation
parameter_list|(
name|MapJoinTestImplementation
name|mapJoinImplementation
parameter_list|,
name|MapJoinTestDescription
name|testDesc
parameter_list|,
name|MapJoinTestData
name|testData
parameter_list|,
name|RowTestObjectsMultiSet
name|expectedTestRowMultiSet
parameter_list|,
name|String
name|title
parameter_list|)
throws|throws
name|Exception
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"*BENCHMARK* Starting implementation "
operator|+
name|mapJoinImplementation
operator|+
literal|" variation "
operator|+
name|testDesc
operator|.
name|vectorMapJoinVariation
operator|+
literal|" title "
operator|+
name|title
argument_list|)
expr_stmt|;
comment|// UNDONE: Parameterize for implementation variation?
name|MapJoinDesc
name|mapJoinDesc
init|=
name|MapJoinTestConfig
operator|.
name|createMapJoinDesc
argument_list|(
name|testDesc
argument_list|)
decl_stmt|;
specifier|final
name|boolean
name|isVectorOutput
init|=
name|MapJoinTestConfig
operator|.
name|isVectorOutput
argument_list|(
name|mapJoinImplementation
argument_list|)
decl_stmt|;
name|RowTestObjectsMultiSet
name|outputTestRowMultiSet
init|=
operator|new
name|RowTestObjectsMultiSet
argument_list|()
decl_stmt|;
name|CreateMapJoinResult
name|result
init|=
name|MapJoinTestConfig
operator|.
name|createMapJoinImplementation
argument_list|(
name|mapJoinImplementation
argument_list|,
name|testDesc
argument_list|,
name|testData
argument_list|,
name|mapJoinDesc
argument_list|)
decl_stmt|;
name|MapJoinOperator
name|mapJoinOperator
init|=
name|result
operator|.
name|mapJoinOperator
decl_stmt|;
name|MapJoinTableContainer
name|mapJoinTableContainer
init|=
name|result
operator|.
name|mapJoinTableContainer
decl_stmt|;
name|MapJoinTableContainerSerDe
name|mapJoinTableContainerSerDe
init|=
name|result
operator|.
name|mapJoinTableContainerSerDe
decl_stmt|;
name|CountCollectorTestOperator
name|testCollectorOperator
decl_stmt|;
if|if
condition|(
operator|!
name|isVectorOutput
condition|)
block|{
name|testCollectorOperator
operator|=
operator|new
name|TestMultiSetCollectorOperator
argument_list|(
name|testDesc
operator|.
name|outputObjectInspectors
argument_list|,
name|outputTestRowMultiSet
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|VectorizationContext
name|vOutContext
init|=
operator|(
operator|(
name|VectorizationContextRegion
operator|)
name|mapJoinOperator
operator|)
operator|.
name|getOutputVectorizationContext
argument_list|()
decl_stmt|;
name|testCollectorOperator
operator|=
operator|new
name|TestMultiSetVectorCollectorOperator
argument_list|(
name|ArrayUtils
operator|.
name|toPrimitive
argument_list|(
name|vOutContext
operator|.
name|getProjectedColumns
argument_list|()
operator|.
name|toArray
argument_list|(
operator|new
name|Integer
index|[
literal|0
index|]
argument_list|)
argument_list|)
argument_list|,
name|testDesc
operator|.
name|outputTypeInfos
argument_list|,
name|testDesc
operator|.
name|outputObjectInspectors
argument_list|,
name|outputTestRowMultiSet
argument_list|)
expr_stmt|;
block|}
name|MapJoinTestConfig
operator|.
name|connectOperators
argument_list|(
name|mapJoinOperator
argument_list|,
name|testCollectorOperator
argument_list|)
expr_stmt|;
name|CountCollectorTestOperator
name|interceptTestCollectorOperator
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|testDesc
operator|.
name|vectorMapJoinVariation
operator|==
name|VectorMapJoinVariation
operator|.
name|FULL_OUTER
operator|&&
operator|!
name|mapJoinDesc
operator|.
name|isDynamicPartitionHashJoin
argument_list|()
condition|)
block|{
if|if
condition|(
name|mapJoinImplementation
operator|==
name|MapJoinTestImplementation
operator|.
name|ROW_MODE_HASH_MAP
condition|)
block|{
comment|// Not supported.
return|return;
block|}
comment|// Wire in FULL OUTER Intercept.
name|interceptTestCollectorOperator
operator|=
name|MapJoinTestConfig
operator|.
name|addFullOuterIntercept
argument_list|(
name|mapJoinImplementation
argument_list|,
name|testDesc
argument_list|,
name|outputTestRowMultiSet
argument_list|,
name|testData
argument_list|,
name|mapJoinOperator
argument_list|,
name|mapJoinTableContainer
argument_list|,
name|mapJoinTableContainerSerDe
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// Invoke initializeOp methods.
name|mapJoinOperator
operator|.
name|initialize
argument_list|(
name|testDesc
operator|.
name|hiveConf
argument_list|,
name|testDesc
operator|.
name|inputObjectInspectors
argument_list|)
expr_stmt|;
comment|// Fixup the mapJoinTables.
name|mapJoinOperator
operator|.
name|setTestMapJoinTableContainer
argument_list|(
literal|1
argument_list|,
name|mapJoinTableContainer
argument_list|,
name|mapJoinTableContainerSerDe
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|isVectorOutput
condition|)
block|{
name|MapJoinTestData
operator|.
name|driveBigTableData
argument_list|(
name|testDesc
argument_list|,
name|testData
argument_list|,
name|mapJoinOperator
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|MapJoinTestData
operator|.
name|driveVectorBigTableData
argument_list|(
name|testDesc
argument_list|,
name|testData
argument_list|,
name|mapJoinOperator
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|testCollectorOperator
operator|.
name|getIsClosed
argument_list|()
condition|)
block|{
name|Assert
operator|.
name|fail
argument_list|(
literal|"collector operator not closed"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|testCollectorOperator
operator|.
name|getIsAborted
argument_list|()
condition|)
block|{
name|Assert
operator|.
name|fail
argument_list|(
literal|"collector operator aborted"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|testDesc
operator|.
name|vectorMapJoinVariation
operator|==
name|VectorMapJoinVariation
operator|.
name|FULL_OUTER
operator|&&
operator|!
name|mapJoinDesc
operator|.
name|isDynamicPartitionHashJoin
argument_list|()
condition|)
block|{
if|if
condition|(
operator|!
name|interceptTestCollectorOperator
operator|.
name|getIsClosed
argument_list|()
condition|)
block|{
name|Assert
operator|.
name|fail
argument_list|(
literal|"intercept collector operator not closed"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|interceptTestCollectorOperator
operator|.
name|getIsAborted
argument_list|()
condition|)
block|{
name|Assert
operator|.
name|fail
argument_list|(
literal|"intercept collector operator aborted"
argument_list|)
expr_stmt|;
block|}
block|}
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"*BENCHMARK* executeTestImplementation row count "
operator|+
name|testCollectorOperator
operator|.
name|getRowCount
argument_list|()
argument_list|)
expr_stmt|;
comment|// Verify the output!
name|String
name|option
init|=
literal|""
decl_stmt|;
if|if
condition|(
name|testDesc
operator|.
name|vectorMapJoinVariation
operator|==
name|VectorMapJoinVariation
operator|.
name|FULL_OUTER
condition|)
block|{
name|option
operator|=
literal|" mapJoinPlanVariation "
operator|+
name|testDesc
operator|.
name|mapJoinPlanVariation
operator|.
name|name
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|expectedTestRowMultiSet
operator|.
name|verify
argument_list|(
name|outputTestRowMultiSet
argument_list|,
literal|"expected"
argument_list|,
literal|"actual"
argument_list|)
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"*BENCHMARK* "
operator|+
name|title
operator|+
literal|" verify failed"
operator|+
literal|" for implementation "
operator|+
name|mapJoinImplementation
operator|+
literal|" variation "
operator|+
name|testDesc
operator|.
name|vectorMapJoinVariation
operator|+
name|option
argument_list|)
expr_stmt|;
name|expectedTestRowMultiSet
operator|.
name|displayDifferences
argument_list|(
name|outputTestRowMultiSet
argument_list|,
literal|"expected"
argument_list|,
literal|"actual"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"*BENCHMARK* "
operator|+
name|title
operator|+
literal|" verify succeeded "
operator|+
literal|" for implementation "
operator|+
name|mapJoinImplementation
operator|+
literal|" variation "
operator|+
name|testDesc
operator|.
name|vectorMapJoinVariation
operator|+
name|option
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_class

end_unit

