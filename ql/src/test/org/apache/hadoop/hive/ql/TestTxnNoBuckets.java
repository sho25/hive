begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
package|;
end_package

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|conf
operator|.
name|HiveConf
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|io
operator|.
name|BucketCodec
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|processors
operator|.
name|CommandProcessorResponse
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|Assert
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|Before
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|Test
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|File
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_class
specifier|public
class|class
name|TestTxnNoBuckets
extends|extends
name|TxnCommandsBaseForTests
block|{
specifier|static
specifier|final
specifier|private
name|Logger
name|LOG
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|TestTxnNoBuckets
operator|.
name|class
argument_list|)
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|String
name|TEST_DATA_DIR
init|=
operator|new
name|File
argument_list|(
name|System
operator|.
name|getProperty
argument_list|(
literal|"java.io.tmpdir"
argument_list|)
operator|+
name|File
operator|.
name|separator
operator|+
name|TestTxnNoBuckets
operator|.
name|class
operator|.
name|getCanonicalName
argument_list|()
operator|+
literal|"-"
operator|+
name|System
operator|.
name|currentTimeMillis
argument_list|()
argument_list|)
operator|.
name|getPath
argument_list|()
operator|.
name|replaceAll
argument_list|(
literal|"\\\\"
argument_list|,
literal|"/"
argument_list|)
decl_stmt|;
annotation|@
name|Override
name|String
name|getTestDataDir
parameter_list|()
block|{
return|return
name|TEST_DATA_DIR
return|;
block|}
annotation|@
name|Override
annotation|@
name|Before
specifier|public
name|void
name|setUp
parameter_list|()
throws|throws
name|Exception
block|{
name|setUpInternal
argument_list|()
expr_stmt|;
name|hiveConf
operator|.
name|setBoolVar
argument_list|(
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVE_VECTORIZATION_ENABLED
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
comment|/**    * Tests that Acid can work with un-bucketed tables.    */
annotation|@
name|Test
specifier|public
name|void
name|testNoBuckets
parameter_list|()
throws|throws
name|Exception
block|{
name|int
index|[]
index|[]
name|sourceVals1
init|=
block|{
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|3
block|,
literal|3
block|,
literal|3
block|}
block|}
decl_stmt|;
name|int
index|[]
index|[]
name|sourceVals2
init|=
block|{
block|{
literal|1
block|,
literal|1
block|,
literal|1
block|}
block|,
block|{
literal|2
block|,
literal|2
block|,
literal|2
block|}
block|}
decl_stmt|;
name|runStatementOnDriver
argument_list|(
literal|"drop table if exists tmp"
argument_list|)
expr_stmt|;
name|runStatementOnDriver
argument_list|(
literal|"create table tmp (c1 integer, c2 integer, c3 integer) stored as orc"
argument_list|)
expr_stmt|;
name|runStatementOnDriver
argument_list|(
literal|"insert into tmp "
operator|+
name|makeValuesClause
argument_list|(
name|sourceVals1
argument_list|)
argument_list|)
expr_stmt|;
name|runStatementOnDriver
argument_list|(
literal|"insert into tmp "
operator|+
name|makeValuesClause
argument_list|(
name|sourceVals2
argument_list|)
argument_list|)
expr_stmt|;
name|runStatementOnDriver
argument_list|(
literal|"drop table if exists nobuckets"
argument_list|)
expr_stmt|;
name|runStatementOnDriver
argument_list|(
literal|"create table nobuckets (c1 integer, c2 integer, c3 integer) stored "
operator|+
literal|"as orc tblproperties('transactional'='true', 'transactional_properties'='default')"
argument_list|)
expr_stmt|;
name|String
name|stmt
init|=
literal|"insert into nobuckets select * from tmp"
decl_stmt|;
name|runStatementOnDriver
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|rs
init|=
name|runStatementOnDriver
argument_list|(
literal|"select ROW__ID, c1, c2, c3, INPUT__FILE__NAME from nobuckets order by ROW__ID"
argument_list|)
decl_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
literal|""
argument_list|,
literal|4
argument_list|,
name|rs
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|warn
argument_list|(
literal|"after insert"
argument_list|)
expr_stmt|;
for|for
control|(
name|String
name|s
range|:
name|rs
control|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
comment|/**the insert creates 2 output files (presumably because there are 2 input files)      * The number in the file name is writerId.  This is the number encoded in ROW__ID.bucketId -      * see {@link org.apache.hadoop.hive.ql.io.BucketCodec}*/
name|Assert
operator|.
name|assertTrue
argument_list|(
name|rs
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|,
name|rs
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|startsWith
argument_list|(
literal|"{\"transactionid\":19,\"bucketid\":536870912,\"rowid\":0}\t0\t0\t0\t"
argument_list|)
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertTrue
argument_list|(
name|rs
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|,
name|rs
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|endsWith
argument_list|(
literal|"nobuckets/delta_0000019_0000019_0000/bucket_00000"
argument_list|)
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertTrue
argument_list|(
name|rs
operator|.
name|get
argument_list|(
literal|1
argument_list|)
argument_list|,
name|rs
operator|.
name|get
argument_list|(
literal|1
argument_list|)
operator|.
name|startsWith
argument_list|(
literal|"{\"transactionid\":19,\"bucketid\":536870912,\"rowid\":1}\t3\t3\t3\t"
argument_list|)
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertTrue
argument_list|(
name|rs
operator|.
name|get
argument_list|(
literal|1
argument_list|)
argument_list|,
name|rs
operator|.
name|get
argument_list|(
literal|1
argument_list|)
operator|.
name|endsWith
argument_list|(
literal|"nobuckets/delta_0000019_0000019_0000/bucket_00000"
argument_list|)
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertTrue
argument_list|(
name|rs
operator|.
name|get
argument_list|(
literal|2
argument_list|)
argument_list|,
name|rs
operator|.
name|get
argument_list|(
literal|2
argument_list|)
operator|.
name|startsWith
argument_list|(
literal|"{\"transactionid\":19,\"bucketid\":536936448,\"rowid\":0}\t1\t1\t1\t"
argument_list|)
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertTrue
argument_list|(
name|rs
operator|.
name|get
argument_list|(
literal|2
argument_list|)
argument_list|,
name|rs
operator|.
name|get
argument_list|(
literal|2
argument_list|)
operator|.
name|endsWith
argument_list|(
literal|"nobuckets/delta_0000019_0000019_0000/bucket_00001"
argument_list|)
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertTrue
argument_list|(
name|rs
operator|.
name|get
argument_list|(
literal|3
argument_list|)
argument_list|,
name|rs
operator|.
name|get
argument_list|(
literal|3
argument_list|)
operator|.
name|startsWith
argument_list|(
literal|"{\"transactionid\":19,\"bucketid\":536936448,\"rowid\":1}\t2\t2\t2\t"
argument_list|)
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertTrue
argument_list|(
name|rs
operator|.
name|get
argument_list|(
literal|3
argument_list|)
argument_list|,
name|rs
operator|.
name|get
argument_list|(
literal|3
argument_list|)
operator|.
name|endsWith
argument_list|(
literal|"nobuckets/delta_0000019_0000019_0000/bucket_00001"
argument_list|)
argument_list|)
expr_stmt|;
comment|/*todo: WTF?     RS for update seems to spray randomly... is that OK?  maybe as long as all resultant files have different names... will they?     Assuming we name them based on taskId, we should create bucketX and bucketY.     we delete events can be written to bucketX file it could be useful for filter delete for a split by file name since the insert     events seem to be written to a proper bucketX file.  In fact this may reduce the number of changes elsewhere like compactor... maybe     But this limits the parallelism - what is worse, you don't know what the parallelism should be until you have a list of all the     input files since bucket count is no longer a metadata property.  Also, with late Update split, the file name has already been determined     from taskId so the Insert part won't end up matching the bucketX property necessarily.     With early Update split, the Insert can still be an insert - i.e. go to appropriate bucketX.  But deletes will still go wherever (random shuffle)     unless you know all the bucketX files to be read - may not be worth the trouble.     * 2nd: something in FS fails.  ArrayIndexOutOfBoundsException: 1 at FileSinkOperator.process(FileSinkOperator.java:779)*/
name|runStatementOnDriver
argument_list|(
literal|"update nobuckets set c3 = 17 where c3 in(0,1)"
argument_list|)
expr_stmt|;
name|rs
operator|=
name|runStatementOnDriver
argument_list|(
literal|"select ROW__ID, c1, c2, c3, INPUT__FILE__NAME from nobuckets order by INPUT__FILE__NAME, ROW__ID"
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|warn
argument_list|(
literal|"after update"
argument_list|)
expr_stmt|;
for|for
control|(
name|String
name|s
range|:
name|rs
control|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
name|Assert
operator|.
name|assertTrue
argument_list|(
name|rs
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|,
name|rs
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|startsWith
argument_list|(
literal|"{\"transactionid\":19,\"bucketid\":536870912,\"rowid\":1}\t3\t3\t3\t"
argument_list|)
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertTrue
argument_list|(
name|rs
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|,
name|rs
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|endsWith
argument_list|(
literal|"nobuckets/delta_0000019_0000019_0000/bucket_00000"
argument_list|)
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertTrue
argument_list|(
name|rs
operator|.
name|get
argument_list|(
literal|1
argument_list|)
argument_list|,
name|rs
operator|.
name|get
argument_list|(
literal|1
argument_list|)
operator|.
name|startsWith
argument_list|(
literal|"{\"transactionid\":19,\"bucketid\":536936448,\"rowid\":1}\t2\t2\t2\t"
argument_list|)
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertTrue
argument_list|(
name|rs
operator|.
name|get
argument_list|(
literal|1
argument_list|)
argument_list|,
name|rs
operator|.
name|get
argument_list|(
literal|1
argument_list|)
operator|.
name|endsWith
argument_list|(
literal|"nobuckets/delta_0000019_0000019_0000/bucket_00001"
argument_list|)
argument_list|)
expr_stmt|;
comment|//so update has 1 writer which creates bucket0 where both new rows land
name|Assert
operator|.
name|assertTrue
argument_list|(
name|rs
operator|.
name|get
argument_list|(
literal|2
argument_list|)
argument_list|,
name|rs
operator|.
name|get
argument_list|(
literal|2
argument_list|)
operator|.
name|startsWith
argument_list|(
literal|"{\"transactionid\":21,\"bucketid\":536870912,\"rowid\":0}\t0\t0\t17\t"
argument_list|)
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertTrue
argument_list|(
name|rs
operator|.
name|get
argument_list|(
literal|2
argument_list|)
argument_list|,
name|rs
operator|.
name|get
argument_list|(
literal|2
argument_list|)
operator|.
name|endsWith
argument_list|(
literal|"nobuckets/delta_0000021_0000021_0000/bucket_00000"
argument_list|)
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertTrue
argument_list|(
name|rs
operator|.
name|get
argument_list|(
literal|3
argument_list|)
argument_list|,
name|rs
operator|.
name|get
argument_list|(
literal|3
argument_list|)
operator|.
name|startsWith
argument_list|(
literal|"{\"transactionid\":21,\"bucketid\":536870912,\"rowid\":1}\t1\t1\t17\t"
argument_list|)
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertTrue
argument_list|(
name|rs
operator|.
name|get
argument_list|(
literal|3
argument_list|)
argument_list|,
name|rs
operator|.
name|get
argument_list|(
literal|3
argument_list|)
operator|.
name|endsWith
argument_list|(
literal|"nobuckets/delta_0000021_0000021_0000/bucket_00000"
argument_list|)
argument_list|)
expr_stmt|;
name|Set
argument_list|<
name|String
argument_list|>
name|expectedFiles
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|()
decl_stmt|;
comment|//both delete events land in a single bucket0.  Each has a different ROW__ID.bucketId value (even writerId in it is different)
name|expectedFiles
operator|.
name|add
argument_list|(
literal|"ts/delete_delta_0000021_0000021_0000/bucket_00000"
argument_list|)
expr_stmt|;
name|expectedFiles
operator|.
name|add
argument_list|(
literal|"nobuckets/delta_0000019_0000019_0000/bucket_00000"
argument_list|)
expr_stmt|;
name|expectedFiles
operator|.
name|add
argument_list|(
literal|"nobuckets/delta_0000019_0000019_0000/bucket_00001"
argument_list|)
expr_stmt|;
name|expectedFiles
operator|.
name|add
argument_list|(
literal|"nobuckets/delta_0000021_0000021_0000/bucket_00000"
argument_list|)
expr_stmt|;
comment|//check that we get the right files on disk
name|assertExpectedFileSet
argument_list|(
name|expectedFiles
argument_list|,
name|getWarehouseDir
argument_list|()
operator|+
literal|"/nobuckets"
argument_list|)
expr_stmt|;
comment|//todo: it would be nice to check the contents of the files... could use orc.FileDump - it has
comment|// methods to print to a supplied stream but those are package private
name|runStatementOnDriver
argument_list|(
literal|"alter table nobuckets compact 'major'"
argument_list|)
expr_stmt|;
name|TestTxnCommands2
operator|.
name|runWorker
argument_list|(
name|hiveConf
argument_list|)
expr_stmt|;
name|rs
operator|=
name|runStatementOnDriver
argument_list|(
literal|"select ROW__ID, c1, c2, c3, INPUT__FILE__NAME from nobuckets order by INPUT__FILE__NAME, ROW__ID"
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|warn
argument_list|(
literal|"after major compact"
argument_list|)
expr_stmt|;
for|for
control|(
name|String
name|s
range|:
name|rs
control|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
comment|/* ├── base_0000021 │   ├── bucket_00000 │   └── bucket_00001 ├── delete_delta_0000021_0000021_0000 │   └── bucket_00000 ├── delta_0000019_0000019_0000 │   ├── bucket_00000 │   └── bucket_00001 └── delta_0000021_0000021_0000     └── bucket_00000     */
name|Assert
operator|.
name|assertTrue
argument_list|(
name|rs
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|,
name|rs
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|startsWith
argument_list|(
literal|"{\"transactionid\":19,\"bucketid\":536870912,\"rowid\":1}\t3\t3\t3\t"
argument_list|)
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertTrue
argument_list|(
name|rs
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|,
name|rs
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|endsWith
argument_list|(
literal|"nobuckets/base_0000021/bucket_00000"
argument_list|)
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertTrue
argument_list|(
name|rs
operator|.
name|get
argument_list|(
literal|1
argument_list|)
argument_list|,
name|rs
operator|.
name|get
argument_list|(
literal|1
argument_list|)
operator|.
name|startsWith
argument_list|(
literal|"{\"transactionid\":21,\"bucketid\":536870912,\"rowid\":0}\t0\t0\t17\t"
argument_list|)
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertTrue
argument_list|(
name|rs
operator|.
name|get
argument_list|(
literal|1
argument_list|)
argument_list|,
name|rs
operator|.
name|get
argument_list|(
literal|1
argument_list|)
operator|.
name|endsWith
argument_list|(
literal|"nobuckets/base_0000021/bucket_00000"
argument_list|)
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertTrue
argument_list|(
name|rs
operator|.
name|get
argument_list|(
literal|2
argument_list|)
argument_list|,
name|rs
operator|.
name|get
argument_list|(
literal|2
argument_list|)
operator|.
name|startsWith
argument_list|(
literal|"{\"transactionid\":21,\"bucketid\":536870912,\"rowid\":1}\t1\t1\t17\t"
argument_list|)
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertTrue
argument_list|(
name|rs
operator|.
name|get
argument_list|(
literal|2
argument_list|)
argument_list|,
name|rs
operator|.
name|get
argument_list|(
literal|2
argument_list|)
operator|.
name|endsWith
argument_list|(
literal|"nobuckets/base_0000021/bucket_00000"
argument_list|)
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertTrue
argument_list|(
name|rs
operator|.
name|get
argument_list|(
literal|3
argument_list|)
argument_list|,
name|rs
operator|.
name|get
argument_list|(
literal|3
argument_list|)
operator|.
name|startsWith
argument_list|(
literal|"{\"transactionid\":19,\"bucketid\":536936448,\"rowid\":1}\t2\t2\t2\t"
argument_list|)
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertTrue
argument_list|(
name|rs
operator|.
name|get
argument_list|(
literal|3
argument_list|)
argument_list|,
name|rs
operator|.
name|get
argument_list|(
literal|3
argument_list|)
operator|.
name|endsWith
argument_list|(
literal|"nobuckets/base_0000021/bucket_00001"
argument_list|)
argument_list|)
expr_stmt|;
name|expectedFiles
operator|.
name|clear
argument_list|()
expr_stmt|;
name|expectedFiles
operator|.
name|add
argument_list|(
literal|"delete_delta_0000021_0000021_0000/bucket_00000"
argument_list|)
expr_stmt|;
name|expectedFiles
operator|.
name|add
argument_list|(
literal|"uckets/delta_0000019_0000019_0000/bucket_00000"
argument_list|)
expr_stmt|;
name|expectedFiles
operator|.
name|add
argument_list|(
literal|"uckets/delta_0000019_0000019_0000/bucket_00001"
argument_list|)
expr_stmt|;
name|expectedFiles
operator|.
name|add
argument_list|(
literal|"uckets/delta_0000021_0000021_0000/bucket_00000"
argument_list|)
expr_stmt|;
name|expectedFiles
operator|.
name|add
argument_list|(
literal|"/warehouse/nobuckets/base_0000021/bucket_00000"
argument_list|)
expr_stmt|;
name|expectedFiles
operator|.
name|add
argument_list|(
literal|"/warehouse/nobuckets/base_0000021/bucket_00001"
argument_list|)
expr_stmt|;
name|assertExpectedFileSet
argument_list|(
name|expectedFiles
argument_list|,
name|getWarehouseDir
argument_list|()
operator|+
literal|"/nobuckets"
argument_list|)
expr_stmt|;
name|TestTxnCommands2
operator|.
name|runCleaner
argument_list|(
name|hiveConf
argument_list|)
expr_stmt|;
name|rs
operator|=
name|runStatementOnDriver
argument_list|(
literal|"select c1, c2, c3 from nobuckets order by c1, c2, c3"
argument_list|)
expr_stmt|;
name|int
index|[]
index|[]
name|result
init|=
block|{
block|{
literal|0
block|,
literal|0
block|,
literal|17
block|}
block|,
block|{
literal|1
block|,
literal|1
block|,
literal|17
block|}
block|,
block|{
literal|2
block|,
literal|2
block|,
literal|2
block|}
block|,
block|{
literal|3
block|,
literal|3
block|,
literal|3
block|}
block|}
decl_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
literal|"Unexpected result after clean"
argument_list|,
name|stringifyValues
argument_list|(
name|result
argument_list|)
argument_list|,
name|rs
argument_list|)
expr_stmt|;
name|expectedFiles
operator|.
name|clear
argument_list|()
expr_stmt|;
name|expectedFiles
operator|.
name|add
argument_list|(
literal|"nobuckets/base_0000021/bucket_00000"
argument_list|)
expr_stmt|;
name|expectedFiles
operator|.
name|add
argument_list|(
literal|"nobuckets/base_0000021/bucket_00001"
argument_list|)
expr_stmt|;
name|assertExpectedFileSet
argument_list|(
name|expectedFiles
argument_list|,
name|getWarehouseDir
argument_list|()
operator|+
literal|"/nobuckets"
argument_list|)
expr_stmt|;
block|}
comment|/**    * all of these pass but don't do exactly the right thing    * files land as if it's not an acid table "warehouse/myctas4/000000_0"    * even though in {@link org.apache.hadoop.hive.metastore.TransactionalValidationListener} fires    * and sees it as transactional table    * look for QB.isCTAS() and CreateTableDesc() in SemanticAnalyzer    *    * On read, these files are treated like non acid to acid conversion    *    * see HIVE-15899    * See CTAS tests in TestAcidOnTez    */
annotation|@
name|Test
specifier|public
name|void
name|testCTAS
parameter_list|()
throws|throws
name|Exception
block|{
name|int
index|[]
index|[]
name|values
init|=
block|{
block|{
literal|1
block|,
literal|2
block|}
block|,
block|{
literal|3
block|,
literal|4
block|}
block|}
decl_stmt|;
name|runStatementOnDriver
argument_list|(
literal|"insert into "
operator|+
name|Table
operator|.
name|NONACIDORCTBL
operator|+
name|makeValuesClause
argument_list|(
name|values
argument_list|)
argument_list|)
expr_stmt|;
name|runStatementOnDriver
argument_list|(
literal|"create table myctas stored as ORC TBLPROPERTIES ('transactional"
operator|+
literal|"'='true', 'transactional_properties'='default') as select a, b from "
operator|+
name|Table
operator|.
name|NONACIDORCTBL
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|rs
init|=
name|runStatementOnDriver
argument_list|(
literal|"select * from myctas order by a, b"
argument_list|)
decl_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
name|stringifyValues
argument_list|(
name|values
argument_list|)
argument_list|,
name|rs
argument_list|)
expr_stmt|;
name|runStatementOnDriver
argument_list|(
literal|"insert into "
operator|+
name|Table
operator|.
name|ACIDTBL
operator|+
name|makeValuesClause
argument_list|(
name|values
argument_list|)
argument_list|)
expr_stmt|;
name|runStatementOnDriver
argument_list|(
literal|"create table myctas2 stored as ORC TBLPROPERTIES ('transactional"
operator|+
literal|"'='true', 'transactional_properties'='default') as select a, b from "
operator|+
name|Table
operator|.
name|ACIDTBL
argument_list|)
expr_stmt|;
name|rs
operator|=
name|runStatementOnDriver
argument_list|(
literal|"select * from myctas2 order by a, b"
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
name|stringifyValues
argument_list|(
name|values
argument_list|)
argument_list|,
name|rs
argument_list|)
expr_stmt|;
name|runStatementOnDriver
argument_list|(
literal|"create table myctas3 stored as ORC TBLPROPERTIES ('transactional"
operator|+
literal|"'='true', 'transactional_properties'='default') as select a, b from "
operator|+
name|Table
operator|.
name|NONACIDORCTBL
operator|+
literal|" union all select a, b from "
operator|+
name|Table
operator|.
name|ACIDTBL
argument_list|)
expr_stmt|;
name|rs
operator|=
name|runStatementOnDriver
argument_list|(
literal|"select * from myctas3 order by a, b"
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
name|stringifyValues
argument_list|(
operator|new
name|int
index|[]
index|[]
block|{
block|{
literal|1
block|,
literal|2
block|}
block|,
block|{
literal|1
block|,
literal|2
block|}
block|,
block|{
literal|3
block|,
literal|4
block|}
block|,
block|{
literal|3
block|,
literal|4
block|}
block|}
argument_list|)
argument_list|,
name|rs
argument_list|)
expr_stmt|;
name|runStatementOnDriver
argument_list|(
literal|"create table myctas4 stored as ORC TBLPROPERTIES ('transactional"
operator|+
literal|"'='true', 'transactional_properties'='default') as select a, b from "
operator|+
name|Table
operator|.
name|NONACIDORCTBL
operator|+
literal|" union distinct select a, b from "
operator|+
name|Table
operator|.
name|ACIDTBL
argument_list|)
expr_stmt|;
name|rs
operator|=
name|runStatementOnDriver
argument_list|(
literal|"select * from myctas4 order by a, b"
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
name|stringifyValues
argument_list|(
name|values
argument_list|)
argument_list|,
name|rs
argument_list|)
expr_stmt|;
block|}
comment|/**    * see HIVE-16177    * See also {@link TestTxnCommands2#testNonAcidToAcidConversion02()}  todo need test with> 1 bucket file    */
annotation|@
name|Test
specifier|public
name|void
name|testToAcidConversion02
parameter_list|()
throws|throws
name|Exception
block|{
comment|//create 2 rows in a file 00000_0
name|runStatementOnDriver
argument_list|(
literal|"insert into "
operator|+
name|Table
operator|.
name|NONACIDNONBUCKET
operator|+
literal|"(a,b) values(1,2),(1,3)"
argument_list|)
expr_stmt|;
comment|//create 4 rows in a file 000000_0_copy_1
name|runStatementOnDriver
argument_list|(
literal|"insert into "
operator|+
name|Table
operator|.
name|NONACIDNONBUCKET
operator|+
literal|"(a,b) values(0,12),(0,13),(1,4),(1,5)"
argument_list|)
expr_stmt|;
comment|//create 1 row in a file 000000_0_copy_2
name|runStatementOnDriver
argument_list|(
literal|"insert into "
operator|+
name|Table
operator|.
name|NONACIDNONBUCKET
operator|+
literal|"(a,b) values(1,6)"
argument_list|)
expr_stmt|;
comment|//convert the table to Acid  //todo: remove trans_prop after HIVE-17089
name|runStatementOnDriver
argument_list|(
literal|"alter table "
operator|+
name|Table
operator|.
name|NONACIDNONBUCKET
operator|+
literal|" SET TBLPROPERTIES ('transactional'='true', 'transactional_properties'='default')"
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|rs
init|=
name|runStatementOnDriver
argument_list|(
literal|"select ROW__ID, a, b, INPUT__FILE__NAME from "
operator|+
name|Table
operator|.
name|NONACIDNONBUCKET
operator|+
literal|" order by ROW__ID"
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|warn
argument_list|(
literal|"before acid ops (after convert)"
argument_list|)
expr_stmt|;
for|for
control|(
name|String
name|s
range|:
name|rs
control|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
comment|//create a some of delta directories
name|runStatementOnDriver
argument_list|(
literal|"insert into "
operator|+
name|Table
operator|.
name|NONACIDNONBUCKET
operator|+
literal|"(a,b) values(0,15),(1,16)"
argument_list|)
expr_stmt|;
name|runStatementOnDriver
argument_list|(
literal|"update "
operator|+
name|Table
operator|.
name|NONACIDNONBUCKET
operator|+
literal|" set b = 120 where a = 0 and b = 12"
argument_list|)
expr_stmt|;
name|runStatementOnDriver
argument_list|(
literal|"insert into "
operator|+
name|Table
operator|.
name|NONACIDNONBUCKET
operator|+
literal|"(a,b) values(0,17)"
argument_list|)
expr_stmt|;
name|runStatementOnDriver
argument_list|(
literal|"delete from "
operator|+
name|Table
operator|.
name|NONACIDNONBUCKET
operator|+
literal|" where a = 1 and b = 3"
argument_list|)
expr_stmt|;
name|rs
operator|=
name|runStatementOnDriver
argument_list|(
literal|"select ROW__ID, a, b, INPUT__FILE__NAME from "
operator|+
name|Table
operator|.
name|NONACIDNONBUCKET
operator|+
literal|" order by a,b"
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|warn
argument_list|(
literal|"before compact"
argument_list|)
expr_stmt|;
for|for
control|(
name|String
name|s
range|:
name|rs
control|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
name|Assert
operator|.
name|assertEquals
argument_list|(
literal|0
argument_list|,
name|BucketCodec
operator|.
name|determineVersion
argument_list|(
literal|536870912
argument_list|)
operator|.
name|decodeWriterId
argument_list|(
literal|536870912
argument_list|)
argument_list|)
expr_stmt|;
comment|/*      * All ROW__IDs are unique on read after conversion to acid      * ROW__IDs are exactly the same before and after compaction      * Also check the file name (only) after compaction for completeness      */
name|String
index|[]
index|[]
name|expected
init|=
block|{
block|{
literal|"{\"transactionid\":0,\"bucketid\":536870912,\"rowid\":3}\t0\t13"
block|,
literal|"bucket_00000"
block|,
literal|"000000_0_copy_1"
block|}
block|,
block|{
literal|"{\"transactionid\":18,\"bucketid\":536870912,\"rowid\":0}\t0\t15"
block|,
literal|"bucket_00000"
block|,
literal|"bucket_00000"
block|}
block|,
block|{
literal|"{\"transactionid\":20,\"bucketid\":536870912,\"rowid\":0}\t0\t17"
block|,
literal|"bucket_00000"
block|,
literal|"bucket_00000"
block|}
block|,
block|{
literal|"{\"transactionid\":19,\"bucketid\":536870912,\"rowid\":0}\t0\t120"
block|,
literal|"bucket_00000"
block|,
literal|"bucket_00000"
block|}
block|,
block|{
literal|"{\"transactionid\":0,\"bucketid\":536870912,\"rowid\":0}\t1\t2"
block|,
literal|"bucket_00000"
block|,
literal|"000000_0"
block|}
block|,
block|{
literal|"{\"transactionid\":0,\"bucketid\":536870912,\"rowid\":4}\t1\t4"
block|,
literal|"bucket_00000"
block|,
literal|"000000_0_copy_1"
block|}
block|,
block|{
literal|"{\"transactionid\":0,\"bucketid\":536870912,\"rowid\":5}\t1\t5"
block|,
literal|"bucket_00000"
block|,
literal|"000000_0_copy_1"
block|}
block|,
block|{
literal|"{\"transactionid\":0,\"bucketid\":536870912,\"rowid\":6}\t1\t6"
block|,
literal|"bucket_00000"
block|,
literal|"000000_0_copy_2"
block|}
block|,
block|{
literal|"{\"transactionid\":18,\"bucketid\":536870912,\"rowid\":1}\t1\t16"
block|,
literal|"bucket_00000"
block|,
literal|"bucket_00000"
block|}
block|}
decl_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
literal|"Unexpected row count before compaction"
argument_list|,
name|expected
operator|.
name|length
argument_list|,
name|rs
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|expected
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|Assert
operator|.
name|assertTrue
argument_list|(
literal|"Actual line "
operator|+
name|i
operator|+
literal|" bc: "
operator|+
name|rs
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|,
name|rs
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|startsWith
argument_list|(
name|expected
index|[
name|i
index|]
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertTrue
argument_list|(
literal|"Actual line(file) "
operator|+
name|i
operator|+
literal|" bc: "
operator|+
name|rs
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|,
name|rs
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|endsWith
argument_list|(
name|expected
index|[
name|i
index|]
index|[
literal|2
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|//run Compaction
name|runStatementOnDriver
argument_list|(
literal|"alter table "
operator|+
name|Table
operator|.
name|NONACIDNONBUCKET
operator|+
literal|" compact 'major'"
argument_list|)
expr_stmt|;
name|TestTxnCommands2
operator|.
name|runWorker
argument_list|(
name|hiveConf
argument_list|)
expr_stmt|;
comment|/*     nonacidnonbucket/     ├── 000000_0     ├── 000000_0_copy_1     ├── 000000_0_copy_2     ├── base_0000021     │   └── bucket_00000     ├── delete_delta_0000019_0000019_0000     │   └── bucket_00000     ├── delete_delta_0000021_0000021_0000     │   └── bucket_00000     ├── delta_0000018_0000018_0000     │   └── bucket_00000     ├── delta_0000019_0000019_0000     │   └── bucket_00000     └── delta_0000020_0000020_0000         └── bucket_00000      6 directories, 9 files     */
name|rs
operator|=
name|runStatementOnDriver
argument_list|(
literal|"select ROW__ID, a, b, INPUT__FILE__NAME from "
operator|+
name|Table
operator|.
name|NONACIDNONBUCKET
operator|+
literal|" order by a,b"
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|warn
argument_list|(
literal|"after compact"
argument_list|)
expr_stmt|;
for|for
control|(
name|String
name|s
range|:
name|rs
control|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
name|Assert
operator|.
name|assertEquals
argument_list|(
literal|"Unexpected row count after compaction"
argument_list|,
name|expected
operator|.
name|length
argument_list|,
name|rs
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|expected
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|Assert
operator|.
name|assertTrue
argument_list|(
literal|"Actual line "
operator|+
name|i
operator|+
literal|" ac: "
operator|+
name|rs
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|,
name|rs
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|startsWith
argument_list|(
name|expected
index|[
name|i
index|]
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertTrue
argument_list|(
literal|"Actual line(file) "
operator|+
name|i
operator|+
literal|" ac: "
operator|+
name|rs
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|,
name|rs
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|endsWith
argument_list|(
name|expected
index|[
name|i
index|]
index|[
literal|1
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|//make sure they are the same before and after compaction
block|}
comment|/**    * Currently CTAS doesn't support bucketed tables.  Correspondingly Acid only supports CTAS for    * unbucketed tables.  This test is here to make sure that if CTAS is made to support unbucketed    * tables, that it raises a red flag for Acid.    */
annotation|@
name|Test
specifier|public
name|void
name|testCtasBucketed
parameter_list|()
throws|throws
name|Exception
block|{
name|runStatementOnDriver
argument_list|(
literal|"insert into "
operator|+
name|Table
operator|.
name|NONACIDNONBUCKET
operator|+
literal|"(a,b) values(1,2),(1,3)"
argument_list|)
expr_stmt|;
name|CommandProcessorResponse
name|cpr
init|=
name|runStatementOnDriverNegative
argument_list|(
literal|"create table myctas "
operator|+
literal|"clustered by (a) into 2 buckets stored as ORC TBLPROPERTIES ('transactional'='true') as "
operator|+
literal|"select a, b from "
operator|+
name|Table
operator|.
name|NONACIDORCTBL
argument_list|)
decl_stmt|;
name|int
name|j
init|=
name|ErrorMsg
operator|.
name|CTAS_PARCOL_COEXISTENCE
operator|.
name|getErrorCode
argument_list|()
decl_stmt|;
comment|//this code doesn't propagate
comment|//    Assert.assertEquals("Wrong msg", ErrorMsg.CTAS_PARCOL_COEXISTENCE.getErrorCode(), cpr.getErrorCode());
name|Assert
operator|.
name|assertTrue
argument_list|(
name|cpr
operator|.
name|getErrorMessage
argument_list|()
operator|.
name|contains
argument_list|(
literal|"CREATE-TABLE-AS-SELECT does not support"
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_class

end_unit

