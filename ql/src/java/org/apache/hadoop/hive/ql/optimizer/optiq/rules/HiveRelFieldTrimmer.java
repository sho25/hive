begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|optimizer
operator|.
name|optiq
operator|.
name|rules
package|;
end_package

begin_import
import|import
name|java
operator|.
name|math
operator|.
name|BigDecimal
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|BitSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|LinkedHashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|net
operator|.
name|hydromatic
operator|.
name|linq4j
operator|.
name|Ord
import|;
end_import

begin_import
import|import
name|net
operator|.
name|hydromatic
operator|.
name|optiq
operator|.
name|util
operator|.
name|BitSets
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|optimizer
operator|.
name|optiq
operator|.
name|reloperators
operator|.
name|HiveAggregateRel
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|optimizer
operator|.
name|optiq
operator|.
name|reloperators
operator|.
name|HiveFilterRel
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|optimizer
operator|.
name|optiq
operator|.
name|reloperators
operator|.
name|HiveJoinRel
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|optimizer
operator|.
name|optiq
operator|.
name|reloperators
operator|.
name|HiveProjectRel
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|optimizer
operator|.
name|optiq
operator|.
name|reloperators
operator|.
name|HiveRel
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|optimizer
operator|.
name|optiq
operator|.
name|reloperators
operator|.
name|HiveSortRel
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|optimizer
operator|.
name|optiq
operator|.
name|reloperators
operator|.
name|HiveTableScanRel
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|optimizer
operator|.
name|optiq
operator|.
name|reloperators
operator|.
name|HiveUnionRel
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|rel
operator|.
name|AggregateCall
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|rel
operator|.
name|AggregateRel
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|rel
operator|.
name|CalcRel
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|rel
operator|.
name|InvalidRelException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|rel
operator|.
name|JoinRel
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|rel
operator|.
name|RelCollation
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|rel
operator|.
name|RelFieldCollation
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|rel
operator|.
name|RelNode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|rel
operator|.
name|SetOpRel
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|rel
operator|.
name|SortRel
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|rel
operator|.
name|TableFunctionRel
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|rel
operator|.
name|TableModificationRel
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|rel
operator|.
name|ValuesRel
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|rel
operator|.
name|rules
operator|.
name|RemoveTrivialProjectRule
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|relopt
operator|.
name|RelOptUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|reltype
operator|.
name|RelDataType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|reltype
operator|.
name|RelDataTypeField
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|reltype
operator|.
name|RelDataTypeImpl
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|rex
operator|.
name|RexBuilder
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|rex
operator|.
name|RexLiteral
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|rex
operator|.
name|RexNode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|rex
operator|.
name|RexPermuteInputsShuttle
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|rex
operator|.
name|RexUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|rex
operator|.
name|RexVisitor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|sql
operator|.
name|validate
operator|.
name|SqlValidator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|util
operator|.
name|Bug
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|util
operator|.
name|Pair
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|util
operator|.
name|ReflectUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|util
operator|.
name|ReflectiveVisitor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|util
operator|.
name|Util
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|util
operator|.
name|mapping
operator|.
name|IntPair
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|util
operator|.
name|mapping
operator|.
name|Mapping
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|util
operator|.
name|mapping
operator|.
name|MappingType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|util
operator|.
name|mapping
operator|.
name|Mappings
import|;
end_import

begin_comment
comment|/**  * Transformer that walks over a tree of relational expressions, replacing each  * {@link RelNode} with a 'slimmed down' relational expression that projects  * only the columns required by its consumer.  *  *<p>  * Uses multi-methods to fire the right rule for each type of relational  * expression. This allows the transformer to be extended without having to add  * a new method to RelNode, and without requiring a collection of rule classes  * scattered to the four winds.  *  *<p>  * REVIEW: jhyde, 2009/7/28: Is sql2rel the correct package for this class?  * Trimming fields is not an essential part of SQL-to-Rel translation, and  * arguably belongs in the optimization phase. But this transformer does not  * obey the usual pattern for planner rules; it is difficult to do so, because  * each {@link RelNode} needs to return a different set of fields after  * trimming.  *  *<p>  * TODO: Change 2nd arg of the {@link #trimFields} method from BitSet to  * Mapping. Sometimes it helps the consumer if you return the columns in a  * particular order. For instance, it may avoid a project at the top of the tree  * just for reordering. Could ease the transition by writing methods that  * convert BitSet to Mapping and vice versa.  */
end_comment

begin_class
specifier|public
class|class
name|HiveRelFieldTrimmer
implements|implements
name|ReflectiveVisitor
block|{
comment|// ~ Static fields/initializers ---------------------------------------------
comment|// ~ Instance fields --------------------------------------------------------
specifier|private
specifier|final
name|ReflectUtil
operator|.
name|MethodDispatcher
argument_list|<
name|TrimResult
argument_list|>
name|trimFieldsDispatcher
decl_stmt|;
comment|// ~ Constructors -----------------------------------------------------------
comment|/**    * Creates a RelFieldTrimmer.    *    * @param validator    *          Validator    */
specifier|public
name|HiveRelFieldTrimmer
parameter_list|(
name|SqlValidator
name|validator
parameter_list|)
block|{
name|Util
operator|.
name|discard
argument_list|(
name|validator
argument_list|)
expr_stmt|;
comment|// may be useful one day
name|this
operator|.
name|trimFieldsDispatcher
operator|=
name|ReflectUtil
operator|.
name|createMethodDispatcher
argument_list|(
name|TrimResult
operator|.
name|class
argument_list|,
name|this
argument_list|,
literal|"trimFields"
argument_list|,
name|RelNode
operator|.
name|class
argument_list|,
name|BitSet
operator|.
name|class
argument_list|,
name|Set
operator|.
name|class
argument_list|)
expr_stmt|;
block|}
comment|// ~ Methods ----------------------------------------------------------------
comment|/**    * Trims unused fields from a relational expression.    *    *<p>    * We presume that all fields of the relational expression are wanted by its    * consumer, so only trim fields that are not used within the tree.    *    * @param root    *          Root node of relational expression    * @return Trimmed relational expression    */
specifier|public
name|RelNode
name|trim
parameter_list|(
name|RelNode
name|root
parameter_list|)
block|{
specifier|final
name|int
name|fieldCount
init|=
name|root
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldCount
argument_list|()
decl_stmt|;
specifier|final
name|BitSet
name|fieldsUsed
init|=
name|BitSets
operator|.
name|range
argument_list|(
name|fieldCount
argument_list|)
decl_stmt|;
specifier|final
name|Set
argument_list|<
name|RelDataTypeField
argument_list|>
name|extraFields
init|=
name|Collections
operator|.
name|emptySet
argument_list|()
decl_stmt|;
specifier|final
name|TrimResult
name|trimResult
init|=
name|dispatchTrimFields
argument_list|(
name|root
argument_list|,
name|fieldsUsed
argument_list|,
name|extraFields
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|trimResult
operator|.
name|right
operator|.
name|isIdentity
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|()
throw|;
block|}
return|return
name|trimResult
operator|.
name|left
return|;
block|}
comment|/**    * Trims the fields of an input relational expression.    *    * @param rel    *          Relational expression    * @param input    *          Input relational expression, whose fields to trim    * @param fieldsUsed    *          Bitmap of fields needed by the consumer    * @return New relational expression and its field mapping    */
specifier|protected
name|TrimResult
name|trimChild
parameter_list|(
name|RelNode
name|rel
parameter_list|,
name|RelNode
name|input
parameter_list|,
name|BitSet
name|fieldsUsed
parameter_list|,
name|Set
argument_list|<
name|RelDataTypeField
argument_list|>
name|extraFields
parameter_list|)
block|{
name|Util
operator|.
name|discard
argument_list|(
name|rel
argument_list|)
expr_stmt|;
if|if
condition|(
name|input
operator|.
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
operator|.
name|endsWith
argument_list|(
literal|"MedMdrClassExtentRel"
argument_list|)
condition|)
block|{
comment|// MedMdrJoinRule cannot handle Join of Project of
comment|// MedMdrClassExtentRel, only naked MedMdrClassExtentRel.
comment|// So, disable trimming.
name|fieldsUsed
operator|=
name|BitSets
operator|.
name|range
argument_list|(
name|input
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldCount
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|dispatchTrimFields
argument_list|(
name|input
argument_list|,
name|fieldsUsed
argument_list|,
name|extraFields
argument_list|)
return|;
block|}
comment|/**    * Trims a child relational expression, then adds back a dummy project to    * restore the fields that were removed.    *    *<p>    * Sounds pointless? It causes unused fields to be removed further down the    * tree (towards the leaves), but it ensure that the consuming relational    * expression continues to see the same fields.    *    * @param rel    *          Relational expression    * @param input    *          Input relational expression, whose fields to trim    * @param fieldsUsed    *          Bitmap of fields needed by the consumer    * @return New relational expression and its field mapping    */
specifier|protected
name|TrimResult
name|trimChildRestore
parameter_list|(
name|RelNode
name|rel
parameter_list|,
name|RelNode
name|input
parameter_list|,
name|BitSet
name|fieldsUsed
parameter_list|,
name|Set
argument_list|<
name|RelDataTypeField
argument_list|>
name|extraFields
parameter_list|)
block|{
name|TrimResult
name|trimResult
init|=
name|trimChild
argument_list|(
name|rel
argument_list|,
name|input
argument_list|,
name|fieldsUsed
argument_list|,
name|extraFields
argument_list|)
decl_stmt|;
if|if
condition|(
name|trimResult
operator|.
name|right
operator|.
name|isIdentity
argument_list|()
condition|)
block|{
return|return
name|trimResult
return|;
block|}
specifier|final
name|RelDataType
name|rowType
init|=
name|input
operator|.
name|getRowType
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|RelDataTypeField
argument_list|>
name|fieldList
init|=
name|rowType
operator|.
name|getFieldList
argument_list|()
decl_stmt|;
specifier|final
name|List
argument_list|<
name|RexNode
argument_list|>
name|exprList
init|=
operator|new
name|ArrayList
argument_list|<
name|RexNode
argument_list|>
argument_list|()
decl_stmt|;
specifier|final
name|List
argument_list|<
name|String
argument_list|>
name|nameList
init|=
name|rowType
operator|.
name|getFieldNames
argument_list|()
decl_stmt|;
name|RexBuilder
name|rexBuilder
init|=
name|rel
operator|.
name|getCluster
argument_list|()
operator|.
name|getRexBuilder
argument_list|()
decl_stmt|;
assert|assert
name|trimResult
operator|.
name|right
operator|.
name|getSourceCount
argument_list|()
operator|==
name|fieldList
operator|.
name|size
argument_list|()
assert|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|fieldList
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|int
name|source
init|=
name|trimResult
operator|.
name|right
operator|.
name|getTargetOpt
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|RelDataTypeField
name|field
init|=
name|fieldList
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|exprList
operator|.
name|add
argument_list|(
name|source
operator|<
literal|0
condition|?
name|rexBuilder
operator|.
name|makeZeroLiteral
argument_list|(
name|field
operator|.
name|getType
argument_list|()
argument_list|)
else|:
name|rexBuilder
operator|.
name|makeInputRef
argument_list|(
name|field
operator|.
name|getType
argument_list|()
argument_list|,
name|source
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|RelNode
name|project
init|=
name|CalcRel
operator|.
name|createProject
argument_list|(
name|trimResult
operator|.
name|left
argument_list|,
name|exprList
argument_list|,
name|nameList
argument_list|)
decl_stmt|;
return|return
operator|new
name|TrimResult
argument_list|(
name|project
argument_list|,
name|Mappings
operator|.
name|createIdentity
argument_list|(
name|fieldList
operator|.
name|size
argument_list|()
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Invokes {@link #trimFields}, or the appropriate method for the type of the    * rel parameter, using multi-method dispatch.    *    * @param rel    *          Relational expression    * @param fieldsUsed    *          Bitmap of fields needed by the consumer    * @return New relational expression and its field mapping    */
specifier|protected
specifier|final
name|TrimResult
name|dispatchTrimFields
parameter_list|(
name|RelNode
name|rel
parameter_list|,
name|BitSet
name|fieldsUsed
parameter_list|,
name|Set
argument_list|<
name|RelDataTypeField
argument_list|>
name|extraFields
parameter_list|)
block|{
specifier|final
name|TrimResult
name|trimResult
init|=
name|trimFieldsDispatcher
operator|.
name|invoke
argument_list|(
name|rel
argument_list|,
name|fieldsUsed
argument_list|,
name|extraFields
argument_list|)
decl_stmt|;
specifier|final
name|RelNode
name|newRel
init|=
name|trimResult
operator|.
name|left
decl_stmt|;
specifier|final
name|Mapping
name|mapping
init|=
name|trimResult
operator|.
name|right
decl_stmt|;
specifier|final
name|int
name|fieldCount
init|=
name|rel
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldCount
argument_list|()
decl_stmt|;
assert|assert
name|mapping
operator|.
name|getSourceCount
argument_list|()
operator|==
name|fieldCount
operator|:
literal|"source: "
operator|+
name|mapping
operator|.
name|getSourceCount
argument_list|()
operator|+
literal|" != "
operator|+
name|fieldCount
assert|;
specifier|final
name|int
name|newFieldCount
init|=
name|newRel
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldCount
argument_list|()
decl_stmt|;
assert|assert
name|mapping
operator|.
name|getTargetCount
argument_list|()
operator|+
name|extraFields
operator|.
name|size
argument_list|()
operator|==
name|newFieldCount
operator|:
literal|"target: "
operator|+
name|mapping
operator|.
name|getTargetCount
argument_list|()
operator|+
literal|" + "
operator|+
name|extraFields
operator|.
name|size
argument_list|()
operator|+
literal|" != "
operator|+
name|newFieldCount
assert|;
if|if
condition|(
name|Bug
operator|.
name|TODO_FIXED
condition|)
block|{
assert|assert
name|newFieldCount
operator|>
literal|0
operator|:
literal|"rel has no fields after trim: "
operator|+
name|rel
assert|;
block|}
if|if
condition|(
name|newRel
operator|.
name|equals
argument_list|(
name|rel
argument_list|)
condition|)
block|{
return|return
operator|new
name|TrimResult
argument_list|(
name|rel
argument_list|,
name|mapping
argument_list|)
return|;
block|}
return|return
name|trimResult
return|;
block|}
comment|/**    * Visit method, per {@link org.eigenbase.util.ReflectiveVisitor}.    *    *<p>    * This method is invoked reflectively, so there may not be any apparent calls    * to it. The class (or derived classes) may contain overloads of this method    * with more specific types for the {@code rel} parameter.    *    *<p>    * Returns a pair: the relational expression created, and the mapping between    * the original fields and the fields of the newly created relational    * expression.    *    * @param rel    *          Relational expression    * @param fieldsUsed    *          Fields needed by the consumer    * @return relational expression and mapping    */
specifier|public
name|TrimResult
name|trimFields
parameter_list|(
name|HiveRel
name|rel
parameter_list|,
name|BitSet
name|fieldsUsed
parameter_list|,
name|Set
argument_list|<
name|RelDataTypeField
argument_list|>
name|extraFields
parameter_list|)
block|{
comment|// We don't know how to trim this kind of relational expression, so give
comment|// it back intact.
name|Util
operator|.
name|discard
argument_list|(
name|fieldsUsed
argument_list|)
expr_stmt|;
return|return
operator|new
name|TrimResult
argument_list|(
name|rel
argument_list|,
name|Mappings
operator|.
name|createIdentity
argument_list|(
name|rel
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldCount
argument_list|()
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Variant of {@link #trimFields(RelNode, BitSet, Set)} for    * {@link HiveProjectRel} .    */
specifier|public
name|TrimResult
name|trimFields
parameter_list|(
name|HiveProjectRel
name|project
parameter_list|,
name|BitSet
name|fieldsUsed
parameter_list|,
name|Set
argument_list|<
name|RelDataTypeField
argument_list|>
name|extraFields
parameter_list|)
block|{
specifier|final
name|RelDataType
name|rowType
init|=
name|project
operator|.
name|getRowType
argument_list|()
decl_stmt|;
specifier|final
name|int
name|fieldCount
init|=
name|rowType
operator|.
name|getFieldCount
argument_list|()
decl_stmt|;
specifier|final
name|RelNode
name|input
init|=
name|project
operator|.
name|getChild
argument_list|()
decl_stmt|;
specifier|final
name|RelDataType
name|inputRowType
init|=
name|input
operator|.
name|getRowType
argument_list|()
decl_stmt|;
comment|// Which fields are required from the input?
name|BitSet
name|inputFieldsUsed
init|=
operator|new
name|BitSet
argument_list|(
name|inputRowType
operator|.
name|getFieldCount
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|Set
argument_list|<
name|RelDataTypeField
argument_list|>
name|inputExtraFields
init|=
operator|new
name|LinkedHashSet
argument_list|<
name|RelDataTypeField
argument_list|>
argument_list|(
name|extraFields
argument_list|)
decl_stmt|;
name|RelOptUtil
operator|.
name|InputFinder
name|inputFinder
init|=
operator|new
name|RelOptUtil
operator|.
name|InputFinder
argument_list|(
name|inputFieldsUsed
argument_list|,
name|inputExtraFields
argument_list|)
decl_stmt|;
for|for
control|(
name|Ord
argument_list|<
name|RexNode
argument_list|>
name|ord
range|:
name|Ord
operator|.
name|zip
argument_list|(
name|project
operator|.
name|getProjects
argument_list|()
argument_list|)
control|)
block|{
if|if
condition|(
name|fieldsUsed
operator|.
name|get
argument_list|(
name|ord
operator|.
name|i
argument_list|)
condition|)
block|{
name|ord
operator|.
name|e
operator|.
name|accept
argument_list|(
name|inputFinder
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Create input with trimmed columns.
name|TrimResult
name|trimResult
init|=
name|trimChild
argument_list|(
name|project
argument_list|,
name|input
argument_list|,
name|inputFieldsUsed
argument_list|,
name|inputExtraFields
argument_list|)
decl_stmt|;
name|RelNode
name|newInput
init|=
name|trimResult
operator|.
name|left
decl_stmt|;
specifier|final
name|Mapping
name|inputMapping
init|=
name|trimResult
operator|.
name|right
decl_stmt|;
comment|// If the input is unchanged, and we need to project all columns,
comment|// there's nothing we can do.
if|if
condition|(
name|newInput
operator|==
name|input
operator|&&
name|fieldsUsed
operator|.
name|cardinality
argument_list|()
operator|==
name|fieldCount
condition|)
block|{
return|return
operator|new
name|TrimResult
argument_list|(
name|project
argument_list|,
name|Mappings
operator|.
name|createIdentity
argument_list|(
name|fieldCount
argument_list|)
argument_list|)
return|;
block|}
comment|// Some parts of the system can't handle rows with zero fields, so
comment|// pretend that one field is used.
if|if
condition|(
name|fieldsUsed
operator|.
name|cardinality
argument_list|()
operator|==
literal|0
condition|)
block|{
specifier|final
name|Mapping
name|mapping
init|=
name|Mappings
operator|.
name|create
argument_list|(
name|MappingType
operator|.
name|INVERSE_SURJECTION
argument_list|,
name|fieldCount
argument_list|,
literal|1
argument_list|)
decl_stmt|;
specifier|final
name|RexLiteral
name|expr
init|=
name|project
operator|.
name|getCluster
argument_list|()
operator|.
name|getRexBuilder
argument_list|()
operator|.
name|makeExactLiteral
argument_list|(
name|BigDecimal
operator|.
name|ZERO
argument_list|)
decl_stmt|;
name|RelDataType
name|newRowType
init|=
name|project
operator|.
name|getCluster
argument_list|()
operator|.
name|getTypeFactory
argument_list|()
operator|.
name|createStructType
argument_list|(
name|Collections
operator|.
name|singletonList
argument_list|(
name|expr
operator|.
name|getType
argument_list|()
argument_list|)
argument_list|,
name|Collections
operator|.
name|singletonList
argument_list|(
literal|"DUMMY"
argument_list|)
argument_list|)
decl_stmt|;
name|HiveProjectRel
name|newProject
init|=
operator|new
name|HiveProjectRel
argument_list|(
name|project
operator|.
name|getCluster
argument_list|()
argument_list|,
name|project
operator|.
name|getCluster
argument_list|()
operator|.
name|traitSetOf
argument_list|(
name|HiveRel
operator|.
name|CONVENTION
argument_list|)
argument_list|,
name|newInput
argument_list|,
name|Collections
operator|.
expr|<
name|RexNode
operator|>
name|singletonList
argument_list|(
name|expr
argument_list|)
argument_list|,
name|newRowType
argument_list|,
name|project
operator|.
name|getFlags
argument_list|()
argument_list|)
decl_stmt|;
return|return
operator|new
name|TrimResult
argument_list|(
name|newProject
argument_list|,
name|mapping
argument_list|)
return|;
block|}
comment|// Build new project expressions, and populate the mapping.
name|List
argument_list|<
name|RexNode
argument_list|>
name|newProjectExprList
init|=
operator|new
name|ArrayList
argument_list|<
name|RexNode
argument_list|>
argument_list|()
decl_stmt|;
specifier|final
name|RexVisitor
argument_list|<
name|RexNode
argument_list|>
name|shuttle
init|=
operator|new
name|RexPermuteInputsShuttle
argument_list|(
name|inputMapping
argument_list|,
name|newInput
argument_list|)
decl_stmt|;
specifier|final
name|Mapping
name|mapping
init|=
name|Mappings
operator|.
name|create
argument_list|(
name|MappingType
operator|.
name|INVERSE_SURJECTION
argument_list|,
name|fieldCount
argument_list|,
name|fieldsUsed
operator|.
name|cardinality
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|Ord
argument_list|<
name|RexNode
argument_list|>
name|ord
range|:
name|Ord
operator|.
name|zip
argument_list|(
name|project
operator|.
name|getProjects
argument_list|()
argument_list|)
control|)
block|{
if|if
condition|(
name|fieldsUsed
operator|.
name|get
argument_list|(
name|ord
operator|.
name|i
argument_list|)
condition|)
block|{
name|mapping
operator|.
name|set
argument_list|(
name|ord
operator|.
name|i
argument_list|,
name|newProjectExprList
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|RexNode
name|newProjectExpr
init|=
name|ord
operator|.
name|e
operator|.
name|accept
argument_list|(
name|shuttle
argument_list|)
decl_stmt|;
name|newProjectExprList
operator|.
name|add
argument_list|(
name|newProjectExpr
argument_list|)
expr_stmt|;
block|}
block|}
specifier|final
name|RelDataType
name|newRowType
init|=
name|project
operator|.
name|getCluster
argument_list|()
operator|.
name|getTypeFactory
argument_list|()
operator|.
name|createStructType
argument_list|(
name|Mappings
operator|.
name|apply3
argument_list|(
name|mapping
argument_list|,
name|rowType
operator|.
name|getFieldList
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
specifier|final
name|List
argument_list|<
name|RelCollation
argument_list|>
name|newCollations
init|=
name|RexUtil
operator|.
name|apply
argument_list|(
name|inputMapping
argument_list|,
name|project
operator|.
name|getCollationList
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|RelNode
name|newProject
decl_stmt|;
if|if
condition|(
name|RemoveTrivialProjectRule
operator|.
name|isIdentity
argument_list|(
name|newProjectExprList
argument_list|,
name|newRowType
argument_list|,
name|newInput
operator|.
name|getRowType
argument_list|()
argument_list|)
condition|)
block|{
comment|// The new project would be the identity. It is equivalent to return
comment|// its child.
name|newProject
operator|=
name|newInput
expr_stmt|;
block|}
else|else
block|{
name|newProject
operator|=
operator|new
name|HiveProjectRel
argument_list|(
name|project
operator|.
name|getCluster
argument_list|()
argument_list|,
name|project
operator|.
name|getCluster
argument_list|()
operator|.
name|traitSetOf
argument_list|(
name|newCollations
operator|.
name|isEmpty
argument_list|()
condition|?
name|HiveRel
operator|.
name|CONVENTION
else|:
name|newCollations
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|)
argument_list|,
name|newInput
argument_list|,
name|newProjectExprList
argument_list|,
name|newRowType
argument_list|,
name|project
operator|.
name|getFlags
argument_list|()
argument_list|)
expr_stmt|;
assert|assert
name|newProject
operator|.
name|getClass
argument_list|()
operator|==
name|project
operator|.
name|getClass
argument_list|()
assert|;
block|}
return|return
operator|new
name|TrimResult
argument_list|(
name|newProject
argument_list|,
name|mapping
argument_list|)
return|;
block|}
comment|/**    * Variant of {@link #trimFields(RelNode, BitSet, Set)} for    * {@link HiveFilterRel}.    */
specifier|public
name|TrimResult
name|trimFields
parameter_list|(
name|HiveFilterRel
name|filter
parameter_list|,
name|BitSet
name|fieldsUsed
parameter_list|,
name|Set
argument_list|<
name|RelDataTypeField
argument_list|>
name|extraFields
parameter_list|)
block|{
specifier|final
name|RelDataType
name|rowType
init|=
name|filter
operator|.
name|getRowType
argument_list|()
decl_stmt|;
specifier|final
name|int
name|fieldCount
init|=
name|rowType
operator|.
name|getFieldCount
argument_list|()
decl_stmt|;
specifier|final
name|RexNode
name|conditionExpr
init|=
name|filter
operator|.
name|getCondition
argument_list|()
decl_stmt|;
specifier|final
name|RelNode
name|input
init|=
name|filter
operator|.
name|getChild
argument_list|()
decl_stmt|;
comment|// We use the fields used by the consumer, plus any fields used in the
comment|// filter.
name|BitSet
name|inputFieldsUsed
init|=
operator|(
name|BitSet
operator|)
name|fieldsUsed
operator|.
name|clone
argument_list|()
decl_stmt|;
specifier|final
name|Set
argument_list|<
name|RelDataTypeField
argument_list|>
name|inputExtraFields
init|=
operator|new
name|LinkedHashSet
argument_list|<
name|RelDataTypeField
argument_list|>
argument_list|(
name|extraFields
argument_list|)
decl_stmt|;
name|RelOptUtil
operator|.
name|InputFinder
name|inputFinder
init|=
operator|new
name|RelOptUtil
operator|.
name|InputFinder
argument_list|(
name|inputFieldsUsed
argument_list|,
name|inputExtraFields
argument_list|)
decl_stmt|;
name|conditionExpr
operator|.
name|accept
argument_list|(
name|inputFinder
argument_list|)
expr_stmt|;
comment|// Create input with trimmed columns.
name|TrimResult
name|trimResult
init|=
name|trimChild
argument_list|(
name|filter
argument_list|,
name|input
argument_list|,
name|inputFieldsUsed
argument_list|,
name|inputExtraFields
argument_list|)
decl_stmt|;
name|RelNode
name|newInput
init|=
name|trimResult
operator|.
name|left
decl_stmt|;
specifier|final
name|Mapping
name|inputMapping
init|=
name|trimResult
operator|.
name|right
decl_stmt|;
comment|// If the input is unchanged, and we need to project all columns,
comment|// there's nothing we can do.
if|if
condition|(
name|newInput
operator|==
name|input
operator|&&
name|fieldsUsed
operator|.
name|cardinality
argument_list|()
operator|==
name|fieldCount
condition|)
block|{
return|return
operator|new
name|TrimResult
argument_list|(
name|filter
argument_list|,
name|Mappings
operator|.
name|createIdentity
argument_list|(
name|fieldCount
argument_list|)
argument_list|)
return|;
block|}
comment|// Build new project expressions, and populate the mapping.
specifier|final
name|RexVisitor
argument_list|<
name|RexNode
argument_list|>
name|shuttle
init|=
operator|new
name|RexPermuteInputsShuttle
argument_list|(
name|inputMapping
argument_list|,
name|newInput
argument_list|)
decl_stmt|;
name|RexNode
name|newConditionExpr
init|=
name|conditionExpr
operator|.
name|accept
argument_list|(
name|shuttle
argument_list|)
decl_stmt|;
specifier|final
name|HiveFilterRel
name|newFilter
init|=
operator|new
name|HiveFilterRel
argument_list|(
name|filter
operator|.
name|getCluster
argument_list|()
argument_list|,
name|filter
operator|.
name|getCluster
argument_list|()
operator|.
name|traitSetOf
argument_list|(
name|HiveRel
operator|.
name|CONVENTION
argument_list|)
argument_list|,
name|newInput
argument_list|,
name|newConditionExpr
argument_list|)
decl_stmt|;
assert|assert
name|newFilter
operator|.
name|getClass
argument_list|()
operator|==
name|filter
operator|.
name|getClass
argument_list|()
assert|;
comment|// The result has the same mapping as the input gave us. Sometimes we
comment|// return fields that the consumer didn't ask for, because the filter
comment|// needs them for its condition.
return|return
operator|new
name|TrimResult
argument_list|(
name|newFilter
argument_list|,
name|inputMapping
argument_list|)
return|;
block|}
comment|/**    * Variant of {@link #trimFields(RelNode, BitSet, Set)} for {@link SortRel}.    */
specifier|public
name|TrimResult
name|trimFields
parameter_list|(
name|HiveSortRel
name|sort
parameter_list|,
name|BitSet
name|fieldsUsed
parameter_list|,
name|Set
argument_list|<
name|RelDataTypeField
argument_list|>
name|extraFields
parameter_list|)
block|{
specifier|final
name|RelDataType
name|rowType
init|=
name|sort
operator|.
name|getRowType
argument_list|()
decl_stmt|;
specifier|final
name|int
name|fieldCount
init|=
name|rowType
operator|.
name|getFieldCount
argument_list|()
decl_stmt|;
specifier|final
name|RelCollation
name|collation
init|=
name|sort
operator|.
name|getCollation
argument_list|()
decl_stmt|;
specifier|final
name|RelNode
name|input
init|=
name|sort
operator|.
name|getChild
argument_list|()
decl_stmt|;
comment|// We use the fields used by the consumer, plus any fields used as sort
comment|// keys.
name|BitSet
name|inputFieldsUsed
init|=
operator|(
name|BitSet
operator|)
name|fieldsUsed
operator|.
name|clone
argument_list|()
decl_stmt|;
for|for
control|(
name|RelFieldCollation
name|field
range|:
name|collation
operator|.
name|getFieldCollations
argument_list|()
control|)
block|{
name|inputFieldsUsed
operator|.
name|set
argument_list|(
name|field
operator|.
name|getFieldIndex
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// Create input with trimmed columns.
specifier|final
name|Set
argument_list|<
name|RelDataTypeField
argument_list|>
name|inputExtraFields
init|=
name|Collections
operator|.
name|emptySet
argument_list|()
decl_stmt|;
name|TrimResult
name|trimResult
init|=
name|trimChild
argument_list|(
name|sort
argument_list|,
name|input
argument_list|,
name|inputFieldsUsed
argument_list|,
name|inputExtraFields
argument_list|)
decl_stmt|;
name|RelNode
name|newInput
init|=
name|trimResult
operator|.
name|left
decl_stmt|;
specifier|final
name|Mapping
name|inputMapping
init|=
name|trimResult
operator|.
name|right
decl_stmt|;
comment|// If the input is unchanged, and we need to project all columns,
comment|// there's nothing we can do.
if|if
condition|(
name|newInput
operator|==
name|input
operator|&&
name|inputMapping
operator|.
name|isIdentity
argument_list|()
operator|&&
name|fieldsUsed
operator|.
name|cardinality
argument_list|()
operator|==
name|fieldCount
condition|)
block|{
return|return
operator|new
name|TrimResult
argument_list|(
name|sort
argument_list|,
name|Mappings
operator|.
name|createIdentity
argument_list|(
name|fieldCount
argument_list|)
argument_list|)
return|;
block|}
specifier|final
name|SortRel
name|newSort
init|=
name|sort
operator|.
name|copy
argument_list|(
name|sort
operator|.
name|getTraitSet
argument_list|()
argument_list|,
name|newInput
argument_list|,
name|RexUtil
operator|.
name|apply
argument_list|(
name|inputMapping
argument_list|,
name|collation
argument_list|)
argument_list|)
decl_stmt|;
assert|assert
name|newSort
operator|.
name|getClass
argument_list|()
operator|==
name|sort
operator|.
name|getClass
argument_list|()
assert|;
comment|// The result has the same mapping as the input gave us. Sometimes we
comment|// return fields that the consumer didn't ask for, because the filter
comment|// needs them for its condition.
return|return
operator|new
name|TrimResult
argument_list|(
name|newSort
argument_list|,
name|inputMapping
argument_list|)
return|;
block|}
comment|/**    * Variant of {@link #trimFields(RelNode, BitSet, Set)} for {@link JoinRel}.    */
specifier|public
name|TrimResult
name|trimFields
parameter_list|(
name|HiveJoinRel
name|join
parameter_list|,
name|BitSet
name|fieldsUsed
parameter_list|,
name|Set
argument_list|<
name|RelDataTypeField
argument_list|>
name|extraFields
parameter_list|)
block|{
specifier|final
name|RelDataType
name|rowType
init|=
name|join
operator|.
name|getRowType
argument_list|()
decl_stmt|;
specifier|final
name|int
name|fieldCount
init|=
name|rowType
operator|.
name|getFieldCount
argument_list|()
decl_stmt|;
specifier|final
name|RexNode
name|conditionExpr
init|=
name|join
operator|.
name|getCondition
argument_list|()
decl_stmt|;
specifier|final
name|int
name|systemFieldCount
init|=
name|join
operator|.
name|getSystemFieldList
argument_list|()
operator|.
name|size
argument_list|()
decl_stmt|;
comment|/*      * todo: hb 6/26/14 for left SemiJoin we cannot trim yet.      * HiveJoinRelNode.deriveRowType return only left columns. Default field      * trimmer needs to be enhanced to handle this.      */
if|if
condition|(
name|join
operator|.
name|isLeftSemiJoin
argument_list|()
condition|)
block|{
return|return
operator|new
name|TrimResult
argument_list|(
name|join
argument_list|,
name|Mappings
operator|.
name|createIdentity
argument_list|(
name|fieldCount
argument_list|)
argument_list|)
return|;
block|}
comment|// Add in fields used in the condition.
name|BitSet
name|fieldsUsedPlus
init|=
operator|(
name|BitSet
operator|)
name|fieldsUsed
operator|.
name|clone
argument_list|()
decl_stmt|;
specifier|final
name|Set
argument_list|<
name|RelDataTypeField
argument_list|>
name|combinedInputExtraFields
init|=
operator|new
name|LinkedHashSet
argument_list|<
name|RelDataTypeField
argument_list|>
argument_list|(
name|extraFields
argument_list|)
decl_stmt|;
name|RelOptUtil
operator|.
name|InputFinder
name|inputFinder
init|=
operator|new
name|RelOptUtil
operator|.
name|InputFinder
argument_list|(
name|fieldsUsedPlus
argument_list|,
name|combinedInputExtraFields
argument_list|)
decl_stmt|;
name|conditionExpr
operator|.
name|accept
argument_list|(
name|inputFinder
argument_list|)
expr_stmt|;
comment|// If no system fields are used, we can remove them.
name|int
name|systemFieldUsedCount
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|systemFieldCount
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|fieldsUsed
operator|.
name|get
argument_list|(
name|i
argument_list|)
condition|)
block|{
operator|++
name|systemFieldUsedCount
expr_stmt|;
block|}
block|}
specifier|final
name|int
name|newSystemFieldCount
decl_stmt|;
if|if
condition|(
name|systemFieldUsedCount
operator|==
literal|0
condition|)
block|{
name|newSystemFieldCount
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|newSystemFieldCount
operator|=
name|systemFieldCount
expr_stmt|;
block|}
name|int
name|offset
init|=
name|systemFieldCount
decl_stmt|;
name|int
name|changeCount
init|=
literal|0
decl_stmt|;
name|int
name|newFieldCount
init|=
name|newSystemFieldCount
decl_stmt|;
name|List
argument_list|<
name|RelNode
argument_list|>
name|newInputs
init|=
operator|new
name|ArrayList
argument_list|<
name|RelNode
argument_list|>
argument_list|(
literal|2
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|Mapping
argument_list|>
name|inputMappings
init|=
operator|new
name|ArrayList
argument_list|<
name|Mapping
argument_list|>
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|Integer
argument_list|>
name|inputExtraFieldCounts
init|=
operator|new
name|ArrayList
argument_list|<
name|Integer
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|RelNode
name|input
range|:
name|join
operator|.
name|getInputs
argument_list|()
control|)
block|{
specifier|final
name|RelDataType
name|inputRowType
init|=
name|input
operator|.
name|getRowType
argument_list|()
decl_stmt|;
specifier|final
name|int
name|inputFieldCount
init|=
name|inputRowType
operator|.
name|getFieldCount
argument_list|()
decl_stmt|;
comment|// Compute required mapping.
name|BitSet
name|inputFieldsUsed
init|=
operator|new
name|BitSet
argument_list|(
name|inputFieldCount
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|bit
range|:
name|BitSets
operator|.
name|toIter
argument_list|(
name|fieldsUsedPlus
argument_list|)
control|)
block|{
if|if
condition|(
name|bit
operator|>=
name|offset
operator|&&
name|bit
operator|<
name|offset
operator|+
name|inputFieldCount
condition|)
block|{
name|inputFieldsUsed
operator|.
name|set
argument_list|(
name|bit
operator|-
name|offset
argument_list|)
expr_stmt|;
block|}
block|}
comment|// If there are system fields, we automatically use the
comment|// corresponding field in each input.
if|if
condition|(
name|newSystemFieldCount
operator|>
literal|0
condition|)
block|{
comment|// calling with newSystemFieldCount == 0 should be safe but hits
comment|// http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=6222207
name|inputFieldsUsed
operator|.
name|set
argument_list|(
literal|0
argument_list|,
name|newSystemFieldCount
argument_list|)
expr_stmt|;
block|}
comment|// FIXME: We ought to collect extra fields for each input
comment|// individually. For now, we assume that just one input has
comment|// on-demand fields.
name|Set
argument_list|<
name|RelDataTypeField
argument_list|>
name|inputExtraFields
init|=
name|RelDataTypeImpl
operator|.
name|extra
argument_list|(
name|rowType
argument_list|)
operator|==
literal|null
condition|?
name|Collections
operator|.
expr|<
name|RelDataTypeField
operator|>
name|emptySet
argument_list|()
else|:
name|combinedInputExtraFields
decl_stmt|;
name|inputExtraFieldCounts
operator|.
name|add
argument_list|(
name|inputExtraFields
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|TrimResult
name|trimResult
init|=
name|trimChild
argument_list|(
name|join
argument_list|,
name|input
argument_list|,
name|inputFieldsUsed
argument_list|,
name|inputExtraFields
argument_list|)
decl_stmt|;
name|newInputs
operator|.
name|add
argument_list|(
name|trimResult
operator|.
name|left
argument_list|)
expr_stmt|;
if|if
condition|(
name|trimResult
operator|.
name|left
operator|!=
name|input
condition|)
block|{
operator|++
name|changeCount
expr_stmt|;
block|}
specifier|final
name|Mapping
name|inputMapping
init|=
name|trimResult
operator|.
name|right
decl_stmt|;
name|inputMappings
operator|.
name|add
argument_list|(
name|inputMapping
argument_list|)
expr_stmt|;
comment|// Move offset to point to start of next input.
name|offset
operator|+=
name|inputFieldCount
expr_stmt|;
name|newFieldCount
operator|+=
name|inputMapping
operator|.
name|getTargetCount
argument_list|()
operator|+
name|inputExtraFields
operator|.
name|size
argument_list|()
expr_stmt|;
block|}
name|Mapping
name|mapping
init|=
name|Mappings
operator|.
name|create
argument_list|(
name|MappingType
operator|.
name|INVERSE_SURJECTION
argument_list|,
name|fieldCount
argument_list|,
name|newFieldCount
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|newSystemFieldCount
condition|;
operator|++
name|i
control|)
block|{
name|mapping
operator|.
name|set
argument_list|(
name|i
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
name|offset
operator|=
name|systemFieldCount
expr_stmt|;
name|int
name|newOffset
init|=
name|newSystemFieldCount
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|inputMappings
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|Mapping
name|inputMapping
init|=
name|inputMappings
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
for|for
control|(
name|IntPair
name|pair
range|:
name|inputMapping
control|)
block|{
name|mapping
operator|.
name|set
argument_list|(
name|pair
operator|.
name|source
operator|+
name|offset
argument_list|,
name|pair
operator|.
name|target
operator|+
name|newOffset
argument_list|)
expr_stmt|;
block|}
name|offset
operator|+=
name|inputMapping
operator|.
name|getSourceCount
argument_list|()
expr_stmt|;
name|newOffset
operator|+=
name|inputMapping
operator|.
name|getTargetCount
argument_list|()
operator|+
name|inputExtraFieldCounts
operator|.
name|get
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|changeCount
operator|==
literal|0
operator|&&
name|mapping
operator|.
name|isIdentity
argument_list|()
condition|)
block|{
return|return
operator|new
name|TrimResult
argument_list|(
name|join
argument_list|,
name|Mappings
operator|.
name|createIdentity
argument_list|(
name|fieldCount
argument_list|)
argument_list|)
return|;
block|}
comment|// Build new join.
specifier|final
name|RexVisitor
argument_list|<
name|RexNode
argument_list|>
name|shuttle
init|=
operator|new
name|RexPermuteInputsShuttle
argument_list|(
name|mapping
argument_list|,
name|newInputs
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|,
name|newInputs
operator|.
name|get
argument_list|(
literal|1
argument_list|)
argument_list|)
decl_stmt|;
name|RexNode
name|newConditionExpr
init|=
name|conditionExpr
operator|.
name|accept
argument_list|(
name|shuttle
argument_list|)
decl_stmt|;
specifier|final
name|HiveJoinRel
name|newJoin
init|=
name|join
operator|.
name|copy
argument_list|(
name|join
operator|.
name|getTraitSet
argument_list|()
argument_list|,
name|newConditionExpr
argument_list|,
name|newInputs
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|,
name|newInputs
operator|.
name|get
argument_list|(
literal|1
argument_list|)
argument_list|,
name|join
operator|.
name|getJoinType
argument_list|()
argument_list|,
literal|false
argument_list|)
decl_stmt|;
return|return
operator|new
name|TrimResult
argument_list|(
name|newJoin
argument_list|,
name|mapping
argument_list|)
return|;
block|}
comment|/**    * Variant of {@link #trimFields(RelNode, BitSet, Set)} for {@link SetOpRel}    * (including UNION and UNION ALL).    */
specifier|public
name|TrimResult
name|trimFields
parameter_list|(
name|HiveUnionRel
name|setOp
parameter_list|,
name|BitSet
name|fieldsUsed
parameter_list|,
name|Set
argument_list|<
name|RelDataTypeField
argument_list|>
name|extraFields
parameter_list|)
block|{
specifier|final
name|RelDataType
name|rowType
init|=
name|setOp
operator|.
name|getRowType
argument_list|()
decl_stmt|;
specifier|final
name|int
name|fieldCount
init|=
name|rowType
operator|.
name|getFieldCount
argument_list|()
decl_stmt|;
name|int
name|changeCount
init|=
literal|0
decl_stmt|;
comment|// Fennel abhors an empty row type, so pretend that the parent rel
comment|// wants the last field. (The last field is the least likely to be a
comment|// system field.)
if|if
condition|(
name|fieldsUsed
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|fieldsUsed
operator|.
name|set
argument_list|(
name|rowType
operator|.
name|getFieldCount
argument_list|()
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
comment|// Compute the desired field mapping. Give the consumer the fields they
comment|// want, in the order that they appear in the bitset.
specifier|final
name|Mapping
name|mapping
init|=
name|createMapping
argument_list|(
name|fieldsUsed
argument_list|,
name|fieldCount
argument_list|)
decl_stmt|;
comment|// Create input with trimmed columns.
specifier|final
name|List
argument_list|<
name|RelNode
argument_list|>
name|newInputs
init|=
operator|new
name|ArrayList
argument_list|<
name|RelNode
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|RelNode
name|input
range|:
name|setOp
operator|.
name|getInputs
argument_list|()
control|)
block|{
name|TrimResult
name|trimResult
init|=
name|trimChild
argument_list|(
name|setOp
argument_list|,
name|input
argument_list|,
name|fieldsUsed
argument_list|,
name|extraFields
argument_list|)
decl_stmt|;
name|RelNode
name|newInput
init|=
name|trimResult
operator|.
name|left
decl_stmt|;
specifier|final
name|Mapping
name|inputMapping
init|=
name|trimResult
operator|.
name|right
decl_stmt|;
comment|// We want "mapping", the input gave us "inputMapping", compute
comment|// "remaining" mapping.
comment|// | | |
comment|// |---------------- mapping ---------->|
comment|// |-- inputMapping -->| |
comment|// | |-- remaining -->|
comment|//
comment|// For instance, suppose we have columns [a, b, c, d],
comment|// the consumer asked for mapping = [b, d],
comment|// and the transformed input has columns inputMapping = [d, a, b].
comment|// remaining will permute [b, d] to [d, a, b].
name|Mapping
name|remaining
init|=
name|Mappings
operator|.
name|divide
argument_list|(
name|mapping
argument_list|,
name|inputMapping
argument_list|)
decl_stmt|;
comment|// Create a projection; does nothing if remaining is identity.
name|newInput
operator|=
name|HiveProjectRel
operator|.
name|projectMapping
argument_list|(
name|newInput
argument_list|,
name|remaining
argument_list|,
literal|null
argument_list|)
expr_stmt|;
if|if
condition|(
name|input
operator|!=
name|newInput
condition|)
block|{
operator|++
name|changeCount
expr_stmt|;
block|}
name|newInputs
operator|.
name|add
argument_list|(
name|newInput
argument_list|)
expr_stmt|;
block|}
comment|// If the input is unchanged, and we need to project all columns,
comment|// there's to do.
if|if
condition|(
name|changeCount
operator|==
literal|0
operator|&&
name|mapping
operator|.
name|isIdentity
argument_list|()
condition|)
block|{
return|return
operator|new
name|TrimResult
argument_list|(
name|setOp
argument_list|,
name|mapping
argument_list|)
return|;
block|}
name|RelNode
name|newSetOp
init|=
name|setOp
operator|.
name|copy
argument_list|(
name|setOp
operator|.
name|getTraitSet
argument_list|()
argument_list|,
name|newInputs
argument_list|,
literal|true
argument_list|)
decl_stmt|;
return|return
operator|new
name|TrimResult
argument_list|(
name|newSetOp
argument_list|,
name|mapping
argument_list|)
return|;
block|}
comment|/**    * Variant of {@link #trimFields(RelNode, BitSet, Set)} for    * {@link AggregateRel}.    *    * @throws InvalidRelException    */
specifier|public
name|TrimResult
name|trimFields
parameter_list|(
name|HiveAggregateRel
name|aggregate
parameter_list|,
name|BitSet
name|fieldsUsed
parameter_list|,
name|Set
argument_list|<
name|RelDataTypeField
argument_list|>
name|extraFields
parameter_list|)
throws|throws
name|InvalidRelException
block|{
comment|// Fields:
comment|//
comment|// | sys fields | group fields | agg functions |
comment|//
comment|// Two kinds of trimming:
comment|//
comment|// 1. If agg rel has system fields but none of these are used, create an
comment|// agg rel with no system fields.
comment|//
comment|// 2. If aggregate functions are not used, remove them.
comment|//
comment|// But grouping fields stay, even if they are not used.
specifier|final
name|RelDataType
name|rowType
init|=
name|aggregate
operator|.
name|getRowType
argument_list|()
decl_stmt|;
comment|// Compute which input fields are used.
name|BitSet
name|inputFieldsUsed
init|=
operator|new
name|BitSet
argument_list|()
decl_stmt|;
comment|// 1. group fields are always used
for|for
control|(
name|int
name|i
range|:
name|BitSets
operator|.
name|toIter
argument_list|(
name|aggregate
operator|.
name|getGroupSet
argument_list|()
argument_list|)
control|)
block|{
name|inputFieldsUsed
operator|.
name|set
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
comment|// 2. agg functions
for|for
control|(
name|AggregateCall
name|aggCall
range|:
name|aggregate
operator|.
name|getAggCallList
argument_list|()
control|)
block|{
for|for
control|(
name|int
name|i
range|:
name|aggCall
operator|.
name|getArgList
argument_list|()
control|)
block|{
name|inputFieldsUsed
operator|.
name|set
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Create input with trimmed columns.
specifier|final
name|RelNode
name|input
init|=
name|aggregate
operator|.
name|getInput
argument_list|(
literal|0
argument_list|)
decl_stmt|;
specifier|final
name|Set
argument_list|<
name|RelDataTypeField
argument_list|>
name|inputExtraFields
init|=
name|Collections
operator|.
name|emptySet
argument_list|()
decl_stmt|;
specifier|final
name|TrimResult
name|trimResult
init|=
name|trimChild
argument_list|(
name|aggregate
argument_list|,
name|input
argument_list|,
name|inputFieldsUsed
argument_list|,
name|inputExtraFields
argument_list|)
decl_stmt|;
specifier|final
name|RelNode
name|newInput
init|=
name|trimResult
operator|.
name|left
decl_stmt|;
specifier|final
name|Mapping
name|inputMapping
init|=
name|trimResult
operator|.
name|right
decl_stmt|;
comment|// If the input is unchanged, and we need to project all columns,
comment|// there's nothing to do.
if|if
condition|(
name|input
operator|==
name|newInput
operator|&&
name|fieldsUsed
operator|.
name|equals
argument_list|(
name|BitSets
operator|.
name|range
argument_list|(
name|rowType
operator|.
name|getFieldCount
argument_list|()
argument_list|)
argument_list|)
condition|)
block|{
return|return
operator|new
name|TrimResult
argument_list|(
name|aggregate
argument_list|,
name|Mappings
operator|.
name|createIdentity
argument_list|(
name|rowType
operator|.
name|getFieldCount
argument_list|()
argument_list|)
argument_list|)
return|;
block|}
comment|// Which agg calls are used by our consumer?
specifier|final
name|int
name|groupCount
init|=
name|aggregate
operator|.
name|getGroupSet
argument_list|()
operator|.
name|cardinality
argument_list|()
decl_stmt|;
name|int
name|j
init|=
name|groupCount
decl_stmt|;
name|int
name|usedAggCallCount
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|aggregate
operator|.
name|getAggCallList
argument_list|()
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|fieldsUsed
operator|.
name|get
argument_list|(
name|j
operator|++
argument_list|)
condition|)
block|{
operator|++
name|usedAggCallCount
expr_stmt|;
block|}
block|}
comment|// Offset due to the number of system fields having changed.
name|Mapping
name|mapping
init|=
name|Mappings
operator|.
name|create
argument_list|(
name|MappingType
operator|.
name|INVERSE_SURJECTION
argument_list|,
name|rowType
operator|.
name|getFieldCount
argument_list|()
argument_list|,
name|groupCount
operator|+
name|usedAggCallCount
argument_list|)
decl_stmt|;
specifier|final
name|BitSet
name|newGroupSet
init|=
name|Mappings
operator|.
name|apply
argument_list|(
name|inputMapping
argument_list|,
name|aggregate
operator|.
name|getGroupSet
argument_list|()
argument_list|)
decl_stmt|;
comment|// Populate mapping of where to find the fields. System and grouping
comment|// fields first.
for|for
control|(
name|IntPair
name|pair
range|:
name|inputMapping
control|)
block|{
if|if
condition|(
name|pair
operator|.
name|source
operator|<
name|groupCount
condition|)
block|{
name|mapping
operator|.
name|set
argument_list|(
name|pair
operator|.
name|source
argument_list|,
name|pair
operator|.
name|target
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Now create new agg calls, and populate mapping for them.
specifier|final
name|List
argument_list|<
name|AggregateCall
argument_list|>
name|newAggCallList
init|=
operator|new
name|ArrayList
argument_list|<
name|AggregateCall
argument_list|>
argument_list|()
decl_stmt|;
name|j
operator|=
name|groupCount
expr_stmt|;
for|for
control|(
name|AggregateCall
name|aggCall
range|:
name|aggregate
operator|.
name|getAggCallList
argument_list|()
control|)
block|{
if|if
condition|(
name|fieldsUsed
operator|.
name|get
argument_list|(
name|j
argument_list|)
condition|)
block|{
name|AggregateCall
name|newAggCall
init|=
operator|new
name|AggregateCall
argument_list|(
name|aggCall
operator|.
name|getAggregation
argument_list|()
argument_list|,
name|aggCall
operator|.
name|isDistinct
argument_list|()
argument_list|,
name|Mappings
operator|.
name|apply2
argument_list|(
name|inputMapping
argument_list|,
name|aggCall
operator|.
name|getArgList
argument_list|()
argument_list|)
argument_list|,
name|aggCall
operator|.
name|getType
argument_list|()
argument_list|,
name|aggCall
operator|.
name|getName
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|newAggCall
operator|.
name|equals
argument_list|(
name|aggCall
argument_list|)
condition|)
block|{
name|newAggCall
operator|=
name|aggCall
expr_stmt|;
comment|// immutable -> canonize to save space
block|}
name|mapping
operator|.
name|set
argument_list|(
name|j
argument_list|,
name|groupCount
operator|+
name|newAggCallList
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|newAggCallList
operator|.
name|add
argument_list|(
name|newAggCall
argument_list|)
expr_stmt|;
block|}
operator|++
name|j
expr_stmt|;
block|}
name|RelNode
name|newAggregate
init|=
operator|new
name|HiveAggregateRel
argument_list|(
name|aggregate
operator|.
name|getCluster
argument_list|()
argument_list|,
name|aggregate
operator|.
name|getCluster
argument_list|()
operator|.
name|traitSetOf
argument_list|(
name|HiveRel
operator|.
name|CONVENTION
argument_list|)
argument_list|,
name|newInput
argument_list|,
name|newGroupSet
argument_list|,
name|newAggCallList
argument_list|)
decl_stmt|;
assert|assert
name|newAggregate
operator|.
name|getClass
argument_list|()
operator|==
name|aggregate
operator|.
name|getClass
argument_list|()
assert|;
return|return
operator|new
name|TrimResult
argument_list|(
name|newAggregate
argument_list|,
name|mapping
argument_list|)
return|;
block|}
comment|/**    * Variant of {@link #trimFields(RelNode, BitSet, Set)} for    * {@link TableModificationRel}.    */
specifier|public
name|TrimResult
name|trimFields
parameter_list|(
name|TableModificationRel
name|modifier
parameter_list|,
name|BitSet
name|fieldsUsed
parameter_list|,
name|Set
argument_list|<
name|RelDataTypeField
argument_list|>
name|extraFields
parameter_list|)
block|{
comment|// Ignore what consumer wants. We always project all columns.
name|Util
operator|.
name|discard
argument_list|(
name|fieldsUsed
argument_list|)
expr_stmt|;
specifier|final
name|RelDataType
name|rowType
init|=
name|modifier
operator|.
name|getRowType
argument_list|()
decl_stmt|;
specifier|final
name|int
name|fieldCount
init|=
name|rowType
operator|.
name|getFieldCount
argument_list|()
decl_stmt|;
name|RelNode
name|input
init|=
name|modifier
operator|.
name|getChild
argument_list|()
decl_stmt|;
comment|// We want all fields from the child.
specifier|final
name|int
name|inputFieldCount
init|=
name|input
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldCount
argument_list|()
decl_stmt|;
name|BitSet
name|inputFieldsUsed
init|=
name|BitSets
operator|.
name|range
argument_list|(
name|inputFieldCount
argument_list|)
decl_stmt|;
comment|// Create input with trimmed columns.
specifier|final
name|Set
argument_list|<
name|RelDataTypeField
argument_list|>
name|inputExtraFields
init|=
name|Collections
operator|.
name|emptySet
argument_list|()
decl_stmt|;
name|TrimResult
name|trimResult
init|=
name|trimChild
argument_list|(
name|modifier
argument_list|,
name|input
argument_list|,
name|inputFieldsUsed
argument_list|,
name|inputExtraFields
argument_list|)
decl_stmt|;
name|RelNode
name|newInput
init|=
name|trimResult
operator|.
name|left
decl_stmt|;
specifier|final
name|Mapping
name|inputMapping
init|=
name|trimResult
operator|.
name|right
decl_stmt|;
if|if
condition|(
operator|!
name|inputMapping
operator|.
name|isIdentity
argument_list|()
condition|)
block|{
comment|// We asked for all fields. Can't believe that the child decided
comment|// to permute them!
throw|throw
name|Util
operator|.
name|newInternal
argument_list|(
literal|"Expected identity mapping, got "
operator|+
name|inputMapping
argument_list|)
throw|;
block|}
name|TableModificationRel
name|newModifier
init|=
name|modifier
decl_stmt|;
if|if
condition|(
name|newInput
operator|!=
name|input
condition|)
block|{
name|newModifier
operator|=
name|modifier
operator|.
name|copy
argument_list|(
name|modifier
operator|.
name|getTraitSet
argument_list|()
argument_list|,
name|Collections
operator|.
name|singletonList
argument_list|(
name|newInput
argument_list|)
argument_list|)
expr_stmt|;
block|}
assert|assert
name|newModifier
operator|.
name|getClass
argument_list|()
operator|==
name|modifier
operator|.
name|getClass
argument_list|()
assert|;
comment|// Always project all fields.
name|Mapping
name|mapping
init|=
name|Mappings
operator|.
name|createIdentity
argument_list|(
name|fieldCount
argument_list|)
decl_stmt|;
return|return
operator|new
name|TrimResult
argument_list|(
name|newModifier
argument_list|,
name|mapping
argument_list|)
return|;
block|}
comment|/**    * Variant of {@link #trimFields(RelNode, BitSet, Set)} for    * {@link TableFunctionRel}.    */
specifier|public
name|TrimResult
name|trimFields
parameter_list|(
name|TableFunctionRel
name|tabFun
parameter_list|,
name|BitSet
name|fieldsUsed
parameter_list|,
name|Set
argument_list|<
name|RelDataTypeField
argument_list|>
name|extraFields
parameter_list|)
block|{
specifier|final
name|RelDataType
name|rowType
init|=
name|tabFun
operator|.
name|getRowType
argument_list|()
decl_stmt|;
specifier|final
name|int
name|fieldCount
init|=
name|rowType
operator|.
name|getFieldCount
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|RelNode
argument_list|>
name|newInputs
init|=
operator|new
name|ArrayList
argument_list|<
name|RelNode
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|RelNode
name|input
range|:
name|tabFun
operator|.
name|getInputs
argument_list|()
control|)
block|{
specifier|final
name|int
name|inputFieldCount
init|=
name|input
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldCount
argument_list|()
decl_stmt|;
name|BitSet
name|inputFieldsUsed
init|=
name|BitSets
operator|.
name|range
argument_list|(
name|inputFieldCount
argument_list|)
decl_stmt|;
comment|// Create input with trimmed columns.
specifier|final
name|Set
argument_list|<
name|RelDataTypeField
argument_list|>
name|inputExtraFields
init|=
name|Collections
operator|.
name|emptySet
argument_list|()
decl_stmt|;
name|TrimResult
name|trimResult
init|=
name|trimChildRestore
argument_list|(
name|tabFun
argument_list|,
name|input
argument_list|,
name|inputFieldsUsed
argument_list|,
name|inputExtraFields
argument_list|)
decl_stmt|;
assert|assert
name|trimResult
operator|.
name|right
operator|.
name|isIdentity
argument_list|()
assert|;
name|newInputs
operator|.
name|add
argument_list|(
name|trimResult
operator|.
name|left
argument_list|)
expr_stmt|;
block|}
name|TableFunctionRel
name|newTabFun
init|=
name|tabFun
decl_stmt|;
if|if
condition|(
operator|!
name|tabFun
operator|.
name|getInputs
argument_list|()
operator|.
name|equals
argument_list|(
name|newInputs
argument_list|)
condition|)
block|{
name|newTabFun
operator|=
name|tabFun
operator|.
name|copy
argument_list|(
name|tabFun
operator|.
name|getTraitSet
argument_list|()
argument_list|,
name|newInputs
argument_list|)
expr_stmt|;
block|}
assert|assert
name|newTabFun
operator|.
name|getClass
argument_list|()
operator|==
name|tabFun
operator|.
name|getClass
argument_list|()
assert|;
comment|// Always project all fields.
name|Mapping
name|mapping
init|=
name|Mappings
operator|.
name|createIdentity
argument_list|(
name|fieldCount
argument_list|)
decl_stmt|;
return|return
operator|new
name|TrimResult
argument_list|(
name|newTabFun
argument_list|,
name|mapping
argument_list|)
return|;
block|}
comment|/**    * Variant of {@link #trimFields(RelNode, BitSet, Set)} for    * {@link org.eigenbase.rel.ValuesRel}.    */
specifier|public
name|TrimResult
name|trimFields
parameter_list|(
name|ValuesRel
name|values
parameter_list|,
name|BitSet
name|fieldsUsed
parameter_list|,
name|Set
argument_list|<
name|RelDataTypeField
argument_list|>
name|extraFields
parameter_list|)
block|{
specifier|final
name|RelDataType
name|rowType
init|=
name|values
operator|.
name|getRowType
argument_list|()
decl_stmt|;
specifier|final
name|int
name|fieldCount
init|=
name|rowType
operator|.
name|getFieldCount
argument_list|()
decl_stmt|;
comment|// If they are asking for no fields, we can't give them what they want,
comment|// because zero-column records are illegal. Give them the last field,
comment|// which is unlikely to be a system field.
if|if
condition|(
name|fieldsUsed
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|fieldsUsed
operator|=
name|BitSets
operator|.
name|range
argument_list|(
name|fieldCount
operator|-
literal|1
argument_list|,
name|fieldCount
argument_list|)
expr_stmt|;
block|}
comment|// If all fields are used, return unchanged.
if|if
condition|(
name|fieldsUsed
operator|.
name|equals
argument_list|(
name|BitSets
operator|.
name|range
argument_list|(
name|fieldCount
argument_list|)
argument_list|)
condition|)
block|{
name|Mapping
name|mapping
init|=
name|Mappings
operator|.
name|createIdentity
argument_list|(
name|fieldCount
argument_list|)
decl_stmt|;
return|return
operator|new
name|TrimResult
argument_list|(
name|values
argument_list|,
name|mapping
argument_list|)
return|;
block|}
name|List
argument_list|<
name|List
argument_list|<
name|RexLiteral
argument_list|>
argument_list|>
name|newTuples
init|=
operator|new
name|ArrayList
argument_list|<
name|List
argument_list|<
name|RexLiteral
argument_list|>
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|List
argument_list|<
name|RexLiteral
argument_list|>
name|tuple
range|:
name|values
operator|.
name|getTuples
argument_list|()
control|)
block|{
name|List
argument_list|<
name|RexLiteral
argument_list|>
name|newTuple
init|=
operator|new
name|ArrayList
argument_list|<
name|RexLiteral
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|field
range|:
name|BitSets
operator|.
name|toIter
argument_list|(
name|fieldsUsed
argument_list|)
control|)
block|{
name|newTuple
operator|.
name|add
argument_list|(
name|tuple
operator|.
name|get
argument_list|(
name|field
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|newTuples
operator|.
name|add
argument_list|(
name|newTuple
argument_list|)
expr_stmt|;
block|}
specifier|final
name|Mapping
name|mapping
init|=
name|createMapping
argument_list|(
name|fieldsUsed
argument_list|,
name|fieldCount
argument_list|)
decl_stmt|;
name|RelDataType
name|newRowType
init|=
name|values
operator|.
name|getCluster
argument_list|()
operator|.
name|getTypeFactory
argument_list|()
operator|.
name|createStructType
argument_list|(
name|Mappings
operator|.
name|apply3
argument_list|(
name|mapping
argument_list|,
name|rowType
operator|.
name|getFieldList
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
specifier|final
name|ValuesRel
name|newValues
init|=
operator|new
name|ValuesRel
argument_list|(
name|values
operator|.
name|getCluster
argument_list|()
argument_list|,
name|newRowType
argument_list|,
name|newTuples
argument_list|)
decl_stmt|;
return|return
operator|new
name|TrimResult
argument_list|(
name|newValues
argument_list|,
name|mapping
argument_list|)
return|;
block|}
specifier|private
name|Mapping
name|createMapping
parameter_list|(
name|BitSet
name|fieldsUsed
parameter_list|,
name|int
name|fieldCount
parameter_list|)
block|{
specifier|final
name|Mapping
name|mapping
init|=
name|Mappings
operator|.
name|create
argument_list|(
name|MappingType
operator|.
name|INVERSE_SURJECTION
argument_list|,
name|fieldCount
argument_list|,
name|fieldsUsed
operator|.
name|cardinality
argument_list|()
argument_list|)
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|field
range|:
name|BitSets
operator|.
name|toIter
argument_list|(
name|fieldsUsed
argument_list|)
control|)
block|{
name|mapping
operator|.
name|set
argument_list|(
name|field
argument_list|,
name|i
operator|++
argument_list|)
expr_stmt|;
block|}
return|return
name|mapping
return|;
block|}
comment|/**    * Variant of {@link #trimFields(RelNode, BitSet, Set)} for    * {@link org.eigenbase.rel.TableAccessRel}.    */
specifier|public
name|TrimResult
name|trimFields
parameter_list|(
specifier|final
name|HiveTableScanRel
name|tableAccessRel
parameter_list|,
name|BitSet
name|fieldsUsed
parameter_list|,
name|Set
argument_list|<
name|RelDataTypeField
argument_list|>
name|extraFields
parameter_list|)
block|{
specifier|final
name|int
name|fieldCount
init|=
name|tableAccessRel
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldCount
argument_list|()
decl_stmt|;
if|if
condition|(
name|fieldsUsed
operator|.
name|equals
argument_list|(
name|BitSets
operator|.
name|range
argument_list|(
name|fieldCount
argument_list|)
argument_list|)
operator|&&
name|extraFields
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return
name|trimFields
argument_list|(
operator|(
name|HiveRel
operator|)
name|tableAccessRel
argument_list|,
name|fieldsUsed
argument_list|,
name|extraFields
argument_list|)
return|;
block|}
specifier|final
name|RelNode
name|_newTableAccessRel
init|=
name|tableAccessRel
operator|.
name|project
argument_list|(
name|fieldsUsed
argument_list|,
name|extraFields
argument_list|)
decl_stmt|;
specifier|final
name|RelNode
name|newTableAccessRel
init|=
name|HiveProjectRel
operator|.
name|DEFAULT_PROJECT_FACTORY
operator|.
name|createProject
argument_list|(
name|tableAccessRel
argument_list|,
name|_newTableAccessRel
operator|.
name|getChildExps
argument_list|()
argument_list|,
name|_newTableAccessRel
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldNames
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|Mapping
name|mapping
init|=
name|createMapping
argument_list|(
name|fieldsUsed
argument_list|,
name|fieldCount
argument_list|)
decl_stmt|;
return|return
operator|new
name|TrimResult
argument_list|(
name|newTableAccessRel
argument_list|,
name|mapping
argument_list|)
return|;
block|}
comment|// ~ Inner Classes ----------------------------------------------------------
comment|/**    * Result of an attempt to trim columns from a relational expression.    *    *<p>    * The mapping describes where to find the columns wanted by the parent of the    * current relational expression.    *    *<p>    * The mapping is a {@link org.eigenbase.util.mapping.Mappings.SourceMapping},    * which means that no column can be used more than once, and some columns are    * not used. {@code columnsUsed.getSource(i)} returns the source of the i'th    * output field.    *    *<p>    * For example, consider the mapping for a relational expression that has 4    * output columns but only two are being used. The mapping {2&rarr; 1, 3    *&rarr; 0} would give the following behavior:    *</p>    *    *<ul>    *<li>columnsUsed.getSourceCount() returns 4    *<li>columnsUsed.getTargetCount() returns 2    *<li>columnsUsed.getSource(0) returns 3    *<li>columnsUsed.getSource(1) returns 2    *<li>columnsUsed.getSource(2) throws IndexOutOfBounds    *<li>columnsUsed.getTargetOpt(3) returns 0    *<li>columnsUsed.getTargetOpt(0) returns -1    *</ul>    */
specifier|protected
specifier|static
class|class
name|TrimResult
extends|extends
name|Pair
argument_list|<
name|RelNode
argument_list|,
name|Mapping
argument_list|>
block|{
comment|/**      * Creates a TrimResult.      *      * @param left      *          New relational expression      * @param right      *          Mapping of fields onto original fields      */
specifier|public
name|TrimResult
parameter_list|(
name|RelNode
name|left
parameter_list|,
name|Mapping
name|right
parameter_list|)
block|{
name|super
argument_list|(
name|left
argument_list|,
name|right
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_class

begin_comment
comment|// End RelFieldTrimmer.java
end_comment

end_unit

