begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*   Licensed to the Apache Software Foundation (ASF) under one   or more contributor license agreements.  See the NOTICE file   distributed with this work for additional information   regarding copyright ownership.  The ASF licenses this file   to you under the Apache License, Version 2.0 (the   "License"); you may not use this file except in compliance   with the License.  You may obtain a copy of the License at        http://www.apache.org/licenses/LICENSE-2.0    Unless required by applicable law or agreed to in writing, software   distributed under the License is distributed on an "AS IS" BASIS,   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.   See the License for the specific language governing permissions and   limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|lockmgr
package|;
end_package

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|VisibleForTesting
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|common
operator|.
name|JavaUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|common
operator|.
name|ValidTxnList
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|common
operator|.
name|ValidTxnWriteIdList
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|conf
operator|.
name|HiveConf
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|metastore
operator|.
name|IMetaStoreClient
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|metastore
operator|.
name|LockRequestBuilder
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|metastore
operator|.
name|api
operator|.
name|LockComponent
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|metastore
operator|.
name|api
operator|.
name|LockResponse
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|metastore
operator|.
name|api
operator|.
name|LockState
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|metastore
operator|.
name|api
operator|.
name|MetaException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|metastore
operator|.
name|api
operator|.
name|NoSuchLockException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|metastore
operator|.
name|api
operator|.
name|NoSuchTxnException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|metastore
operator|.
name|api
operator|.
name|TxnAbortedException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|metastore
operator|.
name|api
operator|.
name|TxnToWriteId
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|metastore
operator|.
name|api
operator|.
name|CommitTxnRequest
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|metastore
operator|.
name|txn
operator|.
name|TxnCommonUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|Context
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|ErrorMsg
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|QueryPlan
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|hooks
operator|.
name|WriteEntity
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|io
operator|.
name|AcidUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|metadata
operator|.
name|Hive
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|metadata
operator|.
name|HiveException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|HiveOperation
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|LockDatabaseDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|LockTableDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|UnlockDatabaseDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|UnlockTableDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|security
operator|.
name|UserGroupInformation
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hive
operator|.
name|common
operator|.
name|util
operator|.
name|ShutdownHookManager
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|thrift
operator|.
name|TException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|security
operator|.
name|PrivilegedExceptionAction
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|Executors
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ScheduledExecutorService
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ScheduledFuture
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ScheduledThreadPoolExecutor
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ThreadFactory
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|TimeUnit
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicInteger
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicReference
import|;
end_import

begin_comment
comment|/**  * An implementation of HiveTxnManager that stores the transactions in the metastore database.  * There should be 1 instance o {@link DbTxnManager} per {@link org.apache.hadoop.hive.ql.session.SessionState}  * with a single thread accessing it at a time, with the exception of {@link #heartbeat()} method.  * The later may (usually will) be called from a timer thread.  * See {@link #getMS()} for more important concurrency/metastore access notes.  *  * Each statement that the TM (transaction manager) should be aware of should belong to a transaction.  * Effectively, that means any statement that has side effects.  Exceptions are statements like  * Show Compactions, Show Tables, Use Database foo, etc.  The transaction is started either  * explicitly ( via Start Transaction SQL statement from end user - not fully supported) or  * implicitly by the {@link org.apache.hadoop.hive.ql.Driver} (which looks exactly as autoCommit=true  * from end user poit of view). See more at {@link #isExplicitTransaction}.  */
end_comment

begin_class
specifier|public
specifier|final
class|class
name|DbTxnManager
extends|extends
name|HiveTxnManagerImpl
block|{
specifier|static
specifier|final
specifier|private
name|String
name|CLASS_NAME
init|=
name|DbTxnManager
operator|.
name|class
operator|.
name|getName
argument_list|()
decl_stmt|;
specifier|static
specifier|final
specifier|private
name|Logger
name|LOG
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|CLASS_NAME
argument_list|)
decl_stmt|;
specifier|private
specifier|volatile
name|DbLockManager
name|lockMgr
init|=
literal|null
decl_stmt|;
comment|/**    * The Metastore NEXT_TXN_ID.NTXN_NEXT is initialized to 1; it contains the next available    * transaction id.  Thus is 1 is first transaction id.    */
specifier|private
specifier|volatile
name|long
name|txnId
init|=
literal|0
decl_stmt|;
comment|/**    * The local cache of table write IDs allocated/created by the current transaction    */
specifier|private
name|Map
argument_list|<
name|String
argument_list|,
name|Long
argument_list|>
name|tableWriteIds
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
comment|/**    * assigns a unique monotonically increasing ID to each statement    * which is part of an open transaction.  This is used by storage    * layer (see {@link org.apache.hadoop.hive.ql.io.AcidUtils#deltaSubdir(long, long, int)})    * to keep apart multiple writes of the same data within the same transaction    * Also see {@link org.apache.hadoop.hive.ql.io.AcidOutputFormat.Options}.    */
specifier|private
name|int
name|stmtId
init|=
operator|-
literal|1
decl_stmt|;
comment|/**    * counts number of statements in the current transaction.    */
specifier|private
name|int
name|numStatements
init|=
literal|0
decl_stmt|;
comment|/**    * if {@code true} it means current transaction is started via START TRANSACTION which means it cannot    * include any Operations which cannot be rolled back (drop partition; write to  non-acid table).    * If false, it's a single statement transaction which can include any statement.  This is not a    * contradiction from the user point of view who doesn't know anything about the implicit txn    * and cannot call rollback (the statement of course can fail in which case there is nothing to    * rollback (assuming the statement is well implemented)).    *    * This is done so that all commands run in a transaction which simplifies implementation and    * allows a simple implementation of multi-statement txns which don't require a lock manager    * capable of deadlock detection.  (todo: not fully implemented; elaborate on how this LM works)    *    * Also, critically important, ensuring that everything runs in a transaction assigns an order    * to all operations in the system - needed for replication/DR.    *    * We don't want to allow non-transactional statements in a user demarcated txn because the effect    * of such statement is "visible" immediately on statement completion, but the user may    * issue a rollback but the action of the statement can't be undone (and has possibly already been    * seen by another txn).  For example,    * start transaction    * insert into transactional_table values(1);    * insert into non_transactional_table select * from transactional_table;    * rollback    *    * The user would be in for a surprise especially if they are not aware of transactional    * properties of the tables involved.    *    * As a side note: what should the lock manager do with locks for non-transactional resources?    * Should it it release them at the end of the stmt or txn?    * Some interesting thoughts: http://mysqlmusings.blogspot.com/2009/02/mixing-engines-in-transactions.html.    */
specifier|private
name|boolean
name|isExplicitTransaction
init|=
literal|false
decl_stmt|;
comment|/**    * To ensure transactions don't nest.    */
specifier|private
name|int
name|startTransactionCount
init|=
literal|0
decl_stmt|;
comment|// QueryId for the query in current transaction
specifier|private
name|String
name|queryId
decl_stmt|;
comment|// ExecutorService for sending heartbeat to metastore periodically.
specifier|private
specifier|static
name|ScheduledExecutorService
name|heartbeatExecutorService
init|=
literal|null
decl_stmt|;
specifier|private
name|ScheduledFuture
argument_list|<
name|?
argument_list|>
name|heartbeatTask
init|=
literal|null
decl_stmt|;
specifier|private
name|Runnable
name|shutdownRunner
init|=
literal|null
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|int
name|SHUTDOWN_HOOK_PRIORITY
init|=
literal|0
decl_stmt|;
comment|/**    * We do this on every call to make sure TM uses same MS connection as is used by the caller (Driver,    * SemanticAnalyzer, etc).  {@code Hive} instances are cached using ThreadLocal and    * {@link IMetaStoreClient} is cached within {@code Hive} with additional logic.  Futhermore, this    * ensures that multiple threads are not sharing the same Thrift client (which could happen    * if we had cached {@link IMetaStoreClient} here.    *    * ThreadLocal gets cleaned up automatically when its thread goes away    * https://docs.oracle.com/javase/7/docs/api/java/lang/ThreadLocal.html.  This is especially    * important for threads created by {@link #heartbeatExecutorService} threads.    *    * Embedded {@link DbLockManager} follows the same logic.    * @return IMetaStoreClient    * @throws LockException on any errors    */
name|IMetaStoreClient
name|getMS
parameter_list|()
throws|throws
name|LockException
block|{
try|try
block|{
return|return
name|Hive
operator|.
name|get
argument_list|(
name|conf
argument_list|)
operator|.
name|getMSC
argument_list|()
return|;
block|}
catch|catch
parameter_list|(
name|HiveException
decl||
name|MetaException
name|e
parameter_list|)
block|{
name|String
name|msg
init|=
literal|"Unable to reach Hive Metastore: "
operator|+
name|e
operator|.
name|getMessage
argument_list|()
decl_stmt|;
name|LOG
operator|.
name|error
argument_list|(
name|msg
argument_list|,
name|e
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|LockException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
name|DbTxnManager
parameter_list|()
block|{
name|shutdownRunner
operator|=
operator|new
name|Runnable
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|void
name|run
parameter_list|()
block|{
if|if
condition|(
name|heartbeatExecutorService
operator|!=
literal|null
operator|&&
operator|!
name|heartbeatExecutorService
operator|.
name|isShutdown
argument_list|()
operator|&&
operator|!
name|heartbeatExecutorService
operator|.
name|isTerminated
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Shutting down Heartbeater thread pool."
argument_list|)
expr_stmt|;
name|heartbeatExecutorService
operator|.
name|shutdown
argument_list|()
expr_stmt|;
block|}
block|}
block|}
expr_stmt|;
name|ShutdownHookManager
operator|.
name|addShutdownHook
argument_list|(
name|shutdownRunner
argument_list|,
name|SHUTDOWN_HOOK_PRIORITY
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
name|void
name|setHiveConf
parameter_list|(
name|HiveConf
name|conf
parameter_list|)
block|{
name|super
operator|.
name|setHiveConf
argument_list|(
name|conf
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|conf
operator|.
name|getBoolVar
argument_list|(
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVE_SUPPORT_CONCURRENCY
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
name|ErrorMsg
operator|.
name|DBTXNMGR_REQUIRES_CONCURRENCY
operator|.
name|getMsg
argument_list|()
argument_list|)
throw|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|List
argument_list|<
name|Long
argument_list|>
name|replOpenTxn
parameter_list|(
name|String
name|replPolicy
parameter_list|,
name|List
argument_list|<
name|Long
argument_list|>
name|srcTxnIds
parameter_list|,
name|String
name|user
parameter_list|)
throws|throws
name|LockException
block|{
try|try
block|{
return|return
name|getMS
argument_list|()
operator|.
name|replOpenTxn
argument_list|(
name|replPolicy
argument_list|,
name|srcTxnIds
argument_list|,
name|user
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|TException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|LockException
argument_list|(
name|e
argument_list|,
name|ErrorMsg
operator|.
name|METASTORE_COMMUNICATION_FAILED
argument_list|)
throw|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|long
name|openTxn
parameter_list|(
name|Context
name|ctx
parameter_list|,
name|String
name|user
parameter_list|)
throws|throws
name|LockException
block|{
return|return
name|openTxn
argument_list|(
name|ctx
argument_list|,
name|user
argument_list|,
literal|0
argument_list|)
return|;
block|}
annotation|@
name|VisibleForTesting
name|long
name|openTxn
parameter_list|(
name|Context
name|ctx
parameter_list|,
name|String
name|user
parameter_list|,
name|long
name|delay
parameter_list|)
throws|throws
name|LockException
block|{
comment|/*Q: why don't we lock the snapshot here???  Instead of having client make an explicit call     whenever it chooses     A: If we want to rely on locks for transaction scheduling we must get the snapshot after lock     acquisition.  Relying on locks is a pessimistic strategy which works better under high     contention.*/
name|init
argument_list|()
expr_stmt|;
name|getLockManager
argument_list|()
expr_stmt|;
if|if
condition|(
name|isTxnOpen
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|LockException
argument_list|(
literal|"Transaction already opened. "
operator|+
name|JavaUtils
operator|.
name|txnIdToString
argument_list|(
name|txnId
argument_list|)
argument_list|)
throw|;
block|}
try|try
block|{
name|txnId
operator|=
name|getMS
argument_list|()
operator|.
name|openTxn
argument_list|(
name|user
argument_list|)
expr_stmt|;
name|stmtId
operator|=
literal|0
expr_stmt|;
name|numStatements
operator|=
literal|0
expr_stmt|;
name|tableWriteIds
operator|.
name|clear
argument_list|()
expr_stmt|;
name|isExplicitTransaction
operator|=
literal|false
expr_stmt|;
name|startTransactionCount
operator|=
literal|0
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Opened "
operator|+
name|JavaUtils
operator|.
name|txnIdToString
argument_list|(
name|txnId
argument_list|)
argument_list|)
expr_stmt|;
name|ctx
operator|.
name|setHeartbeater
argument_list|(
name|startHeartbeat
argument_list|(
name|delay
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|txnId
return|;
block|}
catch|catch
parameter_list|(
name|TException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|LockException
argument_list|(
name|e
argument_list|,
name|ErrorMsg
operator|.
name|METASTORE_COMMUNICATION_FAILED
argument_list|)
throw|;
block|}
block|}
comment|/**    * we don't expect multiple threads to call this method concurrently but {@link #lockMgr} will    * be read by a different threads than one writing it, thus it's {@code volatile}    */
annotation|@
name|Override
specifier|public
name|HiveLockManager
name|getLockManager
parameter_list|()
throws|throws
name|LockException
block|{
name|init
argument_list|()
expr_stmt|;
if|if
condition|(
name|lockMgr
operator|==
literal|null
condition|)
block|{
name|lockMgr
operator|=
operator|new
name|DbLockManager
argument_list|(
name|conf
argument_list|,
name|this
argument_list|)
expr_stmt|;
block|}
return|return
name|lockMgr
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|acquireLocks
parameter_list|(
name|QueryPlan
name|plan
parameter_list|,
name|Context
name|ctx
parameter_list|,
name|String
name|username
parameter_list|)
throws|throws
name|LockException
block|{
try|try
block|{
name|acquireLocksWithHeartbeatDelay
argument_list|(
name|plan
argument_list|,
name|ctx
argument_list|,
name|username
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|LockException
name|e
parameter_list|)
block|{
if|if
condition|(
name|e
operator|.
name|getCause
argument_list|()
operator|instanceof
name|TxnAbortedException
condition|)
block|{
name|txnId
operator|=
literal|0
expr_stmt|;
name|stmtId
operator|=
operator|-
literal|1
expr_stmt|;
name|tableWriteIds
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
throw|throw
name|e
throw|;
block|}
block|}
comment|/**    * Watermark to include in error msgs and logs    * @param queryPlan    * @return    */
specifier|private
specifier|static
name|String
name|getQueryIdWaterMark
parameter_list|(
name|QueryPlan
name|queryPlan
parameter_list|)
block|{
return|return
literal|"queryId="
operator|+
name|queryPlan
operator|.
name|getQueryId
argument_list|()
return|;
block|}
specifier|private
name|void
name|markExplicitTransaction
parameter_list|(
name|QueryPlan
name|queryPlan
parameter_list|)
throws|throws
name|LockException
block|{
name|isExplicitTransaction
operator|=
literal|true
expr_stmt|;
if|if
condition|(
operator|++
name|startTransactionCount
operator|>
literal|1
condition|)
block|{
throw|throw
operator|new
name|LockException
argument_list|(
literal|null
argument_list|,
name|ErrorMsg
operator|.
name|OP_NOT_ALLOWED_IN_TXN
argument_list|,
name|queryPlan
operator|.
name|getOperationName
argument_list|()
argument_list|,
name|JavaUtils
operator|.
name|txnIdToString
argument_list|(
name|getCurrentTxnId
argument_list|()
argument_list|)
argument_list|,
name|queryPlan
operator|.
name|getQueryId
argument_list|()
argument_list|)
throw|;
block|}
block|}
comment|/**    * Ensures that the current SQL statement is appropriate for the current state of the    * Transaction Manager (e.g. can call commit unless you called start transaction)    *    * Note that support for multi-statement txns is a work-in-progress so it's only supported in    * HiveConf#HIVE_IN_TEST/HiveConf#TEZ_HIVE_IN_TEST.    * @param queryPlan    * @throws LockException    */
specifier|private
name|void
name|verifyState
parameter_list|(
name|QueryPlan
name|queryPlan
parameter_list|)
throws|throws
name|LockException
block|{
if|if
condition|(
operator|!
name|isTxnOpen
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|LockException
argument_list|(
literal|"No transaction context for operation: "
operator|+
name|queryPlan
operator|.
name|getOperationName
argument_list|()
operator|+
literal|" for "
operator|+
name|getQueryIdWaterMark
argument_list|(
name|queryPlan
argument_list|)
argument_list|)
throw|;
block|}
if|if
condition|(
name|queryPlan
operator|.
name|getOperation
argument_list|()
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"Unkown HiverOperation for "
operator|+
name|getQueryIdWaterMark
argument_list|(
name|queryPlan
argument_list|)
argument_list|)
throw|;
block|}
name|numStatements
operator|++
expr_stmt|;
switch|switch
condition|(
name|queryPlan
operator|.
name|getOperation
argument_list|()
condition|)
block|{
case|case
name|START_TRANSACTION
case|:
name|markExplicitTransaction
argument_list|(
name|queryPlan
argument_list|)
expr_stmt|;
break|break;
case|case
name|COMMIT
case|:
case|case
name|ROLLBACK
case|:
if|if
condition|(
operator|!
name|isTxnOpen
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|LockException
argument_list|(
literal|null
argument_list|,
name|ErrorMsg
operator|.
name|OP_NOT_ALLOWED_WITHOUT_TXN
argument_list|,
name|queryPlan
operator|.
name|getOperationName
argument_list|()
argument_list|)
throw|;
block|}
if|if
condition|(
operator|!
name|isExplicitTransaction
condition|)
block|{
throw|throw
operator|new
name|LockException
argument_list|(
literal|null
argument_list|,
name|ErrorMsg
operator|.
name|OP_NOT_ALLOWED_IN_IMPLICIT_TXN
argument_list|,
name|queryPlan
operator|.
name|getOperationName
argument_list|()
argument_list|)
throw|;
block|}
break|break;
default|default:
if|if
condition|(
operator|!
name|queryPlan
operator|.
name|getOperation
argument_list|()
operator|.
name|isAllowedInTransaction
argument_list|()
operator|&&
name|isExplicitTransaction
condition|)
block|{
if|if
condition|(
name|allowOperationInATransaction
argument_list|(
name|queryPlan
argument_list|)
condition|)
block|{
break|break;
block|}
comment|//look at queryPlan.outputs(WriteEntity.t - that's the table)
comment|//for example, drop table in an explicit txn is not allowed
comment|//in some cases this requires looking at more than just the operation
comment|//for example HiveOperation.LOAD - OK if target is MM table but not OK if non-acid table
throw|throw
operator|new
name|LockException
argument_list|(
literal|null
argument_list|,
name|ErrorMsg
operator|.
name|OP_NOT_ALLOWED_IN_TXN
argument_list|,
name|queryPlan
operator|.
name|getOperationName
argument_list|()
argument_list|,
name|JavaUtils
operator|.
name|txnIdToString
argument_list|(
name|getCurrentTxnId
argument_list|()
argument_list|)
argument_list|,
name|queryPlan
operator|.
name|getQueryId
argument_list|()
argument_list|)
throw|;
block|}
block|}
comment|/*     Should we allow writing to non-transactional tables in an explicit transaction?  The user may     issue ROLLBACK but these tables won't rollback.     Can do this by checking ReadEntity/WriteEntity to determine whether it's reading/writing     any non acid and raise an appropriate error     * Driver.acidSinks and Driver.transactionalInQuery can be used if any acid is in the query*/
block|}
comment|/**    * This modifies the logic wrt what operations are allowed in a transaction.  Multi-statement    * transaction support is incomplete but it makes some Acid tests cases much easier to write.    */
specifier|private
name|boolean
name|allowOperationInATransaction
parameter_list|(
name|QueryPlan
name|queryPlan
parameter_list|)
block|{
comment|//Acid and MM tables support Load Data with transactional semantics.  This will allow Load Data
comment|//in a txn assuming we can determine the target is a suitable table type.
if|if
condition|(
name|queryPlan
operator|.
name|getOperation
argument_list|()
operator|==
name|HiveOperation
operator|.
name|LOAD
operator|&&
name|queryPlan
operator|.
name|getOutputs
argument_list|()
operator|!=
literal|null
operator|&&
name|queryPlan
operator|.
name|getOutputs
argument_list|()
operator|.
name|size
argument_list|()
operator|==
literal|1
condition|)
block|{
name|WriteEntity
name|writeEntity
init|=
name|queryPlan
operator|.
name|getOutputs
argument_list|()
operator|.
name|iterator
argument_list|()
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
name|AcidUtils
operator|.
name|isTransactionalTable
argument_list|(
name|writeEntity
operator|.
name|getTable
argument_list|()
argument_list|)
condition|)
block|{
switch|switch
condition|(
name|writeEntity
operator|.
name|getWriteType
argument_list|()
condition|)
block|{
case|case
name|INSERT
case|:
comment|//allow operation in a txn
return|return
literal|true
return|;
case|case
name|INSERT_OVERWRITE
case|:
comment|//see HIVE-18154
return|return
literal|false
return|;
default|default:
comment|//not relevant for LOAD
return|return
literal|false
return|;
block|}
block|}
block|}
comment|//todo: handle Insert Overwrite as well: HIVE-18154
return|return
literal|false
return|;
block|}
comment|/**    * Normally client should call {@link #acquireLocks(org.apache.hadoop.hive.ql.QueryPlan, org.apache.hadoop.hive.ql.Context, String)}    * @param isBlocking if false, the method will return immediately; thus the locks may be in LockState.WAITING    * @return null if no locks were needed    */
annotation|@
name|VisibleForTesting
name|LockState
name|acquireLocks
parameter_list|(
name|QueryPlan
name|plan
parameter_list|,
name|Context
name|ctx
parameter_list|,
name|String
name|username
parameter_list|,
name|boolean
name|isBlocking
parameter_list|)
throws|throws
name|LockException
block|{
name|init
argument_list|()
expr_stmt|;
comment|// Make sure we've built the lock manager
name|getLockManager
argument_list|()
expr_stmt|;
name|verifyState
argument_list|(
name|plan
argument_list|)
expr_stmt|;
name|queryId
operator|=
name|plan
operator|.
name|getQueryId
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|plan
operator|.
name|getOperation
argument_list|()
condition|)
block|{
case|case
name|SET_AUTOCOMMIT
case|:
comment|/**This is here for documentation purposes.  This TM doesn't support this - only has one         * mode of operation documented at {@link DbTxnManager#isExplicitTransaction}*/
return|return
literal|null
return|;
block|}
name|LockRequestBuilder
name|rqstBuilder
init|=
operator|new
name|LockRequestBuilder
argument_list|(
name|queryId
argument_list|)
decl_stmt|;
comment|//link queryId to txnId
name|LOG
operator|.
name|info
argument_list|(
literal|"Setting lock request transaction to "
operator|+
name|JavaUtils
operator|.
name|txnIdToString
argument_list|(
name|txnId
argument_list|)
operator|+
literal|" for queryId="
operator|+
name|queryId
argument_list|)
expr_stmt|;
name|rqstBuilder
operator|.
name|setTransactionId
argument_list|(
name|txnId
argument_list|)
operator|.
name|setUser
argument_list|(
name|username
argument_list|)
expr_stmt|;
comment|// Make sure we need locks.  It's possible there's nothing to lock in
comment|// this operation.
if|if
condition|(
name|plan
operator|.
name|getInputs
argument_list|()
operator|.
name|isEmpty
argument_list|()
operator|&&
name|plan
operator|.
name|getOutputs
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"No locks needed for queryId="
operator|+
name|queryId
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
name|List
argument_list|<
name|LockComponent
argument_list|>
name|lockComponents
init|=
name|AcidUtils
operator|.
name|makeLockComponents
argument_list|(
name|plan
operator|.
name|getOutputs
argument_list|()
argument_list|,
name|plan
operator|.
name|getInputs
argument_list|()
argument_list|,
name|conf
argument_list|)
decl_stmt|;
comment|//It's possible there's nothing to lock even if we have w/r entities.
if|if
condition|(
name|lockComponents
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"No locks needed for queryId="
operator|+
name|queryId
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
name|rqstBuilder
operator|.
name|addLockComponents
argument_list|(
name|lockComponents
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|HiveLock
argument_list|>
name|locks
init|=
operator|new
name|ArrayList
argument_list|<
name|HiveLock
argument_list|>
argument_list|(
literal|1
argument_list|)
decl_stmt|;
name|LockState
name|lockState
init|=
name|lockMgr
operator|.
name|lock
argument_list|(
name|rqstBuilder
operator|.
name|build
argument_list|()
argument_list|,
name|queryId
argument_list|,
name|isBlocking
argument_list|,
name|locks
argument_list|)
decl_stmt|;
name|ctx
operator|.
name|setHiveLocks
argument_list|(
name|locks
argument_list|)
expr_stmt|;
return|return
name|lockState
return|;
block|}
comment|/**    * @param delay time to delay for first heartbeat    */
annotation|@
name|VisibleForTesting
name|void
name|acquireLocksWithHeartbeatDelay
parameter_list|(
name|QueryPlan
name|plan
parameter_list|,
name|Context
name|ctx
parameter_list|,
name|String
name|username
parameter_list|,
name|long
name|delay
parameter_list|)
throws|throws
name|LockException
block|{
name|LockState
name|ls
init|=
name|acquireLocks
argument_list|(
name|plan
argument_list|,
name|ctx
argument_list|,
name|username
argument_list|,
literal|true
argument_list|)
decl_stmt|;
if|if
condition|(
name|ls
operator|!=
literal|null
operator|&&
operator|!
name|isTxnOpen
argument_list|()
condition|)
block|{
comment|// If there's no lock, we don't need to do heartbeat
comment|// Start heartbeat for read-only queries which don't open transactions but requires locks.
comment|// For those that require transactions, the heartbeat has already been started in openTxn.
name|ctx
operator|.
name|setHeartbeater
argument_list|(
name|startHeartbeat
argument_list|(
name|delay
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|void
name|releaseLocks
parameter_list|(
name|List
argument_list|<
name|HiveLock
argument_list|>
name|hiveLocks
parameter_list|)
throws|throws
name|LockException
block|{
if|if
condition|(
name|lockMgr
operator|!=
literal|null
condition|)
block|{
name|stopHeartbeat
argument_list|()
expr_stmt|;
name|lockMgr
operator|.
name|releaseLocks
argument_list|(
name|hiveLocks
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|clearLocksAndHB
parameter_list|()
throws|throws
name|LockException
block|{
name|lockMgr
operator|.
name|clearLocalLockRecords
argument_list|()
expr_stmt|;
name|stopHeartbeat
argument_list|()
expr_stmt|;
block|}
specifier|private
name|void
name|resetTxnInfo
parameter_list|()
block|{
name|txnId
operator|=
literal|0
expr_stmt|;
name|stmtId
operator|=
operator|-
literal|1
expr_stmt|;
name|numStatements
operator|=
literal|0
expr_stmt|;
name|tableWriteIds
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|replCommitTxn
parameter_list|(
name|CommitTxnRequest
name|rqst
parameter_list|)
throws|throws
name|LockException
block|{
try|try
block|{
if|if
condition|(
name|rqst
operator|.
name|isSetReplLastIdInfo
argument_list|()
condition|)
block|{
if|if
condition|(
operator|!
name|isTxnOpen
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Attempt to commit before opening a transaction"
argument_list|)
throw|;
block|}
comment|// For transaction started internally by repl load command, heartbeat needs to be stopped.
name|clearLocksAndHB
argument_list|()
expr_stmt|;
block|}
name|getMS
argument_list|()
operator|.
name|replCommitTxn
argument_list|(
name|rqst
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|NoSuchTxnException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Metastore could not find "
operator|+
name|JavaUtils
operator|.
name|txnIdToString
argument_list|(
name|rqst
operator|.
name|getTxnid
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|LockException
argument_list|(
name|e
argument_list|,
name|ErrorMsg
operator|.
name|TXN_NO_SUCH_TRANSACTION
argument_list|,
name|JavaUtils
operator|.
name|txnIdToString
argument_list|(
name|rqst
operator|.
name|getTxnid
argument_list|()
argument_list|)
argument_list|)
throw|;
block|}
catch|catch
parameter_list|(
name|TxnAbortedException
name|e
parameter_list|)
block|{
name|LockException
name|le
init|=
operator|new
name|LockException
argument_list|(
name|e
argument_list|,
name|ErrorMsg
operator|.
name|TXN_ABORTED
argument_list|,
name|JavaUtils
operator|.
name|txnIdToString
argument_list|(
name|rqst
operator|.
name|getTxnid
argument_list|()
argument_list|)
argument_list|,
name|e
operator|.
name|getMessage
argument_list|()
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|error
argument_list|(
name|le
operator|.
name|getMessage
argument_list|()
argument_list|)
expr_stmt|;
throw|throw
name|le
throw|;
block|}
catch|catch
parameter_list|(
name|TException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|LockException
argument_list|(
name|ErrorMsg
operator|.
name|METASTORE_COMMUNICATION_FAILED
operator|.
name|getMsg
argument_list|()
argument_list|,
name|e
argument_list|)
throw|;
block|}
finally|finally
block|{
if|if
condition|(
name|rqst
operator|.
name|isSetReplLastIdInfo
argument_list|()
condition|)
block|{
comment|// For transaction started internally by repl load command, needs to clear the txn info.
name|resetTxnInfo
argument_list|()
expr_stmt|;
block|}
block|}
block|}
annotation|@
name|Override
specifier|public
name|void
name|commitTxn
parameter_list|()
throws|throws
name|LockException
block|{
if|if
condition|(
operator|!
name|isTxnOpen
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Attempt to commit before opening a transaction"
argument_list|)
throw|;
block|}
try|try
block|{
comment|// do all new clear in clearLocksAndHB method to make sure that same code is there for replCommitTxn flow.
name|clearLocksAndHB
argument_list|()
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Committing txn "
operator|+
name|JavaUtils
operator|.
name|txnIdToString
argument_list|(
name|txnId
argument_list|)
argument_list|)
expr_stmt|;
name|getMS
argument_list|()
operator|.
name|commitTxn
argument_list|(
name|txnId
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|NoSuchTxnException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Metastore could not find "
operator|+
name|JavaUtils
operator|.
name|txnIdToString
argument_list|(
name|txnId
argument_list|)
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|LockException
argument_list|(
name|e
argument_list|,
name|ErrorMsg
operator|.
name|TXN_NO_SUCH_TRANSACTION
argument_list|,
name|JavaUtils
operator|.
name|txnIdToString
argument_list|(
name|txnId
argument_list|)
argument_list|)
throw|;
block|}
catch|catch
parameter_list|(
name|TxnAbortedException
name|e
parameter_list|)
block|{
name|LockException
name|le
init|=
operator|new
name|LockException
argument_list|(
name|e
argument_list|,
name|ErrorMsg
operator|.
name|TXN_ABORTED
argument_list|,
name|JavaUtils
operator|.
name|txnIdToString
argument_list|(
name|txnId
argument_list|)
argument_list|,
name|e
operator|.
name|getMessage
argument_list|()
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|error
argument_list|(
name|le
operator|.
name|getMessage
argument_list|()
argument_list|)
expr_stmt|;
throw|throw
name|le
throw|;
block|}
catch|catch
parameter_list|(
name|TException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|LockException
argument_list|(
name|ErrorMsg
operator|.
name|METASTORE_COMMUNICATION_FAILED
operator|.
name|getMsg
argument_list|()
argument_list|,
name|e
argument_list|)
throw|;
block|}
finally|finally
block|{
comment|// do all new reset in resetTxnInfo method to make sure that same code is there for replCommitTxn flow.
name|resetTxnInfo
argument_list|()
expr_stmt|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|void
name|replRollbackTxn
parameter_list|(
name|String
name|replPolicy
parameter_list|,
name|long
name|srcTxnId
parameter_list|)
throws|throws
name|LockException
block|{
try|try
block|{
name|getMS
argument_list|()
operator|.
name|replRollbackTxn
argument_list|(
name|srcTxnId
argument_list|,
name|replPolicy
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|NoSuchTxnException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Metastore could not find "
operator|+
name|JavaUtils
operator|.
name|txnIdToString
argument_list|(
name|srcTxnId
argument_list|)
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|LockException
argument_list|(
name|e
argument_list|,
name|ErrorMsg
operator|.
name|TXN_NO_SUCH_TRANSACTION
argument_list|,
name|JavaUtils
operator|.
name|txnIdToString
argument_list|(
name|srcTxnId
argument_list|)
argument_list|)
throw|;
block|}
catch|catch
parameter_list|(
name|TxnAbortedException
name|e
parameter_list|)
block|{
name|LockException
name|le
init|=
operator|new
name|LockException
argument_list|(
name|e
argument_list|,
name|ErrorMsg
operator|.
name|TXN_ABORTED
argument_list|,
name|JavaUtils
operator|.
name|txnIdToString
argument_list|(
name|srcTxnId
argument_list|)
argument_list|,
name|e
operator|.
name|getMessage
argument_list|()
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|error
argument_list|(
name|le
operator|.
name|getMessage
argument_list|()
argument_list|)
expr_stmt|;
throw|throw
name|le
throw|;
block|}
catch|catch
parameter_list|(
name|TException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|LockException
argument_list|(
name|ErrorMsg
operator|.
name|METASTORE_COMMUNICATION_FAILED
operator|.
name|getMsg
argument_list|()
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|void
name|rollbackTxn
parameter_list|()
throws|throws
name|LockException
block|{
if|if
condition|(
operator|!
name|isTxnOpen
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Attempt to rollback before opening a transaction"
argument_list|)
throw|;
block|}
try|try
block|{
name|lockMgr
operator|.
name|clearLocalLockRecords
argument_list|()
expr_stmt|;
name|stopHeartbeat
argument_list|()
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Rolling back "
operator|+
name|JavaUtils
operator|.
name|txnIdToString
argument_list|(
name|txnId
argument_list|)
argument_list|)
expr_stmt|;
name|getMS
argument_list|()
operator|.
name|rollbackTxn
argument_list|(
name|txnId
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|NoSuchTxnException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Metastore could not find "
operator|+
name|JavaUtils
operator|.
name|txnIdToString
argument_list|(
name|txnId
argument_list|)
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|LockException
argument_list|(
name|e
argument_list|,
name|ErrorMsg
operator|.
name|TXN_NO_SUCH_TRANSACTION
argument_list|,
name|JavaUtils
operator|.
name|txnIdToString
argument_list|(
name|txnId
argument_list|)
argument_list|)
throw|;
block|}
catch|catch
parameter_list|(
name|TxnAbortedException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|LockException
argument_list|(
name|e
argument_list|,
name|ErrorMsg
operator|.
name|TXN_ABORTED
argument_list|,
name|JavaUtils
operator|.
name|txnIdToString
argument_list|(
name|txnId
argument_list|)
argument_list|)
throw|;
block|}
catch|catch
parameter_list|(
name|TException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|LockException
argument_list|(
name|ErrorMsg
operator|.
name|METASTORE_COMMUNICATION_FAILED
operator|.
name|getMsg
argument_list|()
argument_list|,
name|e
argument_list|)
throw|;
block|}
finally|finally
block|{
name|txnId
operator|=
literal|0
expr_stmt|;
name|stmtId
operator|=
operator|-
literal|1
expr_stmt|;
name|numStatements
operator|=
literal|0
expr_stmt|;
name|tableWriteIds
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|void
name|replTableWriteIdState
parameter_list|(
name|String
name|validWriteIdList
parameter_list|,
name|String
name|dbName
parameter_list|,
name|String
name|tableName
parameter_list|,
name|List
argument_list|<
name|String
argument_list|>
name|partNames
parameter_list|)
throws|throws
name|LockException
block|{
try|try
block|{
name|getMS
argument_list|()
operator|.
name|replTableWriteIdState
argument_list|(
name|validWriteIdList
argument_list|,
name|dbName
argument_list|,
name|tableName
argument_list|,
name|partNames
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|TException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|LockException
argument_list|(
name|ErrorMsg
operator|.
name|METASTORE_COMMUNICATION_FAILED
operator|.
name|getMsg
argument_list|()
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|void
name|heartbeat
parameter_list|()
throws|throws
name|LockException
block|{
name|List
argument_list|<
name|HiveLock
argument_list|>
name|locks
decl_stmt|;
if|if
condition|(
name|isTxnOpen
argument_list|()
condition|)
block|{
comment|// Create one dummy lock so we can go through the loop below, though we only
comment|//really need txnId
name|DbLockManager
operator|.
name|DbHiveLock
name|dummyLock
init|=
operator|new
name|DbLockManager
operator|.
name|DbHiveLock
argument_list|(
literal|0L
argument_list|)
decl_stmt|;
name|locks
operator|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|locks
operator|.
name|add
argument_list|(
name|dummyLock
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|locks
operator|=
name|lockMgr
operator|.
name|getLocks
argument_list|(
literal|false
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|LOG
operator|.
name|isInfoEnabled
argument_list|()
condition|)
block|{
name|StringBuilder
name|sb
init|=
operator|new
name|StringBuilder
argument_list|(
literal|"Sending heartbeat for "
argument_list|)
operator|.
name|append
argument_list|(
name|JavaUtils
operator|.
name|txnIdToString
argument_list|(
name|txnId
argument_list|)
argument_list|)
operator|.
name|append
argument_list|(
literal|" and"
argument_list|)
decl_stmt|;
for|for
control|(
name|HiveLock
name|lock
range|:
name|locks
control|)
block|{
name|sb
operator|.
name|append
argument_list|(
literal|" "
argument_list|)
operator|.
name|append
argument_list|(
name|lock
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|LOG
operator|.
name|info
argument_list|(
name|sb
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|isTxnOpen
argument_list|()
operator|&&
name|locks
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
comment|// No locks, no txn, we outta here.
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"No need to send heartbeat as there is no transaction and no locks."
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
for|for
control|(
name|HiveLock
name|lock
range|:
name|locks
control|)
block|{
name|long
name|lockId
init|=
operator|(
operator|(
name|DbLockManager
operator|.
name|DbHiveLock
operator|)
name|lock
operator|)
operator|.
name|lockId
decl_stmt|;
try|try
block|{
comment|/**          * This relies on the ThreadLocal caching, which implies that the same {@link IMetaStoreClient},          * in particular the Thrift connection it uses is never shared between threads          */
name|getMS
argument_list|()
operator|.
name|heartbeat
argument_list|(
name|txnId
argument_list|,
name|lockId
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|NoSuchLockException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Unable to find lock "
operator|+
name|JavaUtils
operator|.
name|lockIdToString
argument_list|(
name|lockId
argument_list|)
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|LockException
argument_list|(
name|e
argument_list|,
name|ErrorMsg
operator|.
name|LOCK_NO_SUCH_LOCK
argument_list|,
name|JavaUtils
operator|.
name|lockIdToString
argument_list|(
name|lockId
argument_list|)
argument_list|)
throw|;
block|}
catch|catch
parameter_list|(
name|NoSuchTxnException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Unable to find transaction "
operator|+
name|JavaUtils
operator|.
name|txnIdToString
argument_list|(
name|txnId
argument_list|)
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|LockException
argument_list|(
name|e
argument_list|,
name|ErrorMsg
operator|.
name|TXN_NO_SUCH_TRANSACTION
argument_list|,
name|JavaUtils
operator|.
name|txnIdToString
argument_list|(
name|txnId
argument_list|)
argument_list|)
throw|;
block|}
catch|catch
parameter_list|(
name|TxnAbortedException
name|e
parameter_list|)
block|{
name|LockException
name|le
init|=
operator|new
name|LockException
argument_list|(
name|e
argument_list|,
name|ErrorMsg
operator|.
name|TXN_ABORTED
argument_list|,
name|JavaUtils
operator|.
name|txnIdToString
argument_list|(
name|txnId
argument_list|)
argument_list|,
name|e
operator|.
name|getMessage
argument_list|()
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|error
argument_list|(
name|le
operator|.
name|getMessage
argument_list|()
argument_list|)
expr_stmt|;
throw|throw
name|le
throw|;
block|}
catch|catch
parameter_list|(
name|TException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|LockException
argument_list|(
name|ErrorMsg
operator|.
name|METASTORE_COMMUNICATION_FAILED
operator|.
name|getMsg
argument_list|()
operator|+
literal|"("
operator|+
name|JavaUtils
operator|.
name|txnIdToString
argument_list|(
name|txnId
argument_list|)
operator|+
literal|","
operator|+
name|lock
operator|.
name|toString
argument_list|()
operator|+
literal|")"
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
block|}
comment|/**    * Start the heartbeater threadpool and return the task.    * @param initialDelay time to delay before first execution, in milliseconds    * @return heartbeater    */
specifier|private
name|Heartbeater
name|startHeartbeat
parameter_list|(
name|long
name|initialDelay
parameter_list|)
throws|throws
name|LockException
block|{
name|long
name|heartbeatInterval
init|=
name|getHeartbeatInterval
argument_list|(
name|conf
argument_list|)
decl_stmt|;
assert|assert
name|heartbeatInterval
operator|>
literal|0
assert|;
name|UserGroupInformation
name|currentUser
decl_stmt|;
try|try
block|{
name|currentUser
operator|=
name|UserGroupInformation
operator|.
name|getCurrentUser
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|LockException
argument_list|(
literal|"error while getting current user,"
argument_list|,
name|e
argument_list|)
throw|;
block|}
name|Heartbeater
name|heartbeater
init|=
operator|new
name|Heartbeater
argument_list|(
name|this
argument_list|,
name|conf
argument_list|,
name|queryId
argument_list|,
name|currentUser
argument_list|)
decl_stmt|;
name|heartbeatTask
operator|=
name|startHeartbeat
argument_list|(
name|initialDelay
argument_list|,
name|heartbeatInterval
argument_list|,
name|heartbeater
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Started heartbeat with delay/interval = "
operator|+
name|initialDelay
operator|+
literal|"/"
operator|+
name|heartbeatInterval
operator|+
literal|" "
operator|+
name|TimeUnit
operator|.
name|MILLISECONDS
operator|+
literal|" for query: "
operator|+
name|queryId
argument_list|)
expr_stmt|;
return|return
name|heartbeater
return|;
block|}
specifier|private
name|ScheduledFuture
argument_list|<
name|?
argument_list|>
name|startHeartbeat
parameter_list|(
name|long
name|initialDelay
parameter_list|,
name|long
name|heartbeatInterval
parameter_list|,
name|Runnable
name|heartbeater
parameter_list|)
block|{
comment|// For negative testing purpose..
if|if
condition|(
name|conf
operator|.
name|getBoolVar
argument_list|(
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVE_IN_TEST
argument_list|)
operator|&&
name|conf
operator|.
name|getBoolVar
argument_list|(
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVETESTMODEFAILHEARTBEATER
argument_list|)
condition|)
block|{
name|initialDelay
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|initialDelay
operator|==
literal|0
condition|)
block|{
comment|/*make initialDelay a random number in [0, 0.75*heartbeatInterval] so that if a lot       of queries land on the server at the same time and all get blocked on lack of       resources, that they all don't start heartbeating at the same time*/
name|initialDelay
operator|=
operator|(
name|long
operator|)
name|Math
operator|.
name|floor
argument_list|(
name|heartbeatInterval
operator|*
literal|0.75
operator|*
name|Math
operator|.
name|random
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|ScheduledFuture
argument_list|<
name|?
argument_list|>
name|task
init|=
name|heartbeatExecutorService
operator|.
name|scheduleAtFixedRate
argument_list|(
name|heartbeater
argument_list|,
name|initialDelay
argument_list|,
name|heartbeatInterval
argument_list|,
name|TimeUnit
operator|.
name|MILLISECONDS
argument_list|)
decl_stmt|;
return|return
name|task
return|;
block|}
specifier|private
name|void
name|stopHeartbeat
parameter_list|()
throws|throws
name|LockException
block|{
if|if
condition|(
name|heartbeatTask
operator|!=
literal|null
condition|)
block|{
name|heartbeatTask
operator|.
name|cancel
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|long
name|startTime
init|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
decl_stmt|;
name|long
name|sleepInterval
init|=
literal|100
decl_stmt|;
while|while
condition|(
operator|!
name|heartbeatTask
operator|.
name|isCancelled
argument_list|()
operator|&&
operator|!
name|heartbeatTask
operator|.
name|isDone
argument_list|()
condition|)
block|{
comment|// We will wait for 30 seconds for the task to be cancelled.
comment|// If it's still not cancelled (unlikely), we will just move on.
name|long
name|now
init|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
decl_stmt|;
if|if
condition|(
name|now
operator|-
name|startTime
operator|>
literal|30000
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Heartbeat task cannot be cancelled for unknown reason. QueryId: "
operator|+
name|queryId
argument_list|)
expr_stmt|;
break|break;
block|}
try|try
block|{
name|Thread
operator|.
name|sleep
argument_list|(
name|sleepInterval
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{         }
name|sleepInterval
operator|*=
literal|2
expr_stmt|;
block|}
if|if
condition|(
name|heartbeatTask
operator|.
name|isCancelled
argument_list|()
operator|||
name|heartbeatTask
operator|.
name|isDone
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Stopped heartbeat for query: "
operator|+
name|queryId
argument_list|)
expr_stmt|;
block|}
name|heartbeatTask
operator|=
literal|null
expr_stmt|;
name|queryId
operator|=
literal|null
expr_stmt|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|ValidTxnList
name|getValidTxns
parameter_list|()
throws|throws
name|LockException
block|{
assert|assert
name|isTxnOpen
argument_list|()
assert|;
name|init
argument_list|()
expr_stmt|;
try|try
block|{
return|return
name|getMS
argument_list|()
operator|.
name|getValidTxns
argument_list|(
name|txnId
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|TException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|LockException
argument_list|(
name|ErrorMsg
operator|.
name|METASTORE_COMMUNICATION_FAILED
operator|.
name|getMsg
argument_list|()
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|ValidTxnWriteIdList
name|getValidWriteIds
parameter_list|(
name|List
argument_list|<
name|String
argument_list|>
name|tableList
parameter_list|,
name|String
name|validTxnList
parameter_list|)
throws|throws
name|LockException
block|{
assert|assert
name|isTxnOpen
argument_list|()
assert|;
assert|assert
name|validTxnList
operator|!=
literal|null
operator|&&
operator|!
name|validTxnList
operator|.
name|isEmpty
argument_list|()
assert|;
try|try
block|{
return|return
name|TxnCommonUtils
operator|.
name|createValidTxnWriteIdList
argument_list|(
name|txnId
argument_list|,
name|getMS
argument_list|()
operator|.
name|getValidWriteIds
argument_list|(
name|tableList
argument_list|,
name|validTxnList
argument_list|)
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|TException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|LockException
argument_list|(
name|ErrorMsg
operator|.
name|METASTORE_COMMUNICATION_FAILED
operator|.
name|getMsg
argument_list|()
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|String
name|getTxnManagerName
parameter_list|()
block|{
return|return
name|CLASS_NAME
return|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|supportsExplicitLock
parameter_list|()
block|{
return|return
literal|false
return|;
block|}
annotation|@
name|Override
specifier|public
name|int
name|lockTable
parameter_list|(
name|Hive
name|db
parameter_list|,
name|LockTableDesc
name|lockTbl
parameter_list|)
throws|throws
name|HiveException
block|{
name|super
operator|.
name|lockTable
argument_list|(
name|db
argument_list|,
name|lockTbl
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
annotation|@
name|Override
specifier|public
name|int
name|unlockTable
parameter_list|(
name|Hive
name|hiveDB
parameter_list|,
name|UnlockTableDesc
name|unlockTbl
parameter_list|)
throws|throws
name|HiveException
block|{
name|super
operator|.
name|unlockTable
argument_list|(
name|hiveDB
argument_list|,
name|unlockTbl
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
annotation|@
name|Override
specifier|public
name|int
name|lockDatabase
parameter_list|(
name|Hive
name|hiveDB
parameter_list|,
name|LockDatabaseDesc
name|lockDb
parameter_list|)
throws|throws
name|HiveException
block|{
name|super
operator|.
name|lockDatabase
argument_list|(
name|hiveDB
argument_list|,
name|lockDb
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
annotation|@
name|Override
specifier|public
name|int
name|unlockDatabase
parameter_list|(
name|Hive
name|hiveDB
parameter_list|,
name|UnlockDatabaseDesc
name|unlockDb
parameter_list|)
throws|throws
name|HiveException
block|{
name|super
operator|.
name|unlockDatabase
argument_list|(
name|hiveDB
argument_list|,
name|unlockDb
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|useNewShowLocksFormat
parameter_list|()
block|{
return|return
literal|true
return|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|supportsAcid
parameter_list|()
block|{
return|return
literal|true
return|;
block|}
comment|/**    * In an explicit txn start_transaction is the 1st statement and we record the snapshot at the    * start of the txn for Snapshot Isolation.  For Read Committed (not supported yet) we'd record    * it before executing each statement (but after lock acquisition if using lock based concurrency    * control).    * For implicit txn, the stmt that triggered/started the txn is the first statement    */
annotation|@
name|Override
specifier|public
name|boolean
name|recordSnapshot
parameter_list|(
name|QueryPlan
name|queryPlan
parameter_list|)
block|{
assert|assert
name|isTxnOpen
argument_list|()
assert|;
assert|assert
name|numStatements
operator|>
literal|0
operator|:
literal|"was acquireLocks() called already?"
assert|;
if|if
condition|(
name|queryPlan
operator|.
name|getOperation
argument_list|()
operator|==
name|HiveOperation
operator|.
name|START_TRANSACTION
condition|)
block|{
comment|//here if start of explicit txn
assert|assert
name|isExplicitTransaction
assert|;
assert|assert
name|numStatements
operator|==
literal|1
assert|;
return|return
literal|true
return|;
block|}
elseif|else
if|if
condition|(
operator|!
name|isExplicitTransaction
condition|)
block|{
assert|assert
name|numStatements
operator|==
literal|1
operator|:
literal|"numStatements="
operator|+
name|numStatements
operator|+
literal|" in implicit txn"
assert|;
if|if
condition|(
name|queryPlan
operator|.
name|hasAcidResourcesInQuery
argument_list|()
condition|)
block|{
comment|//1st and only stmt in implicit txn and uses acid resource
return|return
literal|true
return|;
block|}
block|}
return|return
literal|false
return|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|isImplicitTransactionOpen
parameter_list|()
block|{
if|if
condition|(
operator|!
name|isTxnOpen
argument_list|()
condition|)
block|{
comment|//some commands like "show databases" don't start implicit transactions
return|return
literal|false
return|;
block|}
if|if
condition|(
operator|!
name|isExplicitTransaction
condition|)
block|{
assert|assert
name|numStatements
operator|==
literal|1
operator|:
literal|"numStatements="
operator|+
name|numStatements
assert|;
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
annotation|@
name|Override
specifier|protected
name|void
name|destruct
parameter_list|()
block|{
try|try
block|{
name|stopHeartbeat
argument_list|()
expr_stmt|;
if|if
condition|(
name|shutdownRunner
operator|!=
literal|null
condition|)
block|{
name|ShutdownHookManager
operator|.
name|removeShutdownHook
argument_list|(
name|shutdownRunner
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|isTxnOpen
argument_list|()
condition|)
name|rollbackTxn
argument_list|()
expr_stmt|;
if|if
condition|(
name|lockMgr
operator|!=
literal|null
condition|)
name|lockMgr
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Caught exception "
operator|+
name|e
operator|.
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
operator|+
literal|" with message<"
operator|+
name|e
operator|.
name|getMessage
argument_list|()
operator|+
literal|">, swallowing as there is nothing we can do with it."
argument_list|)
expr_stmt|;
comment|// Not much we can do about it here.
block|}
block|}
specifier|private
name|void
name|init
parameter_list|()
throws|throws
name|LockException
block|{
if|if
condition|(
name|conf
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Must call setHiveConf before any other methods."
argument_list|)
throw|;
block|}
name|initHeartbeatExecutorService
argument_list|()
expr_stmt|;
block|}
specifier|private
specifier|synchronized
name|void
name|initHeartbeatExecutorService
parameter_list|()
block|{
synchronized|synchronized
init|(
name|DbTxnManager
operator|.
name|class
init|)
block|{
if|if
condition|(
name|heartbeatExecutorService
operator|!=
literal|null
operator|&&
operator|!
name|heartbeatExecutorService
operator|.
name|isShutdown
argument_list|()
operator|&&
operator|!
name|heartbeatExecutorService
operator|.
name|isTerminated
argument_list|()
condition|)
block|{
return|return;
block|}
name|heartbeatExecutorService
operator|=
name|Executors
operator|.
name|newScheduledThreadPool
argument_list|(
name|conf
operator|.
name|getIntVar
argument_list|(
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVE_TXN_HEARTBEAT_THREADPOOL_SIZE
argument_list|)
argument_list|,
operator|new
name|ThreadFactory
argument_list|()
block|{
specifier|private
specifier|final
name|AtomicInteger
name|threadCounter
init|=
operator|new
name|AtomicInteger
argument_list|()
decl_stmt|;
annotation|@
name|Override
specifier|public
name|Thread
name|newThread
parameter_list|(
name|Runnable
name|r
parameter_list|)
block|{
return|return
operator|new
name|HeartbeaterThread
argument_list|(
name|r
argument_list|,
literal|"Heartbeater-"
operator|+
name|threadCounter
operator|.
name|getAndIncrement
argument_list|()
argument_list|)
return|;
block|}
block|}
argument_list|)
expr_stmt|;
operator|(
operator|(
name|ScheduledThreadPoolExecutor
operator|)
name|heartbeatExecutorService
operator|)
operator|.
name|setRemoveOnCancelPolicy
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
block|}
specifier|public
specifier|static
class|class
name|HeartbeaterThread
extends|extends
name|Thread
block|{
name|HeartbeaterThread
parameter_list|(
name|Runnable
name|target
parameter_list|,
name|String
name|name
parameter_list|)
block|{
name|super
argument_list|(
name|target
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|setDaemon
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|isTxnOpen
parameter_list|()
block|{
return|return
name|txnId
operator|>
literal|0
return|;
block|}
annotation|@
name|Override
specifier|public
name|long
name|getCurrentTxnId
parameter_list|()
block|{
return|return
name|txnId
return|;
block|}
annotation|@
name|Override
specifier|public
name|int
name|getStmtIdAndIncrement
parameter_list|()
block|{
assert|assert
name|isTxnOpen
argument_list|()
assert|;
return|return
name|stmtId
operator|++
return|;
block|}
annotation|@
name|Override
specifier|public
name|int
name|getCurrentStmtId
parameter_list|()
block|{
assert|assert
name|isTxnOpen
argument_list|()
assert|;
return|return
name|stmtId
return|;
block|}
annotation|@
name|Override
specifier|public
name|long
name|getTableWriteId
parameter_list|(
name|String
name|dbName
parameter_list|,
name|String
name|tableName
parameter_list|)
throws|throws
name|LockException
block|{
assert|assert
name|isTxnOpen
argument_list|()
assert|;
return|return
name|getTableWriteId
argument_list|(
name|dbName
argument_list|,
name|tableName
argument_list|,
literal|true
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|long
name|getAllocatedTableWriteId
parameter_list|(
name|String
name|dbName
parameter_list|,
name|String
name|tableName
parameter_list|)
throws|throws
name|LockException
block|{
assert|assert
name|isTxnOpen
argument_list|()
assert|;
comment|// Calls getTableWriteId() with allocateIfNotYet being false
comment|// to return 0 if the dbName:tableName's writeId is yet allocated.
comment|// This happens when the current context is before
comment|// Driver.acquireLocks() is called.
return|return
name|getTableWriteId
argument_list|(
name|dbName
argument_list|,
name|tableName
argument_list|,
literal|false
argument_list|)
return|;
block|}
specifier|private
name|long
name|getTableWriteId
parameter_list|(
name|String
name|dbName
parameter_list|,
name|String
name|tableName
parameter_list|,
name|boolean
name|allocateIfNotYet
parameter_list|)
throws|throws
name|LockException
block|{
name|String
name|fullTableName
init|=
name|AcidUtils
operator|.
name|getFullTableName
argument_list|(
name|dbName
argument_list|,
name|tableName
argument_list|)
decl_stmt|;
if|if
condition|(
name|tableWriteIds
operator|.
name|containsKey
argument_list|(
name|fullTableName
argument_list|)
condition|)
block|{
return|return
name|tableWriteIds
operator|.
name|get
argument_list|(
name|fullTableName
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
operator|!
name|allocateIfNotYet
condition|)
block|{
return|return
literal|0
return|;
block|}
try|try
block|{
name|long
name|writeId
init|=
name|getMS
argument_list|()
operator|.
name|allocateTableWriteId
argument_list|(
name|txnId
argument_list|,
name|dbName
argument_list|,
name|tableName
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Allocated write ID {} for {}.{}"
argument_list|,
name|writeId
argument_list|,
name|dbName
argument_list|,
name|tableName
argument_list|)
expr_stmt|;
name|tableWriteIds
operator|.
name|put
argument_list|(
name|fullTableName
argument_list|,
name|writeId
argument_list|)
expr_stmt|;
return|return
name|writeId
return|;
block|}
catch|catch
parameter_list|(
name|TException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|LockException
argument_list|(
name|ErrorMsg
operator|.
name|METASTORE_COMMUNICATION_FAILED
operator|.
name|getMsg
argument_list|()
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|LockResponse
name|acquireMaterializationRebuildLock
parameter_list|(
name|String
name|dbName
parameter_list|,
name|String
name|tableName
parameter_list|,
name|long
name|txnId
parameter_list|)
throws|throws
name|LockException
block|{
comment|// Acquire lock
name|LockResponse
name|lockResponse
decl_stmt|;
try|try
block|{
name|lockResponse
operator|=
name|getMS
argument_list|()
operator|.
name|lockMaterializationRebuild
argument_list|(
name|dbName
argument_list|,
name|tableName
argument_list|,
name|txnId
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|TException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|LockException
argument_list|(
name|ErrorMsg
operator|.
name|METASTORE_COMMUNICATION_FAILED
operator|.
name|getMsg
argument_list|()
argument_list|,
name|e
argument_list|)
throw|;
block|}
if|if
condition|(
name|lockResponse
operator|.
name|getState
argument_list|()
operator|==
name|LockState
operator|.
name|ACQUIRED
condition|)
block|{
comment|// If lock response is ACQUIRED, we can create the heartbeater
name|long
name|initialDelay
init|=
literal|0L
decl_stmt|;
name|long
name|heartbeatInterval
init|=
name|getHeartbeatInterval
argument_list|(
name|conf
argument_list|)
decl_stmt|;
assert|assert
name|heartbeatInterval
operator|>
literal|0
assert|;
name|MaterializationRebuildLockHeartbeater
name|heartbeater
init|=
operator|new
name|MaterializationRebuildLockHeartbeater
argument_list|(
name|this
argument_list|,
name|dbName
argument_list|,
name|tableName
argument_list|,
name|queryId
argument_list|,
name|txnId
argument_list|)
decl_stmt|;
name|ScheduledFuture
argument_list|<
name|?
argument_list|>
name|task
init|=
name|startHeartbeat
argument_list|(
name|initialDelay
argument_list|,
name|heartbeatInterval
argument_list|,
name|heartbeater
argument_list|)
decl_stmt|;
name|heartbeater
operator|.
name|task
operator|.
name|set
argument_list|(
name|task
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Started heartbeat for materialization rebuild lock for {} with delay/interval = {}/{} {} for query: {}"
argument_list|,
name|AcidUtils
operator|.
name|getFullTableName
argument_list|(
name|dbName
argument_list|,
name|tableName
argument_list|)
argument_list|,
name|initialDelay
argument_list|,
name|heartbeatInterval
argument_list|,
name|TimeUnit
operator|.
name|MILLISECONDS
argument_list|,
name|queryId
argument_list|)
expr_stmt|;
block|}
return|return
name|lockResponse
return|;
block|}
specifier|private
name|boolean
name|heartbeatMaterializationRebuildLock
parameter_list|(
name|String
name|dbName
parameter_list|,
name|String
name|tableName
parameter_list|,
name|long
name|txnId
parameter_list|)
throws|throws
name|LockException
block|{
try|try
block|{
return|return
name|getMS
argument_list|()
operator|.
name|heartbeatLockMaterializationRebuild
argument_list|(
name|dbName
argument_list|,
name|tableName
argument_list|,
name|txnId
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|TException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|LockException
argument_list|(
name|ErrorMsg
operator|.
name|METASTORE_COMMUNICATION_FAILED
operator|.
name|getMsg
argument_list|()
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
specifier|public
name|void
name|replAllocateTableWriteIdsBatch
parameter_list|(
name|String
name|dbName
parameter_list|,
name|String
name|tableName
parameter_list|,
name|String
name|replPolicy
parameter_list|,
name|List
argument_list|<
name|TxnToWriteId
argument_list|>
name|srcTxnToWriteIdList
parameter_list|)
throws|throws
name|LockException
block|{
try|try
block|{
name|getMS
argument_list|()
operator|.
name|replAllocateTableWriteIdsBatch
argument_list|(
name|dbName
argument_list|,
name|tableName
argument_list|,
name|replPolicy
argument_list|,
name|srcTxnToWriteIdList
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|TException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|LockException
argument_list|(
name|ErrorMsg
operator|.
name|METASTORE_COMMUNICATION_FAILED
operator|.
name|getMsg
argument_list|()
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
specifier|public
specifier|static
name|long
name|getHeartbeatInterval
parameter_list|(
name|Configuration
name|conf
parameter_list|)
throws|throws
name|LockException
block|{
comment|// Retrieve HIVE_TXN_TIMEOUT in MILLISECONDS (it's defined as SECONDS),
comment|// then divide it by 2 to give us a safety factor.
name|long
name|interval
init|=
name|HiveConf
operator|.
name|getTimeVar
argument_list|(
name|conf
argument_list|,
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVE_TXN_TIMEOUT
argument_list|,
name|TimeUnit
operator|.
name|MILLISECONDS
argument_list|)
operator|/
literal|2
decl_stmt|;
if|if
condition|(
name|interval
operator|==
literal|0
condition|)
block|{
throw|throw
operator|new
name|LockException
argument_list|(
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVE_TXN_TIMEOUT
operator|.
name|toString
argument_list|()
operator|+
literal|" not set,"
operator|+
literal|" heartbeats won't be sent"
argument_list|)
throw|;
block|}
return|return
name|interval
return|;
block|}
comment|/**    * Heartbeater thread    */
specifier|public
specifier|static
class|class
name|Heartbeater
implements|implements
name|Runnable
block|{
specifier|private
name|HiveTxnManager
name|txnMgr
decl_stmt|;
specifier|private
name|HiveConf
name|conf
decl_stmt|;
specifier|private
name|UserGroupInformation
name|currentUser
decl_stmt|;
name|LockException
name|lockException
decl_stmt|;
specifier|private
specifier|final
name|String
name|queryId
decl_stmt|;
specifier|public
name|LockException
name|getLockException
parameter_list|()
block|{
return|return
name|lockException
return|;
block|}
comment|/**      *      * @param txnMgr transaction manager for this operation      * @param currentUser      */
name|Heartbeater
parameter_list|(
name|HiveTxnManager
name|txnMgr
parameter_list|,
name|HiveConf
name|conf
parameter_list|,
name|String
name|queryId
parameter_list|,
name|UserGroupInformation
name|currentUser
parameter_list|)
block|{
name|this
operator|.
name|txnMgr
operator|=
name|txnMgr
expr_stmt|;
name|this
operator|.
name|conf
operator|=
name|conf
expr_stmt|;
name|this
operator|.
name|currentUser
operator|=
name|currentUser
expr_stmt|;
name|lockException
operator|=
literal|null
expr_stmt|;
name|this
operator|.
name|queryId
operator|=
name|queryId
expr_stmt|;
block|}
comment|/**      * Send a heartbeat to the metastore for locks and transactions.      */
annotation|@
name|Override
specifier|public
name|void
name|run
parameter_list|()
block|{
try|try
block|{
comment|// For negative testing purpose..
if|if
condition|(
name|conf
operator|.
name|getBoolVar
argument_list|(
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVE_IN_TEST
argument_list|)
operator|&&
name|conf
operator|.
name|getBoolVar
argument_list|(
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVETESTMODEFAILHEARTBEATER
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|LockException
argument_list|(
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVETESTMODEFAILHEARTBEATER
operator|.
name|name
argument_list|()
operator|+
literal|"=true"
argument_list|)
throw|;
block|}
name|LOG
operator|.
name|debug
argument_list|(
literal|"Heartbeating...for currentUser: "
operator|+
name|currentUser
argument_list|)
expr_stmt|;
name|currentUser
operator|.
name|doAs
argument_list|(
call|(
name|PrivilegedExceptionAction
argument_list|<
name|Object
argument_list|>
call|)
argument_list|()
operator|->
block|{
name|txnMgr
operator|.
name|heartbeat
argument_list|()
block|;
return|return
literal|null
return|;
block|}
block|)
empty_stmt|;
block|}
catch|catch
parameter_list|(
name|LockException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Failed trying to heartbeat queryId="
operator|+
name|queryId
operator|+
literal|", currentUser: "
operator|+
name|currentUser
operator|+
literal|": "
operator|+
name|e
operator|.
name|getMessage
argument_list|()
argument_list|)
expr_stmt|;
name|lockException
operator|=
name|e
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{
name|String
name|errorMsg
init|=
literal|"Failed trying to heartbeat queryId="
operator|+
name|queryId
operator|+
literal|", currentUser: "
operator|+
name|currentUser
operator|+
literal|": "
operator|+
name|t
operator|.
name|getMessage
argument_list|()
decl_stmt|;
name|LOG
operator|.
name|error
argument_list|(
name|errorMsg
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|lockException
operator|=
operator|new
name|LockException
argument_list|(
name|errorMsg
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_class

begin_comment
comment|/**    * MaterializationRebuildLockHeartbeater is a runnable that will be run in a    * ScheduledExecutorService in given intervals. Once the heartbeat cannot    * refresh the lock anymore, it will interrupt itself.    */
end_comment

begin_class
specifier|private
specifier|static
class|class
name|MaterializationRebuildLockHeartbeater
implements|implements
name|Runnable
block|{
specifier|private
specifier|final
name|DbTxnManager
name|txnMgr
decl_stmt|;
specifier|private
specifier|final
name|String
name|dbName
decl_stmt|;
specifier|private
specifier|final
name|String
name|tableName
decl_stmt|;
specifier|private
specifier|final
name|String
name|queryId
decl_stmt|;
specifier|private
specifier|final
name|long
name|txnId
decl_stmt|;
specifier|private
specifier|final
name|AtomicReference
argument_list|<
name|ScheduledFuture
argument_list|<
name|?
argument_list|>
argument_list|>
name|task
decl_stmt|;
name|MaterializationRebuildLockHeartbeater
parameter_list|(
name|DbTxnManager
name|txnMgr
parameter_list|,
name|String
name|dbName
parameter_list|,
name|String
name|tableName
parameter_list|,
name|String
name|queryId
parameter_list|,
name|long
name|txnId
parameter_list|)
block|{
name|this
operator|.
name|txnMgr
operator|=
name|txnMgr
expr_stmt|;
name|this
operator|.
name|queryId
operator|=
name|queryId
expr_stmt|;
name|this
operator|.
name|dbName
operator|=
name|dbName
expr_stmt|;
name|this
operator|.
name|tableName
operator|=
name|tableName
expr_stmt|;
name|this
operator|.
name|txnId
operator|=
name|txnId
expr_stmt|;
name|this
operator|.
name|task
operator|=
operator|new
name|AtomicReference
argument_list|<>
argument_list|()
expr_stmt|;
block|}
comment|/**      * Send a heartbeat to the metastore for locks and transactions.      */
annotation|@
name|Override
specifier|public
name|void
name|run
parameter_list|()
block|{
name|LOG
operator|.
name|trace
argument_list|(
literal|"Heartbeating materialization rebuild lock for {} for query: {}"
argument_list|,
name|AcidUtils
operator|.
name|getFullTableName
argument_list|(
name|dbName
argument_list|,
name|tableName
argument_list|)
argument_list|,
name|queryId
argument_list|)
expr_stmt|;
name|boolean
name|refreshed
decl_stmt|;
try|try
block|{
name|refreshed
operator|=
name|txnMgr
operator|.
name|heartbeatMaterializationRebuildLock
argument_list|(
name|dbName
argument_list|,
name|tableName
argument_list|,
name|txnId
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|LockException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Failed trying to acquire lock"
argument_list|,
name|e
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|RuntimeException
argument_list|(
name|e
argument_list|)
throw|;
block|}
if|if
condition|(
operator|!
name|refreshed
condition|)
block|{
comment|// We could not heartbeat the lock, i.e., the operation has finished,
comment|// hence we interrupt this work
name|ScheduledFuture
argument_list|<
name|?
argument_list|>
name|t
init|=
name|task
operator|.
name|get
argument_list|()
decl_stmt|;
if|if
condition|(
name|t
operator|!=
literal|null
condition|)
block|{
name|t
operator|.
name|cancel
argument_list|(
literal|false
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Stopped heartbeat for materialization rebuild lock for {} for query: {}"
argument_list|,
name|AcidUtils
operator|.
name|getFullTableName
argument_list|(
name|dbName
argument_list|,
name|tableName
argument_list|)
argument_list|,
name|queryId
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_class

unit|}
end_unit

