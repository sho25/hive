begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|log
operator|.
name|syslog
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|sql
operator|.
name|Timestamp
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Calendar
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|GregorianCalendar
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Locale
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|TimeZone
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|TimeUnit
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FileStatus
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|Path
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|conf
operator|.
name|HiveConf
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|SerializationUtilities
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|io
operator|.
name|parquet
operator|.
name|ProjectionPusher
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|io
operator|.
name|sarg
operator|.
name|ConvertAstToSearchArg
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|io
operator|.
name|sarg
operator|.
name|PredicateLeaf
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|io
operator|.
name|sarg
operator|.
name|SearchArgument
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|ExprNodeGenericFuncDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|TableScanDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|LongWritable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|Text
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapred
operator|.
name|FileSplit
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapred
operator|.
name|InputSplit
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapred
operator|.
name|JobConf
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapred
operator|.
name|RecordReader
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapred
operator|.
name|Reporter
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapred
operator|.
name|TextInputFormat
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|VisibleForTesting
import|;
end_import

begin_comment
comment|/**  * Syslog input format handles files written to sys.logs hive table. This input format can prune files based on  * predicates in ts (timestamp) column. Following are the assumptions/supported options for the file pruning to work.  * When configuring log shippers (like fluentd), the following directory layout has to be followed  *  * WAREHOUSE_DIR/sys.db/logs/dt=DATE/ns=NAMESPACE/app=APPLICATION/YYYY-mm-DD-HH-MM_i[.log][.gz]  * WAREHOUSE_DIR - is hive warehouse location for external tables  * DATE - date of the log files  * NAMESPACE - namespace for the applications  * APPLICATION - name of the application (hiveserver2, metastore etc.)  * YYYY - year  * mm - month  * DD - day of the month  * HH - hour of the day (24 hr format)  * MM - minute  * i - index (log rotation)  * [.log] - optional log extension  * [.gz] - optional gz compression extension  *  * When executing queries like  * select count(*) from sys.logs where ts between current_timestamp() - INTERVAL '1' DAY and current_timestamp()  *  * syslog input format can prunes the file listing based on the query filter condition.  * File Pruning Assumptions/Support:  * - All timestamps are in UTC (timestamp in file name, log lines and in query predicates all assume UTC)  * - File names are in YYYY-mm-DD-HH-MM_i[.log][.gz] format.  * - Seconds and millis in predicates gets rounded off to nearest minute (essentially ignoring them).  * - Time slice used by log aggregation library should match with hive.syslog.input.format.file.time.slice config.  *   If a filename is 2019-04-02-21-00_0.log.gz and timeslice is 300s then the file 2019-04-02-21-00_0.log.gz is  *   expected to have log lines from timestamp 2019:04:02 21:00:00 to 2019:04:02 21:05:00 timestamp.  * - Logs table should have 'ts' as timestamp column.  * - Only simple BETWEEN filter predicate is supported for 'ts' column. There cannot be>1 predicates on 'ts' column.  */
end_comment

begin_class
specifier|public
class|class
name|SyslogInputFormat
extends|extends
name|TextInputFormat
block|{
specifier|private
specifier|static
specifier|final
name|Logger
name|LOG
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|SyslogInputFormat
operator|.
name|class
argument_list|)
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|long
name|MILLISECONDS_PER_MINUTE
init|=
literal|60
operator|*
literal|1000L
decl_stmt|;
specifier|private
name|SearchArgument
name|sarg
decl_stmt|;
specifier|private
name|JobConf
name|jobConf
decl_stmt|;
specifier|private
name|ProjectionPusher
name|projectionPusher
init|=
operator|new
name|ProjectionPusher
argument_list|()
decl_stmt|;
enum|enum
name|Location
block|{
name|BEFORE
block|,
name|MIN
block|,
name|MIDDLE
block|,
name|MAX
block|,
name|AFTER
block|}
annotation|@
name|Override
specifier|protected
name|FileStatus
index|[]
name|listStatus
parameter_list|(
specifier|final
name|JobConf
name|job
parameter_list|)
throws|throws
name|IOException
block|{
name|FileStatus
index|[]
name|fileStatuses
init|=
name|super
operator|.
name|listStatus
argument_list|(
name|job
argument_list|)
decl_stmt|;
name|String
name|filterExprSerialized
init|=
name|job
operator|.
name|get
argument_list|(
name|TableScanDesc
operator|.
name|FILTER_EXPR_CONF_STR
argument_list|)
decl_stmt|;
specifier|final
name|boolean
name|filePruning
init|=
name|HiveConf
operator|.
name|getBoolVar
argument_list|(
name|job
argument_list|,
name|HiveConf
operator|.
name|ConfVars
operator|.
name|SYSLOG_INPUT_FORMAT_FILE_PRUNING
argument_list|)
decl_stmt|;
specifier|final
name|long
name|timeSliceSeconds
init|=
name|HiveConf
operator|.
name|getTimeVar
argument_list|(
name|job
argument_list|,
name|HiveConf
operator|.
name|ConfVars
operator|.
name|SYSLOG_INPUT_FORMAT_FILE_TIME_SLICE
argument_list|,
name|TimeUnit
operator|.
name|SECONDS
argument_list|)
decl_stmt|;
if|if
condition|(
name|filePruning
operator|&&
name|filterExprSerialized
operator|!=
literal|null
condition|)
block|{
name|ExprNodeGenericFuncDesc
name|filterExpr
init|=
name|SerializationUtilities
operator|.
name|deserializeExpression
argument_list|(
name|filterExprSerialized
argument_list|)
decl_stmt|;
comment|// we receive the expression filters from hive and convert it to sarg keeping only timestamp (ts) column from
comment|// sys.logs table. The SARG on ts column is evaluated against the files that are formatted in YYYY-mm-dd-MM_* format
name|this
operator|.
name|sarg
operator|=
name|ConvertAstToSearchArg
operator|.
name|create
argument_list|(
name|job
argument_list|,
name|filterExpr
argument_list|)
expr_stmt|;
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"Syslog configs - filePruning: {} SARG: {} timeSliceSeconds: {}"
argument_list|,
name|filePruning
argument_list|,
name|sarg
argument_list|,
name|timeSliceSeconds
argument_list|)
expr_stmt|;
if|if
condition|(
name|sarg
operator|!=
literal|null
condition|)
block|{
name|fileStatuses
operator|=
name|pruneFiles
argument_list|(
name|sarg
argument_list|,
name|timeSliceSeconds
argument_list|,
name|Arrays
operator|.
name|asList
argument_list|(
name|fileStatuses
argument_list|)
argument_list|)
operator|.
name|toArray
argument_list|(
operator|new
name|FileStatus
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
return|return
name|fileStatuses
return|;
block|}
annotation|@
name|VisibleForTesting
specifier|public
name|List
argument_list|<
name|FileStatus
argument_list|>
name|pruneFiles
parameter_list|(
specifier|final
name|SearchArgument
name|sarg
parameter_list|,
specifier|final
name|long
name|timeSliceSeconds
parameter_list|,
specifier|final
name|List
argument_list|<
name|FileStatus
argument_list|>
name|inputFiles
parameter_list|)
block|{
name|int
name|tsExpr
init|=
literal|0
decl_stmt|;
name|List
argument_list|<
name|PredicateLeaf
argument_list|>
name|predLeaves
init|=
name|sarg
operator|.
name|getLeaves
argument_list|()
decl_stmt|;
name|SearchArgument
operator|.
name|TruthValue
index|[]
name|truthValues
init|=
operator|new
name|SearchArgument
operator|.
name|TruthValue
index|[
name|predLeaves
operator|.
name|size
argument_list|()
index|]
decl_stmt|;
name|PredicateLeaf
name|tsPred
init|=
literal|null
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|truthValues
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|predLeaves
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|getColumnName
argument_list|()
operator|.
name|equalsIgnoreCase
argument_list|(
literal|"ts"
argument_list|)
condition|)
block|{
name|truthValues
index|[
name|i
index|]
operator|=
name|SearchArgument
operator|.
name|TruthValue
operator|.
name|YES_NO_NULL
expr_stmt|;
block|}
else|else
block|{
name|tsPred
operator|=
name|predLeaves
operator|.
name|get
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|tsExpr
operator|++
expr_stmt|;
block|}
block|}
comment|// multiple expressions on 'ts' columns are not supported
if|if
condition|(
name|tsExpr
operator|==
literal|0
operator|||
name|tsExpr
operator|>
literal|1
condition|)
block|{
comment|// no expressions on timestamp column or multi-expression
if|if
condition|(
name|tsExpr
operator|==
literal|0
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"No filter expression on 'ts' column. Skipping file pruning.."
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Multi-filter expression ({}) on 'ts' column is not supported. Skipping file pruning.."
argument_list|,
name|tsExpr
argument_list|)
expr_stmt|;
block|}
return|return
name|inputFiles
return|;
block|}
comment|// only BETWEEN filter is supported
if|if
condition|(
name|tsPred
operator|.
name|getOperator
argument_list|()
operator|==
name|PredicateLeaf
operator|.
name|Operator
operator|.
name|BETWEEN
condition|)
block|{
name|List
argument_list|<
name|FileStatus
argument_list|>
name|selectedFiles
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|Object
argument_list|>
name|objects
init|=
name|tsPred
operator|.
name|getLiteralList
argument_list|()
decl_stmt|;
name|Timestamp
name|left
init|=
operator|(
name|Timestamp
operator|)
name|objects
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|Timestamp
name|right
init|=
operator|(
name|Timestamp
operator|)
name|objects
operator|.
name|get
argument_list|(
literal|1
argument_list|)
decl_stmt|;
comment|// file pruning does not handle seconds and millis granularity.
comment|// so we round to nearest minute (left = floor) and (right = ceil).
name|Timestamp
name|predLowerBound
init|=
name|roundupToMinuteFloor
argument_list|(
name|left
argument_list|)
decl_stmt|;
name|Timestamp
name|predUpperBound
init|=
name|roundupToMinuteCeil
argument_list|(
name|right
argument_list|)
decl_stmt|;
comment|// we have left and right values from BETWEEN expression. For each file we have a start timestamp (from filename)
comment|// and end timestamp (start + timeslice). We compare the predicates with start and end timestamp of each file
comment|// and see if it falls within the range.
for|for
control|(
name|FileStatus
name|fileStatus
range|:
name|inputFiles
control|)
block|{
name|Timestamp
name|fileLowerBound
init|=
name|getTimeStampFromPath
argument_list|(
name|fileStatus
argument_list|)
decl_stmt|;
if|if
condition|(
name|fileLowerBound
operator|!=
literal|null
condition|)
block|{
name|Timestamp
name|fileUpperBound
init|=
name|Timestamp
operator|.
name|from
argument_list|(
name|fileLowerBound
operator|.
name|toInstant
argument_list|()
operator|.
name|plusSeconds
argument_list|(
name|timeSliceSeconds
argument_list|)
argument_list|)
decl_stmt|;
name|Location
name|predLowerLocation
decl_stmt|;
name|Location
name|predUpperLocation
init|=
literal|null
decl_stmt|;
name|predLowerLocation
operator|=
name|compareToRange
argument_list|(
name|predLowerBound
argument_list|,
name|fileLowerBound
argument_list|,
name|fileUpperBound
argument_list|)
expr_stmt|;
name|boolean
name|selected
init|=
literal|false
decl_stmt|;
if|if
condition|(
name|predLowerLocation
operator|==
name|Location
operator|.
name|BEFORE
operator|||
name|predLowerLocation
operator|==
name|Location
operator|.
name|MIN
condition|)
block|{
name|predUpperLocation
operator|=
name|compareToRange
argument_list|(
name|predUpperBound
argument_list|,
name|fileLowerBound
argument_list|,
name|fileUpperBound
argument_list|)
expr_stmt|;
if|if
condition|(
name|predUpperLocation
operator|==
name|Location
operator|.
name|AFTER
operator|||
name|predUpperLocation
operator|==
name|Location
operator|.
name|MAX
condition|)
block|{
name|selectedFiles
operator|.
name|add
argument_list|(
name|fileStatus
argument_list|)
expr_stmt|;
name|selected
operator|=
literal|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|predUpperLocation
operator|==
name|Location
operator|.
name|BEFORE
condition|)
block|{
comment|// file skipped (out of range)
block|}
else|else
block|{
name|selectedFiles
operator|.
name|add
argument_list|(
name|fileStatus
argument_list|)
expr_stmt|;
name|selected
operator|=
literal|true
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|predLowerLocation
operator|==
name|Location
operator|.
name|AFTER
condition|)
block|{
comment|// file skipped (out of range)
block|}
else|else
block|{
name|selectedFiles
operator|.
name|add
argument_list|(
name|fileStatus
argument_list|)
expr_stmt|;
name|selected
operator|=
literal|true
expr_stmt|;
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"file: {} -> [{}, {}] against predicate [{}({}), {}({})]. selected? {}"
argument_list|,
name|fileStatus
operator|.
name|getPath
argument_list|()
argument_list|,
name|fileLowerBound
operator|.
name|toInstant
argument_list|()
argument_list|,
name|fileUpperBound
operator|.
name|toInstant
argument_list|()
argument_list|,
name|predLowerBound
operator|.
name|toInstant
argument_list|()
argument_list|,
name|predLowerLocation
argument_list|,
name|predUpperBound
operator|.
name|toInstant
argument_list|()
argument_list|,
name|predUpperLocation
argument_list|,
name|selected
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Timestamp cannot be extracted from filename. Incorrect file name convention? {}"
argument_list|,
name|fileStatus
operator|.
name|getPath
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|inputFiles
return|;
block|}
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"Total selected files: {}"
argument_list|,
name|selectedFiles
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|selectedFiles
return|;
block|}
name|LOG
operator|.
name|warn
argument_list|(
literal|"Unsupported expression ({}) on 'ts' column. Skipping file pruning.."
argument_list|,
name|tsPred
operator|.
name|getOperator
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|inputFiles
return|;
block|}
comment|// 2019-10-13 10:15:35.100 -> 2019-10-13 10:15:00.000
specifier|private
name|Timestamp
name|roundupToMinuteFloor
parameter_list|(
specifier|final
name|Timestamp
name|ts
parameter_list|)
block|{
name|long
name|millis
init|=
name|ts
operator|.
name|getTime
argument_list|()
decl_stmt|;
name|long
name|newMillis
init|=
name|MILLISECONDS_PER_MINUTE
operator|*
operator|(
name|millis
operator|/
name|MILLISECONDS_PER_MINUTE
operator|)
decl_stmt|;
return|return
operator|new
name|Timestamp
argument_list|(
name|newMillis
argument_list|)
return|;
block|}
comment|// 2019-10-13 10:15:35.100 -> 2019-10-13 10:16:00.000
specifier|private
name|Timestamp
name|roundupToMinuteCeil
parameter_list|(
specifier|final
name|Timestamp
name|ts
parameter_list|)
block|{
name|long
name|millis
init|=
name|ts
operator|.
name|getTime
argument_list|()
decl_stmt|;
name|long
name|newMillis
init|=
name|MILLISECONDS_PER_MINUTE
operator|*
operator|(
name|millis
operator|/
name|MILLISECONDS_PER_MINUTE
operator|)
decl_stmt|;
name|newMillis
operator|+=
name|MILLISECONDS_PER_MINUTE
expr_stmt|;
return|return
operator|new
name|Timestamp
argument_list|(
name|newMillis
argument_list|)
return|;
block|}
comment|// 2019-04-02-21-00_0.log.gz -> 2019:04:02 21:00:00.0
specifier|private
specifier|static
name|Timestamp
name|getTimeStampFromPath
parameter_list|(
specifier|final
name|FileStatus
name|fileStatus
parameter_list|)
block|{
name|String
name|file
init|=
name|fileStatus
operator|.
name|getPath
argument_list|()
operator|.
name|getName
argument_list|()
decl_stmt|;
if|if
condition|(
name|file
operator|.
name|contains
argument_list|(
literal|"_"
argument_list|)
condition|)
block|{
name|String
name|tsStr
init|=
name|file
operator|.
name|split
argument_list|(
literal|"_"
argument_list|)
index|[
literal|0
index|]
decl_stmt|;
if|if
condition|(
name|tsStr
operator|.
name|contains
argument_list|(
literal|"-"
argument_list|)
condition|)
block|{
name|String
index|[]
name|tsTokens
init|=
name|tsStr
operator|.
name|split
argument_list|(
literal|"-"
argument_list|)
decl_stmt|;
if|if
condition|(
name|tsTokens
operator|.
name|length
operator|==
literal|5
condition|)
block|{
try|try
block|{
name|Calendar
name|calendar
init|=
operator|new
name|GregorianCalendar
argument_list|(
name|TimeZone
operator|.
name|getTimeZone
argument_list|(
literal|"UTC"
argument_list|)
argument_list|,
name|Locale
operator|.
name|getDefault
argument_list|()
argument_list|)
decl_stmt|;
name|int
name|year
init|=
name|Integer
operator|.
name|parseUnsignedInt
argument_list|(
name|tsTokens
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
name|int
name|month
init|=
name|Integer
operator|.
name|parseUnsignedInt
argument_list|(
name|tsTokens
index|[
literal|1
index|]
argument_list|)
decl_stmt|;
name|int
name|day
init|=
name|Integer
operator|.
name|parseUnsignedInt
argument_list|(
name|tsTokens
index|[
literal|2
index|]
argument_list|)
decl_stmt|;
name|int
name|hour
init|=
name|Integer
operator|.
name|parseUnsignedInt
argument_list|(
name|tsTokens
index|[
literal|3
index|]
argument_list|)
decl_stmt|;
name|int
name|min
init|=
name|Integer
operator|.
name|parseUnsignedInt
argument_list|(
name|tsTokens
index|[
literal|4
index|]
argument_list|)
decl_stmt|;
comment|// month value is zero indexed
name|calendar
operator|.
name|set
argument_list|(
name|year
argument_list|,
name|month
operator|-
literal|1
argument_list|,
name|day
argument_list|,
name|hour
argument_list|,
name|min
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|Timestamp
name|ts
init|=
operator|new
name|Timestamp
argument_list|(
name|calendar
operator|.
name|getTimeInMillis
argument_list|()
argument_list|)
decl_stmt|;
name|ts
operator|.
name|setNanos
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return
name|ts
return|;
block|}
catch|catch
parameter_list|(
name|NumberFormatException
name|e
parameter_list|)
block|{
return|return
literal|null
return|;
block|}
block|}
block|}
block|}
return|return
literal|null
return|;
block|}
specifier|private
parameter_list|<
name|T
parameter_list|>
name|Location
name|compareToRange
parameter_list|(
name|Comparable
argument_list|<
name|T
argument_list|>
name|point
parameter_list|,
name|T
name|min
parameter_list|,
name|T
name|max
parameter_list|)
block|{
name|int
name|minCompare
init|=
name|point
operator|.
name|compareTo
argument_list|(
name|min
argument_list|)
decl_stmt|;
if|if
condition|(
name|minCompare
operator|<
literal|0
condition|)
block|{
return|return
name|Location
operator|.
name|BEFORE
return|;
block|}
elseif|else
if|if
condition|(
name|minCompare
operator|==
literal|0
condition|)
block|{
return|return
name|Location
operator|.
name|MIN
return|;
block|}
else|else
block|{
name|int
name|maxCompare
init|=
name|point
operator|.
name|compareTo
argument_list|(
name|max
argument_list|)
decl_stmt|;
if|if
condition|(
name|maxCompare
operator|>
literal|0
condition|)
block|{
return|return
name|Location
operator|.
name|AFTER
return|;
block|}
else|else
block|{
return|return
name|maxCompare
operator|==
literal|0
condition|?
name|Location
operator|.
name|MAX
else|:
name|Location
operator|.
name|MIDDLE
return|;
block|}
block|}
block|}
annotation|@
name|Override
specifier|public
name|RecordReader
argument_list|<
name|LongWritable
argument_list|,
name|Text
argument_list|>
name|getRecordReader
parameter_list|(
specifier|final
name|InputSplit
name|genericSplit
parameter_list|,
specifier|final
name|JobConf
name|job
parameter_list|,
specifier|final
name|Reporter
name|reporter
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|genericSplit
operator|instanceof
name|FileSplit
condition|)
block|{
specifier|final
name|Path
name|finalPath
init|=
operator|(
operator|(
name|FileSplit
operator|)
name|genericSplit
operator|)
operator|.
name|getPath
argument_list|()
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Returning record reader for path {}"
argument_list|,
name|finalPath
argument_list|)
expr_stmt|;
name|jobConf
operator|=
name|projectionPusher
operator|.
name|pushProjectionsAndFilters
argument_list|(
name|job
argument_list|,
name|finalPath
operator|.
name|getParent
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// textIF considers '\r' or '\n' as line ending but syslog uses '\r' for escaping new lines. So to read multi-line
comment|// exceptions correctly we explictly use only '\n'
name|jobConf
operator|.
name|set
argument_list|(
literal|"textinputformat.record.delimiter"
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
return|return
name|super
operator|.
name|getRecordReader
argument_list|(
name|genericSplit
argument_list|,
name|jobConf
argument_list|,
name|reporter
argument_list|)
return|;
block|}
block|}
end_class

end_unit

