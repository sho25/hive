begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|txn
operator|.
name|compactor
package|;
end_package

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|Log
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|LogFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|BlockLocation
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FileStatus
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FileSystem
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|LocalFileSystem
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|Path
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|common
operator|.
name|ValidTxnList
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|common
operator|.
name|ValidTxnListImpl
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|conf
operator|.
name|HiveConf
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|metastore
operator|.
name|api
operator|.
name|FieldSchema
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|metastore
operator|.
name|api
operator|.
name|StorageDescriptor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|metastore
operator|.
name|api
operator|.
name|Table
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|io
operator|.
name|AcidInputFormat
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|io
operator|.
name|AcidOutputFormat
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|io
operator|.
name|AcidUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|io
operator|.
name|FSRecordWriter
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|io
operator|.
name|RecordIdentifier
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde
operator|.
name|serdeConstants
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|objectinspector
operator|.
name|ObjectInspector
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|NullWritable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|Writable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapred
operator|.
name|InputFormat
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapred
operator|.
name|InputSplit
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapred
operator|.
name|JobClient
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapred
operator|.
name|JobConf
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapred
operator|.
name|JobContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapred
operator|.
name|JobStatus
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapred
operator|.
name|Mapper
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapred
operator|.
name|OutputCollector
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapred
operator|.
name|OutputCommitter
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapred
operator|.
name|RecordReader
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapred
operator|.
name|Reporter
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapred
operator|.
name|RunningJob
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapred
operator|.
name|TaskAttemptContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapred
operator|.
name|lib
operator|.
name|NullOutputFormat
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|StringUtils
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|DataInput
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|DataOutput
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|*
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|regex
operator|.
name|Matcher
import|;
end_import

begin_comment
comment|/**  * Class to do compactions via an MR job.  This has to be in the ql package rather than metastore  * .compactions package with all of it's relatives because it needs access to the actual input  * and output formats, which are in ql.  ql depends on metastore and we can't have a circular  * dependency.  */
end_comment

begin_class
specifier|public
class|class
name|CompactorMR
block|{
specifier|static
specifier|final
specifier|private
name|String
name|CLASS_NAME
init|=
name|CompactorMR
operator|.
name|class
operator|.
name|getName
argument_list|()
decl_stmt|;
specifier|static
specifier|final
specifier|private
name|Log
name|LOG
init|=
name|LogFactory
operator|.
name|getLog
argument_list|(
name|CLASS_NAME
argument_list|)
decl_stmt|;
specifier|static
specifier|final
specifier|private
name|String
name|INPUT_FORMAT_CLASS_NAME
init|=
literal|"hive.compactor.input.format.class.name"
decl_stmt|;
specifier|static
specifier|final
specifier|private
name|String
name|OUTPUT_FORMAT_CLASS_NAME
init|=
literal|"hive.compactor.output.format.class.name"
decl_stmt|;
specifier|static
specifier|final
specifier|private
name|String
name|TMP_LOCATION
init|=
literal|"hive.compactor.input.tmp.dir"
decl_stmt|;
specifier|static
specifier|final
specifier|private
name|String
name|FINAL_LOCATION
init|=
literal|"hive.compactor.input.dir"
decl_stmt|;
specifier|static
specifier|final
specifier|private
name|String
name|MIN_TXN
init|=
literal|"hive.compactor.txn.min"
decl_stmt|;
specifier|static
specifier|final
specifier|private
name|String
name|MAX_TXN
init|=
literal|"hive.compactor.txn.max"
decl_stmt|;
specifier|static
specifier|final
specifier|private
name|String
name|IS_MAJOR
init|=
literal|"hive.compactor.is.major"
decl_stmt|;
specifier|static
specifier|final
specifier|private
name|String
name|IS_COMPRESSED
init|=
literal|"hive.compactor.is.compressed"
decl_stmt|;
specifier|static
specifier|final
specifier|private
name|String
name|TABLE_PROPS
init|=
literal|"hive.compactor.table.props"
decl_stmt|;
specifier|static
specifier|final
specifier|private
name|String
name|NUM_BUCKETS
init|=
literal|"hive.compactor.num.buckets"
decl_stmt|;
specifier|static
specifier|final
specifier|private
name|String
name|BASE_DIR
init|=
literal|"hive.compactor.base.dir"
decl_stmt|;
specifier|static
specifier|final
specifier|private
name|String
name|DELTA_DIRS
init|=
literal|"hive.compactor.delta.dirs"
decl_stmt|;
specifier|static
specifier|final
specifier|private
name|String
name|DIRS_TO_SEARCH
init|=
literal|"hive.compactor.dirs.to.search"
decl_stmt|;
specifier|static
specifier|final
specifier|private
name|String
name|TMPDIR
init|=
literal|"_tmp"
decl_stmt|;
specifier|public
name|CompactorMR
parameter_list|()
block|{   }
comment|/**    * Run a compactor job.    * @param conf Hive configuration file    * @param jobName name to run this job with    * @param t metastore table    * @param sd metastore storage descriptor    * @param txns list of valid transactions    * @param isMajor is this a major compaction?    * @throws java.io.IOException if the job fails    */
name|void
name|run
parameter_list|(
name|HiveConf
name|conf
parameter_list|,
name|String
name|jobName
parameter_list|,
name|Table
name|t
parameter_list|,
name|StorageDescriptor
name|sd
parameter_list|,
name|ValidTxnList
name|txns
parameter_list|,
name|boolean
name|isMajor
parameter_list|)
throws|throws
name|IOException
block|{
name|JobConf
name|job
init|=
operator|new
name|JobConf
argument_list|(
name|conf
argument_list|)
decl_stmt|;
name|job
operator|.
name|setJobName
argument_list|(
name|jobName
argument_list|)
expr_stmt|;
name|job
operator|.
name|setOutputKeyClass
argument_list|(
name|NullWritable
operator|.
name|class
argument_list|)
expr_stmt|;
name|job
operator|.
name|setOutputValueClass
argument_list|(
name|NullWritable
operator|.
name|class
argument_list|)
expr_stmt|;
name|job
operator|.
name|setJarByClass
argument_list|(
name|CompactorMR
operator|.
name|class
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"User jar set to "
operator|+
name|job
operator|.
name|getJar
argument_list|()
argument_list|)
expr_stmt|;
name|job
operator|.
name|setMapperClass
argument_list|(
name|CompactorMap
operator|.
name|class
argument_list|)
expr_stmt|;
name|job
operator|.
name|setNumReduceTasks
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|job
operator|.
name|setInputFormat
argument_list|(
name|CompactorInputFormat
operator|.
name|class
argument_list|)
expr_stmt|;
name|job
operator|.
name|setOutputFormat
argument_list|(
name|NullOutputFormat
operator|.
name|class
argument_list|)
expr_stmt|;
name|job
operator|.
name|setOutputCommitter
argument_list|(
name|CompactorOutputCommitter
operator|.
name|class
argument_list|)
expr_stmt|;
name|job
operator|.
name|set
argument_list|(
name|FINAL_LOCATION
argument_list|,
name|sd
operator|.
name|getLocation
argument_list|()
argument_list|)
expr_stmt|;
name|job
operator|.
name|set
argument_list|(
name|TMP_LOCATION
argument_list|,
name|sd
operator|.
name|getLocation
argument_list|()
operator|+
literal|"/"
operator|+
name|TMPDIR
operator|+
literal|"_"
operator|+
name|UUID
operator|.
name|randomUUID
argument_list|()
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|job
operator|.
name|set
argument_list|(
name|INPUT_FORMAT_CLASS_NAME
argument_list|,
name|sd
operator|.
name|getInputFormat
argument_list|()
argument_list|)
expr_stmt|;
name|job
operator|.
name|set
argument_list|(
name|OUTPUT_FORMAT_CLASS_NAME
argument_list|,
name|sd
operator|.
name|getOutputFormat
argument_list|()
argument_list|)
expr_stmt|;
name|job
operator|.
name|setBoolean
argument_list|(
name|IS_MAJOR
argument_list|,
name|isMajor
argument_list|)
expr_stmt|;
name|job
operator|.
name|setBoolean
argument_list|(
name|IS_COMPRESSED
argument_list|,
name|sd
operator|.
name|isCompressed
argument_list|()
argument_list|)
expr_stmt|;
name|job
operator|.
name|set
argument_list|(
name|TABLE_PROPS
argument_list|,
operator|new
name|StringableMap
argument_list|(
name|t
operator|.
name|getParameters
argument_list|()
argument_list|)
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|job
operator|.
name|setInt
argument_list|(
name|NUM_BUCKETS
argument_list|,
name|sd
operator|.
name|getBucketColsSize
argument_list|()
argument_list|)
expr_stmt|;
name|job
operator|.
name|set
argument_list|(
name|ValidTxnList
operator|.
name|VALID_TXNS_KEY
argument_list|,
name|txns
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|setColumnTypes
argument_list|(
name|job
argument_list|,
name|sd
operator|.
name|getCols
argument_list|()
argument_list|)
expr_stmt|;
comment|// Figure out and encode what files we need to read.  We do this here (rather than in
comment|// getSplits below) because as part of this we discover our minimum and maximum transactions,
comment|// and discovering that in getSplits is too late as we then have no way to pass it to our
comment|// mapper.
name|AcidUtils
operator|.
name|Directory
name|dir
init|=
name|AcidUtils
operator|.
name|getAcidState
argument_list|(
operator|new
name|Path
argument_list|(
name|sd
operator|.
name|getLocation
argument_list|()
argument_list|)
argument_list|,
name|conf
argument_list|,
name|txns
argument_list|)
decl_stmt|;
name|StringableList
name|dirsToSearch
init|=
operator|new
name|StringableList
argument_list|()
decl_stmt|;
name|Path
name|baseDir
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|isMajor
condition|)
block|{
comment|// There may not be a base dir if the partition was empty before inserts or if this
comment|// partition is just now being converted to ACID.
name|baseDir
operator|=
name|dir
operator|.
name|getBaseDirectory
argument_list|()
expr_stmt|;
if|if
condition|(
name|baseDir
operator|==
literal|null
condition|)
block|{
name|List
argument_list|<
name|FileStatus
argument_list|>
name|originalFiles
init|=
name|dir
operator|.
name|getOriginalFiles
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|originalFiles
operator|==
literal|null
operator|)
operator|&&
operator|!
operator|(
name|originalFiles
operator|.
name|size
argument_list|()
operator|==
literal|0
operator|)
condition|)
block|{
comment|// There are original format files
for|for
control|(
name|FileStatus
name|stat
range|:
name|originalFiles
control|)
block|{
name|dirsToSearch
operator|.
name|add
argument_list|(
name|stat
operator|.
name|getPath
argument_list|()
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Adding original file "
operator|+
name|stat
operator|.
name|getPath
argument_list|()
operator|.
name|toString
argument_list|()
operator|+
literal|" to dirs to search"
argument_list|)
expr_stmt|;
block|}
comment|// Set base to the location so that the input format reads the original files.
name|baseDir
operator|=
operator|new
name|Path
argument_list|(
name|sd
operator|.
name|getLocation
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// add our base to the list of directories to search for files in.
name|LOG
operator|.
name|debug
argument_list|(
literal|"Adding base directory "
operator|+
name|baseDir
operator|+
literal|" to dirs to search"
argument_list|)
expr_stmt|;
name|dirsToSearch
operator|.
name|add
argument_list|(
name|baseDir
argument_list|)
expr_stmt|;
block|}
block|}
name|List
argument_list|<
name|AcidUtils
operator|.
name|ParsedDelta
argument_list|>
name|parsedDeltas
init|=
name|dir
operator|.
name|getCurrentDirectories
argument_list|()
decl_stmt|;
if|if
condition|(
name|parsedDeltas
operator|==
literal|null
operator|||
name|parsedDeltas
operator|.
name|size
argument_list|()
operator|==
literal|0
condition|)
block|{
comment|// Seriously, no deltas?  Can't compact that.
name|LOG
operator|.
name|error
argument_list|(
literal|"No delta files found to compact in "
operator|+
name|sd
operator|.
name|getLocation
argument_list|()
argument_list|)
expr_stmt|;
return|return;
block|}
name|StringableList
name|deltaDirs
init|=
operator|new
name|StringableList
argument_list|()
decl_stmt|;
name|long
name|minTxn
init|=
name|Long
operator|.
name|MAX_VALUE
decl_stmt|;
name|long
name|maxTxn
init|=
name|Long
operator|.
name|MIN_VALUE
decl_stmt|;
for|for
control|(
name|AcidUtils
operator|.
name|ParsedDelta
name|delta
range|:
name|parsedDeltas
control|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Adding delta "
operator|+
name|delta
operator|.
name|getPath
argument_list|()
operator|+
literal|" to directories to search"
argument_list|)
expr_stmt|;
name|dirsToSearch
operator|.
name|add
argument_list|(
name|delta
operator|.
name|getPath
argument_list|()
argument_list|)
expr_stmt|;
name|deltaDirs
operator|.
name|add
argument_list|(
name|delta
operator|.
name|getPath
argument_list|()
argument_list|)
expr_stmt|;
name|minTxn
operator|=
name|Math
operator|.
name|min
argument_list|(
name|minTxn
argument_list|,
name|delta
operator|.
name|getMinTransaction
argument_list|()
argument_list|)
expr_stmt|;
name|maxTxn
operator|=
name|Math
operator|.
name|max
argument_list|(
name|maxTxn
argument_list|,
name|delta
operator|.
name|getMaxTransaction
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|baseDir
operator|!=
literal|null
condition|)
name|job
operator|.
name|set
argument_list|(
name|BASE_DIR
argument_list|,
name|baseDir
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|job
operator|.
name|set
argument_list|(
name|DELTA_DIRS
argument_list|,
name|deltaDirs
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|job
operator|.
name|set
argument_list|(
name|DIRS_TO_SEARCH
argument_list|,
name|dirsToSearch
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|job
operator|.
name|setLong
argument_list|(
name|MIN_TXN
argument_list|,
name|minTxn
argument_list|)
expr_stmt|;
name|job
operator|.
name|setLong
argument_list|(
name|MAX_TXN
argument_list|,
name|maxTxn
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Setting minimum transaction to "
operator|+
name|minTxn
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Setting maximume transaction to "
operator|+
name|maxTxn
argument_list|)
expr_stmt|;
name|JobClient
operator|.
name|runJob
argument_list|(
name|job
argument_list|)
operator|.
name|waitForCompletion
argument_list|()
expr_stmt|;
block|}
comment|/**    * Set the column names and types into the job conf for the input format    * to use.    * @param job the job to update    * @param cols the columns of the table    */
specifier|private
name|void
name|setColumnTypes
parameter_list|(
name|JobConf
name|job
parameter_list|,
name|List
argument_list|<
name|FieldSchema
argument_list|>
name|cols
parameter_list|)
block|{
name|StringBuilder
name|colNames
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|StringBuilder
name|colTypes
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|boolean
name|isFirst
init|=
literal|true
decl_stmt|;
for|for
control|(
name|FieldSchema
name|col
range|:
name|cols
control|)
block|{
if|if
condition|(
name|isFirst
condition|)
block|{
name|isFirst
operator|=
literal|false
expr_stmt|;
block|}
else|else
block|{
name|colNames
operator|.
name|append
argument_list|(
literal|','
argument_list|)
expr_stmt|;
name|colTypes
operator|.
name|append
argument_list|(
literal|','
argument_list|)
expr_stmt|;
block|}
name|colNames
operator|.
name|append
argument_list|(
name|col
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
name|colTypes
operator|.
name|append
argument_list|(
name|col
operator|.
name|getType
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|job
operator|.
name|set
argument_list|(
name|serdeConstants
operator|.
name|LIST_COLUMNS
argument_list|,
name|colNames
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|job
operator|.
name|set
argument_list|(
name|serdeConstants
operator|.
name|LIST_COLUMN_TYPES
argument_list|,
name|colTypes
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
specifier|static
class|class
name|CompactorInputSplit
implements|implements
name|InputSplit
block|{
specifier|private
name|long
name|length
init|=
literal|0
decl_stmt|;
specifier|private
name|List
argument_list|<
name|String
argument_list|>
name|locations
decl_stmt|;
specifier|private
name|int
name|bucketNum
decl_stmt|;
specifier|private
name|Path
name|base
decl_stmt|;
specifier|private
name|Path
index|[]
name|deltas
decl_stmt|;
specifier|public
name|CompactorInputSplit
parameter_list|()
block|{     }
comment|/**      *      * @param hadoopConf      * @param bucket bucket to be processed by this split      * @param files actual files this split should process.  It is assumed the caller has already      *              parsed out the files in base and deltas to populate this list.      * @param base directory of the base, or the partition/table location if the files are in old      *             style.  Can be null.      * @param deltas directories of the delta files.      * @throws IOException      */
name|CompactorInputSplit
parameter_list|(
name|Configuration
name|hadoopConf
parameter_list|,
name|int
name|bucket
parameter_list|,
name|List
argument_list|<
name|Path
argument_list|>
name|files
parameter_list|,
name|Path
name|base
parameter_list|,
name|Path
index|[]
name|deltas
parameter_list|)
throws|throws
name|IOException
block|{
name|bucketNum
operator|=
name|bucket
expr_stmt|;
name|this
operator|.
name|base
operator|=
name|base
expr_stmt|;
name|this
operator|.
name|deltas
operator|=
name|deltas
expr_stmt|;
name|locations
operator|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
expr_stmt|;
for|for
control|(
name|Path
name|path
range|:
name|files
control|)
block|{
name|FileSystem
name|fs
init|=
name|path
operator|.
name|getFileSystem
argument_list|(
name|hadoopConf
argument_list|)
decl_stmt|;
name|FileStatus
name|stat
init|=
name|fs
operator|.
name|getFileStatus
argument_list|(
name|path
argument_list|)
decl_stmt|;
name|length
operator|+=
name|stat
operator|.
name|getLen
argument_list|()
expr_stmt|;
name|BlockLocation
index|[]
name|locs
init|=
name|fs
operator|.
name|getFileBlockLocations
argument_list|(
name|stat
argument_list|,
literal|0
argument_list|,
name|length
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|locs
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|String
index|[]
name|hosts
init|=
name|locs
index|[
name|i
index|]
operator|.
name|getHosts
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|hosts
operator|.
name|length
condition|;
name|j
operator|++
control|)
block|{
name|locations
operator|.
name|add
argument_list|(
name|hosts
index|[
name|j
index|]
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
annotation|@
name|Override
specifier|public
name|long
name|getLength
parameter_list|()
throws|throws
name|IOException
block|{
return|return
name|length
return|;
block|}
annotation|@
name|Override
specifier|public
name|String
index|[]
name|getLocations
parameter_list|()
throws|throws
name|IOException
block|{
return|return
name|locations
operator|.
name|toArray
argument_list|(
operator|new
name|String
index|[
name|locations
operator|.
name|size
argument_list|()
index|]
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|write
parameter_list|(
name|DataOutput
name|dataOutput
parameter_list|)
throws|throws
name|IOException
block|{
name|dataOutput
operator|.
name|writeLong
argument_list|(
name|length
argument_list|)
expr_stmt|;
name|dataOutput
operator|.
name|writeInt
argument_list|(
name|locations
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|locations
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|dataOutput
operator|.
name|writeInt
argument_list|(
name|locations
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|length
argument_list|()
argument_list|)
expr_stmt|;
name|dataOutput
operator|.
name|writeBytes
argument_list|(
name|locations
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|dataOutput
operator|.
name|writeInt
argument_list|(
name|bucketNum
argument_list|)
expr_stmt|;
if|if
condition|(
name|base
operator|==
literal|null
condition|)
block|{
name|dataOutput
operator|.
name|writeInt
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|dataOutput
operator|.
name|writeInt
argument_list|(
name|base
operator|.
name|toString
argument_list|()
operator|.
name|length
argument_list|()
argument_list|)
expr_stmt|;
name|dataOutput
operator|.
name|writeBytes
argument_list|(
name|base
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|dataOutput
operator|.
name|writeInt
argument_list|(
name|deltas
operator|.
name|length
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|deltas
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|dataOutput
operator|.
name|writeInt
argument_list|(
name|deltas
index|[
name|i
index|]
operator|.
name|toString
argument_list|()
operator|.
name|length
argument_list|()
argument_list|)
expr_stmt|;
name|dataOutput
operator|.
name|writeBytes
argument_list|(
name|deltas
index|[
name|i
index|]
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|void
name|readFields
parameter_list|(
name|DataInput
name|dataInput
parameter_list|)
throws|throws
name|IOException
block|{
name|int
name|len
decl_stmt|;
name|byte
index|[]
name|buf
decl_stmt|;
name|locations
operator|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
expr_stmt|;
name|length
operator|=
name|dataInput
operator|.
name|readLong
argument_list|()
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Read length of "
operator|+
name|length
argument_list|)
expr_stmt|;
name|int
name|numElements
init|=
name|dataInput
operator|.
name|readInt
argument_list|()
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Read numElements of "
operator|+
name|numElements
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numElements
condition|;
name|i
operator|++
control|)
block|{
name|len
operator|=
name|dataInput
operator|.
name|readInt
argument_list|()
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Read file length of "
operator|+
name|len
argument_list|)
expr_stmt|;
name|buf
operator|=
operator|new
name|byte
index|[
name|len
index|]
expr_stmt|;
name|dataInput
operator|.
name|readFully
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|locations
operator|.
name|add
argument_list|(
operator|new
name|String
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|bucketNum
operator|=
name|dataInput
operator|.
name|readInt
argument_list|()
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Read bucket number of "
operator|+
name|bucketNum
argument_list|)
expr_stmt|;
name|len
operator|=
name|dataInput
operator|.
name|readInt
argument_list|()
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Read base path length of "
operator|+
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|>
literal|0
condition|)
block|{
name|buf
operator|=
operator|new
name|byte
index|[
name|len
index|]
expr_stmt|;
name|dataInput
operator|.
name|readFully
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|base
operator|=
operator|new
name|Path
argument_list|(
operator|new
name|String
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|numElements
operator|=
name|dataInput
operator|.
name|readInt
argument_list|()
expr_stmt|;
name|deltas
operator|=
operator|new
name|Path
index|[
name|numElements
index|]
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numElements
condition|;
name|i
operator|++
control|)
block|{
name|len
operator|=
name|dataInput
operator|.
name|readInt
argument_list|()
expr_stmt|;
name|buf
operator|=
operator|new
name|byte
index|[
name|len
index|]
expr_stmt|;
name|dataInput
operator|.
name|readFully
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|deltas
index|[
name|i
index|]
operator|=
operator|new
name|Path
argument_list|(
operator|new
name|String
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
specifier|public
name|void
name|set
parameter_list|(
name|CompactorInputSplit
name|other
parameter_list|)
block|{
name|length
operator|=
name|other
operator|.
name|length
expr_stmt|;
name|locations
operator|=
name|other
operator|.
name|locations
expr_stmt|;
name|bucketNum
operator|=
name|other
operator|.
name|bucketNum
expr_stmt|;
name|base
operator|=
name|other
operator|.
name|base
expr_stmt|;
name|deltas
operator|=
name|other
operator|.
name|deltas
expr_stmt|;
block|}
name|int
name|getBucket
parameter_list|()
block|{
return|return
name|bucketNum
return|;
block|}
name|Path
name|getBaseDir
parameter_list|()
block|{
return|return
name|base
return|;
block|}
name|Path
index|[]
name|getDeltaDirs
parameter_list|()
block|{
return|return
name|deltas
return|;
block|}
specifier|public
name|String
name|toString
parameter_list|()
block|{
name|StringBuilder
name|builder
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|builder
operator|.
name|append
argument_list|(
literal|"CompactorInputSplit{base: "
argument_list|)
expr_stmt|;
name|builder
operator|.
name|append
argument_list|(
name|base
argument_list|)
expr_stmt|;
name|builder
operator|.
name|append
argument_list|(
literal|", bucket: "
argument_list|)
expr_stmt|;
name|builder
operator|.
name|append
argument_list|(
name|bucketNum
argument_list|)
expr_stmt|;
name|builder
operator|.
name|append
argument_list|(
literal|", length: "
argument_list|)
expr_stmt|;
name|builder
operator|.
name|append
argument_list|(
name|length
argument_list|)
expr_stmt|;
name|builder
operator|.
name|append
argument_list|(
literal|", deltas: ["
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|deltas
operator|.
name|length
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|i
operator|!=
literal|0
condition|)
block|{
name|builder
operator|.
name|append
argument_list|(
literal|", "
argument_list|)
expr_stmt|;
block|}
name|builder
operator|.
name|append
argument_list|(
name|deltas
index|[
name|i
index|]
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|builder
operator|.
name|append
argument_list|(
literal|"]}"
argument_list|)
expr_stmt|;
return|return
name|builder
operator|.
name|toString
argument_list|()
return|;
block|}
block|}
comment|/**    * This input format returns its own input split as a value.  This is because our splits    * contain information needed to properly construct the writer.  Crazy, huh?    */
specifier|static
class|class
name|CompactorInputFormat
implements|implements
name|InputFormat
argument_list|<
name|NullWritable
argument_list|,
name|CompactorInputSplit
argument_list|>
block|{
annotation|@
name|Override
specifier|public
name|InputSplit
index|[]
name|getSplits
parameter_list|(
name|JobConf
name|entries
parameter_list|,
name|int
name|i
parameter_list|)
throws|throws
name|IOException
block|{
name|Path
name|baseDir
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|entries
operator|.
name|get
argument_list|(
name|BASE_DIR
argument_list|)
operator|!=
literal|null
condition|)
name|baseDir
operator|=
operator|new
name|Path
argument_list|(
name|entries
operator|.
name|get
argument_list|(
name|BASE_DIR
argument_list|)
argument_list|)
expr_stmt|;
name|StringableList
name|tmpDeltaDirs
init|=
operator|new
name|StringableList
argument_list|(
name|entries
operator|.
name|get
argument_list|(
name|DELTA_DIRS
argument_list|)
argument_list|)
decl_stmt|;
name|Path
index|[]
name|deltaDirs
init|=
name|tmpDeltaDirs
operator|.
name|toArray
argument_list|(
operator|new
name|Path
index|[
name|tmpDeltaDirs
operator|.
name|size
argument_list|()
index|]
argument_list|)
decl_stmt|;
name|StringableList
name|dirsToSearch
init|=
operator|new
name|StringableList
argument_list|(
name|entries
operator|.
name|get
argument_list|(
name|DIRS_TO_SEARCH
argument_list|)
argument_list|)
decl_stmt|;
name|Map
argument_list|<
name|Integer
argument_list|,
name|BucketTracker
argument_list|>
name|splitToBucketMap
init|=
operator|new
name|HashMap
argument_list|<
name|Integer
argument_list|,
name|BucketTracker
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|Path
name|dir
range|:
name|dirsToSearch
control|)
block|{
name|FileSystem
name|fs
init|=
name|dir
operator|.
name|getFileSystem
argument_list|(
name|entries
argument_list|)
decl_stmt|;
comment|// If this is a base or delta directory, then we need to be looking for the bucket files.
comment|// But if it's a legacy file then we need to add it directly.
if|if
condition|(
name|dir
operator|.
name|getName
argument_list|()
operator|.
name|startsWith
argument_list|(
name|AcidUtils
operator|.
name|BASE_PREFIX
argument_list|)
operator|||
name|dir
operator|.
name|getName
argument_list|()
operator|.
name|startsWith
argument_list|(
name|AcidUtils
operator|.
name|DELTA_PREFIX
argument_list|)
condition|)
block|{
name|boolean
name|sawBase
init|=
name|dir
operator|.
name|getName
argument_list|()
operator|.
name|startsWith
argument_list|(
name|AcidUtils
operator|.
name|BASE_PREFIX
argument_list|)
decl_stmt|;
name|FileStatus
index|[]
name|files
init|=
name|fs
operator|.
name|listStatus
argument_list|(
name|dir
argument_list|,
name|AcidUtils
operator|.
name|bucketFileFilter
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|files
operator|.
name|length
condition|;
name|j
operator|++
control|)
block|{
comment|// For each file, figure out which bucket it is.
name|Matcher
name|matcher
init|=
name|AcidUtils
operator|.
name|BUCKET_DIGIT_PATTERN
operator|.
name|matcher
argument_list|(
name|files
index|[
name|j
index|]
operator|.
name|getPath
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|)
decl_stmt|;
name|addFileToMap
argument_list|(
name|matcher
argument_list|,
name|files
index|[
name|j
index|]
operator|.
name|getPath
argument_list|()
argument_list|,
name|sawBase
argument_list|,
name|splitToBucketMap
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// Legacy file, see if it's a bucket file
name|Matcher
name|matcher
init|=
name|AcidUtils
operator|.
name|LEGACY_BUCKET_DIGIT_PATTERN
operator|.
name|matcher
argument_list|(
name|dir
operator|.
name|getName
argument_list|()
argument_list|)
decl_stmt|;
name|addFileToMap
argument_list|(
name|matcher
argument_list|,
name|dir
argument_list|,
literal|true
argument_list|,
name|splitToBucketMap
argument_list|)
expr_stmt|;
block|}
block|}
name|List
argument_list|<
name|InputSplit
argument_list|>
name|splits
init|=
operator|new
name|ArrayList
argument_list|<
name|InputSplit
argument_list|>
argument_list|(
name|splitToBucketMap
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|Integer
argument_list|,
name|BucketTracker
argument_list|>
name|e
range|:
name|splitToBucketMap
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|BucketTracker
name|bt
init|=
name|e
operator|.
name|getValue
argument_list|()
decl_stmt|;
name|splits
operator|.
name|add
argument_list|(
operator|new
name|CompactorInputSplit
argument_list|(
name|entries
argument_list|,
name|e
operator|.
name|getKey
argument_list|()
argument_list|,
name|bt
operator|.
name|buckets
argument_list|,
name|bt
operator|.
name|sawBase
condition|?
name|baseDir
else|:
literal|null
argument_list|,
name|deltaDirs
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|LOG
operator|.
name|debug
argument_list|(
literal|"Returning "
operator|+
name|splits
operator|.
name|size
argument_list|()
operator|+
literal|" splits"
argument_list|)
expr_stmt|;
return|return
name|splits
operator|.
name|toArray
argument_list|(
operator|new
name|InputSplit
index|[
name|splits
operator|.
name|size
argument_list|()
index|]
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|RecordReader
argument_list|<
name|NullWritable
argument_list|,
name|CompactorInputSplit
argument_list|>
name|getRecordReader
parameter_list|(
name|InputSplit
name|inputSplit
parameter_list|,
name|JobConf
name|entries
parameter_list|,
name|Reporter
name|reporter
parameter_list|)
throws|throws
name|IOException
block|{
return|return
operator|new
name|CompactorRecordReader
argument_list|(
operator|(
name|CompactorInputSplit
operator|)
name|inputSplit
argument_list|)
return|;
block|}
specifier|private
name|void
name|addFileToMap
parameter_list|(
name|Matcher
name|matcher
parameter_list|,
name|Path
name|file
parameter_list|,
name|boolean
name|sawBase
parameter_list|,
name|Map
argument_list|<
name|Integer
argument_list|,
name|BucketTracker
argument_list|>
name|splitToBucketMap
parameter_list|)
block|{
if|if
condition|(
operator|!
name|matcher
operator|.
name|find
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Found a non-bucket file that we thought matched the bucket pattern! "
operator|+
name|file
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|int
name|bucketNum
init|=
name|Integer
operator|.
name|valueOf
argument_list|(
name|matcher
operator|.
name|group
argument_list|()
argument_list|)
decl_stmt|;
name|BucketTracker
name|bt
init|=
name|splitToBucketMap
operator|.
name|get
argument_list|(
name|bucketNum
argument_list|)
decl_stmt|;
if|if
condition|(
name|bt
operator|==
literal|null
condition|)
block|{
name|bt
operator|=
operator|new
name|BucketTracker
argument_list|()
expr_stmt|;
name|splitToBucketMap
operator|.
name|put
argument_list|(
name|bucketNum
argument_list|,
name|bt
argument_list|)
expr_stmt|;
block|}
name|LOG
operator|.
name|debug
argument_list|(
literal|"Adding "
operator|+
name|file
operator|.
name|toString
argument_list|()
operator|+
literal|" to list of files for splits"
argument_list|)
expr_stmt|;
name|bt
operator|.
name|buckets
operator|.
name|add
argument_list|(
name|file
argument_list|)
expr_stmt|;
name|bt
operator|.
name|sawBase
operator||=
name|sawBase
expr_stmt|;
block|}
specifier|private
specifier|static
class|class
name|BucketTracker
block|{
name|BucketTracker
parameter_list|()
block|{
name|sawBase
operator|=
literal|false
expr_stmt|;
name|buckets
operator|=
operator|new
name|ArrayList
argument_list|<
name|Path
argument_list|>
argument_list|()
expr_stmt|;
block|}
name|boolean
name|sawBase
decl_stmt|;
name|List
argument_list|<
name|Path
argument_list|>
name|buckets
decl_stmt|;
block|}
block|}
specifier|static
class|class
name|CompactorRecordReader
implements|implements
name|RecordReader
argument_list|<
name|NullWritable
argument_list|,
name|CompactorInputSplit
argument_list|>
block|{
specifier|private
name|CompactorInputSplit
name|split
decl_stmt|;
name|CompactorRecordReader
parameter_list|(
name|CompactorInputSplit
name|split
parameter_list|)
block|{
name|this
operator|.
name|split
operator|=
name|split
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|next
parameter_list|(
name|NullWritable
name|key
parameter_list|,
name|CompactorInputSplit
name|compactorInputSplit
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|split
operator|!=
literal|null
condition|)
block|{
name|compactorInputSplit
operator|.
name|set
argument_list|(
name|split
argument_list|)
expr_stmt|;
name|split
operator|=
literal|null
expr_stmt|;
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
annotation|@
name|Override
specifier|public
name|NullWritable
name|createKey
parameter_list|()
block|{
return|return
name|NullWritable
operator|.
name|get
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|CompactorInputSplit
name|createValue
parameter_list|()
block|{
return|return
operator|new
name|CompactorInputSplit
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|long
name|getPos
parameter_list|()
throws|throws
name|IOException
block|{
return|return
literal|0
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|close
parameter_list|()
throws|throws
name|IOException
block|{      }
annotation|@
name|Override
specifier|public
name|float
name|getProgress
parameter_list|()
throws|throws
name|IOException
block|{
return|return
literal|0
return|;
block|}
block|}
specifier|static
class|class
name|CompactorMap
parameter_list|<
name|V
extends|extends
name|Writable
parameter_list|>
implements|implements
name|Mapper
argument_list|<
name|NullWritable
argument_list|,
name|CompactorInputSplit
argument_list|,
name|NullWritable
argument_list|,
name|NullWritable
argument_list|>
block|{
name|JobConf
name|jobConf
decl_stmt|;
name|FSRecordWriter
name|writer
decl_stmt|;
annotation|@
name|Override
specifier|public
name|void
name|map
parameter_list|(
name|NullWritable
name|key
parameter_list|,
name|CompactorInputSplit
name|split
parameter_list|,
name|OutputCollector
argument_list|<
name|NullWritable
argument_list|,
name|NullWritable
argument_list|>
name|nullWritableVOutputCollector
parameter_list|,
name|Reporter
name|reporter
parameter_list|)
throws|throws
name|IOException
block|{
comment|// This will only get called once, since CompactRecordReader only returns one record,
comment|// the input split.
comment|// Based on the split we're passed we go instantiate the real reader and then iterate on it
comment|// until it finishes.
name|AcidInputFormat
name|aif
init|=
name|instantiate
argument_list|(
name|AcidInputFormat
operator|.
name|class
argument_list|,
name|jobConf
operator|.
name|get
argument_list|(
name|INPUT_FORMAT_CLASS_NAME
argument_list|)
argument_list|)
decl_stmt|;
name|ValidTxnList
name|txnList
init|=
operator|new
name|ValidTxnListImpl
argument_list|(
name|jobConf
operator|.
name|get
argument_list|(
name|ValidTxnList
operator|.
name|VALID_TXNS_KEY
argument_list|)
argument_list|)
decl_stmt|;
name|AcidInputFormat
operator|.
name|RawReader
argument_list|<
name|V
argument_list|>
name|reader
init|=
name|aif
operator|.
name|getRawReader
argument_list|(
name|jobConf
argument_list|,
name|jobConf
operator|.
name|getBoolean
argument_list|(
name|IS_MAJOR
argument_list|,
literal|false
argument_list|)
argument_list|,
name|split
operator|.
name|getBucket
argument_list|()
argument_list|,
name|txnList
argument_list|,
name|split
operator|.
name|getBaseDir
argument_list|()
argument_list|,
name|split
operator|.
name|getDeltaDirs
argument_list|()
argument_list|)
decl_stmt|;
name|RecordIdentifier
name|identifier
init|=
name|reader
operator|.
name|createKey
argument_list|()
decl_stmt|;
name|V
name|value
init|=
name|reader
operator|.
name|createValue
argument_list|()
decl_stmt|;
name|getWriter
argument_list|(
name|reporter
argument_list|,
name|reader
operator|.
name|getObjectInspector
argument_list|()
argument_list|,
name|split
operator|.
name|getBucket
argument_list|()
argument_list|)
expr_stmt|;
while|while
condition|(
name|reader
operator|.
name|next
argument_list|(
name|identifier
argument_list|,
name|value
argument_list|)
condition|)
block|{
name|writer
operator|.
name|write
argument_list|(
name|value
argument_list|)
expr_stmt|;
name|reporter
operator|.
name|progress
argument_list|()
expr_stmt|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|void
name|configure
parameter_list|(
name|JobConf
name|entries
parameter_list|)
block|{
name|jobConf
operator|=
name|entries
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|close
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|writer
operator|!=
literal|null
condition|)
block|{
name|writer
operator|.
name|close
argument_list|(
literal|false
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|getWriter
parameter_list|(
name|Reporter
name|reporter
parameter_list|,
name|ObjectInspector
name|inspector
parameter_list|,
name|int
name|bucket
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|writer
operator|==
literal|null
condition|)
block|{
name|AcidOutputFormat
operator|.
name|Options
name|options
init|=
operator|new
name|AcidOutputFormat
operator|.
name|Options
argument_list|(
name|jobConf
argument_list|)
decl_stmt|;
name|options
operator|.
name|inspector
argument_list|(
name|inspector
argument_list|)
operator|.
name|writingBase
argument_list|(
name|jobConf
operator|.
name|getBoolean
argument_list|(
name|IS_MAJOR
argument_list|,
literal|false
argument_list|)
argument_list|)
operator|.
name|isCompressed
argument_list|(
name|jobConf
operator|.
name|getBoolean
argument_list|(
name|IS_COMPRESSED
argument_list|,
literal|false
argument_list|)
argument_list|)
operator|.
name|tableProperties
argument_list|(
operator|new
name|StringableMap
argument_list|(
name|jobConf
operator|.
name|get
argument_list|(
name|TABLE_PROPS
argument_list|)
argument_list|)
operator|.
name|toProperties
argument_list|()
argument_list|)
operator|.
name|reporter
argument_list|(
name|reporter
argument_list|)
operator|.
name|minimumTransactionId
argument_list|(
name|jobConf
operator|.
name|getLong
argument_list|(
name|MIN_TXN
argument_list|,
name|Long
operator|.
name|MAX_VALUE
argument_list|)
argument_list|)
operator|.
name|maximumTransactionId
argument_list|(
name|jobConf
operator|.
name|getLong
argument_list|(
name|MAX_TXN
argument_list|,
name|Long
operator|.
name|MIN_VALUE
argument_list|)
argument_list|)
operator|.
name|bucket
argument_list|(
name|bucket
argument_list|)
expr_stmt|;
comment|// Instantiate the underlying output format
name|AcidOutputFormat
argument_list|<
name|V
argument_list|>
name|aof
init|=
name|instantiate
argument_list|(
name|AcidOutputFormat
operator|.
name|class
argument_list|,
name|jobConf
operator|.
name|get
argument_list|(
name|OUTPUT_FORMAT_CLASS_NAME
argument_list|)
argument_list|)
decl_stmt|;
name|writer
operator|=
name|aof
operator|.
name|getRawRecordWriter
argument_list|(
operator|new
name|Path
argument_list|(
name|jobConf
operator|.
name|get
argument_list|(
name|TMP_LOCATION
argument_list|)
argument_list|)
argument_list|,
name|options
argument_list|)
expr_stmt|;
block|}
block|}
block|}
specifier|static
class|class
name|StringableMap
extends|extends
name|HashMap
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
block|{
name|StringableMap
parameter_list|(
name|String
name|s
parameter_list|)
block|{
name|String
index|[]
name|parts
init|=
name|s
operator|.
name|split
argument_list|(
literal|":"
argument_list|,
literal|2
argument_list|)
decl_stmt|;
comment|// read that many chars
name|int
name|numElements
init|=
name|Integer
operator|.
name|valueOf
argument_list|(
name|parts
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
name|s
operator|=
name|parts
index|[
literal|1
index|]
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numElements
condition|;
name|i
operator|++
control|)
block|{
name|parts
operator|=
name|s
operator|.
name|split
argument_list|(
literal|":"
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|int
name|len
init|=
name|Integer
operator|.
name|valueOf
argument_list|(
name|parts
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
name|String
name|key
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|len
operator|>
literal|0
condition|)
name|key
operator|=
name|parts
index|[
literal|1
index|]
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|parts
operator|=
name|parts
index|[
literal|1
index|]
operator|.
name|substring
argument_list|(
name|len
argument_list|)
operator|.
name|split
argument_list|(
literal|":"
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|len
operator|=
name|Integer
operator|.
name|valueOf
argument_list|(
name|parts
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|String
name|value
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|len
operator|>
literal|0
condition|)
name|value
operator|=
name|parts
index|[
literal|1
index|]
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|s
operator|=
name|parts
index|[
literal|1
index|]
operator|.
name|substring
argument_list|(
name|len
argument_list|)
expr_stmt|;
name|put
argument_list|(
name|key
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
block|}
name|StringableMap
parameter_list|(
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|m
parameter_list|)
block|{
name|super
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|toString
parameter_list|()
block|{
name|StringBuffer
name|buf
init|=
operator|new
name|StringBuffer
argument_list|()
decl_stmt|;
name|buf
operator|.
name|append
argument_list|(
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|buf
operator|.
name|append
argument_list|(
literal|':'
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|entry
range|:
name|entrySet
argument_list|()
control|)
block|{
name|int
name|length
init|=
operator|(
name|entry
operator|.
name|getKey
argument_list|()
operator|==
literal|null
operator|)
condition|?
literal|0
else|:
name|entry
operator|.
name|getKey
argument_list|()
operator|.
name|length
argument_list|()
decl_stmt|;
name|buf
operator|.
name|append
argument_list|(
name|entry
operator|.
name|getKey
argument_list|()
operator|==
literal|null
condition|?
literal|0
else|:
name|length
argument_list|)
expr_stmt|;
name|buf
operator|.
name|append
argument_list|(
literal|':'
argument_list|)
expr_stmt|;
if|if
condition|(
name|length
operator|>
literal|0
condition|)
name|buf
operator|.
name|append
argument_list|(
name|entry
operator|.
name|getKey
argument_list|()
argument_list|)
expr_stmt|;
name|length
operator|=
operator|(
name|entry
operator|.
name|getValue
argument_list|()
operator|==
literal|null
operator|)
condition|?
literal|0
else|:
name|entry
operator|.
name|getValue
argument_list|()
operator|.
name|length
argument_list|()
expr_stmt|;
name|buf
operator|.
name|append
argument_list|(
name|length
argument_list|)
expr_stmt|;
name|buf
operator|.
name|append
argument_list|(
literal|':'
argument_list|)
expr_stmt|;
if|if
condition|(
name|length
operator|>
literal|0
condition|)
name|buf
operator|.
name|append
argument_list|(
name|entry
operator|.
name|getValue
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|buf
operator|.
name|toString
argument_list|()
return|;
block|}
specifier|public
name|Properties
name|toProperties
parameter_list|()
block|{
name|Properties
name|props
init|=
operator|new
name|Properties
argument_list|()
decl_stmt|;
name|props
operator|.
name|putAll
argument_list|(
name|this
argument_list|)
expr_stmt|;
return|return
name|props
return|;
block|}
block|}
specifier|static
class|class
name|StringableList
extends|extends
name|ArrayList
argument_list|<
name|Path
argument_list|>
block|{
name|StringableList
parameter_list|()
block|{      }
name|StringableList
parameter_list|(
name|String
name|s
parameter_list|)
block|{
name|String
index|[]
name|parts
init|=
name|s
operator|.
name|split
argument_list|(
literal|":"
argument_list|,
literal|2
argument_list|)
decl_stmt|;
comment|// read that many chars
name|int
name|numElements
init|=
name|Integer
operator|.
name|valueOf
argument_list|(
name|parts
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
name|s
operator|=
name|parts
index|[
literal|1
index|]
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numElements
condition|;
name|i
operator|++
control|)
block|{
name|parts
operator|=
name|s
operator|.
name|split
argument_list|(
literal|":"
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|int
name|len
init|=
name|Integer
operator|.
name|valueOf
argument_list|(
name|parts
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
name|String
name|val
init|=
name|parts
index|[
literal|1
index|]
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|len
argument_list|)
decl_stmt|;
name|s
operator|=
name|parts
index|[
literal|1
index|]
operator|.
name|substring
argument_list|(
name|len
argument_list|)
expr_stmt|;
name|add
argument_list|(
operator|new
name|Path
argument_list|(
name|val
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|String
name|toString
parameter_list|()
block|{
name|StringBuffer
name|buf
init|=
operator|new
name|StringBuffer
argument_list|()
decl_stmt|;
name|buf
operator|.
name|append
argument_list|(
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|buf
operator|.
name|append
argument_list|(
literal|':'
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
for|for
control|(
name|Path
name|p
range|:
name|this
control|)
block|{
name|buf
operator|.
name|append
argument_list|(
name|p
operator|.
name|toString
argument_list|()
operator|.
name|length
argument_list|()
argument_list|)
expr_stmt|;
name|buf
operator|.
name|append
argument_list|(
literal|':'
argument_list|)
expr_stmt|;
name|buf
operator|.
name|append
argument_list|(
name|p
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|buf
operator|.
name|toString
argument_list|()
return|;
block|}
block|}
specifier|private
specifier|static
parameter_list|<
name|T
parameter_list|>
name|T
name|instantiate
parameter_list|(
name|Class
argument_list|<
name|T
argument_list|>
name|classType
parameter_list|,
name|String
name|classname
parameter_list|)
throws|throws
name|IOException
block|{
name|T
name|t
init|=
literal|null
decl_stmt|;
try|try
block|{
name|Class
name|c
init|=
name|Class
operator|.
name|forName
argument_list|(
name|classname
argument_list|)
decl_stmt|;
name|Object
name|o
init|=
name|c
operator|.
name|newInstance
argument_list|()
decl_stmt|;
if|if
condition|(
name|classType
operator|.
name|isAssignableFrom
argument_list|(
name|o
operator|.
name|getClass
argument_list|()
argument_list|)
condition|)
block|{
name|t
operator|=
operator|(
name|T
operator|)
name|o
expr_stmt|;
block|}
else|else
block|{
name|String
name|s
init|=
name|classname
operator|+
literal|" is not an instance of "
operator|+
name|classType
operator|.
name|getName
argument_list|()
decl_stmt|;
name|LOG
operator|.
name|error
argument_list|(
name|s
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|IOException
argument_list|(
name|s
argument_list|)
throw|;
block|}
block|}
catch|catch
parameter_list|(
name|ClassNotFoundException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Unable to instantiate class, "
operator|+
name|StringUtils
operator|.
name|stringifyException
argument_list|(
name|e
argument_list|)
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|IOException
argument_list|(
name|e
argument_list|)
throw|;
block|}
catch|catch
parameter_list|(
name|InstantiationException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Unable to instantiate class, "
operator|+
name|StringUtils
operator|.
name|stringifyException
argument_list|(
name|e
argument_list|)
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|IOException
argument_list|(
name|e
argument_list|)
throw|;
block|}
catch|catch
parameter_list|(
name|IllegalAccessException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Unable to instantiate class, "
operator|+
name|StringUtils
operator|.
name|stringifyException
argument_list|(
name|e
argument_list|)
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|IOException
argument_list|(
name|e
argument_list|)
throw|;
block|}
return|return
name|t
return|;
block|}
specifier|static
class|class
name|CompactorOutputCommitter
extends|extends
name|OutputCommitter
block|{
annotation|@
name|Override
specifier|public
name|void
name|setupJob
parameter_list|(
name|JobContext
name|jobContext
parameter_list|)
throws|throws
name|IOException
block|{      }
annotation|@
name|Override
specifier|public
name|void
name|setupTask
parameter_list|(
name|TaskAttemptContext
name|taskAttemptContext
parameter_list|)
throws|throws
name|IOException
block|{      }
annotation|@
name|Override
specifier|public
name|boolean
name|needsTaskCommit
parameter_list|(
name|TaskAttemptContext
name|taskAttemptContext
parameter_list|)
throws|throws
name|IOException
block|{
return|return
literal|false
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|commitTask
parameter_list|(
name|TaskAttemptContext
name|taskAttemptContext
parameter_list|)
throws|throws
name|IOException
block|{      }
annotation|@
name|Override
specifier|public
name|void
name|abortTask
parameter_list|(
name|TaskAttemptContext
name|taskAttemptContext
parameter_list|)
throws|throws
name|IOException
block|{      }
annotation|@
name|Override
specifier|public
name|void
name|commitJob
parameter_list|(
name|JobContext
name|context
parameter_list|)
throws|throws
name|IOException
block|{
name|Path
name|tmpLocation
init|=
operator|new
name|Path
argument_list|(
name|context
operator|.
name|getJobConf
argument_list|()
operator|.
name|get
argument_list|(
name|TMP_LOCATION
argument_list|)
argument_list|)
decl_stmt|;
name|Path
name|finalLocation
init|=
operator|new
name|Path
argument_list|(
name|context
operator|.
name|getJobConf
argument_list|()
operator|.
name|get
argument_list|(
name|FINAL_LOCATION
argument_list|)
argument_list|)
decl_stmt|;
name|FileSystem
name|fs
init|=
name|tmpLocation
operator|.
name|getFileSystem
argument_list|(
name|context
operator|.
name|getJobConf
argument_list|()
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Moving contents of "
operator|+
name|tmpLocation
operator|.
name|toString
argument_list|()
operator|+
literal|" to "
operator|+
name|finalLocation
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|FileStatus
index|[]
name|contents
init|=
name|fs
operator|.
name|listStatus
argument_list|(
name|tmpLocation
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|contents
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|Path
name|newPath
init|=
operator|new
name|Path
argument_list|(
name|finalLocation
argument_list|,
name|contents
index|[
name|i
index|]
operator|.
name|getPath
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|)
decl_stmt|;
name|fs
operator|.
name|rename
argument_list|(
name|contents
index|[
name|i
index|]
operator|.
name|getPath
argument_list|()
argument_list|,
name|newPath
argument_list|)
expr_stmt|;
block|}
name|fs
operator|.
name|delete
argument_list|(
name|tmpLocation
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|abortJob
parameter_list|(
name|JobContext
name|context
parameter_list|,
name|int
name|status
parameter_list|)
throws|throws
name|IOException
block|{
name|Path
name|tmpLocation
init|=
operator|new
name|Path
argument_list|(
name|context
operator|.
name|getJobConf
argument_list|()
operator|.
name|get
argument_list|(
name|TMP_LOCATION
argument_list|)
argument_list|)
decl_stmt|;
name|FileSystem
name|fs
init|=
name|tmpLocation
operator|.
name|getFileSystem
argument_list|(
name|context
operator|.
name|getJobConf
argument_list|()
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Removing "
operator|+
name|tmpLocation
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|fs
operator|.
name|delete
argument_list|(
name|tmpLocation
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_class

end_unit

