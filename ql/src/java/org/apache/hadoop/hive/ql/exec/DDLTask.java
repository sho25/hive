begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|BufferedWriter
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|DataOutput
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|FileNotFoundException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|OutputStreamWriter
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|Serializable
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|Writer
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|LinkedHashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|SortedSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|TreeSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
operator|.
name|Entry
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|Log
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|LogFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FSDataOutputStream
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FileStatus
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FileSystem
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|Path
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|conf
operator|.
name|HiveConf
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|metastore
operator|.
name|MetaStoreUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|metastore
operator|.
name|Warehouse
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|metastore
operator|.
name|api
operator|.
name|FieldSchema
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|metastore
operator|.
name|api
operator|.
name|InvalidOperationException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|metastore
operator|.
name|api
operator|.
name|MetaException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|metastore
operator|.
name|api
operator|.
name|Order
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|metastore
operator|.
name|api
operator|.
name|StorageDescriptor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|QueryPlan
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|hooks
operator|.
name|ReadEntity
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|hooks
operator|.
name|WriteEntity
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|metadata
operator|.
name|CheckResult
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|metadata
operator|.
name|Hive
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|metadata
operator|.
name|HiveException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|metadata
operator|.
name|HiveMetaStoreChecker
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|metadata
operator|.
name|InvalidTableException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|metadata
operator|.
name|Partition
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|metadata
operator|.
name|Table
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|AddPartitionDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|DDLWork
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|MsckDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|alterTableDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|createTableDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|createTableLikeDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|descFunctionDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|descTableDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|dropTableDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|showFunctionsDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|showPartitionsDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|showTableStatusDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|showTablesDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|api
operator|.
name|StageType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|udf
operator|.
name|generic
operator|.
name|GenericUDF
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|udf
operator|.
name|generic
operator|.
name|GenericUDFBridge
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde
operator|.
name|Constants
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|Deserializer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|MetadataTypedColumnsetSerDe
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|SerDeException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|SerDeUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|columnar
operator|.
name|ColumnarSerDe
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|dynamic_type
operator|.
name|DynamicSerDe
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|lazy
operator|.
name|LazySimpleSerDe
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|shims
operator|.
name|ShimLoader
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|StringUtils
import|;
end_import

begin_comment
comment|/**  * DDLTask implementation  *  **/
end_comment

begin_class
specifier|public
class|class
name|DDLTask
extends|extends
name|Task
argument_list|<
name|DDLWork
argument_list|>
implements|implements
name|Serializable
block|{
specifier|private
specifier|static
specifier|final
name|long
name|serialVersionUID
init|=
literal|1L
decl_stmt|;
specifier|static
specifier|final
specifier|private
name|Log
name|LOG
init|=
name|LogFactory
operator|.
name|getLog
argument_list|(
literal|"hive.ql.exec.DDLTask"
argument_list|)
decl_stmt|;
specifier|transient
name|HiveConf
name|conf
decl_stmt|;
specifier|static
specifier|final
specifier|private
name|int
name|separator
init|=
name|Utilities
operator|.
name|tabCode
decl_stmt|;
specifier|static
specifier|final
specifier|private
name|int
name|terminator
init|=
name|Utilities
operator|.
name|newLineCode
decl_stmt|;
specifier|public
name|DDLTask
parameter_list|()
block|{
name|super
argument_list|()
expr_stmt|;
block|}
specifier|public
name|void
name|initialize
parameter_list|(
name|HiveConf
name|conf
parameter_list|,
name|QueryPlan
name|queryPlan
parameter_list|)
block|{
name|super
operator|.
name|initialize
argument_list|(
name|conf
argument_list|,
name|queryPlan
argument_list|)
expr_stmt|;
name|this
operator|.
name|conf
operator|=
name|conf
expr_stmt|;
block|}
specifier|public
name|int
name|execute
parameter_list|()
block|{
comment|// Create the db
name|Hive
name|db
decl_stmt|;
try|try
block|{
name|db
operator|=
name|Hive
operator|.
name|get
argument_list|(
name|conf
argument_list|)
expr_stmt|;
name|createTableDesc
name|crtTbl
init|=
name|work
operator|.
name|getCreateTblDesc
argument_list|()
decl_stmt|;
if|if
condition|(
name|crtTbl
operator|!=
literal|null
condition|)
block|{
return|return
name|createTable
argument_list|(
name|db
argument_list|,
name|crtTbl
argument_list|)
return|;
block|}
name|createTableLikeDesc
name|crtTblLike
init|=
name|work
operator|.
name|getCreateTblLikeDesc
argument_list|()
decl_stmt|;
if|if
condition|(
name|crtTblLike
operator|!=
literal|null
condition|)
block|{
return|return
name|createTableLike
argument_list|(
name|db
argument_list|,
name|crtTblLike
argument_list|)
return|;
block|}
name|dropTableDesc
name|dropTbl
init|=
name|work
operator|.
name|getDropTblDesc
argument_list|()
decl_stmt|;
if|if
condition|(
name|dropTbl
operator|!=
literal|null
condition|)
block|{
return|return
name|dropTable
argument_list|(
name|db
argument_list|,
name|dropTbl
argument_list|)
return|;
block|}
name|alterTableDesc
name|alterTbl
init|=
name|work
operator|.
name|getAlterTblDesc
argument_list|()
decl_stmt|;
if|if
condition|(
name|alterTbl
operator|!=
literal|null
condition|)
block|{
return|return
name|alterTable
argument_list|(
name|db
argument_list|,
name|alterTbl
argument_list|)
return|;
block|}
name|AddPartitionDesc
name|addPartitionDesc
init|=
name|work
operator|.
name|getAddPartitionDesc
argument_list|()
decl_stmt|;
if|if
condition|(
name|addPartitionDesc
operator|!=
literal|null
condition|)
block|{
return|return
name|addPartition
argument_list|(
name|db
argument_list|,
name|addPartitionDesc
argument_list|)
return|;
block|}
name|MsckDesc
name|msckDesc
init|=
name|work
operator|.
name|getMsckDesc
argument_list|()
decl_stmt|;
if|if
condition|(
name|msckDesc
operator|!=
literal|null
condition|)
block|{
return|return
name|msck
argument_list|(
name|db
argument_list|,
name|msckDesc
argument_list|)
return|;
block|}
name|descTableDesc
name|descTbl
init|=
name|work
operator|.
name|getDescTblDesc
argument_list|()
decl_stmt|;
if|if
condition|(
name|descTbl
operator|!=
literal|null
condition|)
block|{
return|return
name|describeTable
argument_list|(
name|db
argument_list|,
name|descTbl
argument_list|)
return|;
block|}
name|descFunctionDesc
name|descFunc
init|=
name|work
operator|.
name|getDescFunctionDesc
argument_list|()
decl_stmt|;
if|if
condition|(
name|descFunc
operator|!=
literal|null
condition|)
block|{
return|return
name|describeFunction
argument_list|(
name|descFunc
argument_list|)
return|;
block|}
name|showTablesDesc
name|showTbls
init|=
name|work
operator|.
name|getShowTblsDesc
argument_list|()
decl_stmt|;
if|if
condition|(
name|showTbls
operator|!=
literal|null
condition|)
block|{
return|return
name|showTables
argument_list|(
name|db
argument_list|,
name|showTbls
argument_list|)
return|;
block|}
name|showTableStatusDesc
name|showTblStatus
init|=
name|work
operator|.
name|getShowTblStatusDesc
argument_list|()
decl_stmt|;
if|if
condition|(
name|showTblStatus
operator|!=
literal|null
condition|)
block|{
return|return
name|showTableStatus
argument_list|(
name|db
argument_list|,
name|showTblStatus
argument_list|)
return|;
block|}
name|showFunctionsDesc
name|showFuncs
init|=
name|work
operator|.
name|getShowFuncsDesc
argument_list|()
decl_stmt|;
if|if
condition|(
name|showFuncs
operator|!=
literal|null
condition|)
block|{
return|return
name|showFunctions
argument_list|(
name|showFuncs
argument_list|)
return|;
block|}
name|showPartitionsDesc
name|showParts
init|=
name|work
operator|.
name|getShowPartsDesc
argument_list|()
decl_stmt|;
if|if
condition|(
name|showParts
operator|!=
literal|null
condition|)
block|{
return|return
name|showPartitions
argument_list|(
name|db
argument_list|,
name|showParts
argument_list|)
return|;
block|}
block|}
catch|catch
parameter_list|(
name|InvalidTableException
name|e
parameter_list|)
block|{
name|console
operator|.
name|printError
argument_list|(
literal|"Table "
operator|+
name|e
operator|.
name|getTableName
argument_list|()
operator|+
literal|" does not exist"
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
name|StringUtils
operator|.
name|stringifyException
argument_list|(
name|e
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
catch|catch
parameter_list|(
name|HiveException
name|e
parameter_list|)
block|{
name|console
operator|.
name|printError
argument_list|(
literal|"FAILED: Error in metadata: "
operator|+
name|e
operator|.
name|getMessage
argument_list|()
argument_list|,
literal|"\n"
operator|+
name|StringUtils
operator|.
name|stringifyException
argument_list|(
name|e
argument_list|)
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
name|StringUtils
operator|.
name|stringifyException
argument_list|(
name|e
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|console
operator|.
name|printError
argument_list|(
literal|"Failed with exception "
operator|+
name|e
operator|.
name|getMessage
argument_list|()
argument_list|,
literal|"\n"
operator|+
name|StringUtils
operator|.
name|stringifyException
argument_list|(
name|e
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
assert|assert
literal|false
assert|;
return|return
literal|0
return|;
block|}
comment|/**    * Add a partition to a table.    * @param db Database to add the partition to.    * @param addPartitionDesc Add this partition.    * @return Returns 0 when execution succeeds and above 0 if it fails.    * @throws HiveException    */
specifier|private
name|int
name|addPartition
parameter_list|(
name|Hive
name|db
parameter_list|,
name|AddPartitionDesc
name|addPartitionDesc
parameter_list|)
throws|throws
name|HiveException
block|{
name|Table
name|tbl
init|=
name|db
operator|.
name|getTable
argument_list|(
name|addPartitionDesc
operator|.
name|getDbName
argument_list|()
argument_list|,
name|addPartitionDesc
operator|.
name|getTableName
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|addPartitionDesc
operator|.
name|getLocation
argument_list|()
operator|==
literal|null
condition|)
block|{
name|db
operator|.
name|createPartition
argument_list|(
name|tbl
argument_list|,
name|addPartitionDesc
operator|.
name|getPartSpec
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|//set partition path relative to table
name|db
operator|.
name|createPartition
argument_list|(
name|tbl
argument_list|,
name|addPartitionDesc
operator|.
name|getPartSpec
argument_list|()
argument_list|,
operator|new
name|Path
argument_list|(
name|tbl
operator|.
name|getPath
argument_list|()
argument_list|,
name|addPartitionDesc
operator|.
name|getLocation
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|Partition
name|part
init|=
name|db
operator|.
name|getPartition
argument_list|(
name|tbl
argument_list|,
name|addPartitionDesc
operator|.
name|getPartSpec
argument_list|()
argument_list|,
literal|false
argument_list|)
decl_stmt|;
name|work
operator|.
name|getOutputs
argument_list|()
operator|.
name|add
argument_list|(
operator|new
name|WriteEntity
argument_list|(
name|part
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/**    * MetastoreCheck, see if the data in the metastore matches    * what is on the dfs.    * Current version checks for tables and partitions that    * are either missing on disk on in the metastore.    *    * @param db The database in question.    * @param msckDesc Information about the tables and partitions    * we want to check for.    * @return Returns 0 when execution succeeds and above 0 if it fails.    */
specifier|private
name|int
name|msck
parameter_list|(
name|Hive
name|db
parameter_list|,
name|MsckDesc
name|msckDesc
parameter_list|)
block|{
name|CheckResult
name|result
init|=
operator|new
name|CheckResult
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|repairOutput
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
try|try
block|{
name|HiveMetaStoreChecker
name|checker
init|=
operator|new
name|HiveMetaStoreChecker
argument_list|(
name|db
argument_list|)
decl_stmt|;
name|checker
operator|.
name|checkMetastore
argument_list|(
name|MetaStoreUtils
operator|.
name|DEFAULT_DATABASE_NAME
argument_list|,
name|msckDesc
operator|.
name|getTableName
argument_list|()
argument_list|,
name|msckDesc
operator|.
name|getPartitionSpec
argument_list|()
argument_list|,
name|result
argument_list|)
expr_stmt|;
if|if
condition|(
name|msckDesc
operator|.
name|isRepairPartitions
argument_list|()
condition|)
block|{
name|Table
name|table
init|=
name|db
operator|.
name|getTable
argument_list|(
name|MetaStoreUtils
operator|.
name|DEFAULT_DATABASE_NAME
argument_list|,
name|msckDesc
operator|.
name|getTableName
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|CheckResult
operator|.
name|PartitionResult
name|part
range|:
name|result
operator|.
name|getPartitionsNotInMs
argument_list|()
control|)
block|{
try|try
block|{
name|db
operator|.
name|createPartition
argument_list|(
name|table
argument_list|,
name|Warehouse
operator|.
name|makeSpecFromName
argument_list|(
name|part
operator|.
name|getPartitionName
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|repairOutput
operator|.
name|add
argument_list|(
literal|"Repair: Added partition to metastore "
operator|+
name|msckDesc
operator|.
name|getTableName
argument_list|()
operator|+
literal|':'
operator|+
name|part
operator|.
name|getPartitionName
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Repair error, could not add partition to metastore: "
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
catch|catch
parameter_list|(
name|HiveException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Failed to run metacheck: "
argument_list|,
name|e
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Failed to run metacheck: "
argument_list|,
name|e
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
finally|finally
block|{
name|BufferedWriter
name|resultOut
init|=
literal|null
decl_stmt|;
try|try
block|{
name|FileSystem
name|fs
init|=
name|msckDesc
operator|.
name|getResFile
argument_list|()
operator|.
name|getFileSystem
argument_list|(
name|conf
argument_list|)
decl_stmt|;
name|resultOut
operator|=
operator|new
name|BufferedWriter
argument_list|(
operator|new
name|OutputStreamWriter
argument_list|(
name|fs
operator|.
name|create
argument_list|(
name|msckDesc
operator|.
name|getResFile
argument_list|()
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|boolean
name|firstWritten
init|=
literal|false
decl_stmt|;
name|firstWritten
operator||=
name|writeMsckResult
argument_list|(
name|result
operator|.
name|getTablesNotInMs
argument_list|()
argument_list|,
literal|"Tables not in metastore:"
argument_list|,
name|resultOut
argument_list|,
name|firstWritten
argument_list|)
expr_stmt|;
name|firstWritten
operator||=
name|writeMsckResult
argument_list|(
name|result
operator|.
name|getTablesNotOnFs
argument_list|()
argument_list|,
literal|"Tables missing on filesystem:"
argument_list|,
name|resultOut
argument_list|,
name|firstWritten
argument_list|)
expr_stmt|;
name|firstWritten
operator||=
name|writeMsckResult
argument_list|(
name|result
operator|.
name|getPartitionsNotInMs
argument_list|()
argument_list|,
literal|"Partitions not in metastore:"
argument_list|,
name|resultOut
argument_list|,
name|firstWritten
argument_list|)
expr_stmt|;
name|firstWritten
operator||=
name|writeMsckResult
argument_list|(
name|result
operator|.
name|getPartitionsNotOnFs
argument_list|()
argument_list|,
literal|"Partitions missing from filesystem:"
argument_list|,
name|resultOut
argument_list|,
name|firstWritten
argument_list|)
expr_stmt|;
for|for
control|(
name|String
name|rout
range|:
name|repairOutput
control|)
block|{
if|if
condition|(
name|firstWritten
condition|)
block|{
name|resultOut
operator|.
name|write
argument_list|(
name|terminator
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|firstWritten
operator|=
literal|true
expr_stmt|;
block|}
name|resultOut
operator|.
name|write
argument_list|(
name|rout
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Failed to save metacheck output: "
argument_list|,
name|e
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
finally|finally
block|{
if|if
condition|(
name|resultOut
operator|!=
literal|null
condition|)
block|{
try|try
block|{
name|resultOut
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Failed to close output file: "
argument_list|,
name|e
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
block|}
block|}
return|return
literal|0
return|;
block|}
comment|/**    * Write the result of msck to a writer.    * @param result The result we're going to write    * @param msg Message to write.    * @param out Writer to write to    * @param wrote if any previous call wrote data    * @return true if something was written    * @throws IOException In case the writing fails    */
specifier|private
name|boolean
name|writeMsckResult
parameter_list|(
name|List
argument_list|<
name|?
extends|extends
name|Object
argument_list|>
name|result
parameter_list|,
name|String
name|msg
parameter_list|,
name|Writer
name|out
parameter_list|,
name|boolean
name|wrote
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
operator|!
name|result
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
if|if
condition|(
name|wrote
condition|)
block|{
name|out
operator|.
name|write
argument_list|(
name|terminator
argument_list|)
expr_stmt|;
block|}
name|out
operator|.
name|write
argument_list|(
name|msg
argument_list|)
expr_stmt|;
for|for
control|(
name|Object
name|entry
range|:
name|result
control|)
block|{
name|out
operator|.
name|write
argument_list|(
name|separator
argument_list|)
expr_stmt|;
name|out
operator|.
name|write
argument_list|(
name|entry
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
comment|/**    * Write a list of partitions to a file.    *    * @param db The database in question.    * @param showParts These are the partitions we're interested in.    * @return Returns 0 when execution succeeds and above 0 if it fails.    * @throws HiveException Throws this exception if an unexpected error occurs.    */
specifier|private
name|int
name|showPartitions
parameter_list|(
name|Hive
name|db
parameter_list|,
name|showPartitionsDesc
name|showParts
parameter_list|)
throws|throws
name|HiveException
block|{
comment|// get the partitions for the table and populate the output
name|String
name|tabName
init|=
name|showParts
operator|.
name|getTabName
argument_list|()
decl_stmt|;
name|Table
name|tbl
init|=
literal|null
decl_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|parts
init|=
literal|null
decl_stmt|;
name|tbl
operator|=
name|db
operator|.
name|getTable
argument_list|(
name|MetaStoreUtils
operator|.
name|DEFAULT_DATABASE_NAME
argument_list|,
name|tabName
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|tbl
operator|.
name|isPartitioned
argument_list|()
condition|)
block|{
name|console
operator|.
name|printError
argument_list|(
literal|"Table "
operator|+
name|tabName
operator|+
literal|" is not a partitioned table"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
name|parts
operator|=
name|db
operator|.
name|getPartitionNames
argument_list|(
name|MetaStoreUtils
operator|.
name|DEFAULT_DATABASE_NAME
argument_list|,
name|tbl
operator|.
name|getName
argument_list|()
argument_list|,
name|Short
operator|.
name|MAX_VALUE
argument_list|)
expr_stmt|;
comment|// write the results in the file
try|try
block|{
name|FileSystem
name|fs
init|=
name|showParts
operator|.
name|getResFile
argument_list|()
operator|.
name|getFileSystem
argument_list|(
name|conf
argument_list|)
decl_stmt|;
name|DataOutput
name|outStream
init|=
operator|(
name|DataOutput
operator|)
name|fs
operator|.
name|create
argument_list|(
name|showParts
operator|.
name|getResFile
argument_list|()
argument_list|)
decl_stmt|;
name|Iterator
argument_list|<
name|String
argument_list|>
name|iterParts
init|=
name|parts
operator|.
name|iterator
argument_list|()
decl_stmt|;
while|while
condition|(
name|iterParts
operator|.
name|hasNext
argument_list|()
condition|)
block|{
comment|// create a row per partition name
name|outStream
operator|.
name|writeBytes
argument_list|(
name|iterParts
operator|.
name|next
argument_list|()
argument_list|)
expr_stmt|;
name|outStream
operator|.
name|write
argument_list|(
name|terminator
argument_list|)
expr_stmt|;
block|}
operator|(
operator|(
name|FSDataOutputStream
operator|)
name|outStream
operator|)
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|FileNotFoundException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"show partitions: "
operator|+
name|StringUtils
operator|.
name|stringifyException
argument_list|(
name|e
argument_list|)
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|HiveException
argument_list|(
name|e
operator|.
name|toString
argument_list|()
argument_list|)
throw|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"show partitions: "
operator|+
name|StringUtils
operator|.
name|stringifyException
argument_list|(
name|e
argument_list|)
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|HiveException
argument_list|(
name|e
operator|.
name|toString
argument_list|()
argument_list|)
throw|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|HiveException
argument_list|(
name|e
operator|.
name|toString
argument_list|()
argument_list|)
throw|;
block|}
return|return
literal|0
return|;
block|}
comment|/**    * Write a list of the tables in the database to a file.    *    * @param db The database in question.    * @param showTbls These are the tables we're interested in.    * @return Returns 0 when execution succeeds and above 0 if it fails.    * @throws HiveException Throws this exception if an unexpected error occurs.    */
specifier|private
name|int
name|showTables
parameter_list|(
name|Hive
name|db
parameter_list|,
name|showTablesDesc
name|showTbls
parameter_list|)
throws|throws
name|HiveException
block|{
comment|// get the tables for the desired pattenn - populate the output stream
name|List
argument_list|<
name|String
argument_list|>
name|tbls
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|showTbls
operator|.
name|getPattern
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"pattern: "
operator|+
name|showTbls
operator|.
name|getPattern
argument_list|()
argument_list|)
expr_stmt|;
name|tbls
operator|=
name|db
operator|.
name|getTablesByPattern
argument_list|(
name|showTbls
operator|.
name|getPattern
argument_list|()
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"results : "
operator|+
name|tbls
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
name|tbls
operator|=
name|db
operator|.
name|getAllTables
argument_list|()
expr_stmt|;
comment|// write the results in the file
try|try
block|{
name|FileSystem
name|fs
init|=
name|showTbls
operator|.
name|getResFile
argument_list|()
operator|.
name|getFileSystem
argument_list|(
name|conf
argument_list|)
decl_stmt|;
name|DataOutput
name|outStream
init|=
operator|(
name|DataOutput
operator|)
name|fs
operator|.
name|create
argument_list|(
name|showTbls
operator|.
name|getResFile
argument_list|()
argument_list|)
decl_stmt|;
name|SortedSet
argument_list|<
name|String
argument_list|>
name|sortedTbls
init|=
operator|new
name|TreeSet
argument_list|<
name|String
argument_list|>
argument_list|(
name|tbls
argument_list|)
decl_stmt|;
name|Iterator
argument_list|<
name|String
argument_list|>
name|iterTbls
init|=
name|sortedTbls
operator|.
name|iterator
argument_list|()
decl_stmt|;
while|while
condition|(
name|iterTbls
operator|.
name|hasNext
argument_list|()
condition|)
block|{
comment|// create a row per table name
name|outStream
operator|.
name|writeBytes
argument_list|(
name|iterTbls
operator|.
name|next
argument_list|()
argument_list|)
expr_stmt|;
name|outStream
operator|.
name|write
argument_list|(
name|terminator
argument_list|)
expr_stmt|;
block|}
operator|(
operator|(
name|FSDataOutputStream
operator|)
name|outStream
operator|)
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|FileNotFoundException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"show table: "
operator|+
name|StringUtils
operator|.
name|stringifyException
argument_list|(
name|e
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"show table: "
operator|+
name|StringUtils
operator|.
name|stringifyException
argument_list|(
name|e
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|HiveException
argument_list|(
name|e
operator|.
name|toString
argument_list|()
argument_list|)
throw|;
block|}
return|return
literal|0
return|;
block|}
comment|/**    * Write a list of the user defined functions to a file.    *    * @param showFuncs are the functions we're interested in.    * @return Returns 0 when execution succeeds and above 0 if it fails.    * @throws HiveException Throws this exception if an unexpected error occurs.    */
specifier|private
name|int
name|showFunctions
parameter_list|(
name|showFunctionsDesc
name|showFuncs
parameter_list|)
throws|throws
name|HiveException
block|{
comment|// get the tables for the desired pattenn - populate the output stream
name|Set
argument_list|<
name|String
argument_list|>
name|funcs
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|showFuncs
operator|.
name|getPattern
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"pattern: "
operator|+
name|showFuncs
operator|.
name|getPattern
argument_list|()
argument_list|)
expr_stmt|;
name|funcs
operator|=
name|FunctionRegistry
operator|.
name|getFunctionNames
argument_list|(
name|showFuncs
operator|.
name|getPattern
argument_list|()
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"results : "
operator|+
name|funcs
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
name|funcs
operator|=
name|FunctionRegistry
operator|.
name|getFunctionNames
argument_list|()
expr_stmt|;
comment|// write the results in the file
try|try
block|{
name|FileSystem
name|fs
init|=
name|showFuncs
operator|.
name|getResFile
argument_list|()
operator|.
name|getFileSystem
argument_list|(
name|conf
argument_list|)
decl_stmt|;
name|DataOutput
name|outStream
init|=
operator|(
name|DataOutput
operator|)
name|fs
operator|.
name|create
argument_list|(
name|showFuncs
operator|.
name|getResFile
argument_list|()
argument_list|)
decl_stmt|;
name|SortedSet
argument_list|<
name|String
argument_list|>
name|sortedFuncs
init|=
operator|new
name|TreeSet
argument_list|<
name|String
argument_list|>
argument_list|(
name|funcs
argument_list|)
decl_stmt|;
name|Iterator
argument_list|<
name|String
argument_list|>
name|iterFuncs
init|=
name|sortedFuncs
operator|.
name|iterator
argument_list|()
decl_stmt|;
while|while
condition|(
name|iterFuncs
operator|.
name|hasNext
argument_list|()
condition|)
block|{
comment|// create a row per table name
name|outStream
operator|.
name|writeBytes
argument_list|(
name|iterFuncs
operator|.
name|next
argument_list|()
argument_list|)
expr_stmt|;
name|outStream
operator|.
name|write
argument_list|(
name|terminator
argument_list|)
expr_stmt|;
block|}
operator|(
operator|(
name|FSDataOutputStream
operator|)
name|outStream
operator|)
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|FileNotFoundException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"show function: "
operator|+
name|StringUtils
operator|.
name|stringifyException
argument_list|(
name|e
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"show function: "
operator|+
name|StringUtils
operator|.
name|stringifyException
argument_list|(
name|e
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|HiveException
argument_list|(
name|e
operator|.
name|toString
argument_list|()
argument_list|)
throw|;
block|}
return|return
literal|0
return|;
block|}
comment|/**    * Shows a description of a function.    *    * @param descFunc is the function we are describing    * @throws HiveException    */
specifier|private
name|int
name|describeFunction
parameter_list|(
name|descFunctionDesc
name|descFunc
parameter_list|)
throws|throws
name|HiveException
block|{
name|String
name|name
init|=
name|descFunc
operator|.
name|getName
argument_list|()
decl_stmt|;
comment|// write the results in the file
try|try
block|{
name|FileSystem
name|fs
init|=
name|descFunc
operator|.
name|getResFile
argument_list|()
operator|.
name|getFileSystem
argument_list|(
name|conf
argument_list|)
decl_stmt|;
name|DataOutput
name|outStream
init|=
operator|(
name|DataOutput
operator|)
name|fs
operator|.
name|create
argument_list|(
name|descFunc
operator|.
name|getResFile
argument_list|()
argument_list|)
decl_stmt|;
comment|// get the function documentation
name|description
name|desc
init|=
literal|null
decl_stmt|;
name|FunctionInfo
name|fi
init|=
name|FunctionRegistry
operator|.
name|getFunctionInfo
argument_list|(
name|name
argument_list|)
decl_stmt|;
name|Class
argument_list|<
name|?
argument_list|>
name|funcClass
init|=
literal|null
decl_stmt|;
name|GenericUDF
name|udf
init|=
name|fi
operator|.
name|getGenericUDF
argument_list|()
decl_stmt|;
if|if
condition|(
name|udf
operator|!=
literal|null
condition|)
block|{
comment|// If it's a GenericUDFBridge, then let's use the
if|if
condition|(
name|udf
operator|instanceof
name|GenericUDFBridge
condition|)
block|{
name|funcClass
operator|=
operator|(
operator|(
name|GenericUDFBridge
operator|)
name|udf
operator|)
operator|.
name|getUdfClass
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|funcClass
operator|=
name|udf
operator|.
name|getClass
argument_list|()
expr_stmt|;
block|}
block|}
if|if
condition|(
name|funcClass
operator|!=
literal|null
condition|)
block|{
name|desc
operator|=
name|funcClass
operator|.
name|getAnnotation
argument_list|(
name|description
operator|.
name|class
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|desc
operator|!=
literal|null
condition|)
block|{
name|outStream
operator|.
name|writeBytes
argument_list|(
name|desc
operator|.
name|value
argument_list|()
operator|.
name|replace
argument_list|(
literal|"_FUNC_"
argument_list|,
name|name
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|descFunc
operator|.
name|isExtended
argument_list|()
operator|&&
name|desc
operator|.
name|extended
argument_list|()
operator|.
name|length
argument_list|()
operator|>
literal|0
condition|)
block|{
name|outStream
operator|.
name|writeBytes
argument_list|(
literal|"\n"
operator|+
name|desc
operator|.
name|extended
argument_list|()
operator|.
name|replace
argument_list|(
literal|"_FUNC_"
argument_list|,
name|name
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|outStream
operator|.
name|writeBytes
argument_list|(
literal|"Function "
operator|+
name|name
operator|+
literal|" does not exist or cannot"
operator|+
literal|" find documentation for it."
argument_list|)
expr_stmt|;
block|}
name|outStream
operator|.
name|write
argument_list|(
name|terminator
argument_list|)
expr_stmt|;
operator|(
operator|(
name|FSDataOutputStream
operator|)
name|outStream
operator|)
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|FileNotFoundException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"describe function: "
operator|+
name|StringUtils
operator|.
name|stringifyException
argument_list|(
name|e
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"describe function: "
operator|+
name|StringUtils
operator|.
name|stringifyException
argument_list|(
name|e
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|HiveException
argument_list|(
name|e
operator|.
name|toString
argument_list|()
argument_list|)
throw|;
block|}
return|return
literal|0
return|;
block|}
comment|/**    * Write the status of tables to a file.    *    * @param db  The database in question.    * @param showTblStatus tables we are interested in    * @return Return 0 when execution succeeds and above 0 if it fails.    */
specifier|private
name|int
name|showTableStatus
parameter_list|(
name|Hive
name|db
parameter_list|,
name|showTableStatusDesc
name|showTblStatus
parameter_list|)
throws|throws
name|HiveException
block|{
comment|// get the tables for the desired pattenn - populate the output stream
name|List
argument_list|<
name|Table
argument_list|>
name|tbls
init|=
operator|new
name|ArrayList
argument_list|<
name|Table
argument_list|>
argument_list|()
decl_stmt|;
name|HashMap
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|part
init|=
name|showTblStatus
operator|.
name|getPartSpec
argument_list|()
decl_stmt|;
name|Partition
name|par
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|part
operator|!=
literal|null
condition|)
block|{
name|Table
name|tbl
init|=
name|db
operator|.
name|getTable
argument_list|(
name|showTblStatus
operator|.
name|getDbName
argument_list|()
argument_list|,
name|showTblStatus
operator|.
name|getPattern
argument_list|()
argument_list|)
decl_stmt|;
name|par
operator|=
name|db
operator|.
name|getPartition
argument_list|(
name|tbl
argument_list|,
name|part
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|tbls
operator|.
name|add
argument_list|(
name|tbl
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"pattern: "
operator|+
name|showTblStatus
operator|.
name|getPattern
argument_list|()
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|tblStr
init|=
name|db
operator|.
name|getTablesForDb
argument_list|(
name|showTblStatus
operator|.
name|getDbName
argument_list|()
argument_list|,
name|showTblStatus
operator|.
name|getPattern
argument_list|()
argument_list|)
decl_stmt|;
name|SortedSet
argument_list|<
name|String
argument_list|>
name|sortedTbls
init|=
operator|new
name|TreeSet
argument_list|<
name|String
argument_list|>
argument_list|(
name|tblStr
argument_list|)
decl_stmt|;
name|Iterator
argument_list|<
name|String
argument_list|>
name|iterTbls
init|=
name|sortedTbls
operator|.
name|iterator
argument_list|()
decl_stmt|;
while|while
condition|(
name|iterTbls
operator|.
name|hasNext
argument_list|()
condition|)
block|{
comment|// create a row per table name
name|String
name|tblName
init|=
name|iterTbls
operator|.
name|next
argument_list|()
decl_stmt|;
name|Table
name|tbl
init|=
name|db
operator|.
name|getTable
argument_list|(
name|showTblStatus
operator|.
name|getDbName
argument_list|()
argument_list|,
name|tblName
argument_list|)
decl_stmt|;
name|tbls
operator|.
name|add
argument_list|(
name|tbl
argument_list|)
expr_stmt|;
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"results : "
operator|+
name|tblStr
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// write the results in the file
try|try
block|{
name|FileSystem
name|fs
init|=
name|showTblStatus
operator|.
name|getResFile
argument_list|()
operator|.
name|getFileSystem
argument_list|(
name|conf
argument_list|)
decl_stmt|;
name|DataOutput
name|outStream
init|=
operator|(
name|DataOutput
operator|)
name|fs
operator|.
name|create
argument_list|(
name|showTblStatus
operator|.
name|getResFile
argument_list|()
argument_list|)
decl_stmt|;
name|Iterator
argument_list|<
name|Table
argument_list|>
name|iterTables
init|=
name|tbls
operator|.
name|iterator
argument_list|()
decl_stmt|;
while|while
condition|(
name|iterTables
operator|.
name|hasNext
argument_list|()
condition|)
block|{
comment|// create a row per table name
name|Table
name|tbl
init|=
name|iterTables
operator|.
name|next
argument_list|()
decl_stmt|;
name|String
name|tableName
init|=
name|tbl
operator|.
name|getName
argument_list|()
decl_stmt|;
name|String
name|tblLoc
init|=
literal|null
decl_stmt|;
name|String
name|inputFormattCls
init|=
literal|null
decl_stmt|;
name|String
name|outputFormattCls
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|part
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|par
operator|!=
literal|null
condition|)
block|{
name|tblLoc
operator|=
name|par
operator|.
name|getDataLocation
argument_list|()
operator|.
name|toString
argument_list|()
expr_stmt|;
name|inputFormattCls
operator|=
name|par
operator|.
name|getTPartition
argument_list|()
operator|.
name|getSd
argument_list|()
operator|.
name|getInputFormat
argument_list|()
expr_stmt|;
name|outputFormattCls
operator|=
name|par
operator|.
name|getTPartition
argument_list|()
operator|.
name|getSd
argument_list|()
operator|.
name|getOutputFormat
argument_list|()
expr_stmt|;
block|}
block|}
else|else
block|{
name|tblLoc
operator|=
name|tbl
operator|.
name|getDataLocation
argument_list|()
operator|.
name|toString
argument_list|()
expr_stmt|;
name|inputFormattCls
operator|=
name|tbl
operator|.
name|getInputFormatClass
argument_list|()
operator|.
name|getName
argument_list|()
expr_stmt|;
name|outputFormattCls
operator|=
name|tbl
operator|.
name|getOutputFormatClass
argument_list|()
operator|.
name|getName
argument_list|()
expr_stmt|;
block|}
name|String
name|owner
init|=
name|tbl
operator|.
name|getOwner
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|FieldSchema
argument_list|>
name|cols
init|=
name|tbl
operator|.
name|getCols
argument_list|()
decl_stmt|;
name|String
name|ddlCols
init|=
name|MetaStoreUtils
operator|.
name|getDDLFromFieldSchema
argument_list|(
literal|"columns"
argument_list|,
name|cols
argument_list|)
decl_stmt|;
name|boolean
name|isPartitioned
init|=
name|tbl
operator|.
name|isPartitioned
argument_list|()
decl_stmt|;
name|String
name|partitionCols
init|=
literal|""
decl_stmt|;
if|if
condition|(
name|isPartitioned
condition|)
name|partitionCols
operator|=
name|MetaStoreUtils
operator|.
name|getDDLFromFieldSchema
argument_list|(
literal|"partition_columns"
argument_list|,
name|tbl
operator|.
name|getPartCols
argument_list|()
argument_list|)
expr_stmt|;
name|outStream
operator|.
name|writeBytes
argument_list|(
literal|"tableName:"
operator|+
name|tableName
argument_list|)
expr_stmt|;
name|outStream
operator|.
name|write
argument_list|(
name|terminator
argument_list|)
expr_stmt|;
name|outStream
operator|.
name|writeBytes
argument_list|(
literal|"owner:"
operator|+
name|owner
argument_list|)
expr_stmt|;
name|outStream
operator|.
name|write
argument_list|(
name|terminator
argument_list|)
expr_stmt|;
name|outStream
operator|.
name|writeBytes
argument_list|(
literal|"location:"
operator|+
name|tblLoc
argument_list|)
expr_stmt|;
name|outStream
operator|.
name|write
argument_list|(
name|terminator
argument_list|)
expr_stmt|;
name|outStream
operator|.
name|writeBytes
argument_list|(
literal|"inputformat:"
operator|+
name|inputFormattCls
argument_list|)
expr_stmt|;
name|outStream
operator|.
name|write
argument_list|(
name|terminator
argument_list|)
expr_stmt|;
name|outStream
operator|.
name|writeBytes
argument_list|(
literal|"outputformat:"
operator|+
name|outputFormattCls
argument_list|)
expr_stmt|;
name|outStream
operator|.
name|write
argument_list|(
name|terminator
argument_list|)
expr_stmt|;
name|outStream
operator|.
name|writeBytes
argument_list|(
literal|"columns:"
operator|+
name|ddlCols
argument_list|)
expr_stmt|;
name|outStream
operator|.
name|write
argument_list|(
name|terminator
argument_list|)
expr_stmt|;
name|outStream
operator|.
name|writeBytes
argument_list|(
literal|"partitioned:"
operator|+
name|isPartitioned
argument_list|)
expr_stmt|;
name|outStream
operator|.
name|write
argument_list|(
name|terminator
argument_list|)
expr_stmt|;
name|outStream
operator|.
name|writeBytes
argument_list|(
literal|"partitionColumns:"
operator|+
name|partitionCols
argument_list|)
expr_stmt|;
name|outStream
operator|.
name|write
argument_list|(
name|terminator
argument_list|)
expr_stmt|;
comment|// output file system information
name|Path
name|tablLoc
init|=
name|tbl
operator|.
name|getPath
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|Path
argument_list|>
name|locations
init|=
operator|new
name|ArrayList
argument_list|<
name|Path
argument_list|>
argument_list|()
decl_stmt|;
if|if
condition|(
name|isPartitioned
condition|)
block|{
if|if
condition|(
name|par
operator|==
literal|null
condition|)
block|{
name|List
argument_list|<
name|Partition
argument_list|>
name|parts
init|=
name|db
operator|.
name|getPartitions
argument_list|(
name|tbl
argument_list|)
decl_stmt|;
for|for
control|(
name|Partition
name|curPart
range|:
name|parts
control|)
name|locations
operator|.
name|add
argument_list|(
operator|new
name|Path
argument_list|(
name|curPart
operator|.
name|getTPartition
argument_list|()
operator|.
name|getSd
argument_list|()
operator|.
name|getLocation
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|locations
operator|.
name|add
argument_list|(
operator|new
name|Path
argument_list|(
name|par
operator|.
name|getTPartition
argument_list|()
operator|.
name|getSd
argument_list|()
operator|.
name|getLocation
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|locations
operator|.
name|add
argument_list|(
name|tablLoc
argument_list|)
expr_stmt|;
block|}
name|writeFileSystemStats
argument_list|(
name|outStream
argument_list|,
name|locations
argument_list|,
name|tablLoc
argument_list|,
literal|false
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|outStream
operator|.
name|write
argument_list|(
name|terminator
argument_list|)
expr_stmt|;
block|}
operator|(
operator|(
name|FSDataOutputStream
operator|)
name|outStream
operator|)
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|FileNotFoundException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"show table status: "
operator|+
name|StringUtils
operator|.
name|stringifyException
argument_list|(
name|e
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"show table status: "
operator|+
name|StringUtils
operator|.
name|stringifyException
argument_list|(
name|e
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|HiveException
argument_list|(
name|e
operator|.
name|toString
argument_list|()
argument_list|)
throw|;
block|}
return|return
literal|0
return|;
block|}
comment|/**    * Write the description of a table to a file.    *    * @param db The database in question.    * @param descTbl This is the table we're interested in.    * @return Returns 0 when execution succeeds and above 0 if it fails.    * @throws HiveException Throws this exception if an unexpected error occurs.    */
specifier|private
name|int
name|describeTable
parameter_list|(
name|Hive
name|db
parameter_list|,
name|descTableDesc
name|descTbl
parameter_list|)
throws|throws
name|HiveException
block|{
name|String
name|colPath
init|=
name|descTbl
operator|.
name|getTableName
argument_list|()
decl_stmt|;
name|String
name|tableName
init|=
name|colPath
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|colPath
operator|.
name|indexOf
argument_list|(
literal|'.'
argument_list|)
operator|==
operator|-
literal|1
condition|?
name|colPath
operator|.
name|length
argument_list|()
else|:
name|colPath
operator|.
name|indexOf
argument_list|(
literal|'.'
argument_list|)
argument_list|)
decl_stmt|;
comment|// describe the table - populate the output stream
name|Table
name|tbl
init|=
name|db
operator|.
name|getTable
argument_list|(
name|MetaStoreUtils
operator|.
name|DEFAULT_DATABASE_NAME
argument_list|,
name|tableName
argument_list|,
literal|false
argument_list|)
decl_stmt|;
name|Partition
name|part
init|=
literal|null
decl_stmt|;
try|try
block|{
if|if
condition|(
name|tbl
operator|==
literal|null
condition|)
block|{
name|FileSystem
name|fs
init|=
name|descTbl
operator|.
name|getResFile
argument_list|()
operator|.
name|getFileSystem
argument_list|(
name|conf
argument_list|)
decl_stmt|;
name|DataOutput
name|outStream
init|=
operator|(
name|DataOutput
operator|)
name|fs
operator|.
name|open
argument_list|(
name|descTbl
operator|.
name|getResFile
argument_list|()
argument_list|)
decl_stmt|;
name|String
name|errMsg
init|=
literal|"Table "
operator|+
name|tableName
operator|+
literal|" does not exist"
decl_stmt|;
name|outStream
operator|.
name|write
argument_list|(
name|errMsg
operator|.
name|getBytes
argument_list|(
literal|"UTF-8"
argument_list|)
argument_list|)
expr_stmt|;
operator|(
operator|(
name|FSDataOutputStream
operator|)
name|outStream
operator|)
operator|.
name|close
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|descTbl
operator|.
name|getPartSpec
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|part
operator|=
name|db
operator|.
name|getPartition
argument_list|(
name|tbl
argument_list|,
name|descTbl
operator|.
name|getPartSpec
argument_list|()
argument_list|,
literal|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|part
operator|==
literal|null
condition|)
block|{
name|FileSystem
name|fs
init|=
name|descTbl
operator|.
name|getResFile
argument_list|()
operator|.
name|getFileSystem
argument_list|(
name|conf
argument_list|)
decl_stmt|;
name|DataOutput
name|outStream
init|=
operator|(
name|DataOutput
operator|)
name|fs
operator|.
name|open
argument_list|(
name|descTbl
operator|.
name|getResFile
argument_list|()
argument_list|)
decl_stmt|;
name|String
name|errMsg
init|=
literal|"Partition "
operator|+
name|descTbl
operator|.
name|getPartSpec
argument_list|()
operator|+
literal|" for table "
operator|+
name|tableName
operator|+
literal|" does not exist"
decl_stmt|;
name|outStream
operator|.
name|write
argument_list|(
name|errMsg
operator|.
name|getBytes
argument_list|(
literal|"UTF-8"
argument_list|)
argument_list|)
expr_stmt|;
operator|(
operator|(
name|FSDataOutputStream
operator|)
name|outStream
operator|)
operator|.
name|close
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
name|tbl
operator|=
name|part
operator|.
name|getTable
argument_list|()
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|FileNotFoundException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"describe table: "
operator|+
name|StringUtils
operator|.
name|stringifyException
argument_list|(
name|e
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"describe table: "
operator|+
name|StringUtils
operator|.
name|stringifyException
argument_list|(
name|e
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
try|try
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"DDLTask: got data for "
operator|+
name|tbl
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|FieldSchema
argument_list|>
name|cols
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|colPath
operator|.
name|equals
argument_list|(
name|tableName
argument_list|)
condition|)
block|{
name|cols
operator|=
name|tbl
operator|.
name|getCols
argument_list|()
expr_stmt|;
if|if
condition|(
name|part
operator|!=
literal|null
condition|)
block|{
name|cols
operator|=
name|part
operator|.
name|getTPartition
argument_list|()
operator|.
name|getSd
argument_list|()
operator|.
name|getCols
argument_list|()
expr_stmt|;
block|}
block|}
else|else
block|{
name|cols
operator|=
name|Hive
operator|.
name|getFieldsFromDeserializer
argument_list|(
name|colPath
argument_list|,
name|tbl
operator|.
name|getDeserializer
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|FileSystem
name|fs
init|=
name|descTbl
operator|.
name|getResFile
argument_list|()
operator|.
name|getFileSystem
argument_list|(
name|conf
argument_list|)
decl_stmt|;
name|DataOutput
name|outStream
init|=
operator|(
name|DataOutput
operator|)
name|fs
operator|.
name|create
argument_list|(
name|descTbl
operator|.
name|getResFile
argument_list|()
argument_list|)
decl_stmt|;
name|Iterator
argument_list|<
name|FieldSchema
argument_list|>
name|iterCols
init|=
name|cols
operator|.
name|iterator
argument_list|()
decl_stmt|;
while|while
condition|(
name|iterCols
operator|.
name|hasNext
argument_list|()
condition|)
block|{
comment|// create a row per column
name|FieldSchema
name|col
init|=
name|iterCols
operator|.
name|next
argument_list|()
decl_stmt|;
name|outStream
operator|.
name|writeBytes
argument_list|(
name|col
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
name|outStream
operator|.
name|write
argument_list|(
name|separator
argument_list|)
expr_stmt|;
name|outStream
operator|.
name|writeBytes
argument_list|(
name|col
operator|.
name|getType
argument_list|()
argument_list|)
expr_stmt|;
name|outStream
operator|.
name|write
argument_list|(
name|separator
argument_list|)
expr_stmt|;
name|outStream
operator|.
name|writeBytes
argument_list|(
name|col
operator|.
name|getComment
argument_list|()
operator|==
literal|null
condition|?
literal|""
else|:
name|col
operator|.
name|getComment
argument_list|()
argument_list|)
expr_stmt|;
name|outStream
operator|.
name|write
argument_list|(
name|terminator
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|tableName
operator|.
name|equals
argument_list|(
name|colPath
argument_list|)
condition|)
block|{
comment|// also return the partitioning columns
name|List
argument_list|<
name|FieldSchema
argument_list|>
name|partCols
init|=
name|tbl
operator|.
name|getPartCols
argument_list|()
decl_stmt|;
name|Iterator
argument_list|<
name|FieldSchema
argument_list|>
name|iterPartCols
init|=
name|partCols
operator|.
name|iterator
argument_list|()
decl_stmt|;
while|while
condition|(
name|iterPartCols
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|FieldSchema
name|col
init|=
name|iterPartCols
operator|.
name|next
argument_list|()
decl_stmt|;
name|outStream
operator|.
name|writeBytes
argument_list|(
name|col
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
name|outStream
operator|.
name|write
argument_list|(
name|separator
argument_list|)
expr_stmt|;
name|outStream
operator|.
name|writeBytes
argument_list|(
name|col
operator|.
name|getType
argument_list|()
argument_list|)
expr_stmt|;
name|outStream
operator|.
name|write
argument_list|(
name|separator
argument_list|)
expr_stmt|;
name|outStream
operator|.
name|writeBytes
argument_list|(
name|col
operator|.
name|getComment
argument_list|()
operator|==
literal|null
condition|?
literal|""
else|:
name|col
operator|.
name|getComment
argument_list|()
argument_list|)
expr_stmt|;
name|outStream
operator|.
name|write
argument_list|(
name|terminator
argument_list|)
expr_stmt|;
block|}
comment|// if extended desc table then show the complete details of the table
if|if
condition|(
name|descTbl
operator|.
name|isExt
argument_list|()
condition|)
block|{
comment|// add empty line
name|outStream
operator|.
name|write
argument_list|(
name|terminator
argument_list|)
expr_stmt|;
if|if
condition|(
name|part
operator|!=
literal|null
condition|)
block|{
comment|// show partition information
name|outStream
operator|.
name|writeBytes
argument_list|(
literal|"Detailed Partition Information"
argument_list|)
expr_stmt|;
name|outStream
operator|.
name|write
argument_list|(
name|separator
argument_list|)
expr_stmt|;
name|outStream
operator|.
name|writeBytes
argument_list|(
name|part
operator|.
name|getTPartition
argument_list|()
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|outStream
operator|.
name|write
argument_list|(
name|separator
argument_list|)
expr_stmt|;
comment|// comment column is empty
name|outStream
operator|.
name|write
argument_list|(
name|terminator
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// show table information
name|outStream
operator|.
name|writeBytes
argument_list|(
literal|"Detailed Table Information"
argument_list|)
expr_stmt|;
name|outStream
operator|.
name|write
argument_list|(
name|separator
argument_list|)
expr_stmt|;
name|outStream
operator|.
name|writeBytes
argument_list|(
name|tbl
operator|.
name|getTTable
argument_list|()
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|outStream
operator|.
name|write
argument_list|(
name|separator
argument_list|)
expr_stmt|;
comment|// comment column is empty
name|outStream
operator|.
name|write
argument_list|(
name|terminator
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"DDLTask: written data for "
operator|+
name|tbl
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
operator|(
operator|(
name|FSDataOutputStream
operator|)
name|outStream
operator|)
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|FileNotFoundException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"describe table: "
operator|+
name|StringUtils
operator|.
name|stringifyException
argument_list|(
name|e
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"describe table: "
operator|+
name|StringUtils
operator|.
name|stringifyException
argument_list|(
name|e
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|HiveException
argument_list|(
name|e
operator|.
name|toString
argument_list|()
argument_list|)
throw|;
block|}
return|return
literal|0
return|;
block|}
specifier|private
name|void
name|writeFileSystemStats
parameter_list|(
name|DataOutput
name|outStream
parameter_list|,
name|List
argument_list|<
name|Path
argument_list|>
name|locations
parameter_list|,
name|Path
name|tabLoc
parameter_list|,
name|boolean
name|partSpecified
parameter_list|,
name|int
name|indent
parameter_list|)
throws|throws
name|IOException
block|{
name|long
name|totalFileSize
init|=
literal|0
decl_stmt|;
name|long
name|maxFileSize
init|=
literal|0
decl_stmt|;
name|long
name|minFileSize
init|=
name|Long
operator|.
name|MAX_VALUE
decl_stmt|;
name|long
name|lastAccessTime
init|=
literal|0
decl_stmt|;
name|long
name|lastUpdateTime
init|=
literal|0
decl_stmt|;
name|int
name|numOfFiles
init|=
literal|0
decl_stmt|;
name|boolean
name|unknown
init|=
literal|false
decl_stmt|;
name|FileSystem
name|fs
init|=
name|tabLoc
operator|.
name|getFileSystem
argument_list|(
name|conf
argument_list|)
decl_stmt|;
comment|// in case all files in locations do not exist
try|try
block|{
name|FileStatus
name|tmpStatus
init|=
name|fs
operator|.
name|getFileStatus
argument_list|(
name|tabLoc
argument_list|)
decl_stmt|;
name|lastAccessTime
operator|=
name|ShimLoader
operator|.
name|getHadoopShims
argument_list|()
operator|.
name|getAccessTime
argument_list|(
name|tmpStatus
argument_list|)
expr_stmt|;
name|lastUpdateTime
operator|=
name|tmpStatus
operator|.
name|getModificationTime
argument_list|()
expr_stmt|;
if|if
condition|(
name|partSpecified
condition|)
block|{
comment|// check whether the part exists or not in fs
name|tmpStatus
operator|=
name|fs
operator|.
name|getFileStatus
argument_list|(
name|locations
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Cannot access File System. File System status will be unknown: "
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|unknown
operator|=
literal|true
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|unknown
condition|)
block|{
for|for
control|(
name|Path
name|loc
range|:
name|locations
control|)
block|{
try|try
block|{
name|FileStatus
name|status
init|=
name|fs
operator|.
name|getFileStatus
argument_list|(
name|tabLoc
argument_list|)
decl_stmt|;
name|FileStatus
index|[]
name|files
init|=
name|fs
operator|.
name|listStatus
argument_list|(
name|loc
argument_list|)
decl_stmt|;
name|long
name|accessTime
init|=
name|ShimLoader
operator|.
name|getHadoopShims
argument_list|()
operator|.
name|getAccessTime
argument_list|(
name|status
argument_list|)
decl_stmt|;
name|long
name|updateTime
init|=
name|status
operator|.
name|getModificationTime
argument_list|()
decl_stmt|;
comment|// no matter loc is the table location or part location, it must be a
comment|// directory.
if|if
condition|(
operator|!
name|status
operator|.
name|isDir
argument_list|()
condition|)
continue|continue;
if|if
condition|(
name|accessTime
operator|>
name|lastAccessTime
condition|)
name|lastAccessTime
operator|=
name|accessTime
expr_stmt|;
if|if
condition|(
name|updateTime
operator|>
name|lastUpdateTime
condition|)
name|lastUpdateTime
operator|=
name|updateTime
expr_stmt|;
for|for
control|(
name|FileStatus
name|currentStatus
range|:
name|files
control|)
block|{
if|if
condition|(
name|currentStatus
operator|.
name|isDir
argument_list|()
condition|)
continue|continue;
name|numOfFiles
operator|++
expr_stmt|;
name|long
name|fileLen
init|=
name|currentStatus
operator|.
name|getLen
argument_list|()
decl_stmt|;
name|totalFileSize
operator|+=
name|fileLen
expr_stmt|;
if|if
condition|(
name|fileLen
operator|>
name|maxFileSize
condition|)
name|maxFileSize
operator|=
name|fileLen
expr_stmt|;
if|if
condition|(
name|fileLen
operator|<
name|minFileSize
condition|)
name|minFileSize
operator|=
name|fileLen
expr_stmt|;
name|accessTime
operator|=
name|ShimLoader
operator|.
name|getHadoopShims
argument_list|()
operator|.
name|getAccessTime
argument_list|(
name|currentStatus
argument_list|)
expr_stmt|;
name|updateTime
operator|=
name|currentStatus
operator|.
name|getModificationTime
argument_list|()
expr_stmt|;
if|if
condition|(
name|accessTime
operator|>
name|lastAccessTime
condition|)
name|lastAccessTime
operator|=
name|accessTime
expr_stmt|;
if|if
condition|(
name|updateTime
operator|>
name|lastUpdateTime
condition|)
name|lastUpdateTime
operator|=
name|updateTime
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
comment|// ignore
block|}
block|}
block|}
name|String
name|unknownString
init|=
literal|"unknown"
decl_stmt|;
for|for
control|(
name|int
name|k
init|=
literal|0
init|;
name|k
operator|<
name|indent
condition|;
name|k
operator|++
control|)
name|outStream
operator|.
name|writeBytes
argument_list|(
name|Utilities
operator|.
name|INDENT
argument_list|)
expr_stmt|;
name|outStream
operator|.
name|writeBytes
argument_list|(
literal|"totalNumberFiles:"
argument_list|)
expr_stmt|;
name|outStream
operator|.
name|writeBytes
argument_list|(
name|unknown
condition|?
name|unknownString
else|:
literal|""
operator|+
name|numOfFiles
argument_list|)
expr_stmt|;
name|outStream
operator|.
name|write
argument_list|(
name|terminator
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|k
init|=
literal|0
init|;
name|k
operator|<
name|indent
condition|;
name|k
operator|++
control|)
name|outStream
operator|.
name|writeBytes
argument_list|(
name|Utilities
operator|.
name|INDENT
argument_list|)
expr_stmt|;
name|outStream
operator|.
name|writeBytes
argument_list|(
literal|"totalFileSize:"
argument_list|)
expr_stmt|;
name|outStream
operator|.
name|writeBytes
argument_list|(
name|unknown
condition|?
name|unknownString
else|:
literal|""
operator|+
name|totalFileSize
argument_list|)
expr_stmt|;
name|outStream
operator|.
name|write
argument_list|(
name|terminator
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|k
init|=
literal|0
init|;
name|k
operator|<
name|indent
condition|;
name|k
operator|++
control|)
name|outStream
operator|.
name|writeBytes
argument_list|(
name|Utilities
operator|.
name|INDENT
argument_list|)
expr_stmt|;
name|outStream
operator|.
name|writeBytes
argument_list|(
literal|"maxFileSize:"
argument_list|)
expr_stmt|;
name|outStream
operator|.
name|writeBytes
argument_list|(
name|unknown
condition|?
name|unknownString
else|:
literal|""
operator|+
name|maxFileSize
argument_list|)
expr_stmt|;
name|outStream
operator|.
name|write
argument_list|(
name|terminator
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|k
init|=
literal|0
init|;
name|k
operator|<
name|indent
condition|;
name|k
operator|++
control|)
name|outStream
operator|.
name|writeBytes
argument_list|(
name|Utilities
operator|.
name|INDENT
argument_list|)
expr_stmt|;
name|outStream
operator|.
name|writeBytes
argument_list|(
literal|"minFileSize:"
argument_list|)
expr_stmt|;
if|if
condition|(
name|numOfFiles
operator|>
literal|0
condition|)
name|outStream
operator|.
name|writeBytes
argument_list|(
name|unknown
condition|?
name|unknownString
else|:
literal|""
operator|+
name|minFileSize
argument_list|)
expr_stmt|;
else|else
name|outStream
operator|.
name|writeBytes
argument_list|(
name|unknown
condition|?
name|unknownString
else|:
literal|""
operator|+
literal|0
argument_list|)
expr_stmt|;
name|outStream
operator|.
name|write
argument_list|(
name|terminator
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|k
init|=
literal|0
init|;
name|k
operator|<
name|indent
condition|;
name|k
operator|++
control|)
name|outStream
operator|.
name|writeBytes
argument_list|(
name|Utilities
operator|.
name|INDENT
argument_list|)
expr_stmt|;
name|outStream
operator|.
name|writeBytes
argument_list|(
literal|"lastAccessTime:"
argument_list|)
expr_stmt|;
name|outStream
operator|.
name|writeBytes
argument_list|(
operator|(
name|unknown
operator|||
name|lastAccessTime
operator|<
literal|0
operator|)
condition|?
name|unknownString
else|:
literal|""
operator|+
name|lastAccessTime
argument_list|)
expr_stmt|;
name|outStream
operator|.
name|write
argument_list|(
name|terminator
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|k
init|=
literal|0
init|;
name|k
operator|<
name|indent
condition|;
name|k
operator|++
control|)
name|outStream
operator|.
name|writeBytes
argument_list|(
name|Utilities
operator|.
name|INDENT
argument_list|)
expr_stmt|;
name|outStream
operator|.
name|writeBytes
argument_list|(
literal|"lastUpdateTime:"
argument_list|)
expr_stmt|;
name|outStream
operator|.
name|writeBytes
argument_list|(
name|unknown
condition|?
name|unknownString
else|:
literal|""
operator|+
name|lastUpdateTime
argument_list|)
expr_stmt|;
name|outStream
operator|.
name|write
argument_list|(
name|terminator
argument_list|)
expr_stmt|;
block|}
comment|/**    * Alter a given table.    *    * @param db The database in question.    * @param alterTbl This is the table we're altering.    * @return Returns 0 when execution succeeds and above 0 if it fails.    * @throws HiveException Throws this exception if an unexpected error occurs.    */
specifier|private
name|int
name|alterTable
parameter_list|(
name|Hive
name|db
parameter_list|,
name|alterTableDesc
name|alterTbl
parameter_list|)
throws|throws
name|HiveException
block|{
comment|// alter the table
name|Table
name|tbl
init|=
name|db
operator|.
name|getTable
argument_list|(
name|MetaStoreUtils
operator|.
name|DEFAULT_DATABASE_NAME
argument_list|,
name|alterTbl
operator|.
name|getOldName
argument_list|()
argument_list|)
decl_stmt|;
name|Table
name|oldTbl
init|=
name|tbl
operator|.
name|copy
argument_list|()
decl_stmt|;
if|if
condition|(
name|alterTbl
operator|.
name|getOp
argument_list|()
operator|==
name|alterTableDesc
operator|.
name|alterTableTypes
operator|.
name|RENAME
condition|)
block|{
name|tbl
operator|.
name|getTTable
argument_list|()
operator|.
name|setTableName
argument_list|(
name|alterTbl
operator|.
name|getNewName
argument_list|()
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|alterTbl
operator|.
name|getOp
argument_list|()
operator|==
name|alterTableDesc
operator|.
name|alterTableTypes
operator|.
name|ADDCOLS
condition|)
block|{
name|List
argument_list|<
name|FieldSchema
argument_list|>
name|newCols
init|=
name|alterTbl
operator|.
name|getNewCols
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|FieldSchema
argument_list|>
name|oldCols
init|=
name|tbl
operator|.
name|getCols
argument_list|()
decl_stmt|;
if|if
condition|(
name|tbl
operator|.
name|getSerializationLib
argument_list|()
operator|.
name|equals
argument_list|(
literal|"org.apache.hadoop.hive.serde.thrift.columnsetSerDe"
argument_list|)
condition|)
block|{
name|console
operator|.
name|printInfo
argument_list|(
literal|"Replacing columns for columnsetSerDe and changing to LazySimpleSerDe"
argument_list|)
expr_stmt|;
name|tbl
operator|.
name|setSerializationLib
argument_list|(
name|LazySimpleSerDe
operator|.
name|class
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
name|tbl
operator|.
name|getTTable
argument_list|()
operator|.
name|getSd
argument_list|()
operator|.
name|setCols
argument_list|(
name|newCols
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// make sure the columns does not already exist
name|Iterator
argument_list|<
name|FieldSchema
argument_list|>
name|iterNewCols
init|=
name|newCols
operator|.
name|iterator
argument_list|()
decl_stmt|;
while|while
condition|(
name|iterNewCols
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|FieldSchema
name|newCol
init|=
name|iterNewCols
operator|.
name|next
argument_list|()
decl_stmt|;
name|String
name|newColName
init|=
name|newCol
operator|.
name|getName
argument_list|()
decl_stmt|;
name|Iterator
argument_list|<
name|FieldSchema
argument_list|>
name|iterOldCols
init|=
name|oldCols
operator|.
name|iterator
argument_list|()
decl_stmt|;
while|while
condition|(
name|iterOldCols
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|String
name|oldColName
init|=
name|iterOldCols
operator|.
name|next
argument_list|()
operator|.
name|getName
argument_list|()
decl_stmt|;
if|if
condition|(
name|oldColName
operator|.
name|equalsIgnoreCase
argument_list|(
name|newColName
argument_list|)
condition|)
block|{
name|console
operator|.
name|printError
argument_list|(
literal|"Column '"
operator|+
name|newColName
operator|+
literal|"' exists"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
name|oldCols
operator|.
name|add
argument_list|(
name|newCol
argument_list|)
expr_stmt|;
block|}
name|tbl
operator|.
name|getTTable
argument_list|()
operator|.
name|getSd
argument_list|()
operator|.
name|setCols
argument_list|(
name|oldCols
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|alterTbl
operator|.
name|getOp
argument_list|()
operator|==
name|alterTableDesc
operator|.
name|alterTableTypes
operator|.
name|RENAMECOLUMN
condition|)
block|{
name|List
argument_list|<
name|FieldSchema
argument_list|>
name|oldCols
init|=
name|tbl
operator|.
name|getCols
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|FieldSchema
argument_list|>
name|newCols
init|=
operator|new
name|ArrayList
argument_list|<
name|FieldSchema
argument_list|>
argument_list|()
decl_stmt|;
name|Iterator
argument_list|<
name|FieldSchema
argument_list|>
name|iterOldCols
init|=
name|oldCols
operator|.
name|iterator
argument_list|()
decl_stmt|;
name|String
name|oldName
init|=
name|alterTbl
operator|.
name|getOldColName
argument_list|()
decl_stmt|;
name|String
name|newName
init|=
name|alterTbl
operator|.
name|getNewColName
argument_list|()
decl_stmt|;
name|String
name|type
init|=
name|alterTbl
operator|.
name|getNewColType
argument_list|()
decl_stmt|;
name|String
name|comment
init|=
name|alterTbl
operator|.
name|getNewColComment
argument_list|()
decl_stmt|;
name|boolean
name|first
init|=
name|alterTbl
operator|.
name|getFirst
argument_list|()
decl_stmt|;
name|String
name|afterCol
init|=
name|alterTbl
operator|.
name|getAfterCol
argument_list|()
decl_stmt|;
name|FieldSchema
name|column
init|=
literal|null
decl_stmt|;
name|boolean
name|found
init|=
literal|false
decl_stmt|;
name|int
name|position
init|=
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|first
condition|)
name|position
operator|=
literal|0
expr_stmt|;
name|int
name|i
init|=
literal|1
decl_stmt|;
while|while
condition|(
name|iterOldCols
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|FieldSchema
name|col
init|=
name|iterOldCols
operator|.
name|next
argument_list|()
decl_stmt|;
name|String
name|oldColName
init|=
name|col
operator|.
name|getName
argument_list|()
decl_stmt|;
if|if
condition|(
name|oldColName
operator|.
name|equalsIgnoreCase
argument_list|(
name|newName
argument_list|)
operator|&&
operator|!
name|oldColName
operator|.
name|equalsIgnoreCase
argument_list|(
name|oldName
argument_list|)
condition|)
block|{
name|console
operator|.
name|printError
argument_list|(
literal|"Column '"
operator|+
name|newName
operator|+
literal|"' exists"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|oldColName
operator|.
name|equalsIgnoreCase
argument_list|(
name|oldName
argument_list|)
condition|)
block|{
name|col
operator|.
name|setName
argument_list|(
name|newName
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|!=
literal|null
operator|&&
operator|!
name|type
operator|.
name|trim
argument_list|()
operator|.
name|equals
argument_list|(
literal|""
argument_list|)
condition|)
block|{
name|col
operator|.
name|setType
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|comment
operator|!=
literal|null
condition|)
name|col
operator|.
name|setComment
argument_list|(
name|comment
argument_list|)
expr_stmt|;
name|found
operator|=
literal|true
expr_stmt|;
if|if
condition|(
name|first
operator|||
operator|(
name|afterCol
operator|!=
literal|null
operator|&&
operator|!
name|afterCol
operator|.
name|trim
argument_list|()
operator|.
name|equals
argument_list|(
literal|""
argument_list|)
operator|)
condition|)
block|{
name|column
operator|=
name|col
expr_stmt|;
continue|continue;
block|}
block|}
if|if
condition|(
name|afterCol
operator|!=
literal|null
operator|&&
operator|!
name|afterCol
operator|.
name|trim
argument_list|()
operator|.
name|equals
argument_list|(
literal|""
argument_list|)
operator|&&
name|oldColName
operator|.
name|equalsIgnoreCase
argument_list|(
name|afterCol
argument_list|)
condition|)
block|{
name|position
operator|=
name|i
expr_stmt|;
block|}
name|i
operator|++
expr_stmt|;
name|newCols
operator|.
name|add
argument_list|(
name|col
argument_list|)
expr_stmt|;
block|}
comment|//did not find the column
if|if
condition|(
operator|!
name|found
condition|)
block|{
name|console
operator|.
name|printError
argument_list|(
literal|"Column '"
operator|+
name|oldName
operator|+
literal|"' does not exist"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
comment|//after column is not null, but we did not find it.
if|if
condition|(
operator|(
name|afterCol
operator|!=
literal|null
operator|&&
operator|!
name|afterCol
operator|.
name|trim
argument_list|()
operator|.
name|equals
argument_list|(
literal|""
argument_list|)
operator|)
operator|&&
name|position
operator|<
literal|0
condition|)
block|{
name|console
operator|.
name|printError
argument_list|(
literal|"Column '"
operator|+
name|afterCol
operator|+
literal|"' does not exist"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
name|position
operator|>=
literal|0
condition|)
name|newCols
operator|.
name|add
argument_list|(
name|position
argument_list|,
name|column
argument_list|)
expr_stmt|;
name|tbl
operator|.
name|getTTable
argument_list|()
operator|.
name|getSd
argument_list|()
operator|.
name|setCols
argument_list|(
name|newCols
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|alterTbl
operator|.
name|getOp
argument_list|()
operator|==
name|alterTableDesc
operator|.
name|alterTableTypes
operator|.
name|REPLACECOLS
condition|)
block|{
comment|// change SerDe to LazySimpleSerDe if it is columnsetSerDe
if|if
condition|(
name|tbl
operator|.
name|getSerializationLib
argument_list|()
operator|.
name|equals
argument_list|(
literal|"org.apache.hadoop.hive.serde.thrift.columnsetSerDe"
argument_list|)
condition|)
block|{
name|console
operator|.
name|printInfo
argument_list|(
literal|"Replacing columns for columnsetSerDe and changing to LazySimpleSerDe"
argument_list|)
expr_stmt|;
name|tbl
operator|.
name|setSerializationLib
argument_list|(
name|LazySimpleSerDe
operator|.
name|class
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|tbl
operator|.
name|getSerializationLib
argument_list|()
operator|.
name|equals
argument_list|(
name|MetadataTypedColumnsetSerDe
operator|.
name|class
operator|.
name|getName
argument_list|()
argument_list|)
operator|&&
operator|!
name|tbl
operator|.
name|getSerializationLib
argument_list|()
operator|.
name|equals
argument_list|(
name|LazySimpleSerDe
operator|.
name|class
operator|.
name|getName
argument_list|()
argument_list|)
operator|&&
operator|!
name|tbl
operator|.
name|getSerializationLib
argument_list|()
operator|.
name|equals
argument_list|(
name|ColumnarSerDe
operator|.
name|class
operator|.
name|getName
argument_list|()
argument_list|)
operator|&&
operator|!
name|tbl
operator|.
name|getSerializationLib
argument_list|()
operator|.
name|equals
argument_list|(
name|DynamicSerDe
operator|.
name|class
operator|.
name|getName
argument_list|()
argument_list|)
condition|)
block|{
name|console
operator|.
name|printError
argument_list|(
literal|"Replace columns is not supported for this table. SerDe may be incompatible."
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
name|tbl
operator|.
name|getTTable
argument_list|()
operator|.
name|getSd
argument_list|()
operator|.
name|setCols
argument_list|(
name|alterTbl
operator|.
name|getNewCols
argument_list|()
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|alterTbl
operator|.
name|getOp
argument_list|()
operator|==
name|alterTableDesc
operator|.
name|alterTableTypes
operator|.
name|ADDPROPS
condition|)
block|{
name|tbl
operator|.
name|getTTable
argument_list|()
operator|.
name|getParameters
argument_list|()
operator|.
name|putAll
argument_list|(
name|alterTbl
operator|.
name|getProps
argument_list|()
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|alterTbl
operator|.
name|getOp
argument_list|()
operator|==
name|alterTableDesc
operator|.
name|alterTableTypes
operator|.
name|ADDSERDEPROPS
condition|)
block|{
name|tbl
operator|.
name|getTTable
argument_list|()
operator|.
name|getSd
argument_list|()
operator|.
name|getSerdeInfo
argument_list|()
operator|.
name|getParameters
argument_list|()
operator|.
name|putAll
argument_list|(
name|alterTbl
operator|.
name|getProps
argument_list|()
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|alterTbl
operator|.
name|getOp
argument_list|()
operator|==
name|alterTableDesc
operator|.
name|alterTableTypes
operator|.
name|ADDSERDE
condition|)
block|{
name|tbl
operator|.
name|setSerializationLib
argument_list|(
name|alterTbl
operator|.
name|getSerdeName
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|alterTbl
operator|.
name|getProps
argument_list|()
operator|!=
literal|null
operator|)
operator|&&
operator|(
name|alterTbl
operator|.
name|getProps
argument_list|()
operator|.
name|size
argument_list|()
operator|>
literal|0
operator|)
condition|)
name|tbl
operator|.
name|getTTable
argument_list|()
operator|.
name|getSd
argument_list|()
operator|.
name|getSerdeInfo
argument_list|()
operator|.
name|getParameters
argument_list|()
operator|.
name|putAll
argument_list|(
name|alterTbl
operator|.
name|getProps
argument_list|()
argument_list|)
expr_stmt|;
comment|// since serde is modified then do the appropriate things to reset columns
comment|// etc
name|tbl
operator|.
name|reinitSerDe
argument_list|()
expr_stmt|;
name|tbl
operator|.
name|setFields
argument_list|(
name|Hive
operator|.
name|getFieldsFromDeserializer
argument_list|(
name|tbl
operator|.
name|getName
argument_list|()
argument_list|,
name|tbl
operator|.
name|getDeserializer
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|alterTbl
operator|.
name|getOp
argument_list|()
operator|==
name|alterTableDesc
operator|.
name|alterTableTypes
operator|.
name|ADDFILEFORMAT
condition|)
block|{
name|tbl
operator|.
name|getTTable
argument_list|()
operator|.
name|getSd
argument_list|()
operator|.
name|setInputFormat
argument_list|(
name|alterTbl
operator|.
name|getInputFormat
argument_list|()
argument_list|)
expr_stmt|;
name|tbl
operator|.
name|getTTable
argument_list|()
operator|.
name|getSd
argument_list|()
operator|.
name|setOutputFormat
argument_list|(
name|alterTbl
operator|.
name|getOutputFormat
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|alterTbl
operator|.
name|getSerdeName
argument_list|()
operator|!=
literal|null
condition|)
name|tbl
operator|.
name|setSerializationLib
argument_list|(
name|alterTbl
operator|.
name|getSerdeName
argument_list|()
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|alterTbl
operator|.
name|getOp
argument_list|()
operator|==
name|alterTableDesc
operator|.
name|alterTableTypes
operator|.
name|ADDCLUSTERSORTCOLUMN
condition|)
block|{
comment|//validate sort columns and bucket columns
name|List
argument_list|<
name|String
argument_list|>
name|columns
init|=
name|Utilities
operator|.
name|getColumnNamesFromFieldSchema
argument_list|(
name|tbl
operator|.
name|getCols
argument_list|()
argument_list|)
decl_stmt|;
name|Utilities
operator|.
name|validateColumnNames
argument_list|(
name|columns
argument_list|,
name|alterTbl
operator|.
name|getBucketColumns
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|alterTbl
operator|.
name|getSortColumns
argument_list|()
operator|!=
literal|null
condition|)
name|Utilities
operator|.
name|validateColumnNames
argument_list|(
name|columns
argument_list|,
name|Utilities
operator|.
name|getColumnNamesFromSortCols
argument_list|(
name|alterTbl
operator|.
name|getSortColumns
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|tbl
operator|.
name|getTTable
argument_list|()
operator|.
name|getSd
argument_list|()
operator|.
name|setBucketCols
argument_list|(
name|alterTbl
operator|.
name|getBucketColumns
argument_list|()
argument_list|)
expr_stmt|;
name|tbl
operator|.
name|getTTable
argument_list|()
operator|.
name|getSd
argument_list|()
operator|.
name|setNumBuckets
argument_list|(
name|alterTbl
operator|.
name|getNumberBuckets
argument_list|()
argument_list|)
expr_stmt|;
name|tbl
operator|.
name|getTTable
argument_list|()
operator|.
name|getSd
argument_list|()
operator|.
name|setSortCols
argument_list|(
name|alterTbl
operator|.
name|getSortColumns
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|console
operator|.
name|printError
argument_list|(
literal|"Unsupported Alter commnad"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
comment|// set last modified by properties
try|try
block|{
name|tbl
operator|.
name|setProperty
argument_list|(
literal|"last_modified_by"
argument_list|,
name|conf
operator|.
name|getUser
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|console
operator|.
name|printError
argument_list|(
literal|"Unable to get current user: "
operator|+
name|e
operator|.
name|getMessage
argument_list|()
argument_list|,
name|StringUtils
operator|.
name|stringifyException
argument_list|(
name|e
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
name|tbl
operator|.
name|setProperty
argument_list|(
literal|"last_modified_time"
argument_list|,
name|Long
operator|.
name|toString
argument_list|(
name|System
operator|.
name|currentTimeMillis
argument_list|()
operator|/
literal|1000
argument_list|)
argument_list|)
expr_stmt|;
try|try
block|{
name|tbl
operator|.
name|checkValidity
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|HiveException
name|e
parameter_list|)
block|{
name|console
operator|.
name|printError
argument_list|(
literal|"Invalid table columns : "
operator|+
name|e
operator|.
name|getMessage
argument_list|()
argument_list|,
name|StringUtils
operator|.
name|stringifyException
argument_list|(
name|e
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
try|try
block|{
name|db
operator|.
name|alterTable
argument_list|(
name|alterTbl
operator|.
name|getOldName
argument_list|()
argument_list|,
name|tbl
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InvalidOperationException
name|e
parameter_list|)
block|{
name|console
operator|.
name|printError
argument_list|(
literal|"Invalid alter operation: "
operator|+
name|e
operator|.
name|getMessage
argument_list|()
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"alter table: "
operator|+
name|StringUtils
operator|.
name|stringifyException
argument_list|(
name|e
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
catch|catch
parameter_list|(
name|HiveException
name|e
parameter_list|)
block|{
return|return
literal|1
return|;
block|}
comment|// This is kind of hacky - the read entity contains the old table, whereas the write entity
comment|// contains the new table. This is needed for rename - both the old and the new table names are
comment|// passed
name|work
operator|.
name|getInputs
argument_list|()
operator|.
name|add
argument_list|(
operator|new
name|ReadEntity
argument_list|(
name|oldTbl
argument_list|)
argument_list|)
expr_stmt|;
name|work
operator|.
name|getOutputs
argument_list|()
operator|.
name|add
argument_list|(
operator|new
name|WriteEntity
argument_list|(
name|tbl
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/**    * Drop a given table.    *    * @param db The database in question.    * @param dropTbl This is the table we're dropping.    * @return Returns 0 when execution succeeds and above 0 if it fails.    * @throws HiveException Throws this exception if an unexpected error occurs.    */
specifier|private
name|int
name|dropTable
parameter_list|(
name|Hive
name|db
parameter_list|,
name|dropTableDesc
name|dropTbl
parameter_list|)
throws|throws
name|HiveException
block|{
comment|// We need to fetch the table before it is dropped so that it can be passed to
comment|// post-execution hook
name|Table
name|tbl
init|=
literal|null
decl_stmt|;
try|try
block|{
name|tbl
operator|=
name|db
operator|.
name|getTable
argument_list|(
name|MetaStoreUtils
operator|.
name|DEFAULT_DATABASE_NAME
argument_list|,
name|dropTbl
operator|.
name|getTableName
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InvalidTableException
name|e
parameter_list|)
block|{
comment|// drop table is idempotent
block|}
if|if
condition|(
name|dropTbl
operator|.
name|getPartSpecs
argument_list|()
operator|==
literal|null
condition|)
block|{
comment|// drop the table
name|db
operator|.
name|dropTable
argument_list|(
name|MetaStoreUtils
operator|.
name|DEFAULT_DATABASE_NAME
argument_list|,
name|dropTbl
operator|.
name|getTableName
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|tbl
operator|!=
literal|null
condition|)
name|work
operator|.
name|getOutputs
argument_list|()
operator|.
name|add
argument_list|(
operator|new
name|WriteEntity
argument_list|(
name|tbl
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// get all partitions of the table
name|List
argument_list|<
name|String
argument_list|>
name|partitionNames
init|=
name|db
operator|.
name|getPartitionNames
argument_list|(
name|MetaStoreUtils
operator|.
name|DEFAULT_DATABASE_NAME
argument_list|,
name|dropTbl
operator|.
name|getTableName
argument_list|()
argument_list|,
operator|(
name|short
operator|)
operator|-
literal|1
argument_list|)
decl_stmt|;
name|Set
argument_list|<
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
argument_list|>
name|partitions
init|=
operator|new
name|HashSet
argument_list|<
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|partitionNames
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
try|try
block|{
name|partitions
operator|.
name|add
argument_list|(
name|Warehouse
operator|.
name|makeSpecFromName
argument_list|(
name|partitionNames
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|MetaException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Unrecognized partition name from metastore: "
operator|+
name|partitionNames
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|// drop partitions in the list
name|List
argument_list|<
name|Partition
argument_list|>
name|partsToDelete
init|=
operator|new
name|ArrayList
argument_list|<
name|Partition
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|partSpec
range|:
name|dropTbl
operator|.
name|getPartSpecs
argument_list|()
control|)
block|{
name|Iterator
argument_list|<
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
argument_list|>
name|it
init|=
name|partitions
operator|.
name|iterator
argument_list|()
decl_stmt|;
while|while
condition|(
name|it
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|part
init|=
name|it
operator|.
name|next
argument_list|()
decl_stmt|;
comment|// test if partSpec matches part
name|boolean
name|match
init|=
literal|true
decl_stmt|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|item
range|:
name|partSpec
operator|.
name|entrySet
argument_list|()
control|)
block|{
if|if
condition|(
operator|!
name|item
operator|.
name|getValue
argument_list|()
operator|.
name|equals
argument_list|(
name|part
operator|.
name|get
argument_list|(
name|item
operator|.
name|getKey
argument_list|()
argument_list|)
argument_list|)
condition|)
block|{
name|match
operator|=
literal|false
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|match
condition|)
block|{
name|partsToDelete
operator|.
name|add
argument_list|(
name|db
operator|.
name|getPartition
argument_list|(
name|tbl
argument_list|,
name|part
argument_list|,
literal|false
argument_list|)
argument_list|)
expr_stmt|;
name|it
operator|.
name|remove
argument_list|()
expr_stmt|;
block|}
block|}
block|}
comment|// drop all existing partitions from the list
for|for
control|(
name|Partition
name|partition
range|:
name|partsToDelete
control|)
block|{
name|console
operator|.
name|printInfo
argument_list|(
literal|"Dropping the partition "
operator|+
name|partition
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
name|db
operator|.
name|dropPartition
argument_list|(
name|MetaStoreUtils
operator|.
name|DEFAULT_DATABASE_NAME
argument_list|,
name|dropTbl
operator|.
name|getTableName
argument_list|()
argument_list|,
name|partition
operator|.
name|getValues
argument_list|()
argument_list|,
literal|true
argument_list|)
expr_stmt|;
comment|// drop data for the
comment|// partition
name|work
operator|.
name|getOutputs
argument_list|()
operator|.
name|add
argument_list|(
operator|new
name|WriteEntity
argument_list|(
name|partition
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return
literal|0
return|;
block|}
comment|/**    * Check if the given serde is valid    */
specifier|private
name|void
name|validateSerDe
parameter_list|(
name|String
name|serdeName
parameter_list|)
throws|throws
name|HiveException
block|{
try|try
block|{
name|Deserializer
name|d
init|=
name|SerDeUtils
operator|.
name|lookupDeserializer
argument_list|(
name|serdeName
argument_list|)
decl_stmt|;
if|if
condition|(
name|d
operator|!=
literal|null
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"Found class for "
operator|+
name|serdeName
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|SerDeException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|HiveException
argument_list|(
literal|"Cannot validate serde: "
operator|+
name|serdeName
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
comment|/**    * Create a new table.    *    * @param db The database in question.    * @param crtTbl This is the table we're creating.    * @return Returns 0 when execution succeeds and above 0 if it fails.    * @throws HiveException Throws this exception if an unexpected error occurs.    */
specifier|private
name|int
name|createTable
parameter_list|(
name|Hive
name|db
parameter_list|,
name|createTableDesc
name|crtTbl
parameter_list|)
throws|throws
name|HiveException
block|{
comment|// create the table
name|Table
name|tbl
init|=
operator|new
name|Table
argument_list|(
name|crtTbl
operator|.
name|getTableName
argument_list|()
argument_list|)
decl_stmt|;
name|StorageDescriptor
name|tblStorDesc
init|=
name|tbl
operator|.
name|getTTable
argument_list|()
operator|.
name|getSd
argument_list|()
decl_stmt|;
if|if
condition|(
name|crtTbl
operator|.
name|getBucketCols
argument_list|()
operator|!=
literal|null
condition|)
name|tblStorDesc
operator|.
name|setBucketCols
argument_list|(
name|crtTbl
operator|.
name|getBucketCols
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|crtTbl
operator|.
name|getSortCols
argument_list|()
operator|!=
literal|null
condition|)
name|tbl
operator|.
name|setSortCols
argument_list|(
name|crtTbl
operator|.
name|getSortCols
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|crtTbl
operator|.
name|getPartCols
argument_list|()
operator|!=
literal|null
condition|)
name|tbl
operator|.
name|setPartCols
argument_list|(
name|crtTbl
operator|.
name|getPartCols
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|crtTbl
operator|.
name|getNumBuckets
argument_list|()
operator|!=
operator|-
literal|1
condition|)
name|tblStorDesc
operator|.
name|setNumBuckets
argument_list|(
name|crtTbl
operator|.
name|getNumBuckets
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|crtTbl
operator|.
name|getSerName
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|tbl
operator|.
name|setSerializationLib
argument_list|(
name|crtTbl
operator|.
name|getSerName
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|crtTbl
operator|.
name|getMapProp
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|Iterator
argument_list|<
name|Entry
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
argument_list|>
name|iter
init|=
name|crtTbl
operator|.
name|getMapProp
argument_list|()
operator|.
name|entrySet
argument_list|()
operator|.
name|iterator
argument_list|()
decl_stmt|;
while|while
condition|(
name|iter
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|Entry
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|m
init|=
operator|(
name|Entry
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
operator|)
name|iter
operator|.
name|next
argument_list|()
decl_stmt|;
name|tbl
operator|.
name|setSerdeParam
argument_list|(
name|m
operator|.
name|getKey
argument_list|()
argument_list|,
name|m
operator|.
name|getValue
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
if|if
condition|(
name|crtTbl
operator|.
name|getFieldDelim
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|tbl
operator|.
name|setSerdeParam
argument_list|(
name|Constants
operator|.
name|FIELD_DELIM
argument_list|,
name|crtTbl
operator|.
name|getFieldDelim
argument_list|()
argument_list|)
expr_stmt|;
name|tbl
operator|.
name|setSerdeParam
argument_list|(
name|Constants
operator|.
name|SERIALIZATION_FORMAT
argument_list|,
name|crtTbl
operator|.
name|getFieldDelim
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|crtTbl
operator|.
name|getFieldEscape
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|tbl
operator|.
name|setSerdeParam
argument_list|(
name|Constants
operator|.
name|ESCAPE_CHAR
argument_list|,
name|crtTbl
operator|.
name|getFieldEscape
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|crtTbl
operator|.
name|getCollItemDelim
argument_list|()
operator|!=
literal|null
condition|)
name|tbl
operator|.
name|setSerdeParam
argument_list|(
name|Constants
operator|.
name|COLLECTION_DELIM
argument_list|,
name|crtTbl
operator|.
name|getCollItemDelim
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|crtTbl
operator|.
name|getMapKeyDelim
argument_list|()
operator|!=
literal|null
condition|)
name|tbl
operator|.
name|setSerdeParam
argument_list|(
name|Constants
operator|.
name|MAPKEY_DELIM
argument_list|,
name|crtTbl
operator|.
name|getMapKeyDelim
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|crtTbl
operator|.
name|getLineDelim
argument_list|()
operator|!=
literal|null
condition|)
name|tbl
operator|.
name|setSerdeParam
argument_list|(
name|Constants
operator|.
name|LINE_DELIM
argument_list|,
name|crtTbl
operator|.
name|getLineDelim
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/**      * We use LazySimpleSerDe by default.      *      * If the user didn't specify a SerDe, and any of the columns are not simple types,      * we will have to use DynamicSerDe instead.      */
if|if
condition|(
name|crtTbl
operator|.
name|getSerName
argument_list|()
operator|==
literal|null
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Default to LazySimpleSerDe for table "
operator|+
name|crtTbl
operator|.
name|getTableName
argument_list|()
argument_list|)
expr_stmt|;
name|tbl
operator|.
name|setSerializationLib
argument_list|(
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|lazy
operator|.
name|LazySimpleSerDe
operator|.
name|class
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// let's validate that the serde exists
name|validateSerDe
argument_list|(
name|crtTbl
operator|.
name|getSerName
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|crtTbl
operator|.
name|getComment
argument_list|()
operator|!=
literal|null
condition|)
name|tbl
operator|.
name|setProperty
argument_list|(
literal|"comment"
argument_list|,
name|crtTbl
operator|.
name|getComment
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|crtTbl
operator|.
name|getLocation
argument_list|()
operator|!=
literal|null
condition|)
name|tblStorDesc
operator|.
name|setLocation
argument_list|(
name|crtTbl
operator|.
name|getLocation
argument_list|()
argument_list|)
expr_stmt|;
name|tbl
operator|.
name|setInputFormatClass
argument_list|(
name|crtTbl
operator|.
name|getInputFormat
argument_list|()
argument_list|)
expr_stmt|;
name|tbl
operator|.
name|setOutputFormatClass
argument_list|(
name|crtTbl
operator|.
name|getOutputFormat
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|crtTbl
operator|.
name|isExternal
argument_list|()
condition|)
name|tbl
operator|.
name|setProperty
argument_list|(
literal|"EXTERNAL"
argument_list|,
literal|"TRUE"
argument_list|)
expr_stmt|;
comment|// If the sorted columns is a superset of bucketed columns, store this fact.
comment|// It can be later used to
comment|// optimize some group-by queries. Note that, the order does not matter as
comment|// long as it in the first
comment|// 'n' columns where 'n' is the length of the bucketed columns.
if|if
condition|(
operator|(
name|tbl
operator|.
name|getBucketCols
argument_list|()
operator|!=
literal|null
operator|)
operator|&&
operator|(
name|tbl
operator|.
name|getSortCols
argument_list|()
operator|!=
literal|null
operator|)
condition|)
block|{
name|List
argument_list|<
name|String
argument_list|>
name|bucketCols
init|=
name|tbl
operator|.
name|getBucketCols
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|Order
argument_list|>
name|sortCols
init|=
name|tbl
operator|.
name|getSortCols
argument_list|()
decl_stmt|;
if|if
condition|(
operator|(
name|sortCols
operator|.
name|size
argument_list|()
operator|>
literal|0
operator|)
operator|&&
operator|(
name|sortCols
operator|.
name|size
argument_list|()
operator|>=
name|bucketCols
operator|.
name|size
argument_list|()
operator|)
condition|)
block|{
name|boolean
name|found
init|=
literal|true
decl_stmt|;
name|Iterator
argument_list|<
name|String
argument_list|>
name|iterBucketCols
init|=
name|bucketCols
operator|.
name|iterator
argument_list|()
decl_stmt|;
while|while
condition|(
name|iterBucketCols
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|String
name|bucketCol
init|=
name|iterBucketCols
operator|.
name|next
argument_list|()
decl_stmt|;
name|boolean
name|colFound
init|=
literal|false
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|bucketCols
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|bucketCol
operator|.
name|equals
argument_list|(
name|sortCols
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|getCol
argument_list|()
argument_list|)
condition|)
block|{
name|colFound
operator|=
literal|true
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|colFound
operator|==
literal|false
condition|)
block|{
name|found
operator|=
literal|false
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|found
condition|)
name|tbl
operator|.
name|setProperty
argument_list|(
literal|"SORTBUCKETCOLSPREFIX"
argument_list|,
literal|"TRUE"
argument_list|)
expr_stmt|;
block|}
block|}
try|try
block|{
name|tbl
operator|.
name|setOwner
argument_list|(
name|conf
operator|.
name|getUser
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|console
operator|.
name|printError
argument_list|(
literal|"Unable to get current user: "
operator|+
name|e
operator|.
name|getMessage
argument_list|()
argument_list|,
name|StringUtils
operator|.
name|stringifyException
argument_list|(
name|e
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
comment|// set create time
name|tbl
operator|.
name|getTTable
argument_list|()
operator|.
name|setCreateTime
argument_list|(
call|(
name|int
call|)
argument_list|(
name|System
operator|.
name|currentTimeMillis
argument_list|()
operator|/
literal|1000
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|crtTbl
operator|.
name|getCols
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|tbl
operator|.
name|setFields
argument_list|(
name|crtTbl
operator|.
name|getCols
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// create the table
name|db
operator|.
name|createTable
argument_list|(
name|tbl
argument_list|,
name|crtTbl
operator|.
name|getIfNotExists
argument_list|()
argument_list|)
expr_stmt|;
name|work
operator|.
name|getOutputs
argument_list|()
operator|.
name|add
argument_list|(
operator|new
name|WriteEntity
argument_list|(
name|tbl
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/**    * Create a new table like an existing table.    *    * @param db The database in question.    * @param crtTbl This is the table we're creating.    * @return Returns 0 when execution succeeds and above 0 if it fails.    * @throws HiveException Throws this exception if an unexpected error occurs.    */
specifier|private
name|int
name|createTableLike
parameter_list|(
name|Hive
name|db
parameter_list|,
name|createTableLikeDesc
name|crtTbl
parameter_list|)
throws|throws
name|HiveException
block|{
comment|// Get the existing table
name|Table
name|tbl
init|=
name|db
operator|.
name|getTable
argument_list|(
name|MetaStoreUtils
operator|.
name|DEFAULT_DATABASE_NAME
argument_list|,
name|crtTbl
operator|.
name|getLikeTableName
argument_list|()
argument_list|)
decl_stmt|;
name|StorageDescriptor
name|tblStorDesc
init|=
name|tbl
operator|.
name|getTTable
argument_list|()
operator|.
name|getSd
argument_list|()
decl_stmt|;
name|tbl
operator|.
name|getTTable
argument_list|()
operator|.
name|setTableName
argument_list|(
name|crtTbl
operator|.
name|getTableName
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|crtTbl
operator|.
name|isExternal
argument_list|()
condition|)
block|{
name|tbl
operator|.
name|setProperty
argument_list|(
literal|"EXTERNAL"
argument_list|,
literal|"TRUE"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|tbl
operator|.
name|setProperty
argument_list|(
literal|"EXTERNAL"
argument_list|,
literal|"FALSE"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|crtTbl
operator|.
name|getLocation
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|tblStorDesc
operator|.
name|setLocation
argument_list|(
name|crtTbl
operator|.
name|getLocation
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|tblStorDesc
operator|.
name|setLocation
argument_list|(
literal|null
argument_list|)
expr_stmt|;
name|tblStorDesc
operator|.
name|unsetLocation
argument_list|()
expr_stmt|;
block|}
comment|// create the table
name|db
operator|.
name|createTable
argument_list|(
name|tbl
argument_list|,
name|crtTbl
operator|.
name|getIfNotExists
argument_list|()
argument_list|)
expr_stmt|;
name|work
operator|.
name|getOutputs
argument_list|()
operator|.
name|add
argument_list|(
operator|new
name|WriteEntity
argument_list|(
name|tbl
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
specifier|public
name|int
name|getType
parameter_list|()
block|{
return|return
name|StageType
operator|.
name|DDL
return|;
block|}
block|}
end_class

end_unit

