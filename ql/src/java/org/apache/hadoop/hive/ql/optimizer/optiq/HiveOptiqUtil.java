begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|optimizer
operator|.
name|optiq
package|;
end_package

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|BitSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
operator|.
name|Entry
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|optimizer
operator|.
name|optiq
operator|.
name|reloperators
operator|.
name|HiveJoinRel
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|parse
operator|.
name|ASTNode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|rel
operator|.
name|RelFactories
operator|.
name|ProjectFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|rel
operator|.
name|RelNode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|relopt
operator|.
name|RelOptUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|relopt
operator|.
name|RelOptUtil
operator|.
name|InputReferencedVisitor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|reltype
operator|.
name|RelDataTypeField
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|rex
operator|.
name|RexBuilder
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|rex
operator|.
name|RexInputRef
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|rex
operator|.
name|RexNode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|sql
operator|.
name|SqlKind
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|sql
operator|.
name|fun
operator|.
name|SqlStdOperatorTable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|sql
operator|.
name|validate
operator|.
name|SqlValidatorUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|util
operator|.
name|Pair
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Function
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|ImmutableList
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|ImmutableMap
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|ImmutableSet
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Lists
import|;
end_import

begin_comment
comment|/**  * Generic utility functions needed for Optiq based Hive CBO.  */
end_comment

begin_class
specifier|public
class|class
name|HiveOptiqUtil
block|{
comment|/**    * Get list of virtual columns from the given list of projections.    *<p>    *    * @param exps    *          list of rex nodes representing projections    * @return List of Virtual Columns, will not be null.    */
specifier|public
specifier|static
name|List
argument_list|<
name|Integer
argument_list|>
name|getVirtualCols
parameter_list|(
name|List
argument_list|<
name|?
extends|extends
name|RexNode
argument_list|>
name|exps
parameter_list|)
block|{
name|List
argument_list|<
name|Integer
argument_list|>
name|vCols
init|=
operator|new
name|ArrayList
argument_list|<
name|Integer
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|exps
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
operator|(
name|exps
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|instanceof
name|RexInputRef
operator|)
condition|)
block|{
name|vCols
operator|.
name|add
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|vCols
return|;
block|}
specifier|public
specifier|static
name|boolean
name|validateASTForCBO
parameter_list|(
name|ASTNode
name|ast
parameter_list|)
block|{
name|String
name|astTree
init|=
name|ast
operator|.
name|toStringTree
argument_list|()
decl_stmt|;
name|String
index|[]
name|tokens
init|=
block|{
literal|"TOK_CHARSETLITERAL"
block|}
decl_stmt|;
for|for
control|(
name|String
name|token
range|:
name|tokens
control|)
block|{
if|if
condition|(
name|astTree
operator|.
name|contains
argument_list|(
name|token
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
return|return
literal|true
return|;
block|}
specifier|public
specifier|static
name|List
argument_list|<
name|RexNode
argument_list|>
name|getProjsFromBelowAsInputRef
parameter_list|(
specifier|final
name|RelNode
name|rel
parameter_list|)
block|{
name|List
argument_list|<
name|RexNode
argument_list|>
name|projectList
init|=
name|Lists
operator|.
name|transform
argument_list|(
name|rel
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldList
argument_list|()
argument_list|,
operator|new
name|Function
argument_list|<
name|RelDataTypeField
argument_list|,
name|RexNode
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|RexNode
name|apply
parameter_list|(
name|RelDataTypeField
name|field
parameter_list|)
block|{
return|return
name|rel
operator|.
name|getCluster
argument_list|()
operator|.
name|getRexBuilder
argument_list|()
operator|.
name|makeInputRef
argument_list|(
name|field
operator|.
name|getType
argument_list|()
argument_list|,
name|field
operator|.
name|getIndex
argument_list|()
argument_list|)
return|;
block|}
block|}
argument_list|)
decl_stmt|;
return|return
name|projectList
return|;
block|}
specifier|public
specifier|static
name|List
argument_list|<
name|Integer
argument_list|>
name|translateBitSetToProjIndx
parameter_list|(
name|BitSet
name|projBitSet
parameter_list|)
block|{
name|List
argument_list|<
name|Integer
argument_list|>
name|projIndxLst
init|=
operator|new
name|ArrayList
argument_list|<
name|Integer
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|projBitSet
operator|.
name|length
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|projBitSet
operator|.
name|get
argument_list|(
name|i
argument_list|)
condition|)
block|{
name|projIndxLst
operator|.
name|add
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|projIndxLst
return|;
block|}
comment|/**    * Push any equi join conditions that are not column references as Projections    * on top of the children.    *    * @param factory    *          Project factory to use.    * @param inputRels    *          inputs to a join    * @param leftJoinKeys    *          expressions for LHS of join key    * @param rightJoinKeys    *          expressions for RHS of join key    * @param systemColCount    *          number of system columns, usually zero. These columns are    *          projected at the leading edge of the output row.    * @param leftKeys    *          on return this contains the join key positions from the new    *          project rel on the LHS.    * @param rightKeys    *          on return this contains the join key positions from the new    *          project rel on the RHS.    * @return the join condition after the equi expressions pushed down.    */
specifier|public
specifier|static
name|RexNode
name|projectNonColumnEquiConditions
parameter_list|(
name|ProjectFactory
name|factory
parameter_list|,
name|RelNode
index|[]
name|inputRels
parameter_list|,
name|List
argument_list|<
name|RexNode
argument_list|>
name|leftJoinKeys
parameter_list|,
name|List
argument_list|<
name|RexNode
argument_list|>
name|rightJoinKeys
parameter_list|,
name|int
name|systemColCount
parameter_list|,
name|List
argument_list|<
name|Integer
argument_list|>
name|leftKeys
parameter_list|,
name|List
argument_list|<
name|Integer
argument_list|>
name|rightKeys
parameter_list|)
block|{
name|RelNode
name|leftRel
init|=
name|inputRels
index|[
literal|0
index|]
decl_stmt|;
name|RelNode
name|rightRel
init|=
name|inputRels
index|[
literal|1
index|]
decl_stmt|;
name|RexBuilder
name|rexBuilder
init|=
name|leftRel
operator|.
name|getCluster
argument_list|()
operator|.
name|getRexBuilder
argument_list|()
decl_stmt|;
name|RexNode
name|outJoinCond
init|=
literal|null
decl_stmt|;
name|int
name|origLeftInputSize
init|=
name|leftRel
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldCount
argument_list|()
decl_stmt|;
name|int
name|origRightInputSize
init|=
name|rightRel
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldCount
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|RexNode
argument_list|>
name|newLeftFields
init|=
operator|new
name|ArrayList
argument_list|<
name|RexNode
argument_list|>
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|newLeftFieldNames
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|RexNode
argument_list|>
name|newRightFields
init|=
operator|new
name|ArrayList
argument_list|<
name|RexNode
argument_list|>
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|newRightFieldNames
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
name|int
name|leftKeyCount
init|=
name|leftJoinKeys
operator|.
name|size
argument_list|()
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|origLeftInputSize
condition|;
name|i
operator|++
control|)
block|{
specifier|final
name|RelDataTypeField
name|field
init|=
name|leftRel
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldList
argument_list|()
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|newLeftFields
operator|.
name|add
argument_list|(
name|rexBuilder
operator|.
name|makeInputRef
argument_list|(
name|field
operator|.
name|getType
argument_list|()
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|newLeftFieldNames
operator|.
name|add
argument_list|(
name|field
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|origRightInputSize
condition|;
name|i
operator|++
control|)
block|{
specifier|final
name|RelDataTypeField
name|field
init|=
name|rightRel
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldList
argument_list|()
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|newRightFields
operator|.
name|add
argument_list|(
name|rexBuilder
operator|.
name|makeInputRef
argument_list|(
name|field
operator|.
name|getType
argument_list|()
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|newRightFieldNames
operator|.
name|add
argument_list|(
name|field
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|int
name|newKeyCount
init|=
literal|0
decl_stmt|;
name|List
argument_list|<
name|Pair
argument_list|<
name|Integer
argument_list|,
name|Integer
argument_list|>
argument_list|>
name|origColEqConds
init|=
operator|new
name|ArrayList
argument_list|<
name|Pair
argument_list|<
name|Integer
argument_list|,
name|Integer
argument_list|>
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|leftKeyCount
condition|;
name|i
operator|++
control|)
block|{
name|RexNode
name|leftKey
init|=
name|leftJoinKeys
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|RexNode
name|rightKey
init|=
name|rightJoinKeys
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|leftKey
operator|instanceof
name|RexInputRef
operator|&&
name|rightKey
operator|instanceof
name|RexInputRef
condition|)
block|{
name|origColEqConds
operator|.
name|add
argument_list|(
name|Pair
operator|.
name|of
argument_list|(
operator|(
operator|(
name|RexInputRef
operator|)
name|leftKey
operator|)
operator|.
name|getIndex
argument_list|()
argument_list|,
operator|(
operator|(
name|RexInputRef
operator|)
name|rightKey
operator|)
operator|.
name|getIndex
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|newLeftFields
operator|.
name|add
argument_list|(
name|leftKey
argument_list|)
expr_stmt|;
name|newLeftFieldNames
operator|.
name|add
argument_list|(
literal|null
argument_list|)
expr_stmt|;
name|newRightFields
operator|.
name|add
argument_list|(
name|rightKey
argument_list|)
expr_stmt|;
name|newRightFieldNames
operator|.
name|add
argument_list|(
literal|null
argument_list|)
expr_stmt|;
name|newKeyCount
operator|++
expr_stmt|;
block|}
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|origColEqConds
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|Pair
argument_list|<
name|Integer
argument_list|,
name|Integer
argument_list|>
name|p
init|=
name|origColEqConds
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|RexNode
name|leftKey
init|=
name|leftJoinKeys
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|RexNode
name|rightKey
init|=
name|rightJoinKeys
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|leftKeys
operator|.
name|add
argument_list|(
name|p
operator|.
name|left
argument_list|)
expr_stmt|;
name|rightKeys
operator|.
name|add
argument_list|(
name|p
operator|.
name|right
argument_list|)
expr_stmt|;
name|RexNode
name|cond
init|=
name|rexBuilder
operator|.
name|makeCall
argument_list|(
name|SqlStdOperatorTable
operator|.
name|EQUALS
argument_list|,
name|rexBuilder
operator|.
name|makeInputRef
argument_list|(
name|leftKey
operator|.
name|getType
argument_list|()
argument_list|,
name|systemColCount
operator|+
name|p
operator|.
name|left
argument_list|)
argument_list|,
name|rexBuilder
operator|.
name|makeInputRef
argument_list|(
name|rightKey
operator|.
name|getType
argument_list|()
argument_list|,
name|systemColCount
operator|+
name|origLeftInputSize
operator|+
name|newKeyCount
operator|+
name|p
operator|.
name|right
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|outJoinCond
operator|==
literal|null
condition|)
block|{
name|outJoinCond
operator|=
name|cond
expr_stmt|;
block|}
else|else
block|{
name|outJoinCond
operator|=
name|rexBuilder
operator|.
name|makeCall
argument_list|(
name|SqlStdOperatorTable
operator|.
name|AND
argument_list|,
name|outJoinCond
argument_list|,
name|cond
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|newKeyCount
operator|==
literal|0
condition|)
block|{
return|return
name|outJoinCond
return|;
block|}
name|int
name|newLeftOffset
init|=
name|systemColCount
operator|+
name|origLeftInputSize
decl_stmt|;
name|int
name|newRightOffset
init|=
name|systemColCount
operator|+
name|origLeftInputSize
operator|+
name|origRightInputSize
operator|+
name|newKeyCount
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|newKeyCount
condition|;
name|i
operator|++
control|)
block|{
name|leftKeys
operator|.
name|add
argument_list|(
name|origLeftInputSize
operator|+
name|i
argument_list|)
expr_stmt|;
name|rightKeys
operator|.
name|add
argument_list|(
name|origRightInputSize
operator|+
name|i
argument_list|)
expr_stmt|;
name|RexNode
name|cond
init|=
name|rexBuilder
operator|.
name|makeCall
argument_list|(
name|SqlStdOperatorTable
operator|.
name|EQUALS
argument_list|,
name|rexBuilder
operator|.
name|makeInputRef
argument_list|(
name|newLeftFields
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|getType
argument_list|()
argument_list|,
name|newLeftOffset
operator|+
name|i
argument_list|)
argument_list|,
name|rexBuilder
operator|.
name|makeInputRef
argument_list|(
name|newLeftFields
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|getType
argument_list|()
argument_list|,
name|newRightOffset
operator|+
name|i
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|outJoinCond
operator|==
literal|null
condition|)
block|{
name|outJoinCond
operator|=
name|cond
expr_stmt|;
block|}
else|else
block|{
name|outJoinCond
operator|=
name|rexBuilder
operator|.
name|makeCall
argument_list|(
name|SqlStdOperatorTable
operator|.
name|AND
argument_list|,
name|outJoinCond
argument_list|,
name|cond
argument_list|)
expr_stmt|;
block|}
block|}
comment|// added project if need to produce new keys than the original input
comment|// fields
if|if
condition|(
name|newKeyCount
operator|>
literal|0
condition|)
block|{
name|leftRel
operator|=
name|factory
operator|.
name|createProject
argument_list|(
name|leftRel
argument_list|,
name|newLeftFields
argument_list|,
name|SqlValidatorUtil
operator|.
name|uniquify
argument_list|(
name|newLeftFieldNames
argument_list|)
argument_list|)
expr_stmt|;
name|rightRel
operator|=
name|factory
operator|.
name|createProject
argument_list|(
name|rightRel
argument_list|,
name|newRightFields
argument_list|,
name|SqlValidatorUtil
operator|.
name|uniquify
argument_list|(
name|newRightFieldNames
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|inputRels
index|[
literal|0
index|]
operator|=
name|leftRel
expr_stmt|;
name|inputRels
index|[
literal|1
index|]
operator|=
name|rightRel
expr_stmt|;
return|return
name|outJoinCond
return|;
block|}
comment|/**    * JoinPredicateInfo represents Join condition; JoinPredicate Info uses    * JoinLeafPredicateInfo to represent individual conjunctive elements in the    * predicate.<br>    * JoinPredicateInfo = JoinLeafPredicateInfo1 and JoinLeafPredicateInfo2...<br>    *<p>    * JoinPredicateInfo:<br>    * 1. preserves the order of conjuctive elements for    * equi-join(m_equiJoinPredicateElements)<br>    * 2. Stores set of projection indexes from left and right child which is part    * of equi join keys; the indexes are both in child and Join node schema.<br>    * 3. Keeps a map of projection indexes that are part of join keys to list of    * conjuctive elements(JoinLeafPredicateInfo) that uses them.    *    */
specifier|public
specifier|static
class|class
name|JoinPredicateInfo
block|{
specifier|private
specifier|final
name|ImmutableList
argument_list|<
name|JoinLeafPredicateInfo
argument_list|>
name|nonEquiJoinPredicateElements
decl_stmt|;
specifier|private
specifier|final
name|ImmutableList
argument_list|<
name|JoinLeafPredicateInfo
argument_list|>
name|equiJoinPredicateElements
decl_stmt|;
specifier|private
specifier|final
name|ImmutableSet
argument_list|<
name|Integer
argument_list|>
name|projsFromLeftPartOfJoinKeysInChildSchema
decl_stmt|;
specifier|private
specifier|final
name|ImmutableSet
argument_list|<
name|Integer
argument_list|>
name|projsFromRightPartOfJoinKeysInChildSchema
decl_stmt|;
specifier|private
specifier|final
name|ImmutableSet
argument_list|<
name|Integer
argument_list|>
name|projsFromRightPartOfJoinKeysInJoinSchema
decl_stmt|;
specifier|private
specifier|final
name|ImmutableMap
argument_list|<
name|Integer
argument_list|,
name|ImmutableList
argument_list|<
name|JoinLeafPredicateInfo
argument_list|>
argument_list|>
name|mapOfProjIndxInJoinSchemaToLeafPInfo
decl_stmt|;
specifier|public
name|JoinPredicateInfo
parameter_list|(
name|List
argument_list|<
name|JoinLeafPredicateInfo
argument_list|>
name|nonEquiJoinPredicateElements
parameter_list|,
name|List
argument_list|<
name|JoinLeafPredicateInfo
argument_list|>
name|equiJoinPredicateElements
parameter_list|,
name|Set
argument_list|<
name|Integer
argument_list|>
name|projsFromLeftPartOfJoinKeysInChildSchema
parameter_list|,
name|Set
argument_list|<
name|Integer
argument_list|>
name|projsFromRightPartOfJoinKeysInChildSchema
parameter_list|,
name|Set
argument_list|<
name|Integer
argument_list|>
name|projsFromRightPartOfJoinKeysInJoinSchema
parameter_list|,
name|Map
argument_list|<
name|Integer
argument_list|,
name|ImmutableList
argument_list|<
name|JoinLeafPredicateInfo
argument_list|>
argument_list|>
name|mapOfProjIndxInJoinSchemaToLeafPInfo
parameter_list|)
block|{
name|this
operator|.
name|nonEquiJoinPredicateElements
operator|=
name|ImmutableList
operator|.
name|copyOf
argument_list|(
name|nonEquiJoinPredicateElements
argument_list|)
expr_stmt|;
name|this
operator|.
name|equiJoinPredicateElements
operator|=
name|ImmutableList
operator|.
name|copyOf
argument_list|(
name|equiJoinPredicateElements
argument_list|)
expr_stmt|;
name|this
operator|.
name|projsFromLeftPartOfJoinKeysInChildSchema
operator|=
name|ImmutableSet
operator|.
name|copyOf
argument_list|(
name|projsFromLeftPartOfJoinKeysInChildSchema
argument_list|)
expr_stmt|;
name|this
operator|.
name|projsFromRightPartOfJoinKeysInChildSchema
operator|=
name|ImmutableSet
operator|.
name|copyOf
argument_list|(
name|projsFromRightPartOfJoinKeysInChildSchema
argument_list|)
expr_stmt|;
name|this
operator|.
name|projsFromRightPartOfJoinKeysInJoinSchema
operator|=
name|ImmutableSet
operator|.
name|copyOf
argument_list|(
name|projsFromRightPartOfJoinKeysInJoinSchema
argument_list|)
expr_stmt|;
name|this
operator|.
name|mapOfProjIndxInJoinSchemaToLeafPInfo
operator|=
name|ImmutableMap
operator|.
name|copyOf
argument_list|(
name|mapOfProjIndxInJoinSchemaToLeafPInfo
argument_list|)
expr_stmt|;
block|}
specifier|public
name|List
argument_list|<
name|JoinLeafPredicateInfo
argument_list|>
name|getNonEquiJoinPredicateElements
parameter_list|()
block|{
return|return
name|nonEquiJoinPredicateElements
return|;
block|}
specifier|public
name|List
argument_list|<
name|JoinLeafPredicateInfo
argument_list|>
name|getEquiJoinPredicateElements
parameter_list|()
block|{
return|return
name|equiJoinPredicateElements
return|;
block|}
specifier|public
name|Set
argument_list|<
name|Integer
argument_list|>
name|getProjsFromLeftPartOfJoinKeysInChildSchema
parameter_list|()
block|{
return|return
name|projsFromLeftPartOfJoinKeysInChildSchema
return|;
block|}
specifier|public
name|Set
argument_list|<
name|Integer
argument_list|>
name|getProjsFromRightPartOfJoinKeysInChildSchema
parameter_list|()
block|{
return|return
name|projsFromRightPartOfJoinKeysInChildSchema
return|;
block|}
comment|/**      * NOTE: Join Schema = left Schema + (right Schema offset by      * left.fieldcount). Hence its ok to return projections from left in child      * schema.      */
specifier|public
name|Set
argument_list|<
name|Integer
argument_list|>
name|getProjsFromLeftPartOfJoinKeysInJoinSchema
parameter_list|()
block|{
return|return
name|projsFromLeftPartOfJoinKeysInChildSchema
return|;
block|}
specifier|public
name|Set
argument_list|<
name|Integer
argument_list|>
name|getProjsFromRightPartOfJoinKeysInJoinSchema
parameter_list|()
block|{
return|return
name|projsFromRightPartOfJoinKeysInJoinSchema
return|;
block|}
specifier|public
name|Map
argument_list|<
name|Integer
argument_list|,
name|ImmutableList
argument_list|<
name|JoinLeafPredicateInfo
argument_list|>
argument_list|>
name|getMapOfProjIndxToLeafPInfo
parameter_list|()
block|{
return|return
name|mapOfProjIndxInJoinSchemaToLeafPInfo
return|;
block|}
specifier|public
specifier|static
name|JoinPredicateInfo
name|constructJoinPredicateInfo
parameter_list|(
name|HiveJoinRel
name|j
parameter_list|)
block|{
return|return
name|constructJoinPredicateInfo
argument_list|(
name|j
argument_list|,
name|j
operator|.
name|getCondition
argument_list|()
argument_list|)
return|;
block|}
specifier|public
specifier|static
name|JoinPredicateInfo
name|constructJoinPredicateInfo
parameter_list|(
name|HiveJoinRel
name|j
parameter_list|,
name|RexNode
name|predicate
parameter_list|)
block|{
name|JoinPredicateInfo
name|jpi
init|=
literal|null
decl_stmt|;
name|JoinLeafPredicateInfo
name|jlpi
init|=
literal|null
decl_stmt|;
name|List
argument_list|<
name|JoinLeafPredicateInfo
argument_list|>
name|equiLPIList
init|=
operator|new
name|ArrayList
argument_list|<
name|JoinLeafPredicateInfo
argument_list|>
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|JoinLeafPredicateInfo
argument_list|>
name|nonEquiLPIList
init|=
operator|new
name|ArrayList
argument_list|<
name|JoinLeafPredicateInfo
argument_list|>
argument_list|()
decl_stmt|;
name|Set
argument_list|<
name|Integer
argument_list|>
name|projsFromLeftPartOfJoinKeys
init|=
operator|new
name|HashSet
argument_list|<
name|Integer
argument_list|>
argument_list|()
decl_stmt|;
name|Set
argument_list|<
name|Integer
argument_list|>
name|projsFromRightPartOfJoinKeys
init|=
operator|new
name|HashSet
argument_list|<
name|Integer
argument_list|>
argument_list|()
decl_stmt|;
name|Set
argument_list|<
name|Integer
argument_list|>
name|projsFromRightPartOfJoinKeysInJoinSchema
init|=
operator|new
name|HashSet
argument_list|<
name|Integer
argument_list|>
argument_list|()
decl_stmt|;
name|Map
argument_list|<
name|Integer
argument_list|,
name|List
argument_list|<
name|JoinLeafPredicateInfo
argument_list|>
argument_list|>
name|tmpMapOfProjIndxInJoinSchemaToLeafPInfo
init|=
operator|new
name|HashMap
argument_list|<
name|Integer
argument_list|,
name|List
argument_list|<
name|JoinLeafPredicateInfo
argument_list|>
argument_list|>
argument_list|()
decl_stmt|;
name|Map
argument_list|<
name|Integer
argument_list|,
name|ImmutableList
argument_list|<
name|JoinLeafPredicateInfo
argument_list|>
argument_list|>
name|mapOfProjIndxInJoinSchemaToLeafPInfo
init|=
operator|new
name|HashMap
argument_list|<
name|Integer
argument_list|,
name|ImmutableList
argument_list|<
name|JoinLeafPredicateInfo
argument_list|>
argument_list|>
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|JoinLeafPredicateInfo
argument_list|>
name|tmpJLPILst
init|=
literal|null
decl_stmt|;
name|int
name|rightOffSet
init|=
name|j
operator|.
name|getLeft
argument_list|()
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldCount
argument_list|()
decl_stmt|;
name|int
name|projIndxInJoin
decl_stmt|;
name|List
argument_list|<
name|RexNode
argument_list|>
name|conjuctiveElements
decl_stmt|;
comment|// 1. Decompose Join condition to a number of leaf predicates
comment|// (conjuctive elements)
name|conjuctiveElements
operator|=
name|RelOptUtil
operator|.
name|conjunctions
argument_list|(
name|predicate
argument_list|)
expr_stmt|;
comment|// 2. Walk through leaf predicates building up JoinLeafPredicateInfo
for|for
control|(
name|RexNode
name|ce
range|:
name|conjuctiveElements
control|)
block|{
comment|// 2.1 Construct JoinLeafPredicateInfo
name|jlpi
operator|=
name|JoinLeafPredicateInfo
operator|.
name|constructJoinLeafPredicateInfo
argument_list|(
name|j
argument_list|,
name|ce
argument_list|)
expr_stmt|;
comment|// 2.2 Classify leaf predicate as Equi vs Non Equi
if|if
condition|(
name|jlpi
operator|.
name|m_comparisonType
operator|.
name|equals
argument_list|(
name|SqlKind
operator|.
name|EQUALS
argument_list|)
condition|)
block|{
name|equiLPIList
operator|.
name|add
argument_list|(
name|jlpi
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|nonEquiLPIList
operator|.
name|add
argument_list|(
name|jlpi
argument_list|)
expr_stmt|;
block|}
comment|// 2.3 Maintain join keys coming from left vs right (in child&
comment|// Join Schema)
name|projsFromLeftPartOfJoinKeys
operator|.
name|addAll
argument_list|(
name|jlpi
operator|.
name|getProjsFromLeftPartOfJoinKeysInChildSchema
argument_list|()
argument_list|)
expr_stmt|;
name|projsFromRightPartOfJoinKeys
operator|.
name|addAll
argument_list|(
name|jlpi
operator|.
name|getProjsFromRightPartOfJoinKeysInChildSchema
argument_list|()
argument_list|)
expr_stmt|;
name|projsFromRightPartOfJoinKeysInJoinSchema
operator|.
name|addAll
argument_list|(
name|jlpi
operator|.
name|getProjsFromRightPartOfJoinKeysInJoinSchema
argument_list|()
argument_list|)
expr_stmt|;
comment|// 2.4 Update Join Key to JoinLeafPredicateInfo map with keys
comment|// from left
for|for
control|(
name|Integer
name|projIndx
range|:
name|jlpi
operator|.
name|getProjsFromLeftPartOfJoinKeysInChildSchema
argument_list|()
control|)
block|{
name|tmpJLPILst
operator|=
name|tmpMapOfProjIndxInJoinSchemaToLeafPInfo
operator|.
name|get
argument_list|(
name|projIndx
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmpJLPILst
operator|==
literal|null
condition|)
name|tmpJLPILst
operator|=
operator|new
name|ArrayList
argument_list|<
name|JoinLeafPredicateInfo
argument_list|>
argument_list|()
expr_stmt|;
name|tmpJLPILst
operator|.
name|add
argument_list|(
name|jlpi
argument_list|)
expr_stmt|;
name|tmpMapOfProjIndxInJoinSchemaToLeafPInfo
operator|.
name|put
argument_list|(
name|projIndx
argument_list|,
name|tmpJLPILst
argument_list|)
expr_stmt|;
block|}
comment|// 2.5 Update Join Key to JoinLeafPredicateInfo map with keys
comment|// from right
for|for
control|(
name|Integer
name|projIndx
range|:
name|jlpi
operator|.
name|getProjsFromRightPartOfJoinKeysInChildSchema
argument_list|()
control|)
block|{
name|projIndxInJoin
operator|=
name|projIndx
operator|+
name|rightOffSet
expr_stmt|;
name|tmpJLPILst
operator|=
name|tmpMapOfProjIndxInJoinSchemaToLeafPInfo
operator|.
name|get
argument_list|(
name|projIndxInJoin
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmpJLPILst
operator|==
literal|null
condition|)
name|tmpJLPILst
operator|=
operator|new
name|ArrayList
argument_list|<
name|JoinLeafPredicateInfo
argument_list|>
argument_list|()
expr_stmt|;
name|tmpJLPILst
operator|.
name|add
argument_list|(
name|jlpi
argument_list|)
expr_stmt|;
name|tmpMapOfProjIndxInJoinSchemaToLeafPInfo
operator|.
name|put
argument_list|(
name|projIndxInJoin
argument_list|,
name|tmpJLPILst
argument_list|)
expr_stmt|;
block|}
block|}
comment|// 3. Update Update Join Key to List<JoinLeafPredicateInfo> to use
comment|// ImmutableList
for|for
control|(
name|Entry
argument_list|<
name|Integer
argument_list|,
name|List
argument_list|<
name|JoinLeafPredicateInfo
argument_list|>
argument_list|>
name|e
range|:
name|tmpMapOfProjIndxInJoinSchemaToLeafPInfo
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|mapOfProjIndxInJoinSchemaToLeafPInfo
operator|.
name|put
argument_list|(
name|e
operator|.
name|getKey
argument_list|()
argument_list|,
name|ImmutableList
operator|.
name|copyOf
argument_list|(
name|e
operator|.
name|getValue
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// 4. Construct JoinPredicateInfo
name|jpi
operator|=
operator|new
name|JoinPredicateInfo
argument_list|(
name|nonEquiLPIList
argument_list|,
name|equiLPIList
argument_list|,
name|projsFromLeftPartOfJoinKeys
argument_list|,
name|projsFromRightPartOfJoinKeys
argument_list|,
name|projsFromRightPartOfJoinKeysInJoinSchema
argument_list|,
name|mapOfProjIndxInJoinSchemaToLeafPInfo
argument_list|)
expr_stmt|;
return|return
name|jpi
return|;
block|}
block|}
comment|/**    * JoinLeafPredicateInfo represents leaf predicate in Join condition    * (conjuctive lement).<br>    *<p>    * JoinLeafPredicateInfo:<br>    * 1. Stores list of expressions from left and right child which is part of    * equi join keys.<br>    * 2. Stores set of projection indexes from left and right child which is part    * of equi join keys; the indexes are both in child and Join node schema.<br>    */
specifier|public
specifier|static
class|class
name|JoinLeafPredicateInfo
block|{
specifier|private
specifier|final
name|SqlKind
name|m_comparisonType
decl_stmt|;
specifier|private
specifier|final
name|ImmutableList
argument_list|<
name|RexNode
argument_list|>
name|m_joinKeyExprsFromLeft
decl_stmt|;
specifier|private
specifier|final
name|ImmutableList
argument_list|<
name|RexNode
argument_list|>
name|m_joinKeyExprsFromRight
decl_stmt|;
specifier|private
specifier|final
name|ImmutableSet
argument_list|<
name|Integer
argument_list|>
name|m_projsFromLeftPartOfJoinKeysInChildSchema
decl_stmt|;
specifier|private
specifier|final
name|ImmutableSet
argument_list|<
name|Integer
argument_list|>
name|m_projsFromRightPartOfJoinKeysInChildSchema
decl_stmt|;
specifier|private
specifier|final
name|ImmutableSet
argument_list|<
name|Integer
argument_list|>
name|m_projsFromRightPartOfJoinKeysInJoinSchema
decl_stmt|;
specifier|public
name|JoinLeafPredicateInfo
parameter_list|(
name|SqlKind
name|comparisonType
parameter_list|,
name|List
argument_list|<
name|RexNode
argument_list|>
name|joinKeyExprsFromLeft
parameter_list|,
name|List
argument_list|<
name|RexNode
argument_list|>
name|joinKeyExprsFromRight
parameter_list|,
name|Set
argument_list|<
name|Integer
argument_list|>
name|projsFromLeftPartOfJoinKeysInChildSchema
parameter_list|,
name|Set
argument_list|<
name|Integer
argument_list|>
name|projsFromRightPartOfJoinKeysInChildSchema
parameter_list|,
name|Set
argument_list|<
name|Integer
argument_list|>
name|projsFromRightPartOfJoinKeysInJoinSchema
parameter_list|)
block|{
name|m_comparisonType
operator|=
name|comparisonType
expr_stmt|;
name|m_joinKeyExprsFromLeft
operator|=
name|ImmutableList
operator|.
name|copyOf
argument_list|(
name|joinKeyExprsFromLeft
argument_list|)
expr_stmt|;
name|m_joinKeyExprsFromRight
operator|=
name|ImmutableList
operator|.
name|copyOf
argument_list|(
name|joinKeyExprsFromRight
argument_list|)
expr_stmt|;
name|m_projsFromLeftPartOfJoinKeysInChildSchema
operator|=
name|ImmutableSet
operator|.
name|copyOf
argument_list|(
name|projsFromLeftPartOfJoinKeysInChildSchema
argument_list|)
expr_stmt|;
name|m_projsFromRightPartOfJoinKeysInChildSchema
operator|=
name|ImmutableSet
operator|.
name|copyOf
argument_list|(
name|projsFromRightPartOfJoinKeysInChildSchema
argument_list|)
expr_stmt|;
name|m_projsFromRightPartOfJoinKeysInJoinSchema
operator|=
name|ImmutableSet
operator|.
name|copyOf
argument_list|(
name|projsFromRightPartOfJoinKeysInJoinSchema
argument_list|)
expr_stmt|;
block|}
specifier|public
name|List
argument_list|<
name|RexNode
argument_list|>
name|getJoinKeyExprsFromLeft
parameter_list|()
block|{
return|return
name|m_joinKeyExprsFromLeft
return|;
block|}
specifier|public
name|List
argument_list|<
name|RexNode
argument_list|>
name|getJoinKeyExprsFromRight
parameter_list|()
block|{
return|return
name|m_joinKeyExprsFromRight
return|;
block|}
specifier|public
name|Set
argument_list|<
name|Integer
argument_list|>
name|getProjsFromLeftPartOfJoinKeysInChildSchema
parameter_list|()
block|{
return|return
name|m_projsFromLeftPartOfJoinKeysInChildSchema
return|;
block|}
comment|/**      * NOTE: Join Schema = left Schema + (right Schema offset by      * left.fieldcount). Hence its ok to return projections from left in child      * schema.      */
specifier|public
name|Set
argument_list|<
name|Integer
argument_list|>
name|getProjsFromLeftPartOfJoinKeysInJoinSchema
parameter_list|()
block|{
return|return
name|m_projsFromLeftPartOfJoinKeysInChildSchema
return|;
block|}
specifier|public
name|Set
argument_list|<
name|Integer
argument_list|>
name|getProjsFromRightPartOfJoinKeysInChildSchema
parameter_list|()
block|{
return|return
name|m_projsFromRightPartOfJoinKeysInChildSchema
return|;
block|}
specifier|public
name|Set
argument_list|<
name|Integer
argument_list|>
name|getProjsFromRightPartOfJoinKeysInJoinSchema
parameter_list|()
block|{
return|return
name|m_projsFromRightPartOfJoinKeysInJoinSchema
return|;
block|}
specifier|private
specifier|static
name|JoinLeafPredicateInfo
name|constructJoinLeafPredicateInfo
parameter_list|(
name|HiveJoinRel
name|j
parameter_list|,
name|RexNode
name|pe
parameter_list|)
block|{
name|JoinLeafPredicateInfo
name|jlpi
init|=
literal|null
decl_stmt|;
name|List
argument_list|<
name|Integer
argument_list|>
name|filterNulls
init|=
operator|new
name|ArrayList
argument_list|<
name|Integer
argument_list|>
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|RexNode
argument_list|>
name|joinKeyExprsFromLeft
init|=
operator|new
name|ArrayList
argument_list|<
name|RexNode
argument_list|>
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|RexNode
argument_list|>
name|joinKeyExprsFromRight
init|=
operator|new
name|ArrayList
argument_list|<
name|RexNode
argument_list|>
argument_list|()
decl_stmt|;
name|Set
argument_list|<
name|Integer
argument_list|>
name|projsFromLeftPartOfJoinKeysInChildSchema
init|=
operator|new
name|HashSet
argument_list|<
name|Integer
argument_list|>
argument_list|()
decl_stmt|;
name|Set
argument_list|<
name|Integer
argument_list|>
name|projsFromRightPartOfJoinKeysInChildSchema
init|=
operator|new
name|HashSet
argument_list|<
name|Integer
argument_list|>
argument_list|()
decl_stmt|;
name|Set
argument_list|<
name|Integer
argument_list|>
name|projsFromRightPartOfJoinKeysInJoinSchema
init|=
operator|new
name|HashSet
argument_list|<
name|Integer
argument_list|>
argument_list|()
decl_stmt|;
name|int
name|rightOffSet
init|=
name|j
operator|.
name|getLeft
argument_list|()
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldCount
argument_list|()
decl_stmt|;
comment|// 1. Split leaf join predicate to expressions from left, right
name|RelOptUtil
operator|.
name|splitJoinCondition
argument_list|(
name|j
operator|.
name|getSystemFieldList
argument_list|()
argument_list|,
name|j
operator|.
name|getLeft
argument_list|()
argument_list|,
name|j
operator|.
name|getRight
argument_list|()
argument_list|,
name|pe
argument_list|,
name|joinKeyExprsFromLeft
argument_list|,
name|joinKeyExprsFromRight
argument_list|,
name|filterNulls
argument_list|,
literal|null
argument_list|)
expr_stmt|;
comment|// 2. For left expressions, collect child projection indexes used
name|InputReferencedVisitor
name|irvLeft
init|=
operator|new
name|InputReferencedVisitor
argument_list|()
decl_stmt|;
name|irvLeft
operator|.
name|apply
argument_list|(
name|joinKeyExprsFromLeft
argument_list|)
expr_stmt|;
name|projsFromLeftPartOfJoinKeysInChildSchema
operator|.
name|addAll
argument_list|(
name|irvLeft
operator|.
name|inputPosReferenced
argument_list|)
expr_stmt|;
comment|// 3. For right expressions, collect child projection indexes used
name|InputReferencedVisitor
name|irvRight
init|=
operator|new
name|InputReferencedVisitor
argument_list|()
decl_stmt|;
name|irvRight
operator|.
name|apply
argument_list|(
name|joinKeyExprsFromRight
argument_list|)
expr_stmt|;
name|projsFromRightPartOfJoinKeysInChildSchema
operator|.
name|addAll
argument_list|(
name|irvRight
operator|.
name|inputPosReferenced
argument_list|)
expr_stmt|;
comment|// 3. Translate projection indexes from right to join schema, by adding
comment|// offset.
for|for
control|(
name|Integer
name|indx
range|:
name|projsFromRightPartOfJoinKeysInChildSchema
control|)
block|{
name|projsFromRightPartOfJoinKeysInJoinSchema
operator|.
name|add
argument_list|(
name|indx
operator|+
name|rightOffSet
argument_list|)
expr_stmt|;
block|}
comment|// 4. Construct JoinLeafPredicateInfo
name|jlpi
operator|=
operator|new
name|JoinLeafPredicateInfo
argument_list|(
name|pe
operator|.
name|getKind
argument_list|()
argument_list|,
name|joinKeyExprsFromLeft
argument_list|,
name|joinKeyExprsFromRight
argument_list|,
name|projsFromLeftPartOfJoinKeysInChildSchema
argument_list|,
name|projsFromRightPartOfJoinKeysInChildSchema
argument_list|,
name|projsFromRightPartOfJoinKeysInJoinSchema
argument_list|)
expr_stmt|;
return|return
name|jlpi
return|;
block|}
block|}
block|}
end_class

end_unit

