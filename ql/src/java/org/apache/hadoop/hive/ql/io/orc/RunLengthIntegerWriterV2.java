begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|io
operator|.
name|orc
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_comment
comment|/**  * A writer that performs light weight compression over sequence of integers.  *<p>  * There are four types of lightweight integer compression  *<ul>  *<li>SHORT_REPEAT</li>  *<li>DIRECT</li>  *<li>PATCHED_BASE</li>  *<li>DELTA</li>  *</ul>  *</p>  * The description and format for these types are as below:  *<p>  *<b>SHORT_REPEAT:</b> Used for short repeated integer sequences.  *<ul>  *<li>1 byte header  *<ul>  *<li>2 bits for encoding type</li>  *<li>3 bits for bytes required for repeating value</li>  *<li>3 bits for repeat count (MIN_REPEAT + run length)</li>  *</ul>  *</li>  *<li>Blob - repeat value (fixed bytes)</li>  *</ul>  *</p>  *<p>  *<b>DIRECT:</b> Used for random integer sequences whose number of bit  * requirement doesn't vary a lot.  *<ul>  *<li>2 bytes header  *<ul>  * 1st byte  *<li>2 bits for encoding type</li>  *<li>5 bits for fixed bit width of values in blob</li>  *<li>1 bit for storing MSB of run length</li>  *</ul>  *<ul>  * 2nd byte  *<li>8 bits for lower run length bits</li>  *</ul>  *</li>  *<li>Blob - stores the direct values using fixed bit width. The length of the  * data blob is (fixed width * run length) bits long</li>  *</ul>  *</p>  *<p>  *<b>PATCHED_BASE:</b> Used for random integer sequences whose number of bit  * requirement varies beyond a threshold.  *<ul>  *<li>4 bytes header  *<ul>  * 1st byte  *<li>2 bits for encoding type</li>  *<li>5 bits for fixed bit width of values in blob</li>  *<li>1 bit for storing MSB of run length</li>  *</ul>  *<ul>  * 2nd byte  *<li>8 bits for lower run length bits</li>  *</ul>  *<ul>  * 3rd byte  *<li>3 bits for bytes required to encode base value</li>  *<li>5 bits for patch width</li>  *</ul>  *<ul>  * 4th byte  *<li>3 bits for patch gap width</li>  *<li>5 bits for patch length</li>  *</ul>  *</li>  *<li>Base value - Stored using fixed number of bytes. If MSB is set, base  * value is negative else positive. Length of base value is (base width * 8)  * bits.</li>  *<li>Data blob - Base reduced values as stored using fixed bit width. Length  * of data blob is (fixed width * run length) bits.</li>  *<li>Patch blob - Patch blob is a list of gap and patch value. Each entry in  * the patch list is (patch width + patch gap width) bits long. Gap between the  * subsequent elements to be patched are stored in upper part of entry whereas  * patch values are stored in lower part of entry. Length of patch blob is  * ((patch width + patch gap width) * patch length) bits.</li>  *</ul>  *</p>  *<p>  *<b>DELTA</b> Used for monotonically increasing or decreasing sequences,  * sequences with fixed delta values or long repeated sequences.  *<ul>  *<li>2 bytes header  *<ul>  * 1st byte  *<li>2 bits for encoding type</li>  *<li>5 bits for fixed bit width of values in blob</li>  *<li>1 bit for storing MSB of run length</li>  *</ul>  *<ul>  * 2nd byte  *<li>8 bits for lower run length bits</li>  *</ul>  *</li>  *<li>Base value - encoded as varint</li>  *<li>Delta base - encoded as varint</li>  *<li>Delta blob - only positive values. monotonicity and orderness are decided  * based on the sign of the base value and delta base</li>  *</ul>  *</p>  */
end_comment

begin_class
class|class
name|RunLengthIntegerWriterV2
implements|implements
name|IntegerWriter
block|{
specifier|public
enum|enum
name|EncodingType
block|{
name|SHORT_REPEAT
block|,
name|DIRECT
block|,
name|PATCHED_BASE
block|,
name|DELTA
block|}
specifier|static
specifier|final
name|int
name|MAX_SCOPE
init|=
literal|512
decl_stmt|;
specifier|static
specifier|final
name|int
name|MIN_REPEAT
init|=
literal|3
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|int
name|MAX_SHORT_REPEAT_LENGTH
init|=
literal|10
decl_stmt|;
specifier|private
name|long
name|prevDelta
init|=
literal|0
decl_stmt|;
specifier|private
name|int
name|fixedRunLength
init|=
literal|0
decl_stmt|;
specifier|private
name|int
name|variableRunLength
init|=
literal|0
decl_stmt|;
specifier|private
specifier|final
name|long
index|[]
name|literals
init|=
operator|new
name|long
index|[
name|MAX_SCOPE
index|]
decl_stmt|;
specifier|private
specifier|final
name|PositionedOutputStream
name|output
decl_stmt|;
specifier|private
specifier|final
name|boolean
name|signed
decl_stmt|;
specifier|private
name|EncodingType
name|encoding
decl_stmt|;
specifier|private
name|int
name|numLiterals
decl_stmt|;
specifier|private
specifier|final
name|long
index|[]
name|zigzagLiterals
init|=
operator|new
name|long
index|[
name|MAX_SCOPE
index|]
decl_stmt|;
specifier|private
specifier|final
name|long
index|[]
name|baseRedLiterals
init|=
operator|new
name|long
index|[
name|MAX_SCOPE
index|]
decl_stmt|;
specifier|private
specifier|final
name|long
index|[]
name|adjDeltas
init|=
operator|new
name|long
index|[
name|MAX_SCOPE
index|]
decl_stmt|;
specifier|private
name|long
name|fixedDelta
decl_stmt|;
specifier|private
name|int
name|zzBits90p
decl_stmt|;
specifier|private
name|int
name|zzBits100p
decl_stmt|;
specifier|private
name|int
name|brBits95p
decl_stmt|;
specifier|private
name|int
name|brBits100p
decl_stmt|;
specifier|private
name|int
name|bitsDeltaMax
decl_stmt|;
specifier|private
name|int
name|patchWidth
decl_stmt|;
specifier|private
name|int
name|patchGapWidth
decl_stmt|;
specifier|private
name|int
name|patchLength
decl_stmt|;
specifier|private
name|long
index|[]
name|gapVsPatchList
decl_stmt|;
specifier|private
name|long
name|min
decl_stmt|;
specifier|private
name|boolean
name|isFixedDelta
decl_stmt|;
specifier|private
name|SerializationUtils
name|utils
decl_stmt|;
specifier|private
name|boolean
name|alignedBitpacking
decl_stmt|;
name|RunLengthIntegerWriterV2
parameter_list|(
name|PositionedOutputStream
name|output
parameter_list|,
name|boolean
name|signed
parameter_list|)
block|{
name|this
argument_list|(
name|output
argument_list|,
name|signed
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
name|RunLengthIntegerWriterV2
parameter_list|(
name|PositionedOutputStream
name|output
parameter_list|,
name|boolean
name|signed
parameter_list|,
name|boolean
name|alignedBitpacking
parameter_list|)
block|{
name|this
operator|.
name|output
operator|=
name|output
expr_stmt|;
name|this
operator|.
name|signed
operator|=
name|signed
expr_stmt|;
name|this
operator|.
name|alignedBitpacking
operator|=
name|alignedBitpacking
expr_stmt|;
name|this
operator|.
name|utils
operator|=
operator|new
name|SerializationUtils
argument_list|()
expr_stmt|;
name|clear
argument_list|()
expr_stmt|;
block|}
specifier|private
name|void
name|writeValues
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|numLiterals
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|encoding
operator|.
name|equals
argument_list|(
name|EncodingType
operator|.
name|SHORT_REPEAT
argument_list|)
condition|)
block|{
name|writeShortRepeatValues
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|encoding
operator|.
name|equals
argument_list|(
name|EncodingType
operator|.
name|DIRECT
argument_list|)
condition|)
block|{
name|writeDirectValues
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|encoding
operator|.
name|equals
argument_list|(
name|EncodingType
operator|.
name|PATCHED_BASE
argument_list|)
condition|)
block|{
name|writePatchedBaseValues
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|writeDeltaValues
argument_list|()
expr_stmt|;
block|}
comment|// clear all the variables
name|clear
argument_list|()
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|writeDeltaValues
parameter_list|()
throws|throws
name|IOException
block|{
name|int
name|len
init|=
literal|0
decl_stmt|;
name|int
name|fb
init|=
name|bitsDeltaMax
decl_stmt|;
name|int
name|efb
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|alignedBitpacking
condition|)
block|{
name|fb
operator|=
name|utils
operator|.
name|getClosestAlignedFixedBits
argument_list|(
name|fb
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|isFixedDelta
condition|)
block|{
comment|// if fixed run length is greater than threshold then it will be fixed
comment|// delta sequence with delta value 0 else fixed delta sequence with
comment|// non-zero delta value
if|if
condition|(
name|fixedRunLength
operator|>
name|MIN_REPEAT
condition|)
block|{
comment|// ex. sequence: 2 2 2 2 2 2 2 2
name|len
operator|=
name|fixedRunLength
operator|-
literal|1
expr_stmt|;
name|fixedRunLength
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|// ex. sequence: 4 6 8 10 12 14 16
name|len
operator|=
name|variableRunLength
operator|-
literal|1
expr_stmt|;
name|variableRunLength
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// fixed width 0 is used for long repeating values.
comment|// sequences that require only 1 bit to encode will have an additional bit
if|if
condition|(
name|fb
operator|==
literal|1
condition|)
block|{
name|fb
operator|=
literal|2
expr_stmt|;
block|}
name|efb
operator|=
name|utils
operator|.
name|encodeBitWidth
argument_list|(
name|fb
argument_list|)
expr_stmt|;
name|efb
operator|=
name|efb
operator|<<
literal|1
expr_stmt|;
name|len
operator|=
name|variableRunLength
operator|-
literal|1
expr_stmt|;
name|variableRunLength
operator|=
literal|0
expr_stmt|;
block|}
comment|// extract the 9th bit of run length
specifier|final
name|int
name|tailBits
init|=
operator|(
name|len
operator|&
literal|0x100
operator|)
operator|>>>
literal|8
decl_stmt|;
comment|// create first byte of the header
specifier|final
name|int
name|headerFirstByte
init|=
name|getOpcode
argument_list|()
operator||
name|efb
operator||
name|tailBits
decl_stmt|;
comment|// second byte of the header stores the remaining 8 bits of runlength
specifier|final
name|int
name|headerSecondByte
init|=
name|len
operator|&
literal|0xff
decl_stmt|;
comment|// write header
name|output
operator|.
name|write
argument_list|(
name|headerFirstByte
argument_list|)
expr_stmt|;
name|output
operator|.
name|write
argument_list|(
name|headerSecondByte
argument_list|)
expr_stmt|;
comment|// store the first value from zigzag literal array
if|if
condition|(
name|signed
condition|)
block|{
name|utils
operator|.
name|writeVslong
argument_list|(
name|output
argument_list|,
name|literals
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|utils
operator|.
name|writeVulong
argument_list|(
name|output
argument_list|,
name|literals
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|isFixedDelta
condition|)
block|{
comment|// if delta is fixed then we don't need to store delta blob
name|utils
operator|.
name|writeVslong
argument_list|(
name|output
argument_list|,
name|fixedDelta
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// store the first value as delta value using zigzag encoding
name|utils
operator|.
name|writeVslong
argument_list|(
name|output
argument_list|,
name|adjDeltas
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
comment|// adjacent delta values are bit packed. The length of adjDeltas array is
comment|// always one less than the number of literals (delta difference for n
comment|// elements is n-1). We have already written one element, write the
comment|// remaining numLiterals - 2 elements here
name|utils
operator|.
name|writeInts
argument_list|(
name|adjDeltas
argument_list|,
literal|1
argument_list|,
name|numLiterals
operator|-
literal|2
argument_list|,
name|fb
argument_list|,
name|output
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|writePatchedBaseValues
parameter_list|()
throws|throws
name|IOException
block|{
comment|// NOTE: Aligned bit packing cannot be applied for PATCHED_BASE encoding
comment|// because patch is applied to MSB bits. For example: If fixed bit width of
comment|// base value is 7 bits and if patch is 3 bits, the actual value is
comment|// constructed by shifting the patch to left by 7 positions.
comment|// actual_value = patch<< 7 | base_value
comment|// So, if we align base_value then actual_value can not be reconstructed.
comment|// write the number of fixed bits required in next 5 bits
specifier|final
name|int
name|fb
init|=
name|brBits95p
decl_stmt|;
specifier|final
name|int
name|efb
init|=
name|utils
operator|.
name|encodeBitWidth
argument_list|(
name|fb
argument_list|)
operator|<<
literal|1
decl_stmt|;
comment|// adjust variable run length, they are one off
name|variableRunLength
operator|-=
literal|1
expr_stmt|;
comment|// extract the 9th bit of run length
specifier|final
name|int
name|tailBits
init|=
operator|(
name|variableRunLength
operator|&
literal|0x100
operator|)
operator|>>>
literal|8
decl_stmt|;
comment|// create first byte of the header
specifier|final
name|int
name|headerFirstByte
init|=
name|getOpcode
argument_list|()
operator||
name|efb
operator||
name|tailBits
decl_stmt|;
comment|// second byte of the header stores the remaining 8 bits of runlength
specifier|final
name|int
name|headerSecondByte
init|=
name|variableRunLength
operator|&
literal|0xff
decl_stmt|;
comment|// if the min value is negative toggle the sign
specifier|final
name|boolean
name|isNegative
init|=
name|min
operator|<
literal|0
condition|?
literal|true
else|:
literal|false
decl_stmt|;
if|if
condition|(
name|isNegative
condition|)
block|{
name|min
operator|=
operator|-
name|min
expr_stmt|;
block|}
comment|// find the number of bytes required for base and shift it by 5 bits
comment|// to accommodate patch width. The additional bit is used to store the sign
comment|// of the base value.
specifier|final
name|int
name|baseWidth
init|=
name|utils
operator|.
name|findClosestNumBits
argument_list|(
name|min
argument_list|)
operator|+
literal|1
decl_stmt|;
specifier|final
name|int
name|baseBytes
init|=
name|baseWidth
operator|%
literal|8
operator|==
literal|0
condition|?
name|baseWidth
operator|/
literal|8
else|:
operator|(
name|baseWidth
operator|/
literal|8
operator|)
operator|+
literal|1
decl_stmt|;
specifier|final
name|int
name|bb
init|=
operator|(
name|baseBytes
operator|-
literal|1
operator|)
operator|<<
literal|5
decl_stmt|;
comment|// if the base value is negative then set MSB to 1
if|if
condition|(
name|isNegative
condition|)
block|{
name|min
operator||=
operator|(
literal|1L
operator|<<
operator|(
operator|(
name|baseBytes
operator|*
literal|8
operator|)
operator|-
literal|1
operator|)
operator|)
expr_stmt|;
block|}
comment|// third byte contains 3 bits for number of bytes occupied by base
comment|// and 5 bits for patchWidth
specifier|final
name|int
name|headerThirdByte
init|=
name|bb
operator||
name|utils
operator|.
name|encodeBitWidth
argument_list|(
name|patchWidth
argument_list|)
decl_stmt|;
comment|// fourth byte contains 3 bits for page gap width and 5 bits for
comment|// patch length
specifier|final
name|int
name|headerFourthByte
init|=
operator|(
name|patchGapWidth
operator|-
literal|1
operator|)
operator|<<
literal|5
operator||
name|patchLength
decl_stmt|;
comment|// write header
name|output
operator|.
name|write
argument_list|(
name|headerFirstByte
argument_list|)
expr_stmt|;
name|output
operator|.
name|write
argument_list|(
name|headerSecondByte
argument_list|)
expr_stmt|;
name|output
operator|.
name|write
argument_list|(
name|headerThirdByte
argument_list|)
expr_stmt|;
name|output
operator|.
name|write
argument_list|(
name|headerFourthByte
argument_list|)
expr_stmt|;
comment|// write the base value using fixed bytes in big endian order
for|for
control|(
name|int
name|i
init|=
name|baseBytes
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|byte
name|b
init|=
call|(
name|byte
call|)
argument_list|(
operator|(
name|min
operator|>>>
operator|(
name|i
operator|*
literal|8
operator|)
operator|)
operator|&
literal|0xff
argument_list|)
decl_stmt|;
name|output
operator|.
name|write
argument_list|(
name|b
argument_list|)
expr_stmt|;
block|}
comment|// base reduced literals are bit packed
name|int
name|closestFixedBits
init|=
name|utils
operator|.
name|getClosestFixedBits
argument_list|(
name|fb
argument_list|)
decl_stmt|;
name|utils
operator|.
name|writeInts
argument_list|(
name|baseRedLiterals
argument_list|,
literal|0
argument_list|,
name|numLiterals
argument_list|,
name|closestFixedBits
argument_list|,
name|output
argument_list|)
expr_stmt|;
comment|// write patch list
name|closestFixedBits
operator|=
name|utils
operator|.
name|getClosestFixedBits
argument_list|(
name|patchGapWidth
operator|+
name|patchWidth
argument_list|)
expr_stmt|;
name|utils
operator|.
name|writeInts
argument_list|(
name|gapVsPatchList
argument_list|,
literal|0
argument_list|,
name|gapVsPatchList
operator|.
name|length
argument_list|,
name|closestFixedBits
argument_list|,
name|output
argument_list|)
expr_stmt|;
comment|// reset run length
name|variableRunLength
operator|=
literal|0
expr_stmt|;
block|}
comment|/**    * Store the opcode in 2 MSB bits    * @return opcode    */
specifier|private
name|int
name|getOpcode
parameter_list|()
block|{
return|return
name|encoding
operator|.
name|ordinal
argument_list|()
operator|<<
literal|6
return|;
block|}
specifier|private
name|void
name|writeDirectValues
parameter_list|()
throws|throws
name|IOException
block|{
comment|// write the number of fixed bits required in next 5 bits
name|int
name|fb
init|=
name|zzBits100p
decl_stmt|;
if|if
condition|(
name|alignedBitpacking
condition|)
block|{
name|fb
operator|=
name|utils
operator|.
name|getClosestAlignedFixedBits
argument_list|(
name|fb
argument_list|)
expr_stmt|;
block|}
specifier|final
name|int
name|efb
init|=
name|utils
operator|.
name|encodeBitWidth
argument_list|(
name|fb
argument_list|)
operator|<<
literal|1
decl_stmt|;
comment|// adjust variable run length
name|variableRunLength
operator|-=
literal|1
expr_stmt|;
comment|// extract the 9th bit of run length
specifier|final
name|int
name|tailBits
init|=
operator|(
name|variableRunLength
operator|&
literal|0x100
operator|)
operator|>>>
literal|8
decl_stmt|;
comment|// create first byte of the header
specifier|final
name|int
name|headerFirstByte
init|=
name|getOpcode
argument_list|()
operator||
name|efb
operator||
name|tailBits
decl_stmt|;
comment|// second byte of the header stores the remaining 8 bits of runlength
specifier|final
name|int
name|headerSecondByte
init|=
name|variableRunLength
operator|&
literal|0xff
decl_stmt|;
comment|// write header
name|output
operator|.
name|write
argument_list|(
name|headerFirstByte
argument_list|)
expr_stmt|;
name|output
operator|.
name|write
argument_list|(
name|headerSecondByte
argument_list|)
expr_stmt|;
comment|// bit packing the zigzag encoded literals
name|utils
operator|.
name|writeInts
argument_list|(
name|zigzagLiterals
argument_list|,
literal|0
argument_list|,
name|numLiterals
argument_list|,
name|fb
argument_list|,
name|output
argument_list|)
expr_stmt|;
comment|// reset run length
name|variableRunLength
operator|=
literal|0
expr_stmt|;
block|}
specifier|private
name|void
name|writeShortRepeatValues
parameter_list|()
throws|throws
name|IOException
block|{
comment|// get the value that is repeating, compute the bits and bytes required
name|long
name|repeatVal
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|signed
condition|)
block|{
name|repeatVal
operator|=
name|utils
operator|.
name|zigzagEncode
argument_list|(
name|literals
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|repeatVal
operator|=
name|literals
index|[
literal|0
index|]
expr_stmt|;
block|}
specifier|final
name|int
name|numBitsRepeatVal
init|=
name|utils
operator|.
name|findClosestNumBits
argument_list|(
name|repeatVal
argument_list|)
decl_stmt|;
specifier|final
name|int
name|numBytesRepeatVal
init|=
name|numBitsRepeatVal
operator|%
literal|8
operator|==
literal|0
condition|?
name|numBitsRepeatVal
operator|>>>
literal|3
else|:
operator|(
name|numBitsRepeatVal
operator|>>>
literal|3
operator|)
operator|+
literal|1
decl_stmt|;
comment|// write encoding type in top 2 bits
name|int
name|header
init|=
name|getOpcode
argument_list|()
decl_stmt|;
comment|// write the number of bytes required for the value
name|header
operator||=
operator|(
operator|(
name|numBytesRepeatVal
operator|-
literal|1
operator|)
operator|<<
literal|3
operator|)
expr_stmt|;
comment|// write the run length
name|fixedRunLength
operator|-=
name|MIN_REPEAT
expr_stmt|;
name|header
operator||=
name|fixedRunLength
expr_stmt|;
comment|// write the header
name|output
operator|.
name|write
argument_list|(
name|header
argument_list|)
expr_stmt|;
comment|// write the repeating value in big endian byte order
for|for
control|(
name|int
name|i
init|=
name|numBytesRepeatVal
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|int
name|b
init|=
call|(
name|int
call|)
argument_list|(
operator|(
name|repeatVal
operator|>>>
operator|(
name|i
operator|*
literal|8
operator|)
operator|)
operator|&
literal|0xff
argument_list|)
decl_stmt|;
name|output
operator|.
name|write
argument_list|(
name|b
argument_list|)
expr_stmt|;
block|}
name|fixedRunLength
operator|=
literal|0
expr_stmt|;
block|}
specifier|private
name|void
name|determineEncoding
parameter_list|()
block|{
comment|// we need to compute zigzag values for DIRECT encoding if we decide to
comment|// break early for delta overflows or for shorter runs
name|computeZigZagLiterals
argument_list|()
expr_stmt|;
name|zzBits100p
operator|=
name|utils
operator|.
name|percentileBits
argument_list|(
name|zigzagLiterals
argument_list|,
literal|0
argument_list|,
name|numLiterals
argument_list|,
literal|1.0
argument_list|)
expr_stmt|;
comment|// not a big win for shorter runs to determine encoding
if|if
condition|(
name|numLiterals
operator|<=
name|MIN_REPEAT
condition|)
block|{
name|encoding
operator|=
name|EncodingType
operator|.
name|DIRECT
expr_stmt|;
return|return;
block|}
comment|// DELTA encoding check
comment|// for identifying monotonic sequences
name|boolean
name|isIncreasing
init|=
literal|true
decl_stmt|;
name|boolean
name|isDecreasing
init|=
literal|true
decl_stmt|;
name|this
operator|.
name|isFixedDelta
operator|=
literal|true
expr_stmt|;
name|this
operator|.
name|min
operator|=
name|literals
index|[
literal|0
index|]
expr_stmt|;
name|long
name|max
init|=
name|literals
index|[
literal|0
index|]
decl_stmt|;
specifier|final
name|long
name|initialDelta
init|=
name|literals
index|[
literal|1
index|]
operator|-
name|literals
index|[
literal|0
index|]
decl_stmt|;
name|long
name|currDelta
init|=
name|initialDelta
decl_stmt|;
name|long
name|deltaMax
init|=
name|initialDelta
decl_stmt|;
name|this
operator|.
name|adjDeltas
index|[
literal|0
index|]
operator|=
name|initialDelta
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<
name|numLiterals
condition|;
name|i
operator|++
control|)
block|{
specifier|final
name|long
name|l1
init|=
name|literals
index|[
name|i
index|]
decl_stmt|;
specifier|final
name|long
name|l0
init|=
name|literals
index|[
name|i
operator|-
literal|1
index|]
decl_stmt|;
name|currDelta
operator|=
name|l1
operator|-
name|l0
expr_stmt|;
name|min
operator|=
name|Math
operator|.
name|min
argument_list|(
name|min
argument_list|,
name|l1
argument_list|)
expr_stmt|;
name|max
operator|=
name|Math
operator|.
name|max
argument_list|(
name|max
argument_list|,
name|l1
argument_list|)
expr_stmt|;
name|isIncreasing
operator|&=
operator|(
name|l0
operator|<=
name|l1
operator|)
expr_stmt|;
name|isDecreasing
operator|&=
operator|(
name|l0
operator|>=
name|l1
operator|)
expr_stmt|;
name|isFixedDelta
operator|&=
operator|(
name|currDelta
operator|==
name|initialDelta
operator|)
expr_stmt|;
if|if
condition|(
name|i
operator|>
literal|1
condition|)
block|{
name|adjDeltas
index|[
name|i
operator|-
literal|1
index|]
operator|=
name|Math
operator|.
name|abs
argument_list|(
name|currDelta
argument_list|)
expr_stmt|;
name|deltaMax
operator|=
name|Math
operator|.
name|max
argument_list|(
name|deltaMax
argument_list|,
name|adjDeltas
index|[
name|i
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
block|}
comment|// its faster to exit under delta overflow condition without checking for
comment|// PATCHED_BASE condition as encoding using DIRECT is faster and has less
comment|// overhead than PATCHED_BASE
if|if
condition|(
operator|!
name|utils
operator|.
name|isSafeSubtract
argument_list|(
name|max
argument_list|,
name|min
argument_list|)
condition|)
block|{
name|encoding
operator|=
name|EncodingType
operator|.
name|DIRECT
expr_stmt|;
return|return;
block|}
comment|// invariant - subtracting any number from any other in the literals after
comment|// this point won't overflow
comment|// if initialDelta is 0 then we cannot delta encode as we cannot identify
comment|// the sign of deltas (increasing or decreasing)
if|if
condition|(
name|initialDelta
operator|!=
literal|0
condition|)
block|{
comment|// if min is equal to max then the delta is 0, this condition happens for
comment|// fixed values run>10 which cannot be encoded with SHORT_REPEAT
if|if
condition|(
name|min
operator|==
name|max
condition|)
block|{
assert|assert
name|isFixedDelta
operator|:
name|min
operator|+
literal|"=="
operator|+
name|max
operator|+
literal|", isFixedDelta cannot be false"
assert|;
assert|assert
name|currDelta
operator|==
literal|0
operator|:
name|min
operator|+
literal|"=="
operator|+
name|max
operator|+
literal|", currDelta should be zero"
assert|;
name|fixedDelta
operator|=
literal|0
expr_stmt|;
name|encoding
operator|=
name|EncodingType
operator|.
name|DELTA
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|isFixedDelta
condition|)
block|{
assert|assert
name|currDelta
operator|==
name|initialDelta
operator|:
literal|"currDelta should be equal to initialDelta for fixed delta encoding"
assert|;
name|encoding
operator|=
name|EncodingType
operator|.
name|DELTA
expr_stmt|;
name|fixedDelta
operator|=
name|currDelta
expr_stmt|;
return|return;
block|}
comment|// stores the number of bits required for packing delta blob in
comment|// delta encoding
name|bitsDeltaMax
operator|=
name|utils
operator|.
name|findClosestNumBits
argument_list|(
name|deltaMax
argument_list|)
expr_stmt|;
comment|// monotonic condition
if|if
condition|(
name|isIncreasing
operator|||
name|isDecreasing
condition|)
block|{
name|encoding
operator|=
name|EncodingType
operator|.
name|DELTA
expr_stmt|;
return|return;
block|}
block|}
comment|// PATCHED_BASE encoding check
comment|// percentile values are computed for the zigzag encoded values. if the
comment|// number of bit requirement between 90th and 100th percentile varies
comment|// beyond a threshold then we need to patch the values. if the variation
comment|// is not significant then we can use direct encoding
name|zzBits90p
operator|=
name|utils
operator|.
name|percentileBits
argument_list|(
name|zigzagLiterals
argument_list|,
literal|0
argument_list|,
name|numLiterals
argument_list|,
literal|0.9
argument_list|)
expr_stmt|;
name|int
name|diffBitsLH
init|=
name|zzBits100p
operator|-
name|zzBits90p
decl_stmt|;
comment|// if the difference between 90th percentile and 100th percentile fixed
comment|// bits is> 1 then we need patch the values
if|if
condition|(
name|diffBitsLH
operator|>
literal|1
condition|)
block|{
comment|// patching is done only on base reduced values.
comment|// remove base from literals
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numLiterals
condition|;
name|i
operator|++
control|)
block|{
name|baseRedLiterals
index|[
name|i
index|]
operator|=
name|literals
index|[
name|i
index|]
operator|-
name|min
expr_stmt|;
block|}
comment|// 95th percentile width is used to determine max allowed value
comment|// after which patching will be done
name|brBits95p
operator|=
name|utils
operator|.
name|percentileBits
argument_list|(
name|baseRedLiterals
argument_list|,
literal|0
argument_list|,
name|numLiterals
argument_list|,
literal|0.95
argument_list|)
expr_stmt|;
comment|// 100th percentile is used to compute the max patch width
name|brBits100p
operator|=
name|utils
operator|.
name|percentileBits
argument_list|(
name|baseRedLiterals
argument_list|,
literal|0
argument_list|,
name|numLiterals
argument_list|,
literal|1.0
argument_list|)
expr_stmt|;
comment|// after base reducing the values, if the difference in bits between
comment|// 95th percentile and 100th percentile value is zero then there
comment|// is no point in patching the values, in which case we will
comment|// fallback to DIRECT encoding.
comment|// The decision to use patched base was based on zigzag values, but the
comment|// actual patching is done on base reduced literals.
if|if
condition|(
operator|(
name|brBits100p
operator|-
name|brBits95p
operator|)
operator|!=
literal|0
condition|)
block|{
name|encoding
operator|=
name|EncodingType
operator|.
name|PATCHED_BASE
expr_stmt|;
name|preparePatchedBlob
argument_list|()
expr_stmt|;
return|return;
block|}
else|else
block|{
name|encoding
operator|=
name|EncodingType
operator|.
name|DIRECT
expr_stmt|;
return|return;
block|}
block|}
else|else
block|{
comment|// if difference in bits between 95th percentile and 100th percentile is
comment|// 0, then patch length will become 0. Hence we will fallback to direct
name|encoding
operator|=
name|EncodingType
operator|.
name|DIRECT
expr_stmt|;
return|return;
block|}
block|}
specifier|private
name|void
name|computeZigZagLiterals
parameter_list|()
block|{
comment|// populate zigzag encoded literals
name|long
name|zzEncVal
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numLiterals
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|signed
condition|)
block|{
name|zzEncVal
operator|=
name|utils
operator|.
name|zigzagEncode
argument_list|(
name|literals
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|zzEncVal
operator|=
name|literals
index|[
name|i
index|]
expr_stmt|;
block|}
name|zigzagLiterals
index|[
name|i
index|]
operator|=
name|zzEncVal
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|preparePatchedBlob
parameter_list|()
block|{
comment|// mask will be max value beyond which patch will be generated
name|long
name|mask
init|=
operator|(
literal|1L
operator|<<
name|brBits95p
operator|)
operator|-
literal|1
decl_stmt|;
comment|// since we are considering only 95 percentile, the size of gap and
comment|// patch array can contain only be 5% values
name|patchLength
operator|=
operator|(
name|int
operator|)
name|Math
operator|.
name|ceil
argument_list|(
operator|(
name|numLiterals
operator|*
literal|0.05
operator|)
argument_list|)
expr_stmt|;
name|int
index|[]
name|gapList
init|=
operator|new
name|int
index|[
name|patchLength
index|]
decl_stmt|;
name|long
index|[]
name|patchList
init|=
operator|new
name|long
index|[
name|patchLength
index|]
decl_stmt|;
comment|// #bit for patch
name|patchWidth
operator|=
name|brBits100p
operator|-
name|brBits95p
expr_stmt|;
name|patchWidth
operator|=
name|utils
operator|.
name|getClosestFixedBits
argument_list|(
name|patchWidth
argument_list|)
expr_stmt|;
comment|// if patch bit requirement is 64 then it will not possible to pack
comment|// gap and patch together in a long. To make sure gap and patch can be
comment|// packed together adjust the patch width
if|if
condition|(
name|patchWidth
operator|==
literal|64
condition|)
block|{
name|patchWidth
operator|=
literal|56
expr_stmt|;
name|brBits95p
operator|=
literal|8
expr_stmt|;
name|mask
operator|=
operator|(
literal|1L
operator|<<
name|brBits95p
operator|)
operator|-
literal|1
expr_stmt|;
block|}
name|int
name|gapIdx
init|=
literal|0
decl_stmt|;
name|int
name|patchIdx
init|=
literal|0
decl_stmt|;
name|int
name|prev
init|=
literal|0
decl_stmt|;
name|int
name|gap
init|=
literal|0
decl_stmt|;
name|int
name|maxGap
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numLiterals
condition|;
name|i
operator|++
control|)
block|{
comment|// if value is above mask then create the patch and record the gap
if|if
condition|(
name|baseRedLiterals
index|[
name|i
index|]
operator|>
name|mask
condition|)
block|{
name|gap
operator|=
name|i
operator|-
name|prev
expr_stmt|;
if|if
condition|(
name|gap
operator|>
name|maxGap
condition|)
block|{
name|maxGap
operator|=
name|gap
expr_stmt|;
block|}
comment|// gaps are relative, so store the previous patched value index
name|prev
operator|=
name|i
expr_stmt|;
name|gapList
index|[
name|gapIdx
operator|++
index|]
operator|=
name|gap
expr_stmt|;
comment|// extract the most significant bits that are over mask bits
name|long
name|patch
init|=
name|baseRedLiterals
index|[
name|i
index|]
operator|>>>
name|brBits95p
decl_stmt|;
name|patchList
index|[
name|patchIdx
operator|++
index|]
operator|=
name|patch
expr_stmt|;
comment|// strip off the MSB to enable safe bit packing
name|baseRedLiterals
index|[
name|i
index|]
operator|&=
name|mask
expr_stmt|;
block|}
block|}
comment|// adjust the patch length to number of entries in gap list
name|patchLength
operator|=
name|gapIdx
expr_stmt|;
comment|// if the element to be patched is the first and only element then
comment|// max gap will be 0, but to store the gap as 0 we need atleast 1 bit
if|if
condition|(
name|maxGap
operator|==
literal|0
operator|&&
name|patchLength
operator|!=
literal|0
condition|)
block|{
name|patchGapWidth
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|patchGapWidth
operator|=
name|utils
operator|.
name|findClosestNumBits
argument_list|(
name|maxGap
argument_list|)
expr_stmt|;
block|}
comment|// special case: if the patch gap width is greater than 256, then
comment|// we need 9 bits to encode the gap width. But we only have 3 bits in
comment|// header to record the gap width. To deal with this case, we will save
comment|// two entries in patch list in the following way
comment|// 256 gap width => 0 for patch value
comment|// actual gap - 256 => actual patch value
comment|// We will do the same for gap width = 511. If the element to be patched is
comment|// the last element in the scope then gap width will be 511. In this case we
comment|// will have 3 entries in the patch list in the following way
comment|// 255 gap width => 0 for patch value
comment|// 255 gap width => 0 for patch value
comment|// 1 gap width => actual patch value
if|if
condition|(
name|patchGapWidth
operator|>
literal|8
condition|)
block|{
name|patchGapWidth
operator|=
literal|8
expr_stmt|;
comment|// for gap = 511, we need two additional entries in patch list
if|if
condition|(
name|maxGap
operator|==
literal|511
condition|)
block|{
name|patchLength
operator|+=
literal|2
expr_stmt|;
block|}
else|else
block|{
name|patchLength
operator|+=
literal|1
expr_stmt|;
block|}
block|}
comment|// create gap vs patch list
name|gapIdx
operator|=
literal|0
expr_stmt|;
name|patchIdx
operator|=
literal|0
expr_stmt|;
name|gapVsPatchList
operator|=
operator|new
name|long
index|[
name|patchLength
index|]
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|patchLength
condition|;
name|i
operator|++
control|)
block|{
name|long
name|g
init|=
name|gapList
index|[
name|gapIdx
operator|++
index|]
decl_stmt|;
name|long
name|p
init|=
name|patchList
index|[
name|patchIdx
operator|++
index|]
decl_stmt|;
while|while
condition|(
name|g
operator|>
literal|255
condition|)
block|{
name|gapVsPatchList
index|[
name|i
operator|++
index|]
operator|=
operator|(
literal|255L
operator|<<
name|patchWidth
operator|)
expr_stmt|;
name|g
operator|-=
literal|255
expr_stmt|;
block|}
comment|// store patch value in LSBs and gap in MSBs
name|gapVsPatchList
index|[
name|i
index|]
operator|=
operator|(
name|g
operator|<<
name|patchWidth
operator|)
operator||
name|p
expr_stmt|;
block|}
block|}
comment|/**    * clears all the variables    */
specifier|private
name|void
name|clear
parameter_list|()
block|{
name|numLiterals
operator|=
literal|0
expr_stmt|;
name|encoding
operator|=
literal|null
expr_stmt|;
name|prevDelta
operator|=
literal|0
expr_stmt|;
name|fixedDelta
operator|=
literal|0
expr_stmt|;
name|zzBits90p
operator|=
literal|0
expr_stmt|;
name|zzBits100p
operator|=
literal|0
expr_stmt|;
name|brBits95p
operator|=
literal|0
expr_stmt|;
name|brBits100p
operator|=
literal|0
expr_stmt|;
name|bitsDeltaMax
operator|=
literal|0
expr_stmt|;
name|patchGapWidth
operator|=
literal|0
expr_stmt|;
name|patchLength
operator|=
literal|0
expr_stmt|;
name|patchWidth
operator|=
literal|0
expr_stmt|;
name|gapVsPatchList
operator|=
literal|null
expr_stmt|;
name|min
operator|=
literal|0
expr_stmt|;
name|isFixedDelta
operator|=
literal|true
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|flush
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|numLiterals
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|variableRunLength
operator|!=
literal|0
condition|)
block|{
name|determineEncoding
argument_list|()
expr_stmt|;
name|writeValues
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fixedRunLength
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|fixedRunLength
operator|<
name|MIN_REPEAT
condition|)
block|{
name|variableRunLength
operator|=
name|fixedRunLength
expr_stmt|;
name|fixedRunLength
operator|=
literal|0
expr_stmt|;
name|determineEncoding
argument_list|()
expr_stmt|;
name|writeValues
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fixedRunLength
operator|>=
name|MIN_REPEAT
operator|&&
name|fixedRunLength
operator|<=
name|MAX_SHORT_REPEAT_LENGTH
condition|)
block|{
name|encoding
operator|=
name|EncodingType
operator|.
name|SHORT_REPEAT
expr_stmt|;
name|writeValues
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|encoding
operator|=
name|EncodingType
operator|.
name|DELTA
expr_stmt|;
name|isFixedDelta
operator|=
literal|true
expr_stmt|;
name|writeValues
argument_list|()
expr_stmt|;
block|}
block|}
block|}
name|output
operator|.
name|flush
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|write
parameter_list|(
name|long
name|val
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|numLiterals
operator|==
literal|0
condition|)
block|{
name|initializeLiterals
argument_list|(
name|val
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|numLiterals
operator|==
literal|1
condition|)
block|{
name|prevDelta
operator|=
name|val
operator|-
name|literals
index|[
literal|0
index|]
expr_stmt|;
name|literals
index|[
name|numLiterals
operator|++
index|]
operator|=
name|val
expr_stmt|;
comment|// if both values are same count as fixed run else variable run
if|if
condition|(
name|val
operator|==
name|literals
index|[
literal|0
index|]
condition|)
block|{
name|fixedRunLength
operator|=
literal|2
expr_stmt|;
name|variableRunLength
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|fixedRunLength
operator|=
literal|0
expr_stmt|;
name|variableRunLength
operator|=
literal|2
expr_stmt|;
block|}
block|}
else|else
block|{
name|long
name|currentDelta
init|=
name|val
operator|-
name|literals
index|[
name|numLiterals
operator|-
literal|1
index|]
decl_stmt|;
if|if
condition|(
name|prevDelta
operator|==
literal|0
operator|&&
name|currentDelta
operator|==
literal|0
condition|)
block|{
comment|// fixed delta run
name|literals
index|[
name|numLiterals
operator|++
index|]
operator|=
name|val
expr_stmt|;
comment|// if variable run is non-zero then we are seeing repeating
comment|// values at the end of variable run in which case keep
comment|// updating variable and fixed runs
if|if
condition|(
name|variableRunLength
operator|>
literal|0
condition|)
block|{
name|fixedRunLength
operator|=
literal|2
expr_stmt|;
block|}
name|fixedRunLength
operator|+=
literal|1
expr_stmt|;
comment|// if fixed run met the minimum condition and if variable
comment|// run is non-zero then flush the variable run and shift the
comment|// tail fixed runs to start of the buffer
if|if
condition|(
name|fixedRunLength
operator|>=
name|MIN_REPEAT
operator|&&
name|variableRunLength
operator|>
literal|0
condition|)
block|{
name|numLiterals
operator|-=
name|MIN_REPEAT
expr_stmt|;
name|variableRunLength
operator|-=
name|MIN_REPEAT
operator|-
literal|1
expr_stmt|;
comment|// copy the tail fixed runs
name|long
index|[]
name|tailVals
init|=
operator|new
name|long
index|[
name|MIN_REPEAT
index|]
decl_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|literals
argument_list|,
name|numLiterals
argument_list|,
name|tailVals
argument_list|,
literal|0
argument_list|,
name|MIN_REPEAT
argument_list|)
expr_stmt|;
comment|// determine variable encoding and flush values
name|determineEncoding
argument_list|()
expr_stmt|;
name|writeValues
argument_list|()
expr_stmt|;
comment|// shift tail fixed runs to beginning of the buffer
for|for
control|(
name|long
name|l
range|:
name|tailVals
control|)
block|{
name|literals
index|[
name|numLiterals
operator|++
index|]
operator|=
name|l
expr_stmt|;
block|}
block|}
comment|// if fixed runs reached max repeat length then write values
if|if
condition|(
name|fixedRunLength
operator|==
name|MAX_SCOPE
condition|)
block|{
name|determineEncoding
argument_list|()
expr_stmt|;
name|writeValues
argument_list|()
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// variable delta run
comment|// if fixed run length is non-zero and if it satisfies the
comment|// short repeat conditions then write the values as short repeats
comment|// else use delta encoding
if|if
condition|(
name|fixedRunLength
operator|>=
name|MIN_REPEAT
condition|)
block|{
if|if
condition|(
name|fixedRunLength
operator|<=
name|MAX_SHORT_REPEAT_LENGTH
condition|)
block|{
name|encoding
operator|=
name|EncodingType
operator|.
name|SHORT_REPEAT
expr_stmt|;
name|writeValues
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|encoding
operator|=
name|EncodingType
operator|.
name|DELTA
expr_stmt|;
name|isFixedDelta
operator|=
literal|true
expr_stmt|;
name|writeValues
argument_list|()
expr_stmt|;
block|}
block|}
comment|// if fixed run length is<MIN_REPEAT and current value is
comment|// different from previous then treat it as variable run
if|if
condition|(
name|fixedRunLength
operator|>
literal|0
operator|&&
name|fixedRunLength
operator|<
name|MIN_REPEAT
condition|)
block|{
if|if
condition|(
name|val
operator|!=
name|literals
index|[
name|numLiterals
operator|-
literal|1
index|]
condition|)
block|{
name|variableRunLength
operator|=
name|fixedRunLength
expr_stmt|;
name|fixedRunLength
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|// after writing values re-initialize the variables
if|if
condition|(
name|numLiterals
operator|==
literal|0
condition|)
block|{
name|initializeLiterals
argument_list|(
name|val
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// keep updating variable run lengths
name|prevDelta
operator|=
name|val
operator|-
name|literals
index|[
name|numLiterals
operator|-
literal|1
index|]
expr_stmt|;
name|literals
index|[
name|numLiterals
operator|++
index|]
operator|=
name|val
expr_stmt|;
name|variableRunLength
operator|+=
literal|1
expr_stmt|;
comment|// if variable run length reach the max scope, write it
if|if
condition|(
name|variableRunLength
operator|==
name|MAX_SCOPE
condition|)
block|{
name|determineEncoding
argument_list|()
expr_stmt|;
name|writeValues
argument_list|()
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
block|}
specifier|private
name|void
name|initializeLiterals
parameter_list|(
name|long
name|val
parameter_list|)
block|{
name|literals
index|[
name|numLiterals
operator|++
index|]
operator|=
name|val
expr_stmt|;
name|fixedRunLength
operator|=
literal|1
expr_stmt|;
name|variableRunLength
operator|=
literal|1
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|getPosition
parameter_list|(
name|PositionRecorder
name|recorder
parameter_list|)
throws|throws
name|IOException
block|{
name|output
operator|.
name|getPosition
argument_list|(
name|recorder
argument_list|)
expr_stmt|;
name|recorder
operator|.
name|addPosition
argument_list|(
name|numLiterals
argument_list|)
expr_stmt|;
block|}
block|}
end_class

end_unit

