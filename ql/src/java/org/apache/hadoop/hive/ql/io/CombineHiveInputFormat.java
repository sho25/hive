begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|io
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|DataInput
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|DataOutput
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|Callable
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ExecutionException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ExecutorService
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|Executors
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|Future
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|VisibleForTesting
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FileSystem
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|Path
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|PathFilter
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|metastore
operator|.
name|MetaStoreUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|Operator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|Utilities
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|log
operator|.
name|PerfLogger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|parse
operator|.
name|SplitSample
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|OperatorDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|PartitionDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|TableDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|session
operator|.
name|SessionState
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|shims
operator|.
name|HadoopShims
operator|.
name|CombineFileInputFormatShim
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|shims
operator|.
name|HadoopShimsSecure
operator|.
name|InputSplitShim
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|shims
operator|.
name|ShimLoader
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|Writable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|WritableComparable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapred
operator|.
name|FileInputFormat
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapred
operator|.
name|InputFormat
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapred
operator|.
name|InputSplit
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapred
operator|.
name|JobConf
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapred
operator|.
name|RecordReader
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapred
operator|.
name|Reporter
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapred
operator|.
name|lib
operator|.
name|CombineFileSplit
import|;
end_import

begin_comment
comment|/**  * CombineHiveInputFormat is a parameterized InputFormat which looks at the path  * name and determine the correct InputFormat for that path name from  * mapredPlan.pathToPartitionInfo(). It can be used to read files with different  * input format in the same map-reduce job.  */
end_comment

begin_class
specifier|public
class|class
name|CombineHiveInputFormat
parameter_list|<
name|K
extends|extends
name|WritableComparable
parameter_list|,
name|V
extends|extends
name|Writable
parameter_list|>
extends|extends
name|HiveInputFormat
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
block|{
specifier|private
specifier|static
specifier|final
name|String
name|CLASS_NAME
init|=
name|CombineHiveInputFormat
operator|.
name|class
operator|.
name|getName
argument_list|()
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|Logger
name|LOG
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|CLASS_NAME
argument_list|)
decl_stmt|;
comment|// max number of threads we can use to check non-combinable paths
specifier|private
specifier|static
specifier|final
name|int
name|MAX_CHECK_NONCOMBINABLE_THREAD_NUM
init|=
literal|50
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|int
name|DEFAULT_NUM_PATH_PER_THREAD
init|=
literal|100
decl_stmt|;
specifier|private
class|class
name|CheckNonCombinablePathCallable
implements|implements
name|Callable
argument_list|<
name|Set
argument_list|<
name|Integer
argument_list|>
argument_list|>
block|{
specifier|private
specifier|final
name|Path
index|[]
name|paths
decl_stmt|;
specifier|private
specifier|final
name|int
name|start
decl_stmt|;
specifier|private
specifier|final
name|int
name|length
decl_stmt|;
specifier|private
specifier|final
name|JobConf
name|conf
decl_stmt|;
specifier|public
name|CheckNonCombinablePathCallable
parameter_list|(
name|Path
index|[]
name|paths
parameter_list|,
name|int
name|start
parameter_list|,
name|int
name|length
parameter_list|,
name|JobConf
name|conf
parameter_list|)
block|{
name|this
operator|.
name|paths
operator|=
name|paths
expr_stmt|;
name|this
operator|.
name|start
operator|=
name|start
expr_stmt|;
name|this
operator|.
name|length
operator|=
name|length
expr_stmt|;
name|this
operator|.
name|conf
operator|=
name|conf
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|Set
argument_list|<
name|Integer
argument_list|>
name|call
parameter_list|()
throws|throws
name|Exception
block|{
name|Set
argument_list|<
name|Integer
argument_list|>
name|nonCombinablePathIndices
init|=
operator|new
name|HashSet
argument_list|<
name|Integer
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|length
condition|;
name|i
operator|++
control|)
block|{
name|PartitionDesc
name|part
init|=
name|HiveFileFormatUtils
operator|.
name|getPartitionDescFromPathRecursively
argument_list|(
name|pathToPartitionInfo
argument_list|,
name|paths
index|[
name|i
operator|+
name|start
index|]
argument_list|,
name|IOPrepareCache
operator|.
name|get
argument_list|()
operator|.
name|allocatePartitionDescMap
argument_list|()
argument_list|)
decl_stmt|;
comment|// Use HiveInputFormat if any of the paths is not splittable
name|Class
argument_list|<
name|?
extends|extends
name|InputFormat
argument_list|>
name|inputFormatClass
init|=
name|part
operator|.
name|getInputFileFormatClass
argument_list|()
decl_stmt|;
name|InputFormat
argument_list|<
name|WritableComparable
argument_list|,
name|Writable
argument_list|>
name|inputFormat
init|=
name|getInputFormatFromCache
argument_list|(
name|inputFormatClass
argument_list|,
name|conf
argument_list|)
decl_stmt|;
name|boolean
name|isAvoidSplitCombine
init|=
name|inputFormat
operator|instanceof
name|AvoidSplitCombination
operator|&&
operator|(
operator|(
name|AvoidSplitCombination
operator|)
name|inputFormat
operator|)
operator|.
name|shouldSkipCombine
argument_list|(
name|paths
index|[
name|i
operator|+
name|start
index|]
argument_list|,
name|conf
argument_list|)
decl_stmt|;
name|boolean
name|isMmTable
init|=
name|MetaStoreUtils
operator|.
name|isInsertOnlyTable
argument_list|(
name|part
operator|.
name|getTableDesc
argument_list|()
operator|.
name|getProperties
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|isAvoidSplitCombine
operator|||
name|isMmTable
condition|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"The path ["
operator|+
name|paths
index|[
name|i
operator|+
name|start
index|]
operator|+
literal|"] is being parked for HiveInputFormat.getSplits"
argument_list|)
expr_stmt|;
block|}
name|nonCombinablePathIndices
operator|.
name|add
argument_list|(
name|i
operator|+
name|start
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|nonCombinablePathIndices
return|;
block|}
block|}
comment|/**    * CombineHiveInputSplit encapsulates an InputSplit with its corresponding    * inputFormatClassName. A CombineHiveInputSplit comprises of multiple chunks    * from different files. Since, they belong to a single directory, there is a    * single inputformat for all the chunks.    */
specifier|public
specifier|static
class|class
name|CombineHiveInputSplit
extends|extends
name|InputSplitShim
block|{
specifier|private
name|String
name|inputFormatClassName
decl_stmt|;
specifier|private
name|CombineFileSplit
name|inputSplitShim
decl_stmt|;
specifier|private
name|Map
argument_list|<
name|Path
argument_list|,
name|PartitionDesc
argument_list|>
name|pathToPartitionInfo
decl_stmt|;
specifier|public
name|CombineHiveInputSplit
parameter_list|()
throws|throws
name|IOException
block|{
name|this
argument_list|(
name|ShimLoader
operator|.
name|getHadoopShims
argument_list|()
operator|.
name|getCombineFileInputFormat
argument_list|()
operator|.
name|getInputSplitShim
argument_list|()
argument_list|)
expr_stmt|;
block|}
specifier|public
name|CombineHiveInputSplit
parameter_list|(
name|CombineFileSplit
name|inputSplitShim
parameter_list|)
throws|throws
name|IOException
block|{
name|this
argument_list|(
name|inputSplitShim
operator|.
name|getJob
argument_list|()
argument_list|,
name|inputSplitShim
argument_list|)
expr_stmt|;
block|}
specifier|public
name|CombineHiveInputSplit
parameter_list|(
name|JobConf
name|job
parameter_list|,
name|CombineFileSplit
name|inputSplitShim
parameter_list|)
throws|throws
name|IOException
block|{
name|this
argument_list|(
name|job
argument_list|,
name|inputSplitShim
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
specifier|public
name|CombineHiveInputSplit
parameter_list|(
name|JobConf
name|job
parameter_list|,
name|CombineFileSplit
name|inputSplitShim
parameter_list|,
name|Map
argument_list|<
name|Path
argument_list|,
name|PartitionDesc
argument_list|>
name|pathToPartitionInfo
parameter_list|)
throws|throws
name|IOException
block|{
name|this
operator|.
name|inputSplitShim
operator|=
name|inputSplitShim
expr_stmt|;
name|this
operator|.
name|pathToPartitionInfo
operator|=
name|pathToPartitionInfo
expr_stmt|;
if|if
condition|(
name|job
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|this
operator|.
name|pathToPartitionInfo
operator|==
literal|null
condition|)
block|{
name|this
operator|.
name|pathToPartitionInfo
operator|=
name|Utilities
operator|.
name|getMapWork
argument_list|(
name|job
argument_list|)
operator|.
name|getPathToPartitionInfo
argument_list|()
expr_stmt|;
block|}
comment|// extract all the inputFormatClass names for each chunk in the
comment|// CombinedSplit.
name|Path
index|[]
name|ipaths
init|=
name|inputSplitShim
operator|.
name|getPaths
argument_list|()
decl_stmt|;
if|if
condition|(
name|ipaths
operator|.
name|length
operator|>
literal|0
condition|)
block|{
name|PartitionDesc
name|part
init|=
name|HiveFileFormatUtils
operator|.
name|getPartitionDescFromPathRecursively
argument_list|(
name|this
operator|.
name|pathToPartitionInfo
argument_list|,
name|ipaths
index|[
literal|0
index|]
argument_list|,
name|IOPrepareCache
operator|.
name|get
argument_list|()
operator|.
name|getPartitionDescMap
argument_list|()
argument_list|)
decl_stmt|;
name|inputFormatClassName
operator|=
name|part
operator|.
name|getInputFileFormatClass
argument_list|()
operator|.
name|getName
argument_list|()
expr_stmt|;
block|}
block|}
block|}
specifier|public
name|CombineFileSplit
name|getInputSplitShim
parameter_list|()
block|{
return|return
name|inputSplitShim
return|;
block|}
comment|/**      * Returns the inputFormat class name for the i-th chunk.      */
specifier|public
name|String
name|inputFormatClassName
parameter_list|()
block|{
return|return
name|inputFormatClassName
return|;
block|}
specifier|public
name|void
name|setInputFormatClassName
parameter_list|(
name|String
name|inputFormatClassName
parameter_list|)
block|{
name|this
operator|.
name|inputFormatClassName
operator|=
name|inputFormatClassName
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|JobConf
name|getJob
parameter_list|()
block|{
return|return
name|inputSplitShim
operator|.
name|getJob
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|long
name|getLength
parameter_list|()
block|{
return|return
name|inputSplitShim
operator|.
name|getLength
argument_list|()
return|;
block|}
comment|/** Returns an array containing the startoffsets of the files in the split. */
annotation|@
name|Override
specifier|public
name|long
index|[]
name|getStartOffsets
parameter_list|()
block|{
return|return
name|inputSplitShim
operator|.
name|getStartOffsets
argument_list|()
return|;
block|}
comment|/** Returns an array containing the lengths of the files in the split. */
annotation|@
name|Override
specifier|public
name|long
index|[]
name|getLengths
parameter_list|()
block|{
return|return
name|inputSplitShim
operator|.
name|getLengths
argument_list|()
return|;
block|}
comment|/** Returns the start offset of the i<sup>th</sup> Path. */
annotation|@
name|Override
specifier|public
name|long
name|getOffset
parameter_list|(
name|int
name|i
parameter_list|)
block|{
return|return
name|inputSplitShim
operator|.
name|getOffset
argument_list|(
name|i
argument_list|)
return|;
block|}
comment|/** Returns the length of the i<sup>th</sup> Path. */
annotation|@
name|Override
specifier|public
name|long
name|getLength
parameter_list|(
name|int
name|i
parameter_list|)
block|{
return|return
name|inputSplitShim
operator|.
name|getLength
argument_list|(
name|i
argument_list|)
return|;
block|}
comment|/** Returns the number of Paths in the split. */
annotation|@
name|Override
specifier|public
name|int
name|getNumPaths
parameter_list|()
block|{
return|return
name|inputSplitShim
operator|.
name|getNumPaths
argument_list|()
return|;
block|}
comment|/** Returns the i<sup>th</sup> Path. */
annotation|@
name|Override
specifier|public
name|Path
name|getPath
parameter_list|(
name|int
name|i
parameter_list|)
block|{
return|return
name|inputSplitShim
operator|.
name|getPath
argument_list|(
name|i
argument_list|)
return|;
block|}
comment|/** Returns all the Paths in the split. */
annotation|@
name|Override
specifier|public
name|Path
index|[]
name|getPaths
parameter_list|()
block|{
return|return
name|inputSplitShim
operator|.
name|getPaths
argument_list|()
return|;
block|}
comment|/** Returns all the Paths where this input-split resides. */
annotation|@
name|Override
specifier|public
name|String
index|[]
name|getLocations
parameter_list|()
throws|throws
name|IOException
block|{
return|return
name|inputSplitShim
operator|.
name|getLocations
argument_list|()
return|;
block|}
comment|/**      * Prints this obejct as a string.      */
annotation|@
name|Override
specifier|public
name|String
name|toString
parameter_list|()
block|{
name|StringBuilder
name|sb
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|sb
operator|.
name|append
argument_list|(
name|inputSplitShim
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|"InputFormatClass: "
operator|+
name|inputFormatClassName
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
return|return
name|sb
operator|.
name|toString
argument_list|()
return|;
block|}
comment|/**      * Writable interface.      */
annotation|@
name|Override
specifier|public
name|void
name|readFields
parameter_list|(
name|DataInput
name|in
parameter_list|)
throws|throws
name|IOException
block|{
name|inputSplitShim
operator|.
name|readFields
argument_list|(
name|in
argument_list|)
expr_stmt|;
name|inputFormatClassName
operator|=
name|in
operator|.
name|readUTF
argument_list|()
expr_stmt|;
block|}
comment|/**      * Writable interface.      */
annotation|@
name|Override
specifier|public
name|void
name|write
parameter_list|(
name|DataOutput
name|out
parameter_list|)
throws|throws
name|IOException
block|{
name|inputSplitShim
operator|.
name|write
argument_list|(
name|out
argument_list|)
expr_stmt|;
if|if
condition|(
name|inputFormatClassName
operator|==
literal|null
condition|)
block|{
if|if
condition|(
name|pathToPartitionInfo
operator|==
literal|null
condition|)
block|{
name|pathToPartitionInfo
operator|=
name|Utilities
operator|.
name|getMapWork
argument_list|(
name|getJob
argument_list|()
argument_list|)
operator|.
name|getPathToPartitionInfo
argument_list|()
expr_stmt|;
block|}
comment|// extract all the inputFormatClass names for each chunk in the
comment|// CombinedSplit.
name|PartitionDesc
name|part
init|=
name|HiveFileFormatUtils
operator|.
name|getPartitionDescFromPathRecursively
argument_list|(
name|pathToPartitionInfo
argument_list|,
name|inputSplitShim
operator|.
name|getPath
argument_list|(
literal|0
argument_list|)
argument_list|,
name|IOPrepareCache
operator|.
name|get
argument_list|()
operator|.
name|getPartitionDescMap
argument_list|()
argument_list|)
decl_stmt|;
comment|// create a new InputFormat instance if this is the first time to see
comment|// this class
name|inputFormatClassName
operator|=
name|part
operator|.
name|getInputFileFormatClass
argument_list|()
operator|.
name|getName
argument_list|()
expr_stmt|;
block|}
name|out
operator|.
name|writeUTF
argument_list|(
name|inputFormatClassName
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Splits are not shared across different partitions with different input formats.
comment|// For example, 2 partitions (1 sequencefile and 1 rcfile) will have 2 different splits
specifier|private
specifier|static
class|class
name|CombinePathInputFormat
block|{
specifier|private
specifier|final
name|List
argument_list|<
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
argument_list|>
name|opList
decl_stmt|;
specifier|private
specifier|final
name|String
name|inputFormatClassName
decl_stmt|;
specifier|private
specifier|final
name|String
name|deserializerClassName
decl_stmt|;
specifier|public
name|CombinePathInputFormat
parameter_list|(
name|List
argument_list|<
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
argument_list|>
name|opList
parameter_list|,
name|String
name|inputFormatClassName
parameter_list|,
name|String
name|deserializerClassName
parameter_list|)
block|{
name|this
operator|.
name|opList
operator|=
name|opList
expr_stmt|;
name|this
operator|.
name|inputFormatClassName
operator|=
name|inputFormatClassName
expr_stmt|;
name|this
operator|.
name|deserializerClassName
operator|=
name|deserializerClassName
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|equals
parameter_list|(
name|Object
name|o
parameter_list|)
block|{
if|if
condition|(
name|o
operator|instanceof
name|CombinePathInputFormat
condition|)
block|{
name|CombinePathInputFormat
name|mObj
init|=
operator|(
name|CombinePathInputFormat
operator|)
name|o
decl_stmt|;
return|return
operator|(
name|opList
operator|.
name|equals
argument_list|(
name|mObj
operator|.
name|opList
argument_list|)
operator|)
operator|&&
operator|(
name|inputFormatClassName
operator|.
name|equals
argument_list|(
name|mObj
operator|.
name|inputFormatClassName
argument_list|)
operator|)
operator|&&
operator|(
name|deserializerClassName
operator|==
literal|null
condition|?
operator|(
name|mObj
operator|.
name|deserializerClassName
operator|==
literal|null
operator|)
else|:
name|deserializerClassName
operator|.
name|equals
argument_list|(
name|mObj
operator|.
name|deserializerClassName
argument_list|)
operator|)
return|;
block|}
return|return
literal|false
return|;
block|}
annotation|@
name|Override
specifier|public
name|int
name|hashCode
parameter_list|()
block|{
return|return
operator|(
name|opList
operator|==
literal|null
operator|)
condition|?
literal|0
else|:
name|opList
operator|.
name|hashCode
argument_list|()
return|;
block|}
block|}
comment|/**    * Create Hive splits based on CombineFileSplit.    */
specifier|private
name|InputSplit
index|[]
name|getCombineSplits
parameter_list|(
name|JobConf
name|job
parameter_list|,
name|int
name|numSplits
parameter_list|,
name|Map
argument_list|<
name|Path
argument_list|,
name|PartitionDesc
argument_list|>
name|pathToPartitionInfo
parameter_list|)
throws|throws
name|IOException
block|{
name|init
argument_list|(
name|job
argument_list|)
expr_stmt|;
name|Map
argument_list|<
name|Path
argument_list|,
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|>
name|pathToAliases
init|=
name|mrwork
operator|.
name|getPathToAliases
argument_list|()
decl_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
argument_list|>
name|aliasToWork
init|=
name|mrwork
operator|.
name|getAliasToWork
argument_list|()
decl_stmt|;
name|CombineFileInputFormatShim
name|combine
init|=
name|ShimLoader
operator|.
name|getHadoopShims
argument_list|()
operator|.
name|getCombineFileInputFormat
argument_list|()
decl_stmt|;
name|InputSplit
index|[]
name|splits
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|combine
operator|==
literal|null
condition|)
block|{
name|splits
operator|=
name|super
operator|.
name|getSplits
argument_list|(
name|job
argument_list|,
name|numSplits
argument_list|)
expr_stmt|;
return|return
name|splits
return|;
block|}
if|if
condition|(
name|combine
operator|.
name|getInputPathsShim
argument_list|(
name|job
argument_list|)
operator|.
name|length
operator|==
literal|0
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"No input paths specified in job"
argument_list|)
throw|;
block|}
name|ArrayList
argument_list|<
name|InputSplit
argument_list|>
name|result
init|=
operator|new
name|ArrayList
argument_list|<
name|InputSplit
argument_list|>
argument_list|()
decl_stmt|;
comment|// combine splits only from same tables and same partitions. Do not combine splits from multiple
comment|// tables or multiple partitions.
name|Path
index|[]
name|paths
init|=
name|combine
operator|.
name|getInputPathsShim
argument_list|(
name|job
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|Path
argument_list|>
name|inpDirs
init|=
operator|new
name|ArrayList
argument_list|<
name|Path
argument_list|>
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|Path
argument_list|>
name|inpFiles
init|=
operator|new
name|ArrayList
argument_list|<
name|Path
argument_list|>
argument_list|()
decl_stmt|;
name|Map
argument_list|<
name|CombinePathInputFormat
argument_list|,
name|CombineFilter
argument_list|>
name|poolMap
init|=
operator|new
name|HashMap
argument_list|<
name|CombinePathInputFormat
argument_list|,
name|CombineFilter
argument_list|>
argument_list|()
decl_stmt|;
name|Set
argument_list|<
name|Path
argument_list|>
name|poolSet
init|=
operator|new
name|HashSet
argument_list|<
name|Path
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|Path
name|path
range|:
name|paths
control|)
block|{
name|PartitionDesc
name|part
init|=
name|HiveFileFormatUtils
operator|.
name|getPartitionDescFromPathRecursively
argument_list|(
name|pathToPartitionInfo
argument_list|,
name|path
argument_list|,
name|IOPrepareCache
operator|.
name|get
argument_list|()
operator|.
name|allocatePartitionDescMap
argument_list|()
argument_list|)
decl_stmt|;
name|TableDesc
name|tableDesc
init|=
name|part
operator|.
name|getTableDesc
argument_list|()
decl_stmt|;
if|if
condition|(
operator|(
name|tableDesc
operator|!=
literal|null
operator|)
operator|&&
name|tableDesc
operator|.
name|isNonNative
argument_list|()
condition|)
block|{
return|return
name|super
operator|.
name|getSplits
argument_list|(
name|job
argument_list|,
name|numSplits
argument_list|)
return|;
block|}
comment|// Use HiveInputFormat if any of the paths is not splittable
name|Class
name|inputFormatClass
init|=
name|part
operator|.
name|getInputFileFormatClass
argument_list|()
decl_stmt|;
name|String
name|inputFormatClassName
init|=
name|inputFormatClass
operator|.
name|getName
argument_list|()
decl_stmt|;
name|InputFormat
name|inputFormat
init|=
name|getInputFormatFromCache
argument_list|(
name|inputFormatClass
argument_list|,
name|job
argument_list|)
decl_stmt|;
name|String
name|deserializerClassName
init|=
literal|null
decl_stmt|;
try|try
block|{
name|deserializerClassName
operator|=
name|part
operator|.
name|getDeserializer
argument_list|(
name|job
argument_list|)
operator|.
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
comment|// ignore
block|}
name|FileSystem
name|inpFs
init|=
name|path
operator|.
name|getFileSystem
argument_list|(
name|job
argument_list|)
decl_stmt|;
comment|//don't combine if inputformat is a SymlinkTextInputFormat
if|if
condition|(
name|inputFormat
operator|instanceof
name|SymlinkTextInputFormat
condition|)
block|{
name|splits
operator|=
name|super
operator|.
name|getSplits
argument_list|(
name|job
argument_list|,
name|numSplits
argument_list|)
expr_stmt|;
return|return
name|splits
return|;
block|}
name|Path
name|filterPath
init|=
name|path
decl_stmt|;
comment|// Does a pool exist for this path already
name|CombineFilter
name|f
init|=
literal|null
decl_stmt|;
name|List
argument_list|<
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
argument_list|>
name|opList
init|=
literal|null
decl_stmt|;
if|if
condition|(
operator|!
name|mrwork
operator|.
name|isMapperCannotSpanPartns
argument_list|()
condition|)
block|{
comment|//if mapper can span partitions, make sure a splits does not contain multiple
comment|// opList + inputFormatClassName + deserializerClassName combination
comment|// This is done using the Map of CombinePathInputFormat to PathFilter
name|opList
operator|=
name|HiveFileFormatUtils
operator|.
name|doGetWorksFromPath
argument_list|(
name|pathToAliases
argument_list|,
name|aliasToWork
argument_list|,
name|filterPath
argument_list|)
expr_stmt|;
name|CombinePathInputFormat
name|combinePathInputFormat
init|=
operator|new
name|CombinePathInputFormat
argument_list|(
name|opList
argument_list|,
name|inputFormatClassName
argument_list|,
name|deserializerClassName
argument_list|)
decl_stmt|;
name|f
operator|=
name|poolMap
operator|.
name|get
argument_list|(
name|combinePathInputFormat
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
operator|==
literal|null
condition|)
block|{
name|f
operator|=
operator|new
name|CombineFilter
argument_list|(
name|filterPath
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"CombineHiveInputSplit creating pool for "
operator|+
name|path
operator|+
literal|"; using filter path "
operator|+
name|filterPath
argument_list|)
expr_stmt|;
name|combine
operator|.
name|createPool
argument_list|(
name|job
argument_list|,
name|f
argument_list|)
expr_stmt|;
name|poolMap
operator|.
name|put
argument_list|(
name|combinePathInputFormat
argument_list|,
name|f
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"CombineHiveInputSplit: pool is already created for "
operator|+
name|path
operator|+
literal|"; using filter path "
operator|+
name|filterPath
argument_list|)
expr_stmt|;
name|f
operator|.
name|addPath
argument_list|(
name|filterPath
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// In the case of tablesample, the input paths are pointing to files rather than directories.
comment|// We need to get the parent directory as the filtering path so that all files in the same
comment|// parent directory will be grouped into one pool but not files from different parent
comment|// directories. This guarantees that a split will combine all files in the same partition
comment|// but won't cross multiple partitions if the user has asked so.
if|if
condition|(
operator|!
name|path
operator|.
name|getFileSystem
argument_list|(
name|job
argument_list|)
operator|.
name|getFileStatus
argument_list|(
name|path
argument_list|)
operator|.
name|isDir
argument_list|()
condition|)
block|{
comment|// path is not directory
name|filterPath
operator|=
name|path
operator|.
name|getParent
argument_list|()
expr_stmt|;
name|inpFiles
operator|.
name|add
argument_list|(
name|path
argument_list|)
expr_stmt|;
name|poolSet
operator|.
name|add
argument_list|(
name|filterPath
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|inpDirs
operator|.
name|add
argument_list|(
name|path
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|// Processing directories
name|List
argument_list|<
name|CombineFileSplit
argument_list|>
name|iss
init|=
operator|new
name|ArrayList
argument_list|<
name|CombineFileSplit
argument_list|>
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|mrwork
operator|.
name|isMapperCannotSpanPartns
argument_list|()
condition|)
block|{
comment|//mapper can span partitions
comment|//combine into as few as one split, subject to the PathFilters set
comment|// using combine.createPool.
name|iss
operator|=
name|Arrays
operator|.
name|asList
argument_list|(
name|combine
operator|.
name|getSplits
argument_list|(
name|job
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|Path
name|path
range|:
name|inpDirs
control|)
block|{
name|processPaths
argument_list|(
name|job
argument_list|,
name|combine
argument_list|,
name|iss
argument_list|,
name|path
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|inpFiles
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
comment|// Processing files
for|for
control|(
name|Path
name|filterPath
range|:
name|poolSet
control|)
block|{
name|combine
operator|.
name|createPool
argument_list|(
name|job
argument_list|,
operator|new
name|CombineFilter
argument_list|(
name|filterPath
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|processPaths
argument_list|(
name|job
argument_list|,
name|combine
argument_list|,
name|iss
argument_list|,
name|inpFiles
operator|.
name|toArray
argument_list|(
operator|new
name|Path
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|mrwork
operator|.
name|getNameToSplitSample
argument_list|()
operator|!=
literal|null
operator|&&
operator|!
name|mrwork
operator|.
name|getNameToSplitSample
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|iss
operator|=
name|sampleSplits
argument_list|(
name|iss
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|CombineFileSplit
name|is
range|:
name|iss
control|)
block|{
name|CombineHiveInputSplit
name|csplit
init|=
operator|new
name|CombineHiveInputSplit
argument_list|(
name|job
argument_list|,
name|is
argument_list|,
name|pathToPartitionInfo
argument_list|)
decl_stmt|;
name|result
operator|.
name|add
argument_list|(
name|csplit
argument_list|)
expr_stmt|;
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"number of splits "
operator|+
name|result
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|result
operator|.
name|toArray
argument_list|(
operator|new
name|CombineHiveInputSplit
index|[
name|result
operator|.
name|size
argument_list|()
index|]
argument_list|)
return|;
block|}
comment|/**    * Gets all the path indices that should not be combined    */
annotation|@
name|VisibleForTesting
specifier|public
name|Set
argument_list|<
name|Integer
argument_list|>
name|getNonCombinablePathIndices
parameter_list|(
name|JobConf
name|job
parameter_list|,
name|Path
index|[]
name|paths
parameter_list|,
name|int
name|numThreads
parameter_list|)
throws|throws
name|ExecutionException
throws|,
name|InterruptedException
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Total number of paths: "
operator|+
name|paths
operator|.
name|length
operator|+
literal|", launching "
operator|+
name|numThreads
operator|+
literal|" threads to check non-combinable ones."
argument_list|)
expr_stmt|;
name|int
name|numPathPerThread
init|=
operator|(
name|int
operator|)
name|Math
operator|.
name|ceil
argument_list|(
operator|(
name|double
operator|)
name|paths
operator|.
name|length
operator|/
name|numThreads
argument_list|)
decl_stmt|;
name|ExecutorService
name|executor
init|=
name|Executors
operator|.
name|newFixedThreadPool
argument_list|(
name|numThreads
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|Future
argument_list|<
name|Set
argument_list|<
name|Integer
argument_list|>
argument_list|>
argument_list|>
name|futureList
init|=
operator|new
name|ArrayList
argument_list|<
name|Future
argument_list|<
name|Set
argument_list|<
name|Integer
argument_list|>
argument_list|>
argument_list|>
argument_list|(
name|numThreads
argument_list|)
decl_stmt|;
try|try
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numThreads
condition|;
name|i
operator|++
control|)
block|{
name|int
name|start
init|=
name|i
operator|*
name|numPathPerThread
decl_stmt|;
name|int
name|length
init|=
name|i
operator|!=
name|numThreads
operator|-
literal|1
condition|?
name|numPathPerThread
else|:
name|paths
operator|.
name|length
operator|-
name|start
decl_stmt|;
name|futureList
operator|.
name|add
argument_list|(
name|executor
operator|.
name|submit
argument_list|(
operator|new
name|CheckNonCombinablePathCallable
argument_list|(
name|paths
argument_list|,
name|start
argument_list|,
name|length
argument_list|,
name|job
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|Set
argument_list|<
name|Integer
argument_list|>
name|nonCombinablePathIndices
init|=
operator|new
name|HashSet
argument_list|<
name|Integer
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|Future
argument_list|<
name|Set
argument_list|<
name|Integer
argument_list|>
argument_list|>
name|future
range|:
name|futureList
control|)
block|{
name|nonCombinablePathIndices
operator|.
name|addAll
argument_list|(
name|future
operator|.
name|get
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|nonCombinablePathIndices
return|;
block|}
finally|finally
block|{
name|executor
operator|.
name|shutdownNow
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Create Hive splits based on CombineFileSplit.    */
annotation|@
name|Override
specifier|public
name|InputSplit
index|[]
name|getSplits
parameter_list|(
name|JobConf
name|job
parameter_list|,
name|int
name|numSplits
parameter_list|)
throws|throws
name|IOException
block|{
name|PerfLogger
name|perfLogger
init|=
name|SessionState
operator|.
name|getPerfLogger
argument_list|()
decl_stmt|;
name|perfLogger
operator|.
name|PerfLogBegin
argument_list|(
name|CLASS_NAME
argument_list|,
name|PerfLogger
operator|.
name|GET_SPLITS
argument_list|)
expr_stmt|;
name|init
argument_list|(
name|job
argument_list|)
expr_stmt|;
name|ArrayList
argument_list|<
name|InputSplit
argument_list|>
name|result
init|=
operator|new
name|ArrayList
argument_list|<
name|InputSplit
argument_list|>
argument_list|()
decl_stmt|;
name|Path
index|[]
name|paths
init|=
name|getInputPaths
argument_list|(
name|job
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|Path
argument_list|>
name|nonCombinablePaths
init|=
operator|new
name|ArrayList
argument_list|<
name|Path
argument_list|>
argument_list|(
name|paths
operator|.
name|length
operator|/
literal|2
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|Path
argument_list|>
name|combinablePaths
init|=
operator|new
name|ArrayList
argument_list|<
name|Path
argument_list|>
argument_list|(
name|paths
operator|.
name|length
operator|/
literal|2
argument_list|)
decl_stmt|;
name|int
name|numThreads
init|=
name|Math
operator|.
name|min
argument_list|(
name|MAX_CHECK_NONCOMBINABLE_THREAD_NUM
argument_list|,
operator|(
name|int
operator|)
name|Math
operator|.
name|ceil
argument_list|(
operator|(
name|double
operator|)
name|paths
operator|.
name|length
operator|/
name|DEFAULT_NUM_PATH_PER_THREAD
argument_list|)
argument_list|)
decl_stmt|;
comment|// This check is necessary because for Spark branch, the result array from
comment|// getInputPaths() above could be empty, and therefore numThreads could be 0.
comment|// In that case, Executors.newFixedThreadPool will fail.
if|if
condition|(
name|numThreads
operator|>
literal|0
condition|)
block|{
try|try
block|{
name|Set
argument_list|<
name|Integer
argument_list|>
name|nonCombinablePathIndices
init|=
name|getNonCombinablePathIndices
argument_list|(
name|job
argument_list|,
name|paths
argument_list|,
name|numThreads
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|paths
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|nonCombinablePathIndices
operator|.
name|contains
argument_list|(
name|i
argument_list|)
condition|)
block|{
name|nonCombinablePaths
operator|.
name|add
argument_list|(
name|paths
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|combinablePaths
operator|.
name|add
argument_list|(
name|paths
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Error checking non-combinable path"
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|perfLogger
operator|.
name|PerfLogEnd
argument_list|(
name|CLASS_NAME
argument_list|,
name|PerfLogger
operator|.
name|GET_SPLITS
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|IOException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
comment|// Store the previous value for the path specification
name|String
name|oldPaths
init|=
name|job
operator|.
name|get
argument_list|(
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|lib
operator|.
name|input
operator|.
name|FileInputFormat
operator|.
name|INPUT_DIR
argument_list|)
decl_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"The received input paths are: ["
operator|+
name|oldPaths
operator|+
literal|"] against the property "
operator|+
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|lib
operator|.
name|input
operator|.
name|FileInputFormat
operator|.
name|INPUT_DIR
argument_list|)
expr_stmt|;
block|}
comment|// Process the normal splits
if|if
condition|(
name|nonCombinablePaths
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
name|FileInputFormat
operator|.
name|setInputPaths
argument_list|(
name|job
argument_list|,
name|nonCombinablePaths
operator|.
name|toArray
argument_list|(
operator|new
name|Path
index|[
name|nonCombinablePaths
operator|.
name|size
argument_list|()
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|InputSplit
index|[]
name|splits
init|=
name|super
operator|.
name|getSplits
argument_list|(
name|job
argument_list|,
name|numSplits
argument_list|)
decl_stmt|;
for|for
control|(
name|InputSplit
name|split
range|:
name|splits
control|)
block|{
name|result
operator|.
name|add
argument_list|(
name|split
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Process the combine splits
if|if
condition|(
name|combinablePaths
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
name|FileInputFormat
operator|.
name|setInputPaths
argument_list|(
name|job
argument_list|,
name|combinablePaths
operator|.
name|toArray
argument_list|(
operator|new
name|Path
index|[
name|combinablePaths
operator|.
name|size
argument_list|()
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|Map
argument_list|<
name|Path
argument_list|,
name|PartitionDesc
argument_list|>
name|pathToPartitionInfo
init|=
name|this
operator|.
name|pathToPartitionInfo
operator|!=
literal|null
condition|?
name|this
operator|.
name|pathToPartitionInfo
else|:
name|Utilities
operator|.
name|getMapWork
argument_list|(
name|job
argument_list|)
operator|.
name|getPathToPartitionInfo
argument_list|()
decl_stmt|;
name|InputSplit
index|[]
name|splits
init|=
name|getCombineSplits
argument_list|(
name|job
argument_list|,
name|numSplits
argument_list|,
name|pathToPartitionInfo
argument_list|)
decl_stmt|;
for|for
control|(
name|InputSplit
name|split
range|:
name|splits
control|)
block|{
name|result
operator|.
name|add
argument_list|(
name|split
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Restore the old path information back
comment|// This is just to prevent incompatibilities with previous versions Hive
comment|// if some application depends on the original value being set.
if|if
condition|(
name|oldPaths
operator|!=
literal|null
condition|)
block|{
name|job
operator|.
name|set
argument_list|(
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|lib
operator|.
name|input
operator|.
name|FileInputFormat
operator|.
name|INPUT_DIR
argument_list|,
name|oldPaths
argument_list|)
expr_stmt|;
block|}
comment|// clear work from ThreadLocal after splits generated in case of thread is reused in pool.
name|Utilities
operator|.
name|clearWorkMapForConf
argument_list|(
name|job
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Number of all splits "
operator|+
name|result
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|perfLogger
operator|.
name|PerfLogEnd
argument_list|(
name|CLASS_NAME
argument_list|,
name|PerfLogger
operator|.
name|GET_SPLITS
argument_list|)
expr_stmt|;
return|return
name|result
operator|.
name|toArray
argument_list|(
operator|new
name|InputSplit
index|[
name|result
operator|.
name|size
argument_list|()
index|]
argument_list|)
return|;
block|}
specifier|private
name|void
name|processPaths
parameter_list|(
name|JobConf
name|job
parameter_list|,
name|CombineFileInputFormatShim
name|combine
parameter_list|,
name|List
argument_list|<
name|CombineFileSplit
argument_list|>
name|iss
parameter_list|,
name|Path
modifier|...
name|path
parameter_list|)
throws|throws
name|IOException
block|{
name|JobConf
name|currJob
init|=
operator|new
name|JobConf
argument_list|(
name|job
argument_list|)
decl_stmt|;
name|FileInputFormat
operator|.
name|setInputPaths
argument_list|(
name|currJob
argument_list|,
name|path
argument_list|)
expr_stmt|;
name|iss
operator|.
name|addAll
argument_list|(
name|Arrays
operator|.
name|asList
argument_list|(
name|combine
operator|.
name|getSplits
argument_list|(
name|currJob
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**    * This function is used to sample inputs for clauses like "TABLESAMPLE(1 PERCENT)"    *    * First, splits are grouped by alias they are for. If one split serves more than one    * alias or not for any sampled alias, we just directly add it to returned list.    * Then we find a list of exclusive splits for every alias to be sampled.    * For each alias, we start from position of seedNumber%totalNumber, and keep add    * splits until the total size hits percentage.    * @param splits    * @return the sampled splits    */
specifier|private
name|List
argument_list|<
name|CombineFileSplit
argument_list|>
name|sampleSplits
parameter_list|(
name|List
argument_list|<
name|CombineFileSplit
argument_list|>
name|splits
parameter_list|)
block|{
name|HashMap
argument_list|<
name|String
argument_list|,
name|SplitSample
argument_list|>
name|nameToSamples
init|=
name|mrwork
operator|.
name|getNameToSplitSample
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|CombineFileSplit
argument_list|>
name|retLists
init|=
operator|new
name|ArrayList
argument_list|<
name|CombineFileSplit
argument_list|>
argument_list|()
decl_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|ArrayList
argument_list|<
name|CombineFileSplit
argument_list|>
argument_list|>
name|aliasToSplitList
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|ArrayList
argument_list|<
name|CombineFileSplit
argument_list|>
argument_list|>
argument_list|()
decl_stmt|;
name|Map
argument_list|<
name|Path
argument_list|,
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|>
name|pathToAliases
init|=
name|mrwork
operator|.
name|getPathToAliases
argument_list|()
decl_stmt|;
name|Map
argument_list|<
name|Path
argument_list|,
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|>
name|pathToAliasesNoScheme
init|=
name|removeScheme
argument_list|(
name|pathToAliases
argument_list|)
decl_stmt|;
comment|// Populate list of exclusive splits for every sampled alias
comment|//
for|for
control|(
name|CombineFileSplit
name|split
range|:
name|splits
control|)
block|{
name|String
name|alias
init|=
literal|null
decl_stmt|;
for|for
control|(
name|Path
name|path
range|:
name|split
operator|.
name|getPaths
argument_list|()
control|)
block|{
name|boolean
name|schemeless
init|=
name|path
operator|.
name|toUri
argument_list|()
operator|.
name|getScheme
argument_list|()
operator|==
literal|null
decl_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|l
init|=
name|HiveFileFormatUtils
operator|.
name|doGetAliasesFromPath
argument_list|(
name|schemeless
condition|?
name|pathToAliasesNoScheme
else|:
name|pathToAliases
argument_list|,
name|path
argument_list|)
decl_stmt|;
comment|// a path for a split unqualified the split from being sampled if:
comment|// 1. it serves more than one alias
comment|// 2. the alias it serves is not sampled
comment|// 3. it serves different alias than another path for the same split
if|if
condition|(
name|l
operator|.
name|size
argument_list|()
operator|!=
literal|1
operator|||
operator|!
name|nameToSamples
operator|.
name|containsKey
argument_list|(
name|l
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|)
operator|||
operator|(
name|alias
operator|!=
literal|null
operator|&&
name|l
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|!=
name|alias
operator|)
condition|)
block|{
name|alias
operator|=
literal|null
expr_stmt|;
break|break;
block|}
name|alias
operator|=
name|l
operator|.
name|get
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|alias
operator|!=
literal|null
condition|)
block|{
comment|// split exclusively serves alias, which needs to be sampled
comment|// add it to the split list of the alias.
if|if
condition|(
operator|!
name|aliasToSplitList
operator|.
name|containsKey
argument_list|(
name|alias
argument_list|)
condition|)
block|{
name|aliasToSplitList
operator|.
name|put
argument_list|(
name|alias
argument_list|,
operator|new
name|ArrayList
argument_list|<
name|CombineFileSplit
argument_list|>
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|aliasToSplitList
operator|.
name|get
argument_list|(
name|alias
argument_list|)
operator|.
name|add
argument_list|(
name|split
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// The split doesn't exclusively serve one alias
name|retLists
operator|.
name|add
argument_list|(
name|split
argument_list|)
expr_stmt|;
block|}
block|}
comment|// for every sampled alias, we figure out splits to be sampled and add
comment|// them to return list
comment|//
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|ArrayList
argument_list|<
name|CombineFileSplit
argument_list|>
argument_list|>
name|entry
range|:
name|aliasToSplitList
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|ArrayList
argument_list|<
name|CombineFileSplit
argument_list|>
name|splitList
init|=
name|entry
operator|.
name|getValue
argument_list|()
decl_stmt|;
name|long
name|totalSize
init|=
literal|0
decl_stmt|;
for|for
control|(
name|CombineFileSplit
name|split
range|:
name|splitList
control|)
block|{
name|totalSize
operator|+=
name|split
operator|.
name|getLength
argument_list|()
expr_stmt|;
block|}
name|SplitSample
name|splitSample
init|=
name|nameToSamples
operator|.
name|get
argument_list|(
name|entry
operator|.
name|getKey
argument_list|()
argument_list|)
decl_stmt|;
name|long
name|targetSize
init|=
name|splitSample
operator|.
name|getTargetSize
argument_list|(
name|totalSize
argument_list|)
decl_stmt|;
name|int
name|startIndex
init|=
name|splitSample
operator|.
name|getSeedNum
argument_list|()
operator|%
name|splitList
operator|.
name|size
argument_list|()
decl_stmt|;
name|long
name|size
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|splitList
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|CombineFileSplit
name|split
init|=
name|splitList
operator|.
name|get
argument_list|(
operator|(
name|startIndex
operator|+
name|i
operator|)
operator|%
name|splitList
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
name|retLists
operator|.
name|add
argument_list|(
name|split
argument_list|)
expr_stmt|;
name|long
name|splitgLength
init|=
name|split
operator|.
name|getLength
argument_list|()
decl_stmt|;
if|if
condition|(
name|size
operator|+
name|splitgLength
operator|>=
name|targetSize
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Sample alias "
operator|+
name|entry
operator|.
name|getValue
argument_list|()
operator|+
literal|" using "
operator|+
operator|(
name|i
operator|+
literal|1
operator|)
operator|+
literal|"splits"
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
operator|+
name|splitgLength
operator|>
name|targetSize
condition|)
block|{
operator|(
operator|(
name|InputSplitShim
operator|)
name|split
operator|)
operator|.
name|shrinkSplit
argument_list|(
name|targetSize
operator|-
name|size
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
name|size
operator|+=
name|splitgLength
expr_stmt|;
block|}
block|}
return|return
name|retLists
return|;
block|}
name|Map
argument_list|<
name|Path
argument_list|,
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|>
name|removeScheme
parameter_list|(
name|Map
argument_list|<
name|Path
argument_list|,
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|>
name|pathToAliases
parameter_list|)
block|{
name|Map
argument_list|<
name|Path
argument_list|,
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|>
name|result
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|Path
argument_list|,
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|>
name|entry
range|:
name|pathToAliases
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|Path
name|newKey
init|=
name|Path
operator|.
name|getPathWithoutSchemeAndAuthority
argument_list|(
name|entry
operator|.
name|getKey
argument_list|()
argument_list|)
decl_stmt|;
name|result
operator|.
name|put
argument_list|(
name|newKey
argument_list|,
name|entry
operator|.
name|getValue
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
comment|/**    * Create a generic Hive RecordReader than can iterate over all chunks in a    * CombinedFileSplit.    */
annotation|@
name|Override
specifier|public
name|RecordReader
name|getRecordReader
parameter_list|(
name|InputSplit
name|split
parameter_list|,
name|JobConf
name|job
parameter_list|,
name|Reporter
name|reporter
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
operator|!
operator|(
name|split
operator|instanceof
name|CombineHiveInputSplit
operator|)
condition|)
block|{
return|return
name|super
operator|.
name|getRecordReader
argument_list|(
name|split
argument_list|,
name|job
argument_list|,
name|reporter
argument_list|)
return|;
block|}
name|CombineHiveInputSplit
name|hsplit
init|=
operator|(
name|CombineHiveInputSplit
operator|)
name|split
decl_stmt|;
name|String
name|inputFormatClassName
init|=
literal|null
decl_stmt|;
name|Class
name|inputFormatClass
init|=
literal|null
decl_stmt|;
try|try
block|{
name|inputFormatClassName
operator|=
name|hsplit
operator|.
name|inputFormatClassName
argument_list|()
expr_stmt|;
name|inputFormatClass
operator|=
name|job
operator|.
name|getClassByName
argument_list|(
name|inputFormatClassName
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"cannot find class "
operator|+
name|inputFormatClassName
argument_list|)
throw|;
block|}
name|pushProjectionsAndFilters
argument_list|(
name|job
argument_list|,
name|inputFormatClass
argument_list|,
name|hsplit
operator|.
name|getPath
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|ShimLoader
operator|.
name|getHadoopShims
argument_list|()
operator|.
name|getCombineFileInputFormat
argument_list|()
operator|.
name|getRecordReader
argument_list|(
name|job
argument_list|,
operator|(
name|CombineFileSplit
operator|)
name|split
argument_list|,
name|reporter
argument_list|,
name|CombineHiveRecordReader
operator|.
name|class
argument_list|)
return|;
block|}
specifier|static
class|class
name|CombineFilter
implements|implements
name|PathFilter
block|{
specifier|private
specifier|final
name|Set
argument_list|<
name|String
argument_list|>
name|pStrings
init|=
operator|new
name|HashSet
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
comment|// store a path prefix in this TestFilter
comment|// PRECONDITION: p should always be a directory
specifier|public
name|CombineFilter
parameter_list|(
name|Path
name|p
parameter_list|)
block|{
comment|// we need to keep the path part only because the Hadoop CombineFileInputFormat will
comment|// pass the path part only to accept().
comment|// Trailing the path with a separator to prevent partial matching.
name|addPath
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
specifier|public
name|void
name|addPath
parameter_list|(
name|Path
name|p
parameter_list|)
block|{
name|String
name|pString
init|=
name|p
operator|.
name|toUri
argument_list|()
operator|.
name|getPath
argument_list|()
decl_stmt|;
name|pStrings
operator|.
name|add
argument_list|(
name|pString
argument_list|)
expr_stmt|;
block|}
comment|// returns true if the specified path matches the prefix stored
comment|// in this TestFilter.
annotation|@
name|Override
specifier|public
name|boolean
name|accept
parameter_list|(
name|Path
name|path
parameter_list|)
block|{
name|boolean
name|find
init|=
literal|false
decl_stmt|;
while|while
condition|(
name|path
operator|!=
literal|null
operator|&&
operator|!
name|find
condition|)
block|{
if|if
condition|(
name|pStrings
operator|.
name|contains
argument_list|(
name|path
operator|.
name|toUri
argument_list|()
operator|.
name|getPath
argument_list|()
argument_list|)
condition|)
block|{
name|find
operator|=
literal|true
expr_stmt|;
break|break;
block|}
name|path
operator|=
name|path
operator|.
name|getParent
argument_list|()
expr_stmt|;
block|}
return|return
name|find
return|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|toString
parameter_list|()
block|{
name|StringBuilder
name|s
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|s
operator|.
name|append
argument_list|(
literal|"PathFilter: "
argument_list|)
expr_stmt|;
for|for
control|(
name|String
name|pString
range|:
name|pStrings
control|)
block|{
name|s
operator|.
name|append
argument_list|(
name|pString
operator|+
literal|" "
argument_list|)
expr_stmt|;
block|}
return|return
name|s
operator|.
name|toString
argument_list|()
return|;
block|}
block|}
comment|/**      * This is a marker interface that is used to identify the formats where      * combine split generation is not applicable      */
specifier|public
interface|interface
name|AvoidSplitCombination
block|{
name|boolean
name|shouldSkipCombine
parameter_list|(
name|Path
name|path
parameter_list|,
name|Configuration
name|conf
parameter_list|)
throws|throws
name|IOException
function_decl|;
block|}
block|}
end_class

end_unit

