begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|tez
package|;
end_package

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|annotation
operator|.
name|Annotation
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|reflect
operator|.
name|Field
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|common
operator|.
name|metrics
operator|.
name|common
operator|.
name|Metrics
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|common
operator|.
name|metrics
operator|.
name|common
operator|.
name|MetricsFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|common
operator|.
name|metrics
operator|.
name|common
operator|.
name|MetricsVariable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|common
operator|.
name|metrics
operator|.
name|metrics2
operator|.
name|CodahaleMetrics
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|metrics2
operator|.
name|MetricsCollector
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|metrics2
operator|.
name|MetricsRecordBuilder
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|metrics2
operator|.
name|MetricsSource
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|metrics2
operator|.
name|MetricsSystem
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|metrics2
operator|.
name|annotation
operator|.
name|Metric
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|metrics2
operator|.
name|impl
operator|.
name|MsInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|metrics2
operator|.
name|lib
operator|.
name|MetricsRegistry
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|metrics2
operator|.
name|lib
operator|.
name|MutableCounterInt
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|metrics2
operator|.
name|lib
operator|.
name|MutableGaugeInt
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|metrics2
operator|.
name|lib
operator|.
name|MutableMetric
import|;
end_import

begin_comment
comment|/**  * A wrapper for metrics for single WM pool. This outputs metrics both to Codahale and standard  * Hadoop metrics, in parallel. The codahale output is prefixed with pool name and is mostly  * for the JMX view, or to look at when Hadoop metrics are not set up. Hadoop metrics are output  * because they can be tagged properly rather than prefixed, so they are better for dashboards.  */
end_comment

begin_class
specifier|public
class|class
name|WmPoolMetrics
implements|implements
name|MetricsSource
block|{
specifier|private
specifier|final
name|String
name|poolName
decl_stmt|,
name|sourceName
decl_stmt|;
specifier|private
name|MetricsSystem
name|ms
decl_stmt|;
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unused"
argument_list|)
comment|// Metrics system will get this via reflection 0_o
specifier|private
specifier|final
name|MetricsRegistry
name|registry
decl_stmt|;
comment|// Codahale. We just include the pool name in the counter name.
specifier|private
name|List
argument_list|<
name|String
argument_list|>
name|codahaleGaugeNames
decl_stmt|;
specifier|private
name|Map
argument_list|<
name|String
argument_list|,
name|MutableMetric
argument_list|>
name|allMetrics
decl_stmt|;
annotation|@
name|Metric
argument_list|(
literal|"Number of guaranteed cluster executors given to queries"
argument_list|)
name|MutableGaugeInt
name|numExecutors
decl_stmt|;
annotation|@
name|Metric
argument_list|(
literal|"Number of guaranteed cluster executors allocated"
argument_list|)
name|MutableGaugeInt
name|numExecutorsMax
decl_stmt|;
annotation|@
name|Metric
argument_list|(
literal|"Number of parallel queries allowed to run"
argument_list|)
name|MutableGaugeInt
name|numParallelQueries
decl_stmt|;
annotation|@
name|Metric
argument_list|(
literal|"Number of queries running"
argument_list|)
name|MutableCounterInt
name|numRunningQueries
decl_stmt|;
annotation|@
name|Metric
argument_list|(
literal|"Number of queries queued"
argument_list|)
name|MutableCounterInt
name|numQueuedQueries
decl_stmt|;
comment|// TODO: these would need to be propagated from AM via progress.
comment|// @Metric("Number of allocated guaranteed executors in use"),
comment|// @Metric("Number of speculative executors in use")
specifier|public
name|WmPoolMetrics
parameter_list|(
name|String
name|poolName
parameter_list|,
name|MetricsSystem
name|ms
parameter_list|)
block|{
name|this
operator|.
name|poolName
operator|=
name|poolName
expr_stmt|;
name|this
operator|.
name|sourceName
operator|=
literal|"WmPoolMetrics."
operator|+
name|poolName
expr_stmt|;
name|this
operator|.
name|ms
operator|=
name|ms
expr_stmt|;
name|this
operator|.
name|registry
operator|=
operator|new
name|MetricsRegistry
argument_list|(
name|sourceName
argument_list|)
expr_stmt|;
block|}
specifier|public
name|void
name|initAfterRegister
parameter_list|()
block|{
comment|// Make sure we capture the same metrics as Hadoop2 metrics system, via annotations.
if|if
condition|(
name|allMetrics
operator|!=
literal|null
condition|)
return|return;
name|allMetrics
operator|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
expr_stmt|;
for|for
control|(
name|Field
name|field
range|:
name|this
operator|.
name|getClass
argument_list|()
operator|.
name|getDeclaredFields
argument_list|()
control|)
block|{
for|for
control|(
name|Annotation
name|annotation
range|:
name|field
operator|.
name|getAnnotations
argument_list|()
control|)
block|{
if|if
condition|(
operator|!
operator|(
name|annotation
operator|instanceof
name|Metric
operator|)
condition|)
continue|continue;
try|try
block|{
name|field
operator|.
name|setAccessible
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|allMetrics
operator|.
name|put
argument_list|(
name|field
operator|.
name|getName
argument_list|()
argument_list|,
operator|(
name|MutableMetric
operator|)
name|field
operator|.
name|get
argument_list|(
name|this
argument_list|)
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IllegalAccessException
name|ex
parameter_list|)
block|{
break|break;
comment|// Not expected, access by the same class.
block|}
break|break;
block|}
block|}
comment|// Set up codahale if enabled; we cannot tag the values so just prefix them for the JMX view.
name|Metrics
name|chMetrics
init|=
name|MetricsFactory
operator|.
name|getInstance
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|chMetrics
operator|instanceof
name|CodahaleMetrics
operator|)
condition|)
return|return;
name|List
argument_list|<
name|String
argument_list|>
name|codahaleNames
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|MutableMetric
argument_list|>
name|e
range|:
name|allMetrics
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|MutableMetric
name|metric
init|=
name|e
operator|.
name|getValue
argument_list|()
decl_stmt|;
name|MetricsVariable
argument_list|<
name|?
argument_list|>
name|var
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|metric
operator|instanceof
name|MutableCounterInt
condition|)
block|{
name|var
operator|=
operator|new
name|CodahaleCounterWrapper
argument_list|(
operator|(
name|MutableCounterInt
operator|)
name|metric
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|metric
operator|instanceof
name|MutableGaugeInt
condition|)
block|{
name|var
operator|=
operator|new
name|CodahaleGaugeWrapper
argument_list|(
operator|(
name|MutableGaugeInt
operator|)
name|metric
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|var
operator|==
literal|null
condition|)
continue|continue;
comment|// Unexpected metric type.
name|String
name|name
init|=
literal|"WM_"
operator|+
name|poolName
operator|+
literal|"_"
operator|+
name|e
operator|.
name|getKey
argument_list|()
decl_stmt|;
name|codahaleNames
operator|.
name|add
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|chMetrics
operator|.
name|addGauge
argument_list|(
name|name
argument_list|,
name|var
argument_list|)
expr_stmt|;
block|}
name|this
operator|.
name|codahaleGaugeNames
operator|=
name|codahaleNames
expr_stmt|;
block|}
specifier|public
name|void
name|setParallelQueries
parameter_list|(
name|int
name|size
parameter_list|)
block|{
name|numParallelQueries
operator|.
name|set
argument_list|(
name|size
argument_list|)
expr_stmt|;
block|}
specifier|public
name|void
name|setExecutors
parameter_list|(
name|int
name|allocation
parameter_list|)
block|{
name|numExecutors
operator|.
name|set
argument_list|(
name|allocation
argument_list|)
expr_stmt|;
block|}
specifier|public
name|void
name|setMaxExecutors
parameter_list|(
name|int
name|allocation
parameter_list|)
block|{
name|numExecutorsMax
operator|.
name|set
argument_list|(
name|allocation
argument_list|)
expr_stmt|;
block|}
specifier|public
name|void
name|addQueuedQuery
parameter_list|()
block|{
name|numQueuedQueries
operator|.
name|incr
argument_list|()
expr_stmt|;
block|}
specifier|public
name|void
name|addRunningQuery
parameter_list|()
block|{
name|numRunningQueries
operator|.
name|incr
argument_list|()
expr_stmt|;
block|}
specifier|public
name|void
name|removeQueuedQueries
parameter_list|(
name|int
name|num
parameter_list|)
block|{
name|numQueuedQueries
operator|.
name|incr
argument_list|(
operator|-
name|num
argument_list|)
expr_stmt|;
block|}
specifier|public
name|void
name|removeRunningQueries
parameter_list|(
name|int
name|num
parameter_list|)
block|{
name|numRunningQueries
operator|.
name|incr
argument_list|(
operator|-
name|num
argument_list|)
expr_stmt|;
block|}
specifier|public
name|void
name|moveQueuedToRunning
parameter_list|()
block|{
name|numQueuedQueries
operator|.
name|incr
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
name|numRunningQueries
operator|.
name|incr
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|getMetrics
parameter_list|(
name|MetricsCollector
name|collector
parameter_list|,
name|boolean
name|all
parameter_list|)
block|{
comment|// We could also have one metricssource for all the pools and add all the pools to the collector
comment|// in its getMetrics call (as separate records). Not clear if that's supported.
comment|// Also, we'd have to initialize the metrics ourselves instead of using @Metric annotation.
name|MetricsRecordBuilder
name|rb
init|=
name|collector
operator|.
name|addRecord
argument_list|(
literal|"WmPoolMetrics."
operator|+
name|poolName
argument_list|)
operator|.
name|setContext
argument_list|(
literal|"HS2"
argument_list|)
operator|.
name|tag
argument_list|(
name|MsInfo
operator|.
name|SessionId
argument_list|,
name|poolName
argument_list|)
decl_stmt|;
if|if
condition|(
name|allMetrics
operator|==
literal|null
condition|)
block|{
name|initAfterRegister
argument_list|()
expr_stmt|;
comment|// This happens if register calls getMetrics.
block|}
for|for
control|(
name|MutableMetric
name|metric
range|:
name|allMetrics
operator|.
name|values
argument_list|()
control|)
block|{
name|metric
operator|.
name|snapshot
argument_list|(
name|rb
argument_list|,
name|all
argument_list|)
expr_stmt|;
block|}
block|}
specifier|public
specifier|static
name|WmPoolMetrics
name|create
parameter_list|(
name|String
name|poolName
parameter_list|,
name|MetricsSystem
name|ms
parameter_list|)
block|{
name|WmPoolMetrics
name|metrics
init|=
operator|new
name|WmPoolMetrics
argument_list|(
name|poolName
argument_list|,
name|ms
argument_list|)
decl_stmt|;
name|metrics
operator|=
name|ms
operator|.
name|register
argument_list|(
name|metrics
operator|.
name|sourceName
argument_list|,
literal|"WM "
operator|+
name|poolName
operator|+
literal|" pool metrics"
argument_list|,
name|metrics
argument_list|)
expr_stmt|;
name|metrics
operator|.
name|initAfterRegister
argument_list|()
expr_stmt|;
return|return
name|metrics
return|;
block|}
specifier|public
name|void
name|destroy
parameter_list|()
block|{
name|ms
operator|.
name|unregisterSource
argument_list|(
name|sourceName
argument_list|)
expr_stmt|;
name|ms
operator|=
literal|null
expr_stmt|;
if|if
condition|(
name|codahaleGaugeNames
operator|!=
literal|null
condition|)
block|{
name|Metrics
name|metrics
init|=
name|MetricsFactory
operator|.
name|getInstance
argument_list|()
decl_stmt|;
for|for
control|(
name|String
name|chgName
range|:
name|codahaleGaugeNames
control|)
block|{
name|metrics
operator|.
name|removeGauge
argument_list|(
name|chgName
argument_list|)
expr_stmt|;
block|}
name|codahaleGaugeNames
operator|=
literal|null
expr_stmt|;
block|}
block|}
specifier|private
specifier|static
class|class
name|CodahaleGaugeWrapper
implements|implements
name|MetricsVariable
argument_list|<
name|Integer
argument_list|>
block|{
specifier|private
specifier|final
name|MutableGaugeInt
name|mm
decl_stmt|;
specifier|public
name|CodahaleGaugeWrapper
parameter_list|(
name|MutableGaugeInt
name|mm
parameter_list|)
block|{
name|this
operator|.
name|mm
operator|=
name|mm
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|Integer
name|getValue
parameter_list|()
block|{
return|return
name|mm
operator|.
name|value
argument_list|()
return|;
block|}
block|}
specifier|private
specifier|static
class|class
name|CodahaleCounterWrapper
implements|implements
name|MetricsVariable
argument_list|<
name|Integer
argument_list|>
block|{
specifier|private
specifier|final
name|MutableCounterInt
name|mm
decl_stmt|;
specifier|public
name|CodahaleCounterWrapper
parameter_list|(
name|MutableCounterInt
name|mm
parameter_list|)
block|{
name|this
operator|.
name|mm
operator|=
name|mm
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|Integer
name|getValue
parameter_list|()
block|{
return|return
name|mm
operator|.
name|value
argument_list|()
return|;
block|}
block|}
block|}
end_class

end_unit

