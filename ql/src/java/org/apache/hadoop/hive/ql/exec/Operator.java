begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|Serializable
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|Log
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|LogFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|lib
operator|.
name|Node
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|metadata
operator|.
name|HiveException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|parse
operator|.
name|SemanticException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|Explain
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|ExprNodeDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|OperatorDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|api
operator|.
name|OperatorType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|objectinspector
operator|.
name|ObjectInspector
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|objectinspector
operator|.
name|ObjectInspectorFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|objectinspector
operator|.
name|StructObjectInspector
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|LongWritable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapred
operator|.
name|Counters
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapred
operator|.
name|OutputCollector
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapred
operator|.
name|Reporter
import|;
end_import

begin_comment
comment|/**  * Base operator implementation.  **/
end_comment

begin_class
specifier|public
specifier|abstract
class|class
name|Operator
parameter_list|<
name|T
extends|extends
name|OperatorDesc
parameter_list|>
implements|implements
name|Serializable
implements|,
name|Cloneable
implements|,
name|Node
block|{
comment|// Bean methods
specifier|private
specifier|static
specifier|final
name|long
name|serialVersionUID
init|=
literal|1L
decl_stmt|;
specifier|private
name|Configuration
name|configuration
decl_stmt|;
specifier|protected
name|List
argument_list|<
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
argument_list|>
name|childOperators
decl_stmt|;
specifier|protected
name|List
argument_list|<
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
argument_list|>
name|parentOperators
decl_stmt|;
specifier|protected
name|String
name|operatorId
decl_stmt|;
comment|/**    * List of counter names associated with the operator. It contains the    * following default counters NUM_INPUT_ROWS NUM_OUTPUT_ROWS TIME_TAKEN    * Individual operators can add to this list via addToCounterNames methods.    */
specifier|protected
name|ArrayList
argument_list|<
name|String
argument_list|>
name|counterNames
decl_stmt|;
comment|/**    * Each operator has its own map of its counter names to disjoint    * ProgressCounter - it is populated at compile time and is read in at    * run-time while extracting the operator specific counts.    */
specifier|protected
name|HashMap
argument_list|<
name|String
argument_list|,
name|ProgressCounter
argument_list|>
name|counterNameToEnum
decl_stmt|;
specifier|private
specifier|transient
name|ExecMapperContext
name|execContext
decl_stmt|;
specifier|private
specifier|static
name|int
name|seqId
decl_stmt|;
comment|// It can be optimized later so that an operator operator (init/close) is performed
comment|// only after that operation has been performed on all the parents. This will require
comment|// initializing the whole tree in all the mappers (which might be required for mappers
comment|// spanning multiple files anyway, in future)
comment|/**    * State.    *    */
specifier|public
specifier|static
enum|enum
name|State
block|{
name|UNINIT
block|,
comment|// initialize() has not been called
name|INIT
block|,
comment|// initialize() has been called and close() has not been called,
comment|// or close() has been called but one of its parent is not closed.
name|CLOSE
comment|// all its parents operators are in state CLOSE and called close()
comment|// to children. Note: close() being called and its state being CLOSE is
comment|// difference since close() could be called but state is not CLOSE if
comment|// one of its parent is not in state CLOSE..
block|}
empty_stmt|;
specifier|protected
specifier|transient
name|State
name|state
init|=
name|State
operator|.
name|UNINIT
decl_stmt|;
specifier|static
specifier|transient
name|boolean
name|fatalError
init|=
literal|false
decl_stmt|;
comment|// fatalError is shared acorss
comment|// all operators
static|static
block|{
name|seqId
operator|=
literal|0
expr_stmt|;
block|}
specifier|private
name|boolean
name|useBucketizedHiveInputFormat
decl_stmt|;
specifier|public
name|Operator
parameter_list|()
block|{
name|id
operator|=
name|String
operator|.
name|valueOf
argument_list|(
name|seqId
operator|++
argument_list|)
expr_stmt|;
block|}
specifier|public
specifier|static
name|void
name|resetId
parameter_list|()
block|{
name|seqId
operator|=
literal|0
expr_stmt|;
block|}
comment|/**    * Create an operator with a reporter.    *    * @param reporter    *          Used to report progress of certain operators.    */
specifier|public
name|Operator
parameter_list|(
name|Reporter
name|reporter
parameter_list|)
block|{
name|this
operator|.
name|reporter
operator|=
name|reporter
expr_stmt|;
name|id
operator|=
name|String
operator|.
name|valueOf
argument_list|(
name|seqId
operator|++
argument_list|)
expr_stmt|;
block|}
specifier|public
name|void
name|setChildOperators
parameter_list|(
name|List
argument_list|<
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
argument_list|>
name|childOperators
parameter_list|)
block|{
name|this
operator|.
name|childOperators
operator|=
name|childOperators
expr_stmt|;
block|}
specifier|public
name|Configuration
name|getConfiguration
parameter_list|()
block|{
return|return
name|configuration
return|;
block|}
specifier|public
name|List
argument_list|<
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
argument_list|>
name|getChildOperators
parameter_list|()
block|{
return|return
name|childOperators
return|;
block|}
specifier|public
name|int
name|getNumChild
parameter_list|()
block|{
return|return
name|childOperators
operator|==
literal|null
condition|?
literal|0
else|:
name|childOperators
operator|.
name|size
argument_list|()
return|;
block|}
comment|/**    * Implements the getChildren function for the Node Interface.    */
specifier|public
name|ArrayList
argument_list|<
name|Node
argument_list|>
name|getChildren
parameter_list|()
block|{
if|if
condition|(
name|getChildOperators
argument_list|()
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
name|ArrayList
argument_list|<
name|Node
argument_list|>
name|ret_vec
init|=
operator|new
name|ArrayList
argument_list|<
name|Node
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
name|op
range|:
name|getChildOperators
argument_list|()
control|)
block|{
name|ret_vec
operator|.
name|add
argument_list|(
name|op
argument_list|)
expr_stmt|;
block|}
return|return
name|ret_vec
return|;
block|}
specifier|public
name|void
name|setParentOperators
parameter_list|(
name|List
argument_list|<
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
argument_list|>
name|parentOperators
parameter_list|)
block|{
name|this
operator|.
name|parentOperators
operator|=
name|parentOperators
expr_stmt|;
block|}
specifier|public
name|List
argument_list|<
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
argument_list|>
name|getParentOperators
parameter_list|()
block|{
return|return
name|parentOperators
return|;
block|}
specifier|public
name|int
name|getNumParent
parameter_list|()
block|{
return|return
name|parentOperators
operator|==
literal|null
condition|?
literal|0
else|:
name|parentOperators
operator|.
name|size
argument_list|()
return|;
block|}
specifier|protected
name|T
name|conf
decl_stmt|;
specifier|protected
name|boolean
name|done
decl_stmt|;
specifier|public
name|void
name|setConf
parameter_list|(
name|T
name|conf
parameter_list|)
block|{
name|this
operator|.
name|conf
operator|=
name|conf
expr_stmt|;
block|}
annotation|@
name|Explain
specifier|public
name|T
name|getConf
parameter_list|()
block|{
return|return
name|conf
return|;
block|}
specifier|public
name|boolean
name|getDone
parameter_list|()
block|{
return|return
name|done
operator|||
name|fatalError
return|;
block|}
specifier|public
name|void
name|setDone
parameter_list|(
name|boolean
name|done
parameter_list|)
block|{
name|this
operator|.
name|done
operator|=
name|done
expr_stmt|;
block|}
comment|// non-bean fields needed during compilation
specifier|private
specifier|transient
name|RowSchema
name|rowSchema
decl_stmt|;
specifier|public
name|void
name|setSchema
parameter_list|(
name|RowSchema
name|rowSchema
parameter_list|)
block|{
name|this
operator|.
name|rowSchema
operator|=
name|rowSchema
expr_stmt|;
block|}
specifier|public
name|RowSchema
name|getSchema
parameter_list|()
block|{
return|return
name|rowSchema
return|;
block|}
comment|// non-bean ..
specifier|protected
specifier|transient
name|HashMap
argument_list|<
name|Enum
argument_list|<
name|?
argument_list|>
argument_list|,
name|LongWritable
argument_list|>
name|statsMap
init|=
operator|new
name|HashMap
argument_list|<
name|Enum
argument_list|<
name|?
argument_list|>
argument_list|,
name|LongWritable
argument_list|>
argument_list|()
decl_stmt|;
specifier|protected
specifier|transient
name|OutputCollector
name|out
decl_stmt|;
specifier|protected
specifier|transient
name|Log
name|LOG
init|=
name|LogFactory
operator|.
name|getLog
argument_list|(
name|this
operator|.
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|)
decl_stmt|;
specifier|protected
specifier|transient
name|boolean
name|isLogInfoEnabled
init|=
name|LOG
operator|.
name|isInfoEnabled
argument_list|()
decl_stmt|;
specifier|protected
specifier|transient
name|String
name|alias
decl_stmt|;
specifier|protected
specifier|transient
name|Reporter
name|reporter
decl_stmt|;
specifier|protected
specifier|transient
name|String
name|id
decl_stmt|;
comment|// object inspectors for input rows
comment|// We will increase the size of the array on demand
specifier|protected
specifier|transient
name|ObjectInspector
index|[]
name|inputObjInspectors
init|=
operator|new
name|ObjectInspector
index|[
literal|1
index|]
decl_stmt|;
comment|// for output rows of this operator
specifier|protected
specifier|transient
name|ObjectInspector
name|outputObjInspector
decl_stmt|;
comment|/**    * A map of output column name to input expression map. This is used by    * optimizer and built during semantic analysis contains only key elements for    * reduce sink and group by op    */
specifier|protected
specifier|transient
name|Map
argument_list|<
name|String
argument_list|,
name|ExprNodeDesc
argument_list|>
name|colExprMap
decl_stmt|;
specifier|public
name|void
name|setId
parameter_list|(
name|String
name|id
parameter_list|)
block|{
name|this
operator|.
name|id
operator|=
name|id
expr_stmt|;
block|}
comment|/**    * This function is not named getId(), to make sure java serialization does    * NOT serialize it. Some TestParse tests will fail if we serialize this    * field, since the Operator ID will change based on the number of query    * tests.    */
specifier|public
name|String
name|getIdentifier
parameter_list|()
block|{
return|return
name|id
return|;
block|}
specifier|public
name|void
name|setReporter
parameter_list|(
name|Reporter
name|rep
parameter_list|)
block|{
name|reporter
operator|=
name|rep
expr_stmt|;
comment|// the collector is same across all operators
if|if
condition|(
name|childOperators
operator|==
literal|null
condition|)
block|{
return|return;
block|}
for|for
control|(
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
name|op
range|:
name|childOperators
control|)
block|{
name|op
operator|.
name|setReporter
argument_list|(
name|rep
argument_list|)
expr_stmt|;
block|}
block|}
specifier|public
name|void
name|setOutputCollector
parameter_list|(
name|OutputCollector
name|out
parameter_list|)
block|{
name|this
operator|.
name|out
operator|=
name|out
expr_stmt|;
comment|// the collector is same across all operators
if|if
condition|(
name|childOperators
operator|==
literal|null
condition|)
block|{
return|return;
block|}
for|for
control|(
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
name|op
range|:
name|childOperators
control|)
block|{
name|op
operator|.
name|setOutputCollector
argument_list|(
name|out
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Store the alias this operator is working on behalf of.    */
specifier|public
name|void
name|setAlias
parameter_list|(
name|String
name|alias
parameter_list|)
block|{
name|this
operator|.
name|alias
operator|=
name|alias
expr_stmt|;
if|if
condition|(
name|childOperators
operator|==
literal|null
condition|)
block|{
return|return;
block|}
for|for
control|(
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
name|op
range|:
name|childOperators
control|)
block|{
name|op
operator|.
name|setAlias
argument_list|(
name|alias
argument_list|)
expr_stmt|;
block|}
block|}
specifier|public
name|Map
argument_list|<
name|Enum
argument_list|<
name|?
argument_list|>
argument_list|,
name|Long
argument_list|>
name|getStats
parameter_list|()
block|{
name|HashMap
argument_list|<
name|Enum
argument_list|<
name|?
argument_list|>
argument_list|,
name|Long
argument_list|>
name|ret
init|=
operator|new
name|HashMap
argument_list|<
name|Enum
argument_list|<
name|?
argument_list|>
argument_list|,
name|Long
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|Enum
argument_list|<
name|?
argument_list|>
name|one
range|:
name|statsMap
operator|.
name|keySet
argument_list|()
control|)
block|{
name|ret
operator|.
name|put
argument_list|(
name|one
argument_list|,
name|Long
operator|.
name|valueOf
argument_list|(
name|statsMap
operator|.
name|get
argument_list|(
name|one
argument_list|)
operator|.
name|get
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|ret
operator|)
return|;
block|}
comment|/**    * checks whether all parent operators are initialized or not.    *    * @return true if there are no parents or all parents are initialized. false    *         otherwise    */
specifier|protected
name|boolean
name|areAllParentsInitialized
parameter_list|()
block|{
if|if
condition|(
name|parentOperators
operator|==
literal|null
condition|)
block|{
return|return
literal|true
return|;
block|}
for|for
control|(
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
name|parent
range|:
name|parentOperators
control|)
block|{
if|if
condition|(
name|parent
operator|==
literal|null
condition|)
block|{
comment|//return true;
continue|continue;
block|}
if|if
condition|(
name|parent
operator|.
name|state
operator|!=
name|State
operator|.
name|INIT
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
return|return
literal|true
return|;
block|}
comment|/**    * Initializes operators only if all parents have been initialized. Calls    * operator specific initializer which then initializes child ops.    *    * @param hconf    * @param inputOIs    *          input object inspector array indexes by tag id. null value is    *          ignored.    * @throws HiveException    */
specifier|public
name|void
name|initialize
parameter_list|(
name|Configuration
name|hconf
parameter_list|,
name|ObjectInspector
index|[]
name|inputOIs
parameter_list|)
throws|throws
name|HiveException
block|{
if|if
condition|(
name|state
operator|==
name|State
operator|.
name|INIT
condition|)
block|{
return|return;
block|}
name|this
operator|.
name|configuration
operator|=
name|hconf
expr_stmt|;
name|this
operator|.
name|out
operator|=
literal|null
expr_stmt|;
if|if
condition|(
operator|!
name|areAllParentsInitialized
argument_list|()
condition|)
block|{
return|return;
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"Initializing Self "
operator|+
name|id
operator|+
literal|" "
operator|+
name|getName
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|inputOIs
operator|!=
literal|null
condition|)
block|{
name|inputObjInspectors
operator|=
name|inputOIs
expr_stmt|;
block|}
comment|// initialize structure to maintain child op info. operator tree changes
comment|// while
comment|// initializing so this need to be done here instead of initialize() method
if|if
condition|(
name|childOperators
operator|!=
literal|null
condition|)
block|{
name|childOperatorsArray
operator|=
operator|new
name|Operator
index|[
name|childOperators
operator|.
name|size
argument_list|()
index|]
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|childOperatorsArray
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|childOperatorsArray
index|[
name|i
index|]
operator|=
name|childOperators
operator|.
name|get
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
name|childOperatorsTag
operator|=
operator|new
name|int
index|[
name|childOperatorsArray
operator|.
name|length
index|]
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|childOperatorsArray
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|List
argument_list|<
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
argument_list|>
name|parentOperators
init|=
name|childOperatorsArray
index|[
name|i
index|]
operator|.
name|getParentOperators
argument_list|()
decl_stmt|;
if|if
condition|(
name|parentOperators
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|HiveException
argument_list|(
literal|"Hive internal error: parent is null in "
operator|+
name|childOperatorsArray
index|[
name|i
index|]
operator|.
name|getClass
argument_list|()
operator|+
literal|"!"
argument_list|)
throw|;
block|}
name|childOperatorsTag
index|[
name|i
index|]
operator|=
name|parentOperators
operator|.
name|indexOf
argument_list|(
name|this
argument_list|)
expr_stmt|;
if|if
condition|(
name|childOperatorsTag
index|[
name|i
index|]
operator|==
operator|-
literal|1
condition|)
block|{
throw|throw
operator|new
name|HiveException
argument_list|(
literal|"Hive internal error: cannot find parent in the child operator!"
argument_list|)
throw|;
block|}
block|}
block|}
if|if
condition|(
name|inputObjInspectors
operator|.
name|length
operator|==
literal|0
condition|)
block|{
throw|throw
operator|new
name|HiveException
argument_list|(
literal|"Internal Error during operator initialization."
argument_list|)
throw|;
block|}
comment|// derived classes can set this to different object if needed
name|outputObjInspector
operator|=
name|inputObjInspectors
index|[
literal|0
index|]
expr_stmt|;
comment|//pass the exec context to child operators
name|passExecContext
argument_list|(
name|this
operator|.
name|execContext
argument_list|)
expr_stmt|;
name|initializeOp
argument_list|(
name|hconf
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Initialization Done "
operator|+
name|id
operator|+
literal|" "
operator|+
name|getName
argument_list|()
argument_list|)
expr_stmt|;
block|}
specifier|public
name|void
name|initializeLocalWork
parameter_list|(
name|Configuration
name|hconf
parameter_list|)
throws|throws
name|HiveException
block|{
if|if
condition|(
name|childOperators
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|childOperators
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
name|childOp
init|=
name|this
operator|.
name|childOperators
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|childOp
operator|.
name|initializeLocalWork
argument_list|(
name|hconf
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**    * Operator specific initialization.    */
specifier|protected
name|void
name|initializeOp
parameter_list|(
name|Configuration
name|hconf
parameter_list|)
throws|throws
name|HiveException
block|{
name|initializeChildren
argument_list|(
name|hconf
argument_list|)
expr_stmt|;
block|}
comment|/**    * Calls initialize on each of the children with outputObjetInspector as the    * output row format.    */
specifier|protected
name|void
name|initializeChildren
parameter_list|(
name|Configuration
name|hconf
parameter_list|)
throws|throws
name|HiveException
block|{
name|state
operator|=
name|State
operator|.
name|INIT
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Operator "
operator|+
name|id
operator|+
literal|" "
operator|+
name|getName
argument_list|()
operator|+
literal|" initialized"
argument_list|)
expr_stmt|;
if|if
condition|(
name|childOperators
operator|==
literal|null
condition|)
block|{
return|return;
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"Initializing children of "
operator|+
name|id
operator|+
literal|" "
operator|+
name|getName
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|childOperatorsArray
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|childOperatorsArray
index|[
name|i
index|]
operator|.
name|initialize
argument_list|(
name|hconf
argument_list|,
name|outputObjInspector
argument_list|,
name|childOperatorsTag
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|reporter
operator|!=
literal|null
condition|)
block|{
name|childOperatorsArray
index|[
name|i
index|]
operator|.
name|setReporter
argument_list|(
name|reporter
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**    * Pass the execContext reference to every child operator    */
specifier|public
name|void
name|passExecContext
parameter_list|(
name|ExecMapperContext
name|execContext
parameter_list|)
block|{
name|this
operator|.
name|setExecContext
argument_list|(
name|execContext
argument_list|)
expr_stmt|;
if|if
condition|(
name|childOperators
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|childOperators
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|childOperators
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|passExecContext
argument_list|(
name|execContext
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**    * Collects all the parent's output object inspectors and calls actual    * initialization method.    *    * @param hconf    * @param inputOI    *          OI of the row that this parent will pass to this op    * @param parentId    *          parent operator id    * @throws HiveException    */
specifier|private
name|void
name|initialize
parameter_list|(
name|Configuration
name|hconf
parameter_list|,
name|ObjectInspector
name|inputOI
parameter_list|,
name|int
name|parentId
parameter_list|)
throws|throws
name|HiveException
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Initializing child "
operator|+
name|id
operator|+
literal|" "
operator|+
name|getName
argument_list|()
argument_list|)
expr_stmt|;
comment|// Double the size of the array if needed
if|if
condition|(
name|parentId
operator|>=
name|inputObjInspectors
operator|.
name|length
condition|)
block|{
name|int
name|newLength
init|=
name|inputObjInspectors
operator|.
name|length
operator|*
literal|2
decl_stmt|;
while|while
condition|(
name|parentId
operator|>=
name|newLength
condition|)
block|{
name|newLength
operator|*=
literal|2
expr_stmt|;
block|}
name|inputObjInspectors
operator|=
name|Arrays
operator|.
name|copyOf
argument_list|(
name|inputObjInspectors
argument_list|,
name|newLength
argument_list|)
expr_stmt|;
block|}
name|inputObjInspectors
index|[
name|parentId
index|]
operator|=
name|inputOI
expr_stmt|;
comment|// call the actual operator initialization function
name|initialize
argument_list|(
name|hconf
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
specifier|public
name|ObjectInspector
index|[]
name|getInputObjInspectors
parameter_list|()
block|{
return|return
name|inputObjInspectors
return|;
block|}
specifier|public
name|void
name|setInputObjInspectors
parameter_list|(
name|ObjectInspector
index|[]
name|inputObjInspectors
parameter_list|)
block|{
name|this
operator|.
name|inputObjInspectors
operator|=
name|inputObjInspectors
expr_stmt|;
block|}
comment|/**    * Process the row.    *    * @param row    *          The object representing the row.    * @param tag    *          The tag of the row usually means which parent this row comes from.    *          Rows with the same tag should have exactly the same rowInspector    *          all the time.    */
specifier|public
specifier|abstract
name|void
name|processOp
parameter_list|(
name|Object
name|row
parameter_list|,
name|int
name|tag
parameter_list|)
throws|throws
name|HiveException
function_decl|;
comment|/**    * Process the row.    *    * @param row    *          The object representing the row.    * @param tag    *          The tag of the row usually means which parent this row comes from.    *          Rows with the same tag should have exactly the same rowInspector    *          all the time.    */
specifier|public
name|void
name|process
parameter_list|(
name|Object
name|row
parameter_list|,
name|int
name|tag
parameter_list|)
throws|throws
name|HiveException
block|{
if|if
condition|(
name|fatalError
condition|)
block|{
return|return;
block|}
if|if
condition|(
name|counterNameToEnum
operator|!=
literal|null
condition|)
block|{
name|inputRows
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|inputRows
operator|%
literal|1000
operator|)
operator|==
literal|0
condition|)
block|{
name|incrCounter
argument_list|(
name|numInputRowsCntr
argument_list|,
name|inputRows
argument_list|)
expr_stmt|;
name|incrCounter
argument_list|(
name|timeTakenCntr
argument_list|,
name|totalTime
argument_list|)
expr_stmt|;
name|inputRows
operator|=
literal|0
expr_stmt|;
name|totalTime
operator|=
literal|0
expr_stmt|;
block|}
name|beginTime
operator|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
expr_stmt|;
name|processOp
argument_list|(
name|row
argument_list|,
name|tag
argument_list|)
expr_stmt|;
name|totalTime
operator|+=
operator|(
name|System
operator|.
name|currentTimeMillis
argument_list|()
operator|-
name|beginTime
operator|)
expr_stmt|;
block|}
else|else
block|{
name|processOp
argument_list|(
name|row
argument_list|,
name|tag
argument_list|)
expr_stmt|;
block|}
block|}
comment|// If a operator wants to do some work at the beginning of a group
specifier|public
name|void
name|startGroup
parameter_list|()
throws|throws
name|HiveException
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Starting group"
argument_list|)
expr_stmt|;
if|if
condition|(
name|childOperators
operator|==
literal|null
condition|)
block|{
return|return;
block|}
if|if
condition|(
name|fatalError
condition|)
block|{
return|return;
block|}
name|LOG
operator|.
name|debug
argument_list|(
literal|"Starting group for children:"
argument_list|)
expr_stmt|;
for|for
control|(
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
name|op
range|:
name|childOperators
control|)
block|{
name|op
operator|.
name|startGroup
argument_list|()
expr_stmt|;
block|}
name|LOG
operator|.
name|debug
argument_list|(
literal|"Start group Done"
argument_list|)
expr_stmt|;
block|}
comment|// If a operator wants to do some work at the end of a group
specifier|public
name|void
name|endGroup
parameter_list|()
throws|throws
name|HiveException
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Ending group"
argument_list|)
expr_stmt|;
if|if
condition|(
name|childOperators
operator|==
literal|null
condition|)
block|{
return|return;
block|}
if|if
condition|(
name|fatalError
condition|)
block|{
return|return;
block|}
name|LOG
operator|.
name|debug
argument_list|(
literal|"Ending group for children:"
argument_list|)
expr_stmt|;
for|for
control|(
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
name|op
range|:
name|childOperators
control|)
block|{
name|op
operator|.
name|endGroup
argument_list|()
expr_stmt|;
block|}
name|LOG
operator|.
name|debug
argument_list|(
literal|"End group Done"
argument_list|)
expr_stmt|;
block|}
specifier|protected
name|boolean
name|allInitializedParentsAreClosed
parameter_list|()
block|{
if|if
condition|(
name|parentOperators
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
name|parent
range|:
name|parentOperators
control|)
block|{
if|if
condition|(
name|parent
operator|==
literal|null
condition|)
block|{
continue|continue;
block|}
if|if
condition|(
operator|!
operator|(
name|parent
operator|.
name|state
operator|==
name|State
operator|.
name|CLOSE
operator|||
name|parent
operator|.
name|state
operator|==
name|State
operator|.
name|UNINIT
operator|)
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
block|}
return|return
literal|true
return|;
block|}
comment|// This close() function does not need to be synchronized
comment|// since it is called by its parents' main thread, so no
comment|// more than 1 thread should call this close() function.
specifier|public
name|void
name|close
parameter_list|(
name|boolean
name|abort
parameter_list|)
throws|throws
name|HiveException
block|{
if|if
condition|(
name|state
operator|==
name|State
operator|.
name|CLOSE
condition|)
block|{
return|return;
block|}
comment|// check if all parents are finished
if|if
condition|(
operator|!
name|allInitializedParentsAreClosed
argument_list|()
condition|)
block|{
return|return;
block|}
comment|// set state as CLOSE as long as all parents are closed
comment|// state == CLOSE doesn't mean all children are also in state CLOSE
name|state
operator|=
name|State
operator|.
name|CLOSE
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
name|id
operator|+
literal|" finished. closing... "
argument_list|)
expr_stmt|;
if|if
condition|(
name|counterNameToEnum
operator|!=
literal|null
condition|)
block|{
name|incrCounter
argument_list|(
name|numInputRowsCntr
argument_list|,
name|inputRows
argument_list|)
expr_stmt|;
name|incrCounter
argument_list|(
name|numOutputRowsCntr
argument_list|,
name|outputRows
argument_list|)
expr_stmt|;
name|incrCounter
argument_list|(
name|timeTakenCntr
argument_list|,
name|totalTime
argument_list|)
expr_stmt|;
block|}
name|LOG
operator|.
name|info
argument_list|(
name|id
operator|+
literal|" forwarded "
operator|+
name|cntr
operator|+
literal|" rows"
argument_list|)
expr_stmt|;
comment|// call the operator specific close routine
name|closeOp
argument_list|(
name|abort
argument_list|)
expr_stmt|;
try|try
block|{
name|logStats
argument_list|()
expr_stmt|;
if|if
condition|(
name|childOperators
operator|==
literal|null
condition|)
block|{
return|return;
block|}
for|for
control|(
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
name|op
range|:
name|childOperators
control|)
block|{
name|op
operator|.
name|close
argument_list|(
name|abort
argument_list|)
expr_stmt|;
block|}
name|LOG
operator|.
name|info
argument_list|(
name|id
operator|+
literal|" Close done"
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|HiveException
name|e
parameter_list|)
block|{
name|e
operator|.
name|printStackTrace
argument_list|()
expr_stmt|;
throw|throw
name|e
throw|;
block|}
block|}
comment|/**    * Operator specific close routine. Operators which inherents this class    * should overwrite this funtion for their specific cleanup routine.    */
specifier|protected
name|void
name|closeOp
parameter_list|(
name|boolean
name|abort
parameter_list|)
throws|throws
name|HiveException
block|{   }
specifier|private
name|boolean
name|jobCloseDone
init|=
literal|false
decl_stmt|;
comment|// Operator specific logic goes here
specifier|public
name|void
name|jobCloseOp
parameter_list|(
name|Configuration
name|conf
parameter_list|,
name|boolean
name|success
parameter_list|,
name|JobCloseFeedBack
name|feedBack
parameter_list|)
throws|throws
name|HiveException
block|{   }
comment|/**    * Unlike other operator interfaces which are called from map or reduce task,    * jobClose is called from the jobclient side once the job has completed.    *    * @param conf    *          Configuration with with which job was submitted    * @param success    *          whether the job was completed successfully or not    */
specifier|public
name|void
name|jobClose
parameter_list|(
name|Configuration
name|conf
parameter_list|,
name|boolean
name|success
parameter_list|,
name|JobCloseFeedBack
name|feedBack
parameter_list|)
throws|throws
name|HiveException
block|{
comment|// JobClose has already been performed on this operator
if|if
condition|(
name|jobCloseDone
condition|)
block|{
return|return;
block|}
name|jobCloseOp
argument_list|(
name|conf
argument_list|,
name|success
argument_list|,
name|feedBack
argument_list|)
expr_stmt|;
name|jobCloseDone
operator|=
literal|true
expr_stmt|;
if|if
condition|(
name|childOperators
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
name|op
range|:
name|childOperators
control|)
block|{
name|op
operator|.
name|jobClose
argument_list|(
name|conf
argument_list|,
name|success
argument_list|,
name|feedBack
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**    * Cache childOperators in an array for faster access. childOperatorsArray is    * accessed per row, so it's important to make the access efficient.    */
specifier|protected
specifier|transient
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
index|[]
name|childOperatorsArray
init|=
literal|null
decl_stmt|;
specifier|protected
specifier|transient
name|int
index|[]
name|childOperatorsTag
decl_stmt|;
comment|// counters for debugging
specifier|private
specifier|transient
name|long
name|cntr
init|=
literal|0
decl_stmt|;
specifier|private
specifier|transient
name|long
name|nextCntr
init|=
literal|1
decl_stmt|;
comment|/**    * Replace one child with another at the same position. The parent of the    * child is not changed    *    * @param child    *          the old child    * @param newChild    *          the new child    */
specifier|public
name|void
name|replaceChild
parameter_list|(
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
name|child
parameter_list|,
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
name|newChild
parameter_list|)
block|{
name|int
name|childIndex
init|=
name|childOperators
operator|.
name|indexOf
argument_list|(
name|child
argument_list|)
decl_stmt|;
assert|assert
name|childIndex
operator|!=
operator|-
literal|1
assert|;
name|childOperators
operator|.
name|set
argument_list|(
name|childIndex
argument_list|,
name|newChild
argument_list|)
expr_stmt|;
block|}
specifier|public
name|void
name|removeChild
parameter_list|(
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
name|child
parameter_list|)
block|{
name|int
name|childIndex
init|=
name|childOperators
operator|.
name|indexOf
argument_list|(
name|child
argument_list|)
decl_stmt|;
assert|assert
name|childIndex
operator|!=
operator|-
literal|1
assert|;
if|if
condition|(
name|childOperators
operator|.
name|size
argument_list|()
operator|==
literal|1
condition|)
block|{
name|childOperators
operator|=
literal|null
expr_stmt|;
block|}
else|else
block|{
name|childOperators
operator|.
name|remove
argument_list|(
name|childIndex
argument_list|)
expr_stmt|;
block|}
name|int
name|parentIndex
init|=
name|child
operator|.
name|getParentOperators
argument_list|()
operator|.
name|indexOf
argument_list|(
name|this
argument_list|)
decl_stmt|;
assert|assert
name|parentIndex
operator|!=
operator|-
literal|1
assert|;
if|if
condition|(
name|child
operator|.
name|getParentOperators
argument_list|()
operator|.
name|size
argument_list|()
operator|==
literal|1
condition|)
block|{
name|child
operator|.
name|setParentOperators
argument_list|(
literal|null
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|child
operator|.
name|getParentOperators
argument_list|()
operator|.
name|remove
argument_list|(
name|parentIndex
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Remove a child and add all of the child's children to the location of the child    *    * @param child   If this operator is not the only parent of the child. There can be unpredictable result.    * @throws SemanticException    */
specifier|public
name|void
name|removeChildAndAdoptItsChildren
parameter_list|(
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
name|child
parameter_list|)
throws|throws
name|SemanticException
block|{
name|int
name|childIndex
init|=
name|childOperators
operator|.
name|indexOf
argument_list|(
name|child
argument_list|)
decl_stmt|;
if|if
condition|(
name|childIndex
operator|==
operator|-
literal|1
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
literal|"Exception when trying to remove partition predicates: fail to find child from parent"
argument_list|)
throw|;
block|}
name|childOperators
operator|.
name|remove
argument_list|(
name|childIndex
argument_list|)
expr_stmt|;
if|if
condition|(
name|child
operator|.
name|getChildOperators
argument_list|()
operator|!=
literal|null
operator|&&
name|child
operator|.
name|getChildOperators
argument_list|()
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
name|childOperators
operator|.
name|addAll
argument_list|(
name|childIndex
argument_list|,
name|child
operator|.
name|getChildOperators
argument_list|()
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
name|gc
range|:
name|child
operator|.
name|getChildOperators
argument_list|()
control|)
block|{
name|List
argument_list|<
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
argument_list|>
name|parents
init|=
name|gc
operator|.
name|getParentOperators
argument_list|()
decl_stmt|;
name|int
name|index
init|=
name|parents
operator|.
name|indexOf
argument_list|(
name|child
argument_list|)
decl_stmt|;
if|if
condition|(
name|index
operator|==
operator|-
literal|1
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
literal|"Exception when trying to remove partition predicates: fail to find parent from child"
argument_list|)
throw|;
block|}
name|parents
operator|.
name|set
argument_list|(
name|index
argument_list|,
name|this
argument_list|)
expr_stmt|;
block|}
block|}
specifier|public
name|void
name|removeParent
parameter_list|(
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
name|parent
parameter_list|)
block|{
name|int
name|parentIndex
init|=
name|parentOperators
operator|.
name|indexOf
argument_list|(
name|parent
argument_list|)
decl_stmt|;
assert|assert
name|parentIndex
operator|!=
operator|-
literal|1
assert|;
if|if
condition|(
name|parentOperators
operator|.
name|size
argument_list|()
operator|==
literal|1
condition|)
block|{
name|parentOperators
operator|=
literal|null
expr_stmt|;
block|}
else|else
block|{
name|parentOperators
operator|.
name|remove
argument_list|(
name|parentIndex
argument_list|)
expr_stmt|;
block|}
name|int
name|childIndex
init|=
name|parent
operator|.
name|getChildOperators
argument_list|()
operator|.
name|indexOf
argument_list|(
name|this
argument_list|)
decl_stmt|;
assert|assert
name|childIndex
operator|!=
operator|-
literal|1
assert|;
if|if
condition|(
name|parent
operator|.
name|getChildOperators
argument_list|()
operator|.
name|size
argument_list|()
operator|==
literal|1
condition|)
block|{
name|parent
operator|.
name|setChildOperators
argument_list|(
literal|null
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|parent
operator|.
name|getChildOperators
argument_list|()
operator|.
name|remove
argument_list|(
name|childIndex
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Remove the operators till a certain depth.
comment|// Return true if the remove was successful, false otherwise
specifier|public
name|boolean
name|removeChildren
parameter_list|(
name|int
name|depth
parameter_list|)
block|{
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
name|currOp
init|=
name|this
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|depth
condition|;
name|i
operator|++
control|)
block|{
comment|// If there are more than 1 children at any level, don't do anything
if|if
condition|(
operator|(
name|currOp
operator|.
name|getChildOperators
argument_list|()
operator|==
literal|null
operator|)
operator|||
operator|(
name|currOp
operator|.
name|getChildOperators
argument_list|()
operator|.
name|size
argument_list|()
operator|>
literal|1
operator|)
condition|)
block|{
return|return
literal|false
return|;
block|}
name|currOp
operator|=
name|currOp
operator|.
name|getChildOperators
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
name|setChildOperators
argument_list|(
name|currOp
operator|.
name|getChildOperators
argument_list|()
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
argument_list|>
name|parentOps
init|=
operator|new
name|ArrayList
argument_list|<
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
argument_list|>
argument_list|()
decl_stmt|;
name|parentOps
operator|.
name|add
argument_list|(
name|this
argument_list|)
expr_stmt|;
for|for
control|(
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
name|op
range|:
name|currOp
operator|.
name|getChildOperators
argument_list|()
control|)
block|{
name|op
operator|.
name|setParentOperators
argument_list|(
name|parentOps
argument_list|)
expr_stmt|;
block|}
return|return
literal|true
return|;
block|}
comment|/**    * Replace one parent with another at the same position. Chilren of the new    * parent are not updated    *    * @param parent    *          the old parent    * @param newParent    *          the new parent    */
specifier|public
name|void
name|replaceParent
parameter_list|(
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
name|parent
parameter_list|,
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
name|newParent
parameter_list|)
block|{
name|int
name|parentIndex
init|=
name|parentOperators
operator|.
name|indexOf
argument_list|(
name|parent
argument_list|)
decl_stmt|;
assert|assert
name|parentIndex
operator|!=
operator|-
literal|1
assert|;
name|parentOperators
operator|.
name|set
argument_list|(
name|parentIndex
argument_list|,
name|newParent
argument_list|)
expr_stmt|;
block|}
specifier|private
name|long
name|getNextCntr
parameter_list|(
name|long
name|cntr
parameter_list|)
block|{
comment|// A very simple counter to keep track of number of rows processed by an
comment|// operator. It dumps
comment|// every 1 million times, and quickly before that
if|if
condition|(
name|cntr
operator|>=
literal|1000000
condition|)
block|{
return|return
name|cntr
operator|+
literal|1000000
return|;
block|}
return|return
literal|10
operator|*
name|cntr
return|;
block|}
specifier|protected
name|void
name|forward
parameter_list|(
name|Object
name|row
parameter_list|,
name|ObjectInspector
name|rowInspector
parameter_list|)
throws|throws
name|HiveException
block|{
if|if
condition|(
name|counterNameToEnum
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
operator|(
operator|++
name|outputRows
operator|%
literal|1000
operator|)
operator|==
literal|0
condition|)
block|{
name|incrCounter
argument_list|(
name|numOutputRowsCntr
argument_list|,
name|outputRows
argument_list|)
expr_stmt|;
name|outputRows
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
name|isLogInfoEnabled
condition|)
block|{
name|cntr
operator|++
expr_stmt|;
if|if
condition|(
name|cntr
operator|==
name|nextCntr
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
name|id
operator|+
literal|" forwarding "
operator|+
name|cntr
operator|+
literal|" rows"
argument_list|)
expr_stmt|;
name|nextCntr
operator|=
name|getNextCntr
argument_list|(
name|cntr
argument_list|)
expr_stmt|;
block|}
block|}
comment|// For debugging purposes:
comment|// System.out.println("" + this.getClass() + ": " +
comment|// SerDeUtils.getJSONString(row, rowInspector));
comment|// System.out.println("" + this.getClass() + ">> " +
comment|// ObjectInspectorUtils.getObjectInspectorName(rowInspector));
if|if
condition|(
name|childOperatorsArray
operator|==
literal|null
operator|&&
name|childOperators
operator|!=
literal|null
condition|)
block|{
throw|throw
operator|new
name|HiveException
argument_list|(
literal|"Internal Hive error during operator initialization."
argument_list|)
throw|;
block|}
if|if
condition|(
operator|(
name|childOperatorsArray
operator|==
literal|null
operator|)
operator|||
operator|(
name|getDone
argument_list|()
operator|)
condition|)
block|{
return|return;
block|}
name|int
name|childrenDone
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|childOperatorsArray
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
name|o
init|=
name|childOperatorsArray
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|o
operator|.
name|getDone
argument_list|()
condition|)
block|{
name|childrenDone
operator|++
expr_stmt|;
block|}
else|else
block|{
name|o
operator|.
name|process
argument_list|(
name|row
argument_list|,
name|childOperatorsTag
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
comment|// if all children are done, this operator is also done
if|if
condition|(
name|childrenDone
operator|==
name|childOperatorsArray
operator|.
name|length
condition|)
block|{
name|setDone
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
block|}
specifier|public
name|void
name|resetStats
parameter_list|()
block|{
for|for
control|(
name|Enum
argument_list|<
name|?
argument_list|>
name|e
range|:
name|statsMap
operator|.
name|keySet
argument_list|()
control|)
block|{
name|statsMap
operator|.
name|get
argument_list|(
name|e
argument_list|)
operator|.
name|set
argument_list|(
literal|0L
argument_list|)
expr_stmt|;
block|}
block|}
specifier|public
name|void
name|reset
parameter_list|()
block|{
name|this
operator|.
name|state
operator|=
name|State
operator|.
name|INIT
expr_stmt|;
if|if
condition|(
name|childOperators
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
name|o
range|:
name|childOperators
control|)
block|{
name|o
operator|.
name|reset
argument_list|()
expr_stmt|;
block|}
block|}
block|}
comment|/**    * OperatorFunc.    *    */
specifier|public
specifier|static
interface|interface
name|OperatorFunc
block|{
name|void
name|func
parameter_list|(
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
name|op
parameter_list|)
function_decl|;
block|}
specifier|public
name|void
name|preorderMap
parameter_list|(
name|OperatorFunc
name|opFunc
parameter_list|)
block|{
name|opFunc
operator|.
name|func
argument_list|(
name|this
argument_list|)
expr_stmt|;
if|if
condition|(
name|childOperators
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
name|o
range|:
name|childOperators
control|)
block|{
name|o
operator|.
name|preorderMap
argument_list|(
name|opFunc
argument_list|)
expr_stmt|;
block|}
block|}
block|}
specifier|public
name|void
name|logStats
parameter_list|()
block|{
for|for
control|(
name|Enum
argument_list|<
name|?
argument_list|>
name|e
range|:
name|statsMap
operator|.
name|keySet
argument_list|()
control|)
block|{
name|LOG
operator|.
name|info
argument_list|(
name|e
operator|.
name|toString
argument_list|()
operator|+
literal|":"
operator|+
name|statsMap
operator|.
name|get
argument_list|(
name|e
argument_list|)
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Implements the getName function for the Node Interface.    *    * @return the name of the operator    */
specifier|public
name|String
name|getName
parameter_list|()
block|{
return|return
name|getOperatorName
argument_list|()
return|;
block|}
specifier|static
specifier|public
name|String
name|getOperatorName
parameter_list|()
block|{
return|return
literal|"OP"
return|;
block|}
comment|/**    * Returns a map of output column name to input expression map Note that    * currently it returns only key columns for ReduceSink and GroupBy operators.    *    * @return null if the operator doesn't change columns    */
specifier|public
name|Map
argument_list|<
name|String
argument_list|,
name|ExprNodeDesc
argument_list|>
name|getColumnExprMap
parameter_list|()
block|{
return|return
name|colExprMap
return|;
block|}
specifier|public
name|void
name|setColumnExprMap
parameter_list|(
name|Map
argument_list|<
name|String
argument_list|,
name|ExprNodeDesc
argument_list|>
name|colExprMap
parameter_list|)
block|{
name|this
operator|.
name|colExprMap
operator|=
name|colExprMap
expr_stmt|;
block|}
specifier|private
name|String
name|getLevelString
parameter_list|(
name|int
name|level
parameter_list|)
block|{
if|if
condition|(
name|level
operator|==
literal|0
condition|)
block|{
return|return
literal|"\n"
return|;
block|}
name|StringBuilder
name|s
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|s
operator|.
name|append
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
while|while
condition|(
name|level
operator|>
literal|0
condition|)
block|{
name|s
operator|.
name|append
argument_list|(
literal|"  "
argument_list|)
expr_stmt|;
name|level
operator|--
expr_stmt|;
block|}
return|return
name|s
operator|.
name|toString
argument_list|()
return|;
block|}
specifier|public
name|String
name|dump
parameter_list|(
name|int
name|level
parameter_list|)
block|{
return|return
name|dump
argument_list|(
name|level
argument_list|,
operator|new
name|HashSet
argument_list|<
name|Integer
argument_list|>
argument_list|()
argument_list|)
return|;
block|}
specifier|public
name|String
name|dump
parameter_list|(
name|int
name|level
parameter_list|,
name|HashSet
argument_list|<
name|Integer
argument_list|>
name|seenOpts
parameter_list|)
block|{
if|if
condition|(
name|seenOpts
operator|.
name|contains
argument_list|(
operator|new
name|Integer
argument_list|(
name|id
argument_list|)
argument_list|)
condition|)
block|{
return|return
literal|null
return|;
block|}
name|seenOpts
operator|.
name|add
argument_list|(
operator|new
name|Integer
argument_list|(
name|id
argument_list|)
argument_list|)
expr_stmt|;
name|StringBuilder
name|s
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|String
name|ls
init|=
name|getLevelString
argument_list|(
name|level
argument_list|)
decl_stmt|;
name|s
operator|.
name|append
argument_list|(
name|ls
argument_list|)
expr_stmt|;
name|s
operator|.
name|append
argument_list|(
literal|"<"
operator|+
name|getName
argument_list|()
operator|+
literal|">"
argument_list|)
expr_stmt|;
name|s
operator|.
name|append
argument_list|(
literal|"Id ="
operator|+
name|id
argument_list|)
expr_stmt|;
if|if
condition|(
name|childOperators
operator|!=
literal|null
condition|)
block|{
name|s
operator|.
name|append
argument_list|(
name|ls
argument_list|)
expr_stmt|;
name|s
operator|.
name|append
argument_list|(
literal|"<Children>"
argument_list|)
expr_stmt|;
for|for
control|(
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
name|o
range|:
name|childOperators
control|)
block|{
name|s
operator|.
name|append
argument_list|(
name|o
operator|.
name|dump
argument_list|(
name|level
operator|+
literal|2
argument_list|,
name|seenOpts
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|s
operator|.
name|append
argument_list|(
name|ls
argument_list|)
expr_stmt|;
name|s
operator|.
name|append
argument_list|(
literal|"<\\Children>"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|parentOperators
operator|!=
literal|null
condition|)
block|{
name|s
operator|.
name|append
argument_list|(
name|ls
argument_list|)
expr_stmt|;
name|s
operator|.
name|append
argument_list|(
literal|"<Parent>"
argument_list|)
expr_stmt|;
for|for
control|(
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
name|o
range|:
name|parentOperators
control|)
block|{
name|s
operator|.
name|append
argument_list|(
literal|"Id = "
operator|+
name|o
operator|.
name|id
operator|+
literal|" "
argument_list|)
expr_stmt|;
name|s
operator|.
name|append
argument_list|(
name|o
operator|.
name|dump
argument_list|(
name|level
argument_list|,
name|seenOpts
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|s
operator|.
name|append
argument_list|(
literal|"<\\Parent>"
argument_list|)
expr_stmt|;
block|}
name|s
operator|.
name|append
argument_list|(
name|ls
argument_list|)
expr_stmt|;
name|s
operator|.
name|append
argument_list|(
literal|"<\\"
operator|+
name|getName
argument_list|()
operator|+
literal|">"
argument_list|)
expr_stmt|;
return|return
name|s
operator|.
name|toString
argument_list|()
return|;
block|}
comment|/**    * Initialize an array of ExprNodeEvaluator and return the result    * ObjectInspectors.    */
specifier|protected
specifier|static
name|ObjectInspector
index|[]
name|initEvaluators
parameter_list|(
name|ExprNodeEvaluator
index|[]
name|evals
parameter_list|,
name|ObjectInspector
name|rowInspector
parameter_list|)
throws|throws
name|HiveException
block|{
name|ObjectInspector
index|[]
name|result
init|=
operator|new
name|ObjectInspector
index|[
name|evals
operator|.
name|length
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|evals
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|result
index|[
name|i
index|]
operator|=
name|evals
index|[
name|i
index|]
operator|.
name|initialize
argument_list|(
name|rowInspector
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
comment|/**    * Initialize an array of ExprNodeEvaluator from start, for specified length    * and return the result ObjectInspectors.    */
specifier|protected
specifier|static
name|ObjectInspector
index|[]
name|initEvaluators
parameter_list|(
name|ExprNodeEvaluator
index|[]
name|evals
parameter_list|,
name|int
name|start
parameter_list|,
name|int
name|length
parameter_list|,
name|ObjectInspector
name|rowInspector
parameter_list|)
throws|throws
name|HiveException
block|{
name|ObjectInspector
index|[]
name|result
init|=
operator|new
name|ObjectInspector
index|[
name|length
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|length
condition|;
name|i
operator|++
control|)
block|{
name|result
index|[
name|i
index|]
operator|=
name|evals
index|[
name|start
operator|+
name|i
index|]
operator|.
name|initialize
argument_list|(
name|rowInspector
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
comment|/**    * Initialize an array of ExprNodeEvaluator and put the return values into a    * StructObjectInspector with integer field names.    */
specifier|protected
specifier|static
name|StructObjectInspector
name|initEvaluatorsAndReturnStruct
parameter_list|(
name|ExprNodeEvaluator
index|[]
name|evals
parameter_list|,
name|List
argument_list|<
name|String
argument_list|>
name|outputColName
parameter_list|,
name|ObjectInspector
name|rowInspector
parameter_list|)
throws|throws
name|HiveException
block|{
name|ObjectInspector
index|[]
name|fieldObjectInspectors
init|=
name|initEvaluators
argument_list|(
name|evals
argument_list|,
name|rowInspector
argument_list|)
decl_stmt|;
return|return
name|ObjectInspectorFactory
operator|.
name|getStandardStructObjectInspector
argument_list|(
name|outputColName
argument_list|,
name|Arrays
operator|.
name|asList
argument_list|(
name|fieldObjectInspectors
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * All counter stuff below this    */
comment|/**    * TODO This is a hack for hadoop 0.17 which only supports enum counters.    */
specifier|public
specifier|static
enum|enum
name|ProgressCounter
block|{
name|CREATED_FILES
block|,
name|C1
block|,
name|C2
block|,
name|C3
block|,
name|C4
block|,
name|C5
block|,
name|C6
block|,
name|C7
block|,
name|C8
block|,
name|C9
block|,
name|C10
block|,
name|C11
block|,
name|C12
block|,
name|C13
block|,
name|C14
block|,
name|C15
block|,
name|C16
block|,
name|C17
block|,
name|C18
block|,
name|C19
block|,
name|C20
block|,
name|C21
block|,
name|C22
block|,
name|C23
block|,
name|C24
block|,
name|C25
block|,
name|C26
block|,
name|C27
block|,
name|C28
block|,
name|C29
block|,
name|C30
block|,
name|C31
block|,
name|C32
block|,
name|C33
block|,
name|C34
block|,
name|C35
block|,
name|C36
block|,
name|C37
block|,
name|C38
block|,
name|C39
block|,
name|C40
block|,
name|C41
block|,
name|C42
block|,
name|C43
block|,
name|C44
block|,
name|C45
block|,
name|C46
block|,
name|C47
block|,
name|C48
block|,
name|C49
block|,
name|C50
block|,
name|C51
block|,
name|C52
block|,
name|C53
block|,
name|C54
block|,
name|C55
block|,
name|C56
block|,
name|C57
block|,
name|C58
block|,
name|C59
block|,
name|C60
block|,
name|C61
block|,
name|C62
block|,
name|C63
block|,
name|C64
block|,
name|C65
block|,
name|C66
block|,
name|C67
block|,
name|C68
block|,
name|C69
block|,
name|C70
block|,
name|C71
block|,
name|C72
block|,
name|C73
block|,
name|C74
block|,
name|C75
block|,
name|C76
block|,
name|C77
block|,
name|C78
block|,
name|C79
block|,
name|C80
block|,
name|C81
block|,
name|C82
block|,
name|C83
block|,
name|C84
block|,
name|C85
block|,
name|C86
block|,
name|C87
block|,
name|C88
block|,
name|C89
block|,
name|C90
block|,
name|C91
block|,
name|C92
block|,
name|C93
block|,
name|C94
block|,
name|C95
block|,
name|C96
block|,
name|C97
block|,
name|C98
block|,
name|C99
block|,
name|C100
block|,
name|C101
block|,
name|C102
block|,
name|C103
block|,
name|C104
block|,
name|C105
block|,
name|C106
block|,
name|C107
block|,
name|C108
block|,
name|C109
block|,
name|C110
block|,
name|C111
block|,
name|C112
block|,
name|C113
block|,
name|C114
block|,
name|C115
block|,
name|C116
block|,
name|C117
block|,
name|C118
block|,
name|C119
block|,
name|C120
block|,
name|C121
block|,
name|C122
block|,
name|C123
block|,
name|C124
block|,
name|C125
block|,
name|C126
block|,
name|C127
block|,
name|C128
block|,
name|C129
block|,
name|C130
block|,
name|C131
block|,
name|C132
block|,
name|C133
block|,
name|C134
block|,
name|C135
block|,
name|C136
block|,
name|C137
block|,
name|C138
block|,
name|C139
block|,
name|C140
block|,
name|C141
block|,
name|C142
block|,
name|C143
block|,
name|C144
block|,
name|C145
block|,
name|C146
block|,
name|C147
block|,
name|C148
block|,
name|C149
block|,
name|C150
block|,
name|C151
block|,
name|C152
block|,
name|C153
block|,
name|C154
block|,
name|C155
block|,
name|C156
block|,
name|C157
block|,
name|C158
block|,
name|C159
block|,
name|C160
block|,
name|C161
block|,
name|C162
block|,
name|C163
block|,
name|C164
block|,
name|C165
block|,
name|C166
block|,
name|C167
block|,
name|C168
block|,
name|C169
block|,
name|C170
block|,
name|C171
block|,
name|C172
block|,
name|C173
block|,
name|C174
block|,
name|C175
block|,
name|C176
block|,
name|C177
block|,
name|C178
block|,
name|C179
block|,
name|C180
block|,
name|C181
block|,
name|C182
block|,
name|C183
block|,
name|C184
block|,
name|C185
block|,
name|C186
block|,
name|C187
block|,
name|C188
block|,
name|C189
block|,
name|C190
block|,
name|C191
block|,
name|C192
block|,
name|C193
block|,
name|C194
block|,
name|C195
block|,
name|C196
block|,
name|C197
block|,
name|C198
block|,
name|C199
block|,
name|C200
block|,
name|C201
block|,
name|C202
block|,
name|C203
block|,
name|C204
block|,
name|C205
block|,
name|C206
block|,
name|C207
block|,
name|C208
block|,
name|C209
block|,
name|C210
block|,
name|C211
block|,
name|C212
block|,
name|C213
block|,
name|C214
block|,
name|C215
block|,
name|C216
block|,
name|C217
block|,
name|C218
block|,
name|C219
block|,
name|C220
block|,
name|C221
block|,
name|C222
block|,
name|C223
block|,
name|C224
block|,
name|C225
block|,
name|C226
block|,
name|C227
block|,
name|C228
block|,
name|C229
block|,
name|C230
block|,
name|C231
block|,
name|C232
block|,
name|C233
block|,
name|C234
block|,
name|C235
block|,
name|C236
block|,
name|C237
block|,
name|C238
block|,
name|C239
block|,
name|C240
block|,
name|C241
block|,
name|C242
block|,
name|C243
block|,
name|C244
block|,
name|C245
block|,
name|C246
block|,
name|C247
block|,
name|C248
block|,
name|C249
block|,
name|C250
block|,
name|C251
block|,
name|C252
block|,
name|C253
block|,
name|C254
block|,
name|C255
block|,
name|C256
block|,
name|C257
block|,
name|C258
block|,
name|C259
block|,
name|C260
block|,
name|C261
block|,
name|C262
block|,
name|C263
block|,
name|C264
block|,
name|C265
block|,
name|C266
block|,
name|C267
block|,
name|C268
block|,
name|C269
block|,
name|C270
block|,
name|C271
block|,
name|C272
block|,
name|C273
block|,
name|C274
block|,
name|C275
block|,
name|C276
block|,
name|C277
block|,
name|C278
block|,
name|C279
block|,
name|C280
block|,
name|C281
block|,
name|C282
block|,
name|C283
block|,
name|C284
block|,
name|C285
block|,
name|C286
block|,
name|C287
block|,
name|C288
block|,
name|C289
block|,
name|C290
block|,
name|C291
block|,
name|C292
block|,
name|C293
block|,
name|C294
block|,
name|C295
block|,
name|C296
block|,
name|C297
block|,
name|C298
block|,
name|C299
block|,
name|C300
block|,
name|C301
block|,
name|C302
block|,
name|C303
block|,
name|C304
block|,
name|C305
block|,
name|C306
block|,
name|C307
block|,
name|C308
block|,
name|C309
block|,
name|C310
block|,
name|C311
block|,
name|C312
block|,
name|C313
block|,
name|C314
block|,
name|C315
block|,
name|C316
block|,
name|C317
block|,
name|C318
block|,
name|C319
block|,
name|C320
block|,
name|C321
block|,
name|C322
block|,
name|C323
block|,
name|C324
block|,
name|C325
block|,
name|C326
block|,
name|C327
block|,
name|C328
block|,
name|C329
block|,
name|C330
block|,
name|C331
block|,
name|C332
block|,
name|C333
block|,
name|C334
block|,
name|C335
block|,
name|C336
block|,
name|C337
block|,
name|C338
block|,
name|C339
block|,
name|C340
block|,
name|C341
block|,
name|C342
block|,
name|C343
block|,
name|C344
block|,
name|C345
block|,
name|C346
block|,
name|C347
block|,
name|C348
block|,
name|C349
block|,
name|C350
block|,
name|C351
block|,
name|C352
block|,
name|C353
block|,
name|C354
block|,
name|C355
block|,
name|C356
block|,
name|C357
block|,
name|C358
block|,
name|C359
block|,
name|C360
block|,
name|C361
block|,
name|C362
block|,
name|C363
block|,
name|C364
block|,
name|C365
block|,
name|C366
block|,
name|C367
block|,
name|C368
block|,
name|C369
block|,
name|C370
block|,
name|C371
block|,
name|C372
block|,
name|C373
block|,
name|C374
block|,
name|C375
block|,
name|C376
block|,
name|C377
block|,
name|C378
block|,
name|C379
block|,
name|C380
block|,
name|C381
block|,
name|C382
block|,
name|C383
block|,
name|C384
block|,
name|C385
block|,
name|C386
block|,
name|C387
block|,
name|C388
block|,
name|C389
block|,
name|C390
block|,
name|C391
block|,
name|C392
block|,
name|C393
block|,
name|C394
block|,
name|C395
block|,
name|C396
block|,
name|C397
block|,
name|C398
block|,
name|C399
block|,
name|C400
block|,
name|C401
block|,
name|C402
block|,
name|C403
block|,
name|C404
block|,
name|C405
block|,
name|C406
block|,
name|C407
block|,
name|C408
block|,
name|C409
block|,
name|C410
block|,
name|C411
block|,
name|C412
block|,
name|C413
block|,
name|C414
block|,
name|C415
block|,
name|C416
block|,
name|C417
block|,
name|C418
block|,
name|C419
block|,
name|C420
block|,
name|C421
block|,
name|C422
block|,
name|C423
block|,
name|C424
block|,
name|C425
block|,
name|C426
block|,
name|C427
block|,
name|C428
block|,
name|C429
block|,
name|C430
block|,
name|C431
block|,
name|C432
block|,
name|C433
block|,
name|C434
block|,
name|C435
block|,
name|C436
block|,
name|C437
block|,
name|C438
block|,
name|C439
block|,
name|C440
block|,
name|C441
block|,
name|C442
block|,
name|C443
block|,
name|C444
block|,
name|C445
block|,
name|C446
block|,
name|C447
block|,
name|C448
block|,
name|C449
block|,
name|C450
block|,
name|C451
block|,
name|C452
block|,
name|C453
block|,
name|C454
block|,
name|C455
block|,
name|C456
block|,
name|C457
block|,
name|C458
block|,
name|C459
block|,
name|C460
block|,
name|C461
block|,
name|C462
block|,
name|C463
block|,
name|C464
block|,
name|C465
block|,
name|C466
block|,
name|C467
block|,
name|C468
block|,
name|C469
block|,
name|C470
block|,
name|C471
block|,
name|C472
block|,
name|C473
block|,
name|C474
block|,
name|C475
block|,
name|C476
block|,
name|C477
block|,
name|C478
block|,
name|C479
block|,
name|C480
block|,
name|C481
block|,
name|C482
block|,
name|C483
block|,
name|C484
block|,
name|C485
block|,
name|C486
block|,
name|C487
block|,
name|C488
block|,
name|C489
block|,
name|C490
block|,
name|C491
block|,
name|C492
block|,
name|C493
block|,
name|C494
block|,
name|C495
block|,
name|C496
block|,
name|C497
block|,
name|C498
block|,
name|C499
block|,
name|C500
block|,
name|C501
block|,
name|C502
block|,
name|C503
block|,
name|C504
block|,
name|C505
block|,
name|C506
block|,
name|C507
block|,
name|C508
block|,
name|C509
block|,
name|C510
block|,
name|C511
block|,
name|C512
block|,
name|C513
block|,
name|C514
block|,
name|C515
block|,
name|C516
block|,
name|C517
block|,
name|C518
block|,
name|C519
block|,
name|C520
block|,
name|C521
block|,
name|C522
block|,
name|C523
block|,
name|C524
block|,
name|C525
block|,
name|C526
block|,
name|C527
block|,
name|C528
block|,
name|C529
block|,
name|C530
block|,
name|C531
block|,
name|C532
block|,
name|C533
block|,
name|C534
block|,
name|C535
block|,
name|C536
block|,
name|C537
block|,
name|C538
block|,
name|C539
block|,
name|C540
block|,
name|C541
block|,
name|C542
block|,
name|C543
block|,
name|C544
block|,
name|C545
block|,
name|C546
block|,
name|C547
block|,
name|C548
block|,
name|C549
block|,
name|C550
block|,
name|C551
block|,
name|C552
block|,
name|C553
block|,
name|C554
block|,
name|C555
block|,
name|C556
block|,
name|C557
block|,
name|C558
block|,
name|C559
block|,
name|C560
block|,
name|C561
block|,
name|C562
block|,
name|C563
block|,
name|C564
block|,
name|C565
block|,
name|C566
block|,
name|C567
block|,
name|C568
block|,
name|C569
block|,
name|C570
block|,
name|C571
block|,
name|C572
block|,
name|C573
block|,
name|C574
block|,
name|C575
block|,
name|C576
block|,
name|C577
block|,
name|C578
block|,
name|C579
block|,
name|C580
block|,
name|C581
block|,
name|C582
block|,
name|C583
block|,
name|C584
block|,
name|C585
block|,
name|C586
block|,
name|C587
block|,
name|C588
block|,
name|C589
block|,
name|C590
block|,
name|C591
block|,
name|C592
block|,
name|C593
block|,
name|C594
block|,
name|C595
block|,
name|C596
block|,
name|C597
block|,
name|C598
block|,
name|C599
block|,
name|C600
block|,
name|C601
block|,
name|C602
block|,
name|C603
block|,
name|C604
block|,
name|C605
block|,
name|C606
block|,
name|C607
block|,
name|C608
block|,
name|C609
block|,
name|C610
block|,
name|C611
block|,
name|C612
block|,
name|C613
block|,
name|C614
block|,
name|C615
block|,
name|C616
block|,
name|C617
block|,
name|C618
block|,
name|C619
block|,
name|C620
block|,
name|C621
block|,
name|C622
block|,
name|C623
block|,
name|C624
block|,
name|C625
block|,
name|C626
block|,
name|C627
block|,
name|C628
block|,
name|C629
block|,
name|C630
block|,
name|C631
block|,
name|C632
block|,
name|C633
block|,
name|C634
block|,
name|C635
block|,
name|C636
block|,
name|C637
block|,
name|C638
block|,
name|C639
block|,
name|C640
block|,
name|C641
block|,
name|C642
block|,
name|C643
block|,
name|C644
block|,
name|C645
block|,
name|C646
block|,
name|C647
block|,
name|C648
block|,
name|C649
block|,
name|C650
block|,
name|C651
block|,
name|C652
block|,
name|C653
block|,
name|C654
block|,
name|C655
block|,
name|C656
block|,
name|C657
block|,
name|C658
block|,
name|C659
block|,
name|C660
block|,
name|C661
block|,
name|C662
block|,
name|C663
block|,
name|C664
block|,
name|C665
block|,
name|C666
block|,
name|C667
block|,
name|C668
block|,
name|C669
block|,
name|C670
block|,
name|C671
block|,
name|C672
block|,
name|C673
block|,
name|C674
block|,
name|C675
block|,
name|C676
block|,
name|C677
block|,
name|C678
block|,
name|C679
block|,
name|C680
block|,
name|C681
block|,
name|C682
block|,
name|C683
block|,
name|C684
block|,
name|C685
block|,
name|C686
block|,
name|C687
block|,
name|C688
block|,
name|C689
block|,
name|C690
block|,
name|C691
block|,
name|C692
block|,
name|C693
block|,
name|C694
block|,
name|C695
block|,
name|C696
block|,
name|C697
block|,
name|C698
block|,
name|C699
block|,
name|C700
block|,
name|C701
block|,
name|C702
block|,
name|C703
block|,
name|C704
block|,
name|C705
block|,
name|C706
block|,
name|C707
block|,
name|C708
block|,
name|C709
block|,
name|C710
block|,
name|C711
block|,
name|C712
block|,
name|C713
block|,
name|C714
block|,
name|C715
block|,
name|C716
block|,
name|C717
block|,
name|C718
block|,
name|C719
block|,
name|C720
block|,
name|C721
block|,
name|C722
block|,
name|C723
block|,
name|C724
block|,
name|C725
block|,
name|C726
block|,
name|C727
block|,
name|C728
block|,
name|C729
block|,
name|C730
block|,
name|C731
block|,
name|C732
block|,
name|C733
block|,
name|C734
block|,
name|C735
block|,
name|C736
block|,
name|C737
block|,
name|C738
block|,
name|C739
block|,
name|C740
block|,
name|C741
block|,
name|C742
block|,
name|C743
block|,
name|C744
block|,
name|C745
block|,
name|C746
block|,
name|C747
block|,
name|C748
block|,
name|C749
block|,
name|C750
block|,
name|C751
block|,
name|C752
block|,
name|C753
block|,
name|C754
block|,
name|C755
block|,
name|C756
block|,
name|C757
block|,
name|C758
block|,
name|C759
block|,
name|C760
block|,
name|C761
block|,
name|C762
block|,
name|C763
block|,
name|C764
block|,
name|C765
block|,
name|C766
block|,
name|C767
block|,
name|C768
block|,
name|C769
block|,
name|C770
block|,
name|C771
block|,
name|C772
block|,
name|C773
block|,
name|C774
block|,
name|C775
block|,
name|C776
block|,
name|C777
block|,
name|C778
block|,
name|C779
block|,
name|C780
block|,
name|C781
block|,
name|C782
block|,
name|C783
block|,
name|C784
block|,
name|C785
block|,
name|C786
block|,
name|C787
block|,
name|C788
block|,
name|C789
block|,
name|C790
block|,
name|C791
block|,
name|C792
block|,
name|C793
block|,
name|C794
block|,
name|C795
block|,
name|C796
block|,
name|C797
block|,
name|C798
block|,
name|C799
block|,
name|C800
block|,
name|C801
block|,
name|C802
block|,
name|C803
block|,
name|C804
block|,
name|C805
block|,
name|C806
block|,
name|C807
block|,
name|C808
block|,
name|C809
block|,
name|C810
block|,
name|C811
block|,
name|C812
block|,
name|C813
block|,
name|C814
block|,
name|C815
block|,
name|C816
block|,
name|C817
block|,
name|C818
block|,
name|C819
block|,
name|C820
block|,
name|C821
block|,
name|C822
block|,
name|C823
block|,
name|C824
block|,
name|C825
block|,
name|C826
block|,
name|C827
block|,
name|C828
block|,
name|C829
block|,
name|C830
block|,
name|C831
block|,
name|C832
block|,
name|C833
block|,
name|C834
block|,
name|C835
block|,
name|C836
block|,
name|C837
block|,
name|C838
block|,
name|C839
block|,
name|C840
block|,
name|C841
block|,
name|C842
block|,
name|C843
block|,
name|C844
block|,
name|C845
block|,
name|C846
block|,
name|C847
block|,
name|C848
block|,
name|C849
block|,
name|C850
block|,
name|C851
block|,
name|C852
block|,
name|C853
block|,
name|C854
block|,
name|C855
block|,
name|C856
block|,
name|C857
block|,
name|C858
block|,
name|C859
block|,
name|C860
block|,
name|C861
block|,
name|C862
block|,
name|C863
block|,
name|C864
block|,
name|C865
block|,
name|C866
block|,
name|C867
block|,
name|C868
block|,
name|C869
block|,
name|C870
block|,
name|C871
block|,
name|C872
block|,
name|C873
block|,
name|C874
block|,
name|C875
block|,
name|C876
block|,
name|C877
block|,
name|C878
block|,
name|C879
block|,
name|C880
block|,
name|C881
block|,
name|C882
block|,
name|C883
block|,
name|C884
block|,
name|C885
block|,
name|C886
block|,
name|C887
block|,
name|C888
block|,
name|C889
block|,
name|C890
block|,
name|C891
block|,
name|C892
block|,
name|C893
block|,
name|C894
block|,
name|C895
block|,
name|C896
block|,
name|C897
block|,
name|C898
block|,
name|C899
block|,
name|C900
block|,
name|C901
block|,
name|C902
block|,
name|C903
block|,
name|C904
block|,
name|C905
block|,
name|C906
block|,
name|C907
block|,
name|C908
block|,
name|C909
block|,
name|C910
block|,
name|C911
block|,
name|C912
block|,
name|C913
block|,
name|C914
block|,
name|C915
block|,
name|C916
block|,
name|C917
block|,
name|C918
block|,
name|C919
block|,
name|C920
block|,
name|C921
block|,
name|C922
block|,
name|C923
block|,
name|C924
block|,
name|C925
block|,
name|C926
block|,
name|C927
block|,
name|C928
block|,
name|C929
block|,
name|C930
block|,
name|C931
block|,
name|C932
block|,
name|C933
block|,
name|C934
block|,
name|C935
block|,
name|C936
block|,
name|C937
block|,
name|C938
block|,
name|C939
block|,
name|C940
block|,
name|C941
block|,
name|C942
block|,
name|C943
block|,
name|C944
block|,
name|C945
block|,
name|C946
block|,
name|C947
block|,
name|C948
block|,
name|C949
block|,
name|C950
block|,
name|C951
block|,
name|C952
block|,
name|C953
block|,
name|C954
block|,
name|C955
block|,
name|C956
block|,
name|C957
block|,
name|C958
block|,
name|C959
block|,
name|C960
block|,
name|C961
block|,
name|C962
block|,
name|C963
block|,
name|C964
block|,
name|C965
block|,
name|C966
block|,
name|C967
block|,
name|C968
block|,
name|C969
block|,
name|C970
block|,
name|C971
block|,
name|C972
block|,
name|C973
block|,
name|C974
block|,
name|C975
block|,
name|C976
block|,
name|C977
block|,
name|C978
block|,
name|C979
block|,
name|C980
block|,
name|C981
block|,
name|C982
block|,
name|C983
block|,
name|C984
block|,
name|C985
block|,
name|C986
block|,
name|C987
block|,
name|C988
block|,
name|C989
block|,
name|C990
block|,
name|C991
block|,
name|C992
block|,
name|C993
block|,
name|C994
block|,
name|C995
block|,
name|C996
block|,
name|C997
block|,
name|C998
block|,
name|C999
block|,
name|C1000
block|}
empty_stmt|;
specifier|private
specifier|static
name|int
name|totalNumCntrs
init|=
literal|1000
decl_stmt|;
comment|/**    * populated at runtime from hadoop counters at run time in the client.    */
specifier|protected
specifier|transient
name|HashMap
argument_list|<
name|String
argument_list|,
name|Long
argument_list|>
name|counters
decl_stmt|;
comment|/**    * keeps track of unique ProgressCounter enums used this value is used at    * compile time while assigning ProgressCounter enums to counter names.    */
specifier|private
specifier|static
name|int
name|lastEnumUsed
decl_stmt|;
specifier|protected
specifier|transient
name|long
name|inputRows
init|=
literal|0
decl_stmt|;
specifier|protected
specifier|transient
name|long
name|outputRows
init|=
literal|0
decl_stmt|;
specifier|protected
specifier|transient
name|long
name|beginTime
init|=
literal|0
decl_stmt|;
specifier|protected
specifier|transient
name|long
name|totalTime
init|=
literal|0
decl_stmt|;
specifier|protected
specifier|transient
name|Object
name|groupKeyObject
decl_stmt|;
comment|/**    * this is called in operators in map or reduce tasks.    *    * @param name    * @param amount    */
specifier|protected
name|void
name|incrCounter
parameter_list|(
name|String
name|name
parameter_list|,
name|long
name|amount
parameter_list|)
block|{
name|String
name|counterName
init|=
name|getWrappedCounterName
argument_list|(
name|name
argument_list|)
decl_stmt|;
name|ProgressCounter
name|pc
init|=
name|counterNameToEnum
operator|.
name|get
argument_list|(
name|counterName
argument_list|)
decl_stmt|;
comment|// Currently, we maintain fixed number of counters per plan - in case of a
comment|// bigger tree, we may run out of them
if|if
condition|(
name|pc
operator|==
literal|null
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Using too many counters. Increase the total number of counters for "
operator|+
name|counterName
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|reporter
operator|!=
literal|null
condition|)
block|{
name|reporter
operator|.
name|incrCounter
argument_list|(
name|pc
argument_list|,
name|amount
argument_list|)
expr_stmt|;
block|}
block|}
specifier|public
name|ArrayList
argument_list|<
name|String
argument_list|>
name|getCounterNames
parameter_list|()
block|{
return|return
name|counterNames
return|;
block|}
specifier|public
name|void
name|setCounterNames
parameter_list|(
name|ArrayList
argument_list|<
name|String
argument_list|>
name|counterNames
parameter_list|)
block|{
name|this
operator|.
name|counterNames
operator|=
name|counterNames
expr_stmt|;
block|}
specifier|public
name|String
name|getOperatorId
parameter_list|()
block|{
return|return
name|operatorId
return|;
block|}
specifier|public
specifier|final
name|String
name|getWrappedCounterName
parameter_list|(
name|String
name|ctrName
parameter_list|)
block|{
return|return
name|String
operator|.
name|format
argument_list|(
name|counterNameFormat
argument_list|,
name|getOperatorId
argument_list|()
argument_list|,
name|ctrName
argument_list|)
return|;
block|}
specifier|public
name|void
name|initOperatorId
parameter_list|()
block|{
name|setOperatorId
argument_list|(
name|getName
argument_list|()
operator|+
literal|"_"
operator|+
name|this
operator|.
name|id
argument_list|)
expr_stmt|;
block|}
specifier|public
name|void
name|setOperatorId
parameter_list|(
name|String
name|operatorId
parameter_list|)
block|{
name|this
operator|.
name|operatorId
operator|=
name|operatorId
expr_stmt|;
block|}
specifier|public
name|HashMap
argument_list|<
name|String
argument_list|,
name|Long
argument_list|>
name|getCounters
parameter_list|()
block|{
return|return
name|counters
return|;
block|}
comment|/**    * called in ExecDriver.progress periodically.    *    * @param ctrs    *          counters from the running job    */
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
specifier|public
name|void
name|updateCounters
parameter_list|(
name|Counters
name|ctrs
parameter_list|)
block|{
if|if
condition|(
name|counters
operator|==
literal|null
condition|)
block|{
name|counters
operator|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|Long
argument_list|>
argument_list|()
expr_stmt|;
block|}
comment|// For some old unit tests, the counters will not be populated. Eventually,
comment|// the old tests should be removed
if|if
condition|(
name|counterNameToEnum
operator|==
literal|null
condition|)
block|{
return|return;
block|}
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|ProgressCounter
argument_list|>
name|counter
range|:
name|counterNameToEnum
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|counters
operator|.
name|put
argument_list|(
name|counter
operator|.
name|getKey
argument_list|()
argument_list|,
name|ctrs
operator|.
name|getCounter
argument_list|(
name|counter
operator|.
name|getValue
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// update counters of child operators
comment|// this wont be an infinite loop since the operator graph is acyclic
comment|// but, some operators may be updated more than once and that's ok
if|if
condition|(
name|getChildren
argument_list|()
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|Node
name|op
range|:
name|getChildren
argument_list|()
control|)
block|{
operator|(
operator|(
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
operator|)
name|op
operator|)
operator|.
name|updateCounters
argument_list|(
name|ctrs
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**    * Recursively check this operator and its descendants to see if the fatal    * error counter is set to non-zero.    *    * @param ctrs    */
specifier|public
name|boolean
name|checkFatalErrors
parameter_list|(
name|Counters
name|ctrs
parameter_list|,
name|StringBuilder
name|errMsg
parameter_list|)
block|{
if|if
condition|(
name|counterNameToEnum
operator|==
literal|null
condition|)
block|{
return|return
literal|false
return|;
block|}
name|String
name|counterName
init|=
name|getWrappedCounterName
argument_list|(
name|fatalErrorCntr
argument_list|)
decl_stmt|;
name|ProgressCounter
name|pc
init|=
name|counterNameToEnum
operator|.
name|get
argument_list|(
name|counterName
argument_list|)
decl_stmt|;
comment|// Currently, we maintain fixed number of counters per plan - in case of a
comment|// bigger tree, we may run out of them
if|if
condition|(
name|pc
operator|==
literal|null
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Using too many counters. Increase the total number of counters for "
operator|+
name|counterName
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|long
name|value
init|=
name|ctrs
operator|.
name|getCounter
argument_list|(
name|pc
argument_list|)
decl_stmt|;
name|fatalErrorMessage
argument_list|(
name|errMsg
argument_list|,
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
operator|!=
literal|0
condition|)
block|{
return|return
literal|true
return|;
block|}
block|}
if|if
condition|(
name|getChildren
argument_list|()
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|Node
name|op
range|:
name|getChildren
argument_list|()
control|)
block|{
if|if
condition|(
operator|(
operator|(
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
operator|)
name|op
operator|)
operator|.
name|checkFatalErrors
argument_list|(
name|ctrs
argument_list|,
name|errMsg
argument_list|)
condition|)
block|{
return|return
literal|true
return|;
block|}
block|}
block|}
return|return
literal|false
return|;
block|}
comment|/**    * Get the fatal error message based on counter's code.    *    * @param errMsg    *          error message should be appended to this output parameter.    * @param counterValue    *          input counter code.    */
specifier|protected
name|void
name|fatalErrorMessage
parameter_list|(
name|StringBuilder
name|errMsg
parameter_list|,
name|long
name|counterValue
parameter_list|)
block|{   }
comment|// A given query can have multiple map-reduce jobs
specifier|public
specifier|static
name|void
name|resetLastEnumUsed
parameter_list|()
block|{
name|lastEnumUsed
operator|=
literal|0
expr_stmt|;
block|}
comment|/**    * Called only in SemanticAnalyzer after all operators have added their own    * set of counter names.    */
specifier|public
name|void
name|assignCounterNameToEnum
parameter_list|()
block|{
if|if
condition|(
name|counterNameToEnum
operator|!=
literal|null
condition|)
block|{
return|return;
block|}
name|counterNameToEnum
operator|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|ProgressCounter
argument_list|>
argument_list|()
expr_stmt|;
for|for
control|(
name|String
name|counterName
range|:
name|getCounterNames
argument_list|()
control|)
block|{
operator|++
name|lastEnumUsed
expr_stmt|;
comment|// TODO Hack for hadoop-0.17
comment|// Currently, only maximum number of 'totalNumCntrs' can be used. If you
comment|// want
comment|// to add more counters, increase the number of counters in
comment|// ProgressCounter
if|if
condition|(
name|lastEnumUsed
operator|>
name|totalNumCntrs
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Using too many counters. Increase the total number of counters"
argument_list|)
expr_stmt|;
return|return;
block|}
name|String
name|enumName
init|=
literal|"C"
operator|+
name|lastEnumUsed
decl_stmt|;
name|ProgressCounter
name|ctr
init|=
name|ProgressCounter
operator|.
name|valueOf
argument_list|(
name|enumName
argument_list|)
decl_stmt|;
name|counterNameToEnum
operator|.
name|put
argument_list|(
name|counterName
argument_list|,
name|ctr
argument_list|)
expr_stmt|;
block|}
block|}
specifier|protected
specifier|static
name|String
name|numInputRowsCntr
init|=
literal|"NUM_INPUT_ROWS"
decl_stmt|;
specifier|protected
specifier|static
name|String
name|numOutputRowsCntr
init|=
literal|"NUM_OUTPUT_ROWS"
decl_stmt|;
specifier|protected
specifier|static
name|String
name|timeTakenCntr
init|=
literal|"TIME_TAKEN"
decl_stmt|;
specifier|protected
specifier|static
name|String
name|fatalErrorCntr
init|=
literal|"FATAL_ERROR"
decl_stmt|;
specifier|private
specifier|static
name|String
name|counterNameFormat
init|=
literal|"CNTR_NAME_%s_%s"
decl_stmt|;
specifier|public
name|void
name|initializeCounters
parameter_list|()
block|{
name|initOperatorId
argument_list|()
expr_stmt|;
name|counterNames
operator|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
expr_stmt|;
name|counterNames
operator|.
name|add
argument_list|(
name|getWrappedCounterName
argument_list|(
name|numInputRowsCntr
argument_list|)
argument_list|)
expr_stmt|;
name|counterNames
operator|.
name|add
argument_list|(
name|getWrappedCounterName
argument_list|(
name|numOutputRowsCntr
argument_list|)
argument_list|)
expr_stmt|;
name|counterNames
operator|.
name|add
argument_list|(
name|getWrappedCounterName
argument_list|(
name|timeTakenCntr
argument_list|)
argument_list|)
expr_stmt|;
name|counterNames
operator|.
name|add
argument_list|(
name|getWrappedCounterName
argument_list|(
name|fatalErrorCntr
argument_list|)
argument_list|)
expr_stmt|;
comment|/* getAdditionalCounter should return Wrapped counters */
name|List
argument_list|<
name|String
argument_list|>
name|newCntrs
init|=
name|getAdditionalCounters
argument_list|()
decl_stmt|;
if|if
condition|(
name|newCntrs
operator|!=
literal|null
condition|)
block|{
name|counterNames
operator|.
name|addAll
argument_list|(
name|newCntrs
argument_list|)
expr_stmt|;
block|}
block|}
comment|/*    * By default, the list is empty - if an operator wants to add more counters,    * it should override this method and provide the new list. Counter names returned    * by this method should be wrapped counter names (i.e the strings should be passed    * through getWrappedCounterName).    */
specifier|protected
name|List
argument_list|<
name|String
argument_list|>
name|getAdditionalCounters
parameter_list|()
block|{
return|return
literal|null
return|;
block|}
specifier|public
name|HashMap
argument_list|<
name|String
argument_list|,
name|ProgressCounter
argument_list|>
name|getCounterNameToEnum
parameter_list|()
block|{
return|return
name|counterNameToEnum
return|;
block|}
specifier|public
name|void
name|setCounterNameToEnum
parameter_list|(
name|HashMap
argument_list|<
name|String
argument_list|,
name|ProgressCounter
argument_list|>
name|counterNameToEnum
parameter_list|)
block|{
name|this
operator|.
name|counterNameToEnum
operator|=
name|counterNameToEnum
expr_stmt|;
block|}
comment|/**    * Return the type of the specific operator among the    * types in OperatorType.    *    * @return OperatorType.*    */
specifier|abstract
specifier|public
name|OperatorType
name|getType
parameter_list|()
function_decl|;
specifier|public
name|void
name|setGroupKeyObject
parameter_list|(
name|Object
name|keyObject
parameter_list|)
block|{
name|this
operator|.
name|groupKeyObject
operator|=
name|keyObject
expr_stmt|;
block|}
specifier|public
name|Object
name|getGroupKeyObject
parameter_list|()
block|{
return|return
name|groupKeyObject
return|;
block|}
comment|/**    * Called during semantic analysis as operators are being added    * in order to give them a chance to compute any additional plan information    * needed.  Does nothing by default.    */
specifier|public
name|void
name|augmentPlan
parameter_list|()
block|{   }
specifier|public
name|ExecMapperContext
name|getExecContext
parameter_list|()
block|{
return|return
name|execContext
return|;
block|}
specifier|public
name|void
name|setExecContext
parameter_list|(
name|ExecMapperContext
name|execContext
parameter_list|)
block|{
name|this
operator|.
name|execContext
operator|=
name|execContext
expr_stmt|;
if|if
condition|(
name|this
operator|.
name|childOperators
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|this
operator|.
name|childOperators
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
name|op
init|=
name|this
operator|.
name|childOperators
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|op
operator|.
name|setExecContext
argument_list|(
name|execContext
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|// The input file has changed - every operator can invoke specific action
comment|// for each input file
specifier|public
name|void
name|cleanUpInputFileChanged
parameter_list|()
throws|throws
name|HiveException
block|{
name|this
operator|.
name|cleanUpInputFileChangedOp
argument_list|()
expr_stmt|;
if|if
condition|(
name|this
operator|.
name|childOperators
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|this
operator|.
name|childOperators
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
name|op
init|=
name|this
operator|.
name|childOperators
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|op
operator|.
name|cleanUpInputFileChanged
argument_list|()
expr_stmt|;
block|}
block|}
block|}
comment|// If a operator needs to invoke specific cleanup, that operator can override
comment|// this method
specifier|public
name|void
name|cleanUpInputFileChangedOp
parameter_list|()
throws|throws
name|HiveException
block|{   }
specifier|public
name|boolean
name|supportSkewJoinOptimization
parameter_list|()
block|{
return|return
literal|false
return|;
block|}
annotation|@
name|Override
specifier|public
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
name|clone
parameter_list|()
throws|throws
name|CloneNotSupportedException
block|{
name|List
argument_list|<
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
argument_list|>
name|parents
init|=
name|getParentOperators
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
argument_list|>
name|parentClones
init|=
operator|new
name|ArrayList
argument_list|<
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
argument_list|>
argument_list|()
decl_stmt|;
if|if
condition|(
name|parents
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
name|parent
range|:
name|parents
control|)
block|{
name|parentClones
operator|.
name|add
argument_list|(
call|(
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
call|)
argument_list|(
name|parent
operator|.
name|clone
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|T
name|descClone
init|=
operator|(
name|T
operator|)
name|conf
operator|.
name|clone
argument_list|()
decl_stmt|;
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
name|ret
init|=
operator|(
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
operator|)
name|OperatorFactory
operator|.
name|getAndMakeChild
argument_list|(
name|descClone
argument_list|,
name|getSchema
argument_list|()
argument_list|,
name|parentClones
argument_list|)
decl_stmt|;
return|return
name|ret
return|;
block|}
comment|/*    * True only for operators which produce atmost 1 output row per input    * row to it. This will allow the output column names to be directly    * translated to input column names.    */
specifier|public
name|boolean
name|columnNamesRowResolvedCanBeObtained
parameter_list|()
block|{
return|return
literal|false
return|;
block|}
specifier|public
name|boolean
name|isUseBucketizedHiveInputFormat
parameter_list|()
block|{
return|return
name|useBucketizedHiveInputFormat
return|;
block|}
specifier|public
name|void
name|setUseBucketizedHiveInputFormat
parameter_list|(
name|boolean
name|useBucketizedHiveInputFormat
parameter_list|)
block|{
name|this
operator|.
name|useBucketizedHiveInputFormat
operator|=
name|useBucketizedHiveInputFormat
expr_stmt|;
block|}
comment|/**    * Whether this operator supports automatic sort merge join.    * The stack is traversed, and this method is invoked for all the operators.    * @return TRUE if yes, FALSE otherwise.    */
specifier|public
name|boolean
name|supportAutomaticSortMergeJoin
parameter_list|()
block|{
return|return
literal|false
return|;
block|}
specifier|public
name|boolean
name|supportUnionRemoveOptimization
parameter_list|()
block|{
return|return
literal|false
return|;
block|}
comment|/*    * This operator is allowed before mapjoin. Eventually, mapjoin hint should be done away with.    * But, since bucketized mapjoin and sortmerge join depend on it completely. it is needed.    * Check the operators which are allowed before mapjoin.    */
specifier|public
name|boolean
name|opAllowedBeforeMapJoin
parameter_list|()
block|{
return|return
literal|true
return|;
block|}
comment|/*    * This operator is allowed after mapjoin. Eventually, mapjoin hint should be done away with.    * But, since bucketized mapjoin and sortmerge join depend on it completely. it is needed.    * Check the operators which are allowed after mapjoin.    */
specifier|public
name|boolean
name|opAllowedAfterMapJoin
parameter_list|()
block|{
return|return
literal|true
return|;
block|}
comment|/*    * If this task contains a join, it can be converted to a map-join task if this operator is    * present in the mapper. For eg. if a sort-merge join operator is present followed by a regular    * join, it cannot be converted to a auto map-join.    */
specifier|public
name|boolean
name|opAllowedConvertMapJoin
parameter_list|()
block|{
return|return
literal|true
return|;
block|}
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
name|getName
argument_list|()
operator|+
literal|"["
operator|+
name|getIdentifier
argument_list|()
operator|+
literal|"]"
return|;
block|}
specifier|public
specifier|static
name|String
name|toString
parameter_list|(
name|Collection
argument_list|<
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
argument_list|>
name|top
parameter_list|)
block|{
name|StringBuilder
name|builder
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|Set
argument_list|<
name|String
argument_list|>
name|visited
init|=
operator|new
name|HashSet
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|Operator
argument_list|<
name|?
argument_list|>
name|op
range|:
name|top
control|)
block|{
if|if
condition|(
name|builder
operator|.
name|length
argument_list|()
operator|>
literal|0
condition|)
block|{
name|builder
operator|.
name|append
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
name|toString
argument_list|(
name|builder
argument_list|,
name|visited
argument_list|,
name|op
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
return|return
name|builder
operator|.
name|toString
argument_list|()
return|;
block|}
specifier|static
name|boolean
name|toString
parameter_list|(
name|StringBuilder
name|builder
parameter_list|,
name|Set
argument_list|<
name|String
argument_list|>
name|visited
parameter_list|,
name|Operator
argument_list|<
name|?
argument_list|>
name|op
parameter_list|,
name|int
name|start
parameter_list|)
block|{
name|String
name|name
init|=
name|op
operator|.
name|toString
argument_list|()
decl_stmt|;
name|boolean
name|added
init|=
name|visited
operator|.
name|add
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|start
operator|>
literal|0
condition|)
block|{
name|builder
operator|.
name|append
argument_list|(
literal|"-"
argument_list|)
expr_stmt|;
name|start
operator|++
expr_stmt|;
block|}
name|builder
operator|.
name|append
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|start
operator|+=
name|name
operator|.
name|length
argument_list|()
expr_stmt|;
if|if
condition|(
name|added
condition|)
block|{
if|if
condition|(
name|op
operator|.
name|getNumChild
argument_list|()
operator|>
literal|0
condition|)
block|{
name|List
argument_list|<
name|Operator
argument_list|<
name|?
argument_list|>
argument_list|>
name|children
init|=
name|op
operator|.
name|getChildOperators
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|children
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|>
literal|0
condition|)
block|{
name|builder
operator|.
name|append
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|start
condition|;
name|j
operator|++
control|)
block|{
name|builder
operator|.
name|append
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
block|}
block|}
name|toString
argument_list|(
name|builder
argument_list|,
name|visited
argument_list|,
name|children
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|,
name|start
argument_list|)
expr_stmt|;
block|}
block|}
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
block|}
end_class

end_unit

