begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|management
operator|.
name|ManagementFactory
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|management
operator|.
name|MemoryMXBean
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Comparator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|TreeMap
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|conf
operator|.
name|HiveConf
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|vector
operator|.
name|VectorizedRowBatch
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|io
operator|.
name|HiveKey
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|metadata
operator|.
name|HiveException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|OperatorDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|BytesWritable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|WritableComparator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|MinMaxPriorityQueue
import|;
end_import

begin_comment
comment|/**  * Stores binary key/value in sorted manner to get top-n key/value  * TODO: rename to TopNHeap?  */
end_comment

begin_class
specifier|public
class|class
name|TopNHash
block|{
specifier|private
specifier|static
specifier|final
name|Logger
name|LOG
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|TopNHash
operator|.
name|class
argument_list|)
decl_stmt|;
comment|/**    * For interaction between operator and top-n hash.    * Currently only used to forward key/values stored in hash.    */
specifier|public
specifier|static
interface|interface
name|BinaryCollector
block|{
specifier|public
name|void
name|collect
parameter_list|(
name|byte
index|[]
name|key
parameter_list|,
name|byte
index|[]
name|value
parameter_list|,
name|int
name|hash
parameter_list|)
throws|throws
name|IOException
function_decl|;
block|}
specifier|public
specifier|static
specifier|final
name|int
name|FORWARD
init|=
operator|-
literal|1
decl_stmt|;
comment|// Forward the row to reducer as is.
specifier|public
specifier|static
specifier|final
name|int
name|EXCLUDE
init|=
operator|-
literal|2
decl_stmt|;
comment|// Discard the row.
specifier|private
specifier|static
specifier|final
name|int
name|MAY_FORWARD
init|=
operator|-
literal|3
decl_stmt|;
comment|// Vectorized - may forward the row, not sure yet.
specifier|protected
name|BinaryCollector
name|collector
decl_stmt|;
specifier|protected
name|int
name|topN
decl_stmt|;
specifier|protected
name|long
name|threshold
decl_stmt|;
comment|// max heap size
specifier|protected
name|long
name|usage
decl_stmt|;
comment|// binary keys, values and hashCodes of rows, lined up by index
specifier|private
name|byte
index|[]
index|[]
name|keys
decl_stmt|;
specifier|private
name|byte
index|[]
index|[]
name|values
decl_stmt|;
specifier|private
name|int
index|[]
name|hashes
decl_stmt|;
specifier|private
name|int
index|[]
name|distKeyLengths
decl_stmt|;
specifier|private
name|IndexStore
name|indexes
decl_stmt|;
comment|// The heap over the keys, storing indexes in the array.
specifier|private
name|int
name|evicted
decl_stmt|;
comment|// recently evicted index (used for next key/value)
specifier|private
name|int
name|excluded
decl_stmt|;
comment|// count of excluded rows from previous flush
comment|// temporary single-batch context used for vectorization
specifier|private
name|int
name|batchNumForwards
init|=
literal|0
decl_stmt|;
comment|// whether current batch has any forwarded keys
specifier|private
name|int
index|[]
name|indexToBatchIndex
decl_stmt|;
comment|// mapping of index (lined up w/keys) to index in the batch
specifier|protected
name|int
index|[]
name|batchIndexToResult
decl_stmt|;
comment|// mapping of index in the batch (linear) to hash result
specifier|protected
name|int
name|batchSize
decl_stmt|;
comment|// Size of the current batch.
specifier|protected
name|boolean
name|isEnabled
init|=
literal|false
decl_stmt|;
specifier|private
specifier|final
name|Comparator
argument_list|<
name|Integer
argument_list|>
name|C
init|=
operator|new
name|Comparator
argument_list|<
name|Integer
argument_list|>
argument_list|()
block|{
specifier|public
name|int
name|compare
parameter_list|(
name|Integer
name|o1
parameter_list|,
name|Integer
name|o2
parameter_list|)
block|{
name|byte
index|[]
name|key1
init|=
name|keys
index|[
name|o1
index|]
decl_stmt|;
name|byte
index|[]
name|key2
init|=
name|keys
index|[
name|o2
index|]
decl_stmt|;
name|int
name|length1
init|=
name|distKeyLengths
index|[
name|o1
index|]
decl_stmt|;
name|int
name|length2
init|=
name|distKeyLengths
index|[
name|o2
index|]
decl_stmt|;
return|return
name|WritableComparator
operator|.
name|compareBytes
argument_list|(
name|key1
argument_list|,
literal|0
argument_list|,
name|length1
argument_list|,
name|key2
argument_list|,
literal|0
argument_list|,
name|length2
argument_list|)
return|;
block|}
block|}
decl_stmt|;
specifier|public
name|void
name|initialize
parameter_list|(
name|int
name|topN
parameter_list|,
name|float
name|memUsage
parameter_list|,
name|boolean
name|isMapGroupBy
parameter_list|,
name|BinaryCollector
name|collector
parameter_list|,
specifier|final
name|OperatorDesc
name|conf
parameter_list|,
specifier|final
name|Configuration
name|hconf
parameter_list|)
block|{
assert|assert
name|topN
operator|>=
literal|0
operator|&&
name|memUsage
operator|>
literal|0
assert|;
assert|assert
operator|!
name|this
operator|.
name|isEnabled
assert|;
name|this
operator|.
name|isEnabled
operator|=
literal|false
expr_stmt|;
name|this
operator|.
name|topN
operator|=
name|topN
expr_stmt|;
name|this
operator|.
name|collector
operator|=
name|collector
expr_stmt|;
if|if
condition|(
name|topN
operator|==
literal|0
condition|)
block|{
name|isEnabled
operator|=
literal|true
expr_stmt|;
return|return;
comment|// topN == 0 will cause a short-circuit, don't need any initialization
block|}
specifier|final
name|boolean
name|isTez
init|=
name|HiveConf
operator|.
name|getVar
argument_list|(
name|hconf
argument_list|,
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVE_EXECUTION_ENGINE
argument_list|)
operator|.
name|equals
argument_list|(
literal|"tez"
argument_list|)
decl_stmt|;
specifier|final
name|boolean
name|isLlap
init|=
name|isTez
operator|&&
name|HiveConf
operator|.
name|getVar
argument_list|(
name|hconf
argument_list|,
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVE_EXECUTION_MODE
argument_list|)
operator|.
name|equals
argument_list|(
literal|"llap"
argument_list|)
decl_stmt|;
specifier|final
name|int
name|numExecutors
init|=
name|isLlap
condition|?
name|HiveConf
operator|.
name|getIntVar
argument_list|(
name|hconf
argument_list|,
name|HiveConf
operator|.
name|ConfVars
operator|.
name|LLAP_DAEMON_NUM_EXECUTORS
argument_list|)
else|:
literal|1
decl_stmt|;
comment|// Used Memory = totalMemory() - freeMemory();
comment|// Total Free Memory = maxMemory() - Used Memory;
name|long
name|totalFreeMemory
init|=
name|Runtime
operator|.
name|getRuntime
argument_list|()
operator|.
name|maxMemory
argument_list|()
operator|-
name|Runtime
operator|.
name|getRuntime
argument_list|()
operator|.
name|totalMemory
argument_list|()
operator|+
name|Runtime
operator|.
name|getRuntime
argument_list|()
operator|.
name|freeMemory
argument_list|()
decl_stmt|;
if|if
condition|(
name|isTez
condition|)
block|{
name|MemoryMXBean
name|memoryMXBean
init|=
name|ManagementFactory
operator|.
name|getMemoryMXBean
argument_list|()
decl_stmt|;
comment|// TODO: For LLAP, assumption is off-heap cache.
specifier|final
name|long
name|memoryUsedPerExecutor
init|=
operator|(
name|memoryMXBean
operator|.
name|getHeapMemoryUsage
argument_list|()
operator|.
name|getUsed
argument_list|()
operator|/
name|numExecutors
operator|)
decl_stmt|;
comment|// this is total free memory available per executor in case of LLAP
name|totalFreeMemory
operator|=
name|conf
operator|.
name|getMaxMemoryAvailable
argument_list|()
operator|-
name|memoryUsedPerExecutor
expr_stmt|;
block|}
comment|// limit * 64 : compensation of arrays for key/value/hashcodes
name|this
operator|.
name|threshold
operator|=
call|(
name|long
call|)
argument_list|(
name|memUsage
operator|*
name|totalFreeMemory
argument_list|)
operator|-
name|topN
operator|*
literal|64L
expr_stmt|;
if|if
condition|(
name|threshold
operator|<
literal|0
condition|)
block|{
return|return;
block|}
name|this
operator|.
name|indexes
operator|=
name|isMapGroupBy
condition|?
operator|new
name|HashForGroup
argument_list|()
else|:
operator|new
name|HashForRow
argument_list|()
expr_stmt|;
name|this
operator|.
name|keys
operator|=
operator|new
name|byte
index|[
name|topN
operator|+
literal|1
index|]
index|[]
expr_stmt|;
name|this
operator|.
name|values
operator|=
operator|new
name|byte
index|[
name|topN
operator|+
literal|1
index|]
index|[]
expr_stmt|;
name|this
operator|.
name|hashes
operator|=
operator|new
name|int
index|[
name|topN
operator|+
literal|1
index|]
expr_stmt|;
name|this
operator|.
name|distKeyLengths
operator|=
operator|new
name|int
index|[
name|topN
operator|+
literal|1
index|]
expr_stmt|;
name|this
operator|.
name|evicted
operator|=
name|topN
expr_stmt|;
name|this
operator|.
name|isEnabled
operator|=
literal|true
expr_stmt|;
block|}
comment|/**    * Try store the non-vectorized key.    * @param key Serialized key.    * @return TopNHash.FORWARD if the row should be forwarded;    *         TopNHash.EXCLUDED if the row should be discarded;    *         any other number if the row is to be stored; the index should be passed to storeValue.    */
specifier|public
name|int
name|tryStoreKey
parameter_list|(
name|HiveKey
name|key
parameter_list|,
name|boolean
name|partColsIsNull
parameter_list|)
throws|throws
name|HiveException
throws|,
name|IOException
block|{
if|if
condition|(
operator|!
name|isEnabled
condition|)
block|{
return|return
name|FORWARD
return|;
comment|// short-circuit quickly - forward all rows
block|}
if|if
condition|(
name|topN
operator|==
literal|0
condition|)
block|{
return|return
name|EXCLUDE
return|;
comment|// short-circuit quickly - eat all rows
block|}
name|int
name|index
init|=
name|insertKeyIntoHeap
argument_list|(
name|key
argument_list|)
decl_stmt|;
if|if
condition|(
name|index
operator|>=
literal|0
condition|)
block|{
name|usage
operator|+=
name|key
operator|.
name|getLength
argument_list|()
expr_stmt|;
return|return
name|index
return|;
block|}
comment|// IndexStore is trying to tell us something.
switch|switch
condition|(
name|index
condition|)
block|{
case|case
name|FORWARD
case|:
return|return
name|FORWARD
return|;
case|case
name|EXCLUDE
case|:
return|return
name|EXCLUDE
return|;
comment|// skip the row.
default|default:
block|{
assert|assert
literal|false
assert|;
throw|throw
operator|new
name|HiveException
argument_list|(
literal|"Invalid result trying to store the key: "
operator|+
name|index
argument_list|)
throw|;
block|}
block|}
block|}
comment|/**    * Perform basic checks and initialize TopNHash for the new vectorized row batch.    * @param size batch size    * @return TopNHash.FORWARD if all rows should be forwarded w/o trying to call TopN;    *         TopNHash.EXCLUDED if all rows should be discarded w/o trying to call TopN;    *         any other result means the batch has been started.    */
specifier|public
name|int
name|startVectorizedBatch
parameter_list|(
name|int
name|size
parameter_list|)
throws|throws
name|IOException
throws|,
name|HiveException
block|{
if|if
condition|(
operator|!
name|isEnabled
condition|)
block|{
return|return
name|FORWARD
return|;
comment|// short-circuit quickly - forward all rows
block|}
elseif|else
if|if
condition|(
name|topN
operator|==
literal|0
condition|)
block|{
return|return
name|EXCLUDE
return|;
comment|// short-circuit quickly - eat all rows
block|}
comment|// Flush here if the memory usage is too high. After that, we have the entire
comment|// batch already in memory anyway so we will bypass the memory checks.
if|if
condition|(
name|usage
operator|>
name|threshold
condition|)
block|{
name|int
name|excluded
init|=
name|this
operator|.
name|excluded
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Top-N hash is flushing rows"
argument_list|)
expr_stmt|;
name|flushInternal
argument_list|()
expr_stmt|;
if|if
condition|(
name|excluded
operator|==
literal|0
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Top-N hash has been disabled"
argument_list|)
expr_stmt|;
name|isEnabled
operator|=
literal|false
expr_stmt|;
return|return
name|FORWARD
return|;
comment|// Hash is ineffective, disable.
block|}
block|}
comment|// Started ok; initialize context for new batch.
name|batchSize
operator|=
name|size
expr_stmt|;
if|if
condition|(
name|batchIndexToResult
operator|==
literal|null
operator|||
name|batchIndexToResult
operator|.
name|length
operator|<
name|batchSize
condition|)
block|{
name|batchIndexToResult
operator|=
operator|new
name|int
index|[
name|Math
operator|.
name|max
argument_list|(
name|batchSize
argument_list|,
name|VectorizedRowBatch
operator|.
name|DEFAULT_SIZE
argument_list|)
index|]
expr_stmt|;
block|}
if|if
condition|(
name|indexToBatchIndex
operator|==
literal|null
condition|)
block|{
name|indexToBatchIndex
operator|=
operator|new
name|int
index|[
name|topN
operator|+
literal|1
index|]
expr_stmt|;
block|}
name|Arrays
operator|.
name|fill
argument_list|(
name|indexToBatchIndex
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|batchNumForwards
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/**    * Try to put the key from the current vectorized batch into the heap.    * @param key the key.    * @param batchIndex The index of the key in the vectorized batch (sequential, not .selected).    */
specifier|public
name|void
name|tryStoreVectorizedKey
parameter_list|(
name|HiveKey
name|key
parameter_list|,
name|boolean
name|partColsIsNull
parameter_list|,
name|int
name|batchIndex
parameter_list|)
throws|throws
name|HiveException
throws|,
name|IOException
block|{
comment|// Assumption - batchIndex is increasing; startVectorizedBatch was called
name|int
name|size
init|=
name|indexes
operator|.
name|size
argument_list|()
decl_stmt|;
name|int
name|index
init|=
name|size
operator|<
name|topN
condition|?
name|size
else|:
name|evicted
decl_stmt|;
name|keys
index|[
name|index
index|]
operator|=
name|Arrays
operator|.
name|copyOf
argument_list|(
name|key
operator|.
name|getBytes
argument_list|()
argument_list|,
name|key
operator|.
name|getLength
argument_list|()
argument_list|)
expr_stmt|;
name|distKeyLengths
index|[
name|index
index|]
operator|=
name|key
operator|.
name|getDistKeyLength
argument_list|()
expr_stmt|;
name|hashes
index|[
name|index
index|]
operator|=
name|key
operator|.
name|hashCode
argument_list|()
expr_stmt|;
name|Integer
name|collisionIndex
init|=
name|indexes
operator|.
name|store
argument_list|(
name|index
argument_list|)
decl_stmt|;
if|if
condition|(
literal|null
operator|!=
name|collisionIndex
condition|)
block|{
comment|/*        * since there is a collision index will be used for the next value         * so have the map point back to original index.        */
if|if
condition|(
name|indexes
operator|instanceof
name|HashForGroup
condition|)
block|{
name|indexes
operator|.
name|store
argument_list|(
name|collisionIndex
argument_list|)
expr_stmt|;
block|}
comment|// forward conditional on the survival of the corresponding key currently in indexes.
operator|++
name|batchNumForwards
expr_stmt|;
name|batchIndexToResult
index|[
name|batchIndex
index|]
operator|=
name|MAY_FORWARD
operator|-
name|collisionIndex
expr_stmt|;
return|return;
block|}
name|indexToBatchIndex
index|[
name|index
index|]
operator|=
name|batchIndex
expr_stmt|;
name|batchIndexToResult
index|[
name|batchIndex
index|]
operator|=
name|index
expr_stmt|;
if|if
condition|(
name|size
operator|!=
name|topN
condition|)
return|return;
name|evicted
operator|=
name|indexes
operator|.
name|removeBiggest
argument_list|()
expr_stmt|;
comment|// remove the biggest key
if|if
condition|(
name|index
operator|==
name|evicted
condition|)
block|{
name|excluded
operator|++
expr_stmt|;
name|batchIndexToResult
index|[
name|batchIndex
index|]
operator|=
name|EXCLUDE
expr_stmt|;
name|indexToBatchIndex
index|[
name|index
index|]
operator|=
operator|-
literal|1
expr_stmt|;
return|return;
comment|// input key is bigger than any of keys in hash
block|}
name|removed
argument_list|(
name|evicted
argument_list|)
expr_stmt|;
name|int
name|evictedBatchIndex
init|=
name|indexToBatchIndex
index|[
name|evicted
index|]
decl_stmt|;
if|if
condition|(
name|evictedBatchIndex
operator|>=
literal|0
condition|)
block|{
comment|// reset the result for the evicted index
name|batchIndexToResult
index|[
name|evictedBatchIndex
index|]
operator|=
name|EXCLUDE
expr_stmt|;
name|indexToBatchIndex
index|[
name|evicted
index|]
operator|=
operator|-
literal|1
expr_stmt|;
block|}
comment|// Evict all results grouped with this index; it cannot be any key further in the batch.
comment|// If we evict a key from this batch, the keys grouped with it cannot be earlier that that key.
comment|// If we evict a key that is not from this batch, initial i = (-1) + 1 = 0, as intended.
name|int
name|evictedForward
init|=
operator|(
name|MAY_FORWARD
operator|-
name|evicted
operator|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
name|evictedBatchIndex
operator|+
literal|1
init|;
name|i
operator|<
name|batchIndex
operator|&&
operator|(
name|batchNumForwards
operator|>
literal|0
operator|)
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|batchIndexToResult
index|[
name|i
index|]
operator|==
name|evictedForward
condition|)
block|{
name|batchIndexToResult
index|[
name|i
index|]
operator|=
name|EXCLUDE
expr_stmt|;
operator|--
name|batchNumForwards
expr_stmt|;
block|}
block|}
block|}
comment|/**    * Get vectorized batch result for particular index.    * @param batchIndex index of the key in the batch.    * @return the result, same as from {@link #tryStoreKey(HiveKey)}    */
specifier|public
name|int
name|getVectorizedBatchResult
parameter_list|(
name|int
name|batchIndex
parameter_list|)
block|{
name|int
name|result
init|=
name|batchIndexToResult
index|[
name|batchIndex
index|]
decl_stmt|;
return|return
operator|(
name|result
operator|<=
name|MAY_FORWARD
operator|)
condition|?
name|FORWARD
else|:
name|result
return|;
block|}
comment|/**    * After vectorized batch is processed, can return the key that caused a particular row    * to be forwarded. Because the row could only be marked to forward because it has    * the same key with some row already in the heap (for GBY), we can use that key from the    * heap to emit the forwarded row.    * @param batchIndex index of the key in the batch.    * @return The key corresponding to the index.    */
specifier|public
name|HiveKey
name|getVectorizedKeyToForward
parameter_list|(
name|int
name|batchIndex
parameter_list|)
block|{
name|int
name|index
init|=
name|MAY_FORWARD
operator|-
name|batchIndexToResult
index|[
name|batchIndex
index|]
decl_stmt|;
name|HiveKey
name|hk
init|=
operator|new
name|HiveKey
argument_list|()
decl_stmt|;
name|hk
operator|.
name|set
argument_list|(
name|keys
index|[
name|index
index|]
argument_list|,
literal|0
argument_list|,
name|keys
index|[
name|index
index|]
operator|.
name|length
argument_list|)
expr_stmt|;
name|hk
operator|.
name|setHashCode
argument_list|(
name|hashes
index|[
name|index
index|]
argument_list|)
expr_stmt|;
name|hk
operator|.
name|setDistKeyLength
argument_list|(
name|distKeyLengths
index|[
name|index
index|]
argument_list|)
expr_stmt|;
return|return
name|hk
return|;
block|}
comment|/**    * After vectorized batch is processed, can return distribution keys length of a key.    * @param batchIndex index of the key in the batch.    * @return The distribution length corresponding to the key.    */
specifier|public
name|int
name|getVectorizedKeyDistLength
parameter_list|(
name|int
name|batchIndex
parameter_list|)
block|{
return|return
name|distKeyLengths
index|[
name|batchIndexToResult
index|[
name|batchIndex
index|]
index|]
return|;
block|}
comment|/**    * After vectorized batch is processed, can return hashCode of a key.    * @param batchIndex index of the key in the batch.    * @return The hashCode corresponding to the key.    */
specifier|public
name|int
name|getVectorizedKeyHashCode
parameter_list|(
name|int
name|batchIndex
parameter_list|)
block|{
return|return
name|hashes
index|[
name|batchIndexToResult
index|[
name|batchIndex
index|]
index|]
return|;
block|}
comment|/**    * Stores the value for the key in the heap.    * @param index The index, either from tryStoreKey or from tryStoreVectorizedKey result.    * @param hasCode hashCode of key, used by ptfTopNHash.    * @param value The value to store.    * @param keyHash The key hash to store.    * @param vectorized Whether the result is coming from a vectorized batch.    */
specifier|public
name|void
name|storeValue
parameter_list|(
name|int
name|index
parameter_list|,
name|int
name|hashCode
parameter_list|,
name|BytesWritable
name|value
parameter_list|,
name|boolean
name|vectorized
parameter_list|)
block|{
name|values
index|[
name|index
index|]
operator|=
name|Arrays
operator|.
name|copyOf
argument_list|(
name|value
operator|.
name|getBytes
argument_list|()
argument_list|,
name|value
operator|.
name|getLength
argument_list|()
argument_list|)
expr_stmt|;
comment|// Vectorized doesn't adjust usage for the keys while processing the batch
name|usage
operator|+=
name|values
index|[
name|index
index|]
operator|.
name|length
operator|+
operator|(
name|vectorized
condition|?
name|keys
index|[
name|index
index|]
operator|.
name|length
else|:
literal|0
operator|)
expr_stmt|;
block|}
comment|/**    * Flushes all the rows cached in the heap.    */
specifier|public
name|void
name|flush
parameter_list|()
throws|throws
name|HiveException
block|{
if|if
condition|(
operator|!
name|isEnabled
operator|||
operator|(
name|topN
operator|==
literal|0
operator|)
condition|)
return|return;
try|try
block|{
name|flushInternal
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ex
parameter_list|)
block|{
throw|throw
operator|new
name|HiveException
argument_list|(
name|ex
argument_list|)
throw|;
block|}
block|}
comment|/**    * returns index for key/value/hashcode if it's acceptable.    * -1, -2, -3, -4 can be returned for other actions.    *<p/>    * -1 for FORWARD   : should be forwarded to output collector (for GBY)    * -2 for EXCLUDED  : not in top-k. ignore it    */
specifier|private
name|int
name|insertKeyIntoHeap
parameter_list|(
name|HiveKey
name|key
parameter_list|)
throws|throws
name|IOException
throws|,
name|HiveException
block|{
if|if
condition|(
name|usage
operator|>
name|threshold
condition|)
block|{
name|flushInternal
argument_list|()
expr_stmt|;
if|if
condition|(
name|excluded
operator|==
literal|0
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Top-N hash is disabled"
argument_list|)
expr_stmt|;
name|isEnabled
operator|=
literal|false
expr_stmt|;
block|}
comment|// we can now retry adding key/value into hash, which is flushed.
comment|// but for simplicity, just forward them
return|return
name|FORWARD
return|;
block|}
name|int
name|size
init|=
name|indexes
operator|.
name|size
argument_list|()
decl_stmt|;
name|int
name|index
init|=
name|size
operator|<
name|topN
condition|?
name|size
else|:
name|evicted
decl_stmt|;
name|keys
index|[
name|index
index|]
operator|=
name|Arrays
operator|.
name|copyOf
argument_list|(
name|key
operator|.
name|getBytes
argument_list|()
argument_list|,
name|key
operator|.
name|getLength
argument_list|()
argument_list|)
expr_stmt|;
name|distKeyLengths
index|[
name|index
index|]
operator|=
name|key
operator|.
name|getDistKeyLength
argument_list|()
expr_stmt|;
name|hashes
index|[
name|index
index|]
operator|=
name|key
operator|.
name|hashCode
argument_list|()
expr_stmt|;
if|if
condition|(
literal|null
operator|!=
name|indexes
operator|.
name|store
argument_list|(
name|index
argument_list|)
condition|)
block|{
comment|// it's only for GBY which should forward all values associated with the key in the range
comment|// of limit. new value should be attatched with the key but in current implementation,
comment|// only one values is allowed. with map-aggreagtion which is true by default,
comment|// this is not common case, so just forward new key/value and forget that (todo)
return|return
name|FORWARD
return|;
block|}
if|if
condition|(
name|size
operator|==
name|topN
condition|)
block|{
name|evicted
operator|=
name|indexes
operator|.
name|removeBiggest
argument_list|()
expr_stmt|;
comment|// remove the biggest key
if|if
condition|(
name|index
operator|==
name|evicted
condition|)
block|{
name|excluded
operator|++
expr_stmt|;
return|return
name|EXCLUDE
return|;
comment|// input key is bigger than any of keys in hash
block|}
name|removed
argument_list|(
name|evicted
argument_list|)
expr_stmt|;
block|}
return|return
name|index
return|;
block|}
comment|// key/value of the index is removed. retrieve memory usage
specifier|private
name|void
name|removed
parameter_list|(
name|int
name|index
parameter_list|)
block|{
name|usage
operator|-=
name|keys
index|[
name|index
index|]
operator|.
name|length
expr_stmt|;
name|keys
index|[
name|index
index|]
operator|=
literal|null
expr_stmt|;
if|if
condition|(
name|values
index|[
name|index
index|]
operator|!=
literal|null
condition|)
block|{
name|usage
operator|-=
name|values
index|[
name|index
index|]
operator|.
name|length
expr_stmt|;
name|values
index|[
name|index
index|]
operator|=
literal|null
expr_stmt|;
block|}
name|hashes
index|[
name|index
index|]
operator|=
operator|-
literal|1
expr_stmt|;
name|distKeyLengths
index|[
name|index
index|]
operator|=
operator|-
literal|1
expr_stmt|;
block|}
specifier|private
name|void
name|flushInternal
parameter_list|()
throws|throws
name|IOException
throws|,
name|HiveException
block|{
for|for
control|(
name|int
name|index
range|:
name|indexes
operator|.
name|indexes
argument_list|()
control|)
block|{
if|if
condition|(
name|index
operator|!=
name|evicted
operator|&&
name|values
index|[
name|index
index|]
operator|!=
literal|null
condition|)
block|{
name|collector
operator|.
name|collect
argument_list|(
name|keys
index|[
name|index
index|]
argument_list|,
name|values
index|[
name|index
index|]
argument_list|,
name|hashes
index|[
name|index
index|]
argument_list|)
expr_stmt|;
name|usage
operator|-=
name|values
index|[
name|index
index|]
operator|.
name|length
expr_stmt|;
name|values
index|[
name|index
index|]
operator|=
literal|null
expr_stmt|;
name|hashes
index|[
name|index
index|]
operator|=
operator|-
literal|1
expr_stmt|;
block|}
block|}
name|excluded
operator|=
literal|0
expr_stmt|;
block|}
specifier|private
interface|interface
name|IndexStore
block|{
name|int
name|size
parameter_list|()
function_decl|;
comment|/**      * @return the index which caused the item to be rejected; or null if accepted      */
name|Integer
name|store
parameter_list|(
name|int
name|index
parameter_list|)
function_decl|;
name|int
name|removeBiggest
parameter_list|()
function_decl|;
name|Iterable
argument_list|<
name|Integer
argument_list|>
name|indexes
parameter_list|()
function_decl|;
block|}
comment|/**    * for order by, same keys are counted (For 1-2-2-3-4, limit 3 is 1-2-2)    * MinMaxPriorityQueue is used because it alows duplication and fast access to biggest one    */
specifier|private
class|class
name|HashForRow
implements|implements
name|IndexStore
block|{
specifier|private
specifier|final
name|MinMaxPriorityQueue
argument_list|<
name|Integer
argument_list|>
name|indexes
init|=
name|MinMaxPriorityQueue
operator|.
name|orderedBy
argument_list|(
name|C
argument_list|)
operator|.
name|create
argument_list|()
decl_stmt|;
specifier|public
name|int
name|size
parameter_list|()
block|{
return|return
name|indexes
operator|.
name|size
argument_list|()
return|;
block|}
comment|// returns null always
specifier|public
name|Integer
name|store
parameter_list|(
name|int
name|index
parameter_list|)
block|{
name|boolean
name|result
init|=
name|indexes
operator|.
name|add
argument_list|(
name|index
argument_list|)
decl_stmt|;
assert|assert
name|result
assert|;
return|return
literal|null
return|;
block|}
specifier|public
name|int
name|removeBiggest
parameter_list|()
block|{
return|return
name|indexes
operator|.
name|removeLast
argument_list|()
return|;
block|}
specifier|public
name|Iterable
argument_list|<
name|Integer
argument_list|>
name|indexes
parameter_list|()
block|{
name|Integer
index|[]
name|array
init|=
name|indexes
operator|.
name|toArray
argument_list|(
operator|new
name|Integer
index|[
name|indexes
operator|.
name|size
argument_list|()
index|]
argument_list|)
decl_stmt|;
name|Arrays
operator|.
name|sort
argument_list|(
name|array
argument_list|,
literal|0
argument_list|,
name|array
operator|.
name|length
argument_list|,
name|C
argument_list|)
expr_stmt|;
return|return
name|Arrays
operator|.
name|asList
argument_list|(
name|array
argument_list|)
return|;
block|}
block|}
comment|/**    * for group by, same keys are not counted (For 1-2-2-3-4, limit 3 is 1-2-(2)-3)    * simple TreeMap is used because group by does not need keep duplicated keys    */
specifier|private
class|class
name|HashForGroup
implements|implements
name|IndexStore
block|{
comment|// TreeSet anyway uses TreeMap; so use plain TreeMap to be able to get value in collisions.
specifier|private
specifier|final
name|TreeMap
argument_list|<
name|Integer
argument_list|,
name|Integer
argument_list|>
name|indexes
init|=
operator|new
name|TreeMap
argument_list|<
name|Integer
argument_list|,
name|Integer
argument_list|>
argument_list|(
name|C
argument_list|)
decl_stmt|;
specifier|public
name|int
name|size
parameter_list|()
block|{
return|return
name|indexes
operator|.
name|size
argument_list|()
return|;
block|}
comment|// returns false if index already exists in map
specifier|public
name|Integer
name|store
parameter_list|(
name|int
name|index
parameter_list|)
block|{
return|return
name|indexes
operator|.
name|put
argument_list|(
name|index
argument_list|,
name|index
argument_list|)
return|;
block|}
specifier|public
name|int
name|removeBiggest
parameter_list|()
block|{
name|Integer
name|last
init|=
name|indexes
operator|.
name|lastKey
argument_list|()
decl_stmt|;
name|indexes
operator|.
name|remove
argument_list|(
name|last
argument_list|)
expr_stmt|;
return|return
name|last
return|;
block|}
specifier|public
name|Iterable
argument_list|<
name|Integer
argument_list|>
name|indexes
parameter_list|()
block|{
return|return
name|indexes
operator|.
name|keySet
argument_list|()
return|;
block|}
block|}
block|}
end_class

end_unit

