begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|optimizer
package|;
end_package

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|Log
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|LogFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|conf
operator|.
name|HiveConf
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|Context
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|Operator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|TableScanOperator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|metadata
operator|.
name|HiveException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|metadata
operator|.
name|Table
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|optimizer
operator|.
name|ppr
operator|.
name|PartitionPruner
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|parse
operator|.
name|GlobalLimitCtx
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|parse
operator|.
name|ParseContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|parse
operator|.
name|PrunedPartitionList
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|parse
operator|.
name|QB
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|parse
operator|.
name|QBParseInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|parse
operator|.
name|SemanticException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|parse
operator|.
name|SplitSample
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|ExprNodeDesc
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|Serializable
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_comment
comment|/**  * This optimizer is used to reduce the input size for the query for queries which are  * specifying a limit.  *<p/>  * For eg. for a query of type:  *<p/>  * select expr from T where<filter> limit 100;  *<p/>  * Most probably, the whole table T need not be scanned.  * Chances are that even if we scan the first file of T, we would get the 100 rows  * needed by this query.  * This optimizer step populates the GlobalLimitCtx which is used later on to prune the inputs.  */
end_comment

begin_class
specifier|public
class|class
name|GlobalLimitOptimizer
implements|implements
name|Transform
block|{
specifier|private
specifier|final
name|Log
name|LOG
init|=
name|LogFactory
operator|.
name|getLog
argument_list|(
name|GlobalLimitOptimizer
operator|.
name|class
operator|.
name|getName
argument_list|()
argument_list|)
decl_stmt|;
specifier|public
name|ParseContext
name|transform
parameter_list|(
name|ParseContext
name|pctx
parameter_list|)
throws|throws
name|SemanticException
block|{
name|Context
name|ctx
init|=
name|pctx
operator|.
name|getContext
argument_list|()
decl_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|Operator
argument_list|<
name|?
extends|extends
name|Serializable
argument_list|>
argument_list|>
name|topOps
init|=
name|pctx
operator|.
name|getTopOps
argument_list|()
decl_stmt|;
name|GlobalLimitCtx
name|globalLimitCtx
init|=
name|pctx
operator|.
name|getGlobalLimitCtx
argument_list|()
decl_stmt|;
name|Map
argument_list|<
name|TableScanOperator
argument_list|,
name|ExprNodeDesc
argument_list|>
name|opToPartPruner
init|=
name|pctx
operator|.
name|getOpToPartPruner
argument_list|()
decl_stmt|;
name|Map
argument_list|<
name|TableScanOperator
argument_list|,
name|PrunedPartitionList
argument_list|>
name|opToPartList
init|=
name|pctx
operator|.
name|getOpToPartList
argument_list|()
decl_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|PrunedPartitionList
argument_list|>
name|prunedPartitions
init|=
name|pctx
operator|.
name|getPrunedPartitions
argument_list|()
decl_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|SplitSample
argument_list|>
name|nameToSplitSample
init|=
name|pctx
operator|.
name|getNameToSplitSample
argument_list|()
decl_stmt|;
name|Map
argument_list|<
name|TableScanOperator
argument_list|,
name|Table
argument_list|>
name|topToTable
init|=
name|pctx
operator|.
name|getTopToTable
argument_list|()
decl_stmt|;
name|QB
name|qb
init|=
name|pctx
operator|.
name|getQB
argument_list|()
decl_stmt|;
name|HiveConf
name|conf
init|=
name|pctx
operator|.
name|getConf
argument_list|()
decl_stmt|;
name|QBParseInfo
name|qbParseInfo
init|=
name|qb
operator|.
name|getParseInfo
argument_list|()
decl_stmt|;
comment|// determine the query qualifies reduce input size for LIMIT
comment|// The query only qualifies when there are only one top operator
comment|// and there is no transformer or UDTF and no block sampling
comment|// is used.
if|if
condition|(
name|ctx
operator|.
name|getTryCount
argument_list|()
operator|==
literal|0
operator|&&
name|topOps
operator|.
name|size
argument_list|()
operator|==
literal|1
operator|&&
operator|!
name|globalLimitCtx
operator|.
name|ifHasTransformOrUDTF
argument_list|()
operator|&&
name|nameToSplitSample
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
comment|// Here we recursively check:
comment|// 1. whether there are exact one LIMIT in the query
comment|// 2. whether there is no aggregation, group-by, distinct, sort by,
comment|//    distributed by, or table sampling in any of the sub-query.
comment|// The query only qualifies if both conditions are satisfied.
comment|//
comment|// Example qualified queries:
comment|//    CREATE TABLE ... AS SELECT col1, col2 FROM tbl LIMIT ..
comment|//    INSERT OVERWRITE TABLE ... SELECT col1, hash(col2), split(col1)
comment|//                               FROM ... LIMIT...
comment|//    SELECT * FROM (SELECT col1 as col2 (SELECT * FROM ...) t1 LIMIT ...) t2);
comment|//
name|Integer
name|tempGlobalLimit
init|=
name|checkQbpForGlobalLimit
argument_list|(
name|qb
argument_list|)
decl_stmt|;
comment|// query qualify for the optimization
if|if
condition|(
name|tempGlobalLimit
operator|!=
literal|null
operator|&&
name|tempGlobalLimit
operator|!=
literal|0
condition|)
block|{
name|TableScanOperator
name|ts
init|=
operator|(
name|TableScanOperator
operator|)
name|topOps
operator|.
name|values
argument_list|()
operator|.
name|toArray
argument_list|()
index|[
literal|0
index|]
decl_stmt|;
name|Table
name|tab
init|=
name|topToTable
operator|.
name|get
argument_list|(
name|ts
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|tab
operator|.
name|isPartitioned
argument_list|()
condition|)
block|{
if|if
condition|(
name|qbParseInfo
operator|.
name|getDestToWhereExpr
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|globalLimitCtx
operator|.
name|enableOpt
argument_list|(
name|tempGlobalLimit
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// check if the pruner only contains partition columns
if|if
condition|(
name|PartitionPruner
operator|.
name|onlyContainsPartnCols
argument_list|(
name|tab
argument_list|,
name|opToPartPruner
operator|.
name|get
argument_list|(
name|ts
argument_list|)
argument_list|)
condition|)
block|{
name|PrunedPartitionList
name|partsList
init|=
literal|null
decl_stmt|;
try|try
block|{
name|partsList
operator|=
name|opToPartList
operator|.
name|get
argument_list|(
name|ts
argument_list|)
expr_stmt|;
if|if
condition|(
name|partsList
operator|==
literal|null
condition|)
block|{
name|partsList
operator|=
name|PartitionPruner
operator|.
name|prune
argument_list|(
name|tab
argument_list|,
name|opToPartPruner
operator|.
name|get
argument_list|(
name|ts
argument_list|)
argument_list|,
name|conf
argument_list|,
operator|(
name|String
operator|)
name|topOps
operator|.
name|keySet
argument_list|()
operator|.
name|toArray
argument_list|()
index|[
literal|0
index|]
argument_list|,
name|prunedPartitions
argument_list|)
expr_stmt|;
name|opToPartList
operator|.
name|put
argument_list|(
name|ts
argument_list|,
name|partsList
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|HiveException
name|e
parameter_list|)
block|{
comment|// Has to use full name to make sure it does not conflict with
comment|// org.apache.commons.lang.StringUtils
name|LOG
operator|.
name|error
argument_list|(
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|StringUtils
operator|.
name|stringifyException
argument_list|(
name|e
argument_list|)
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|SemanticException
argument_list|(
name|e
operator|.
name|getMessage
argument_list|()
argument_list|,
name|e
argument_list|)
throw|;
block|}
comment|// If there is any unknown partition, create a map-reduce job for
comment|// the filter to prune correctly
if|if
condition|(
operator|(
name|partsList
operator|.
name|getUnknownPartns
argument_list|()
operator|.
name|size
argument_list|()
operator|==
literal|0
operator|)
condition|)
block|{
name|globalLimitCtx
operator|.
name|enableOpt
argument_list|(
name|tempGlobalLimit
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|globalLimitCtx
operator|.
name|isEnable
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Qualify the optimize that reduces input size for 'limit' for limit "
operator|+
name|globalLimitCtx
operator|.
name|getGlobalLimit
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
name|pctx
return|;
block|}
comment|/**    * Recursively check the limit number in all sub queries    *    * @param qbParseInfo    * @return if there is one and only one limit for all subqueries, return the limit    *         if there is no limit, return 0    *         otherwise, return null    */
specifier|private
name|Integer
name|checkQbpForGlobalLimit
parameter_list|(
name|QB
name|localQb
parameter_list|)
block|{
name|QBParseInfo
name|qbParseInfo
init|=
name|localQb
operator|.
name|getParseInfo
argument_list|()
decl_stmt|;
if|if
condition|(
name|localQb
operator|.
name|getNumSelDi
argument_list|()
operator|==
literal|0
operator|&&
name|qbParseInfo
operator|.
name|getDestToClusterBy
argument_list|()
operator|.
name|isEmpty
argument_list|()
operator|&&
name|qbParseInfo
operator|.
name|getDestToDistributeBy
argument_list|()
operator|.
name|isEmpty
argument_list|()
operator|&&
name|qbParseInfo
operator|.
name|getDestToOrderBy
argument_list|()
operator|.
name|isEmpty
argument_list|()
operator|&&
name|qbParseInfo
operator|.
name|getDestToSortBy
argument_list|()
operator|.
name|isEmpty
argument_list|()
operator|&&
name|qbParseInfo
operator|.
name|getDestToAggregationExprs
argument_list|()
operator|.
name|size
argument_list|()
operator|<=
literal|1
operator|&&
name|qbParseInfo
operator|.
name|getDestToDistinctFuncExprs
argument_list|()
operator|.
name|size
argument_list|()
operator|<=
literal|1
operator|&&
name|qbParseInfo
operator|.
name|getNameToSample
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
if|if
condition|(
operator|(
name|qbParseInfo
operator|.
name|getDestToAggregationExprs
argument_list|()
operator|.
name|size
argument_list|()
operator|<
literal|1
operator|||
name|qbParseInfo
operator|.
name|getDestToAggregationExprs
argument_list|()
operator|.
name|values
argument_list|()
operator|.
name|iterator
argument_list|()
operator|.
name|next
argument_list|()
operator|.
name|isEmpty
argument_list|()
operator|)
operator|&&
operator|(
name|qbParseInfo
operator|.
name|getDestToDistinctFuncExprs
argument_list|()
operator|.
name|size
argument_list|()
operator|<
literal|1
operator|||
name|qbParseInfo
operator|.
name|getDestToDistinctFuncExprs
argument_list|()
operator|.
name|values
argument_list|()
operator|.
name|iterator
argument_list|()
operator|.
name|next
argument_list|()
operator|.
name|isEmpty
argument_list|()
operator|)
operator|&&
name|qbParseInfo
operator|.
name|getDestToLimit
argument_list|()
operator|.
name|size
argument_list|()
operator|<=
literal|1
condition|)
block|{
name|Integer
name|retValue
decl_stmt|;
if|if
condition|(
name|qbParseInfo
operator|.
name|getDestToLimit
argument_list|()
operator|.
name|size
argument_list|()
operator|==
literal|0
condition|)
block|{
name|retValue
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|retValue
operator|=
name|qbParseInfo
operator|.
name|getDestToLimit
argument_list|()
operator|.
name|values
argument_list|()
operator|.
name|iterator
argument_list|()
operator|.
name|next
argument_list|()
expr_stmt|;
block|}
for|for
control|(
name|String
name|alias
range|:
name|localQb
operator|.
name|getSubqAliases
argument_list|()
control|)
block|{
name|Integer
name|limit
init|=
name|checkQbpForGlobalLimit
argument_list|(
name|localQb
operator|.
name|getSubqForAlias
argument_list|(
name|alias
argument_list|)
operator|.
name|getQB
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|limit
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
elseif|else
if|if
condition|(
name|retValue
operator|>
literal|0
operator|&&
name|limit
operator|>
literal|0
condition|)
block|{
comment|// Any query has more than one LIMITs shown in the query is not
comment|// qualified to this optimization
return|return
literal|null
return|;
block|}
elseif|else
if|if
condition|(
name|limit
operator|>
literal|0
condition|)
block|{
name|retValue
operator|=
name|limit
expr_stmt|;
block|}
block|}
return|return
name|retValue
return|;
block|}
block|}
return|return
literal|null
return|;
block|}
block|}
end_class

end_unit

