begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed under the Apache License, Version 2.0 (the "License");  * you may not use this file except in compliance with the License.  * You may obtain a copy of the License at  *  * http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|io
operator|.
name|parquet
operator|.
name|write
package|;
end_package

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|Log
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|LogFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|common
operator|.
name|type
operator|.
name|HiveDecimal
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|io
operator|.
name|parquet
operator|.
name|serde
operator|.
name|ParquetHiveSerDe
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|io
operator|.
name|parquet
operator|.
name|timestamp
operator|.
name|NanoTimeUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|io
operator|.
name|DateWritable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|io
operator|.
name|ParquetHiveRecord
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|objectinspector
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|objectinspector
operator|.
name|primitive
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|typeinfo
operator|.
name|DecimalTypeInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|parquet
operator|.
name|io
operator|.
name|api
operator|.
name|Binary
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|parquet
operator|.
name|io
operator|.
name|api
operator|.
name|RecordConsumer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|parquet
operator|.
name|schema
operator|.
name|GroupType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|parquet
operator|.
name|schema
operator|.
name|OriginalType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|parquet
operator|.
name|schema
operator|.
name|Type
import|;
end_import

begin_import
import|import
name|java
operator|.
name|sql
operator|.
name|Date
import|;
end_import

begin_import
import|import
name|java
operator|.
name|sql
operator|.
name|Timestamp
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_comment
comment|/**  *  * DataWritableWriter is a writer that reads a ParquetWritable object and send the data to the Parquet  * API with the expected schema. This class is only used through DataWritableWriteSupport class.  */
end_comment

begin_class
specifier|public
class|class
name|DataWritableWriter
block|{
specifier|private
specifier|static
specifier|final
name|Log
name|LOG
init|=
name|LogFactory
operator|.
name|getLog
argument_list|(
name|DataWritableWriter
operator|.
name|class
argument_list|)
decl_stmt|;
specifier|private
specifier|final
name|RecordConsumer
name|recordConsumer
decl_stmt|;
specifier|private
specifier|final
name|GroupType
name|schema
decl_stmt|;
specifier|public
name|DataWritableWriter
parameter_list|(
specifier|final
name|RecordConsumer
name|recordConsumer
parameter_list|,
specifier|final
name|GroupType
name|schema
parameter_list|)
block|{
name|this
operator|.
name|recordConsumer
operator|=
name|recordConsumer
expr_stmt|;
name|this
operator|.
name|schema
operator|=
name|schema
expr_stmt|;
block|}
comment|/**    * It writes all record values to the Parquet RecordConsumer.    * @param record Contains the record that are going to be written.    */
specifier|public
name|void
name|write
parameter_list|(
specifier|final
name|ParquetHiveRecord
name|record
parameter_list|)
block|{
if|if
condition|(
name|record
operator|!=
literal|null
condition|)
block|{
name|recordConsumer
operator|.
name|startMessage
argument_list|()
expr_stmt|;
try|try
block|{
name|writeGroupFields
argument_list|(
name|record
operator|.
name|getObject
argument_list|()
argument_list|,
name|record
operator|.
name|getObjectInspector
argument_list|()
argument_list|,
name|schema
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|RuntimeException
name|e
parameter_list|)
block|{
name|String
name|errorMessage
init|=
literal|"Parquet record is malformed: "
operator|+
name|e
operator|.
name|getMessage
argument_list|()
decl_stmt|;
name|LOG
operator|.
name|error
argument_list|(
name|errorMessage
argument_list|,
name|e
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|RuntimeException
argument_list|(
name|errorMessage
argument_list|,
name|e
argument_list|)
throw|;
block|}
name|recordConsumer
operator|.
name|endMessage
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * It writes all the fields contained inside a group to the RecordConsumer.    * @param value The list of values contained in the group.    * @param inspector The object inspector used to get the correct value type.    * @param type Type that contains information about the group schema.    */
specifier|private
name|void
name|writeGroupFields
parameter_list|(
specifier|final
name|Object
name|value
parameter_list|,
specifier|final
name|StructObjectInspector
name|inspector
parameter_list|,
specifier|final
name|GroupType
name|type
parameter_list|)
block|{
if|if
condition|(
name|value
operator|!=
literal|null
condition|)
block|{
name|List
argument_list|<
name|?
extends|extends
name|StructField
argument_list|>
name|fields
init|=
name|inspector
operator|.
name|getAllStructFieldRefs
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|Object
argument_list|>
name|fieldValuesList
init|=
name|inspector
operator|.
name|getStructFieldsDataAsList
argument_list|(
name|value
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|type
operator|.
name|getFieldCount
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|Type
name|fieldType
init|=
name|type
operator|.
name|getType
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|String
name|fieldName
init|=
name|fieldType
operator|.
name|getName
argument_list|()
decl_stmt|;
name|Object
name|fieldValue
init|=
name|fieldValuesList
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|fieldValue
operator|!=
literal|null
condition|)
block|{
name|ObjectInspector
name|fieldInspector
init|=
name|fields
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|getFieldObjectInspector
argument_list|()
decl_stmt|;
name|recordConsumer
operator|.
name|startField
argument_list|(
name|fieldName
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|writeValue
argument_list|(
name|fieldValue
argument_list|,
name|fieldInspector
argument_list|,
name|fieldType
argument_list|)
expr_stmt|;
name|recordConsumer
operator|.
name|endField
argument_list|(
name|fieldName
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/**    * It writes the field value to the Parquet RecordConsumer. It detects the field type, and calls    * the correct write function.    * @param value The writable object that contains the value.    * @param inspector The object inspector used to get the correct value type.    * @param type Type that contains information about the type schema.    */
specifier|private
name|void
name|writeValue
parameter_list|(
specifier|final
name|Object
name|value
parameter_list|,
specifier|final
name|ObjectInspector
name|inspector
parameter_list|,
specifier|final
name|Type
name|type
parameter_list|)
block|{
if|if
condition|(
name|type
operator|.
name|isPrimitive
argument_list|()
condition|)
block|{
name|checkInspectorCategory
argument_list|(
name|inspector
argument_list|,
name|ObjectInspector
operator|.
name|Category
operator|.
name|PRIMITIVE
argument_list|)
expr_stmt|;
name|writePrimitive
argument_list|(
name|value
argument_list|,
operator|(
name|PrimitiveObjectInspector
operator|)
name|inspector
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|GroupType
name|groupType
init|=
name|type
operator|.
name|asGroupType
argument_list|()
decl_stmt|;
name|OriginalType
name|originalType
init|=
name|type
operator|.
name|getOriginalType
argument_list|()
decl_stmt|;
if|if
condition|(
name|originalType
operator|!=
literal|null
operator|&&
name|originalType
operator|.
name|equals
argument_list|(
name|OriginalType
operator|.
name|LIST
argument_list|)
condition|)
block|{
name|checkInspectorCategory
argument_list|(
name|inspector
argument_list|,
name|ObjectInspector
operator|.
name|Category
operator|.
name|LIST
argument_list|)
expr_stmt|;
name|writeArray
argument_list|(
name|value
argument_list|,
operator|(
name|ListObjectInspector
operator|)
name|inspector
argument_list|,
name|groupType
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|originalType
operator|!=
literal|null
operator|&&
name|originalType
operator|.
name|equals
argument_list|(
name|OriginalType
operator|.
name|MAP
argument_list|)
condition|)
block|{
name|checkInspectorCategory
argument_list|(
name|inspector
argument_list|,
name|ObjectInspector
operator|.
name|Category
operator|.
name|MAP
argument_list|)
expr_stmt|;
name|writeMap
argument_list|(
name|value
argument_list|,
operator|(
name|MapObjectInspector
operator|)
name|inspector
argument_list|,
name|groupType
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|checkInspectorCategory
argument_list|(
name|inspector
argument_list|,
name|ObjectInspector
operator|.
name|Category
operator|.
name|STRUCT
argument_list|)
expr_stmt|;
name|writeGroup
argument_list|(
name|value
argument_list|,
operator|(
name|StructObjectInspector
operator|)
name|inspector
argument_list|,
name|groupType
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**    * Checks that an inspector matches the category indicated as a parameter.    * @param inspector The object inspector to check    * @param category The category to match    * @throws IllegalArgumentException if inspector does not match the category    */
specifier|private
name|void
name|checkInspectorCategory
parameter_list|(
name|ObjectInspector
name|inspector
parameter_list|,
name|ObjectInspector
operator|.
name|Category
name|category
parameter_list|)
block|{
if|if
condition|(
operator|!
name|inspector
operator|.
name|getCategory
argument_list|()
operator|.
name|equals
argument_list|(
name|category
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Invalid data type: expected "
operator|+
name|category
operator|+
literal|" type, but found: "
operator|+
name|inspector
operator|.
name|getCategory
argument_list|()
argument_list|)
throw|;
block|}
block|}
comment|/**    * It writes a group type and all its values to the Parquet RecordConsumer.    * This is used only for optional and required groups.    * @param value Object that contains the group values.    * @param inspector The object inspector used to get the correct value type.    * @param type Type that contains information about the group schema.    */
specifier|private
name|void
name|writeGroup
parameter_list|(
specifier|final
name|Object
name|value
parameter_list|,
specifier|final
name|StructObjectInspector
name|inspector
parameter_list|,
specifier|final
name|GroupType
name|type
parameter_list|)
block|{
name|recordConsumer
operator|.
name|startGroup
argument_list|()
expr_stmt|;
name|writeGroupFields
argument_list|(
name|value
argument_list|,
name|inspector
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|recordConsumer
operator|.
name|endGroup
argument_list|()
expr_stmt|;
block|}
comment|/**    * It writes a list type and its array elements to the Parquet RecordConsumer.    * This is called when the original type (LIST) is detected by writeValue()/    * This function assumes the following schema:    *    optional group arrayCol (LIST) {    *      repeated group array {    *        optional TYPE array_element;    *      }    *    }    * @param value The object that contains the array values.    * @param inspector The object inspector used to get the correct value type.    * @param type Type that contains information about the group (LIST) schema.    */
specifier|private
name|void
name|writeArray
parameter_list|(
specifier|final
name|Object
name|value
parameter_list|,
specifier|final
name|ListObjectInspector
name|inspector
parameter_list|,
specifier|final
name|GroupType
name|type
parameter_list|)
block|{
comment|// Get the internal array structure
name|GroupType
name|repeatedType
init|=
name|type
operator|.
name|getType
argument_list|(
literal|0
argument_list|)
operator|.
name|asGroupType
argument_list|()
decl_stmt|;
name|recordConsumer
operator|.
name|startGroup
argument_list|()
expr_stmt|;
name|recordConsumer
operator|.
name|startField
argument_list|(
name|repeatedType
operator|.
name|getName
argument_list|()
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|?
argument_list|>
name|arrayValues
init|=
name|inspector
operator|.
name|getList
argument_list|(
name|value
argument_list|)
decl_stmt|;
name|ObjectInspector
name|elementInspector
init|=
name|inspector
operator|.
name|getListElementObjectInspector
argument_list|()
decl_stmt|;
name|Type
name|elementType
init|=
name|repeatedType
operator|.
name|getType
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|String
name|elementName
init|=
name|elementType
operator|.
name|getName
argument_list|()
decl_stmt|;
for|for
control|(
name|Object
name|element
range|:
name|arrayValues
control|)
block|{
name|recordConsumer
operator|.
name|startGroup
argument_list|()
expr_stmt|;
if|if
condition|(
name|element
operator|!=
literal|null
condition|)
block|{
name|recordConsumer
operator|.
name|startField
argument_list|(
name|elementName
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|writeValue
argument_list|(
name|element
argument_list|,
name|elementInspector
argument_list|,
name|elementType
argument_list|)
expr_stmt|;
name|recordConsumer
operator|.
name|endField
argument_list|(
name|elementName
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|recordConsumer
operator|.
name|endGroup
argument_list|()
expr_stmt|;
block|}
name|recordConsumer
operator|.
name|endField
argument_list|(
name|repeatedType
operator|.
name|getName
argument_list|()
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|recordConsumer
operator|.
name|endGroup
argument_list|()
expr_stmt|;
block|}
comment|/**    * It writes a map type and its key-pair values to the Parquet RecordConsumer.    * This is called when the original type (MAP) is detected by writeValue().    * This function assumes the following schema:    *    optional group mapCol (MAP) {    *      repeated group map (MAP_KEY_VALUE) {    *        required TYPE key;    *        optional TYPE value;    *      }    *    }    * @param value The object that contains the map key-values.    * @param inspector The object inspector used to get the correct value type.    * @param type Type that contains information about the group (MAP) schema.    */
specifier|private
name|void
name|writeMap
parameter_list|(
specifier|final
name|Object
name|value
parameter_list|,
specifier|final
name|MapObjectInspector
name|inspector
parameter_list|,
specifier|final
name|GroupType
name|type
parameter_list|)
block|{
comment|// Get the internal map structure (MAP_KEY_VALUE)
name|GroupType
name|repeatedType
init|=
name|type
operator|.
name|getType
argument_list|(
literal|0
argument_list|)
operator|.
name|asGroupType
argument_list|()
decl_stmt|;
name|recordConsumer
operator|.
name|startGroup
argument_list|()
expr_stmt|;
name|recordConsumer
operator|.
name|startField
argument_list|(
name|repeatedType
operator|.
name|getName
argument_list|()
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|Map
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
name|mapValues
init|=
name|inspector
operator|.
name|getMap
argument_list|(
name|value
argument_list|)
decl_stmt|;
name|Type
name|keyType
init|=
name|repeatedType
operator|.
name|getType
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|String
name|keyName
init|=
name|keyType
operator|.
name|getName
argument_list|()
decl_stmt|;
name|ObjectInspector
name|keyInspector
init|=
name|inspector
operator|.
name|getMapKeyObjectInspector
argument_list|()
decl_stmt|;
name|Type
name|valuetype
init|=
name|repeatedType
operator|.
name|getType
argument_list|(
literal|1
argument_list|)
decl_stmt|;
name|String
name|valueName
init|=
name|valuetype
operator|.
name|getName
argument_list|()
decl_stmt|;
name|ObjectInspector
name|valueInspector
init|=
name|inspector
operator|.
name|getMapValueObjectInspector
argument_list|()
decl_stmt|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
name|keyValue
range|:
name|mapValues
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|recordConsumer
operator|.
name|startGroup
argument_list|()
expr_stmt|;
if|if
condition|(
name|keyValue
operator|!=
literal|null
condition|)
block|{
comment|// write key element
name|Object
name|keyElement
init|=
name|keyValue
operator|.
name|getKey
argument_list|()
decl_stmt|;
name|recordConsumer
operator|.
name|startField
argument_list|(
name|keyName
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|writeValue
argument_list|(
name|keyElement
argument_list|,
name|keyInspector
argument_list|,
name|keyType
argument_list|)
expr_stmt|;
name|recordConsumer
operator|.
name|endField
argument_list|(
name|keyName
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|// write value element
name|Object
name|valueElement
init|=
name|keyValue
operator|.
name|getValue
argument_list|()
decl_stmt|;
if|if
condition|(
name|valueElement
operator|!=
literal|null
condition|)
block|{
name|recordConsumer
operator|.
name|startField
argument_list|(
name|valueName
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|writeValue
argument_list|(
name|valueElement
argument_list|,
name|valueInspector
argument_list|,
name|valuetype
argument_list|)
expr_stmt|;
name|recordConsumer
operator|.
name|endField
argument_list|(
name|valueName
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
name|recordConsumer
operator|.
name|endGroup
argument_list|()
expr_stmt|;
block|}
name|recordConsumer
operator|.
name|endField
argument_list|(
name|repeatedType
operator|.
name|getName
argument_list|()
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|recordConsumer
operator|.
name|endGroup
argument_list|()
expr_stmt|;
block|}
comment|/**    * It writes the primitive value to the Parquet RecordConsumer.    * @param value The object that contains the primitive value.    * @param inspector The object inspector used to get the correct value type.    */
specifier|private
name|void
name|writePrimitive
parameter_list|(
specifier|final
name|Object
name|value
parameter_list|,
specifier|final
name|PrimitiveObjectInspector
name|inspector
parameter_list|)
block|{
if|if
condition|(
name|value
operator|==
literal|null
condition|)
block|{
return|return;
block|}
switch|switch
condition|(
name|inspector
operator|.
name|getPrimitiveCategory
argument_list|()
condition|)
block|{
case|case
name|VOID
case|:
return|return;
case|case
name|DOUBLE
case|:
name|recordConsumer
operator|.
name|addDouble
argument_list|(
operator|(
operator|(
name|DoubleObjectInspector
operator|)
name|inspector
operator|)
operator|.
name|get
argument_list|(
name|value
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|BOOLEAN
case|:
name|recordConsumer
operator|.
name|addBoolean
argument_list|(
operator|(
operator|(
name|BooleanObjectInspector
operator|)
name|inspector
operator|)
operator|.
name|get
argument_list|(
name|value
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|FLOAT
case|:
name|recordConsumer
operator|.
name|addFloat
argument_list|(
operator|(
operator|(
name|FloatObjectInspector
operator|)
name|inspector
operator|)
operator|.
name|get
argument_list|(
name|value
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|BYTE
case|:
name|recordConsumer
operator|.
name|addInteger
argument_list|(
operator|(
operator|(
name|ByteObjectInspector
operator|)
name|inspector
operator|)
operator|.
name|get
argument_list|(
name|value
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|INT
case|:
name|recordConsumer
operator|.
name|addInteger
argument_list|(
operator|(
operator|(
name|IntObjectInspector
operator|)
name|inspector
operator|)
operator|.
name|get
argument_list|(
name|value
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|LONG
case|:
name|recordConsumer
operator|.
name|addLong
argument_list|(
operator|(
operator|(
name|LongObjectInspector
operator|)
name|inspector
operator|)
operator|.
name|get
argument_list|(
name|value
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|SHORT
case|:
name|recordConsumer
operator|.
name|addInteger
argument_list|(
operator|(
operator|(
name|ShortObjectInspector
operator|)
name|inspector
operator|)
operator|.
name|get
argument_list|(
name|value
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|STRING
case|:
name|String
name|v
init|=
operator|(
operator|(
name|StringObjectInspector
operator|)
name|inspector
operator|)
operator|.
name|getPrimitiveJavaObject
argument_list|(
name|value
argument_list|)
decl_stmt|;
name|recordConsumer
operator|.
name|addBinary
argument_list|(
name|Binary
operator|.
name|fromString
argument_list|(
name|v
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|CHAR
case|:
name|String
name|vChar
init|=
operator|(
operator|(
name|HiveCharObjectInspector
operator|)
name|inspector
operator|)
operator|.
name|getPrimitiveJavaObject
argument_list|(
name|value
argument_list|)
operator|.
name|getStrippedValue
argument_list|()
decl_stmt|;
name|recordConsumer
operator|.
name|addBinary
argument_list|(
name|Binary
operator|.
name|fromString
argument_list|(
name|vChar
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|VARCHAR
case|:
name|String
name|vVarchar
init|=
operator|(
operator|(
name|HiveVarcharObjectInspector
operator|)
name|inspector
operator|)
operator|.
name|getPrimitiveJavaObject
argument_list|(
name|value
argument_list|)
operator|.
name|getValue
argument_list|()
decl_stmt|;
name|recordConsumer
operator|.
name|addBinary
argument_list|(
name|Binary
operator|.
name|fromString
argument_list|(
name|vVarchar
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|BINARY
case|:
name|byte
index|[]
name|vBinary
init|=
operator|(
operator|(
name|BinaryObjectInspector
operator|)
name|inspector
operator|)
operator|.
name|getPrimitiveJavaObject
argument_list|(
name|value
argument_list|)
decl_stmt|;
name|recordConsumer
operator|.
name|addBinary
argument_list|(
name|Binary
operator|.
name|fromByteArray
argument_list|(
name|vBinary
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|TIMESTAMP
case|:
name|Timestamp
name|ts
init|=
operator|(
operator|(
name|TimestampObjectInspector
operator|)
name|inspector
operator|)
operator|.
name|getPrimitiveJavaObject
argument_list|(
name|value
argument_list|)
decl_stmt|;
name|recordConsumer
operator|.
name|addBinary
argument_list|(
name|NanoTimeUtils
operator|.
name|getNanoTime
argument_list|(
name|ts
argument_list|,
literal|false
argument_list|)
operator|.
name|toBinary
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|DECIMAL
case|:
name|HiveDecimal
name|vDecimal
init|=
operator|(
operator|(
name|HiveDecimal
operator|)
name|inspector
operator|.
name|getPrimitiveJavaObject
argument_list|(
name|value
argument_list|)
operator|)
decl_stmt|;
name|DecimalTypeInfo
name|decTypeInfo
init|=
operator|(
name|DecimalTypeInfo
operator|)
name|inspector
operator|.
name|getTypeInfo
argument_list|()
decl_stmt|;
name|recordConsumer
operator|.
name|addBinary
argument_list|(
name|decimalToBinary
argument_list|(
name|vDecimal
argument_list|,
name|decTypeInfo
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|DATE
case|:
name|Date
name|vDate
init|=
operator|(
operator|(
name|DateObjectInspector
operator|)
name|inspector
operator|)
operator|.
name|getPrimitiveJavaObject
argument_list|(
name|value
argument_list|)
decl_stmt|;
name|recordConsumer
operator|.
name|addInteger
argument_list|(
name|DateWritable
operator|.
name|dateToDays
argument_list|(
name|vDate
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Unsupported primitive data type: "
operator|+
name|inspector
operator|.
name|getPrimitiveCategory
argument_list|()
argument_list|)
throw|;
block|}
block|}
specifier|private
name|Binary
name|decimalToBinary
parameter_list|(
specifier|final
name|HiveDecimal
name|hiveDecimal
parameter_list|,
specifier|final
name|DecimalTypeInfo
name|decimalTypeInfo
parameter_list|)
block|{
name|int
name|prec
init|=
name|decimalTypeInfo
operator|.
name|precision
argument_list|()
decl_stmt|;
name|int
name|scale
init|=
name|decimalTypeInfo
operator|.
name|scale
argument_list|()
decl_stmt|;
name|byte
index|[]
name|decimalBytes
init|=
name|hiveDecimal
operator|.
name|setScale
argument_list|(
name|scale
argument_list|)
operator|.
name|unscaledValue
argument_list|()
operator|.
name|toByteArray
argument_list|()
decl_stmt|;
comment|// Estimated number of bytes needed.
name|int
name|precToBytes
init|=
name|ParquetHiveSerDe
operator|.
name|PRECISION_TO_BYTE_COUNT
index|[
name|prec
operator|-
literal|1
index|]
decl_stmt|;
if|if
condition|(
name|precToBytes
operator|==
name|decimalBytes
operator|.
name|length
condition|)
block|{
comment|// No padding needed.
return|return
name|Binary
operator|.
name|fromByteArray
argument_list|(
name|decimalBytes
argument_list|)
return|;
block|}
name|byte
index|[]
name|tgt
init|=
operator|new
name|byte
index|[
name|precToBytes
index|]
decl_stmt|;
if|if
condition|(
name|hiveDecimal
operator|.
name|signum
argument_list|()
operator|==
operator|-
literal|1
condition|)
block|{
comment|// For negative number, initializing bits to 1
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|precToBytes
condition|;
name|i
operator|++
control|)
block|{
name|tgt
index|[
name|i
index|]
operator||=
literal|0xFF
expr_stmt|;
block|}
block|}
name|System
operator|.
name|arraycopy
argument_list|(
name|decimalBytes
argument_list|,
literal|0
argument_list|,
name|tgt
argument_list|,
name|precToBytes
operator|-
name|decimalBytes
operator|.
name|length
argument_list|,
name|decimalBytes
operator|.
name|length
argument_list|)
expr_stmt|;
comment|// Padding leading zeroes/ones.
return|return
name|Binary
operator|.
name|fromByteArray
argument_list|(
name|tgt
argument_list|)
return|;
block|}
block|}
end_class

end_unit

