begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|ppd
package|;
end_package

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
operator|.
name|Entry
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Stack
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|Log
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|LogFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|conf
operator|.
name|HiveConf
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|ColumnInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|FilterOperator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|JoinOperator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|Operator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|OperatorFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|RowSchema
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|TableScanOperator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|Utilities
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|lib
operator|.
name|Node
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|lib
operator|.
name|NodeProcessor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|lib
operator|.
name|NodeProcessorCtx
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|metadata
operator|.
name|HiveStorageHandler
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|metadata
operator|.
name|HiveStoragePredicateHandler
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|metadata
operator|.
name|Table
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|parse
operator|.
name|ASTNode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|parse
operator|.
name|BaseSemanticAnalyzer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|parse
operator|.
name|HiveParser
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|parse
operator|.
name|OpParseContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|parse
operator|.
name|RowResolver
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|parse
operator|.
name|SemanticException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|ExprNodeColumnDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|ExprNodeDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|ExprNodeDescUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|FilterDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|JoinCondDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|JoinDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|OperatorDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|TableScanDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|Deserializer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapred
operator|.
name|JobConf
import|;
end_import

begin_comment
comment|/**  * Operator factory for predicate pushdown processing of operator graph Each  * operator determines the pushdown predicates by walking the expression tree.  * Each operator merges its own pushdown predicates with those of its children  * Finally the TableScan operator gathers all the predicates and inserts a  * filter operator after itself. TODO: Further optimizations 1) Multi-insert  * case 2) Create a filter operator for those predicates that couldn't be pushed  * to the previous operators in the data flow 3) Merge multiple sequential  * filter predicates into so that plans are more readable 4) Remove predicates  * from filter operators that have been pushed. Currently these pushed  * predicates are evaluated twice.  */
end_comment

begin_class
specifier|public
specifier|final
class|class
name|OpProcFactory
block|{
specifier|protected
specifier|static
specifier|final
name|Log
name|LOG
init|=
name|LogFactory
operator|.
name|getLog
argument_list|(
name|OpProcFactory
operator|.
name|class
operator|.
name|getName
argument_list|()
argument_list|)
decl_stmt|;
comment|/**    * Processor for Script Operator Prevents any predicates being pushed.    */
specifier|public
specifier|static
class|class
name|ScriptPPD
extends|extends
name|DefaultPPD
implements|implements
name|NodeProcessor
block|{
annotation|@
name|Override
specifier|public
name|Object
name|process
parameter_list|(
name|Node
name|nd
parameter_list|,
name|Stack
argument_list|<
name|Node
argument_list|>
name|stack
parameter_list|,
name|NodeProcessorCtx
name|procCtx
parameter_list|,
name|Object
modifier|...
name|nodeOutputs
parameter_list|)
throws|throws
name|SemanticException
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Processing for "
operator|+
name|nd
operator|.
name|getName
argument_list|()
operator|+
literal|"("
operator|+
operator|(
operator|(
name|Operator
operator|)
name|nd
operator|)
operator|.
name|getIdentifier
argument_list|()
operator|+
literal|")"
argument_list|)
expr_stmt|;
comment|// script operator is a black-box to hive so no optimization here
comment|// assuming that nothing can be pushed above the script op
comment|// same with LIMIT op
comment|// create a filter with all children predicates
name|OpWalkerInfo
name|owi
init|=
operator|(
name|OpWalkerInfo
operator|)
name|procCtx
decl_stmt|;
if|if
condition|(
name|HiveConf
operator|.
name|getBoolVar
argument_list|(
name|owi
operator|.
name|getParseContext
argument_list|()
operator|.
name|getConf
argument_list|()
argument_list|,
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVEPPDREMOVEDUPLICATEFILTERS
argument_list|)
condition|)
block|{
name|ExprWalkerInfo
name|unpushedPreds
init|=
name|mergeChildrenPred
argument_list|(
name|nd
argument_list|,
name|owi
argument_list|,
literal|null
argument_list|,
literal|false
argument_list|)
decl_stmt|;
return|return
name|createFilter
argument_list|(
operator|(
name|Operator
operator|)
name|nd
argument_list|,
name|unpushedPreds
argument_list|,
name|owi
argument_list|)
return|;
block|}
return|return
literal|null
return|;
block|}
block|}
specifier|public
specifier|static
class|class
name|UDTFPPD
extends|extends
name|DefaultPPD
implements|implements
name|NodeProcessor
block|{
annotation|@
name|Override
specifier|public
name|Object
name|process
parameter_list|(
name|Node
name|nd
parameter_list|,
name|Stack
argument_list|<
name|Node
argument_list|>
name|stack
parameter_list|,
name|NodeProcessorCtx
name|procCtx
parameter_list|,
name|Object
modifier|...
name|nodeOutputs
parameter_list|)
throws|throws
name|SemanticException
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Processing for "
operator|+
name|nd
operator|.
name|getName
argument_list|()
operator|+
literal|"("
operator|+
operator|(
operator|(
name|Operator
operator|)
name|nd
operator|)
operator|.
name|getIdentifier
argument_list|()
operator|+
literal|")"
argument_list|)
expr_stmt|;
comment|//Predicates for UDTF wont be candidates for its children. So, nothing to
comment|//optimize here. See lateral_view_ppd.q for example.
return|return
literal|null
return|;
block|}
block|}
specifier|public
specifier|static
class|class
name|LateralViewForwardPPD
extends|extends
name|DefaultPPD
implements|implements
name|NodeProcessor
block|{
annotation|@
name|Override
specifier|public
name|Object
name|process
parameter_list|(
name|Node
name|nd
parameter_list|,
name|Stack
argument_list|<
name|Node
argument_list|>
name|stack
parameter_list|,
name|NodeProcessorCtx
name|procCtx
parameter_list|,
name|Object
modifier|...
name|nodeOutputs
parameter_list|)
throws|throws
name|SemanticException
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Processing for "
operator|+
name|nd
operator|.
name|getName
argument_list|()
operator|+
literal|"("
operator|+
operator|(
operator|(
name|Operator
operator|)
name|nd
operator|)
operator|.
name|getIdentifier
argument_list|()
operator|+
literal|")"
argument_list|)
expr_stmt|;
name|OpWalkerInfo
name|owi
init|=
operator|(
name|OpWalkerInfo
operator|)
name|procCtx
decl_stmt|;
comment|// The lateral view forward operator has 2 children, a SELECT(*) and
comment|// a SELECT(cols) (for the UDTF operator) The child at index 0 is the
comment|// SELECT(*) because that's the way that the DAG was constructed. We
comment|// only want to get the predicates from the SELECT(*).
name|ExprWalkerInfo
name|childPreds
init|=
name|owi
operator|.
name|getPrunedPreds
argument_list|(
operator|(
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
operator|)
name|nd
operator|.
name|getChildren
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|owi
operator|.
name|putPrunedPreds
argument_list|(
operator|(
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
operator|)
name|nd
argument_list|,
name|childPreds
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
block|}
comment|/**    * Combines predicates of its child into a single expression and adds a filter    * op as new child.    */
specifier|public
specifier|static
class|class
name|TableScanPPD
extends|extends
name|DefaultPPD
implements|implements
name|NodeProcessor
block|{
annotation|@
name|Override
specifier|public
name|Object
name|process
parameter_list|(
name|Node
name|nd
parameter_list|,
name|Stack
argument_list|<
name|Node
argument_list|>
name|stack
parameter_list|,
name|NodeProcessorCtx
name|procCtx
parameter_list|,
name|Object
modifier|...
name|nodeOutputs
parameter_list|)
throws|throws
name|SemanticException
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Processing for "
operator|+
name|nd
operator|.
name|getName
argument_list|()
operator|+
literal|"("
operator|+
operator|(
operator|(
name|Operator
operator|)
name|nd
operator|)
operator|.
name|getIdentifier
argument_list|()
operator|+
literal|")"
argument_list|)
expr_stmt|;
name|OpWalkerInfo
name|owi
init|=
operator|(
name|OpWalkerInfo
operator|)
name|procCtx
decl_stmt|;
name|TableScanOperator
name|tsOp
init|=
operator|(
name|TableScanOperator
operator|)
name|nd
decl_stmt|;
name|mergeWithChildrenPred
argument_list|(
name|tsOp
argument_list|,
name|owi
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|ExprWalkerInfo
name|pushDownPreds
init|=
name|owi
operator|.
name|getPrunedPreds
argument_list|(
name|tsOp
argument_list|)
decl_stmt|;
return|return
name|createFilter
argument_list|(
name|tsOp
argument_list|,
name|pushDownPreds
argument_list|,
name|owi
argument_list|)
return|;
block|}
block|}
comment|/**    * Determines the push down predicates in its where expression and then    * combines it with the push down predicates that are passed from its children.    */
specifier|public
specifier|static
class|class
name|FilterPPD
extends|extends
name|DefaultPPD
implements|implements
name|NodeProcessor
block|{
annotation|@
name|Override
specifier|public
name|Object
name|process
parameter_list|(
name|Node
name|nd
parameter_list|,
name|Stack
argument_list|<
name|Node
argument_list|>
name|stack
parameter_list|,
name|NodeProcessorCtx
name|procCtx
parameter_list|,
name|Object
modifier|...
name|nodeOutputs
parameter_list|)
throws|throws
name|SemanticException
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Processing for "
operator|+
name|nd
operator|.
name|getName
argument_list|()
operator|+
literal|"("
operator|+
operator|(
operator|(
name|Operator
operator|)
name|nd
operator|)
operator|.
name|getIdentifier
argument_list|()
operator|+
literal|")"
argument_list|)
expr_stmt|;
name|OpWalkerInfo
name|owi
init|=
operator|(
name|OpWalkerInfo
operator|)
name|procCtx
decl_stmt|;
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
name|op
init|=
operator|(
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
operator|)
name|nd
decl_stmt|;
name|ExprNodeDesc
name|predicate
init|=
operator|(
operator|(
operator|(
name|FilterOperator
operator|)
name|nd
operator|)
operator|.
name|getConf
argument_list|()
operator|)
operator|.
name|getPredicate
argument_list|()
decl_stmt|;
name|ExprWalkerInfo
name|ewi
init|=
operator|new
name|ExprWalkerInfo
argument_list|()
decl_stmt|;
comment|// Don't push a sampling predicate since createFilter() always creates filter
comment|// with isSamplePred = false. Also, the filterop with sampling pred is always
comment|// a child of TableScan, so there is no need to push this predicate.
if|if
condition|(
operator|!
operator|(
operator|(
name|FilterOperator
operator|)
name|op
operator|)
operator|.
name|getConf
argument_list|()
operator|.
name|getIsSamplingPred
argument_list|()
condition|)
block|{
comment|// get pushdown predicates for this operator's predicate
name|ewi
operator|=
name|ExprWalkerProcFactory
operator|.
name|extractPushdownPreds
argument_list|(
name|owi
argument_list|,
name|op
argument_list|,
name|predicate
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ewi
operator|.
name|isDeterministic
argument_list|()
condition|)
block|{
comment|/* predicate is not deterministic */
if|if
condition|(
name|op
operator|.
name|getChildren
argument_list|()
operator|!=
literal|null
operator|&&
name|op
operator|.
name|getChildren
argument_list|()
operator|.
name|size
argument_list|()
operator|==
literal|1
condition|)
block|{
name|createFilter
argument_list|(
name|op
argument_list|,
name|owi
operator|.
name|getPrunedPreds
argument_list|(
call|(
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
call|)
argument_list|(
name|op
operator|.
name|getChildren
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|owi
argument_list|)
expr_stmt|;
block|}
return|return
literal|null
return|;
block|}
if|if
condition|(
name|HiveConf
operator|.
name|getBoolVar
argument_list|(
name|owi
operator|.
name|getParseContext
argument_list|()
operator|.
name|getConf
argument_list|()
argument_list|,
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVEPPDREMOVEDUPLICATEFILTERS
argument_list|)
condition|)
block|{
comment|// add this filter for deletion, if it does not have non-final candidates
if|if
condition|(
name|ewi
operator|.
name|getNonFinalCandidates
argument_list|()
operator|.
name|values
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|owi
operator|.
name|addCandidateFilterOp
argument_list|(
operator|(
name|FilterOperator
operator|)
name|op
argument_list|)
expr_stmt|;
block|}
block|}
name|logExpr
argument_list|(
name|nd
argument_list|,
name|ewi
argument_list|)
expr_stmt|;
name|owi
operator|.
name|putPrunedPreds
argument_list|(
operator|(
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
operator|)
name|nd
argument_list|,
name|ewi
argument_list|)
expr_stmt|;
block|}
comment|// merge it with children predicates
name|boolean
name|hasUnpushedPredicates
init|=
name|mergeWithChildrenPred
argument_list|(
name|nd
argument_list|,
name|owi
argument_list|,
name|ewi
argument_list|,
literal|null
argument_list|,
literal|false
argument_list|)
decl_stmt|;
if|if
condition|(
name|HiveConf
operator|.
name|getBoolVar
argument_list|(
name|owi
operator|.
name|getParseContext
argument_list|()
operator|.
name|getConf
argument_list|()
argument_list|,
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVEPPDREMOVEDUPLICATEFILTERS
argument_list|)
condition|)
block|{
if|if
condition|(
name|hasUnpushedPredicates
condition|)
block|{
name|ExprWalkerInfo
name|unpushedPreds
init|=
name|mergeChildrenPred
argument_list|(
name|nd
argument_list|,
name|owi
argument_list|,
literal|null
argument_list|,
literal|false
argument_list|)
decl_stmt|;
return|return
name|createFilter
argument_list|(
operator|(
name|Operator
operator|)
name|nd
argument_list|,
name|unpushedPreds
argument_list|,
name|owi
argument_list|)
return|;
block|}
block|}
return|return
literal|null
return|;
block|}
block|}
comment|/**    * Determines predicates for which alias can be pushed to it's parents. See    * the comments for getQualifiedAliases function.    */
specifier|public
specifier|static
class|class
name|JoinPPD
extends|extends
name|DefaultPPD
implements|implements
name|NodeProcessor
block|{
annotation|@
name|Override
specifier|public
name|Object
name|process
parameter_list|(
name|Node
name|nd
parameter_list|,
name|Stack
argument_list|<
name|Node
argument_list|>
name|stack
parameter_list|,
name|NodeProcessorCtx
name|procCtx
parameter_list|,
name|Object
modifier|...
name|nodeOutputs
parameter_list|)
throws|throws
name|SemanticException
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Processing for "
operator|+
name|nd
operator|.
name|getName
argument_list|()
operator|+
literal|"("
operator|+
operator|(
operator|(
name|Operator
operator|)
name|nd
operator|)
operator|.
name|getIdentifier
argument_list|()
operator|+
literal|")"
argument_list|)
expr_stmt|;
name|OpWalkerInfo
name|owi
init|=
operator|(
name|OpWalkerInfo
operator|)
name|procCtx
decl_stmt|;
name|Set
argument_list|<
name|String
argument_list|>
name|aliases
init|=
name|getQualifiedAliases
argument_list|(
operator|(
name|JoinOperator
operator|)
name|nd
argument_list|,
name|owi
operator|.
name|getRowResolver
argument_list|(
name|nd
argument_list|)
argument_list|)
decl_stmt|;
comment|// we pass null for aliases here because mergeWithChildrenPred filters
comment|// aliases in the children node context and we need to filter them in
comment|// the current JoinOperator's context
name|boolean
name|hasUnpushedPredicates
init|=
name|mergeWithChildrenPred
argument_list|(
name|nd
argument_list|,
name|owi
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
literal|false
argument_list|)
decl_stmt|;
name|ExprWalkerInfo
name|prunePreds
init|=
name|owi
operator|.
name|getPrunedPreds
argument_list|(
operator|(
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
operator|)
name|nd
argument_list|)
decl_stmt|;
if|if
condition|(
name|prunePreds
operator|!=
literal|null
condition|)
block|{
name|Set
argument_list|<
name|String
argument_list|>
name|toRemove
init|=
operator|new
name|HashSet
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
comment|// we don't push down any expressions that refer to aliases that can;t
comment|// be pushed down per getQualifiedAliases
for|for
control|(
name|String
name|key
range|:
name|prunePreds
operator|.
name|getFinalCandidates
argument_list|()
operator|.
name|keySet
argument_list|()
control|)
block|{
if|if
condition|(
operator|!
name|aliases
operator|.
name|contains
argument_list|(
name|key
argument_list|)
condition|)
block|{
name|toRemove
operator|.
name|add
argument_list|(
name|key
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
name|String
name|alias
range|:
name|toRemove
control|)
block|{
for|for
control|(
name|ExprNodeDesc
name|expr
range|:
name|prunePreds
operator|.
name|getFinalCandidates
argument_list|()
operator|.
name|get
argument_list|(
name|alias
argument_list|)
control|)
block|{
comment|// add expr to the list of predicates rejected from further pushing
comment|// so that we know to add it in createFilter()
name|prunePreds
operator|.
name|addAlias
argument_list|(
name|expr
argument_list|,
name|alias
argument_list|)
expr_stmt|;
name|prunePreds
operator|.
name|addNonFinalCandidate
argument_list|(
name|expr
argument_list|)
expr_stmt|;
block|}
name|prunePreds
operator|.
name|getFinalCandidates
argument_list|()
operator|.
name|remove
argument_list|(
name|alias
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|HiveConf
operator|.
name|getBoolVar
argument_list|(
name|owi
operator|.
name|getParseContext
argument_list|()
operator|.
name|getConf
argument_list|()
argument_list|,
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVEPPDRECOGNIZETRANSITIVITY
argument_list|)
condition|)
block|{
name|applyFilterTransitivity
argument_list|(
operator|(
name|JoinOperator
operator|)
name|nd
argument_list|,
name|owi
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|HiveConf
operator|.
name|getBoolVar
argument_list|(
name|owi
operator|.
name|getParseContext
argument_list|()
operator|.
name|getConf
argument_list|()
argument_list|,
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVEPPDREMOVEDUPLICATEFILTERS
argument_list|)
condition|)
block|{
comment|// Here, we add all the "non-final candidiates", ie. the predicates
comment|// rejected from pushdown through this operator to unpushedPreds
comment|// and pass it to createFilter
name|ExprWalkerInfo
name|unpushedPreds
init|=
operator|new
name|ExprWalkerInfo
argument_list|()
decl_stmt|;
for|for
control|(
name|Entry
argument_list|<
name|String
argument_list|,
name|List
argument_list|<
name|ExprNodeDesc
argument_list|>
argument_list|>
name|entry
range|:
name|prunePreds
operator|.
name|getNonFinalCandidates
argument_list|()
operator|.
name|entrySet
argument_list|()
control|)
block|{
for|for
control|(
name|ExprNodeDesc
name|expr
range|:
name|entry
operator|.
name|getValue
argument_list|()
control|)
block|{
assert|assert
name|prunePreds
operator|.
name|getNewToOldExprMap
argument_list|()
operator|.
name|containsKey
argument_list|(
name|expr
argument_list|)
assert|;
name|ExprNodeDesc
name|oldExpr
init|=
name|prunePreds
operator|.
name|getNewToOldExprMap
argument_list|()
operator|.
name|get
argument_list|(
name|expr
argument_list|)
decl_stmt|;
name|unpushedPreds
operator|.
name|addAlias
argument_list|(
name|oldExpr
argument_list|,
name|entry
operator|.
name|getKey
argument_list|()
argument_list|)
expr_stmt|;
name|unpushedPreds
operator|.
name|addFinalCandidate
argument_list|(
name|oldExpr
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|createFilter
argument_list|(
operator|(
name|Operator
operator|)
name|nd
argument_list|,
name|unpushedPreds
argument_list|,
name|owi
argument_list|)
return|;
block|}
block|}
return|return
literal|null
return|;
block|}
comment|/**      * Adds additional pushdown predicates for a join operator by replicating      * filters transitively over all the equijoin conditions.      *      * If we have a predicate "t.col=1" and the equijoin conditions      * "t.col=s.col" and "t.col=u.col", we add the filters "s.col=1" and      * "u.col=1". Note that this does not depend on the types of joins (ie.      * inner, left/right/full outer) between the tables s, t and u because if      * a predicate, eg. "t.col=1" is present in getFinalCandidates() at this      * point, we have already verified that it can be pushed down, so any rows      * emitted must satisfy s.col=t.col=u.col=1 and replicating the filters      * like this is ok.      */
specifier|private
name|void
name|applyFilterTransitivity
parameter_list|(
name|JoinOperator
name|nd
parameter_list|,
name|OpWalkerInfo
name|owi
parameter_list|)
throws|throws
name|SemanticException
block|{
name|ExprWalkerInfo
name|prunePreds
init|=
name|owi
operator|.
name|getPrunedPreds
argument_list|(
operator|(
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
operator|)
name|nd
argument_list|)
decl_stmt|;
if|if
condition|(
name|prunePreds
operator|!=
literal|null
condition|)
block|{
comment|// We want to use the row resolvers of the parents of the join op
comment|// because the rowresolver refers to the output columns of an operator
comment|// and the filters at this point refer to the input columns of the join
comment|// operator.
name|Map
argument_list|<
name|String
argument_list|,
name|RowResolver
argument_list|>
name|aliasToRR
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|RowResolver
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
name|o
range|:
operator|(
name|nd
operator|)
operator|.
name|getParentOperators
argument_list|()
control|)
block|{
for|for
control|(
name|String
name|alias
range|:
name|owi
operator|.
name|getRowResolver
argument_list|(
name|o
argument_list|)
operator|.
name|getTableNames
argument_list|()
control|)
block|{
name|aliasToRR
operator|.
name|put
argument_list|(
name|alias
argument_list|,
name|owi
operator|.
name|getRowResolver
argument_list|(
name|o
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|// eqExpressions is a list of ArrayList<ASTNode>'s, one for each table
comment|// in the join. Then for each i, j and k, the join condition is that
comment|// eqExpressions[i][k]=eqExpressions[j][k] (*) (ie. the columns referenced
comment|// by the corresponding ASTNodes are equal). For example, if the query
comment|// was SELECT * FROM a join b on a.col=b.col and a.col2=b.col2 left
comment|// outer join c on b.col=c.col and b.col2=c.col2 WHERE c.col=1,
comment|// eqExpressions would be [[a.col1, a.col2], [b.col1, b.col2],
comment|// [c.col1, c.col2]].
comment|//
comment|// numEqualities is the number of equal columns in each equality
comment|// "chain" and numColumns is the number of such chains.
comment|//
comment|// Note that (*) is guaranteed to be true for the
comment|// join operator: if the equijoin condititions can't be expressed in
comment|// these equal-length lists of equal columns (for example if we had the
comment|// query SELECT * FROM a join b on a.col=b.col and a.col2=b.col2 left
comment|// outer join c on b.col=c.col), more than one join operator is used.
name|ArrayList
argument_list|<
name|ArrayList
argument_list|<
name|ASTNode
argument_list|>
argument_list|>
name|eqExpressions
init|=
name|owi
operator|.
name|getParseContext
argument_list|()
operator|.
name|getJoinContext
argument_list|()
operator|.
name|get
argument_list|(
name|nd
argument_list|)
operator|.
name|getExpressions
argument_list|()
decl_stmt|;
name|int
name|numColumns
init|=
name|eqExpressions
operator|.
name|size
argument_list|()
decl_stmt|;
name|int
name|numEqualities
init|=
name|eqExpressions
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|size
argument_list|()
decl_stmt|;
comment|// joins[i] is the join between table i and i+1 in the JoinOperator
name|JoinCondDesc
index|[]
name|joins
init|=
operator|(
name|nd
operator|)
operator|.
name|getConf
argument_list|()
operator|.
name|getConds
argument_list|()
decl_stmt|;
comment|// oldFilters contains the filters to be pushed down
name|Map
argument_list|<
name|String
argument_list|,
name|List
argument_list|<
name|ExprNodeDesc
argument_list|>
argument_list|>
name|oldFilters
init|=
name|prunePreds
operator|.
name|getFinalCandidates
argument_list|()
decl_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|List
argument_list|<
name|ExprNodeDesc
argument_list|>
argument_list|>
name|newFilters
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|List
argument_list|<
name|ExprNodeDesc
argument_list|>
argument_list|>
argument_list|()
decl_stmt|;
comment|// We loop through for each chain of equalities
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numEqualities
condition|;
name|i
operator|++
control|)
block|{
comment|// equalColumns[i] is the ColumnInfo corresponding to the ith term
comment|// of the equality or null if the term is not a simple column
comment|// reference
name|ColumnInfo
index|[]
name|equalColumns
init|=
operator|new
name|ColumnInfo
index|[
name|numColumns
index|]
decl_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|numColumns
condition|;
name|j
operator|++
control|)
block|{
name|equalColumns
index|[
name|j
index|]
operator|=
name|getColumnInfoFromAST
argument_list|(
name|eqExpressions
operator|.
name|get
argument_list|(
name|j
argument_list|)
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|,
name|aliasToRR
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|numColumns
condition|;
name|j
operator|++
control|)
block|{
for|for
control|(
name|int
name|k
init|=
literal|0
init|;
name|k
operator|<
name|numColumns
condition|;
name|k
operator|++
control|)
block|{
if|if
condition|(
name|j
operator|!=
name|k
operator|&&
name|equalColumns
index|[
name|j
index|]
operator|!=
literal|null
operator|&&
name|equalColumns
index|[
name|k
index|]
operator|!=
literal|null
condition|)
block|{
comment|// terms j and k in the equality chain are simple columns,
comment|// so we can replace instances of column j with column k
comment|// in the filter and ad the replicated filter.
name|ColumnInfo
name|left
init|=
name|equalColumns
index|[
name|j
index|]
decl_stmt|;
name|ColumnInfo
name|right
init|=
name|equalColumns
index|[
name|k
index|]
decl_stmt|;
if|if
condition|(
name|oldFilters
operator|.
name|get
argument_list|(
name|left
operator|.
name|getTabAlias
argument_list|()
argument_list|)
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|ExprNodeDesc
name|expr
range|:
name|oldFilters
operator|.
name|get
argument_list|(
name|left
operator|.
name|getTabAlias
argument_list|()
argument_list|)
control|)
block|{
comment|// Only replicate the filter if there is exactly one column
comment|// referenced
name|Set
argument_list|<
name|String
argument_list|>
name|colsreferenced
init|=
operator|new
name|HashSet
argument_list|<
name|String
argument_list|>
argument_list|(
name|expr
operator|.
name|getCols
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|colsreferenced
operator|.
name|size
argument_list|()
operator|==
literal|1
operator|&&
name|colsreferenced
operator|.
name|contains
argument_list|(
name|left
operator|.
name|getInternalName
argument_list|()
argument_list|)
condition|)
block|{
name|ExprNodeDesc
name|newexpr
init|=
name|expr
operator|.
name|clone
argument_list|()
decl_stmt|;
comment|// Replace the column reference in the filter
name|replaceColumnReference
argument_list|(
name|newexpr
argument_list|,
name|left
operator|.
name|getInternalName
argument_list|()
argument_list|,
name|right
operator|.
name|getInternalName
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|newFilters
operator|.
name|get
argument_list|(
name|right
operator|.
name|getTabAlias
argument_list|()
argument_list|)
operator|==
literal|null
condition|)
block|{
name|newFilters
operator|.
name|put
argument_list|(
name|right
operator|.
name|getTabAlias
argument_list|()
argument_list|,
operator|new
name|ArrayList
argument_list|<
name|ExprNodeDesc
argument_list|>
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|newFilters
operator|.
name|get
argument_list|(
name|right
operator|.
name|getTabAlias
argument_list|()
argument_list|)
operator|.
name|add
argument_list|(
name|newexpr
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
block|}
block|}
for|for
control|(
name|Entry
argument_list|<
name|String
argument_list|,
name|List
argument_list|<
name|ExprNodeDesc
argument_list|>
argument_list|>
name|aliasToFilters
range|:
name|newFilters
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|owi
operator|.
name|getPrunedPreds
argument_list|(
operator|(
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
operator|)
name|nd
argument_list|)
operator|.
name|addPushDowns
argument_list|(
name|aliasToFilters
operator|.
name|getKey
argument_list|()
argument_list|,
name|aliasToFilters
operator|.
name|getValue
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**      * Replaces the ColumnInfo for the column referred to by an ASTNode      * representing "table.column" or null if the ASTNode is not in that form      */
specifier|private
name|ColumnInfo
name|getColumnInfoFromAST
parameter_list|(
name|ASTNode
name|nd
parameter_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|RowResolver
argument_list|>
name|aliastoRR
parameter_list|)
throws|throws
name|SemanticException
block|{
comment|// this bit is messy since we are parsing an ASTNode at this point
if|if
condition|(
name|nd
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|DOT
condition|)
block|{
if|if
condition|(
name|nd
operator|.
name|getChildCount
argument_list|()
operator|==
literal|2
condition|)
block|{
if|if
condition|(
name|nd
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_TABLE_OR_COL
operator|&&
name|nd
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getChildCount
argument_list|()
operator|==
literal|1
operator|&&
name|nd
operator|.
name|getChild
argument_list|(
literal|1
argument_list|)
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|Identifier
condition|)
block|{
comment|// We unescape the identifiers and make them lower case--this
comment|// really shouldn't be done here, but getExpressions gives us the
comment|// raw ASTNodes. The same thing is done in SemanticAnalyzer.
comment|// parseJoinCondPopulateAlias().
name|String
name|alias
init|=
name|BaseSemanticAnalyzer
operator|.
name|unescapeIdentifier
argument_list|(
name|nd
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getText
argument_list|()
operator|.
name|toLowerCase
argument_list|()
argument_list|)
decl_stmt|;
name|String
name|column
init|=
name|BaseSemanticAnalyzer
operator|.
name|unescapeIdentifier
argument_list|(
name|nd
operator|.
name|getChild
argument_list|(
literal|1
argument_list|)
operator|.
name|getText
argument_list|()
operator|.
name|toLowerCase
argument_list|()
argument_list|)
decl_stmt|;
name|RowResolver
name|rr
init|=
name|aliastoRR
operator|.
name|get
argument_list|(
name|alias
argument_list|)
decl_stmt|;
if|if
condition|(
name|rr
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
return|return
name|rr
operator|.
name|get
argument_list|(
name|alias
argument_list|,
name|column
argument_list|)
return|;
block|}
block|}
block|}
return|return
literal|null
return|;
block|}
comment|/**      * Replaces all instances of oldColumn with newColumn in the      * ExprColumnDesc's of the ExprNodeDesc      */
specifier|private
name|void
name|replaceColumnReference
parameter_list|(
name|ExprNodeDesc
name|expr
parameter_list|,
name|String
name|oldColumn
parameter_list|,
name|String
name|newColumn
parameter_list|)
block|{
if|if
condition|(
name|expr
operator|instanceof
name|ExprNodeColumnDesc
condition|)
block|{
if|if
condition|(
operator|(
operator|(
name|ExprNodeColumnDesc
operator|)
name|expr
operator|)
operator|.
name|getColumn
argument_list|()
operator|.
name|equals
argument_list|(
name|oldColumn
argument_list|)
condition|)
block|{
operator|(
operator|(
name|ExprNodeColumnDesc
operator|)
name|expr
operator|)
operator|.
name|setColumn
argument_list|(
name|newColumn
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|expr
operator|.
name|getChildren
argument_list|()
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|ExprNodeDesc
name|childexpr
range|:
name|expr
operator|.
name|getChildren
argument_list|()
control|)
block|{
name|replaceColumnReference
argument_list|(
name|childexpr
argument_list|,
name|oldColumn
argument_list|,
name|newColumn
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**      * Figures out the aliases for whom it is safe to push predicates based on      * ANSI SQL semantics. The join conditions are left associative so "a      * RIGHT OUTER JOIN b LEFT OUTER JOIN c INNER JOIN d" is interpreted as      * "((a RIGHT OUTER JOIN b) LEFT OUTER JOIN c) INNER JOIN d".  For inner      * joins, both the left and right join subexpressions are considered for      * pushing down aliases, for the right outer join, the right subexpression      * is considered and the left ignored and for the left outer join, the      * left subexpression is considered and the left ignored. Here, aliases b      * and d are eligible to be pushed up.      *      * TODO: further optimization opportunity for the case a.c1 = b.c1 and b.c2      * = c.c2 a and b are first joined and then the result with c. But the      * second join op currently treats a and b as separate aliases and thus      * disallowing predicate expr containing both tables a and b (such as a.c3      * + a.c4> 20). Such predicates also can be pushed just above the second      * join and below the first join      *      * @param op      *          Join Operator      * @param rr      *          Row resolver      * @return set of qualified aliases      */
specifier|private
name|Set
argument_list|<
name|String
argument_list|>
name|getQualifiedAliases
parameter_list|(
name|JoinOperator
name|op
parameter_list|,
name|RowResolver
name|rr
parameter_list|)
block|{
name|Set
argument_list|<
name|String
argument_list|>
name|aliases
init|=
operator|new
name|HashSet
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
name|JoinCondDesc
index|[]
name|conds
init|=
name|op
operator|.
name|getConf
argument_list|()
operator|.
name|getConds
argument_list|()
decl_stmt|;
name|Map
argument_list|<
name|Integer
argument_list|,
name|Set
argument_list|<
name|String
argument_list|>
argument_list|>
name|posToAliasMap
init|=
name|op
operator|.
name|getPosToAliasMap
argument_list|()
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|conds
operator|.
name|length
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|conds
index|[
name|i
index|]
operator|.
name|getType
argument_list|()
operator|==
name|JoinDesc
operator|.
name|INNER_JOIN
condition|)
block|{
name|aliases
operator|.
name|addAll
argument_list|(
name|posToAliasMap
operator|.
name|get
argument_list|(
name|i
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|conds
index|[
name|i
index|]
operator|.
name|getType
argument_list|()
operator|==
name|JoinDesc
operator|.
name|FULL_OUTER_JOIN
condition|)
block|{
break|break;
block|}
elseif|else
if|if
condition|(
name|conds
index|[
name|i
index|]
operator|.
name|getType
argument_list|()
operator|==
name|JoinDesc
operator|.
name|RIGHT_OUTER_JOIN
condition|)
block|{
name|aliases
operator|.
name|addAll
argument_list|(
name|posToAliasMap
operator|.
name|get
argument_list|(
name|i
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|conds
index|[
name|i
index|]
operator|.
name|getType
argument_list|()
operator|==
name|JoinDesc
operator|.
name|LEFT_OUTER_JOIN
condition|)
block|{
continue|continue;
block|}
block|}
if|if
condition|(
name|i
operator|==
operator|-
literal|1
condition|)
block|{
name|aliases
operator|.
name|addAll
argument_list|(
name|posToAliasMap
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|Set
argument_list|<
name|String
argument_list|>
name|aliases2
init|=
name|rr
operator|.
name|getTableNames
argument_list|()
decl_stmt|;
name|aliases
operator|.
name|retainAll
argument_list|(
name|aliases2
argument_list|)
expr_stmt|;
return|return
name|aliases
return|;
block|}
block|}
comment|/**    * Processor for ReduceSink operator.    *    */
specifier|public
specifier|static
class|class
name|ReduceSinkPPD
extends|extends
name|DefaultPPD
implements|implements
name|NodeProcessor
block|{
annotation|@
name|Override
specifier|public
name|Object
name|process
parameter_list|(
name|Node
name|nd
parameter_list|,
name|Stack
argument_list|<
name|Node
argument_list|>
name|stack
parameter_list|,
name|NodeProcessorCtx
name|procCtx
parameter_list|,
name|Object
modifier|...
name|nodeOutputs
parameter_list|)
throws|throws
name|SemanticException
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Processing for "
operator|+
name|nd
operator|.
name|getName
argument_list|()
operator|+
literal|"("
operator|+
operator|(
operator|(
name|Operator
operator|)
name|nd
operator|)
operator|.
name|getIdentifier
argument_list|()
operator|+
literal|")"
argument_list|)
expr_stmt|;
name|OpWalkerInfo
name|owi
init|=
operator|(
name|OpWalkerInfo
operator|)
name|procCtx
decl_stmt|;
name|Set
argument_list|<
name|String
argument_list|>
name|aliases
init|=
name|owi
operator|.
name|getRowResolver
argument_list|(
name|nd
argument_list|)
operator|.
name|getTableNames
argument_list|()
decl_stmt|;
name|boolean
name|ignoreAliases
init|=
literal|false
decl_stmt|;
if|if
condition|(
name|aliases
operator|.
name|size
argument_list|()
operator|==
literal|1
operator|&&
name|aliases
operator|.
name|contains
argument_list|(
literal|""
argument_list|)
condition|)
block|{
comment|// Reduce sink of group by operator
name|ignoreAliases
operator|=
literal|true
expr_stmt|;
block|}
name|boolean
name|hasUnpushedPredicates
init|=
name|mergeWithChildrenPred
argument_list|(
name|nd
argument_list|,
name|owi
argument_list|,
literal|null
argument_list|,
name|aliases
argument_list|,
name|ignoreAliases
argument_list|)
decl_stmt|;
if|if
condition|(
name|HiveConf
operator|.
name|getBoolVar
argument_list|(
name|owi
operator|.
name|getParseContext
argument_list|()
operator|.
name|getConf
argument_list|()
argument_list|,
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVEPPDREMOVEDUPLICATEFILTERS
argument_list|)
condition|)
block|{
if|if
condition|(
name|hasUnpushedPredicates
condition|)
block|{
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
name|op
init|=
operator|(
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
operator|)
name|nd
decl_stmt|;
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
name|childOperator
init|=
name|op
operator|.
name|getChildOperators
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|childOperator
operator|.
name|getParentOperators
argument_list|()
operator|.
name|size
argument_list|()
operator|==
literal|1
condition|)
block|{
name|owi
operator|.
name|getCandidateFilterOps
argument_list|()
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
block|}
block|}
return|return
literal|null
return|;
block|}
block|}
comment|/**    * Default processor which just merges its children.    */
specifier|public
specifier|static
class|class
name|DefaultPPD
implements|implements
name|NodeProcessor
block|{
annotation|@
name|Override
specifier|public
name|Object
name|process
parameter_list|(
name|Node
name|nd
parameter_list|,
name|Stack
argument_list|<
name|Node
argument_list|>
name|stack
parameter_list|,
name|NodeProcessorCtx
name|procCtx
parameter_list|,
name|Object
modifier|...
name|nodeOutputs
parameter_list|)
throws|throws
name|SemanticException
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Processing for "
operator|+
name|nd
operator|.
name|getName
argument_list|()
operator|+
literal|"("
operator|+
operator|(
operator|(
name|Operator
operator|)
name|nd
operator|)
operator|.
name|getIdentifier
argument_list|()
operator|+
literal|")"
argument_list|)
expr_stmt|;
name|OpWalkerInfo
name|owi
init|=
operator|(
name|OpWalkerInfo
operator|)
name|procCtx
decl_stmt|;
name|boolean
name|hasUnpushedPredicates
init|=
name|mergeWithChildrenPred
argument_list|(
name|nd
argument_list|,
name|owi
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
literal|false
argument_list|)
decl_stmt|;
if|if
condition|(
name|HiveConf
operator|.
name|getBoolVar
argument_list|(
name|owi
operator|.
name|getParseContext
argument_list|()
operator|.
name|getConf
argument_list|()
argument_list|,
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVEPPDREMOVEDUPLICATEFILTERS
argument_list|)
condition|)
block|{
if|if
condition|(
name|hasUnpushedPredicates
condition|)
block|{
name|ExprWalkerInfo
name|unpushedPreds
init|=
name|mergeChildrenPred
argument_list|(
name|nd
argument_list|,
name|owi
argument_list|,
literal|null
argument_list|,
literal|false
argument_list|)
decl_stmt|;
return|return
name|createFilter
argument_list|(
operator|(
name|Operator
operator|)
name|nd
argument_list|,
name|unpushedPreds
argument_list|,
name|owi
argument_list|)
return|;
block|}
block|}
return|return
literal|null
return|;
block|}
comment|/**      * @param nd      * @param ewi      */
specifier|protected
name|void
name|logExpr
parameter_list|(
name|Node
name|nd
parameter_list|,
name|ExprWalkerInfo
name|ewi
parameter_list|)
block|{
for|for
control|(
name|Entry
argument_list|<
name|String
argument_list|,
name|List
argument_list|<
name|ExprNodeDesc
argument_list|>
argument_list|>
name|e
range|:
name|ewi
operator|.
name|getFinalCandidates
argument_list|()
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Pushdown Predicates of "
operator|+
name|nd
operator|.
name|getName
argument_list|()
operator|+
literal|" For Alias : "
operator|+
name|e
operator|.
name|getKey
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|ExprNodeDesc
name|n
range|:
name|e
operator|.
name|getValue
argument_list|()
control|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"\t"
operator|+
name|n
operator|.
name|getExprString
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**      * Take current operators pushdown predicates and merges them with      * children's pushdown predicates.      *      * @param nd      *          current operator      * @param owi      *          operator context during this walk      * @param ewi      *          pushdown predicates (part of expression walker info)      * @param aliases      *          aliases that this operator can pushdown. null means that all      *          aliases can be pushed down      * @param ignoreAliases      * @throws SemanticException      */
specifier|protected
name|boolean
name|mergeWithChildrenPred
parameter_list|(
name|Node
name|nd
parameter_list|,
name|OpWalkerInfo
name|owi
parameter_list|,
name|ExprWalkerInfo
name|ewi
parameter_list|,
name|Set
argument_list|<
name|String
argument_list|>
name|aliases
parameter_list|,
name|boolean
name|ignoreAliases
parameter_list|)
throws|throws
name|SemanticException
block|{
name|boolean
name|hasUnpushedPredicates
init|=
literal|false
decl_stmt|;
name|Operator
argument_list|<
name|?
argument_list|>
name|current
init|=
operator|(
name|Operator
argument_list|<
name|?
argument_list|>
operator|)
name|nd
decl_stmt|;
name|List
argument_list|<
name|Operator
argument_list|<
name|?
argument_list|>
argument_list|>
name|children
init|=
name|current
operator|.
name|getChildOperators
argument_list|()
decl_stmt|;
if|if
condition|(
name|children
operator|==
literal|null
operator|||
name|children
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return
name|hasUnpushedPredicates
return|;
block|}
if|if
condition|(
name|children
operator|.
name|size
argument_list|()
operator|>
literal|1
condition|)
block|{
comment|// ppd for multi-insert query is not yet implemented
comment|// no-op for leafs
for|for
control|(
name|Operator
argument_list|<
name|?
argument_list|>
name|child
range|:
name|children
control|)
block|{
name|removeCandidates
argument_list|(
name|child
argument_list|,
name|owi
argument_list|)
expr_stmt|;
comment|// remove candidated filters on this branch
block|}
return|return
name|hasUnpushedPredicates
return|;
block|}
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
name|op
init|=
operator|(
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
operator|)
name|nd
decl_stmt|;
name|ExprWalkerInfo
name|childPreds
init|=
name|owi
operator|.
name|getPrunedPreds
argument_list|(
name|children
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|childPreds
operator|==
literal|null
condition|)
block|{
return|return
name|hasUnpushedPredicates
return|;
block|}
if|if
condition|(
name|ewi
operator|==
literal|null
condition|)
block|{
name|ewi
operator|=
operator|new
name|ExprWalkerInfo
argument_list|()
expr_stmt|;
block|}
for|for
control|(
name|Entry
argument_list|<
name|String
argument_list|,
name|List
argument_list|<
name|ExprNodeDesc
argument_list|>
argument_list|>
name|e
range|:
name|childPreds
operator|.
name|getFinalCandidates
argument_list|()
operator|.
name|entrySet
argument_list|()
control|)
block|{
if|if
condition|(
name|ignoreAliases
operator|||
name|aliases
operator|==
literal|null
operator|||
name|aliases
operator|.
name|contains
argument_list|(
name|e
operator|.
name|getKey
argument_list|()
argument_list|)
operator|||
name|e
operator|.
name|getKey
argument_list|()
operator|==
literal|null
condition|)
block|{
comment|// e.getKey() (alias) can be null in case of constant expressions. see
comment|// input8.q
name|ExprWalkerInfo
name|extractPushdownPreds
init|=
name|ExprWalkerProcFactory
operator|.
name|extractPushdownPreds
argument_list|(
name|owi
argument_list|,
name|op
argument_list|,
name|e
operator|.
name|getValue
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|extractPushdownPreds
operator|.
name|getNonFinalCandidates
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|hasUnpushedPredicates
operator|=
literal|true
expr_stmt|;
block|}
name|ewi
operator|.
name|merge
argument_list|(
name|extractPushdownPreds
argument_list|)
expr_stmt|;
name|logExpr
argument_list|(
name|nd
argument_list|,
name|extractPushdownPreds
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|hasUnpushedPredicates
operator|=
literal|true
expr_stmt|;
block|}
block|}
name|owi
operator|.
name|putPrunedPreds
argument_list|(
operator|(
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
operator|)
name|nd
argument_list|,
name|ewi
argument_list|)
expr_stmt|;
return|return
name|hasUnpushedPredicates
return|;
block|}
specifier|private
name|void
name|removeCandidates
parameter_list|(
name|Operator
argument_list|<
name|?
argument_list|>
name|operator
parameter_list|,
name|OpWalkerInfo
name|owi
parameter_list|)
block|{
if|if
condition|(
name|operator
operator|instanceof
name|FilterOperator
condition|)
block|{
name|owi
operator|.
name|getCandidateFilterOps
argument_list|()
operator|.
name|remove
argument_list|(
name|operator
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|operator
operator|.
name|getChildOperators
argument_list|()
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|Operator
argument_list|<
name|?
argument_list|>
name|child
range|:
name|operator
operator|.
name|getChildOperators
argument_list|()
control|)
block|{
name|removeCandidates
argument_list|(
name|child
argument_list|,
name|owi
argument_list|)
expr_stmt|;
block|}
block|}
block|}
specifier|protected
name|ExprWalkerInfo
name|mergeChildrenPred
parameter_list|(
name|Node
name|nd
parameter_list|,
name|OpWalkerInfo
name|owi
parameter_list|,
name|Set
argument_list|<
name|String
argument_list|>
name|excludedAliases
parameter_list|,
name|boolean
name|ignoreAliases
parameter_list|)
throws|throws
name|SemanticException
block|{
if|if
condition|(
name|nd
operator|.
name|getChildren
argument_list|()
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
name|op
init|=
operator|(
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
operator|)
name|nd
decl_stmt|;
name|ExprWalkerInfo
name|ewi
init|=
operator|new
name|ExprWalkerInfo
argument_list|()
decl_stmt|;
for|for
control|(
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
name|child
range|:
name|op
operator|.
name|getChildOperators
argument_list|()
control|)
block|{
name|ExprWalkerInfo
name|childPreds
init|=
name|owi
operator|.
name|getPrunedPreds
argument_list|(
name|child
argument_list|)
decl_stmt|;
if|if
condition|(
name|childPreds
operator|==
literal|null
condition|)
block|{
continue|continue;
block|}
for|for
control|(
name|Entry
argument_list|<
name|String
argument_list|,
name|List
argument_list|<
name|ExprNodeDesc
argument_list|>
argument_list|>
name|e
range|:
name|childPreds
operator|.
name|getFinalCandidates
argument_list|()
operator|.
name|entrySet
argument_list|()
control|)
block|{
if|if
condition|(
name|ignoreAliases
operator|||
name|excludedAliases
operator|==
literal|null
operator|||
operator|!
name|excludedAliases
operator|.
name|contains
argument_list|(
name|e
operator|.
name|getKey
argument_list|()
argument_list|)
operator|||
name|e
operator|.
name|getKey
argument_list|()
operator|==
literal|null
condition|)
block|{
name|ewi
operator|.
name|addPushDowns
argument_list|(
name|e
operator|.
name|getKey
argument_list|()
argument_list|,
name|e
operator|.
name|getValue
argument_list|()
argument_list|)
expr_stmt|;
name|logExpr
argument_list|(
name|nd
argument_list|,
name|ewi
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
name|ewi
return|;
block|}
block|}
specifier|protected
specifier|static
name|Object
name|createFilter
parameter_list|(
name|Operator
name|op
parameter_list|,
name|ExprWalkerInfo
name|pushDownPreds
parameter_list|,
name|OpWalkerInfo
name|owi
parameter_list|)
block|{
if|if
condition|(
name|pushDownPreds
operator|==
literal|null
operator|||
name|pushDownPreds
operator|.
name|getFinalCandidates
argument_list|()
operator|==
literal|null
operator|||
name|pushDownPreds
operator|.
name|getFinalCandidates
argument_list|()
operator|.
name|size
argument_list|()
operator|==
literal|0
condition|)
block|{
return|return
literal|null
return|;
block|}
name|RowResolver
name|inputRR
init|=
name|owi
operator|.
name|getRowResolver
argument_list|(
name|op
argument_list|)
decl_stmt|;
comment|// combine all predicates into a single expression
name|List
argument_list|<
name|ExprNodeDesc
argument_list|>
name|preds
init|=
operator|new
name|ArrayList
argument_list|<
name|ExprNodeDesc
argument_list|>
argument_list|()
decl_stmt|;
name|Iterator
argument_list|<
name|List
argument_list|<
name|ExprNodeDesc
argument_list|>
argument_list|>
name|iterator
init|=
name|pushDownPreds
operator|.
name|getFinalCandidates
argument_list|()
operator|.
name|values
argument_list|()
operator|.
name|iterator
argument_list|()
decl_stmt|;
while|while
condition|(
name|iterator
operator|.
name|hasNext
argument_list|()
condition|)
block|{
for|for
control|(
name|ExprNodeDesc
name|pred
range|:
name|iterator
operator|.
name|next
argument_list|()
control|)
block|{
name|preds
operator|=
name|ExprNodeDescUtils
operator|.
name|split
argument_list|(
name|pred
argument_list|,
name|preds
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|preds
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return
literal|null
return|;
block|}
name|ExprNodeDesc
name|condn
init|=
name|ExprNodeDescUtils
operator|.
name|mergePredicates
argument_list|(
name|preds
argument_list|)
decl_stmt|;
if|if
condition|(
name|op
operator|instanceof
name|TableScanOperator
condition|)
block|{
name|boolean
name|pushFilterToStorage
decl_stmt|;
name|HiveConf
name|hiveConf
init|=
name|owi
operator|.
name|getParseContext
argument_list|()
operator|.
name|getConf
argument_list|()
decl_stmt|;
name|pushFilterToStorage
operator|=
name|hiveConf
operator|.
name|getBoolVar
argument_list|(
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVEOPTPPD_STORAGE
argument_list|)
expr_stmt|;
if|if
condition|(
name|pushFilterToStorage
condition|)
block|{
name|condn
operator|=
name|pushFilterToStorageHandler
argument_list|(
operator|(
name|TableScanOperator
operator|)
name|op
argument_list|,
name|condn
argument_list|,
name|owi
argument_list|,
name|hiveConf
argument_list|)
expr_stmt|;
if|if
condition|(
name|condn
operator|==
literal|null
condition|)
block|{
comment|// we pushed the whole thing down
return|return
literal|null
return|;
block|}
block|}
block|}
comment|// add new filter op
name|List
argument_list|<
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
argument_list|>
name|originalChilren
init|=
name|op
operator|.
name|getChildOperators
argument_list|()
decl_stmt|;
name|op
operator|.
name|setChildOperators
argument_list|(
literal|null
argument_list|)
expr_stmt|;
name|Operator
argument_list|<
name|FilterDesc
argument_list|>
name|output
init|=
name|OperatorFactory
operator|.
name|getAndMakeChild
argument_list|(
operator|new
name|FilterDesc
argument_list|(
name|condn
argument_list|,
literal|false
argument_list|)
argument_list|,
operator|new
name|RowSchema
argument_list|(
name|inputRR
operator|.
name|getColumnInfos
argument_list|()
argument_list|)
argument_list|,
name|op
argument_list|)
decl_stmt|;
name|output
operator|.
name|setChildOperators
argument_list|(
name|originalChilren
argument_list|)
expr_stmt|;
for|for
control|(
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
name|ch
range|:
name|originalChilren
control|)
block|{
name|List
argument_list|<
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
argument_list|>
name|parentOperators
init|=
name|ch
operator|.
name|getParentOperators
argument_list|()
decl_stmt|;
name|int
name|pos
init|=
name|parentOperators
operator|.
name|indexOf
argument_list|(
name|op
argument_list|)
decl_stmt|;
assert|assert
name|pos
operator|!=
operator|-
literal|1
assert|;
name|parentOperators
operator|.
name|remove
argument_list|(
name|pos
argument_list|)
expr_stmt|;
name|parentOperators
operator|.
name|add
argument_list|(
name|pos
argument_list|,
name|output
argument_list|)
expr_stmt|;
comment|// add the new op as the old
block|}
name|OpParseContext
name|ctx
init|=
operator|new
name|OpParseContext
argument_list|(
name|inputRR
argument_list|)
decl_stmt|;
name|owi
operator|.
name|put
argument_list|(
name|output
argument_list|,
name|ctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|HiveConf
operator|.
name|getBoolVar
argument_list|(
name|owi
operator|.
name|getParseContext
argument_list|()
operator|.
name|getConf
argument_list|()
argument_list|,
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVEPPDREMOVEDUPLICATEFILTERS
argument_list|)
condition|)
block|{
comment|// remove the candidate filter ops
for|for
control|(
name|FilterOperator
name|fop
range|:
name|owi
operator|.
name|getCandidateFilterOps
argument_list|()
control|)
block|{
name|List
argument_list|<
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
argument_list|>
name|children
init|=
name|fop
operator|.
name|getChildOperators
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
argument_list|>
name|parents
init|=
name|fop
operator|.
name|getParentOperators
argument_list|()
decl_stmt|;
for|for
control|(
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
name|parent
range|:
name|parents
control|)
block|{
name|parent
operator|.
name|getChildOperators
argument_list|()
operator|.
name|addAll
argument_list|(
name|children
argument_list|)
expr_stmt|;
name|parent
operator|.
name|removeChild
argument_list|(
name|fop
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
name|child
range|:
name|children
control|)
block|{
name|child
operator|.
name|getParentOperators
argument_list|()
operator|.
name|addAll
argument_list|(
name|parents
argument_list|)
expr_stmt|;
name|child
operator|.
name|removeParent
argument_list|(
name|fop
argument_list|)
expr_stmt|;
block|}
block|}
name|owi
operator|.
name|getCandidateFilterOps
argument_list|()
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
return|return
name|output
return|;
block|}
comment|/**    * Attempts to push a predicate down into a storage handler.  For    * native tables, this is a no-op.    *    * @param tableScanOp table scan against which predicate applies    *    * @param originalPredicate predicate to be pushed down    *    * @param owi object walk info    *    * @param hiveConf Hive configuration    *    * @return portion of predicate which needs to be evaluated    * by Hive as a post-filter, or null if it was possible    * to push down the entire predicate    */
specifier|private
specifier|static
name|ExprNodeDesc
name|pushFilterToStorageHandler
parameter_list|(
name|TableScanOperator
name|tableScanOp
parameter_list|,
name|ExprNodeDesc
name|originalPredicate
parameter_list|,
name|OpWalkerInfo
name|owi
parameter_list|,
name|HiveConf
name|hiveConf
parameter_list|)
block|{
name|TableScanDesc
name|tableScanDesc
init|=
name|tableScanOp
operator|.
name|getConf
argument_list|()
decl_stmt|;
name|Table
name|tbl
init|=
name|owi
operator|.
name|getParseContext
argument_list|()
operator|.
name|getTopToTable
argument_list|()
operator|.
name|get
argument_list|(
name|tableScanOp
argument_list|)
decl_stmt|;
if|if
condition|(
name|HiveConf
operator|.
name|getBoolVar
argument_list|(
name|hiveConf
argument_list|,
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVEOPTINDEXFILTER
argument_list|)
condition|)
block|{
comment|// attach the original predicate to the table scan operator for index
comment|// optimizations that require the pushed predicate before pcr& later
comment|// optimizations are applied
name|tableScanDesc
operator|.
name|setFilterExpr
argument_list|(
name|originalPredicate
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|tbl
operator|.
name|isNonNative
argument_list|()
condition|)
block|{
return|return
name|originalPredicate
return|;
block|}
name|HiveStorageHandler
name|storageHandler
init|=
name|tbl
operator|.
name|getStorageHandler
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|storageHandler
operator|instanceof
name|HiveStoragePredicateHandler
operator|)
condition|)
block|{
comment|// The storage handler does not provide predicate decomposition
comment|// support, so we'll implement the entire filter in Hive.  However,
comment|// we still provide the full predicate to the storage handler in
comment|// case it wants to do any of its own prefiltering.
name|tableScanDesc
operator|.
name|setFilterExpr
argument_list|(
name|originalPredicate
argument_list|)
expr_stmt|;
return|return
name|originalPredicate
return|;
block|}
name|HiveStoragePredicateHandler
name|predicateHandler
init|=
operator|(
name|HiveStoragePredicateHandler
operator|)
name|storageHandler
decl_stmt|;
name|JobConf
name|jobConf
init|=
operator|new
name|JobConf
argument_list|(
name|owi
operator|.
name|getParseContext
argument_list|()
operator|.
name|getConf
argument_list|()
argument_list|)
decl_stmt|;
name|Utilities
operator|.
name|setColumnNameList
argument_list|(
name|jobConf
argument_list|,
name|tableScanOp
argument_list|)
expr_stmt|;
name|Utilities
operator|.
name|setColumnTypeList
argument_list|(
name|jobConf
argument_list|,
name|tableScanOp
argument_list|)
expr_stmt|;
name|Utilities
operator|.
name|copyTableJobPropertiesToConf
argument_list|(
name|Utilities
operator|.
name|getTableDesc
argument_list|(
name|tbl
argument_list|)
argument_list|,
name|jobConf
argument_list|)
expr_stmt|;
name|Deserializer
name|deserializer
init|=
name|tbl
operator|.
name|getDeserializer
argument_list|()
decl_stmt|;
name|HiveStoragePredicateHandler
operator|.
name|DecomposedPredicate
name|decomposed
init|=
name|predicateHandler
operator|.
name|decomposePredicate
argument_list|(
name|jobConf
argument_list|,
name|deserializer
argument_list|,
name|originalPredicate
argument_list|)
decl_stmt|;
if|if
condition|(
name|decomposed
operator|==
literal|null
condition|)
block|{
comment|// not able to push anything down
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"No pushdown possible for predicate:  "
operator|+
name|originalPredicate
operator|.
name|getExprString
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|originalPredicate
return|;
block|}
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Original predicate:  "
operator|+
name|originalPredicate
operator|.
name|getExprString
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|decomposed
operator|.
name|pushedPredicate
operator|!=
literal|null
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Pushed predicate:  "
operator|+
name|decomposed
operator|.
name|pushedPredicate
operator|.
name|getExprString
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|decomposed
operator|.
name|residualPredicate
operator|!=
literal|null
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Residual predicate:  "
operator|+
name|decomposed
operator|.
name|residualPredicate
operator|.
name|getExprString
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
name|tableScanDesc
operator|.
name|setFilterExpr
argument_list|(
name|decomposed
operator|.
name|pushedPredicate
argument_list|)
expr_stmt|;
return|return
name|decomposed
operator|.
name|residualPredicate
return|;
block|}
specifier|public
specifier|static
name|NodeProcessor
name|getFilterProc
parameter_list|()
block|{
return|return
operator|new
name|FilterPPD
argument_list|()
return|;
block|}
specifier|public
specifier|static
name|NodeProcessor
name|getJoinProc
parameter_list|()
block|{
return|return
operator|new
name|JoinPPD
argument_list|()
return|;
block|}
specifier|public
specifier|static
name|NodeProcessor
name|getRSProc
parameter_list|()
block|{
return|return
operator|new
name|ReduceSinkPPD
argument_list|()
return|;
block|}
specifier|public
specifier|static
name|NodeProcessor
name|getTSProc
parameter_list|()
block|{
return|return
operator|new
name|TableScanPPD
argument_list|()
return|;
block|}
specifier|public
specifier|static
name|NodeProcessor
name|getDefaultProc
parameter_list|()
block|{
return|return
operator|new
name|DefaultPPD
argument_list|()
return|;
block|}
specifier|public
specifier|static
name|NodeProcessor
name|getPTFProc
parameter_list|()
block|{
return|return
operator|new
name|ScriptPPD
argument_list|()
return|;
block|}
specifier|public
specifier|static
name|NodeProcessor
name|getSCRProc
parameter_list|()
block|{
return|return
operator|new
name|ScriptPPD
argument_list|()
return|;
block|}
specifier|public
specifier|static
name|NodeProcessor
name|getLIMProc
parameter_list|()
block|{
return|return
operator|new
name|ScriptPPD
argument_list|()
return|;
block|}
specifier|public
specifier|static
name|NodeProcessor
name|getUDTFProc
parameter_list|()
block|{
return|return
operator|new
name|UDTFPPD
argument_list|()
return|;
block|}
specifier|public
specifier|static
name|NodeProcessor
name|getLVFProc
parameter_list|()
block|{
return|return
operator|new
name|LateralViewForwardPPD
argument_list|()
return|;
block|}
specifier|private
name|OpProcFactory
parameter_list|()
block|{
comment|// prevent instantiation
block|}
block|}
end_class

end_unit

