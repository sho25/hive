begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|ppd
package|;
end_package

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
operator|.
name|Entry
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Stack
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|Log
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|LogFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|conf
operator|.
name|HiveConf
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|ColumnInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|FilterOperator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|JoinOperator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|LateralViewJoinOperator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|Operator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|OperatorFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|PTFOperator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|ReduceSinkOperator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|RowSchema
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|TableScanOperator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|Utilities
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|lib
operator|.
name|Node
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|lib
operator|.
name|NodeProcessor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|lib
operator|.
name|NodeProcessorCtx
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|metadata
operator|.
name|HiveStorageHandler
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|metadata
operator|.
name|HiveStoragePredicateHandler
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|metadata
operator|.
name|Table
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|parse
operator|.
name|ASTNode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|parse
operator|.
name|BaseSemanticAnalyzer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|parse
operator|.
name|HiveParser
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|parse
operator|.
name|OpParseContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|parse
operator|.
name|RowResolver
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|parse
operator|.
name|SemanticException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|parse
operator|.
name|WindowingSpec
operator|.
name|Direction
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|ExprNodeColumnDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|ExprNodeConstantDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|ExprNodeDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|ExprNodeDescUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|ExprNodeGenericFuncDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|FilterDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|JoinCondDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|JoinDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|OperatorDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|PTFDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|ReduceSinkDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|TableScanDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|ptf
operator|.
name|BoundaryDef
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|ptf
operator|.
name|ValueBoundaryDef
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|ptf
operator|.
name|WindowFrameDef
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|ptf
operator|.
name|WindowFunctionDef
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|ptf
operator|.
name|WindowTableFunctionDef
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|udf
operator|.
name|generic
operator|.
name|GenericUDAFDenseRank
operator|.
name|GenericUDAFDenseRankEvaluator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|udf
operator|.
name|generic
operator|.
name|GenericUDAFLead
operator|.
name|GenericUDAFLeadEvaluator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|udf
operator|.
name|generic
operator|.
name|GenericUDAFRank
operator|.
name|GenericUDAFRankEvaluator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|udf
operator|.
name|generic
operator|.
name|GenericUDFOPEqualOrLessThan
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|udf
operator|.
name|generic
operator|.
name|GenericUDFOPLessThan
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|Deserializer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|typeinfo
operator|.
name|TypeInfoFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapred
operator|.
name|JobConf
import|;
end_import

begin_comment
comment|/**  * Operator factory for predicate pushdown processing of operator graph Each  * operator determines the pushdown predicates by walking the expression tree.  * Each operator merges its own pushdown predicates with those of its children  * Finally the TableScan operator gathers all the predicates and inserts a  * filter operator after itself. TODO: Further optimizations 1) Multi-insert  * case 2) Create a filter operator for those predicates that couldn't be pushed  * to the previous operators in the data flow 3) Merge multiple sequential  * filter predicates into so that plans are more readable 4) Remove predicates  * from filter operators that have been pushed. Currently these pushed  * predicates are evaluated twice.  */
end_comment

begin_class
specifier|public
specifier|final
class|class
name|OpProcFactory
block|{
specifier|protected
specifier|static
specifier|final
name|Log
name|LOG
init|=
name|LogFactory
operator|.
name|getLog
argument_list|(
name|OpProcFactory
operator|.
name|class
operator|.
name|getName
argument_list|()
argument_list|)
decl_stmt|;
specifier|private
specifier|static
name|ExprWalkerInfo
name|getChildWalkerInfo
parameter_list|(
name|Operator
argument_list|<
name|?
argument_list|>
name|current
parameter_list|,
name|OpWalkerInfo
name|owi
parameter_list|)
block|{
if|if
condition|(
name|current
operator|.
name|getNumChild
argument_list|()
operator|==
literal|0
condition|)
block|{
return|return
literal|null
return|;
block|}
if|if
condition|(
name|current
operator|.
name|getNumChild
argument_list|()
operator|>
literal|1
condition|)
block|{
comment|// ppd for multi-insert query is not yet implemented
comment|// no-op for leafs
for|for
control|(
name|Operator
argument_list|<
name|?
argument_list|>
name|child
range|:
name|current
operator|.
name|getChildOperators
argument_list|()
control|)
block|{
name|removeCandidates
argument_list|(
name|child
argument_list|,
name|owi
argument_list|)
expr_stmt|;
comment|// remove candidated filters on this branch
block|}
return|return
literal|null
return|;
block|}
return|return
name|owi
operator|.
name|getPrunedPreds
argument_list|(
name|current
operator|.
name|getChildOperators
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|)
return|;
block|}
specifier|private
specifier|static
name|void
name|removeCandidates
parameter_list|(
name|Operator
argument_list|<
name|?
argument_list|>
name|operator
parameter_list|,
name|OpWalkerInfo
name|owi
parameter_list|)
block|{
if|if
condition|(
name|operator
operator|instanceof
name|FilterOperator
condition|)
block|{
name|owi
operator|.
name|getCandidateFilterOps
argument_list|()
operator|.
name|remove
argument_list|(
name|operator
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|operator
operator|.
name|getChildOperators
argument_list|()
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|Operator
argument_list|<
name|?
argument_list|>
name|child
range|:
name|operator
operator|.
name|getChildOperators
argument_list|()
control|)
block|{
name|removeCandidates
argument_list|(
name|child
argument_list|,
name|owi
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**    * Processor for Script Operator Prevents any predicates being pushed.    */
specifier|public
specifier|static
class|class
name|ScriptPPD
extends|extends
name|DefaultPPD
implements|implements
name|NodeProcessor
block|{
annotation|@
name|Override
specifier|public
name|Object
name|process
parameter_list|(
name|Node
name|nd
parameter_list|,
name|Stack
argument_list|<
name|Node
argument_list|>
name|stack
parameter_list|,
name|NodeProcessorCtx
name|procCtx
parameter_list|,
name|Object
modifier|...
name|nodeOutputs
parameter_list|)
throws|throws
name|SemanticException
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Processing for "
operator|+
name|nd
operator|.
name|getName
argument_list|()
operator|+
literal|"("
operator|+
operator|(
operator|(
name|Operator
operator|)
name|nd
operator|)
operator|.
name|getIdentifier
argument_list|()
operator|+
literal|")"
argument_list|)
expr_stmt|;
comment|// script operator is a black-box to hive so no optimization here
comment|// assuming that nothing can be pushed above the script op
comment|// same with LIMIT op
comment|// create a filter with all children predicates
name|OpWalkerInfo
name|owi
init|=
operator|(
name|OpWalkerInfo
operator|)
name|procCtx
decl_stmt|;
name|ExprWalkerInfo
name|childInfo
init|=
name|getChildWalkerInfo
argument_list|(
operator|(
name|Operator
argument_list|<
name|?
argument_list|>
operator|)
name|nd
argument_list|,
name|owi
argument_list|)
decl_stmt|;
if|if
condition|(
name|childInfo
operator|!=
literal|null
operator|&&
name|HiveConf
operator|.
name|getBoolVar
argument_list|(
name|owi
operator|.
name|getParseContext
argument_list|()
operator|.
name|getConf
argument_list|()
argument_list|,
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVEPPDREMOVEDUPLICATEFILTERS
argument_list|)
condition|)
block|{
name|ExprWalkerInfo
name|unpushedPreds
init|=
name|mergeChildrenPred
argument_list|(
name|nd
argument_list|,
name|owi
argument_list|,
literal|null
argument_list|,
literal|false
argument_list|)
decl_stmt|;
return|return
name|createFilter
argument_list|(
operator|(
name|Operator
operator|)
name|nd
argument_list|,
name|unpushedPreds
argument_list|,
name|owi
argument_list|)
return|;
block|}
return|return
literal|null
return|;
block|}
block|}
specifier|public
specifier|static
class|class
name|PTFPPD
extends|extends
name|ScriptPPD
block|{
comment|/*      * For WindowingTableFunction if:      * a. there is a Rank/DenseRank function: if there are unpushedPred of the form       *    rnkValue< Constant; then use the smallest Constant val as the 'rankLimit'      *    on the WindowingTablFn.      * b. If there are no Wdw Fns with an End Boundary past the current row, the       *    condition can be pushed down as a limit pushdown(mapGroupBy=true)      *       * (non-Javadoc)      * @see org.apache.hadoop.hive.ql.ppd.OpProcFactory.ScriptPPD#process(org.apache.hadoop.hive.ql.lib.Node, java.util.Stack, org.apache.hadoop.hive.ql.lib.NodeProcessorCtx, java.lang.Object[])      */
annotation|@
name|Override
specifier|public
name|Object
name|process
parameter_list|(
name|Node
name|nd
parameter_list|,
name|Stack
argument_list|<
name|Node
argument_list|>
name|stack
parameter_list|,
name|NodeProcessorCtx
name|procCtx
parameter_list|,
name|Object
modifier|...
name|nodeOutputs
parameter_list|)
throws|throws
name|SemanticException
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Processing for "
operator|+
name|nd
operator|.
name|getName
argument_list|()
operator|+
literal|"("
operator|+
operator|(
operator|(
name|Operator
operator|)
name|nd
operator|)
operator|.
name|getIdentifier
argument_list|()
operator|+
literal|")"
argument_list|)
expr_stmt|;
name|OpWalkerInfo
name|owi
init|=
operator|(
name|OpWalkerInfo
operator|)
name|procCtx
decl_stmt|;
name|PTFOperator
name|ptfOp
init|=
operator|(
name|PTFOperator
operator|)
name|nd
decl_stmt|;
name|pushRankLimit
argument_list|(
name|ptfOp
argument_list|,
name|owi
argument_list|)
expr_stmt|;
return|return
name|super
operator|.
name|process
argument_list|(
name|nd
argument_list|,
name|stack
argument_list|,
name|procCtx
argument_list|,
name|nodeOutputs
argument_list|)
return|;
block|}
specifier|private
name|void
name|pushRankLimit
parameter_list|(
name|PTFOperator
name|ptfOp
parameter_list|,
name|OpWalkerInfo
name|owi
parameter_list|)
throws|throws
name|SemanticException
block|{
name|PTFDesc
name|conf
init|=
name|ptfOp
operator|.
name|getConf
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|conf
operator|.
name|forWindowing
argument_list|()
condition|)
block|{
return|return;
block|}
name|float
name|threshold
init|=
name|owi
operator|.
name|getParseContext
argument_list|()
operator|.
name|getConf
argument_list|()
operator|.
name|getFloatVar
argument_list|(
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVELIMITPUSHDOWNMEMORYUSAGE
argument_list|)
decl_stmt|;
if|if
condition|(
name|threshold
operator|<=
literal|0
operator|||
name|threshold
operator|>=
literal|1
condition|)
block|{
return|return;
block|}
name|WindowTableFunctionDef
name|wTFn
init|=
operator|(
name|WindowTableFunctionDef
operator|)
name|conf
operator|.
name|getFuncDef
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|Integer
argument_list|>
name|rFnIdxs
init|=
name|rankingFunctions
argument_list|(
name|wTFn
argument_list|)
decl_stmt|;
if|if
condition|(
name|rFnIdxs
operator|.
name|size
argument_list|()
operator|==
literal|0
condition|)
block|{
return|return;
block|}
name|ExprWalkerInfo
name|childInfo
init|=
name|getChildWalkerInfo
argument_list|(
name|ptfOp
argument_list|,
name|owi
argument_list|)
decl_stmt|;
if|if
condition|(
name|childInfo
operator|==
literal|null
condition|)
block|{
return|return;
block|}
name|List
argument_list|<
name|ExprNodeDesc
argument_list|>
name|preds
init|=
operator|new
name|ArrayList
argument_list|<
name|ExprNodeDesc
argument_list|>
argument_list|()
decl_stmt|;
name|Iterator
argument_list|<
name|List
argument_list|<
name|ExprNodeDesc
argument_list|>
argument_list|>
name|iterator
init|=
name|childInfo
operator|.
name|getFinalCandidates
argument_list|()
operator|.
name|values
argument_list|()
operator|.
name|iterator
argument_list|()
decl_stmt|;
while|while
condition|(
name|iterator
operator|.
name|hasNext
argument_list|()
condition|)
block|{
for|for
control|(
name|ExprNodeDesc
name|pred
range|:
name|iterator
operator|.
name|next
argument_list|()
control|)
block|{
name|preds
operator|=
name|ExprNodeDescUtils
operator|.
name|split
argument_list|(
name|pred
argument_list|,
name|preds
argument_list|)
expr_stmt|;
block|}
block|}
name|int
name|rLimit
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|fnIdx
init|=
operator|-
literal|1
decl_stmt|;
for|for
control|(
name|ExprNodeDesc
name|pred
range|:
name|preds
control|)
block|{
name|int
index|[]
name|pLimit
init|=
name|getLimit
argument_list|(
name|wTFn
argument_list|,
name|rFnIdxs
argument_list|,
name|pred
argument_list|)
decl_stmt|;
if|if
condition|(
name|pLimit
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|rLimit
operator|==
operator|-
literal|1
operator|||
name|rLimit
operator|>=
name|pLimit
index|[
literal|0
index|]
condition|)
block|{
name|rLimit
operator|=
name|pLimit
index|[
literal|0
index|]
expr_stmt|;
name|fnIdx
operator|=
name|pLimit
index|[
literal|1
index|]
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|rLimit
operator|!=
operator|-
literal|1
condition|)
block|{
name|wTFn
operator|.
name|setRankLimit
argument_list|(
name|rLimit
argument_list|)
expr_stmt|;
name|wTFn
operator|.
name|setRankLimitFunction
argument_list|(
name|fnIdx
argument_list|)
expr_stmt|;
if|if
condition|(
name|canPushLimitToReduceSink
argument_list|(
name|wTFn
argument_list|)
condition|)
block|{
name|pushRankLimitToRedSink
argument_list|(
name|ptfOp
argument_list|,
name|owi
operator|.
name|getParseContext
argument_list|()
operator|.
name|getConf
argument_list|()
argument_list|,
name|rLimit
argument_list|)
expr_stmt|;
block|}
block|}
block|}
specifier|private
name|List
argument_list|<
name|Integer
argument_list|>
name|rankingFunctions
parameter_list|(
name|WindowTableFunctionDef
name|wTFn
parameter_list|)
block|{
name|List
argument_list|<
name|Integer
argument_list|>
name|rFns
init|=
operator|new
name|ArrayList
argument_list|<
name|Integer
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|wTFn
operator|.
name|getWindowFunctions
argument_list|()
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|WindowFunctionDef
name|wFnDef
init|=
name|wTFn
operator|.
name|getWindowFunctions
argument_list|()
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|wFnDef
operator|.
name|getWFnEval
argument_list|()
operator|instanceof
name|GenericUDAFRankEvaluator
operator|)
operator|||
operator|(
name|wFnDef
operator|.
name|getWFnEval
argument_list|()
operator|instanceof
name|GenericUDAFDenseRankEvaluator
operator|)
condition|)
block|{
name|rFns
operator|.
name|add
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|rFns
return|;
block|}
comment|/*      * For a predicate check if it is a candidate for pushing down as limit optimization.      * The expression must be of the form rankFn<|<= constant.      */
specifier|private
name|int
index|[]
name|getLimit
parameter_list|(
name|WindowTableFunctionDef
name|wTFn
parameter_list|,
name|List
argument_list|<
name|Integer
argument_list|>
name|rFnIdxs
parameter_list|,
name|ExprNodeDesc
name|expr
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|expr
operator|instanceof
name|ExprNodeGenericFuncDesc
operator|)
condition|)
block|{
return|return
literal|null
return|;
block|}
name|ExprNodeGenericFuncDesc
name|fExpr
init|=
operator|(
name|ExprNodeGenericFuncDesc
operator|)
name|expr
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|fExpr
operator|.
name|getGenericUDF
argument_list|()
operator|instanceof
name|GenericUDFOPLessThan
operator|)
operator|&&
operator|!
operator|(
name|fExpr
operator|.
name|getGenericUDF
argument_list|()
operator|instanceof
name|GenericUDFOPEqualOrLessThan
operator|)
condition|)
block|{
return|return
literal|null
return|;
block|}
if|if
condition|(
operator|!
operator|(
name|fExpr
operator|.
name|getChildren
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|instanceof
name|ExprNodeColumnDesc
operator|)
condition|)
block|{
return|return
literal|null
return|;
block|}
if|if
condition|(
operator|!
operator|(
name|fExpr
operator|.
name|getChildren
argument_list|()
operator|.
name|get
argument_list|(
literal|1
argument_list|)
operator|instanceof
name|ExprNodeConstantDesc
operator|)
condition|)
block|{
return|return
literal|null
return|;
block|}
name|ExprNodeConstantDesc
name|constantExpr
init|=
operator|(
name|ExprNodeConstantDesc
operator|)
name|fExpr
operator|.
name|getChildren
argument_list|()
operator|.
name|get
argument_list|(
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|constantExpr
operator|.
name|getTypeInfo
argument_list|()
operator|!=
name|TypeInfoFactory
operator|.
name|intTypeInfo
condition|)
block|{
return|return
literal|null
return|;
block|}
name|int
name|limit
init|=
operator|(
name|Integer
operator|)
name|constantExpr
operator|.
name|getValue
argument_list|()
decl_stmt|;
if|if
condition|(
name|fExpr
operator|.
name|getGenericUDF
argument_list|()
operator|instanceof
name|GenericUDFOPEqualOrLessThan
condition|)
block|{
name|limit
operator|=
name|limit
operator|+
literal|1
expr_stmt|;
block|}
name|String
name|colName
init|=
operator|(
operator|(
name|ExprNodeColumnDesc
operator|)
name|fExpr
operator|.
name|getChildren
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|)
operator|.
name|getColumn
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|rFnIdxs
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|String
name|fAlias
init|=
name|wTFn
operator|.
name|getWindowFunctions
argument_list|()
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|getAlias
argument_list|()
decl_stmt|;
if|if
condition|(
name|fAlias
operator|.
name|equals
argument_list|(
name|colName
argument_list|)
condition|)
block|{
return|return
operator|new
name|int
index|[]
block|{
name|limit
block|,
name|i
block|}
return|;
block|}
block|}
return|return
literal|null
return|;
block|}
comment|/*      * Limit can be pushed down to Map-side if all Window Functions need access       * to rows before the current row. This is true for:      * 1. Rank, DenseRank and Lead Fns. (the window doesn't matter for lead fn).      * 2. If the Window for the function is Row based and the End Boundary doesn't      * reference rows past the Current Row.      */
specifier|private
name|boolean
name|canPushLimitToReduceSink
parameter_list|(
name|WindowTableFunctionDef
name|wTFn
parameter_list|)
block|{
for|for
control|(
name|WindowFunctionDef
name|wFnDef
range|:
name|wTFn
operator|.
name|getWindowFunctions
argument_list|()
control|)
block|{
if|if
condition|(
operator|(
name|wFnDef
operator|.
name|getWFnEval
argument_list|()
operator|instanceof
name|GenericUDAFRankEvaluator
operator|)
operator|||
operator|(
name|wFnDef
operator|.
name|getWFnEval
argument_list|()
operator|instanceof
name|GenericUDAFDenseRankEvaluator
operator|)
operator|||
operator|(
name|wFnDef
operator|.
name|getWFnEval
argument_list|()
operator|instanceof
name|GenericUDAFLeadEvaluator
operator|)
condition|)
block|{
continue|continue;
block|}
name|WindowFrameDef
name|wdwFrame
init|=
name|wFnDef
operator|.
name|getWindowFrame
argument_list|()
decl_stmt|;
name|BoundaryDef
name|end
init|=
name|wdwFrame
operator|.
name|getEnd
argument_list|()
decl_stmt|;
if|if
condition|(
name|end
operator|instanceof
name|ValueBoundaryDef
condition|)
block|{
return|return
literal|false
return|;
block|}
if|if
condition|(
name|end
operator|.
name|getDirection
argument_list|()
operator|==
name|Direction
operator|.
name|FOLLOWING
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
return|return
literal|true
return|;
block|}
specifier|private
name|void
name|pushRankLimitToRedSink
parameter_list|(
name|PTFOperator
name|ptfOp
parameter_list|,
name|HiveConf
name|conf
parameter_list|,
name|int
name|rLimit
parameter_list|)
throws|throws
name|SemanticException
block|{
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
name|parent
init|=
name|ptfOp
operator|.
name|getParentOperators
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
name|gP
init|=
name|parent
operator|==
literal|null
condition|?
literal|null
else|:
name|parent
operator|.
name|getParentOperators
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|gP
operator|==
literal|null
operator|||
operator|!
operator|(
name|gP
operator|instanceof
name|ReduceSinkOperator
operator|)
condition|)
block|{
return|return;
block|}
name|float
name|threshold
init|=
name|conf
operator|.
name|getFloatVar
argument_list|(
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVELIMITPUSHDOWNMEMORYUSAGE
argument_list|)
decl_stmt|;
name|ReduceSinkOperator
name|rSink
init|=
operator|(
name|ReduceSinkOperator
operator|)
name|gP
decl_stmt|;
name|ReduceSinkDesc
name|rDesc
init|=
name|rSink
operator|.
name|getConf
argument_list|()
decl_stmt|;
name|rDesc
operator|.
name|setTopN
argument_list|(
name|rLimit
argument_list|)
expr_stmt|;
name|rDesc
operator|.
name|setTopNMemoryUsage
argument_list|(
name|threshold
argument_list|)
expr_stmt|;
name|rDesc
operator|.
name|setMapGroupBy
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|rDesc
operator|.
name|setPTFReduceSink
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
block|}
specifier|public
specifier|static
class|class
name|UDTFPPD
extends|extends
name|DefaultPPD
implements|implements
name|NodeProcessor
block|{
annotation|@
name|Override
specifier|public
name|Object
name|process
parameter_list|(
name|Node
name|nd
parameter_list|,
name|Stack
argument_list|<
name|Node
argument_list|>
name|stack
parameter_list|,
name|NodeProcessorCtx
name|procCtx
parameter_list|,
name|Object
modifier|...
name|nodeOutputs
parameter_list|)
throws|throws
name|SemanticException
block|{
name|super
operator|.
name|process
argument_list|(
name|nd
argument_list|,
name|stack
argument_list|,
name|procCtx
argument_list|,
name|nodeOutputs
argument_list|)
expr_stmt|;
name|OpWalkerInfo
name|owi
init|=
operator|(
name|OpWalkerInfo
operator|)
name|procCtx
decl_stmt|;
name|ExprWalkerInfo
name|prunedPred
init|=
name|owi
operator|.
name|getPrunedPreds
argument_list|(
operator|(
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
operator|)
name|nd
argument_list|)
decl_stmt|;
if|if
condition|(
name|prunedPred
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
name|Map
argument_list|<
name|String
argument_list|,
name|List
argument_list|<
name|ExprNodeDesc
argument_list|>
argument_list|>
name|candidates
init|=
name|prunedPred
operator|.
name|getFinalCandidates
argument_list|()
decl_stmt|;
if|if
condition|(
name|candidates
operator|!=
literal|null
operator|&&
operator|!
name|candidates
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|createFilter
argument_list|(
operator|(
name|Operator
operator|)
name|nd
argument_list|,
name|prunedPred
argument_list|,
name|owi
argument_list|)
expr_stmt|;
name|candidates
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
return|return
literal|null
return|;
block|}
block|}
specifier|public
specifier|static
class|class
name|LateralViewForwardPPD
extends|extends
name|DefaultPPD
implements|implements
name|NodeProcessor
block|{
annotation|@
name|Override
specifier|public
name|Object
name|process
parameter_list|(
name|Node
name|nd
parameter_list|,
name|Stack
argument_list|<
name|Node
argument_list|>
name|stack
parameter_list|,
name|NodeProcessorCtx
name|procCtx
parameter_list|,
name|Object
modifier|...
name|nodeOutputs
parameter_list|)
throws|throws
name|SemanticException
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Processing for "
operator|+
name|nd
operator|.
name|getName
argument_list|()
operator|+
literal|"("
operator|+
operator|(
operator|(
name|Operator
operator|)
name|nd
operator|)
operator|.
name|getIdentifier
argument_list|()
operator|+
literal|")"
argument_list|)
expr_stmt|;
name|OpWalkerInfo
name|owi
init|=
operator|(
name|OpWalkerInfo
operator|)
name|procCtx
decl_stmt|;
comment|// The lateral view forward operator has 2 children, a SELECT(*) and
comment|// a SELECT(cols) (for the UDTF operator) The child at index 0 is the
comment|// SELECT(*) because that's the way that the DAG was constructed. We
comment|// only want to get the predicates from the SELECT(*).
name|ExprWalkerInfo
name|childPreds
init|=
name|owi
operator|.
name|getPrunedPreds
argument_list|(
operator|(
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
operator|)
name|nd
operator|.
name|getChildren
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|owi
operator|.
name|putPrunedPreds
argument_list|(
operator|(
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
operator|)
name|nd
argument_list|,
name|childPreds
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
block|}
comment|/**    * Combines predicates of its child into a single expression and adds a filter    * op as new child.    */
specifier|public
specifier|static
class|class
name|TableScanPPD
extends|extends
name|DefaultPPD
implements|implements
name|NodeProcessor
block|{
annotation|@
name|Override
specifier|public
name|Object
name|process
parameter_list|(
name|Node
name|nd
parameter_list|,
name|Stack
argument_list|<
name|Node
argument_list|>
name|stack
parameter_list|,
name|NodeProcessorCtx
name|procCtx
parameter_list|,
name|Object
modifier|...
name|nodeOutputs
parameter_list|)
throws|throws
name|SemanticException
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Processing for "
operator|+
name|nd
operator|.
name|getName
argument_list|()
operator|+
literal|"("
operator|+
operator|(
operator|(
name|Operator
operator|)
name|nd
operator|)
operator|.
name|getIdentifier
argument_list|()
operator|+
literal|")"
argument_list|)
expr_stmt|;
name|OpWalkerInfo
name|owi
init|=
operator|(
name|OpWalkerInfo
operator|)
name|procCtx
decl_stmt|;
name|TableScanOperator
name|tsOp
init|=
operator|(
name|TableScanOperator
operator|)
name|nd
decl_stmt|;
name|mergeWithChildrenPred
argument_list|(
name|tsOp
argument_list|,
name|owi
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
expr_stmt|;
name|ExprWalkerInfo
name|pushDownPreds
init|=
name|owi
operator|.
name|getPrunedPreds
argument_list|(
name|tsOp
argument_list|)
decl_stmt|;
return|return
name|createFilter
argument_list|(
name|tsOp
argument_list|,
name|pushDownPreds
argument_list|,
name|owi
argument_list|)
return|;
block|}
block|}
comment|/**    * Determines the push down predicates in its where expression and then    * combines it with the push down predicates that are passed from its children.    */
specifier|public
specifier|static
class|class
name|FilterPPD
extends|extends
name|DefaultPPD
implements|implements
name|NodeProcessor
block|{
annotation|@
name|Override
specifier|public
name|Object
name|process
parameter_list|(
name|Node
name|nd
parameter_list|,
name|Stack
argument_list|<
name|Node
argument_list|>
name|stack
parameter_list|,
name|NodeProcessorCtx
name|procCtx
parameter_list|,
name|Object
modifier|...
name|nodeOutputs
parameter_list|)
throws|throws
name|SemanticException
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Processing for "
operator|+
name|nd
operator|.
name|getName
argument_list|()
operator|+
literal|"("
operator|+
operator|(
operator|(
name|Operator
operator|)
name|nd
operator|)
operator|.
name|getIdentifier
argument_list|()
operator|+
literal|")"
argument_list|)
expr_stmt|;
name|OpWalkerInfo
name|owi
init|=
operator|(
name|OpWalkerInfo
operator|)
name|procCtx
decl_stmt|;
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
name|op
init|=
operator|(
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
operator|)
name|nd
decl_stmt|;
comment|// if this filter is generated one, predicates need not to be extracted
name|ExprWalkerInfo
name|ewi
init|=
name|owi
operator|.
name|getPrunedPreds
argument_list|(
name|op
argument_list|)
decl_stmt|;
comment|// Don't push a sampling predicate since createFilter() always creates filter
comment|// with isSamplePred = false. Also, the filterop with sampling pred is always
comment|// a child of TableScan, so there is no need to push this predicate.
if|if
condition|(
name|ewi
operator|==
literal|null
operator|&&
operator|!
operator|(
operator|(
name|FilterOperator
operator|)
name|op
operator|)
operator|.
name|getConf
argument_list|()
operator|.
name|getIsSamplingPred
argument_list|()
condition|)
block|{
comment|// get pushdown predicates for this operator's predicate
name|ExprNodeDesc
name|predicate
init|=
operator|(
operator|(
operator|(
name|FilterOperator
operator|)
name|nd
operator|)
operator|.
name|getConf
argument_list|()
operator|)
operator|.
name|getPredicate
argument_list|()
decl_stmt|;
name|ewi
operator|=
name|ExprWalkerProcFactory
operator|.
name|extractPushdownPreds
argument_list|(
name|owi
argument_list|,
name|op
argument_list|,
name|predicate
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ewi
operator|.
name|isDeterministic
argument_list|()
condition|)
block|{
comment|/* predicate is not deterministic */
if|if
condition|(
name|op
operator|.
name|getChildren
argument_list|()
operator|!=
literal|null
operator|&&
name|op
operator|.
name|getChildren
argument_list|()
operator|.
name|size
argument_list|()
operator|==
literal|1
condition|)
block|{
name|createFilter
argument_list|(
name|op
argument_list|,
name|owi
operator|.
name|getPrunedPreds
argument_list|(
call|(
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
call|)
argument_list|(
name|op
operator|.
name|getChildren
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|owi
argument_list|)
expr_stmt|;
block|}
return|return
literal|null
return|;
block|}
if|if
condition|(
name|HiveConf
operator|.
name|getBoolVar
argument_list|(
name|owi
operator|.
name|getParseContext
argument_list|()
operator|.
name|getConf
argument_list|()
argument_list|,
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVEPPDREMOVEDUPLICATEFILTERS
argument_list|)
condition|)
block|{
comment|// add this filter for deletion, if it does not have non-final candidates
if|if
condition|(
name|ewi
operator|.
name|getNonFinalCandidates
argument_list|()
operator|.
name|values
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|owi
operator|.
name|addCandidateFilterOp
argument_list|(
operator|(
name|FilterOperator
operator|)
name|op
argument_list|)
expr_stmt|;
block|}
block|}
name|logExpr
argument_list|(
name|nd
argument_list|,
name|ewi
argument_list|)
expr_stmt|;
name|owi
operator|.
name|putPrunedPreds
argument_list|(
operator|(
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
operator|)
name|nd
argument_list|,
name|ewi
argument_list|)
expr_stmt|;
block|}
comment|// merge it with children predicates
name|boolean
name|hasUnpushedPredicates
init|=
name|mergeWithChildrenPred
argument_list|(
name|nd
argument_list|,
name|owi
argument_list|,
name|ewi
argument_list|,
literal|null
argument_list|)
decl_stmt|;
if|if
condition|(
name|HiveConf
operator|.
name|getBoolVar
argument_list|(
name|owi
operator|.
name|getParseContext
argument_list|()
operator|.
name|getConf
argument_list|()
argument_list|,
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVEPPDREMOVEDUPLICATEFILTERS
argument_list|)
condition|)
block|{
if|if
condition|(
name|hasUnpushedPredicates
condition|)
block|{
name|ExprWalkerInfo
name|unpushedPreds
init|=
name|mergeChildrenPred
argument_list|(
name|nd
argument_list|,
name|owi
argument_list|,
literal|null
argument_list|,
literal|false
argument_list|)
decl_stmt|;
return|return
name|createFilter
argument_list|(
operator|(
name|Operator
operator|)
name|nd
argument_list|,
name|unpushedPreds
argument_list|,
name|owi
argument_list|)
return|;
block|}
block|}
return|return
literal|null
return|;
block|}
block|}
comment|/**    * Determines predicates for which alias can be pushed to it's parents. See    * the comments for getQualifiedAliases function.    */
specifier|public
specifier|static
class|class
name|JoinerPPD
extends|extends
name|DefaultPPD
implements|implements
name|NodeProcessor
block|{
annotation|@
name|Override
specifier|public
name|Object
name|process
parameter_list|(
name|Node
name|nd
parameter_list|,
name|Stack
argument_list|<
name|Node
argument_list|>
name|stack
parameter_list|,
name|NodeProcessorCtx
name|procCtx
parameter_list|,
name|Object
modifier|...
name|nodeOutputs
parameter_list|)
throws|throws
name|SemanticException
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Processing for "
operator|+
name|nd
operator|.
name|getName
argument_list|()
operator|+
literal|"("
operator|+
operator|(
operator|(
name|Operator
operator|)
name|nd
operator|)
operator|.
name|getIdentifier
argument_list|()
operator|+
literal|")"
argument_list|)
expr_stmt|;
name|OpWalkerInfo
name|owi
init|=
operator|(
name|OpWalkerInfo
operator|)
name|procCtx
decl_stmt|;
name|Set
argument_list|<
name|String
argument_list|>
name|aliases
init|=
name|getAliases
argument_list|(
name|nd
argument_list|,
name|owi
argument_list|)
decl_stmt|;
comment|// we pass null for aliases here because mergeWithChildrenPred filters
comment|// aliases in the children node context and we need to filter them in
comment|// the current JoinOperator's context
name|mergeWithChildrenPred
argument_list|(
name|nd
argument_list|,
name|owi
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
expr_stmt|;
name|ExprWalkerInfo
name|prunePreds
init|=
name|owi
operator|.
name|getPrunedPreds
argument_list|(
operator|(
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
operator|)
name|nd
argument_list|)
decl_stmt|;
if|if
condition|(
name|prunePreds
operator|!=
literal|null
condition|)
block|{
name|Set
argument_list|<
name|String
argument_list|>
name|toRemove
init|=
operator|new
name|HashSet
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
comment|// we don't push down any expressions that refer to aliases that can;t
comment|// be pushed down per getQualifiedAliases
for|for
control|(
name|String
name|key
range|:
name|prunePreds
operator|.
name|getFinalCandidates
argument_list|()
operator|.
name|keySet
argument_list|()
control|)
block|{
if|if
condition|(
operator|!
name|aliases
operator|.
name|contains
argument_list|(
name|key
argument_list|)
condition|)
block|{
name|toRemove
operator|.
name|add
argument_list|(
name|key
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
name|String
name|alias
range|:
name|toRemove
control|)
block|{
for|for
control|(
name|ExprNodeDesc
name|expr
range|:
name|prunePreds
operator|.
name|getFinalCandidates
argument_list|()
operator|.
name|get
argument_list|(
name|alias
argument_list|)
control|)
block|{
comment|// add expr to the list of predicates rejected from further pushing
comment|// so that we know to add it in createFilter()
name|prunePreds
operator|.
name|addAlias
argument_list|(
name|expr
argument_list|,
name|alias
argument_list|)
expr_stmt|;
name|prunePreds
operator|.
name|addNonFinalCandidate
argument_list|(
name|expr
argument_list|)
expr_stmt|;
block|}
name|prunePreds
operator|.
name|getFinalCandidates
argument_list|()
operator|.
name|remove
argument_list|(
name|alias
argument_list|)
expr_stmt|;
block|}
return|return
name|handlePredicates
argument_list|(
name|nd
argument_list|,
name|prunePreds
argument_list|,
name|owi
argument_list|)
return|;
block|}
return|return
literal|null
return|;
block|}
specifier|protected
name|Set
argument_list|<
name|String
argument_list|>
name|getAliases
parameter_list|(
name|Node
name|nd
parameter_list|,
name|OpWalkerInfo
name|owi
parameter_list|)
throws|throws
name|SemanticException
block|{
return|return
name|owi
operator|.
name|getRowResolver
argument_list|(
name|nd
argument_list|)
operator|.
name|getTableNames
argument_list|()
return|;
block|}
specifier|protected
name|Object
name|handlePredicates
parameter_list|(
name|Node
name|nd
parameter_list|,
name|ExprWalkerInfo
name|prunePreds
parameter_list|,
name|OpWalkerInfo
name|owi
parameter_list|)
throws|throws
name|SemanticException
block|{
if|if
condition|(
name|HiveConf
operator|.
name|getBoolVar
argument_list|(
name|owi
operator|.
name|getParseContext
argument_list|()
operator|.
name|getConf
argument_list|()
argument_list|,
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVEPPDREMOVEDUPLICATEFILTERS
argument_list|)
condition|)
block|{
return|return
name|createFilter
argument_list|(
operator|(
name|Operator
operator|)
name|nd
argument_list|,
name|prunePreds
operator|.
name|getResidualPredicates
argument_list|(
literal|true
argument_list|)
argument_list|,
name|owi
argument_list|)
return|;
block|}
return|return
literal|null
return|;
block|}
block|}
specifier|public
specifier|static
class|class
name|JoinPPD
extends|extends
name|JoinerPPD
block|{
annotation|@
name|Override
specifier|protected
name|Set
argument_list|<
name|String
argument_list|>
name|getAliases
parameter_list|(
name|Node
name|nd
parameter_list|,
name|OpWalkerInfo
name|owi
parameter_list|)
block|{
return|return
name|getQualifiedAliases
argument_list|(
operator|(
name|JoinOperator
operator|)
name|nd
argument_list|,
name|owi
operator|.
name|getRowResolver
argument_list|(
name|nd
argument_list|)
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|protected
name|Object
name|handlePredicates
parameter_list|(
name|Node
name|nd
parameter_list|,
name|ExprWalkerInfo
name|prunePreds
parameter_list|,
name|OpWalkerInfo
name|owi
parameter_list|)
throws|throws
name|SemanticException
block|{
if|if
condition|(
name|HiveConf
operator|.
name|getBoolVar
argument_list|(
name|owi
operator|.
name|getParseContext
argument_list|()
operator|.
name|getConf
argument_list|()
argument_list|,
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVEPPDRECOGNIZETRANSITIVITY
argument_list|)
condition|)
block|{
name|applyFilterTransitivity
argument_list|(
operator|(
name|JoinOperator
operator|)
name|nd
argument_list|,
name|owi
argument_list|)
expr_stmt|;
block|}
return|return
name|super
operator|.
name|handlePredicates
argument_list|(
name|nd
argument_list|,
name|prunePreds
argument_list|,
name|owi
argument_list|)
return|;
block|}
comment|/**      * Adds additional pushdown predicates for a join operator by replicating      * filters transitively over all the equijoin conditions.      *      * If we have a predicate "t.col=1" and the equijoin conditions      * "t.col=s.col" and "t.col=u.col", we add the filters "s.col=1" and      * "u.col=1". Note that this does not depend on the types of joins (ie.      * inner, left/right/full outer) between the tables s, t and u because if      * a predicate, eg. "t.col=1" is present in getFinalCandidates() at this      * point, we have already verified that it can be pushed down, so any rows      * emitted must satisfy s.col=t.col=u.col=1 and replicating the filters      * like this is ok.      */
specifier|private
name|void
name|applyFilterTransitivity
parameter_list|(
name|JoinOperator
name|nd
parameter_list|,
name|OpWalkerInfo
name|owi
parameter_list|)
throws|throws
name|SemanticException
block|{
name|ExprWalkerInfo
name|prunePreds
init|=
name|owi
operator|.
name|getPrunedPreds
argument_list|(
operator|(
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
operator|)
name|nd
argument_list|)
decl_stmt|;
if|if
condition|(
name|prunePreds
operator|!=
literal|null
condition|)
block|{
comment|// We want to use the row resolvers of the parents of the join op
comment|// because the rowresolver refers to the output columns of an operator
comment|// and the filters at this point refer to the input columns of the join
comment|// operator.
name|Map
argument_list|<
name|String
argument_list|,
name|RowResolver
argument_list|>
name|aliasToRR
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|RowResolver
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
name|o
range|:
operator|(
name|nd
operator|)
operator|.
name|getParentOperators
argument_list|()
control|)
block|{
for|for
control|(
name|String
name|alias
range|:
name|owi
operator|.
name|getRowResolver
argument_list|(
name|o
argument_list|)
operator|.
name|getTableNames
argument_list|()
control|)
block|{
name|aliasToRR
operator|.
name|put
argument_list|(
name|alias
argument_list|,
name|owi
operator|.
name|getRowResolver
argument_list|(
name|o
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|// eqExpressions is a list of ArrayList<ASTNode>'s, one for each table
comment|// in the join. Then for each i, j and k, the join condition is that
comment|// eqExpressions[i][k]=eqExpressions[j][k] (*) (ie. the columns referenced
comment|// by the corresponding ASTNodes are equal). For example, if the query
comment|// was SELECT * FROM a join b on a.col=b.col and a.col2=b.col2 left
comment|// outer join c on b.col=c.col and b.col2=c.col2 WHERE c.col=1,
comment|// eqExpressions would be [[a.col1, a.col2], [b.col1, b.col2],
comment|// [c.col1, c.col2]].
comment|//
comment|// numEqualities is the number of equal columns in each equality
comment|// "chain" and numColumns is the number of such chains.
comment|//
comment|// Note that (*) is guaranteed to be true for the
comment|// join operator: if the equijoin condititions can't be expressed in
comment|// these equal-length lists of equal columns (for example if we had the
comment|// query SELECT * FROM a join b on a.col=b.col and a.col2=b.col2 left
comment|// outer join c on b.col=c.col), more than one join operator is used.
name|ArrayList
argument_list|<
name|ArrayList
argument_list|<
name|ASTNode
argument_list|>
argument_list|>
name|eqExpressions
init|=
name|owi
operator|.
name|getParseContext
argument_list|()
operator|.
name|getJoinContext
argument_list|()
operator|.
name|get
argument_list|(
name|nd
argument_list|)
operator|.
name|getExpressions
argument_list|()
decl_stmt|;
name|int
name|numColumns
init|=
name|eqExpressions
operator|.
name|size
argument_list|()
decl_stmt|;
name|int
name|numEqualities
init|=
name|eqExpressions
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|size
argument_list|()
decl_stmt|;
comment|// joins[i] is the join between table i and i+1 in the JoinOperator
name|JoinCondDesc
index|[]
name|joins
init|=
operator|(
name|nd
operator|)
operator|.
name|getConf
argument_list|()
operator|.
name|getConds
argument_list|()
decl_stmt|;
comment|// oldFilters contains the filters to be pushed down
name|Map
argument_list|<
name|String
argument_list|,
name|List
argument_list|<
name|ExprNodeDesc
argument_list|>
argument_list|>
name|oldFilters
init|=
name|prunePreds
operator|.
name|getFinalCandidates
argument_list|()
decl_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|List
argument_list|<
name|ExprNodeDesc
argument_list|>
argument_list|>
name|newFilters
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|List
argument_list|<
name|ExprNodeDesc
argument_list|>
argument_list|>
argument_list|()
decl_stmt|;
comment|// We loop through for each chain of equalities
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numEqualities
condition|;
name|i
operator|++
control|)
block|{
comment|// equalColumns[i] is the ColumnInfo corresponding to the ith term
comment|// of the equality or null if the term is not a simple column
comment|// reference
name|ColumnInfo
index|[]
name|equalColumns
init|=
operator|new
name|ColumnInfo
index|[
name|numColumns
index|]
decl_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|numColumns
condition|;
name|j
operator|++
control|)
block|{
name|equalColumns
index|[
name|j
index|]
operator|=
name|getColumnInfoFromAST
argument_list|(
name|eqExpressions
operator|.
name|get
argument_list|(
name|j
argument_list|)
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|,
name|aliasToRR
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|numColumns
condition|;
name|j
operator|++
control|)
block|{
for|for
control|(
name|int
name|k
init|=
literal|0
init|;
name|k
operator|<
name|numColumns
condition|;
name|k
operator|++
control|)
block|{
if|if
condition|(
name|j
operator|!=
name|k
operator|&&
name|equalColumns
index|[
name|j
index|]
operator|!=
literal|null
operator|&&
name|equalColumns
index|[
name|k
index|]
operator|!=
literal|null
condition|)
block|{
comment|// terms j and k in the equality chain are simple columns,
comment|// so we can replace instances of column j with column k
comment|// in the filter and ad the replicated filter.
name|ColumnInfo
name|left
init|=
name|equalColumns
index|[
name|j
index|]
decl_stmt|;
name|ColumnInfo
name|right
init|=
name|equalColumns
index|[
name|k
index|]
decl_stmt|;
if|if
condition|(
name|oldFilters
operator|.
name|get
argument_list|(
name|left
operator|.
name|getTabAlias
argument_list|()
argument_list|)
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|ExprNodeDesc
name|expr
range|:
name|oldFilters
operator|.
name|get
argument_list|(
name|left
operator|.
name|getTabAlias
argument_list|()
argument_list|)
control|)
block|{
comment|// Only replicate the filter if there is exactly one column
comment|// referenced
name|Set
argument_list|<
name|String
argument_list|>
name|colsreferenced
init|=
operator|new
name|HashSet
argument_list|<
name|String
argument_list|>
argument_list|(
name|expr
operator|.
name|getCols
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|colsreferenced
operator|.
name|size
argument_list|()
operator|==
literal|1
operator|&&
name|colsreferenced
operator|.
name|contains
argument_list|(
name|left
operator|.
name|getInternalName
argument_list|()
argument_list|)
condition|)
block|{
name|ExprNodeDesc
name|newexpr
init|=
name|expr
operator|.
name|clone
argument_list|()
decl_stmt|;
comment|// Replace the column reference in the filter
name|replaceColumnReference
argument_list|(
name|newexpr
argument_list|,
name|left
operator|.
name|getInternalName
argument_list|()
argument_list|,
name|right
operator|.
name|getInternalName
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|newFilters
operator|.
name|get
argument_list|(
name|right
operator|.
name|getTabAlias
argument_list|()
argument_list|)
operator|==
literal|null
condition|)
block|{
name|newFilters
operator|.
name|put
argument_list|(
name|right
operator|.
name|getTabAlias
argument_list|()
argument_list|,
operator|new
name|ArrayList
argument_list|<
name|ExprNodeDesc
argument_list|>
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|newFilters
operator|.
name|get
argument_list|(
name|right
operator|.
name|getTabAlias
argument_list|()
argument_list|)
operator|.
name|add
argument_list|(
name|newexpr
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
block|}
block|}
for|for
control|(
name|Entry
argument_list|<
name|String
argument_list|,
name|List
argument_list|<
name|ExprNodeDesc
argument_list|>
argument_list|>
name|aliasToFilters
range|:
name|newFilters
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|owi
operator|.
name|getPrunedPreds
argument_list|(
operator|(
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
operator|)
name|nd
argument_list|)
operator|.
name|addPushDowns
argument_list|(
name|aliasToFilters
operator|.
name|getKey
argument_list|()
argument_list|,
name|aliasToFilters
operator|.
name|getValue
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**      * Replaces the ColumnInfo for the column referred to by an ASTNode      * representing "table.column" or null if the ASTNode is not in that form      */
specifier|private
name|ColumnInfo
name|getColumnInfoFromAST
parameter_list|(
name|ASTNode
name|nd
parameter_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|RowResolver
argument_list|>
name|aliastoRR
parameter_list|)
throws|throws
name|SemanticException
block|{
comment|// this bit is messy since we are parsing an ASTNode at this point
if|if
condition|(
name|nd
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|DOT
condition|)
block|{
if|if
condition|(
name|nd
operator|.
name|getChildCount
argument_list|()
operator|==
literal|2
condition|)
block|{
if|if
condition|(
name|nd
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_TABLE_OR_COL
operator|&&
name|nd
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getChildCount
argument_list|()
operator|==
literal|1
operator|&&
name|nd
operator|.
name|getChild
argument_list|(
literal|1
argument_list|)
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|Identifier
condition|)
block|{
comment|// We unescape the identifiers and make them lower case--this
comment|// really shouldn't be done here, but getExpressions gives us the
comment|// raw ASTNodes. The same thing is done in SemanticAnalyzer.
comment|// parseJoinCondPopulateAlias().
name|String
name|alias
init|=
name|BaseSemanticAnalyzer
operator|.
name|unescapeIdentifier
argument_list|(
name|nd
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getText
argument_list|()
operator|.
name|toLowerCase
argument_list|()
argument_list|)
decl_stmt|;
name|String
name|column
init|=
name|BaseSemanticAnalyzer
operator|.
name|unescapeIdentifier
argument_list|(
name|nd
operator|.
name|getChild
argument_list|(
literal|1
argument_list|)
operator|.
name|getText
argument_list|()
operator|.
name|toLowerCase
argument_list|()
argument_list|)
decl_stmt|;
name|RowResolver
name|rr
init|=
name|aliastoRR
operator|.
name|get
argument_list|(
name|alias
argument_list|)
decl_stmt|;
if|if
condition|(
name|rr
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
return|return
name|rr
operator|.
name|get
argument_list|(
name|alias
argument_list|,
name|column
argument_list|)
return|;
block|}
block|}
block|}
return|return
literal|null
return|;
block|}
comment|/**      * Replaces all instances of oldColumn with newColumn in the      * ExprColumnDesc's of the ExprNodeDesc      */
specifier|private
name|void
name|replaceColumnReference
parameter_list|(
name|ExprNodeDesc
name|expr
parameter_list|,
name|String
name|oldColumn
parameter_list|,
name|String
name|newColumn
parameter_list|)
block|{
if|if
condition|(
name|expr
operator|instanceof
name|ExprNodeColumnDesc
condition|)
block|{
if|if
condition|(
operator|(
operator|(
name|ExprNodeColumnDesc
operator|)
name|expr
operator|)
operator|.
name|getColumn
argument_list|()
operator|.
name|equals
argument_list|(
name|oldColumn
argument_list|)
condition|)
block|{
operator|(
operator|(
name|ExprNodeColumnDesc
operator|)
name|expr
operator|)
operator|.
name|setColumn
argument_list|(
name|newColumn
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|expr
operator|.
name|getChildren
argument_list|()
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|ExprNodeDesc
name|childexpr
range|:
name|expr
operator|.
name|getChildren
argument_list|()
control|)
block|{
name|replaceColumnReference
argument_list|(
name|childexpr
argument_list|,
name|oldColumn
argument_list|,
name|newColumn
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**      * Figures out the aliases for whom it is safe to push predicates based on      * ANSI SQL semantics. The join conditions are left associative so "a      * RIGHT OUTER JOIN b LEFT OUTER JOIN c INNER JOIN d" is interpreted as      * "((a RIGHT OUTER JOIN b) LEFT OUTER JOIN c) INNER JOIN d".  For inner      * joins, both the left and right join subexpressions are considered for      * pushing down aliases, for the right outer join, the right subexpression      * is considered and the left ignored and for the left outer join, the      * left subexpression is considered and the left ignored. Here, aliases b      * and d are eligible to be pushed up.      *      * TODO: further optimization opportunity for the case a.c1 = b.c1 and b.c2      * = c.c2 a and b are first joined and then the result with c. But the      * second join op currently treats a and b as separate aliases and thus      * disallowing predicate expr containing both tables a and b (such as a.c3      * + a.c4> 20). Such predicates also can be pushed just above the second      * join and below the first join      *      * @param op      *          Join Operator      * @param rr      *          Row resolver      * @return set of qualified aliases      */
specifier|private
name|Set
argument_list|<
name|String
argument_list|>
name|getQualifiedAliases
parameter_list|(
name|JoinOperator
name|op
parameter_list|,
name|RowResolver
name|rr
parameter_list|)
block|{
name|Set
argument_list|<
name|String
argument_list|>
name|aliases
init|=
operator|new
name|HashSet
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
name|JoinCondDesc
index|[]
name|conds
init|=
name|op
operator|.
name|getConf
argument_list|()
operator|.
name|getConds
argument_list|()
decl_stmt|;
name|Map
argument_list|<
name|Integer
argument_list|,
name|Set
argument_list|<
name|String
argument_list|>
argument_list|>
name|posToAliasMap
init|=
name|op
operator|.
name|getPosToAliasMap
argument_list|()
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|conds
operator|.
name|length
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|conds
index|[
name|i
index|]
operator|.
name|getType
argument_list|()
operator|==
name|JoinDesc
operator|.
name|INNER_JOIN
condition|)
block|{
name|aliases
operator|.
name|addAll
argument_list|(
name|posToAliasMap
operator|.
name|get
argument_list|(
name|i
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|conds
index|[
name|i
index|]
operator|.
name|getType
argument_list|()
operator|==
name|JoinDesc
operator|.
name|FULL_OUTER_JOIN
condition|)
block|{
break|break;
block|}
elseif|else
if|if
condition|(
name|conds
index|[
name|i
index|]
operator|.
name|getType
argument_list|()
operator|==
name|JoinDesc
operator|.
name|RIGHT_OUTER_JOIN
condition|)
block|{
name|aliases
operator|.
name|addAll
argument_list|(
name|posToAliasMap
operator|.
name|get
argument_list|(
name|i
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|conds
index|[
name|i
index|]
operator|.
name|getType
argument_list|()
operator|==
name|JoinDesc
operator|.
name|LEFT_OUTER_JOIN
condition|)
block|{
continue|continue;
block|}
block|}
if|if
condition|(
name|i
operator|==
operator|-
literal|1
condition|)
block|{
name|aliases
operator|.
name|addAll
argument_list|(
name|posToAliasMap
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|Set
argument_list|<
name|String
argument_list|>
name|aliases2
init|=
name|rr
operator|.
name|getTableNames
argument_list|()
decl_stmt|;
name|aliases
operator|.
name|retainAll
argument_list|(
name|aliases2
argument_list|)
expr_stmt|;
return|return
name|aliases
return|;
block|}
block|}
comment|/**    * Default processor which just merges its children.    */
specifier|public
specifier|static
class|class
name|DefaultPPD
implements|implements
name|NodeProcessor
block|{
annotation|@
name|Override
specifier|public
name|Object
name|process
parameter_list|(
name|Node
name|nd
parameter_list|,
name|Stack
argument_list|<
name|Node
argument_list|>
name|stack
parameter_list|,
name|NodeProcessorCtx
name|procCtx
parameter_list|,
name|Object
modifier|...
name|nodeOutputs
parameter_list|)
throws|throws
name|SemanticException
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Processing for "
operator|+
name|nd
operator|.
name|getName
argument_list|()
operator|+
literal|"("
operator|+
operator|(
operator|(
name|Operator
operator|)
name|nd
operator|)
operator|.
name|getIdentifier
argument_list|()
operator|+
literal|")"
argument_list|)
expr_stmt|;
name|OpWalkerInfo
name|owi
init|=
operator|(
name|OpWalkerInfo
operator|)
name|procCtx
decl_stmt|;
name|Set
argument_list|<
name|String
argument_list|>
name|includes
init|=
name|getQualifiedAliases
argument_list|(
operator|(
name|Operator
argument_list|<
name|?
argument_list|>
operator|)
name|nd
argument_list|,
name|owi
argument_list|)
decl_stmt|;
name|boolean
name|hasUnpushedPredicates
init|=
name|mergeWithChildrenPred
argument_list|(
name|nd
argument_list|,
name|owi
argument_list|,
literal|null
argument_list|,
name|includes
argument_list|)
decl_stmt|;
if|if
condition|(
name|hasUnpushedPredicates
operator|&&
name|HiveConf
operator|.
name|getBoolVar
argument_list|(
name|owi
operator|.
name|getParseContext
argument_list|()
operator|.
name|getConf
argument_list|()
argument_list|,
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVEPPDREMOVEDUPLICATEFILTERS
argument_list|)
condition|)
block|{
if|if
condition|(
name|includes
operator|!=
literal|null
operator|||
name|nd
operator|instanceof
name|ReduceSinkOperator
condition|)
block|{
name|owi
operator|.
name|getCandidateFilterOps
argument_list|()
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|ExprWalkerInfo
name|pruned
init|=
name|owi
operator|.
name|getPrunedPreds
argument_list|(
operator|(
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
operator|)
name|nd
argument_list|)
decl_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|List
argument_list|<
name|ExprNodeDesc
argument_list|>
argument_list|>
name|residual
init|=
name|pruned
operator|.
name|getResidualPredicates
argument_list|(
literal|true
argument_list|)
decl_stmt|;
if|if
condition|(
name|residual
operator|!=
literal|null
operator|&&
operator|!
name|residual
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|createFilter
argument_list|(
operator|(
name|Operator
operator|)
name|nd
argument_list|,
name|residual
argument_list|,
name|owi
argument_list|)
expr_stmt|;
name|pruned
operator|.
name|getNonFinalCandidates
argument_list|()
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
block|}
block|}
return|return
literal|null
return|;
block|}
comment|// RS for join, SEL(*) for lateral view
comment|// SEL for union does not count (should be copied to both sides)
specifier|private
name|Set
argument_list|<
name|String
argument_list|>
name|getQualifiedAliases
parameter_list|(
name|Operator
argument_list|<
name|?
argument_list|>
name|operator
parameter_list|,
name|OpWalkerInfo
name|owi
parameter_list|)
block|{
if|if
condition|(
name|operator
operator|.
name|getNumChild
argument_list|()
operator|!=
literal|1
condition|)
block|{
return|return
literal|null
return|;
block|}
name|Operator
argument_list|<
name|?
argument_list|>
name|child
init|=
name|operator
operator|.
name|getChildOperators
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|child
operator|instanceof
name|JoinOperator
operator|||
name|child
operator|instanceof
name|LateralViewJoinOperator
operator|)
condition|)
block|{
return|return
literal|null
return|;
block|}
if|if
condition|(
name|operator
operator|instanceof
name|ReduceSinkOperator
operator|&&
operator|(
operator|(
name|ReduceSinkOperator
operator|)
name|operator
operator|)
operator|.
name|getInputAliases
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|String
index|[]
name|aliases
init|=
operator|(
operator|(
name|ReduceSinkOperator
operator|)
name|operator
operator|)
operator|.
name|getInputAliases
argument_list|()
decl_stmt|;
return|return
operator|new
name|HashSet
argument_list|<
name|String
argument_list|>
argument_list|(
name|Arrays
operator|.
name|asList
argument_list|(
name|aliases
argument_list|)
argument_list|)
return|;
block|}
name|Set
argument_list|<
name|String
argument_list|>
name|includes
init|=
name|owi
operator|.
name|getRowResolver
argument_list|(
name|operator
argument_list|)
operator|.
name|getTableNames
argument_list|()
decl_stmt|;
if|if
condition|(
name|includes
operator|.
name|size
argument_list|()
operator|==
literal|1
operator|&&
name|includes
operator|.
name|contains
argument_list|(
literal|""
argument_list|)
condition|)
block|{
comment|// Reduce sink of group by operator
return|return
literal|null
return|;
block|}
return|return
name|includes
return|;
block|}
comment|/**      * @param nd      * @param ewi      */
specifier|protected
name|void
name|logExpr
parameter_list|(
name|Node
name|nd
parameter_list|,
name|ExprWalkerInfo
name|ewi
parameter_list|)
block|{
for|for
control|(
name|Entry
argument_list|<
name|String
argument_list|,
name|List
argument_list|<
name|ExprNodeDesc
argument_list|>
argument_list|>
name|e
range|:
name|ewi
operator|.
name|getFinalCandidates
argument_list|()
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Pushdown Predicates of "
operator|+
name|nd
operator|.
name|getName
argument_list|()
operator|+
literal|" For Alias : "
operator|+
name|e
operator|.
name|getKey
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|ExprNodeDesc
name|n
range|:
name|e
operator|.
name|getValue
argument_list|()
control|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"\t"
operator|+
name|n
operator|.
name|getExprString
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**      * Take current operators pushdown predicates and merges them with      * children's pushdown predicates.      *      * @param nd      *          current operator      * @param owi      *          operator context during this walk      * @param ewi      *          pushdown predicates (part of expression walker info)      * @param aliases      *          aliases that this operator can pushdown. null means that all      *          aliases can be pushed down      * @throws SemanticException      */
specifier|protected
name|boolean
name|mergeWithChildrenPred
parameter_list|(
name|Node
name|nd
parameter_list|,
name|OpWalkerInfo
name|owi
parameter_list|,
name|ExprWalkerInfo
name|ewi
parameter_list|,
name|Set
argument_list|<
name|String
argument_list|>
name|aliases
parameter_list|)
throws|throws
name|SemanticException
block|{
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
name|op
init|=
operator|(
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
operator|)
name|nd
decl_stmt|;
name|ExprWalkerInfo
name|childPreds
init|=
name|getChildWalkerInfo
argument_list|(
name|op
argument_list|,
name|owi
argument_list|)
decl_stmt|;
if|if
condition|(
name|childPreds
operator|==
literal|null
condition|)
block|{
return|return
literal|false
return|;
block|}
if|if
condition|(
name|ewi
operator|==
literal|null
condition|)
block|{
name|ewi
operator|=
operator|new
name|ExprWalkerInfo
argument_list|()
expr_stmt|;
block|}
name|boolean
name|hasUnpushedPredicates
init|=
literal|false
decl_stmt|;
for|for
control|(
name|Entry
argument_list|<
name|String
argument_list|,
name|List
argument_list|<
name|ExprNodeDesc
argument_list|>
argument_list|>
name|e
range|:
name|childPreds
operator|.
name|getFinalCandidates
argument_list|()
operator|.
name|entrySet
argument_list|()
control|)
block|{
if|if
condition|(
name|aliases
operator|==
literal|null
operator|||
name|e
operator|.
name|getKey
argument_list|()
operator|==
literal|null
operator|||
name|aliases
operator|.
name|contains
argument_list|(
name|e
operator|.
name|getKey
argument_list|()
argument_list|)
condition|)
block|{
comment|// e.getKey() (alias) can be null in case of constant expressions. see
comment|// input8.q
name|ExprWalkerInfo
name|extractPushdownPreds
init|=
name|ExprWalkerProcFactory
operator|.
name|extractPushdownPreds
argument_list|(
name|owi
argument_list|,
name|op
argument_list|,
name|e
operator|.
name|getValue
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|extractPushdownPreds
operator|.
name|getNonFinalCandidates
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|hasUnpushedPredicates
operator|=
literal|true
expr_stmt|;
block|}
name|ewi
operator|.
name|merge
argument_list|(
name|extractPushdownPreds
argument_list|)
expr_stmt|;
name|logExpr
argument_list|(
name|nd
argument_list|,
name|extractPushdownPreds
argument_list|)
expr_stmt|;
block|}
block|}
name|owi
operator|.
name|putPrunedPreds
argument_list|(
operator|(
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
operator|)
name|nd
argument_list|,
name|ewi
argument_list|)
expr_stmt|;
return|return
name|hasUnpushedPredicates
return|;
block|}
specifier|protected
name|ExprWalkerInfo
name|mergeChildrenPred
parameter_list|(
name|Node
name|nd
parameter_list|,
name|OpWalkerInfo
name|owi
parameter_list|,
name|Set
argument_list|<
name|String
argument_list|>
name|excludedAliases
parameter_list|,
name|boolean
name|ignoreAliases
parameter_list|)
throws|throws
name|SemanticException
block|{
if|if
condition|(
name|nd
operator|.
name|getChildren
argument_list|()
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
name|op
init|=
operator|(
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
operator|)
name|nd
decl_stmt|;
name|ExprWalkerInfo
name|ewi
init|=
operator|new
name|ExprWalkerInfo
argument_list|()
decl_stmt|;
for|for
control|(
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
name|child
range|:
name|op
operator|.
name|getChildOperators
argument_list|()
control|)
block|{
name|ExprWalkerInfo
name|childPreds
init|=
name|owi
operator|.
name|getPrunedPreds
argument_list|(
name|child
argument_list|)
decl_stmt|;
if|if
condition|(
name|childPreds
operator|==
literal|null
condition|)
block|{
continue|continue;
block|}
for|for
control|(
name|Entry
argument_list|<
name|String
argument_list|,
name|List
argument_list|<
name|ExprNodeDesc
argument_list|>
argument_list|>
name|e
range|:
name|childPreds
operator|.
name|getFinalCandidates
argument_list|()
operator|.
name|entrySet
argument_list|()
control|)
block|{
if|if
condition|(
name|ignoreAliases
operator|||
name|excludedAliases
operator|==
literal|null
operator|||
operator|!
name|excludedAliases
operator|.
name|contains
argument_list|(
name|e
operator|.
name|getKey
argument_list|()
argument_list|)
operator|||
name|e
operator|.
name|getKey
argument_list|()
operator|==
literal|null
condition|)
block|{
name|ewi
operator|.
name|addPushDowns
argument_list|(
name|e
operator|.
name|getKey
argument_list|()
argument_list|,
name|e
operator|.
name|getValue
argument_list|()
argument_list|)
expr_stmt|;
name|logExpr
argument_list|(
name|nd
argument_list|,
name|ewi
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
name|ewi
return|;
block|}
block|}
specifier|protected
specifier|static
name|Object
name|createFilter
parameter_list|(
name|Operator
name|op
parameter_list|,
name|ExprWalkerInfo
name|pushDownPreds
parameter_list|,
name|OpWalkerInfo
name|owi
parameter_list|)
block|{
if|if
condition|(
name|pushDownPreds
operator|==
literal|null
operator|||
name|pushDownPreds
operator|.
name|getFinalCandidates
argument_list|()
operator|==
literal|null
operator|||
name|pushDownPreds
operator|.
name|getFinalCandidates
argument_list|()
operator|.
name|size
argument_list|()
operator|==
literal|0
condition|)
block|{
return|return
literal|null
return|;
block|}
return|return
name|createFilter
argument_list|(
name|op
argument_list|,
name|pushDownPreds
operator|.
name|getFinalCandidates
argument_list|()
argument_list|,
name|owi
argument_list|)
return|;
block|}
specifier|protected
specifier|static
name|Object
name|createFilter
parameter_list|(
name|Operator
name|op
parameter_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|List
argument_list|<
name|ExprNodeDesc
argument_list|>
argument_list|>
name|predicates
parameter_list|,
name|OpWalkerInfo
name|owi
parameter_list|)
block|{
name|RowResolver
name|inputRR
init|=
name|owi
operator|.
name|getRowResolver
argument_list|(
name|op
argument_list|)
decl_stmt|;
comment|// combine all predicates into a single expression
name|List
argument_list|<
name|ExprNodeDesc
argument_list|>
name|preds
init|=
operator|new
name|ArrayList
argument_list|<
name|ExprNodeDesc
argument_list|>
argument_list|()
decl_stmt|;
name|Iterator
argument_list|<
name|List
argument_list|<
name|ExprNodeDesc
argument_list|>
argument_list|>
name|iterator
init|=
name|predicates
operator|.
name|values
argument_list|()
operator|.
name|iterator
argument_list|()
decl_stmt|;
while|while
condition|(
name|iterator
operator|.
name|hasNext
argument_list|()
condition|)
block|{
for|for
control|(
name|ExprNodeDesc
name|pred
range|:
name|iterator
operator|.
name|next
argument_list|()
control|)
block|{
name|preds
operator|=
name|ExprNodeDescUtils
operator|.
name|split
argument_list|(
name|pred
argument_list|,
name|preds
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|preds
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return
literal|null
return|;
block|}
name|ExprNodeDesc
name|condn
init|=
name|ExprNodeDescUtils
operator|.
name|mergePredicates
argument_list|(
name|preds
argument_list|)
decl_stmt|;
if|if
condition|(
name|op
operator|instanceof
name|TableScanOperator
operator|&&
name|condn
operator|instanceof
name|ExprNodeGenericFuncDesc
condition|)
block|{
name|boolean
name|pushFilterToStorage
decl_stmt|;
name|HiveConf
name|hiveConf
init|=
name|owi
operator|.
name|getParseContext
argument_list|()
operator|.
name|getConf
argument_list|()
decl_stmt|;
name|pushFilterToStorage
operator|=
name|hiveConf
operator|.
name|getBoolVar
argument_list|(
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVEOPTPPD_STORAGE
argument_list|)
expr_stmt|;
if|if
condition|(
name|pushFilterToStorage
condition|)
block|{
name|condn
operator|=
name|pushFilterToStorageHandler
argument_list|(
operator|(
name|TableScanOperator
operator|)
name|op
argument_list|,
operator|(
name|ExprNodeGenericFuncDesc
operator|)
name|condn
argument_list|,
name|owi
argument_list|,
name|hiveConf
argument_list|)
expr_stmt|;
if|if
condition|(
name|condn
operator|==
literal|null
condition|)
block|{
comment|// we pushed the whole thing down
return|return
literal|null
return|;
block|}
block|}
block|}
comment|// add new filter op
name|List
argument_list|<
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
argument_list|>
name|originalChilren
init|=
name|op
operator|.
name|getChildOperators
argument_list|()
decl_stmt|;
name|op
operator|.
name|setChildOperators
argument_list|(
literal|null
argument_list|)
expr_stmt|;
name|Operator
argument_list|<
name|FilterDesc
argument_list|>
name|output
init|=
name|OperatorFactory
operator|.
name|getAndMakeChild
argument_list|(
operator|new
name|FilterDesc
argument_list|(
name|condn
argument_list|,
literal|false
argument_list|)
argument_list|,
operator|new
name|RowSchema
argument_list|(
name|inputRR
operator|.
name|getColumnInfos
argument_list|()
argument_list|)
argument_list|,
name|op
argument_list|)
decl_stmt|;
name|output
operator|.
name|setChildOperators
argument_list|(
name|originalChilren
argument_list|)
expr_stmt|;
for|for
control|(
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
name|ch
range|:
name|originalChilren
control|)
block|{
name|List
argument_list|<
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
argument_list|>
name|parentOperators
init|=
name|ch
operator|.
name|getParentOperators
argument_list|()
decl_stmt|;
name|int
name|pos
init|=
name|parentOperators
operator|.
name|indexOf
argument_list|(
name|op
argument_list|)
decl_stmt|;
assert|assert
name|pos
operator|!=
operator|-
literal|1
assert|;
name|parentOperators
operator|.
name|remove
argument_list|(
name|pos
argument_list|)
expr_stmt|;
name|parentOperators
operator|.
name|add
argument_list|(
name|pos
argument_list|,
name|output
argument_list|)
expr_stmt|;
comment|// add the new op as the old
block|}
name|OpParseContext
name|ctx
init|=
operator|new
name|OpParseContext
argument_list|(
name|inputRR
argument_list|)
decl_stmt|;
name|owi
operator|.
name|put
argument_list|(
name|output
argument_list|,
name|ctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|HiveConf
operator|.
name|getBoolVar
argument_list|(
name|owi
operator|.
name|getParseContext
argument_list|()
operator|.
name|getConf
argument_list|()
argument_list|,
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVEPPDREMOVEDUPLICATEFILTERS
argument_list|)
condition|)
block|{
comment|// remove the candidate filter ops
for|for
control|(
name|FilterOperator
name|fop
range|:
name|owi
operator|.
name|getCandidateFilterOps
argument_list|()
control|)
block|{
name|List
argument_list|<
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
argument_list|>
name|children
init|=
name|fop
operator|.
name|getChildOperators
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
argument_list|>
name|parents
init|=
name|fop
operator|.
name|getParentOperators
argument_list|()
decl_stmt|;
for|for
control|(
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
name|parent
range|:
name|parents
control|)
block|{
name|parent
operator|.
name|getChildOperators
argument_list|()
operator|.
name|addAll
argument_list|(
name|children
argument_list|)
expr_stmt|;
name|parent
operator|.
name|removeChild
argument_list|(
name|fop
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
name|child
range|:
name|children
control|)
block|{
name|child
operator|.
name|getParentOperators
argument_list|()
operator|.
name|addAll
argument_list|(
name|parents
argument_list|)
expr_stmt|;
name|child
operator|.
name|removeParent
argument_list|(
name|fop
argument_list|)
expr_stmt|;
block|}
block|}
name|owi
operator|.
name|getCandidateFilterOps
argument_list|()
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
comment|// push down current ppd context to newly added filter
name|ExprWalkerInfo
name|walkerInfo
init|=
name|owi
operator|.
name|getPrunedPreds
argument_list|(
name|op
argument_list|)
decl_stmt|;
if|if
condition|(
name|walkerInfo
operator|!=
literal|null
condition|)
block|{
name|walkerInfo
operator|.
name|getNonFinalCandidates
argument_list|()
operator|.
name|clear
argument_list|()
expr_stmt|;
name|owi
operator|.
name|putPrunedPreds
argument_list|(
name|output
argument_list|,
name|walkerInfo
argument_list|)
expr_stmt|;
block|}
return|return
name|output
return|;
block|}
comment|/**    * Attempts to push a predicate down into a storage handler.  For    * native tables, this is a no-op.    *    * @param tableScanOp table scan against which predicate applies    *    * @param originalPredicate predicate to be pushed down    *    * @param owi object walk info    *    * @param hiveConf Hive configuration    *    * @return portion of predicate which needs to be evaluated    * by Hive as a post-filter, or null if it was possible    * to push down the entire predicate    */
specifier|private
specifier|static
name|ExprNodeGenericFuncDesc
name|pushFilterToStorageHandler
parameter_list|(
name|TableScanOperator
name|tableScanOp
parameter_list|,
name|ExprNodeGenericFuncDesc
name|originalPredicate
parameter_list|,
name|OpWalkerInfo
name|owi
parameter_list|,
name|HiveConf
name|hiveConf
parameter_list|)
block|{
name|TableScanDesc
name|tableScanDesc
init|=
name|tableScanOp
operator|.
name|getConf
argument_list|()
decl_stmt|;
name|Table
name|tbl
init|=
name|owi
operator|.
name|getParseContext
argument_list|()
operator|.
name|getTopToTable
argument_list|()
operator|.
name|get
argument_list|(
name|tableScanOp
argument_list|)
decl_stmt|;
if|if
condition|(
name|HiveConf
operator|.
name|getBoolVar
argument_list|(
name|hiveConf
argument_list|,
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVEOPTINDEXFILTER
argument_list|)
condition|)
block|{
comment|// attach the original predicate to the table scan operator for index
comment|// optimizations that require the pushed predicate before pcr& later
comment|// optimizations are applied
name|tableScanDesc
operator|.
name|setFilterExpr
argument_list|(
name|originalPredicate
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|tbl
operator|.
name|isNonNative
argument_list|()
condition|)
block|{
return|return
name|originalPredicate
return|;
block|}
name|HiveStorageHandler
name|storageHandler
init|=
name|tbl
operator|.
name|getStorageHandler
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|storageHandler
operator|instanceof
name|HiveStoragePredicateHandler
operator|)
condition|)
block|{
comment|// The storage handler does not provide predicate decomposition
comment|// support, so we'll implement the entire filter in Hive.  However,
comment|// we still provide the full predicate to the storage handler in
comment|// case it wants to do any of its own prefiltering.
name|tableScanDesc
operator|.
name|setFilterExpr
argument_list|(
name|originalPredicate
argument_list|)
expr_stmt|;
return|return
name|originalPredicate
return|;
block|}
name|HiveStoragePredicateHandler
name|predicateHandler
init|=
operator|(
name|HiveStoragePredicateHandler
operator|)
name|storageHandler
decl_stmt|;
name|JobConf
name|jobConf
init|=
operator|new
name|JobConf
argument_list|(
name|owi
operator|.
name|getParseContext
argument_list|()
operator|.
name|getConf
argument_list|()
argument_list|)
decl_stmt|;
name|Utilities
operator|.
name|setColumnNameList
argument_list|(
name|jobConf
argument_list|,
name|tableScanOp
argument_list|)
expr_stmt|;
name|Utilities
operator|.
name|setColumnTypeList
argument_list|(
name|jobConf
argument_list|,
name|tableScanOp
argument_list|)
expr_stmt|;
name|Utilities
operator|.
name|copyTableJobPropertiesToConf
argument_list|(
name|Utilities
operator|.
name|getTableDesc
argument_list|(
name|tbl
argument_list|)
argument_list|,
name|jobConf
argument_list|)
expr_stmt|;
name|Deserializer
name|deserializer
init|=
name|tbl
operator|.
name|getDeserializer
argument_list|()
decl_stmt|;
name|HiveStoragePredicateHandler
operator|.
name|DecomposedPredicate
name|decomposed
init|=
name|predicateHandler
operator|.
name|decomposePredicate
argument_list|(
name|jobConf
argument_list|,
name|deserializer
argument_list|,
name|originalPredicate
argument_list|)
decl_stmt|;
if|if
condition|(
name|decomposed
operator|==
literal|null
condition|)
block|{
comment|// not able to push anything down
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"No pushdown possible for predicate:  "
operator|+
name|originalPredicate
operator|.
name|getExprString
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|originalPredicate
return|;
block|}
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Original predicate:  "
operator|+
name|originalPredicate
operator|.
name|getExprString
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|decomposed
operator|.
name|pushedPredicate
operator|!=
literal|null
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Pushed predicate:  "
operator|+
name|decomposed
operator|.
name|pushedPredicate
operator|.
name|getExprString
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|decomposed
operator|.
name|residualPredicate
operator|!=
literal|null
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Residual predicate:  "
operator|+
name|decomposed
operator|.
name|residualPredicate
operator|.
name|getExprString
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
name|tableScanDesc
operator|.
name|setFilterExpr
argument_list|(
name|decomposed
operator|.
name|pushedPredicate
argument_list|)
expr_stmt|;
name|tableScanDesc
operator|.
name|setFilterObject
argument_list|(
name|decomposed
operator|.
name|pushedPredicateObject
argument_list|)
expr_stmt|;
return|return
name|decomposed
operator|.
name|residualPredicate
return|;
block|}
specifier|public
specifier|static
name|NodeProcessor
name|getFilterProc
parameter_list|()
block|{
return|return
operator|new
name|FilterPPD
argument_list|()
return|;
block|}
specifier|public
specifier|static
name|NodeProcessor
name|getJoinProc
parameter_list|()
block|{
return|return
operator|new
name|JoinPPD
argument_list|()
return|;
block|}
specifier|public
specifier|static
name|NodeProcessor
name|getTSProc
parameter_list|()
block|{
return|return
operator|new
name|TableScanPPD
argument_list|()
return|;
block|}
specifier|public
specifier|static
name|NodeProcessor
name|getDefaultProc
parameter_list|()
block|{
return|return
operator|new
name|DefaultPPD
argument_list|()
return|;
block|}
specifier|public
specifier|static
name|NodeProcessor
name|getPTFProc
parameter_list|()
block|{
return|return
operator|new
name|PTFPPD
argument_list|()
return|;
block|}
specifier|public
specifier|static
name|NodeProcessor
name|getSCRProc
parameter_list|()
block|{
return|return
operator|new
name|ScriptPPD
argument_list|()
return|;
block|}
specifier|public
specifier|static
name|NodeProcessor
name|getLIMProc
parameter_list|()
block|{
return|return
operator|new
name|ScriptPPD
argument_list|()
return|;
block|}
specifier|public
specifier|static
name|NodeProcessor
name|getLVFProc
parameter_list|()
block|{
return|return
operator|new
name|LateralViewForwardPPD
argument_list|()
return|;
block|}
specifier|public
specifier|static
name|NodeProcessor
name|getUDTFProc
parameter_list|()
block|{
return|return
operator|new
name|UDTFPPD
argument_list|()
return|;
block|}
specifier|public
specifier|static
name|NodeProcessor
name|getLVJProc
parameter_list|()
block|{
return|return
operator|new
name|JoinerPPD
argument_list|()
return|;
block|}
specifier|private
name|OpProcFactory
parameter_list|()
block|{
comment|// prevent instantiation
block|}
block|}
end_class

end_unit

