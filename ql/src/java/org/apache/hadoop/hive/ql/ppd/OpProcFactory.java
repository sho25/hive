begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|ppd
package|;
end_package

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
operator|.
name|Entry
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Stack
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|Log
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|LogFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|conf
operator|.
name|HiveConf
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|FilterOperator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|JoinOperator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|LateralViewJoinOperator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|Operator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|OperatorFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|PTFOperator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|ReduceSinkOperator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|RowSchema
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|TableScanOperator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|Utilities
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|lib
operator|.
name|Node
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|lib
operator|.
name|NodeProcessor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|lib
operator|.
name|NodeProcessorCtx
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|metadata
operator|.
name|HiveStorageHandler
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|metadata
operator|.
name|HiveStoragePredicateHandler
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|metadata
operator|.
name|Table
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|parse
operator|.
name|SemanticException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|parse
operator|.
name|WindowingSpec
operator|.
name|Direction
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|ExprNodeColumnDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|ExprNodeConstantDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|ExprNodeDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|ExprNodeDescUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|ExprNodeGenericFuncDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|FilterDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|JoinCondDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|JoinDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|OperatorDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|PTFDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|ReduceSinkDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|TableScanDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|ptf
operator|.
name|BoundaryDef
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|ptf
operator|.
name|ValueBoundaryDef
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|ptf
operator|.
name|WindowFrameDef
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|ptf
operator|.
name|WindowFunctionDef
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|ptf
operator|.
name|WindowTableFunctionDef
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|udf
operator|.
name|generic
operator|.
name|GenericUDAFDenseRank
operator|.
name|GenericUDAFDenseRankEvaluator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|udf
operator|.
name|generic
operator|.
name|GenericUDAFLead
operator|.
name|GenericUDAFLeadEvaluator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|udf
operator|.
name|generic
operator|.
name|GenericUDAFRank
operator|.
name|GenericUDAFRankEvaluator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|udf
operator|.
name|generic
operator|.
name|GenericUDFOPEqualOrLessThan
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|udf
operator|.
name|generic
operator|.
name|GenericUDFOPLessThan
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|Deserializer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|typeinfo
operator|.
name|TypeInfoFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapred
operator|.
name|JobConf
import|;
end_import

begin_comment
comment|/**  * Operator factory for predicate pushdown processing of operator graph Each  * operator determines the pushdown predicates by walking the expression tree.  * Each operator merges its own pushdown predicates with those of its children  * Finally the TableScan operator gathers all the predicates and inserts a  * filter operator after itself. TODO: Further optimizations 1) Multi-insert  * case 2) Create a filter operator for those predicates that couldn't be pushed  * to the previous operators in the data flow 3) Merge multiple sequential  * filter predicates into so that plans are more readable 4) Remove predicates  * from filter operators that have been pushed. Currently these pushed  * predicates are evaluated twice.  */
end_comment

begin_class
specifier|public
specifier|final
class|class
name|OpProcFactory
block|{
specifier|protected
specifier|static
specifier|final
name|Log
name|LOG
init|=
name|LogFactory
operator|.
name|getLog
argument_list|(
name|OpProcFactory
operator|.
name|class
operator|.
name|getName
argument_list|()
argument_list|)
decl_stmt|;
specifier|private
specifier|static
name|ExprWalkerInfo
name|getChildWalkerInfo
parameter_list|(
name|Operator
argument_list|<
name|?
argument_list|>
name|current
parameter_list|,
name|OpWalkerInfo
name|owi
parameter_list|)
block|{
if|if
condition|(
name|current
operator|.
name|getNumChild
argument_list|()
operator|==
literal|0
condition|)
block|{
return|return
literal|null
return|;
block|}
if|if
condition|(
name|current
operator|.
name|getNumChild
argument_list|()
operator|>
literal|1
condition|)
block|{
comment|// ppd for multi-insert query is not yet implemented
comment|// no-op for leafs
for|for
control|(
name|Operator
argument_list|<
name|?
argument_list|>
name|child
range|:
name|current
operator|.
name|getChildOperators
argument_list|()
control|)
block|{
name|removeCandidates
argument_list|(
name|child
argument_list|,
name|owi
argument_list|)
expr_stmt|;
comment|// remove candidated filters on this branch
block|}
return|return
literal|null
return|;
block|}
return|return
name|owi
operator|.
name|getPrunedPreds
argument_list|(
name|current
operator|.
name|getChildOperators
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|)
return|;
block|}
specifier|private
specifier|static
name|void
name|removeCandidates
parameter_list|(
name|Operator
argument_list|<
name|?
argument_list|>
name|operator
parameter_list|,
name|OpWalkerInfo
name|owi
parameter_list|)
block|{
if|if
condition|(
name|operator
operator|instanceof
name|FilterOperator
condition|)
block|{
name|owi
operator|.
name|getCandidateFilterOps
argument_list|()
operator|.
name|remove
argument_list|(
name|operator
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|operator
operator|.
name|getChildOperators
argument_list|()
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|Operator
argument_list|<
name|?
argument_list|>
name|child
range|:
name|operator
operator|.
name|getChildOperators
argument_list|()
control|)
block|{
name|removeCandidates
argument_list|(
name|child
argument_list|,
name|owi
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**    * Processor for Script Operator Prevents any predicates being pushed.    */
specifier|public
specifier|static
class|class
name|ScriptPPD
extends|extends
name|DefaultPPD
implements|implements
name|NodeProcessor
block|{
annotation|@
name|Override
specifier|public
name|Object
name|process
parameter_list|(
name|Node
name|nd
parameter_list|,
name|Stack
argument_list|<
name|Node
argument_list|>
name|stack
parameter_list|,
name|NodeProcessorCtx
name|procCtx
parameter_list|,
name|Object
modifier|...
name|nodeOutputs
parameter_list|)
throws|throws
name|SemanticException
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Processing for "
operator|+
name|nd
operator|.
name|getName
argument_list|()
operator|+
literal|"("
operator|+
operator|(
operator|(
name|Operator
operator|)
name|nd
operator|)
operator|.
name|getIdentifier
argument_list|()
operator|+
literal|")"
argument_list|)
expr_stmt|;
comment|// script operator is a black-box to hive so no optimization here
comment|// assuming that nothing can be pushed above the script op
comment|// same with LIMIT op
comment|// create a filter with all children predicates
name|OpWalkerInfo
name|owi
init|=
operator|(
name|OpWalkerInfo
operator|)
name|procCtx
decl_stmt|;
name|ExprWalkerInfo
name|childInfo
init|=
name|getChildWalkerInfo
argument_list|(
operator|(
name|Operator
argument_list|<
name|?
argument_list|>
operator|)
name|nd
argument_list|,
name|owi
argument_list|)
decl_stmt|;
if|if
condition|(
name|childInfo
operator|!=
literal|null
operator|&&
name|HiveConf
operator|.
name|getBoolVar
argument_list|(
name|owi
operator|.
name|getParseContext
argument_list|()
operator|.
name|getConf
argument_list|()
argument_list|,
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVEPPDREMOVEDUPLICATEFILTERS
argument_list|)
condition|)
block|{
name|ExprWalkerInfo
name|unpushedPreds
init|=
name|mergeChildrenPred
argument_list|(
name|nd
argument_list|,
name|owi
argument_list|,
literal|null
argument_list|,
literal|false
argument_list|)
decl_stmt|;
return|return
name|createFilter
argument_list|(
operator|(
name|Operator
operator|)
name|nd
argument_list|,
name|unpushedPreds
argument_list|,
name|owi
argument_list|)
return|;
block|}
return|return
literal|null
return|;
block|}
block|}
specifier|public
specifier|static
class|class
name|PTFPPD
extends|extends
name|ScriptPPD
block|{
comment|/*      * For WindowingTableFunction if:      * a. there is a Rank/DenseRank function: if there are unpushedPred of the form      *    rnkValue< Constant; then use the smallest Constant val as the 'rankLimit'      *    on the WindowingTablFn.      * b. If there are no Wdw Fns with an End Boundary past the current row, the      *    condition can be pushed down as a limit pushdown(mapGroupBy=true)      *      * (non-Javadoc)      * @see org.apache.hadoop.hive.ql.ppd.OpProcFactory.ScriptPPD#process(org.apache.hadoop.hive.ql.lib.Node, java.util.Stack, org.apache.hadoop.hive.ql.lib.NodeProcessorCtx, java.lang.Object[])      */
annotation|@
name|Override
specifier|public
name|Object
name|process
parameter_list|(
name|Node
name|nd
parameter_list|,
name|Stack
argument_list|<
name|Node
argument_list|>
name|stack
parameter_list|,
name|NodeProcessorCtx
name|procCtx
parameter_list|,
name|Object
modifier|...
name|nodeOutputs
parameter_list|)
throws|throws
name|SemanticException
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Processing for "
operator|+
name|nd
operator|.
name|getName
argument_list|()
operator|+
literal|"("
operator|+
operator|(
operator|(
name|Operator
operator|)
name|nd
operator|)
operator|.
name|getIdentifier
argument_list|()
operator|+
literal|")"
argument_list|)
expr_stmt|;
name|OpWalkerInfo
name|owi
init|=
operator|(
name|OpWalkerInfo
operator|)
name|procCtx
decl_stmt|;
name|PTFOperator
name|ptfOp
init|=
operator|(
name|PTFOperator
operator|)
name|nd
decl_stmt|;
name|pushRankLimit
argument_list|(
name|ptfOp
argument_list|,
name|owi
argument_list|)
expr_stmt|;
return|return
name|super
operator|.
name|process
argument_list|(
name|nd
argument_list|,
name|stack
argument_list|,
name|procCtx
argument_list|,
name|nodeOutputs
argument_list|)
return|;
block|}
specifier|private
name|void
name|pushRankLimit
parameter_list|(
name|PTFOperator
name|ptfOp
parameter_list|,
name|OpWalkerInfo
name|owi
parameter_list|)
throws|throws
name|SemanticException
block|{
name|PTFDesc
name|conf
init|=
name|ptfOp
operator|.
name|getConf
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|conf
operator|.
name|forWindowing
argument_list|()
condition|)
block|{
return|return;
block|}
name|float
name|threshold
init|=
name|owi
operator|.
name|getParseContext
argument_list|()
operator|.
name|getConf
argument_list|()
operator|.
name|getFloatVar
argument_list|(
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVELIMITPUSHDOWNMEMORYUSAGE
argument_list|)
decl_stmt|;
if|if
condition|(
name|threshold
operator|<=
literal|0
operator|||
name|threshold
operator|>=
literal|1
condition|)
block|{
return|return;
block|}
name|WindowTableFunctionDef
name|wTFn
init|=
operator|(
name|WindowTableFunctionDef
operator|)
name|conf
operator|.
name|getFuncDef
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|Integer
argument_list|>
name|rFnIdxs
init|=
name|rankingFunctions
argument_list|(
name|wTFn
argument_list|)
decl_stmt|;
if|if
condition|(
name|rFnIdxs
operator|.
name|size
argument_list|()
operator|==
literal|0
condition|)
block|{
return|return;
block|}
name|ExprWalkerInfo
name|childInfo
init|=
name|getChildWalkerInfo
argument_list|(
name|ptfOp
argument_list|,
name|owi
argument_list|)
decl_stmt|;
if|if
condition|(
name|childInfo
operator|==
literal|null
condition|)
block|{
return|return;
block|}
name|List
argument_list|<
name|ExprNodeDesc
argument_list|>
name|preds
init|=
operator|new
name|ArrayList
argument_list|<
name|ExprNodeDesc
argument_list|>
argument_list|()
decl_stmt|;
name|Iterator
argument_list|<
name|List
argument_list|<
name|ExprNodeDesc
argument_list|>
argument_list|>
name|iterator
init|=
name|childInfo
operator|.
name|getFinalCandidates
argument_list|()
operator|.
name|values
argument_list|()
operator|.
name|iterator
argument_list|()
decl_stmt|;
while|while
condition|(
name|iterator
operator|.
name|hasNext
argument_list|()
condition|)
block|{
for|for
control|(
name|ExprNodeDesc
name|pred
range|:
name|iterator
operator|.
name|next
argument_list|()
control|)
block|{
name|preds
operator|=
name|ExprNodeDescUtils
operator|.
name|split
argument_list|(
name|pred
argument_list|,
name|preds
argument_list|)
expr_stmt|;
block|}
block|}
name|int
name|rLimit
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|fnIdx
init|=
operator|-
literal|1
decl_stmt|;
for|for
control|(
name|ExprNodeDesc
name|pred
range|:
name|preds
control|)
block|{
name|int
index|[]
name|pLimit
init|=
name|getLimit
argument_list|(
name|wTFn
argument_list|,
name|rFnIdxs
argument_list|,
name|pred
argument_list|)
decl_stmt|;
if|if
condition|(
name|pLimit
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|rLimit
operator|==
operator|-
literal|1
operator|||
name|rLimit
operator|>=
name|pLimit
index|[
literal|0
index|]
condition|)
block|{
name|rLimit
operator|=
name|pLimit
index|[
literal|0
index|]
expr_stmt|;
name|fnIdx
operator|=
name|pLimit
index|[
literal|1
index|]
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|rLimit
operator|!=
operator|-
literal|1
condition|)
block|{
name|wTFn
operator|.
name|setRankLimit
argument_list|(
name|rLimit
argument_list|)
expr_stmt|;
name|wTFn
operator|.
name|setRankLimitFunction
argument_list|(
name|fnIdx
argument_list|)
expr_stmt|;
if|if
condition|(
name|canPushLimitToReduceSink
argument_list|(
name|wTFn
argument_list|)
condition|)
block|{
name|pushRankLimitToRedSink
argument_list|(
name|ptfOp
argument_list|,
name|owi
operator|.
name|getParseContext
argument_list|()
operator|.
name|getConf
argument_list|()
argument_list|,
name|rLimit
argument_list|)
expr_stmt|;
block|}
block|}
block|}
specifier|private
name|List
argument_list|<
name|Integer
argument_list|>
name|rankingFunctions
parameter_list|(
name|WindowTableFunctionDef
name|wTFn
parameter_list|)
block|{
name|List
argument_list|<
name|Integer
argument_list|>
name|rFns
init|=
operator|new
name|ArrayList
argument_list|<
name|Integer
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|wTFn
operator|.
name|getWindowFunctions
argument_list|()
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|WindowFunctionDef
name|wFnDef
init|=
name|wTFn
operator|.
name|getWindowFunctions
argument_list|()
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|wFnDef
operator|.
name|getWFnEval
argument_list|()
operator|instanceof
name|GenericUDAFRankEvaluator
operator|)
operator|||
operator|(
name|wFnDef
operator|.
name|getWFnEval
argument_list|()
operator|instanceof
name|GenericUDAFDenseRankEvaluator
operator|)
condition|)
block|{
name|rFns
operator|.
name|add
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|rFns
return|;
block|}
comment|/*      * For a predicate check if it is a candidate for pushing down as limit optimization.      * The expression must be of the form rankFn<|<= constant.      */
specifier|private
name|int
index|[]
name|getLimit
parameter_list|(
name|WindowTableFunctionDef
name|wTFn
parameter_list|,
name|List
argument_list|<
name|Integer
argument_list|>
name|rFnIdxs
parameter_list|,
name|ExprNodeDesc
name|expr
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|expr
operator|instanceof
name|ExprNodeGenericFuncDesc
operator|)
condition|)
block|{
return|return
literal|null
return|;
block|}
name|ExprNodeGenericFuncDesc
name|fExpr
init|=
operator|(
name|ExprNodeGenericFuncDesc
operator|)
name|expr
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|fExpr
operator|.
name|getGenericUDF
argument_list|()
operator|instanceof
name|GenericUDFOPLessThan
operator|)
operator|&&
operator|!
operator|(
name|fExpr
operator|.
name|getGenericUDF
argument_list|()
operator|instanceof
name|GenericUDFOPEqualOrLessThan
operator|)
condition|)
block|{
return|return
literal|null
return|;
block|}
if|if
condition|(
operator|!
operator|(
name|fExpr
operator|.
name|getChildren
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|instanceof
name|ExprNodeColumnDesc
operator|)
condition|)
block|{
return|return
literal|null
return|;
block|}
if|if
condition|(
operator|!
operator|(
name|fExpr
operator|.
name|getChildren
argument_list|()
operator|.
name|get
argument_list|(
literal|1
argument_list|)
operator|instanceof
name|ExprNodeConstantDesc
operator|)
condition|)
block|{
return|return
literal|null
return|;
block|}
name|ExprNodeConstantDesc
name|constantExpr
init|=
operator|(
name|ExprNodeConstantDesc
operator|)
name|fExpr
operator|.
name|getChildren
argument_list|()
operator|.
name|get
argument_list|(
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|constantExpr
operator|.
name|getTypeInfo
argument_list|()
operator|!=
name|TypeInfoFactory
operator|.
name|intTypeInfo
condition|)
block|{
return|return
literal|null
return|;
block|}
name|int
name|limit
init|=
operator|(
name|Integer
operator|)
name|constantExpr
operator|.
name|getValue
argument_list|()
decl_stmt|;
if|if
condition|(
name|fExpr
operator|.
name|getGenericUDF
argument_list|()
operator|instanceof
name|GenericUDFOPEqualOrLessThan
condition|)
block|{
name|limit
operator|=
name|limit
operator|+
literal|1
expr_stmt|;
block|}
name|String
name|colName
init|=
operator|(
operator|(
name|ExprNodeColumnDesc
operator|)
name|fExpr
operator|.
name|getChildren
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|)
operator|.
name|getColumn
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|rFnIdxs
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|String
name|fAlias
init|=
name|wTFn
operator|.
name|getWindowFunctions
argument_list|()
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|getAlias
argument_list|()
decl_stmt|;
if|if
condition|(
name|fAlias
operator|.
name|equals
argument_list|(
name|colName
argument_list|)
condition|)
block|{
return|return
operator|new
name|int
index|[]
block|{
name|limit
block|,
name|i
block|}
return|;
block|}
block|}
return|return
literal|null
return|;
block|}
comment|/*      * Limit can be pushed down to Map-side if all Window Functions need access      * to rows before the current row. This is true for:      * 1. Rank, DenseRank and Lead Fns. (the window doesn't matter for lead fn).      * 2. If the Window for the function is Row based and the End Boundary doesn't      * reference rows past the Current Row.      */
specifier|private
name|boolean
name|canPushLimitToReduceSink
parameter_list|(
name|WindowTableFunctionDef
name|wTFn
parameter_list|)
block|{
for|for
control|(
name|WindowFunctionDef
name|wFnDef
range|:
name|wTFn
operator|.
name|getWindowFunctions
argument_list|()
control|)
block|{
if|if
condition|(
operator|(
name|wFnDef
operator|.
name|getWFnEval
argument_list|()
operator|instanceof
name|GenericUDAFRankEvaluator
operator|)
operator|||
operator|(
name|wFnDef
operator|.
name|getWFnEval
argument_list|()
operator|instanceof
name|GenericUDAFDenseRankEvaluator
operator|)
operator|||
operator|(
name|wFnDef
operator|.
name|getWFnEval
argument_list|()
operator|instanceof
name|GenericUDAFLeadEvaluator
operator|)
condition|)
block|{
continue|continue;
block|}
name|WindowFrameDef
name|wdwFrame
init|=
name|wFnDef
operator|.
name|getWindowFrame
argument_list|()
decl_stmt|;
name|BoundaryDef
name|end
init|=
name|wdwFrame
operator|.
name|getEnd
argument_list|()
decl_stmt|;
if|if
condition|(
name|end
operator|instanceof
name|ValueBoundaryDef
condition|)
block|{
return|return
literal|false
return|;
block|}
if|if
condition|(
name|end
operator|.
name|getDirection
argument_list|()
operator|==
name|Direction
operator|.
name|FOLLOWING
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
return|return
literal|true
return|;
block|}
specifier|private
name|void
name|pushRankLimitToRedSink
parameter_list|(
name|PTFOperator
name|ptfOp
parameter_list|,
name|HiveConf
name|conf
parameter_list|,
name|int
name|rLimit
parameter_list|)
throws|throws
name|SemanticException
block|{
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
name|parent
init|=
name|ptfOp
operator|.
name|getParentOperators
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
name|gP
init|=
name|parent
operator|==
literal|null
condition|?
literal|null
else|:
name|parent
operator|.
name|getParentOperators
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|gP
operator|==
literal|null
operator|||
operator|!
operator|(
name|gP
operator|instanceof
name|ReduceSinkOperator
operator|)
condition|)
block|{
return|return;
block|}
name|float
name|threshold
init|=
name|conf
operator|.
name|getFloatVar
argument_list|(
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVELIMITPUSHDOWNMEMORYUSAGE
argument_list|)
decl_stmt|;
name|ReduceSinkOperator
name|rSink
init|=
operator|(
name|ReduceSinkOperator
operator|)
name|gP
decl_stmt|;
name|ReduceSinkDesc
name|rDesc
init|=
name|rSink
operator|.
name|getConf
argument_list|()
decl_stmt|;
name|rDesc
operator|.
name|setTopN
argument_list|(
name|rLimit
argument_list|)
expr_stmt|;
name|rDesc
operator|.
name|setTopNMemoryUsage
argument_list|(
name|threshold
argument_list|)
expr_stmt|;
name|rDesc
operator|.
name|setMapGroupBy
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|rDesc
operator|.
name|setPTFReduceSink
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
block|}
specifier|public
specifier|static
class|class
name|UDTFPPD
extends|extends
name|DefaultPPD
implements|implements
name|NodeProcessor
block|{
annotation|@
name|Override
specifier|public
name|Object
name|process
parameter_list|(
name|Node
name|nd
parameter_list|,
name|Stack
argument_list|<
name|Node
argument_list|>
name|stack
parameter_list|,
name|NodeProcessorCtx
name|procCtx
parameter_list|,
name|Object
modifier|...
name|nodeOutputs
parameter_list|)
throws|throws
name|SemanticException
block|{
name|super
operator|.
name|process
argument_list|(
name|nd
argument_list|,
name|stack
argument_list|,
name|procCtx
argument_list|,
name|nodeOutputs
argument_list|)
expr_stmt|;
name|OpWalkerInfo
name|owi
init|=
operator|(
name|OpWalkerInfo
operator|)
name|procCtx
decl_stmt|;
name|ExprWalkerInfo
name|prunedPred
init|=
name|owi
operator|.
name|getPrunedPreds
argument_list|(
operator|(
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
operator|)
name|nd
argument_list|)
decl_stmt|;
if|if
condition|(
name|prunedPred
operator|==
literal|null
operator|||
operator|!
name|prunedPred
operator|.
name|hasAnyCandidates
argument_list|()
condition|)
block|{
return|return
literal|null
return|;
block|}
name|Map
argument_list|<
name|String
argument_list|,
name|List
argument_list|<
name|ExprNodeDesc
argument_list|>
argument_list|>
name|candidates
init|=
name|prunedPred
operator|.
name|getFinalCandidates
argument_list|()
decl_stmt|;
name|createFilter
argument_list|(
operator|(
name|Operator
operator|)
name|nd
argument_list|,
name|prunedPred
argument_list|,
name|owi
argument_list|)
expr_stmt|;
name|candidates
operator|.
name|clear
argument_list|()
expr_stmt|;
return|return
literal|null
return|;
block|}
block|}
specifier|public
specifier|static
class|class
name|LateralViewForwardPPD
extends|extends
name|DefaultPPD
implements|implements
name|NodeProcessor
block|{
annotation|@
name|Override
specifier|public
name|Object
name|process
parameter_list|(
name|Node
name|nd
parameter_list|,
name|Stack
argument_list|<
name|Node
argument_list|>
name|stack
parameter_list|,
name|NodeProcessorCtx
name|procCtx
parameter_list|,
name|Object
modifier|...
name|nodeOutputs
parameter_list|)
throws|throws
name|SemanticException
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Processing for "
operator|+
name|nd
operator|.
name|getName
argument_list|()
operator|+
literal|"("
operator|+
operator|(
operator|(
name|Operator
operator|)
name|nd
operator|)
operator|.
name|getIdentifier
argument_list|()
operator|+
literal|")"
argument_list|)
expr_stmt|;
name|OpWalkerInfo
name|owi
init|=
operator|(
name|OpWalkerInfo
operator|)
name|procCtx
decl_stmt|;
comment|// The lateral view forward operator has 2 children, a SELECT(*) and
comment|// a SELECT(cols) (for the UDTF operator) The child at index 0 is the
comment|// SELECT(*) because that's the way that the DAG was constructed. We
comment|// only want to get the predicates from the SELECT(*).
name|ExprWalkerInfo
name|childPreds
init|=
name|owi
operator|.
name|getPrunedPreds
argument_list|(
operator|(
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
operator|)
name|nd
operator|.
name|getChildren
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|owi
operator|.
name|putPrunedPreds
argument_list|(
operator|(
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
operator|)
name|nd
argument_list|,
name|childPreds
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
block|}
comment|/**    * Combines predicates of its child into a single expression and adds a filter    * op as new child.    */
specifier|public
specifier|static
class|class
name|TableScanPPD
extends|extends
name|DefaultPPD
implements|implements
name|NodeProcessor
block|{
annotation|@
name|Override
specifier|public
name|Object
name|process
parameter_list|(
name|Node
name|nd
parameter_list|,
name|Stack
argument_list|<
name|Node
argument_list|>
name|stack
parameter_list|,
name|NodeProcessorCtx
name|procCtx
parameter_list|,
name|Object
modifier|...
name|nodeOutputs
parameter_list|)
throws|throws
name|SemanticException
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Processing for "
operator|+
name|nd
operator|.
name|getName
argument_list|()
operator|+
literal|"("
operator|+
operator|(
operator|(
name|Operator
operator|)
name|nd
operator|)
operator|.
name|getIdentifier
argument_list|()
operator|+
literal|")"
argument_list|)
expr_stmt|;
name|OpWalkerInfo
name|owi
init|=
operator|(
name|OpWalkerInfo
operator|)
name|procCtx
decl_stmt|;
name|TableScanOperator
name|tsOp
init|=
operator|(
name|TableScanOperator
operator|)
name|nd
decl_stmt|;
name|mergeWithChildrenPred
argument_list|(
name|tsOp
argument_list|,
name|owi
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
expr_stmt|;
name|ExprWalkerInfo
name|pushDownPreds
init|=
name|owi
operator|.
name|getPrunedPreds
argument_list|(
name|tsOp
argument_list|)
decl_stmt|;
return|return
name|createFilter
argument_list|(
name|tsOp
argument_list|,
name|pushDownPreds
argument_list|,
name|owi
argument_list|)
return|;
block|}
block|}
comment|/**    * Determines the push down predicates in its where expression and then    * combines it with the push down predicates that are passed from its children.    */
specifier|public
specifier|static
class|class
name|FilterPPD
extends|extends
name|DefaultPPD
implements|implements
name|NodeProcessor
block|{
annotation|@
name|Override
specifier|public
name|Object
name|process
parameter_list|(
name|Node
name|nd
parameter_list|,
name|Stack
argument_list|<
name|Node
argument_list|>
name|stack
parameter_list|,
name|NodeProcessorCtx
name|procCtx
parameter_list|,
name|Object
modifier|...
name|nodeOutputs
parameter_list|)
throws|throws
name|SemanticException
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Processing for "
operator|+
name|nd
operator|.
name|getName
argument_list|()
operator|+
literal|"("
operator|+
operator|(
operator|(
name|Operator
operator|)
name|nd
operator|)
operator|.
name|getIdentifier
argument_list|()
operator|+
literal|")"
argument_list|)
expr_stmt|;
name|OpWalkerInfo
name|owi
init|=
operator|(
name|OpWalkerInfo
operator|)
name|procCtx
decl_stmt|;
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
name|op
init|=
operator|(
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
operator|)
name|nd
decl_stmt|;
comment|// if this filter is generated one, predicates need not to be extracted
name|ExprWalkerInfo
name|ewi
init|=
name|owi
operator|.
name|getPrunedPreds
argument_list|(
name|op
argument_list|)
decl_stmt|;
comment|// Don't push a sampling predicate since createFilter() always creates filter
comment|// with isSamplePred = false. Also, the filterop with sampling pred is always
comment|// a child of TableScan, so there is no need to push this predicate.
if|if
condition|(
name|ewi
operator|==
literal|null
operator|&&
operator|!
operator|(
operator|(
name|FilterOperator
operator|)
name|op
operator|)
operator|.
name|getConf
argument_list|()
operator|.
name|getIsSamplingPred
argument_list|()
condition|)
block|{
comment|// get pushdown predicates for this operator's predicate
name|ExprNodeDesc
name|predicate
init|=
operator|(
operator|(
operator|(
name|FilterOperator
operator|)
name|nd
operator|)
operator|.
name|getConf
argument_list|()
operator|)
operator|.
name|getPredicate
argument_list|()
decl_stmt|;
name|ewi
operator|=
name|ExprWalkerProcFactory
operator|.
name|extractPushdownPreds
argument_list|(
name|owi
argument_list|,
name|op
argument_list|,
name|predicate
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ewi
operator|.
name|isDeterministic
argument_list|()
condition|)
block|{
comment|/* predicate is not deterministic */
if|if
condition|(
name|op
operator|.
name|getChildren
argument_list|()
operator|!=
literal|null
operator|&&
name|op
operator|.
name|getChildren
argument_list|()
operator|.
name|size
argument_list|()
operator|==
literal|1
condition|)
block|{
name|createFilter
argument_list|(
name|op
argument_list|,
name|owi
operator|.
name|getPrunedPreds
argument_list|(
call|(
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
call|)
argument_list|(
name|op
operator|.
name|getChildren
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|owi
argument_list|)
expr_stmt|;
block|}
return|return
literal|null
return|;
block|}
if|if
condition|(
name|HiveConf
operator|.
name|getBoolVar
argument_list|(
name|owi
operator|.
name|getParseContext
argument_list|()
operator|.
name|getConf
argument_list|()
argument_list|,
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVEPPDREMOVEDUPLICATEFILTERS
argument_list|)
condition|)
block|{
comment|// add this filter for deletion, if it does not have non-final candidates
if|if
condition|(
name|ewi
operator|.
name|getNonFinalCandidates
argument_list|()
operator|.
name|values
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|owi
operator|.
name|addCandidateFilterOp
argument_list|(
operator|(
name|FilterOperator
operator|)
name|op
argument_list|)
expr_stmt|;
block|}
block|}
name|logExpr
argument_list|(
name|nd
argument_list|,
name|ewi
argument_list|)
expr_stmt|;
name|owi
operator|.
name|putPrunedPreds
argument_list|(
operator|(
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
operator|)
name|nd
argument_list|,
name|ewi
argument_list|)
expr_stmt|;
block|}
comment|// merge it with children predicates
name|boolean
name|hasUnpushedPredicates
init|=
name|mergeWithChildrenPred
argument_list|(
name|nd
argument_list|,
name|owi
argument_list|,
name|ewi
argument_list|,
literal|null
argument_list|)
decl_stmt|;
if|if
condition|(
name|HiveConf
operator|.
name|getBoolVar
argument_list|(
name|owi
operator|.
name|getParseContext
argument_list|()
operator|.
name|getConf
argument_list|()
argument_list|,
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVEPPDREMOVEDUPLICATEFILTERS
argument_list|)
condition|)
block|{
if|if
condition|(
name|hasUnpushedPredicates
condition|)
block|{
name|ExprWalkerInfo
name|unpushedPreds
init|=
name|mergeChildrenPred
argument_list|(
name|nd
argument_list|,
name|owi
argument_list|,
literal|null
argument_list|,
literal|false
argument_list|)
decl_stmt|;
return|return
name|createFilter
argument_list|(
operator|(
name|Operator
operator|)
name|nd
argument_list|,
name|unpushedPreds
argument_list|,
name|owi
argument_list|)
return|;
block|}
block|}
return|return
literal|null
return|;
block|}
block|}
comment|/**    * Determines predicates for which alias can be pushed to it's parents. See    * the comments for getQualifiedAliases function.    */
specifier|public
specifier|static
class|class
name|JoinerPPD
extends|extends
name|DefaultPPD
implements|implements
name|NodeProcessor
block|{
annotation|@
name|Override
specifier|public
name|Object
name|process
parameter_list|(
name|Node
name|nd
parameter_list|,
name|Stack
argument_list|<
name|Node
argument_list|>
name|stack
parameter_list|,
name|NodeProcessorCtx
name|procCtx
parameter_list|,
name|Object
modifier|...
name|nodeOutputs
parameter_list|)
throws|throws
name|SemanticException
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Processing for "
operator|+
name|nd
operator|.
name|getName
argument_list|()
operator|+
literal|"("
operator|+
operator|(
operator|(
name|Operator
operator|)
name|nd
operator|)
operator|.
name|getIdentifier
argument_list|()
operator|+
literal|")"
argument_list|)
expr_stmt|;
name|OpWalkerInfo
name|owi
init|=
operator|(
name|OpWalkerInfo
operator|)
name|procCtx
decl_stmt|;
name|Set
argument_list|<
name|String
argument_list|>
name|aliases
init|=
name|getAliases
argument_list|(
name|nd
argument_list|)
decl_stmt|;
comment|// we pass null for aliases here because mergeWithChildrenPred filters
comment|// aliases in the children node context and we need to filter them in
comment|// the current JoinOperator's context
name|mergeWithChildrenPred
argument_list|(
name|nd
argument_list|,
name|owi
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
expr_stmt|;
name|ExprWalkerInfo
name|prunePreds
init|=
name|owi
operator|.
name|getPrunedPreds
argument_list|(
operator|(
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
operator|)
name|nd
argument_list|)
decl_stmt|;
if|if
condition|(
name|prunePreds
operator|!=
literal|null
condition|)
block|{
name|Set
argument_list|<
name|String
argument_list|>
name|toRemove
init|=
operator|new
name|HashSet
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
comment|// we don't push down any expressions that refer to aliases that can;t
comment|// be pushed down per getQualifiedAliases
for|for
control|(
name|Entry
argument_list|<
name|String
argument_list|,
name|List
argument_list|<
name|ExprNodeDesc
argument_list|>
argument_list|>
name|entry
range|:
name|prunePreds
operator|.
name|getFinalCandidates
argument_list|()
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|String
name|key
init|=
name|entry
operator|.
name|getKey
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|ExprNodeDesc
argument_list|>
name|value
init|=
name|entry
operator|.
name|getValue
argument_list|()
decl_stmt|;
if|if
condition|(
name|key
operator|==
literal|null
operator|&&
name|ExprNodeDescUtils
operator|.
name|isAllConstants
argument_list|(
name|value
argument_list|)
condition|)
block|{
continue|continue;
comment|// propagate constants
block|}
if|if
condition|(
operator|!
name|aliases
operator|.
name|contains
argument_list|(
name|key
argument_list|)
condition|)
block|{
name|toRemove
operator|.
name|add
argument_list|(
name|key
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
name|String
name|alias
range|:
name|toRemove
control|)
block|{
for|for
control|(
name|ExprNodeDesc
name|expr
range|:
name|prunePreds
operator|.
name|getFinalCandidates
argument_list|()
operator|.
name|get
argument_list|(
name|alias
argument_list|)
control|)
block|{
comment|// add expr to the list of predicates rejected from further pushing
comment|// so that we know to add it in createFilter()
name|prunePreds
operator|.
name|addAlias
argument_list|(
name|expr
argument_list|,
name|alias
argument_list|)
expr_stmt|;
name|prunePreds
operator|.
name|addNonFinalCandidate
argument_list|(
name|expr
argument_list|)
expr_stmt|;
block|}
name|prunePreds
operator|.
name|getFinalCandidates
argument_list|()
operator|.
name|remove
argument_list|(
name|alias
argument_list|)
expr_stmt|;
block|}
return|return
name|handlePredicates
argument_list|(
name|nd
argument_list|,
name|prunePreds
argument_list|,
name|owi
argument_list|)
return|;
block|}
return|return
literal|null
return|;
block|}
specifier|protected
name|Set
argument_list|<
name|String
argument_list|>
name|getAliases
parameter_list|(
name|Node
name|nd
parameter_list|)
throws|throws
name|SemanticException
block|{
return|return
operator|(
operator|(
name|Operator
operator|)
name|nd
operator|)
operator|.
name|getSchema
argument_list|()
operator|.
name|getTableNames
argument_list|()
return|;
block|}
specifier|protected
name|Object
name|handlePredicates
parameter_list|(
name|Node
name|nd
parameter_list|,
name|ExprWalkerInfo
name|prunePreds
parameter_list|,
name|OpWalkerInfo
name|owi
parameter_list|)
throws|throws
name|SemanticException
block|{
if|if
condition|(
name|HiveConf
operator|.
name|getBoolVar
argument_list|(
name|owi
operator|.
name|getParseContext
argument_list|()
operator|.
name|getConf
argument_list|()
argument_list|,
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVEPPDREMOVEDUPLICATEFILTERS
argument_list|)
condition|)
block|{
return|return
name|createFilter
argument_list|(
operator|(
name|Operator
operator|)
name|nd
argument_list|,
name|prunePreds
operator|.
name|getResidualPredicates
argument_list|(
literal|true
argument_list|)
argument_list|,
name|owi
argument_list|)
return|;
block|}
return|return
literal|null
return|;
block|}
block|}
specifier|public
specifier|static
class|class
name|JoinPPD
extends|extends
name|JoinerPPD
block|{
annotation|@
name|Override
specifier|protected
name|Set
argument_list|<
name|String
argument_list|>
name|getAliases
parameter_list|(
name|Node
name|nd
parameter_list|)
block|{
return|return
name|getQualifiedAliases
argument_list|(
operator|(
name|JoinOperator
operator|)
name|nd
argument_list|,
operator|(
operator|(
name|JoinOperator
operator|)
name|nd
operator|)
operator|.
name|getSchema
argument_list|()
argument_list|)
return|;
block|}
comment|/**      * Figures out the aliases for whom it is safe to push predicates based on      * ANSI SQL semantics. The join conditions are left associative so "a      * RIGHT OUTER JOIN b LEFT OUTER JOIN c INNER JOIN d" is interpreted as      * "((a RIGHT OUTER JOIN b) LEFT OUTER JOIN c) INNER JOIN d".  For inner      * joins, both the left and right join subexpressions are considered for      * pushing down aliases, for the right outer join, the right subexpression      * is considered and the left ignored and for the left outer join, the      * left subexpression is considered and the left ignored. Here, aliases b      * and d are eligible to be pushed up.      *      * TODO: further optimization opportunity for the case a.c1 = b.c1 and b.c2      * = c.c2 a and b are first joined and then the result with c. But the      * second join op currently treats a and b as separate aliases and thus      * disallowing predicate expr containing both tables a and b (such as a.c3      * + a.c4> 20). Such predicates also can be pushed just above the second      * join and below the first join      *      * @param op      *          Join Operator      * @param rr      *          Row resolver      * @return set of qualified aliases      */
specifier|private
name|Set
argument_list|<
name|String
argument_list|>
name|getQualifiedAliases
parameter_list|(
name|JoinOperator
name|op
parameter_list|,
name|RowSchema
name|rs
parameter_list|)
block|{
name|Set
argument_list|<
name|String
argument_list|>
name|aliases
init|=
operator|new
name|HashSet
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
name|JoinCondDesc
index|[]
name|conds
init|=
name|op
operator|.
name|getConf
argument_list|()
operator|.
name|getConds
argument_list|()
decl_stmt|;
name|Map
argument_list|<
name|Integer
argument_list|,
name|Set
argument_list|<
name|String
argument_list|>
argument_list|>
name|posToAliasMap
init|=
name|op
operator|.
name|getPosToAliasMap
argument_list|()
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|conds
operator|.
name|length
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|conds
index|[
name|i
index|]
operator|.
name|getType
argument_list|()
operator|==
name|JoinDesc
operator|.
name|INNER_JOIN
condition|)
block|{
name|aliases
operator|.
name|addAll
argument_list|(
name|posToAliasMap
operator|.
name|get
argument_list|(
name|i
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|conds
index|[
name|i
index|]
operator|.
name|getType
argument_list|()
operator|==
name|JoinDesc
operator|.
name|FULL_OUTER_JOIN
condition|)
block|{
break|break;
block|}
elseif|else
if|if
condition|(
name|conds
index|[
name|i
index|]
operator|.
name|getType
argument_list|()
operator|==
name|JoinDesc
operator|.
name|RIGHT_OUTER_JOIN
condition|)
block|{
name|aliases
operator|.
name|addAll
argument_list|(
name|posToAliasMap
operator|.
name|get
argument_list|(
name|i
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|conds
index|[
name|i
index|]
operator|.
name|getType
argument_list|()
operator|==
name|JoinDesc
operator|.
name|LEFT_OUTER_JOIN
condition|)
block|{
continue|continue;
block|}
block|}
if|if
condition|(
name|i
operator|==
operator|-
literal|1
condition|)
block|{
name|aliases
operator|.
name|addAll
argument_list|(
name|posToAliasMap
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|Set
argument_list|<
name|String
argument_list|>
name|aliases2
init|=
name|rs
operator|.
name|getTableNames
argument_list|()
decl_stmt|;
name|aliases
operator|.
name|retainAll
argument_list|(
name|aliases2
argument_list|)
expr_stmt|;
return|return
name|aliases
return|;
block|}
block|}
specifier|public
specifier|static
class|class
name|ReduceSinkPPD
extends|extends
name|DefaultPPD
implements|implements
name|NodeProcessor
block|{
specifier|public
name|Object
name|process
parameter_list|(
name|Node
name|nd
parameter_list|,
name|Stack
argument_list|<
name|Node
argument_list|>
name|stack
parameter_list|,
name|NodeProcessorCtx
name|procCtx
parameter_list|,
name|Object
modifier|...
name|nodeOutputs
parameter_list|)
throws|throws
name|SemanticException
block|{
name|super
operator|.
name|process
argument_list|(
name|nd
argument_list|,
name|stack
argument_list|,
name|procCtx
argument_list|,
name|nodeOutputs
argument_list|)
expr_stmt|;
name|Operator
argument_list|<
name|?
argument_list|>
name|operator
init|=
operator|(
name|Operator
argument_list|<
name|?
argument_list|>
operator|)
name|nd
decl_stmt|;
name|OpWalkerInfo
name|owi
init|=
operator|(
name|OpWalkerInfo
operator|)
name|procCtx
decl_stmt|;
if|if
condition|(
name|operator
operator|.
name|getNumChild
argument_list|()
operator|==
literal|1
operator|&&
name|operator
operator|.
name|getChildOperators
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|instanceof
name|JoinOperator
condition|)
block|{
if|if
condition|(
name|HiveConf
operator|.
name|getBoolVar
argument_list|(
name|owi
operator|.
name|getParseContext
argument_list|()
operator|.
name|getConf
argument_list|()
argument_list|,
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVEPPDRECOGNIZETRANSITIVITY
argument_list|)
condition|)
block|{
name|JoinOperator
name|child
init|=
operator|(
name|JoinOperator
operator|)
name|operator
operator|.
name|getChildOperators
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|int
name|targetPos
init|=
name|child
operator|.
name|getParentOperators
argument_list|()
operator|.
name|indexOf
argument_list|(
name|operator
argument_list|)
decl_stmt|;
name|applyFilterTransitivity
argument_list|(
name|child
argument_list|,
name|targetPos
argument_list|,
name|owi
argument_list|)
expr_stmt|;
block|}
block|}
return|return
literal|null
return|;
block|}
comment|/**      * Adds additional pushdown predicates for a join operator by replicating      * filters transitively over all the equijoin conditions.      *      * If we have a predicate "t.col=1" and the equijoin conditions      * "t.col=s.col" and "t.col=u.col", we add the filters "s.col=1" and      * "u.col=1". Note that this does not depend on the types of joins (ie.      * inner, left/right/full outer) between the tables s, t and u because if      * a predicate, eg. "t.col=1" is present in getFinalCandidates() at this      * point, we have already verified that it can be pushed down, so any rows      * emitted must satisfy s.col=t.col=u.col=1 and replicating the filters      * like this is ok.      */
specifier|private
name|void
name|applyFilterTransitivity
parameter_list|(
name|JoinOperator
name|join
parameter_list|,
name|int
name|targetPos
parameter_list|,
name|OpWalkerInfo
name|owi
parameter_list|)
throws|throws
name|SemanticException
block|{
name|ExprWalkerInfo
name|joinPreds
init|=
name|owi
operator|.
name|getPrunedPreds
argument_list|(
name|join
argument_list|)
decl_stmt|;
if|if
condition|(
name|joinPreds
operator|==
literal|null
operator|||
operator|!
name|joinPreds
operator|.
name|hasAnyCandidates
argument_list|()
condition|)
block|{
return|return;
block|}
name|Map
argument_list|<
name|String
argument_list|,
name|List
argument_list|<
name|ExprNodeDesc
argument_list|>
argument_list|>
name|oldFilters
init|=
name|joinPreds
operator|.
name|getFinalCandidates
argument_list|()
decl_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|List
argument_list|<
name|ExprNodeDesc
argument_list|>
argument_list|>
name|newFilters
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|List
argument_list|<
name|ExprNodeDesc
argument_list|>
argument_list|>
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
argument_list|>
name|parentOperators
init|=
name|join
operator|.
name|getParentOperators
argument_list|()
decl_stmt|;
name|ReduceSinkOperator
name|target
init|=
operator|(
name|ReduceSinkOperator
operator|)
name|parentOperators
operator|.
name|get
argument_list|(
name|targetPos
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|ExprNodeDesc
argument_list|>
name|targetKeys
init|=
name|target
operator|.
name|getConf
argument_list|()
operator|.
name|getKeyCols
argument_list|()
decl_stmt|;
name|ExprWalkerInfo
name|rsPreds
init|=
name|owi
operator|.
name|getPrunedPreds
argument_list|(
name|target
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|sourcePos
init|=
literal|0
init|;
name|sourcePos
operator|<
name|parentOperators
operator|.
name|size
argument_list|()
condition|;
name|sourcePos
operator|++
control|)
block|{
name|ReduceSinkOperator
name|source
init|=
operator|(
name|ReduceSinkOperator
operator|)
name|parentOperators
operator|.
name|get
argument_list|(
name|sourcePos
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|ExprNodeDesc
argument_list|>
name|sourceKeys
init|=
name|source
operator|.
name|getConf
argument_list|()
operator|.
name|getKeyCols
argument_list|()
decl_stmt|;
name|Set
argument_list|<
name|String
argument_list|>
name|sourceAliases
init|=
operator|new
name|HashSet
argument_list|<
name|String
argument_list|>
argument_list|(
name|Arrays
operator|.
name|asList
argument_list|(
name|source
operator|.
name|getInputAliases
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|List
argument_list|<
name|ExprNodeDesc
argument_list|>
argument_list|>
name|entry
range|:
name|oldFilters
operator|.
name|entrySet
argument_list|()
control|)
block|{
if|if
condition|(
name|entry
operator|.
name|getKey
argument_list|()
operator|==
literal|null
operator|&&
name|ExprNodeDescUtils
operator|.
name|isAllConstants
argument_list|(
name|entry
operator|.
name|getValue
argument_list|()
argument_list|)
condition|)
block|{
comment|// propagate constants
for|for
control|(
name|String
name|targetAlias
range|:
name|target
operator|.
name|getInputAliases
argument_list|()
control|)
block|{
name|rsPreds
operator|.
name|addPushDowns
argument_list|(
name|targetAlias
argument_list|,
name|entry
operator|.
name|getValue
argument_list|()
argument_list|)
expr_stmt|;
block|}
continue|continue;
block|}
if|if
condition|(
operator|!
name|sourceAliases
operator|.
name|contains
argument_list|(
name|entry
operator|.
name|getKey
argument_list|()
argument_list|)
condition|)
block|{
continue|continue;
block|}
for|for
control|(
name|ExprNodeDesc
name|predicate
range|:
name|entry
operator|.
name|getValue
argument_list|()
control|)
block|{
name|ExprNodeDesc
name|backtrack
init|=
name|ExprNodeDescUtils
operator|.
name|backtrack
argument_list|(
name|predicate
argument_list|,
name|join
argument_list|,
name|source
argument_list|)
decl_stmt|;
if|if
condition|(
name|backtrack
operator|==
literal|null
condition|)
block|{
continue|continue;
block|}
name|ExprNodeDesc
name|replaced
init|=
name|ExprNodeDescUtils
operator|.
name|replace
argument_list|(
name|backtrack
argument_list|,
name|sourceKeys
argument_list|,
name|targetKeys
argument_list|)
decl_stmt|;
if|if
condition|(
name|replaced
operator|==
literal|null
condition|)
block|{
continue|continue;
block|}
for|for
control|(
name|String
name|targetAlias
range|:
name|target
operator|.
name|getInputAliases
argument_list|()
control|)
block|{
name|rsPreds
operator|.
name|addFinalCandidate
argument_list|(
name|targetAlias
argument_list|,
name|replaced
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
block|}
comment|/**    * Default processor which just merges its children.    */
specifier|public
specifier|static
class|class
name|DefaultPPD
implements|implements
name|NodeProcessor
block|{
annotation|@
name|Override
specifier|public
name|Object
name|process
parameter_list|(
name|Node
name|nd
parameter_list|,
name|Stack
argument_list|<
name|Node
argument_list|>
name|stack
parameter_list|,
name|NodeProcessorCtx
name|procCtx
parameter_list|,
name|Object
modifier|...
name|nodeOutputs
parameter_list|)
throws|throws
name|SemanticException
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Processing for "
operator|+
name|nd
operator|.
name|getName
argument_list|()
operator|+
literal|"("
operator|+
operator|(
operator|(
name|Operator
operator|)
name|nd
operator|)
operator|.
name|getIdentifier
argument_list|()
operator|+
literal|")"
argument_list|)
expr_stmt|;
name|OpWalkerInfo
name|owi
init|=
operator|(
name|OpWalkerInfo
operator|)
name|procCtx
decl_stmt|;
name|Set
argument_list|<
name|String
argument_list|>
name|includes
init|=
name|getQualifiedAliases
argument_list|(
operator|(
name|Operator
argument_list|<
name|?
argument_list|>
operator|)
name|nd
argument_list|,
name|owi
argument_list|)
decl_stmt|;
name|boolean
name|hasUnpushedPredicates
init|=
name|mergeWithChildrenPred
argument_list|(
name|nd
argument_list|,
name|owi
argument_list|,
literal|null
argument_list|,
name|includes
argument_list|)
decl_stmt|;
if|if
condition|(
name|hasUnpushedPredicates
operator|&&
name|HiveConf
operator|.
name|getBoolVar
argument_list|(
name|owi
operator|.
name|getParseContext
argument_list|()
operator|.
name|getConf
argument_list|()
argument_list|,
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVEPPDREMOVEDUPLICATEFILTERS
argument_list|)
condition|)
block|{
if|if
condition|(
name|includes
operator|!=
literal|null
operator|||
name|nd
operator|instanceof
name|ReduceSinkOperator
condition|)
block|{
name|owi
operator|.
name|getCandidateFilterOps
argument_list|()
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|ExprWalkerInfo
name|pruned
init|=
name|owi
operator|.
name|getPrunedPreds
argument_list|(
operator|(
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
operator|)
name|nd
argument_list|)
decl_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|List
argument_list|<
name|ExprNodeDesc
argument_list|>
argument_list|>
name|residual
init|=
name|pruned
operator|.
name|getResidualPredicates
argument_list|(
literal|true
argument_list|)
decl_stmt|;
if|if
condition|(
name|residual
operator|!=
literal|null
operator|&&
operator|!
name|residual
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|createFilter
argument_list|(
operator|(
name|Operator
operator|)
name|nd
argument_list|,
name|residual
argument_list|,
name|owi
argument_list|)
expr_stmt|;
name|pruned
operator|.
name|getNonFinalCandidates
argument_list|()
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
block|}
block|}
return|return
literal|null
return|;
block|}
comment|// RS for join, SEL(*) for lateral view
comment|// SEL for union does not count (should be copied to both sides)
specifier|private
name|Set
argument_list|<
name|String
argument_list|>
name|getQualifiedAliases
parameter_list|(
name|Operator
argument_list|<
name|?
argument_list|>
name|operator
parameter_list|,
name|OpWalkerInfo
name|owi
parameter_list|)
block|{
if|if
condition|(
name|operator
operator|.
name|getNumChild
argument_list|()
operator|!=
literal|1
condition|)
block|{
return|return
literal|null
return|;
block|}
name|Operator
argument_list|<
name|?
argument_list|>
name|child
init|=
name|operator
operator|.
name|getChildOperators
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|child
operator|instanceof
name|JoinOperator
operator|||
name|child
operator|instanceof
name|LateralViewJoinOperator
operator|)
condition|)
block|{
return|return
literal|null
return|;
block|}
if|if
condition|(
name|operator
operator|instanceof
name|ReduceSinkOperator
operator|&&
operator|(
operator|(
name|ReduceSinkOperator
operator|)
name|operator
operator|)
operator|.
name|getInputAliases
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|String
index|[]
name|aliases
init|=
operator|(
operator|(
name|ReduceSinkOperator
operator|)
name|operator
operator|)
operator|.
name|getInputAliases
argument_list|()
decl_stmt|;
return|return
operator|new
name|HashSet
argument_list|<
name|String
argument_list|>
argument_list|(
name|Arrays
operator|.
name|asList
argument_list|(
name|aliases
argument_list|)
argument_list|)
return|;
block|}
name|Set
argument_list|<
name|String
argument_list|>
name|includes
init|=
name|operator
operator|.
name|getSchema
argument_list|()
operator|.
name|getTableNames
argument_list|()
decl_stmt|;
if|if
condition|(
name|includes
operator|.
name|size
argument_list|()
operator|==
literal|1
operator|&&
name|includes
operator|.
name|contains
argument_list|(
literal|""
argument_list|)
condition|)
block|{
comment|// Reduce sink of group by operator
return|return
literal|null
return|;
block|}
return|return
name|includes
return|;
block|}
comment|/**      * @param nd      * @param ewi      */
specifier|protected
name|void
name|logExpr
parameter_list|(
name|Node
name|nd
parameter_list|,
name|ExprWalkerInfo
name|ewi
parameter_list|)
block|{
for|for
control|(
name|Entry
argument_list|<
name|String
argument_list|,
name|List
argument_list|<
name|ExprNodeDesc
argument_list|>
argument_list|>
name|e
range|:
name|ewi
operator|.
name|getFinalCandidates
argument_list|()
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Pushdown Predicates of "
operator|+
name|nd
operator|.
name|getName
argument_list|()
operator|+
literal|" For Alias : "
operator|+
name|e
operator|.
name|getKey
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|ExprNodeDesc
name|n
range|:
name|e
operator|.
name|getValue
argument_list|()
control|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"\t"
operator|+
name|n
operator|.
name|getExprString
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**      * Take current operators pushdown predicates and merges them with      * children's pushdown predicates.      *      * @param nd      *          current operator      * @param owi      *          operator context during this walk      * @param ewi      *          pushdown predicates (part of expression walker info)      * @param aliases      *          aliases that this operator can pushdown. null means that all      *          aliases can be pushed down      * @throws SemanticException      */
specifier|protected
name|boolean
name|mergeWithChildrenPred
parameter_list|(
name|Node
name|nd
parameter_list|,
name|OpWalkerInfo
name|owi
parameter_list|,
name|ExprWalkerInfo
name|ewi
parameter_list|,
name|Set
argument_list|<
name|String
argument_list|>
name|aliases
parameter_list|)
throws|throws
name|SemanticException
block|{
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
name|op
init|=
operator|(
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
operator|)
name|nd
decl_stmt|;
name|ExprWalkerInfo
name|childPreds
init|=
name|getChildWalkerInfo
argument_list|(
name|op
argument_list|,
name|owi
argument_list|)
decl_stmt|;
if|if
condition|(
name|childPreds
operator|==
literal|null
condition|)
block|{
return|return
literal|false
return|;
block|}
if|if
condition|(
name|ewi
operator|==
literal|null
condition|)
block|{
name|ewi
operator|=
operator|new
name|ExprWalkerInfo
argument_list|()
expr_stmt|;
block|}
name|boolean
name|hasUnpushedPredicates
init|=
literal|false
decl_stmt|;
for|for
control|(
name|Entry
argument_list|<
name|String
argument_list|,
name|List
argument_list|<
name|ExprNodeDesc
argument_list|>
argument_list|>
name|e
range|:
name|childPreds
operator|.
name|getFinalCandidates
argument_list|()
operator|.
name|entrySet
argument_list|()
control|)
block|{
if|if
condition|(
name|aliases
operator|==
literal|null
operator|||
name|e
operator|.
name|getKey
argument_list|()
operator|==
literal|null
operator|||
name|aliases
operator|.
name|contains
argument_list|(
name|e
operator|.
name|getKey
argument_list|()
argument_list|)
condition|)
block|{
comment|// e.getKey() (alias) can be null in case of constant expressions. see
comment|// input8.q
name|ExprWalkerInfo
name|extractPushdownPreds
init|=
name|ExprWalkerProcFactory
operator|.
name|extractPushdownPreds
argument_list|(
name|owi
argument_list|,
name|op
argument_list|,
name|e
operator|.
name|getValue
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|extractPushdownPreds
operator|.
name|getNonFinalCandidates
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|hasUnpushedPredicates
operator|=
literal|true
expr_stmt|;
block|}
name|ewi
operator|.
name|merge
argument_list|(
name|extractPushdownPreds
argument_list|)
expr_stmt|;
name|logExpr
argument_list|(
name|nd
argument_list|,
name|extractPushdownPreds
argument_list|)
expr_stmt|;
block|}
block|}
name|owi
operator|.
name|putPrunedPreds
argument_list|(
operator|(
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
operator|)
name|nd
argument_list|,
name|ewi
argument_list|)
expr_stmt|;
return|return
name|hasUnpushedPredicates
return|;
block|}
specifier|protected
name|ExprWalkerInfo
name|mergeChildrenPred
parameter_list|(
name|Node
name|nd
parameter_list|,
name|OpWalkerInfo
name|owi
parameter_list|,
name|Set
argument_list|<
name|String
argument_list|>
name|excludedAliases
parameter_list|,
name|boolean
name|ignoreAliases
parameter_list|)
throws|throws
name|SemanticException
block|{
if|if
condition|(
name|nd
operator|.
name|getChildren
argument_list|()
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
name|op
init|=
operator|(
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
operator|)
name|nd
decl_stmt|;
name|ExprWalkerInfo
name|ewi
init|=
operator|new
name|ExprWalkerInfo
argument_list|()
decl_stmt|;
for|for
control|(
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
name|child
range|:
name|op
operator|.
name|getChildOperators
argument_list|()
control|)
block|{
name|ExprWalkerInfo
name|childPreds
init|=
name|owi
operator|.
name|getPrunedPreds
argument_list|(
name|child
argument_list|)
decl_stmt|;
if|if
condition|(
name|childPreds
operator|==
literal|null
condition|)
block|{
continue|continue;
block|}
for|for
control|(
name|Entry
argument_list|<
name|String
argument_list|,
name|List
argument_list|<
name|ExprNodeDesc
argument_list|>
argument_list|>
name|e
range|:
name|childPreds
operator|.
name|getFinalCandidates
argument_list|()
operator|.
name|entrySet
argument_list|()
control|)
block|{
if|if
condition|(
name|ignoreAliases
operator|||
name|excludedAliases
operator|==
literal|null
operator|||
operator|!
name|excludedAliases
operator|.
name|contains
argument_list|(
name|e
operator|.
name|getKey
argument_list|()
argument_list|)
operator|||
name|e
operator|.
name|getKey
argument_list|()
operator|==
literal|null
condition|)
block|{
name|ewi
operator|.
name|addPushDowns
argument_list|(
name|e
operator|.
name|getKey
argument_list|()
argument_list|,
name|e
operator|.
name|getValue
argument_list|()
argument_list|)
expr_stmt|;
name|logExpr
argument_list|(
name|nd
argument_list|,
name|ewi
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
name|ewi
return|;
block|}
block|}
specifier|protected
specifier|static
name|Object
name|createFilter
parameter_list|(
name|Operator
name|op
parameter_list|,
name|ExprWalkerInfo
name|pushDownPreds
parameter_list|,
name|OpWalkerInfo
name|owi
parameter_list|)
block|{
if|if
condition|(
name|pushDownPreds
operator|!=
literal|null
operator|&&
name|pushDownPreds
operator|.
name|hasAnyCandidates
argument_list|()
condition|)
block|{
return|return
name|createFilter
argument_list|(
name|op
argument_list|,
name|pushDownPreds
operator|.
name|getFinalCandidates
argument_list|()
argument_list|,
name|owi
argument_list|)
return|;
block|}
return|return
literal|null
return|;
block|}
specifier|protected
specifier|static
name|Object
name|createFilter
parameter_list|(
name|Operator
name|op
parameter_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|List
argument_list|<
name|ExprNodeDesc
argument_list|>
argument_list|>
name|predicates
parameter_list|,
name|OpWalkerInfo
name|owi
parameter_list|)
block|{
name|RowSchema
name|inputRS
init|=
name|op
operator|.
name|getSchema
argument_list|()
decl_stmt|;
comment|// combine all predicates into a single expression
name|List
argument_list|<
name|ExprNodeDesc
argument_list|>
name|preds
init|=
operator|new
name|ArrayList
argument_list|<
name|ExprNodeDesc
argument_list|>
argument_list|()
decl_stmt|;
name|Iterator
argument_list|<
name|List
argument_list|<
name|ExprNodeDesc
argument_list|>
argument_list|>
name|iterator
init|=
name|predicates
operator|.
name|values
argument_list|()
operator|.
name|iterator
argument_list|()
decl_stmt|;
while|while
condition|(
name|iterator
operator|.
name|hasNext
argument_list|()
condition|)
block|{
for|for
control|(
name|ExprNodeDesc
name|pred
range|:
name|iterator
operator|.
name|next
argument_list|()
control|)
block|{
name|preds
operator|=
name|ExprNodeDescUtils
operator|.
name|split
argument_list|(
name|pred
argument_list|,
name|preds
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|preds
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return
literal|null
return|;
block|}
name|ExprNodeDesc
name|condn
init|=
name|ExprNodeDescUtils
operator|.
name|mergePredicates
argument_list|(
name|preds
argument_list|)
decl_stmt|;
if|if
condition|(
name|op
operator|instanceof
name|TableScanOperator
operator|&&
name|condn
operator|instanceof
name|ExprNodeGenericFuncDesc
condition|)
block|{
name|boolean
name|pushFilterToStorage
decl_stmt|;
name|HiveConf
name|hiveConf
init|=
name|owi
operator|.
name|getParseContext
argument_list|()
operator|.
name|getConf
argument_list|()
decl_stmt|;
name|pushFilterToStorage
operator|=
name|hiveConf
operator|.
name|getBoolVar
argument_list|(
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVEOPTPPD_STORAGE
argument_list|)
expr_stmt|;
if|if
condition|(
name|pushFilterToStorage
condition|)
block|{
name|condn
operator|=
name|pushFilterToStorageHandler
argument_list|(
operator|(
name|TableScanOperator
operator|)
name|op
argument_list|,
operator|(
name|ExprNodeGenericFuncDesc
operator|)
name|condn
argument_list|,
name|owi
argument_list|,
name|hiveConf
argument_list|)
expr_stmt|;
if|if
condition|(
name|condn
operator|==
literal|null
condition|)
block|{
comment|// we pushed the whole thing down
return|return
literal|null
return|;
block|}
block|}
block|}
comment|// add new filter op
name|List
argument_list|<
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
argument_list|>
name|originalChilren
init|=
name|op
operator|.
name|getChildOperators
argument_list|()
decl_stmt|;
name|op
operator|.
name|setChildOperators
argument_list|(
literal|null
argument_list|)
expr_stmt|;
name|Operator
argument_list|<
name|FilterDesc
argument_list|>
name|output
init|=
name|OperatorFactory
operator|.
name|getAndMakeChild
argument_list|(
operator|new
name|FilterDesc
argument_list|(
name|condn
argument_list|,
literal|false
argument_list|)
argument_list|,
operator|new
name|RowSchema
argument_list|(
name|inputRS
operator|.
name|getSignature
argument_list|()
argument_list|)
argument_list|,
name|op
argument_list|)
decl_stmt|;
name|output
operator|.
name|setChildOperators
argument_list|(
name|originalChilren
argument_list|)
expr_stmt|;
for|for
control|(
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
name|ch
range|:
name|originalChilren
control|)
block|{
name|List
argument_list|<
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
argument_list|>
name|parentOperators
init|=
name|ch
operator|.
name|getParentOperators
argument_list|()
decl_stmt|;
name|int
name|pos
init|=
name|parentOperators
operator|.
name|indexOf
argument_list|(
name|op
argument_list|)
decl_stmt|;
assert|assert
name|pos
operator|!=
operator|-
literal|1
assert|;
name|parentOperators
operator|.
name|remove
argument_list|(
name|pos
argument_list|)
expr_stmt|;
name|parentOperators
operator|.
name|add
argument_list|(
name|pos
argument_list|,
name|output
argument_list|)
expr_stmt|;
comment|// add the new op as the old
block|}
if|if
condition|(
name|HiveConf
operator|.
name|getBoolVar
argument_list|(
name|owi
operator|.
name|getParseContext
argument_list|()
operator|.
name|getConf
argument_list|()
argument_list|,
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVEPPDREMOVEDUPLICATEFILTERS
argument_list|)
condition|)
block|{
comment|// remove the candidate filter ops
for|for
control|(
name|FilterOperator
name|fop
range|:
name|owi
operator|.
name|getCandidateFilterOps
argument_list|()
control|)
block|{
name|List
argument_list|<
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
argument_list|>
name|children
init|=
name|fop
operator|.
name|getChildOperators
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
argument_list|>
name|parents
init|=
name|fop
operator|.
name|getParentOperators
argument_list|()
decl_stmt|;
for|for
control|(
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
name|parent
range|:
name|parents
control|)
block|{
name|parent
operator|.
name|getChildOperators
argument_list|()
operator|.
name|addAll
argument_list|(
name|children
argument_list|)
expr_stmt|;
name|parent
operator|.
name|removeChild
argument_list|(
name|fop
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
name|child
range|:
name|children
control|)
block|{
name|child
operator|.
name|getParentOperators
argument_list|()
operator|.
name|addAll
argument_list|(
name|parents
argument_list|)
expr_stmt|;
name|child
operator|.
name|removeParent
argument_list|(
name|fop
argument_list|)
expr_stmt|;
block|}
block|}
name|owi
operator|.
name|getCandidateFilterOps
argument_list|()
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
comment|// push down current ppd context to newly added filter
name|ExprWalkerInfo
name|walkerInfo
init|=
name|owi
operator|.
name|getPrunedPreds
argument_list|(
name|op
argument_list|)
decl_stmt|;
if|if
condition|(
name|walkerInfo
operator|!=
literal|null
condition|)
block|{
name|walkerInfo
operator|.
name|getNonFinalCandidates
argument_list|()
operator|.
name|clear
argument_list|()
expr_stmt|;
name|owi
operator|.
name|putPrunedPreds
argument_list|(
name|output
argument_list|,
name|walkerInfo
argument_list|)
expr_stmt|;
block|}
return|return
name|output
return|;
block|}
comment|/**    * Attempts to push a predicate down into a storage handler.  For    * native tables, this is a no-op.    *    * @param tableScanOp table scan against which predicate applies    *    * @param originalPredicate predicate to be pushed down    *    * @param owi object walk info    *    * @param hiveConf Hive configuration    *    * @return portion of predicate which needs to be evaluated    * by Hive as a post-filter, or null if it was possible    * to push down the entire predicate    */
specifier|private
specifier|static
name|ExprNodeGenericFuncDesc
name|pushFilterToStorageHandler
parameter_list|(
name|TableScanOperator
name|tableScanOp
parameter_list|,
name|ExprNodeGenericFuncDesc
name|originalPredicate
parameter_list|,
name|OpWalkerInfo
name|owi
parameter_list|,
name|HiveConf
name|hiveConf
parameter_list|)
block|{
name|TableScanDesc
name|tableScanDesc
init|=
name|tableScanOp
operator|.
name|getConf
argument_list|()
decl_stmt|;
name|Table
name|tbl
init|=
name|tableScanDesc
operator|.
name|getTableMetadata
argument_list|()
decl_stmt|;
if|if
condition|(
name|HiveConf
operator|.
name|getBoolVar
argument_list|(
name|hiveConf
argument_list|,
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVEOPTINDEXFILTER
argument_list|)
condition|)
block|{
comment|// attach the original predicate to the table scan operator for index
comment|// optimizations that require the pushed predicate before pcr& later
comment|// optimizations are applied
name|tableScanDesc
operator|.
name|setFilterExpr
argument_list|(
name|originalPredicate
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|tbl
operator|.
name|isNonNative
argument_list|()
condition|)
block|{
return|return
name|originalPredicate
return|;
block|}
name|HiveStorageHandler
name|storageHandler
init|=
name|tbl
operator|.
name|getStorageHandler
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|storageHandler
operator|instanceof
name|HiveStoragePredicateHandler
operator|)
condition|)
block|{
comment|// The storage handler does not provide predicate decomposition
comment|// support, so we'll implement the entire filter in Hive.  However,
comment|// we still provide the full predicate to the storage handler in
comment|// case it wants to do any of its own prefiltering.
name|tableScanDesc
operator|.
name|setFilterExpr
argument_list|(
name|originalPredicate
argument_list|)
expr_stmt|;
return|return
name|originalPredicate
return|;
block|}
name|HiveStoragePredicateHandler
name|predicateHandler
init|=
operator|(
name|HiveStoragePredicateHandler
operator|)
name|storageHandler
decl_stmt|;
name|JobConf
name|jobConf
init|=
operator|new
name|JobConf
argument_list|(
name|owi
operator|.
name|getParseContext
argument_list|()
operator|.
name|getConf
argument_list|()
argument_list|)
decl_stmt|;
name|Utilities
operator|.
name|setColumnNameList
argument_list|(
name|jobConf
argument_list|,
name|tableScanOp
argument_list|)
expr_stmt|;
name|Utilities
operator|.
name|setColumnTypeList
argument_list|(
name|jobConf
argument_list|,
name|tableScanOp
argument_list|)
expr_stmt|;
name|Utilities
operator|.
name|copyTableJobPropertiesToConf
argument_list|(
name|Utilities
operator|.
name|getTableDesc
argument_list|(
name|tbl
argument_list|)
argument_list|,
name|jobConf
argument_list|)
expr_stmt|;
name|Deserializer
name|deserializer
init|=
name|tbl
operator|.
name|getDeserializer
argument_list|()
decl_stmt|;
name|HiveStoragePredicateHandler
operator|.
name|DecomposedPredicate
name|decomposed
init|=
name|predicateHandler
operator|.
name|decomposePredicate
argument_list|(
name|jobConf
argument_list|,
name|deserializer
argument_list|,
name|originalPredicate
argument_list|)
decl_stmt|;
if|if
condition|(
name|decomposed
operator|==
literal|null
condition|)
block|{
comment|// not able to push anything down
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"No pushdown possible for predicate:  "
operator|+
name|originalPredicate
operator|.
name|getExprString
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|originalPredicate
return|;
block|}
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Original predicate:  "
operator|+
name|originalPredicate
operator|.
name|getExprString
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|decomposed
operator|.
name|pushedPredicate
operator|!=
literal|null
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Pushed predicate:  "
operator|+
name|decomposed
operator|.
name|pushedPredicate
operator|.
name|getExprString
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|decomposed
operator|.
name|residualPredicate
operator|!=
literal|null
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Residual predicate:  "
operator|+
name|decomposed
operator|.
name|residualPredicate
operator|.
name|getExprString
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
name|tableScanDesc
operator|.
name|setFilterExpr
argument_list|(
name|decomposed
operator|.
name|pushedPredicate
argument_list|)
expr_stmt|;
name|tableScanDesc
operator|.
name|setFilterObject
argument_list|(
name|decomposed
operator|.
name|pushedPredicateObject
argument_list|)
expr_stmt|;
return|return
name|decomposed
operator|.
name|residualPredicate
return|;
block|}
specifier|public
specifier|static
name|NodeProcessor
name|getFilterProc
parameter_list|()
block|{
return|return
operator|new
name|FilterPPD
argument_list|()
return|;
block|}
specifier|public
specifier|static
name|NodeProcessor
name|getJoinProc
parameter_list|()
block|{
return|return
operator|new
name|JoinPPD
argument_list|()
return|;
block|}
specifier|public
specifier|static
name|NodeProcessor
name|getTSProc
parameter_list|()
block|{
return|return
operator|new
name|TableScanPPD
argument_list|()
return|;
block|}
specifier|public
specifier|static
name|NodeProcessor
name|getDefaultProc
parameter_list|()
block|{
return|return
operator|new
name|DefaultPPD
argument_list|()
return|;
block|}
specifier|public
specifier|static
name|NodeProcessor
name|getPTFProc
parameter_list|()
block|{
return|return
operator|new
name|PTFPPD
argument_list|()
return|;
block|}
specifier|public
specifier|static
name|NodeProcessor
name|getSCRProc
parameter_list|()
block|{
return|return
operator|new
name|ScriptPPD
argument_list|()
return|;
block|}
specifier|public
specifier|static
name|NodeProcessor
name|getLIMProc
parameter_list|()
block|{
return|return
operator|new
name|ScriptPPD
argument_list|()
return|;
block|}
specifier|public
specifier|static
name|NodeProcessor
name|getLVFProc
parameter_list|()
block|{
return|return
operator|new
name|LateralViewForwardPPD
argument_list|()
return|;
block|}
specifier|public
specifier|static
name|NodeProcessor
name|getUDTFProc
parameter_list|()
block|{
return|return
operator|new
name|UDTFPPD
argument_list|()
return|;
block|}
specifier|public
specifier|static
name|NodeProcessor
name|getLVJProc
parameter_list|()
block|{
return|return
operator|new
name|JoinerPPD
argument_list|()
return|;
block|}
specifier|public
specifier|static
name|NodeProcessor
name|getRSProc
parameter_list|()
block|{
return|return
operator|new
name|ReduceSinkPPD
argument_list|()
return|;
block|}
specifier|private
name|OpProcFactory
parameter_list|()
block|{
comment|// prevent instantiation
block|}
block|}
end_class

end_unit

