begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|ByteArrayOutputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|DataInput
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|PrintStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|Serializable
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|InetAddress
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|LinkedHashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|LinkedHashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|LinkedList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Queue
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|TimeUnit
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|locks
operator|.
name|ReentrantLock
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Iterables
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|lang
operator|.
name|StringUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FSDataInputStream
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|common
operator|.
name|ValidTxnList
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|common
operator|.
name|metrics
operator|.
name|common
operator|.
name|Metrics
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|common
operator|.
name|metrics
operator|.
name|common
operator|.
name|MetricsConstant
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|common
operator|.
name|metrics
operator|.
name|common
operator|.
name|MetricsFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|conf
operator|.
name|HiveConf
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|conf
operator|.
name|HiveConf
operator|.
name|ConfVars
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|conf
operator|.
name|HiveVariableSource
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|conf
operator|.
name|VariableSubstitution
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|metastore
operator|.
name|MetaStoreUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|metastore
operator|.
name|api
operator|.
name|FieldSchema
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|metastore
operator|.
name|api
operator|.
name|Schema
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|ConditionalTask
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|ExplainTask
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|FetchTask
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|TableScanOperator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|Task
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|TaskFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|TaskResult
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|TaskRunner
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|Utilities
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|history
operator|.
name|HiveHistory
operator|.
name|Keys
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|hooks
operator|.
name|Entity
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|hooks
operator|.
name|ExecuteWithHookContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|hooks
operator|.
name|Hook
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|hooks
operator|.
name|HookContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|hooks
operator|.
name|HookUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|hooks
operator|.
name|MetricsQueryLifeTimeHook
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|hooks
operator|.
name|PostExecute
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|hooks
operator|.
name|PreExecute
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|hooks
operator|.
name|QueryLifeTimeHook
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|hooks
operator|.
name|QueryLifeTimeHookContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|hooks
operator|.
name|QueryLifeTimeHookContextImpl
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|hooks
operator|.
name|ReadEntity
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|hooks
operator|.
name|WriteEntity
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|lockmgr
operator|.
name|HiveLock
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|lockmgr
operator|.
name|HiveTxnManager
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|lockmgr
operator|.
name|LockException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|log
operator|.
name|PerfLogger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|metadata
operator|.
name|AuthorizationException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|metadata
operator|.
name|Hive
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|metadata
operator|.
name|HiveException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|metadata
operator|.
name|Partition
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|metadata
operator|.
name|Table
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|metadata
operator|.
name|formatting
operator|.
name|JsonMetaDataFormatter
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|metadata
operator|.
name|formatting
operator|.
name|MetaDataFormatUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|metadata
operator|.
name|formatting
operator|.
name|MetaDataFormatter
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|optimizer
operator|.
name|ppr
operator|.
name|PartitionPruner
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|parse
operator|.
name|ASTNode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|parse
operator|.
name|BaseSemanticAnalyzer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|parse
operator|.
name|ColumnAccessInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|parse
operator|.
name|HiveSemanticAnalyzerHook
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|parse
operator|.
name|HiveSemanticAnalyzerHookContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|parse
operator|.
name|HiveSemanticAnalyzerHookContextImpl
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|parse
operator|.
name|ImportSemanticAnalyzer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|parse
operator|.
name|ParseContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|parse
operator|.
name|ParseDriver
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|parse
operator|.
name|ParseUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|parse
operator|.
name|PrunedPartitionList
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|parse
operator|.
name|SemanticAnalyzer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|parse
operator|.
name|SemanticAnalyzerFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|parse
operator|.
name|ExplainConfiguration
operator|.
name|AnalyzeState
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|FileSinkDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|HiveOperation
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|TableDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|processors
operator|.
name|CommandProcessor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|processors
operator|.
name|CommandProcessorResponse
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|security
operator|.
name|authorization
operator|.
name|AuthorizationUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|security
operator|.
name|authorization
operator|.
name|HiveAuthorizationProvider
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|security
operator|.
name|authorization
operator|.
name|plugin
operator|.
name|HiveOperationType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|security
operator|.
name|authorization
operator|.
name|plugin
operator|.
name|HivePrivilegeObject
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|security
operator|.
name|authorization
operator|.
name|plugin
operator|.
name|HivePrivilegeObject
operator|.
name|HivePrivObjectActionType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|security
operator|.
name|authorization
operator|.
name|plugin
operator|.
name|HivePrivilegeObject
operator|.
name|HivePrivilegeObjectType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|security
operator|.
name|authorization
operator|.
name|plugin
operator|.
name|HiveAuthzContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|session
operator|.
name|OperationLog
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|session
operator|.
name|OperationLog
operator|.
name|LoggingLevel
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|session
operator|.
name|SessionState
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|session
operator|.
name|SessionState
operator|.
name|LogHelper
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|ByteStream
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|shims
operator|.
name|Utils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapred
operator|.
name|ClusterStatus
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapred
operator|.
name|JobClient
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapred
operator|.
name|JobConf
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|MRJobConfig
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hive
operator|.
name|common
operator|.
name|util
operator|.
name|ShutdownHookManager
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Strings
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|ImmutableMap
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Sets
import|;
end_import

begin_class
specifier|public
class|class
name|Driver
implements|implements
name|CommandProcessor
block|{
specifier|static
specifier|final
specifier|private
name|String
name|CLASS_NAME
init|=
name|Driver
operator|.
name|class
operator|.
name|getName
argument_list|()
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|Logger
name|LOG
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|CLASS_NAME
argument_list|)
decl_stmt|;
specifier|static
specifier|final
specifier|private
name|LogHelper
name|console
init|=
operator|new
name|LogHelper
argument_list|(
name|LOG
argument_list|)
decl_stmt|;
specifier|static
specifier|final
name|int
name|SHUTDOWN_HOOK_PRIORITY
init|=
literal|0
decl_stmt|;
specifier|private
name|Runnable
name|shutdownRunner
init|=
literal|null
decl_stmt|;
specifier|private
name|int
name|maxRows
init|=
literal|100
decl_stmt|;
name|ByteStream
operator|.
name|Output
name|bos
init|=
operator|new
name|ByteStream
operator|.
name|Output
argument_list|()
decl_stmt|;
specifier|private
specifier|final
name|HiveConf
name|conf
decl_stmt|;
specifier|private
specifier|final
name|boolean
name|isParallelEnabled
decl_stmt|;
specifier|private
name|DataInput
name|resStream
decl_stmt|;
specifier|private
name|Context
name|ctx
decl_stmt|;
specifier|private
name|DriverContext
name|driverCxt
decl_stmt|;
specifier|private
name|QueryPlan
name|plan
decl_stmt|;
specifier|private
name|Schema
name|schema
decl_stmt|;
specifier|private
name|String
name|errorMessage
decl_stmt|;
specifier|private
name|String
name|SQLState
decl_stmt|;
specifier|private
name|Throwable
name|downstreamError
decl_stmt|;
specifier|private
name|FetchTask
name|fetchTask
decl_stmt|;
name|List
argument_list|<
name|HiveLock
argument_list|>
name|hiveLocks
init|=
operator|new
name|ArrayList
argument_list|<
name|HiveLock
argument_list|>
argument_list|()
decl_stmt|;
comment|// A list of FileSinkOperators writing in an ACID compliant manner
specifier|private
name|Set
argument_list|<
name|FileSinkDesc
argument_list|>
name|acidSinks
decl_stmt|;
comment|// whether any ACID table is involved in a query
specifier|private
name|boolean
name|acidInQuery
decl_stmt|;
comment|// A limit on the number of threads that can be launched
specifier|private
name|int
name|maxthreads
decl_stmt|;
specifier|private
name|int
name|tryCount
init|=
name|Integer
operator|.
name|MAX_VALUE
decl_stmt|;
specifier|private
name|String
name|userName
decl_stmt|;
comment|// HS2 operation handle guid string
specifier|private
name|String
name|operationId
decl_stmt|;
comment|// For WebUI.  Kept alive after queryPlan is freed.
specifier|private
specifier|final
name|QueryDisplay
name|queryDisplay
init|=
operator|new
name|QueryDisplay
argument_list|()
decl_stmt|;
specifier|private
name|LockedDriverState
name|lDrvState
init|=
operator|new
name|LockedDriverState
argument_list|()
decl_stmt|;
comment|// Query specific info
specifier|private
name|QueryState
name|queryState
decl_stmt|;
comment|// Query hooks that execute before compilation and after execution
specifier|private
name|List
argument_list|<
name|QueryLifeTimeHook
argument_list|>
name|queryHooks
decl_stmt|;
specifier|public
enum|enum
name|DriverState
block|{
name|INITIALIZED
block|,
name|COMPILING
block|,
name|COMPILED
block|,
name|EXECUTING
block|,
name|EXECUTED
block|,
comment|// a state that the driver enters after close() has been called to interrupt its running
comment|// query in the query cancellation
name|INTERRUPT
block|,
comment|// a state that the driver enters after close() has been called to clean the query results
comment|// and release the resources after the query has been executed
name|CLOSED
block|,
comment|// a state that the driver enters after destroy() is called and it is the end of driver life cycle
name|DESTROYED
block|,
name|ERROR
block|}
specifier|public
specifier|static
class|class
name|LockedDriverState
block|{
comment|// a lock is used for synchronizing the state transition and its associated
comment|// resource releases
specifier|public
specifier|final
name|ReentrantLock
name|stateLock
init|=
operator|new
name|ReentrantLock
argument_list|()
decl_stmt|;
specifier|public
name|DriverState
name|driverState
init|=
name|DriverState
operator|.
name|INITIALIZED
decl_stmt|;
block|}
specifier|private
name|boolean
name|checkConcurrency
parameter_list|()
block|{
name|boolean
name|supportConcurrency
init|=
name|conf
operator|.
name|getBoolVar
argument_list|(
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVE_SUPPORT_CONCURRENCY
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|supportConcurrency
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Concurrency mode is disabled, not creating a lock manager"
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
return|return
literal|true
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|init
parameter_list|()
block|{
comment|// Nothing for now.
block|}
comment|/**    * Return the status information about the Map-Reduce cluster    */
specifier|public
name|ClusterStatus
name|getClusterStatus
parameter_list|()
throws|throws
name|Exception
block|{
name|ClusterStatus
name|cs
decl_stmt|;
try|try
block|{
name|JobConf
name|job
init|=
operator|new
name|JobConf
argument_list|(
name|conf
argument_list|)
decl_stmt|;
name|JobClient
name|jc
init|=
operator|new
name|JobClient
argument_list|(
name|job
argument_list|)
decl_stmt|;
name|cs
operator|=
name|jc
operator|.
name|getClusterStatus
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|e
operator|.
name|printStackTrace
argument_list|()
expr_stmt|;
throw|throw
name|e
throw|;
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"Returning cluster status: "
operator|+
name|cs
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|cs
return|;
block|}
specifier|public
name|Schema
name|getSchema
parameter_list|()
block|{
return|return
name|schema
return|;
block|}
comment|/**    * Get a Schema with fields represented with native Hive types    */
specifier|private
specifier|static
name|Schema
name|getSchema
parameter_list|(
name|BaseSemanticAnalyzer
name|sem
parameter_list|,
name|HiveConf
name|conf
parameter_list|)
block|{
name|Schema
name|schema
init|=
literal|null
decl_stmt|;
comment|// If we have a plan, prefer its logical result schema if it's
comment|// available; otherwise, try digging out a fetch task; failing that,
comment|// give up.
if|if
condition|(
name|sem
operator|==
literal|null
condition|)
block|{
comment|// can't get any info without a plan
block|}
elseif|else
if|if
condition|(
name|sem
operator|.
name|getResultSchema
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|List
argument_list|<
name|FieldSchema
argument_list|>
name|lst
init|=
name|sem
operator|.
name|getResultSchema
argument_list|()
decl_stmt|;
name|schema
operator|=
operator|new
name|Schema
argument_list|(
name|lst
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sem
operator|.
name|getFetchTask
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|FetchTask
name|ft
init|=
name|sem
operator|.
name|getFetchTask
argument_list|()
decl_stmt|;
name|TableDesc
name|td
init|=
name|ft
operator|.
name|getTblDesc
argument_list|()
decl_stmt|;
comment|// partitioned tables don't have tableDesc set on the FetchTask. Instead
comment|// they have a list of PartitionDesc objects, each with a table desc.
comment|// Let's
comment|// try to fetch the desc for the first partition and use it's
comment|// deserializer.
if|if
condition|(
name|td
operator|==
literal|null
operator|&&
name|ft
operator|.
name|getWork
argument_list|()
operator|!=
literal|null
operator|&&
name|ft
operator|.
name|getWork
argument_list|()
operator|.
name|getPartDesc
argument_list|()
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|ft
operator|.
name|getWork
argument_list|()
operator|.
name|getPartDesc
argument_list|()
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
name|td
operator|=
name|ft
operator|.
name|getWork
argument_list|()
operator|.
name|getPartDesc
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|getTableDesc
argument_list|()
expr_stmt|;
block|}
block|}
if|if
condition|(
name|td
operator|==
literal|null
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"No returning schema."
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|String
name|tableName
init|=
literal|"result"
decl_stmt|;
name|List
argument_list|<
name|FieldSchema
argument_list|>
name|lst
init|=
literal|null
decl_stmt|;
try|try
block|{
name|lst
operator|=
name|MetaStoreUtils
operator|.
name|getFieldsFromDeserializer
argument_list|(
name|tableName
argument_list|,
name|td
operator|.
name|getDeserializer
argument_list|(
name|conf
argument_list|)
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Error getting schema: "
operator|+
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|StringUtils
operator|.
name|stringifyException
argument_list|(
name|e
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|lst
operator|!=
literal|null
condition|)
block|{
name|schema
operator|=
operator|new
name|Schema
argument_list|(
name|lst
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|schema
operator|==
literal|null
condition|)
block|{
name|schema
operator|=
operator|new
name|Schema
argument_list|()
expr_stmt|;
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"Returning Hive schema: "
operator|+
name|schema
argument_list|)
expr_stmt|;
return|return
name|schema
return|;
block|}
comment|/**    * Get a Schema with fields represented with Thrift DDL types    */
specifier|public
name|Schema
name|getThriftSchema
parameter_list|()
throws|throws
name|Exception
block|{
name|Schema
name|schema
decl_stmt|;
try|try
block|{
name|schema
operator|=
name|getSchema
argument_list|()
expr_stmt|;
if|if
condition|(
name|schema
operator|!=
literal|null
condition|)
block|{
name|List
argument_list|<
name|FieldSchema
argument_list|>
name|lst
init|=
name|schema
operator|.
name|getFieldSchemas
argument_list|()
decl_stmt|;
comment|// Go over the schema and convert type to thrift type
if|if
condition|(
name|lst
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|FieldSchema
name|f
range|:
name|lst
control|)
block|{
name|f
operator|.
name|setType
argument_list|(
name|MetaStoreUtils
operator|.
name|typeToThriftType
argument_list|(
name|f
operator|.
name|getType
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|e
operator|.
name|printStackTrace
argument_list|()
expr_stmt|;
throw|throw
name|e
throw|;
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"Returning Thrift schema: "
operator|+
name|schema
argument_list|)
expr_stmt|;
return|return
name|schema
return|;
block|}
comment|/**    * Return the maximum number of rows returned by getResults    */
specifier|public
name|int
name|getMaxRows
parameter_list|()
block|{
return|return
name|maxRows
return|;
block|}
comment|/**    * Set the maximum number of rows returned by getResults    */
specifier|public
name|void
name|setMaxRows
parameter_list|(
name|int
name|maxRows
parameter_list|)
block|{
name|this
operator|.
name|maxRows
operator|=
name|maxRows
expr_stmt|;
block|}
specifier|public
name|Driver
parameter_list|()
block|{
name|this
argument_list|(
operator|new
name|QueryState
argument_list|(
operator|(
name|SessionState
operator|.
name|get
argument_list|()
operator|!=
literal|null
operator|)
condition|?
name|SessionState
operator|.
name|get
argument_list|()
operator|.
name|getConf
argument_list|()
else|:
operator|new
name|HiveConf
argument_list|()
argument_list|)
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
specifier|public
name|Driver
parameter_list|(
name|HiveConf
name|conf
parameter_list|)
block|{
name|this
argument_list|(
operator|new
name|QueryState
argument_list|(
name|conf
argument_list|)
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
specifier|public
name|Driver
parameter_list|(
name|HiveConf
name|conf
parameter_list|,
name|Context
name|ctx
parameter_list|)
block|{
name|this
argument_list|(
operator|new
name|QueryState
argument_list|(
name|conf
argument_list|)
argument_list|,
literal|null
argument_list|)
expr_stmt|;
name|this
operator|.
name|ctx
operator|=
name|ctx
expr_stmt|;
block|}
specifier|public
name|Driver
parameter_list|(
name|HiveConf
name|conf
parameter_list|,
name|String
name|userName
parameter_list|)
block|{
name|this
argument_list|(
operator|new
name|QueryState
argument_list|(
name|conf
argument_list|)
argument_list|,
name|userName
argument_list|)
expr_stmt|;
block|}
specifier|public
name|Driver
parameter_list|(
name|QueryState
name|queryState
parameter_list|,
name|String
name|userName
parameter_list|)
block|{
name|this
operator|.
name|queryState
operator|=
name|queryState
expr_stmt|;
name|this
operator|.
name|conf
operator|=
name|queryState
operator|.
name|getConf
argument_list|()
expr_stmt|;
name|isParallelEnabled
operator|=
operator|(
name|conf
operator|!=
literal|null
operator|)
operator|&&
name|HiveConf
operator|.
name|getBoolVar
argument_list|(
name|conf
argument_list|,
name|ConfVars
operator|.
name|HIVE_SERVER2_PARALLEL_COMPILATION
argument_list|)
expr_stmt|;
name|this
operator|.
name|userName
operator|=
name|userName
expr_stmt|;
block|}
comment|/**    * Compile a new query. Any currently-planned query associated with this Driver is discarded.    * Do not reset id for inner queries(index, etc). Task ids are used for task identity check.    *    * @param command    *          The SQL query to compile.    */
specifier|public
name|int
name|compile
parameter_list|(
name|String
name|command
parameter_list|)
block|{
return|return
name|compile
argument_list|(
name|command
argument_list|,
literal|true
argument_list|)
return|;
block|}
comment|/**    * Compile a new query, but potentially reset taskID counter.  Not resetting task counter    * is useful for generating re-entrant QL queries.    * @param command  The HiveQL query to compile    * @param resetTaskIds Resets taskID counter if true.    * @return 0 for ok    */
specifier|public
name|int
name|compile
parameter_list|(
name|String
name|command
parameter_list|,
name|boolean
name|resetTaskIds
parameter_list|)
block|{
return|return
name|compile
argument_list|(
name|command
argument_list|,
name|resetTaskIds
argument_list|,
literal|false
argument_list|)
return|;
block|}
comment|// deferClose indicates if the close/destroy should be deferred when the process has been
comment|// interrupted, it should be set to true if the compile is called within another method like
comment|// runInternal, which defers the close to the called in that method.
specifier|public
name|int
name|compile
parameter_list|(
name|String
name|command
parameter_list|,
name|boolean
name|resetTaskIds
parameter_list|,
name|boolean
name|deferClose
parameter_list|)
block|{
name|PerfLogger
name|perfLogger
init|=
name|SessionState
operator|.
name|getPerfLogger
argument_list|(
literal|true
argument_list|)
decl_stmt|;
name|perfLogger
operator|.
name|PerfLogBegin
argument_list|(
name|CLASS_NAME
argument_list|,
name|PerfLogger
operator|.
name|DRIVER_RUN
argument_list|)
expr_stmt|;
name|perfLogger
operator|.
name|PerfLogBegin
argument_list|(
name|CLASS_NAME
argument_list|,
name|PerfLogger
operator|.
name|COMPILE
argument_list|)
expr_stmt|;
name|lDrvState
operator|.
name|stateLock
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
name|lDrvState
operator|.
name|driverState
operator|=
name|DriverState
operator|.
name|COMPILING
expr_stmt|;
block|}
finally|finally
block|{
name|lDrvState
operator|.
name|stateLock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
name|command
operator|=
operator|new
name|VariableSubstitution
argument_list|(
operator|new
name|HiveVariableSource
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|getHiveVariable
parameter_list|()
block|{
return|return
name|SessionState
operator|.
name|get
argument_list|()
operator|.
name|getHiveVariables
argument_list|()
return|;
block|}
block|}
argument_list|)
operator|.
name|substitute
argument_list|(
name|conf
argument_list|,
name|command
argument_list|)
expr_stmt|;
name|String
name|queryStr
init|=
name|command
decl_stmt|;
try|try
block|{
comment|// command should be redacted to avoid to logging sensitive data
name|queryStr
operator|=
name|HookUtils
operator|.
name|redactLogString
argument_list|(
name|conf
argument_list|,
name|command
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"WARNING! Query command could not be redacted."
operator|+
name|e
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|isInterrupted
argument_list|()
condition|)
block|{
return|return
name|handleInterruption
argument_list|(
literal|"at beginning of compilation."
argument_list|)
return|;
comment|//indicate if need clean resource
block|}
if|if
condition|(
name|ctx
operator|!=
literal|null
operator|&&
name|ctx
operator|.
name|getExplainAnalyze
argument_list|()
operator|!=
name|AnalyzeState
operator|.
name|RUNNING
condition|)
block|{
comment|// close the existing ctx etc before compiling a new query, but does not destroy driver
name|closeInProcess
argument_list|(
literal|false
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|resetTaskIds
condition|)
block|{
name|TaskFactory
operator|.
name|resetId
argument_list|()
expr_stmt|;
block|}
name|String
name|queryId
init|=
name|conf
operator|.
name|getVar
argument_list|(
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVEQUERYID
argument_list|)
decl_stmt|;
comment|//save some info for webUI for use after plan is freed
name|this
operator|.
name|queryDisplay
operator|.
name|setQueryStr
argument_list|(
name|queryStr
argument_list|)
expr_stmt|;
name|this
operator|.
name|queryDisplay
operator|.
name|setQueryId
argument_list|(
name|queryId
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Compiling command(queryId="
operator|+
name|queryId
operator|+
literal|"): "
operator|+
name|queryStr
argument_list|)
expr_stmt|;
name|SessionState
operator|.
name|get
argument_list|()
operator|.
name|setupQueryCurrentTimestamp
argument_list|()
expr_stmt|;
comment|// Whether any error occurred during query compilation. Used for query lifetime hook.
name|boolean
name|compileError
init|=
literal|false
decl_stmt|;
try|try
block|{
comment|// Initialize the transaction manager.  This must be done before analyze is called.
specifier|final
name|HiveTxnManager
name|txnManager
init|=
name|SessionState
operator|.
name|get
argument_list|()
operator|.
name|initTxnMgr
argument_list|(
name|conf
argument_list|)
decl_stmt|;
comment|// In case when user Ctrl-C twice to kill Hive CLI JVM, we want to release locks
comment|// if compile is being called multiple times, clear the old shutdownhook
name|ShutdownHookManager
operator|.
name|removeShutdownHook
argument_list|(
name|shutdownRunner
argument_list|)
expr_stmt|;
name|shutdownRunner
operator|=
operator|new
name|Runnable
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|void
name|run
parameter_list|()
block|{
try|try
block|{
name|releaseLocksAndCommitOrRollback
argument_list|(
literal|false
argument_list|,
name|txnManager
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|LockException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Exception when releasing locks in ShutdownHook for Driver: "
operator|+
name|e
operator|.
name|getMessage
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
expr_stmt|;
name|ShutdownHookManager
operator|.
name|addShutdownHook
argument_list|(
name|shutdownRunner
argument_list|,
name|SHUTDOWN_HOOK_PRIORITY
argument_list|)
expr_stmt|;
if|if
condition|(
name|isInterrupted
argument_list|()
condition|)
block|{
return|return
name|handleInterruption
argument_list|(
literal|"before parsing and analysing the query"
argument_list|)
return|;
block|}
if|if
condition|(
name|ctx
operator|==
literal|null
condition|)
block|{
name|ctx
operator|=
operator|new
name|Context
argument_list|(
name|conf
argument_list|)
expr_stmt|;
block|}
name|ctx
operator|.
name|setTryCount
argument_list|(
name|getTryCount
argument_list|()
argument_list|)
expr_stmt|;
name|ctx
operator|.
name|setCmd
argument_list|(
name|command
argument_list|)
expr_stmt|;
name|ctx
operator|.
name|setHDFSCleanup
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|perfLogger
operator|.
name|PerfLogBegin
argument_list|(
name|CLASS_NAME
argument_list|,
name|PerfLogger
operator|.
name|PARSE
argument_list|)
expr_stmt|;
name|ASTNode
name|tree
init|=
name|ParseUtils
operator|.
name|parse
argument_list|(
name|command
argument_list|,
name|ctx
argument_list|)
decl_stmt|;
name|perfLogger
operator|.
name|PerfLogEnd
argument_list|(
name|CLASS_NAME
argument_list|,
name|PerfLogger
operator|.
name|PARSE
argument_list|)
expr_stmt|;
comment|// Trigger query hook before compilation
name|queryHooks
operator|=
name|loadQueryHooks
argument_list|()
expr_stmt|;
if|if
condition|(
name|queryHooks
operator|!=
literal|null
operator|&&
operator|!
name|queryHooks
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|QueryLifeTimeHookContext
name|qhc
init|=
operator|new
name|QueryLifeTimeHookContextImpl
argument_list|()
decl_stmt|;
name|qhc
operator|.
name|setHiveConf
argument_list|(
name|conf
argument_list|)
expr_stmt|;
name|qhc
operator|.
name|setCommand
argument_list|(
name|command
argument_list|)
expr_stmt|;
for|for
control|(
name|QueryLifeTimeHook
name|hook
range|:
name|queryHooks
control|)
block|{
name|hook
operator|.
name|beforeCompile
argument_list|(
name|qhc
argument_list|)
expr_stmt|;
block|}
block|}
name|perfLogger
operator|.
name|PerfLogBegin
argument_list|(
name|CLASS_NAME
argument_list|,
name|PerfLogger
operator|.
name|ANALYZE
argument_list|)
expr_stmt|;
name|BaseSemanticAnalyzer
name|sem
init|=
name|SemanticAnalyzerFactory
operator|.
name|get
argument_list|(
name|queryState
argument_list|,
name|tree
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|HiveSemanticAnalyzerHook
argument_list|>
name|saHooks
init|=
name|getHooks
argument_list|(
name|HiveConf
operator|.
name|ConfVars
operator|.
name|SEMANTIC_ANALYZER_HOOK
argument_list|,
name|HiveSemanticAnalyzerHook
operator|.
name|class
argument_list|)
decl_stmt|;
comment|// Flush the metastore cache.  This assures that we don't pick up objects from a previous
comment|// query running in this same thread.  This has to be done after we get our semantic
comment|// analyzer (this is when the connection to the metastore is made) but before we analyze,
comment|// because at that point we need access to the objects.
name|Hive
operator|.
name|get
argument_list|()
operator|.
name|getMSC
argument_list|()
operator|.
name|flushCache
argument_list|()
expr_stmt|;
comment|// Do semantic analysis and plan generation
if|if
condition|(
name|saHooks
operator|!=
literal|null
operator|&&
operator|!
name|saHooks
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|HiveSemanticAnalyzerHookContext
name|hookCtx
init|=
operator|new
name|HiveSemanticAnalyzerHookContextImpl
argument_list|()
decl_stmt|;
name|hookCtx
operator|.
name|setConf
argument_list|(
name|conf
argument_list|)
expr_stmt|;
name|hookCtx
operator|.
name|setUserName
argument_list|(
name|userName
argument_list|)
expr_stmt|;
name|hookCtx
operator|.
name|setIpAddress
argument_list|(
name|SessionState
operator|.
name|get
argument_list|()
operator|.
name|getUserIpAddress
argument_list|()
argument_list|)
expr_stmt|;
name|hookCtx
operator|.
name|setCommand
argument_list|(
name|command
argument_list|)
expr_stmt|;
for|for
control|(
name|HiveSemanticAnalyzerHook
name|hook
range|:
name|saHooks
control|)
block|{
name|tree
operator|=
name|hook
operator|.
name|preAnalyze
argument_list|(
name|hookCtx
argument_list|,
name|tree
argument_list|)
expr_stmt|;
block|}
name|sem
operator|.
name|analyze
argument_list|(
name|tree
argument_list|,
name|ctx
argument_list|)
expr_stmt|;
name|hookCtx
operator|.
name|update
argument_list|(
name|sem
argument_list|)
expr_stmt|;
for|for
control|(
name|HiveSemanticAnalyzerHook
name|hook
range|:
name|saHooks
control|)
block|{
name|hook
operator|.
name|postAnalyze
argument_list|(
name|hookCtx
argument_list|,
name|sem
operator|.
name|getAllRootTasks
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|sem
operator|.
name|analyze
argument_list|(
name|tree
argument_list|,
name|ctx
argument_list|)
expr_stmt|;
block|}
comment|// Record any ACID compliant FileSinkOperators we saw so we can add our transaction ID to
comment|// them later.
name|acidSinks
operator|=
name|sem
operator|.
name|getAcidFileSinks
argument_list|()
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Semantic Analysis Completed"
argument_list|)
expr_stmt|;
comment|// validate the plan
name|sem
operator|.
name|validate
argument_list|()
expr_stmt|;
name|acidInQuery
operator|=
name|sem
operator|.
name|hasAcidInQuery
argument_list|()
expr_stmt|;
name|perfLogger
operator|.
name|PerfLogEnd
argument_list|(
name|CLASS_NAME
argument_list|,
name|PerfLogger
operator|.
name|ANALYZE
argument_list|)
expr_stmt|;
if|if
condition|(
name|isInterrupted
argument_list|()
condition|)
block|{
return|return
name|handleInterruption
argument_list|(
literal|"after analyzing query."
argument_list|)
return|;
block|}
comment|// get the output schema
name|schema
operator|=
name|getSchema
argument_list|(
name|sem
argument_list|,
name|conf
argument_list|)
expr_stmt|;
name|plan
operator|=
operator|new
name|QueryPlan
argument_list|(
name|queryStr
argument_list|,
name|sem
argument_list|,
name|perfLogger
operator|.
name|getStartTime
argument_list|(
name|PerfLogger
operator|.
name|DRIVER_RUN
argument_list|)
argument_list|,
name|queryId
argument_list|,
name|queryState
operator|.
name|getHiveOperation
argument_list|()
argument_list|,
name|schema
argument_list|)
expr_stmt|;
name|conf
operator|.
name|setQueryString
argument_list|(
name|queryStr
argument_list|)
expr_stmt|;
name|conf
operator|.
name|set
argument_list|(
literal|"mapreduce.workflow.id"
argument_list|,
literal|"hive_"
operator|+
name|queryId
argument_list|)
expr_stmt|;
name|conf
operator|.
name|set
argument_list|(
literal|"mapreduce.workflow.name"
argument_list|,
name|queryStr
argument_list|)
expr_stmt|;
comment|// initialize FetchTask right here
if|if
condition|(
name|plan
operator|.
name|getFetchTask
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|plan
operator|.
name|getFetchTask
argument_list|()
operator|.
name|initialize
argument_list|(
name|queryState
argument_list|,
name|plan
argument_list|,
literal|null
argument_list|,
name|ctx
operator|.
name|getOpContext
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|//do the authorization check
if|if
condition|(
operator|!
name|sem
operator|.
name|skipAuthorization
argument_list|()
operator|&&
name|HiveConf
operator|.
name|getBoolVar
argument_list|(
name|conf
argument_list|,
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVE_AUTHORIZATION_ENABLED
argument_list|)
condition|)
block|{
try|try
block|{
name|perfLogger
operator|.
name|PerfLogBegin
argument_list|(
name|CLASS_NAME
argument_list|,
name|PerfLogger
operator|.
name|DO_AUTHORIZATION
argument_list|)
expr_stmt|;
name|doAuthorization
argument_list|(
name|queryState
operator|.
name|getHiveOperation
argument_list|()
argument_list|,
name|sem
argument_list|,
name|command
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|AuthorizationException
name|authExp
parameter_list|)
block|{
name|console
operator|.
name|printError
argument_list|(
literal|"Authorization failed:"
operator|+
name|authExp
operator|.
name|getMessage
argument_list|()
operator|+
literal|". Use SHOW GRANT to get more details."
argument_list|)
expr_stmt|;
name|errorMessage
operator|=
name|authExp
operator|.
name|getMessage
argument_list|()
expr_stmt|;
name|SQLState
operator|=
literal|"42000"
expr_stmt|;
return|return
literal|403
return|;
block|}
finally|finally
block|{
name|perfLogger
operator|.
name|PerfLogEnd
argument_list|(
name|CLASS_NAME
argument_list|,
name|PerfLogger
operator|.
name|DO_AUTHORIZATION
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|conf
operator|.
name|getBoolVar
argument_list|(
name|ConfVars
operator|.
name|HIVE_LOG_EXPLAIN_OUTPUT
argument_list|)
condition|)
block|{
name|String
name|explainOutput
init|=
name|getExplainOutput
argument_list|(
name|sem
argument_list|,
name|plan
argument_list|,
name|tree
argument_list|)
decl_stmt|;
if|if
condition|(
name|explainOutput
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|conf
operator|.
name|getBoolVar
argument_list|(
name|ConfVars
operator|.
name|HIVE_LOG_EXPLAIN_OUTPUT
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"EXPLAIN output for queryid "
operator|+
name|queryId
operator|+
literal|" : "
operator|+
name|explainOutput
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|conf
operator|.
name|isWebUiQueryInfoCacheEnabled
argument_list|()
condition|)
block|{
name|queryDisplay
operator|.
name|setExplainPlan
argument_list|(
name|explainOutput
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
literal|0
return|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
if|if
condition|(
name|isInterrupted
argument_list|()
condition|)
block|{
return|return
name|handleInterruption
argument_list|(
literal|"during query compilation: "
operator|+
name|e
operator|.
name|getMessage
argument_list|()
argument_list|)
return|;
block|}
name|compileError
operator|=
literal|true
expr_stmt|;
name|ErrorMsg
name|error
init|=
name|ErrorMsg
operator|.
name|getErrorMsg
argument_list|(
name|e
operator|.
name|getMessage
argument_list|()
argument_list|)
decl_stmt|;
name|errorMessage
operator|=
literal|"FAILED: "
operator|+
name|e
operator|.
name|getClass
argument_list|()
operator|.
name|getSimpleName
argument_list|()
expr_stmt|;
if|if
condition|(
name|error
operator|!=
name|ErrorMsg
operator|.
name|GENERIC_ERROR
condition|)
block|{
name|errorMessage
operator|+=
literal|" [Error "
operator|+
name|error
operator|.
name|getErrorCode
argument_list|()
operator|+
literal|"]:"
expr_stmt|;
block|}
comment|// HIVE-4889
if|if
condition|(
operator|(
name|e
operator|instanceof
name|IllegalArgumentException
operator|)
operator|&&
name|e
operator|.
name|getMessage
argument_list|()
operator|==
literal|null
operator|&&
name|e
operator|.
name|getCause
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|errorMessage
operator|+=
literal|" "
operator|+
name|e
operator|.
name|getCause
argument_list|()
operator|.
name|getMessage
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|errorMessage
operator|+=
literal|" "
operator|+
name|e
operator|.
name|getMessage
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|error
operator|==
name|ErrorMsg
operator|.
name|TXNMGR_NOT_ACID
condition|)
block|{
name|errorMessage
operator|+=
literal|". Failed command: "
operator|+
name|queryStr
expr_stmt|;
block|}
name|SQLState
operator|=
name|error
operator|.
name|getSQLState
argument_list|()
expr_stmt|;
name|downstreamError
operator|=
name|e
expr_stmt|;
name|console
operator|.
name|printError
argument_list|(
name|errorMessage
argument_list|,
literal|"\n"
operator|+
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|StringUtils
operator|.
name|stringifyException
argument_list|(
name|e
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|error
operator|.
name|getErrorCode
argument_list|()
return|;
comment|//todo: this is bad if returned as cmd shell exit
comment|// since it exceeds valid range of shell return values
block|}
finally|finally
block|{
comment|// Trigger post compilation hook. Note that if the compilation fails here then
comment|// before/after execution hook will never be executed.
try|try
block|{
if|if
condition|(
name|queryHooks
operator|!=
literal|null
operator|&&
operator|!
name|queryHooks
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|QueryLifeTimeHookContext
name|qhc
init|=
operator|new
name|QueryLifeTimeHookContextImpl
argument_list|()
decl_stmt|;
name|qhc
operator|.
name|setHiveConf
argument_list|(
name|conf
argument_list|)
expr_stmt|;
name|qhc
operator|.
name|setCommand
argument_list|(
name|command
argument_list|)
expr_stmt|;
for|for
control|(
name|QueryLifeTimeHook
name|hook
range|:
name|queryHooks
control|)
block|{
name|hook
operator|.
name|afterCompile
argument_list|(
name|qhc
argument_list|,
name|compileError
argument_list|)
expr_stmt|;
block|}
block|}
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Failed when invoking query after-compilation hook."
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
name|double
name|duration
init|=
name|perfLogger
operator|.
name|PerfLogEnd
argument_list|(
name|CLASS_NAME
argument_list|,
name|PerfLogger
operator|.
name|COMPILE
argument_list|)
operator|/
literal|1000.00
decl_stmt|;
name|ImmutableMap
argument_list|<
name|String
argument_list|,
name|Long
argument_list|>
name|compileHMSTimings
init|=
name|dumpMetaCallTimingWithoutEx
argument_list|(
literal|"compilation"
argument_list|)
decl_stmt|;
name|queryDisplay
operator|.
name|setHmsTimings
argument_list|(
name|QueryDisplay
operator|.
name|Phase
operator|.
name|COMPILATION
argument_list|,
name|compileHMSTimings
argument_list|)
expr_stmt|;
name|boolean
name|isInterrupted
init|=
name|isInterrupted
argument_list|()
decl_stmt|;
if|if
condition|(
name|isInterrupted
operator|&&
operator|!
name|deferClose
condition|)
block|{
name|closeInProcess
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
name|lDrvState
operator|.
name|stateLock
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
if|if
condition|(
name|isInterrupted
condition|)
block|{
name|lDrvState
operator|.
name|driverState
operator|=
name|deferClose
condition|?
name|DriverState
operator|.
name|EXECUTING
else|:
name|DriverState
operator|.
name|ERROR
expr_stmt|;
block|}
else|else
block|{
name|lDrvState
operator|.
name|driverState
operator|=
name|compileError
condition|?
name|DriverState
operator|.
name|ERROR
else|:
name|DriverState
operator|.
name|COMPILED
expr_stmt|;
block|}
block|}
finally|finally
block|{
name|lDrvState
operator|.
name|stateLock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|isInterrupted
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Compiling command(queryId="
operator|+
name|queryId
operator|+
literal|") has been interrupted after "
operator|+
name|duration
operator|+
literal|" seconds"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Completed compiling command(queryId="
operator|+
name|queryId
operator|+
literal|"); Time taken: "
operator|+
name|duration
operator|+
literal|" seconds"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
specifier|private
name|int
name|handleInterruption
parameter_list|(
name|String
name|msg
parameter_list|)
block|{
name|SQLState
operator|=
literal|"HY008"
expr_stmt|;
comment|//SQLState for cancel operation
name|errorMessage
operator|=
literal|"FAILED: command has been interrupted: "
operator|+
name|msg
expr_stmt|;
name|console
operator|.
name|printError
argument_list|(
name|errorMessage
argument_list|)
expr_stmt|;
return|return
literal|1000
return|;
block|}
specifier|private
name|boolean
name|isInterrupted
parameter_list|()
block|{
name|lDrvState
operator|.
name|stateLock
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
if|if
condition|(
name|lDrvState
operator|.
name|driverState
operator|==
name|DriverState
operator|.
name|INTERRUPT
condition|)
block|{
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|interrupt
argument_list|()
expr_stmt|;
return|return
literal|true
return|;
block|}
else|else
block|{
return|return
literal|false
return|;
block|}
block|}
finally|finally
block|{
name|lDrvState
operator|.
name|stateLock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
specifier|private
name|List
argument_list|<
name|QueryLifeTimeHook
argument_list|>
name|loadQueryHooks
parameter_list|()
throws|throws
name|Exception
block|{
name|List
argument_list|<
name|QueryLifeTimeHook
argument_list|>
name|hooks
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
if|if
condition|(
name|conf
operator|.
name|getBoolVar
argument_list|(
name|ConfVars
operator|.
name|HIVE_SERVER2_METRICS_ENABLED
argument_list|)
condition|)
block|{
name|hooks
operator|.
name|add
argument_list|(
operator|new
name|MetricsQueryLifeTimeHook
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|List
argument_list|<
name|QueryLifeTimeHook
argument_list|>
name|propertyDefinedHoooks
init|=
name|getHooks
argument_list|(
name|ConfVars
operator|.
name|HIVE_QUERY_LIFETIME_HOOKS
argument_list|,
name|QueryLifeTimeHook
operator|.
name|class
argument_list|)
decl_stmt|;
if|if
condition|(
name|propertyDefinedHoooks
operator|!=
literal|null
condition|)
block|{
name|Iterables
operator|.
name|addAll
argument_list|(
name|hooks
argument_list|,
name|propertyDefinedHoooks
argument_list|)
expr_stmt|;
block|}
return|return
name|hooks
return|;
block|}
specifier|private
name|ImmutableMap
argument_list|<
name|String
argument_list|,
name|Long
argument_list|>
name|dumpMetaCallTimingWithoutEx
parameter_list|(
name|String
name|phase
parameter_list|)
block|{
try|try
block|{
return|return
name|Hive
operator|.
name|get
argument_list|()
operator|.
name|dumpAndClearMetaCallTiming
argument_list|(
name|phase
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|HiveException
name|he
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Caught exception attempting to write metadata call information "
operator|+
name|he
argument_list|,
name|he
argument_list|)
expr_stmt|;
block|}
return|return
literal|null
return|;
block|}
comment|/**    * Returns EXPLAIN EXTENDED output for a semantically    * analyzed query.    *    * @param sem semantic analyzer for analyzed query    * @param plan query plan    * @param astTree AST tree dump    * @throws java.io.IOException    */
specifier|private
name|String
name|getExplainOutput
parameter_list|(
name|BaseSemanticAnalyzer
name|sem
parameter_list|,
name|QueryPlan
name|plan
parameter_list|,
name|ASTNode
name|astTree
parameter_list|)
throws|throws
name|IOException
block|{
name|String
name|ret
init|=
literal|null
decl_stmt|;
name|ExplainTask
name|task
init|=
operator|new
name|ExplainTask
argument_list|()
decl_stmt|;
name|task
operator|.
name|initialize
argument_list|(
name|queryState
argument_list|,
name|plan
argument_list|,
literal|null
argument_list|,
name|ctx
operator|.
name|getOpContext
argument_list|()
argument_list|)
expr_stmt|;
name|ByteArrayOutputStream
name|baos
init|=
operator|new
name|ByteArrayOutputStream
argument_list|()
decl_stmt|;
name|PrintStream
name|ps
init|=
operator|new
name|PrintStream
argument_list|(
name|baos
argument_list|)
decl_stmt|;
try|try
block|{
name|List
argument_list|<
name|Task
argument_list|<
name|?
argument_list|>
argument_list|>
name|rootTasks
init|=
name|sem
operator|.
name|getAllRootTasks
argument_list|()
decl_stmt|;
name|task
operator|.
name|getJSONPlan
argument_list|(
name|ps
argument_list|,
name|rootTasks
argument_list|,
name|sem
operator|.
name|getFetchTask
argument_list|()
argument_list|,
literal|false
argument_list|,
literal|true
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|ret
operator|=
name|baos
operator|.
name|toString
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Exception generating explain output: "
operator|+
name|e
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
comment|/**    * Do authorization using post semantic analysis information in the semantic analyzer    * The original command is also passed so that authorization interface can provide    * more useful information in logs.    * @param sem SemanticAnalyzer used to parse input query    * @param command input query    * @throws HiveException    * @throws AuthorizationException    */
specifier|public
specifier|static
name|void
name|doAuthorization
parameter_list|(
name|HiveOperation
name|op
parameter_list|,
name|BaseSemanticAnalyzer
name|sem
parameter_list|,
name|String
name|command
parameter_list|)
throws|throws
name|HiveException
throws|,
name|AuthorizationException
block|{
name|SessionState
name|ss
init|=
name|SessionState
operator|.
name|get
argument_list|()
decl_stmt|;
name|Hive
name|db
init|=
name|sem
operator|.
name|getDb
argument_list|()
decl_stmt|;
name|Set
argument_list|<
name|ReadEntity
argument_list|>
name|additionalInputs
init|=
operator|new
name|HashSet
argument_list|<
name|ReadEntity
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|Entity
name|e
range|:
name|sem
operator|.
name|getInputs
argument_list|()
control|)
block|{
if|if
condition|(
name|e
operator|.
name|getType
argument_list|()
operator|==
name|Entity
operator|.
name|Type
operator|.
name|PARTITION
condition|)
block|{
name|additionalInputs
operator|.
name|add
argument_list|(
operator|new
name|ReadEntity
argument_list|(
name|e
operator|.
name|getTable
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|Set
argument_list|<
name|WriteEntity
argument_list|>
name|additionalOutputs
init|=
operator|new
name|HashSet
argument_list|<
name|WriteEntity
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|WriteEntity
name|e
range|:
name|sem
operator|.
name|getOutputs
argument_list|()
control|)
block|{
if|if
condition|(
name|e
operator|.
name|getType
argument_list|()
operator|==
name|Entity
operator|.
name|Type
operator|.
name|PARTITION
condition|)
block|{
name|additionalOutputs
operator|.
name|add
argument_list|(
operator|new
name|WriteEntity
argument_list|(
name|e
operator|.
name|getTable
argument_list|()
argument_list|,
name|e
operator|.
name|getWriteType
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|// The following union operation returns a union, which traverses over the
comment|// first set once and then  then over each element of second set, in order,
comment|// that is not contained in first. This means it doesn't replace anything
comment|// in first set, and would preserve the WriteType in WriteEntity in first
comment|// set in case of outputs list.
name|Set
argument_list|<
name|ReadEntity
argument_list|>
name|inputs
init|=
name|Sets
operator|.
name|union
argument_list|(
name|sem
operator|.
name|getInputs
argument_list|()
argument_list|,
name|additionalInputs
argument_list|)
decl_stmt|;
name|Set
argument_list|<
name|WriteEntity
argument_list|>
name|outputs
init|=
name|Sets
operator|.
name|union
argument_list|(
name|sem
operator|.
name|getOutputs
argument_list|()
argument_list|,
name|additionalOutputs
argument_list|)
decl_stmt|;
if|if
condition|(
name|ss
operator|.
name|isAuthorizationModeV2
argument_list|()
condition|)
block|{
comment|// get mapping of tables to columns used
name|ColumnAccessInfo
name|colAccessInfo
init|=
name|sem
operator|.
name|getColumnAccessInfo
argument_list|()
decl_stmt|;
comment|// colAccessInfo is set only in case of SemanticAnalyzer
name|Map
argument_list|<
name|String
argument_list|,
name|List
argument_list|<
name|String
argument_list|>
argument_list|>
name|selectTab2Cols
init|=
name|colAccessInfo
operator|!=
literal|null
condition|?
name|colAccessInfo
operator|.
name|getTableToColumnAccessMap
argument_list|()
else|:
literal|null
decl_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|List
argument_list|<
name|String
argument_list|>
argument_list|>
name|updateTab2Cols
init|=
name|sem
operator|.
name|getUpdateColumnAccessInfo
argument_list|()
operator|!=
literal|null
condition|?
name|sem
operator|.
name|getUpdateColumnAccessInfo
argument_list|()
operator|.
name|getTableToColumnAccessMap
argument_list|()
else|:
literal|null
decl_stmt|;
name|doAuthorizationV2
argument_list|(
name|ss
argument_list|,
name|op
argument_list|,
name|inputs
argument_list|,
name|outputs
argument_list|,
name|command
argument_list|,
name|selectTab2Cols
argument_list|,
name|updateTab2Cols
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|op
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|HiveException
argument_list|(
literal|"Operation should not be null"
argument_list|)
throw|;
block|}
name|HiveAuthorizationProvider
name|authorizer
init|=
name|ss
operator|.
name|getAuthorizer
argument_list|()
decl_stmt|;
if|if
condition|(
name|op
operator|.
name|equals
argument_list|(
name|HiveOperation
operator|.
name|CREATEDATABASE
argument_list|)
condition|)
block|{
name|authorizer
operator|.
name|authorize
argument_list|(
name|op
operator|.
name|getInputRequiredPrivileges
argument_list|()
argument_list|,
name|op
operator|.
name|getOutputRequiredPrivileges
argument_list|()
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|op
operator|.
name|equals
argument_list|(
name|HiveOperation
operator|.
name|CREATETABLE_AS_SELECT
argument_list|)
operator|||
name|op
operator|.
name|equals
argument_list|(
name|HiveOperation
operator|.
name|CREATETABLE
argument_list|)
condition|)
block|{
name|authorizer
operator|.
name|authorize
argument_list|(
name|db
operator|.
name|getDatabase
argument_list|(
name|SessionState
operator|.
name|get
argument_list|()
operator|.
name|getCurrentDatabase
argument_list|()
argument_list|)
argument_list|,
literal|null
argument_list|,
name|HiveOperation
operator|.
name|CREATETABLE_AS_SELECT
operator|.
name|getOutputRequiredPrivileges
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|op
operator|.
name|equals
argument_list|(
name|HiveOperation
operator|.
name|IMPORT
argument_list|)
condition|)
block|{
name|ImportSemanticAnalyzer
name|isa
init|=
operator|(
name|ImportSemanticAnalyzer
operator|)
name|sem
decl_stmt|;
if|if
condition|(
operator|!
name|isa
operator|.
name|existsTable
argument_list|()
condition|)
block|{
name|authorizer
operator|.
name|authorize
argument_list|(
name|db
operator|.
name|getDatabase
argument_list|(
name|SessionState
operator|.
name|get
argument_list|()
operator|.
name|getCurrentDatabase
argument_list|()
argument_list|)
argument_list|,
literal|null
argument_list|,
name|HiveOperation
operator|.
name|CREATETABLE_AS_SELECT
operator|.
name|getOutputRequiredPrivileges
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|outputs
operator|!=
literal|null
operator|&&
name|outputs
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
for|for
control|(
name|WriteEntity
name|write
range|:
name|outputs
control|)
block|{
if|if
condition|(
name|write
operator|.
name|isDummy
argument_list|()
operator|||
name|write
operator|.
name|isPathType
argument_list|()
condition|)
block|{
continue|continue;
block|}
if|if
condition|(
name|write
operator|.
name|getType
argument_list|()
operator|==
name|Entity
operator|.
name|Type
operator|.
name|DATABASE
condition|)
block|{
if|if
condition|(
operator|!
name|op
operator|.
name|equals
argument_list|(
name|HiveOperation
operator|.
name|IMPORT
argument_list|)
condition|)
block|{
comment|// We skip DB check for import here because we already handle it above
comment|// as a CTAS check.
name|authorizer
operator|.
name|authorize
argument_list|(
name|write
operator|.
name|getDatabase
argument_list|()
argument_list|,
literal|null
argument_list|,
name|op
operator|.
name|getOutputRequiredPrivileges
argument_list|()
argument_list|)
expr_stmt|;
block|}
continue|continue;
block|}
if|if
condition|(
name|write
operator|.
name|getType
argument_list|()
operator|==
name|WriteEntity
operator|.
name|Type
operator|.
name|PARTITION
condition|)
block|{
name|Partition
name|part
init|=
name|db
operator|.
name|getPartition
argument_list|(
name|write
operator|.
name|getTable
argument_list|()
argument_list|,
name|write
operator|.
name|getPartition
argument_list|()
operator|.
name|getSpec
argument_list|()
argument_list|,
literal|false
argument_list|)
decl_stmt|;
if|if
condition|(
name|part
operator|!=
literal|null
condition|)
block|{
name|authorizer
operator|.
name|authorize
argument_list|(
name|write
operator|.
name|getPartition
argument_list|()
argument_list|,
literal|null
argument_list|,
name|op
operator|.
name|getOutputRequiredPrivileges
argument_list|()
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
if|if
condition|(
name|write
operator|.
name|getTable
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|authorizer
operator|.
name|authorize
argument_list|(
name|write
operator|.
name|getTable
argument_list|()
argument_list|,
literal|null
argument_list|,
name|op
operator|.
name|getOutputRequiredPrivileges
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|inputs
operator|!=
literal|null
operator|&&
name|inputs
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
name|Map
argument_list|<
name|Table
argument_list|,
name|List
argument_list|<
name|String
argument_list|>
argument_list|>
name|tab2Cols
init|=
operator|new
name|HashMap
argument_list|<
name|Table
argument_list|,
name|List
argument_list|<
name|String
argument_list|>
argument_list|>
argument_list|()
decl_stmt|;
name|Map
argument_list|<
name|Partition
argument_list|,
name|List
argument_list|<
name|String
argument_list|>
argument_list|>
name|part2Cols
init|=
operator|new
name|HashMap
argument_list|<
name|Partition
argument_list|,
name|List
argument_list|<
name|String
argument_list|>
argument_list|>
argument_list|()
decl_stmt|;
comment|//determine if partition level privileges should be checked for input tables
name|Map
argument_list|<
name|String
argument_list|,
name|Boolean
argument_list|>
name|tableUsePartLevelAuth
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|Boolean
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|ReadEntity
name|read
range|:
name|inputs
control|)
block|{
if|if
condition|(
name|read
operator|.
name|isDummy
argument_list|()
operator|||
name|read
operator|.
name|isPathType
argument_list|()
operator|||
name|read
operator|.
name|getType
argument_list|()
operator|==
name|Entity
operator|.
name|Type
operator|.
name|DATABASE
condition|)
block|{
continue|continue;
block|}
name|Table
name|tbl
init|=
name|read
operator|.
name|getTable
argument_list|()
decl_stmt|;
if|if
condition|(
operator|(
name|read
operator|.
name|getPartition
argument_list|()
operator|!=
literal|null
operator|)
operator|||
operator|(
name|tbl
operator|!=
literal|null
operator|&&
name|tbl
operator|.
name|isPartitioned
argument_list|()
operator|)
condition|)
block|{
name|String
name|tblName
init|=
name|tbl
operator|.
name|getTableName
argument_list|()
decl_stmt|;
if|if
condition|(
name|tableUsePartLevelAuth
operator|.
name|get
argument_list|(
name|tblName
argument_list|)
operator|==
literal|null
condition|)
block|{
name|boolean
name|usePartLevelPriv
init|=
operator|(
name|tbl
operator|.
name|getParameters
argument_list|()
operator|.
name|get
argument_list|(
literal|"PARTITION_LEVEL_PRIVILEGE"
argument_list|)
operator|!=
literal|null
operator|&&
operator|(
literal|"TRUE"
operator|.
name|equalsIgnoreCase
argument_list|(
name|tbl
operator|.
name|getParameters
argument_list|()
operator|.
name|get
argument_list|(
literal|"PARTITION_LEVEL_PRIVILEGE"
argument_list|)
argument_list|)
operator|)
operator|)
decl_stmt|;
if|if
condition|(
name|usePartLevelPriv
condition|)
block|{
name|tableUsePartLevelAuth
operator|.
name|put
argument_list|(
name|tblName
argument_list|,
name|Boolean
operator|.
name|TRUE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|tableUsePartLevelAuth
operator|.
name|put
argument_list|(
name|tblName
argument_list|,
name|Boolean
operator|.
name|FALSE
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
comment|// column authorization is checked through table scan operators.
name|getTablePartitionUsedColumns
argument_list|(
name|op
argument_list|,
name|sem
argument_list|,
name|tab2Cols
argument_list|,
name|part2Cols
argument_list|,
name|tableUsePartLevelAuth
argument_list|)
expr_stmt|;
comment|// cache the results for table authorization
name|Set
argument_list|<
name|String
argument_list|>
name|tableAuthChecked
init|=
operator|new
name|HashSet
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|ReadEntity
name|read
range|:
name|inputs
control|)
block|{
comment|// if read is not direct, we do not need to check its autho.
if|if
condition|(
name|read
operator|.
name|isDummy
argument_list|()
operator|||
name|read
operator|.
name|isPathType
argument_list|()
operator|||
operator|!
name|read
operator|.
name|isDirect
argument_list|()
condition|)
block|{
continue|continue;
block|}
if|if
condition|(
name|read
operator|.
name|getType
argument_list|()
operator|==
name|Entity
operator|.
name|Type
operator|.
name|DATABASE
condition|)
block|{
name|authorizer
operator|.
name|authorize
argument_list|(
name|read
operator|.
name|getDatabase
argument_list|()
argument_list|,
name|op
operator|.
name|getInputRequiredPrivileges
argument_list|()
argument_list|,
literal|null
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|Table
name|tbl
init|=
name|read
operator|.
name|getTable
argument_list|()
decl_stmt|;
if|if
condition|(
name|tbl
operator|.
name|isView
argument_list|()
operator|&&
name|sem
operator|instanceof
name|SemanticAnalyzer
condition|)
block|{
name|tab2Cols
operator|.
name|put
argument_list|(
name|tbl
argument_list|,
name|sem
operator|.
name|getColumnAccessInfo
argument_list|()
operator|.
name|getTableToColumnAccessMap
argument_list|()
operator|.
name|get
argument_list|(
name|tbl
operator|.
name|getCompleteName
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|read
operator|.
name|getPartition
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|Partition
name|partition
init|=
name|read
operator|.
name|getPartition
argument_list|()
decl_stmt|;
name|tbl
operator|=
name|partition
operator|.
name|getTable
argument_list|()
expr_stmt|;
comment|// use partition level authorization
if|if
condition|(
name|Boolean
operator|.
name|TRUE
operator|.
name|equals
argument_list|(
name|tableUsePartLevelAuth
operator|.
name|get
argument_list|(
name|tbl
operator|.
name|getTableName
argument_list|()
argument_list|)
argument_list|)
condition|)
block|{
name|List
argument_list|<
name|String
argument_list|>
name|cols
init|=
name|part2Cols
operator|.
name|get
argument_list|(
name|partition
argument_list|)
decl_stmt|;
if|if
condition|(
name|cols
operator|!=
literal|null
operator|&&
name|cols
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
name|authorizer
operator|.
name|authorize
argument_list|(
name|partition
operator|.
name|getTable
argument_list|()
argument_list|,
name|partition
argument_list|,
name|cols
argument_list|,
name|op
operator|.
name|getInputRequiredPrivileges
argument_list|()
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|authorizer
operator|.
name|authorize
argument_list|(
name|partition
argument_list|,
name|op
operator|.
name|getInputRequiredPrivileges
argument_list|()
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
continue|continue;
block|}
block|}
comment|// if we reach here, it means it needs to do a table authorization
comment|// check, and the table authorization may already happened because of other
comment|// partitions
if|if
condition|(
name|tbl
operator|!=
literal|null
operator|&&
operator|!
name|tableAuthChecked
operator|.
name|contains
argument_list|(
name|tbl
operator|.
name|getTableName
argument_list|()
argument_list|)
operator|&&
operator|!
operator|(
name|Boolean
operator|.
name|TRUE
operator|.
name|equals
argument_list|(
name|tableUsePartLevelAuth
operator|.
name|get
argument_list|(
name|tbl
operator|.
name|getTableName
argument_list|()
argument_list|)
argument_list|)
operator|)
condition|)
block|{
name|List
argument_list|<
name|String
argument_list|>
name|cols
init|=
name|tab2Cols
operator|.
name|get
argument_list|(
name|tbl
argument_list|)
decl_stmt|;
if|if
condition|(
name|cols
operator|!=
literal|null
operator|&&
name|cols
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
name|authorizer
operator|.
name|authorize
argument_list|(
name|tbl
argument_list|,
literal|null
argument_list|,
name|cols
argument_list|,
name|op
operator|.
name|getInputRequiredPrivileges
argument_list|()
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|authorizer
operator|.
name|authorize
argument_list|(
name|tbl
argument_list|,
name|op
operator|.
name|getInputRequiredPrivileges
argument_list|()
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
name|tableAuthChecked
operator|.
name|add
argument_list|(
name|tbl
operator|.
name|getTableName
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
specifier|private
specifier|static
name|void
name|getTablePartitionUsedColumns
parameter_list|(
name|HiveOperation
name|op
parameter_list|,
name|BaseSemanticAnalyzer
name|sem
parameter_list|,
name|Map
argument_list|<
name|Table
argument_list|,
name|List
argument_list|<
name|String
argument_list|>
argument_list|>
name|tab2Cols
parameter_list|,
name|Map
argument_list|<
name|Partition
argument_list|,
name|List
argument_list|<
name|String
argument_list|>
argument_list|>
name|part2Cols
parameter_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|Boolean
argument_list|>
name|tableUsePartLevelAuth
parameter_list|)
throws|throws
name|HiveException
block|{
comment|// for a select or create-as-select query, populate the partition to column
comment|// (par2Cols) or
comment|// table to columns mapping (tab2Cols)
if|if
condition|(
name|op
operator|.
name|equals
argument_list|(
name|HiveOperation
operator|.
name|CREATETABLE_AS_SELECT
argument_list|)
operator|||
name|op
operator|.
name|equals
argument_list|(
name|HiveOperation
operator|.
name|QUERY
argument_list|)
condition|)
block|{
name|SemanticAnalyzer
name|querySem
init|=
operator|(
name|SemanticAnalyzer
operator|)
name|sem
decl_stmt|;
name|ParseContext
name|parseCtx
init|=
name|querySem
operator|.
name|getParseContext
argument_list|()
decl_stmt|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|TableScanOperator
argument_list|>
name|topOpMap
range|:
name|querySem
operator|.
name|getParseContext
argument_list|()
operator|.
name|getTopOps
argument_list|()
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|TableScanOperator
name|tableScanOp
init|=
name|topOpMap
operator|.
name|getValue
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|tableScanOp
operator|.
name|isInsideView
argument_list|()
condition|)
block|{
name|Table
name|tbl
init|=
name|tableScanOp
operator|.
name|getConf
argument_list|()
operator|.
name|getTableMetadata
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|Integer
argument_list|>
name|neededColumnIds
init|=
name|tableScanOp
operator|.
name|getNeededColumnIDs
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|FieldSchema
argument_list|>
name|columns
init|=
name|tbl
operator|.
name|getCols
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|cols
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|neededColumnIds
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|cols
operator|.
name|add
argument_list|(
name|columns
operator|.
name|get
argument_list|(
name|neededColumnIds
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|)
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// map may not contain all sources, since input list may have been
comment|// optimized out
comment|// or non-existent tho such sources may still be referenced by the
comment|// TableScanOperator
comment|// if it's null then the partition probably doesn't exist so let's use
comment|// table permission
if|if
condition|(
name|tbl
operator|.
name|isPartitioned
argument_list|()
operator|&&
name|Boolean
operator|.
name|TRUE
operator|.
name|equals
argument_list|(
name|tableUsePartLevelAuth
operator|.
name|get
argument_list|(
name|tbl
operator|.
name|getTableName
argument_list|()
argument_list|)
argument_list|)
condition|)
block|{
name|String
name|alias_id
init|=
name|topOpMap
operator|.
name|getKey
argument_list|()
decl_stmt|;
name|PrunedPartitionList
name|partsList
init|=
name|PartitionPruner
operator|.
name|prune
argument_list|(
name|tableScanOp
argument_list|,
name|parseCtx
argument_list|,
name|alias_id
argument_list|)
decl_stmt|;
name|Set
argument_list|<
name|Partition
argument_list|>
name|parts
init|=
name|partsList
operator|.
name|getPartitions
argument_list|()
decl_stmt|;
for|for
control|(
name|Partition
name|part
range|:
name|parts
control|)
block|{
name|List
argument_list|<
name|String
argument_list|>
name|existingCols
init|=
name|part2Cols
operator|.
name|get
argument_list|(
name|part
argument_list|)
decl_stmt|;
if|if
condition|(
name|existingCols
operator|==
literal|null
condition|)
block|{
name|existingCols
operator|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
expr_stmt|;
block|}
name|existingCols
operator|.
name|addAll
argument_list|(
name|cols
argument_list|)
expr_stmt|;
name|part2Cols
operator|.
name|put
argument_list|(
name|part
argument_list|,
name|existingCols
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|List
argument_list|<
name|String
argument_list|>
name|existingCols
init|=
name|tab2Cols
operator|.
name|get
argument_list|(
name|tbl
argument_list|)
decl_stmt|;
if|if
condition|(
name|existingCols
operator|==
literal|null
condition|)
block|{
name|existingCols
operator|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
expr_stmt|;
block|}
name|existingCols
operator|.
name|addAll
argument_list|(
name|cols
argument_list|)
expr_stmt|;
name|tab2Cols
operator|.
name|put
argument_list|(
name|tbl
argument_list|,
name|existingCols
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
specifier|private
specifier|static
name|void
name|doAuthorizationV2
parameter_list|(
name|SessionState
name|ss
parameter_list|,
name|HiveOperation
name|op
parameter_list|,
name|Set
argument_list|<
name|ReadEntity
argument_list|>
name|inputs
parameter_list|,
name|Set
argument_list|<
name|WriteEntity
argument_list|>
name|outputs
parameter_list|,
name|String
name|command
parameter_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|List
argument_list|<
name|String
argument_list|>
argument_list|>
name|tab2cols
parameter_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|List
argument_list|<
name|String
argument_list|>
argument_list|>
name|updateTab2Cols
parameter_list|)
throws|throws
name|HiveException
block|{
comment|/* comment for reviewers -> updateTab2Cols needed to be separate from tab2cols because if I     pass tab2cols to getHivePrivObjects for the output case it will trip up insert/selects,     since the insert will get passed the columns from the select.      */
name|HiveAuthzContext
operator|.
name|Builder
name|authzContextBuilder
init|=
operator|new
name|HiveAuthzContext
operator|.
name|Builder
argument_list|()
decl_stmt|;
name|authzContextBuilder
operator|.
name|setUserIpAddress
argument_list|(
name|ss
operator|.
name|getUserIpAddress
argument_list|()
argument_list|)
expr_stmt|;
name|authzContextBuilder
operator|.
name|setForwardedAddresses
argument_list|(
name|ss
operator|.
name|getForwardedAddresses
argument_list|()
argument_list|)
expr_stmt|;
name|authzContextBuilder
operator|.
name|setCommandString
argument_list|(
name|command
argument_list|)
expr_stmt|;
name|HiveOperationType
name|hiveOpType
init|=
name|getHiveOperationType
argument_list|(
name|op
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|HivePrivilegeObject
argument_list|>
name|inputsHObjs
init|=
name|getHivePrivObjects
argument_list|(
name|inputs
argument_list|,
name|tab2cols
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|HivePrivilegeObject
argument_list|>
name|outputHObjs
init|=
name|getHivePrivObjects
argument_list|(
name|outputs
argument_list|,
name|updateTab2Cols
argument_list|)
decl_stmt|;
name|ss
operator|.
name|getAuthorizerV2
argument_list|()
operator|.
name|checkPrivileges
argument_list|(
name|hiveOpType
argument_list|,
name|inputsHObjs
argument_list|,
name|outputHObjs
argument_list|,
name|authzContextBuilder
operator|.
name|build
argument_list|()
argument_list|)
expr_stmt|;
block|}
specifier|private
specifier|static
name|List
argument_list|<
name|HivePrivilegeObject
argument_list|>
name|getHivePrivObjects
parameter_list|(
name|Set
argument_list|<
name|?
extends|extends
name|Entity
argument_list|>
name|privObjects
parameter_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|List
argument_list|<
name|String
argument_list|>
argument_list|>
name|tableName2Cols
parameter_list|)
block|{
name|List
argument_list|<
name|HivePrivilegeObject
argument_list|>
name|hivePrivobjs
init|=
operator|new
name|ArrayList
argument_list|<
name|HivePrivilegeObject
argument_list|>
argument_list|()
decl_stmt|;
if|if
condition|(
name|privObjects
operator|==
literal|null
condition|)
block|{
return|return
name|hivePrivobjs
return|;
block|}
for|for
control|(
name|Entity
name|privObject
range|:
name|privObjects
control|)
block|{
name|HivePrivilegeObjectType
name|privObjType
init|=
name|AuthorizationUtils
operator|.
name|getHivePrivilegeObjectType
argument_list|(
name|privObject
operator|.
name|getType
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|privObject
operator|.
name|isDummy
argument_list|()
condition|)
block|{
comment|//do not authorize dummy readEntity or writeEntity
continue|continue;
block|}
if|if
condition|(
name|privObject
operator|instanceof
name|ReadEntity
operator|&&
operator|!
operator|(
operator|(
name|ReadEntity
operator|)
name|privObject
operator|)
operator|.
name|isDirect
argument_list|()
condition|)
block|{
comment|// In case of views, the underlying views or tables are not direct dependencies
comment|// and are not used for authorization checks.
comment|// This ReadEntity represents one of the underlying tables/views, so skip it.
comment|// See description of the isDirect in ReadEntity
continue|continue;
block|}
if|if
condition|(
name|privObject
operator|instanceof
name|WriteEntity
operator|&&
operator|(
operator|(
name|WriteEntity
operator|)
name|privObject
operator|)
operator|.
name|isTempURI
argument_list|()
condition|)
block|{
comment|//do not authorize temporary uris
continue|continue;
block|}
comment|//support for authorization on partitions needs to be added
name|String
name|dbname
init|=
literal|null
decl_stmt|;
name|String
name|objName
init|=
literal|null
decl_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|partKeys
init|=
literal|null
decl_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|columns
init|=
literal|null
decl_stmt|;
switch|switch
condition|(
name|privObject
operator|.
name|getType
argument_list|()
condition|)
block|{
case|case
name|DATABASE
case|:
name|dbname
operator|=
name|privObject
operator|.
name|getDatabase
argument_list|()
operator|.
name|getName
argument_list|()
expr_stmt|;
break|break;
case|case
name|TABLE
case|:
name|dbname
operator|=
name|privObject
operator|.
name|getTable
argument_list|()
operator|.
name|getDbName
argument_list|()
expr_stmt|;
name|objName
operator|=
name|privObject
operator|.
name|getTable
argument_list|()
operator|.
name|getTableName
argument_list|()
expr_stmt|;
name|columns
operator|=
name|tableName2Cols
operator|==
literal|null
condition|?
literal|null
else|:
name|tableName2Cols
operator|.
name|get
argument_list|(
name|Table
operator|.
name|getCompleteName
argument_list|(
name|dbname
argument_list|,
name|objName
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|DFS_DIR
case|:
case|case
name|LOCAL_DIR
case|:
name|objName
operator|=
name|privObject
operator|.
name|getD
argument_list|()
operator|.
name|toString
argument_list|()
expr_stmt|;
break|break;
case|case
name|FUNCTION
case|:
if|if
condition|(
name|privObject
operator|.
name|getDatabase
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|dbname
operator|=
name|privObject
operator|.
name|getDatabase
argument_list|()
operator|.
name|getName
argument_list|()
expr_stmt|;
block|}
name|objName
operator|=
name|privObject
operator|.
name|getFunctionName
argument_list|()
expr_stmt|;
break|break;
case|case
name|DUMMYPARTITION
case|:
case|case
name|PARTITION
case|:
comment|// not currently handled
continue|continue;
default|default:
throw|throw
operator|new
name|AssertionError
argument_list|(
literal|"Unexpected object type"
argument_list|)
throw|;
block|}
name|HivePrivObjectActionType
name|actionType
init|=
name|AuthorizationUtils
operator|.
name|getActionType
argument_list|(
name|privObject
argument_list|)
decl_stmt|;
name|HivePrivilegeObject
name|hPrivObject
init|=
operator|new
name|HivePrivilegeObject
argument_list|(
name|privObjType
argument_list|,
name|dbname
argument_list|,
name|objName
argument_list|,
name|partKeys
argument_list|,
name|columns
argument_list|,
name|actionType
argument_list|,
literal|null
argument_list|)
decl_stmt|;
name|hivePrivobjs
operator|.
name|add
argument_list|(
name|hPrivObject
argument_list|)
expr_stmt|;
block|}
return|return
name|hivePrivobjs
return|;
block|}
specifier|private
specifier|static
name|HiveOperationType
name|getHiveOperationType
parameter_list|(
name|HiveOperation
name|op
parameter_list|)
block|{
return|return
name|HiveOperationType
operator|.
name|valueOf
argument_list|(
name|op
operator|.
name|name
argument_list|()
argument_list|)
return|;
block|}
comment|/**    * @return The current query plan associated with this Driver, if any.    */
specifier|public
name|QueryPlan
name|getPlan
parameter_list|()
block|{
return|return
name|plan
return|;
block|}
comment|/**    * @return The current FetchTask associated with the Driver's plan, if any.    */
specifier|public
name|FetchTask
name|getFetchTask
parameter_list|()
block|{
return|return
name|fetchTask
return|;
block|}
comment|// Write the current set of valid transactions into the conf file so that it can be read by
comment|// the input format.
specifier|private
name|void
name|recordValidTxns
parameter_list|()
throws|throws
name|LockException
block|{
name|HiveTxnManager
name|txnMgr
init|=
name|SessionState
operator|.
name|get
argument_list|()
operator|.
name|getTxnMgr
argument_list|()
decl_stmt|;
name|ValidTxnList
name|txns
init|=
name|txnMgr
operator|.
name|getValidTxns
argument_list|()
decl_stmt|;
name|String
name|txnStr
init|=
name|txns
operator|.
name|toString
argument_list|()
decl_stmt|;
name|conf
operator|.
name|set
argument_list|(
name|ValidTxnList
operator|.
name|VALID_TXNS_KEY
argument_list|,
name|txnStr
argument_list|)
expr_stmt|;
if|if
condition|(
name|plan
operator|.
name|getFetchTask
argument_list|()
operator|!=
literal|null
condition|)
block|{
comment|/**        * This is needed for {@link HiveConf.ConfVars.HIVEFETCHTASKCONVERSION} optimization which        * initializes JobConf in FetchOperator before recordValidTxns() but this has to be done        * after locks are acquired to avoid race conditions in ACID.        */
name|plan
operator|.
name|getFetchTask
argument_list|()
operator|.
name|setValidTxnList
argument_list|(
name|txnStr
argument_list|)
expr_stmt|;
block|}
name|LOG
operator|.
name|debug
argument_list|(
literal|"Encoding valid txns info "
operator|+
name|txnStr
operator|+
literal|" txnid:"
operator|+
name|txnMgr
operator|.
name|getCurrentTxnId
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/**    * Acquire read and write locks needed by the statement. The list of objects to be locked are    * obtained from the inputs and outputs populated by the compiler. The lock acquisition scheme is    * pretty simple. If all the locks cannot be obtained, error out. Deadlock is avoided by making    * sure that the locks are lexicographically sorted.    *    * This method also records the list of valid transactions.  This must be done after any    * transactions have been opened and locks acquired.    * @param startTxnImplicitly in AC=false, the 1st DML starts a txn    **/
specifier|private
name|int
name|acquireLocksAndOpenTxn
parameter_list|(
name|boolean
name|startTxnImplicitly
parameter_list|)
block|{
name|PerfLogger
name|perfLogger
init|=
name|SessionState
operator|.
name|getPerfLogger
argument_list|()
decl_stmt|;
name|perfLogger
operator|.
name|PerfLogBegin
argument_list|(
name|CLASS_NAME
argument_list|,
name|PerfLogger
operator|.
name|ACQUIRE_READ_WRITE_LOCKS
argument_list|)
expr_stmt|;
name|SessionState
name|ss
init|=
name|SessionState
operator|.
name|get
argument_list|()
decl_stmt|;
name|HiveTxnManager
name|txnMgr
init|=
name|ss
operator|.
name|getTxnMgr
argument_list|()
decl_stmt|;
if|if
condition|(
name|startTxnImplicitly
condition|)
block|{
assert|assert
operator|!
name|txnMgr
operator|.
name|getAutoCommit
argument_list|()
assert|;
block|}
try|try
block|{
comment|// Don't use the userName member, as it may or may not have been set.  Get the value from
comment|// conf, which calls into getUGI to figure out who the process is running as.
name|String
name|userFromUGI
decl_stmt|;
try|try
block|{
name|userFromUGI
operator|=
name|conf
operator|.
name|getUser
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|errorMessage
operator|=
literal|"FAILED: Error in determining user while acquiring locks: "
operator|+
name|e
operator|.
name|getMessage
argument_list|()
expr_stmt|;
name|SQLState
operator|=
name|ErrorMsg
operator|.
name|findSQLState
argument_list|(
name|e
operator|.
name|getMessage
argument_list|()
argument_list|)
expr_stmt|;
name|downstreamError
operator|=
name|e
expr_stmt|;
name|console
operator|.
name|printError
argument_list|(
name|errorMessage
argument_list|,
literal|"\n"
operator|+
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|StringUtils
operator|.
name|stringifyException
argument_list|(
name|e
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|10
return|;
block|}
name|boolean
name|initiatingTransaction
init|=
literal|false
decl_stmt|;
name|boolean
name|readOnlyQueryInAutoCommit
init|=
literal|false
decl_stmt|;
if|if
condition|(
operator|(
name|txnMgr
operator|.
name|getAutoCommit
argument_list|()
operator|&&
name|haveAcidWrite
argument_list|()
operator|)
operator|||
name|plan
operator|.
name|getOperation
argument_list|()
operator|==
name|HiveOperation
operator|.
name|START_TRANSACTION
operator|||
operator|(
operator|!
name|txnMgr
operator|.
name|getAutoCommit
argument_list|()
operator|&&
name|startTxnImplicitly
operator|)
condition|)
block|{
if|if
condition|(
name|txnMgr
operator|.
name|isTxnOpen
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Already have an open transaction txnid:"
operator|+
name|txnMgr
operator|.
name|getCurrentTxnId
argument_list|()
argument_list|)
throw|;
block|}
comment|// We are writing to tables in an ACID compliant way, so we need to open a transaction
name|txnMgr
operator|.
name|openTxn
argument_list|(
name|ctx
argument_list|,
name|userFromUGI
argument_list|)
expr_stmt|;
name|initiatingTransaction
operator|=
literal|true
expr_stmt|;
block|}
else|else
block|{
name|readOnlyQueryInAutoCommit
operator|=
name|txnMgr
operator|.
name|getAutoCommit
argument_list|()
operator|&&
name|plan
operator|.
name|getOperation
argument_list|()
operator|==
name|HiveOperation
operator|.
name|QUERY
operator|&&
operator|!
name|haveAcidWrite
argument_list|()
expr_stmt|;
block|}
comment|// Set the transaction id in all of the acid file sinks
if|if
condition|(
name|haveAcidWrite
argument_list|()
condition|)
block|{
for|for
control|(
name|FileSinkDesc
name|desc
range|:
name|acidSinks
control|)
block|{
name|desc
operator|.
name|setTransactionId
argument_list|(
name|txnMgr
operator|.
name|getCurrentTxnId
argument_list|()
argument_list|)
expr_stmt|;
comment|//it's possible to have> 1 FileSink writing to the same table/partition
comment|//e.g. Merge stmt, multi-insert stmt when mixing DP and SP writes
name|desc
operator|.
name|setStatementId
argument_list|(
name|txnMgr
operator|.
name|getWriteIdAndIncrement
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
comment|/*Note, we have to record snapshot after lock acquisition to prevent lost update problem       consider 2 concurrent "update table T set x = x + 1".  1st will get the locks and the       2nd will block until 1st one commits and only then lock in the snapshot, i.e. it will       see the changes made by 1st one.  This takes care of autoCommit=true case.       For multi-stmt txns this is not sufficient and will be managed via WriteSet tracking       in the lock manager.*/
name|txnMgr
operator|.
name|acquireLocks
argument_list|(
name|plan
argument_list|,
name|ctx
argument_list|,
name|userFromUGI
argument_list|,
name|lDrvState
argument_list|)
expr_stmt|;
if|if
condition|(
name|initiatingTransaction
operator|||
operator|(
name|readOnlyQueryInAutoCommit
operator|&&
name|acidInQuery
operator|)
condition|)
block|{
comment|//For multi-stmt txns we should record the snapshot when txn starts but
comment|// don't update it after that until txn completes.  Thus the check for {@code initiatingTransaction}
comment|//For autoCommit=true, Read-only statements, txn is implicit, i.e. lock in the snapshot
comment|//for each statement.
name|recordValidTxns
argument_list|()
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|errorMessage
operator|=
literal|"FAILED: Error in acquiring locks: "
operator|+
name|e
operator|.
name|getMessage
argument_list|()
expr_stmt|;
name|SQLState
operator|=
name|ErrorMsg
operator|.
name|findSQLState
argument_list|(
name|e
operator|.
name|getMessage
argument_list|()
argument_list|)
expr_stmt|;
name|downstreamError
operator|=
name|e
expr_stmt|;
name|console
operator|.
name|printError
argument_list|(
name|errorMessage
argument_list|,
literal|"\n"
operator|+
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|StringUtils
operator|.
name|stringifyException
argument_list|(
name|e
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|10
return|;
block|}
finally|finally
block|{
name|perfLogger
operator|.
name|PerfLogEnd
argument_list|(
name|CLASS_NAME
argument_list|,
name|PerfLogger
operator|.
name|ACQUIRE_READ_WRITE_LOCKS
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
name|boolean
name|haveAcidWrite
parameter_list|()
block|{
return|return
name|acidSinks
operator|!=
literal|null
operator|&&
operator|!
name|acidSinks
operator|.
name|isEmpty
argument_list|()
return|;
block|}
comment|/**    * @param commit if there is an open transaction and if true, commit,    *               if false rollback.  If there is no open transaction this parameter is ignored.    * @param txnManager an optional existing transaction manager retrieved earlier from the session    *    **/
specifier|private
name|void
name|releaseLocksAndCommitOrRollback
parameter_list|(
name|boolean
name|commit
parameter_list|,
name|HiveTxnManager
name|txnManager
parameter_list|)
throws|throws
name|LockException
block|{
name|PerfLogger
name|perfLogger
init|=
name|SessionState
operator|.
name|getPerfLogger
argument_list|()
decl_stmt|;
name|perfLogger
operator|.
name|PerfLogBegin
argument_list|(
name|CLASS_NAME
argument_list|,
name|PerfLogger
operator|.
name|RELEASE_LOCKS
argument_list|)
expr_stmt|;
name|HiveTxnManager
name|txnMgr
decl_stmt|;
if|if
condition|(
name|txnManager
operator|==
literal|null
condition|)
block|{
name|SessionState
name|ss
init|=
name|SessionState
operator|.
name|get
argument_list|()
decl_stmt|;
name|txnMgr
operator|=
name|ss
operator|.
name|getTxnMgr
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|txnMgr
operator|=
name|txnManager
expr_stmt|;
block|}
comment|// If we've opened a transaction we need to commit or rollback rather than explicitly
comment|// releasing the locks.
if|if
condition|(
name|txnMgr
operator|.
name|isTxnOpen
argument_list|()
condition|)
block|{
if|if
condition|(
name|commit
condition|)
block|{
if|if
condition|(
name|conf
operator|.
name|getBoolVar
argument_list|(
name|ConfVars
operator|.
name|HIVE_IN_TEST
argument_list|)
operator|&&
name|conf
operator|.
name|getBoolVar
argument_list|(
name|ConfVars
operator|.
name|HIVETESTMODEROLLBACKTXN
argument_list|)
condition|)
block|{
name|txnMgr
operator|.
name|rollbackTxn
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|txnMgr
operator|.
name|commitTxn
argument_list|()
expr_stmt|;
comment|//both commit& rollback clear ALL locks for this tx
block|}
block|}
else|else
block|{
name|txnMgr
operator|.
name|rollbackTxn
argument_list|()
expr_stmt|;
block|}
block|}
else|else
block|{
comment|//since there is no tx, we only have locks for current query (if any)
if|if
condition|(
name|ctx
operator|!=
literal|null
operator|&&
name|ctx
operator|.
name|getHiveLocks
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|hiveLocks
operator|.
name|addAll
argument_list|(
name|ctx
operator|.
name|getHiveLocks
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|txnMgr
operator|.
name|releaseLocks
argument_list|(
name|hiveLocks
argument_list|)
expr_stmt|;
block|}
name|hiveLocks
operator|.
name|clear
argument_list|()
expr_stmt|;
if|if
condition|(
name|ctx
operator|!=
literal|null
condition|)
block|{
name|ctx
operator|.
name|setHiveLocks
argument_list|(
literal|null
argument_list|)
expr_stmt|;
block|}
name|perfLogger
operator|.
name|PerfLogEnd
argument_list|(
name|CLASS_NAME
argument_list|,
name|PerfLogger
operator|.
name|RELEASE_LOCKS
argument_list|)
expr_stmt|;
block|}
comment|/**    * Release some resources after a query is executed    * while keeping the result around.    */
specifier|private
name|void
name|releaseResources
parameter_list|()
block|{
name|releasePlan
argument_list|()
expr_stmt|;
name|releaseDriverContext
argument_list|()
expr_stmt|;
if|if
condition|(
name|SessionState
operator|.
name|get
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|SessionState
operator|.
name|get
argument_list|()
operator|.
name|getLineageState
argument_list|()
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|CommandProcessorResponse
name|run
parameter_list|(
name|String
name|command
parameter_list|)
throws|throws
name|CommandNeedRetryException
block|{
return|return
name|run
argument_list|(
name|command
argument_list|,
literal|false
argument_list|)
return|;
block|}
specifier|public
name|CommandProcessorResponse
name|run
parameter_list|()
throws|throws
name|CommandNeedRetryException
block|{
return|return
name|run
argument_list|(
literal|null
argument_list|,
literal|true
argument_list|)
return|;
block|}
specifier|public
name|CommandProcessorResponse
name|run
parameter_list|(
name|String
name|command
parameter_list|,
name|boolean
name|alreadyCompiled
parameter_list|)
throws|throws
name|CommandNeedRetryException
block|{
name|CommandProcessorResponse
name|cpr
init|=
name|runInternal
argument_list|(
name|command
argument_list|,
name|alreadyCompiled
argument_list|)
decl_stmt|;
if|if
condition|(
name|cpr
operator|.
name|getResponseCode
argument_list|()
operator|==
literal|0
condition|)
block|{
return|return
name|cpr
return|;
block|}
name|SessionState
name|ss
init|=
name|SessionState
operator|.
name|get
argument_list|()
decl_stmt|;
if|if
condition|(
name|ss
operator|==
literal|null
condition|)
block|{
return|return
name|cpr
return|;
block|}
name|MetaDataFormatter
name|mdf
init|=
name|MetaDataFormatUtils
operator|.
name|getFormatter
argument_list|(
name|ss
operator|.
name|getConf
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|mdf
operator|instanceof
name|JsonMetaDataFormatter
operator|)
condition|)
block|{
return|return
name|cpr
return|;
block|}
comment|/*Here we want to encode the error in machine readable way (e.g. JSON)      * Ideally, errorCode would always be set to a canonical error defined in ErrorMsg.      * In practice that is rarely the case, so the messy logic below tries to tease      * out canonical error code if it can.  Exclude stack trace from output when      * the error is a specific/expected one.      * It's written to stdout for backward compatibility (WebHCat consumes it).*/
try|try
block|{
if|if
condition|(
name|downstreamError
operator|==
literal|null
condition|)
block|{
name|mdf
operator|.
name|error
argument_list|(
name|ss
operator|.
name|out
argument_list|,
name|errorMessage
argument_list|,
name|cpr
operator|.
name|getResponseCode
argument_list|()
argument_list|,
name|SQLState
argument_list|)
expr_stmt|;
return|return
name|cpr
return|;
block|}
name|ErrorMsg
name|canonicalErr
init|=
name|ErrorMsg
operator|.
name|getErrorMsg
argument_list|(
name|cpr
operator|.
name|getResponseCode
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|canonicalErr
operator|!=
literal|null
operator|&&
name|canonicalErr
operator|!=
name|ErrorMsg
operator|.
name|GENERIC_ERROR
condition|)
block|{
comment|/*Some HiveExceptions (e.g. SemanticException) don't set           canonical ErrorMsg explicitly, but there is logic           (e.g. #compile()) to find an appropriate canonical error and           return its code as error code. In this case we want to           preserve it for downstream code to interpret*/
name|mdf
operator|.
name|error
argument_list|(
name|ss
operator|.
name|out
argument_list|,
name|errorMessage
argument_list|,
name|cpr
operator|.
name|getResponseCode
argument_list|()
argument_list|,
name|SQLState
argument_list|,
literal|null
argument_list|)
expr_stmt|;
return|return
name|cpr
return|;
block|}
if|if
condition|(
name|downstreamError
operator|instanceof
name|HiveException
condition|)
block|{
name|HiveException
name|rc
init|=
operator|(
name|HiveException
operator|)
name|downstreamError
decl_stmt|;
name|mdf
operator|.
name|error
argument_list|(
name|ss
operator|.
name|out
argument_list|,
name|errorMessage
argument_list|,
name|rc
operator|.
name|getCanonicalErrorMsg
argument_list|()
operator|.
name|getErrorCode
argument_list|()
argument_list|,
name|SQLState
argument_list|,
name|rc
operator|.
name|getCanonicalErrorMsg
argument_list|()
operator|==
name|ErrorMsg
operator|.
name|GENERIC_ERROR
condition|?
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|StringUtils
operator|.
name|stringifyException
argument_list|(
name|rc
argument_list|)
else|:
literal|null
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ErrorMsg
name|canonicalMsg
init|=
name|ErrorMsg
operator|.
name|getErrorMsg
argument_list|(
name|downstreamError
operator|.
name|getMessage
argument_list|()
argument_list|)
decl_stmt|;
name|mdf
operator|.
name|error
argument_list|(
name|ss
operator|.
name|out
argument_list|,
name|errorMessage
argument_list|,
name|canonicalMsg
operator|.
name|getErrorCode
argument_list|()
argument_list|,
name|SQLState
argument_list|,
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|StringUtils
operator|.
name|stringifyException
argument_list|(
name|downstreamError
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|HiveException
name|ex
parameter_list|)
block|{
name|console
operator|.
name|printError
argument_list|(
literal|"Unable to JSON-encode the error"
argument_list|,
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|StringUtils
operator|.
name|stringifyException
argument_list|(
name|ex
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|cpr
return|;
block|}
specifier|public
name|CommandProcessorResponse
name|compileAndRespond
parameter_list|(
name|String
name|command
parameter_list|)
block|{
return|return
name|createProcessorResponse
argument_list|(
name|compileInternal
argument_list|(
name|command
argument_list|,
literal|false
argument_list|)
argument_list|)
return|;
block|}
specifier|private
specifier|static
specifier|final
name|ReentrantLock
name|globalCompileLock
init|=
operator|new
name|ReentrantLock
argument_list|()
decl_stmt|;
specifier|private
name|int
name|compileInternal
parameter_list|(
name|String
name|command
parameter_list|,
name|boolean
name|deferClose
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
name|Metrics
name|metrics
init|=
name|MetricsFactory
operator|.
name|getInstance
argument_list|()
decl_stmt|;
if|if
condition|(
name|metrics
operator|!=
literal|null
condition|)
block|{
name|metrics
operator|.
name|incrementCounter
argument_list|(
name|MetricsConstant
operator|.
name|WAITING_COMPILE_OPS
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
specifier|final
name|ReentrantLock
name|compileLock
init|=
name|tryAcquireCompileLock
argument_list|(
name|isParallelEnabled
argument_list|,
name|command
argument_list|)
decl_stmt|;
if|if
condition|(
name|compileLock
operator|==
literal|null
condition|)
block|{
return|return
name|ErrorMsg
operator|.
name|COMPILE_LOCK_TIMED_OUT
operator|.
name|getErrorCode
argument_list|()
return|;
block|}
try|try
block|{
if|if
condition|(
name|metrics
operator|!=
literal|null
condition|)
block|{
name|metrics
operator|.
name|decrementCounter
argument_list|(
name|MetricsConstant
operator|.
name|WAITING_COMPILE_OPS
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|ret
operator|=
name|compile
argument_list|(
name|command
argument_list|,
literal|true
argument_list|,
name|deferClose
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|compileLock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
block|{
try|try
block|{
name|releaseLocksAndCommitOrRollback
argument_list|(
literal|false
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|LockException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Exception in releasing locks. "
operator|+
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|StringUtils
operator|.
name|stringifyException
argument_list|(
name|e
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|//Save compile-time PerfLogging for WebUI.
comment|//Execution-time Perf logs are done by either another thread's PerfLogger
comment|//or a reset PerfLogger.
name|PerfLogger
name|perfLogger
init|=
name|SessionState
operator|.
name|getPerfLogger
argument_list|()
decl_stmt|;
name|queryDisplay
operator|.
name|setPerfLogStarts
argument_list|(
name|QueryDisplay
operator|.
name|Phase
operator|.
name|COMPILATION
argument_list|,
name|perfLogger
operator|.
name|getStartTimes
argument_list|()
argument_list|)
expr_stmt|;
name|queryDisplay
operator|.
name|setPerfLogEnds
argument_list|(
name|QueryDisplay
operator|.
name|Phase
operator|.
name|COMPILATION
argument_list|,
name|perfLogger
operator|.
name|getEndTimes
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
comment|/**    * Acquires the compile lock. If the compile lock wait timeout is configured,    * it will acquire the lock if it is not held by another thread within the given    * waiting time.    * @return the ReentrantLock object if the lock was successfully acquired,    *         or {@code null} if compile lock wait timeout is configured and    *         either the waiting time elapsed before the lock could be acquired    *         or if the current thread is interrupted.    */
specifier|private
name|ReentrantLock
name|tryAcquireCompileLock
parameter_list|(
name|boolean
name|isParallelEnabled
parameter_list|,
name|String
name|command
parameter_list|)
block|{
specifier|final
name|ReentrantLock
name|compileLock
init|=
name|isParallelEnabled
condition|?
name|SessionState
operator|.
name|get
argument_list|()
operator|.
name|getCompileLock
argument_list|()
else|:
name|globalCompileLock
decl_stmt|;
name|long
name|maxCompileLockWaitTime
init|=
name|HiveConf
operator|.
name|getTimeVar
argument_list|(
name|this
operator|.
name|conf
argument_list|,
name|ConfVars
operator|.
name|HIVE_SERVER2_COMPILE_LOCK_TIMEOUT
argument_list|,
name|TimeUnit
operator|.
name|SECONDS
argument_list|)
decl_stmt|;
specifier|final
name|String
name|lockAcquiredMsg
init|=
literal|"Acquired the compile lock."
decl_stmt|;
comment|// First shot without waiting.
try|try
block|{
if|if
condition|(
name|compileLock
operator|.
name|tryLock
argument_list|(
literal|0
argument_list|,
name|TimeUnit
operator|.
name|SECONDS
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
name|lockAcquiredMsg
argument_list|)
expr_stmt|;
return|return
name|compileLock
return|;
block|}
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|interrupt
argument_list|()
expr_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Interrupted Exception ignored"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
return|return
literal|null
return|;
block|}
comment|// If the first shot fails, then we log the waiting messages.
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Waiting to acquire compile lock: "
operator|+
name|command
argument_list|)
expr_stmt|;
block|}
name|OperationLog
name|ol
init|=
name|OperationLog
operator|.
name|getCurrentOperationLog
argument_list|()
decl_stmt|;
if|if
condition|(
name|ol
operator|!=
literal|null
condition|)
block|{
name|ol
operator|.
name|writeOperationLog
argument_list|(
name|LoggingLevel
operator|.
name|EXECUTION
argument_list|,
literal|"Waiting to acquire compile lock.\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|maxCompileLockWaitTime
operator|>
literal|0
condition|)
block|{
try|try
block|{
if|if
condition|(
operator|!
name|compileLock
operator|.
name|tryLock
argument_list|(
name|maxCompileLockWaitTime
argument_list|,
name|TimeUnit
operator|.
name|SECONDS
argument_list|)
condition|)
block|{
name|errorMessage
operator|=
name|ErrorMsg
operator|.
name|COMPILE_LOCK_TIMED_OUT
operator|.
name|getErrorCodedMsg
argument_list|()
expr_stmt|;
name|LOG
operator|.
name|error
argument_list|(
name|errorMessage
operator|+
literal|": "
operator|+
name|command
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|interrupt
argument_list|()
expr_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Interrupted Exception ignored"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
return|return
literal|null
return|;
block|}
block|}
else|else
block|{
name|compileLock
operator|.
name|lock
argument_list|()
expr_stmt|;
block|}
name|LOG
operator|.
name|debug
argument_list|(
name|lockAcquiredMsg
argument_list|)
expr_stmt|;
if|if
condition|(
name|ol
operator|!=
literal|null
condition|)
block|{
name|ol
operator|.
name|writeOperationLog
argument_list|(
name|LoggingLevel
operator|.
name|EXECUTION
argument_list|,
name|lockAcquiredMsg
operator|+
literal|"\n"
argument_list|)
expr_stmt|;
block|}
return|return
name|compileLock
return|;
block|}
specifier|private
name|CommandProcessorResponse
name|runInternal
parameter_list|(
name|String
name|command
parameter_list|,
name|boolean
name|alreadyCompiled
parameter_list|)
throws|throws
name|CommandNeedRetryException
block|{
name|errorMessage
operator|=
literal|null
expr_stmt|;
name|SQLState
operator|=
literal|null
expr_stmt|;
name|downstreamError
operator|=
literal|null
expr_stmt|;
name|lDrvState
operator|.
name|stateLock
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
if|if
condition|(
name|alreadyCompiled
condition|)
block|{
if|if
condition|(
name|lDrvState
operator|.
name|driverState
operator|==
name|DriverState
operator|.
name|COMPILED
condition|)
block|{
name|lDrvState
operator|.
name|driverState
operator|=
name|DriverState
operator|.
name|EXECUTING
expr_stmt|;
block|}
else|else
block|{
name|errorMessage
operator|=
literal|"FAILED: Precompiled query has been cancelled or closed."
expr_stmt|;
name|console
operator|.
name|printError
argument_list|(
name|errorMessage
argument_list|)
expr_stmt|;
return|return
name|createProcessorResponse
argument_list|(
literal|12
argument_list|)
return|;
block|}
block|}
else|else
block|{
name|lDrvState
operator|.
name|driverState
operator|=
name|DriverState
operator|.
name|COMPILING
expr_stmt|;
block|}
block|}
finally|finally
block|{
name|lDrvState
operator|.
name|stateLock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
comment|// a flag that helps to set the correct driver state in finally block by tracking if
comment|// the method has been returned by an error or not.
name|boolean
name|isFinishedWithError
init|=
literal|true
decl_stmt|;
try|try
block|{
name|HiveDriverRunHookContext
name|hookContext
init|=
operator|new
name|HiveDriverRunHookContextImpl
argument_list|(
name|conf
argument_list|,
name|alreadyCompiled
condition|?
name|ctx
operator|.
name|getCmd
argument_list|()
else|:
name|command
argument_list|)
decl_stmt|;
comment|// Get all the driver run hooks and pre-execute them.
name|List
argument_list|<
name|HiveDriverRunHook
argument_list|>
name|driverRunHooks
decl_stmt|;
try|try
block|{
name|driverRunHooks
operator|=
name|getHooks
argument_list|(
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVE_DRIVER_RUN_HOOKS
argument_list|,
name|HiveDriverRunHook
operator|.
name|class
argument_list|)
expr_stmt|;
for|for
control|(
name|HiveDriverRunHook
name|driverRunHook
range|:
name|driverRunHooks
control|)
block|{
name|driverRunHook
operator|.
name|preDriverRun
argument_list|(
name|hookContext
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|errorMessage
operator|=
literal|"FAILED: Hive Internal Error: "
operator|+
name|Utilities
operator|.
name|getNameMessage
argument_list|(
name|e
argument_list|)
expr_stmt|;
name|SQLState
operator|=
name|ErrorMsg
operator|.
name|findSQLState
argument_list|(
name|e
operator|.
name|getMessage
argument_list|()
argument_list|)
expr_stmt|;
name|downstreamError
operator|=
name|e
expr_stmt|;
name|console
operator|.
name|printError
argument_list|(
name|errorMessage
operator|+
literal|"\n"
operator|+
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|StringUtils
operator|.
name|stringifyException
argument_list|(
name|e
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|createProcessorResponse
argument_list|(
literal|12
argument_list|)
return|;
block|}
name|PerfLogger
name|perfLogger
init|=
literal|null
decl_stmt|;
name|int
name|ret
decl_stmt|;
if|if
condition|(
operator|!
name|alreadyCompiled
condition|)
block|{
comment|// compile internal will automatically reset the perf logger
name|ret
operator|=
name|compileInternal
argument_list|(
name|command
argument_list|,
literal|true
argument_list|)
expr_stmt|;
comment|// then we continue to use this perf logger
name|perfLogger
operator|=
name|SessionState
operator|.
name|getPerfLogger
argument_list|()
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
block|{
return|return
name|createProcessorResponse
argument_list|(
name|ret
argument_list|)
return|;
block|}
block|}
else|else
block|{
comment|// reuse existing perf logger.
name|perfLogger
operator|=
name|SessionState
operator|.
name|getPerfLogger
argument_list|()
expr_stmt|;
comment|// Since we're reusing the compiled plan, we need to update its start time for current run
name|plan
operator|.
name|setQueryStartTime
argument_list|(
name|perfLogger
operator|.
name|getStartTime
argument_list|(
name|PerfLogger
operator|.
name|DRIVER_RUN
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// the reason that we set the txn manager for the cxt here is because each
comment|// query has its own ctx object. The txn mgr is shared across the
comment|// same instance of Driver, which can run multiple queries.
name|HiveTxnManager
name|txnManager
init|=
name|SessionState
operator|.
name|get
argument_list|()
operator|.
name|getTxnMgr
argument_list|()
decl_stmt|;
name|ctx
operator|.
name|setHiveTxnManager
argument_list|(
name|txnManager
argument_list|)
expr_stmt|;
name|boolean
name|startTxnImplicitly
init|=
literal|false
decl_stmt|;
block|{
comment|//this block ensures op makes sense in given context, e.g. COMMIT is valid only if txn is open
comment|//DDL is not allowed in a txn, etc.
comment|//an error in an open txn does a rollback of the txn
if|if
condition|(
name|txnManager
operator|.
name|isTxnOpen
argument_list|()
operator|&&
operator|!
name|plan
operator|.
name|getOperation
argument_list|()
operator|.
name|isAllowedInTransaction
argument_list|()
condition|)
block|{
assert|assert
operator|!
name|txnManager
operator|.
name|getAutoCommit
argument_list|()
operator|:
literal|"didn't expect AC=true"
assert|;
return|return
name|rollback
argument_list|(
operator|new
name|CommandProcessorResponse
argument_list|(
literal|12
argument_list|,
name|ErrorMsg
operator|.
name|OP_NOT_ALLOWED_IN_TXN
argument_list|,
literal|null
argument_list|,
name|plan
operator|.
name|getOperationName
argument_list|()
argument_list|,
name|Long
operator|.
name|toString
argument_list|(
name|txnManager
operator|.
name|getCurrentTxnId
argument_list|()
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
if|if
condition|(
operator|!
name|txnManager
operator|.
name|isTxnOpen
argument_list|()
operator|&&
name|plan
operator|.
name|getOperation
argument_list|()
operator|.
name|isRequiresOpenTransaction
argument_list|()
condition|)
block|{
return|return
name|rollback
argument_list|(
operator|new
name|CommandProcessorResponse
argument_list|(
literal|12
argument_list|,
name|ErrorMsg
operator|.
name|OP_NOT_ALLOWED_WITHOUT_TXN
argument_list|,
literal|null
argument_list|,
name|plan
operator|.
name|getOperationName
argument_list|()
argument_list|)
argument_list|)
return|;
block|}
if|if
condition|(
operator|!
name|txnManager
operator|.
name|isTxnOpen
argument_list|()
operator|&&
name|plan
operator|.
name|getOperation
argument_list|()
operator|==
name|HiveOperation
operator|.
name|QUERY
operator|&&
operator|!
name|txnManager
operator|.
name|getAutoCommit
argument_list|()
condition|)
block|{
comment|//this effectively makes START TRANSACTION optional and supports JDBC setAutoCommit(false) semantics
comment|//also, indirectly allows DDL to be executed outside a txn context
name|startTxnImplicitly
operator|=
literal|true
expr_stmt|;
block|}
if|if
condition|(
name|txnManager
operator|.
name|getAutoCommit
argument_list|()
operator|&&
name|plan
operator|.
name|getOperation
argument_list|()
operator|==
name|HiveOperation
operator|.
name|START_TRANSACTION
condition|)
block|{
return|return
name|rollback
argument_list|(
operator|new
name|CommandProcessorResponse
argument_list|(
literal|12
argument_list|,
name|ErrorMsg
operator|.
name|OP_NOT_ALLOWED_IN_AUTOCOMMIT
argument_list|,
literal|null
argument_list|,
name|plan
operator|.
name|getOperationName
argument_list|()
argument_list|)
argument_list|)
return|;
block|}
block|}
if|if
condition|(
name|plan
operator|.
name|getOperation
argument_list|()
operator|==
name|HiveOperation
operator|.
name|SET_AUTOCOMMIT
condition|)
block|{
try|try
block|{
if|if
condition|(
name|plan
operator|.
name|getAutoCommitValue
argument_list|()
operator|&&
operator|!
name|txnManager
operator|.
name|getAutoCommit
argument_list|()
condition|)
block|{
comment|/*here, if there is an open txn, we want to commit it; this behavior matches             * https://docs.oracle.com/javase/6/docs/api/java/sql/Connection.html#setAutoCommit(boolean)*/
name|releaseLocksAndCommitOrRollback
argument_list|(
literal|true
argument_list|,
literal|null
argument_list|)
expr_stmt|;
name|txnManager
operator|.
name|setAutoCommit
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|plan
operator|.
name|getAutoCommitValue
argument_list|()
operator|&&
name|txnManager
operator|.
name|getAutoCommit
argument_list|()
condition|)
block|{
name|txnManager
operator|.
name|setAutoCommit
argument_list|(
literal|false
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/*didn't change autoCommit value - no-op*/
block|}
block|}
catch|catch
parameter_list|(
name|LockException
name|e
parameter_list|)
block|{
return|return
name|handleHiveException
argument_list|(
name|e
argument_list|,
literal|12
argument_list|)
return|;
block|}
block|}
if|if
condition|(
name|requiresLock
argument_list|()
condition|)
block|{
comment|// a checkpoint to see if the thread is interrupted or not before an expensive operation
if|if
condition|(
name|isInterrupted
argument_list|()
condition|)
block|{
name|ret
operator|=
name|handleInterruption
argument_list|(
literal|"at acquiring the lock."
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ret
operator|=
name|acquireLocksAndOpenTxn
argument_list|(
name|startTxnImplicitly
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
block|{
return|return
name|rollback
argument_list|(
name|createProcessorResponse
argument_list|(
name|ret
argument_list|)
argument_list|)
return|;
block|}
block|}
name|ret
operator|=
name|execute
argument_list|(
literal|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
block|{
comment|//if needRequireLock is false, the release here will do nothing because there is no lock
return|return
name|rollback
argument_list|(
name|createProcessorResponse
argument_list|(
name|ret
argument_list|)
argument_list|)
return|;
block|}
comment|//if needRequireLock is false, the release here will do nothing because there is no lock
try|try
block|{
if|if
condition|(
name|txnManager
operator|.
name|getAutoCommit
argument_list|()
operator|||
name|plan
operator|.
name|getOperation
argument_list|()
operator|==
name|HiveOperation
operator|.
name|COMMIT
condition|)
block|{
name|releaseLocksAndCommitOrRollback
argument_list|(
literal|true
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|plan
operator|.
name|getOperation
argument_list|()
operator|==
name|HiveOperation
operator|.
name|ROLLBACK
condition|)
block|{
name|releaseLocksAndCommitOrRollback
argument_list|(
literal|false
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|//txn (if there is one started) is not finished
block|}
block|}
catch|catch
parameter_list|(
name|LockException
name|e
parameter_list|)
block|{
return|return
name|handleHiveException
argument_list|(
name|e
argument_list|,
literal|12
argument_list|)
return|;
block|}
name|perfLogger
operator|.
name|PerfLogEnd
argument_list|(
name|CLASS_NAME
argument_list|,
name|PerfLogger
operator|.
name|DRIVER_RUN
argument_list|)
expr_stmt|;
name|queryDisplay
operator|.
name|setPerfLogStarts
argument_list|(
name|QueryDisplay
operator|.
name|Phase
operator|.
name|EXECUTION
argument_list|,
name|perfLogger
operator|.
name|getStartTimes
argument_list|()
argument_list|)
expr_stmt|;
name|queryDisplay
operator|.
name|setPerfLogEnds
argument_list|(
name|QueryDisplay
operator|.
name|Phase
operator|.
name|EXECUTION
argument_list|,
name|perfLogger
operator|.
name|getEndTimes
argument_list|()
argument_list|)
expr_stmt|;
comment|// Take all the driver run hooks and post-execute them.
try|try
block|{
for|for
control|(
name|HiveDriverRunHook
name|driverRunHook
range|:
name|driverRunHooks
control|)
block|{
name|driverRunHook
operator|.
name|postDriverRun
argument_list|(
name|hookContext
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|errorMessage
operator|=
literal|"FAILED: Hive Internal Error: "
operator|+
name|Utilities
operator|.
name|getNameMessage
argument_list|(
name|e
argument_list|)
expr_stmt|;
name|SQLState
operator|=
name|ErrorMsg
operator|.
name|findSQLState
argument_list|(
name|e
operator|.
name|getMessage
argument_list|()
argument_list|)
expr_stmt|;
name|downstreamError
operator|=
name|e
expr_stmt|;
name|console
operator|.
name|printError
argument_list|(
name|errorMessage
operator|+
literal|"\n"
operator|+
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|StringUtils
operator|.
name|stringifyException
argument_list|(
name|e
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|createProcessorResponse
argument_list|(
literal|12
argument_list|)
return|;
block|}
name|isFinishedWithError
operator|=
literal|false
expr_stmt|;
return|return
name|createProcessorResponse
argument_list|(
name|ret
argument_list|)
return|;
block|}
finally|finally
block|{
if|if
condition|(
name|isInterrupted
argument_list|()
condition|)
block|{
name|closeInProcess
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// only release the related resources ctx, driverContext as normal
name|releaseResources
argument_list|()
expr_stmt|;
block|}
name|lDrvState
operator|.
name|stateLock
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
if|if
condition|(
name|lDrvState
operator|.
name|driverState
operator|==
name|DriverState
operator|.
name|INTERRUPT
condition|)
block|{
name|lDrvState
operator|.
name|driverState
operator|=
name|DriverState
operator|.
name|ERROR
expr_stmt|;
block|}
else|else
block|{
name|lDrvState
operator|.
name|driverState
operator|=
name|isFinishedWithError
condition|?
name|DriverState
operator|.
name|ERROR
else|:
name|DriverState
operator|.
name|EXECUTED
expr_stmt|;
block|}
block|}
finally|finally
block|{
name|lDrvState
operator|.
name|stateLock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
block|}
specifier|private
name|CommandProcessorResponse
name|rollback
parameter_list|(
name|CommandProcessorResponse
name|cpr
parameter_list|)
block|{
comment|//console.printError(cpr.toString());
try|try
block|{
name|releaseLocksAndCommitOrRollback
argument_list|(
literal|false
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|LockException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"rollback() FAILED: "
operator|+
name|cpr
argument_list|)
expr_stmt|;
comment|//make sure not to loose
name|handleHiveException
argument_list|(
name|e
argument_list|,
literal|12
argument_list|,
literal|"Additional info in hive.log at \"rollback() FAILED\""
argument_list|)
expr_stmt|;
block|}
return|return
name|cpr
return|;
block|}
specifier|private
name|CommandProcessorResponse
name|handleHiveException
parameter_list|(
name|HiveException
name|e
parameter_list|,
name|int
name|ret
parameter_list|)
block|{
return|return
name|handleHiveException
argument_list|(
name|e
argument_list|,
name|ret
argument_list|,
literal|null
argument_list|)
return|;
block|}
specifier|private
name|CommandProcessorResponse
name|handleHiveException
parameter_list|(
name|HiveException
name|e
parameter_list|,
name|int
name|ret
parameter_list|,
name|String
name|rootMsg
parameter_list|)
block|{
name|errorMessage
operator|=
literal|"FAILED: Hive Internal Error: "
operator|+
name|Utilities
operator|.
name|getNameMessage
argument_list|(
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
name|rootMsg
operator|!=
literal|null
condition|)
block|{
name|errorMessage
operator|+=
literal|"\n"
operator|+
name|rootMsg
expr_stmt|;
block|}
name|SQLState
operator|=
name|e
operator|.
name|getCanonicalErrorMsg
argument_list|()
operator|!=
literal|null
condition|?
name|e
operator|.
name|getCanonicalErrorMsg
argument_list|()
operator|.
name|getSQLState
argument_list|()
else|:
name|ErrorMsg
operator|.
name|findSQLState
argument_list|(
name|e
operator|.
name|getMessage
argument_list|()
argument_list|)
expr_stmt|;
name|downstreamError
operator|=
name|e
expr_stmt|;
name|console
operator|.
name|printError
argument_list|(
name|errorMessage
operator|+
literal|"\n"
operator|+
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|StringUtils
operator|.
name|stringifyException
argument_list|(
name|e
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|createProcessorResponse
argument_list|(
name|ret
argument_list|)
return|;
block|}
specifier|private
name|boolean
name|requiresLock
parameter_list|()
block|{
if|if
condition|(
operator|!
name|checkConcurrency
argument_list|()
condition|)
block|{
return|return
literal|false
return|;
block|}
comment|// Lock operations themselves don't require the lock.
if|if
condition|(
name|isExplicitLockOperation
argument_list|()
condition|)
block|{
return|return
literal|false
return|;
block|}
if|if
condition|(
operator|!
name|HiveConf
operator|.
name|getBoolVar
argument_list|(
name|conf
argument_list|,
name|ConfVars
operator|.
name|HIVE_LOCK_MAPRED_ONLY
argument_list|)
condition|)
block|{
return|return
literal|true
return|;
block|}
name|Queue
argument_list|<
name|Task
argument_list|<
name|?
extends|extends
name|Serializable
argument_list|>
argument_list|>
name|taskQueue
init|=
operator|new
name|LinkedList
argument_list|<
name|Task
argument_list|<
name|?
extends|extends
name|Serializable
argument_list|>
argument_list|>
argument_list|()
decl_stmt|;
name|taskQueue
operator|.
name|addAll
argument_list|(
name|plan
operator|.
name|getRootTasks
argument_list|()
argument_list|)
expr_stmt|;
while|while
condition|(
name|taskQueue
operator|.
name|peek
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|Task
argument_list|<
name|?
extends|extends
name|Serializable
argument_list|>
name|tsk
init|=
name|taskQueue
operator|.
name|remove
argument_list|()
decl_stmt|;
if|if
condition|(
name|tsk
operator|.
name|requireLock
argument_list|()
condition|)
block|{
return|return
literal|true
return|;
block|}
if|if
condition|(
name|tsk
operator|instanceof
name|ConditionalTask
condition|)
block|{
name|taskQueue
operator|.
name|addAll
argument_list|(
operator|(
operator|(
name|ConditionalTask
operator|)
name|tsk
operator|)
operator|.
name|getListTasks
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|tsk
operator|.
name|getChildTasks
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|taskQueue
operator|.
name|addAll
argument_list|(
name|tsk
operator|.
name|getChildTasks
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// does not add back up task here, because back up task should be the same
comment|// type of the original task.
block|}
return|return
literal|false
return|;
block|}
specifier|private
name|boolean
name|isExplicitLockOperation
parameter_list|()
block|{
name|HiveOperation
name|currentOpt
init|=
name|plan
operator|.
name|getOperation
argument_list|()
decl_stmt|;
if|if
condition|(
name|currentOpt
operator|!=
literal|null
condition|)
block|{
switch|switch
condition|(
name|currentOpt
condition|)
block|{
case|case
name|LOCKDB
case|:
case|case
name|UNLOCKDB
case|:
case|case
name|LOCKTABLE
case|:
case|case
name|UNLOCKTABLE
case|:
return|return
literal|true
return|;
default|default:
return|return
literal|false
return|;
block|}
block|}
return|return
literal|false
return|;
block|}
specifier|private
name|CommandProcessorResponse
name|createProcessorResponse
parameter_list|(
name|int
name|ret
parameter_list|)
block|{
name|SessionState
operator|.
name|getPerfLogger
argument_list|()
operator|.
name|cleanupPerfLogMetrics
argument_list|()
expr_stmt|;
name|queryDisplay
operator|.
name|setErrorMessage
argument_list|(
name|errorMessage
argument_list|)
expr_stmt|;
return|return
operator|new
name|CommandProcessorResponse
argument_list|(
name|ret
argument_list|,
name|errorMessage
argument_list|,
name|SQLState
argument_list|,
name|downstreamError
argument_list|)
return|;
block|}
comment|/**    * Returns a set of hooks specified in a configuration variable.    * See getHooks(HiveConf.ConfVars hookConfVar, Class<T> clazz)    */
specifier|private
name|List
argument_list|<
name|Hook
argument_list|>
name|getHooks
parameter_list|(
name|HiveConf
operator|.
name|ConfVars
name|hookConfVar
parameter_list|)
throws|throws
name|Exception
block|{
return|return
name|getHooks
argument_list|(
name|hookConfVar
argument_list|,
name|Hook
operator|.
name|class
argument_list|)
return|;
block|}
comment|/**    * Returns the hooks specified in a configuration variable.    *    * @param hookConfVar The configuration variable specifying a comma separated list of the hook    *                    class names.    * @param clazz       The super type of the hooks.    * @return            A list of the hooks cast as the type specified in clazz, in the order    *                    they are listed in the value of hookConfVar    * @throws Exception    */
specifier|private
parameter_list|<
name|T
extends|extends
name|Hook
parameter_list|>
name|List
argument_list|<
name|T
argument_list|>
name|getHooks
parameter_list|(
name|ConfVars
name|hookConfVar
parameter_list|,
name|Class
argument_list|<
name|T
argument_list|>
name|clazz
parameter_list|)
throws|throws
name|Exception
block|{
try|try
block|{
return|return
name|HookUtils
operator|.
name|getHooks
argument_list|(
name|conf
argument_list|,
name|hookConfVar
argument_list|,
name|clazz
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|ClassNotFoundException
name|e
parameter_list|)
block|{
name|console
operator|.
name|printError
argument_list|(
name|hookConfVar
operator|.
name|varname
operator|+
literal|" Class not found:"
operator|+
name|e
operator|.
name|getMessage
argument_list|()
argument_list|)
expr_stmt|;
throw|throw
name|e
throw|;
block|}
block|}
specifier|public
name|int
name|execute
parameter_list|()
throws|throws
name|CommandNeedRetryException
block|{
return|return
name|execute
argument_list|(
literal|false
argument_list|)
return|;
block|}
specifier|public
name|int
name|execute
parameter_list|(
name|boolean
name|deferClose
parameter_list|)
throws|throws
name|CommandNeedRetryException
block|{
name|PerfLogger
name|perfLogger
init|=
name|SessionState
operator|.
name|getPerfLogger
argument_list|()
decl_stmt|;
name|perfLogger
operator|.
name|PerfLogBegin
argument_list|(
name|CLASS_NAME
argument_list|,
name|PerfLogger
operator|.
name|DRIVER_EXECUTE
argument_list|)
expr_stmt|;
name|boolean
name|noName
init|=
name|StringUtils
operator|.
name|isEmpty
argument_list|(
name|conf
operator|.
name|get
argument_list|(
name|MRJobConfig
operator|.
name|JOB_NAME
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|maxlen
init|=
name|conf
operator|.
name|getIntVar
argument_list|(
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVEJOBNAMELENGTH
argument_list|)
decl_stmt|;
name|Metrics
name|metrics
init|=
name|MetricsFactory
operator|.
name|getInstance
argument_list|()
decl_stmt|;
name|String
name|queryId
init|=
name|conf
operator|.
name|getVar
argument_list|(
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVEQUERYID
argument_list|)
decl_stmt|;
comment|// Get the query string from the conf file as the compileInternal() method might
comment|// hide sensitive information during query redaction.
name|String
name|queryStr
init|=
name|conf
operator|.
name|getQueryString
argument_list|()
decl_stmt|;
name|lDrvState
operator|.
name|stateLock
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
comment|// if query is not in compiled state, or executing state which is carried over from
comment|// a combined compile/execute in runInternal, throws the error
if|if
condition|(
name|lDrvState
operator|.
name|driverState
operator|!=
name|DriverState
operator|.
name|COMPILED
operator|&&
name|lDrvState
operator|.
name|driverState
operator|!=
name|DriverState
operator|.
name|EXECUTING
condition|)
block|{
name|SQLState
operator|=
literal|"HY008"
expr_stmt|;
name|errorMessage
operator|=
literal|"FAILED: query "
operator|+
name|queryStr
operator|+
literal|" has "
operator|+
operator|(
name|lDrvState
operator|.
name|driverState
operator|==
name|DriverState
operator|.
name|INTERRUPT
condition|?
literal|"been cancelled"
else|:
literal|"not been compiled."
operator|)
expr_stmt|;
name|console
operator|.
name|printError
argument_list|(
name|errorMessage
argument_list|)
expr_stmt|;
return|return
literal|1000
return|;
block|}
else|else
block|{
name|lDrvState
operator|.
name|driverState
operator|=
name|DriverState
operator|.
name|EXECUTING
expr_stmt|;
block|}
block|}
finally|finally
block|{
name|lDrvState
operator|.
name|stateLock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
name|maxthreads
operator|=
name|HiveConf
operator|.
name|getIntVar
argument_list|(
name|conf
argument_list|,
name|HiveConf
operator|.
name|ConfVars
operator|.
name|EXECPARALLETHREADNUMBER
argument_list|)
expr_stmt|;
name|HookContext
name|hookContext
init|=
literal|null
decl_stmt|;
comment|// Whether there's any error occurred during query execution. Used for query lifetime hook.
name|boolean
name|executionError
init|=
literal|false
decl_stmt|;
try|try
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Executing command(queryId="
operator|+
name|queryId
operator|+
literal|"): "
operator|+
name|queryStr
argument_list|)
expr_stmt|;
comment|// compile and execute can get called from different threads in case of HS2
comment|// so clear timing in this thread's Hive object before proceeding.
name|Hive
operator|.
name|get
argument_list|()
operator|.
name|clearMetaCallTiming
argument_list|()
expr_stmt|;
name|plan
operator|.
name|setStarted
argument_list|()
expr_stmt|;
if|if
condition|(
name|SessionState
operator|.
name|get
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|SessionState
operator|.
name|get
argument_list|()
operator|.
name|getHiveHistory
argument_list|()
operator|.
name|startQuery
argument_list|(
name|queryStr
argument_list|,
name|conf
operator|.
name|getVar
argument_list|(
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVEQUERYID
argument_list|)
argument_list|)
expr_stmt|;
name|SessionState
operator|.
name|get
argument_list|()
operator|.
name|getHiveHistory
argument_list|()
operator|.
name|logPlanProgress
argument_list|(
name|plan
argument_list|)
expr_stmt|;
block|}
name|resStream
operator|=
literal|null
expr_stmt|;
name|SessionState
name|ss
init|=
name|SessionState
operator|.
name|get
argument_list|()
decl_stmt|;
name|hookContext
operator|=
operator|new
name|HookContext
argument_list|(
name|plan
argument_list|,
name|queryState
argument_list|,
name|ctx
operator|.
name|getPathToCS
argument_list|()
argument_list|,
name|ss
operator|.
name|getUserFromAuthenticator
argument_list|()
argument_list|,
name|ss
operator|.
name|getUserIpAddress
argument_list|()
argument_list|,
name|InetAddress
operator|.
name|getLocalHost
argument_list|()
operator|.
name|getHostAddress
argument_list|()
argument_list|,
name|operationId
argument_list|,
name|ss
operator|.
name|getSessionId
argument_list|()
argument_list|,
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|,
name|ss
operator|.
name|isHiveServerQuery
argument_list|()
argument_list|,
name|perfLogger
argument_list|)
expr_stmt|;
name|hookContext
operator|.
name|setHookType
argument_list|(
name|HookContext
operator|.
name|HookType
operator|.
name|PRE_EXEC_HOOK
argument_list|)
expr_stmt|;
for|for
control|(
name|Hook
name|peh
range|:
name|getHooks
argument_list|(
name|HiveConf
operator|.
name|ConfVars
operator|.
name|PREEXECHOOKS
argument_list|)
control|)
block|{
if|if
condition|(
name|peh
operator|instanceof
name|ExecuteWithHookContext
condition|)
block|{
name|perfLogger
operator|.
name|PerfLogBegin
argument_list|(
name|CLASS_NAME
argument_list|,
name|PerfLogger
operator|.
name|PRE_HOOK
operator|+
name|peh
operator|.
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
operator|(
operator|(
name|ExecuteWithHookContext
operator|)
name|peh
operator|)
operator|.
name|run
argument_list|(
name|hookContext
argument_list|)
expr_stmt|;
name|perfLogger
operator|.
name|PerfLogEnd
argument_list|(
name|CLASS_NAME
argument_list|,
name|PerfLogger
operator|.
name|PRE_HOOK
operator|+
name|peh
operator|.
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|peh
operator|instanceof
name|PreExecute
condition|)
block|{
name|perfLogger
operator|.
name|PerfLogBegin
argument_list|(
name|CLASS_NAME
argument_list|,
name|PerfLogger
operator|.
name|PRE_HOOK
operator|+
name|peh
operator|.
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
operator|(
operator|(
name|PreExecute
operator|)
name|peh
operator|)
operator|.
name|run
argument_list|(
name|SessionState
operator|.
name|get
argument_list|()
argument_list|,
name|plan
operator|.
name|getInputs
argument_list|()
argument_list|,
name|plan
operator|.
name|getOutputs
argument_list|()
argument_list|,
name|Utils
operator|.
name|getUGI
argument_list|()
argument_list|)
expr_stmt|;
name|perfLogger
operator|.
name|PerfLogEnd
argument_list|(
name|CLASS_NAME
argument_list|,
name|PerfLogger
operator|.
name|PRE_HOOK
operator|+
name|peh
operator|.
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Trigger query hooks before query execution.
if|if
condition|(
name|queryHooks
operator|!=
literal|null
operator|&&
operator|!
name|queryHooks
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|QueryLifeTimeHookContext
name|qhc
init|=
operator|new
name|QueryLifeTimeHookContextImpl
argument_list|()
decl_stmt|;
name|qhc
operator|.
name|setHiveConf
argument_list|(
name|conf
argument_list|)
expr_stmt|;
name|qhc
operator|.
name|setCommand
argument_list|(
name|queryStr
argument_list|)
expr_stmt|;
name|qhc
operator|.
name|setHookContext
argument_list|(
name|hookContext
argument_list|)
expr_stmt|;
for|for
control|(
name|QueryLifeTimeHook
name|hook
range|:
name|queryHooks
control|)
block|{
name|hook
operator|.
name|beforeExecution
argument_list|(
name|qhc
argument_list|)
expr_stmt|;
block|}
block|}
name|setQueryDisplays
argument_list|(
name|plan
operator|.
name|getRootTasks
argument_list|()
argument_list|)
expr_stmt|;
name|int
name|mrJobs
init|=
name|Utilities
operator|.
name|getMRTasks
argument_list|(
name|plan
operator|.
name|getRootTasks
argument_list|()
argument_list|)
operator|.
name|size
argument_list|()
decl_stmt|;
name|int
name|jobs
init|=
name|mrJobs
operator|+
name|Utilities
operator|.
name|getTezTasks
argument_list|(
name|plan
operator|.
name|getRootTasks
argument_list|()
argument_list|)
operator|.
name|size
argument_list|()
operator|+
name|Utilities
operator|.
name|getSparkTasks
argument_list|(
name|plan
operator|.
name|getRootTasks
argument_list|()
argument_list|)
operator|.
name|size
argument_list|()
decl_stmt|;
if|if
condition|(
name|jobs
operator|>
literal|0
condition|)
block|{
name|logMrWarning
argument_list|(
name|mrJobs
argument_list|)
expr_stmt|;
name|console
operator|.
name|printInfo
argument_list|(
literal|"Query ID = "
operator|+
name|queryId
argument_list|)
expr_stmt|;
name|console
operator|.
name|printInfo
argument_list|(
literal|"Total jobs = "
operator|+
name|jobs
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|SessionState
operator|.
name|get
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|SessionState
operator|.
name|get
argument_list|()
operator|.
name|getHiveHistory
argument_list|()
operator|.
name|setQueryProperty
argument_list|(
name|queryId
argument_list|,
name|Keys
operator|.
name|QUERY_NUM_TASKS
argument_list|,
name|String
operator|.
name|valueOf
argument_list|(
name|jobs
argument_list|)
argument_list|)
expr_stmt|;
name|SessionState
operator|.
name|get
argument_list|()
operator|.
name|getHiveHistory
argument_list|()
operator|.
name|setIdToTableMap
argument_list|(
name|plan
operator|.
name|getIdToTableNameMap
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|String
name|jobname
init|=
name|Utilities
operator|.
name|abbreviate
argument_list|(
name|queryStr
argument_list|,
name|maxlen
operator|-
literal|6
argument_list|)
decl_stmt|;
comment|// A runtime that launches runnable tasks as separate Threads through
comment|// TaskRunners
comment|// As soon as a task isRunnable, it is put in a queue
comment|// At any time, at most maxthreads tasks can be running
comment|// The main thread polls the TaskRunners to check if they have finished.
if|if
condition|(
name|isInterrupted
argument_list|()
condition|)
block|{
return|return
name|handleInterruption
argument_list|(
literal|"before running tasks."
argument_list|)
return|;
block|}
name|DriverContext
name|driverCxt
init|=
operator|new
name|DriverContext
argument_list|(
name|ctx
argument_list|)
decl_stmt|;
name|driverCxt
operator|.
name|prepare
argument_list|(
name|plan
argument_list|)
expr_stmt|;
name|ctx
operator|.
name|setHDFSCleanup
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|this
operator|.
name|driverCxt
operator|=
name|driverCxt
expr_stmt|;
comment|// for canceling the query (should be bound to session?)
name|SessionState
operator|.
name|get
argument_list|()
operator|.
name|setMapRedStats
argument_list|(
operator|new
name|LinkedHashMap
argument_list|<
name|String
argument_list|,
name|MapRedStats
argument_list|>
argument_list|()
argument_list|)
expr_stmt|;
name|SessionState
operator|.
name|get
argument_list|()
operator|.
name|setStackTraces
argument_list|(
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|List
argument_list|<
name|List
argument_list|<
name|String
argument_list|>
argument_list|>
argument_list|>
argument_list|()
argument_list|)
expr_stmt|;
name|SessionState
operator|.
name|get
argument_list|()
operator|.
name|setLocalMapRedErrors
argument_list|(
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|List
argument_list|<
name|String
argument_list|>
argument_list|>
argument_list|()
argument_list|)
expr_stmt|;
comment|// Add root Tasks to runnable
for|for
control|(
name|Task
argument_list|<
name|?
extends|extends
name|Serializable
argument_list|>
name|tsk
range|:
name|plan
operator|.
name|getRootTasks
argument_list|()
control|)
block|{
comment|// This should never happen, if it does, it's a bug with the potential to produce
comment|// incorrect results.
assert|assert
name|tsk
operator|.
name|getParentTasks
argument_list|()
operator|==
literal|null
operator|||
name|tsk
operator|.
name|getParentTasks
argument_list|()
operator|.
name|isEmpty
argument_list|()
assert|;
name|driverCxt
operator|.
name|addToRunnable
argument_list|(
name|tsk
argument_list|)
expr_stmt|;
if|if
condition|(
name|metrics
operator|!=
literal|null
condition|)
block|{
name|tsk
operator|.
name|updateTaskMetrics
argument_list|(
name|metrics
argument_list|)
expr_stmt|;
block|}
block|}
name|perfLogger
operator|.
name|PerfLogBegin
argument_list|(
name|CLASS_NAME
argument_list|,
name|PerfLogger
operator|.
name|RUN_TASKS
argument_list|)
expr_stmt|;
comment|// Loop while you either have tasks running, or tasks queued up
while|while
condition|(
name|driverCxt
operator|.
name|isRunning
argument_list|()
condition|)
block|{
comment|// Launch upto maxthreads tasks
name|Task
argument_list|<
name|?
extends|extends
name|Serializable
argument_list|>
name|task
decl_stmt|;
while|while
condition|(
operator|(
name|task
operator|=
name|driverCxt
operator|.
name|getRunnable
argument_list|(
name|maxthreads
argument_list|)
operator|)
operator|!=
literal|null
condition|)
block|{
name|TaskRunner
name|runner
init|=
name|launchTask
argument_list|(
name|task
argument_list|,
name|queryId
argument_list|,
name|noName
argument_list|,
name|jobname
argument_list|,
name|jobs
argument_list|,
name|driverCxt
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|runner
operator|.
name|isRunning
argument_list|()
condition|)
block|{
break|break;
block|}
block|}
comment|// poll the Tasks to see which one completed
name|TaskRunner
name|tskRun
init|=
name|driverCxt
operator|.
name|pollFinished
argument_list|()
decl_stmt|;
if|if
condition|(
name|tskRun
operator|==
literal|null
condition|)
block|{
continue|continue;
block|}
name|hookContext
operator|.
name|addCompleteTask
argument_list|(
name|tskRun
argument_list|)
expr_stmt|;
name|queryDisplay
operator|.
name|setTaskResult
argument_list|(
name|tskRun
operator|.
name|getTask
argument_list|()
operator|.
name|getId
argument_list|()
argument_list|,
name|tskRun
operator|.
name|getTaskResult
argument_list|()
argument_list|)
expr_stmt|;
name|Task
argument_list|<
name|?
extends|extends
name|Serializable
argument_list|>
name|tsk
init|=
name|tskRun
operator|.
name|getTask
argument_list|()
decl_stmt|;
name|TaskResult
name|result
init|=
name|tskRun
operator|.
name|getTaskResult
argument_list|()
decl_stmt|;
name|int
name|exitVal
init|=
name|result
operator|.
name|getExitVal
argument_list|()
decl_stmt|;
if|if
condition|(
name|isInterrupted
argument_list|()
condition|)
block|{
return|return
name|handleInterruption
argument_list|(
literal|"when checking the execution result."
argument_list|)
return|;
block|}
if|if
condition|(
name|exitVal
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|tsk
operator|.
name|ifRetryCmdWhenFail
argument_list|()
condition|)
block|{
name|driverCxt
operator|.
name|shutdown
argument_list|()
expr_stmt|;
comment|// in case we decided to run everything in local mode, restore the
comment|// the jobtracker setting to its initial value
name|ctx
operator|.
name|restoreOriginalTracker
argument_list|()
expr_stmt|;
throw|throw
operator|new
name|CommandNeedRetryException
argument_list|()
throw|;
block|}
name|Task
argument_list|<
name|?
extends|extends
name|Serializable
argument_list|>
name|backupTask
init|=
name|tsk
operator|.
name|getAndInitBackupTask
argument_list|()
decl_stmt|;
if|if
condition|(
name|backupTask
operator|!=
literal|null
condition|)
block|{
name|setErrorMsgAndDetail
argument_list|(
name|exitVal
argument_list|,
name|result
operator|.
name|getTaskError
argument_list|()
argument_list|,
name|tsk
argument_list|)
expr_stmt|;
name|console
operator|.
name|printError
argument_list|(
name|errorMessage
argument_list|)
expr_stmt|;
name|errorMessage
operator|=
literal|"ATTEMPT: Execute BackupTask: "
operator|+
name|backupTask
operator|.
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
expr_stmt|;
name|console
operator|.
name|printError
argument_list|(
name|errorMessage
argument_list|)
expr_stmt|;
comment|// add backup task to runnable
if|if
condition|(
name|DriverContext
operator|.
name|isLaunchable
argument_list|(
name|backupTask
argument_list|)
condition|)
block|{
name|driverCxt
operator|.
name|addToRunnable
argument_list|(
name|backupTask
argument_list|)
expr_stmt|;
block|}
continue|continue;
block|}
else|else
block|{
name|setErrorMsgAndDetail
argument_list|(
name|exitVal
argument_list|,
name|result
operator|.
name|getTaskError
argument_list|()
argument_list|,
name|tsk
argument_list|)
expr_stmt|;
name|invokeFailureHooks
argument_list|(
name|perfLogger
argument_list|,
name|hookContext
argument_list|,
name|errorMessage
operator|+
name|Strings
operator|.
name|nullToEmpty
argument_list|(
name|tsk
operator|.
name|getDiagnosticsMessage
argument_list|()
argument_list|)
argument_list|,
name|result
operator|.
name|getTaskError
argument_list|()
argument_list|)
expr_stmt|;
name|SQLState
operator|=
literal|"08S01"
expr_stmt|;
name|console
operator|.
name|printError
argument_list|(
name|errorMessage
argument_list|)
expr_stmt|;
name|driverCxt
operator|.
name|shutdown
argument_list|()
expr_stmt|;
comment|// in case we decided to run everything in local mode, restore the
comment|// the jobtracker setting to its initial value
name|ctx
operator|.
name|restoreOriginalTracker
argument_list|()
expr_stmt|;
return|return
name|exitVal
return|;
block|}
block|}
name|driverCxt
operator|.
name|finished
argument_list|(
name|tskRun
argument_list|)
expr_stmt|;
if|if
condition|(
name|SessionState
operator|.
name|get
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|SessionState
operator|.
name|get
argument_list|()
operator|.
name|getHiveHistory
argument_list|()
operator|.
name|setTaskProperty
argument_list|(
name|queryId
argument_list|,
name|tsk
operator|.
name|getId
argument_list|()
argument_list|,
name|Keys
operator|.
name|TASK_RET_CODE
argument_list|,
name|String
operator|.
name|valueOf
argument_list|(
name|exitVal
argument_list|)
argument_list|)
expr_stmt|;
name|SessionState
operator|.
name|get
argument_list|()
operator|.
name|getHiveHistory
argument_list|()
operator|.
name|endTask
argument_list|(
name|queryId
argument_list|,
name|tsk
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|tsk
operator|.
name|getChildTasks
argument_list|()
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|Task
argument_list|<
name|?
extends|extends
name|Serializable
argument_list|>
name|child
range|:
name|tsk
operator|.
name|getChildTasks
argument_list|()
control|)
block|{
if|if
condition|(
name|DriverContext
operator|.
name|isLaunchable
argument_list|(
name|child
argument_list|)
condition|)
block|{
name|driverCxt
operator|.
name|addToRunnable
argument_list|(
name|child
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
name|perfLogger
operator|.
name|PerfLogEnd
argument_list|(
name|CLASS_NAME
argument_list|,
name|PerfLogger
operator|.
name|RUN_TASKS
argument_list|)
expr_stmt|;
comment|// in case we decided to run everything in local mode, restore the
comment|// the jobtracker setting to its initial value
name|ctx
operator|.
name|restoreOriginalTracker
argument_list|()
expr_stmt|;
if|if
condition|(
name|driverCxt
operator|.
name|isShutdown
argument_list|()
condition|)
block|{
name|SQLState
operator|=
literal|"HY008"
expr_stmt|;
name|errorMessage
operator|=
literal|"FAILED: Operation cancelled"
expr_stmt|;
name|invokeFailureHooks
argument_list|(
name|perfLogger
argument_list|,
name|hookContext
argument_list|,
name|errorMessage
argument_list|,
literal|null
argument_list|)
expr_stmt|;
name|console
operator|.
name|printError
argument_list|(
name|errorMessage
argument_list|)
expr_stmt|;
return|return
literal|1000
return|;
block|}
comment|// remove incomplete outputs.
comment|// Some incomplete outputs may be added at the beginning, for eg: for dynamic partitions.
comment|// remove them
name|HashSet
argument_list|<
name|WriteEntity
argument_list|>
name|remOutputs
init|=
operator|new
name|LinkedHashSet
argument_list|<
name|WriteEntity
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|WriteEntity
name|output
range|:
name|plan
operator|.
name|getOutputs
argument_list|()
control|)
block|{
if|if
condition|(
operator|!
name|output
operator|.
name|isComplete
argument_list|()
condition|)
block|{
name|remOutputs
operator|.
name|add
argument_list|(
name|output
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
name|WriteEntity
name|output
range|:
name|remOutputs
control|)
block|{
name|plan
operator|.
name|getOutputs
argument_list|()
operator|.
name|remove
argument_list|(
name|output
argument_list|)
expr_stmt|;
block|}
name|hookContext
operator|.
name|setHookType
argument_list|(
name|HookContext
operator|.
name|HookType
operator|.
name|POST_EXEC_HOOK
argument_list|)
expr_stmt|;
comment|// Get all the post execution hooks and execute them.
for|for
control|(
name|Hook
name|peh
range|:
name|getHooks
argument_list|(
name|HiveConf
operator|.
name|ConfVars
operator|.
name|POSTEXECHOOKS
argument_list|)
control|)
block|{
if|if
condition|(
name|peh
operator|instanceof
name|ExecuteWithHookContext
condition|)
block|{
name|perfLogger
operator|.
name|PerfLogBegin
argument_list|(
name|CLASS_NAME
argument_list|,
name|PerfLogger
operator|.
name|POST_HOOK
operator|+
name|peh
operator|.
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
operator|(
operator|(
name|ExecuteWithHookContext
operator|)
name|peh
operator|)
operator|.
name|run
argument_list|(
name|hookContext
argument_list|)
expr_stmt|;
name|perfLogger
operator|.
name|PerfLogEnd
argument_list|(
name|CLASS_NAME
argument_list|,
name|PerfLogger
operator|.
name|POST_HOOK
operator|+
name|peh
operator|.
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|peh
operator|instanceof
name|PostExecute
condition|)
block|{
name|perfLogger
operator|.
name|PerfLogBegin
argument_list|(
name|CLASS_NAME
argument_list|,
name|PerfLogger
operator|.
name|POST_HOOK
operator|+
name|peh
operator|.
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
operator|(
operator|(
name|PostExecute
operator|)
name|peh
operator|)
operator|.
name|run
argument_list|(
name|SessionState
operator|.
name|get
argument_list|()
argument_list|,
name|plan
operator|.
name|getInputs
argument_list|()
argument_list|,
name|plan
operator|.
name|getOutputs
argument_list|()
argument_list|,
operator|(
name|SessionState
operator|.
name|get
argument_list|()
operator|!=
literal|null
condition|?
name|SessionState
operator|.
name|get
argument_list|()
operator|.
name|getLineageState
argument_list|()
operator|.
name|getLineageInfo
argument_list|()
else|:
literal|null
operator|)
argument_list|,
name|Utils
operator|.
name|getUGI
argument_list|()
argument_list|)
expr_stmt|;
name|perfLogger
operator|.
name|PerfLogEnd
argument_list|(
name|CLASS_NAME
argument_list|,
name|PerfLogger
operator|.
name|POST_HOOK
operator|+
name|peh
operator|.
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|SessionState
operator|.
name|get
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|SessionState
operator|.
name|get
argument_list|()
operator|.
name|getHiveHistory
argument_list|()
operator|.
name|setQueryProperty
argument_list|(
name|queryId
argument_list|,
name|Keys
operator|.
name|QUERY_RET_CODE
argument_list|,
name|String
operator|.
name|valueOf
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|SessionState
operator|.
name|get
argument_list|()
operator|.
name|getHiveHistory
argument_list|()
operator|.
name|printRowCount
argument_list|(
name|queryId
argument_list|)
expr_stmt|;
block|}
name|releasePlan
argument_list|(
name|plan
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|CommandNeedRetryException
name|e
parameter_list|)
block|{
name|executionError
operator|=
literal|true
expr_stmt|;
throw|throw
name|e
throw|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|e
parameter_list|)
block|{
name|executionError
operator|=
literal|true
expr_stmt|;
if|if
condition|(
name|isInterrupted
argument_list|()
condition|)
block|{
return|return
name|handleInterruption
argument_list|(
literal|"during query execution: \n"
operator|+
name|e
operator|.
name|getMessage
argument_list|()
argument_list|)
return|;
block|}
name|ctx
operator|.
name|restoreOriginalTracker
argument_list|()
expr_stmt|;
if|if
condition|(
name|SessionState
operator|.
name|get
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|SessionState
operator|.
name|get
argument_list|()
operator|.
name|getHiveHistory
argument_list|()
operator|.
name|setQueryProperty
argument_list|(
name|queryId
argument_list|,
name|Keys
operator|.
name|QUERY_RET_CODE
argument_list|,
name|String
operator|.
name|valueOf
argument_list|(
literal|12
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// TODO: do better with handling types of Exception here
name|errorMessage
operator|=
literal|"FAILED: Hive Internal Error: "
operator|+
name|Utilities
operator|.
name|getNameMessage
argument_list|(
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
name|hookContext
operator|!=
literal|null
condition|)
block|{
try|try
block|{
name|invokeFailureHooks
argument_list|(
name|perfLogger
argument_list|,
name|hookContext
argument_list|,
name|errorMessage
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|t
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Failed to invoke failure hook"
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
block|}
name|SQLState
operator|=
literal|"08S01"
expr_stmt|;
name|downstreamError
operator|=
name|e
expr_stmt|;
name|console
operator|.
name|printError
argument_list|(
name|errorMessage
operator|+
literal|"\n"
operator|+
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|StringUtils
operator|.
name|stringifyException
argument_list|(
name|e
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|12
operator|)
return|;
block|}
finally|finally
block|{
comment|// Trigger query hooks after query completes its execution.
try|try
block|{
if|if
condition|(
name|queryHooks
operator|!=
literal|null
operator|&&
operator|!
name|queryHooks
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|QueryLifeTimeHookContext
name|qhc
init|=
operator|new
name|QueryLifeTimeHookContextImpl
argument_list|()
decl_stmt|;
name|qhc
operator|.
name|setHiveConf
argument_list|(
name|conf
argument_list|)
expr_stmt|;
name|qhc
operator|.
name|setCommand
argument_list|(
name|queryStr
argument_list|)
expr_stmt|;
name|qhc
operator|.
name|setHookContext
argument_list|(
name|hookContext
argument_list|)
expr_stmt|;
for|for
control|(
name|QueryLifeTimeHook
name|hook
range|:
name|queryHooks
control|)
block|{
name|hook
operator|.
name|afterExecution
argument_list|(
name|qhc
argument_list|,
name|executionError
argument_list|)
expr_stmt|;
block|}
block|}
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Failed when invoking query after execution hook"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|SessionState
operator|.
name|get
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|SessionState
operator|.
name|get
argument_list|()
operator|.
name|getHiveHistory
argument_list|()
operator|.
name|endQuery
argument_list|(
name|queryId
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|noName
condition|)
block|{
name|conf
operator|.
name|set
argument_list|(
name|MRJobConfig
operator|.
name|JOB_NAME
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
name|double
name|duration
init|=
name|perfLogger
operator|.
name|PerfLogEnd
argument_list|(
name|CLASS_NAME
argument_list|,
name|PerfLogger
operator|.
name|DRIVER_EXECUTE
argument_list|)
operator|/
literal|1000.00
decl_stmt|;
name|ImmutableMap
argument_list|<
name|String
argument_list|,
name|Long
argument_list|>
name|executionHMSTimings
init|=
name|dumpMetaCallTimingWithoutEx
argument_list|(
literal|"execution"
argument_list|)
decl_stmt|;
name|queryDisplay
operator|.
name|setHmsTimings
argument_list|(
name|QueryDisplay
operator|.
name|Phase
operator|.
name|EXECUTION
argument_list|,
name|executionHMSTimings
argument_list|)
expr_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|MapRedStats
argument_list|>
name|stats
init|=
name|SessionState
operator|.
name|get
argument_list|()
operator|.
name|getMapRedStats
argument_list|()
decl_stmt|;
if|if
condition|(
name|stats
operator|!=
literal|null
operator|&&
operator|!
name|stats
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|long
name|totalCpu
init|=
literal|0
decl_stmt|;
name|console
operator|.
name|printInfo
argument_list|(
literal|"MapReduce Jobs Launched: "
argument_list|)
expr_stmt|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|MapRedStats
argument_list|>
name|entry
range|:
name|stats
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|console
operator|.
name|printInfo
argument_list|(
literal|"Stage-"
operator|+
name|entry
operator|.
name|getKey
argument_list|()
operator|+
literal|": "
operator|+
name|entry
operator|.
name|getValue
argument_list|()
argument_list|)
expr_stmt|;
name|totalCpu
operator|+=
name|entry
operator|.
name|getValue
argument_list|()
operator|.
name|getCpuMSec
argument_list|()
expr_stmt|;
block|}
name|console
operator|.
name|printInfo
argument_list|(
literal|"Total MapReduce CPU Time Spent: "
operator|+
name|Utilities
operator|.
name|formatMsecToStr
argument_list|(
name|totalCpu
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|boolean
name|isInterrupted
init|=
name|isInterrupted
argument_list|()
decl_stmt|;
if|if
condition|(
name|isInterrupted
operator|&&
operator|!
name|deferClose
condition|)
block|{
name|closeInProcess
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
name|lDrvState
operator|.
name|stateLock
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
if|if
condition|(
name|isInterrupted
condition|)
block|{
if|if
condition|(
operator|!
name|deferClose
condition|)
block|{
name|lDrvState
operator|.
name|driverState
operator|=
name|DriverState
operator|.
name|ERROR
expr_stmt|;
block|}
block|}
else|else
block|{
name|lDrvState
operator|.
name|driverState
operator|=
name|executionError
condition|?
name|DriverState
operator|.
name|ERROR
else|:
name|DriverState
operator|.
name|EXECUTED
expr_stmt|;
block|}
block|}
finally|finally
block|{
name|lDrvState
operator|.
name|stateLock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|isInterrupted
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Executing command(queryId="
operator|+
name|queryId
operator|+
literal|") has been interrupted after "
operator|+
name|duration
operator|+
literal|" seconds"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Completed executing command(queryId="
operator|+
name|queryId
operator|+
literal|"); Time taken: "
operator|+
name|duration
operator|+
literal|" seconds"
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|console
operator|!=
literal|null
condition|)
block|{
name|console
operator|.
name|printInfo
argument_list|(
literal|"OK"
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
specifier|private
name|void
name|releasePlan
parameter_list|(
name|QueryPlan
name|plan
parameter_list|)
block|{
comment|// Plan maybe null if Driver.close is called in another thread for the same Driver object
name|lDrvState
operator|.
name|stateLock
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
if|if
condition|(
name|plan
operator|!=
literal|null
condition|)
block|{
name|plan
operator|.
name|setDone
argument_list|()
expr_stmt|;
if|if
condition|(
name|SessionState
operator|.
name|get
argument_list|()
operator|!=
literal|null
condition|)
block|{
try|try
block|{
name|SessionState
operator|.
name|get
argument_list|()
operator|.
name|getHiveHistory
argument_list|()
operator|.
name|logPlanProgress
argument_list|(
name|plan
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
comment|// Log and ignore
name|LOG
operator|.
name|warn
argument_list|(
literal|"Could not log query plan progress"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
finally|finally
block|{
name|lDrvState
operator|.
name|stateLock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|setQueryDisplays
parameter_list|(
name|List
argument_list|<
name|Task
argument_list|<
name|?
extends|extends
name|Serializable
argument_list|>
argument_list|>
name|tasks
parameter_list|)
block|{
if|if
condition|(
name|tasks
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|Task
argument_list|<
name|?
extends|extends
name|Serializable
argument_list|>
name|task
range|:
name|tasks
control|)
block|{
name|task
operator|.
name|setQueryDisplay
argument_list|(
name|queryDisplay
argument_list|)
expr_stmt|;
name|setQueryDisplays
argument_list|(
name|task
operator|.
name|getDependentTasks
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
specifier|private
name|void
name|logMrWarning
parameter_list|(
name|int
name|mrJobs
parameter_list|)
block|{
if|if
condition|(
name|mrJobs
operator|<=
literal|0
operator|||
operator|!
operator|(
literal|"mr"
operator|.
name|equals
argument_list|(
name|HiveConf
operator|.
name|getVar
argument_list|(
name|conf
argument_list|,
name|ConfVars
operator|.
name|HIVE_EXECUTION_ENGINE
argument_list|)
argument_list|)
operator|)
condition|)
block|{
return|return;
block|}
name|String
name|warning
init|=
name|HiveConf
operator|.
name|generateMrDeprecationWarning
argument_list|()
decl_stmt|;
name|LOG
operator|.
name|warn
argument_list|(
name|warning
argument_list|)
expr_stmt|;
name|warning
operator|=
literal|"WARNING: "
operator|+
name|warning
expr_stmt|;
name|console
operator|.
name|printInfo
argument_list|(
name|warning
argument_list|)
expr_stmt|;
comment|// Propagate warning to beeline via operation log.
name|OperationLog
name|ol
init|=
name|OperationLog
operator|.
name|getCurrentOperationLog
argument_list|()
decl_stmt|;
if|if
condition|(
name|ol
operator|!=
literal|null
condition|)
block|{
name|ol
operator|.
name|writeOperationLog
argument_list|(
name|LoggingLevel
operator|.
name|EXECUTION
argument_list|,
name|warning
operator|+
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|setErrorMsgAndDetail
parameter_list|(
name|int
name|exitVal
parameter_list|,
name|Throwable
name|downstreamError
parameter_list|,
name|Task
name|tsk
parameter_list|)
block|{
name|this
operator|.
name|downstreamError
operator|=
name|downstreamError
expr_stmt|;
name|errorMessage
operator|=
literal|"FAILED: Execution Error, return code "
operator|+
name|exitVal
operator|+
literal|" from "
operator|+
name|tsk
operator|.
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
expr_stmt|;
if|if
condition|(
name|downstreamError
operator|!=
literal|null
condition|)
block|{
comment|//here we assume that upstream code may have parametrized the msg from ErrorMsg
comment|//so we want to keep it
name|errorMessage
operator|+=
literal|". "
operator|+
name|downstreamError
operator|.
name|getMessage
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|ErrorMsg
name|em
init|=
name|ErrorMsg
operator|.
name|getErrorMsg
argument_list|(
name|exitVal
argument_list|)
decl_stmt|;
if|if
condition|(
name|em
operator|!=
literal|null
condition|)
block|{
name|errorMessage
operator|+=
literal|". "
operator|+
name|em
operator|.
name|getMsg
argument_list|()
expr_stmt|;
block|}
block|}
block|}
specifier|private
name|void
name|invokeFailureHooks
parameter_list|(
name|PerfLogger
name|perfLogger
parameter_list|,
name|HookContext
name|hookContext
parameter_list|,
name|String
name|errorMessage
parameter_list|,
name|Throwable
name|exception
parameter_list|)
throws|throws
name|Exception
block|{
name|hookContext
operator|.
name|setHookType
argument_list|(
name|HookContext
operator|.
name|HookType
operator|.
name|ON_FAILURE_HOOK
argument_list|)
expr_stmt|;
name|hookContext
operator|.
name|setErrorMessage
argument_list|(
name|errorMessage
argument_list|)
expr_stmt|;
name|hookContext
operator|.
name|setException
argument_list|(
name|exception
argument_list|)
expr_stmt|;
comment|// Get all the failure execution hooks and execute them.
for|for
control|(
name|Hook
name|ofh
range|:
name|getHooks
argument_list|(
name|HiveConf
operator|.
name|ConfVars
operator|.
name|ONFAILUREHOOKS
argument_list|)
control|)
block|{
name|perfLogger
operator|.
name|PerfLogBegin
argument_list|(
name|CLASS_NAME
argument_list|,
name|PerfLogger
operator|.
name|FAILURE_HOOK
operator|+
name|ofh
operator|.
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
operator|(
operator|(
name|ExecuteWithHookContext
operator|)
name|ofh
operator|)
operator|.
name|run
argument_list|(
name|hookContext
argument_list|)
expr_stmt|;
name|perfLogger
operator|.
name|PerfLogEnd
argument_list|(
name|CLASS_NAME
argument_list|,
name|PerfLogger
operator|.
name|FAILURE_HOOK
operator|+
name|ofh
operator|.
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Launches a new task    *    * @param tsk    *          task being launched    * @param queryId    *          Id of the query containing the task    * @param noName    *          whether the task has a name set    * @param jobname    *          name of the task, if it is a map-reduce job    * @param jobs    *          number of map-reduce jobs    * @param cxt    *          the driver context    */
specifier|private
name|TaskRunner
name|launchTask
parameter_list|(
name|Task
argument_list|<
name|?
extends|extends
name|Serializable
argument_list|>
name|tsk
parameter_list|,
name|String
name|queryId
parameter_list|,
name|boolean
name|noName
parameter_list|,
name|String
name|jobname
parameter_list|,
name|int
name|jobs
parameter_list|,
name|DriverContext
name|cxt
parameter_list|)
throws|throws
name|HiveException
block|{
if|if
condition|(
name|SessionState
operator|.
name|get
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|SessionState
operator|.
name|get
argument_list|()
operator|.
name|getHiveHistory
argument_list|()
operator|.
name|startTask
argument_list|(
name|queryId
argument_list|,
name|tsk
argument_list|,
name|tsk
operator|.
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|tsk
operator|.
name|isMapRedTask
argument_list|()
operator|&&
operator|!
operator|(
name|tsk
operator|instanceof
name|ConditionalTask
operator|)
condition|)
block|{
if|if
condition|(
name|noName
condition|)
block|{
name|conf
operator|.
name|set
argument_list|(
name|MRJobConfig
operator|.
name|JOB_NAME
argument_list|,
name|jobname
operator|+
literal|"("
operator|+
name|tsk
operator|.
name|getId
argument_list|()
operator|+
literal|")"
argument_list|)
expr_stmt|;
block|}
name|conf
operator|.
name|set
argument_list|(
literal|"mapreduce.workflow.node.name"
argument_list|,
name|tsk
operator|.
name|getId
argument_list|()
argument_list|)
expr_stmt|;
name|Utilities
operator|.
name|setWorkflowAdjacencies
argument_list|(
name|conf
argument_list|,
name|plan
argument_list|)
expr_stmt|;
name|cxt
operator|.
name|incCurJobNo
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|console
operator|.
name|printInfo
argument_list|(
literal|"Launching Job "
operator|+
name|cxt
operator|.
name|getCurJobNo
argument_list|()
operator|+
literal|" out of "
operator|+
name|jobs
argument_list|)
expr_stmt|;
block|}
name|tsk
operator|.
name|initialize
argument_list|(
name|queryState
argument_list|,
name|plan
argument_list|,
name|cxt
argument_list|,
name|ctx
operator|.
name|getOpContext
argument_list|()
argument_list|)
expr_stmt|;
name|TaskResult
name|tskRes
init|=
operator|new
name|TaskResult
argument_list|()
decl_stmt|;
name|TaskRunner
name|tskRun
init|=
operator|new
name|TaskRunner
argument_list|(
name|tsk
argument_list|,
name|tskRes
argument_list|)
decl_stmt|;
name|cxt
operator|.
name|launching
argument_list|(
name|tskRun
argument_list|)
expr_stmt|;
comment|// Launch Task
if|if
condition|(
name|HiveConf
operator|.
name|getBoolVar
argument_list|(
name|conf
argument_list|,
name|HiveConf
operator|.
name|ConfVars
operator|.
name|EXECPARALLEL
argument_list|)
operator|&&
name|tsk
operator|.
name|isMapRedTask
argument_list|()
condition|)
block|{
comment|// Launch it in the parallel mode, as a separate thread only for MR tasks
if|if
condition|(
name|LOG
operator|.
name|isInfoEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Starting task ["
operator|+
name|tsk
operator|+
literal|"] in parallel"
argument_list|)
expr_stmt|;
block|}
name|tskRun
operator|.
name|setOperationLog
argument_list|(
name|OperationLog
operator|.
name|getCurrentOperationLog
argument_list|()
argument_list|)
expr_stmt|;
name|tskRun
operator|.
name|start
argument_list|()
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|LOG
operator|.
name|isInfoEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Starting task ["
operator|+
name|tsk
operator|+
literal|"] in serial mode"
argument_list|)
expr_stmt|;
block|}
name|tskRun
operator|.
name|runSequential
argument_list|()
expr_stmt|;
block|}
return|return
name|tskRun
return|;
block|}
specifier|public
name|boolean
name|isFetchingTable
parameter_list|()
block|{
return|return
name|fetchTask
operator|!=
literal|null
return|;
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
specifier|public
name|boolean
name|getResults
parameter_list|(
name|List
name|res
parameter_list|)
throws|throws
name|IOException
throws|,
name|CommandNeedRetryException
block|{
if|if
condition|(
name|lDrvState
operator|.
name|driverState
operator|==
name|DriverState
operator|.
name|DESTROYED
operator|||
name|lDrvState
operator|.
name|driverState
operator|==
name|DriverState
operator|.
name|CLOSED
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"FAILED: query has been cancelled, closed, or destroyed."
argument_list|)
throw|;
block|}
if|if
condition|(
name|isFetchingTable
argument_list|()
condition|)
block|{
comment|/**        * If resultset serialization to thrift object is enabled, and if the destination table is        * indeed written using ThriftJDBCBinarySerDe, read one row from the output sequence file,        * since it is a blob of row batches.        */
if|if
condition|(
name|fetchTask
operator|.
name|getWork
argument_list|()
operator|.
name|isUsingThriftJDBCBinarySerDe
argument_list|()
condition|)
block|{
name|maxRows
operator|=
literal|1
expr_stmt|;
block|}
name|fetchTask
operator|.
name|setMaxRows
argument_list|(
name|maxRows
argument_list|)
expr_stmt|;
return|return
name|fetchTask
operator|.
name|fetch
argument_list|(
name|res
argument_list|)
return|;
block|}
if|if
condition|(
name|resStream
operator|==
literal|null
condition|)
block|{
name|resStream
operator|=
name|ctx
operator|.
name|getStream
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|resStream
operator|==
literal|null
condition|)
block|{
return|return
literal|false
return|;
block|}
name|int
name|numRows
init|=
literal|0
decl_stmt|;
name|String
name|row
init|=
literal|null
decl_stmt|;
while|while
condition|(
name|numRows
operator|<
name|maxRows
condition|)
block|{
if|if
condition|(
name|resStream
operator|==
literal|null
condition|)
block|{
if|if
condition|(
name|numRows
operator|>
literal|0
condition|)
block|{
return|return
literal|true
return|;
block|}
else|else
block|{
return|return
literal|false
return|;
block|}
block|}
name|bos
operator|.
name|reset
argument_list|()
expr_stmt|;
name|Utilities
operator|.
name|StreamStatus
name|ss
decl_stmt|;
try|try
block|{
name|ss
operator|=
name|Utilities
operator|.
name|readColumn
argument_list|(
name|resStream
argument_list|,
name|bos
argument_list|)
expr_stmt|;
if|if
condition|(
name|bos
operator|.
name|getLength
argument_list|()
operator|>
literal|0
condition|)
block|{
name|row
operator|=
operator|new
name|String
argument_list|(
name|bos
operator|.
name|getData
argument_list|()
argument_list|,
literal|0
argument_list|,
name|bos
operator|.
name|getLength
argument_list|()
argument_list|,
literal|"UTF-8"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ss
operator|==
name|Utilities
operator|.
name|StreamStatus
operator|.
name|TERMINATED
condition|)
block|{
name|row
operator|=
operator|new
name|String
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|row
operator|!=
literal|null
condition|)
block|{
name|numRows
operator|++
expr_stmt|;
name|res
operator|.
name|add
argument_list|(
name|row
argument_list|)
expr_stmt|;
block|}
name|row
operator|=
literal|null
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|console
operator|.
name|printError
argument_list|(
literal|"FAILED: Unexpected IO exception : "
operator|+
name|e
operator|.
name|getMessage
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
name|ss
operator|==
name|Utilities
operator|.
name|StreamStatus
operator|.
name|EOF
condition|)
block|{
name|resStream
operator|=
name|ctx
operator|.
name|getStream
argument_list|()
expr_stmt|;
block|}
block|}
return|return
literal|true
return|;
block|}
specifier|public
name|void
name|resetFetch
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|lDrvState
operator|.
name|driverState
operator|==
name|DriverState
operator|.
name|DESTROYED
operator|||
name|lDrvState
operator|.
name|driverState
operator|==
name|DriverState
operator|.
name|CLOSED
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"FAILED: driver has been cancelled, closed or destroyed."
argument_list|)
throw|;
block|}
if|if
condition|(
name|isFetchingTable
argument_list|()
condition|)
block|{
try|try
block|{
name|fetchTask
operator|.
name|clearFetch
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Error closing the current fetch task"
argument_list|,
name|e
argument_list|)
throw|;
block|}
comment|// FetchTask should not depend on the plan.
name|fetchTask
operator|.
name|initialize
argument_list|(
name|queryState
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
name|ctx
operator|.
name|getOpContext
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ctx
operator|.
name|resetStream
argument_list|()
expr_stmt|;
name|resStream
operator|=
literal|null
expr_stmt|;
block|}
block|}
specifier|public
name|int
name|getTryCount
parameter_list|()
block|{
return|return
name|tryCount
return|;
block|}
specifier|public
name|void
name|setTryCount
parameter_list|(
name|int
name|tryCount
parameter_list|)
block|{
name|this
operator|.
name|tryCount
operator|=
name|tryCount
expr_stmt|;
block|}
comment|// DriverContext could be released in the query and close processes at same
comment|// time, which needs to be thread protected.
specifier|private
name|void
name|releaseDriverContext
parameter_list|()
block|{
name|lDrvState
operator|.
name|stateLock
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
if|if
condition|(
name|driverCxt
operator|!=
literal|null
condition|)
block|{
name|driverCxt
operator|.
name|shutdown
argument_list|()
expr_stmt|;
name|driverCxt
operator|=
literal|null
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Exception while shutting down the task runner"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|lDrvState
operator|.
name|stateLock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|releasePlan
parameter_list|()
block|{
try|try
block|{
if|if
condition|(
name|plan
operator|!=
literal|null
condition|)
block|{
name|fetchTask
operator|=
name|plan
operator|.
name|getFetchTask
argument_list|()
expr_stmt|;
if|if
condition|(
name|fetchTask
operator|!=
literal|null
condition|)
block|{
name|fetchTask
operator|.
name|setDriverContext
argument_list|(
literal|null
argument_list|)
expr_stmt|;
name|fetchTask
operator|.
name|setQueryPlan
argument_list|(
literal|null
argument_list|)
expr_stmt|;
block|}
block|}
name|plan
operator|=
literal|null
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Exception while clearing the Fetch task"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|releaseContext
parameter_list|()
block|{
try|try
block|{
if|if
condition|(
name|ctx
operator|!=
literal|null
condition|)
block|{
name|ctx
operator|.
name|clear
argument_list|()
expr_stmt|;
if|if
condition|(
name|ctx
operator|.
name|getHiveLocks
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|hiveLocks
operator|.
name|addAll
argument_list|(
name|ctx
operator|.
name|getHiveLocks
argument_list|()
argument_list|)
expr_stmt|;
name|ctx
operator|.
name|setHiveLocks
argument_list|(
literal|null
argument_list|)
expr_stmt|;
block|}
name|ctx
operator|=
literal|null
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Exception while clearing the context "
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|releaseResStream
parameter_list|()
block|{
try|try
block|{
if|if
condition|(
name|resStream
operator|!=
literal|null
condition|)
block|{
operator|(
operator|(
name|FSDataInputStream
operator|)
name|resStream
operator|)
operator|.
name|close
argument_list|()
expr_stmt|;
name|resStream
operator|=
literal|null
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|" Exception while closing the resStream "
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|releaseFetchTask
parameter_list|()
block|{
try|try
block|{
if|if
condition|(
name|fetchTask
operator|!=
literal|null
condition|)
block|{
name|fetchTask
operator|.
name|clearFetch
argument_list|()
expr_stmt|;
name|fetchTask
operator|=
literal|null
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|" Exception while clearing the FetchTask "
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Close and release resources within a running query process. Since it runs under
comment|// driver state COMPILING, EXECUTING or INTERRUPT, it would not have race condition
comment|// with the releases probably running in the other closing thread.
specifier|private
name|int
name|closeInProcess
parameter_list|(
name|boolean
name|destroyed
parameter_list|)
block|{
name|releaseDriverContext
argument_list|()
expr_stmt|;
name|releasePlan
argument_list|()
expr_stmt|;
name|releaseFetchTask
argument_list|()
expr_stmt|;
name|releaseResStream
argument_list|()
expr_stmt|;
name|releaseContext
argument_list|()
expr_stmt|;
if|if
condition|(
name|SessionState
operator|.
name|get
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|SessionState
operator|.
name|get
argument_list|()
operator|.
name|getLineageState
argument_list|()
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|destroyed
condition|)
block|{
if|if
condition|(
operator|!
name|hiveLocks
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
try|try
block|{
name|releaseLocksAndCommitOrRollback
argument_list|(
literal|false
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|LockException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Exception when releasing locking in destroy: "
operator|+
name|e
operator|.
name|getMessage
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
name|ShutdownHookManager
operator|.
name|removeShutdownHook
argument_list|(
name|shutdownRunner
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
comment|// is called to stop the query if it is running, clean query results, and release resources.
specifier|public
name|int
name|close
parameter_list|()
block|{
name|lDrvState
operator|.
name|stateLock
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
name|releaseDriverContext
argument_list|()
expr_stmt|;
if|if
condition|(
name|lDrvState
operator|.
name|driverState
operator|==
name|DriverState
operator|.
name|COMPILING
operator|||
name|lDrvState
operator|.
name|driverState
operator|==
name|DriverState
operator|.
name|EXECUTING
operator|||
name|lDrvState
operator|.
name|driverState
operator|==
name|DriverState
operator|.
name|INTERRUPT
condition|)
block|{
name|lDrvState
operator|.
name|driverState
operator|=
name|DriverState
operator|.
name|INTERRUPT
expr_stmt|;
return|return
literal|0
return|;
block|}
name|releasePlan
argument_list|()
expr_stmt|;
name|releaseFetchTask
argument_list|()
expr_stmt|;
name|releaseResStream
argument_list|()
expr_stmt|;
name|releaseContext
argument_list|()
expr_stmt|;
name|lDrvState
operator|.
name|driverState
operator|=
name|DriverState
operator|.
name|CLOSED
expr_stmt|;
block|}
finally|finally
block|{
name|lDrvState
operator|.
name|stateLock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|SessionState
operator|.
name|get
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|SessionState
operator|.
name|get
argument_list|()
operator|.
name|getLineageState
argument_list|()
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
comment|// is usually called after close() to commit or rollback a query and end the driver life cycle.
comment|// do not understand why it is needed and wonder if it could be combined with close.
specifier|public
name|void
name|destroy
parameter_list|()
block|{
name|lDrvState
operator|.
name|stateLock
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
comment|// in the cancel case where the driver state is INTERRUPTED, destroy will be deferred to
comment|// the query process
if|if
condition|(
name|lDrvState
operator|.
name|driverState
operator|==
name|DriverState
operator|.
name|DESTROYED
operator|||
name|lDrvState
operator|.
name|driverState
operator|==
name|DriverState
operator|.
name|INTERRUPT
condition|)
block|{
return|return;
block|}
else|else
block|{
name|lDrvState
operator|.
name|driverState
operator|=
name|DriverState
operator|.
name|DESTROYED
expr_stmt|;
block|}
block|}
finally|finally
block|{
name|lDrvState
operator|.
name|stateLock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|hiveLocks
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
try|try
block|{
name|releaseLocksAndCommitOrRollback
argument_list|(
literal|false
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|LockException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Exception when releasing locking in destroy: "
operator|+
name|e
operator|.
name|getMessage
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
name|ShutdownHookManager
operator|.
name|removeShutdownHook
argument_list|(
name|shutdownRunner
argument_list|)
expr_stmt|;
block|}
specifier|public
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|api
operator|.
name|Query
name|getQueryPlan
parameter_list|()
throws|throws
name|IOException
block|{
return|return
name|plan
operator|.
name|getQueryPlan
argument_list|()
return|;
block|}
specifier|public
name|String
name|getErrorMsg
parameter_list|()
block|{
return|return
name|errorMessage
return|;
block|}
specifier|public
name|QueryDisplay
name|getQueryDisplay
parameter_list|()
block|{
return|return
name|queryDisplay
return|;
block|}
comment|/**    * Set the HS2 operation handle's guid string    * @param opId base64 encoded guid string    */
specifier|public
name|void
name|setOperationId
parameter_list|(
name|String
name|opId
parameter_list|)
block|{
name|this
operator|.
name|operationId
operator|=
name|opId
expr_stmt|;
block|}
comment|/**    * Resets QueryState to get new queryId on Driver reuse.    */
specifier|public
name|void
name|resetQueryState
parameter_list|()
block|{
comment|// Note: Driver cleanup for reuse at this point is not very clear. The assumption here is that
comment|// repeated compile/execute calls create new contexts, plan, etc., so we don't need to worry
comment|// propagating queryState into those existing fields, or resetting them.
name|releaseResources
argument_list|()
expr_stmt|;
name|this
operator|.
name|queryState
operator|=
operator|new
name|QueryState
argument_list|(
name|queryState
operator|.
name|getConf
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
end_class

end_unit

