begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|optimizer
operator|.
name|optiq
operator|.
name|stats
package|;
end_package

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|BitSet
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|optimizer
operator|.
name|optiq
operator|.
name|RelOptHiveTable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|optimizer
operator|.
name|optiq
operator|.
name|reloperators
operator|.
name|HiveTableScanRel
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|rel
operator|.
name|FilterRelBase
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|rel
operator|.
name|ProjectRel
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|rel
operator|.
name|ProjectRelBase
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|rel
operator|.
name|RelNode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|rel
operator|.
name|metadata
operator|.
name|RelMetadataQuery
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|relopt
operator|.
name|RelOptUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|relopt
operator|.
name|RelOptUtil
operator|.
name|InputReferencedVisitor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|rex
operator|.
name|RexCall
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|rex
operator|.
name|RexInputRef
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|rex
operator|.
name|RexNode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|rex
operator|.
name|RexUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|rex
operator|.
name|RexVisitorImpl
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|sql
operator|.
name|SqlKind
import|;
end_import

begin_class
specifier|public
class|class
name|FilterSelectivityEstimator
extends|extends
name|RexVisitorImpl
argument_list|<
name|Double
argument_list|>
block|{
specifier|private
specifier|final
name|RelNode
name|m_childRel
decl_stmt|;
specifier|private
specifier|final
name|double
name|m_childCardinality
decl_stmt|;
specifier|protected
name|FilterSelectivityEstimator
parameter_list|(
name|RelNode
name|childRel
parameter_list|)
block|{
name|super
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|m_childRel
operator|=
name|childRel
expr_stmt|;
name|m_childCardinality
operator|=
name|RelMetadataQuery
operator|.
name|getRowCount
argument_list|(
name|m_childRel
argument_list|)
expr_stmt|;
block|}
specifier|public
name|Double
name|estimateSelectivity
parameter_list|(
name|RexNode
name|predicate
parameter_list|)
block|{
return|return
name|predicate
operator|.
name|accept
argument_list|(
name|this
argument_list|)
return|;
block|}
specifier|public
name|Double
name|visitCall
parameter_list|(
name|RexCall
name|call
parameter_list|)
block|{
if|if
condition|(
operator|!
name|deep
condition|)
block|{
return|return
literal|1.0
return|;
block|}
comment|/*      * Ignore any predicates on partition columns      * because we have already accounted for these in      * the Table row count.      */
if|if
condition|(
name|isPartitionPredicate
argument_list|(
name|call
argument_list|,
name|m_childRel
argument_list|)
condition|)
block|{
return|return
literal|1.0
return|;
block|}
name|Double
name|selectivity
init|=
literal|null
decl_stmt|;
name|SqlKind
name|op
init|=
name|call
operator|.
name|getKind
argument_list|()
decl_stmt|;
switch|switch
condition|(
name|op
condition|)
block|{
case|case
name|AND
case|:
block|{
name|selectivity
operator|=
name|computeConjunctionSelectivity
argument_list|(
name|call
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|OR
case|:
block|{
name|selectivity
operator|=
name|computeDisjunctionSelectivity
argument_list|(
name|call
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|NOT_EQUALS
case|:
block|{
name|selectivity
operator|=
name|computeNotEqualitySelectivity
argument_list|(
name|call
argument_list|)
expr_stmt|;
block|}
case|case
name|LESS_THAN_OR_EQUAL
case|:
case|case
name|GREATER_THAN_OR_EQUAL
case|:
case|case
name|LESS_THAN
case|:
case|case
name|GREATER_THAN
case|:
block|{
name|selectivity
operator|=
operator|(
operator|(
name|double
operator|)
literal|1
operator|/
operator|(
name|double
operator|)
literal|3
operator|)
expr_stmt|;
break|break;
block|}
case|case
name|IN
case|:
block|{
name|selectivity
operator|=
operator|(
operator|(
name|double
operator|)
literal|1
operator|/
operator|(
operator|(
name|double
operator|)
name|call
operator|.
name|operands
operator|.
name|size
argument_list|()
operator|)
operator|)
expr_stmt|;
break|break;
block|}
default|default:
name|selectivity
operator|=
name|computeFunctionSelectivity
argument_list|(
name|call
argument_list|)
expr_stmt|;
block|}
return|return
name|selectivity
return|;
block|}
comment|/**    * NDV of "f1(x, y, z) != f2(p, q, r)" ->    * "(maxNDV(x,y,z,p,q,r) - 1)/maxNDV(x,y,z,p,q,r)".    *<p>    *     * @param call    * @return    */
specifier|private
name|Double
name|computeNotEqualitySelectivity
parameter_list|(
name|RexCall
name|call
parameter_list|)
block|{
name|double
name|tmpNDV
init|=
name|getMaxNDV
argument_list|(
name|call
argument_list|)
decl_stmt|;
if|if
condition|(
name|tmpNDV
operator|>
literal|1
condition|)
return|return
operator|(
name|tmpNDV
operator|-
operator|(
name|double
operator|)
literal|1
operator|)
operator|/
name|tmpNDV
return|;
else|else
return|return
literal|1.0
return|;
block|}
comment|/**    * Selectivity of f(X,y,z) -> 1/maxNDV(x,y,z).    *<p>    * Note that>,>=,<,<=, = ... are considered generic functions and uses    * this method to find their selectivity.    *     * @param call    * @return    */
specifier|private
name|Double
name|computeFunctionSelectivity
parameter_list|(
name|RexCall
name|call
parameter_list|)
block|{
return|return
literal|1
operator|/
name|getMaxNDV
argument_list|(
name|call
argument_list|)
return|;
block|}
comment|/**    * Disjunction Selectivity -> (1 D(1-m1/n)(1-m2/n)) where n is the total    * number of tuples from child and m1 and m2 is the expected number of tuples    * from each part of the disjunction predicate.    *<p>    * Note we compute m1. m2.. by applying selectivity of the disjunctive element    * on the cardinality from child.    *     * @param call    * @return    */
specifier|private
name|Double
name|computeDisjunctionSelectivity
parameter_list|(
name|RexCall
name|call
parameter_list|)
block|{
name|Double
name|tmpCardinality
decl_stmt|;
name|Double
name|tmpSelectivity
decl_stmt|;
name|double
name|selectivity
init|=
literal|1
decl_stmt|;
for|for
control|(
name|RexNode
name|dje
range|:
name|call
operator|.
name|getOperands
argument_list|()
control|)
block|{
name|tmpSelectivity
operator|=
name|dje
operator|.
name|accept
argument_list|(
name|this
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmpSelectivity
operator|==
literal|null
condition|)
block|{
name|tmpSelectivity
operator|=
literal|0.99
expr_stmt|;
block|}
name|tmpCardinality
operator|=
name|m_childCardinality
operator|*
name|tmpSelectivity
expr_stmt|;
if|if
condition|(
name|tmpCardinality
operator|>
literal|1
condition|)
name|tmpSelectivity
operator|=
operator|(
literal|1
operator|-
name|tmpCardinality
operator|/
name|m_childCardinality
operator|)
expr_stmt|;
else|else
name|tmpSelectivity
operator|=
literal|1.0
expr_stmt|;
name|selectivity
operator|*=
name|tmpSelectivity
expr_stmt|;
block|}
if|if
condition|(
name|selectivity
operator|>
literal|1
condition|)
return|return
operator|(
literal|1
operator|-
name|selectivity
operator|)
return|;
else|else
return|return
literal|1.0
return|;
block|}
comment|/**    * Selectivity of conjunctive predicate -> (selectivity of conjunctive    * element1) * (selectivity of conjunctive element2)...    *     * @param call    * @return    */
specifier|private
name|Double
name|computeConjunctionSelectivity
parameter_list|(
name|RexCall
name|call
parameter_list|)
block|{
name|Double
name|tmpSelectivity
decl_stmt|;
name|double
name|selectivity
init|=
literal|1
decl_stmt|;
for|for
control|(
name|RexNode
name|cje
range|:
name|call
operator|.
name|getOperands
argument_list|()
control|)
block|{
name|tmpSelectivity
operator|=
name|cje
operator|.
name|accept
argument_list|(
name|this
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmpSelectivity
operator|!=
literal|null
condition|)
block|{
name|selectivity
operator|*=
name|tmpSelectivity
expr_stmt|;
block|}
block|}
return|return
name|selectivity
return|;
block|}
specifier|private
name|Double
name|getMaxNDV
parameter_list|(
name|RexCall
name|call
parameter_list|)
block|{
name|double
name|tmpNDV
decl_stmt|;
name|double
name|maxNDV
init|=
literal|1.0
decl_stmt|;
name|InputReferencedVisitor
name|irv
decl_stmt|;
for|for
control|(
name|RexNode
name|op
range|:
name|call
operator|.
name|getOperands
argument_list|()
control|)
block|{
if|if
condition|(
name|op
operator|instanceof
name|RexInputRef
condition|)
block|{
name|tmpNDV
operator|=
name|HiveRelMdDistinctRowCount
operator|.
name|getDistinctRowCount
argument_list|(
name|m_childRel
argument_list|,
operator|(
operator|(
name|RexInputRef
operator|)
name|op
operator|)
operator|.
name|getIndex
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmpNDV
operator|>
name|maxNDV
condition|)
name|maxNDV
operator|=
name|tmpNDV
expr_stmt|;
block|}
else|else
block|{
name|irv
operator|=
operator|new
name|InputReferencedVisitor
argument_list|()
expr_stmt|;
name|irv
operator|.
name|apply
argument_list|(
name|op
argument_list|)
expr_stmt|;
for|for
control|(
name|Integer
name|childProjIndx
range|:
name|irv
operator|.
name|inputPosReferenced
control|)
block|{
name|tmpNDV
operator|=
name|HiveRelMdDistinctRowCount
operator|.
name|getDistinctRowCount
argument_list|(
name|m_childRel
argument_list|,
name|childProjIndx
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmpNDV
operator|>
name|maxNDV
condition|)
name|maxNDV
operator|=
name|tmpNDV
expr_stmt|;
block|}
block|}
block|}
return|return
name|maxNDV
return|;
block|}
specifier|private
name|boolean
name|isPartitionPredicate
parameter_list|(
name|RexNode
name|expr
parameter_list|,
name|RelNode
name|r
parameter_list|)
block|{
if|if
condition|(
name|r
operator|instanceof
name|ProjectRelBase
condition|)
block|{
name|expr
operator|=
name|RelOptUtil
operator|.
name|pushFilterPastProject
argument_list|(
name|expr
argument_list|,
operator|(
name|ProjectRelBase
operator|)
name|r
argument_list|)
expr_stmt|;
return|return
name|isPartitionPredicate
argument_list|(
name|expr
argument_list|,
operator|(
operator|(
name|ProjectRelBase
operator|)
name|r
operator|)
operator|.
name|getChild
argument_list|()
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|r
operator|instanceof
name|FilterRelBase
condition|)
block|{
name|isPartitionPredicate
argument_list|(
name|expr
argument_list|,
operator|(
operator|(
name|ProjectRelBase
operator|)
name|r
operator|)
operator|.
name|getChild
argument_list|()
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|r
operator|instanceof
name|HiveTableScanRel
condition|)
block|{
name|RelOptHiveTable
name|table
init|=
call|(
name|RelOptHiveTable
call|)
argument_list|(
operator|(
name|HiveTableScanRel
operator|)
name|r
argument_list|)
operator|.
name|getTable
argument_list|()
decl_stmt|;
name|BitSet
name|cols
init|=
name|RelOptUtil
operator|.
name|InputFinder
operator|.
name|bits
argument_list|(
name|expr
argument_list|)
decl_stmt|;
return|return
name|table
operator|.
name|containsPartitionColumnsOnly
argument_list|(
name|cols
argument_list|)
return|;
block|}
return|return
literal|false
return|;
block|}
block|}
end_class

end_unit

