begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|udf
operator|.
name|ptf
package|;
end_package

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|ColumnInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|ExprNodeEvaluator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|ExprNodeEvaluatorFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|PTFPartition
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|PTFPartition
operator|.
name|PTFPartitionIterator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|PTFUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|lib
operator|.
name|Node
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|metadata
operator|.
name|HiveException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|parse
operator|.
name|ASTNode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|parse
operator|.
name|PTFTranslator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|parse
operator|.
name|RowResolver
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|parse
operator|.
name|SemanticAnalyzer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|parse
operator|.
name|SemanticException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|parse
operator|.
name|TypeCheckCtx
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|parse
operator|.
name|TypeCheckProcFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|parse
operator|.
name|WindowingSpec
operator|.
name|WindowExpressionSpec
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|ExprNodeColumnDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|ExprNodeDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|PTFDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|PTFDesc
operator|.
name|PTFExpressionDef
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|PTFDesc
operator|.
name|PTFInputDef
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|PTFDesc
operator|.
name|PartitionedTableFunctionDef
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|objectinspector
operator|.
name|ConstantObjectInspector
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|objectinspector
operator|.
name|ObjectInspector
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|objectinspector
operator|.
name|ObjectInspectorConverters
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|objectinspector
operator|.
name|ObjectInspectorConverters
operator|.
name|Converter
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|objectinspector
operator|.
name|ObjectInspectorFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|objectinspector
operator|.
name|ObjectInspectorUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|objectinspector
operator|.
name|PrimitiveObjectInspector
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|objectinspector
operator|.
name|StandardListObjectInspector
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|objectinspector
operator|.
name|StructField
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|objectinspector
operator|.
name|StructObjectInspector
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|objectinspector
operator|.
name|primitive
operator|.
name|PrimitiveObjectInspectorFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|typeinfo
operator|.
name|StructTypeInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|typeinfo
operator|.
name|TypeInfoUtils
import|;
end_import

begin_comment
comment|/**  * return rows that meet a specified pattern. Use symbols to specify a list of expressions  * to match.  * Pattern is used to specify a Path. The results list can contain expressions based on  * the input columns and also the matched Path.  *<ol>  *<li><b>pattern:</b> pattern for the Path. Path is 'dot' separated list of symbols.  * Each element is treated as a symbol. Elements that end in '*' or '+' are interpreted with  * the usual meaning of zero or more, one or more respectively. For e.g.  * "LATE.EARLY*.ONTIMEOREARLY" implies a sequence of flights  * where the first occurrence was LATE, followed by zero or more EARLY flights,  * followed by a ONTIME or EARLY flight.  *<li><b>symbols</b> specify a list of name, expression pairs. For e.g.  * 'LATE', arrival_delay> 0, 'EARLY', arrival_delay< 0 , 'ONTIME', arrival_delay == 0.  * These symbols can be used in the Pattern defined above.  *<li><b>resultSelectList</b> specified as a select list.  * The expressions in the selectList are evaluated in the context where all the  * input columns are available, plus the attribute  * "tpath" is available. Path is a collection of rows that represents the matching Path.  *</ol>  */
end_comment

begin_class
specifier|public
class|class
name|NPath
extends|extends
name|TableFunctionEvaluator
block|{
specifier|private
specifier|transient
name|String
name|patternStr
decl_stmt|;
specifier|private
specifier|transient
name|SymbolsInfo
name|symInfo
decl_stmt|;
specifier|private
specifier|transient
name|String
name|resultExprStr
decl_stmt|;
specifier|private
specifier|transient
name|SymbolFunction
name|syFn
decl_stmt|;
specifier|private
name|ResultExprInfo
name|resultExprInfo
decl_stmt|;
comment|/*    * the names of the Columns of the input to NPath. Used to setup the tpath Struct column.    */
specifier|private
name|ArrayList
argument_list|<
name|String
argument_list|>
name|inputColumnNames
decl_stmt|;
specifier|private
name|ArrayList
argument_list|<
name|String
argument_list|>
name|selectListNames
decl_stmt|;
annotation|@
name|Override
specifier|public
name|void
name|execute
parameter_list|(
name|PTFPartitionIterator
argument_list|<
name|Object
argument_list|>
name|pItr
parameter_list|,
name|PTFPartition
name|outP
parameter_list|)
throws|throws
name|HiveException
block|{
while|while
condition|(
name|pItr
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|Object
name|iRow
init|=
name|pItr
operator|.
name|next
argument_list|()
decl_stmt|;
name|SymbolFunctionResult
name|syFnRes
init|=
name|SymbolFunction
operator|.
name|match
argument_list|(
name|syFn
argument_list|,
name|iRow
argument_list|,
name|pItr
argument_list|)
decl_stmt|;
if|if
condition|(
name|syFnRes
operator|.
name|matches
condition|)
block|{
name|int
name|sz
init|=
name|syFnRes
operator|.
name|nextRow
operator|-
operator|(
name|pItr
operator|.
name|getIndex
argument_list|()
operator|-
literal|1
operator|)
decl_stmt|;
name|Object
name|selectListInput
init|=
name|NPath
operator|.
name|getSelectListInput
argument_list|(
name|iRow
argument_list|,
name|tDef
operator|.
name|getInput
argument_list|()
operator|.
name|getOutputShape
argument_list|()
operator|.
name|getOI
argument_list|()
argument_list|,
name|pItr
argument_list|,
name|sz
argument_list|)
decl_stmt|;
name|ArrayList
argument_list|<
name|Object
argument_list|>
name|oRow
init|=
operator|new
name|ArrayList
argument_list|<
name|Object
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|ExprNodeEvaluator
name|resExprEval
range|:
name|resultExprInfo
operator|.
name|resultExprEvals
control|)
block|{
name|oRow
operator|.
name|add
argument_list|(
name|resExprEval
operator|.
name|evaluate
argument_list|(
name|selectListInput
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|outP
operator|.
name|append
argument_list|(
name|oRow
argument_list|)
expr_stmt|;
block|}
block|}
block|}
specifier|static
name|void
name|throwErrorWithSignature
parameter_list|(
name|String
name|message
parameter_list|)
throws|throws
name|SemanticException
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"NPath signature is: SymbolPattern, one or more SymbolName, "
operator|+
literal|"expression pairs, the result expression as a select list. Error %s"
argument_list|,
name|message
argument_list|)
argument_list|)
throw|;
block|}
specifier|public
name|ArrayList
argument_list|<
name|String
argument_list|>
name|getInputColumnNames
parameter_list|()
block|{
return|return
name|inputColumnNames
return|;
block|}
specifier|public
name|void
name|setInputColumnNames
parameter_list|(
name|ArrayList
argument_list|<
name|String
argument_list|>
name|inputColumnNames
parameter_list|)
block|{
name|this
operator|.
name|inputColumnNames
operator|=
name|inputColumnNames
expr_stmt|;
block|}
specifier|public
name|ArrayList
argument_list|<
name|String
argument_list|>
name|getSelectListNames
parameter_list|()
block|{
return|return
name|selectListNames
return|;
block|}
specifier|public
name|void
name|setSelectListNames
parameter_list|(
name|ArrayList
argument_list|<
name|String
argument_list|>
name|selectListNames
parameter_list|)
block|{
name|this
operator|.
name|selectListNames
operator|=
name|selectListNames
expr_stmt|;
block|}
specifier|public
specifier|static
class|class
name|NPathResolver
extends|extends
name|TableFunctionResolver
block|{
annotation|@
name|Override
specifier|protected
name|TableFunctionEvaluator
name|createEvaluator
parameter_list|(
name|PTFDesc
name|ptfDesc
parameter_list|,
name|PartitionedTableFunctionDef
name|tDef
parameter_list|)
block|{
return|return
operator|new
name|NPath
argument_list|()
return|;
block|}
comment|/**      *<ul>      *<li> check structure of Arguments:      *<ol>      *<li> First arg should be a String      *<li> then there should be an even number of Arguments:      * String, expression; expression should be Convertible to Boolean.      *<li> finally there should be a String.      *</ol>      *<li> convert pattern into a NNode chain.      *<li> convert symbol args into a Symbol Map.      *<li> parse selectList into SelectList struct. The inputOI used to translate      * these expressions should be based on the      * columns in the Input, the 'path.attr'      *</ul>      */
annotation|@
name|Override
specifier|public
name|void
name|setupOutputOI
parameter_list|()
throws|throws
name|SemanticException
block|{
name|NPath
name|evaluator
init|=
operator|(
name|NPath
operator|)
name|getEvaluator
argument_list|()
decl_stmt|;
name|PartitionedTableFunctionDef
name|tDef
init|=
name|evaluator
operator|.
name|getTableDef
argument_list|()
decl_stmt|;
name|ArrayList
argument_list|<
name|PTFExpressionDef
argument_list|>
name|args
init|=
name|tDef
operator|.
name|getArgs
argument_list|()
decl_stmt|;
name|int
name|argsNum
init|=
name|args
operator|==
literal|null
condition|?
literal|0
else|:
name|args
operator|.
name|size
argument_list|()
decl_stmt|;
if|if
condition|(
name|argsNum
operator|<
literal|4
condition|)
block|{
name|throwErrorWithSignature
argument_list|(
literal|"at least 4 arguments required"
argument_list|)
expr_stmt|;
block|}
name|validateAndSetupPatternStr
argument_list|(
name|evaluator
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|validateAndSetupSymbolInfo
argument_list|(
name|evaluator
argument_list|,
name|args
argument_list|,
name|argsNum
argument_list|)
expr_stmt|;
name|validateAndSetupResultExprStr
argument_list|(
name|evaluator
argument_list|,
name|args
argument_list|,
name|argsNum
argument_list|)
expr_stmt|;
name|setupSymbolFunctionChain
argument_list|(
name|evaluator
argument_list|)
expr_stmt|;
comment|/*        * setup OI for input to resultExpr select list        */
name|RowResolver
name|selectListInputRR
init|=
name|NPath
operator|.
name|createSelectListRR
argument_list|(
name|evaluator
argument_list|,
name|tDef
operator|.
name|getInput
argument_list|()
argument_list|)
decl_stmt|;
comment|/*        * parse ResultExpr Str and setup OI.        */
name|ResultExpressionParser
name|resultExprParser
init|=
operator|new
name|ResultExpressionParser
argument_list|(
name|evaluator
operator|.
name|resultExprStr
argument_list|,
name|selectListInputRR
argument_list|)
decl_stmt|;
try|try
block|{
name|resultExprParser
operator|.
name|translate
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|HiveException
name|he
parameter_list|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|he
argument_list|)
throw|;
block|}
name|evaluator
operator|.
name|resultExprInfo
operator|=
name|resultExprParser
operator|.
name|getResultExprInfo
argument_list|()
expr_stmt|;
name|StructObjectInspector
name|OI
init|=
name|evaluator
operator|.
name|resultExprInfo
operator|.
name|resultOI
decl_stmt|;
name|evaluator
operator|.
name|selectListNames
operator|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
expr_stmt|;
name|extractOIColumnNames
argument_list|(
name|resultExprParser
operator|.
name|selectListInputOI
argument_list|,
name|evaluator
operator|.
name|selectListNames
argument_list|)
expr_stmt|;
name|setOutputOI
argument_list|(
name|OI
argument_list|)
expr_stmt|;
block|}
comment|/*      * validate and setup patternStr      */
specifier|private
name|void
name|validateAndSetupPatternStr
parameter_list|(
name|NPath
name|evaluator
parameter_list|,
name|ArrayList
argument_list|<
name|PTFExpressionDef
argument_list|>
name|args
parameter_list|)
throws|throws
name|SemanticException
block|{
name|PTFExpressionDef
name|symboPatternArg
init|=
name|args
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|ObjectInspector
name|symbolPatternArgOI
init|=
name|symboPatternArg
operator|.
name|getOI
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|ObjectInspectorUtils
operator|.
name|isConstantObjectInspector
argument_list|(
name|symbolPatternArgOI
argument_list|)
operator|||
operator|(
name|symbolPatternArgOI
operator|.
name|getCategory
argument_list|()
operator|!=
name|ObjectInspector
operator|.
name|Category
operator|.
name|PRIMITIVE
operator|)
operator|||
operator|(
operator|(
name|PrimitiveObjectInspector
operator|)
name|symbolPatternArgOI
operator|)
operator|.
name|getPrimitiveCategory
argument_list|()
operator|!=
name|PrimitiveObjectInspector
operator|.
name|PrimitiveCategory
operator|.
name|STRING
condition|)
block|{
name|throwErrorWithSignature
argument_list|(
literal|"Currently the symbol Pattern must be a Constant String."
argument_list|)
expr_stmt|;
block|}
name|evaluator
operator|.
name|patternStr
operator|=
operator|(
operator|(
name|ConstantObjectInspector
operator|)
name|symbolPatternArgOI
operator|)
operator|.
name|getWritableConstantValue
argument_list|()
operator|.
name|toString
argument_list|()
expr_stmt|;
block|}
comment|/*      * validate and setup SymbolInfo      */
specifier|private
name|void
name|validateAndSetupSymbolInfo
parameter_list|(
name|NPath
name|evaluator
parameter_list|,
name|ArrayList
argument_list|<
name|PTFExpressionDef
argument_list|>
name|args
parameter_list|,
name|int
name|argsNum
parameter_list|)
throws|throws
name|SemanticException
block|{
name|int
name|symbolArgsSz
init|=
name|argsNum
operator|-
literal|2
decl_stmt|;
if|if
condition|(
name|symbolArgsSz
operator|%
literal|2
operator|!=
literal|0
condition|)
block|{
name|throwErrorWithSignature
argument_list|(
literal|"Symbol Name, Expression need to be specified in pairs: "
operator|+
literal|"there are odd number of symbol args"
argument_list|)
expr_stmt|;
block|}
name|evaluator
operator|.
name|symInfo
operator|=
operator|new
name|SymbolsInfo
argument_list|(
name|symbolArgsSz
operator|/
literal|2
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<=
name|symbolArgsSz
condition|;
name|i
operator|+=
literal|2
control|)
block|{
name|PTFExpressionDef
name|symbolNameArg
init|=
name|args
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|ObjectInspector
name|symbolNameArgOI
init|=
name|symbolNameArg
operator|.
name|getOI
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|ObjectInspectorUtils
operator|.
name|isConstantObjectInspector
argument_list|(
name|symbolNameArgOI
argument_list|)
operator|||
operator|(
name|symbolNameArgOI
operator|.
name|getCategory
argument_list|()
operator|!=
name|ObjectInspector
operator|.
name|Category
operator|.
name|PRIMITIVE
operator|)
operator|||
operator|(
operator|(
name|PrimitiveObjectInspector
operator|)
name|symbolNameArgOI
operator|)
operator|.
name|getPrimitiveCategory
argument_list|()
operator|!=
name|PrimitiveObjectInspector
operator|.
name|PrimitiveCategory
operator|.
name|STRING
condition|)
block|{
name|throwErrorWithSignature
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"Currently a Symbol Name(%s) must be a Constant String"
argument_list|,
name|symbolNameArg
operator|.
name|getExpressionTreeString
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|String
name|symbolName
init|=
operator|(
operator|(
name|ConstantObjectInspector
operator|)
name|symbolNameArgOI
operator|)
operator|.
name|getWritableConstantValue
argument_list|()
operator|.
name|toString
argument_list|()
decl_stmt|;
name|PTFExpressionDef
name|symolExprArg
init|=
name|args
operator|.
name|get
argument_list|(
name|i
operator|+
literal|1
argument_list|)
decl_stmt|;
name|ObjectInspector
name|symolExprArgOI
init|=
name|symolExprArg
operator|.
name|getOI
argument_list|()
decl_stmt|;
if|if
condition|(
operator|(
name|symolExprArgOI
operator|.
name|getCategory
argument_list|()
operator|!=
name|ObjectInspector
operator|.
name|Category
operator|.
name|PRIMITIVE
operator|)
operator|||
operator|(
operator|(
name|PrimitiveObjectInspector
operator|)
name|symolExprArgOI
operator|)
operator|.
name|getPrimitiveCategory
argument_list|()
operator|!=
name|PrimitiveObjectInspector
operator|.
name|PrimitiveCategory
operator|.
name|BOOLEAN
condition|)
block|{
name|throwErrorWithSignature
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"Currently a Symbol Expression(%s) "
operator|+
literal|"must be a boolean expression"
argument_list|,
name|symolExprArg
operator|.
name|getExpressionTreeString
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|evaluator
operator|.
name|symInfo
operator|.
name|add
argument_list|(
name|symbolName
argument_list|,
name|symolExprArg
argument_list|)
expr_stmt|;
block|}
block|}
comment|/*      * validate and setup resultExprStr      */
specifier|private
name|void
name|validateAndSetupResultExprStr
parameter_list|(
name|NPath
name|evaluator
parameter_list|,
name|ArrayList
argument_list|<
name|PTFExpressionDef
argument_list|>
name|args
parameter_list|,
name|int
name|argsNum
parameter_list|)
throws|throws
name|SemanticException
block|{
name|PTFExpressionDef
name|resultExprArg
init|=
name|args
operator|.
name|get
argument_list|(
name|argsNum
operator|-
literal|1
argument_list|)
decl_stmt|;
name|ObjectInspector
name|resultExprArgOI
init|=
name|resultExprArg
operator|.
name|getOI
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|ObjectInspectorUtils
operator|.
name|isConstantObjectInspector
argument_list|(
name|resultExprArgOI
argument_list|)
operator|||
operator|(
name|resultExprArgOI
operator|.
name|getCategory
argument_list|()
operator|!=
name|ObjectInspector
operator|.
name|Category
operator|.
name|PRIMITIVE
operator|)
operator|||
operator|(
operator|(
name|PrimitiveObjectInspector
operator|)
name|resultExprArgOI
operator|)
operator|.
name|getPrimitiveCategory
argument_list|()
operator|!=
name|PrimitiveObjectInspector
operator|.
name|PrimitiveCategory
operator|.
name|STRING
condition|)
block|{
name|throwErrorWithSignature
argument_list|(
literal|"Currently the result Expr parameter must be a Constant String."
argument_list|)
expr_stmt|;
block|}
name|evaluator
operator|.
name|resultExprStr
operator|=
operator|(
operator|(
name|ConstantObjectInspector
operator|)
name|resultExprArgOI
operator|)
operator|.
name|getWritableConstantValue
argument_list|()
operator|.
name|toString
argument_list|()
expr_stmt|;
block|}
comment|/*      * setup SymbolFunction chain.      */
specifier|private
name|void
name|setupSymbolFunctionChain
parameter_list|(
name|NPath
name|evaluator
parameter_list|)
throws|throws
name|SemanticException
block|{
name|SymbolParser
name|syP
init|=
operator|new
name|SymbolParser
argument_list|(
name|evaluator
operator|.
name|patternStr
argument_list|,
name|evaluator
operator|.
name|symInfo
operator|.
name|symbolExprsNames
argument_list|,
name|evaluator
operator|.
name|symInfo
operator|.
name|symbolExprsEvaluators
argument_list|,
name|evaluator
operator|.
name|symInfo
operator|.
name|symbolExprsOIs
argument_list|)
decl_stmt|;
name|syP
operator|.
name|parse
argument_list|()
expr_stmt|;
name|evaluator
operator|.
name|syFn
operator|=
name|syP
operator|.
name|getSymbolFunction
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|transformsRawInput
parameter_list|()
block|{
return|return
literal|false
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|initializeOutputOI
parameter_list|()
throws|throws
name|HiveException
block|{
try|try
block|{
name|NPath
name|evaluator
init|=
operator|(
name|NPath
operator|)
name|getEvaluator
argument_list|()
decl_stmt|;
name|PartitionedTableFunctionDef
name|tDef
init|=
name|evaluator
operator|.
name|getTableDef
argument_list|()
decl_stmt|;
name|ArrayList
argument_list|<
name|PTFExpressionDef
argument_list|>
name|args
init|=
name|tDef
operator|.
name|getArgs
argument_list|()
decl_stmt|;
name|int
name|argsNum
init|=
name|args
operator|.
name|size
argument_list|()
decl_stmt|;
name|validateAndSetupPatternStr
argument_list|(
name|evaluator
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|validateAndSetupSymbolInfo
argument_list|(
name|evaluator
argument_list|,
name|args
argument_list|,
name|argsNum
argument_list|)
expr_stmt|;
name|validateAndSetupResultExprStr
argument_list|(
name|evaluator
argument_list|,
name|args
argument_list|,
name|argsNum
argument_list|)
expr_stmt|;
name|setupSymbolFunctionChain
argument_list|(
name|evaluator
argument_list|)
expr_stmt|;
comment|/*          * setup OI for input to resultExpr select list          */
name|StructObjectInspector
name|selectListInputOI
init|=
name|NPath
operator|.
name|createSelectListOI
argument_list|(
name|evaluator
argument_list|,
name|tDef
operator|.
name|getInput
argument_list|()
argument_list|)
decl_stmt|;
name|ResultExprInfo
name|resultExprInfo
init|=
name|evaluator
operator|.
name|resultExprInfo
decl_stmt|;
name|ArrayList
argument_list|<
name|ObjectInspector
argument_list|>
name|selectListExprOIs
init|=
operator|new
name|ArrayList
argument_list|<
name|ObjectInspector
argument_list|>
argument_list|()
decl_stmt|;
name|resultExprInfo
operator|.
name|resultExprEvals
operator|=
operator|new
name|ArrayList
argument_list|<
name|ExprNodeEvaluator
argument_list|>
argument_list|()
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|resultExprInfo
operator|.
name|resultExprNodes
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|ExprNodeDesc
name|selectColumnExprNode
init|=
name|resultExprInfo
operator|.
name|resultExprNodes
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|ExprNodeEvaluator
name|selectColumnExprEval
init|=
name|ExprNodeEvaluatorFactory
operator|.
name|get
argument_list|(
name|selectColumnExprNode
argument_list|)
decl_stmt|;
name|ObjectInspector
name|selectColumnOI
init|=
name|selectColumnExprEval
operator|.
name|initialize
argument_list|(
name|selectListInputOI
argument_list|)
decl_stmt|;
name|resultExprInfo
operator|.
name|resultExprEvals
operator|.
name|add
argument_list|(
name|selectColumnExprEval
argument_list|)
expr_stmt|;
name|selectListExprOIs
operator|.
name|add
argument_list|(
name|selectColumnOI
argument_list|)
expr_stmt|;
block|}
name|resultExprInfo
operator|.
name|resultOI
operator|=
name|ObjectInspectorFactory
operator|.
name|getStandardStructObjectInspector
argument_list|(
name|resultExprInfo
operator|.
name|resultExprNames
argument_list|,
name|selectListExprOIs
argument_list|)
expr_stmt|;
name|setOutputOI
argument_list|(
name|resultExprInfo
operator|.
name|resultOI
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|SemanticException
name|se
parameter_list|)
block|{
throw|throw
operator|new
name|HiveException
argument_list|(
name|se
argument_list|)
throw|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|ArrayList
argument_list|<
name|String
argument_list|>
name|getOutputColumnNames
parameter_list|()
block|{
name|NPath
name|evaluator
init|=
operator|(
name|NPath
operator|)
name|getEvaluator
argument_list|()
decl_stmt|;
return|return
name|evaluator
operator|.
name|resultExprInfo
operator|.
name|getResultExprNames
argument_list|()
return|;
block|}
specifier|private
specifier|static
name|void
name|extractOIColumnNames
parameter_list|(
name|StructObjectInspector
name|OI
parameter_list|,
name|ArrayList
argument_list|<
name|String
argument_list|>
name|oiColumnNames
parameter_list|)
block|{
name|StructTypeInfo
name|t
init|=
operator|(
name|StructTypeInfo
operator|)
name|TypeInfoUtils
operator|.
name|getTypeInfoFromObjectInspector
argument_list|(
name|OI
argument_list|)
decl_stmt|;
name|ArrayList
argument_list|<
name|String
argument_list|>
name|fnames
init|=
name|t
operator|.
name|getAllStructFieldNames
argument_list|()
decl_stmt|;
name|oiColumnNames
operator|.
name|addAll
argument_list|(
name|fnames
argument_list|)
expr_stmt|;
block|}
block|}
specifier|public
name|ResultExprInfo
name|getResultExprInfo
parameter_list|()
block|{
return|return
name|resultExprInfo
return|;
block|}
specifier|public
name|void
name|setResultExprInfo
parameter_list|(
name|ResultExprInfo
name|resultExprInfo
parameter_list|)
block|{
name|this
operator|.
name|resultExprInfo
operator|=
name|resultExprInfo
expr_stmt|;
block|}
specifier|static
class|class
name|SymbolsInfo
block|{
name|int
name|sz
decl_stmt|;
name|ArrayList
argument_list|<
name|ExprNodeEvaluator
argument_list|>
name|symbolExprsEvaluators
decl_stmt|;
name|ArrayList
argument_list|<
name|ObjectInspector
argument_list|>
name|symbolExprsOIs
decl_stmt|;
name|ArrayList
argument_list|<
name|String
argument_list|>
name|symbolExprsNames
decl_stmt|;
name|SymbolsInfo
parameter_list|(
name|int
name|sz
parameter_list|)
block|{
name|this
operator|.
name|sz
operator|=
name|sz
expr_stmt|;
name|symbolExprsEvaluators
operator|=
operator|new
name|ArrayList
argument_list|<
name|ExprNodeEvaluator
argument_list|>
argument_list|(
name|sz
argument_list|)
expr_stmt|;
name|symbolExprsOIs
operator|=
operator|new
name|ArrayList
argument_list|<
name|ObjectInspector
argument_list|>
argument_list|(
name|sz
argument_list|)
expr_stmt|;
name|symbolExprsNames
operator|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|(
name|sz
argument_list|)
expr_stmt|;
block|}
name|void
name|add
parameter_list|(
name|String
name|name
parameter_list|,
name|PTFExpressionDef
name|arg
parameter_list|)
block|{
name|symbolExprsNames
operator|.
name|add
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|symbolExprsEvaluators
operator|.
name|add
argument_list|(
name|arg
operator|.
name|getExprEvaluator
argument_list|()
argument_list|)
expr_stmt|;
name|symbolExprsOIs
operator|.
name|add
argument_list|(
name|arg
operator|.
name|getOI
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
specifier|public
specifier|static
class|class
name|ResultExprInfo
block|{
name|ArrayList
argument_list|<
name|String
argument_list|>
name|resultExprNames
decl_stmt|;
name|ArrayList
argument_list|<
name|ExprNodeDesc
argument_list|>
name|resultExprNodes
decl_stmt|;
specifier|private
specifier|transient
name|ArrayList
argument_list|<
name|ExprNodeEvaluator
argument_list|>
name|resultExprEvals
decl_stmt|;
specifier|private
specifier|transient
name|StructObjectInspector
name|resultOI
decl_stmt|;
specifier|public
name|ArrayList
argument_list|<
name|String
argument_list|>
name|getResultExprNames
parameter_list|()
block|{
return|return
name|resultExprNames
return|;
block|}
specifier|public
name|void
name|setResultExprNames
parameter_list|(
name|ArrayList
argument_list|<
name|String
argument_list|>
name|resultExprNames
parameter_list|)
block|{
name|this
operator|.
name|resultExprNames
operator|=
name|resultExprNames
expr_stmt|;
block|}
specifier|public
name|ArrayList
argument_list|<
name|ExprNodeDesc
argument_list|>
name|getResultExprNodes
parameter_list|()
block|{
return|return
name|resultExprNodes
return|;
block|}
specifier|public
name|void
name|setResultExprNodes
parameter_list|(
name|ArrayList
argument_list|<
name|ExprNodeDesc
argument_list|>
name|resultExprNodes
parameter_list|)
block|{
name|this
operator|.
name|resultExprNodes
operator|=
name|resultExprNodes
expr_stmt|;
block|}
block|}
specifier|public
specifier|static
specifier|abstract
class|class
name|SymbolFunction
block|{
name|SymbolFunctionResult
name|result
decl_stmt|;
specifier|public
name|SymbolFunction
parameter_list|()
block|{
name|result
operator|=
operator|new
name|SymbolFunctionResult
argument_list|()
expr_stmt|;
block|}
specifier|public
specifier|static
name|SymbolFunctionResult
name|match
parameter_list|(
name|SymbolFunction
name|syFn
parameter_list|,
name|Object
name|row
parameter_list|,
name|PTFPartitionIterator
argument_list|<
name|Object
argument_list|>
name|pItr
parameter_list|)
throws|throws
name|HiveException
block|{
name|int
name|resetToIdx
init|=
name|pItr
operator|.
name|getIndex
argument_list|()
operator|-
literal|1
decl_stmt|;
try|try
block|{
return|return
name|syFn
operator|.
name|match
argument_list|(
name|row
argument_list|,
name|pItr
argument_list|)
return|;
block|}
finally|finally
block|{
name|pItr
operator|.
name|resetToIndex
argument_list|(
name|resetToIdx
argument_list|)
expr_stmt|;
block|}
block|}
specifier|protected
specifier|abstract
name|SymbolFunctionResult
name|match
parameter_list|(
name|Object
name|row
parameter_list|,
name|PTFPartitionIterator
argument_list|<
name|Object
argument_list|>
name|pItr
parameter_list|)
throws|throws
name|HiveException
function_decl|;
specifier|protected
specifier|abstract
name|boolean
name|isOptional
parameter_list|()
function_decl|;
block|}
specifier|public
specifier|static
class|class
name|Symbol
extends|extends
name|SymbolFunction
block|{
name|ExprNodeEvaluator
name|symbolExprEval
decl_stmt|;
name|Converter
name|converter
decl_stmt|;
specifier|public
name|Symbol
parameter_list|(
name|ExprNodeEvaluator
name|symbolExprEval
parameter_list|,
name|ObjectInspector
name|symbolOI
parameter_list|)
block|{
name|this
operator|.
name|symbolExprEval
operator|=
name|symbolExprEval
expr_stmt|;
name|converter
operator|=
name|ObjectInspectorConverters
operator|.
name|getConverter
argument_list|(
name|symbolOI
argument_list|,
name|PrimitiveObjectInspectorFactory
operator|.
name|javaBooleanObjectInspector
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|protected
name|SymbolFunctionResult
name|match
parameter_list|(
name|Object
name|row
parameter_list|,
name|PTFPartitionIterator
argument_list|<
name|Object
argument_list|>
name|pItr
parameter_list|)
throws|throws
name|HiveException
block|{
name|Object
name|val
init|=
literal|null
decl_stmt|;
name|val
operator|=
name|symbolExprEval
operator|.
name|evaluate
argument_list|(
name|row
argument_list|)
expr_stmt|;
name|val
operator|=
name|converter
operator|.
name|convert
argument_list|(
name|val
argument_list|)
expr_stmt|;
name|result
operator|.
name|matches
operator|=
operator|(
operator|(
name|Boolean
operator|)
name|val
operator|)
operator|.
name|booleanValue
argument_list|()
expr_stmt|;
name|result
operator|.
name|nextRow
operator|=
name|pItr
operator|.
name|getIndex
argument_list|()
expr_stmt|;
return|return
name|result
return|;
block|}
annotation|@
name|Override
specifier|protected
name|boolean
name|isOptional
parameter_list|()
block|{
return|return
literal|false
return|;
block|}
block|}
specifier|public
specifier|static
class|class
name|Star
extends|extends
name|SymbolFunction
block|{
name|SymbolFunction
name|symbolFn
decl_stmt|;
specifier|public
name|Star
parameter_list|(
name|SymbolFunction
name|symbolFn
parameter_list|)
block|{
name|this
operator|.
name|symbolFn
operator|=
name|symbolFn
expr_stmt|;
block|}
annotation|@
name|Override
specifier|protected
name|SymbolFunctionResult
name|match
parameter_list|(
name|Object
name|row
parameter_list|,
name|PTFPartitionIterator
argument_list|<
name|Object
argument_list|>
name|pItr
parameter_list|)
throws|throws
name|HiveException
block|{
name|result
operator|.
name|matches
operator|=
literal|true
expr_stmt|;
name|SymbolFunctionResult
name|rowResult
init|=
name|symbolFn
operator|.
name|match
argument_list|(
name|row
argument_list|,
name|pItr
argument_list|)
decl_stmt|;
while|while
condition|(
name|rowResult
operator|.
name|matches
operator|&&
name|pItr
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|row
operator|=
name|pItr
operator|.
name|next
argument_list|()
expr_stmt|;
name|rowResult
operator|=
name|symbolFn
operator|.
name|match
argument_list|(
name|row
argument_list|,
name|pItr
argument_list|)
expr_stmt|;
block|}
name|result
operator|.
name|nextRow
operator|=
name|pItr
operator|.
name|getIndex
argument_list|()
operator|-
literal|1
expr_stmt|;
return|return
name|result
return|;
block|}
annotation|@
name|Override
specifier|protected
name|boolean
name|isOptional
parameter_list|()
block|{
return|return
literal|true
return|;
block|}
block|}
specifier|public
specifier|static
class|class
name|Plus
extends|extends
name|SymbolFunction
block|{
name|SymbolFunction
name|symbolFn
decl_stmt|;
specifier|public
name|Plus
parameter_list|(
name|SymbolFunction
name|symbolFn
parameter_list|)
block|{
name|this
operator|.
name|symbolFn
operator|=
name|symbolFn
expr_stmt|;
block|}
annotation|@
name|Override
specifier|protected
name|SymbolFunctionResult
name|match
parameter_list|(
name|Object
name|row
parameter_list|,
name|PTFPartitionIterator
argument_list|<
name|Object
argument_list|>
name|pItr
parameter_list|)
throws|throws
name|HiveException
block|{
name|SymbolFunctionResult
name|rowResult
init|=
name|symbolFn
operator|.
name|match
argument_list|(
name|row
argument_list|,
name|pItr
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|rowResult
operator|.
name|matches
condition|)
block|{
name|result
operator|.
name|matches
operator|=
literal|false
expr_stmt|;
name|result
operator|.
name|nextRow
operator|=
name|pItr
operator|.
name|getIndex
argument_list|()
operator|-
literal|1
expr_stmt|;
return|return
name|result
return|;
block|}
name|result
operator|.
name|matches
operator|=
literal|true
expr_stmt|;
while|while
condition|(
name|rowResult
operator|.
name|matches
operator|&&
name|pItr
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|row
operator|=
name|pItr
operator|.
name|next
argument_list|()
expr_stmt|;
name|rowResult
operator|=
name|symbolFn
operator|.
name|match
argument_list|(
name|row
argument_list|,
name|pItr
argument_list|)
expr_stmt|;
block|}
name|result
operator|.
name|nextRow
operator|=
name|pItr
operator|.
name|getIndex
argument_list|()
operator|-
literal|1
expr_stmt|;
return|return
name|result
return|;
block|}
annotation|@
name|Override
specifier|protected
name|boolean
name|isOptional
parameter_list|()
block|{
return|return
literal|false
return|;
block|}
block|}
specifier|public
specifier|static
class|class
name|Chain
extends|extends
name|SymbolFunction
block|{
name|ArrayList
argument_list|<
name|SymbolFunction
argument_list|>
name|components
decl_stmt|;
specifier|public
name|Chain
parameter_list|(
name|ArrayList
argument_list|<
name|SymbolFunction
argument_list|>
name|components
parameter_list|)
block|{
name|this
operator|.
name|components
operator|=
name|components
expr_stmt|;
block|}
comment|/*      * Iterate over the Symbol Functions in the Chain:      * - If we are not at the end of the Iterator (i.e. row != null )      * - match the current componentFn      * - if it returns false, then return false      * - otherwise set row to the next row from the Iterator.      * - if we are at the end of the Iterator      * - skip any optional Symbol Fns (star patterns) at the end.      * - but if we come to a non optional Symbol Fn, return false.      * - if we match all Fns in the chain return true.      */
annotation|@
name|Override
specifier|protected
name|SymbolFunctionResult
name|match
parameter_list|(
name|Object
name|row
parameter_list|,
name|PTFPartitionIterator
argument_list|<
name|Object
argument_list|>
name|pItr
parameter_list|)
throws|throws
name|HiveException
block|{
name|SymbolFunctionResult
name|componentResult
init|=
literal|null
decl_stmt|;
for|for
control|(
name|SymbolFunction
name|sFn
range|:
name|components
control|)
block|{
if|if
condition|(
name|row
operator|!=
literal|null
condition|)
block|{
name|componentResult
operator|=
name|sFn
operator|.
name|match
argument_list|(
name|row
argument_list|,
name|pItr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|componentResult
operator|.
name|matches
condition|)
block|{
name|result
operator|.
name|matches
operator|=
literal|false
expr_stmt|;
name|result
operator|.
name|nextRow
operator|=
name|componentResult
operator|.
name|nextRow
expr_stmt|;
return|return
name|result
return|;
block|}
name|row
operator|=
name|pItr
operator|.
name|resetToIndex
argument_list|(
name|componentResult
operator|.
name|nextRow
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|sFn
operator|.
name|isOptional
argument_list|()
condition|)
block|{
name|result
operator|.
name|matches
operator|=
literal|false
expr_stmt|;
name|result
operator|.
name|nextRow
operator|=
name|componentResult
operator|.
name|nextRow
expr_stmt|;
return|return
name|result
return|;
block|}
block|}
block|}
name|result
operator|.
name|matches
operator|=
literal|true
expr_stmt|;
name|result
operator|.
name|nextRow
operator|=
name|componentResult
operator|.
name|nextRow
expr_stmt|;
return|return
name|result
return|;
block|}
annotation|@
name|Override
specifier|protected
name|boolean
name|isOptional
parameter_list|()
block|{
return|return
literal|false
return|;
block|}
block|}
specifier|public
specifier|static
class|class
name|SymbolFunctionResult
block|{
comment|/*      * does the row match the pattern represented by this SymbolFunction      */
specifier|public
name|boolean
name|matches
decl_stmt|;
comment|/*      * what is the index of the row beyond the set of rows that match this pattern.      */
specifier|public
name|int
name|nextRow
decl_stmt|;
block|}
specifier|public
specifier|static
class|class
name|SymbolParser
block|{
name|String
name|patternStr
decl_stmt|;
name|String
index|[]
name|symbols
decl_stmt|;
name|HashMap
argument_list|<
name|String
argument_list|,
name|Object
index|[]
argument_list|>
name|symbolExprEvalMap
decl_stmt|;
name|ArrayList
argument_list|<
name|SymbolFunction
argument_list|>
name|symbolFunctions
decl_stmt|;
name|Chain
name|symbolFnChain
decl_stmt|;
specifier|public
name|SymbolParser
parameter_list|(
name|String
name|patternStr
parameter_list|,
name|ArrayList
argument_list|<
name|String
argument_list|>
name|symbolNames
parameter_list|,
name|ArrayList
argument_list|<
name|ExprNodeEvaluator
argument_list|>
name|symbolExprEvals
parameter_list|,
name|ArrayList
argument_list|<
name|ObjectInspector
argument_list|>
name|symbolExprOIs
parameter_list|)
block|{
name|super
argument_list|()
expr_stmt|;
name|this
operator|.
name|patternStr
operator|=
name|patternStr
expr_stmt|;
name|symbolExprEvalMap
operator|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|Object
index|[]
argument_list|>
argument_list|()
expr_stmt|;
name|int
name|sz
init|=
name|symbolNames
operator|.
name|size
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|sz
condition|;
name|i
operator|++
control|)
block|{
name|String
name|symbolName
init|=
name|symbolNames
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|ExprNodeEvaluator
name|symbolExprEval
init|=
name|symbolExprEvals
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|ObjectInspector
name|symbolExprOI
init|=
name|symbolExprOIs
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|symbolExprEvalMap
operator|.
name|put
argument_list|(
name|symbolName
operator|.
name|toLowerCase
argument_list|()
argument_list|,
operator|new
name|Object
index|[]
block|{
name|symbolExprEval
block|,
name|symbolExprOI
block|}
argument_list|)
expr_stmt|;
block|}
block|}
specifier|public
name|SymbolFunction
name|getSymbolFunction
parameter_list|()
block|{
return|return
name|symbolFnChain
return|;
block|}
specifier|public
name|void
name|parse
parameter_list|()
throws|throws
name|SemanticException
block|{
name|symbols
operator|=
name|patternStr
operator|.
name|split
argument_list|(
literal|"\\."
argument_list|)
expr_stmt|;
name|symbolFunctions
operator|=
operator|new
name|ArrayList
argument_list|<
name|SymbolFunction
argument_list|>
argument_list|()
expr_stmt|;
for|for
control|(
name|String
name|symbol
range|:
name|symbols
control|)
block|{
name|boolean
name|isStar
init|=
name|symbol
operator|.
name|endsWith
argument_list|(
literal|"*"
argument_list|)
decl_stmt|;
name|boolean
name|isPlus
init|=
name|symbol
operator|.
name|endsWith
argument_list|(
literal|"+"
argument_list|)
decl_stmt|;
name|symbol
operator|=
operator|(
name|isStar
operator|||
name|isPlus
operator|)
condition|?
name|symbol
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|symbol
operator|.
name|length
argument_list|()
operator|-
literal|1
argument_list|)
else|:
name|symbol
expr_stmt|;
name|Object
index|[]
name|symbolDetails
init|=
name|symbolExprEvalMap
operator|.
name|get
argument_list|(
name|symbol
operator|.
name|toLowerCase
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|symbolDetails
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"Unknown Symbol %s"
argument_list|,
name|symbol
argument_list|)
argument_list|)
throw|;
block|}
name|ExprNodeEvaluator
name|symbolExprEval
init|=
operator|(
name|ExprNodeEvaluator
operator|)
name|symbolDetails
index|[
literal|0
index|]
decl_stmt|;
name|ObjectInspector
name|symbolExprOI
init|=
operator|(
name|ObjectInspector
operator|)
name|symbolDetails
index|[
literal|1
index|]
decl_stmt|;
name|SymbolFunction
name|sFn
init|=
operator|new
name|Symbol
argument_list|(
name|symbolExprEval
argument_list|,
name|symbolExprOI
argument_list|)
decl_stmt|;
if|if
condition|(
name|isStar
condition|)
block|{
name|sFn
operator|=
operator|new
name|Star
argument_list|(
name|sFn
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|isPlus
condition|)
block|{
name|sFn
operator|=
operator|new
name|Plus
argument_list|(
name|sFn
argument_list|)
expr_stmt|;
block|}
name|symbolFunctions
operator|.
name|add
argument_list|(
name|sFn
argument_list|)
expr_stmt|;
block|}
name|symbolFnChain
operator|=
operator|new
name|Chain
argument_list|(
name|symbolFunctions
argument_list|)
expr_stmt|;
block|}
block|}
comment|/*    * ResultExpression is a Select List with the following variation:    * - the select keyword is optional. The parser checks if the expression doesn't start with    * select; if not it prefixes it.    * - Window Fn clauses are not permitted.    * - expressions can operate on the input columns plus the psuedo column 'path'    * which is array of    * structs. The shape of the struct is    * the same as the input.    */
specifier|public
specifier|static
class|class
name|ResultExpressionParser
block|{
name|String
name|resultExprString
decl_stmt|;
name|RowResolver
name|selectListInputRowResolver
decl_stmt|;
name|TypeCheckCtx
name|selectListInputTypeCheckCtx
decl_stmt|;
name|StructObjectInspector
name|selectListInputOI
decl_stmt|;
name|ArrayList
argument_list|<
name|WindowExpressionSpec
argument_list|>
name|selectSpec
decl_stmt|;
name|ResultExprInfo
name|resultExprInfo
decl_stmt|;
specifier|public
name|ResultExpressionParser
parameter_list|(
name|String
name|resultExprString
parameter_list|,
name|RowResolver
name|selectListInputRowResolver
parameter_list|)
block|{
name|this
operator|.
name|resultExprString
operator|=
name|resultExprString
expr_stmt|;
name|this
operator|.
name|selectListInputRowResolver
operator|=
name|selectListInputRowResolver
expr_stmt|;
block|}
specifier|public
name|void
name|translate
parameter_list|()
throws|throws
name|SemanticException
throws|,
name|HiveException
block|{
name|setupSelectListInputInfo
argument_list|()
expr_stmt|;
name|fixResultExprString
argument_list|()
expr_stmt|;
name|parse
argument_list|()
expr_stmt|;
name|validateSelectExpr
argument_list|()
expr_stmt|;
name|buildSelectListEvaluators
argument_list|()
expr_stmt|;
block|}
specifier|public
name|ResultExprInfo
name|getResultExprInfo
parameter_list|()
block|{
return|return
name|resultExprInfo
return|;
block|}
specifier|private
name|void
name|buildSelectListEvaluators
parameter_list|()
throws|throws
name|SemanticException
throws|,
name|HiveException
block|{
name|resultExprInfo
operator|=
operator|new
name|ResultExprInfo
argument_list|()
expr_stmt|;
name|resultExprInfo
operator|.
name|resultExprEvals
operator|=
operator|new
name|ArrayList
argument_list|<
name|ExprNodeEvaluator
argument_list|>
argument_list|()
expr_stmt|;
name|resultExprInfo
operator|.
name|resultExprNames
operator|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
expr_stmt|;
name|resultExprInfo
operator|.
name|resultExprNodes
operator|=
operator|new
name|ArrayList
argument_list|<
name|ExprNodeDesc
argument_list|>
argument_list|()
expr_stmt|;
comment|//result
name|ArrayList
argument_list|<
name|ObjectInspector
argument_list|>
name|selectListExprOIs
init|=
operator|new
name|ArrayList
argument_list|<
name|ObjectInspector
argument_list|>
argument_list|()
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
for|for
control|(
name|WindowExpressionSpec
name|expr
range|:
name|selectSpec
control|)
block|{
name|String
name|selectColName
init|=
name|expr
operator|.
name|getAlias
argument_list|()
decl_stmt|;
name|ASTNode
name|selectColumnNode
init|=
name|expr
operator|.
name|getExpression
argument_list|()
decl_stmt|;
name|ExprNodeDesc
name|selectColumnExprNode
init|=
name|ResultExpressionParser
operator|.
name|buildExprNode
argument_list|(
name|selectColumnNode
argument_list|,
name|selectListInputTypeCheckCtx
argument_list|)
decl_stmt|;
name|ExprNodeEvaluator
name|selectColumnExprEval
init|=
name|ExprNodeEvaluatorFactory
operator|.
name|get
argument_list|(
name|selectColumnExprNode
argument_list|)
decl_stmt|;
name|ObjectInspector
name|selectColumnOI
init|=
literal|null
decl_stmt|;
name|selectColumnOI
operator|=
name|selectColumnExprEval
operator|.
name|initialize
argument_list|(
name|selectListInputOI
argument_list|)
expr_stmt|;
name|selectColName
operator|=
name|getColumnName
argument_list|(
name|selectColName
argument_list|,
name|selectColumnExprNode
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|resultExprInfo
operator|.
name|resultExprEvals
operator|.
name|add
argument_list|(
name|selectColumnExprEval
argument_list|)
expr_stmt|;
name|selectListExprOIs
operator|.
name|add
argument_list|(
name|selectColumnOI
argument_list|)
expr_stmt|;
name|resultExprInfo
operator|.
name|resultExprNodes
operator|.
name|add
argument_list|(
name|selectColumnExprNode
argument_list|)
expr_stmt|;
name|resultExprInfo
operator|.
name|resultExprNames
operator|.
name|add
argument_list|(
name|selectColName
argument_list|)
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
name|resultExprInfo
operator|.
name|resultOI
operator|=
name|ObjectInspectorFactory
operator|.
name|getStandardStructObjectInspector
argument_list|(
name|resultExprInfo
operator|.
name|resultExprNames
argument_list|,
name|selectListExprOIs
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|setupSelectListInputInfo
parameter_list|()
throws|throws
name|SemanticException
block|{
name|selectListInputTypeCheckCtx
operator|=
operator|new
name|TypeCheckCtx
argument_list|(
name|selectListInputRowResolver
argument_list|)
expr_stmt|;
name|selectListInputTypeCheckCtx
operator|.
name|setUnparseTranslator
argument_list|(
literal|null
argument_list|)
expr_stmt|;
comment|/*        * create SelectListOI        */
name|selectListInputOI
operator|=
operator|(
name|StructObjectInspector
operator|)
name|PTFTranslator
operator|.
name|getStandardStructOI
argument_list|(
name|selectListInputRowResolver
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|fixResultExprString
parameter_list|()
block|{
name|String
name|r
init|=
name|resultExprString
operator|.
name|trim
argument_list|()
decl_stmt|;
name|String
name|prefix
init|=
name|r
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
literal|6
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|prefix
operator|.
name|toLowerCase
argument_list|()
operator|.
name|equals
argument_list|(
literal|"select"
argument_list|)
condition|)
block|{
name|r
operator|=
literal|"select "
operator|+
name|r
expr_stmt|;
block|}
name|resultExprString
operator|=
name|r
expr_stmt|;
block|}
specifier|private
name|void
name|parse
parameter_list|()
throws|throws
name|SemanticException
block|{
name|selectSpec
operator|=
name|SemanticAnalyzer
operator|.
name|parseSelect
argument_list|(
name|resultExprString
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|validateSelectExpr
parameter_list|()
throws|throws
name|SemanticException
block|{
for|for
control|(
name|WindowExpressionSpec
name|expr
range|:
name|selectSpec
control|)
block|{
name|PTFTranslator
operator|.
name|validateNoLeadLagInValueBoundarySpec
argument_list|(
name|expr
operator|.
name|getExpression
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
name|String
name|getColumnName
parameter_list|(
name|String
name|alias
parameter_list|,
name|ExprNodeDesc
name|exprNode
parameter_list|,
name|int
name|colIdx
parameter_list|)
block|{
if|if
condition|(
name|alias
operator|!=
literal|null
condition|)
block|{
return|return
name|alias
return|;
block|}
elseif|else
if|if
condition|(
name|exprNode
operator|instanceof
name|ExprNodeColumnDesc
condition|)
block|{
name|ExprNodeColumnDesc
name|colDesc
init|=
operator|(
name|ExprNodeColumnDesc
operator|)
name|exprNode
decl_stmt|;
return|return
name|colDesc
operator|.
name|getColumn
argument_list|()
return|;
block|}
return|return
literal|"npath_col_"
operator|+
name|colIdx
return|;
block|}
specifier|public
specifier|static
name|ExprNodeDesc
name|buildExprNode
parameter_list|(
name|ASTNode
name|expr
parameter_list|,
name|TypeCheckCtx
name|typeCheckCtx
parameter_list|)
throws|throws
name|SemanticException
block|{
comment|// todo: use SemanticAnalyzer::genExprNodeDesc
comment|// currently SA not available to PTFTranslator.
name|Map
argument_list|<
name|ASTNode
argument_list|,
name|ExprNodeDesc
argument_list|>
name|map
init|=
name|TypeCheckProcFactory
operator|.
name|genExprNode
argument_list|(
name|expr
argument_list|,
name|typeCheckCtx
argument_list|)
decl_stmt|;
name|ExprNodeDesc
name|desc
init|=
name|map
operator|.
name|get
argument_list|(
name|expr
argument_list|)
decl_stmt|;
if|if
condition|(
name|desc
operator|==
literal|null
condition|)
block|{
name|String
name|errMsg
init|=
name|typeCheckCtx
operator|.
name|getError
argument_list|()
decl_stmt|;
if|if
condition|(
name|errMsg
operator|==
literal|null
condition|)
block|{
name|errMsg
operator|=
literal|"Error in parsing "
expr_stmt|;
block|}
throw|throw
operator|new
name|SemanticException
argument_list|(
name|errMsg
argument_list|)
throw|;
block|}
return|return
name|desc
return|;
block|}
block|}
specifier|public
specifier|static
specifier|final
name|String
name|PATHATTR_NAME
init|=
literal|"tpath"
decl_stmt|;
comment|/*    * add array<struct> to the list of columns    */
specifier|protected
specifier|static
name|RowResolver
name|createSelectListRR
parameter_list|(
name|NPath
name|evaluator
parameter_list|,
name|PTFInputDef
name|inpDef
parameter_list|)
throws|throws
name|SemanticException
block|{
name|RowResolver
name|rr
init|=
operator|new
name|RowResolver
argument_list|()
decl_stmt|;
name|RowResolver
name|inputRR
init|=
name|inpDef
operator|.
name|getOutputShape
argument_list|()
operator|.
name|getRr
argument_list|()
decl_stmt|;
name|boolean
name|inputColNamesKnown
init|=
name|evaluator
operator|.
name|inputColumnNames
operator|!=
literal|null
decl_stmt|;
if|if
condition|(
operator|!
name|inputColNamesKnown
condition|)
block|{
name|evaluator
operator|.
name|inputColumnNames
operator|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
expr_stmt|;
block|}
name|ArrayList
argument_list|<
name|ObjectInspector
argument_list|>
name|inpColOIs
init|=
operator|new
name|ArrayList
argument_list|<
name|ObjectInspector
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|ColumnInfo
name|inpCInfo
range|:
name|inputRR
operator|.
name|getColumnInfos
argument_list|()
control|)
block|{
name|ColumnInfo
name|cInfo
init|=
operator|new
name|ColumnInfo
argument_list|(
name|inpCInfo
argument_list|)
decl_stmt|;
name|String
name|colAlias
init|=
name|cInfo
operator|.
name|getAlias
argument_list|()
decl_stmt|;
name|String
index|[]
name|tabColAlias
init|=
name|inputRR
operator|.
name|reverseLookup
argument_list|(
name|inpCInfo
operator|.
name|getInternalName
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|tabColAlias
operator|!=
literal|null
condition|)
block|{
name|colAlias
operator|=
name|tabColAlias
index|[
literal|1
index|]
expr_stmt|;
block|}
name|ASTNode
name|inExpr
init|=
literal|null
decl_stmt|;
name|inExpr
operator|=
name|PTFTranslator
operator|.
name|getASTNode
argument_list|(
name|inpCInfo
argument_list|,
name|inputRR
argument_list|)
expr_stmt|;
if|if
condition|(
name|inExpr
operator|!=
literal|null
condition|)
block|{
name|rr
operator|.
name|putExpression
argument_list|(
name|inExpr
argument_list|,
name|cInfo
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|colAlias
operator|=
name|colAlias
operator|==
literal|null
condition|?
name|cInfo
operator|.
name|getInternalName
argument_list|()
else|:
name|colAlias
expr_stmt|;
name|rr
operator|.
name|put
argument_list|(
name|cInfo
operator|.
name|getTabAlias
argument_list|()
argument_list|,
name|colAlias
argument_list|,
name|cInfo
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|inputColNamesKnown
condition|)
block|{
name|evaluator
operator|.
name|inputColumnNames
operator|.
name|add
argument_list|(
name|colAlias
argument_list|)
expr_stmt|;
block|}
name|inpColOIs
operator|.
name|add
argument_list|(
name|cInfo
operator|.
name|getObjectInspector
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|StandardListObjectInspector
name|pathAttrOI
init|=
name|ObjectInspectorFactory
operator|.
name|getStandardListObjectInspector
argument_list|(
name|ObjectInspectorFactory
operator|.
name|getStandardStructObjectInspector
argument_list|(
name|evaluator
operator|.
name|inputColumnNames
argument_list|,
name|inpColOIs
argument_list|)
argument_list|)
decl_stmt|;
name|ColumnInfo
name|pathColumn
init|=
operator|new
name|ColumnInfo
argument_list|(
name|PATHATTR_NAME
argument_list|,
name|TypeInfoUtils
operator|.
name|getTypeInfoFromObjectInspector
argument_list|(
name|pathAttrOI
argument_list|)
argument_list|,
literal|null
argument_list|,
literal|false
argument_list|,
literal|false
argument_list|)
decl_stmt|;
name|rr
operator|.
name|put
argument_list|(
literal|null
argument_list|,
name|PATHATTR_NAME
argument_list|,
name|pathColumn
argument_list|)
expr_stmt|;
return|return
name|rr
return|;
block|}
specifier|protected
specifier|static
name|StructObjectInspector
name|createSelectListOI
parameter_list|(
name|NPath
name|evaluator
parameter_list|,
name|PTFInputDef
name|inpDef
parameter_list|)
block|{
name|StructObjectInspector
name|inOI
init|=
name|inpDef
operator|.
name|getOutputShape
argument_list|()
operator|.
name|getOI
argument_list|()
decl_stmt|;
name|ArrayList
argument_list|<
name|ObjectInspector
argument_list|>
name|fieldOIs
init|=
operator|new
name|ArrayList
argument_list|<
name|ObjectInspector
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|StructField
name|f
range|:
name|inOI
operator|.
name|getAllStructFieldRefs
argument_list|()
control|)
block|{
name|fieldOIs
operator|.
name|add
argument_list|(
name|f
operator|.
name|getFieldObjectInspector
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|StandardListObjectInspector
name|pathAttrOI
init|=
name|ObjectInspectorFactory
operator|.
name|getStandardListObjectInspector
argument_list|(
name|ObjectInspectorFactory
operator|.
name|getStandardStructObjectInspector
argument_list|(
name|evaluator
operator|.
name|inputColumnNames
argument_list|,
name|fieldOIs
argument_list|)
argument_list|)
decl_stmt|;
name|ArrayList
argument_list|<
name|ObjectInspector
argument_list|>
name|selectFieldOIs
init|=
operator|new
name|ArrayList
argument_list|<
name|ObjectInspector
argument_list|>
argument_list|()
decl_stmt|;
name|selectFieldOIs
operator|.
name|addAll
argument_list|(
name|fieldOIs
argument_list|)
expr_stmt|;
name|selectFieldOIs
operator|.
name|add
argument_list|(
name|pathAttrOI
argument_list|)
expr_stmt|;
return|return
name|ObjectInspectorFactory
operator|.
name|getStandardStructObjectInspector
argument_list|(
name|evaluator
operator|.
name|selectListNames
argument_list|,
name|selectFieldOIs
argument_list|)
return|;
block|}
specifier|public
specifier|static
name|Object
name|getSelectListInput
parameter_list|(
name|Object
name|currRow
parameter_list|,
name|ObjectInspector
name|rowOI
parameter_list|,
name|PTFPartitionIterator
argument_list|<
name|Object
argument_list|>
name|pItr
parameter_list|,
name|int
name|sz
parameter_list|)
block|{
name|ArrayList
argument_list|<
name|Object
argument_list|>
name|oRow
init|=
operator|new
name|ArrayList
argument_list|<
name|Object
argument_list|>
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|?
argument_list|>
name|currRowAsStdObject
init|=
operator|(
name|List
argument_list|<
name|?
argument_list|>
operator|)
name|ObjectInspectorUtils
operator|.
name|copyToStandardObject
argument_list|(
name|currRow
argument_list|,
name|rowOI
argument_list|)
decl_stmt|;
name|oRow
operator|.
name|addAll
argument_list|(
name|currRowAsStdObject
argument_list|)
expr_stmt|;
name|oRow
operator|.
name|add
argument_list|(
name|getPath
argument_list|(
name|currRow
argument_list|,
name|rowOI
argument_list|,
name|pItr
argument_list|,
name|sz
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|oRow
return|;
block|}
specifier|public
specifier|static
name|ArrayList
argument_list|<
name|Object
argument_list|>
name|getPath
parameter_list|(
name|Object
name|currRow
parameter_list|,
name|ObjectInspector
name|rowOI
parameter_list|,
name|PTFPartitionIterator
argument_list|<
name|Object
argument_list|>
name|pItr
parameter_list|,
name|int
name|sz
parameter_list|)
block|{
name|int
name|idx
init|=
name|pItr
operator|.
name|getIndex
argument_list|()
operator|-
literal|1
decl_stmt|;
name|ArrayList
argument_list|<
name|Object
argument_list|>
name|path
init|=
operator|new
name|ArrayList
argument_list|<
name|Object
argument_list|>
argument_list|()
decl_stmt|;
name|path
operator|.
name|add
argument_list|(
name|ObjectInspectorUtils
operator|.
name|copyToStandardObject
argument_list|(
name|currRow
argument_list|,
name|rowOI
argument_list|)
argument_list|)
expr_stmt|;
name|int
name|pSz
init|=
literal|1
decl_stmt|;
while|while
condition|(
name|pSz
operator|<
name|sz
operator|&&
name|pItr
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|currRow
operator|=
name|pItr
operator|.
name|next
argument_list|()
expr_stmt|;
name|path
operator|.
name|add
argument_list|(
name|ObjectInspectorUtils
operator|.
name|copyToStandardObject
argument_list|(
name|currRow
argument_list|,
name|rowOI
argument_list|)
argument_list|)
expr_stmt|;
name|pSz
operator|++
expr_stmt|;
block|}
name|pItr
operator|.
name|resetToIndex
argument_list|(
name|idx
argument_list|)
expr_stmt|;
return|return
name|path
return|;
block|}
block|}
end_class

end_unit

