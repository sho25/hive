begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|vector
operator|.
name|expressions
package|;
end_package

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Random
import|;
end_import

begin_comment
comment|/**  * A high-performance set implementation used to support fast set membership testing,  * using Cuckoo hashing. This is used to support fast tests of the form  *  *       column IN (<list-of-values )  *  * For details on the algorithm, see R. Pagh and F. F. Rodler, "Cuckoo Hashing,"  * Elsevier Science preprint, Dec. 2003. http://www.itu.dk/people/pagh/papers/cuckoo-jour.pdf.  *  */
end_comment

begin_class
specifier|public
class|class
name|CuckooSetLong
block|{
specifier|private
name|long
name|t1
index|[]
decl_stmt|;
specifier|private
name|long
name|t2
index|[]
decl_stmt|;
specifier|private
name|long
name|prev1
index|[]
init|=
literal|null
decl_stmt|;
comment|// used for rehashing to get last set of values
specifier|private
name|long
name|prev2
index|[]
init|=
literal|null
decl_stmt|;
comment|// " "
specifier|private
name|int
name|n
decl_stmt|;
comment|// current array size
specifier|private
specifier|static
specifier|final
name|double
name|PADDING_FACTOR
init|=
literal|1.0
operator|/
literal|0.40
decl_stmt|;
comment|// have minimum 40% fill factor
specifier|private
name|int
name|salt
index|[]
init|=
operator|new
name|int
index|[
literal|6
index|]
decl_stmt|;
specifier|private
name|Random
name|gen
init|=
operator|new
name|Random
argument_list|(
literal|676983475
argument_list|)
decl_stmt|;
specifier|private
name|long
name|blank
init|=
name|Long
operator|.
name|MIN_VALUE
decl_stmt|;
specifier|private
name|int
name|rehashCount
init|=
literal|0
decl_stmt|;
comment|// some prime numbers spaced about at powers of 2 in magnitude
specifier|public
specifier|static
name|int
name|primes
index|[]
init|=
block|{
literal|7
block|,
literal|13
block|,
literal|17
block|,
literal|23
block|,
literal|31
block|,
literal|53
block|,
literal|67
block|,
literal|89
block|,
literal|127
block|,
literal|269
block|,
literal|571
block|,
literal|1019
block|,
literal|2089
block|,
literal|4507
block|,
literal|8263
block|,
literal|16361
block|,
literal|32327
block|,
literal|65437
block|,
literal|131111
block|,
literal|258887
block|,
literal|525961
block|,
literal|999983
block|,
literal|2158909
block|,
literal|4074073
block|,
literal|8321801
block|,
literal|15485863
block|,
literal|32452867
block|,
literal|67867967
block|,
literal|122949829
block|,
literal|256203221
block|,
literal|553105253
block|,
literal|982451653
block|,
literal|1645333507
block|,
literal|2147483647
block|}
decl_stmt|;
comment|/**    * Allocate a new set to hold expectedSize values. Re-allocation to expand    * the set is not implemented, so the expected size must be at least the    * size of the set to be inserteed.    * @param expectedSize At least the size of the set of values that will be inserted.    */
specifier|public
name|CuckooSetLong
parameter_list|(
name|int
name|expectedSize
parameter_list|)
block|{
comment|// Choose array size. We have two hash tables to hold entries, so the sum
comment|// of the two should have a bit more than twice as much space as the
comment|// minimum required.
name|n
operator|=
call|(
name|int
call|)
argument_list|(
name|expectedSize
operator|*
name|PADDING_FACTOR
operator|/
literal|2.0
argument_list|)
expr_stmt|;
comment|// try to get prime number table size to have less dependence on good hash function
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|!=
name|primes
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|n
operator|<=
name|primes
index|[
name|i
index|]
condition|)
block|{
name|n
operator|=
name|primes
index|[
name|i
index|]
expr_stmt|;
break|break;
block|}
block|}
name|t1
operator|=
operator|new
name|long
index|[
name|n
index|]
expr_stmt|;
name|t2
operator|=
operator|new
name|long
index|[
name|n
index|]
expr_stmt|;
name|Arrays
operator|.
name|fill
argument_list|(
name|t1
argument_list|,
name|blank
argument_list|)
expr_stmt|;
name|Arrays
operator|.
name|fill
argument_list|(
name|t2
argument_list|,
name|blank
argument_list|)
expr_stmt|;
name|updateHashSalt
argument_list|()
expr_stmt|;
block|}
comment|/**    * Return true if and only if the value x is present in the set.    */
specifier|public
name|boolean
name|lookup
parameter_list|(
name|long
name|x
parameter_list|)
block|{
comment|/* Must check that x is not blank because otherwise you could      * get a false positive if the blank value was a value you      * were legitimately testing to see if it was in the set.      */
return|return
name|x
operator|!=
name|blank
operator|&&
operator|(
name|t1
index|[
name|h1
argument_list|(
name|x
argument_list|)
index|]
operator|==
name|x
operator|||
name|t2
index|[
name|h2
argument_list|(
name|x
argument_list|)
index|]
operator|==
name|x
operator|)
return|;
block|}
specifier|public
name|void
name|insert
parameter_list|(
name|long
name|x
parameter_list|)
block|{
if|if
condition|(
name|x
operator|==
name|blank
condition|)
block|{
name|findNewBlank
argument_list|()
expr_stmt|;
block|}
name|long
name|temp
decl_stmt|;
if|if
condition|(
name|lookup
argument_list|(
name|x
argument_list|)
condition|)
block|{
return|return;
block|}
comment|// Try to insert up to n times. Rehash if that fails.
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|!=
name|n
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|t1
index|[
name|h1
argument_list|(
name|x
argument_list|)
index|]
operator|==
name|blank
condition|)
block|{
name|t1
index|[
name|h1
argument_list|(
name|x
argument_list|)
index|]
operator|=
name|x
expr_stmt|;
return|return;
block|}
comment|// swap x and t1[h1(x)]
name|temp
operator|=
name|t1
index|[
name|h1
argument_list|(
name|x
argument_list|)
index|]
expr_stmt|;
name|t1
index|[
name|h1
argument_list|(
name|x
argument_list|)
index|]
operator|=
name|x
expr_stmt|;
name|x
operator|=
name|temp
expr_stmt|;
if|if
condition|(
name|t2
index|[
name|h2
argument_list|(
name|x
argument_list|)
index|]
operator|==
name|blank
condition|)
block|{
name|t2
index|[
name|h2
argument_list|(
name|x
argument_list|)
index|]
operator|=
name|x
expr_stmt|;
return|return;
block|}
comment|// swap x and t2[h2(x)]
name|temp
operator|=
name|t2
index|[
name|h2
argument_list|(
name|x
argument_list|)
index|]
expr_stmt|;
name|t2
index|[
name|h2
argument_list|(
name|x
argument_list|)
index|]
operator|=
name|x
expr_stmt|;
name|x
operator|=
name|temp
expr_stmt|;
block|}
name|rehash
argument_list|()
expr_stmt|;
name|insert
argument_list|(
name|x
argument_list|)
expr_stmt|;
block|}
comment|/**    * Insert all values in the input array into the set.    */
specifier|public
name|void
name|load
parameter_list|(
name|long
index|[]
name|a
parameter_list|)
block|{
for|for
control|(
name|Long
name|x
range|:
name|a
control|)
block|{
name|insert
argument_list|(
name|x
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Need to change current blank value to something else because it is in    * the input data set.    */
specifier|private
name|void
name|findNewBlank
parameter_list|()
block|{
name|long
name|newBlank
init|=
name|gen
operator|.
name|nextLong
argument_list|()
decl_stmt|;
while|while
condition|(
name|newBlank
operator|==
name|blank
operator|||
name|lookup
argument_list|(
name|newBlank
argument_list|)
condition|)
block|{
name|newBlank
operator|=
name|gen
operator|.
name|nextLong
argument_list|()
expr_stmt|;
block|}
comment|// replace existing blanks with new blanks
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|!=
name|n
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|t1
index|[
name|i
index|]
operator|==
name|blank
condition|)
block|{
name|t1
index|[
name|i
index|]
operator|=
name|newBlank
expr_stmt|;
block|}
if|if
condition|(
name|t2
index|[
name|i
index|]
operator|==
name|blank
condition|)
block|{
name|t2
index|[
name|i
index|]
operator|=
name|newBlank
expr_stmt|;
block|}
block|}
name|blank
operator|=
name|newBlank
expr_stmt|;
block|}
comment|/**    * Try to insert with up to n value's "poked out". Return the last value poked out.    * If the value is not blank then we assume there was a cycle.    * Don't try to insert the same value twice. This is for use in rehash only,    * so you won't see the same value twice.    */
specifier|private
name|long
name|tryInsert
parameter_list|(
name|long
name|x
parameter_list|)
block|{
name|long
name|temp
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|!=
name|n
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|t1
index|[
name|h1
argument_list|(
name|x
argument_list|)
index|]
operator|==
name|blank
condition|)
block|{
name|t1
index|[
name|h1
argument_list|(
name|x
argument_list|)
index|]
operator|=
name|x
expr_stmt|;
return|return
name|blank
return|;
block|}
comment|// swap x and t1[h1(x)]
name|temp
operator|=
name|t1
index|[
name|h1
argument_list|(
name|x
argument_list|)
index|]
expr_stmt|;
name|t1
index|[
name|h1
argument_list|(
name|x
argument_list|)
index|]
operator|=
name|x
expr_stmt|;
name|x
operator|=
name|temp
expr_stmt|;
if|if
condition|(
name|t2
index|[
name|h2
argument_list|(
name|x
argument_list|)
index|]
operator|==
name|blank
condition|)
block|{
name|t2
index|[
name|h2
argument_list|(
name|x
argument_list|)
index|]
operator|=
name|x
expr_stmt|;
return|return
name|blank
return|;
block|}
comment|// swap x and t2[h2(x)]
name|temp
operator|=
name|t2
index|[
name|h2
argument_list|(
name|x
argument_list|)
index|]
expr_stmt|;
name|t2
index|[
name|h2
argument_list|(
name|x
argument_list|)
index|]
operator|=
name|x
expr_stmt|;
name|x
operator|=
name|temp
expr_stmt|;
if|if
condition|(
name|x
operator|==
name|blank
condition|)
block|{
break|break;
block|}
block|}
return|return
name|x
return|;
block|}
comment|/**    * Variation of Robert Jenkins' hash function.    */
specifier|private
name|int
name|h1
parameter_list|(
name|long
name|y
parameter_list|)
block|{
name|int
name|x
init|=
call|(
name|int
call|)
argument_list|(
operator|(
operator|(
operator|(
name|y
operator|>>>
literal|32
operator|)
operator|^
name|y
operator|)
operator|)
operator|&
literal|0xFFFFFFFF
argument_list|)
decl_stmt|;
name|x
operator|=
operator|(
name|x
operator|+
name|salt
index|[
literal|0
index|]
operator|)
operator|+
operator|(
name|x
operator|<<
literal|12
operator|)
expr_stmt|;
name|x
operator|=
operator|(
name|x
operator|^
name|salt
index|[
literal|1
index|]
operator|)
operator|^
operator|(
name|x
operator|>>
literal|19
operator|)
expr_stmt|;
name|x
operator|=
operator|(
name|x
operator|+
name|salt
index|[
literal|2
index|]
operator|)
operator|+
operator|(
name|x
operator|<<
literal|5
operator|)
expr_stmt|;
name|x
operator|=
operator|(
name|x
operator|+
name|salt
index|[
literal|3
index|]
operator|)
operator|^
operator|(
name|x
operator|<<
literal|9
operator|)
expr_stmt|;
name|x
operator|=
operator|(
name|x
operator|+
name|salt
index|[
literal|4
index|]
operator|)
operator|+
operator|(
name|x
operator|<<
literal|3
operator|)
expr_stmt|;
name|x
operator|=
operator|(
name|x
operator|^
name|salt
index|[
literal|5
index|]
operator|)
operator|^
operator|(
name|x
operator|>>
literal|16
operator|)
expr_stmt|;
comment|// Return value modulo n but always in the positive range (0..n-1).
comment|// And with the mask to zero the sign bit to make the input to mod positive
comment|// so the output will definitely be positive.
return|return
operator|(
name|x
operator|&
literal|0x7FFFFFFF
operator|)
operator|%
name|n
return|;
block|}
comment|/**    * basic modular hash function    */
specifier|private
name|int
name|h2
parameter_list|(
name|long
name|x
parameter_list|)
block|{
comment|// Return value modulo n but always in the positive range (0..n-1).
comment|// Since n is prime, this gives good spread for numbers that are multiples
comment|// of one billion, which is important since timestamps internally
comment|// are stored as a number of nanoseconds, and the fractional seconds
comment|// part is often 0.
return|return
operator|(
operator|(
call|(
name|int
call|)
argument_list|(
name|x
operator|%
name|n
argument_list|)
operator|)
operator|+
name|n
operator|)
operator|%
name|n
return|;
block|}
comment|/**    * In case of rehash, hash function h2 is changed by updating the    * entries in the salt array with new random values.    */
specifier|private
name|void
name|updateHashSalt
parameter_list|()
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|!=
literal|6
condition|;
name|i
operator|++
control|)
block|{
name|salt
index|[
name|i
index|]
operator|=
name|gen
operator|.
name|nextInt
argument_list|(
literal|0x7FFFFFFF
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|rehash
parameter_list|()
block|{
name|rehashCount
operator|++
expr_stmt|;
if|if
condition|(
name|rehashCount
operator|>
literal|20
condition|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Too many rehashes"
argument_list|)
throw|;
block|}
name|updateHashSalt
argument_list|()
expr_stmt|;
comment|// Save original values
if|if
condition|(
name|prev1
operator|==
literal|null
condition|)
block|{
name|prev1
operator|=
name|t1
expr_stmt|;
name|prev1
operator|=
name|t2
expr_stmt|;
block|}
name|t1
operator|=
operator|new
name|long
index|[
name|n
index|]
expr_stmt|;
name|t2
operator|=
operator|new
name|long
index|[
name|n
index|]
expr_stmt|;
name|Arrays
operator|.
name|fill
argument_list|(
name|t1
argument_list|,
name|blank
argument_list|)
expr_stmt|;
name|Arrays
operator|.
name|fill
argument_list|(
name|t2
argument_list|,
name|blank
argument_list|)
expr_stmt|;
for|for
control|(
name|Long
name|v
range|:
name|prev1
control|)
block|{
if|if
condition|(
name|v
operator|!=
name|blank
condition|)
block|{
name|long
name|x
init|=
name|tryInsert
argument_list|(
name|v
argument_list|)
decl_stmt|;
if|if
condition|(
name|x
operator|!=
name|blank
condition|)
block|{
name|rehash
argument_list|()
expr_stmt|;
return|return;
block|}
block|}
block|}
for|for
control|(
name|Long
name|v
range|:
name|prev2
control|)
block|{
if|if
condition|(
name|v
operator|!=
name|blank
condition|)
block|{
name|long
name|x
init|=
name|tryInsert
argument_list|(
name|v
argument_list|)
decl_stmt|;
if|if
condition|(
name|x
operator|!=
name|blank
condition|)
block|{
name|rehash
argument_list|()
expr_stmt|;
return|return;
block|}
block|}
block|}
comment|// We succeeded in adding all the values, so
comment|// clear the previous values recorded.
name|prev1
operator|=
literal|null
expr_stmt|;
name|prev2
operator|=
literal|null
expr_stmt|;
block|}
block|}
end_class

end_unit

