begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|optimizer
package|;
end_package

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Lists
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|common
operator|.
name|StatsSetupConst
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|common
operator|.
name|type
operator|.
name|HiveDecimal
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|metastore
operator|.
name|api
operator|.
name|ColumnStatisticsData
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|metastore
operator|.
name|api
operator|.
name|ColumnStatisticsObj
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|metastore
operator|.
name|api
operator|.
name|DateColumnStatsData
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|metastore
operator|.
name|api
operator|.
name|DoubleColumnStatsData
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|metastore
operator|.
name|api
operator|.
name|LongColumnStatsData
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|metastore
operator|.
name|utils
operator|.
name|MetaStoreUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|ColumnInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|FetchTask
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|FileSinkOperator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|FunctionRegistry
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|GroupByOperator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|Operator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|ReduceSinkOperator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|SelectOperator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|TableScanOperator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|TaskFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|io
operator|.
name|AcidUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|lib
operator|.
name|DefaultGraphWalker
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|lib
operator|.
name|DefaultRuleDispatcher
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|lib
operator|.
name|Dispatcher
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|lib
operator|.
name|GraphWalker
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|lib
operator|.
name|Node
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|lib
operator|.
name|NodeProcessor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|lib
operator|.
name|NodeProcessorCtx
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|lib
operator|.
name|Rule
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|lib
operator|.
name|RuleRegExp
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|metadata
operator|.
name|Hive
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|metadata
operator|.
name|HiveException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|metadata
operator|.
name|Partition
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|metadata
operator|.
name|Table
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|parse
operator|.
name|ParseContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|parse
operator|.
name|SemanticException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|AggregationDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|ExprNodeColumnDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|ExprNodeConstantDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|ExprNodeDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|ExprNodeDescUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|FetchWork
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|GroupByDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|udf
operator|.
name|generic
operator|.
name|GenericUDAFCount
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|udf
operator|.
name|generic
operator|.
name|GenericUDAFMax
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|udf
operator|.
name|generic
operator|.
name|GenericUDAFMin
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|udf
operator|.
name|generic
operator|.
name|GenericUDAFResolver
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|udf
operator|.
name|generic
operator|.
name|GenericUDAFSum
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde
operator|.
name|serdeConstants
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|io
operator|.
name|DateWritable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|objectinspector
operator|.
name|ObjectInspector
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|objectinspector
operator|.
name|ObjectInspectorFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|objectinspector
operator|.
name|PrimitiveObjectInspector
operator|.
name|PrimitiveCategory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|objectinspector
operator|.
name|StandardStructObjectInspector
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|typeinfo
operator|.
name|TypeInfoUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|thrift
operator|.
name|TException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|LinkedHashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Stack
import|;
end_import

begin_comment
comment|/** There is a set of queries which can be answered entirely from statistics stored in metastore.  * Examples of such queries are count(*), count(a), max(a), min(b) etc. Hive already collects  * these basic statistics for query planning purposes. These same statistics can be used to  * answer queries also.  *  * Optimizer looks at query plan to determine if it can answer query using statistics  * and than change the plan to answer query entirely using statistics stored in metastore.  */
end_comment

begin_class
specifier|public
class|class
name|StatsOptimizer
extends|extends
name|Transform
block|{
comment|// TODO: [HIVE-6289] while getting stats from metastore, we currently only get one col at
comment|//       a time; this could be improved - get all necessary columns in advance, then use local.
comment|// TODO: [HIVE-6292] aggregations could be done directly in metastore. Hive over MySQL!
specifier|private
specifier|static
specifier|final
name|Logger
name|Logger
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|StatsOptimizer
operator|.
name|class
argument_list|)
decl_stmt|;
annotation|@
name|Override
specifier|public
name|ParseContext
name|transform
parameter_list|(
name|ParseContext
name|pctx
parameter_list|)
throws|throws
name|SemanticException
block|{
if|if
condition|(
name|pctx
operator|.
name|getFetchTask
argument_list|()
operator|!=
literal|null
operator|||
operator|!
name|pctx
operator|.
name|getQueryProperties
argument_list|()
operator|.
name|isQuery
argument_list|()
operator|||
name|pctx
operator|.
name|getQueryProperties
argument_list|()
operator|.
name|isAnalyzeRewrite
argument_list|()
operator|||
name|pctx
operator|.
name|getQueryProperties
argument_list|()
operator|.
name|isCTAS
argument_list|()
operator|||
name|pctx
operator|.
name|getLoadFileWork
argument_list|()
operator|.
name|size
argument_list|()
operator|>
literal|1
operator|||
operator|!
name|pctx
operator|.
name|getLoadTableWork
argument_list|()
operator|.
name|isEmpty
argument_list|()
comment|// If getNameToSplitSample is not empty, at least one of the source
comment|// tables is being sampled and we can not optimize.
operator|||
operator|!
name|pctx
operator|.
name|getNameToSplitSample
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return
name|pctx
return|;
block|}
name|String
name|TS
init|=
name|TableScanOperator
operator|.
name|getOperatorName
argument_list|()
operator|+
literal|"%"
decl_stmt|;
name|String
name|GBY
init|=
name|GroupByOperator
operator|.
name|getOperatorName
argument_list|()
operator|+
literal|"%"
decl_stmt|;
name|String
name|RS
init|=
name|ReduceSinkOperator
operator|.
name|getOperatorName
argument_list|()
operator|+
literal|"%"
decl_stmt|;
name|String
name|SEL
init|=
name|SelectOperator
operator|.
name|getOperatorName
argument_list|()
operator|+
literal|"%"
decl_stmt|;
name|String
name|FS
init|=
name|FileSinkOperator
operator|.
name|getOperatorName
argument_list|()
operator|+
literal|"%"
decl_stmt|;
name|Map
argument_list|<
name|Rule
argument_list|,
name|NodeProcessor
argument_list|>
name|opRules
init|=
operator|new
name|LinkedHashMap
argument_list|<
name|Rule
argument_list|,
name|NodeProcessor
argument_list|>
argument_list|()
decl_stmt|;
name|opRules
operator|.
name|put
argument_list|(
operator|new
name|RuleRegExp
argument_list|(
literal|"R1"
argument_list|,
name|TS
operator|+
name|SEL
operator|+
name|GBY
operator|+
name|RS
operator|+
name|GBY
operator|+
name|SEL
operator|+
name|FS
argument_list|)
argument_list|,
operator|new
name|MetaDataProcessor
argument_list|(
name|pctx
argument_list|)
argument_list|)
expr_stmt|;
name|opRules
operator|.
name|put
argument_list|(
operator|new
name|RuleRegExp
argument_list|(
literal|"R2"
argument_list|,
name|TS
operator|+
name|SEL
operator|+
name|GBY
operator|+
name|RS
operator|+
name|GBY
operator|+
name|FS
argument_list|)
argument_list|,
operator|new
name|MetaDataProcessor
argument_list|(
name|pctx
argument_list|)
argument_list|)
expr_stmt|;
name|NodeProcessorCtx
name|soProcCtx
init|=
operator|new
name|StatsOptimizerProcContext
argument_list|()
decl_stmt|;
name|Dispatcher
name|disp
init|=
operator|new
name|DefaultRuleDispatcher
argument_list|(
literal|null
argument_list|,
name|opRules
argument_list|,
name|soProcCtx
argument_list|)
decl_stmt|;
name|GraphWalker
name|ogw
init|=
operator|new
name|DefaultGraphWalker
argument_list|(
name|disp
argument_list|)
decl_stmt|;
name|ArrayList
argument_list|<
name|Node
argument_list|>
name|topNodes
init|=
operator|new
name|ArrayList
argument_list|<
name|Node
argument_list|>
argument_list|()
decl_stmt|;
name|topNodes
operator|.
name|addAll
argument_list|(
name|pctx
operator|.
name|getTopOps
argument_list|()
operator|.
name|values
argument_list|()
argument_list|)
expr_stmt|;
name|ogw
operator|.
name|startWalking
argument_list|(
name|topNodes
argument_list|,
literal|null
argument_list|)
expr_stmt|;
return|return
name|pctx
return|;
block|}
specifier|private
specifier|static
class|class
name|StatsOptimizerProcContext
implements|implements
name|NodeProcessorCtx
block|{
name|boolean
name|stopProcess
init|=
literal|false
decl_stmt|;
block|}
specifier|private
specifier|static
class|class
name|MetaDataProcessor
implements|implements
name|NodeProcessor
block|{
specifier|private
specifier|final
name|ParseContext
name|pctx
decl_stmt|;
specifier|public
name|MetaDataProcessor
parameter_list|(
name|ParseContext
name|pctx
parameter_list|)
block|{
name|this
operator|.
name|pctx
operator|=
name|pctx
expr_stmt|;
block|}
enum|enum
name|StatType
block|{
name|Integer
block|,
name|Double
block|,
name|String
block|,
name|Boolean
block|,
name|Binary
block|,
name|Date
block|,
name|Unsupported
block|}
enum|enum
name|LongSubType
block|{
name|BIGINT
block|{
annotation|@
name|Override
name|Object
name|cast
parameter_list|(
name|long
name|longValue
parameter_list|)
block|{
return|return
name|longValue
return|;
block|}
block|}
block|,
name|INT
block|{
annotation|@
name|Override
name|Object
name|cast
parameter_list|(
name|long
name|longValue
parameter_list|)
block|{
return|return
operator|(
name|int
operator|)
name|longValue
return|;
block|}
block|}
block|,
name|SMALLINT
block|{
annotation|@
name|Override
name|Object
name|cast
parameter_list|(
name|long
name|longValue
parameter_list|)
block|{
return|return
operator|(
name|short
operator|)
name|longValue
return|;
block|}
block|}
block|,
name|TINYINT
block|{
annotation|@
name|Override
name|Object
name|cast
parameter_list|(
name|long
name|longValue
parameter_list|)
block|{
return|return
operator|(
name|byte
operator|)
name|longValue
return|;
block|}
block|}
block|;
specifier|abstract
name|Object
name|cast
parameter_list|(
name|long
name|longValue
parameter_list|)
function_decl|;
block|}
enum|enum
name|DoubleSubType
block|{
name|DOUBLE
block|{
annotation|@
name|Override
name|Object
name|cast
parameter_list|(
name|double
name|doubleValue
parameter_list|)
block|{
return|return
name|doubleValue
return|;
block|}
block|}
block|,
name|FLOAT
block|{
annotation|@
name|Override
name|Object
name|cast
parameter_list|(
name|double
name|doubleValue
parameter_list|)
block|{
return|return
operator|(
name|float
operator|)
name|doubleValue
return|;
block|}
block|}
block|;
specifier|abstract
name|Object
name|cast
parameter_list|(
name|double
name|doubleValue
parameter_list|)
function_decl|;
block|}
enum|enum
name|DateSubType
block|{
name|DAYS
block|{
annotation|@
name|Override
name|Object
name|cast
parameter_list|(
name|long
name|longValue
parameter_list|)
block|{
return|return
operator|(
operator|new
name|DateWritable
argument_list|(
operator|(
name|int
operator|)
name|longValue
argument_list|)
operator|)
operator|.
name|get
argument_list|()
return|;
block|}
block|}
block|;
specifier|abstract
name|Object
name|cast
parameter_list|(
name|long
name|longValue
parameter_list|)
function_decl|;
block|}
enum|enum
name|GbyKeyType
block|{
name|NULL
block|,
name|CONSTANT
block|,
name|OTHER
block|}
specifier|private
name|StatType
name|getType
parameter_list|(
name|String
name|origType
parameter_list|)
block|{
if|if
condition|(
name|serdeConstants
operator|.
name|IntegralTypes
operator|.
name|contains
argument_list|(
name|origType
argument_list|)
condition|)
block|{
return|return
name|StatType
operator|.
name|Integer
return|;
block|}
elseif|else
if|if
condition|(
name|origType
operator|.
name|equals
argument_list|(
name|serdeConstants
operator|.
name|DOUBLE_TYPE_NAME
argument_list|)
operator|||
name|origType
operator|.
name|equals
argument_list|(
name|serdeConstants
operator|.
name|FLOAT_TYPE_NAME
argument_list|)
condition|)
block|{
return|return
name|StatType
operator|.
name|Double
return|;
block|}
elseif|else
if|if
condition|(
name|origType
operator|.
name|equals
argument_list|(
name|serdeConstants
operator|.
name|BINARY_TYPE_NAME
argument_list|)
condition|)
block|{
return|return
name|StatType
operator|.
name|Binary
return|;
block|}
elseif|else
if|if
condition|(
name|origType
operator|.
name|equals
argument_list|(
name|serdeConstants
operator|.
name|BOOLEAN_TYPE_NAME
argument_list|)
condition|)
block|{
return|return
name|StatType
operator|.
name|Boolean
return|;
block|}
elseif|else
if|if
condition|(
name|origType
operator|.
name|equals
argument_list|(
name|serdeConstants
operator|.
name|STRING_TYPE_NAME
argument_list|)
condition|)
block|{
return|return
name|StatType
operator|.
name|String
return|;
block|}
elseif|else
if|if
condition|(
name|origType
operator|.
name|equals
argument_list|(
name|serdeConstants
operator|.
name|DATE_TYPE_NAME
argument_list|)
condition|)
block|{
return|return
name|StatType
operator|.
name|Date
return|;
block|}
return|return
name|StatType
operator|.
name|Unsupported
return|;
block|}
specifier|private
name|Long
name|getNullcountFor
parameter_list|(
name|StatType
name|type
parameter_list|,
name|ColumnStatisticsData
name|statData
parameter_list|)
block|{
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|Integer
case|:
return|return
name|statData
operator|.
name|getLongStats
argument_list|()
operator|.
name|getNumNulls
argument_list|()
return|;
case|case
name|Double
case|:
return|return
name|statData
operator|.
name|getDoubleStats
argument_list|()
operator|.
name|getNumNulls
argument_list|()
return|;
case|case
name|String
case|:
return|return
name|statData
operator|.
name|getStringStats
argument_list|()
operator|.
name|getNumNulls
argument_list|()
return|;
case|case
name|Boolean
case|:
return|return
name|statData
operator|.
name|getBooleanStats
argument_list|()
operator|.
name|getNumNulls
argument_list|()
return|;
case|case
name|Binary
case|:
return|return
name|statData
operator|.
name|getBinaryStats
argument_list|()
operator|.
name|getNumNulls
argument_list|()
return|;
case|case
name|Date
case|:
return|return
name|statData
operator|.
name|getDateStats
argument_list|()
operator|.
name|getNumNulls
argument_list|()
return|;
default|default:
return|return
literal|null
return|;
block|}
block|}
specifier|private
name|GbyKeyType
name|getGbyKeyType
parameter_list|(
name|GroupByOperator
name|gbyOp
parameter_list|)
block|{
name|GroupByDesc
name|gbyDesc
init|=
name|gbyOp
operator|.
name|getConf
argument_list|()
decl_stmt|;
name|int
name|numCols
init|=
name|gbyDesc
operator|.
name|getOutputColumnNames
argument_list|()
operator|.
name|size
argument_list|()
decl_stmt|;
name|int
name|aggCols
init|=
name|gbyDesc
operator|.
name|getAggregators
argument_list|()
operator|.
name|size
argument_list|()
decl_stmt|;
comment|// If the Group by operator has null key
if|if
condition|(
name|numCols
operator|==
name|aggCols
condition|)
block|{
return|return
name|GbyKeyType
operator|.
name|NULL
return|;
block|}
comment|// If the Gby key is a constant
name|List
argument_list|<
name|String
argument_list|>
name|dpCols
init|=
name|gbyOp
operator|.
name|getSchema
argument_list|()
operator|.
name|getColumnNames
argument_list|()
operator|.
name|subList
argument_list|(
literal|0
argument_list|,
name|numCols
operator|-
name|aggCols
argument_list|)
decl_stmt|;
for|for
control|(
name|String
name|dpCol
range|:
name|dpCols
control|)
block|{
name|ExprNodeDesc
name|end
init|=
name|ExprNodeDescUtils
operator|.
name|findConstantExprOrigin
argument_list|(
name|dpCol
argument_list|,
name|gbyOp
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|end
operator|instanceof
name|ExprNodeConstantDesc
operator|)
condition|)
block|{
return|return
name|GbyKeyType
operator|.
name|OTHER
return|;
block|}
block|}
return|return
name|GbyKeyType
operator|.
name|CONSTANT
return|;
block|}
annotation|@
name|Override
specifier|public
name|Object
name|process
parameter_list|(
name|Node
name|nd
parameter_list|,
name|Stack
argument_list|<
name|Node
argument_list|>
name|stack
parameter_list|,
name|NodeProcessorCtx
name|procCtx
parameter_list|,
name|Object
modifier|...
name|nodeOutputs
parameter_list|)
throws|throws
name|SemanticException
block|{
comment|// 1. Do few checks to determine eligibility of optimization
comment|// 2. look at ExprNodeFuncGenericDesc in select list to see if its min, max, count etc.
comment|//    If it is
comment|// 3. Connect to metastore and get the stats
comment|// 4. Compose rows and add it in FetchWork
comment|// 5. Delete GBY - RS - GBY - SEL from the pipeline.
name|StatsOptimizerProcContext
name|soProcCtx
init|=
operator|(
name|StatsOptimizerProcContext
operator|)
name|procCtx
decl_stmt|;
comment|// If the optimization has been stopped for the reasons like being not qualified,
comment|// or lack of the stats data. we do not continue this process. For an example,
comment|// for a query select max(value) from src1 union all select max(value) from src2
comment|// if it has been union remove optimized, the AST tree will become
comment|// TS[0]->SEL[1]->GBY[2]-RS[3]->GBY[4]->FS[17]
comment|// TS[6]->SEL[7]->GBY[8]-RS[9]->GBY[10]->FS[18]
comment|// if TS[0] branch for src1 is not optimized because src1 does not have column stats
comment|// there is no need to continue processing TS[6] branch
if|if
condition|(
name|soProcCtx
operator|.
name|stopProcess
condition|)
block|{
return|return
literal|null
return|;
block|}
name|boolean
name|isOptimized
init|=
literal|false
decl_stmt|;
try|try
block|{
name|TableScanOperator
name|tsOp
init|=
operator|(
name|TableScanOperator
operator|)
name|stack
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|tsOp
operator|.
name|getNumParent
argument_list|()
operator|>
literal|0
condition|)
block|{
comment|// looks like a subq plan.
return|return
literal|null
return|;
block|}
if|if
condition|(
name|tsOp
operator|.
name|getConf
argument_list|()
operator|.
name|getRowLimit
argument_list|()
operator|!=
operator|-
literal|1
condition|)
block|{
comment|// table is sampled. In some situation, we really can leverage row
comment|// limit. In order to be safe, we do not use it now.
return|return
literal|null
return|;
block|}
name|Table
name|tbl
init|=
name|tsOp
operator|.
name|getConf
argument_list|()
operator|.
name|getTableMetadata
argument_list|()
decl_stmt|;
if|if
condition|(
name|MetaStoreUtils
operator|.
name|isExternalTable
argument_list|(
name|tbl
operator|.
name|getTTable
argument_list|()
argument_list|)
condition|)
block|{
name|Logger
operator|.
name|info
argument_list|(
literal|"Table "
operator|+
name|tbl
operator|.
name|getTableName
argument_list|()
operator|+
literal|" is external. Skip StatsOptimizer."
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
if|if
condition|(
name|MetaStoreUtils
operator|.
name|isNonNativeTable
argument_list|(
name|tbl
operator|.
name|getTTable
argument_list|()
argument_list|)
condition|)
block|{
name|Logger
operator|.
name|info
argument_list|(
literal|"Table "
operator|+
name|tbl
operator|.
name|getTableName
argument_list|()
operator|+
literal|" is non Native table. Skip StatsOptimizer."
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
if|if
condition|(
name|AcidUtils
operator|.
name|isTransactionalTable
argument_list|(
name|tbl
argument_list|)
condition|)
block|{
comment|//todo: should this be OK for MM table?
name|Logger
operator|.
name|info
argument_list|(
literal|"Table "
operator|+
name|tbl
operator|.
name|getTableName
argument_list|()
operator|+
literal|" is ACID table. Skip StatsOptimizer."
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
name|Long
name|rowCnt
init|=
name|getRowCnt
argument_list|(
name|pctx
argument_list|,
name|tsOp
argument_list|,
name|tbl
argument_list|)
decl_stmt|;
comment|// if we can not have correct table stats, then both the table stats and column stats are not useful.
if|if
condition|(
name|rowCnt
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
name|SelectOperator
name|pselOp
init|=
operator|(
name|SelectOperator
operator|)
name|stack
operator|.
name|get
argument_list|(
literal|1
argument_list|)
decl_stmt|;
for|for
control|(
name|ExprNodeDesc
name|desc
range|:
name|pselOp
operator|.
name|getConf
argument_list|()
operator|.
name|getColList
argument_list|()
control|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|desc
operator|instanceof
name|ExprNodeColumnDesc
operator|)
operator|||
operator|(
name|desc
operator|instanceof
name|ExprNodeConstantDesc
operator|)
operator|)
condition|)
block|{
comment|// Probably an expression, cant handle that
return|return
literal|null
return|;
block|}
block|}
name|Map
argument_list|<
name|String
argument_list|,
name|ExprNodeDesc
argument_list|>
name|exprMap
init|=
name|pselOp
operator|.
name|getColumnExprMap
argument_list|()
decl_stmt|;
comment|// Since we have done an exact match on TS-SEL-GBY-RS-GBY-(SEL)-FS
comment|// we need not to do any instanceof checks for following.
name|GroupByOperator
name|pgbyOp
init|=
operator|(
name|GroupByOperator
operator|)
name|stack
operator|.
name|get
argument_list|(
literal|2
argument_list|)
decl_stmt|;
if|if
condition|(
name|getGbyKeyType
argument_list|(
name|pgbyOp
argument_list|)
operator|==
name|GbyKeyType
operator|.
name|OTHER
condition|)
block|{
return|return
literal|null
return|;
block|}
comment|// we already check if rowCnt is null and rowCnt==0 means table is
comment|// empty.
elseif|else
if|if
condition|(
name|getGbyKeyType
argument_list|(
name|pgbyOp
argument_list|)
operator|==
name|GbyKeyType
operator|.
name|CONSTANT
operator|&&
name|rowCnt
operator|==
literal|0
condition|)
block|{
return|return
literal|null
return|;
block|}
name|ReduceSinkOperator
name|rsOp
init|=
operator|(
name|ReduceSinkOperator
operator|)
name|stack
operator|.
name|get
argument_list|(
literal|3
argument_list|)
decl_stmt|;
if|if
condition|(
name|rsOp
operator|.
name|getConf
argument_list|()
operator|.
name|getDistinctColumnIndices
argument_list|()
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
comment|// we can't handle distinct
return|return
literal|null
return|;
block|}
name|GroupByOperator
name|cgbyOp
init|=
operator|(
name|GroupByOperator
operator|)
name|stack
operator|.
name|get
argument_list|(
literal|4
argument_list|)
decl_stmt|;
if|if
condition|(
name|getGbyKeyType
argument_list|(
name|cgbyOp
argument_list|)
operator|==
name|GbyKeyType
operator|.
name|OTHER
condition|)
block|{
return|return
literal|null
return|;
block|}
comment|// we already check if rowCnt is null and rowCnt==0 means table is
comment|// empty.
elseif|else
if|if
condition|(
name|getGbyKeyType
argument_list|(
name|cgbyOp
argument_list|)
operator|==
name|GbyKeyType
operator|.
name|CONSTANT
operator|&&
name|rowCnt
operator|==
literal|0
condition|)
block|{
return|return
literal|null
return|;
block|}
name|Operator
argument_list|<
name|?
argument_list|>
name|last
init|=
operator|(
name|Operator
argument_list|<
name|?
argument_list|>
operator|)
name|stack
operator|.
name|get
argument_list|(
literal|5
argument_list|)
decl_stmt|;
name|SelectOperator
name|cselOp
init|=
literal|null
decl_stmt|;
name|Map
argument_list|<
name|Integer
argument_list|,
name|Object
argument_list|>
name|posToConstant
init|=
operator|new
name|LinkedHashMap
argument_list|<>
argument_list|()
decl_stmt|;
if|if
condition|(
name|last
operator|instanceof
name|SelectOperator
condition|)
block|{
name|cselOp
operator|=
operator|(
name|SelectOperator
operator|)
name|last
expr_stmt|;
if|if
condition|(
operator|!
name|cselOp
operator|.
name|isIdentitySelect
argument_list|()
condition|)
block|{
for|for
control|(
name|int
name|pos
init|=
literal|0
init|;
name|pos
operator|<
name|cselOp
operator|.
name|getConf
argument_list|()
operator|.
name|getColList
argument_list|()
operator|.
name|size
argument_list|()
condition|;
name|pos
operator|++
control|)
block|{
name|ExprNodeDesc
name|desc
init|=
name|cselOp
operator|.
name|getConf
argument_list|()
operator|.
name|getColList
argument_list|()
operator|.
name|get
argument_list|(
name|pos
argument_list|)
decl_stmt|;
if|if
condition|(
name|desc
operator|instanceof
name|ExprNodeConstantDesc
condition|)
block|{
comment|//We store the position to the constant value for later use.
name|posToConstant
operator|.
name|put
argument_list|(
name|pos
argument_list|,
operator|(
operator|(
name|ExprNodeConstantDesc
operator|)
name|desc
operator|)
operator|.
name|getValue
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
operator|(
name|desc
operator|instanceof
name|ExprNodeColumnDesc
operator|)
condition|)
block|{
comment|// Probably an expression, cant handle that
return|return
literal|null
return|;
block|}
block|}
block|}
block|}
name|last
operator|=
operator|(
name|Operator
argument_list|<
name|?
argument_list|>
operator|)
name|stack
operator|.
name|get
argument_list|(
literal|6
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// Add constants if there is no SELECT on top
name|GroupByDesc
name|gbyDesc
init|=
name|cgbyOp
operator|.
name|getConf
argument_list|()
decl_stmt|;
name|int
name|numCols
init|=
name|gbyDesc
operator|.
name|getOutputColumnNames
argument_list|()
operator|.
name|size
argument_list|()
decl_stmt|;
name|int
name|aggCols
init|=
name|gbyDesc
operator|.
name|getAggregators
argument_list|()
operator|.
name|size
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|dpCols
init|=
name|cgbyOp
operator|.
name|getSchema
argument_list|()
operator|.
name|getColumnNames
argument_list|()
operator|.
name|subList
argument_list|(
literal|0
argument_list|,
name|numCols
operator|-
name|aggCols
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|dpCols
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|ExprNodeDesc
name|end
init|=
name|ExprNodeDescUtils
operator|.
name|findConstantExprOrigin
argument_list|(
name|dpCols
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|,
name|cgbyOp
argument_list|)
decl_stmt|;
assert|assert
name|end
operator|instanceof
name|ExprNodeConstantDesc
assert|;
name|posToConstant
operator|.
name|put
argument_list|(
name|i
argument_list|,
operator|(
operator|(
name|ExprNodeConstantDesc
operator|)
name|end
operator|)
operator|.
name|getValue
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
name|FileSinkOperator
name|fsOp
init|=
operator|(
name|FileSinkOperator
operator|)
name|last
decl_stmt|;
if|if
condition|(
name|fsOp
operator|.
name|getNumChild
argument_list|()
operator|>
literal|0
condition|)
block|{
comment|// looks like a subq plan.
return|return
literal|null
return|;
comment|// todo we can collapse this part of tree into single TS
block|}
name|List
argument_list|<
name|Object
argument_list|>
name|oneRow
init|=
operator|new
name|ArrayList
argument_list|<
name|Object
argument_list|>
argument_list|()
decl_stmt|;
name|Hive
name|hive
init|=
name|Hive
operator|.
name|get
argument_list|(
name|pctx
operator|.
name|getConf
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|AggregationDesc
name|aggr
range|:
name|pgbyOp
operator|.
name|getConf
argument_list|()
operator|.
name|getAggregators
argument_list|()
control|)
block|{
if|if
condition|(
name|aggr
operator|.
name|getDistinct
argument_list|()
condition|)
block|{
comment|// our stats for NDV is approx, not accurate.
return|return
literal|null
return|;
block|}
comment|// Get the aggregate function matching the name in the query.
name|GenericUDAFResolver
name|udaf
init|=
name|FunctionRegistry
operator|.
name|getGenericUDAFResolver
argument_list|(
name|aggr
operator|.
name|getGenericUDAFName
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|udaf
operator|instanceof
name|GenericUDAFSum
condition|)
block|{
comment|// long/double/decimal
name|ExprNodeDesc
name|desc
init|=
name|aggr
operator|.
name|getParameters
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|PrimitiveCategory
name|category
init|=
name|GenericUDAFSum
operator|.
name|getReturnType
argument_list|(
name|desc
operator|.
name|getTypeInfo
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|category
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
name|String
name|constant
decl_stmt|;
if|if
condition|(
name|desc
operator|instanceof
name|ExprNodeConstantDesc
condition|)
block|{
name|constant
operator|=
operator|(
operator|(
name|ExprNodeConstantDesc
operator|)
name|desc
operator|)
operator|.
name|getValue
argument_list|()
operator|.
name|toString
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|desc
operator|instanceof
name|ExprNodeColumnDesc
operator|&&
name|exprMap
operator|.
name|get
argument_list|(
operator|(
operator|(
name|ExprNodeColumnDesc
operator|)
name|desc
operator|)
operator|.
name|getColumn
argument_list|()
argument_list|)
operator|instanceof
name|ExprNodeConstantDesc
condition|)
block|{
name|constant
operator|=
operator|(
operator|(
name|ExprNodeConstantDesc
operator|)
name|exprMap
operator|.
name|get
argument_list|(
operator|(
operator|(
name|ExprNodeColumnDesc
operator|)
name|desc
operator|)
operator|.
name|getColumn
argument_list|()
argument_list|)
operator|)
operator|.
name|getValue
argument_list|()
operator|.
name|toString
argument_list|()
expr_stmt|;
block|}
else|else
block|{
return|return
literal|null
return|;
block|}
switch|switch
condition|(
name|category
condition|)
block|{
case|case
name|LONG
case|:
name|oneRow
operator|.
name|add
argument_list|(
name|Long
operator|.
name|valueOf
argument_list|(
name|constant
argument_list|)
operator|*
name|rowCnt
argument_list|)
expr_stmt|;
break|break;
case|case
name|DOUBLE
case|:
name|oneRow
operator|.
name|add
argument_list|(
name|Double
operator|.
name|valueOf
argument_list|(
name|constant
argument_list|)
operator|*
name|rowCnt
argument_list|)
expr_stmt|;
break|break;
case|case
name|DECIMAL
case|:
name|oneRow
operator|.
name|add
argument_list|(
name|HiveDecimal
operator|.
name|create
argument_list|(
name|constant
argument_list|)
operator|.
name|multiply
argument_list|(
name|HiveDecimal
operator|.
name|create
argument_list|(
name|rowCnt
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"never"
argument_list|)
throw|;
block|}
block|}
elseif|else
if|if
condition|(
name|udaf
operator|instanceof
name|GenericUDAFCount
condition|)
block|{
comment|// always long
name|rowCnt
operator|=
literal|0L
expr_stmt|;
if|if
condition|(
name|aggr
operator|.
name|getParameters
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
comment|// Its either count (*) or count() case
name|rowCnt
operator|=
name|getRowCnt
argument_list|(
name|pctx
argument_list|,
name|tsOp
argument_list|,
name|tbl
argument_list|)
expr_stmt|;
if|if
condition|(
name|rowCnt
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|aggr
operator|.
name|getParameters
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|instanceof
name|ExprNodeConstantDesc
condition|)
block|{
if|if
condition|(
operator|(
operator|(
name|ExprNodeConstantDesc
operator|)
name|aggr
operator|.
name|getParameters
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|)
operator|.
name|getValue
argument_list|()
operator|!=
literal|null
condition|)
block|{
comment|// count (1)
name|rowCnt
operator|=
name|getRowCnt
argument_list|(
name|pctx
argument_list|,
name|tsOp
argument_list|,
name|tbl
argument_list|)
expr_stmt|;
if|if
condition|(
name|rowCnt
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
block|}
comment|// otherwise it is count(null), should directly return 0.
block|}
elseif|else
if|if
condition|(
operator|(
name|aggr
operator|.
name|getParameters
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|instanceof
name|ExprNodeColumnDesc
operator|)
operator|&&
name|exprMap
operator|.
name|get
argument_list|(
operator|(
operator|(
name|ExprNodeColumnDesc
operator|)
name|aggr
operator|.
name|getParameters
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|)
operator|.
name|getColumn
argument_list|()
argument_list|)
operator|instanceof
name|ExprNodeConstantDesc
condition|)
block|{
if|if
condition|(
operator|(
call|(
name|ExprNodeConstantDesc
call|)
argument_list|(
name|exprMap
operator|.
name|get
argument_list|(
operator|(
operator|(
name|ExprNodeColumnDesc
operator|)
name|aggr
operator|.
name|getParameters
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|)
operator|.
name|getColumn
argument_list|()
argument_list|)
argument_list|)
operator|)
operator|.
name|getValue
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|rowCnt
operator|=
name|getRowCnt
argument_list|(
name|pctx
argument_list|,
name|tsOp
argument_list|,
name|tbl
argument_list|)
expr_stmt|;
if|if
condition|(
name|rowCnt
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
block|}
block|}
else|else
block|{
comment|// Its count(col) case
name|ExprNodeColumnDesc
name|desc
init|=
operator|(
name|ExprNodeColumnDesc
operator|)
name|exprMap
operator|.
name|get
argument_list|(
operator|(
operator|(
name|ExprNodeColumnDesc
operator|)
name|aggr
operator|.
name|getParameters
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|)
operator|.
name|getColumn
argument_list|()
argument_list|)
decl_stmt|;
name|String
name|colName
init|=
name|desc
operator|.
name|getColumn
argument_list|()
decl_stmt|;
name|StatType
name|type
init|=
name|getType
argument_list|(
name|desc
operator|.
name|getTypeString
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|tbl
operator|.
name|isPartitioned
argument_list|()
condition|)
block|{
if|if
condition|(
operator|!
name|StatsSetupConst
operator|.
name|areBasicStatsUptoDate
argument_list|(
name|tbl
operator|.
name|getParameters
argument_list|()
argument_list|)
condition|)
block|{
name|Logger
operator|.
name|debug
argument_list|(
literal|"Stats for table : "
operator|+
name|tbl
operator|.
name|getTableName
argument_list|()
operator|+
literal|" are not up to date."
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
name|rowCnt
operator|=
name|Long
operator|.
name|parseLong
argument_list|(
name|tbl
operator|.
name|getProperty
argument_list|(
name|StatsSetupConst
operator|.
name|ROW_COUNT
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|rowCnt
operator|==
literal|null
condition|)
block|{
name|Logger
operator|.
name|debug
argument_list|(
literal|"Table doesn't have up to date stats "
operator|+
name|tbl
operator|.
name|getTableName
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
if|if
condition|(
operator|!
name|StatsSetupConst
operator|.
name|areColumnStatsUptoDate
argument_list|(
name|tbl
operator|.
name|getParameters
argument_list|()
argument_list|,
name|colName
argument_list|)
condition|)
block|{
name|Logger
operator|.
name|debug
argument_list|(
literal|"Stats for table : "
operator|+
name|tbl
operator|.
name|getTableName
argument_list|()
operator|+
literal|" column "
operator|+
name|colName
operator|+
literal|" are not up to date."
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
name|List
argument_list|<
name|ColumnStatisticsObj
argument_list|>
name|stats
init|=
name|hive
operator|.
name|getMSC
argument_list|()
operator|.
name|getTableColumnStatistics
argument_list|(
name|tbl
operator|.
name|getDbName
argument_list|()
argument_list|,
name|tbl
operator|.
name|getTableName
argument_list|()
argument_list|,
name|Lists
operator|.
name|newArrayList
argument_list|(
name|colName
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|stats
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|Logger
operator|.
name|debug
argument_list|(
literal|"No stats for "
operator|+
name|tbl
operator|.
name|getTableName
argument_list|()
operator|+
literal|" column "
operator|+
name|colName
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
name|Long
name|nullCnt
init|=
name|getNullcountFor
argument_list|(
name|type
argument_list|,
name|stats
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|getStatsData
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
literal|null
operator|==
name|nullCnt
condition|)
block|{
name|Logger
operator|.
name|debug
argument_list|(
literal|"Unsupported type: "
operator|+
name|desc
operator|.
name|getTypeString
argument_list|()
operator|+
literal|" encountered in "
operator|+
literal|"metadata optimizer for column : "
operator|+
name|colName
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
else|else
block|{
name|rowCnt
operator|-=
name|nullCnt
expr_stmt|;
block|}
block|}
else|else
block|{
name|Set
argument_list|<
name|Partition
argument_list|>
name|parts
init|=
name|pctx
operator|.
name|getPrunedPartitions
argument_list|(
name|tsOp
operator|.
name|getConf
argument_list|()
operator|.
name|getAlias
argument_list|()
argument_list|,
name|tsOp
argument_list|)
operator|.
name|getPartitions
argument_list|()
decl_stmt|;
for|for
control|(
name|Partition
name|part
range|:
name|parts
control|)
block|{
if|if
condition|(
operator|!
name|StatsSetupConst
operator|.
name|areBasicStatsUptoDate
argument_list|(
name|part
operator|.
name|getParameters
argument_list|()
argument_list|)
condition|)
block|{
name|Logger
operator|.
name|debug
argument_list|(
literal|"Stats for part : "
operator|+
name|part
operator|.
name|getSpec
argument_list|()
operator|+
literal|" are not up to date."
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
name|Long
name|partRowCnt
init|=
name|Long
operator|.
name|parseLong
argument_list|(
name|part
operator|.
name|getParameters
argument_list|()
operator|.
name|get
argument_list|(
name|StatsSetupConst
operator|.
name|ROW_COUNT
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|partRowCnt
operator|==
literal|null
condition|)
block|{
name|Logger
operator|.
name|debug
argument_list|(
literal|"Partition doesn't have up to date stats "
operator|+
name|part
operator|.
name|getSpec
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
name|rowCnt
operator|+=
name|partRowCnt
expr_stmt|;
block|}
name|Collection
argument_list|<
name|List
argument_list|<
name|ColumnStatisticsObj
argument_list|>
argument_list|>
name|result
init|=
name|verifyAndGetPartColumnStats
argument_list|(
name|hive
argument_list|,
name|tbl
argument_list|,
name|colName
argument_list|,
name|parts
argument_list|)
decl_stmt|;
if|if
condition|(
name|result
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
comment|// logging inside
block|}
for|for
control|(
name|List
argument_list|<
name|ColumnStatisticsObj
argument_list|>
name|statObj
range|:
name|result
control|)
block|{
name|ColumnStatisticsData
name|statData
init|=
name|validateSingleColStat
argument_list|(
name|statObj
argument_list|)
decl_stmt|;
if|if
condition|(
name|statData
operator|==
literal|null
condition|)
return|return
literal|null
return|;
name|Long
name|nullCnt
init|=
name|getNullcountFor
argument_list|(
name|type
argument_list|,
name|statData
argument_list|)
decl_stmt|;
if|if
condition|(
name|nullCnt
operator|==
literal|null
condition|)
block|{
name|Logger
operator|.
name|debug
argument_list|(
literal|"Unsupported type: "
operator|+
name|desc
operator|.
name|getTypeString
argument_list|()
operator|+
literal|" encountered in "
operator|+
literal|"metadata optimizer for column : "
operator|+
name|colName
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
else|else
block|{
name|rowCnt
operator|-=
name|nullCnt
expr_stmt|;
block|}
block|}
block|}
block|}
name|oneRow
operator|.
name|add
argument_list|(
name|rowCnt
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|udaf
operator|instanceof
name|GenericUDAFMax
condition|)
block|{
name|ExprNodeColumnDesc
name|colDesc
init|=
operator|(
name|ExprNodeColumnDesc
operator|)
name|exprMap
operator|.
name|get
argument_list|(
operator|(
operator|(
name|ExprNodeColumnDesc
operator|)
name|aggr
operator|.
name|getParameters
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|)
operator|.
name|getColumn
argument_list|()
argument_list|)
decl_stmt|;
name|String
name|colName
init|=
name|colDesc
operator|.
name|getColumn
argument_list|()
decl_stmt|;
name|StatType
name|type
init|=
name|getType
argument_list|(
name|colDesc
operator|.
name|getTypeString
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|tbl
operator|.
name|isPartitioned
argument_list|()
condition|)
block|{
if|if
condition|(
operator|!
name|StatsSetupConst
operator|.
name|areColumnStatsUptoDate
argument_list|(
name|tbl
operator|.
name|getParameters
argument_list|()
argument_list|,
name|colName
argument_list|)
condition|)
block|{
name|Logger
operator|.
name|debug
argument_list|(
literal|"Stats for table : "
operator|+
name|tbl
operator|.
name|getTableName
argument_list|()
operator|+
literal|" column "
operator|+
name|colName
operator|+
literal|" are not up to date."
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
name|List
argument_list|<
name|ColumnStatisticsObj
argument_list|>
name|stats
init|=
name|hive
operator|.
name|getMSC
argument_list|()
operator|.
name|getTableColumnStatistics
argument_list|(
name|tbl
operator|.
name|getDbName
argument_list|()
argument_list|,
name|tbl
operator|.
name|getTableName
argument_list|()
argument_list|,
name|Lists
operator|.
name|newArrayList
argument_list|(
name|colName
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|stats
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|Logger
operator|.
name|debug
argument_list|(
literal|"No stats for "
operator|+
name|tbl
operator|.
name|getTableName
argument_list|()
operator|+
literal|" column "
operator|+
name|colName
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
name|ColumnStatisticsData
name|statData
init|=
name|stats
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|getStatsData
argument_list|()
decl_stmt|;
name|String
name|name
init|=
name|colDesc
operator|.
name|getTypeString
argument_list|()
operator|.
name|toUpperCase
argument_list|()
decl_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|Integer
case|:
block|{
name|LongSubType
name|subType
init|=
name|LongSubType
operator|.
name|valueOf
argument_list|(
name|name
argument_list|)
decl_stmt|;
name|LongColumnStatsData
name|lstats
init|=
name|statData
operator|.
name|getLongStats
argument_list|()
decl_stmt|;
if|if
condition|(
name|lstats
operator|.
name|isSetHighValue
argument_list|()
condition|)
block|{
name|oneRow
operator|.
name|add
argument_list|(
name|subType
operator|.
name|cast
argument_list|(
name|lstats
operator|.
name|getHighValue
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|oneRow
operator|.
name|add
argument_list|(
literal|null
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
case|case
name|Double
case|:
block|{
name|DoubleSubType
name|subType
init|=
name|DoubleSubType
operator|.
name|valueOf
argument_list|(
name|name
argument_list|)
decl_stmt|;
name|DoubleColumnStatsData
name|dstats
init|=
name|statData
operator|.
name|getDoubleStats
argument_list|()
decl_stmt|;
if|if
condition|(
name|dstats
operator|.
name|isSetHighValue
argument_list|()
condition|)
block|{
name|oneRow
operator|.
name|add
argument_list|(
name|subType
operator|.
name|cast
argument_list|(
name|dstats
operator|.
name|getHighValue
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|oneRow
operator|.
name|add
argument_list|(
literal|null
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
case|case
name|Date
case|:
block|{
name|DateColumnStatsData
name|dstats
init|=
name|statData
operator|.
name|getDateStats
argument_list|()
decl_stmt|;
if|if
condition|(
name|dstats
operator|.
name|isSetHighValue
argument_list|()
condition|)
block|{
name|oneRow
operator|.
name|add
argument_list|(
name|DateSubType
operator|.
name|DAYS
operator|.
name|cast
argument_list|(
name|dstats
operator|.
name|getHighValue
argument_list|()
operator|.
name|getDaysSinceEpoch
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|oneRow
operator|.
name|add
argument_list|(
literal|null
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
default|default:
comment|// unsupported type
name|Logger
operator|.
name|debug
argument_list|(
literal|"Unsupported type: "
operator|+
name|colDesc
operator|.
name|getTypeString
argument_list|()
operator|+
literal|" encountered in "
operator|+
literal|"metadata optimizer for column : "
operator|+
name|colName
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
block|}
else|else
block|{
name|Set
argument_list|<
name|Partition
argument_list|>
name|parts
init|=
name|pctx
operator|.
name|getPrunedPartitions
argument_list|(
name|tsOp
operator|.
name|getConf
argument_list|()
operator|.
name|getAlias
argument_list|()
argument_list|,
name|tsOp
argument_list|)
operator|.
name|getPartitions
argument_list|()
decl_stmt|;
name|String
name|name
init|=
name|colDesc
operator|.
name|getTypeString
argument_list|()
operator|.
name|toUpperCase
argument_list|()
decl_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|Integer
case|:
block|{
name|LongSubType
name|subType
init|=
name|LongSubType
operator|.
name|valueOf
argument_list|(
name|name
argument_list|)
decl_stmt|;
name|Long
name|maxVal
init|=
literal|null
decl_stmt|;
name|Collection
argument_list|<
name|List
argument_list|<
name|ColumnStatisticsObj
argument_list|>
argument_list|>
name|result
init|=
name|verifyAndGetPartColumnStats
argument_list|(
name|hive
argument_list|,
name|tbl
argument_list|,
name|colName
argument_list|,
name|parts
argument_list|)
decl_stmt|;
if|if
condition|(
name|result
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
comment|// logging inside
block|}
for|for
control|(
name|List
argument_list|<
name|ColumnStatisticsObj
argument_list|>
name|statObj
range|:
name|result
control|)
block|{
name|ColumnStatisticsData
name|statData
init|=
name|validateSingleColStat
argument_list|(
name|statObj
argument_list|)
decl_stmt|;
if|if
condition|(
name|statData
operator|==
literal|null
condition|)
return|return
literal|null
return|;
name|LongColumnStatsData
name|lstats
init|=
name|statData
operator|.
name|getLongStats
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|lstats
operator|.
name|isSetHighValue
argument_list|()
condition|)
block|{
continue|continue;
block|}
name|long
name|curVal
init|=
name|lstats
operator|.
name|getHighValue
argument_list|()
decl_stmt|;
name|maxVal
operator|=
name|maxVal
operator|==
literal|null
condition|?
name|curVal
else|:
name|Math
operator|.
name|max
argument_list|(
name|maxVal
argument_list|,
name|curVal
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|maxVal
operator|!=
literal|null
condition|)
block|{
name|oneRow
operator|.
name|add
argument_list|(
name|subType
operator|.
name|cast
argument_list|(
name|maxVal
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|oneRow
operator|.
name|add
argument_list|(
name|maxVal
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
case|case
name|Double
case|:
block|{
name|DoubleSubType
name|subType
init|=
name|DoubleSubType
operator|.
name|valueOf
argument_list|(
name|name
argument_list|)
decl_stmt|;
name|Double
name|maxVal
init|=
literal|null
decl_stmt|;
name|Collection
argument_list|<
name|List
argument_list|<
name|ColumnStatisticsObj
argument_list|>
argument_list|>
name|result
init|=
name|verifyAndGetPartColumnStats
argument_list|(
name|hive
argument_list|,
name|tbl
argument_list|,
name|colName
argument_list|,
name|parts
argument_list|)
decl_stmt|;
if|if
condition|(
name|result
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
comment|// logging inside
block|}
for|for
control|(
name|List
argument_list|<
name|ColumnStatisticsObj
argument_list|>
name|statObj
range|:
name|result
control|)
block|{
name|ColumnStatisticsData
name|statData
init|=
name|validateSingleColStat
argument_list|(
name|statObj
argument_list|)
decl_stmt|;
if|if
condition|(
name|statData
operator|==
literal|null
condition|)
return|return
literal|null
return|;
name|DoubleColumnStatsData
name|dstats
init|=
name|statData
operator|.
name|getDoubleStats
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|dstats
operator|.
name|isSetHighValue
argument_list|()
condition|)
block|{
continue|continue;
block|}
name|double
name|curVal
init|=
name|statData
operator|.
name|getDoubleStats
argument_list|()
operator|.
name|getHighValue
argument_list|()
decl_stmt|;
name|maxVal
operator|=
name|maxVal
operator|==
literal|null
condition|?
name|curVal
else|:
name|Math
operator|.
name|max
argument_list|(
name|maxVal
argument_list|,
name|curVal
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|maxVal
operator|!=
literal|null
condition|)
block|{
name|oneRow
operator|.
name|add
argument_list|(
name|subType
operator|.
name|cast
argument_list|(
name|maxVal
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|oneRow
operator|.
name|add
argument_list|(
literal|null
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
case|case
name|Date
case|:
block|{
name|Long
name|maxVal
init|=
literal|null
decl_stmt|;
name|Collection
argument_list|<
name|List
argument_list|<
name|ColumnStatisticsObj
argument_list|>
argument_list|>
name|result
init|=
name|verifyAndGetPartColumnStats
argument_list|(
name|hive
argument_list|,
name|tbl
argument_list|,
name|colName
argument_list|,
name|parts
argument_list|)
decl_stmt|;
if|if
condition|(
name|result
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
comment|// logging inside
block|}
for|for
control|(
name|List
argument_list|<
name|ColumnStatisticsObj
argument_list|>
name|statObj
range|:
name|result
control|)
block|{
name|ColumnStatisticsData
name|statData
init|=
name|validateSingleColStat
argument_list|(
name|statObj
argument_list|)
decl_stmt|;
if|if
condition|(
name|statData
operator|==
literal|null
condition|)
return|return
literal|null
return|;
name|DateColumnStatsData
name|dstats
init|=
name|statData
operator|.
name|getDateStats
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|dstats
operator|.
name|isSetHighValue
argument_list|()
condition|)
block|{
continue|continue;
block|}
name|long
name|curVal
init|=
name|dstats
operator|.
name|getHighValue
argument_list|()
operator|.
name|getDaysSinceEpoch
argument_list|()
decl_stmt|;
name|maxVal
operator|=
name|maxVal
operator|==
literal|null
condition|?
name|curVal
else|:
name|Math
operator|.
name|max
argument_list|(
name|maxVal
argument_list|,
name|curVal
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|maxVal
operator|!=
literal|null
condition|)
block|{
name|oneRow
operator|.
name|add
argument_list|(
name|DateSubType
operator|.
name|DAYS
operator|.
name|cast
argument_list|(
name|maxVal
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|oneRow
operator|.
name|add
argument_list|(
literal|null
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
default|default:
name|Logger
operator|.
name|debug
argument_list|(
literal|"Unsupported type: "
operator|+
name|colDesc
operator|.
name|getTypeString
argument_list|()
operator|+
literal|" encountered in "
operator|+
literal|"metadata optimizer for column : "
operator|+
name|colName
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|udaf
operator|instanceof
name|GenericUDAFMin
condition|)
block|{
name|ExprNodeColumnDesc
name|colDesc
init|=
operator|(
name|ExprNodeColumnDesc
operator|)
name|exprMap
operator|.
name|get
argument_list|(
operator|(
operator|(
name|ExprNodeColumnDesc
operator|)
name|aggr
operator|.
name|getParameters
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|)
operator|.
name|getColumn
argument_list|()
argument_list|)
decl_stmt|;
name|String
name|colName
init|=
name|colDesc
operator|.
name|getColumn
argument_list|()
decl_stmt|;
name|StatType
name|type
init|=
name|getType
argument_list|(
name|colDesc
operator|.
name|getTypeString
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|tbl
operator|.
name|isPartitioned
argument_list|()
condition|)
block|{
if|if
condition|(
operator|!
name|StatsSetupConst
operator|.
name|areColumnStatsUptoDate
argument_list|(
name|tbl
operator|.
name|getParameters
argument_list|()
argument_list|,
name|colName
argument_list|)
condition|)
block|{
name|Logger
operator|.
name|debug
argument_list|(
literal|"Stats for table : "
operator|+
name|tbl
operator|.
name|getTableName
argument_list|()
operator|+
literal|" column "
operator|+
name|colName
operator|+
literal|" are not up to date."
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
name|ColumnStatisticsData
name|statData
init|=
name|hive
operator|.
name|getMSC
argument_list|()
operator|.
name|getTableColumnStatistics
argument_list|(
name|tbl
operator|.
name|getDbName
argument_list|()
argument_list|,
name|tbl
operator|.
name|getTableName
argument_list|()
argument_list|,
name|Lists
operator|.
name|newArrayList
argument_list|(
name|colName
argument_list|)
argument_list|)
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|getStatsData
argument_list|()
decl_stmt|;
name|String
name|name
init|=
name|colDesc
operator|.
name|getTypeString
argument_list|()
operator|.
name|toUpperCase
argument_list|()
decl_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|Integer
case|:
block|{
name|LongSubType
name|subType
init|=
name|LongSubType
operator|.
name|valueOf
argument_list|(
name|name
argument_list|)
decl_stmt|;
name|LongColumnStatsData
name|lstats
init|=
name|statData
operator|.
name|getLongStats
argument_list|()
decl_stmt|;
if|if
condition|(
name|lstats
operator|.
name|isSetLowValue
argument_list|()
condition|)
block|{
name|oneRow
operator|.
name|add
argument_list|(
name|subType
operator|.
name|cast
argument_list|(
name|lstats
operator|.
name|getLowValue
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|oneRow
operator|.
name|add
argument_list|(
literal|null
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
case|case
name|Double
case|:
block|{
name|DoubleSubType
name|subType
init|=
name|DoubleSubType
operator|.
name|valueOf
argument_list|(
name|name
argument_list|)
decl_stmt|;
name|DoubleColumnStatsData
name|dstats
init|=
name|statData
operator|.
name|getDoubleStats
argument_list|()
decl_stmt|;
if|if
condition|(
name|dstats
operator|.
name|isSetLowValue
argument_list|()
condition|)
block|{
name|oneRow
operator|.
name|add
argument_list|(
name|subType
operator|.
name|cast
argument_list|(
name|dstats
operator|.
name|getLowValue
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|oneRow
operator|.
name|add
argument_list|(
literal|null
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
case|case
name|Date
case|:
block|{
name|DateColumnStatsData
name|dstats
init|=
name|statData
operator|.
name|getDateStats
argument_list|()
decl_stmt|;
if|if
condition|(
name|dstats
operator|.
name|isSetLowValue
argument_list|()
condition|)
block|{
name|oneRow
operator|.
name|add
argument_list|(
name|DateSubType
operator|.
name|DAYS
operator|.
name|cast
argument_list|(
name|dstats
operator|.
name|getLowValue
argument_list|()
operator|.
name|getDaysSinceEpoch
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|oneRow
operator|.
name|add
argument_list|(
literal|null
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
default|default:
comment|// unsupported type
name|Logger
operator|.
name|debug
argument_list|(
literal|"Unsupported type: "
operator|+
name|colDesc
operator|.
name|getTypeString
argument_list|()
operator|+
literal|" encountered in "
operator|+
literal|"metadata optimizer for column : "
operator|+
name|colName
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
block|}
else|else
block|{
name|Set
argument_list|<
name|Partition
argument_list|>
name|parts
init|=
name|pctx
operator|.
name|getPrunedPartitions
argument_list|(
name|tsOp
operator|.
name|getConf
argument_list|()
operator|.
name|getAlias
argument_list|()
argument_list|,
name|tsOp
argument_list|)
operator|.
name|getPartitions
argument_list|()
decl_stmt|;
name|String
name|name
init|=
name|colDesc
operator|.
name|getTypeString
argument_list|()
operator|.
name|toUpperCase
argument_list|()
decl_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|Integer
case|:
block|{
name|LongSubType
name|subType
init|=
name|LongSubType
operator|.
name|valueOf
argument_list|(
name|name
argument_list|)
decl_stmt|;
name|Long
name|minVal
init|=
literal|null
decl_stmt|;
name|Collection
argument_list|<
name|List
argument_list|<
name|ColumnStatisticsObj
argument_list|>
argument_list|>
name|result
init|=
name|verifyAndGetPartColumnStats
argument_list|(
name|hive
argument_list|,
name|tbl
argument_list|,
name|colName
argument_list|,
name|parts
argument_list|)
decl_stmt|;
if|if
condition|(
name|result
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
comment|// logging inside
block|}
for|for
control|(
name|List
argument_list|<
name|ColumnStatisticsObj
argument_list|>
name|statObj
range|:
name|result
control|)
block|{
name|ColumnStatisticsData
name|statData
init|=
name|validateSingleColStat
argument_list|(
name|statObj
argument_list|)
decl_stmt|;
if|if
condition|(
name|statData
operator|==
literal|null
condition|)
return|return
literal|null
return|;
name|LongColumnStatsData
name|lstats
init|=
name|statData
operator|.
name|getLongStats
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|lstats
operator|.
name|isSetLowValue
argument_list|()
condition|)
block|{
continue|continue;
block|}
name|long
name|curVal
init|=
name|lstats
operator|.
name|getLowValue
argument_list|()
decl_stmt|;
name|minVal
operator|=
name|minVal
operator|==
literal|null
condition|?
name|curVal
else|:
name|Math
operator|.
name|min
argument_list|(
name|minVal
argument_list|,
name|curVal
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|minVal
operator|!=
literal|null
condition|)
block|{
name|oneRow
operator|.
name|add
argument_list|(
name|subType
operator|.
name|cast
argument_list|(
name|minVal
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|oneRow
operator|.
name|add
argument_list|(
name|minVal
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
case|case
name|Double
case|:
block|{
name|DoubleSubType
name|subType
init|=
name|DoubleSubType
operator|.
name|valueOf
argument_list|(
name|name
argument_list|)
decl_stmt|;
name|Double
name|minVal
init|=
literal|null
decl_stmt|;
name|Collection
argument_list|<
name|List
argument_list|<
name|ColumnStatisticsObj
argument_list|>
argument_list|>
name|result
init|=
name|verifyAndGetPartColumnStats
argument_list|(
name|hive
argument_list|,
name|tbl
argument_list|,
name|colName
argument_list|,
name|parts
argument_list|)
decl_stmt|;
if|if
condition|(
name|result
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
comment|// logging inside
block|}
for|for
control|(
name|List
argument_list|<
name|ColumnStatisticsObj
argument_list|>
name|statObj
range|:
name|result
control|)
block|{
name|ColumnStatisticsData
name|statData
init|=
name|validateSingleColStat
argument_list|(
name|statObj
argument_list|)
decl_stmt|;
if|if
condition|(
name|statData
operator|==
literal|null
condition|)
return|return
literal|null
return|;
name|DoubleColumnStatsData
name|dstats
init|=
name|statData
operator|.
name|getDoubleStats
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|dstats
operator|.
name|isSetLowValue
argument_list|()
condition|)
block|{
continue|continue;
block|}
name|double
name|curVal
init|=
name|statData
operator|.
name|getDoubleStats
argument_list|()
operator|.
name|getLowValue
argument_list|()
decl_stmt|;
name|minVal
operator|=
name|minVal
operator|==
literal|null
condition|?
name|curVal
else|:
name|Math
operator|.
name|min
argument_list|(
name|minVal
argument_list|,
name|curVal
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|minVal
operator|!=
literal|null
condition|)
block|{
name|oneRow
operator|.
name|add
argument_list|(
name|subType
operator|.
name|cast
argument_list|(
name|minVal
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|oneRow
operator|.
name|add
argument_list|(
name|minVal
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
case|case
name|Date
case|:
block|{
name|Long
name|minVal
init|=
literal|null
decl_stmt|;
name|Collection
argument_list|<
name|List
argument_list|<
name|ColumnStatisticsObj
argument_list|>
argument_list|>
name|result
init|=
name|verifyAndGetPartColumnStats
argument_list|(
name|hive
argument_list|,
name|tbl
argument_list|,
name|colName
argument_list|,
name|parts
argument_list|)
decl_stmt|;
if|if
condition|(
name|result
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
comment|// logging inside
block|}
for|for
control|(
name|List
argument_list|<
name|ColumnStatisticsObj
argument_list|>
name|statObj
range|:
name|result
control|)
block|{
name|ColumnStatisticsData
name|statData
init|=
name|validateSingleColStat
argument_list|(
name|statObj
argument_list|)
decl_stmt|;
if|if
condition|(
name|statData
operator|==
literal|null
condition|)
return|return
literal|null
return|;
name|DateColumnStatsData
name|dstats
init|=
name|statData
operator|.
name|getDateStats
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|dstats
operator|.
name|isSetLowValue
argument_list|()
condition|)
block|{
continue|continue;
block|}
name|long
name|curVal
init|=
name|dstats
operator|.
name|getLowValue
argument_list|()
operator|.
name|getDaysSinceEpoch
argument_list|()
decl_stmt|;
name|minVal
operator|=
name|minVal
operator|==
literal|null
condition|?
name|curVal
else|:
name|Math
operator|.
name|min
argument_list|(
name|minVal
argument_list|,
name|curVal
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|minVal
operator|!=
literal|null
condition|)
block|{
name|oneRow
operator|.
name|add
argument_list|(
name|DateSubType
operator|.
name|DAYS
operator|.
name|cast
argument_list|(
name|minVal
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|oneRow
operator|.
name|add
argument_list|(
literal|null
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
default|default:
comment|// unsupported type
name|Logger
operator|.
name|debug
argument_list|(
literal|"Unsupported type: "
operator|+
name|colDesc
operator|.
name|getTypeString
argument_list|()
operator|+
literal|" encountered in "
operator|+
literal|"metadata optimizer for column : "
operator|+
name|colName
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
block|}
block|}
else|else
block|{
comment|// Unsupported aggregation.
name|Logger
operator|.
name|debug
argument_list|(
literal|"Unsupported aggregation for metadata optimizer: "
operator|+
name|aggr
operator|.
name|getGenericUDAFName
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
block|}
name|List
argument_list|<
name|List
argument_list|<
name|Object
argument_list|>
argument_list|>
name|allRows
init|=
operator|new
name|ArrayList
argument_list|<
name|List
argument_list|<
name|Object
argument_list|>
argument_list|>
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|colNames
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|ObjectInspector
argument_list|>
name|ois
init|=
operator|new
name|ArrayList
argument_list|<
name|ObjectInspector
argument_list|>
argument_list|()
decl_stmt|;
if|if
condition|(
name|cselOp
operator|==
literal|null
condition|)
block|{
name|List
argument_list|<
name|Object
argument_list|>
name|oneRowWithConstant
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|oneRowWithConstant
operator|.
name|addAll
argument_list|(
name|posToConstant
operator|.
name|values
argument_list|()
argument_list|)
expr_stmt|;
name|oneRowWithConstant
operator|.
name|addAll
argument_list|(
name|oneRow
argument_list|)
expr_stmt|;
name|allRows
operator|.
name|add
argument_list|(
name|oneRowWithConstant
argument_list|)
expr_stmt|;
for|for
control|(
name|ColumnInfo
name|colInfo
range|:
name|cgbyOp
operator|.
name|getSchema
argument_list|()
operator|.
name|getSignature
argument_list|()
control|)
block|{
name|colNames
operator|.
name|add
argument_list|(
name|colInfo
operator|.
name|getInternalName
argument_list|()
argument_list|)
expr_stmt|;
name|ois
operator|.
name|add
argument_list|(
name|TypeInfoUtils
operator|.
name|getStandardJavaObjectInspectorFromTypeInfo
argument_list|(
name|colInfo
operator|.
name|getType
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// in return path, we may have aggr($f0), aggr($f1) in GBY
comment|// and then select aggr($f1), aggr($f0) in SEL.
comment|// Thus we need to use colExp to find out which position is
comment|// corresponding to which position.
name|Map
argument_list|<
name|String
argument_list|,
name|Integer
argument_list|>
name|nameToIndex
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|index
init|=
literal|0
init|;
name|index
operator|<
name|cgbyOp
operator|.
name|getConf
argument_list|()
operator|.
name|getOutputColumnNames
argument_list|()
operator|.
name|size
argument_list|()
condition|;
name|index
operator|++
control|)
block|{
name|nameToIndex
operator|.
name|put
argument_list|(
name|cgbyOp
operator|.
name|getConf
argument_list|()
operator|.
name|getOutputColumnNames
argument_list|()
operator|.
name|get
argument_list|(
name|index
argument_list|)
argument_list|,
name|index
argument_list|)
expr_stmt|;
block|}
name|List
argument_list|<
name|String
argument_list|>
name|outputColumnNames
init|=
name|cselOp
operator|.
name|getConf
argument_list|()
operator|.
name|getOutputColumnNames
argument_list|()
decl_stmt|;
name|Map
argument_list|<
name|Integer
argument_list|,
name|Integer
argument_list|>
name|cselOpTocgbyOp
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|index
init|=
literal|0
init|;
name|index
operator|<
name|outputColumnNames
operator|.
name|size
argument_list|()
condition|;
name|index
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|posToConstant
operator|.
name|containsKey
argument_list|(
name|index
argument_list|)
condition|)
block|{
name|String
name|outputColumnName
init|=
name|outputColumnNames
operator|.
name|get
argument_list|(
name|index
argument_list|)
decl_stmt|;
name|ExprNodeColumnDesc
name|exprColumnNodeDesc
init|=
operator|(
name|ExprNodeColumnDesc
operator|)
name|cselOp
operator|.
name|getColumnExprMap
argument_list|()
operator|.
name|get
argument_list|(
name|outputColumnName
argument_list|)
decl_stmt|;
name|cselOpTocgbyOp
operator|.
name|put
argument_list|(
name|index
argument_list|,
name|nameToIndex
operator|.
name|get
argument_list|(
name|exprColumnNodeDesc
operator|.
name|getColumn
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|List
argument_list|<
name|Object
argument_list|>
name|oneRowWithConstant
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|pos
init|=
literal|0
init|;
name|pos
operator|<
name|cselOp
operator|.
name|getSchema
argument_list|()
operator|.
name|getSignature
argument_list|()
operator|.
name|size
argument_list|()
condition|;
name|pos
operator|++
control|)
block|{
if|if
condition|(
name|posToConstant
operator|.
name|containsKey
argument_list|(
name|pos
argument_list|)
condition|)
block|{
comment|// This position is a constant.
name|oneRowWithConstant
operator|.
name|add
argument_list|(
name|posToConstant
operator|.
name|get
argument_list|(
name|pos
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// This position is an aggregation.
comment|// As we store in oneRow only the aggregate results, we need to adjust to the correct position
comment|// if there are keys in the GBy operator.
name|oneRowWithConstant
operator|.
name|add
argument_list|(
name|oneRow
operator|.
name|get
argument_list|(
name|cselOpTocgbyOp
operator|.
name|get
argument_list|(
name|pos
argument_list|)
operator|-
name|cgbyOp
operator|.
name|getConf
argument_list|()
operator|.
name|getKeys
argument_list|()
operator|.
name|size
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|ColumnInfo
name|colInfo
init|=
name|cselOp
operator|.
name|getSchema
argument_list|()
operator|.
name|getSignature
argument_list|()
operator|.
name|get
argument_list|(
name|pos
argument_list|)
decl_stmt|;
name|colNames
operator|.
name|add
argument_list|(
name|colInfo
operator|.
name|getInternalName
argument_list|()
argument_list|)
expr_stmt|;
name|ois
operator|.
name|add
argument_list|(
name|TypeInfoUtils
operator|.
name|getStandardJavaObjectInspectorFromTypeInfo
argument_list|(
name|colInfo
operator|.
name|getType
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|allRows
operator|.
name|add
argument_list|(
name|oneRowWithConstant
argument_list|)
expr_stmt|;
block|}
name|FetchWork
name|fWork
init|=
literal|null
decl_stmt|;
name|FetchTask
name|fTask
init|=
name|pctx
operator|.
name|getFetchTask
argument_list|()
decl_stmt|;
if|if
condition|(
name|fTask
operator|!=
literal|null
condition|)
block|{
name|fWork
operator|=
name|fTask
operator|.
name|getWork
argument_list|()
expr_stmt|;
name|fWork
operator|.
name|getRowsComputedUsingStats
argument_list|()
operator|.
name|addAll
argument_list|(
name|allRows
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|StandardStructObjectInspector
name|sOI
init|=
name|ObjectInspectorFactory
operator|.
name|getStandardStructObjectInspector
argument_list|(
name|colNames
argument_list|,
name|ois
argument_list|)
decl_stmt|;
name|fWork
operator|=
operator|new
name|FetchWork
argument_list|(
name|allRows
argument_list|,
name|sOI
argument_list|)
expr_stmt|;
name|fTask
operator|=
operator|(
name|FetchTask
operator|)
name|TaskFactory
operator|.
name|get
argument_list|(
name|fWork
argument_list|)
expr_stmt|;
name|pctx
operator|.
name|setFetchTask
argument_list|(
name|fTask
argument_list|)
expr_stmt|;
block|}
name|fWork
operator|.
name|setLimit
argument_list|(
name|fWork
operator|.
name|getRowsComputedUsingStats
argument_list|()
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|isOptimized
operator|=
literal|true
expr_stmt|;
return|return
literal|null
return|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
comment|// this is best effort optimization, bail out in error conditions and
comment|// try generate and execute slower plan
name|Logger
operator|.
name|debug
argument_list|(
literal|"Failed to optimize using metadata optimizer"
argument_list|,
name|e
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
finally|finally
block|{
comment|// If StatOptimization is not applied for any reason, the FetchTask should still not have been set
if|if
condition|(
operator|!
name|isOptimized
condition|)
block|{
name|soProcCtx
operator|.
name|stopProcess
operator|=
literal|true
expr_stmt|;
name|pctx
operator|.
name|setFetchTask
argument_list|(
literal|null
argument_list|)
expr_stmt|;
block|}
block|}
block|}
specifier|private
name|ColumnStatisticsData
name|validateSingleColStat
parameter_list|(
name|List
argument_list|<
name|ColumnStatisticsObj
argument_list|>
name|statObj
parameter_list|)
block|{
if|if
condition|(
name|statObj
operator|.
name|size
argument_list|()
operator|>
literal|1
condition|)
block|{
name|Logger
operator|.
name|error
argument_list|(
literal|"More than one stat for a single column!"
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
elseif|else
if|if
condition|(
name|statObj
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|Logger
operator|.
name|debug
argument_list|(
literal|"No stats for some partition and column"
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
return|return
name|statObj
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|getStatsData
argument_list|()
return|;
block|}
specifier|private
name|Collection
argument_list|<
name|List
argument_list|<
name|ColumnStatisticsObj
argument_list|>
argument_list|>
name|verifyAndGetPartColumnStats
parameter_list|(
name|Hive
name|hive
parameter_list|,
name|Table
name|tbl
parameter_list|,
name|String
name|colName
parameter_list|,
name|Set
argument_list|<
name|Partition
argument_list|>
name|parts
parameter_list|)
throws|throws
name|TException
block|{
name|List
argument_list|<
name|String
argument_list|>
name|partNames
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|(
name|parts
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|Partition
name|part
range|:
name|parts
control|)
block|{
if|if
condition|(
operator|!
name|StatsSetupConst
operator|.
name|areColumnStatsUptoDate
argument_list|(
name|part
operator|.
name|getParameters
argument_list|()
argument_list|,
name|colName
argument_list|)
condition|)
block|{
name|Logger
operator|.
name|debug
argument_list|(
literal|"Stats for part : "
operator|+
name|part
operator|.
name|getSpec
argument_list|()
operator|+
literal|" column "
operator|+
name|colName
operator|+
literal|" are not up to date."
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
name|partNames
operator|.
name|add
argument_list|(
name|part
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|Map
argument_list|<
name|String
argument_list|,
name|List
argument_list|<
name|ColumnStatisticsObj
argument_list|>
argument_list|>
name|result
init|=
name|hive
operator|.
name|getMSC
argument_list|()
operator|.
name|getPartitionColumnStatistics
argument_list|(
name|tbl
operator|.
name|getDbName
argument_list|()
argument_list|,
name|tbl
operator|.
name|getTableName
argument_list|()
argument_list|,
name|partNames
argument_list|,
name|Lists
operator|.
name|newArrayList
argument_list|(
name|colName
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|result
operator|.
name|size
argument_list|()
operator|!=
name|parts
operator|.
name|size
argument_list|()
condition|)
block|{
name|Logger
operator|.
name|debug
argument_list|(
literal|"Received "
operator|+
name|result
operator|.
name|size
argument_list|()
operator|+
literal|" stats for "
operator|+
name|parts
operator|.
name|size
argument_list|()
operator|+
literal|" partitions"
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
return|return
name|result
operator|.
name|values
argument_list|()
return|;
block|}
specifier|private
name|Long
name|getRowCnt
parameter_list|(
name|ParseContext
name|pCtx
parameter_list|,
name|TableScanOperator
name|tsOp
parameter_list|,
name|Table
name|tbl
parameter_list|)
throws|throws
name|HiveException
block|{
name|Long
name|rowCnt
init|=
literal|0L
decl_stmt|;
if|if
condition|(
name|tbl
operator|.
name|isPartitioned
argument_list|()
condition|)
block|{
for|for
control|(
name|Partition
name|part
range|:
name|pctx
operator|.
name|getPrunedPartitions
argument_list|(
name|tsOp
operator|.
name|getConf
argument_list|()
operator|.
name|getAlias
argument_list|()
argument_list|,
name|tsOp
argument_list|)
operator|.
name|getPartitions
argument_list|()
control|)
block|{
if|if
condition|(
operator|!
name|StatsSetupConst
operator|.
name|areBasicStatsUptoDate
argument_list|(
name|part
operator|.
name|getParameters
argument_list|()
argument_list|)
condition|)
block|{
return|return
literal|null
return|;
block|}
name|Long
name|partRowCnt
init|=
name|Long
operator|.
name|parseLong
argument_list|(
name|part
operator|.
name|getParameters
argument_list|()
operator|.
name|get
argument_list|(
name|StatsSetupConst
operator|.
name|ROW_COUNT
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|partRowCnt
operator|==
literal|null
condition|)
block|{
name|Logger
operator|.
name|debug
argument_list|(
literal|"Partition doesn't have up to date stats "
operator|+
name|part
operator|.
name|getSpec
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
name|rowCnt
operator|+=
name|partRowCnt
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// unpartitioned table
if|if
condition|(
operator|!
name|StatsSetupConst
operator|.
name|areBasicStatsUptoDate
argument_list|(
name|tbl
operator|.
name|getParameters
argument_list|()
argument_list|)
condition|)
block|{
return|return
literal|null
return|;
block|}
name|rowCnt
operator|=
name|Long
operator|.
name|parseLong
argument_list|(
name|tbl
operator|.
name|getProperty
argument_list|(
name|StatsSetupConst
operator|.
name|ROW_COUNT
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|rowCnt
operator|==
literal|null
condition|)
block|{
comment|// if rowCnt< 1 than its either empty table or table on which stats are not
comment|//  computed We assume the worse and don't attempt to optimize.
name|Logger
operator|.
name|debug
argument_list|(
literal|"Table doesn't have up to date stats "
operator|+
name|tbl
operator|.
name|getTableName
argument_list|()
argument_list|)
expr_stmt|;
name|rowCnt
operator|=
literal|null
expr_stmt|;
block|}
block|}
return|return
name|rowCnt
return|;
block|}
block|}
block|}
end_class

end_unit

