begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*   Licensed to the Apache Software Foundation (ASF) under one   or more contributor license agreements.  See the NOTICE file   distributed with this work for additional information   regarding copyright ownership.  The ASF licenses this file   to you under the Apache License, Version 2.0 (the   "License"); you may not use this file except in compliance   with the License.  You may obtain a copy of the License at        http://www.apache.org/licenses/LICENSE-2.0    Unless required by applicable law or agreed to in writing, software   distributed under the License is distributed on an "AS IS" BASIS,   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.   See the License for the specific language governing permissions and   limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|parse
package|;
end_package

begin_import
import|import
name|org
operator|.
name|antlr
operator|.
name|runtime
operator|.
name|tree
operator|.
name|Tree
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|lang3
operator|.
name|StringUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FileStatus
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FileSystem
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|Path
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|conf
operator|.
name|HiveConf
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|metastore
operator|.
name|api
operator|.
name|Database
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|ErrorMsg
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|QueryState
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|Task
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|TaskFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|repl
operator|.
name|ReplDumpWork
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|repl
operator|.
name|ReplStateLogWork
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|repl
operator|.
name|bootstrap
operator|.
name|ReplLoadWork
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|hooks
operator|.
name|ReadEntity
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|metadata
operator|.
name|HiveException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|metadata
operator|.
name|Table
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|parse
operator|.
name|repl
operator|.
name|dump
operator|.
name|Utils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|parse
operator|.
name|repl
operator|.
name|load
operator|.
name|DumpMetaData
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|parse
operator|.
name|repl
operator|.
name|load
operator|.
name|EventDumpDirComparator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|parse
operator|.
name|repl
operator|.
name|load
operator|.
name|UpdatedMetaDataTracker
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|parse
operator|.
name|repl
operator|.
name|load
operator|.
name|message
operator|.
name|MessageHandler
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|parse
operator|.
name|repl
operator|.
name|load
operator|.
name|log
operator|.
name|IncrementalLoadLogger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|parse
operator|.
name|repl
operator|.
name|ReplLogger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|AlterDatabaseDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|AlterTableDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|DDLWork
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|DependencyCollectionWork
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|PlanUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|session
operator|.
name|SessionState
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|FileNotFoundException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|Serializable
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|parse
operator|.
name|HiveParser
operator|.
name|TOK_DBNAME
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|parse
operator|.
name|HiveParser
operator|.
name|TOK_FROM
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|parse
operator|.
name|HiveParser
operator|.
name|TOK_LIMIT
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|parse
operator|.
name|HiveParser
operator|.
name|TOK_REPL_CONFIG
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|parse
operator|.
name|HiveParser
operator|.
name|TOK_REPL_DUMP
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|parse
operator|.
name|HiveParser
operator|.
name|TOK_REPL_LOAD
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|parse
operator|.
name|HiveParser
operator|.
name|TOK_REPL_STATUS
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|parse
operator|.
name|HiveParser
operator|.
name|TOK_TABNAME
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|parse
operator|.
name|HiveParser
operator|.
name|TOK_TO
import|;
end_import

begin_class
specifier|public
class|class
name|ReplicationSemanticAnalyzer
extends|extends
name|BaseSemanticAnalyzer
block|{
comment|// Database name or pattern
specifier|private
name|String
name|dbNameOrPattern
decl_stmt|;
comment|// Table name or pattern
specifier|private
name|String
name|tblNameOrPattern
decl_stmt|;
specifier|private
name|Long
name|eventFrom
decl_stmt|;
specifier|private
name|Long
name|eventTo
decl_stmt|;
specifier|private
name|Integer
name|maxEventLimit
decl_stmt|;
comment|// Base path for REPL LOAD
specifier|private
name|String
name|path
decl_stmt|;
comment|// Added conf member to set the REPL command specific config entries without affecting the configs
comment|// of any other queries running in the session
specifier|private
name|HiveConf
name|conf
decl_stmt|;
specifier|private
specifier|static
name|String
name|testInjectDumpDir
init|=
literal|null
decl_stmt|;
comment|// unit tests can overwrite this to affect default dump behaviour
specifier|private
specifier|static
specifier|final
name|String
name|dumpSchema
init|=
literal|"dump_dir,last_repl_id#string,string"
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|String
name|FUNCTIONS_ROOT_DIR_NAME
init|=
literal|"_functions"
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|String
name|CONSTRAINTS_ROOT_DIR_NAME
init|=
literal|"_constraints"
decl_stmt|;
name|ReplicationSemanticAnalyzer
parameter_list|(
name|QueryState
name|queryState
parameter_list|)
throws|throws
name|SemanticException
block|{
name|super
argument_list|(
name|queryState
argument_list|)
expr_stmt|;
name|this
operator|.
name|conf
operator|=
operator|new
name|HiveConf
argument_list|(
name|super
operator|.
name|conf
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|analyzeInternal
parameter_list|(
name|ASTNode
name|ast
parameter_list|)
throws|throws
name|SemanticException
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"ReplicationSemanticAanalyzer: analyzeInternal"
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
name|ast
operator|.
name|getName
argument_list|()
operator|+
literal|":"
operator|+
name|ast
operator|.
name|getToken
argument_list|()
operator|.
name|getText
argument_list|()
operator|+
literal|"="
operator|+
name|ast
operator|.
name|getText
argument_list|()
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|ast
operator|.
name|getToken
argument_list|()
operator|.
name|getType
argument_list|()
condition|)
block|{
case|case
name|TOK_REPL_DUMP
case|:
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"ReplicationSemanticAnalyzer: analyzeInternal: dump"
argument_list|)
expr_stmt|;
name|initReplDump
argument_list|(
name|ast
argument_list|)
expr_stmt|;
name|analyzeReplDump
argument_list|(
name|ast
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|TOK_REPL_LOAD
case|:
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"ReplicationSemanticAnalyzer: analyzeInternal: load"
argument_list|)
expr_stmt|;
name|initReplLoad
argument_list|(
name|ast
argument_list|)
expr_stmt|;
name|analyzeReplLoad
argument_list|(
name|ast
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|TOK_REPL_STATUS
case|:
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"ReplicationSemanticAnalyzer: analyzeInternal: status"
argument_list|)
expr_stmt|;
name|initReplStatus
argument_list|(
name|ast
argument_list|)
expr_stmt|;
name|analyzeReplStatus
argument_list|(
name|ast
argument_list|)
expr_stmt|;
break|break;
block|}
default|default:
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
literal|"Unexpected root token"
argument_list|)
throw|;
block|}
block|}
block|}
specifier|private
name|void
name|initReplDump
parameter_list|(
name|ASTNode
name|ast
parameter_list|)
block|{
name|int
name|numChildren
init|=
name|ast
operator|.
name|getChildCount
argument_list|()
decl_stmt|;
name|dbNameOrPattern
operator|=
name|PlanUtils
operator|.
name|stripQuotes
argument_list|(
name|ast
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getText
argument_list|()
argument_list|)
expr_stmt|;
comment|// skip the first node, which is always required
name|int
name|currNode
init|=
literal|1
decl_stmt|;
while|while
condition|(
name|currNode
operator|<
name|numChildren
condition|)
block|{
if|if
condition|(
name|ast
operator|.
name|getChild
argument_list|(
name|currNode
argument_list|)
operator|.
name|getType
argument_list|()
operator|!=
name|TOK_FROM
condition|)
block|{
comment|// optional tblName was specified.
name|tblNameOrPattern
operator|=
name|PlanUtils
operator|.
name|stripQuotes
argument_list|(
name|ast
operator|.
name|getChild
argument_list|(
name|currNode
argument_list|)
operator|.
name|getText
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// TOK_FROM subtree
name|Tree
name|fromNode
init|=
name|ast
operator|.
name|getChild
argument_list|(
name|currNode
argument_list|)
decl_stmt|;
name|eventFrom
operator|=
name|Long
operator|.
name|parseLong
argument_list|(
name|PlanUtils
operator|.
name|stripQuotes
argument_list|(
name|fromNode
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getText
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
comment|// skip the first, which is always required
name|int
name|numChild
init|=
literal|1
decl_stmt|;
while|while
condition|(
name|numChild
operator|<
name|fromNode
operator|.
name|getChildCount
argument_list|()
condition|)
block|{
if|if
condition|(
name|fromNode
operator|.
name|getChild
argument_list|(
name|numChild
argument_list|)
operator|.
name|getType
argument_list|()
operator|==
name|TOK_TO
condition|)
block|{
name|eventTo
operator|=
name|Long
operator|.
name|parseLong
argument_list|(
name|PlanUtils
operator|.
name|stripQuotes
argument_list|(
name|fromNode
operator|.
name|getChild
argument_list|(
name|numChild
operator|+
literal|1
argument_list|)
operator|.
name|getText
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
comment|// skip the next child, since we already took care of it
name|numChild
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fromNode
operator|.
name|getChild
argument_list|(
name|numChild
argument_list|)
operator|.
name|getType
argument_list|()
operator|==
name|TOK_LIMIT
condition|)
block|{
name|maxEventLimit
operator|=
name|Integer
operator|.
name|parseInt
argument_list|(
name|PlanUtils
operator|.
name|stripQuotes
argument_list|(
name|fromNode
operator|.
name|getChild
argument_list|(
name|numChild
operator|+
literal|1
argument_list|)
operator|.
name|getText
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
comment|// skip the next child, since we already took care of it
name|numChild
operator|++
expr_stmt|;
block|}
comment|// move to the next child in FROM tree
name|numChild
operator|++
expr_stmt|;
block|}
comment|// FROM node is always the last
break|break;
block|}
comment|// move to the next root node
name|currNode
operator|++
expr_stmt|;
block|}
block|}
comment|// REPL DUMP
specifier|private
name|void
name|analyzeReplDump
parameter_list|(
name|ASTNode
name|ast
parameter_list|)
throws|throws
name|SemanticException
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"ReplicationSemanticAnalyzer.analyzeReplDump: "
operator|+
name|String
operator|.
name|valueOf
argument_list|(
name|dbNameOrPattern
argument_list|)
operator|+
literal|"."
operator|+
name|String
operator|.
name|valueOf
argument_list|(
name|tblNameOrPattern
argument_list|)
operator|+
literal|" from "
operator|+
name|String
operator|.
name|valueOf
argument_list|(
name|eventFrom
argument_list|)
operator|+
literal|" to "
operator|+
name|String
operator|.
name|valueOf
argument_list|(
name|eventTo
argument_list|)
operator|+
literal|" maxEventLimit "
operator|+
name|String
operator|.
name|valueOf
argument_list|(
name|maxEventLimit
argument_list|)
argument_list|)
expr_stmt|;
try|try
block|{
name|ctx
operator|.
name|setResFile
argument_list|(
name|ctx
operator|.
name|getLocalTmpPath
argument_list|()
argument_list|)
expr_stmt|;
name|Task
argument_list|<
name|ReplDumpWork
argument_list|>
name|replDumpWorkTask
init|=
name|TaskFactory
operator|.
name|get
argument_list|(
operator|new
name|ReplDumpWork
argument_list|(
name|dbNameOrPattern
argument_list|,
name|tblNameOrPattern
argument_list|,
name|eventFrom
argument_list|,
name|eventTo
argument_list|,
name|ErrorMsg
operator|.
name|INVALID_PATH
operator|.
name|getMsg
argument_list|(
name|ast
argument_list|)
argument_list|,
name|maxEventLimit
argument_list|,
name|ctx
operator|.
name|getResFile
argument_list|()
operator|.
name|toUri
argument_list|()
operator|.
name|toString
argument_list|()
argument_list|)
argument_list|,
name|conf
argument_list|)
decl_stmt|;
name|rootTasks
operator|.
name|add
argument_list|(
name|replDumpWorkTask
argument_list|)
expr_stmt|;
if|if
condition|(
name|dbNameOrPattern
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|String
name|dbName
range|:
name|Utils
operator|.
name|matchesDb
argument_list|(
name|db
argument_list|,
name|dbNameOrPattern
argument_list|)
control|)
block|{
if|if
condition|(
name|tblNameOrPattern
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|String
name|tblName
range|:
name|Utils
operator|.
name|matchesTbl
argument_list|(
name|db
argument_list|,
name|dbName
argument_list|,
name|tblNameOrPattern
argument_list|)
control|)
block|{
name|inputs
operator|.
name|add
argument_list|(
operator|new
name|ReadEntity
argument_list|(
name|db
operator|.
name|getTable
argument_list|(
name|dbName
argument_list|,
name|tblName
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|inputs
operator|.
name|add
argument_list|(
operator|new
name|ReadEntity
argument_list|(
name|db
operator|.
name|getDatabase
argument_list|(
name|dbName
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|setFetchTask
argument_list|(
name|createFetchTask
argument_list|(
name|dumpSchema
argument_list|)
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
comment|// TODO : simple wrap& rethrow for now, clean up with error codes
name|LOG
operator|.
name|warn
argument_list|(
literal|"Error during analyzeReplDump"
argument_list|,
name|e
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|SemanticException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
comment|// REPL LOAD
specifier|private
name|void
name|initReplLoad
parameter_list|(
name|ASTNode
name|ast
parameter_list|)
throws|throws
name|SemanticException
block|{
name|path
operator|=
name|PlanUtils
operator|.
name|stripQuotes
argument_list|(
name|ast
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getText
argument_list|()
argument_list|)
expr_stmt|;
name|int
name|numChildren
init|=
name|ast
operator|.
name|getChildCount
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<
name|numChildren
condition|;
name|i
operator|++
control|)
block|{
name|ASTNode
name|childNode
init|=
operator|(
name|ASTNode
operator|)
name|ast
operator|.
name|getChild
argument_list|(
name|i
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|childNode
operator|.
name|getToken
argument_list|()
operator|.
name|getType
argument_list|()
condition|)
block|{
case|case
name|TOK_DBNAME
case|:
name|dbNameOrPattern
operator|=
name|PlanUtils
operator|.
name|stripQuotes
argument_list|(
name|childNode
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getText
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|TOK_TABNAME
case|:
name|tblNameOrPattern
operator|=
name|PlanUtils
operator|.
name|stripQuotes
argument_list|(
name|childNode
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getText
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|TOK_REPL_CONFIG
case|:
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|replConfigs
init|=
name|DDLSemanticAnalyzer
operator|.
name|getProps
argument_list|(
operator|(
name|ASTNode
operator|)
name|childNode
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
literal|null
operator|!=
name|replConfigs
condition|)
block|{
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|config
range|:
name|replConfigs
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|conf
operator|.
name|set
argument_list|(
name|config
operator|.
name|getKey
argument_list|()
argument_list|,
name|config
operator|.
name|getValue
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
default|default:
throw|throw
operator|new
name|SemanticException
argument_list|(
literal|"Unrecognized token in REPL LOAD statement"
argument_list|)
throw|;
block|}
block|}
block|}
comment|/*    * Example dump dirs we need to be able to handle :    *    * for: hive.repl.rootdir = staging/    * Then, repl dumps will be created in staging/<dumpdir>    *    * single-db-dump: staging/blah12345 will contain a db dir for the db specified    *  blah12345/    *   default/    *    _metadata    *    tbl1/    *      _metadata    *      dt=20160907/    *        _files    *    tbl2/    *    tbl3/    *    unptn_tbl/    *      _metadata    *      _files    *    * multi-db-dump: staging/bar12347 will contain dirs for each db covered    * staging/    *  bar12347/    *   default/    *     ...    *   sales/    *     ...    *    * single table-dump: staging/baz123 will contain a table object dump inside    * staging/    *  baz123/    *    _metadata    *    dt=20150931/    *      _files    *    * incremental dump : staging/blue123 will contain dirs for each event inside.    * staging/    *  blue123/    *    34/    *    35/    *    36/    */
specifier|private
name|void
name|analyzeReplLoad
parameter_list|(
name|ASTNode
name|ast
parameter_list|)
throws|throws
name|SemanticException
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"ReplSemanticAnalyzer.analyzeReplLoad: "
operator|+
name|String
operator|.
name|valueOf
argument_list|(
name|dbNameOrPattern
argument_list|)
operator|+
literal|"."
operator|+
name|String
operator|.
name|valueOf
argument_list|(
name|tblNameOrPattern
argument_list|)
operator|+
literal|" from "
operator|+
name|String
operator|.
name|valueOf
argument_list|(
name|path
argument_list|)
argument_list|)
expr_stmt|;
comment|// for analyze repl load, we walk through the dir structure available in the path,
comment|// looking at each db, and then each table, and then setting up the appropriate
comment|// import job in its place.
try|try
block|{
name|Path
name|loadPath
init|=
operator|new
name|Path
argument_list|(
name|path
argument_list|)
decl_stmt|;
specifier|final
name|FileSystem
name|fs
init|=
name|loadPath
operator|.
name|getFileSystem
argument_list|(
name|conf
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|fs
operator|.
name|exists
argument_list|(
name|loadPath
argument_list|)
condition|)
block|{
comment|// supposed dump path does not exist.
throw|throw
operator|new
name|FileNotFoundException
argument_list|(
name|loadPath
operator|.
name|toUri
argument_list|()
operator|.
name|toString
argument_list|()
argument_list|)
throw|;
block|}
comment|// Now, the dumped path can be one of three things:
comment|// a) It can be a db dump, in which case we expect a set of dirs, each with a
comment|// db name, and with a _metadata file in each, and table dirs inside that.
comment|// b) It can be a table dump dir, in which case we expect a _metadata dump of
comment|// a table in question in the dir, and individual ptn dir hierarchy.
comment|// c) A dump can be an incremental dump, which means we have several subdirs
comment|// each of which have the evid as the dir name, and each of which correspond
comment|// to a event-level dump. Currently, only CREATE_TABLE and ADD_PARTITION are
comment|// handled, so all of these dumps will be at a table/ptn level.
comment|// For incremental repl, we will have individual events which can
comment|// be other things like roles and fns as well.
comment|// At this point, all dump dirs should contain a _dumpmetadata file that
comment|// tells us what is inside that dumpdir.
name|DumpMetaData
name|dmd
init|=
operator|new
name|DumpMetaData
argument_list|(
name|loadPath
argument_list|,
name|conf
argument_list|)
decl_stmt|;
name|boolean
name|evDump
init|=
literal|false
decl_stmt|;
if|if
condition|(
name|dmd
operator|.
name|isIncrementalDump
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"{} contains an incremental dump"
argument_list|,
name|loadPath
argument_list|)
expr_stmt|;
name|evDump
operator|=
literal|true
expr_stmt|;
block|}
else|else
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"{} contains an bootstrap dump"
argument_list|,
name|loadPath
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
operator|!
name|evDump
operator|)
operator|&&
operator|(
name|tblNameOrPattern
operator|!=
literal|null
operator|)
operator|&&
operator|!
operator|(
name|tblNameOrPattern
operator|.
name|isEmpty
argument_list|()
operator|)
condition|)
block|{
name|ReplLoadWork
name|replLoadWork
init|=
operator|new
name|ReplLoadWork
argument_list|(
name|conf
argument_list|,
name|loadPath
operator|.
name|toString
argument_list|()
argument_list|,
name|dbNameOrPattern
argument_list|,
name|tblNameOrPattern
argument_list|,
name|SessionState
operator|.
name|get
argument_list|()
operator|.
name|getLineageState
argument_list|()
argument_list|,
name|SessionState
operator|.
name|get
argument_list|()
operator|.
name|getTxnMgr
argument_list|()
operator|.
name|getCurrentTxnId
argument_list|()
argument_list|)
decl_stmt|;
name|rootTasks
operator|.
name|add
argument_list|(
name|TaskFactory
operator|.
name|get
argument_list|(
name|replLoadWork
argument_list|,
name|conf
argument_list|,
literal|true
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|FileStatus
index|[]
name|srcs
init|=
name|LoadSemanticAnalyzer
operator|.
name|matchFilesOrDir
argument_list|(
name|fs
argument_list|,
name|loadPath
argument_list|)
decl_stmt|;
if|if
condition|(
name|srcs
operator|==
literal|null
operator|||
operator|(
name|srcs
operator|.
name|length
operator|==
literal|0
operator|)
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Nothing to load at {}"
argument_list|,
name|loadPath
operator|.
name|toUri
argument_list|()
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
return|return;
block|}
name|FileStatus
index|[]
name|dirsInLoadPath
init|=
name|fs
operator|.
name|listStatus
argument_list|(
name|loadPath
argument_list|,
name|EximUtil
operator|.
name|getDirectoryFilter
argument_list|(
name|fs
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|dirsInLoadPath
operator|==
literal|null
operator|)
operator|||
operator|(
name|dirsInLoadPath
operator|.
name|length
operator|==
literal|0
operator|)
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"No data to load in path "
operator|+
name|loadPath
operator|.
name|toUri
argument_list|()
operator|.
name|toString
argument_list|()
argument_list|)
throw|;
block|}
if|if
condition|(
operator|!
name|evDump
condition|)
block|{
comment|// not an event dump, not a table dump - thus, a db dump
if|if
condition|(
operator|(
name|dbNameOrPattern
operator|!=
literal|null
operator|)
operator|&&
operator|(
name|dirsInLoadPath
operator|.
name|length
operator|>
literal|1
operator|)
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Found multiple dirs when we expected 1:"
argument_list|)
expr_stmt|;
for|for
control|(
name|FileStatus
name|d
range|:
name|dirsInLoadPath
control|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"> "
operator|+
name|d
operator|.
name|getPath
argument_list|()
operator|.
name|toUri
argument_list|()
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Multiple dirs in "
operator|+
name|loadPath
operator|.
name|toUri
argument_list|()
operator|.
name|toString
argument_list|()
operator|+
literal|" does not correspond to REPL LOAD expecting to load to a singular destination point."
argument_list|)
throw|;
block|}
name|ReplLoadWork
name|replLoadWork
init|=
operator|new
name|ReplLoadWork
argument_list|(
name|conf
argument_list|,
name|loadPath
operator|.
name|toString
argument_list|()
argument_list|,
name|dbNameOrPattern
argument_list|,
name|SessionState
operator|.
name|get
argument_list|()
operator|.
name|getLineageState
argument_list|()
argument_list|,
name|SessionState
operator|.
name|get
argument_list|()
operator|.
name|getTxnMgr
argument_list|()
operator|.
name|getCurrentTxnId
argument_list|()
argument_list|)
decl_stmt|;
name|rootTasks
operator|.
name|add
argument_list|(
name|TaskFactory
operator|.
name|get
argument_list|(
name|replLoadWork
argument_list|,
name|conf
argument_list|,
literal|true
argument_list|)
argument_list|)
expr_stmt|;
comment|//
comment|//        for (FileStatus dir : dirsInLoadPath) {
comment|//          analyzeDatabaseLoad(dbNameOrPattern, fs, dir);
comment|//        }
block|}
else|else
block|{
comment|// Event dump, each sub-dir is an individual event dump.
comment|// We need to guarantee that the directory listing we got is in order of evid.
name|Arrays
operator|.
name|sort
argument_list|(
name|dirsInLoadPath
argument_list|,
operator|new
name|EventDumpDirComparator
argument_list|()
argument_list|)
expr_stmt|;
name|Task
argument_list|<
name|?
extends|extends
name|Serializable
argument_list|>
name|evTaskRoot
init|=
name|TaskFactory
operator|.
name|get
argument_list|(
operator|new
name|DependencyCollectionWork
argument_list|()
argument_list|,
name|conf
argument_list|)
decl_stmt|;
name|Task
argument_list|<
name|?
extends|extends
name|Serializable
argument_list|>
name|taskChainTail
init|=
name|evTaskRoot
decl_stmt|;
name|ReplLogger
name|replLogger
init|=
operator|new
name|IncrementalLoadLogger
argument_list|(
name|dbNameOrPattern
argument_list|,
name|loadPath
operator|.
name|toString
argument_list|()
argument_list|,
name|dirsInLoadPath
operator|.
name|length
argument_list|)
decl_stmt|;
for|for
control|(
name|FileStatus
name|dir
range|:
name|dirsInLoadPath
control|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Loading event from {} to {}.{}"
argument_list|,
name|dir
operator|.
name|getPath
argument_list|()
operator|.
name|toUri
argument_list|()
argument_list|,
name|dbNameOrPattern
argument_list|,
name|tblNameOrPattern
argument_list|)
expr_stmt|;
comment|// event loads will behave similar to table loads, with one crucial difference
comment|// precursor order is strict, and each event must be processed after the previous one.
comment|// The way we handle this strict order is as follows:
comment|// First, we start with a taskChainTail which is a dummy noop task (a DependecyCollectionTask)
comment|// at the head of our event chain. For each event we process, we tell analyzeTableLoad to
comment|// create tasks that use the taskChainTail as a dependency. Then, we collect all those tasks
comment|// and introduce a new barrier task(also a DependencyCollectionTask) which depends on all
comment|// these tasks. Then, this barrier task becomes our new taskChainTail. Thus, we get a set of
comment|// tasks as follows:
comment|//
comment|//                 --->ev1.task1--                          --->ev2.task1--
comment|//                /               \                        /               \
comment|//  evTaskRoot-->*---->ev1.task2---*--> ev1.barrierTask-->*---->ev2.task2---*->evTaskChainTail
comment|//                \               /
comment|//                 --->ev1.task3--
comment|//
comment|// Once this entire chain is generated, we add evTaskRoot to rootTasks, so as to execute the
comment|// entire chain
name|String
name|locn
init|=
name|dir
operator|.
name|getPath
argument_list|()
operator|.
name|toUri
argument_list|()
operator|.
name|toString
argument_list|()
decl_stmt|;
name|DumpMetaData
name|eventDmd
init|=
operator|new
name|DumpMetaData
argument_list|(
operator|new
name|Path
argument_list|(
name|locn
argument_list|)
argument_list|,
name|conf
argument_list|)
decl_stmt|;
name|MessageHandler
operator|.
name|Context
name|context
init|=
operator|new
name|MessageHandler
operator|.
name|Context
argument_list|(
name|dbNameOrPattern
argument_list|,
name|tblNameOrPattern
argument_list|,
name|locn
argument_list|,
name|taskChainTail
argument_list|,
name|eventDmd
argument_list|,
name|conf
argument_list|,
name|db
argument_list|,
name|ctx
argument_list|,
name|LOG
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|Task
argument_list|<
name|?
extends|extends
name|Serializable
argument_list|>
argument_list|>
name|evTasks
init|=
name|analyzeEventLoad
argument_list|(
name|context
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|evTasks
operator|!=
literal|null
operator|)
operator|&&
operator|(
operator|!
name|evTasks
operator|.
name|isEmpty
argument_list|()
operator|)
condition|)
block|{
name|ReplStateLogWork
name|replStateLogWork
init|=
operator|new
name|ReplStateLogWork
argument_list|(
name|replLogger
argument_list|,
name|dir
operator|.
name|getPath
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|,
name|eventDmd
operator|.
name|getDumpType
argument_list|()
operator|.
name|toString
argument_list|()
argument_list|)
decl_stmt|;
name|Task
argument_list|<
name|?
extends|extends
name|Serializable
argument_list|>
name|barrierTask
init|=
name|TaskFactory
operator|.
name|get
argument_list|(
name|replStateLogWork
argument_list|,
name|conf
argument_list|)
decl_stmt|;
for|for
control|(
name|Task
argument_list|<
name|?
extends|extends
name|Serializable
argument_list|>
name|t
range|:
name|evTasks
control|)
block|{
name|t
operator|.
name|addDependentTask
argument_list|(
name|barrierTask
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Added {}:{} as a precursor of barrier task {}:{}"
argument_list|,
name|t
operator|.
name|getClass
argument_list|()
argument_list|,
name|t
operator|.
name|getId
argument_list|()
argument_list|,
name|barrierTask
operator|.
name|getClass
argument_list|()
argument_list|,
name|barrierTask
operator|.
name|getId
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|LOG
operator|.
name|debug
argument_list|(
literal|"Updated taskChainTail from {}:{} to {}:{}"
argument_list|,
name|taskChainTail
operator|.
name|getClass
argument_list|()
argument_list|,
name|taskChainTail
operator|.
name|getId
argument_list|()
argument_list|,
name|barrierTask
operator|.
name|getClass
argument_list|()
argument_list|,
name|barrierTask
operator|.
name|getId
argument_list|()
argument_list|)
expr_stmt|;
name|taskChainTail
operator|=
name|barrierTask
expr_stmt|;
block|}
block|}
comment|// If any event is there and db name is known, then dump the start and end logs
if|if
condition|(
operator|!
name|evTaskRoot
operator|.
name|equals
argument_list|(
name|taskChainTail
argument_list|)
condition|)
block|{
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|dbProps
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
name|dbProps
operator|.
name|put
argument_list|(
name|ReplicationSpec
operator|.
name|KEY
operator|.
name|CURR_STATE_ID
operator|.
name|toString
argument_list|()
argument_list|,
name|String
operator|.
name|valueOf
argument_list|(
name|dmd
operator|.
name|getEventTo
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|ReplStateLogWork
name|replStateLogWork
init|=
operator|new
name|ReplStateLogWork
argument_list|(
name|replLogger
argument_list|,
name|dbProps
argument_list|)
decl_stmt|;
name|Task
argument_list|<
name|?
extends|extends
name|Serializable
argument_list|>
name|barrierTask
init|=
name|TaskFactory
operator|.
name|get
argument_list|(
name|replStateLogWork
argument_list|,
name|conf
argument_list|)
decl_stmt|;
name|taskChainTail
operator|.
name|addDependentTask
argument_list|(
name|barrierTask
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Added {}:{} as a precursor of barrier task {}:{}"
argument_list|,
name|taskChainTail
operator|.
name|getClass
argument_list|()
argument_list|,
name|taskChainTail
operator|.
name|getId
argument_list|()
argument_list|,
name|barrierTask
operator|.
name|getClass
argument_list|()
argument_list|,
name|barrierTask
operator|.
name|getId
argument_list|()
argument_list|)
expr_stmt|;
name|replLogger
operator|.
name|startLog
argument_list|()
expr_stmt|;
block|}
name|rootTasks
operator|.
name|add
argument_list|(
name|evTaskRoot
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
comment|// TODO : simple wrap& rethrow for now, clean up with error codes
throw|throw
operator|new
name|SemanticException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
specifier|private
name|List
argument_list|<
name|Task
argument_list|<
name|?
extends|extends
name|Serializable
argument_list|>
argument_list|>
name|analyzeEventLoad
parameter_list|(
name|MessageHandler
operator|.
name|Context
name|context
parameter_list|)
throws|throws
name|SemanticException
block|{
name|MessageHandler
name|messageHandler
init|=
name|context
operator|.
name|dmd
operator|.
name|getDumpType
argument_list|()
operator|.
name|handler
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|Task
argument_list|<
name|?
extends|extends
name|Serializable
argument_list|>
argument_list|>
name|tasks
init|=
name|messageHandler
operator|.
name|handle
argument_list|(
name|context
argument_list|)
decl_stmt|;
if|if
condition|(
name|context
operator|.
name|precursor
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|Task
argument_list|<
name|?
extends|extends
name|Serializable
argument_list|>
name|t
range|:
name|tasks
control|)
block|{
name|context
operator|.
name|precursor
operator|.
name|addDependentTask
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Added {}:{} as a precursor of {}:{}"
argument_list|,
name|context
operator|.
name|precursor
operator|.
name|getClass
argument_list|()
argument_list|,
name|context
operator|.
name|precursor
operator|.
name|getId
argument_list|()
argument_list|,
name|t
operator|.
name|getClass
argument_list|()
argument_list|,
name|t
operator|.
name|getId
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
name|inputs
operator|.
name|addAll
argument_list|(
name|messageHandler
operator|.
name|readEntities
argument_list|()
argument_list|)
expr_stmt|;
name|outputs
operator|.
name|addAll
argument_list|(
name|messageHandler
operator|.
name|writeEntities
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|addUpdateReplStateTasks
argument_list|(
name|StringUtils
operator|.
name|isEmpty
argument_list|(
name|context
operator|.
name|tableName
argument_list|)
argument_list|,
name|messageHandler
operator|.
name|getUpdatedMetadata
argument_list|()
argument_list|,
name|tasks
argument_list|)
return|;
block|}
specifier|private
name|Task
argument_list|<
name|?
extends|extends
name|Serializable
argument_list|>
name|tableUpdateReplStateTask
parameter_list|(
name|String
name|dbName
parameter_list|,
name|String
name|tableName
parameter_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|partSpec
parameter_list|,
name|String
name|replState
parameter_list|,
name|Task
argument_list|<
name|?
extends|extends
name|Serializable
argument_list|>
name|preCursor
parameter_list|)
block|{
name|HashMap
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|mapProp
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
name|mapProp
operator|.
name|put
argument_list|(
name|ReplicationSpec
operator|.
name|KEY
operator|.
name|CURR_STATE_ID
operator|.
name|toString
argument_list|()
argument_list|,
name|replState
argument_list|)
expr_stmt|;
name|AlterTableDesc
name|alterTblDesc
init|=
operator|new
name|AlterTableDesc
argument_list|(
name|AlterTableDesc
operator|.
name|AlterTableTypes
operator|.
name|ADDPROPS
argument_list|,
operator|new
name|ReplicationSpec
argument_list|(
name|replState
argument_list|,
name|replState
argument_list|)
argument_list|)
decl_stmt|;
name|alterTblDesc
operator|.
name|setProps
argument_list|(
name|mapProp
argument_list|)
expr_stmt|;
name|alterTblDesc
operator|.
name|setOldName
argument_list|(
name|dbName
operator|+
literal|"."
operator|+
name|tableName
argument_list|)
expr_stmt|;
name|alterTblDesc
operator|.
name|setPartSpec
argument_list|(
operator|(
name|HashMap
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
operator|)
name|partSpec
argument_list|)
expr_stmt|;
name|Task
argument_list|<
name|?
extends|extends
name|Serializable
argument_list|>
name|updateReplIdTask
init|=
name|TaskFactory
operator|.
name|get
argument_list|(
operator|new
name|DDLWork
argument_list|(
name|inputs
argument_list|,
name|outputs
argument_list|,
name|alterTblDesc
argument_list|)
argument_list|,
name|conf
argument_list|)
decl_stmt|;
comment|// Link the update repl state task with dependency collection task
if|if
condition|(
name|preCursor
operator|!=
literal|null
condition|)
block|{
name|preCursor
operator|.
name|addDependentTask
argument_list|(
name|updateReplIdTask
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Added {}:{} as a precursor of {}:{}"
argument_list|,
name|preCursor
operator|.
name|getClass
argument_list|()
argument_list|,
name|preCursor
operator|.
name|getId
argument_list|()
argument_list|,
name|updateReplIdTask
operator|.
name|getClass
argument_list|()
argument_list|,
name|updateReplIdTask
operator|.
name|getId
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|updateReplIdTask
return|;
block|}
specifier|private
name|Task
argument_list|<
name|?
extends|extends
name|Serializable
argument_list|>
name|dbUpdateReplStateTask
parameter_list|(
name|String
name|dbName
parameter_list|,
name|String
name|replState
parameter_list|,
name|Task
argument_list|<
name|?
extends|extends
name|Serializable
argument_list|>
name|preCursor
parameter_list|)
block|{
name|HashMap
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|mapProp
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
name|mapProp
operator|.
name|put
argument_list|(
name|ReplicationSpec
operator|.
name|KEY
operator|.
name|CURR_STATE_ID
operator|.
name|toString
argument_list|()
argument_list|,
name|replState
argument_list|)
expr_stmt|;
name|AlterDatabaseDesc
name|alterDbDesc
init|=
operator|new
name|AlterDatabaseDesc
argument_list|(
name|dbName
argument_list|,
name|mapProp
argument_list|,
operator|new
name|ReplicationSpec
argument_list|(
name|replState
argument_list|,
name|replState
argument_list|)
argument_list|)
decl_stmt|;
name|Task
argument_list|<
name|?
extends|extends
name|Serializable
argument_list|>
name|updateReplIdTask
init|=
name|TaskFactory
operator|.
name|get
argument_list|(
operator|new
name|DDLWork
argument_list|(
name|inputs
argument_list|,
name|outputs
argument_list|,
name|alterDbDesc
argument_list|)
argument_list|,
name|conf
argument_list|)
decl_stmt|;
comment|// Link the update repl state task with dependency collection task
if|if
condition|(
name|preCursor
operator|!=
literal|null
condition|)
block|{
name|preCursor
operator|.
name|addDependentTask
argument_list|(
name|updateReplIdTask
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Added {}:{} as a precursor of {}:{}"
argument_list|,
name|preCursor
operator|.
name|getClass
argument_list|()
argument_list|,
name|preCursor
operator|.
name|getId
argument_list|()
argument_list|,
name|updateReplIdTask
operator|.
name|getClass
argument_list|()
argument_list|,
name|updateReplIdTask
operator|.
name|getId
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|updateReplIdTask
return|;
block|}
specifier|private
name|List
argument_list|<
name|Task
argument_list|<
name|?
extends|extends
name|Serializable
argument_list|>
argument_list|>
name|addUpdateReplStateTasks
parameter_list|(
name|boolean
name|isDatabaseLoad
parameter_list|,
name|UpdatedMetaDataTracker
name|updatedMetadata
parameter_list|,
name|List
argument_list|<
name|Task
argument_list|<
name|?
extends|extends
name|Serializable
argument_list|>
argument_list|>
name|importTasks
parameter_list|)
block|{
name|String
name|replState
init|=
name|updatedMetadata
operator|.
name|getReplicationState
argument_list|()
decl_stmt|;
name|String
name|dbName
init|=
name|updatedMetadata
operator|.
name|getDatabase
argument_list|()
decl_stmt|;
name|String
name|tableName
init|=
name|updatedMetadata
operator|.
name|getTable
argument_list|()
decl_stmt|;
comment|// If no import tasks generated by the event or no table updated for table level load, then no
comment|// need to update the repl state to any object.
if|if
condition|(
name|importTasks
operator|.
name|isEmpty
argument_list|()
operator|||
operator|(
operator|!
name|isDatabaseLoad
operator|&&
operator|(
name|tableName
operator|==
literal|null
operator|)
operator|)
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"No objects need update of repl state: Either 0 import tasks or table level load"
argument_list|)
expr_stmt|;
return|return
name|importTasks
return|;
block|}
comment|// Create a barrier task for dependency collection of import tasks
name|Task
argument_list|<
name|?
extends|extends
name|Serializable
argument_list|>
name|barrierTask
init|=
name|TaskFactory
operator|.
name|get
argument_list|(
operator|new
name|DependencyCollectionWork
argument_list|()
argument_list|,
name|conf
argument_list|)
decl_stmt|;
comment|// Link import tasks to the barrier task which will in-turn linked with repl state update tasks
for|for
control|(
name|Task
argument_list|<
name|?
extends|extends
name|Serializable
argument_list|>
name|t
range|:
name|importTasks
control|)
block|{
name|t
operator|.
name|addDependentTask
argument_list|(
name|barrierTask
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Added {}:{} as a precursor of barrier task {}:{}"
argument_list|,
name|t
operator|.
name|getClass
argument_list|()
argument_list|,
name|t
operator|.
name|getId
argument_list|()
argument_list|,
name|barrierTask
operator|.
name|getClass
argument_list|()
argument_list|,
name|barrierTask
operator|.
name|getId
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|List
argument_list|<
name|Task
argument_list|<
name|?
extends|extends
name|Serializable
argument_list|>
argument_list|>
name|tasks
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|Task
argument_list|<
name|?
extends|extends
name|Serializable
argument_list|>
name|updateReplIdTask
decl_stmt|;
comment|// If any partition is updated, then update repl state in partition object
for|for
control|(
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|partSpec
range|:
name|updatedMetadata
operator|.
name|getPartitions
argument_list|()
control|)
block|{
name|updateReplIdTask
operator|=
name|tableUpdateReplStateTask
argument_list|(
name|dbName
argument_list|,
name|tableName
argument_list|,
name|partSpec
argument_list|,
name|replState
argument_list|,
name|barrierTask
argument_list|)
expr_stmt|;
name|tasks
operator|.
name|add
argument_list|(
name|updateReplIdTask
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|tableName
operator|!=
literal|null
condition|)
block|{
comment|// If any table/partition is updated, then update repl state in table object
name|updateReplIdTask
operator|=
name|tableUpdateReplStateTask
argument_list|(
name|dbName
argument_list|,
name|tableName
argument_list|,
literal|null
argument_list|,
name|replState
argument_list|,
name|barrierTask
argument_list|)
expr_stmt|;
name|tasks
operator|.
name|add
argument_list|(
name|updateReplIdTask
argument_list|)
expr_stmt|;
block|}
comment|// For table level load, need not update replication state for the database
if|if
condition|(
name|isDatabaseLoad
condition|)
block|{
comment|// If any table/partition is updated, then update repl state in db object
name|updateReplIdTask
operator|=
name|dbUpdateReplStateTask
argument_list|(
name|dbName
argument_list|,
name|replState
argument_list|,
name|barrierTask
argument_list|)
expr_stmt|;
name|tasks
operator|.
name|add
argument_list|(
name|updateReplIdTask
argument_list|)
expr_stmt|;
block|}
comment|// At least one task would have been added to update the repl state
return|return
name|tasks
return|;
block|}
comment|// REPL STATUS
specifier|private
name|void
name|initReplStatus
parameter_list|(
name|ASTNode
name|ast
parameter_list|)
block|{
name|int
name|numChildren
init|=
name|ast
operator|.
name|getChildCount
argument_list|()
decl_stmt|;
name|dbNameOrPattern
operator|=
name|PlanUtils
operator|.
name|stripQuotes
argument_list|(
name|ast
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getText
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|numChildren
operator|>
literal|1
condition|)
block|{
name|tblNameOrPattern
operator|=
name|PlanUtils
operator|.
name|stripQuotes
argument_list|(
name|ast
operator|.
name|getChild
argument_list|(
literal|1
argument_list|)
operator|.
name|getText
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|analyzeReplStatus
parameter_list|(
name|ASTNode
name|ast
parameter_list|)
throws|throws
name|SemanticException
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"ReplicationSemanticAnalyzer.analyzeReplStatus: "
operator|+
name|String
operator|.
name|valueOf
argument_list|(
name|dbNameOrPattern
argument_list|)
operator|+
literal|"."
operator|+
name|String
operator|.
name|valueOf
argument_list|(
name|tblNameOrPattern
argument_list|)
argument_list|)
expr_stmt|;
name|String
name|replLastId
init|=
literal|null
decl_stmt|;
try|try
block|{
if|if
condition|(
name|tblNameOrPattern
operator|!=
literal|null
condition|)
block|{
comment|// Checking for status of table
name|Table
name|tbl
init|=
name|db
operator|.
name|getTable
argument_list|(
name|dbNameOrPattern
argument_list|,
name|tblNameOrPattern
argument_list|)
decl_stmt|;
if|if
condition|(
name|tbl
operator|!=
literal|null
condition|)
block|{
name|inputs
operator|.
name|add
argument_list|(
operator|new
name|ReadEntity
argument_list|(
name|tbl
argument_list|)
argument_list|)
expr_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|params
init|=
name|tbl
operator|.
name|getParameters
argument_list|()
decl_stmt|;
if|if
condition|(
name|params
operator|!=
literal|null
operator|&&
operator|(
name|params
operator|.
name|containsKey
argument_list|(
name|ReplicationSpec
operator|.
name|KEY
operator|.
name|CURR_STATE_ID
operator|.
name|toString
argument_list|()
argument_list|)
operator|)
condition|)
block|{
name|replLastId
operator|=
name|params
operator|.
name|get
argument_list|(
name|ReplicationSpec
operator|.
name|KEY
operator|.
name|CURR_STATE_ID
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
comment|// Checking for status of a db
name|Database
name|database
init|=
name|db
operator|.
name|getDatabase
argument_list|(
name|dbNameOrPattern
argument_list|)
decl_stmt|;
if|if
condition|(
name|database
operator|!=
literal|null
condition|)
block|{
name|inputs
operator|.
name|add
argument_list|(
operator|new
name|ReadEntity
argument_list|(
name|database
argument_list|)
argument_list|)
expr_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|params
init|=
name|database
operator|.
name|getParameters
argument_list|()
decl_stmt|;
if|if
condition|(
name|params
operator|!=
literal|null
operator|&&
operator|(
name|params
operator|.
name|containsKey
argument_list|(
name|ReplicationSpec
operator|.
name|KEY
operator|.
name|CURR_STATE_ID
operator|.
name|toString
argument_list|()
argument_list|)
operator|)
condition|)
block|{
name|replLastId
operator|=
name|params
operator|.
name|get
argument_list|(
name|ReplicationSpec
operator|.
name|KEY
operator|.
name|CURR_STATE_ID
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
catch|catch
parameter_list|(
name|HiveException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|e
argument_list|)
throw|;
comment|// TODO : simple wrap& rethrow for now, clean up with error
comment|// codes
block|}
name|prepareReturnValues
argument_list|(
name|Collections
operator|.
name|singletonList
argument_list|(
name|replLastId
argument_list|)
argument_list|,
literal|"last_repl_id#string"
argument_list|)
expr_stmt|;
name|setFetchTask
argument_list|(
name|createFetchTask
argument_list|(
literal|"last_repl_id#string"
argument_list|)
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"ReplicationSemanticAnalyzer.analyzeReplStatus: writing repl.last.id={} out to {}"
argument_list|,
name|String
operator|.
name|valueOf
argument_list|(
name|replLastId
argument_list|)
argument_list|,
name|ctx
operator|.
name|getResFile
argument_list|()
argument_list|,
name|conf
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|prepareReturnValues
parameter_list|(
name|List
argument_list|<
name|String
argument_list|>
name|values
parameter_list|,
name|String
name|schema
parameter_list|)
throws|throws
name|SemanticException
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"prepareReturnValues : "
operator|+
name|schema
argument_list|)
expr_stmt|;
for|for
control|(
name|String
name|s
range|:
name|values
control|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"> "
operator|+
name|s
argument_list|)
expr_stmt|;
block|}
name|ctx
operator|.
name|setResFile
argument_list|(
name|ctx
operator|.
name|getLocalTmpPath
argument_list|()
argument_list|)
expr_stmt|;
name|Utils
operator|.
name|writeOutput
argument_list|(
name|values
argument_list|,
name|ctx
operator|.
name|getResFile
argument_list|()
argument_list|,
name|conf
argument_list|)
expr_stmt|;
block|}
block|}
end_class

end_unit

