begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|optimizer
package|;
end_package

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|LinkedHashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
operator|.
name|Entry
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Stack
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|Log
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|LogFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|JoinOperator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|Operator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|OperatorFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|ReduceSinkOperator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|RowSchema
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|SelectOperator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|TableScanOperator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|UDFArgumentException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|lib
operator|.
name|DefaultGraphWalker
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|lib
operator|.
name|DefaultRuleDispatcher
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|lib
operator|.
name|Dispatcher
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|lib
operator|.
name|GraphWalker
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|lib
operator|.
name|Node
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|lib
operator|.
name|NodeProcessor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|lib
operator|.
name|NodeProcessorCtx
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|lib
operator|.
name|Rule
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|lib
operator|.
name|RuleRegExp
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|metadata
operator|.
name|Table
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|parse
operator|.
name|ParseContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|parse
operator|.
name|QBJoinTree
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|parse
operator|.
name|RowResolver
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|parse
operator|.
name|SemanticException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|ExprNodeColumnDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|ExprNodeConstantDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|ExprNodeDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|ExprNodeDesc
operator|.
name|ExprNodeDescEqualityWrapper
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|ExprNodeGenericFuncDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|FilterDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|OperatorDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|ReduceSinkDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|SelectDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|UnionDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|udf
operator|.
name|generic
operator|.
name|GenericUDFOPAnd
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|udf
operator|.
name|generic
operator|.
name|GenericUDFOPEqual
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|udf
operator|.
name|generic
operator|.
name|GenericUDFOPNot
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|udf
operator|.
name|generic
operator|.
name|GenericUDFOPOr
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|objectinspector
operator|.
name|ObjectInspector
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|objectinspector
operator|.
name|ObjectInspectorConverters
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|objectinspector
operator|.
name|ObjectInspectorConverters
operator|.
name|Converter
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|typeinfo
operator|.
name|TypeInfoFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|typeinfo
operator|.
name|TypeInfoUtils
import|;
end_import

begin_comment
comment|/**  * SkewJoinOptimizer.  *  */
end_comment

begin_class
specifier|public
class|class
name|SkewJoinOptimizer
implements|implements
name|Transform
block|{
specifier|private
specifier|static
specifier|final
name|Log
name|LOG
init|=
name|LogFactory
operator|.
name|getLog
argument_list|(
name|SkewJoinOptimizer
operator|.
name|class
operator|.
name|getName
argument_list|()
argument_list|)
decl_stmt|;
specifier|private
specifier|static
name|ParseContext
name|parseContext
decl_stmt|;
specifier|public
specifier|static
class|class
name|SkewJoinProc
implements|implements
name|NodeProcessor
block|{
specifier|public
name|SkewJoinProc
parameter_list|()
block|{
name|super
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|Object
name|process
parameter_list|(
name|Node
name|nd
parameter_list|,
name|Stack
argument_list|<
name|Node
argument_list|>
name|stack
parameter_list|,
name|NodeProcessorCtx
name|procCtx
parameter_list|,
name|Object
modifier|...
name|nodeOutputs
parameter_list|)
throws|throws
name|SemanticException
block|{
comment|// We should be having a tree which looks like this
comment|//  TS -> * -> RS -
comment|//                  \
comment|//                   -> JOIN -> ..
comment|//                  /
comment|//  TS -> * -> RS -
comment|//
comment|// We are in the join operator now.
name|SkewJoinOptProcCtx
name|ctx
init|=
operator|(
name|SkewJoinOptProcCtx
operator|)
name|procCtx
decl_stmt|;
name|parseContext
operator|=
name|ctx
operator|.
name|getpGraphContext
argument_list|()
expr_stmt|;
name|JoinOperator
name|joinOp
init|=
operator|(
name|JoinOperator
operator|)
name|nd
decl_stmt|;
comment|// This join has already been processed
if|if
condition|(
name|ctx
operator|.
name|getDoneJoins
argument_list|()
operator|.
name|contains
argument_list|(
name|joinOp
argument_list|)
condition|)
block|{
return|return
literal|null
return|;
block|}
name|ctx
operator|.
name|getDoneJoins
argument_list|()
operator|.
name|add
argument_list|(
name|joinOp
argument_list|)
expr_stmt|;
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
name|currOp
init|=
name|joinOp
decl_stmt|;
name|boolean
name|processSelect
init|=
literal|false
decl_stmt|;
comment|// Is there a select following
comment|// Clone the select also. It is useful for a follow-on optimization where the union
comment|// followed by a select star is completely removed.
if|if
condition|(
operator|(
name|joinOp
operator|.
name|getChildOperators
argument_list|()
operator|.
name|size
argument_list|()
operator|==
literal|1
operator|)
operator|&&
operator|(
name|joinOp
operator|.
name|getChildOperators
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|instanceof
name|SelectOperator
operator|)
condition|)
block|{
name|currOp
operator|=
name|joinOp
operator|.
name|getChildOperators
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|processSelect
operator|=
literal|true
expr_stmt|;
block|}
name|List
argument_list|<
name|TableScanOperator
argument_list|>
name|tableScanOpsForJoin
init|=
operator|new
name|ArrayList
argument_list|<
name|TableScanOperator
argument_list|>
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|getTableScanOpsForJoin
argument_list|(
name|joinOp
argument_list|,
name|tableScanOpsForJoin
argument_list|)
condition|)
block|{
return|return
literal|null
return|;
block|}
if|if
condition|(
operator|(
name|tableScanOpsForJoin
operator|==
literal|null
operator|)
operator|||
operator|(
name|tableScanOpsForJoin
operator|.
name|isEmpty
argument_list|()
operator|)
condition|)
block|{
return|return
literal|null
return|;
block|}
comment|// Get the skewed values in all the tables
name|Map
argument_list|<
name|List
argument_list|<
name|ExprNodeDesc
argument_list|>
argument_list|,
name|List
argument_list|<
name|List
argument_list|<
name|String
argument_list|>
argument_list|>
argument_list|>
name|skewedValues
init|=
name|getSkewedValues
argument_list|(
name|joinOp
argument_list|,
name|tableScanOpsForJoin
argument_list|)
decl_stmt|;
comment|// If there are no skewed values, nothing needs to be done
if|if
condition|(
name|skewedValues
operator|==
literal|null
operator|||
name|skewedValues
operator|.
name|size
argument_list|()
operator|==
literal|0
condition|)
block|{
return|return
literal|null
return|;
block|}
comment|// After this optimization, the tree should be like:
comment|//  TS -> (FIL "skewed rows") * -> RS -
comment|//                                     \
comment|//                                       ->   JOIN
comment|//                                     /           \
comment|//  TS -> (FIL "skewed rows") * -> RS -             \
comment|//                                                   \
comment|//                                                     ->  UNION -> ..
comment|//                                                   /
comment|//  TS -> (FIL "no skewed rows") * -> RS -          /
comment|//                                        \        /
comment|//                                         -> JOIN
comment|//                                        /
comment|//  TS -> (FIL "no skewed rows") * -> RS -
comment|//
comment|// Create a clone of the operator
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
name|currOpClone
decl_stmt|;
try|try
block|{
name|currOpClone
operator|=
name|currOp
operator|.
name|clone
argument_list|()
expr_stmt|;
name|insertRowResolvers
argument_list|(
name|currOp
argument_list|,
name|currOpClone
argument_list|,
name|ctx
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|CloneNotSupportedException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Operator tree could not be cloned"
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
comment|// have to create a QBJoinTree for the cloned join operator
name|QBJoinTree
name|originJoinTree
init|=
name|parseContext
operator|.
name|getJoinContext
argument_list|()
operator|.
name|get
argument_list|(
name|joinOp
argument_list|)
decl_stmt|;
name|QBJoinTree
name|newJoinTree
decl_stmt|;
try|try
block|{
name|newJoinTree
operator|=
name|originJoinTree
operator|.
name|clone
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|CloneNotSupportedException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"QBJoinTree could not be cloned: "
argument_list|,
name|e
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
name|JoinOperator
name|joinOpClone
decl_stmt|;
if|if
condition|(
name|processSelect
condition|)
block|{
name|joinOpClone
operator|=
call|(
name|JoinOperator
call|)
argument_list|(
name|currOpClone
operator|.
name|getParentOperators
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|joinOpClone
operator|=
operator|(
name|JoinOperator
operator|)
name|currOpClone
expr_stmt|;
block|}
name|parseContext
operator|.
name|getJoinContext
argument_list|()
operator|.
name|put
argument_list|(
name|joinOpClone
argument_list|,
name|newJoinTree
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|TableScanOperator
argument_list|>
name|tableScanCloneOpsForJoin
init|=
operator|new
name|ArrayList
argument_list|<
name|TableScanOperator
argument_list|>
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|getTableScanOpsForJoin
argument_list|(
name|joinOpClone
argument_list|,
name|tableScanCloneOpsForJoin
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Operator tree not properly cloned!"
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
comment|// Put the filter "skewed column = skewed keys" in op
comment|// and "skewed columns != skewed keys" in selectOpClone
name|insertSkewFilter
argument_list|(
name|tableScanOpsForJoin
argument_list|,
name|skewedValues
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|insertSkewFilter
argument_list|(
name|tableScanCloneOpsForJoin
argument_list|,
name|skewedValues
argument_list|,
literal|false
argument_list|)
expr_stmt|;
comment|// Update the topOps appropriately
name|Map
argument_list|<
name|String
argument_list|,
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
argument_list|>
name|topOps
init|=
name|getTopOps
argument_list|(
name|joinOpClone
argument_list|)
decl_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
argument_list|>
name|origTopOps
init|=
name|parseContext
operator|.
name|getTopOps
argument_list|()
decl_stmt|;
for|for
control|(
name|Entry
argument_list|<
name|String
argument_list|,
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
argument_list|>
name|topOp
range|:
name|topOps
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|TableScanOperator
name|tso
init|=
operator|(
name|TableScanOperator
operator|)
name|topOp
operator|.
name|getValue
argument_list|()
decl_stmt|;
name|Table
name|origTable
init|=
name|parseContext
operator|.
name|getTopToTable
argument_list|()
operator|.
name|get
argument_list|(
name|ctx
operator|.
name|getCloneTSOpMap
argument_list|()
operator|.
name|get
argument_list|(
name|tso
argument_list|)
argument_list|)
decl_stmt|;
name|String
name|tabAlias
init|=
name|tso
operator|.
name|getConf
argument_list|()
operator|.
name|getAlias
argument_list|()
decl_stmt|;
name|parseContext
operator|.
name|getTopToTable
argument_list|()
operator|.
name|put
argument_list|(
name|tso
argument_list|,
name|origTable
argument_list|)
expr_stmt|;
name|int
name|initCnt
init|=
literal|1
decl_stmt|;
name|String
name|newAlias
init|=
literal|"subquery"
operator|+
name|initCnt
operator|+
literal|":"
operator|+
name|tabAlias
decl_stmt|;
while|while
condition|(
name|origTopOps
operator|.
name|containsKey
argument_list|(
name|newAlias
argument_list|)
condition|)
block|{
name|initCnt
operator|++
expr_stmt|;
name|newAlias
operator|=
literal|"subquery"
operator|+
name|initCnt
operator|+
literal|":"
operator|+
name|tabAlias
expr_stmt|;
block|}
name|parseContext
operator|.
name|getTopOps
argument_list|()
operator|.
name|put
argument_list|(
name|newAlias
argument_list|,
name|tso
argument_list|)
expr_stmt|;
name|setUpAlias
argument_list|(
name|originJoinTree
argument_list|,
name|newJoinTree
argument_list|,
name|tabAlias
argument_list|,
name|newAlias
argument_list|,
name|tso
argument_list|)
expr_stmt|;
block|}
comment|// Now do a union of the select operators: selectOp and selectOpClone
comment|// Store the operator that follows the select after the join, we will be
comment|// adding this as a child to the Union later
name|List
argument_list|<
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
argument_list|>
name|finalOps
init|=
name|currOp
operator|.
name|getChildOperators
argument_list|()
decl_stmt|;
name|currOp
operator|.
name|setChildOperators
argument_list|(
literal|null
argument_list|)
expr_stmt|;
name|currOpClone
operator|.
name|setChildOperators
argument_list|(
literal|null
argument_list|)
expr_stmt|;
comment|// Make the union operator
name|List
argument_list|<
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
argument_list|>
name|oplist
init|=
operator|new
name|ArrayList
argument_list|<
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
argument_list|>
argument_list|()
decl_stmt|;
name|oplist
operator|.
name|add
argument_list|(
name|currOp
argument_list|)
expr_stmt|;
name|oplist
operator|.
name|add
argument_list|(
name|currOpClone
argument_list|)
expr_stmt|;
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
name|unionOp
init|=
name|OperatorFactory
operator|.
name|getAndMakeChild
argument_list|(
operator|new
name|UnionDesc
argument_list|()
argument_list|,
operator|new
name|RowSchema
argument_list|(
name|currOp
operator|.
name|getSchema
argument_list|()
operator|.
name|getSignature
argument_list|()
argument_list|)
argument_list|,
name|oplist
argument_list|)
decl_stmt|;
name|RowResolver
name|unionRR
init|=
name|parseContext
operator|.
name|getOpParseCtx
argument_list|()
operator|.
name|get
argument_list|(
name|currOp
argument_list|)
operator|.
name|getRowResolver
argument_list|()
decl_stmt|;
name|GenMapRedUtils
operator|.
name|putOpInsertMap
argument_list|(
name|unionOp
argument_list|,
name|unionRR
argument_list|,
name|parseContext
argument_list|)
expr_stmt|;
comment|// Introduce a select after the union
name|List
argument_list|<
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
argument_list|>
name|unionList
init|=
operator|new
name|ArrayList
argument_list|<
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
argument_list|>
argument_list|()
decl_stmt|;
name|unionList
operator|.
name|add
argument_list|(
name|unionOp
argument_list|)
expr_stmt|;
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
name|selectUnionOp
init|=
name|OperatorFactory
operator|.
name|getAndMakeChild
argument_list|(
operator|new
name|SelectDesc
argument_list|(
literal|true
argument_list|)
argument_list|,
operator|new
name|RowSchema
argument_list|(
name|unionOp
operator|.
name|getSchema
argument_list|()
operator|.
name|getSignature
argument_list|()
argument_list|)
argument_list|,
name|unionList
argument_list|)
decl_stmt|;
name|GenMapRedUtils
operator|.
name|putOpInsertMap
argument_list|(
name|selectUnionOp
argument_list|,
name|unionRR
argument_list|,
name|parseContext
argument_list|)
expr_stmt|;
comment|// add the finalOp after the union
name|selectUnionOp
operator|.
name|setChildOperators
argument_list|(
name|finalOps
argument_list|)
expr_stmt|;
comment|// replace the original selectOp in the parents with selectUnionOp
for|for
control|(
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
name|finalOp
range|:
name|finalOps
control|)
block|{
name|finalOp
operator|.
name|replaceParent
argument_list|(
name|currOp
argument_list|,
name|selectUnionOp
argument_list|)
expr_stmt|;
block|}
return|return
literal|null
return|;
block|}
comment|/*      * Get the list of table scan operators for this join. A interface supportSkewJoinOptimization      * has been provided. Currently, it is only enabled for simple filters and selects.      */
specifier|private
name|boolean
name|getTableScanOpsForJoin
parameter_list|(
name|JoinOperator
name|op
parameter_list|,
name|List
argument_list|<
name|TableScanOperator
argument_list|>
name|tsOps
parameter_list|)
block|{
for|for
control|(
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
name|parent
range|:
name|op
operator|.
name|getParentOperators
argument_list|()
control|)
block|{
if|if
condition|(
operator|!
name|getTableScanOps
argument_list|(
name|parent
argument_list|,
name|tsOps
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
return|return
literal|true
return|;
block|}
specifier|private
name|boolean
name|getTableScanOps
parameter_list|(
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
name|op
parameter_list|,
name|List
argument_list|<
name|TableScanOperator
argument_list|>
name|tsOps
parameter_list|)
block|{
for|for
control|(
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
name|parent
range|:
name|op
operator|.
name|getParentOperators
argument_list|()
control|)
block|{
if|if
condition|(
operator|!
name|parent
operator|.
name|supportSkewJoinOptimization
argument_list|()
condition|)
block|{
return|return
literal|false
return|;
block|}
if|if
condition|(
name|parent
operator|instanceof
name|TableScanOperator
condition|)
block|{
name|tsOps
operator|.
name|add
argument_list|(
operator|(
name|TableScanOperator
operator|)
name|parent
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|getTableScanOps
argument_list|(
name|parent
argument_list|,
name|tsOps
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
return|return
literal|true
return|;
block|}
comment|/**      * Returns the skewed values in all the tables which are going to be scanned.      * If the join is on columns c1, c2 and c3 on tables T1 and T2,      * T1 is skewed on c1 and c4 with the skew values ((1,2),(3,4)),      * whereas T2 is skewed on c1, c2 with skew values ((5,6),(7,8)), the resulting      * map would be:<(c1) -> ((1), (3)), (c1,c2) -> ((5,6),(7,8))>      * @param op The join operator being optimized      * @param tableScanOpsForJoin table scan operators which are parents of the join operator      * @return map<join keys intersection skewedkeys, list of skewed values>.      */
specifier|private
name|Map
argument_list|<
name|List
argument_list|<
name|ExprNodeDesc
argument_list|>
argument_list|,
name|List
argument_list|<
name|List
argument_list|<
name|String
argument_list|>
argument_list|>
argument_list|>
name|getSkewedValues
parameter_list|(
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
name|op
parameter_list|,
name|List
argument_list|<
name|TableScanOperator
argument_list|>
name|tableScanOpsForJoin
parameter_list|)
block|{
name|Map
argument_list|<
name|List
argument_list|<
name|ExprNodeDesc
argument_list|>
argument_list|,
name|List
argument_list|<
name|List
argument_list|<
name|String
argument_list|>
argument_list|>
argument_list|>
name|skewDataReturn
init|=
operator|new
name|HashMap
argument_list|<
name|List
argument_list|<
name|ExprNodeDesc
argument_list|>
argument_list|,
name|List
argument_list|<
name|List
argument_list|<
name|String
argument_list|>
argument_list|>
argument_list|>
argument_list|()
decl_stmt|;
name|Map
argument_list|<
name|List
argument_list|<
name|ExprNodeDescEqualityWrapper
argument_list|>
argument_list|,
name|List
argument_list|<
name|List
argument_list|<
name|String
argument_list|>
argument_list|>
argument_list|>
name|skewData
init|=
operator|new
name|HashMap
argument_list|<
name|List
argument_list|<
name|ExprNodeDescEqualityWrapper
argument_list|>
argument_list|,
name|List
argument_list|<
name|List
argument_list|<
name|String
argument_list|>
argument_list|>
argument_list|>
argument_list|()
decl_stmt|;
comment|// The join keys are available in the reduceSinkOperators before join
for|for
control|(
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
name|reduceSinkOp
range|:
name|op
operator|.
name|getParentOperators
argument_list|()
control|)
block|{
name|ReduceSinkDesc
name|rsDesc
init|=
operator|(
operator|(
name|ReduceSinkOperator
operator|)
name|reduceSinkOp
operator|)
operator|.
name|getConf
argument_list|()
decl_stmt|;
if|if
condition|(
name|rsDesc
operator|.
name|getKeyCols
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|Table
name|table
init|=
literal|null
decl_stmt|;
comment|// Find the skew information corresponding to the table
name|List
argument_list|<
name|String
argument_list|>
name|skewedColumns
init|=
literal|null
decl_stmt|;
name|List
argument_list|<
name|List
argument_list|<
name|String
argument_list|>
argument_list|>
name|skewedValueList
init|=
literal|null
decl_stmt|;
comment|// The join columns which are also skewed
name|List
argument_list|<
name|ExprNodeDescEqualityWrapper
argument_list|>
name|joinKeysSkewedCols
init|=
operator|new
name|ArrayList
argument_list|<
name|ExprNodeDescEqualityWrapper
argument_list|>
argument_list|()
decl_stmt|;
comment|// skewed Keys which intersect with join keys
name|List
argument_list|<
name|Integer
argument_list|>
name|positionSkewedKeys
init|=
operator|new
name|ArrayList
argument_list|<
name|Integer
argument_list|>
argument_list|()
decl_stmt|;
comment|// Update the joinKeys appropriately.
for|for
control|(
name|ExprNodeDesc
name|keyColDesc
range|:
name|rsDesc
operator|.
name|getKeyCols
argument_list|()
control|)
block|{
name|ExprNodeColumnDesc
name|keyCol
init|=
literal|null
decl_stmt|;
comment|// If the key column is not a column, then dont apply this optimization.
comment|// This will be fixed as part of https://issues.apache.org/jira/browse/HIVE-3445
comment|// for type conversion UDFs.
if|if
condition|(
name|keyColDesc
operator|instanceof
name|ExprNodeColumnDesc
condition|)
block|{
name|keyCol
operator|=
operator|(
name|ExprNodeColumnDesc
operator|)
name|keyColDesc
expr_stmt|;
if|if
condition|(
name|table
operator|==
literal|null
condition|)
block|{
name|table
operator|=
name|getTable
argument_list|(
name|parseContext
argument_list|,
name|reduceSinkOp
argument_list|,
name|tableScanOpsForJoin
argument_list|)
expr_stmt|;
name|skewedColumns
operator|=
name|table
operator|==
literal|null
condition|?
literal|null
else|:
name|table
operator|.
name|getSkewedColNames
argument_list|()
expr_stmt|;
comment|// No skew on the table to take care of
if|if
condition|(
operator|(
name|skewedColumns
operator|==
literal|null
operator|)
operator|||
operator|(
name|skewedColumns
operator|.
name|isEmpty
argument_list|()
operator|)
condition|)
block|{
continue|continue;
block|}
name|skewedValueList
operator|=
name|table
operator|==
literal|null
condition|?
literal|null
else|:
name|table
operator|.
name|getSkewedColValues
argument_list|()
expr_stmt|;
block|}
name|int
name|pos
init|=
name|skewedColumns
operator|.
name|indexOf
argument_list|(
name|keyCol
operator|.
name|getColumn
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|pos
operator|>=
literal|0
operator|)
operator|&&
operator|(
operator|!
name|positionSkewedKeys
operator|.
name|contains
argument_list|(
name|pos
argument_list|)
operator|)
condition|)
block|{
name|positionSkewedKeys
operator|.
name|add
argument_list|(
name|pos
argument_list|)
expr_stmt|;
name|ExprNodeColumnDesc
name|keyColClone
init|=
operator|(
name|ExprNodeColumnDesc
operator|)
name|keyCol
operator|.
name|clone
argument_list|()
decl_stmt|;
name|keyColClone
operator|.
name|setTabAlias
argument_list|(
literal|null
argument_list|)
expr_stmt|;
name|joinKeysSkewedCols
operator|.
name|add
argument_list|(
operator|new
name|ExprNodeDescEqualityWrapper
argument_list|(
name|keyColClone
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|// If the skew keys match the join keys, then add it to the list
if|if
condition|(
operator|(
name|skewedColumns
operator|!=
literal|null
operator|)
operator|&&
operator|(
operator|!
name|skewedColumns
operator|.
name|isEmpty
argument_list|()
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|joinKeysSkewedCols
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
comment|// If the join keys matches the skewed keys, use the table skewed keys
name|List
argument_list|<
name|List
argument_list|<
name|String
argument_list|>
argument_list|>
name|skewedJoinValues
decl_stmt|;
if|if
condition|(
name|skewedColumns
operator|.
name|size
argument_list|()
operator|==
name|positionSkewedKeys
operator|.
name|size
argument_list|()
condition|)
block|{
name|skewedJoinValues
operator|=
name|skewedValueList
expr_stmt|;
block|}
else|else
block|{
name|skewedJoinValues
operator|=
name|getSkewedJoinValues
argument_list|(
name|skewedValueList
argument_list|,
name|positionSkewedKeys
argument_list|)
expr_stmt|;
block|}
name|List
argument_list|<
name|List
argument_list|<
name|String
argument_list|>
argument_list|>
name|oldSkewedJoinValues
init|=
name|skewData
operator|.
name|get
argument_list|(
name|joinKeysSkewedCols
argument_list|)
decl_stmt|;
if|if
condition|(
name|oldSkewedJoinValues
operator|==
literal|null
condition|)
block|{
name|oldSkewedJoinValues
operator|=
operator|new
name|ArrayList
argument_list|<
name|List
argument_list|<
name|String
argument_list|>
argument_list|>
argument_list|()
expr_stmt|;
block|}
for|for
control|(
name|List
argument_list|<
name|String
argument_list|>
name|skewValue
range|:
name|skewedJoinValues
control|)
block|{
if|if
condition|(
operator|!
name|oldSkewedJoinValues
operator|.
name|contains
argument_list|(
name|skewValue
argument_list|)
condition|)
block|{
name|oldSkewedJoinValues
operator|.
name|add
argument_list|(
name|skewValue
argument_list|)
expr_stmt|;
block|}
block|}
name|skewData
operator|.
name|put
argument_list|(
name|joinKeysSkewedCols
argument_list|,
name|oldSkewedJoinValues
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
comment|// convert skewData to contain ExprNodeDesc in the keys
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|List
argument_list|<
name|ExprNodeDescEqualityWrapper
argument_list|>
argument_list|,
name|List
argument_list|<
name|List
argument_list|<
name|String
argument_list|>
argument_list|>
argument_list|>
name|mapEntry
range|:
name|skewData
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|List
argument_list|<
name|ExprNodeDesc
argument_list|>
name|skewedKeyJoinCols
init|=
operator|new
name|ArrayList
argument_list|<
name|ExprNodeDesc
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|ExprNodeDescEqualityWrapper
name|key
range|:
name|mapEntry
operator|.
name|getKey
argument_list|()
control|)
block|{
name|skewedKeyJoinCols
operator|.
name|add
argument_list|(
name|key
operator|.
name|getExprNodeDesc
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|skewDataReturn
operator|.
name|put
argument_list|(
name|skewedKeyJoinCols
argument_list|,
name|mapEntry
operator|.
name|getValue
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|skewDataReturn
return|;
block|}
comment|/**      * Get the table alias from the candidate table scans.      */
specifier|private
name|Table
name|getTable
parameter_list|(
name|ParseContext
name|parseContext
parameter_list|,
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
name|op
parameter_list|,
name|List
argument_list|<
name|TableScanOperator
argument_list|>
name|tableScanOpsForJoin
parameter_list|)
block|{
while|while
condition|(
literal|true
condition|)
block|{
if|if
condition|(
name|op
operator|instanceof
name|TableScanOperator
condition|)
block|{
name|TableScanOperator
name|tsOp
init|=
operator|(
name|TableScanOperator
operator|)
name|op
decl_stmt|;
if|if
condition|(
name|tableScanOpsForJoin
operator|.
name|contains
argument_list|(
name|tsOp
argument_list|)
condition|)
block|{
return|return
name|parseContext
operator|.
name|getTopToTable
argument_list|()
operator|.
name|get
argument_list|(
name|tsOp
argument_list|)
return|;
block|}
block|}
if|if
condition|(
operator|(
name|op
operator|.
name|getParentOperators
argument_list|()
operator|==
literal|null
operator|)
operator|||
operator|(
name|op
operator|.
name|getParentOperators
argument_list|()
operator|.
name|isEmpty
argument_list|()
operator|)
operator|||
operator|(
name|op
operator|.
name|getParentOperators
argument_list|()
operator|.
name|size
argument_list|()
operator|>
literal|1
operator|)
condition|)
block|{
return|return
literal|null
return|;
block|}
name|op
operator|=
name|op
operator|.
name|getParentOperators
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
comment|/*      * If the skewedValues contains ((1,2,3),(4,5,6)), and the user is looking for      * positions (0,2), the result would be ((1,3),(4,6))      * Get the skewed key values that are part of the join key.      * @param skewedValuesList List of all the skewed values      * @param positionSkewedKeys the requested positions      * @return sub-list of skewed values with the positions present      */
specifier|private
name|List
argument_list|<
name|List
argument_list|<
name|String
argument_list|>
argument_list|>
name|getSkewedJoinValues
parameter_list|(
name|List
argument_list|<
name|List
argument_list|<
name|String
argument_list|>
argument_list|>
name|skewedValueList
parameter_list|,
name|List
argument_list|<
name|Integer
argument_list|>
name|positionSkewedKeys
parameter_list|)
block|{
name|List
argument_list|<
name|List
argument_list|<
name|String
argument_list|>
argument_list|>
name|skewedJoinValues
init|=
operator|new
name|ArrayList
argument_list|<
name|List
argument_list|<
name|String
argument_list|>
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|List
argument_list|<
name|String
argument_list|>
name|skewedValuesAllColumns
range|:
name|skewedValueList
control|)
block|{
name|List
argument_list|<
name|String
argument_list|>
name|skewedValuesSpecifiedColumns
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|pos
range|:
name|positionSkewedKeys
control|)
block|{
name|skewedValuesSpecifiedColumns
operator|.
name|add
argument_list|(
name|skewedValuesAllColumns
operator|.
name|get
argument_list|(
name|pos
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|skewedJoinValues
operator|.
name|add
argument_list|(
name|skewedValuesSpecifiedColumns
argument_list|)
expr_stmt|;
block|}
return|return
name|skewedJoinValues
return|;
block|}
comment|/**      * Inserts a filter comparing the join keys with the skewed keys. If the table      * is skewed with values (k1, v1) and (k2, v2) on columns (key, value), then      * filter ((key=k1 AND value=v1) OR (key=k2 AND value=v2)) is inserted. If @skewed      * is false, a NOT is inserted before it.      * @param tableScanOpsForJoin table scans for which the filter will be inserted      * @param skewedValuesList the map of<expressions, list of skewed values>      * @param skewed True if we want skewedCol = skewedValue, false if we want      * not (skewedCol = skewedValue)      */
specifier|private
name|void
name|insertSkewFilter
parameter_list|(
name|List
argument_list|<
name|TableScanOperator
argument_list|>
name|tableScanOpsForJoin
parameter_list|,
name|Map
argument_list|<
name|List
argument_list|<
name|ExprNodeDesc
argument_list|>
argument_list|,
name|List
argument_list|<
name|List
argument_list|<
name|String
argument_list|>
argument_list|>
argument_list|>
name|skewedValuesList
parameter_list|,
name|boolean
name|skewed
parameter_list|)
block|{
name|ExprNodeDesc
name|filterExpr
init|=
name|constructFilterExpr
argument_list|(
name|skewedValuesList
argument_list|,
name|skewed
argument_list|)
decl_stmt|;
for|for
control|(
name|TableScanOperator
name|tableScanOp
range|:
name|tableScanOpsForJoin
control|)
block|{
name|insertFilterOnTop
argument_list|(
name|tableScanOp
argument_list|,
name|filterExpr
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Inserts a filter below the table scan operator. Construct the filter      * from the filter expression provided.      * @param tableScanOp the table scan operators      * @param filterExpr the filter expression      */
specifier|private
name|void
name|insertFilterOnTop
parameter_list|(
name|TableScanOperator
name|tableScanOp
parameter_list|,
name|ExprNodeDesc
name|filterExpr
parameter_list|)
block|{
comment|// Get the top operator and it's child, all operators have a single parent
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
name|currChild
init|=
name|tableScanOp
operator|.
name|getChildOperators
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
comment|// Create the filter Operator and update the parents and children appropriately
name|tableScanOp
operator|.
name|setChildOperators
argument_list|(
literal|null
argument_list|)
expr_stmt|;
name|currChild
operator|.
name|setParentOperators
argument_list|(
literal|null
argument_list|)
expr_stmt|;
name|Operator
argument_list|<
name|FilterDesc
argument_list|>
name|filter
init|=
name|OperatorFactory
operator|.
name|getAndMakeChild
argument_list|(
operator|new
name|FilterDesc
argument_list|(
name|filterExpr
argument_list|,
literal|false
argument_list|)
argument_list|,
name|tableScanOp
argument_list|)
decl_stmt|;
name|filter
operator|.
name|setSchema
argument_list|(
operator|new
name|RowSchema
argument_list|(
name|tableScanOp
operator|.
name|getSchema
argument_list|()
operator|.
name|getSignature
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|OperatorFactory
operator|.
name|makeChild
argument_list|(
name|filter
argument_list|,
name|currChild
argument_list|)
expr_stmt|;
name|RowResolver
name|filterRR
init|=
name|parseContext
operator|.
name|getOpParseCtx
argument_list|()
operator|.
name|get
argument_list|(
name|tableScanOp
argument_list|)
operator|.
name|getRowResolver
argument_list|()
decl_stmt|;
name|GenMapRedUtils
operator|.
name|putOpInsertMap
argument_list|(
name|filter
argument_list|,
name|filterRR
argument_list|,
name|parseContext
argument_list|)
expr_stmt|;
block|}
comment|/**      * Construct the filter expression from the skewed keys and skewed values.      * If the skewed join keys are (k1), and (k1,k3) with the skewed values      * (1,2) and ((2,3),(4,5)) respectively, the filter expression would be:      * (k1=1) or (k1=2) or ((k1=2) and (k3=3)) or ((k1=4) and (k3=5)).      */
specifier|private
name|ExprNodeDesc
name|constructFilterExpr
parameter_list|(
name|Map
argument_list|<
name|List
argument_list|<
name|ExprNodeDesc
argument_list|>
argument_list|,
name|List
argument_list|<
name|List
argument_list|<
name|String
argument_list|>
argument_list|>
argument_list|>
name|skewedValuesMap
parameter_list|,
name|boolean
name|skewed
parameter_list|)
block|{
name|ExprNodeDesc
name|finalExprNodeDesc
init|=
literal|null
decl_stmt|;
try|try
block|{
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|List
argument_list|<
name|ExprNodeDesc
argument_list|>
argument_list|,
name|List
argument_list|<
name|List
argument_list|<
name|String
argument_list|>
argument_list|>
argument_list|>
name|mapEntry
range|:
name|skewedValuesMap
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|List
argument_list|<
name|ExprNodeDesc
argument_list|>
name|keyCols
init|=
name|mapEntry
operator|.
name|getKey
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|List
argument_list|<
name|String
argument_list|>
argument_list|>
name|skewedValuesList
init|=
name|mapEntry
operator|.
name|getValue
argument_list|()
decl_stmt|;
for|for
control|(
name|List
argument_list|<
name|String
argument_list|>
name|skewedValues
range|:
name|skewedValuesList
control|)
block|{
name|int
name|keyPos
init|=
literal|0
decl_stmt|;
name|ExprNodeDesc
name|currExprNodeDesc
init|=
literal|null
decl_stmt|;
comment|// Make the following condition: all the values match for all the columns
for|for
control|(
name|String
name|skewedValue
range|:
name|skewedValues
control|)
block|{
name|List
argument_list|<
name|ExprNodeDesc
argument_list|>
name|children
init|=
operator|new
name|ArrayList
argument_list|<
name|ExprNodeDesc
argument_list|>
argument_list|()
decl_stmt|;
comment|// We have ensured that the keys are columns
name|ExprNodeColumnDesc
name|keyCol
init|=
operator|(
name|ExprNodeColumnDesc
operator|)
name|keyCols
operator|.
name|get
argument_list|(
name|keyPos
argument_list|)
operator|.
name|clone
argument_list|()
decl_stmt|;
name|keyPos
operator|++
expr_stmt|;
name|children
operator|.
name|add
argument_list|(
name|keyCol
argument_list|)
expr_stmt|;
comment|// Convert the constants available as strings to the corresponding objects
name|children
operator|.
name|add
argument_list|(
name|createConstDesc
argument_list|(
name|skewedValue
argument_list|,
name|keyCol
argument_list|)
argument_list|)
expr_stmt|;
name|ExprNodeGenericFuncDesc
name|expr
init|=
literal|null
decl_stmt|;
comment|// Create the equality condition
name|expr
operator|=
name|ExprNodeGenericFuncDesc
operator|.
name|newInstance
argument_list|(
operator|new
name|GenericUDFOPEqual
argument_list|()
argument_list|,
name|children
argument_list|)
expr_stmt|;
if|if
condition|(
name|currExprNodeDesc
operator|==
literal|null
condition|)
block|{
name|currExprNodeDesc
operator|=
name|expr
expr_stmt|;
block|}
else|else
block|{
comment|// If there are previous nodes, then AND the current node with the previous one
name|List
argument_list|<
name|ExprNodeDesc
argument_list|>
name|childrenAND
init|=
operator|new
name|ArrayList
argument_list|<
name|ExprNodeDesc
argument_list|>
argument_list|()
decl_stmt|;
name|childrenAND
operator|.
name|add
argument_list|(
name|currExprNodeDesc
argument_list|)
expr_stmt|;
name|childrenAND
operator|.
name|add
argument_list|(
name|expr
argument_list|)
expr_stmt|;
name|currExprNodeDesc
operator|=
name|ExprNodeGenericFuncDesc
operator|.
name|newInstance
argument_list|(
operator|new
name|GenericUDFOPAnd
argument_list|()
argument_list|,
name|childrenAND
argument_list|)
expr_stmt|;
block|}
block|}
comment|// If there are more than one skewed values,
comment|// then OR the current node with the previous one
if|if
condition|(
name|finalExprNodeDesc
operator|==
literal|null
condition|)
block|{
name|finalExprNodeDesc
operator|=
name|currExprNodeDesc
expr_stmt|;
block|}
else|else
block|{
name|List
argument_list|<
name|ExprNodeDesc
argument_list|>
name|childrenOR
init|=
operator|new
name|ArrayList
argument_list|<
name|ExprNodeDesc
argument_list|>
argument_list|()
decl_stmt|;
name|childrenOR
operator|.
name|add
argument_list|(
name|finalExprNodeDesc
argument_list|)
expr_stmt|;
name|childrenOR
operator|.
name|add
argument_list|(
name|currExprNodeDesc
argument_list|)
expr_stmt|;
name|finalExprNodeDesc
operator|=
name|ExprNodeGenericFuncDesc
operator|.
name|newInstance
argument_list|(
operator|new
name|GenericUDFOPOr
argument_list|()
argument_list|,
name|childrenOR
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|// Add a NOT operator in the beginning (this is for the cloned operator because we
comment|// want the values which are not skewed
if|if
condition|(
name|skewed
operator|==
literal|false
condition|)
block|{
name|List
argument_list|<
name|ExprNodeDesc
argument_list|>
name|childrenNOT
init|=
operator|new
name|ArrayList
argument_list|<
name|ExprNodeDesc
argument_list|>
argument_list|()
decl_stmt|;
name|childrenNOT
operator|.
name|add
argument_list|(
name|finalExprNodeDesc
argument_list|)
expr_stmt|;
name|finalExprNodeDesc
operator|=
name|ExprNodeGenericFuncDesc
operator|.
name|newInstance
argument_list|(
operator|new
name|GenericUDFOPNot
argument_list|()
argument_list|,
name|childrenNOT
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|UDFArgumentException
name|e
parameter_list|)
block|{
comment|// Ignore the exception because we are not comparing Long vs. String here.
comment|// There should never be an exception
assert|assert
literal|false
assert|;
block|}
return|return
name|finalExprNodeDesc
return|;
block|}
comment|/**      * Converts the skewedValue available as a string in the metadata to the appropriate object      * by using the type of the column from the join key.      * @param skewedValue      * @param keyCol      * @return an expression node descriptor of the appropriate constant      */
specifier|private
name|ExprNodeConstantDesc
name|createConstDesc
parameter_list|(
name|String
name|skewedValue
parameter_list|,
name|ExprNodeColumnDesc
name|keyCol
parameter_list|)
block|{
name|ObjectInspector
name|inputOI
init|=
name|TypeInfoUtils
operator|.
name|getStandardJavaObjectInspectorFromTypeInfo
argument_list|(
name|TypeInfoFactory
operator|.
name|stringTypeInfo
argument_list|)
decl_stmt|;
name|ObjectInspector
name|outputOI
init|=
name|TypeInfoUtils
operator|.
name|getStandardJavaObjectInspectorFromTypeInfo
argument_list|(
name|keyCol
operator|.
name|getTypeInfo
argument_list|()
argument_list|)
decl_stmt|;
name|Converter
name|converter
init|=
name|ObjectInspectorConverters
operator|.
name|getConverter
argument_list|(
name|inputOI
argument_list|,
name|outputOI
argument_list|)
decl_stmt|;
name|Object
name|skewedValueObject
init|=
name|converter
operator|.
name|convert
argument_list|(
name|skewedValue
argument_list|)
decl_stmt|;
return|return
operator|new
name|ExprNodeConstantDesc
argument_list|(
name|keyCol
operator|.
name|getTypeInfo
argument_list|()
argument_list|,
name|skewedValueObject
argument_list|)
return|;
block|}
specifier|private
name|Map
argument_list|<
name|String
argument_list|,
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
argument_list|>
name|getTopOps
parameter_list|(
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
name|op
parameter_list|)
block|{
comment|// Must be deterministic order map for consistent q-test output across
comment|// Java versions
name|Map
argument_list|<
name|String
argument_list|,
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
argument_list|>
name|topOps
init|=
operator|new
name|LinkedHashMap
argument_list|<
name|String
argument_list|,
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
argument_list|>
argument_list|()
decl_stmt|;
if|if
condition|(
name|op
operator|.
name|getParentOperators
argument_list|()
operator|==
literal|null
operator|||
name|op
operator|.
name|getParentOperators
argument_list|()
operator|.
name|size
argument_list|()
operator|==
literal|0
condition|)
block|{
name|topOps
operator|.
name|put
argument_list|(
operator|(
operator|(
name|TableScanOperator
operator|)
name|op
operator|)
operator|.
name|getConf
argument_list|()
operator|.
name|getAlias
argument_list|()
argument_list|,
name|op
argument_list|)
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
name|parent
range|:
name|op
operator|.
name|getParentOperators
argument_list|()
control|)
block|{
if|if
condition|(
name|parent
operator|!=
literal|null
condition|)
block|{
name|topOps
operator|.
name|putAll
argument_list|(
name|getTopOps
argument_list|(
name|parent
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
name|topOps
return|;
block|}
specifier|private
name|void
name|insertRowResolvers
parameter_list|(
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
name|op
parameter_list|,
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
name|opClone
parameter_list|,
name|SkewJoinOptProcCtx
name|ctx
parameter_list|)
block|{
if|if
condition|(
name|op
operator|instanceof
name|TableScanOperator
condition|)
block|{
name|ctx
operator|.
name|getCloneTSOpMap
argument_list|()
operator|.
name|put
argument_list|(
operator|(
name|TableScanOperator
operator|)
name|opClone
argument_list|,
operator|(
name|TableScanOperator
operator|)
name|op
argument_list|)
expr_stmt|;
block|}
name|GenMapRedUtils
operator|.
name|putOpInsertMap
argument_list|(
name|opClone
argument_list|,
name|parseContext
operator|.
name|getOpParseCtx
argument_list|()
operator|.
name|get
argument_list|(
name|op
argument_list|)
operator|.
name|getRowResolver
argument_list|()
argument_list|,
name|parseContext
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
argument_list|>
name|parents
init|=
name|op
operator|.
name|getParentOperators
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
argument_list|>
name|parentClones
init|=
name|opClone
operator|.
name|getParentOperators
argument_list|()
decl_stmt|;
if|if
condition|(
operator|(
name|parents
operator|!=
literal|null
operator|)
operator|&&
operator|(
operator|!
name|parents
operator|.
name|isEmpty
argument_list|()
operator|)
operator|&&
operator|(
name|parentClones
operator|!=
literal|null
operator|)
operator|&&
operator|(
operator|!
name|parentClones
operator|.
name|isEmpty
argument_list|()
operator|)
condition|)
block|{
for|for
control|(
name|int
name|pos
init|=
literal|0
init|;
name|pos
operator|<
name|parents
operator|.
name|size
argument_list|()
condition|;
name|pos
operator|++
control|)
block|{
name|insertRowResolvers
argument_list|(
name|parents
operator|.
name|get
argument_list|(
name|pos
argument_list|)
argument_list|,
name|parentClones
operator|.
name|get
argument_list|(
name|pos
argument_list|)
argument_list|,
name|ctx
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**      * Set alias in the cloned join tree      */
specifier|private
specifier|static
name|void
name|setUpAlias
parameter_list|(
name|QBJoinTree
name|origin
parameter_list|,
name|QBJoinTree
name|cloned
parameter_list|,
name|String
name|origAlias
parameter_list|,
name|String
name|newAlias
parameter_list|,
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
name|topOp
parameter_list|)
block|{
name|cloned
operator|.
name|getAliasToOpInfo
argument_list|()
operator|.
name|remove
argument_list|(
name|origAlias
argument_list|)
expr_stmt|;
name|cloned
operator|.
name|getAliasToOpInfo
argument_list|()
operator|.
name|put
argument_list|(
name|newAlias
argument_list|,
name|topOp
argument_list|)
expr_stmt|;
if|if
condition|(
name|origin
operator|.
name|getLeftAlias
argument_list|()
operator|.
name|equals
argument_list|(
name|origAlias
argument_list|)
condition|)
block|{
name|cloned
operator|.
name|setLeftAlias
argument_list|(
literal|null
argument_list|)
expr_stmt|;
name|cloned
operator|.
name|setLeftAlias
argument_list|(
name|newAlias
argument_list|)
expr_stmt|;
block|}
name|replaceAlias
argument_list|(
name|origin
operator|.
name|getLeftAliases
argument_list|()
argument_list|,
name|cloned
operator|.
name|getLeftAliases
argument_list|()
argument_list|,
name|origAlias
argument_list|,
name|newAlias
argument_list|)
expr_stmt|;
name|replaceAlias
argument_list|(
name|origin
operator|.
name|getRightAliases
argument_list|()
argument_list|,
name|cloned
operator|.
name|getRightAliases
argument_list|()
argument_list|,
name|origAlias
argument_list|,
name|newAlias
argument_list|)
expr_stmt|;
name|replaceAlias
argument_list|(
name|origin
operator|.
name|getBaseSrc
argument_list|()
argument_list|,
name|cloned
operator|.
name|getBaseSrc
argument_list|()
argument_list|,
name|origAlias
argument_list|,
name|newAlias
argument_list|)
expr_stmt|;
name|replaceAlias
argument_list|(
name|origin
operator|.
name|getMapAliases
argument_list|()
argument_list|,
name|cloned
operator|.
name|getMapAliases
argument_list|()
argument_list|,
name|origAlias
argument_list|,
name|newAlias
argument_list|)
expr_stmt|;
name|replaceAlias
argument_list|(
name|origin
operator|.
name|getStreamAliases
argument_list|()
argument_list|,
name|cloned
operator|.
name|getStreamAliases
argument_list|()
argument_list|,
name|origAlias
argument_list|,
name|newAlias
argument_list|)
expr_stmt|;
block|}
specifier|private
specifier|static
name|void
name|replaceAlias
parameter_list|(
name|String
index|[]
name|origin
parameter_list|,
name|String
index|[]
name|cloned
parameter_list|,
name|String
name|alias
parameter_list|,
name|String
name|newAlias
parameter_list|)
block|{
if|if
condition|(
name|origin
operator|==
literal|null
operator|||
name|cloned
operator|==
literal|null
operator|||
name|origin
operator|.
name|length
operator|!=
name|cloned
operator|.
name|length
condition|)
block|{
return|return;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|origin
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|origin
index|[
name|i
index|]
operator|.
name|equals
argument_list|(
name|alias
argument_list|)
condition|)
block|{
name|cloned
index|[
name|i
index|]
operator|=
name|newAlias
expr_stmt|;
block|}
block|}
block|}
specifier|private
specifier|static
name|void
name|replaceAlias
parameter_list|(
name|List
argument_list|<
name|String
argument_list|>
name|origin
parameter_list|,
name|List
argument_list|<
name|String
argument_list|>
name|cloned
parameter_list|,
name|String
name|alias
parameter_list|,
name|String
name|newAlias
parameter_list|)
block|{
if|if
condition|(
name|origin
operator|==
literal|null
operator|||
name|cloned
operator|==
literal|null
operator|||
name|origin
operator|.
name|size
argument_list|()
operator|!=
name|cloned
operator|.
name|size
argument_list|()
condition|)
block|{
return|return;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|origin
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|origin
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|equals
argument_list|(
name|alias
argument_list|)
condition|)
block|{
name|cloned
operator|.
name|set
argument_list|(
name|i
argument_list|,
name|newAlias
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/* (non-Javadoc)    * @see org.apache.hadoop.hive.ql.optimizer.Transform#transform    * (org.apache.hadoop.hive.ql.parse.ParseContext)    */
annotation|@
name|Override
specifier|public
name|ParseContext
name|transform
parameter_list|(
name|ParseContext
name|pctx
parameter_list|)
throws|throws
name|SemanticException
block|{
name|Map
argument_list|<
name|Rule
argument_list|,
name|NodeProcessor
argument_list|>
name|opRules
init|=
operator|new
name|LinkedHashMap
argument_list|<
name|Rule
argument_list|,
name|NodeProcessor
argument_list|>
argument_list|()
decl_stmt|;
name|opRules
operator|.
name|put
argument_list|(
operator|new
name|RuleRegExp
argument_list|(
literal|"R1"
argument_list|,
literal|"TS%.*RS%JOIN%"
argument_list|)
argument_list|,
name|getSkewJoinProc
argument_list|()
argument_list|)
expr_stmt|;
name|SkewJoinOptProcCtx
name|skewJoinOptProcCtx
init|=
operator|new
name|SkewJoinOptProcCtx
argument_list|(
name|pctx
argument_list|)
decl_stmt|;
comment|// The dispatcher fires the processor corresponding to the closest matching
comment|// rule and passes the context along
name|Dispatcher
name|disp
init|=
operator|new
name|DefaultRuleDispatcher
argument_list|(
literal|null
argument_list|,
name|opRules
argument_list|,
name|skewJoinOptProcCtx
argument_list|)
decl_stmt|;
name|GraphWalker
name|ogw
init|=
operator|new
name|DefaultGraphWalker
argument_list|(
name|disp
argument_list|)
decl_stmt|;
comment|// Create a list of topop nodes
name|List
argument_list|<
name|Node
argument_list|>
name|topNodes
init|=
operator|new
name|ArrayList
argument_list|<
name|Node
argument_list|>
argument_list|()
decl_stmt|;
name|topNodes
operator|.
name|addAll
argument_list|(
name|pctx
operator|.
name|getTopOps
argument_list|()
operator|.
name|values
argument_list|()
argument_list|)
expr_stmt|;
name|ogw
operator|.
name|startWalking
argument_list|(
name|topNodes
argument_list|,
literal|null
argument_list|)
expr_stmt|;
return|return
name|pctx
return|;
block|}
specifier|private
name|NodeProcessor
name|getSkewJoinProc
parameter_list|()
block|{
return|return
operator|new
name|SkewJoinProc
argument_list|()
return|;
block|}
comment|/**    * SkewJoinOptProcCtx.    *    */
specifier|public
specifier|static
class|class
name|SkewJoinOptProcCtx
implements|implements
name|NodeProcessorCtx
block|{
specifier|private
name|ParseContext
name|pGraphContext
decl_stmt|;
comment|// set of joins already processed
specifier|private
name|Set
argument_list|<
name|JoinOperator
argument_list|>
name|doneJoins
decl_stmt|;
specifier|private
name|Map
argument_list|<
name|TableScanOperator
argument_list|,
name|TableScanOperator
argument_list|>
name|cloneTSOpMap
decl_stmt|;
specifier|public
name|SkewJoinOptProcCtx
parameter_list|(
name|ParseContext
name|pctx
parameter_list|)
block|{
name|this
operator|.
name|pGraphContext
operator|=
name|pctx
expr_stmt|;
name|doneJoins
operator|=
operator|new
name|HashSet
argument_list|<
name|JoinOperator
argument_list|>
argument_list|()
expr_stmt|;
name|cloneTSOpMap
operator|=
operator|new
name|HashMap
argument_list|<
name|TableScanOperator
argument_list|,
name|TableScanOperator
argument_list|>
argument_list|()
expr_stmt|;
block|}
specifier|public
name|ParseContext
name|getpGraphContext
parameter_list|()
block|{
return|return
name|pGraphContext
return|;
block|}
specifier|public
name|void
name|setPGraphContext
parameter_list|(
name|ParseContext
name|graphContext
parameter_list|)
block|{
name|pGraphContext
operator|=
name|graphContext
expr_stmt|;
block|}
specifier|public
name|Set
argument_list|<
name|JoinOperator
argument_list|>
name|getDoneJoins
parameter_list|()
block|{
return|return
name|doneJoins
return|;
block|}
specifier|public
name|void
name|setDoneJoins
parameter_list|(
name|Set
argument_list|<
name|JoinOperator
argument_list|>
name|doneJoins
parameter_list|)
block|{
name|this
operator|.
name|doneJoins
operator|=
name|doneJoins
expr_stmt|;
block|}
specifier|public
name|Map
argument_list|<
name|TableScanOperator
argument_list|,
name|TableScanOperator
argument_list|>
name|getCloneTSOpMap
parameter_list|()
block|{
return|return
name|cloneTSOpMap
return|;
block|}
specifier|public
name|void
name|setCloneTSOpMap
parameter_list|(
name|Map
argument_list|<
name|TableScanOperator
argument_list|,
name|TableScanOperator
argument_list|>
name|cloneTSOpMap
parameter_list|)
block|{
name|this
operator|.
name|cloneTSOpMap
operator|=
name|cloneTSOpMap
expr_stmt|;
block|}
block|}
block|}
end_class

end_unit

