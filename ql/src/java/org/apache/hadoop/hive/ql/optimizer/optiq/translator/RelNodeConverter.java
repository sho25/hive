begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|optimizer
operator|.
name|optiq
operator|.
name|translator
package|;
end_package

begin_import
import|import
name|java
operator|.
name|math
operator|.
name|BigDecimal
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|BitSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|LinkedHashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|LinkedList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
operator|.
name|Entry
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Stack
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|metastore
operator|.
name|api
operator|.
name|FieldSchema
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|ColumnInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|FilterOperator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|GroupByOperator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|JoinOperator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|LimitOperator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|Operator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|ReduceSinkOperator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|RowSchema
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|SelectOperator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|TableScanOperator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|lib
operator|.
name|DefaultRuleDispatcher
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|lib
operator|.
name|Dispatcher
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|lib
operator|.
name|ForwardWalker
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|lib
operator|.
name|GraphWalker
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|lib
operator|.
name|Node
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|lib
operator|.
name|NodeProcessor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|lib
operator|.
name|NodeProcessorCtx
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|lib
operator|.
name|Rule
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|lib
operator|.
name|RuleRegExp
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|metadata
operator|.
name|Table
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|optimizer
operator|.
name|optiq
operator|.
name|RelOptHiveTable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|optimizer
operator|.
name|optiq
operator|.
name|reloperators
operator|.
name|HiveAggregateRel
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|optimizer
operator|.
name|optiq
operator|.
name|reloperators
operator|.
name|HiveFilterRel
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|optimizer
operator|.
name|optiq
operator|.
name|reloperators
operator|.
name|HiveJoinRel
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|optimizer
operator|.
name|optiq
operator|.
name|reloperators
operator|.
name|HiveProjectRel
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|optimizer
operator|.
name|optiq
operator|.
name|reloperators
operator|.
name|HiveRel
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|optimizer
operator|.
name|optiq
operator|.
name|reloperators
operator|.
name|HiveSortRel
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|optimizer
operator|.
name|optiq
operator|.
name|reloperators
operator|.
name|HiveTableScanRel
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|parse
operator|.
name|ParseContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|parse
operator|.
name|PrunedPartitionList
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|parse
operator|.
name|QBJoinTree
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|parse
operator|.
name|RowResolver
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|parse
operator|.
name|SemanticAnalyzer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|parse
operator|.
name|SemanticException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|AggregationDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|ColStatistics
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|ExprNodeColumnDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|ExprNodeDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|JoinCondDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|JoinDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|OperatorDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|ReduceSinkDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|Statistics
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|rel
operator|.
name|AggregateCall
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|rel
operator|.
name|Aggregation
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|rel
operator|.
name|InvalidRelException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|rel
operator|.
name|JoinRelType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|rel
operator|.
name|RelCollation
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|rel
operator|.
name|RelCollationImpl
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|rel
operator|.
name|RelFieldCollation
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|rel
operator|.
name|RelNode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|rel
operator|.
name|TableAccessRelBase
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|relopt
operator|.
name|RelOptCluster
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|relopt
operator|.
name|RelOptSchema
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|relopt
operator|.
name|RelTraitSet
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|reltype
operator|.
name|RelDataType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|reltype
operator|.
name|RelDataTypeField
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|rex
operator|.
name|RexCall
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|rex
operator|.
name|RexInputRef
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|rex
operator|.
name|RexNode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|rex
operator|.
name|RexUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|sql
operator|.
name|fun
operator|.
name|SqlStdOperatorTable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|util
operator|.
name|CompositeList
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|util
operator|.
name|Pair
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Function
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|ImmutableMap
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Lists
import|;
end_import

begin_class
specifier|public
class|class
name|RelNodeConverter
block|{
specifier|private
specifier|static
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|Aggregation
argument_list|>
name|AGG_MAP
init|=
name|ImmutableMap
operator|.
expr|<
name|String
decl_stmt|,
name|Aggregation
decl|>
name|builder
argument_list|()
decl|.
name|put
argument_list|(
literal|"count"
argument_list|,
operator|(
name|Aggregation
operator|)
name|SqlStdOperatorTable
operator|.
name|COUNT
argument_list|)
decl|.
name|put
argument_list|(
literal|"sum"
argument_list|,
name|SqlStdOperatorTable
operator|.
name|SUM
argument_list|)
decl|.
name|put
argument_list|(
literal|"min"
argument_list|,
name|SqlStdOperatorTable
operator|.
name|MIN
argument_list|)
decl|.
name|put
argument_list|(
literal|"max"
argument_list|,
name|SqlStdOperatorTable
operator|.
name|MAX
argument_list|)
decl|.
name|put
argument_list|(
literal|"avg"
argument_list|,
name|SqlStdOperatorTable
operator|.
name|AVG
argument_list|)
decl|.
name|build
argument_list|()
decl_stmt|;
specifier|public
specifier|static
name|RelNode
name|convert
parameter_list|(
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
name|sinkOp
parameter_list|,
name|RelOptCluster
name|cluster
parameter_list|,
name|RelOptSchema
name|schema
parameter_list|,
name|SemanticAnalyzer
name|sA
parameter_list|,
name|ParseContext
name|pCtx
parameter_list|)
block|{
name|Context
name|ctx
init|=
operator|new
name|Context
argument_list|(
name|cluster
argument_list|,
name|schema
argument_list|,
name|sA
argument_list|,
name|pCtx
argument_list|)
decl_stmt|;
name|Map
argument_list|<
name|Rule
argument_list|,
name|NodeProcessor
argument_list|>
name|rules
init|=
name|ImmutableMap
operator|.
expr|<
name|Rule
decl_stmt|,
name|NodeProcessor
decl|>
name|builder
argument_list|()
decl|.
name|put
argument_list|(
operator|new
name|RuleRegExp
argument_list|(
literal|"R1"
argument_list|,
name|TableScanOperator
operator|.
name|getOperatorName
argument_list|()
operator|+
literal|"%"
argument_list|)
argument_list|,
operator|new
name|TableScanProcessor
argument_list|()
argument_list|)
decl|.
name|put
argument_list|(
operator|new
name|RuleRegExp
argument_list|(
literal|"R2"
argument_list|,
name|FilterOperator
operator|.
name|getOperatorName
argument_list|()
operator|+
literal|"%"
argument_list|)
argument_list|,
operator|new
name|FilterProcessor
argument_list|()
argument_list|)
decl|.
name|put
argument_list|(
operator|new
name|RuleRegExp
argument_list|(
literal|"R3"
argument_list|,
name|SelectOperator
operator|.
name|getOperatorName
argument_list|()
operator|+
literal|"%"
argument_list|)
argument_list|,
operator|new
name|SelectProcessor
argument_list|()
argument_list|)
decl|.
name|put
argument_list|(
operator|new
name|RuleRegExp
argument_list|(
literal|"R4"
argument_list|,
name|JoinOperator
operator|.
name|getOperatorName
argument_list|()
operator|+
literal|"%"
argument_list|)
argument_list|,
operator|new
name|JoinProcessor
argument_list|()
argument_list|)
decl|.
name|put
argument_list|(
operator|new
name|RuleRegExp
argument_list|(
literal|"R5"
argument_list|,
name|LimitOperator
operator|.
name|getOperatorName
argument_list|()
operator|+
literal|"%"
argument_list|)
argument_list|,
operator|new
name|LimitProcessor
argument_list|()
argument_list|)
decl|.
name|put
argument_list|(
operator|new
name|RuleRegExp
argument_list|(
literal|"R6"
argument_list|,
name|GroupByOperator
operator|.
name|getOperatorName
argument_list|()
operator|+
literal|"%"
argument_list|)
argument_list|,
operator|new
name|GroupByProcessor
argument_list|()
argument_list|)
decl|.
name|put
argument_list|(
operator|new
name|RuleRegExp
argument_list|(
literal|"R7"
argument_list|,
name|ReduceSinkOperator
operator|.
name|getOperatorName
argument_list|()
operator|+
literal|"%"
argument_list|)
argument_list|,
operator|new
name|ReduceSinkProcessor
argument_list|()
argument_list|)
decl|.
name|build
argument_list|()
decl_stmt|;
name|Dispatcher
name|disp
init|=
operator|new
name|DefaultRuleDispatcher
argument_list|(
operator|new
name|DefaultProcessor
argument_list|()
argument_list|,
name|rules
argument_list|,
name|ctx
argument_list|)
decl_stmt|;
name|GraphWalker
name|egw
init|=
operator|new
name|ForwardWalker
argument_list|(
name|disp
argument_list|)
decl_stmt|;
name|ArrayList
argument_list|<
name|Node
argument_list|>
name|topNodes
init|=
operator|new
name|ArrayList
argument_list|<
name|Node
argument_list|>
argument_list|()
decl_stmt|;
name|topNodes
operator|.
name|addAll
argument_list|(
name|pCtx
operator|.
name|getTopOps
argument_list|()
operator|.
name|values
argument_list|()
argument_list|)
expr_stmt|;
name|HashMap
argument_list|<
name|Node
argument_list|,
name|Object
argument_list|>
name|outputMap
init|=
operator|new
name|HashMap
argument_list|<
name|Node
argument_list|,
name|Object
argument_list|>
argument_list|()
decl_stmt|;
try|try
block|{
name|egw
operator|.
name|startWalking
argument_list|(
name|topNodes
argument_list|,
name|outputMap
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|SemanticException
name|se
parameter_list|)
block|{
comment|// @revisit
throw|throw
operator|new
name|RuntimeException
argument_list|(
name|se
argument_list|)
throw|;
block|}
return|return
operator|(
name|HiveRel
operator|)
name|outputMap
operator|.
name|get
argument_list|(
name|sinkOp
argument_list|)
return|;
block|}
specifier|static
class|class
name|Context
implements|implements
name|NodeProcessorCtx
block|{
name|RelOptCluster
name|cluster
decl_stmt|;
name|RelOptSchema
name|schema
decl_stmt|;
name|SemanticAnalyzer
name|sA
decl_stmt|;
name|ParseContext
name|parseCtx
decl_stmt|;
comment|/*      * A Map from hive column internalNames to Optiq positions. A separate map      * for each Operator.      */
name|Map
argument_list|<
name|RelNode
argument_list|,
name|ImmutableMap
argument_list|<
name|String
argument_list|,
name|Integer
argument_list|>
argument_list|>
name|opPositionMap
decl_stmt|;
name|Map
argument_list|<
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
argument_list|,
name|RelNode
argument_list|>
name|hiveOpToRelNode
decl_stmt|;
specifier|public
name|Context
parameter_list|(
name|RelOptCluster
name|cluster
parameter_list|,
name|RelOptSchema
name|schema
parameter_list|,
name|SemanticAnalyzer
name|sA
parameter_list|,
name|ParseContext
name|parseCtx
parameter_list|)
block|{
name|super
argument_list|()
expr_stmt|;
name|this
operator|.
name|cluster
operator|=
name|cluster
expr_stmt|;
name|this
operator|.
name|schema
operator|=
name|schema
expr_stmt|;
name|this
operator|.
name|sA
operator|=
name|sA
expr_stmt|;
name|this
operator|.
name|parseCtx
operator|=
name|parseCtx
expr_stmt|;
name|opPositionMap
operator|=
operator|new
name|HashMap
argument_list|<
name|RelNode
argument_list|,
name|ImmutableMap
argument_list|<
name|String
argument_list|,
name|Integer
argument_list|>
argument_list|>
argument_list|()
expr_stmt|;
name|hiveOpToRelNode
operator|=
operator|new
name|HashMap
argument_list|<
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
argument_list|,
name|RelNode
argument_list|>
argument_list|()
expr_stmt|;
block|}
name|void
name|buildColumnMap
parameter_list|(
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
name|op
parameter_list|,
name|RelNode
name|rNode
parameter_list|)
block|{
name|RowSchema
name|rr
init|=
name|op
operator|.
name|getSchema
argument_list|()
decl_stmt|;
name|ImmutableMap
operator|.
name|Builder
argument_list|<
name|String
argument_list|,
name|Integer
argument_list|>
name|b
init|=
operator|new
name|ImmutableMap
operator|.
name|Builder
argument_list|<
name|String
argument_list|,
name|Integer
argument_list|>
argument_list|()
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
for|for
control|(
name|ColumnInfo
name|ci
range|:
name|rr
operator|.
name|getSignature
argument_list|()
control|)
block|{
name|b
operator|.
name|put
argument_list|(
name|ci
operator|.
name|getInternalName
argument_list|()
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
name|opPositionMap
operator|.
name|put
argument_list|(
name|rNode
argument_list|,
name|b
operator|.
name|build
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/*      * Why special handling for TableScan? - the RowResolver coming from hive      * for TScan still has all the columns, whereas the Optiq type we build is      * based on the needed columns in the TScanOp.      */
name|void
name|buildColumnMap
parameter_list|(
name|TableScanOperator
name|tsOp
parameter_list|,
name|RelNode
name|rNode
parameter_list|)
block|{
name|RelDataType
name|oType
init|=
name|rNode
operator|.
name|getRowType
argument_list|()
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
name|ImmutableMap
operator|.
name|Builder
argument_list|<
name|String
argument_list|,
name|Integer
argument_list|>
name|b
init|=
operator|new
name|ImmutableMap
operator|.
name|Builder
argument_list|<
name|String
argument_list|,
name|Integer
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|String
name|fN
range|:
name|oType
operator|.
name|getFieldNames
argument_list|()
control|)
block|{
name|b
operator|.
name|put
argument_list|(
name|fN
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
name|opPositionMap
operator|.
name|put
argument_list|(
name|rNode
argument_list|,
name|b
operator|.
name|build
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|Map
argument_list|<
name|String
argument_list|,
name|Integer
argument_list|>
name|reducerMap
parameter_list|(
name|Map
argument_list|<
name|String
argument_list|,
name|Integer
argument_list|>
name|inpMap
parameter_list|,
name|ReduceSinkOperator
name|rsOp
parameter_list|)
block|{
name|ImmutableMap
operator|.
name|Builder
argument_list|<
name|String
argument_list|,
name|Integer
argument_list|>
name|b
init|=
operator|new
name|ImmutableMap
operator|.
name|Builder
argument_list|<
name|String
argument_list|,
name|Integer
argument_list|>
argument_list|()
decl_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|ExprNodeDesc
argument_list|>
name|colExprMap
init|=
name|rsOp
operator|.
name|getColumnExprMap
argument_list|()
decl_stmt|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|ExprNodeDesc
argument_list|>
name|e
range|:
name|colExprMap
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|String
name|inpCol
init|=
operator|(
operator|(
name|ExprNodeColumnDesc
operator|)
name|e
operator|.
name|getValue
argument_list|()
operator|)
operator|.
name|getColumn
argument_list|()
decl_stmt|;
name|b
operator|.
name|put
argument_list|(
name|e
operator|.
name|getKey
argument_list|()
argument_list|,
name|inpMap
operator|.
name|get
argument_list|(
name|inpCol
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|b
operator|.
name|build
argument_list|()
return|;
block|}
comment|/*      * The Optiq JoinRel datatype is formed by combining the columns from its      * input RelNodes. Whereas the Hive RowResolver of the JoinOp contains only      * the columns needed by childOps.      */
name|void
name|buildColumnMap
parameter_list|(
name|JoinOperator
name|jOp
parameter_list|,
name|HiveJoinRel
name|jRel
parameter_list|)
throws|throws
name|SemanticException
block|{
name|RowResolver
name|rr
init|=
name|sA
operator|.
name|getRowResolver
argument_list|(
name|jOp
argument_list|)
decl_stmt|;
name|QBJoinTree
name|hTree
init|=
name|parseCtx
operator|.
name|getJoinContext
argument_list|()
operator|.
name|get
argument_list|(
name|jOp
argument_list|)
decl_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|Integer
argument_list|>
name|leftMap
init|=
name|opPositionMap
operator|.
name|get
argument_list|(
name|jRel
operator|.
name|getLeft
argument_list|()
argument_list|)
decl_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|Integer
argument_list|>
name|rightMap
init|=
name|opPositionMap
operator|.
name|get
argument_list|(
name|jRel
operator|.
name|getRight
argument_list|()
argument_list|)
decl_stmt|;
name|leftMap
operator|=
name|reducerMap
argument_list|(
name|leftMap
argument_list|,
operator|(
name|ReduceSinkOperator
operator|)
name|jOp
operator|.
name|getParentOperators
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|rightMap
operator|=
name|reducerMap
argument_list|(
name|rightMap
argument_list|,
operator|(
name|ReduceSinkOperator
operator|)
name|jOp
operator|.
name|getParentOperators
argument_list|()
operator|.
name|get
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|int
name|leftColCount
init|=
name|jRel
operator|.
name|getLeft
argument_list|()
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldCount
argument_list|()
decl_stmt|;
name|ImmutableMap
operator|.
name|Builder
argument_list|<
name|String
argument_list|,
name|Integer
argument_list|>
name|b
init|=
operator|new
name|ImmutableMap
operator|.
name|Builder
argument_list|<
name|String
argument_list|,
name|Integer
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|LinkedHashMap
argument_list|<
name|String
argument_list|,
name|ColumnInfo
argument_list|>
argument_list|>
name|tableEntry
range|:
name|rr
operator|.
name|getRslvMap
argument_list|()
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|String
name|table
init|=
name|tableEntry
operator|.
name|getKey
argument_list|()
decl_stmt|;
name|LinkedHashMap
argument_list|<
name|String
argument_list|,
name|ColumnInfo
argument_list|>
name|cols
init|=
name|tableEntry
operator|.
name|getValue
argument_list|()
decl_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|Integer
argument_list|>
name|posMap
init|=
name|leftMap
decl_stmt|;
name|int
name|offset
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|hTree
operator|.
name|getRightAliases
argument_list|()
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|String
name|rAlias
range|:
name|hTree
operator|.
name|getRightAliases
argument_list|()
control|)
block|{
if|if
condition|(
name|table
operator|.
name|equals
argument_list|(
name|rAlias
argument_list|)
condition|)
block|{
name|posMap
operator|=
name|rightMap
expr_stmt|;
name|offset
operator|=
name|leftColCount
expr_stmt|;
break|break;
block|}
block|}
block|}
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|ColumnInfo
argument_list|>
name|colEntry
range|:
name|cols
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|ColumnInfo
name|ci
init|=
name|colEntry
operator|.
name|getValue
argument_list|()
decl_stmt|;
name|ExprNodeDesc
name|e
init|=
name|jOp
operator|.
name|getColumnExprMap
argument_list|()
operator|.
name|get
argument_list|(
name|ci
operator|.
name|getInternalName
argument_list|()
argument_list|)
decl_stmt|;
name|String
name|cName
init|=
operator|(
operator|(
name|ExprNodeColumnDesc
operator|)
name|e
operator|)
operator|.
name|getColumn
argument_list|()
decl_stmt|;
name|int
name|pos
init|=
name|posMap
operator|.
name|get
argument_list|(
name|cName
argument_list|)
decl_stmt|;
name|b
operator|.
name|put
argument_list|(
name|ci
operator|.
name|getInternalName
argument_list|()
argument_list|,
name|pos
operator|+
name|offset
argument_list|)
expr_stmt|;
block|}
block|}
name|opPositionMap
operator|.
name|put
argument_list|(
name|jRel
argument_list|,
name|b
operator|.
name|build
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|void
name|propagatePosMap
parameter_list|(
name|RelNode
name|node
parameter_list|,
name|RelNode
name|parent
parameter_list|)
block|{
name|opPositionMap
operator|.
name|put
argument_list|(
name|node
argument_list|,
name|opPositionMap
operator|.
name|get
argument_list|(
name|parent
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|RexNode
name|convertToOptiqExpr
parameter_list|(
specifier|final
name|ExprNodeDesc
name|expr
parameter_list|,
specifier|final
name|RelNode
name|optiqOP
parameter_list|,
specifier|final
name|boolean
name|flatten
parameter_list|)
throws|throws
name|SemanticException
block|{
return|return
name|convertToOptiqExpr
argument_list|(
name|expr
argument_list|,
name|optiqOP
argument_list|,
literal|0
argument_list|,
name|flatten
argument_list|)
return|;
block|}
name|RexNode
name|convertToOptiqExpr
parameter_list|(
specifier|final
name|ExprNodeDesc
name|expr
parameter_list|,
specifier|final
name|RelNode
name|optiqOP
parameter_list|,
name|int
name|offset
parameter_list|,
specifier|final
name|boolean
name|flatten
parameter_list|)
throws|throws
name|SemanticException
block|{
name|ImmutableMap
argument_list|<
name|String
argument_list|,
name|Integer
argument_list|>
name|posMap
init|=
name|opPositionMap
operator|.
name|get
argument_list|(
name|optiqOP
argument_list|)
decl_stmt|;
name|RexNodeConverter
name|c
init|=
operator|new
name|RexNodeConverter
argument_list|(
name|cluster
argument_list|,
name|optiqOP
operator|.
name|getRowType
argument_list|()
argument_list|,
name|posMap
argument_list|,
name|offset
argument_list|,
name|flatten
argument_list|)
decl_stmt|;
return|return
name|c
operator|.
name|convert
argument_list|(
name|expr
argument_list|)
return|;
block|}
name|RelNode
name|getParentNode
parameter_list|(
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
name|hiveOp
parameter_list|,
name|int
name|i
parameter_list|)
block|{
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
name|p
init|=
name|hiveOp
operator|.
name|getParentOperators
argument_list|()
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
return|return
name|p
operator|==
literal|null
condition|?
literal|null
else|:
name|hiveOpToRelNode
operator|.
name|get
argument_list|(
name|p
argument_list|)
return|;
block|}
block|}
specifier|static
class|class
name|JoinProcessor
implements|implements
name|NodeProcessor
block|{
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
specifier|public
name|Object
name|process
parameter_list|(
name|Node
name|nd
parameter_list|,
name|Stack
argument_list|<
name|Node
argument_list|>
name|stack
parameter_list|,
name|NodeProcessorCtx
name|procCtx
parameter_list|,
name|Object
modifier|...
name|nodeOutputs
parameter_list|)
throws|throws
name|SemanticException
block|{
name|Context
name|ctx
init|=
operator|(
name|Context
operator|)
name|procCtx
decl_stmt|;
name|HiveRel
name|left
init|=
operator|(
name|HiveRel
operator|)
name|ctx
operator|.
name|getParentNode
argument_list|(
operator|(
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
operator|)
name|nd
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|HiveRel
name|right
init|=
operator|(
name|HiveRel
operator|)
name|ctx
operator|.
name|getParentNode
argument_list|(
operator|(
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
operator|)
name|nd
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|JoinOperator
name|joinOp
init|=
operator|(
name|JoinOperator
operator|)
name|nd
decl_stmt|;
name|JoinCondDesc
index|[]
name|jConds
init|=
name|joinOp
operator|.
name|getConf
argument_list|()
operator|.
name|getConds
argument_list|()
decl_stmt|;
assert|assert
name|jConds
operator|.
name|length
operator|==
literal|1
assert|;
name|HiveJoinRel
name|joinRel
init|=
name|convertJoinOp
argument_list|(
name|ctx
argument_list|,
name|joinOp
argument_list|,
name|jConds
index|[
literal|0
index|]
argument_list|,
name|left
argument_list|,
name|right
argument_list|)
decl_stmt|;
name|ctx
operator|.
name|buildColumnMap
argument_list|(
name|joinOp
argument_list|,
name|joinRel
argument_list|)
expr_stmt|;
name|ctx
operator|.
name|hiveOpToRelNode
operator|.
name|put
argument_list|(
name|joinOp
argument_list|,
name|joinRel
argument_list|)
expr_stmt|;
return|return
name|joinRel
return|;
block|}
comment|/*      * @todo: cleanup, for now just copied from HiveToOptiqRelConvereter      */
specifier|private
name|HiveJoinRel
name|convertJoinOp
parameter_list|(
name|Context
name|ctx
parameter_list|,
name|JoinOperator
name|op
parameter_list|,
name|JoinCondDesc
name|jc
parameter_list|,
name|HiveRel
name|leftRel
parameter_list|,
name|HiveRel
name|rightRel
parameter_list|)
throws|throws
name|SemanticException
block|{
name|HiveJoinRel
name|joinRel
decl_stmt|;
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
name|leftParent
init|=
name|op
operator|.
name|getParentOperators
argument_list|()
operator|.
name|get
argument_list|(
name|jc
operator|.
name|getLeft
argument_list|()
argument_list|)
decl_stmt|;
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
name|rightParent
init|=
name|op
operator|.
name|getParentOperators
argument_list|()
operator|.
name|get
argument_list|(
name|jc
operator|.
name|getRight
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|leftParent
operator|instanceof
name|ReduceSinkOperator
operator|&&
name|rightParent
operator|instanceof
name|ReduceSinkOperator
condition|)
block|{
name|List
argument_list|<
name|ExprNodeDesc
argument_list|>
name|leftCols
init|=
operator|(
call|(
name|ReduceSinkDesc
call|)
argument_list|(
name|leftParent
operator|.
name|getConf
argument_list|()
argument_list|)
operator|)
operator|.
name|getKeyCols
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|ExprNodeDesc
argument_list|>
name|rightCols
init|=
operator|(
call|(
name|ReduceSinkDesc
call|)
argument_list|(
name|rightParent
operator|.
name|getConf
argument_list|()
argument_list|)
operator|)
operator|.
name|getKeyCols
argument_list|()
decl_stmt|;
name|RexNode
name|joinPredicate
init|=
literal|null
decl_stmt|;
name|JoinRelType
name|joinType
init|=
name|JoinRelType
operator|.
name|INNER
decl_stmt|;
name|int
name|rightColOffSet
init|=
name|leftRel
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldCount
argument_list|()
decl_stmt|;
comment|// TODO: what about semi join
switch|switch
condition|(
name|jc
operator|.
name|getType
argument_list|()
condition|)
block|{
case|case
name|JoinDesc
operator|.
name|INNER_JOIN
case|:
name|joinType
operator|=
name|JoinRelType
operator|.
name|INNER
expr_stmt|;
break|break;
case|case
name|JoinDesc
operator|.
name|LEFT_OUTER_JOIN
case|:
name|joinType
operator|=
name|JoinRelType
operator|.
name|LEFT
expr_stmt|;
break|break;
case|case
name|JoinDesc
operator|.
name|RIGHT_OUTER_JOIN
case|:
name|joinType
operator|=
name|JoinRelType
operator|.
name|RIGHT
expr_stmt|;
break|break;
case|case
name|JoinDesc
operator|.
name|FULL_OUTER_JOIN
case|:
name|joinType
operator|=
name|JoinRelType
operator|.
name|FULL
expr_stmt|;
break|break;
block|}
name|int
name|i
init|=
literal|0
decl_stmt|;
for|for
control|(
name|ExprNodeDesc
name|expr
range|:
name|leftCols
control|)
block|{
name|List
argument_list|<
name|RexNode
argument_list|>
name|eqExpr
init|=
operator|new
name|LinkedList
argument_list|<
name|RexNode
argument_list|>
argument_list|()
decl_stmt|;
name|eqExpr
operator|.
name|add
argument_list|(
name|ctx
operator|.
name|convertToOptiqExpr
argument_list|(
name|expr
argument_list|,
name|leftRel
argument_list|,
literal|0
argument_list|,
literal|false
argument_list|)
argument_list|)
expr_stmt|;
name|eqExpr
operator|.
name|add
argument_list|(
name|ctx
operator|.
name|convertToOptiqExpr
argument_list|(
name|rightCols
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|,
name|rightRel
argument_list|,
name|rightColOffSet
argument_list|,
literal|false
argument_list|)
argument_list|)
expr_stmt|;
name|RexNode
name|eqOp
init|=
name|ctx
operator|.
name|cluster
operator|.
name|getRexBuilder
argument_list|()
operator|.
name|makeCall
argument_list|(
name|SqlStdOperatorTable
operator|.
name|EQUALS
argument_list|,
name|eqExpr
argument_list|)
decl_stmt|;
name|i
operator|++
expr_stmt|;
if|if
condition|(
name|joinPredicate
operator|==
literal|null
condition|)
block|{
name|joinPredicate
operator|=
name|eqOp
expr_stmt|;
block|}
else|else
block|{
name|List
argument_list|<
name|RexNode
argument_list|>
name|conjElements
init|=
operator|new
name|LinkedList
argument_list|<
name|RexNode
argument_list|>
argument_list|()
decl_stmt|;
name|conjElements
operator|.
name|add
argument_list|(
name|joinPredicate
argument_list|)
expr_stmt|;
name|conjElements
operator|.
name|add
argument_list|(
name|eqOp
argument_list|)
expr_stmt|;
name|joinPredicate
operator|=
name|ctx
operator|.
name|cluster
operator|.
name|getRexBuilder
argument_list|()
operator|.
name|makeCall
argument_list|(
name|SqlStdOperatorTable
operator|.
name|AND
argument_list|,
name|conjElements
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Translate non-joinkey predicate
name|Set
argument_list|<
name|Entry
argument_list|<
name|Byte
argument_list|,
name|List
argument_list|<
name|ExprNodeDesc
argument_list|>
argument_list|>
argument_list|>
name|filterExprSet
init|=
name|op
operator|.
name|getConf
argument_list|()
operator|.
name|getFilters
argument_list|()
operator|.
name|entrySet
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|filterExprSet
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|RexNode
name|eqExpr
decl_stmt|;
name|int
name|colOffSet
decl_stmt|;
name|RelNode
name|childRel
decl_stmt|;
name|Operator
name|parentHiveOp
decl_stmt|;
name|int
name|inputId
decl_stmt|;
for|for
control|(
name|Entry
argument_list|<
name|Byte
argument_list|,
name|List
argument_list|<
name|ExprNodeDesc
argument_list|>
argument_list|>
name|entry
range|:
name|filterExprSet
control|)
block|{
name|inputId
operator|=
name|entry
operator|.
name|getKey
argument_list|()
operator|.
name|intValue
argument_list|()
expr_stmt|;
if|if
condition|(
name|inputId
operator|==
literal|0
condition|)
block|{
name|colOffSet
operator|=
literal|0
expr_stmt|;
name|childRel
operator|=
name|leftRel
expr_stmt|;
name|parentHiveOp
operator|=
name|leftParent
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|inputId
operator|==
literal|1
condition|)
block|{
name|colOffSet
operator|=
name|rightColOffSet
expr_stmt|;
name|childRel
operator|=
name|rightRel
expr_stmt|;
name|parentHiveOp
operator|=
name|rightParent
expr_stmt|;
block|}
else|else
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Invalid Join Input"
argument_list|)
throw|;
block|}
for|for
control|(
name|ExprNodeDesc
name|expr
range|:
name|entry
operator|.
name|getValue
argument_list|()
control|)
block|{
name|eqExpr
operator|=
name|ctx
operator|.
name|convertToOptiqExpr
argument_list|(
name|expr
argument_list|,
name|childRel
argument_list|,
name|colOffSet
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|RexNode
argument_list|>
name|conjElements
init|=
operator|new
name|LinkedList
argument_list|<
name|RexNode
argument_list|>
argument_list|()
decl_stmt|;
name|conjElements
operator|.
name|add
argument_list|(
name|joinPredicate
argument_list|)
expr_stmt|;
name|conjElements
operator|.
name|add
argument_list|(
name|eqExpr
argument_list|)
expr_stmt|;
name|joinPredicate
operator|=
name|ctx
operator|.
name|cluster
operator|.
name|getRexBuilder
argument_list|()
operator|.
name|makeCall
argument_list|(
name|SqlStdOperatorTable
operator|.
name|AND
argument_list|,
name|conjElements
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|joinRel
operator|=
name|HiveJoinRel
operator|.
name|getJoin
argument_list|(
name|ctx
operator|.
name|cluster
argument_list|,
name|leftRel
argument_list|,
name|rightRel
argument_list|,
name|joinPredicate
argument_list|,
name|joinType
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
else|else
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Right& Left of Join Condition columns are not equal"
argument_list|)
throw|;
block|}
return|return
name|joinRel
return|;
block|}
block|}
specifier|private
specifier|static
name|int
name|convertExpr
parameter_list|(
name|Context
name|ctx
parameter_list|,
name|RelNode
name|input
parameter_list|,
name|ExprNodeDesc
name|expr
parameter_list|,
name|List
argument_list|<
name|RexNode
argument_list|>
name|extraExprs
parameter_list|)
throws|throws
name|SemanticException
block|{
specifier|final
name|RexNode
name|rex
init|=
name|ctx
operator|.
name|convertToOptiqExpr
argument_list|(
name|expr
argument_list|,
name|input
argument_list|,
literal|false
argument_list|)
decl_stmt|;
specifier|final
name|int
name|index
decl_stmt|;
if|if
condition|(
name|rex
operator|instanceof
name|RexInputRef
condition|)
block|{
name|index
operator|=
operator|(
operator|(
name|RexInputRef
operator|)
name|rex
operator|)
operator|.
name|getIndex
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|index
operator|=
name|input
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldCount
argument_list|()
operator|+
name|extraExprs
operator|.
name|size
argument_list|()
expr_stmt|;
name|extraExprs
operator|.
name|add
argument_list|(
name|rex
argument_list|)
expr_stmt|;
block|}
return|return
name|index
return|;
block|}
specifier|private
specifier|static
name|AggregateCall
name|convertAgg
parameter_list|(
name|Context
name|ctx
parameter_list|,
name|AggregationDesc
name|agg
parameter_list|,
name|RelNode
name|input
parameter_list|,
name|ColumnInfo
name|cI
parameter_list|,
name|List
argument_list|<
name|RexNode
argument_list|>
name|extraExprs
parameter_list|)
throws|throws
name|SemanticException
block|{
specifier|final
name|Aggregation
name|aggregation
init|=
name|AGG_MAP
operator|.
name|get
argument_list|(
name|agg
operator|.
name|getGenericUDAFName
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|aggregation
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|AssertionError
argument_list|(
literal|"agg not found: "
operator|+
name|agg
operator|.
name|getGenericUDAFName
argument_list|()
argument_list|)
throw|;
block|}
name|List
argument_list|<
name|Integer
argument_list|>
name|argList
init|=
operator|new
name|ArrayList
argument_list|<
name|Integer
argument_list|>
argument_list|()
decl_stmt|;
name|RelDataType
name|type
init|=
name|TypeConverter
operator|.
name|convert
argument_list|(
name|cI
operator|.
name|getType
argument_list|()
argument_list|,
name|ctx
operator|.
name|cluster
operator|.
name|getTypeFactory
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|aggregation
operator|.
name|equals
argument_list|(
name|SqlStdOperatorTable
operator|.
name|AVG
argument_list|)
condition|)
block|{
name|type
operator|=
name|type
operator|.
name|getField
argument_list|(
literal|"sum"
argument_list|,
literal|false
argument_list|)
operator|.
name|getType
argument_list|()
expr_stmt|;
block|}
for|for
control|(
name|ExprNodeDesc
name|expr
range|:
name|agg
operator|.
name|getParameters
argument_list|()
control|)
block|{
name|int
name|index
init|=
name|convertExpr
argument_list|(
name|ctx
argument_list|,
name|input
argument_list|,
name|expr
argument_list|,
name|extraExprs
argument_list|)
decl_stmt|;
name|argList
operator|.
name|add
argument_list|(
name|index
argument_list|)
expr_stmt|;
block|}
comment|/*      * set the type to the first arg, it there is one; because the RTi set on      * Aggregation call assumes this is the output type.      */
if|if
condition|(
name|argList
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
name|RexNode
name|rex
init|=
name|ctx
operator|.
name|convertToOptiqExpr
argument_list|(
name|agg
operator|.
name|getParameters
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|,
name|input
argument_list|,
literal|false
argument_list|)
decl_stmt|;
name|type
operator|=
name|rex
operator|.
name|getType
argument_list|()
expr_stmt|;
block|}
return|return
operator|new
name|AggregateCall
argument_list|(
name|aggregation
argument_list|,
name|agg
operator|.
name|getDistinct
argument_list|()
argument_list|,
name|argList
argument_list|,
name|type
argument_list|,
literal|null
argument_list|)
return|;
block|}
specifier|static
class|class
name|FilterProcessor
implements|implements
name|NodeProcessor
block|{
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
specifier|public
name|Object
name|process
parameter_list|(
name|Node
name|nd
parameter_list|,
name|Stack
argument_list|<
name|Node
argument_list|>
name|stack
parameter_list|,
name|NodeProcessorCtx
name|procCtx
parameter_list|,
name|Object
modifier|...
name|nodeOutputs
parameter_list|)
throws|throws
name|SemanticException
block|{
name|Context
name|ctx
init|=
operator|(
name|Context
operator|)
name|procCtx
decl_stmt|;
name|HiveRel
name|input
init|=
operator|(
name|HiveRel
operator|)
name|ctx
operator|.
name|getParentNode
argument_list|(
operator|(
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
operator|)
name|nd
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|FilterOperator
name|filterOp
init|=
operator|(
name|FilterOperator
operator|)
name|nd
decl_stmt|;
name|RexNode
name|convertedFilterExpr
init|=
name|ctx
operator|.
name|convertToOptiqExpr
argument_list|(
name|filterOp
operator|.
name|getConf
argument_list|()
operator|.
name|getPredicate
argument_list|()
argument_list|,
name|input
argument_list|,
literal|true
argument_list|)
decl_stmt|;
comment|// Flatten the condition otherwise Optiq chokes on assertion
comment|// (FilterRelBase)
if|if
condition|(
name|convertedFilterExpr
operator|instanceof
name|RexCall
condition|)
block|{
name|RexCall
name|call
init|=
operator|(
name|RexCall
operator|)
name|convertedFilterExpr
decl_stmt|;
name|convertedFilterExpr
operator|=
name|ctx
operator|.
name|cluster
operator|.
name|getRexBuilder
argument_list|()
operator|.
name|makeCall
argument_list|(
name|call
operator|.
name|getType
argument_list|()
argument_list|,
name|call
operator|.
name|getOperator
argument_list|()
argument_list|,
name|RexUtil
operator|.
name|flatten
argument_list|(
name|call
operator|.
name|getOperands
argument_list|()
argument_list|,
name|call
operator|.
name|getOperator
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|HiveRel
name|filtRel
init|=
operator|new
name|HiveFilterRel
argument_list|(
name|ctx
operator|.
name|cluster
argument_list|,
name|ctx
operator|.
name|cluster
operator|.
name|traitSetOf
argument_list|(
name|HiveRel
operator|.
name|CONVENTION
argument_list|)
argument_list|,
name|input
argument_list|,
name|convertedFilterExpr
argument_list|)
decl_stmt|;
name|ctx
operator|.
name|propagatePosMap
argument_list|(
name|filtRel
argument_list|,
name|input
argument_list|)
expr_stmt|;
name|ctx
operator|.
name|hiveOpToRelNode
operator|.
name|put
argument_list|(
name|filterOp
argument_list|,
name|filtRel
argument_list|)
expr_stmt|;
return|return
name|filtRel
return|;
block|}
block|}
specifier|static
class|class
name|SelectProcessor
implements|implements
name|NodeProcessor
block|{
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
specifier|public
name|Object
name|process
parameter_list|(
name|Node
name|nd
parameter_list|,
name|Stack
argument_list|<
name|Node
argument_list|>
name|stack
parameter_list|,
name|NodeProcessorCtx
name|procCtx
parameter_list|,
name|Object
modifier|...
name|nodeOutputs
parameter_list|)
throws|throws
name|SemanticException
block|{
name|Context
name|ctx
init|=
operator|(
name|Context
operator|)
name|procCtx
decl_stmt|;
name|HiveRel
name|inputRelNode
init|=
operator|(
name|HiveRel
operator|)
name|ctx
operator|.
name|getParentNode
argument_list|(
operator|(
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
operator|)
name|nd
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|SelectOperator
name|selectOp
init|=
operator|(
name|SelectOperator
operator|)
name|nd
decl_stmt|;
name|List
argument_list|<
name|ExprNodeDesc
argument_list|>
name|colLst
init|=
name|selectOp
operator|.
name|getConf
argument_list|()
operator|.
name|getColList
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|RexNode
argument_list|>
name|optiqColLst
init|=
operator|new
name|LinkedList
argument_list|<
name|RexNode
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|ExprNodeDesc
name|colExpr
range|:
name|colLst
control|)
block|{
name|optiqColLst
operator|.
name|add
argument_list|(
name|ctx
operator|.
name|convertToOptiqExpr
argument_list|(
name|colExpr
argument_list|,
name|inputRelNode
argument_list|,
literal|false
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/*        * Hive treats names that start with '_c' as internalNames; so change the        * names so we don't run into this issue when converting back to Hive AST.        */
name|List
argument_list|<
name|String
argument_list|>
name|oFieldNames
init|=
name|Lists
operator|.
name|transform
argument_list|(
name|selectOp
operator|.
name|getConf
argument_list|()
operator|.
name|getOutputColumnNames
argument_list|()
argument_list|,
operator|new
name|Function
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
argument_list|()
block|{
specifier|public
name|String
name|apply
parameter_list|(
name|String
name|hName
parameter_list|)
block|{
return|return
literal|"_o_"
operator|+
name|hName
return|;
block|}
block|}
argument_list|)
decl_stmt|;
name|HiveRel
name|selRel
init|=
name|HiveProjectRel
operator|.
name|create
argument_list|(
name|inputRelNode
argument_list|,
name|optiqColLst
argument_list|,
name|oFieldNames
argument_list|)
decl_stmt|;
name|ctx
operator|.
name|buildColumnMap
argument_list|(
name|selectOp
argument_list|,
name|selRel
argument_list|)
expr_stmt|;
name|ctx
operator|.
name|hiveOpToRelNode
operator|.
name|put
argument_list|(
name|selectOp
argument_list|,
name|selRel
argument_list|)
expr_stmt|;
return|return
name|selRel
return|;
block|}
block|}
specifier|static
class|class
name|LimitProcessor
implements|implements
name|NodeProcessor
block|{
specifier|public
name|Object
name|process
parameter_list|(
name|Node
name|nd
parameter_list|,
name|Stack
argument_list|<
name|Node
argument_list|>
name|stack
parameter_list|,
name|NodeProcessorCtx
name|procCtx
parameter_list|,
name|Object
modifier|...
name|nodeOutputs
parameter_list|)
throws|throws
name|SemanticException
block|{
name|Context
name|ctx
init|=
operator|(
name|Context
operator|)
name|procCtx
decl_stmt|;
name|HiveRel
name|input
init|=
operator|(
name|HiveRel
operator|)
name|ctx
operator|.
name|getParentNode
argument_list|(
operator|(
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
operator|)
name|nd
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|LimitOperator
name|limitOp
init|=
operator|(
name|LimitOperator
operator|)
name|nd
decl_stmt|;
comment|// in Optiq, a limit is represented as a sort on 0 columns
specifier|final
name|RexNode
name|fetch
decl_stmt|;
if|if
condition|(
name|limitOp
operator|.
name|getConf
argument_list|()
operator|.
name|getLimit
argument_list|()
operator|>=
literal|0
condition|)
block|{
name|fetch
operator|=
name|ctx
operator|.
name|cluster
operator|.
name|getRexBuilder
argument_list|()
operator|.
name|makeExactLiteral
argument_list|(
name|BigDecimal
operator|.
name|valueOf
argument_list|(
name|limitOp
operator|.
name|getConf
argument_list|()
operator|.
name|getLimit
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fetch
operator|=
literal|null
expr_stmt|;
block|}
name|RelTraitSet
name|traitSet
init|=
name|ctx
operator|.
name|cluster
operator|.
name|traitSetOf
argument_list|(
name|HiveRel
operator|.
name|CONVENTION
argument_list|)
decl_stmt|;
name|RelCollation
name|canonizedCollation
init|=
name|traitSet
operator|.
name|canonize
argument_list|(
name|RelCollationImpl
operator|.
name|EMPTY
argument_list|)
decl_stmt|;
name|HiveRel
name|sortRel
init|=
operator|new
name|HiveSortRel
argument_list|(
name|ctx
operator|.
name|cluster
argument_list|,
name|traitSet
argument_list|,
name|input
argument_list|,
name|canonizedCollation
argument_list|,
literal|null
argument_list|,
name|fetch
argument_list|)
decl_stmt|;
name|ctx
operator|.
name|propagatePosMap
argument_list|(
name|sortRel
argument_list|,
name|input
argument_list|)
expr_stmt|;
name|ctx
operator|.
name|hiveOpToRelNode
operator|.
name|put
argument_list|(
name|limitOp
argument_list|,
name|sortRel
argument_list|)
expr_stmt|;
return|return
name|sortRel
return|;
block|}
block|}
specifier|static
class|class
name|GroupByProcessor
implements|implements
name|NodeProcessor
block|{
specifier|public
name|Object
name|process
parameter_list|(
name|Node
name|nd
parameter_list|,
name|Stack
argument_list|<
name|Node
argument_list|>
name|stack
parameter_list|,
name|NodeProcessorCtx
name|procCtx
parameter_list|,
name|Object
modifier|...
name|nodeOutputs
parameter_list|)
throws|throws
name|SemanticException
block|{
name|Context
name|ctx
init|=
operator|(
name|Context
operator|)
name|procCtx
decl_stmt|;
name|HiveRel
name|input
init|=
operator|(
name|HiveRel
operator|)
name|ctx
operator|.
name|getParentNode
argument_list|(
operator|(
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
operator|)
name|nd
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|GroupByOperator
name|groupByOp
init|=
operator|(
name|GroupByOperator
operator|)
name|nd
decl_stmt|;
name|RowResolver
name|rr
init|=
name|ctx
operator|.
name|sA
operator|.
name|getRowResolver
argument_list|(
name|groupByOp
argument_list|)
decl_stmt|;
name|ArrayList
argument_list|<
name|ColumnInfo
argument_list|>
name|signature
init|=
name|rr
operator|.
name|getRowSchema
argument_list|()
operator|.
name|getSignature
argument_list|()
decl_stmt|;
comment|// GroupBy is represented by two operators, one map side and one reduce
comment|// side. We only translate the map-side one.
if|if
condition|(
name|groupByOp
operator|.
name|getParentOperators
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|instanceof
name|ReduceSinkOperator
condition|)
block|{
name|ctx
operator|.
name|hiveOpToRelNode
operator|.
name|put
argument_list|(
name|groupByOp
argument_list|,
name|input
argument_list|)
expr_stmt|;
return|return
name|input
return|;
block|}
specifier|final
name|List
argument_list|<
name|RexNode
argument_list|>
name|extraExprs
init|=
name|Lists
operator|.
name|newArrayList
argument_list|()
decl_stmt|;
specifier|final
name|BitSet
name|groupSet
init|=
operator|new
name|BitSet
argument_list|()
decl_stmt|;
for|for
control|(
name|ExprNodeDesc
name|key
range|:
name|groupByOp
operator|.
name|getConf
argument_list|()
operator|.
name|getKeys
argument_list|()
control|)
block|{
name|int
name|index
init|=
name|convertExpr
argument_list|(
name|ctx
argument_list|,
name|input
argument_list|,
name|key
argument_list|,
name|extraExprs
argument_list|)
decl_stmt|;
name|groupSet
operator|.
name|set
argument_list|(
name|index
argument_list|)
expr_stmt|;
block|}
name|List
argument_list|<
name|AggregateCall
argument_list|>
name|aggregateCalls
init|=
name|Lists
operator|.
name|newArrayList
argument_list|()
decl_stmt|;
name|int
name|i
init|=
name|groupByOp
operator|.
name|getConf
argument_list|()
operator|.
name|getKeys
argument_list|()
operator|.
name|size
argument_list|()
decl_stmt|;
for|for
control|(
name|AggregationDesc
name|agg
range|:
name|groupByOp
operator|.
name|getConf
argument_list|()
operator|.
name|getAggregators
argument_list|()
control|)
block|{
name|aggregateCalls
operator|.
name|add
argument_list|(
name|convertAgg
argument_list|(
name|ctx
argument_list|,
name|agg
argument_list|,
name|input
argument_list|,
name|signature
operator|.
name|get
argument_list|(
name|i
operator|++
argument_list|)
argument_list|,
name|extraExprs
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|extraExprs
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
comment|// noinspection unchecked
name|input
operator|=
name|HiveProjectRel
operator|.
name|create
argument_list|(
name|input
argument_list|,
name|CompositeList
operator|.
name|of
argument_list|(
name|Lists
operator|.
name|transform
argument_list|(
name|input
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldList
argument_list|()
argument_list|,
operator|new
name|Function
argument_list|<
name|RelDataTypeField
argument_list|,
name|RexNode
argument_list|>
argument_list|()
block|{
specifier|public
name|RexNode
name|apply
parameter_list|(
name|RelDataTypeField
name|input
parameter_list|)
block|{
return|return
operator|new
name|RexInputRef
argument_list|(
name|input
operator|.
name|getIndex
argument_list|()
argument_list|,
name|input
operator|.
name|getType
argument_list|()
argument_list|)
return|;
block|}
block|}
argument_list|)
argument_list|,
name|extraExprs
argument_list|)
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
try|try
block|{
name|HiveRel
name|aggregateRel
init|=
operator|new
name|HiveAggregateRel
argument_list|(
name|ctx
operator|.
name|cluster
argument_list|,
name|ctx
operator|.
name|cluster
operator|.
name|traitSetOf
argument_list|(
name|HiveRel
operator|.
name|CONVENTION
argument_list|)
argument_list|,
name|input
argument_list|,
name|groupSet
argument_list|,
name|aggregateCalls
argument_list|)
decl_stmt|;
name|ctx
operator|.
name|buildColumnMap
argument_list|(
name|groupByOp
argument_list|,
name|aggregateRel
argument_list|)
expr_stmt|;
name|ctx
operator|.
name|hiveOpToRelNode
operator|.
name|put
argument_list|(
name|groupByOp
argument_list|,
name|aggregateRel
argument_list|)
expr_stmt|;
return|return
name|aggregateRel
return|;
block|}
catch|catch
parameter_list|(
name|InvalidRelException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|AssertionError
argument_list|(
name|e
argument_list|)
throw|;
comment|// not possible
block|}
block|}
block|}
specifier|static
class|class
name|ReduceSinkProcessor
implements|implements
name|NodeProcessor
block|{
specifier|public
name|Object
name|process
parameter_list|(
name|Node
name|nd
parameter_list|,
name|Stack
argument_list|<
name|Node
argument_list|>
name|stack
parameter_list|,
name|NodeProcessorCtx
name|procCtx
parameter_list|,
name|Object
modifier|...
name|nodeOutputs
parameter_list|)
throws|throws
name|SemanticException
block|{
name|Context
name|ctx
init|=
operator|(
name|Context
operator|)
name|procCtx
decl_stmt|;
name|HiveRel
name|input
init|=
operator|(
name|HiveRel
operator|)
name|ctx
operator|.
name|getParentNode
argument_list|(
operator|(
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
operator|)
name|nd
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|ReduceSinkOperator
name|sinkOp
init|=
operator|(
name|ReduceSinkOperator
operator|)
name|nd
decl_stmt|;
comment|// It is a sort reducer if and only if the number of reducers is 1.
specifier|final
name|ReduceSinkDesc
name|conf
init|=
name|sinkOp
operator|.
name|getConf
argument_list|()
decl_stmt|;
if|if
condition|(
name|conf
operator|.
name|getNumReducers
argument_list|()
operator|!=
literal|1
condition|)
block|{
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
name|op
init|=
operator|(
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
operator|)
name|nd
decl_stmt|;
name|ctx
operator|.
name|hiveOpToRelNode
operator|.
name|put
argument_list|(
name|op
argument_list|,
name|input
argument_list|)
expr_stmt|;
return|return
name|input
return|;
block|}
specifier|final
name|String
name|order
init|=
name|conf
operator|.
name|getOrder
argument_list|()
decl_stmt|;
comment|// "+-" means "ASC, DESC"
assert|assert
name|order
operator|.
name|length
argument_list|()
operator|==
name|conf
operator|.
name|getKeyCols
argument_list|()
operator|.
name|size
argument_list|()
assert|;
comment|/*        * numReducers == 1 and order.length = 1 => a RS for CrossJoin.        */
if|if
condition|(
name|order
operator|.
name|length
argument_list|()
operator|==
literal|0
condition|)
block|{
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
name|op
init|=
operator|(
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
operator|)
name|nd
decl_stmt|;
name|ctx
operator|.
name|hiveOpToRelNode
operator|.
name|put
argument_list|(
name|op
argument_list|,
name|input
argument_list|)
expr_stmt|;
return|return
name|input
return|;
block|}
specifier|final
name|List
argument_list|<
name|RelFieldCollation
argument_list|>
name|fieldCollations
init|=
name|Lists
operator|.
name|newArrayList
argument_list|()
decl_stmt|;
specifier|final
name|List
argument_list|<
name|RexNode
argument_list|>
name|extraExprs
init|=
name|Lists
operator|.
name|newArrayList
argument_list|()
decl_stmt|;
for|for
control|(
name|Pair
argument_list|<
name|ExprNodeDesc
argument_list|,
name|Character
argument_list|>
name|pair
range|:
name|Pair
operator|.
name|zip
argument_list|(
name|conf
operator|.
name|getKeyCols
argument_list|()
argument_list|,
name|Lists
operator|.
name|charactersOf
argument_list|(
name|order
argument_list|)
argument_list|)
control|)
block|{
name|int
name|index
init|=
name|convertExpr
argument_list|(
name|ctx
argument_list|,
name|input
argument_list|,
name|pair
operator|.
name|left
argument_list|,
name|extraExprs
argument_list|)
decl_stmt|;
name|RelFieldCollation
operator|.
name|Direction
name|direction
init|=
name|getDirection
argument_list|(
name|pair
operator|.
name|right
argument_list|)
decl_stmt|;
name|fieldCollations
operator|.
name|add
argument_list|(
operator|new
name|RelFieldCollation
argument_list|(
name|index
argument_list|,
name|direction
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|extraExprs
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
comment|// noinspection unchecked
name|input
operator|=
name|HiveProjectRel
operator|.
name|create
argument_list|(
name|input
argument_list|,
name|CompositeList
operator|.
name|of
argument_list|(
name|Lists
operator|.
name|transform
argument_list|(
name|input
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldList
argument_list|()
argument_list|,
operator|new
name|Function
argument_list|<
name|RelDataTypeField
argument_list|,
name|RexNode
argument_list|>
argument_list|()
block|{
specifier|public
name|RexNode
name|apply
parameter_list|(
name|RelDataTypeField
name|input
parameter_list|)
block|{
return|return
operator|new
name|RexInputRef
argument_list|(
name|input
operator|.
name|getIndex
argument_list|()
argument_list|,
name|input
operator|.
name|getType
argument_list|()
argument_list|)
return|;
block|}
block|}
argument_list|)
argument_list|,
name|extraExprs
argument_list|)
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
name|RelTraitSet
name|traitSet
init|=
name|ctx
operator|.
name|cluster
operator|.
name|traitSetOf
argument_list|(
name|HiveRel
operator|.
name|CONVENTION
argument_list|)
decl_stmt|;
name|RelCollation
name|canonizedCollation
init|=
name|traitSet
operator|.
name|canonize
argument_list|(
name|RelCollationImpl
operator|.
name|of
argument_list|(
name|fieldCollations
argument_list|)
argument_list|)
decl_stmt|;
name|HiveRel
name|sortRel
init|=
operator|new
name|HiveSortRel
argument_list|(
name|ctx
operator|.
name|cluster
argument_list|,
name|traitSet
argument_list|,
name|input
argument_list|,
name|canonizedCollation
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
decl_stmt|;
name|ctx
operator|.
name|propagatePosMap
argument_list|(
name|sortRel
argument_list|,
name|input
argument_list|)
expr_stmt|;
name|ctx
operator|.
name|hiveOpToRelNode
operator|.
name|put
argument_list|(
name|sinkOp
argument_list|,
name|sortRel
argument_list|)
expr_stmt|;
comment|// REVIEW: Do we need to remove the columns we added due to extraExprs?
return|return
name|sortRel
return|;
block|}
specifier|private
name|RelFieldCollation
operator|.
name|Direction
name|getDirection
parameter_list|(
name|char
name|c
parameter_list|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'+'
case|:
return|return
name|RelFieldCollation
operator|.
name|Direction
operator|.
name|ASCENDING
return|;
case|case
literal|'-'
case|:
return|return
name|RelFieldCollation
operator|.
name|Direction
operator|.
name|DESCENDING
return|;
default|default:
throw|throw
operator|new
name|AssertionError
argument_list|(
literal|"unexpected direction "
operator|+
name|c
argument_list|)
throw|;
block|}
block|}
block|}
specifier|static
class|class
name|TableScanProcessor
implements|implements
name|NodeProcessor
block|{
specifier|public
name|Object
name|process
parameter_list|(
name|Node
name|nd
parameter_list|,
name|Stack
argument_list|<
name|Node
argument_list|>
name|stack
parameter_list|,
name|NodeProcessorCtx
name|procCtx
parameter_list|,
name|Object
modifier|...
name|nodeOutputs
parameter_list|)
throws|throws
name|SemanticException
block|{
name|Context
name|ctx
init|=
operator|(
name|Context
operator|)
name|procCtx
decl_stmt|;
name|TableScanOperator
name|tableScanOp
init|=
operator|(
name|TableScanOperator
operator|)
name|nd
decl_stmt|;
name|RowResolver
name|rr
init|=
name|ctx
operator|.
name|sA
operator|.
name|getRowResolver
argument_list|(
name|tableScanOp
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|neededCols
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|(
name|tableScanOp
operator|.
name|getNeededColumns
argument_list|()
argument_list|)
decl_stmt|;
name|Statistics
name|stats
init|=
name|tableScanOp
operator|.
name|getStatistics
argument_list|()
decl_stmt|;
try|try
block|{
name|stats
operator|=
name|addPartitionColumns
argument_list|(
name|ctx
argument_list|,
name|tableScanOp
argument_list|,
name|tableScanOp
operator|.
name|getConf
argument_list|()
operator|.
name|getAlias
argument_list|()
argument_list|,
name|ctx
operator|.
name|sA
operator|.
name|getTable
argument_list|(
name|tableScanOp
argument_list|)
argument_list|,
name|stats
argument_list|,
name|neededCols
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|CloneNotSupportedException
name|ce
parameter_list|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ce
argument_list|)
throw|;
block|}
if|if
condition|(
name|stats
operator|.
name|getColumnStats
argument_list|()
operator|.
name|size
argument_list|()
operator|!=
name|neededCols
operator|.
name|size
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
literal|"Incomplete Col stats for table: "
operator|+
name|tableScanOp
operator|.
name|getConf
argument_list|()
operator|.
name|getAlias
argument_list|()
argument_list|)
throw|;
block|}
name|RelDataType
name|rowType
init|=
name|TypeConverter
operator|.
name|getType
argument_list|(
name|ctx
operator|.
name|cluster
argument_list|,
name|rr
argument_list|,
name|neededCols
argument_list|)
decl_stmt|;
name|RelOptHiveTable
name|optTable
init|=
operator|new
name|RelOptHiveTable
argument_list|(
name|ctx
operator|.
name|schema
argument_list|,
name|tableScanOp
operator|.
name|getConf
argument_list|()
operator|.
name|getAlias
argument_list|()
argument_list|,
name|rowType
argument_list|,
name|ctx
operator|.
name|sA
operator|.
name|getTable
argument_list|(
name|tableScanOp
argument_list|)
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
decl_stmt|;
name|TableAccessRelBase
name|tableRel
init|=
operator|new
name|HiveTableScanRel
argument_list|(
name|ctx
operator|.
name|cluster
argument_list|,
name|ctx
operator|.
name|cluster
operator|.
name|traitSetOf
argument_list|(
name|HiveRel
operator|.
name|CONVENTION
argument_list|)
argument_list|,
name|optTable
argument_list|,
name|rowType
argument_list|)
decl_stmt|;
name|ctx
operator|.
name|buildColumnMap
argument_list|(
name|tableScanOp
argument_list|,
name|tableRel
argument_list|)
expr_stmt|;
name|ctx
operator|.
name|hiveOpToRelNode
operator|.
name|put
argument_list|(
name|tableScanOp
argument_list|,
name|tableRel
argument_list|)
expr_stmt|;
return|return
name|tableRel
return|;
block|}
comment|/*      * Add partition columns to needed columns and fake the COlStats for it.      */
specifier|private
name|Statistics
name|addPartitionColumns
parameter_list|(
name|Context
name|ctx
parameter_list|,
name|TableScanOperator
name|tableScanOp
parameter_list|,
name|String
name|tblAlias
parameter_list|,
name|Table
name|tbl
parameter_list|,
name|Statistics
name|stats
parameter_list|,
name|List
argument_list|<
name|String
argument_list|>
name|neededCols
parameter_list|)
throws|throws
name|CloneNotSupportedException
block|{
if|if
condition|(
operator|!
name|tbl
operator|.
name|isPartitioned
argument_list|()
condition|)
block|{
return|return
name|stats
return|;
block|}
name|List
argument_list|<
name|ColStatistics
argument_list|>
name|pStats
init|=
operator|new
name|ArrayList
argument_list|<
name|ColStatistics
argument_list|>
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|FieldSchema
argument_list|>
name|pCols
init|=
name|tbl
operator|.
name|getPartCols
argument_list|()
decl_stmt|;
for|for
control|(
name|FieldSchema
name|pC
range|:
name|pCols
control|)
block|{
name|neededCols
operator|.
name|add
argument_list|(
name|pC
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
name|ColStatistics
name|cStats
init|=
name|stats
operator|.
name|getColumnStatisticsForColumn
argument_list|(
name|tblAlias
argument_list|,
name|pC
operator|.
name|getName
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|cStats
operator|==
literal|null
condition|)
block|{
name|PrunedPartitionList
name|partList
init|=
name|ctx
operator|.
name|parseCtx
operator|.
name|getOpToPartList
argument_list|()
operator|.
name|get
argument_list|(
name|tableScanOp
argument_list|)
decl_stmt|;
name|cStats
operator|=
operator|new
name|ColStatistics
argument_list|(
name|tblAlias
argument_list|,
name|pC
operator|.
name|getName
argument_list|()
argument_list|,
name|pC
operator|.
name|getType
argument_list|()
argument_list|)
expr_stmt|;
name|cStats
operator|.
name|setCountDistint
argument_list|(
name|partList
operator|.
name|getPartitions
argument_list|()
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|pStats
operator|.
name|add
argument_list|(
name|cStats
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|pStats
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
name|stats
operator|=
name|stats
operator|.
name|clone
argument_list|()
expr_stmt|;
name|stats
operator|.
name|addToColumnStats
argument_list|(
name|pStats
argument_list|)
expr_stmt|;
block|}
return|return
name|stats
return|;
block|}
block|}
specifier|static
class|class
name|DefaultProcessor
implements|implements
name|NodeProcessor
block|{
specifier|public
name|Object
name|process
parameter_list|(
name|Node
name|nd
parameter_list|,
name|Stack
argument_list|<
name|Node
argument_list|>
name|stack
parameter_list|,
name|NodeProcessorCtx
name|procCtx
parameter_list|,
name|Object
modifier|...
name|nodeOutputs
parameter_list|)
throws|throws
name|SemanticException
block|{
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
name|op
init|=
operator|(
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
operator|)
name|nd
decl_stmt|;
name|Context
name|ctx
init|=
operator|(
name|Context
operator|)
name|procCtx
decl_stmt|;
name|RelNode
name|node
init|=
operator|(
name|HiveRel
operator|)
name|ctx
operator|.
name|getParentNode
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|ctx
operator|.
name|hiveOpToRelNode
operator|.
name|put
argument_list|(
name|op
argument_list|,
name|node
argument_list|)
expr_stmt|;
return|return
name|node
return|;
block|}
block|}
block|}
end_class

end_unit

