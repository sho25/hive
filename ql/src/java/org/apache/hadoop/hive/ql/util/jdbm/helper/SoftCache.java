begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_comment
comment|/**  * JDBM LICENSE v1.00  *  * Redistribution and use of this software and associated documentation  * ("Software"), with or without modification, are permitted provided  * that the following conditions are met:  *  * 1. Redistributions of source code must retain copyright  *    statements and notices.  Redistributions must also contain a  *    copy of this document.  *  * 2. Redistributions in binary form must reproduce the  *    above copyright notice, this list of conditions and the  *    following disclaimer in the documentation and/or other  *    materials provided with the distribution.  *  * 3. The name "JDBM" must not be used to endorse or promote  *    products derived from this Software without prior written  *    permission of Cees de Groot.  For written permission,  *    please contact cg@cdegroot.com.  *  * 4. Products derived from this Software may not be called "JDBM"  *    nor may "JDBM" appear in their names without prior written  *    permission of Cees de Groot.  *  * 5. Due credit should be given to the JDBM Project  *    (http://jdbm.sourceforge.net/).  *  * THIS SOFTWARE IS PROVIDED BY THE JDBM PROJECT AND CONTRIBUTORS  * ``AS IS'' AND ANY EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT  * NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND  * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL  * CEES DE GROOT OR ANY CONTRIBUTORS BE LIABLE FOR ANY DIRECT,  * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR  * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,  * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED  * OF THE POSSIBILITY OF SUCH DAMAGE.  *  * Copyright 2000 (C) Cees de Groot. All Rights Reserved.  * Contributions are Copyright (C) 2000 by their associated contributors.  *  * $Id  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|util
operator|.
name|jdbm
operator|.
name|helper
package|;
end_package

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|ref
operator|.
name|Reference
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|ref
operator|.
name|ReferenceQueue
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|ref
operator|.
name|SoftReference
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Enumeration
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_comment
comment|/**  * Wraps a deterministic cache policy with a<q>Level-2</q> cache based on  * J2SE's {@link SoftReference soft references}. Soft references allow this  * cache to keep references to objects until the memory they occupy is required  * elsewhere.  *<p>  * Since the {@link CachePolicy} interface requires an event be fired when an  * object is evicted, and the event contains the actual object, this class  * cannot be a stand-alone implementation of<code>CachePolicy</code>. This  * limitation arises because Java References does not support notification  * before references are cleared; nor do they support reaching soft referents.  * Therefore, this wrapper cache aggressively notifies evictions: events are  * fired when the objects are evicted from the internal cache. Consequently, the  * soft cache may return a non-null object when<code>get( )</code> is called,  * even if that object was said to have been evicted.  *<p>  * The current implementation uses a hash structure for its internal key to  * value mappings.  *<p>  * Note: this component's publicly exposed methods are not threadsafe;  * potentially concurrent code should synchronize on the cache instance.  *   * @author<a href="mailto:dranatunga@users.sourceforge.net">Dilum Ranatunga</a>  * @version $Id: SoftCache.java,v 1.1 2003/11/01 13:29:27 dranatunga Exp $  */
end_comment

begin_class
specifier|public
class|class
name|SoftCache
implements|implements
name|CachePolicy
block|{
specifier|private
specifier|static
specifier|final
name|int
name|INITIAL_CAPACITY
init|=
literal|128
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|float
name|DEFAULT_LOAD_FACTOR
init|=
literal|1.5f
decl_stmt|;
specifier|private
specifier|final
name|ReferenceQueue
name|_clearQueue
init|=
operator|new
name|ReferenceQueue
argument_list|()
decl_stmt|;
specifier|private
specifier|final
name|CachePolicy
name|_internal
decl_stmt|;
specifier|private
specifier|final
name|Map
name|_cacheMap
decl_stmt|;
comment|/**    * Creates a soft-reference based L2 cache with a {@link MRU} cache as the    * internal (L1) cache. The soft reference cache uses the default load    * capacity of 1.5f, which is intended to sacrifice some performance for    * space. This compromise is reasonable, since all {@link #get(Object) get(    * )s} first try the L1 cache anyway. The internal MRU is given a capacity of    * 128 elements.    */
specifier|public
name|SoftCache
parameter_list|()
block|{
name|this
argument_list|(
operator|new
name|MRU
argument_list|(
name|INITIAL_CAPACITY
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**    * Creates a soft-reference based L2 cache wrapping the specified L1 cache.    *     * @param internal    *          non null internal cache.    * @throws NullPointerException    *           if the internal cache is null.    */
specifier|public
name|SoftCache
parameter_list|(
name|CachePolicy
name|internal
parameter_list|)
throws|throws
name|NullPointerException
block|{
name|this
argument_list|(
name|DEFAULT_LOAD_FACTOR
argument_list|,
name|internal
argument_list|)
expr_stmt|;
block|}
comment|/**    * Creates a soft-reference based L2 cache wrapping the specified L1 cache.    * This constructor is somewhat implementation-specific, so users are    * encouraged to use {@link #SoftCache(CachePolicy)} instead.    *     * @param loadFactor    *          load factor that the soft cache's hash structure should use.    * @param internal    *          non null internal cache.    * @throws IllegalArgumentException    *           if the load factor is nonpositive.    * @throws NullPointerException    *           if the internal cache is null.    */
specifier|public
name|SoftCache
parameter_list|(
name|float
name|loadFactor
parameter_list|,
name|CachePolicy
name|internal
parameter_list|)
throws|throws
name|IllegalArgumentException
throws|,
name|NullPointerException
block|{
if|if
condition|(
name|internal
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|NullPointerException
argument_list|(
literal|"Internal cache cannot be null."
argument_list|)
throw|;
block|}
name|_internal
operator|=
name|internal
expr_stmt|;
name|_cacheMap
operator|=
operator|new
name|HashMap
argument_list|(
name|INITIAL_CAPACITY
argument_list|,
name|loadFactor
argument_list|)
expr_stmt|;
block|}
comment|/**    * Adds the specified value to the cache under the specified key. Note that    * the object is added to both this and the internal cache.    *     * @param key    *          the (non-null) key to store the object under    * @param value    *          the (non-null) object to place in the cache    * @throws CacheEvictionException    *           exception that the internal cache would have experienced while    *           evicting an object it currently cached.    */
specifier|public
name|void
name|put
parameter_list|(
name|Object
name|key
parameter_list|,
name|Object
name|value
parameter_list|)
throws|throws
name|CacheEvictionException
block|{
if|if
condition|(
name|key
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"key cannot be null."
argument_list|)
throw|;
block|}
elseif|else
if|if
condition|(
name|value
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"value cannot be null."
argument_list|)
throw|;
block|}
name|_internal
operator|.
name|put
argument_list|(
name|key
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|removeClearedEntries
argument_list|()
expr_stmt|;
name|_cacheMap
operator|.
name|put
argument_list|(
name|key
argument_list|,
operator|new
name|Entry
argument_list|(
name|key
argument_list|,
name|value
argument_list|,
name|_clearQueue
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**    * Gets the object cached under the specified key.    *<p>    * The cache is looked up in the following manner:    *<ol>    *<li>The internal (L1) cache is checked. If the object is found, it is    * returned.</li>    *<li>This (L2) cache is checked. If the object is not found, then the caller    * is informed that the object is inaccessible.</li>    *<li>Since the object exists in L2, but not in L1, the object is readded to    * L1 using {@link CachePolicy#put(Object, Object)}.</li>    *<li>If the readding succeeds, the value is returned to caller.</li>    *<li>If a cache eviction exception is encountered instead, we remove the    * object from L2 and behave as if the object was inaccessible.</li>    *</ol>    *     * @param key    *          the key that the object was stored under.    * @return the object stored under the key specified; null if the object is    *         not (nolonger) accessible via this cache.    */
specifier|public
name|Object
name|get
parameter_list|(
name|Object
name|key
parameter_list|)
block|{
comment|// first try the internal cache.
name|Object
name|value
init|=
name|_internal
operator|.
name|get
argument_list|(
name|key
argument_list|)
decl_stmt|;
if|if
condition|(
name|value
operator|!=
literal|null
condition|)
block|{
return|return
name|value
return|;
block|}
comment|// poll and remove cleared references.
name|removeClearedEntries
argument_list|()
expr_stmt|;
name|Entry
name|entry
init|=
operator|(
name|Entry
operator|)
name|_cacheMap
operator|.
name|get
argument_list|(
name|key
argument_list|)
decl_stmt|;
if|if
condition|(
name|entry
operator|==
literal|null
condition|)
block|{
comment|// object is not in cache.
return|return
literal|null
return|;
block|}
name|value
operator|=
name|entry
operator|.
name|getValue
argument_list|()
expr_stmt|;
if|if
condition|(
name|value
operator|==
literal|null
condition|)
block|{
comment|// object was in cache, but it was cleared.
return|return
literal|null
return|;
block|}
comment|// we have the object. so we try to re-insert it into internal cache
try|try
block|{
name|_internal
operator|.
name|put
argument_list|(
name|key
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|CacheEvictionException
name|e
parameter_list|)
block|{
comment|// if the internal cache causes a fuss, we kick the object out.
name|_cacheMap
operator|.
name|remove
argument_list|(
name|key
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
return|return
name|value
return|;
block|}
comment|/**    * Removes any object stored under the key specified. Note that the object is    * removed from both this (L2) and the internal (L1) cache.    *     * @param key    *          the key whose object should be removed    */
specifier|public
name|void
name|remove
parameter_list|(
name|Object
name|key
parameter_list|)
block|{
name|_cacheMap
operator|.
name|remove
argument_list|(
name|key
argument_list|)
expr_stmt|;
name|_internal
operator|.
name|remove
argument_list|(
name|key
argument_list|)
expr_stmt|;
block|}
comment|/**    * Removes all objects in this (L2) and its internal (L1) cache.    */
specifier|public
name|void
name|removeAll
parameter_list|()
block|{
name|_cacheMap
operator|.
name|clear
argument_list|()
expr_stmt|;
name|_internal
operator|.
name|removeAll
argument_list|()
expr_stmt|;
block|}
comment|/**    * Gets all the objects stored by the internal (L1) cache.    *     * @return an enumeration of objects in internal cache.    */
specifier|public
name|Enumeration
name|elements
parameter_list|()
block|{
return|return
name|_internal
operator|.
name|elements
argument_list|()
return|;
block|}
comment|/**    * Adds the specified listener to this cache. Note that the events fired by    * this correspond to the<em>internal</em> cache's events.    *     * @param listener    *          the (non-null) listener to add to this policy    * @throws IllegalArgumentException    *           if listener is null.    */
specifier|public
name|void
name|addListener
parameter_list|(
name|CachePolicyListener
name|listener
parameter_list|)
throws|throws
name|IllegalArgumentException
block|{
name|_internal
operator|.
name|addListener
argument_list|(
name|listener
argument_list|)
expr_stmt|;
block|}
comment|/**    * Removes a listener that was added earlier.    *     * @param listener    *          the listener to remove.    */
specifier|public
name|void
name|removeListener
parameter_list|(
name|CachePolicyListener
name|listener
parameter_list|)
block|{
name|_internal
operator|.
name|removeListener
argument_list|(
name|listener
argument_list|)
expr_stmt|;
block|}
comment|/**    * Cleans the mapping structure of any obsolete entries. This is usually    * called before insertions and lookups on the mapping structure. The runtime    * of this is usually very small, but it can be as expensive as n * log(n) if    * a large number of soft references were recently cleared.    */
specifier|private
specifier|final
name|void
name|removeClearedEntries
parameter_list|()
block|{
for|for
control|(
name|Reference
name|r
init|=
name|_clearQueue
operator|.
name|poll
argument_list|()
init|;
name|r
operator|!=
literal|null
condition|;
name|r
operator|=
name|_clearQueue
operator|.
name|poll
argument_list|()
control|)
block|{
name|Object
name|key
init|=
operator|(
operator|(
name|Entry
operator|)
name|r
operator|)
operator|.
name|getKey
argument_list|()
decl_stmt|;
name|_cacheMap
operator|.
name|remove
argument_list|(
name|key
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Value objects we keep in the internal map. This contains the key in    * addition to the value, because polling for cleared references returns these    * instances, and having access to their corresponding keys drastically    * improves the performance of removing the pair from the map (see    * {@link SoftCache#removeClearedEntries()}.)    */
specifier|private
specifier|static
class|class
name|Entry
extends|extends
name|SoftReference
block|{
specifier|private
specifier|final
name|Object
name|_key
decl_stmt|;
comment|/**      * Constructor that uses<code>value</code> as the soft reference's      * referent.      */
specifier|public
name|Entry
parameter_list|(
name|Object
name|key
parameter_list|,
name|Object
name|value
parameter_list|,
name|ReferenceQueue
name|queue
parameter_list|)
block|{
name|super
argument_list|(
name|value
argument_list|,
name|queue
argument_list|)
expr_stmt|;
name|_key
operator|=
name|key
expr_stmt|;
block|}
comment|/**      * Gets the key      *       * @return the key associated with this value.      */
specifier|final
name|Object
name|getKey
parameter_list|()
block|{
return|return
name|_key
return|;
block|}
comment|/**      * Gets the value      *       * @return the value; null if it is no longer accessible      */
specifier|final
name|Object
name|getValue
parameter_list|()
block|{
return|return
name|this
operator|.
name|get
argument_list|()
return|;
block|}
block|}
block|}
end_class

end_unit

