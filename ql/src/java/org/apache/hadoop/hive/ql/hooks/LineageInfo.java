begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|hooks
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|Serializable
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|LinkedHashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|LinkedHashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|collections
operator|.
name|SetUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|lang
operator|.
name|StringUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|common
operator|.
name|StringInternUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|metastore
operator|.
name|Warehouse
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|metastore
operator|.
name|api
operator|.
name|FieldSchema
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|metastore
operator|.
name|api
operator|.
name|Partition
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|metastore
operator|.
name|api
operator|.
name|Table
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|stats
operator|.
name|StatsUtils
import|;
end_import

begin_comment
comment|/**  * This class contains the lineage information that is passed  * to the PreExecution hook.  */
end_comment

begin_class
specifier|public
class|class
name|LineageInfo
implements|implements
name|Serializable
block|{
comment|/**    * Serial version id.    */
specifier|private
specifier|static
specifier|final
name|long
name|serialVersionUID
init|=
literal|1L
decl_stmt|;
comment|/**    * Enum to track dependency. This enum has the following values:    * 1. SIMPLE - Indicates that the column is derived from another table column    *             with no transformations e.g. T2.c1 = T1.c1.    * 2. EXPRESSION - Indicates that the column is derived from a UDF, UDAF, UDTF or    *                 set operations like union on columns on other tables    *                 e.g. T2.c1 = T1.c1 + T3.c1.    * 4. SCRIPT - Indicates that the column is derived from the output    *             of a user script through a TRANSFORM, MAP or REDUCE syntax    *             or from the output of a PTF chain execution.    */
specifier|public
specifier|static
enum|enum
name|DependencyType
block|{
name|SIMPLE
block|,
name|EXPRESSION
block|,
name|SCRIPT
block|}
comment|/**    * Table or Partition data container. We need this class because the output    * of the query can either go to a table or a partition within a table. The    * data container class subsumes both of these.    */
specifier|public
specifier|static
class|class
name|DataContainer
implements|implements
name|Serializable
block|{
comment|/**      * Serial version id.      */
specifier|private
specifier|static
specifier|final
name|long
name|serialVersionUID
init|=
literal|1L
decl_stmt|;
comment|/**      * The table in case this container is a table.      */
specifier|private
specifier|final
name|Table
name|tab
decl_stmt|;
comment|/**      * The partition in case this container is a partition.      */
specifier|private
specifier|final
name|Partition
name|part
decl_stmt|;
comment|/**      * Constructor for non partitioned tables.      *      * @param tab The associated table.      */
specifier|public
name|DataContainer
parameter_list|(
name|Table
name|tab
parameter_list|)
block|{
name|this
operator|.
name|tab
operator|=
name|tab
expr_stmt|;
name|this
operator|.
name|part
operator|=
literal|null
expr_stmt|;
block|}
comment|/**      * Constructor for a partitioned tables partition.      *      * @param part The associated partition.      */
specifier|public
name|DataContainer
parameter_list|(
name|Table
name|tab
parameter_list|,
name|Partition
name|part
parameter_list|)
block|{
name|this
operator|.
name|tab
operator|=
name|tab
expr_stmt|;
name|this
operator|.
name|part
operator|=
name|part
expr_stmt|;
block|}
comment|/**      * Returns true in case this data container is a partition.      *      * @return boolean TRUE if the container is a table partition.      */
specifier|public
name|boolean
name|isPartition
parameter_list|()
block|{
return|return
operator|(
name|part
operator|!=
literal|null
operator|)
return|;
block|}
specifier|public
name|Table
name|getTable
parameter_list|()
block|{
return|return
name|this
operator|.
name|tab
return|;
block|}
specifier|public
name|Partition
name|getPartition
parameter_list|()
block|{
return|return
name|this
operator|.
name|part
return|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
name|isPartition
argument_list|()
condition|?
name|StatsUtils
operator|.
name|getFullyQualifiedTableName
argument_list|(
name|part
operator|.
name|getDbName
argument_list|()
argument_list|,
name|part
operator|.
name|getTableName
argument_list|()
argument_list|)
operator|+
literal|"@"
operator|+
name|part
operator|.
name|getValues
argument_list|()
else|:
name|Warehouse
operator|.
name|getQualifiedName
argument_list|(
name|tab
argument_list|)
return|;
block|}
block|}
comment|/**    * Class that captures the lookup key for the dependency. The dependency    * is from (DataContainer, FieldSchema) to a Dependency structure. This    * class captures the (DataContainer, FieldSchema) tuple.    */
specifier|public
specifier|static
class|class
name|DependencyKey
implements|implements
name|Serializable
block|{
comment|/**      * Serial version id.      */
specifier|private
specifier|static
specifier|final
name|long
name|serialVersionUID
init|=
literal|1L
decl_stmt|;
comment|/**      * The data container for this key.      */
specifier|private
specifier|final
name|DataContainer
name|dc
decl_stmt|;
comment|/**      * The field schema for this key.      */
specifier|private
specifier|final
name|FieldSchema
name|fld
decl_stmt|;
comment|/**      * Constructor.      *      * @param dc The associated data container.      * @param fld The associated field schema.      */
specifier|public
name|DependencyKey
parameter_list|(
name|DataContainer
name|dc
parameter_list|,
name|FieldSchema
name|fld
parameter_list|)
block|{
name|this
operator|.
name|dc
operator|=
name|dc
expr_stmt|;
name|this
operator|.
name|fld
operator|=
name|fld
expr_stmt|;
block|}
specifier|public
name|DataContainer
name|getDataContainer
parameter_list|()
block|{
return|return
name|this
operator|.
name|dc
return|;
block|}
specifier|public
name|FieldSchema
name|getFieldSchema
parameter_list|()
block|{
return|return
name|this
operator|.
name|fld
return|;
block|}
comment|/* (non-Javadoc)      * @see java.lang.Object#hashCode()      */
annotation|@
name|Override
specifier|public
name|int
name|hashCode
parameter_list|()
block|{
specifier|final
name|int
name|prime
init|=
literal|31
decl_stmt|;
name|int
name|result
init|=
literal|1
decl_stmt|;
name|result
operator|=
name|prime
operator|*
name|result
operator|+
operator|(
operator|(
name|dc
operator|==
literal|null
operator|)
condition|?
literal|0
else|:
name|dc
operator|.
name|hashCode
argument_list|()
operator|)
expr_stmt|;
name|result
operator|=
name|prime
operator|*
name|result
operator|+
operator|(
operator|(
name|fld
operator|==
literal|null
operator|)
condition|?
literal|0
else|:
name|fld
operator|.
name|hashCode
argument_list|()
operator|)
expr_stmt|;
return|return
name|result
return|;
block|}
comment|/* (non-Javadoc)      * @see java.lang.Object#equals(java.lang.Object)      */
annotation|@
name|Override
specifier|public
name|boolean
name|equals
parameter_list|(
name|Object
name|obj
parameter_list|)
block|{
if|if
condition|(
name|this
operator|==
name|obj
condition|)
block|{
return|return
literal|true
return|;
block|}
if|if
condition|(
name|obj
operator|==
literal|null
condition|)
block|{
return|return
literal|false
return|;
block|}
if|if
condition|(
name|getClass
argument_list|()
operator|!=
name|obj
operator|.
name|getClass
argument_list|()
condition|)
block|{
return|return
literal|false
return|;
block|}
name|DependencyKey
name|other
init|=
operator|(
name|DependencyKey
operator|)
name|obj
decl_stmt|;
if|if
condition|(
name|dc
operator|!=
name|other
operator|.
name|dc
condition|)
block|{
return|return
literal|false
return|;
block|}
if|if
condition|(
name|fld
operator|!=
name|other
operator|.
name|fld
condition|)
block|{
return|return
literal|false
return|;
block|}
return|return
literal|true
return|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
name|dc
operator|+
literal|":"
operator|+
name|fld
return|;
block|}
block|}
comment|/**    * Base Column information.    */
specifier|public
specifier|static
class|class
name|BaseColumnInfo
implements|implements
name|Serializable
block|{
comment|/**      * Serial version id.      */
specifier|private
specifier|static
specifier|final
name|long
name|serialVersionUID
init|=
literal|1L
decl_stmt|;
comment|/**      * The table and alias info encapsulated in a different class.      */
specifier|private
name|TableAliasInfo
name|tabAlias
decl_stmt|;
comment|/**      * The metastore column information. The column can be null      * and that denotes that the expression is dependent on the row      * of the table and not particular column. This can happen in case      * of count(1).      */
specifier|private
name|FieldSchema
name|column
decl_stmt|;
comment|/**      * @return the tabAlias      */
specifier|public
name|TableAliasInfo
name|getTabAlias
parameter_list|()
block|{
return|return
name|tabAlias
return|;
block|}
comment|/**      * @param tabAlias the tabAlias to set      */
specifier|public
name|void
name|setTabAlias
parameter_list|(
name|TableAliasInfo
name|tabAlias
parameter_list|)
block|{
name|this
operator|.
name|tabAlias
operator|=
name|tabAlias
expr_stmt|;
block|}
comment|/**      * @return the column      */
specifier|public
name|FieldSchema
name|getColumn
parameter_list|()
block|{
return|return
name|column
return|;
block|}
comment|/**      * @param column the column to set      */
specifier|public
name|void
name|setColumn
parameter_list|(
name|FieldSchema
name|column
parameter_list|)
block|{
name|this
operator|.
name|column
operator|=
name|column
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
name|tabAlias
operator|+
literal|":"
operator|+
name|column
return|;
block|}
annotation|@
name|Override
specifier|public
name|int
name|hashCode
parameter_list|()
block|{
return|return
operator|(
name|column
operator|!=
literal|null
condition|?
name|column
operator|.
name|hashCode
argument_list|()
else|:
literal|7
operator|)
operator|+
operator|(
name|tabAlias
operator|!=
literal|null
condition|?
name|tabAlias
operator|.
name|hashCode
argument_list|()
else|:
literal|11
operator|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|equals
parameter_list|(
name|Object
name|obj
parameter_list|)
block|{
if|if
condition|(
name|this
operator|==
name|obj
condition|)
block|{
return|return
literal|true
return|;
block|}
if|if
condition|(
operator|!
operator|(
name|obj
operator|instanceof
name|BaseColumnInfo
operator|)
condition|)
block|{
return|return
literal|false
return|;
block|}
name|BaseColumnInfo
name|ci
init|=
operator|(
name|BaseColumnInfo
operator|)
name|obj
decl_stmt|;
return|return
operator|(
name|column
operator|==
literal|null
condition|?
name|ci
operator|.
name|column
operator|==
literal|null
else|:
name|column
operator|.
name|equals
argument_list|(
name|ci
operator|.
name|column
argument_list|)
operator|)
operator|&&
operator|(
name|tabAlias
operator|==
literal|null
condition|?
name|ci
operator|.
name|tabAlias
operator|==
literal|null
else|:
name|tabAlias
operator|.
name|equals
argument_list|(
name|ci
operator|.
name|tabAlias
argument_list|)
operator|)
return|;
block|}
block|}
specifier|public
specifier|static
class|class
name|TableAliasInfo
implements|implements
name|Serializable
block|{
comment|/**      * Serail version id.      */
specifier|private
specifier|static
specifier|final
name|long
name|serialVersionUID
init|=
literal|1L
decl_stmt|;
comment|/**      * The alias for the table.      */
specifier|private
name|String
name|alias
decl_stmt|;
comment|/**      * The metastore table information.      */
specifier|private
name|Table
name|table
decl_stmt|;
comment|/**      * @return the alias      */
specifier|public
name|String
name|getAlias
parameter_list|()
block|{
return|return
name|alias
return|;
block|}
comment|/**      * @param alias the alias to set      */
specifier|public
name|void
name|setAlias
parameter_list|(
name|String
name|alias
parameter_list|)
block|{
name|this
operator|.
name|alias
operator|=
name|alias
expr_stmt|;
block|}
comment|/**      * @return the table      */
specifier|public
name|Table
name|getTable
parameter_list|()
block|{
return|return
name|table
return|;
block|}
comment|/**      * @param table the table to set      */
specifier|public
name|void
name|setTable
parameter_list|(
name|Table
name|table
parameter_list|)
block|{
name|this
operator|.
name|table
operator|=
name|table
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
name|Warehouse
operator|.
name|getQualifiedName
argument_list|(
name|table
argument_list|)
operator|+
literal|"("
operator|+
name|alias
operator|+
literal|")"
return|;
block|}
annotation|@
name|Override
specifier|public
name|int
name|hashCode
parameter_list|()
block|{
return|return
operator|(
name|alias
operator|!=
literal|null
condition|?
name|alias
operator|.
name|hashCode
argument_list|()
else|:
literal|7
operator|)
operator|+
operator|(
name|table
operator|!=
literal|null
condition|?
name|table
operator|.
name|hashCode
argument_list|()
else|:
literal|11
operator|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|equals
parameter_list|(
name|Object
name|obj
parameter_list|)
block|{
if|if
condition|(
name|this
operator|==
name|obj
condition|)
block|{
return|return
literal|true
return|;
block|}
if|if
condition|(
operator|!
operator|(
name|obj
operator|instanceof
name|TableAliasInfo
operator|)
condition|)
block|{
return|return
literal|false
return|;
block|}
name|TableAliasInfo
name|tabAlias
init|=
operator|(
name|TableAliasInfo
operator|)
name|obj
decl_stmt|;
return|return
name|StringUtils
operator|.
name|equals
argument_list|(
name|alias
argument_list|,
name|tabAlias
operator|.
name|alias
argument_list|)
operator|&&
operator|(
name|table
operator|==
literal|null
condition|?
name|tabAlias
operator|.
name|table
operator|==
literal|null
else|:
name|table
operator|.
name|equals
argument_list|(
name|tabAlias
operator|.
name|table
argument_list|)
operator|)
return|;
block|}
block|}
comment|/**    * This class tracks the dependency information for the base column.    */
specifier|public
specifier|static
class|class
name|Dependency
implements|implements
name|Serializable
block|{
comment|/**      *      */
specifier|private
specifier|static
specifier|final
name|long
name|serialVersionUID
init|=
literal|1L
decl_stmt|;
comment|/**      * The type of dependency.      */
specifier|private
name|DependencyType
name|type
decl_stmt|;
comment|/**      * Expression string for the dependency.      */
specifier|private
name|String
name|expr
decl_stmt|;
comment|/**      * The set of base columns that the particular column depends on.      */
specifier|private
name|Set
argument_list|<
name|BaseColumnInfo
argument_list|>
name|baseCols
decl_stmt|;
comment|/**      * @return the type      */
specifier|public
name|DependencyType
name|getType
parameter_list|()
block|{
return|return
name|type
return|;
block|}
comment|/**      * @param type the type to set      */
specifier|public
name|void
name|setType
parameter_list|(
name|DependencyType
name|type
parameter_list|)
block|{
name|this
operator|.
name|type
operator|=
name|type
expr_stmt|;
block|}
comment|/**      * @return the expr      */
specifier|public
name|String
name|getExpr
parameter_list|()
block|{
return|return
name|expr
return|;
block|}
comment|/**      * @param expr the expr to set      */
specifier|public
name|void
name|setExpr
parameter_list|(
name|String
name|expr
parameter_list|)
block|{
name|this
operator|.
name|expr
operator|=
name|StringInternUtils
operator|.
name|internIfNotNull
argument_list|(
name|expr
argument_list|)
expr_stmt|;
block|}
comment|/**      * @return the baseCols      */
specifier|public
name|Set
argument_list|<
name|BaseColumnInfo
argument_list|>
name|getBaseCols
parameter_list|()
block|{
return|return
name|baseCols
return|;
block|}
comment|/**      * @param baseCols the baseCols to set      */
specifier|public
name|void
name|setBaseCols
parameter_list|(
name|Set
argument_list|<
name|BaseColumnInfo
argument_list|>
name|baseCols
parameter_list|)
block|{
name|this
operator|.
name|baseCols
operator|=
name|baseCols
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
literal|"["
operator|+
name|type
operator|+
literal|"]"
operator|+
name|baseCols
return|;
block|}
block|}
comment|/**    * This class tracks the predicate information for an operator.    */
specifier|public
specifier|static
class|class
name|Predicate
implements|implements
name|Serializable
block|{
comment|/**      * Expression string for the predicate.      */
specifier|private
name|String
name|expr
decl_stmt|;
comment|/**      * The set of base columns that the predicate depends on.      */
specifier|private
name|Set
argument_list|<
name|BaseColumnInfo
argument_list|>
name|baseCols
init|=
operator|new
name|LinkedHashSet
argument_list|<
name|BaseColumnInfo
argument_list|>
argument_list|()
decl_stmt|;
comment|/**      * @return the expr      */
specifier|public
name|String
name|getExpr
parameter_list|()
block|{
return|return
name|expr
return|;
block|}
comment|/**      * @param expr the expr to set      */
specifier|public
name|void
name|setExpr
parameter_list|(
name|String
name|expr
parameter_list|)
block|{
name|this
operator|.
name|expr
operator|=
name|expr
expr_stmt|;
block|}
comment|/**      * @return the baseCols      */
specifier|public
name|Set
argument_list|<
name|BaseColumnInfo
argument_list|>
name|getBaseCols
parameter_list|()
block|{
return|return
name|baseCols
return|;
block|}
annotation|@
name|Override
specifier|public
name|int
name|hashCode
parameter_list|()
block|{
return|return
name|baseCols
operator|.
name|hashCode
argument_list|()
operator|+
operator|(
name|expr
operator|!=
literal|null
condition|?
name|expr
operator|.
name|hashCode
argument_list|()
else|:
literal|11
operator|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|equals
parameter_list|(
name|Object
name|obj
parameter_list|)
block|{
if|if
condition|(
name|this
operator|==
name|obj
condition|)
block|{
return|return
literal|true
return|;
block|}
if|if
condition|(
operator|!
operator|(
name|obj
operator|instanceof
name|Predicate
operator|)
condition|)
block|{
return|return
literal|false
return|;
block|}
name|Predicate
name|cond
init|=
operator|(
name|Predicate
operator|)
name|obj
decl_stmt|;
return|return
name|StringUtils
operator|.
name|equals
argument_list|(
name|cond
operator|.
name|expr
argument_list|,
name|expr
argument_list|)
operator|&&
name|SetUtils
operator|.
name|isEqualSet
argument_list|(
name|cond
operator|.
name|baseCols
argument_list|,
name|baseCols
argument_list|)
return|;
block|}
block|}
comment|/**    * The map contains an index from the (datacontainer, columnname) to the    * dependency vector for that tuple. This is used to generate the    * dependency vectors during the walk of the operator tree.    */
specifier|protected
name|Map
argument_list|<
name|DependencyKey
argument_list|,
name|Dependency
argument_list|>
name|index
decl_stmt|;
comment|/**    * Constructor.    */
specifier|public
name|LineageInfo
parameter_list|()
block|{
name|index
operator|=
name|Collections
operator|.
name|synchronizedMap
argument_list|(
operator|new
name|LinkedHashMap
argument_list|<
name|DependencyKey
argument_list|,
name|Dependency
argument_list|>
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/**    * Gets the dependency for a table, column tuple.    * @param dc The data container of the column whose dependency is being inspected.    * @param col The column whose dependency is being inspected.    * @return Dependency for that particular table, column tuple.    *         null if no dependency is found.    */
specifier|public
name|Dependency
name|getDependency
parameter_list|(
name|DataContainer
name|dc
parameter_list|,
name|FieldSchema
name|col
parameter_list|)
block|{
return|return
name|index
operator|.
name|get
argument_list|(
operator|new
name|DependencyKey
argument_list|(
name|dc
argument_list|,
name|col
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Puts the dependency for a table, column tuple.    * @param dc The datacontainer whose dependency is being inserted.    * @param col The column whose dependency is being inserted.    * @param dep The dependency.    */
specifier|public
name|void
name|putDependency
parameter_list|(
name|DataContainer
name|dc
parameter_list|,
name|FieldSchema
name|col
parameter_list|,
name|Dependency
name|dep
parameter_list|)
block|{
name|index
operator|.
name|put
argument_list|(
operator|new
name|DependencyKey
argument_list|(
name|dc
argument_list|,
name|col
argument_list|)
argument_list|,
name|dep
argument_list|)
expr_stmt|;
block|}
comment|/**    * Gets the entry set on this structure.    *    * @return LineageInfo entry set    */
specifier|public
name|Set
argument_list|<
name|Map
operator|.
name|Entry
argument_list|<
name|DependencyKey
argument_list|,
name|Dependency
argument_list|>
argument_list|>
name|entrySet
parameter_list|()
block|{
return|return
name|index
operator|.
name|entrySet
argument_list|()
return|;
block|}
specifier|public
name|void
name|clear
parameter_list|()
block|{
name|index
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
block|}
end_class

end_unit

