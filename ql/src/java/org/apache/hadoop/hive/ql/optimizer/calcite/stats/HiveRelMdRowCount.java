begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|optimizer
operator|.
name|calcite
operator|.
name|stats
package|;
end_package

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|ImmutableList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|plan
operator|.
name|RelOptUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|plan
operator|.
name|hep
operator|.
name|HepRelVertex
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|RelNode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|RelVisitor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|core
operator|.
name|Filter
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|core
operator|.
name|Join
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|core
operator|.
name|JoinRelType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|core
operator|.
name|Project
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|core
operator|.
name|SemiJoin
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|core
operator|.
name|Sort
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|core
operator|.
name|TableScan
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|metadata
operator|.
name|ReflectiveRelMetadataProvider
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|metadata
operator|.
name|RelColumnOrigin
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|metadata
operator|.
name|RelMdRowCount
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|metadata
operator|.
name|RelMdUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|metadata
operator|.
name|RelMetadataProvider
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|metadata
operator|.
name|RelMetadataQuery
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexBuilder
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexCall
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexInputRef
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexLiteral
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexNode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlKind
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|fun
operator|.
name|SqlStdOperatorTable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|BuiltInMethod
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|ImmutableBitSet
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|Pair
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|metastore
operator|.
name|api
operator|.
name|ColumnStatistics
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|optimizer
operator|.
name|calcite
operator|.
name|HiveRelOptUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|optimizer
operator|.
name|calcite
operator|.
name|HiveRelOptUtil
operator|.
name|PKFKJoinInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|optimizer
operator|.
name|calcite
operator|.
name|RelOptHiveTable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|ColStatistics
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|optimizer
operator|.
name|calcite
operator|.
name|reloperators
operator|.
name|HiveTableScan
import|;
end_import

begin_class
specifier|public
class|class
name|HiveRelMdRowCount
extends|extends
name|RelMdRowCount
block|{
specifier|protected
specifier|static
specifier|final
name|Logger
name|LOG
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|HiveRelMdRowCount
operator|.
name|class
operator|.
name|getName
argument_list|()
argument_list|)
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|Long
name|HIVE_PK_FK_NO_FILTERING_COST_INCREASING_FACTOR
init|=
literal|1000000000000000L
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|RelMetadataProvider
name|SOURCE
init|=
name|ReflectiveRelMetadataProvider
operator|.
name|reflectiveSource
argument_list|(
name|BuiltInMethod
operator|.
name|ROW_COUNT
operator|.
name|method
argument_list|,
operator|new
name|HiveRelMdRowCount
argument_list|()
argument_list|)
decl_stmt|;
specifier|protected
name|HiveRelMdRowCount
parameter_list|()
block|{
name|super
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|Double
name|getRowCount
parameter_list|(
name|Join
name|join
parameter_list|,
name|RelMetadataQuery
name|mq
parameter_list|)
block|{
comment|// Try to infer from constraints first
specifier|final
name|Pair
argument_list|<
name|PKFKRelationInfo
argument_list|,
name|RexNode
argument_list|>
name|constraintBasedResult
init|=
name|constraintsBasedAnalyzeJoinForPKFK
argument_list|(
name|join
argument_list|,
name|mq
argument_list|)
decl_stmt|;
if|if
condition|(
name|constraintBasedResult
operator|!=
literal|null
condition|)
block|{
comment|// We succeeded, we calculate the selectivity based on the inferred information
comment|// and any residual predicate
name|double
name|joinSelectivity
init|=
name|Math
operator|.
name|min
argument_list|(
literal|1.0
argument_list|,
name|constraintBasedResult
operator|.
name|left
operator|.
name|pkInfo
operator|.
name|selectivity
operator|*
name|constraintBasedResult
operator|.
name|left
operator|.
name|ndvScalingFactor
argument_list|)
decl_stmt|;
name|double
name|residualSelectivity
init|=
name|RelMdUtil
operator|.
name|guessSelectivity
argument_list|(
name|constraintBasedResult
operator|.
name|right
argument_list|)
decl_stmt|;
name|double
name|rowCount
decl_stmt|;
if|if
condition|(
name|constraintBasedResult
operator|.
name|left
operator|.
name|isPKSideSimple
condition|)
block|{
name|rowCount
operator|=
name|constraintBasedResult
operator|.
name|left
operator|.
name|pkInfo
operator|.
name|rowCount
operator|+
name|HIVE_PK_FK_NO_FILTERING_COST_INCREASING_FACTOR
expr_stmt|;
block|}
else|else
block|{
name|rowCount
operator|=
name|constraintBasedResult
operator|.
name|left
operator|.
name|fkInfo
operator|.
name|rowCount
operator|*
name|joinSelectivity
operator|*
name|residualSelectivity
expr_stmt|;
block|}
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Identified Primary - Foreign Key relation from constraints:\n {} {} Row count for join: {}\n"
operator|+
literal|" Join selectivity: {}\n Residual selectivity: {}\n"
argument_list|,
name|RelOptUtil
operator|.
name|toString
argument_list|(
name|join
argument_list|)
argument_list|,
name|constraintBasedResult
operator|.
name|left
argument_list|,
name|rowCount
argument_list|,
name|joinSelectivity
argument_list|,
name|residualSelectivity
argument_list|)
expr_stmt|;
block|}
return|return
name|rowCount
return|;
block|}
comment|// Otherwise, try to infer from stats
specifier|final
name|PKFKRelationInfo
name|pkfk
init|=
name|analyzeJoinForPKFK
argument_list|(
name|join
argument_list|,
name|mq
argument_list|)
decl_stmt|;
if|if
condition|(
name|pkfk
operator|!=
literal|null
condition|)
block|{
name|double
name|selectivity
init|=
name|pkfk
operator|.
name|pkInfo
operator|.
name|selectivity
operator|*
name|pkfk
operator|.
name|ndvScalingFactor
decl_stmt|;
name|selectivity
operator|=
name|Math
operator|.
name|min
argument_list|(
literal|1.0
argument_list|,
name|selectivity
argument_list|)
expr_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Identified Primary - Foreign Key relation: {} {}"
argument_list|,
name|RelOptUtil
operator|.
name|toString
argument_list|(
name|join
argument_list|)
argument_list|,
name|pkfk
argument_list|)
expr_stmt|;
block|}
return|return
name|pkfk
operator|.
name|fkInfo
operator|.
name|rowCount
operator|*
name|selectivity
return|;
block|}
comment|// If we cannot infer anything, then we just go to join.estimateRowCount(mq).
comment|// Do not call mq.getRowCount(join), will trigger CyclicMetadataException
specifier|final
name|Double
name|rowCount
init|=
name|join
operator|.
name|estimateRowCount
argument_list|(
name|mq
argument_list|)
decl_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"No Primary - Foreign Key relation: \n{} Row count for join: {}\n"
argument_list|,
name|RelOptUtil
operator|.
name|toString
argument_list|(
name|join
argument_list|)
argument_list|,
name|rowCount
argument_list|)
expr_stmt|;
block|}
return|return
name|rowCount
return|;
block|}
annotation|@
name|Override
specifier|public
name|Double
name|getRowCount
parameter_list|(
name|SemiJoin
name|rel
parameter_list|,
name|RelMetadataQuery
name|mq
parameter_list|)
block|{
name|PKFKRelationInfo
name|pkfk
init|=
name|analyzeJoinForPKFK
argument_list|(
name|rel
argument_list|,
name|mq
argument_list|)
decl_stmt|;
if|if
condition|(
name|pkfk
operator|!=
literal|null
condition|)
block|{
name|double
name|selectivity
init|=
name|pkfk
operator|.
name|pkInfo
operator|.
name|selectivity
operator|*
name|pkfk
operator|.
name|ndvScalingFactor
decl_stmt|;
name|selectivity
operator|=
name|Math
operator|.
name|min
argument_list|(
literal|1.0
argument_list|,
name|selectivity
argument_list|)
expr_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Identified Primary - Foreign Key relation: {} {}"
argument_list|,
name|RelOptUtil
operator|.
name|toString
argument_list|(
name|rel
argument_list|)
argument_list|,
name|pkfk
argument_list|)
expr_stmt|;
block|}
return|return
name|pkfk
operator|.
name|fkInfo
operator|.
name|rowCount
operator|*
name|selectivity
return|;
block|}
return|return
name|super
operator|.
name|getRowCount
argument_list|(
name|rel
argument_list|,
name|mq
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|Double
name|getRowCount
parameter_list|(
name|Sort
name|rel
parameter_list|,
name|RelMetadataQuery
name|mq
parameter_list|)
block|{
specifier|final
name|Double
name|rowCount
init|=
name|mq
operator|.
name|getRowCount
argument_list|(
name|rel
operator|.
name|getInput
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|rowCount
operator|!=
literal|null
operator|&&
name|rel
operator|.
name|fetch
operator|!=
literal|null
condition|)
block|{
specifier|final
name|int
name|offset
init|=
name|rel
operator|.
name|offset
operator|==
literal|null
condition|?
literal|0
else|:
name|RexLiteral
operator|.
name|intValue
argument_list|(
name|rel
operator|.
name|offset
argument_list|)
decl_stmt|;
specifier|final
name|int
name|limit
init|=
name|RexLiteral
operator|.
name|intValue
argument_list|(
name|rel
operator|.
name|fetch
argument_list|)
decl_stmt|;
specifier|final
name|int
name|offsetLimit
init|=
name|offset
operator|+
name|limit
decl_stmt|;
comment|// offsetLimit is smaller than rowCount of the input operator
comment|// thus, we return the offsetLimit
if|if
condition|(
name|offsetLimit
operator|<
name|rowCount
condition|)
block|{
return|return
name|Double
operator|.
name|valueOf
argument_list|(
name|offsetLimit
argument_list|)
return|;
block|}
block|}
return|return
name|rowCount
return|;
block|}
specifier|static
class|class
name|PKFKRelationInfo
block|{
specifier|public
specifier|final
name|int
name|fkSide
decl_stmt|;
specifier|public
specifier|final
name|double
name|ndvScalingFactor
decl_stmt|;
specifier|public
specifier|final
name|FKSideInfo
name|fkInfo
decl_stmt|;
specifier|public
specifier|final
name|PKSideInfo
name|pkInfo
decl_stmt|;
specifier|public
specifier|final
name|boolean
name|isPKSideSimple
decl_stmt|;
name|PKFKRelationInfo
parameter_list|(
name|int
name|fkSide
parameter_list|,
name|FKSideInfo
name|fkInfo
parameter_list|,
name|PKSideInfo
name|pkInfo
parameter_list|,
name|double
name|ndvScalingFactor
parameter_list|,
name|boolean
name|isPKSideSimple
parameter_list|)
block|{
name|this
operator|.
name|fkSide
operator|=
name|fkSide
expr_stmt|;
name|this
operator|.
name|fkInfo
operator|=
name|fkInfo
expr_stmt|;
name|this
operator|.
name|pkInfo
operator|=
name|pkInfo
expr_stmt|;
name|this
operator|.
name|ndvScalingFactor
operator|=
name|ndvScalingFactor
expr_stmt|;
name|this
operator|.
name|isPKSideSimple
operator|=
name|isPKSideSimple
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
name|String
operator|.
name|format
argument_list|(
literal|"Primary - Foreign Key join:\n\tfkSide = %d\n\tFKInfo:%s\n"
operator|+
literal|"\tPKInfo:%s\n\tisPKSideSimple:%s\n\tNDV Scaling Factor:%.2f\n"
argument_list|,
name|fkSide
argument_list|,
name|fkInfo
argument_list|,
name|pkInfo
argument_list|,
name|isPKSideSimple
argument_list|,
name|ndvScalingFactor
argument_list|)
return|;
block|}
block|}
specifier|static
class|class
name|FKSideInfo
block|{
specifier|public
specifier|final
name|double
name|rowCount
decl_stmt|;
specifier|public
specifier|final
name|double
name|distinctCount
decl_stmt|;
specifier|public
name|FKSideInfo
parameter_list|(
name|double
name|rowCount
parameter_list|,
name|double
name|distinctCount
parameter_list|)
block|{
name|this
operator|.
name|rowCount
operator|=
name|rowCount
expr_stmt|;
name|this
operator|.
name|distinctCount
operator|=
name|distinctCount
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
name|String
operator|.
name|format
argument_list|(
literal|"FKInfo(rowCount=%.2f,ndv=%.2f)"
argument_list|,
name|rowCount
argument_list|,
name|distinctCount
argument_list|)
return|;
block|}
block|}
specifier|static
class|class
name|PKSideInfo
extends|extends
name|FKSideInfo
block|{
specifier|public
specifier|final
name|double
name|selectivity
decl_stmt|;
specifier|public
name|PKSideInfo
parameter_list|(
name|double
name|rowCount
parameter_list|,
name|double
name|distinctCount
parameter_list|,
name|double
name|selectivity
parameter_list|)
block|{
name|super
argument_list|(
name|rowCount
argument_list|,
name|distinctCount
argument_list|)
expr_stmt|;
name|this
operator|.
name|selectivity
operator|=
name|selectivity
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
name|String
operator|.
name|format
argument_list|(
literal|"PKInfo(rowCount=%.2f,ndv=%.2f,selectivity=%.2f)"
argument_list|,
name|rowCount
argument_list|,
name|distinctCount
argument_list|,
name|selectivity
argument_list|)
return|;
block|}
block|}
comment|/*    * For T1 join T2 on T1.x = T2.y if we identify 'y' s a key of T2 then we can    * infer the join cardinality as: rowCount(T1) * selectivity(T2) i.e this is    * like a SemiJoin where the T1(Fact side/FK side) is filtered by a factor    * based on the Selectivity of the PK/Dim table side.    *    * 1. If both T1.x and T2.y are keys then use the larger one as the PK side.    * 2. In case of outer Joins: a) The FK side should be the Null Preserving    * side. It doesn't make sense to apply this heuristic in case of Dim loj Fact    * or Fact roj Dim b) The selectivity factor applied on the Fact Table should    * be 1.    */
specifier|public
specifier|static
name|PKFKRelationInfo
name|analyzeJoinForPKFK
parameter_list|(
name|Join
name|joinRel
parameter_list|,
name|RelMetadataQuery
name|mq
parameter_list|)
block|{
name|RelNode
name|left
init|=
name|joinRel
operator|.
name|getInputs
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|RelNode
name|right
init|=
name|joinRel
operator|.
name|getInputs
argument_list|()
operator|.
name|get
argument_list|(
literal|1
argument_list|)
decl_stmt|;
specifier|final
name|List
argument_list|<
name|RexNode
argument_list|>
name|initJoinFilters
init|=
name|RelOptUtil
operator|.
name|conjunctions
argument_list|(
name|joinRel
operator|.
name|getCondition
argument_list|()
argument_list|)
decl_stmt|;
comment|/*      * No joining condition.      */
if|if
condition|(
name|initJoinFilters
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return
literal|null
return|;
block|}
name|List
argument_list|<
name|RexNode
argument_list|>
name|leftFilters
init|=
operator|new
name|ArrayList
argument_list|<
name|RexNode
argument_list|>
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|RexNode
argument_list|>
name|rightFilters
init|=
operator|new
name|ArrayList
argument_list|<
name|RexNode
argument_list|>
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|RexNode
argument_list|>
name|joinFilters
init|=
operator|new
name|ArrayList
argument_list|<
name|RexNode
argument_list|>
argument_list|(
name|initJoinFilters
argument_list|)
decl_stmt|;
comment|// @todo: remove this. 8/28/14 hb
comment|// for now adding because RelOptUtil.classifyFilters has an assertion about
comment|// column counts that is not true for semiJoins.
if|if
condition|(
name|joinRel
operator|instanceof
name|SemiJoin
condition|)
block|{
return|return
literal|null
return|;
block|}
name|RelOptUtil
operator|.
name|classifyFilters
argument_list|(
name|joinRel
argument_list|,
name|joinFilters
argument_list|,
name|joinRel
operator|.
name|getJoinType
argument_list|()
argument_list|,
literal|false
argument_list|,
operator|!
name|joinRel
operator|.
name|getJoinType
argument_list|()
operator|.
name|generatesNullsOnRight
argument_list|()
argument_list|,
operator|!
name|joinRel
operator|.
name|getJoinType
argument_list|()
operator|.
name|generatesNullsOnLeft
argument_list|()
argument_list|,
name|joinFilters
argument_list|,
name|leftFilters
argument_list|,
name|rightFilters
argument_list|)
expr_stmt|;
name|Pair
argument_list|<
name|Integer
argument_list|,
name|Integer
argument_list|>
name|joinCols
init|=
name|canHandleJoin
argument_list|(
name|joinRel
argument_list|,
name|leftFilters
argument_list|,
name|rightFilters
argument_list|,
name|joinFilters
argument_list|)
decl_stmt|;
if|if
condition|(
name|joinCols
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
name|int
name|leftColIdx
init|=
name|joinCols
operator|.
name|left
decl_stmt|;
name|int
name|rightColIdx
init|=
name|joinCols
operator|.
name|right
decl_stmt|;
name|RexBuilder
name|rexBuilder
init|=
name|joinRel
operator|.
name|getCluster
argument_list|()
operator|.
name|getRexBuilder
argument_list|()
decl_stmt|;
name|RexNode
name|leftPred
init|=
name|RexUtil
operator|.
name|composeConjunction
argument_list|(
name|rexBuilder
argument_list|,
name|leftFilters
argument_list|,
literal|true
argument_list|)
decl_stmt|;
name|RexNode
name|rightPred
init|=
name|RexUtil
operator|.
name|composeConjunction
argument_list|(
name|rexBuilder
argument_list|,
name|rightFilters
argument_list|,
literal|true
argument_list|)
decl_stmt|;
name|ImmutableBitSet
name|lBitSet
init|=
name|ImmutableBitSet
operator|.
name|of
argument_list|(
name|leftColIdx
argument_list|)
decl_stmt|;
name|ImmutableBitSet
name|rBitSet
init|=
name|ImmutableBitSet
operator|.
name|of
argument_list|(
name|rightColIdx
argument_list|)
decl_stmt|;
comment|/*      * If the form is Dim loj F or Fact roj Dim or Dim semij Fact then return      * null.      */
name|boolean
name|leftIsKey
init|=
operator|(
name|joinRel
operator|.
name|getJoinType
argument_list|()
operator|==
name|JoinRelType
operator|.
name|INNER
operator|||
name|joinRel
operator|.
name|getJoinType
argument_list|()
operator|==
name|JoinRelType
operator|.
name|RIGHT
operator|)
operator|&&
name|isKey
argument_list|(
name|lBitSet
argument_list|,
name|left
argument_list|,
name|mq
argument_list|)
decl_stmt|;
name|boolean
name|rightIsKey
init|=
operator|(
name|joinRel
operator|.
name|getJoinType
argument_list|()
operator|==
name|JoinRelType
operator|.
name|INNER
operator|||
name|joinRel
operator|.
name|getJoinType
argument_list|()
operator|==
name|JoinRelType
operator|.
name|LEFT
operator|)
operator|&&
name|isKey
argument_list|(
name|rBitSet
argument_list|,
name|right
argument_list|,
name|mq
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|leftIsKey
operator|&&
operator|!
name|rightIsKey
condition|)
block|{
return|return
literal|null
return|;
block|}
name|double
name|leftRowCount
init|=
name|mq
operator|.
name|getRowCount
argument_list|(
name|left
argument_list|)
decl_stmt|;
name|double
name|rightRowCount
init|=
name|mq
operator|.
name|getRowCount
argument_list|(
name|right
argument_list|)
decl_stmt|;
if|if
condition|(
name|leftIsKey
operator|&&
name|rightIsKey
condition|)
block|{
if|if
condition|(
name|rightRowCount
operator|<
name|leftRowCount
condition|)
block|{
name|leftIsKey
operator|=
literal|false
expr_stmt|;
block|}
block|}
name|int
name|pkSide
init|=
name|leftIsKey
condition|?
literal|0
else|:
literal|1
decl_stmt|;
name|boolean
name|isPKSideSimpleTree
init|=
name|leftIsKey
condition|?
name|SimpleTreeOnJoinKey
operator|.
name|check
argument_list|(
literal|false
argument_list|,
name|left
argument_list|,
name|lBitSet
argument_list|,
name|mq
argument_list|)
operator|.
name|left
else|:
name|SimpleTreeOnJoinKey
operator|.
name|check
argument_list|(
literal|false
argument_list|,
name|right
argument_list|,
name|rBitSet
argument_list|,
name|mq
argument_list|)
operator|.
name|left
decl_stmt|;
name|double
name|leftNDV
init|=
name|isPKSideSimpleTree
condition|?
name|mq
operator|.
name|getDistinctRowCount
argument_list|(
name|left
argument_list|,
name|lBitSet
argument_list|,
name|leftPred
argument_list|)
else|:
operator|-
literal|1
decl_stmt|;
name|double
name|rightNDV
init|=
name|isPKSideSimpleTree
condition|?
name|mq
operator|.
name|getDistinctRowCount
argument_list|(
name|right
argument_list|,
name|rBitSet
argument_list|,
name|rightPred
argument_list|)
else|:
operator|-
literal|1
decl_stmt|;
comment|/*      * If the ndv of the PK - FK side don't match, and the PK side is a filter      * on the Key column then scale the NDV on the FK side.      *      * As described by Peter Boncz: http://databasearchitects.blogspot.com/      * in such cases we can be off by a large margin in the Join cardinality      * estimate. The e.g. he provides is on the join of StoreSales and DateDim      * on the TPCDS dataset. Since the DateDim is populated for 20 years into      * the future, while the StoreSales only has 5 years worth of data, there      * are 40 times fewer distinct dates in StoreSales.      *      * In general it is hard to infer the range for the foreign key on an      * arbitrary expression. For e.g. the NDV for DayofWeek is the same      * irrespective of NDV on the number of unique days, whereas the      * NDV of Quarters has the same ratio as the NDV on the keys.      *      * But for expressions that apply only on columns that have the same NDV      * as the key (implying that they are alternate keys) we can apply the      * ratio. So in the case of StoreSales - DateDim joins for predicate on the      * d_date column we can apply the scaling factor.      */
name|double
name|ndvScalingFactor
init|=
literal|1.0
decl_stmt|;
if|if
condition|(
name|isPKSideSimpleTree
condition|)
block|{
name|ndvScalingFactor
operator|=
name|pkSide
operator|==
literal|0
condition|?
name|leftNDV
operator|/
name|rightNDV
else|:
name|rightNDV
operator|/
name|leftNDV
expr_stmt|;
block|}
if|if
condition|(
name|pkSide
operator|==
literal|0
condition|)
block|{
name|FKSideInfo
name|fkInfo
init|=
operator|new
name|FKSideInfo
argument_list|(
name|rightRowCount
argument_list|,
name|rightNDV
argument_list|)
decl_stmt|;
name|double
name|pkSelectivity
init|=
name|pkSelectivity
argument_list|(
name|joinRel
argument_list|,
name|mq
argument_list|,
literal|true
argument_list|,
name|left
argument_list|,
name|leftRowCount
argument_list|)
decl_stmt|;
name|PKSideInfo
name|pkInfo
init|=
operator|new
name|PKSideInfo
argument_list|(
name|leftRowCount
argument_list|,
name|leftNDV
argument_list|,
name|joinRel
operator|.
name|getJoinType
argument_list|()
operator|.
name|generatesNullsOnRight
argument_list|()
condition|?
literal|1.0
else|:
name|pkSelectivity
argument_list|)
decl_stmt|;
return|return
operator|new
name|PKFKRelationInfo
argument_list|(
literal|1
argument_list|,
name|fkInfo
argument_list|,
name|pkInfo
argument_list|,
name|ndvScalingFactor
argument_list|,
name|isPKSideSimpleTree
argument_list|)
return|;
block|}
else|else
block|{
comment|// pkSide == 1
name|FKSideInfo
name|fkInfo
init|=
operator|new
name|FKSideInfo
argument_list|(
name|leftRowCount
argument_list|,
name|leftNDV
argument_list|)
decl_stmt|;
name|double
name|pkSelectivity
init|=
name|pkSelectivity
argument_list|(
name|joinRel
argument_list|,
name|mq
argument_list|,
literal|false
argument_list|,
name|right
argument_list|,
name|rightRowCount
argument_list|)
decl_stmt|;
name|PKSideInfo
name|pkInfo
init|=
operator|new
name|PKSideInfo
argument_list|(
name|rightRowCount
argument_list|,
name|rightNDV
argument_list|,
name|joinRel
operator|.
name|getJoinType
argument_list|()
operator|.
name|generatesNullsOnLeft
argument_list|()
condition|?
literal|1.0
else|:
name|pkSelectivity
argument_list|)
decl_stmt|;
return|return
operator|new
name|PKFKRelationInfo
argument_list|(
literal|0
argument_list|,
name|fkInfo
argument_list|,
name|pkInfo
argument_list|,
name|ndvScalingFactor
argument_list|,
name|isPKSideSimpleTree
argument_list|)
return|;
block|}
block|}
comment|/*    *    */
specifier|public
specifier|static
name|Pair
argument_list|<
name|PKFKRelationInfo
argument_list|,
name|RexNode
argument_list|>
name|constraintsBasedAnalyzeJoinForPKFK
parameter_list|(
name|Join
name|join
parameter_list|,
name|RelMetadataQuery
name|mq
parameter_list|)
block|{
if|if
condition|(
name|join
operator|instanceof
name|SemiJoin
condition|)
block|{
comment|// TODO: Support semijoin
return|return
literal|null
return|;
block|}
specifier|final
name|RelNode
name|left
init|=
name|join
operator|.
name|getInputs
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
specifier|final
name|RelNode
name|right
init|=
name|join
operator|.
name|getInputs
argument_list|()
operator|.
name|get
argument_list|(
literal|1
argument_list|)
decl_stmt|;
comment|// 1) Split filters in conjuncts
specifier|final
name|List
argument_list|<
name|RexNode
argument_list|>
name|condConjs
init|=
name|RelOptUtil
operator|.
name|conjunctions
argument_list|(
name|join
operator|.
name|getCondition
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|condConjs
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
comment|// Bail out
return|return
literal|null
return|;
block|}
comment|// 2) Classify filters depending on their provenance
specifier|final
name|List
argument_list|<
name|RexNode
argument_list|>
name|joinFilters
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|condConjs
argument_list|)
decl_stmt|;
specifier|final
name|List
argument_list|<
name|RexNode
argument_list|>
name|leftFilters
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
specifier|final
name|List
argument_list|<
name|RexNode
argument_list|>
name|rightFilters
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|RelOptUtil
operator|.
name|classifyFilters
argument_list|(
name|join
argument_list|,
name|joinFilters
argument_list|,
name|join
operator|.
name|getJoinType
argument_list|()
argument_list|,
literal|false
argument_list|,
operator|!
name|join
operator|.
name|getJoinType
argument_list|()
operator|.
name|generatesNullsOnRight
argument_list|()
argument_list|,
operator|!
name|join
operator|.
name|getJoinType
argument_list|()
operator|.
name|generatesNullsOnLeft
argument_list|()
argument_list|,
name|joinFilters
argument_list|,
name|leftFilters
argument_list|,
name|rightFilters
argument_list|)
expr_stmt|;
comment|// 3) Check if we are joining on PK-FK
specifier|final
name|PKFKJoinInfo
name|leftInputResult
init|=
name|HiveRelOptUtil
operator|.
name|extractPKFKJoin
argument_list|(
name|join
argument_list|,
name|joinFilters
argument_list|,
literal|false
argument_list|,
name|mq
argument_list|)
decl_stmt|;
specifier|final
name|PKFKJoinInfo
name|rightInputResult
init|=
name|HiveRelOptUtil
operator|.
name|extractPKFKJoin
argument_list|(
name|join
argument_list|,
name|joinFilters
argument_list|,
literal|true
argument_list|,
name|mq
argument_list|)
decl_stmt|;
if|if
condition|(
name|leftInputResult
operator|==
literal|null
operator|&&
name|rightInputResult
operator|==
literal|null
condition|)
block|{
comment|// Nothing to do here, bail out
return|return
literal|null
return|;
block|}
name|boolean
name|leftIsKey
init|=
operator|(
name|join
operator|.
name|getJoinType
argument_list|()
operator|==
name|JoinRelType
operator|.
name|INNER
operator|||
name|join
operator|.
name|getJoinType
argument_list|()
operator|==
name|JoinRelType
operator|.
name|RIGHT
operator|)
operator|&&
name|leftInputResult
operator|.
name|isPkFkJoin
decl_stmt|;
name|boolean
name|rightIsKey
init|=
operator|(
name|join
operator|.
name|getJoinType
argument_list|()
operator|==
name|JoinRelType
operator|.
name|INNER
operator|||
name|join
operator|.
name|getJoinType
argument_list|()
operator|==
name|JoinRelType
operator|.
name|LEFT
operator|)
operator|&&
name|rightInputResult
operator|.
name|isPkFkJoin
decl_stmt|;
if|if
condition|(
operator|!
name|leftIsKey
operator|&&
operator|!
name|rightIsKey
condition|)
block|{
comment|// Nothing to do here, bail out
return|return
literal|null
return|;
block|}
specifier|final
name|double
name|leftRowCount
init|=
name|mq
operator|.
name|getRowCount
argument_list|(
name|left
argument_list|)
decl_stmt|;
specifier|final
name|double
name|rightRowCount
init|=
name|mq
operator|.
name|getRowCount
argument_list|(
name|right
argument_list|)
decl_stmt|;
if|if
condition|(
name|leftIsKey
operator|&&
name|rightIsKey
condition|)
block|{
if|if
condition|(
name|rightRowCount
operator|<
name|leftRowCount
condition|)
block|{
name|leftIsKey
operator|=
literal|false
expr_stmt|;
block|}
block|}
specifier|final
name|ImmutableBitSet
name|lBitSet
init|=
name|leftIsKey
condition|?
name|leftInputResult
operator|.
name|pkFkJoinColumns
operator|.
name|left
else|:
name|rightInputResult
operator|.
name|pkFkJoinColumns
operator|.
name|left
decl_stmt|;
specifier|final
name|ImmutableBitSet
name|rBitSet
init|=
name|leftIsKey
condition|?
name|leftInputResult
operator|.
name|pkFkJoinColumns
operator|.
name|right
else|:
name|rightInputResult
operator|.
name|pkFkJoinColumns
operator|.
name|right
decl_stmt|;
specifier|final
name|List
argument_list|<
name|RexNode
argument_list|>
name|residualFilters
init|=
name|leftIsKey
condition|?
name|leftInputResult
operator|.
name|additionalPredicates
else|:
name|rightInputResult
operator|.
name|additionalPredicates
decl_stmt|;
comment|// 4) Extract additional information on the PK-FK relationship
name|int
name|pkSide
init|=
name|leftIsKey
condition|?
literal|0
else|:
literal|1
decl_stmt|;
name|Pair
argument_list|<
name|Boolean
argument_list|,
name|Boolean
argument_list|>
name|simpleTree
init|=
name|leftIsKey
condition|?
name|SimpleTreeOnJoinKey
operator|.
name|check
argument_list|(
literal|true
argument_list|,
name|left
argument_list|,
name|lBitSet
argument_list|,
name|mq
argument_list|)
else|:
name|SimpleTreeOnJoinKey
operator|.
name|check
argument_list|(
literal|true
argument_list|,
name|right
argument_list|,
name|rBitSet
argument_list|,
name|mq
argument_list|)
decl_stmt|;
name|boolean
name|isPKSideSimpleTree
init|=
name|simpleTree
operator|.
name|left
decl_stmt|;
name|boolean
name|isNoFilteringPKSideTree
init|=
name|simpleTree
operator|.
name|right
decl_stmt|;
name|RexBuilder
name|rexBuilder
init|=
name|join
operator|.
name|getCluster
argument_list|()
operator|.
name|getRexBuilder
argument_list|()
decl_stmt|;
name|RexNode
name|leftPred
init|=
name|RexUtil
operator|.
name|composeConjunction
argument_list|(
name|rexBuilder
argument_list|,
name|leftFilters
argument_list|,
literal|true
argument_list|)
decl_stmt|;
name|RexNode
name|rightPred
init|=
name|RexUtil
operator|.
name|composeConjunction
argument_list|(
name|rexBuilder
argument_list|,
name|rightFilters
argument_list|,
literal|true
argument_list|)
decl_stmt|;
name|double
name|leftNDV
init|=
name|isPKSideSimpleTree
condition|?
name|mq
operator|.
name|getDistinctRowCount
argument_list|(
name|left
argument_list|,
name|lBitSet
argument_list|,
name|leftPred
argument_list|)
else|:
operator|-
literal|1
decl_stmt|;
name|double
name|rightNDV
init|=
name|isPKSideSimpleTree
condition|?
name|mq
operator|.
name|getDistinctRowCount
argument_list|(
name|right
argument_list|,
name|rBitSet
argument_list|,
name|rightPred
argument_list|)
else|:
operator|-
literal|1
decl_stmt|;
comment|// 5) Add the rest of operators back to the join filters
comment|// and create residual condition
name|RexNode
name|residualCond
init|=
name|residualFilters
operator|.
name|isEmpty
argument_list|()
condition|?
literal|null
else|:
name|residualFilters
operator|.
name|size
argument_list|()
operator|==
literal|1
condition|?
name|residualFilters
operator|.
name|get
argument_list|(
literal|0
argument_list|)
else|:
name|rexBuilder
operator|.
name|makeCall
argument_list|(
name|SqlStdOperatorTable
operator|.
name|AND
argument_list|,
name|residualFilters
argument_list|)
decl_stmt|;
comment|// 6) Return result
if|if
condition|(
name|pkSide
operator|==
literal|0
condition|)
block|{
name|FKSideInfo
name|fkInfo
init|=
operator|new
name|FKSideInfo
argument_list|(
name|rightRowCount
argument_list|,
name|rightNDV
argument_list|)
decl_stmt|;
name|double
name|pkSelectivity
init|=
name|pkSelectivity
argument_list|(
name|join
argument_list|,
name|mq
argument_list|,
literal|true
argument_list|,
name|left
argument_list|,
name|leftRowCount
argument_list|)
decl_stmt|;
name|PKSideInfo
name|pkInfo
init|=
operator|new
name|PKSideInfo
argument_list|(
name|leftRowCount
argument_list|,
name|leftNDV
argument_list|,
name|join
operator|.
name|getJoinType
argument_list|()
operator|.
name|generatesNullsOnRight
argument_list|()
condition|?
literal|1.0
else|:
name|pkSelectivity
argument_list|)
decl_stmt|;
name|double
name|ndvScalingFactor
init|=
name|isPKSideSimpleTree
condition|?
name|leftNDV
operator|/
name|rightNDV
else|:
literal|1.0
decl_stmt|;
return|return
name|Pair
operator|.
name|of
argument_list|(
operator|new
name|PKFKRelationInfo
argument_list|(
literal|1
argument_list|,
name|fkInfo
argument_list|,
name|pkInfo
argument_list|,
name|ndvScalingFactor
argument_list|,
name|isNoFilteringPKSideTree
argument_list|)
argument_list|,
name|residualCond
argument_list|)
return|;
block|}
else|else
block|{
comment|// pkSide == 1
name|FKSideInfo
name|fkInfo
init|=
operator|new
name|FKSideInfo
argument_list|(
name|leftRowCount
argument_list|,
name|leftNDV
argument_list|)
decl_stmt|;
name|double
name|pkSelectivity
init|=
name|pkSelectivity
argument_list|(
name|join
argument_list|,
name|mq
argument_list|,
literal|false
argument_list|,
name|right
argument_list|,
name|rightRowCount
argument_list|)
decl_stmt|;
name|PKSideInfo
name|pkInfo
init|=
operator|new
name|PKSideInfo
argument_list|(
name|rightRowCount
argument_list|,
name|rightNDV
argument_list|,
name|join
operator|.
name|getJoinType
argument_list|()
operator|.
name|generatesNullsOnLeft
argument_list|()
condition|?
literal|1.0
else|:
name|pkSelectivity
argument_list|)
decl_stmt|;
name|double
name|ndvScalingFactor
init|=
name|isPKSideSimpleTree
condition|?
name|rightNDV
operator|/
name|leftNDV
else|:
literal|1.0
decl_stmt|;
return|return
name|Pair
operator|.
name|of
argument_list|(
operator|new
name|PKFKRelationInfo
argument_list|(
literal|0
argument_list|,
name|fkInfo
argument_list|,
name|pkInfo
argument_list|,
name|ndvScalingFactor
argument_list|,
name|isNoFilteringPKSideTree
argument_list|)
argument_list|,
name|residualCond
argument_list|)
return|;
block|}
block|}
specifier|private
specifier|static
name|double
name|pkSelectivity
parameter_list|(
name|Join
name|joinRel
parameter_list|,
name|RelMetadataQuery
name|mq
parameter_list|,
name|boolean
name|leftChild
parameter_list|,
name|RelNode
name|child
parameter_list|,
name|double
name|childRowCount
parameter_list|)
block|{
if|if
condition|(
operator|(
name|leftChild
operator|&&
name|joinRel
operator|.
name|getJoinType
argument_list|()
operator|.
name|generatesNullsOnRight
argument_list|()
operator|)
operator|||
operator|(
operator|!
name|leftChild
operator|&&
name|joinRel
operator|.
name|getJoinType
argument_list|()
operator|.
name|generatesNullsOnLeft
argument_list|()
operator|)
condition|)
block|{
return|return
literal|1.0
return|;
block|}
else|else
block|{
name|HiveTableScan
name|tScan
init|=
name|EstimateUniqueKeys
operator|.
name|getTableScan
argument_list|(
name|child
argument_list|,
literal|true
argument_list|)
decl_stmt|;
if|if
condition|(
name|tScan
operator|!=
literal|null
condition|)
block|{
name|double
name|tRowCount
init|=
name|mq
operator|.
name|getRowCount
argument_list|(
name|tScan
argument_list|)
decl_stmt|;
return|return
name|childRowCount
operator|/
name|tRowCount
return|;
block|}
else|else
block|{
return|return
literal|1.0
return|;
block|}
block|}
block|}
specifier|private
specifier|static
name|boolean
name|isKey
parameter_list|(
name|ImmutableBitSet
name|c
parameter_list|,
name|RelNode
name|rel
parameter_list|,
name|RelMetadataQuery
name|mq
parameter_list|)
block|{
name|boolean
name|isKey
init|=
literal|false
decl_stmt|;
comment|//EstimateUniqueKeys doesn't go through metadata providers anymore, which means we will not be
comment|// taking advantage of metadata caching anymore. This could potential increase query compile time
comment|// Leaving a note here in case we see increase in timings
name|Set
argument_list|<
name|ImmutableBitSet
argument_list|>
name|keys
init|=
name|EstimateUniqueKeys
operator|.
name|getUniqueKeys
argument_list|(
name|rel
argument_list|)
decl_stmt|;
if|if
condition|(
name|keys
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|ImmutableBitSet
name|key
range|:
name|keys
control|)
block|{
if|if
condition|(
name|key
operator|.
name|equals
argument_list|(
name|c
argument_list|)
condition|)
block|{
name|isKey
operator|=
literal|true
expr_stmt|;
break|break;
block|}
block|}
block|}
return|return
name|isKey
return|;
block|}
comment|/*    * 1. Join condition must be an Equality Predicate.    * 2. both sides must reference 1 column.    * 3. If needed flip the columns.    */
specifier|private
specifier|static
name|Pair
argument_list|<
name|Integer
argument_list|,
name|Integer
argument_list|>
name|canHandleJoin
parameter_list|(
name|Join
name|joinRel
parameter_list|,
name|List
argument_list|<
name|RexNode
argument_list|>
name|leftFilters
parameter_list|,
name|List
argument_list|<
name|RexNode
argument_list|>
name|rightFilters
parameter_list|,
name|List
argument_list|<
name|RexNode
argument_list|>
name|joinFilters
parameter_list|)
block|{
comment|/*      * If after classifying filters there is more than 1 joining predicate, we      * don't handle this. Return null.      */
if|if
condition|(
name|joinFilters
operator|.
name|size
argument_list|()
operator|!=
literal|1
condition|)
block|{
return|return
literal|null
return|;
block|}
name|RexNode
name|joinCond
init|=
name|joinFilters
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|int
name|leftColIdx
decl_stmt|;
name|int
name|rightColIdx
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|joinCond
operator|instanceof
name|RexCall
operator|)
condition|)
block|{
return|return
literal|null
return|;
block|}
if|if
condition|(
operator|(
operator|(
name|RexCall
operator|)
name|joinCond
operator|)
operator|.
name|getOperator
argument_list|()
operator|!=
name|SqlStdOperatorTable
operator|.
name|EQUALS
condition|)
block|{
return|return
literal|null
return|;
block|}
name|ImmutableBitSet
name|leftCols
init|=
name|RelOptUtil
operator|.
name|InputFinder
operator|.
name|bits
argument_list|(
operator|(
operator|(
name|RexCall
operator|)
name|joinCond
operator|)
operator|.
name|getOperands
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|ImmutableBitSet
name|rightCols
init|=
name|RelOptUtil
operator|.
name|InputFinder
operator|.
name|bits
argument_list|(
operator|(
operator|(
name|RexCall
operator|)
name|joinCond
operator|)
operator|.
name|getOperands
argument_list|()
operator|.
name|get
argument_list|(
literal|1
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|leftCols
operator|.
name|cardinality
argument_list|()
operator|!=
literal|1
operator|||
name|rightCols
operator|.
name|cardinality
argument_list|()
operator|!=
literal|1
condition|)
block|{
return|return
literal|null
return|;
block|}
name|int
name|nFieldsLeft
init|=
name|joinRel
operator|.
name|getLeft
argument_list|()
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldList
argument_list|()
operator|.
name|size
argument_list|()
decl_stmt|;
name|int
name|nFieldsRight
init|=
name|joinRel
operator|.
name|getRight
argument_list|()
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldList
argument_list|()
operator|.
name|size
argument_list|()
decl_stmt|;
name|int
name|nSysFields
init|=
name|joinRel
operator|.
name|getSystemFieldList
argument_list|()
operator|.
name|size
argument_list|()
decl_stmt|;
name|ImmutableBitSet
name|rightFieldsBitSet
init|=
name|ImmutableBitSet
operator|.
name|range
argument_list|(
name|nSysFields
operator|+
name|nFieldsLeft
argument_list|,
name|nSysFields
operator|+
name|nFieldsLeft
operator|+
name|nFieldsRight
argument_list|)
decl_stmt|;
comment|/*      * flip column references if join condition specified in reverse order to      * join sources.      */
if|if
condition|(
name|rightFieldsBitSet
operator|.
name|contains
argument_list|(
name|leftCols
argument_list|)
condition|)
block|{
name|ImmutableBitSet
name|t
init|=
name|leftCols
decl_stmt|;
name|leftCols
operator|=
name|rightCols
expr_stmt|;
name|rightCols
operator|=
name|t
expr_stmt|;
block|}
name|leftColIdx
operator|=
name|leftCols
operator|.
name|nextSetBit
argument_list|(
literal|0
argument_list|)
operator|-
name|nSysFields
expr_stmt|;
name|rightColIdx
operator|=
name|rightCols
operator|.
name|nextSetBit
argument_list|(
literal|0
argument_list|)
operator|-
operator|(
name|nSysFields
operator|+
name|nFieldsLeft
operator|)
expr_stmt|;
return|return
operator|new
name|Pair
argument_list|<
name|Integer
argument_list|,
name|Integer
argument_list|>
argument_list|(
name|leftColIdx
argument_list|,
name|rightColIdx
argument_list|)
return|;
block|}
specifier|private
specifier|static
class|class
name|SimpleTreeOnJoinKey
extends|extends
name|RelVisitor
block|{
name|boolean
name|constraintsBased
decl_stmt|;
name|ImmutableBitSet
name|joinKey
decl_stmt|;
name|boolean
name|simpleTree
decl_stmt|;
name|boolean
name|nonFilteringTree
decl_stmt|;
name|RelMetadataQuery
name|mq
decl_stmt|;
specifier|static
name|Pair
argument_list|<
name|Boolean
argument_list|,
name|Boolean
argument_list|>
name|check
parameter_list|(
name|boolean
name|constraintsBased
parameter_list|,
name|RelNode
name|r
parameter_list|,
name|ImmutableBitSet
name|joinKey
parameter_list|,
name|RelMetadataQuery
name|mq
parameter_list|)
block|{
name|SimpleTreeOnJoinKey
name|v
init|=
operator|new
name|SimpleTreeOnJoinKey
argument_list|(
name|constraintsBased
argument_list|,
name|joinKey
argument_list|,
name|mq
argument_list|)
decl_stmt|;
name|v
operator|.
name|go
argument_list|(
name|r
argument_list|)
expr_stmt|;
return|return
name|Pair
operator|.
name|of
argument_list|(
name|v
operator|.
name|simpleTree
argument_list|,
name|v
operator|.
name|nonFilteringTree
argument_list|)
return|;
block|}
name|SimpleTreeOnJoinKey
parameter_list|(
name|boolean
name|constraintsBased
parameter_list|,
name|ImmutableBitSet
name|joinKey
parameter_list|,
name|RelMetadataQuery
name|mq
parameter_list|)
block|{
name|super
argument_list|()
expr_stmt|;
name|this
operator|.
name|constraintsBased
operator|=
name|constraintsBased
expr_stmt|;
name|this
operator|.
name|joinKey
operator|=
name|joinKey
expr_stmt|;
name|this
operator|.
name|mq
operator|=
name|mq
expr_stmt|;
name|simpleTree
operator|=
literal|true
expr_stmt|;
name|nonFilteringTree
operator|=
literal|true
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|visit
parameter_list|(
name|RelNode
name|node
parameter_list|,
name|int
name|ordinal
parameter_list|,
name|RelNode
name|parent
parameter_list|)
block|{
if|if
condition|(
name|node
operator|instanceof
name|HepRelVertex
condition|)
block|{
name|node
operator|=
operator|(
operator|(
name|HepRelVertex
operator|)
name|node
operator|)
operator|.
name|getCurrentRel
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|node
operator|instanceof
name|TableScan
condition|)
block|{
name|simpleTree
operator|=
literal|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|node
operator|instanceof
name|Project
condition|)
block|{
name|simpleTree
operator|=
name|isSimple
argument_list|(
operator|(
name|Project
operator|)
name|node
argument_list|)
expr_stmt|;
name|nonFilteringTree
operator|&=
name|simpleTree
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|node
operator|instanceof
name|Filter
condition|)
block|{
comment|// Remove is not null from condition if it does not filter anything.
name|Filter
name|filterOp
init|=
operator|(
name|Filter
operator|)
name|node
decl_stmt|;
name|List
argument_list|<
name|RexNode
argument_list|>
name|conjs
init|=
name|extractFilterPreds
argument_list|(
name|filterOp
argument_list|)
decl_stmt|;
name|ImmutableBitSet
name|condBits
init|=
name|RelOptUtil
operator|.
name|InputFinder
operator|.
name|bits
argument_list|(
name|conjs
argument_list|,
literal|null
argument_list|)
decl_stmt|;
comment|// For simple tree, we want to know whether filter is only on
comment|// key columns.
name|simpleTree
operator|=
name|isSimple
argument_list|(
name|condBits
argument_list|,
name|filterOp
argument_list|,
name|mq
argument_list|)
expr_stmt|;
name|nonFilteringTree
operator|&=
name|conjs
operator|.
name|isEmpty
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|simpleTree
operator|=
literal|false
expr_stmt|;
name|nonFilteringTree
operator|=
literal|false
expr_stmt|;
block|}
if|if
condition|(
name|simpleTree
condition|)
block|{
name|super
operator|.
name|visit
argument_list|(
name|node
argument_list|,
name|ordinal
argument_list|,
name|parent
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
name|boolean
name|isSimple
parameter_list|(
name|Project
name|project
parameter_list|)
block|{
name|ImmutableBitSet
operator|.
name|Builder
name|b
init|=
name|ImmutableBitSet
operator|.
name|builder
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|pos
range|:
name|joinKey
control|)
block|{
name|RexNode
name|r
init|=
name|project
operator|.
name|getProjects
argument_list|()
operator|.
name|get
argument_list|(
name|pos
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|r
operator|instanceof
name|RexInputRef
operator|)
condition|)
block|{
return|return
literal|false
return|;
block|}
name|b
operator|.
name|set
argument_list|(
operator|(
operator|(
name|RexInputRef
operator|)
name|r
operator|)
operator|.
name|getIndex
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|joinKey
operator|=
name|b
operator|.
name|build
argument_list|()
expr_stmt|;
return|return
literal|true
return|;
block|}
specifier|private
name|boolean
name|isSimple
parameter_list|(
name|ImmutableBitSet
name|condBits
parameter_list|,
name|Filter
name|filter
parameter_list|,
name|RelMetadataQuery
name|mq
parameter_list|)
block|{
comment|// Returns whether the filter is only applied on the key columns
if|if
condition|(
name|constraintsBased
condition|)
block|{
return|return
name|mq
operator|.
name|areColumnsUnique
argument_list|(
name|filter
argument_list|,
name|condBits
argument_list|)
return|;
block|}
return|return
name|isKey
argument_list|(
name|condBits
argument_list|,
name|filter
argument_list|,
name|mq
argument_list|)
return|;
block|}
specifier|private
name|List
argument_list|<
name|RexNode
argument_list|>
name|extractFilterPreds
parameter_list|(
name|Filter
name|filterOp
parameter_list|)
block|{
name|List
argument_list|<
name|RexNode
argument_list|>
name|conjs
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|RexNode
name|r
range|:
name|HiveRelOptUtil
operator|.
name|conjunctions
argument_list|(
name|filterOp
operator|.
name|getCondition
argument_list|()
argument_list|)
control|)
block|{
if|if
condition|(
name|r
operator|.
name|getKind
argument_list|()
operator|==
name|SqlKind
operator|.
name|IS_NOT_NULL
condition|)
block|{
name|RexCall
name|isNotNullNode
init|=
operator|(
name|RexCall
operator|)
name|r
decl_stmt|;
if|if
condition|(
name|RexUtil
operator|.
name|isReferenceOrAccess
argument_list|(
name|isNotNullNode
operator|.
name|getOperands
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|,
literal|true
argument_list|)
condition|)
block|{
name|ImmutableBitSet
name|ref
init|=
name|RelOptUtil
operator|.
name|InputFinder
operator|.
name|bits
argument_list|(
name|isNotNullNode
argument_list|)
decl_stmt|;
name|RelColumnOrigin
name|co
init|=
name|mq
operator|.
name|getColumnOrigin
argument_list|(
name|filterOp
argument_list|,
name|ref
operator|.
name|nextSetBit
argument_list|(
literal|0
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|co
operator|==
literal|null
condition|)
block|{
comment|// We add it back
name|conjs
operator|.
name|add
argument_list|(
name|r
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|RelOptHiveTable
name|table
init|=
operator|(
name|RelOptHiveTable
operator|)
name|co
operator|.
name|getOriginTable
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|ColStatistics
argument_list|>
name|colStats
init|=
name|table
operator|.
name|getColStat
argument_list|(
name|ImmutableList
operator|.
name|of
argument_list|(
name|co
operator|.
name|getOriginColumnOrdinal
argument_list|()
argument_list|)
argument_list|,
literal|true
argument_list|)
decl_stmt|;
if|if
condition|(
name|colStats
operator|==
literal|null
operator|||
name|colStats
operator|.
name|isEmpty
argument_list|()
operator|||
name|colStats
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|getNumNulls
argument_list|()
operator|!=
literal|0
condition|)
block|{
comment|// We add it back
name|conjs
operator|.
name|add
argument_list|(
name|r
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|conjs
operator|.
name|add
argument_list|(
name|r
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|conjs
return|;
block|}
block|}
block|}
end_class

end_unit

