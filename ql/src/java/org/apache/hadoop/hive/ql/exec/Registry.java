begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
package|;
end_package

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Splitter
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Sets
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|Log
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|LogFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|common
operator|.
name|JavaUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|FunctionInfo
operator|.
name|FunctionResource
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|ErrorMsg
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|metadata
operator|.
name|HiveException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|parse
operator|.
name|SemanticException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|ExprNodeDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|session
operator|.
name|SessionState
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|udf
operator|.
name|generic
operator|.
name|GenericUDAFBridge
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|udf
operator|.
name|generic
operator|.
name|GenericUDAFEvaluator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|udf
operator|.
name|generic
operator|.
name|GenericUDAFParameterInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|udf
operator|.
name|generic
operator|.
name|GenericUDAFResolver
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|udf
operator|.
name|generic
operator|.
name|GenericUDAFResolver2
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|udf
operator|.
name|generic
operator|.
name|GenericUDF
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|udf
operator|.
name|generic
operator|.
name|GenericUDFBridge
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|udf
operator|.
name|generic
operator|.
name|GenericUDFMacro
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|udf
operator|.
name|generic
operator|.
name|GenericUDTF
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|udf
operator|.
name|generic
operator|.
name|SimpleGenericUDAFParameterInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|udf
operator|.
name|ptf
operator|.
name|TableFunctionResolver
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|objectinspector
operator|.
name|ObjectInspector
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|typeinfo
operator|.
name|TypeInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|ReflectionUtils
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|URLClassLoader
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|LinkedHashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|LinkedHashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|TreeSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|regex
operator|.
name|Pattern
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|regex
operator|.
name|PatternSyntaxException
import|;
end_import

begin_comment
comment|// Extracted from FunctionRegistry
end_comment

begin_class
specifier|public
class|class
name|Registry
block|{
specifier|private
specifier|static
specifier|final
name|Log
name|LOG
init|=
name|LogFactory
operator|.
name|getLog
argument_list|(
name|FunctionRegistry
operator|.
name|class
argument_list|)
decl_stmt|;
comment|// prefix for window functions, to discern LEAD/LAG UDFs from window functions with the same name
specifier|private
specifier|static
specifier|final
name|String
name|WINDOW_FUNC_PREFIX
init|=
literal|"@_"
decl_stmt|;
comment|/**    * The mapping from expression function names to expression classes.    */
specifier|private
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|FunctionInfo
argument_list|>
name|mFunctions
init|=
operator|new
name|LinkedHashMap
argument_list|<
name|String
argument_list|,
name|FunctionInfo
argument_list|>
argument_list|()
decl_stmt|;
specifier|private
specifier|final
name|Set
argument_list|<
name|Class
argument_list|<
name|?
argument_list|>
argument_list|>
name|builtIns
init|=
name|Collections
operator|.
name|synchronizedSet
argument_list|(
operator|new
name|HashSet
argument_list|<
name|Class
argument_list|<
name|?
argument_list|>
argument_list|>
argument_list|()
argument_list|)
decl_stmt|;
specifier|private
specifier|final
name|Set
argument_list|<
name|ClassLoader
argument_list|>
name|mSessionUDFLoaders
init|=
operator|new
name|LinkedHashSet
argument_list|<
name|ClassLoader
argument_list|>
argument_list|()
decl_stmt|;
specifier|private
specifier|final
name|boolean
name|isNative
decl_stmt|;
name|Registry
parameter_list|(
name|boolean
name|isNative
parameter_list|)
block|{
name|this
operator|.
name|isNative
operator|=
name|isNative
expr_stmt|;
block|}
specifier|public
name|Registry
parameter_list|()
block|{
name|this
argument_list|(
literal|false
argument_list|)
expr_stmt|;
block|}
comment|/**    * Registers the appropriate kind of temporary function based on a class's    * type.    *    * @param functionName name under which to register function    * @param udfClass     class implementing UD[A|T]F    * @return true if udfClass's type was recognized (so registration    *         succeeded); false otherwise    */
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
specifier|public
name|FunctionInfo
name|registerFunction
parameter_list|(
name|String
name|functionName
parameter_list|,
name|Class
argument_list|<
name|?
argument_list|>
name|udfClass
parameter_list|,
name|FunctionResource
modifier|...
name|resources
parameter_list|)
block|{
name|FunctionUtils
operator|.
name|UDFClassType
name|udfClassType
init|=
name|FunctionUtils
operator|.
name|getUDFClassType
argument_list|(
name|udfClass
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|udfClassType
condition|)
block|{
case|case
name|UDF
case|:
return|return
name|registerUDF
argument_list|(
name|functionName
argument_list|,
operator|(
name|Class
argument_list|<
name|?
extends|extends
name|UDF
argument_list|>
operator|)
name|udfClass
argument_list|,
literal|false
argument_list|,
name|resources
argument_list|)
return|;
case|case
name|GENERIC_UDF
case|:
return|return
name|registerGenericUDF
argument_list|(
name|functionName
argument_list|,
operator|(
name|Class
argument_list|<
name|?
extends|extends
name|GenericUDF
argument_list|>
operator|)
name|udfClass
argument_list|,
name|resources
argument_list|)
return|;
case|case
name|GENERIC_UDTF
case|:
return|return
name|registerGenericUDTF
argument_list|(
name|functionName
argument_list|,
operator|(
name|Class
argument_list|<
name|?
extends|extends
name|GenericUDTF
argument_list|>
operator|)
name|udfClass
argument_list|,
name|resources
argument_list|)
return|;
case|case
name|UDAF
case|:
return|return
name|registerUDAF
argument_list|(
name|functionName
argument_list|,
operator|(
name|Class
argument_list|<
name|?
extends|extends
name|UDAF
argument_list|>
operator|)
name|udfClass
argument_list|,
name|resources
argument_list|)
return|;
case|case
name|GENERIC_UDAF_RESOLVER
case|:
return|return
name|registerGenericUDAF
argument_list|(
name|functionName
argument_list|,
operator|(
name|GenericUDAFResolver
operator|)
name|ReflectionUtils
operator|.
name|newInstance
argument_list|(
name|udfClass
argument_list|,
literal|null
argument_list|)
argument_list|,
name|resources
argument_list|)
return|;
case|case
name|TABLE_FUNCTION_RESOLVER
case|:
comment|// native or not would be decided by annotation. need to evaluate that first
return|return
name|registerTableFunction
argument_list|(
name|functionName
argument_list|,
operator|(
name|Class
argument_list|<
name|?
extends|extends
name|TableFunctionResolver
argument_list|>
operator|)
name|udfClass
argument_list|,
name|resources
argument_list|)
return|;
block|}
return|return
literal|null
return|;
block|}
specifier|public
name|FunctionInfo
name|registerUDF
parameter_list|(
name|String
name|functionName
parameter_list|,
name|Class
argument_list|<
name|?
extends|extends
name|UDF
argument_list|>
name|UDFClass
parameter_list|,
name|boolean
name|isOperator
parameter_list|,
name|FunctionResource
modifier|...
name|resources
parameter_list|)
block|{
return|return
name|registerUDF
argument_list|(
name|functionName
argument_list|,
name|UDFClass
argument_list|,
name|isOperator
argument_list|,
name|functionName
operator|.
name|toLowerCase
argument_list|()
argument_list|,
name|resources
argument_list|)
return|;
block|}
specifier|public
name|FunctionInfo
name|registerUDF
parameter_list|(
name|String
name|functionName
parameter_list|,
name|Class
argument_list|<
name|?
extends|extends
name|UDF
argument_list|>
name|UDFClass
parameter_list|,
name|boolean
name|isOperator
parameter_list|,
name|String
name|displayName
parameter_list|,
name|FunctionResource
modifier|...
name|resources
parameter_list|)
block|{
name|validateClass
argument_list|(
name|UDFClass
argument_list|,
name|UDF
operator|.
name|class
argument_list|)
expr_stmt|;
name|FunctionInfo
name|fI
init|=
operator|new
name|FunctionInfo
argument_list|(
name|isNative
argument_list|,
name|displayName
argument_list|,
operator|new
name|GenericUDFBridge
argument_list|(
name|displayName
argument_list|,
name|isOperator
argument_list|,
name|UDFClass
operator|.
name|getName
argument_list|()
argument_list|)
argument_list|,
name|resources
argument_list|)
decl_stmt|;
name|addFunction
argument_list|(
name|functionName
argument_list|,
name|fI
argument_list|)
expr_stmt|;
return|return
name|fI
return|;
block|}
specifier|public
name|FunctionInfo
name|registerGenericUDF
parameter_list|(
name|String
name|functionName
parameter_list|,
name|Class
argument_list|<
name|?
extends|extends
name|GenericUDF
argument_list|>
name|genericUDFClass
parameter_list|,
name|FunctionResource
modifier|...
name|resources
parameter_list|)
block|{
name|validateClass
argument_list|(
name|genericUDFClass
argument_list|,
name|GenericUDF
operator|.
name|class
argument_list|)
expr_stmt|;
name|FunctionInfo
name|fI
init|=
operator|new
name|FunctionInfo
argument_list|(
name|isNative
argument_list|,
name|functionName
argument_list|,
name|ReflectionUtils
operator|.
name|newInstance
argument_list|(
name|genericUDFClass
argument_list|,
literal|null
argument_list|)
argument_list|,
name|resources
argument_list|)
decl_stmt|;
name|addFunction
argument_list|(
name|functionName
argument_list|,
name|fI
argument_list|)
expr_stmt|;
return|return
name|fI
return|;
block|}
specifier|public
name|FunctionInfo
name|registerGenericUDTF
parameter_list|(
name|String
name|functionName
parameter_list|,
name|Class
argument_list|<
name|?
extends|extends
name|GenericUDTF
argument_list|>
name|genericUDTFClass
parameter_list|,
name|FunctionResource
modifier|...
name|resources
parameter_list|)
block|{
name|validateClass
argument_list|(
name|genericUDTFClass
argument_list|,
name|GenericUDTF
operator|.
name|class
argument_list|)
expr_stmt|;
name|FunctionInfo
name|fI
init|=
operator|new
name|FunctionInfo
argument_list|(
name|isNative
argument_list|,
name|functionName
argument_list|,
name|ReflectionUtils
operator|.
name|newInstance
argument_list|(
name|genericUDTFClass
argument_list|,
literal|null
argument_list|)
argument_list|,
name|resources
argument_list|)
decl_stmt|;
name|addFunction
argument_list|(
name|functionName
argument_list|,
name|fI
argument_list|)
expr_stmt|;
return|return
name|fI
return|;
block|}
specifier|public
name|FunctionInfo
name|registerGenericUDAF
parameter_list|(
name|String
name|functionName
parameter_list|,
name|GenericUDAFResolver
name|genericUDAFResolver
parameter_list|,
name|FunctionResource
modifier|...
name|resources
parameter_list|)
block|{
name|FunctionInfo
name|function
init|=
operator|new
name|WindowFunctionInfo
argument_list|(
name|isNative
argument_list|,
name|functionName
argument_list|,
name|genericUDAFResolver
argument_list|,
name|resources
argument_list|)
decl_stmt|;
name|addFunction
argument_list|(
name|functionName
argument_list|,
name|function
argument_list|)
expr_stmt|;
name|addFunction
argument_list|(
name|WINDOW_FUNC_PREFIX
operator|+
name|functionName
argument_list|,
name|function
argument_list|)
expr_stmt|;
return|return
name|function
return|;
block|}
specifier|public
name|FunctionInfo
name|registerUDAF
parameter_list|(
name|String
name|functionName
parameter_list|,
name|Class
argument_list|<
name|?
extends|extends
name|UDAF
argument_list|>
name|udafClass
parameter_list|,
name|FunctionResource
modifier|...
name|resources
parameter_list|)
block|{
name|validateClass
argument_list|(
name|udafClass
argument_list|,
name|UDAF
operator|.
name|class
argument_list|)
expr_stmt|;
name|FunctionInfo
name|function
init|=
operator|new
name|WindowFunctionInfo
argument_list|(
name|isNative
argument_list|,
name|functionName
argument_list|,
operator|new
name|GenericUDAFBridge
argument_list|(
name|ReflectionUtils
operator|.
name|newInstance
argument_list|(
name|udafClass
argument_list|,
literal|null
argument_list|)
argument_list|)
argument_list|,
name|resources
argument_list|)
decl_stmt|;
name|addFunction
argument_list|(
name|functionName
argument_list|,
name|function
argument_list|)
expr_stmt|;
name|addFunction
argument_list|(
name|WINDOW_FUNC_PREFIX
operator|+
name|functionName
argument_list|,
name|function
argument_list|)
expr_stmt|;
return|return
name|function
return|;
block|}
specifier|public
name|FunctionInfo
name|registerTableFunction
parameter_list|(
name|String
name|functionName
parameter_list|,
name|Class
argument_list|<
name|?
extends|extends
name|TableFunctionResolver
argument_list|>
name|tFnCls
parameter_list|,
name|FunctionResource
modifier|...
name|resources
parameter_list|)
block|{
name|validateClass
argument_list|(
name|tFnCls
argument_list|,
name|TableFunctionResolver
operator|.
name|class
argument_list|)
expr_stmt|;
name|FunctionInfo
name|function
init|=
operator|new
name|FunctionInfo
argument_list|(
name|isNative
argument_list|,
name|functionName
argument_list|,
name|tFnCls
argument_list|,
name|resources
argument_list|)
decl_stmt|;
name|addFunction
argument_list|(
name|functionName
argument_list|,
name|function
argument_list|)
expr_stmt|;
return|return
name|function
return|;
block|}
specifier|public
name|FunctionInfo
name|registerMacro
parameter_list|(
name|String
name|macroName
parameter_list|,
name|ExprNodeDesc
name|body
parameter_list|,
name|List
argument_list|<
name|String
argument_list|>
name|colNames
parameter_list|,
name|List
argument_list|<
name|TypeInfo
argument_list|>
name|colTypes
parameter_list|)
block|{
return|return
name|registerMacro
argument_list|(
name|macroName
argument_list|,
name|body
argument_list|,
name|colNames
argument_list|,
name|colTypes
argument_list|,
literal|null
argument_list|)
return|;
block|}
specifier|public
name|FunctionInfo
name|registerMacro
parameter_list|(
name|String
name|macroName
parameter_list|,
name|ExprNodeDesc
name|body
parameter_list|,
name|List
argument_list|<
name|String
argument_list|>
name|colNames
parameter_list|,
name|List
argument_list|<
name|TypeInfo
argument_list|>
name|colTypes
parameter_list|,
name|FunctionResource
modifier|...
name|resources
parameter_list|)
block|{
name|GenericUDFMacro
name|macro
init|=
operator|new
name|GenericUDFMacro
argument_list|(
name|macroName
argument_list|,
name|body
argument_list|,
name|colNames
argument_list|,
name|colTypes
argument_list|)
decl_stmt|;
name|FunctionInfo
name|fI
init|=
operator|new
name|FunctionInfo
argument_list|(
name|isNative
argument_list|,
name|macroName
argument_list|,
name|macro
argument_list|,
name|resources
argument_list|)
decl_stmt|;
name|addFunction
argument_list|(
name|macroName
argument_list|,
name|fI
argument_list|)
expr_stmt|;
return|return
name|fI
return|;
block|}
specifier|public
name|FunctionInfo
name|registerPermanentFunction
parameter_list|(
name|String
name|functionName
parameter_list|,
name|String
name|className
parameter_list|,
name|boolean
name|registerToSession
parameter_list|,
name|FunctionResource
modifier|...
name|resources
parameter_list|)
block|{
name|FunctionInfo
name|function
init|=
operator|new
name|FunctionInfo
argument_list|(
name|functionName
argument_list|,
name|className
argument_list|,
name|resources
argument_list|)
decl_stmt|;
comment|// register to session first for backward compatibility
if|if
condition|(
name|registerToSession
condition|)
block|{
name|String
name|qualifiedName
init|=
name|FunctionUtils
operator|.
name|qualifyFunctionName
argument_list|(
name|functionName
argument_list|,
name|SessionState
operator|.
name|get
argument_list|()
operator|.
name|getCurrentDatabase
argument_list|()
operator|.
name|toLowerCase
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|registerToSessionRegistry
argument_list|(
name|qualifiedName
argument_list|,
name|function
argument_list|)
operator|!=
literal|null
condition|)
block|{
name|addFunction
argument_list|(
name|functionName
argument_list|,
name|function
argument_list|)
expr_stmt|;
return|return
name|function
return|;
block|}
block|}
name|addFunction
argument_list|(
name|functionName
argument_list|,
name|function
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
comment|/**    * Typically a WindowFunction is the same as a UDAF. The only exceptions are Lead& Lag UDAFs. These    * are not registered as regular UDAFs because    * - we plan to support Lead& Lag as UDFs (usable only within argument expressions    *   of UDAFs when windowing is involved). Since mFunctions holds both UDFs and UDAFs we cannot    *   add both FunctionInfos to mFunctions.    *    * @param name    * @param wFn    */
name|void
name|registerWindowFunction
parameter_list|(
name|String
name|name
parameter_list|,
name|GenericUDAFResolver
name|wFn
parameter_list|)
block|{
name|addFunction
argument_list|(
name|WINDOW_FUNC_PREFIX
operator|+
name|name
argument_list|,
operator|new
name|WindowFunctionInfo
argument_list|(
name|isNative
argument_list|,
name|name
argument_list|,
name|wFn
argument_list|,
literal|null
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|validateClass
parameter_list|(
name|Class
name|input
parameter_list|,
name|Class
name|expected
parameter_list|)
block|{
if|if
condition|(
operator|!
name|expected
operator|.
name|isAssignableFrom
argument_list|(
name|input
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Registering UDF Class "
operator|+
name|input
operator|+
literal|" which does not extend "
operator|+
name|expected
argument_list|)
throw|;
block|}
block|}
comment|/**    * Looks up the function name in the registry. If enabled, will attempt to search the metastore    * for the function.    * @param functionName    * @return    */
specifier|public
specifier|synchronized
name|FunctionInfo
name|getFunctionInfo
parameter_list|(
name|String
name|functionName
parameter_list|)
throws|throws
name|SemanticException
block|{
name|functionName
operator|=
name|functionName
operator|.
name|toLowerCase
argument_list|()
expr_stmt|;
if|if
condition|(
name|FunctionUtils
operator|.
name|isQualifiedFunctionName
argument_list|(
name|functionName
argument_list|)
condition|)
block|{
return|return
name|getQualifiedFunctionInfo
argument_list|(
name|functionName
argument_list|)
return|;
block|}
comment|// First try without qualifiers - would resolve builtin/temp functions.
comment|// Otherwise try qualifying with current db name.
name|FunctionInfo
name|functionInfo
init|=
name|mFunctions
operator|.
name|get
argument_list|(
name|functionName
argument_list|)
decl_stmt|;
if|if
condition|(
name|functionInfo
operator|!=
literal|null
operator|&&
name|functionInfo
operator|.
name|isBlockedFunction
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
literal|"UDF "
operator|+
name|functionName
operator|+
literal|" is not allowed"
argument_list|)
throw|;
block|}
if|if
condition|(
name|functionInfo
operator|==
literal|null
condition|)
block|{
name|String
name|qualifiedName
init|=
name|FunctionUtils
operator|.
name|qualifyFunctionName
argument_list|(
name|functionName
argument_list|,
name|SessionState
operator|.
name|get
argument_list|()
operator|.
name|getCurrentDatabase
argument_list|()
operator|.
name|toLowerCase
argument_list|()
argument_list|)
decl_stmt|;
name|functionInfo
operator|=
name|getQualifiedFunctionInfo
argument_list|(
name|qualifiedName
argument_list|)
expr_stmt|;
block|}
return|return
name|functionInfo
return|;
block|}
specifier|public
name|WindowFunctionInfo
name|getWindowFunctionInfo
parameter_list|(
name|String
name|functionName
parameter_list|)
throws|throws
name|SemanticException
block|{
name|FunctionInfo
name|info
init|=
name|getFunctionInfo
argument_list|(
name|WINDOW_FUNC_PREFIX
operator|+
name|functionName
argument_list|)
decl_stmt|;
if|if
condition|(
name|info
operator|instanceof
name|WindowFunctionInfo
condition|)
block|{
return|return
operator|(
name|WindowFunctionInfo
operator|)
name|info
return|;
block|}
return|return
literal|null
return|;
block|}
comment|/**    * @param udfClass Function class.    * @return True iff the fnExpr represents a hive built-in function.    */
specifier|public
name|boolean
name|isBuiltInFunc
parameter_list|(
name|Class
argument_list|<
name|?
argument_list|>
name|udfClass
parameter_list|)
block|{
return|return
name|udfClass
operator|!=
literal|null
operator|&&
name|builtIns
operator|.
name|contains
argument_list|(
name|udfClass
argument_list|)
return|;
block|}
specifier|public
specifier|synchronized
name|Set
argument_list|<
name|String
argument_list|>
name|getCurrentFunctionNames
parameter_list|()
block|{
return|return
name|getFunctionNames
argument_list|(
operator|(
name|Pattern
operator|)
literal|null
argument_list|)
return|;
block|}
specifier|public
specifier|synchronized
name|Set
argument_list|<
name|String
argument_list|>
name|getFunctionNames
parameter_list|(
name|String
name|funcPatternStr
parameter_list|)
block|{
try|try
block|{
return|return
name|getFunctionNames
argument_list|(
name|Pattern
operator|.
name|compile
argument_list|(
name|funcPatternStr
argument_list|)
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|PatternSyntaxException
name|e
parameter_list|)
block|{
return|return
name|Collections
operator|.
name|emptySet
argument_list|()
return|;
block|}
block|}
comment|/**    * Returns a set of registered function names. This is used for the CLI    * command "SHOW FUNCTIONS 'regular expression';" Returns an empty set when    * the regular expression is not valid.    *    * @param funcPattern regular expression of the interested function names    * @return set of strings contains function names    */
specifier|public
specifier|synchronized
name|Set
argument_list|<
name|String
argument_list|>
name|getFunctionNames
parameter_list|(
name|Pattern
name|funcPattern
parameter_list|)
block|{
name|Set
argument_list|<
name|String
argument_list|>
name|funcNames
init|=
operator|new
name|TreeSet
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|String
name|funcName
range|:
name|mFunctions
operator|.
name|keySet
argument_list|()
control|)
block|{
if|if
condition|(
name|funcName
operator|.
name|contains
argument_list|(
name|WINDOW_FUNC_PREFIX
argument_list|)
condition|)
block|{
continue|continue;
block|}
if|if
condition|(
name|funcPattern
operator|==
literal|null
operator|||
name|funcPattern
operator|.
name|matcher
argument_list|(
name|funcName
argument_list|)
operator|.
name|matches
argument_list|()
condition|)
block|{
name|funcNames
operator|.
name|add
argument_list|(
name|funcName
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|funcNames
return|;
block|}
comment|/**    * Adds to the set of synonyms of the supplied function.    * @param funcName    * @param funcInfo    * @param synonyms    */
specifier|public
specifier|synchronized
name|void
name|getFunctionSynonyms
parameter_list|(
name|String
name|funcName
parameter_list|,
name|FunctionInfo
name|funcInfo
parameter_list|,
name|Set
argument_list|<
name|String
argument_list|>
name|synonyms
parameter_list|)
throws|throws
name|SemanticException
block|{
name|Class
argument_list|<
name|?
argument_list|>
name|funcClass
init|=
name|funcInfo
operator|.
name|getFunctionClass
argument_list|()
decl_stmt|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|FunctionInfo
argument_list|>
name|entry
range|:
name|mFunctions
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|String
name|name
init|=
name|entry
operator|.
name|getKey
argument_list|()
decl_stmt|;
if|if
condition|(
name|name
operator|.
name|contains
argument_list|(
name|WINDOW_FUNC_PREFIX
argument_list|)
operator|||
name|name
operator|.
name|equals
argument_list|(
name|funcName
argument_list|)
condition|)
block|{
continue|continue;
block|}
name|FunctionInfo
name|function
init|=
name|entry
operator|.
name|getValue
argument_list|()
decl_stmt|;
if|if
condition|(
name|function
operator|.
name|getFunctionClass
argument_list|()
operator|==
name|funcClass
condition|)
block|{
name|synonyms
operator|.
name|add
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**    * Get the GenericUDAF evaluator for the name and argumentClasses.    *    * @param name         the name of the UDAF    * @param argumentOIs    * @param isDistinct    * @param isAllColumns    * @return The UDAF evaluator    */
annotation|@
name|SuppressWarnings
argument_list|(
literal|"deprecation"
argument_list|)
specifier|public
name|GenericUDAFEvaluator
name|getGenericUDAFEvaluator
parameter_list|(
name|String
name|name
parameter_list|,
name|List
argument_list|<
name|ObjectInspector
argument_list|>
name|argumentOIs
parameter_list|,
name|boolean
name|isDistinct
parameter_list|,
name|boolean
name|isAllColumns
parameter_list|)
throws|throws
name|SemanticException
block|{
name|GenericUDAFResolver
name|udafResolver
init|=
name|getGenericUDAFResolver
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|udafResolver
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
name|GenericUDAFEvaluator
name|udafEvaluator
decl_stmt|;
name|ObjectInspector
name|args
index|[]
init|=
operator|new
name|ObjectInspector
index|[
name|argumentOIs
operator|.
name|size
argument_list|()
index|]
decl_stmt|;
comment|// Can't use toArray here because Java is dumb when it comes to
comment|// generics + arrays.
for|for
control|(
name|int
name|ii
init|=
literal|0
init|;
name|ii
operator|<
name|argumentOIs
operator|.
name|size
argument_list|()
condition|;
operator|++
name|ii
control|)
block|{
name|args
index|[
name|ii
index|]
operator|=
name|argumentOIs
operator|.
name|get
argument_list|(
name|ii
argument_list|)
expr_stmt|;
block|}
name|GenericUDAFParameterInfo
name|paramInfo
init|=
operator|new
name|SimpleGenericUDAFParameterInfo
argument_list|(
name|args
argument_list|,
name|isDistinct
argument_list|,
name|isAllColumns
argument_list|)
decl_stmt|;
if|if
condition|(
name|udafResolver
operator|instanceof
name|GenericUDAFResolver2
condition|)
block|{
name|udafEvaluator
operator|=
operator|(
operator|(
name|GenericUDAFResolver2
operator|)
name|udafResolver
operator|)
operator|.
name|getEvaluator
argument_list|(
name|paramInfo
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|udafEvaluator
operator|=
name|udafResolver
operator|.
name|getEvaluator
argument_list|(
name|paramInfo
operator|.
name|getParameters
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|udafEvaluator
return|;
block|}
specifier|public
name|GenericUDAFEvaluator
name|getGenericWindowingEvaluator
parameter_list|(
name|String
name|functionName
parameter_list|,
name|List
argument_list|<
name|ObjectInspector
argument_list|>
name|argumentOIs
parameter_list|,
name|boolean
name|isDistinct
parameter_list|,
name|boolean
name|isAllColumns
parameter_list|)
throws|throws
name|SemanticException
block|{
name|functionName
operator|=
name|functionName
operator|.
name|toLowerCase
argument_list|()
expr_stmt|;
name|WindowFunctionInfo
name|info
init|=
name|getWindowFunctionInfo
argument_list|(
name|functionName
argument_list|)
decl_stmt|;
if|if
condition|(
name|info
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
if|if
condition|(
operator|!
name|functionName
operator|.
name|equals
argument_list|(
name|FunctionRegistry
operator|.
name|LEAD_FUNC_NAME
argument_list|)
operator|&&
operator|!
name|functionName
operator|.
name|equals
argument_list|(
name|FunctionRegistry
operator|.
name|LAG_FUNC_NAME
argument_list|)
condition|)
block|{
return|return
name|getGenericUDAFEvaluator
argument_list|(
name|functionName
argument_list|,
name|argumentOIs
argument_list|,
name|isDistinct
argument_list|,
name|isAllColumns
argument_list|)
return|;
block|}
comment|// this must be lead/lag UDAF
name|ObjectInspector
name|args
index|[]
init|=
operator|new
name|ObjectInspector
index|[
name|argumentOIs
operator|.
name|size
argument_list|()
index|]
decl_stmt|;
name|GenericUDAFResolver
name|udafResolver
init|=
name|info
operator|.
name|getGenericUDAFResolver
argument_list|()
decl_stmt|;
name|GenericUDAFParameterInfo
name|paramInfo
init|=
operator|new
name|SimpleGenericUDAFParameterInfo
argument_list|(
name|argumentOIs
operator|.
name|toArray
argument_list|(
name|args
argument_list|)
argument_list|,
name|isDistinct
argument_list|,
name|isAllColumns
argument_list|)
decl_stmt|;
return|return
operator|(
operator|(
name|GenericUDAFResolver2
operator|)
name|udafResolver
operator|)
operator|.
name|getEvaluator
argument_list|(
name|paramInfo
argument_list|)
return|;
block|}
specifier|private
specifier|synchronized
name|void
name|addFunction
parameter_list|(
name|String
name|functionName
parameter_list|,
name|FunctionInfo
name|function
parameter_list|)
block|{
if|if
condition|(
name|isNative
operator|^
name|function
operator|.
name|isNative
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Function "
operator|+
name|functionName
operator|+
literal|" is not for this registry"
argument_list|)
throw|;
block|}
name|functionName
operator|=
name|functionName
operator|.
name|toLowerCase
argument_list|()
expr_stmt|;
name|FunctionInfo
name|prev
init|=
name|mFunctions
operator|.
name|get
argument_list|(
name|functionName
argument_list|)
decl_stmt|;
if|if
condition|(
name|prev
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|isBuiltInFunc
argument_list|(
name|prev
operator|.
name|getFunctionClass
argument_list|()
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Function "
operator|+
name|functionName
operator|+
literal|" is hive builtin function, "
operator|+
literal|"which cannot be overriden."
argument_list|)
throw|;
block|}
name|prev
operator|.
name|discarded
argument_list|()
expr_stmt|;
block|}
name|mFunctions
operator|.
name|put
argument_list|(
name|functionName
argument_list|,
name|function
argument_list|)
expr_stmt|;
if|if
condition|(
name|function
operator|.
name|isBuiltIn
argument_list|()
condition|)
block|{
name|builtIns
operator|.
name|add
argument_list|(
name|function
operator|.
name|getFunctionClass
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
specifier|public
specifier|synchronized
name|void
name|unregisterFunction
parameter_list|(
name|String
name|functionName
parameter_list|)
throws|throws
name|HiveException
block|{
name|functionName
operator|=
name|functionName
operator|.
name|toLowerCase
argument_list|()
expr_stmt|;
name|FunctionInfo
name|fi
init|=
name|mFunctions
operator|.
name|get
argument_list|(
name|functionName
argument_list|)
decl_stmt|;
if|if
condition|(
name|fi
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|fi
operator|.
name|isBuiltIn
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|HiveException
argument_list|(
name|ErrorMsg
operator|.
name|DROP_NATIVE_FUNCTION
operator|.
name|getMsg
argument_list|(
name|functionName
argument_list|)
argument_list|)
throw|;
block|}
name|mFunctions
operator|.
name|remove
argument_list|(
name|functionName
argument_list|)
expr_stmt|;
name|fi
operator|.
name|discarded
argument_list|()
expr_stmt|;
block|}
block|}
specifier|public
name|GenericUDAFResolver
name|getGenericUDAFResolver
parameter_list|(
name|String
name|functionName
parameter_list|)
throws|throws
name|SemanticException
block|{
name|FunctionInfo
name|info
init|=
name|getFunctionInfo
argument_list|(
name|functionName
argument_list|)
decl_stmt|;
if|if
condition|(
name|info
operator|!=
literal|null
condition|)
block|{
return|return
name|info
operator|.
name|getGenericUDAFResolver
argument_list|()
return|;
block|}
return|return
literal|null
return|;
block|}
specifier|private
name|FunctionInfo
name|getQualifiedFunctionInfo
parameter_list|(
name|String
name|qualifiedName
parameter_list|)
throws|throws
name|SemanticException
block|{
name|FunctionInfo
name|info
init|=
name|mFunctions
operator|.
name|get
argument_list|(
name|qualifiedName
argument_list|)
decl_stmt|;
if|if
condition|(
name|info
operator|!=
literal|null
operator|&&
name|info
operator|.
name|isBlockedFunction
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
literal|"UDF "
operator|+
name|qualifiedName
operator|+
literal|" is not allowed"
argument_list|)
throw|;
block|}
if|if
condition|(
operator|!
name|isNative
operator|&&
name|info
operator|!=
literal|null
operator|&&
name|info
operator|.
name|isDiscarded
argument_list|()
condition|)
block|{
comment|// the persistent function is discarded. try reload
name|mFunctions
operator|.
name|remove
argument_list|(
name|qualifiedName
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
comment|// HIVE-6672: In HiveServer2 the JARs for this UDF may have been loaded by a different thread,
comment|// and the current thread may not be able to resolve the UDF. Test for this condition
comment|// and if necessary load the JARs in this thread.
if|if
condition|(
name|isNative
operator|&&
name|info
operator|!=
literal|null
operator|&&
name|info
operator|.
name|isPersistent
argument_list|()
condition|)
block|{
return|return
name|registerToSessionRegistry
argument_list|(
name|qualifiedName
argument_list|,
name|info
argument_list|)
return|;
block|}
return|return
name|info
return|;
block|}
comment|// should be called after session registry is checked
specifier|private
name|FunctionInfo
name|registerToSessionRegistry
parameter_list|(
name|String
name|qualifiedName
parameter_list|,
name|FunctionInfo
name|function
parameter_list|)
block|{
name|FunctionInfo
name|ret
init|=
literal|null
decl_stmt|;
name|ClassLoader
name|prev
init|=
name|Utilities
operator|.
name|getSessionSpecifiedClassLoader
argument_list|()
decl_stmt|;
try|try
block|{
comment|// Found UDF in metastore - now add it to the function registry
comment|// At this point we should add any relevant jars that would be needed for the UDf.
name|FunctionResource
index|[]
name|resources
init|=
name|function
operator|.
name|getResources
argument_list|()
decl_stmt|;
try|try
block|{
name|FunctionTask
operator|.
name|addFunctionResources
argument_list|(
name|resources
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Unable to load resources for "
operator|+
name|qualifiedName
operator|+
literal|":"
operator|+
name|e
argument_list|,
name|e
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
name|ClassLoader
name|loader
init|=
name|Utilities
operator|.
name|getSessionSpecifiedClassLoader
argument_list|()
decl_stmt|;
name|Class
argument_list|<
name|?
argument_list|>
name|udfClass
init|=
name|Class
operator|.
name|forName
argument_list|(
name|function
operator|.
name|getClassName
argument_list|()
argument_list|,
literal|true
argument_list|,
name|loader
argument_list|)
decl_stmt|;
name|ret
operator|=
name|FunctionRegistry
operator|.
name|registerTemporaryUDF
argument_list|(
name|qualifiedName
argument_list|,
name|udfClass
argument_list|,
name|resources
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
literal|null
condition|)
block|{
name|LOG
operator|.
name|error
argument_list|(
name|function
operator|.
name|getClassName
argument_list|()
operator|+
literal|" is not a valid UDF class and was not registered."
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|SessionState
operator|.
name|get
argument_list|()
operator|.
name|isHiveServerQuery
argument_list|()
condition|)
block|{
name|SessionState
operator|.
name|getRegistryForWrite
argument_list|()
operator|.
name|addToUDFLoaders
argument_list|(
name|loader
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|ClassNotFoundException
name|e
parameter_list|)
block|{
comment|// Lookup of UDf class failed
name|LOG
operator|.
name|error
argument_list|(
literal|"Unable to load UDF class: "
operator|+
name|e
argument_list|)
expr_stmt|;
name|Utilities
operator|.
name|restoreSessionSpecifiedClassLoader
argument_list|(
name|prev
argument_list|)
expr_stmt|;
block|}
name|function
operator|.
name|shareStateWith
argument_list|(
name|ret
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
specifier|private
name|void
name|checkFunctionClass
parameter_list|(
name|FunctionInfo
name|cfi
parameter_list|)
throws|throws
name|ClassNotFoundException
block|{
comment|// This call will fail for non-generic UDFs using GenericUDFBridge
name|Class
argument_list|<
name|?
argument_list|>
name|udfClass
init|=
name|cfi
operator|.
name|getFunctionClass
argument_list|()
decl_stmt|;
comment|// Even if we have a reference to the class (which will be the case for GenericUDFs),
comment|// the classloader may not be able to resolve the class, which would mean reflection-based
comment|// methods would fail such as for plan deserialization. Make sure this works too.
name|Class
operator|.
name|forName
argument_list|(
name|udfClass
operator|.
name|getName
argument_list|()
argument_list|,
literal|true
argument_list|,
name|Utilities
operator|.
name|getSessionSpecifiedClassLoader
argument_list|()
argument_list|)
expr_stmt|;
block|}
specifier|public
specifier|synchronized
name|void
name|clear
parameter_list|()
block|{
if|if
condition|(
name|isNative
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"System function registry cannot be cleared"
argument_list|)
throw|;
block|}
name|mFunctions
operator|.
name|clear
argument_list|()
expr_stmt|;
name|builtIns
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
specifier|public
specifier|synchronized
name|void
name|closeCUDFLoaders
parameter_list|()
block|{
try|try
block|{
for|for
control|(
name|ClassLoader
name|loader
range|:
name|mSessionUDFLoaders
control|)
block|{
name|JavaUtils
operator|.
name|closeClassLoader
argument_list|(
name|loader
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|ie
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Error in close loader: "
operator|+
name|ie
argument_list|)
expr_stmt|;
block|}
name|mSessionUDFLoaders
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
specifier|public
specifier|synchronized
name|void
name|addToUDFLoaders
parameter_list|(
name|ClassLoader
name|loader
parameter_list|)
block|{
name|mSessionUDFLoaders
operator|.
name|add
argument_list|(
name|loader
argument_list|)
expr_stmt|;
block|}
specifier|public
specifier|synchronized
name|void
name|removeFromUDFLoaders
parameter_list|(
name|ClassLoader
name|loader
parameter_list|)
block|{
name|mSessionUDFLoaders
operator|.
name|remove
argument_list|(
name|loader
argument_list|)
expr_stmt|;
block|}
comment|/**    * Setup blocked flag for all builtin UDFs as per udf whitelist and blacklist    * @param whiteListStr    * @param blackListStr    */
specifier|public
name|void
name|setupPermissionsForUDFs
parameter_list|(
name|String
name|whiteListStr
parameter_list|,
name|String
name|blackListStr
parameter_list|)
block|{
name|Set
argument_list|<
name|String
argument_list|>
name|whiteList
init|=
name|Sets
operator|.
name|newHashSet
argument_list|(
name|Splitter
operator|.
name|on
argument_list|(
literal|","
argument_list|)
operator|.
name|trimResults
argument_list|()
operator|.
name|omitEmptyStrings
argument_list|()
operator|.
name|split
argument_list|(
name|whiteListStr
operator|.
name|toLowerCase
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
name|Set
argument_list|<
name|String
argument_list|>
name|blackList
init|=
name|Sets
operator|.
name|newHashSet
argument_list|(
name|Splitter
operator|.
name|on
argument_list|(
literal|","
argument_list|)
operator|.
name|trimResults
argument_list|()
operator|.
name|omitEmptyStrings
argument_list|()
operator|.
name|split
argument_list|(
name|blackListStr
operator|.
name|toLowerCase
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
name|blackList
operator|.
name|removeAll
argument_list|(
name|FunctionRegistry
operator|.
name|HIVE_OPERATORS
argument_list|)
expr_stmt|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|FunctionInfo
argument_list|>
name|funcEntry
range|:
name|mFunctions
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|funcEntry
operator|.
name|getValue
argument_list|()
operator|.
name|setBlockedFunction
argument_list|(
name|isUdfBlocked
argument_list|(
name|funcEntry
operator|.
name|getKey
argument_list|()
argument_list|,
name|whiteList
argument_list|,
name|blackList
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Check if the function belongs to whitelist or blacklist    * @param functionName    * @param whiteList    * @param blackList    * @return true if the given udf is to be blocked    */
name|boolean
name|isUdfBlocked
parameter_list|(
name|String
name|functionName
parameter_list|,
name|Set
argument_list|<
name|String
argument_list|>
name|whiteList
parameter_list|,
name|Set
argument_list|<
name|String
argument_list|>
name|blackList
parameter_list|)
block|{
name|functionName
operator|=
name|functionName
operator|.
name|toLowerCase
argument_list|()
expr_stmt|;
return|return
name|blackList
operator|.
name|contains
argument_list|(
name|functionName
argument_list|)
operator|||
operator|(
operator|!
name|whiteList
operator|.
name|isEmpty
argument_list|()
operator|&&
operator|!
name|whiteList
operator|.
name|contains
argument_list|(
name|functionName
argument_list|)
operator|)
return|;
block|}
block|}
end_class

end_unit

