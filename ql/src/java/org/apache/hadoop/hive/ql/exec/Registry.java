begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
package|;
end_package

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Splitter
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Sets
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hive
operator|.
name|common
operator|.
name|util
operator|.
name|AnnotationUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|common
operator|.
name|JavaUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|conf
operator|.
name|HiveConf
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|conf
operator|.
name|HiveConf
operator|.
name|ConfVars
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|metastore
operator|.
name|api
operator|.
name|Function
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|FunctionInfo
operator|.
name|FunctionResource
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|FunctionInfo
operator|.
name|FunctionType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|ErrorMsg
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|metadata
operator|.
name|Hive
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|metadata
operator|.
name|HiveException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|parse
operator|.
name|SemanticException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|ExprNodeDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|session
operator|.
name|SessionState
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|udf
operator|.
name|generic
operator|.
name|GenericUDAFBridge
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|udf
operator|.
name|generic
operator|.
name|GenericUDAFEvaluator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|udf
operator|.
name|generic
operator|.
name|GenericUDAFParameterInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|udf
operator|.
name|generic
operator|.
name|GenericUDAFResolver
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|udf
operator|.
name|generic
operator|.
name|GenericUDAFResolver2
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|udf
operator|.
name|generic
operator|.
name|GenericUDF
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|udf
operator|.
name|generic
operator|.
name|GenericUDFBridge
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|udf
operator|.
name|generic
operator|.
name|GenericUDFMacro
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|udf
operator|.
name|generic
operator|.
name|GenericUDTF
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|udf
operator|.
name|generic
operator|.
name|SimpleGenericUDAFParameterInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|udf
operator|.
name|ptf
operator|.
name|TableFunctionResolver
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|objectinspector
operator|.
name|ObjectInspector
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|typeinfo
operator|.
name|TypeInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hive
operator|.
name|common
operator|.
name|util
operator|.
name|ReflectionUtil
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|LinkedHashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|LinkedHashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|TreeSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ConcurrentHashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|locks
operator|.
name|ReentrantLock
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|regex
operator|.
name|Pattern
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|regex
operator|.
name|PatternSyntaxException
import|;
end_import

begin_comment
comment|// Extracted from FunctionRegistry
end_comment

begin_class
specifier|public
class|class
name|Registry
block|{
specifier|private
specifier|static
specifier|final
name|Logger
name|LOG
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|FunctionRegistry
operator|.
name|class
argument_list|)
decl_stmt|;
comment|// prefix for window functions, to discern LEAD/LAG UDFs from window functions with the same name
specifier|private
specifier|static
specifier|final
name|String
name|WINDOW_FUNC_PREFIX
init|=
literal|"@_"
decl_stmt|;
comment|/**    * The mapping from expression function names to expression classes.    */
specifier|private
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|FunctionInfo
argument_list|>
name|mFunctions
init|=
operator|new
name|LinkedHashMap
argument_list|<
name|String
argument_list|,
name|FunctionInfo
argument_list|>
argument_list|()
decl_stmt|;
specifier|private
specifier|final
name|Set
argument_list|<
name|Class
argument_list|<
name|?
argument_list|>
argument_list|>
name|builtIns
init|=
name|Collections
operator|.
name|synchronizedSet
argument_list|(
operator|new
name|HashSet
argument_list|<
name|Class
argument_list|<
name|?
argument_list|>
argument_list|>
argument_list|()
argument_list|)
decl_stmt|;
comment|/**    * Persistent map contains refcounts that are only modified in synchronized methods for now,    * so there's no separate effort to make refcount operations thread-safe.    */
specifier|private
specifier|final
name|Map
argument_list|<
name|Class
argument_list|<
name|?
argument_list|>
argument_list|,
name|Integer
argument_list|>
name|persistent
init|=
operator|new
name|ConcurrentHashMap
argument_list|<>
argument_list|()
decl_stmt|;
specifier|private
specifier|final
name|Set
argument_list|<
name|ClassLoader
argument_list|>
name|mSessionUDFLoaders
init|=
operator|new
name|LinkedHashSet
argument_list|<
name|ClassLoader
argument_list|>
argument_list|()
decl_stmt|;
specifier|private
specifier|final
name|boolean
name|isNative
decl_stmt|;
comment|/**    * The epic lock for the registry. This was added to replace the synchronized methods with    * minimum disruption; the locking should really be made more granular here.    */
specifier|private
specifier|final
name|ReentrantLock
name|lock
init|=
operator|new
name|ReentrantLock
argument_list|()
decl_stmt|;
specifier|public
name|Registry
parameter_list|(
name|boolean
name|isNative
parameter_list|)
block|{
name|this
operator|.
name|isNative
operator|=
name|isNative
expr_stmt|;
block|}
comment|/**    * Registers the appropriate kind of temporary function based on a class's    * type.    *    * @param functionName name under which to register function    * @param udfClass     class implementing UD[A|T]F    * @return true if udfClass's type was recognized (so registration    *         succeeded); false otherwise    */
specifier|public
name|FunctionInfo
name|registerFunction
parameter_list|(
name|String
name|functionName
parameter_list|,
name|Class
argument_list|<
name|?
argument_list|>
name|udfClass
parameter_list|,
name|FunctionResource
modifier|...
name|resources
parameter_list|)
block|{
name|FunctionType
name|functionType
init|=
name|isNative
condition|?
name|FunctionType
operator|.
name|BUILTIN
else|:
name|FunctionType
operator|.
name|TEMPORARY
decl_stmt|;
return|return
name|registerFunction
argument_list|(
name|functionName
argument_list|,
name|functionType
argument_list|,
name|udfClass
argument_list|,
name|resources
argument_list|)
return|;
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
specifier|private
name|FunctionInfo
name|registerFunction
parameter_list|(
name|String
name|functionName
parameter_list|,
name|FunctionType
name|functionType
parameter_list|,
name|Class
argument_list|<
name|?
argument_list|>
name|udfClass
parameter_list|,
name|FunctionResource
modifier|...
name|resources
parameter_list|)
block|{
name|FunctionUtils
operator|.
name|UDFClassType
name|udfClassType
init|=
name|FunctionUtils
operator|.
name|getUDFClassType
argument_list|(
name|udfClass
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|udfClassType
condition|)
block|{
case|case
name|UDF
case|:
return|return
name|registerUDF
argument_list|(
name|functionName
argument_list|,
name|functionType
argument_list|,
operator|(
name|Class
argument_list|<
name|?
extends|extends
name|UDF
argument_list|>
operator|)
name|udfClass
argument_list|,
literal|false
argument_list|,
name|functionName
operator|.
name|toLowerCase
argument_list|()
argument_list|,
name|resources
argument_list|)
return|;
case|case
name|GENERIC_UDF
case|:
return|return
name|registerGenericUDF
argument_list|(
name|functionName
argument_list|,
name|functionType
argument_list|,
operator|(
name|Class
argument_list|<
name|?
extends|extends
name|GenericUDF
argument_list|>
operator|)
name|udfClass
argument_list|,
name|resources
argument_list|)
return|;
case|case
name|GENERIC_UDTF
case|:
return|return
name|registerGenericUDTF
argument_list|(
name|functionName
argument_list|,
name|functionType
argument_list|,
operator|(
name|Class
argument_list|<
name|?
extends|extends
name|GenericUDTF
argument_list|>
operator|)
name|udfClass
argument_list|,
name|resources
argument_list|)
return|;
case|case
name|UDAF
case|:
return|return
name|registerUDAF
argument_list|(
name|functionName
argument_list|,
name|functionType
argument_list|,
operator|(
name|Class
argument_list|<
name|?
extends|extends
name|UDAF
argument_list|>
operator|)
name|udfClass
argument_list|,
name|resources
argument_list|)
return|;
case|case
name|GENERIC_UDAF_RESOLVER
case|:
return|return
name|registerGenericUDAF
argument_list|(
name|functionName
argument_list|,
name|functionType
argument_list|,
operator|(
name|GenericUDAFResolver
operator|)
name|ReflectionUtil
operator|.
name|newInstance
argument_list|(
name|udfClass
argument_list|,
literal|null
argument_list|)
argument_list|,
name|resources
argument_list|)
return|;
case|case
name|TABLE_FUNCTION_RESOLVER
case|:
comment|// native or not would be decided by annotation. need to evaluate that first
return|return
name|registerTableFunction
argument_list|(
name|functionName
argument_list|,
name|functionType
argument_list|,
operator|(
name|Class
argument_list|<
name|?
extends|extends
name|TableFunctionResolver
argument_list|>
operator|)
name|udfClass
argument_list|,
name|resources
argument_list|)
return|;
block|}
return|return
literal|null
return|;
block|}
specifier|public
name|FunctionInfo
name|registerUDF
parameter_list|(
name|String
name|functionName
parameter_list|,
name|Class
argument_list|<
name|?
extends|extends
name|UDF
argument_list|>
name|UDFClass
parameter_list|,
name|boolean
name|isOperator
parameter_list|,
name|FunctionResource
modifier|...
name|resources
parameter_list|)
block|{
return|return
name|registerUDF
argument_list|(
name|functionName
argument_list|,
name|UDFClass
argument_list|,
name|isOperator
argument_list|,
name|functionName
operator|.
name|toLowerCase
argument_list|()
argument_list|,
name|resources
argument_list|)
return|;
block|}
specifier|public
name|FunctionInfo
name|registerUDF
parameter_list|(
name|String
name|functionName
parameter_list|,
name|Class
argument_list|<
name|?
extends|extends
name|UDF
argument_list|>
name|UDFClass
parameter_list|,
name|boolean
name|isOperator
parameter_list|,
name|String
name|displayName
parameter_list|,
name|FunctionResource
modifier|...
name|resources
parameter_list|)
block|{
name|FunctionType
name|functionType
init|=
name|isNative
condition|?
name|FunctionType
operator|.
name|BUILTIN
else|:
name|FunctionType
operator|.
name|TEMPORARY
decl_stmt|;
return|return
name|registerUDF
argument_list|(
name|functionName
argument_list|,
name|functionType
argument_list|,
name|UDFClass
argument_list|,
name|isOperator
argument_list|,
name|displayName
argument_list|)
return|;
block|}
specifier|private
name|FunctionInfo
name|registerUDF
parameter_list|(
name|String
name|functionName
parameter_list|,
name|FunctionType
name|functionType
parameter_list|,
name|Class
argument_list|<
name|?
extends|extends
name|UDF
argument_list|>
name|UDFClass
parameter_list|,
name|boolean
name|isOperator
parameter_list|,
name|String
name|displayName
parameter_list|,
name|FunctionResource
modifier|...
name|resources
parameter_list|)
block|{
name|validateClass
argument_list|(
name|UDFClass
argument_list|,
name|UDF
operator|.
name|class
argument_list|)
expr_stmt|;
name|validateDescription
argument_list|(
name|UDFClass
argument_list|)
expr_stmt|;
name|FunctionInfo
name|fI
init|=
operator|new
name|FunctionInfo
argument_list|(
name|functionType
argument_list|,
name|displayName
argument_list|,
operator|new
name|GenericUDFBridge
argument_list|(
name|displayName
argument_list|,
name|isOperator
argument_list|,
name|UDFClass
operator|.
name|getName
argument_list|()
argument_list|)
argument_list|,
name|resources
argument_list|)
decl_stmt|;
name|addFunction
argument_list|(
name|functionName
argument_list|,
name|fI
argument_list|)
expr_stmt|;
return|return
name|fI
return|;
block|}
specifier|private
name|void
name|validateDescription
parameter_list|(
name|Class
argument_list|<
name|?
argument_list|>
name|input
parameter_list|)
block|{
name|Description
name|description
init|=
name|AnnotationUtils
operator|.
name|getAnnotation
argument_list|(
name|input
argument_list|,
name|Description
operator|.
name|class
argument_list|)
decl_stmt|;
if|if
condition|(
name|description
operator|==
literal|null
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"UDF Class {}"
operator|+
literal|" does not have description. Please annotate the class with the "
operator|+
literal|"org.apache.hadoop.hive.ql.exec.Description annotation and provide the description of the function."
argument_list|,
name|input
operator|.
name|getCanonicalName
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
specifier|public
name|FunctionInfo
name|registerGenericUDF
parameter_list|(
name|String
name|functionName
parameter_list|,
name|Class
argument_list|<
name|?
extends|extends
name|GenericUDF
argument_list|>
name|genericUDFClass
parameter_list|,
name|FunctionResource
modifier|...
name|resources
parameter_list|)
block|{
name|FunctionType
name|functionType
init|=
name|isNative
condition|?
name|FunctionType
operator|.
name|BUILTIN
else|:
name|FunctionType
operator|.
name|TEMPORARY
decl_stmt|;
return|return
name|registerGenericUDF
argument_list|(
name|functionName
argument_list|,
name|functionType
argument_list|,
name|genericUDFClass
argument_list|,
name|resources
argument_list|)
return|;
block|}
specifier|private
name|FunctionInfo
name|registerGenericUDF
parameter_list|(
name|String
name|functionName
parameter_list|,
name|FunctionType
name|functionType
parameter_list|,
name|Class
argument_list|<
name|?
extends|extends
name|GenericUDF
argument_list|>
name|genericUDFClass
parameter_list|,
name|FunctionResource
modifier|...
name|resources
parameter_list|)
block|{
name|validateClass
argument_list|(
name|genericUDFClass
argument_list|,
name|GenericUDF
operator|.
name|class
argument_list|)
expr_stmt|;
name|validateDescription
argument_list|(
name|genericUDFClass
argument_list|)
expr_stmt|;
name|FunctionInfo
name|fI
init|=
operator|new
name|FunctionInfo
argument_list|(
name|functionType
argument_list|,
name|functionName
argument_list|,
name|ReflectionUtil
operator|.
name|newInstance
argument_list|(
name|genericUDFClass
argument_list|,
literal|null
argument_list|)
argument_list|,
name|resources
argument_list|)
decl_stmt|;
name|addFunction
argument_list|(
name|functionName
argument_list|,
name|fI
argument_list|)
expr_stmt|;
return|return
name|fI
return|;
block|}
comment|/**    * Registers the UDF class as a built-in function; used for dynamically created UDFs, like    * GenericUDFOP*Minus/Plus.    */
specifier|public
name|void
name|registerHiddenBuiltIn
parameter_list|(
name|Class
argument_list|<
name|?
extends|extends
name|GenericUDF
argument_list|>
name|functionClass
parameter_list|)
block|{
name|lock
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
if|if
condition|(
operator|!
name|isNative
condition|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Builtin is not for this registry"
argument_list|)
throw|;
block|}
name|builtIns
operator|.
name|add
argument_list|(
name|functionClass
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|lock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
specifier|public
name|FunctionInfo
name|registerGenericUDTF
parameter_list|(
name|String
name|functionName
parameter_list|,
name|Class
argument_list|<
name|?
extends|extends
name|GenericUDTF
argument_list|>
name|genericUDTFClass
parameter_list|,
name|FunctionResource
modifier|...
name|resources
parameter_list|)
block|{
name|FunctionType
name|functionType
init|=
name|isNative
condition|?
name|FunctionType
operator|.
name|BUILTIN
else|:
name|FunctionType
operator|.
name|TEMPORARY
decl_stmt|;
return|return
name|registerGenericUDTF
argument_list|(
name|functionName
argument_list|,
name|functionType
argument_list|,
name|genericUDTFClass
argument_list|,
name|resources
argument_list|)
return|;
block|}
specifier|private
name|FunctionInfo
name|registerGenericUDTF
parameter_list|(
name|String
name|functionName
parameter_list|,
name|FunctionType
name|functionType
parameter_list|,
name|Class
argument_list|<
name|?
extends|extends
name|GenericUDTF
argument_list|>
name|genericUDTFClass
parameter_list|,
name|FunctionResource
modifier|...
name|resources
parameter_list|)
block|{
name|validateClass
argument_list|(
name|genericUDTFClass
argument_list|,
name|GenericUDTF
operator|.
name|class
argument_list|)
expr_stmt|;
name|validateDescription
argument_list|(
name|genericUDTFClass
argument_list|)
expr_stmt|;
name|FunctionInfo
name|fI
init|=
operator|new
name|FunctionInfo
argument_list|(
name|functionType
argument_list|,
name|functionName
argument_list|,
name|ReflectionUtil
operator|.
name|newInstance
argument_list|(
name|genericUDTFClass
argument_list|,
literal|null
argument_list|)
argument_list|,
name|resources
argument_list|)
decl_stmt|;
name|addFunction
argument_list|(
name|functionName
argument_list|,
name|fI
argument_list|)
expr_stmt|;
return|return
name|fI
return|;
block|}
specifier|public
name|FunctionInfo
name|registerGenericUDAF
parameter_list|(
name|String
name|functionName
parameter_list|,
name|GenericUDAFResolver
name|genericUDAFResolver
parameter_list|,
name|FunctionResource
modifier|...
name|resources
parameter_list|)
block|{
name|FunctionType
name|functionType
init|=
name|isNative
condition|?
name|FunctionType
operator|.
name|BUILTIN
else|:
name|FunctionType
operator|.
name|TEMPORARY
decl_stmt|;
return|return
name|registerGenericUDAF
argument_list|(
name|functionName
argument_list|,
name|functionType
argument_list|,
name|genericUDAFResolver
argument_list|,
name|resources
argument_list|)
return|;
block|}
specifier|private
name|FunctionInfo
name|registerGenericUDAF
parameter_list|(
name|String
name|functionName
parameter_list|,
name|FunctionType
name|functionType
parameter_list|,
name|GenericUDAFResolver
name|genericUDAFResolver
parameter_list|,
name|FunctionResource
modifier|...
name|resources
parameter_list|)
block|{
name|validateDescription
argument_list|(
name|genericUDAFResolver
operator|.
name|getClass
argument_list|()
argument_list|)
expr_stmt|;
name|FunctionInfo
name|function
init|=
operator|new
name|WindowFunctionInfo
argument_list|(
name|functionType
argument_list|,
name|functionName
argument_list|,
name|genericUDAFResolver
argument_list|,
name|resources
argument_list|)
decl_stmt|;
name|addFunction
argument_list|(
name|functionName
argument_list|,
name|function
argument_list|)
expr_stmt|;
name|addFunction
argument_list|(
name|WINDOW_FUNC_PREFIX
operator|+
name|functionName
argument_list|,
name|function
argument_list|)
expr_stmt|;
return|return
name|function
return|;
block|}
specifier|public
name|FunctionInfo
name|registerUDAF
parameter_list|(
name|String
name|functionName
parameter_list|,
name|Class
argument_list|<
name|?
extends|extends
name|UDAF
argument_list|>
name|udafClass
parameter_list|,
name|FunctionResource
modifier|...
name|resources
parameter_list|)
block|{
name|FunctionType
name|functionType
init|=
name|isNative
condition|?
name|FunctionType
operator|.
name|BUILTIN
else|:
name|FunctionType
operator|.
name|TEMPORARY
decl_stmt|;
return|return
name|registerUDAF
argument_list|(
name|functionName
argument_list|,
name|functionType
argument_list|,
name|udafClass
argument_list|,
name|resources
argument_list|)
return|;
block|}
specifier|private
name|FunctionInfo
name|registerUDAF
parameter_list|(
name|String
name|functionName
parameter_list|,
name|FunctionType
name|functionType
parameter_list|,
name|Class
argument_list|<
name|?
extends|extends
name|UDAF
argument_list|>
name|udafClass
parameter_list|,
name|FunctionResource
modifier|...
name|resources
parameter_list|)
block|{
name|validateClass
argument_list|(
name|udafClass
argument_list|,
name|UDAF
operator|.
name|class
argument_list|)
expr_stmt|;
name|FunctionInfo
name|function
init|=
operator|new
name|WindowFunctionInfo
argument_list|(
name|functionType
argument_list|,
name|functionName
argument_list|,
operator|new
name|GenericUDAFBridge
argument_list|(
name|ReflectionUtil
operator|.
name|newInstance
argument_list|(
name|udafClass
argument_list|,
literal|null
argument_list|)
argument_list|)
argument_list|,
name|resources
argument_list|)
decl_stmt|;
name|addFunction
argument_list|(
name|functionName
argument_list|,
name|function
argument_list|)
expr_stmt|;
name|addFunction
argument_list|(
name|WINDOW_FUNC_PREFIX
operator|+
name|functionName
argument_list|,
name|function
argument_list|)
expr_stmt|;
return|return
name|function
return|;
block|}
specifier|public
name|FunctionInfo
name|registerTableFunction
parameter_list|(
name|String
name|functionName
parameter_list|,
name|Class
argument_list|<
name|?
extends|extends
name|TableFunctionResolver
argument_list|>
name|tFnCls
parameter_list|,
name|FunctionResource
modifier|...
name|resources
parameter_list|)
block|{
name|FunctionType
name|functionType
init|=
name|isNative
condition|?
name|FunctionType
operator|.
name|BUILTIN
else|:
name|FunctionType
operator|.
name|TEMPORARY
decl_stmt|;
return|return
name|registerTableFunction
argument_list|(
name|functionName
argument_list|,
name|functionType
argument_list|,
name|tFnCls
argument_list|,
name|resources
argument_list|)
return|;
block|}
specifier|private
name|FunctionInfo
name|registerTableFunction
parameter_list|(
name|String
name|functionName
parameter_list|,
name|FunctionType
name|functionType
parameter_list|,
name|Class
argument_list|<
name|?
extends|extends
name|TableFunctionResolver
argument_list|>
name|tFnCls
parameter_list|,
name|FunctionResource
modifier|...
name|resources
parameter_list|)
block|{
name|validateClass
argument_list|(
name|tFnCls
argument_list|,
name|TableFunctionResolver
operator|.
name|class
argument_list|)
expr_stmt|;
name|FunctionInfo
name|function
init|=
operator|new
name|FunctionInfo
argument_list|(
name|functionType
argument_list|,
name|functionName
argument_list|,
name|tFnCls
argument_list|,
name|resources
argument_list|)
decl_stmt|;
name|addFunction
argument_list|(
name|functionName
argument_list|,
name|function
argument_list|)
expr_stmt|;
return|return
name|function
return|;
block|}
specifier|public
name|FunctionInfo
name|registerMacro
parameter_list|(
name|String
name|macroName
parameter_list|,
name|ExprNodeDesc
name|body
parameter_list|,
name|List
argument_list|<
name|String
argument_list|>
name|colNames
parameter_list|,
name|List
argument_list|<
name|TypeInfo
argument_list|>
name|colTypes
parameter_list|)
block|{
return|return
name|registerMacro
argument_list|(
name|macroName
argument_list|,
name|body
argument_list|,
name|colNames
argument_list|,
name|colTypes
argument_list|,
literal|null
argument_list|)
return|;
block|}
specifier|public
name|FunctionInfo
name|registerMacro
parameter_list|(
name|String
name|macroName
parameter_list|,
name|ExprNodeDesc
name|body
parameter_list|,
name|List
argument_list|<
name|String
argument_list|>
name|colNames
parameter_list|,
name|List
argument_list|<
name|TypeInfo
argument_list|>
name|colTypes
parameter_list|,
name|FunctionResource
modifier|...
name|resources
parameter_list|)
block|{
name|GenericUDFMacro
name|macro
init|=
operator|new
name|GenericUDFMacro
argument_list|(
name|macroName
argument_list|,
name|body
argument_list|,
name|colNames
argument_list|,
name|colTypes
argument_list|)
decl_stmt|;
name|FunctionInfo
name|fI
init|=
operator|new
name|FunctionInfo
argument_list|(
name|FunctionType
operator|.
name|TEMPORARY
argument_list|,
name|macroName
argument_list|,
name|macro
argument_list|,
name|resources
argument_list|)
decl_stmt|;
name|addFunction
argument_list|(
name|macroName
argument_list|,
name|fI
argument_list|)
expr_stmt|;
return|return
name|fI
return|;
block|}
specifier|public
name|FunctionInfo
name|registerPermanentFunction
parameter_list|(
name|String
name|functionName
parameter_list|,
name|String
name|className
parameter_list|,
name|boolean
name|registerToSession
parameter_list|,
name|FunctionResource
modifier|...
name|resources
parameter_list|)
throws|throws
name|SemanticException
block|{
name|FunctionInfo
name|function
init|=
operator|new
name|FunctionInfo
argument_list|(
name|functionName
argument_list|,
name|className
argument_list|,
name|resources
argument_list|)
decl_stmt|;
comment|// register to session first for backward compatibility
if|if
condition|(
name|registerToSession
condition|)
block|{
name|String
name|qualifiedName
init|=
name|FunctionUtils
operator|.
name|qualifyFunctionName
argument_list|(
name|functionName
argument_list|,
name|SessionState
operator|.
name|get
argument_list|()
operator|.
name|getCurrentDatabase
argument_list|()
operator|.
name|toLowerCase
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|registerToSessionRegistry
argument_list|(
name|qualifiedName
argument_list|,
name|function
argument_list|)
operator|!=
literal|null
condition|)
block|{
name|addFunction
argument_list|(
name|functionName
argument_list|,
name|function
argument_list|)
expr_stmt|;
return|return
name|function
return|;
block|}
block|}
else|else
block|{
name|addFunction
argument_list|(
name|functionName
argument_list|,
name|function
argument_list|)
expr_stmt|;
block|}
return|return
literal|null
return|;
block|}
comment|/**    * Typically a WindowFunction is the same as a UDAF. The only exceptions are Lead& Lag UDAFs. These    * are not registered as regular UDAFs because    * - we plan to support Lead& Lag as UDFs (usable only within argument expressions    *   of UDAFs when windowing is involved). Since mFunctions holds both UDFs and UDAFs we cannot    *   add both FunctionInfos to mFunctions.    *    * @param name    * @param wFn    */
name|void
name|registerWindowFunction
parameter_list|(
name|String
name|name
parameter_list|,
name|GenericUDAFResolver
name|wFn
parameter_list|)
block|{
name|FunctionType
name|functionType
init|=
name|isNative
condition|?
name|FunctionType
operator|.
name|BUILTIN
else|:
name|FunctionType
operator|.
name|TEMPORARY
decl_stmt|;
name|addFunction
argument_list|(
name|WINDOW_FUNC_PREFIX
operator|+
name|name
argument_list|,
operator|new
name|WindowFunctionInfo
argument_list|(
name|functionType
argument_list|,
name|name
argument_list|,
name|wFn
argument_list|,
literal|null
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|validateClass
parameter_list|(
name|Class
name|input
parameter_list|,
name|Class
name|expected
parameter_list|)
block|{
if|if
condition|(
operator|!
name|expected
operator|.
name|isAssignableFrom
argument_list|(
name|input
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Registering UDF Class "
operator|+
name|input
operator|+
literal|" which does not extend "
operator|+
name|expected
argument_list|)
throw|;
block|}
block|}
comment|/**    * Looks up the function name in the registry. If enabled, will attempt to search the metastore    * for the function.    * @param functionName    * @return    */
specifier|public
name|FunctionInfo
name|getFunctionInfo
parameter_list|(
name|String
name|functionName
parameter_list|)
throws|throws
name|SemanticException
block|{
name|lock
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
name|functionName
operator|=
name|functionName
operator|.
name|toLowerCase
argument_list|()
expr_stmt|;
if|if
condition|(
name|FunctionUtils
operator|.
name|isQualifiedFunctionName
argument_list|(
name|functionName
argument_list|)
condition|)
block|{
name|FunctionInfo
name|functionInfo
init|=
name|getQualifiedFunctionInfoUnderLock
argument_list|(
name|functionName
argument_list|)
decl_stmt|;
name|addToCurrentFunctions
argument_list|(
name|functionName
argument_list|,
name|functionInfo
argument_list|)
expr_stmt|;
return|return
name|functionInfo
return|;
block|}
comment|// First try without qualifiers - would resolve builtin/temp functions.
comment|// Otherwise try qualifying with current db name.
name|FunctionInfo
name|functionInfo
init|=
name|mFunctions
operator|.
name|get
argument_list|(
name|functionName
argument_list|)
decl_stmt|;
if|if
condition|(
name|functionInfo
operator|!=
literal|null
operator|&&
name|functionInfo
operator|.
name|isBlockedFunction
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
literal|"UDF "
operator|+
name|functionName
operator|+
literal|" is not allowed"
argument_list|)
throw|;
block|}
if|if
condition|(
name|functionInfo
operator|==
literal|null
condition|)
block|{
name|functionName
operator|=
name|FunctionUtils
operator|.
name|qualifyFunctionName
argument_list|(
name|functionName
argument_list|,
name|SessionState
operator|.
name|get
argument_list|()
operator|.
name|getCurrentDatabase
argument_list|()
operator|.
name|toLowerCase
argument_list|()
argument_list|)
expr_stmt|;
name|functionInfo
operator|=
name|getQualifiedFunctionInfoUnderLock
argument_list|(
name|functionName
argument_list|)
expr_stmt|;
block|}
name|addToCurrentFunctions
argument_list|(
name|functionName
argument_list|,
name|functionInfo
argument_list|)
expr_stmt|;
return|return
name|functionInfo
return|;
block|}
finally|finally
block|{
name|lock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|addToCurrentFunctions
parameter_list|(
name|String
name|functionName
parameter_list|,
name|FunctionInfo
name|functionInfo
parameter_list|)
block|{
if|if
condition|(
name|SessionState
operator|.
name|get
argument_list|()
operator|!=
literal|null
operator|&&
name|functionInfo
operator|!=
literal|null
condition|)
block|{
name|SessionState
operator|.
name|get
argument_list|()
operator|.
name|getCurrentFunctionsInUse
argument_list|()
operator|.
name|put
argument_list|(
name|functionName
argument_list|,
name|functionInfo
argument_list|)
expr_stmt|;
block|}
block|}
specifier|public
name|WindowFunctionInfo
name|getWindowFunctionInfo
parameter_list|(
name|String
name|functionName
parameter_list|)
throws|throws
name|SemanticException
block|{
comment|// First try without qualifiers - would resolve builtin/temp functions
name|FunctionInfo
name|info
init|=
name|getFunctionInfo
argument_list|(
name|WINDOW_FUNC_PREFIX
operator|+
name|functionName
argument_list|)
decl_stmt|;
comment|// Try qualifying with current db name for permanent functions
if|if
condition|(
name|info
operator|==
literal|null
condition|)
block|{
name|String
name|qualifiedName
init|=
name|FunctionUtils
operator|.
name|qualifyFunctionName
argument_list|(
name|functionName
argument_list|,
name|SessionState
operator|.
name|get
argument_list|()
operator|.
name|getCurrentDatabase
argument_list|()
operator|.
name|toLowerCase
argument_list|()
argument_list|)
decl_stmt|;
name|info
operator|=
name|getFunctionInfo
argument_list|(
name|WINDOW_FUNC_PREFIX
operator|+
name|qualifiedName
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|info
operator|instanceof
name|WindowFunctionInfo
condition|)
block|{
return|return
operator|(
name|WindowFunctionInfo
operator|)
name|info
return|;
block|}
return|return
literal|null
return|;
block|}
comment|/**    * @param udfClass Function class.    * @return True iff the fnExpr represents a hive built-in function.    */
specifier|public
name|boolean
name|isBuiltInFunc
parameter_list|(
name|Class
argument_list|<
name|?
argument_list|>
name|udfClass
parameter_list|)
block|{
return|return
name|udfClass
operator|!=
literal|null
operator|&&
name|builtIns
operator|.
name|contains
argument_list|(
name|udfClass
argument_list|)
return|;
block|}
specifier|public
name|boolean
name|isPermanentFunc
parameter_list|(
name|Class
argument_list|<
name|?
argument_list|>
name|udfClass
parameter_list|)
block|{
comment|// Note that permanent functions can only be properly checked from the session registry.
comment|// If permanent functions are read from the metastore during Hive initialization,
comment|// the JARs are not loaded for the UDFs during that time and so Hive is unable to instantiate
comment|// the UDf classes to add to the persistent functions set.
comment|// Once a permanent UDF has been referenced in a session its FunctionInfo should be registered
comment|// in the session registry (and persistent set updated), so it can be looked up there.
return|return
name|udfClass
operator|!=
literal|null
operator|&&
name|persistent
operator|.
name|containsKey
argument_list|(
name|udfClass
argument_list|)
return|;
block|}
specifier|public
name|Set
argument_list|<
name|String
argument_list|>
name|getCurrentFunctionNames
parameter_list|()
block|{
name|lock
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
return|return
name|getFunctionNames
argument_list|(
operator|(
name|Pattern
operator|)
literal|null
argument_list|)
return|;
block|}
finally|finally
block|{
name|lock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
specifier|public
name|Set
argument_list|<
name|String
argument_list|>
name|getFunctionNames
parameter_list|(
name|String
name|funcPatternStr
parameter_list|)
block|{
name|lock
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
return|return
name|getFunctionNames
argument_list|(
name|Pattern
operator|.
name|compile
argument_list|(
name|funcPatternStr
argument_list|)
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|PatternSyntaxException
name|e
parameter_list|)
block|{
return|return
name|Collections
operator|.
name|emptySet
argument_list|()
return|;
block|}
finally|finally
block|{
name|lock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Returns a set of registered function names. This is used for the CLI    * command "SHOW FUNCTIONS 'regular expression';" Returns an empty set when    * the regular expression is not valid.    *    * @param funcPattern regular expression of the interested function names    * @return set of strings contains function names    */
specifier|public
name|Set
argument_list|<
name|String
argument_list|>
name|getFunctionNames
parameter_list|(
name|Pattern
name|funcPattern
parameter_list|)
block|{
name|lock
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
name|Set
argument_list|<
name|String
argument_list|>
name|funcNames
init|=
operator|new
name|TreeSet
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|String
name|funcName
range|:
name|mFunctions
operator|.
name|keySet
argument_list|()
control|)
block|{
if|if
condition|(
name|funcName
operator|.
name|contains
argument_list|(
name|WINDOW_FUNC_PREFIX
argument_list|)
condition|)
block|{
continue|continue;
block|}
if|if
condition|(
name|funcPattern
operator|==
literal|null
operator|||
name|funcPattern
operator|.
name|matcher
argument_list|(
name|funcName
argument_list|)
operator|.
name|matches
argument_list|()
condition|)
block|{
name|funcNames
operator|.
name|add
argument_list|(
name|funcName
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|funcNames
return|;
block|}
finally|finally
block|{
name|lock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Adds to the set of synonyms of the supplied function.    * @param funcName    * @param funcInfo    * @param synonyms    */
specifier|public
name|void
name|getFunctionSynonyms
parameter_list|(
name|String
name|funcName
parameter_list|,
name|FunctionInfo
name|funcInfo
parameter_list|,
name|Set
argument_list|<
name|String
argument_list|>
name|synonyms
parameter_list|)
throws|throws
name|SemanticException
block|{
name|lock
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
name|Class
argument_list|<
name|?
argument_list|>
name|funcClass
init|=
name|funcInfo
operator|.
name|getFunctionClass
argument_list|()
decl_stmt|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|FunctionInfo
argument_list|>
name|entry
range|:
name|mFunctions
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|String
name|name
init|=
name|entry
operator|.
name|getKey
argument_list|()
decl_stmt|;
if|if
condition|(
name|name
operator|.
name|contains
argument_list|(
name|WINDOW_FUNC_PREFIX
argument_list|)
operator|||
name|name
operator|.
name|equals
argument_list|(
name|funcName
argument_list|)
condition|)
block|{
continue|continue;
block|}
name|FunctionInfo
name|function
init|=
name|entry
operator|.
name|getValue
argument_list|()
decl_stmt|;
if|if
condition|(
name|function
operator|.
name|getFunctionClass
argument_list|()
operator|==
name|funcClass
condition|)
block|{
name|synonyms
operator|.
name|add
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
block|}
block|}
finally|finally
block|{
name|lock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Get the GenericUDAF evaluator for the name and argumentClasses.    *    * @param name         the name of the UDAF    * @param argumentOIs    * @param isDistinct    * @param isAllColumns    * @return The UDAF evaluator    */
annotation|@
name|SuppressWarnings
argument_list|(
literal|"deprecation"
argument_list|)
specifier|public
name|GenericUDAFEvaluator
name|getGenericUDAFEvaluator
parameter_list|(
name|String
name|name
parameter_list|,
name|List
argument_list|<
name|ObjectInspector
argument_list|>
name|argumentOIs
parameter_list|,
name|boolean
name|isWindowing
parameter_list|,
name|boolean
name|isDistinct
parameter_list|,
name|boolean
name|isAllColumns
parameter_list|)
throws|throws
name|SemanticException
block|{
name|GenericUDAFResolver
name|udafResolver
init|=
name|getGenericUDAFResolver
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|udafResolver
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
name|GenericUDAFEvaluator
name|udafEvaluator
decl_stmt|;
name|ObjectInspector
name|args
index|[]
init|=
operator|new
name|ObjectInspector
index|[
name|argumentOIs
operator|.
name|size
argument_list|()
index|]
decl_stmt|;
comment|// Can't use toArray here because Java is dumb when it comes to
comment|// generics + arrays.
for|for
control|(
name|int
name|ii
init|=
literal|0
init|;
name|ii
operator|<
name|argumentOIs
operator|.
name|size
argument_list|()
condition|;
operator|++
name|ii
control|)
block|{
name|args
index|[
name|ii
index|]
operator|=
name|argumentOIs
operator|.
name|get
argument_list|(
name|ii
argument_list|)
expr_stmt|;
block|}
name|GenericUDAFParameterInfo
name|paramInfo
init|=
operator|new
name|SimpleGenericUDAFParameterInfo
argument_list|(
name|args
argument_list|,
name|isWindowing
argument_list|,
name|isDistinct
argument_list|,
name|isAllColumns
argument_list|)
decl_stmt|;
if|if
condition|(
name|udafResolver
operator|instanceof
name|GenericUDAFResolver2
condition|)
block|{
name|udafEvaluator
operator|=
operator|(
operator|(
name|GenericUDAFResolver2
operator|)
name|udafResolver
operator|)
operator|.
name|getEvaluator
argument_list|(
name|paramInfo
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|udafEvaluator
operator|=
name|udafResolver
operator|.
name|getEvaluator
argument_list|(
name|paramInfo
operator|.
name|getParameters
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|udafEvaluator
return|;
block|}
specifier|public
name|GenericUDAFEvaluator
name|getGenericWindowingEvaluator
parameter_list|(
name|String
name|functionName
parameter_list|,
name|List
argument_list|<
name|ObjectInspector
argument_list|>
name|argumentOIs
parameter_list|,
name|boolean
name|isDistinct
parameter_list|,
name|boolean
name|isAllColumns
parameter_list|)
throws|throws
name|SemanticException
block|{
name|functionName
operator|=
name|functionName
operator|.
name|toLowerCase
argument_list|()
expr_stmt|;
name|WindowFunctionInfo
name|info
init|=
name|getWindowFunctionInfo
argument_list|(
name|functionName
argument_list|)
decl_stmt|;
if|if
condition|(
name|info
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
if|if
condition|(
operator|!
name|functionName
operator|.
name|equals
argument_list|(
name|FunctionRegistry
operator|.
name|LEAD_FUNC_NAME
argument_list|)
operator|&&
operator|!
name|functionName
operator|.
name|equals
argument_list|(
name|FunctionRegistry
operator|.
name|LAG_FUNC_NAME
argument_list|)
condition|)
block|{
return|return
name|getGenericUDAFEvaluator
argument_list|(
name|functionName
argument_list|,
name|argumentOIs
argument_list|,
literal|true
argument_list|,
name|isDistinct
argument_list|,
name|isAllColumns
argument_list|)
return|;
block|}
comment|// this must be lead/lag UDAF
name|ObjectInspector
name|args
index|[]
init|=
operator|new
name|ObjectInspector
index|[
name|argumentOIs
operator|.
name|size
argument_list|()
index|]
decl_stmt|;
name|GenericUDAFResolver
name|udafResolver
init|=
name|info
operator|.
name|getGenericUDAFResolver
argument_list|()
decl_stmt|;
name|GenericUDAFParameterInfo
name|paramInfo
init|=
operator|new
name|SimpleGenericUDAFParameterInfo
argument_list|(
name|argumentOIs
operator|.
name|toArray
argument_list|(
name|args
argument_list|)
argument_list|,
literal|true
argument_list|,
name|isDistinct
argument_list|,
name|isAllColumns
argument_list|)
decl_stmt|;
return|return
operator|(
operator|(
name|GenericUDAFResolver2
operator|)
name|udafResolver
operator|)
operator|.
name|getEvaluator
argument_list|(
name|paramInfo
argument_list|)
return|;
block|}
specifier|private
name|void
name|addFunction
parameter_list|(
name|String
name|functionName
parameter_list|,
name|FunctionInfo
name|function
parameter_list|)
block|{
name|lock
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
comment|// Built-in functions shouldn't go in the session registry,
comment|// and temp functions shouldn't go in the system registry.
comment|// Persistent functions can be in either registry.
if|if
condition|(
operator|(
operator|!
name|isNative
operator|&&
name|function
operator|.
name|isBuiltIn
argument_list|()
operator|)
operator|||
operator|(
name|isNative
operator|&&
operator|!
name|function
operator|.
name|isNative
argument_list|()
operator|)
condition|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Function "
operator|+
name|functionName
operator|+
literal|" is not for this registry"
argument_list|)
throw|;
block|}
name|functionName
operator|=
name|functionName
operator|.
name|toLowerCase
argument_list|()
expr_stmt|;
name|FunctionInfo
name|prev
init|=
name|mFunctions
operator|.
name|get
argument_list|(
name|functionName
argument_list|)
decl_stmt|;
if|if
condition|(
name|prev
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|isBuiltInFunc
argument_list|(
name|prev
operator|.
name|getFunctionClass
argument_list|()
argument_list|)
condition|)
block|{
name|String
name|message
init|=
name|String
operator|.
name|format
argument_list|(
literal|"Function (%s / %s) is hive builtin function, which cannot be overridden."
argument_list|,
name|functionName
argument_list|,
name|prev
operator|.
name|getFunctionClass
argument_list|()
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
name|message
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|RuntimeException
argument_list|(
name|message
argument_list|)
throw|;
block|}
name|prev
operator|.
name|discarded
argument_list|()
expr_stmt|;
block|}
name|mFunctions
operator|.
name|put
argument_list|(
name|functionName
argument_list|,
name|function
argument_list|)
expr_stmt|;
if|if
condition|(
name|function
operator|.
name|isBuiltIn
argument_list|()
condition|)
block|{
name|builtIns
operator|.
name|add
argument_list|(
name|function
operator|.
name|getFunctionClass
argument_list|()
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|function
operator|.
name|isPersistent
argument_list|()
operator|&&
operator|!
name|isNative
condition|)
block|{
comment|// System registry should not be used to check persistent functions - see isPermanentFunc()
name|Class
argument_list|<
name|?
argument_list|>
name|functionClass
init|=
name|getPermanentUdfClass
argument_list|(
name|function
argument_list|)
decl_stmt|;
name|Integer
name|refCount
init|=
name|persistent
operator|.
name|get
argument_list|(
name|functionClass
argument_list|)
decl_stmt|;
name|persistent
operator|.
name|put
argument_list|(
name|functionClass
argument_list|,
name|Integer
operator|.
name|valueOf
argument_list|(
name|refCount
operator|==
literal|null
condition|?
literal|1
else|:
name|refCount
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
finally|finally
block|{
name|lock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
specifier|private
name|Class
argument_list|<
name|?
argument_list|>
name|getPermanentUdfClass
parameter_list|(
name|FunctionInfo
name|function
parameter_list|)
block|{
name|Class
argument_list|<
name|?
argument_list|>
name|functionClass
init|=
name|function
operator|.
name|getFunctionClass
argument_list|()
decl_stmt|;
if|if
condition|(
name|functionClass
operator|==
literal|null
condition|)
block|{
comment|// Expected for permanent UDFs at this point.
name|ClassLoader
name|loader
init|=
name|Utilities
operator|.
name|getSessionSpecifiedClassLoader
argument_list|()
decl_stmt|;
try|try
block|{
name|functionClass
operator|=
name|Class
operator|.
name|forName
argument_list|(
name|function
operator|.
name|getClassName
argument_list|()
argument_list|,
literal|true
argument_list|,
name|loader
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|ClassNotFoundException
name|ex
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
name|ex
argument_list|)
throw|;
block|}
block|}
return|return
name|functionClass
return|;
block|}
specifier|public
name|void
name|unregisterFunction
parameter_list|(
name|String
name|functionName
parameter_list|)
throws|throws
name|HiveException
block|{
name|lock
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
name|functionName
operator|=
name|functionName
operator|.
name|toLowerCase
argument_list|()
expr_stmt|;
name|FunctionInfo
name|fi
init|=
name|mFunctions
operator|.
name|get
argument_list|(
name|functionName
argument_list|)
decl_stmt|;
if|if
condition|(
name|fi
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|fi
operator|.
name|isBuiltIn
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|HiveException
argument_list|(
name|ErrorMsg
operator|.
name|DROP_NATIVE_FUNCTION
operator|.
name|getMsg
argument_list|(
name|functionName
argument_list|)
argument_list|)
throw|;
block|}
name|mFunctions
operator|.
name|remove
argument_list|(
name|functionName
argument_list|)
expr_stmt|;
name|fi
operator|.
name|discarded
argument_list|()
expr_stmt|;
if|if
condition|(
name|fi
operator|.
name|isPersistent
argument_list|()
condition|)
block|{
name|removePersistentFunctionUnderLock
argument_list|(
name|fi
argument_list|)
expr_stmt|;
block|}
block|}
block|}
finally|finally
block|{
name|lock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|removePersistentFunctionUnderLock
parameter_list|(
name|FunctionInfo
name|fi
parameter_list|)
block|{
name|Class
argument_list|<
name|?
argument_list|>
name|functionClass
init|=
name|getPermanentUdfClass
argument_list|(
name|fi
argument_list|)
decl_stmt|;
name|Integer
name|refCount
init|=
name|persistent
operator|.
name|get
argument_list|(
name|functionClass
argument_list|)
decl_stmt|;
if|if
condition|(
name|refCount
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|refCount
operator|==
literal|1
condition|)
block|{
name|persistent
operator|.
name|remove
argument_list|(
name|functionClass
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|persistent
operator|.
name|put
argument_list|(
name|functionClass
argument_list|,
name|Integer
operator|.
name|valueOf
argument_list|(
name|refCount
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**    * Unregisters all the functions belonging to the specified database    * @param dbName database name    * @throws HiveException    */
specifier|public
name|void
name|unregisterFunctions
parameter_list|(
name|String
name|dbName
parameter_list|)
throws|throws
name|HiveException
block|{
name|lock
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
name|Set
argument_list|<
name|String
argument_list|>
name|funcNames
init|=
name|getFunctionNames
argument_list|(
name|dbName
operator|.
name|toLowerCase
argument_list|()
operator|+
literal|"\\..*"
argument_list|)
decl_stmt|;
for|for
control|(
name|String
name|funcName
range|:
name|funcNames
control|)
block|{
name|unregisterFunction
argument_list|(
name|funcName
argument_list|)
expr_stmt|;
block|}
block|}
finally|finally
block|{
name|lock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
specifier|public
name|GenericUDAFResolver
name|getGenericUDAFResolver
parameter_list|(
name|String
name|functionName
parameter_list|)
throws|throws
name|SemanticException
block|{
name|FunctionInfo
name|info
init|=
name|getFunctionInfo
argument_list|(
name|functionName
argument_list|)
decl_stmt|;
if|if
condition|(
name|info
operator|!=
literal|null
condition|)
block|{
return|return
name|info
operator|.
name|getGenericUDAFResolver
argument_list|()
return|;
block|}
return|return
literal|null
return|;
block|}
specifier|private
name|FunctionInfo
name|getQualifiedFunctionInfoUnderLock
parameter_list|(
name|String
name|qualifiedName
parameter_list|)
throws|throws
name|SemanticException
block|{
name|FunctionInfo
name|info
init|=
name|mFunctions
operator|.
name|get
argument_list|(
name|qualifiedName
argument_list|)
decl_stmt|;
if|if
condition|(
name|info
operator|!=
literal|null
operator|&&
name|info
operator|.
name|isBlockedFunction
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
literal|"UDF "
operator|+
name|qualifiedName
operator|+
literal|" is not allowed"
argument_list|)
throw|;
block|}
if|if
condition|(
operator|!
name|isNative
operator|&&
name|info
operator|!=
literal|null
operator|&&
name|info
operator|.
name|isDiscarded
argument_list|()
condition|)
block|{
comment|// the persistent function is discarded. try reload
name|mFunctions
operator|.
name|remove
argument_list|(
name|qualifiedName
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
comment|// HIVE-6672: In HiveServer2 the JARs for this UDF may have been loaded by a different thread,
comment|// and the current thread may not be able to resolve the UDF. Test for this condition
comment|// and if necessary load the JARs in this thread.
if|if
condition|(
name|isNative
operator|&&
name|info
operator|!=
literal|null
operator|&&
name|info
operator|.
name|isPersistent
argument_list|()
condition|)
block|{
return|return
name|registerToSessionRegistry
argument_list|(
name|qualifiedName
argument_list|,
name|info
argument_list|)
return|;
block|}
if|if
condition|(
name|info
operator|!=
literal|null
operator|||
operator|!
name|isNative
condition|)
block|{
return|return
name|info
return|;
comment|// We have the UDF, or we are in the session registry (or both).
block|}
comment|// If we are in the system registry and this feature is enabled, try to get it from metastore.
name|SessionState
name|ss
init|=
name|SessionState
operator|.
name|get
argument_list|()
decl_stmt|;
name|HiveConf
name|conf
init|=
operator|(
name|ss
operator|==
literal|null
operator|)
condition|?
literal|null
else|:
name|ss
operator|.
name|getConf
argument_list|()
decl_stmt|;
if|if
condition|(
name|conf
operator|==
literal|null
operator|||
operator|!
name|HiveConf
operator|.
name|getBoolVar
argument_list|(
name|conf
argument_list|,
name|ConfVars
operator|.
name|HIVE_ALLOW_UDF_LOAD_ON_DEMAND
argument_list|)
condition|)
block|{
return|return
literal|null
return|;
block|}
comment|// This is a little bit weird. We'll do the MS call outside of the lock. Our caller calls us
comment|// under lock, so we'd preserve the lock state for them; their finally block will release the
comment|// lock correctly. See the comment on the lock field - the locking needs to be reworked.
name|lock
operator|.
name|unlock
argument_list|()
expr_stmt|;
try|try
block|{
return|return
name|getFunctionInfoFromMetastoreNoLock
argument_list|(
name|qualifiedName
argument_list|,
name|conf
argument_list|)
return|;
block|}
finally|finally
block|{
name|lock
operator|.
name|lock
argument_list|()
expr_stmt|;
block|}
block|}
comment|// should be called after session registry is checked
specifier|private
name|FunctionInfo
name|registerToSessionRegistry
parameter_list|(
name|String
name|qualifiedName
parameter_list|,
name|FunctionInfo
name|function
parameter_list|)
throws|throws
name|SemanticException
block|{
name|FunctionInfo
name|ret
init|=
literal|null
decl_stmt|;
name|ClassLoader
name|prev
init|=
name|Utilities
operator|.
name|getSessionSpecifiedClassLoader
argument_list|()
decl_stmt|;
try|try
block|{
comment|// Found UDF in metastore - now add it to the function registry
comment|// At this point we should add any relevant jars that would be needed for the UDf.
name|FunctionResource
index|[]
name|resources
init|=
name|function
operator|.
name|getResources
argument_list|()
decl_stmt|;
try|try
block|{
name|FunctionUtils
operator|.
name|addFunctionResources
argument_list|(
name|resources
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Unable to load resources for "
operator|+
name|qualifiedName
operator|+
literal|":"
operator|+
name|e
argument_list|,
name|e
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
name|ClassLoader
name|loader
init|=
name|Utilities
operator|.
name|getSessionSpecifiedClassLoader
argument_list|()
decl_stmt|;
name|Class
argument_list|<
name|?
argument_list|>
name|udfClass
init|=
name|Class
operator|.
name|forName
argument_list|(
name|function
operator|.
name|getClassName
argument_list|()
argument_list|,
literal|true
argument_list|,
name|loader
argument_list|)
decl_stmt|;
comment|// Make sure the FunctionInfo is listed as PERSISTENT (rather than TEMPORARY)
comment|// when it is registered to the system registry.
name|ret
operator|=
name|SessionState
operator|.
name|getRegistryForWrite
argument_list|()
operator|.
name|registerFunction
argument_list|(
name|qualifiedName
argument_list|,
name|FunctionType
operator|.
name|PERSISTENT
argument_list|,
name|udfClass
argument_list|,
name|resources
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
literal|null
condition|)
block|{
name|LOG
operator|.
name|error
argument_list|(
name|function
operator|.
name|getClassName
argument_list|()
operator|+
literal|" is not a valid UDF class and was not registered."
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|SessionState
operator|.
name|get
argument_list|()
operator|.
name|isHiveServerQuery
argument_list|()
condition|)
block|{
name|SessionState
operator|.
name|getRegistryForWrite
argument_list|()
operator|.
name|addToUDFLoaders
argument_list|(
name|loader
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|ClassNotFoundException
name|e
parameter_list|)
block|{
comment|// Lookup of UDf class failed
name|LOG
operator|.
name|error
argument_list|(
literal|"Unable to load UDF class: "
operator|+
name|e
argument_list|)
expr_stmt|;
name|Utilities
operator|.
name|restoreSessionSpecifiedClassLoader
argument_list|(
name|prev
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|SemanticException
argument_list|(
literal|"Unable to load UDF class: "
operator|+
name|e
operator|+
literal|"\nPlease ensure that the JAR file containing this class has been properly installed "
operator|+
literal|"in the auxiliary directory or was added with ADD JAR command."
argument_list|)
throw|;
block|}
finally|finally
block|{
name|function
operator|.
name|shareStateWith
argument_list|(
name|ret
argument_list|)
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
specifier|public
name|void
name|clear
parameter_list|()
block|{
name|lock
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
if|if
condition|(
name|isNative
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"System function registry cannot be cleared"
argument_list|)
throw|;
block|}
name|mFunctions
operator|.
name|clear
argument_list|()
expr_stmt|;
name|builtIns
operator|.
name|clear
argument_list|()
expr_stmt|;
name|persistent
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
finally|finally
block|{
name|lock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
specifier|public
name|void
name|closeCUDFLoaders
parameter_list|()
block|{
name|lock
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
try|try
block|{
for|for
control|(
name|ClassLoader
name|loader
range|:
name|mSessionUDFLoaders
control|)
block|{
name|JavaUtils
operator|.
name|closeClassLoader
argument_list|(
name|loader
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|ie
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Error in close loader: "
operator|+
name|ie
argument_list|)
expr_stmt|;
block|}
name|mSessionUDFLoaders
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
finally|finally
block|{
name|lock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
specifier|public
name|void
name|addToUDFLoaders
parameter_list|(
name|ClassLoader
name|loader
parameter_list|)
block|{
name|lock
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
name|mSessionUDFLoaders
operator|.
name|add
argument_list|(
name|loader
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|lock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
specifier|public
name|void
name|removeFromUDFLoaders
parameter_list|(
name|ClassLoader
name|loader
parameter_list|)
block|{
name|lock
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
name|mSessionUDFLoaders
operator|.
name|remove
argument_list|(
name|loader
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|lock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Setup blocked flag for all builtin UDFs as per udf whitelist and blacklist    * @param whiteListStr    * @param blackListStr    */
specifier|public
name|void
name|setupPermissionsForUDFs
parameter_list|(
name|String
name|whiteListStr
parameter_list|,
name|String
name|blackListStr
parameter_list|)
block|{
name|Set
argument_list|<
name|String
argument_list|>
name|whiteList
init|=
name|Sets
operator|.
name|newHashSet
argument_list|(
name|Splitter
operator|.
name|on
argument_list|(
literal|","
argument_list|)
operator|.
name|trimResults
argument_list|()
operator|.
name|omitEmptyStrings
argument_list|()
operator|.
name|split
argument_list|(
name|whiteListStr
operator|.
name|toLowerCase
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
name|Set
argument_list|<
name|String
argument_list|>
name|blackList
init|=
name|Sets
operator|.
name|newHashSet
argument_list|(
name|Splitter
operator|.
name|on
argument_list|(
literal|","
argument_list|)
operator|.
name|trimResults
argument_list|()
operator|.
name|omitEmptyStrings
argument_list|()
operator|.
name|split
argument_list|(
name|blackListStr
operator|.
name|toLowerCase
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
name|blackList
operator|.
name|removeAll
argument_list|(
name|FunctionRegistry
operator|.
name|HIVE_OPERATORS
argument_list|)
expr_stmt|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|FunctionInfo
argument_list|>
name|funcEntry
range|:
name|mFunctions
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|funcEntry
operator|.
name|getValue
argument_list|()
operator|.
name|setBlockedFunction
argument_list|(
name|isUdfBlocked
argument_list|(
name|funcEntry
operator|.
name|getKey
argument_list|()
argument_list|,
name|whiteList
argument_list|,
name|blackList
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Check if the function belongs to whitelist or blacklist    * @param functionName    * @param whiteList    * @param blackList    * @return true if the given udf is to be blocked    */
name|boolean
name|isUdfBlocked
parameter_list|(
name|String
name|functionName
parameter_list|,
name|Set
argument_list|<
name|String
argument_list|>
name|whiteList
parameter_list|,
name|Set
argument_list|<
name|String
argument_list|>
name|blackList
parameter_list|)
block|{
name|functionName
operator|=
name|functionName
operator|.
name|toLowerCase
argument_list|()
expr_stmt|;
return|return
name|blackList
operator|.
name|contains
argument_list|(
name|functionName
argument_list|)
operator|||
operator|(
operator|!
name|whiteList
operator|.
name|isEmpty
argument_list|()
operator|&&
operator|!
name|whiteList
operator|.
name|contains
argument_list|(
name|functionName
argument_list|)
operator|)
return|;
block|}
comment|/**    * This is called outside of the lock. Some of the methods that are called transitively by    * this (e.g. addFunction) will take the lock again and then release it, which is ok.    */
specifier|private
name|FunctionInfo
name|getFunctionInfoFromMetastoreNoLock
parameter_list|(
name|String
name|functionName
parameter_list|,
name|HiveConf
name|conf
parameter_list|)
block|{
try|try
block|{
name|String
index|[]
name|parts
init|=
name|FunctionUtils
operator|.
name|getQualifiedFunctionNameParts
argument_list|(
name|functionName
argument_list|)
decl_stmt|;
name|Function
name|func
init|=
name|Hive
operator|.
name|get
argument_list|(
name|conf
argument_list|)
operator|.
name|getFunction
argument_list|(
name|parts
index|[
literal|0
index|]
operator|.
name|toLowerCase
argument_list|()
argument_list|,
name|parts
index|[
literal|1
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
name|func
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
comment|// Found UDF in metastore - now add it to the function registry.
name|FunctionInfo
name|fi
init|=
name|registerPermanentFunction
argument_list|(
name|functionName
argument_list|,
name|func
operator|.
name|getClassName
argument_list|()
argument_list|,
literal|true
argument_list|,
name|FunctionUtils
operator|.
name|toFunctionResource
argument_list|(
name|func
operator|.
name|getResourceUris
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|fi
operator|==
literal|null
condition|)
block|{
name|LOG
operator|.
name|error
argument_list|(
name|func
operator|.
name|getClassName
argument_list|()
operator|+
literal|" is not a valid UDF class and was not registered"
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
return|return
name|fi
return|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Unable to look up "
operator|+
name|functionName
operator|+
literal|" in metastore"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
return|return
literal|null
return|;
block|}
block|}
end_class

end_unit

