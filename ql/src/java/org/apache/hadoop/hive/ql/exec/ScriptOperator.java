begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|BufferedInputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|BufferedOutputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|DataInputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|DataOutputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|File
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|Serializable
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Timer
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|TimerTask
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|TimeUnit
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|conf
operator|.
name|HiveConf
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|CompilationOpContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|ErrorMsg
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|metadata
operator|.
name|HiveException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|ScriptDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|api
operator|.
name|OperatorType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|Deserializer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|SerDeException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|SerDeUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|Serializer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|objectinspector
operator|.
name|ObjectInspector
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|BytesWritable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|LongWritable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|Text
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|Writable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapred
operator|.
name|Reporter
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|Shell
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|StringUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|spark
operator|.
name|SparkConf
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|spark
operator|.
name|SparkEnv
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|spark
operator|.
name|SparkFiles
import|;
end_import

begin_comment
comment|/**  * ScriptOperator.  *  */
end_comment

begin_class
specifier|public
class|class
name|ScriptOperator
extends|extends
name|Operator
argument_list|<
name|ScriptDesc
argument_list|>
implements|implements
name|Serializable
block|{
specifier|private
specifier|static
specifier|final
name|long
name|serialVersionUID
init|=
literal|1L
decl_stmt|;
comment|/**    * Counter.    *    */
specifier|public
specifier|static
enum|enum
name|Counter
block|{
name|DESERIALIZE_ERRORS
block|,
name|SERIALIZE_ERRORS
block|}
specifier|private
specifier|final
specifier|transient
name|LongWritable
name|deserialize_error_count
init|=
operator|new
name|LongWritable
argument_list|()
decl_stmt|;
specifier|private
specifier|final
specifier|transient
name|LongWritable
name|serialize_error_count
init|=
operator|new
name|LongWritable
argument_list|()
decl_stmt|;
specifier|transient
name|Thread
name|outThread
init|=
literal|null
decl_stmt|;
specifier|transient
name|Thread
name|errThread
init|=
literal|null
decl_stmt|;
specifier|transient
name|Process
name|scriptPid
init|=
literal|null
decl_stmt|;
specifier|transient
name|Configuration
name|hconf
decl_stmt|;
comment|// Input to the script
specifier|transient
name|Serializer
name|scriptInputSerializer
decl_stmt|;
comment|// Output from the script
specifier|transient
name|Deserializer
name|scriptOutputDeserializer
decl_stmt|;
specifier|transient
specifier|volatile
name|Throwable
name|scriptError
init|=
literal|null
decl_stmt|;
specifier|transient
name|RecordWriter
name|scriptOutWriter
init|=
literal|null
decl_stmt|;
comment|// List of conf entries not to turn into env vars
specifier|transient
name|Set
argument_list|<
name|String
argument_list|>
name|blackListedConfEntries
init|=
literal|null
decl_stmt|;
specifier|static
specifier|final
name|String
name|IO_EXCEPTION_BROKEN_PIPE_STRING
init|=
literal|"Broken pipe"
decl_stmt|;
specifier|static
specifier|final
name|String
name|IO_EXCEPTION_STREAM_CLOSED
init|=
literal|"Stream closed"
decl_stmt|;
comment|/**    * sends periodic reports back to the tracker.    */
specifier|transient
name|AutoProgressor
name|autoProgressor
decl_stmt|;
comment|// first row - the process should only be started if necessary, as it may
comment|// conflict with some
comment|// of the user assumptions.
specifier|transient
name|boolean
name|firstRow
decl_stmt|;
name|String
name|safeEnvVarName
parameter_list|(
name|String
name|name
parameter_list|)
block|{
name|StringBuilder
name|safe
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|int
name|len
init|=
name|name
operator|.
name|length
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
name|char
name|c
init|=
name|name
operator|.
name|charAt
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|char
name|s
decl_stmt|;
if|if
condition|(
operator|(
name|c
operator|>=
literal|'0'
operator|&&
name|c
operator|<=
literal|'9'
operator|)
operator|||
operator|(
name|c
operator|>=
literal|'A'
operator|&&
name|c
operator|<=
literal|'Z'
operator|)
operator|||
operator|(
name|c
operator|>=
literal|'a'
operator|&&
name|c
operator|<=
literal|'z'
operator|)
condition|)
block|{
name|s
operator|=
name|c
expr_stmt|;
block|}
else|else
block|{
name|s
operator|=
literal|'_'
expr_stmt|;
block|}
name|safe
operator|.
name|append
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
return|return
name|safe
operator|.
name|toString
argument_list|()
return|;
block|}
comment|/**    * Most UNIX implementations impose some limit on the total size of environment variables and    * size of strings. To fit in this limit we need sometimes to truncate strings.  Also,    * some values tend be long and are meaningless to scripts, so strain them out.    * @param value environment variable value to check    * @param name name of variable (used only for logging purposes)    * @param truncate truncate value or not    * @return original value, or truncated one if it's length is more then 20KB and    * truncate flag is set    * @see<a href="http://www.kernel.org/doc/man-pages/online/pages/man2/execve.2.html">Linux    * Man page</a> for more details    */
name|String
name|safeEnvVarValue
parameter_list|(
name|String
name|value
parameter_list|,
name|String
name|name
parameter_list|,
name|boolean
name|truncate
parameter_list|)
block|{
specifier|final
name|int
name|lenLimit
init|=
literal|20
operator|*
literal|1024
decl_stmt|;
if|if
condition|(
name|truncate
operator|&&
name|value
operator|.
name|length
argument_list|()
operator|>
name|lenLimit
condition|)
block|{
name|value
operator|=
name|value
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|lenLimit
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|warn
argument_list|(
literal|"Length of environment variable "
operator|+
name|name
operator|+
literal|" was truncated to "
operator|+
name|lenLimit
operator|+
literal|" bytes to fit system limits."
argument_list|)
expr_stmt|;
block|}
return|return
name|value
return|;
block|}
comment|/**    * Checks whether a given configuration name is blacklisted and should not be converted    * to an environment variable.    */
name|boolean
name|blackListed
parameter_list|(
name|Configuration
name|conf
parameter_list|,
name|String
name|name
parameter_list|)
block|{
if|if
condition|(
name|blackListedConfEntries
operator|==
literal|null
condition|)
block|{
name|blackListedConfEntries
operator|=
operator|new
name|HashSet
argument_list|<
name|String
argument_list|>
argument_list|()
expr_stmt|;
if|if
condition|(
name|conf
operator|!=
literal|null
condition|)
block|{
name|String
name|bl
init|=
name|conf
operator|.
name|get
argument_list|(
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVESCRIPT_ENV_BLACKLIST
operator|.
name|toString
argument_list|()
argument_list|,
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVESCRIPT_ENV_BLACKLIST
operator|.
name|getDefaultValue
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|bl
operator|!=
literal|null
operator|&&
operator|!
name|bl
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|String
index|[]
name|bls
init|=
name|bl
operator|.
name|split
argument_list|(
literal|","
argument_list|)
decl_stmt|;
name|Collections
operator|.
name|addAll
argument_list|(
name|blackListedConfEntries
argument_list|,
name|bls
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
name|blackListedConfEntries
operator|.
name|contains
argument_list|(
name|name
argument_list|)
return|;
block|}
comment|/**    * addJobConfToEnvironment is mostly shamelessly copied from hadoop streaming. Added additional    * check on environment variable length    */
name|void
name|addJobConfToEnvironment
parameter_list|(
name|Configuration
name|conf
parameter_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|env
parameter_list|)
block|{
name|Iterator
argument_list|<
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
argument_list|>
name|it
init|=
name|conf
operator|.
name|iterator
argument_list|()
decl_stmt|;
while|while
condition|(
name|it
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|en
init|=
name|it
operator|.
name|next
argument_list|()
decl_stmt|;
name|String
name|name
init|=
name|en
operator|.
name|getKey
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|blackListed
argument_list|(
name|conf
argument_list|,
name|name
argument_list|)
condition|)
block|{
comment|// String value = (String)en.getValue(); // does not apply variable
comment|// expansion
name|String
name|value
init|=
name|conf
operator|.
name|get
argument_list|(
name|name
argument_list|)
decl_stmt|;
comment|// does variable expansion
name|name
operator|=
name|safeEnvVarName
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|boolean
name|truncate
init|=
name|conf
operator|.
name|getBoolean
argument_list|(
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVESCRIPTTRUNCATEENV
operator|.
name|toString
argument_list|()
argument_list|,
literal|false
argument_list|)
decl_stmt|;
name|value
operator|=
name|safeEnvVarValue
argument_list|(
name|value
argument_list|,
name|name
argument_list|,
name|truncate
argument_list|)
expr_stmt|;
name|env
operator|.
name|put
argument_list|(
name|name
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**    * Maps a relative pathname to an absolute pathname using the PATH environment.    */
specifier|public
class|class
name|PathFinder
block|{
name|String
name|pathenv
decl_stmt|;
comment|// a string of pathnames
name|String
name|pathSep
decl_stmt|;
comment|// the path separator
name|String
name|fileSep
decl_stmt|;
comment|// the file separator in a directory
comment|/**      * Construct a PathFinder object using the path from the specified system      * environment variable.      */
specifier|public
name|PathFinder
parameter_list|(
name|String
name|envpath
parameter_list|)
block|{
name|pathenv
operator|=
name|System
operator|.
name|getenv
argument_list|(
name|envpath
argument_list|)
expr_stmt|;
name|pathSep
operator|=
name|System
operator|.
name|getProperty
argument_list|(
literal|"path.separator"
argument_list|)
expr_stmt|;
name|fileSep
operator|=
name|System
operator|.
name|getProperty
argument_list|(
literal|"file.separator"
argument_list|)
expr_stmt|;
block|}
comment|/**      * Appends the specified component to the path list.      */
specifier|public
name|void
name|prependPathComponent
parameter_list|(
name|String
name|str
parameter_list|)
block|{
name|pathenv
operator|=
name|str
operator|+
name|pathSep
operator|+
name|pathenv
expr_stmt|;
block|}
comment|/**      * Returns the full path name of this file if it is listed in the path.      */
specifier|public
name|File
name|getAbsolutePath
parameter_list|(
name|String
name|filename
parameter_list|)
block|{
if|if
condition|(
name|pathenv
operator|==
literal|null
operator|||
name|pathSep
operator|==
literal|null
operator|||
name|fileSep
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
name|int
name|val
init|=
operator|-
literal|1
decl_stmt|;
name|String
name|classvalue
init|=
name|pathenv
operator|+
name|pathSep
decl_stmt|;
while|while
condition|(
operator|(
operator|(
name|val
operator|=
name|classvalue
operator|.
name|indexOf
argument_list|(
name|pathSep
argument_list|)
operator|)
operator|>=
literal|0
operator|)
operator|&&
name|classvalue
operator|.
name|length
argument_list|()
operator|>
literal|0
condition|)
block|{
comment|//
comment|// Extract each entry from the pathenv
comment|//
name|String
name|entry
init|=
name|classvalue
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|val
argument_list|)
operator|.
name|trim
argument_list|()
decl_stmt|;
name|File
name|f
init|=
operator|new
name|File
argument_list|(
name|entry
argument_list|)
decl_stmt|;
try|try
block|{
if|if
condition|(
name|f
operator|.
name|isDirectory
argument_list|()
condition|)
block|{
comment|//
comment|// this entry in the pathenv is a directory.
comment|// see if the required file is in this directory
comment|//
name|f
operator|=
operator|new
name|File
argument_list|(
name|entry
operator|+
name|fileSep
operator|+
name|filename
argument_list|)
expr_stmt|;
block|}
comment|//
comment|// see if the filename matches and we can read it
comment|//
if|if
condition|(
name|f
operator|.
name|isFile
argument_list|()
operator|&&
name|f
operator|.
name|canRead
argument_list|()
condition|)
block|{
return|return
name|f
return|;
block|}
block|}
catch|catch
parameter_list|(
name|Exception
name|exp
parameter_list|)
block|{         }
name|classvalue
operator|=
name|classvalue
operator|.
name|substring
argument_list|(
name|val
operator|+
literal|1
argument_list|)
operator|.
name|trim
argument_list|()
expr_stmt|;
block|}
return|return
literal|null
return|;
block|}
block|}
comment|/** Kryo ctor. */
specifier|protected
name|ScriptOperator
parameter_list|()
block|{
name|super
argument_list|()
expr_stmt|;
block|}
specifier|public
name|ScriptOperator
parameter_list|(
name|CompilationOpContext
name|ctx
parameter_list|)
block|{
name|super
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|protected
name|void
name|initializeOp
parameter_list|(
name|Configuration
name|hconf
parameter_list|)
throws|throws
name|HiveException
block|{
name|super
operator|.
name|initializeOp
argument_list|(
name|hconf
argument_list|)
expr_stmt|;
name|firstRow
operator|=
literal|true
expr_stmt|;
name|statsMap
operator|.
name|put
argument_list|(
name|Counter
operator|.
name|DESERIALIZE_ERRORS
operator|.
name|toString
argument_list|()
argument_list|,
name|deserialize_error_count
argument_list|)
expr_stmt|;
name|statsMap
operator|.
name|put
argument_list|(
name|Counter
operator|.
name|SERIALIZE_ERRORS
operator|.
name|toString
argument_list|()
argument_list|,
name|serialize_error_count
argument_list|)
expr_stmt|;
try|try
block|{
name|this
operator|.
name|hconf
operator|=
name|hconf
expr_stmt|;
name|scriptOutputDeserializer
operator|=
name|conf
operator|.
name|getScriptOutputInfo
argument_list|()
operator|.
name|getDeserializerClass
argument_list|()
operator|.
name|newInstance
argument_list|()
expr_stmt|;
name|SerDeUtils
operator|.
name|initializeSerDe
argument_list|(
name|scriptOutputDeserializer
argument_list|,
name|hconf
argument_list|,
name|conf
operator|.
name|getScriptOutputInfo
argument_list|()
operator|.
name|getProperties
argument_list|()
argument_list|,
literal|null
argument_list|)
expr_stmt|;
name|scriptInputSerializer
operator|=
operator|(
name|Serializer
operator|)
name|conf
operator|.
name|getScriptInputInfo
argument_list|()
operator|.
name|getDeserializerClass
argument_list|()
operator|.
name|newInstance
argument_list|()
expr_stmt|;
name|scriptInputSerializer
operator|.
name|initialize
argument_list|(
name|hconf
argument_list|,
name|conf
operator|.
name|getScriptInputInfo
argument_list|()
operator|.
name|getProperties
argument_list|()
argument_list|)
expr_stmt|;
name|outputObjInspector
operator|=
name|scriptOutputDeserializer
operator|.
name|getObjectInspector
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|HiveException
argument_list|(
name|ErrorMsg
operator|.
name|SCRIPT_INIT_ERROR
operator|.
name|getErrorCodedMsg
argument_list|()
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
name|boolean
name|isBrokenPipeException
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
return|return
operator|(
name|e
operator|.
name|getMessage
argument_list|()
operator|.
name|equalsIgnoreCase
argument_list|(
name|IO_EXCEPTION_BROKEN_PIPE_STRING
argument_list|)
operator|||
name|e
operator|.
name|getMessage
argument_list|()
operator|.
name|equalsIgnoreCase
argument_list|(
name|IO_EXCEPTION_STREAM_CLOSED
argument_list|)
operator|)
return|;
block|}
name|boolean
name|allowPartialConsumption
parameter_list|()
block|{
return|return
name|HiveConf
operator|.
name|getBoolVar
argument_list|(
name|hconf
argument_list|,
name|HiveConf
operator|.
name|ConfVars
operator|.
name|ALLOWPARTIALCONSUMP
argument_list|)
return|;
block|}
name|void
name|displayBrokenPipeInfo
parameter_list|()
block|{
if|if
condition|(
name|LOG
operator|.
name|isInfoEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"The script did not consume all input data. This is considered as an error."
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"set "
operator|+
name|HiveConf
operator|.
name|ConfVars
operator|.
name|ALLOWPARTIALCONSUMP
operator|.
name|toString
argument_list|()
operator|+
literal|"=true; to ignore it."
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
specifier|private
specifier|transient
name|String
name|tableName
decl_stmt|;
specifier|private
specifier|transient
name|String
name|partitionName
decl_stmt|;
annotation|@
name|Override
specifier|public
name|void
name|setInputContext
parameter_list|(
name|String
name|tableName
parameter_list|,
name|String
name|partitionName
parameter_list|)
block|{
name|this
operator|.
name|tableName
operator|=
name|tableName
expr_stmt|;
name|this
operator|.
name|partitionName
operator|=
name|partitionName
expr_stmt|;
name|super
operator|.
name|setInputContext
argument_list|(
name|tableName
argument_list|,
name|partitionName
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|process
parameter_list|(
name|Object
name|row
parameter_list|,
name|int
name|tag
parameter_list|)
throws|throws
name|HiveException
block|{
comment|// initialize the user's process only when you receive the first row
if|if
condition|(
name|firstRow
condition|)
block|{
name|firstRow
operator|=
literal|false
expr_stmt|;
name|SparkConf
name|sparkConf
init|=
literal|null
decl_stmt|;
try|try
block|{
name|String
index|[]
name|cmdArgs
init|=
name|splitArgs
argument_list|(
name|conf
operator|.
name|getScriptCmd
argument_list|()
argument_list|)
decl_stmt|;
name|String
name|prog
init|=
name|cmdArgs
index|[
literal|0
index|]
decl_stmt|;
name|File
name|currentDir
init|=
operator|new
name|File
argument_list|(
literal|"."
argument_list|)
operator|.
name|getAbsoluteFile
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
operator|new
name|File
argument_list|(
name|prog
argument_list|)
operator|.
name|isAbsolute
argument_list|()
condition|)
block|{
name|PathFinder
name|finder
init|=
operator|new
name|PathFinder
argument_list|(
literal|"PATH"
argument_list|)
decl_stmt|;
name|finder
operator|.
name|prependPathComponent
argument_list|(
name|currentDir
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
comment|// In spark local mode, we need to search added files in root directory.
if|if
condition|(
name|HiveConf
operator|.
name|getVar
argument_list|(
name|hconf
argument_list|,
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVE_EXECUTION_ENGINE
argument_list|)
operator|.
name|equals
argument_list|(
literal|"spark"
argument_list|)
condition|)
block|{
name|sparkConf
operator|=
name|SparkEnv
operator|.
name|get
argument_list|()
operator|.
name|conf
argument_list|()
expr_stmt|;
name|finder
operator|.
name|prependPathComponent
argument_list|(
name|SparkFiles
operator|.
name|getRootDirectory
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|File
name|f
init|=
name|finder
operator|.
name|getAbsolutePath
argument_list|(
name|prog
argument_list|)
decl_stmt|;
if|if
condition|(
name|f
operator|!=
literal|null
condition|)
block|{
name|cmdArgs
index|[
literal|0
index|]
operator|=
name|f
operator|.
name|getAbsolutePath
argument_list|()
expr_stmt|;
block|}
name|f
operator|=
literal|null
expr_stmt|;
block|}
name|String
index|[]
name|wrappedCmdArgs
init|=
name|addWrapper
argument_list|(
name|cmdArgs
argument_list|)
decl_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isInfoEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Executing "
operator|+
name|Arrays
operator|.
name|asList
argument_list|(
name|wrappedCmdArgs
argument_list|)
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"tablename="
operator|+
name|tableName
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"partname="
operator|+
name|partitionName
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"alias="
operator|+
name|alias
argument_list|)
expr_stmt|;
block|}
name|ProcessBuilder
name|pb
init|=
operator|new
name|ProcessBuilder
argument_list|(
name|wrappedCmdArgs
argument_list|)
decl_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|env
init|=
name|pb
operator|.
name|environment
argument_list|()
decl_stmt|;
name|addJobConfToEnvironment
argument_list|(
name|hconf
argument_list|,
name|env
argument_list|)
expr_stmt|;
name|env
operator|.
name|put
argument_list|(
name|safeEnvVarName
argument_list|(
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVEALIAS
operator|.
name|varname
argument_list|)
argument_list|,
name|String
operator|.
name|valueOf
argument_list|(
name|alias
argument_list|)
argument_list|)
expr_stmt|;
comment|// Create an environment variable that uniquely identifies this script
comment|// operator
name|String
name|idEnvVarName
init|=
name|HiveConf
operator|.
name|getVar
argument_list|(
name|hconf
argument_list|,
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVESCRIPTIDENVVAR
argument_list|)
decl_stmt|;
name|String
name|idEnvVarVal
init|=
name|getOperatorId
argument_list|()
decl_stmt|;
name|env
operator|.
name|put
argument_list|(
name|safeEnvVarName
argument_list|(
name|idEnvVarName
argument_list|)
argument_list|,
name|idEnvVarVal
argument_list|)
expr_stmt|;
comment|// For spark, in non-local mode, any added dependencies are stored at
comment|// SparkFiles::getRootDirectory, which is the executor's working directory.
comment|// In local mode, we need to manually point the process's working directory to it,
comment|// in order to make the dependencies accessible.
if|if
condition|(
name|sparkConf
operator|!=
literal|null
condition|)
block|{
name|String
name|master
init|=
name|sparkConf
operator|.
name|get
argument_list|(
literal|"spark.master"
argument_list|)
decl_stmt|;
if|if
condition|(
name|master
operator|.
name|equals
argument_list|(
literal|"local"
argument_list|)
operator|||
name|master
operator|.
name|startsWith
argument_list|(
literal|"local["
argument_list|)
condition|)
block|{
name|pb
operator|.
name|directory
argument_list|(
operator|new
name|File
argument_list|(
name|SparkFiles
operator|.
name|getRootDirectory
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|scriptPid
operator|=
name|pb
operator|.
name|start
argument_list|()
expr_stmt|;
comment|// Runtime.getRuntime().exec(wrappedCmdArgs);
name|DataOutputStream
name|scriptOut
init|=
operator|new
name|DataOutputStream
argument_list|(
operator|new
name|BufferedOutputStream
argument_list|(
name|scriptPid
operator|.
name|getOutputStream
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
name|DataInputStream
name|scriptIn
init|=
operator|new
name|DataInputStream
argument_list|(
operator|new
name|BufferedInputStream
argument_list|(
name|scriptPid
operator|.
name|getInputStream
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
name|DataInputStream
name|scriptErr
init|=
operator|new
name|DataInputStream
argument_list|(
operator|new
name|BufferedInputStream
argument_list|(
name|scriptPid
operator|.
name|getErrorStream
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
name|scriptOutWriter
operator|=
name|conf
operator|.
name|getInRecordWriterClass
argument_list|()
operator|.
name|newInstance
argument_list|()
expr_stmt|;
name|scriptOutWriter
operator|.
name|initialize
argument_list|(
name|scriptOut
argument_list|,
name|hconf
argument_list|)
expr_stmt|;
name|RecordReader
name|scriptOutputReader
init|=
name|conf
operator|.
name|getOutRecordReaderClass
argument_list|()
operator|.
name|newInstance
argument_list|()
decl_stmt|;
name|scriptOutputReader
operator|.
name|initialize
argument_list|(
name|scriptIn
argument_list|,
name|hconf
argument_list|,
name|conf
operator|.
name|getScriptOutputInfo
argument_list|()
operator|.
name|getProperties
argument_list|()
argument_list|)
expr_stmt|;
name|outThread
operator|=
operator|new
name|StreamThread
argument_list|(
name|scriptOutputReader
argument_list|,
operator|new
name|OutputStreamProcessor
argument_list|(
name|scriptOutputDeserializer
operator|.
name|getObjectInspector
argument_list|()
argument_list|)
argument_list|,
literal|"OutputProcessor"
argument_list|)
expr_stmt|;
name|RecordReader
name|scriptErrReader
init|=
name|conf
operator|.
name|getErrRecordReaderClass
argument_list|()
operator|.
name|newInstance
argument_list|()
decl_stmt|;
name|scriptErrReader
operator|.
name|initialize
argument_list|(
name|scriptErr
argument_list|,
name|hconf
argument_list|,
name|conf
operator|.
name|getScriptErrInfo
argument_list|()
operator|.
name|getProperties
argument_list|()
argument_list|)
expr_stmt|;
name|errThread
operator|=
operator|new
name|StreamThread
argument_list|(
name|scriptErrReader
argument_list|,
operator|new
name|ErrorStreamProcessor
argument_list|(
name|HiveConf
operator|.
name|getIntVar
argument_list|(
name|hconf
argument_list|,
name|HiveConf
operator|.
name|ConfVars
operator|.
name|SCRIPTERRORLIMIT
argument_list|)
argument_list|)
argument_list|,
literal|"ErrorProcessor"
argument_list|)
expr_stmt|;
if|if
condition|(
name|HiveConf
operator|.
name|getBoolVar
argument_list|(
name|hconf
argument_list|,
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVESCRIPTAUTOPROGRESS
argument_list|)
condition|)
block|{
name|autoProgressor
operator|=
operator|new
name|AutoProgressor
argument_list|(
name|this
operator|.
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|,
name|reporter
argument_list|,
name|Utilities
operator|.
name|getDefaultNotificationInterval
argument_list|(
name|hconf
argument_list|)
argument_list|,
name|HiveConf
operator|.
name|getTimeVar
argument_list|(
name|hconf
argument_list|,
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVES_AUTO_PROGRESS_TIMEOUT
argument_list|,
name|TimeUnit
operator|.
name|MILLISECONDS
argument_list|)
argument_list|)
expr_stmt|;
name|autoProgressor
operator|.
name|go
argument_list|()
expr_stmt|;
block|}
name|outThread
operator|.
name|start
argument_list|()
expr_stmt|;
name|errThread
operator|.
name|start
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|HiveException
argument_list|(
name|ErrorMsg
operator|.
name|SCRIPT_INIT_ERROR
operator|.
name|getErrorCodedMsg
argument_list|()
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
if|if
condition|(
name|scriptError
operator|!=
literal|null
condition|)
block|{
throw|throw
operator|new
name|HiveException
argument_list|(
name|ErrorMsg
operator|.
name|SCRIPT_GENERIC_ERROR
operator|.
name|getErrorCodedMsg
argument_list|()
argument_list|,
name|scriptError
argument_list|)
throw|;
block|}
try|try
block|{
name|Writable
name|res
init|=
name|scriptInputSerializer
operator|.
name|serialize
argument_list|(
name|row
argument_list|,
name|inputObjInspectors
index|[
name|tag
index|]
argument_list|)
decl_stmt|;
name|scriptOutWriter
operator|.
name|write
argument_list|(
name|res
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|SerDeException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Error in serializing the row: "
operator|+
name|e
operator|.
name|getMessage
argument_list|()
argument_list|)
expr_stmt|;
name|scriptError
operator|=
name|e
expr_stmt|;
name|serialize_error_count
operator|.
name|set
argument_list|(
name|serialize_error_count
operator|.
name|get
argument_list|()
operator|+
literal|1
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|HiveException
argument_list|(
name|e
argument_list|)
throw|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
if|if
condition|(
name|isBrokenPipeException
argument_list|(
name|e
argument_list|)
operator|&&
name|allowPartialConsumption
argument_list|()
condition|)
block|{
comment|// Give the outThread a chance to finish before marking the operator as done
try|try
block|{
name|scriptPid
operator|.
name|waitFor
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|interruptedException
parameter_list|)
block|{         }
comment|// best effort attempt to write all output from the script before marking the operator
comment|// as done
try|try
block|{
if|if
condition|(
name|outThread
operator|!=
literal|null
condition|)
block|{
name|outThread
operator|.
name|join
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|Exception
name|e2
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Exception in closing outThread: "
operator|+
name|StringUtils
operator|.
name|stringifyException
argument_list|(
name|e2
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|setDone
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|warn
argument_list|(
literal|"Got broken pipe during write: ignoring exception and setting operator to done"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Error in writing to script: "
operator|+
name|e
operator|.
name|getMessage
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|isBrokenPipeException
argument_list|(
name|e
argument_list|)
condition|)
block|{
name|displayBrokenPipeInfo
argument_list|()
expr_stmt|;
block|}
name|scriptError
operator|=
name|e
expr_stmt|;
throw|throw
operator|new
name|HiveException
argument_list|(
name|ErrorMsg
operator|.
name|SCRIPT_IO_ERROR
operator|.
name|getErrorCodedMsg
argument_list|()
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
block|}
annotation|@
name|Override
specifier|public
name|void
name|close
parameter_list|(
name|boolean
name|abort
parameter_list|)
throws|throws
name|HiveException
block|{
name|boolean
name|new_abort
init|=
name|abort
decl_stmt|;
if|if
condition|(
operator|!
name|abort
condition|)
block|{
if|if
condition|(
name|scriptError
operator|!=
literal|null
condition|)
block|{
throw|throw
operator|new
name|HiveException
argument_list|(
name|ErrorMsg
operator|.
name|SCRIPT_GENERIC_ERROR
operator|.
name|getErrorCodedMsg
argument_list|()
argument_list|,
name|scriptError
argument_list|)
throw|;
block|}
comment|// everything ok. try normal shutdown
try|try
block|{
try|try
block|{
if|if
condition|(
name|scriptOutWriter
operator|!=
literal|null
condition|)
block|{
name|scriptOutWriter
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
if|if
condition|(
name|isBrokenPipeException
argument_list|(
name|e
argument_list|)
operator|&&
name|allowPartialConsumption
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Got broken pipe: ignoring exception"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|isBrokenPipeException
argument_list|(
name|e
argument_list|)
condition|)
block|{
name|displayBrokenPipeInfo
argument_list|()
expr_stmt|;
block|}
throw|throw
name|e
throw|;
block|}
block|}
name|int
name|exitVal
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|scriptPid
operator|!=
literal|null
condition|)
block|{
name|exitVal
operator|=
name|scriptPid
operator|.
name|waitFor
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|exitVal
operator|!=
literal|0
condition|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Script failed with code "
operator|+
name|exitVal
argument_list|)
expr_stmt|;
name|new_abort
operator|=
literal|true
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Got ioexception: "
operator|+
name|e
operator|.
name|getMessage
argument_list|()
argument_list|)
expr_stmt|;
name|e
operator|.
name|printStackTrace
argument_list|()
expr_stmt|;
name|new_abort
operator|=
literal|true
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{       }
block|}
else|else
block|{
comment|// Error already occurred, but we still want to get the
comment|// error code of the child process if possible.
try|try
block|{
comment|// Interrupt the current thread after 1 second
specifier|final
name|Thread
name|mythread
init|=
name|Thread
operator|.
name|currentThread
argument_list|()
decl_stmt|;
name|Timer
name|timer
init|=
operator|new
name|Timer
argument_list|(
literal|true
argument_list|)
decl_stmt|;
name|timer
operator|.
name|schedule
argument_list|(
operator|new
name|TimerTask
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|void
name|run
parameter_list|()
block|{
name|mythread
operator|.
name|interrupt
argument_list|()
expr_stmt|;
block|}
block|}
argument_list|,
literal|1000
argument_list|)
expr_stmt|;
comment|// Wait for the child process to finish
name|int
name|exitVal
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|scriptPid
operator|!=
literal|null
condition|)
block|{
name|scriptPid
operator|.
name|waitFor
argument_list|()
expr_stmt|;
block|}
comment|// Cancel the timer
name|timer
operator|.
name|cancel
argument_list|()
expr_stmt|;
comment|// Output the exit code
name|LOG
operator|.
name|error
argument_list|(
literal|"Script exited with code "
operator|+
name|exitVal
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
comment|// Ignore
name|LOG
operator|.
name|error
argument_list|(
literal|"Script has not exited yet. It will be killed."
argument_list|)
expr_stmt|;
block|}
block|}
comment|// try these best effort
try|try
block|{
if|if
condition|(
name|outThread
operator|!=
literal|null
condition|)
block|{
name|outThread
operator|.
name|join
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Exception in closing outThread: "
operator|+
name|StringUtils
operator|.
name|stringifyException
argument_list|(
name|e
argument_list|)
argument_list|)
expr_stmt|;
block|}
try|try
block|{
if|if
condition|(
name|errThread
operator|!=
literal|null
condition|)
block|{
name|errThread
operator|.
name|join
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Exception in closing errThread: "
operator|+
name|StringUtils
operator|.
name|stringifyException
argument_list|(
name|e
argument_list|)
argument_list|)
expr_stmt|;
block|}
try|try
block|{
if|if
condition|(
name|scriptPid
operator|!=
literal|null
condition|)
block|{
name|scriptPid
operator|.
name|destroy
argument_list|()
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Exception in destroying scriptPid: "
operator|+
name|StringUtils
operator|.
name|stringifyException
argument_list|(
name|e
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|super
operator|.
name|close
argument_list|(
name|new_abort
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_abort
operator|&&
operator|!
name|abort
condition|)
block|{
throw|throw
operator|new
name|HiveException
argument_list|(
name|ErrorMsg
operator|.
name|SCRIPT_CLOSING_ERROR
operator|.
name|getErrorCodedMsg
argument_list|()
argument_list|)
throw|;
block|}
block|}
interface|interface
name|StreamProcessor
block|{
name|void
name|processLine
parameter_list|(
name|Writable
name|line
parameter_list|)
throws|throws
name|HiveException
function_decl|;
name|void
name|close
parameter_list|()
throws|throws
name|HiveException
function_decl|;
block|}
class|class
name|OutputStreamProcessor
implements|implements
name|StreamProcessor
block|{
name|Object
name|row
decl_stmt|;
name|ObjectInspector
name|rowInspector
decl_stmt|;
specifier|public
name|OutputStreamProcessor
parameter_list|(
name|ObjectInspector
name|rowInspector
parameter_list|)
block|{
name|this
operator|.
name|rowInspector
operator|=
name|rowInspector
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|processLine
parameter_list|(
name|Writable
name|line
parameter_list|)
throws|throws
name|HiveException
block|{
try|try
block|{
name|row
operator|=
name|scriptOutputDeserializer
operator|.
name|deserialize
argument_list|(
name|line
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|SerDeException
name|e
parameter_list|)
block|{
name|deserialize_error_count
operator|.
name|set
argument_list|(
name|deserialize_error_count
operator|.
name|get
argument_list|()
operator|+
literal|1
argument_list|)
expr_stmt|;
return|return;
block|}
name|forward
argument_list|(
name|row
argument_list|,
name|rowInspector
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|close
parameter_list|()
block|{     }
block|}
class|class
name|CounterStatusProcessor
block|{
specifier|private
specifier|final
name|String
name|reporterPrefix
decl_stmt|;
specifier|private
specifier|final
name|String
name|counterPrefix
decl_stmt|;
specifier|private
specifier|final
name|String
name|statusPrefix
decl_stmt|;
specifier|private
specifier|final
name|Reporter
name|reporter
decl_stmt|;
name|CounterStatusProcessor
parameter_list|(
name|Configuration
name|hconf
parameter_list|,
name|Reporter
name|reporter
parameter_list|)
block|{
name|this
operator|.
name|reporterPrefix
operator|=
name|HiveConf
operator|.
name|getVar
argument_list|(
name|hconf
argument_list|,
name|HiveConf
operator|.
name|ConfVars
operator|.
name|STREAMREPORTERPERFIX
argument_list|)
expr_stmt|;
name|this
operator|.
name|counterPrefix
operator|=
name|reporterPrefix
operator|+
literal|"counter:"
expr_stmt|;
name|this
operator|.
name|statusPrefix
operator|=
name|reporterPrefix
operator|+
literal|"status:"
expr_stmt|;
name|this
operator|.
name|reporter
operator|=
name|reporter
expr_stmt|;
block|}
specifier|private
name|boolean
name|process
parameter_list|(
name|String
name|line
parameter_list|)
block|{
if|if
condition|(
name|line
operator|.
name|startsWith
argument_list|(
name|reporterPrefix
argument_list|)
condition|)
block|{
if|if
condition|(
name|line
operator|.
name|startsWith
argument_list|(
name|counterPrefix
argument_list|)
condition|)
block|{
name|incrCounter
argument_list|(
name|line
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|line
operator|.
name|startsWith
argument_list|(
name|statusPrefix
argument_list|)
condition|)
block|{
name|setStatus
argument_list|(
name|line
argument_list|)
expr_stmt|;
block|}
return|return
literal|true
return|;
block|}
else|else
block|{
return|return
literal|false
return|;
block|}
block|}
specifier|private
name|void
name|incrCounter
parameter_list|(
name|String
name|line
parameter_list|)
block|{
name|String
name|trimmedLine
init|=
name|line
operator|.
name|substring
argument_list|(
name|counterPrefix
operator|.
name|length
argument_list|()
argument_list|)
operator|.
name|trim
argument_list|()
decl_stmt|;
name|String
index|[]
name|columns
init|=
name|trimmedLine
operator|.
name|split
argument_list|(
literal|","
argument_list|)
decl_stmt|;
if|if
condition|(
name|columns
operator|.
name|length
operator|==
literal|3
condition|)
block|{
try|try
block|{
name|reporter
operator|.
name|incrCounter
argument_list|(
name|columns
index|[
literal|0
index|]
argument_list|,
name|columns
index|[
literal|1
index|]
argument_list|,
name|Long
operator|.
name|parseLong
argument_list|(
name|columns
index|[
literal|2
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|NumberFormatException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Cannot parse counter increment '"
operator|+
name|columns
index|[
literal|2
index|]
operator|+
literal|"' from line "
operator|+
name|line
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Cannot parse counter line: "
operator|+
name|line
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|setStatus
parameter_list|(
name|String
name|line
parameter_list|)
block|{
name|reporter
operator|.
name|setStatus
argument_list|(
name|line
operator|.
name|substring
argument_list|(
name|statusPrefix
operator|.
name|length
argument_list|()
argument_list|)
operator|.
name|trim
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * The processor for stderr stream.    */
class|class
name|ErrorStreamProcessor
implements|implements
name|StreamProcessor
block|{
specifier|private
name|long
name|bytesCopied
init|=
literal|0
decl_stmt|;
specifier|private
specifier|final
name|long
name|maxBytes
decl_stmt|;
specifier|private
name|long
name|lastReportTime
decl_stmt|;
specifier|private
name|CounterStatusProcessor
name|counterStatus
decl_stmt|;
specifier|public
name|ErrorStreamProcessor
parameter_list|(
name|int
name|maxBytes
parameter_list|)
block|{
name|this
operator|.
name|maxBytes
operator|=
name|maxBytes
expr_stmt|;
name|lastReportTime
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|HiveConf
operator|.
name|getBoolVar
argument_list|(
name|hconf
argument_list|,
name|HiveConf
operator|.
name|ConfVars
operator|.
name|STREAMREPORTERENABLED
argument_list|)
condition|)
block|{
name|counterStatus
operator|=
operator|new
name|CounterStatusProcessor
argument_list|(
name|hconf
argument_list|,
name|reporter
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|void
name|processLine
parameter_list|(
name|Writable
name|line
parameter_list|)
throws|throws
name|HiveException
block|{
name|String
name|stringLine
init|=
name|line
operator|.
name|toString
argument_list|()
decl_stmt|;
name|int
name|len
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|line
operator|instanceof
name|Text
condition|)
block|{
name|len
operator|=
operator|(
operator|(
name|Text
operator|)
name|line
operator|)
operator|.
name|getLength
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|line
operator|instanceof
name|BytesWritable
condition|)
block|{
name|len
operator|=
operator|(
operator|(
name|BytesWritable
operator|)
name|line
operator|)
operator|.
name|getSize
argument_list|()
expr_stmt|;
block|}
comment|// Report progress for each stderr line, but no more frequently than once
comment|// per minute.
name|long
name|now
init|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
decl_stmt|;
comment|// reporter is a member variable of the Operator class.
if|if
condition|(
name|now
operator|-
name|lastReportTime
operator|>
literal|60
operator|*
literal|1000
operator|&&
name|reporter
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isInfoEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"ErrorStreamProcessor calling reporter.progress()"
argument_list|)
expr_stmt|;
block|}
name|lastReportTime
operator|=
name|now
expr_stmt|;
name|reporter
operator|.
name|progress
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|reporter
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|counterStatus
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|counterStatus
operator|.
name|process
argument_list|(
name|stringLine
argument_list|)
condition|)
block|{
return|return;
block|}
block|}
block|}
if|if
condition|(
operator|(
name|maxBytes
operator|<
literal|0
operator|)
operator|||
operator|(
name|bytesCopied
operator|<
name|maxBytes
operator|)
condition|)
block|{
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
name|stringLine
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|bytesCopied
operator|<
name|maxBytes
operator|&&
name|bytesCopied
operator|+
name|len
operator|>=
name|maxBytes
condition|)
block|{
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"Operator "
operator|+
name|id
operator|+
literal|" "
operator|+
name|getName
argument_list|()
operator|+
literal|": exceeding stderr limit of "
operator|+
name|maxBytes
operator|+
literal|" bytes, will truncate stderr messages."
argument_list|)
expr_stmt|;
block|}
name|bytesCopied
operator|+=
name|len
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|close
parameter_list|()
block|{     }
block|}
class|class
name|StreamThread
extends|extends
name|Thread
block|{
name|RecordReader
name|in
decl_stmt|;
name|StreamProcessor
name|proc
decl_stmt|;
name|String
name|name
decl_stmt|;
name|StreamThread
parameter_list|(
name|RecordReader
name|in
parameter_list|,
name|StreamProcessor
name|proc
parameter_list|,
name|String
name|name
parameter_list|)
block|{
name|this
operator|.
name|in
operator|=
name|in
expr_stmt|;
name|this
operator|.
name|proc
operator|=
name|proc
expr_stmt|;
name|this
operator|.
name|name
operator|=
name|name
expr_stmt|;
name|setDaemon
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|run
parameter_list|()
block|{
try|try
block|{
name|Writable
name|row
init|=
name|in
operator|.
name|createRow
argument_list|()
decl_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
name|long
name|bytes
init|=
name|in
operator|.
name|next
argument_list|(
name|row
argument_list|)
decl_stmt|;
if|if
condition|(
name|bytes
operator|<=
literal|0
condition|)
block|{
break|break;
block|}
name|proc
operator|.
name|processLine
argument_list|(
name|row
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|LOG
operator|.
name|isInfoEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"StreamThread "
operator|+
name|name
operator|+
literal|" done"
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|Throwable
name|th
parameter_list|)
block|{
name|scriptError
operator|=
name|th
expr_stmt|;
name|LOG
operator|.
name|warn
argument_list|(
literal|"Exception in StreamThread.run(): "
operator|+
name|th
operator|.
name|getMessage
argument_list|()
operator|+
literal|"\nCause: "
operator|+
name|th
operator|.
name|getCause
argument_list|()
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|warn
argument_list|(
name|StringUtils
operator|.
name|stringifyException
argument_list|(
name|th
argument_list|)
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
try|try
block|{
if|if
condition|(
name|in
operator|!=
literal|null
condition|)
block|{
name|in
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
name|name
operator|+
literal|": error in closing .."
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|warn
argument_list|(
name|StringUtils
operator|.
name|stringifyException
argument_list|(
name|e
argument_list|)
argument_list|)
expr_stmt|;
block|}
try|try
block|{
if|if
condition|(
literal|null
operator|!=
name|proc
condition|)
block|{
name|proc
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|": error in closing .."
operator|+
name|StringUtils
operator|.
name|stringifyException
argument_list|(
name|e
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/**    * Wrap the script in a wrapper that allows admins to control.    */
specifier|protected
name|String
index|[]
name|addWrapper
parameter_list|(
name|String
index|[]
name|inArgs
parameter_list|)
block|{
name|String
name|wrapper
init|=
name|HiveConf
operator|.
name|getVar
argument_list|(
name|hconf
argument_list|,
name|HiveConf
operator|.
name|ConfVars
operator|.
name|SCRIPTWRAPPER
argument_list|)
decl_stmt|;
if|if
condition|(
name|wrapper
operator|==
literal|null
condition|)
block|{
return|return
name|inArgs
return|;
block|}
name|String
index|[]
name|wrapComponents
init|=
name|splitArgs
argument_list|(
name|wrapper
argument_list|)
decl_stmt|;
name|int
name|totallength
init|=
name|wrapComponents
operator|.
name|length
operator|+
name|inArgs
operator|.
name|length
decl_stmt|;
name|String
index|[]
name|finalArgv
init|=
operator|new
name|String
index|[
name|totallength
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|wrapComponents
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|finalArgv
index|[
name|i
index|]
operator|=
name|wrapComponents
index|[
name|i
index|]
expr_stmt|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|inArgs
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|finalArgv
index|[
name|wrapComponents
operator|.
name|length
operator|+
name|i
index|]
operator|=
name|inArgs
index|[
name|i
index|]
expr_stmt|;
block|}
return|return
name|finalArgv
return|;
block|}
comment|// Code below shameless borrowed from Hadoop Streaming
specifier|public
specifier|static
name|String
index|[]
name|splitArgs
parameter_list|(
name|String
name|args
parameter_list|)
block|{
specifier|final
name|int
name|OUTSIDE
init|=
literal|1
decl_stmt|;
specifier|final
name|int
name|SINGLEQ
init|=
literal|2
decl_stmt|;
specifier|final
name|int
name|DOUBLEQ
init|=
literal|3
decl_stmt|;
name|ArrayList
name|argList
init|=
operator|new
name|ArrayList
argument_list|()
decl_stmt|;
name|char
index|[]
name|ch
init|=
name|args
operator|.
name|toCharArray
argument_list|()
decl_stmt|;
name|int
name|clen
init|=
name|ch
operator|.
name|length
decl_stmt|;
name|int
name|state
init|=
name|OUTSIDE
decl_stmt|;
name|int
name|argstart
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|c
init|=
literal|0
init|;
name|c
operator|<=
name|clen
condition|;
name|c
operator|++
control|)
block|{
name|boolean
name|last
init|=
operator|(
name|c
operator|==
name|clen
operator|)
decl_stmt|;
name|int
name|lastState
init|=
name|state
decl_stmt|;
name|boolean
name|endToken
init|=
literal|false
decl_stmt|;
if|if
condition|(
operator|!
name|last
condition|)
block|{
if|if
condition|(
name|ch
index|[
name|c
index|]
operator|==
literal|'\''
condition|)
block|{
if|if
condition|(
name|state
operator|==
name|OUTSIDE
condition|)
block|{
name|state
operator|=
name|SINGLEQ
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|state
operator|==
name|SINGLEQ
condition|)
block|{
name|state
operator|=
name|OUTSIDE
expr_stmt|;
block|}
name|endToken
operator|=
operator|(
name|state
operator|!=
name|lastState
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ch
index|[
name|c
index|]
operator|==
literal|'"'
condition|)
block|{
if|if
condition|(
name|state
operator|==
name|OUTSIDE
condition|)
block|{
name|state
operator|=
name|DOUBLEQ
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|state
operator|==
name|DOUBLEQ
condition|)
block|{
name|state
operator|=
name|OUTSIDE
expr_stmt|;
block|}
name|endToken
operator|=
operator|(
name|state
operator|!=
name|lastState
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ch
index|[
name|c
index|]
operator|==
literal|' '
condition|)
block|{
if|if
condition|(
name|state
operator|==
name|OUTSIDE
condition|)
block|{
name|endToken
operator|=
literal|true
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|last
operator|||
name|endToken
condition|)
block|{
if|if
condition|(
name|c
operator|==
name|argstart
condition|)
block|{
comment|// unquoted space
block|}
else|else
block|{
name|String
name|a
decl_stmt|;
name|a
operator|=
name|args
operator|.
name|substring
argument_list|(
name|argstart
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|argList
operator|.
name|add
argument_list|(
name|a
argument_list|)
expr_stmt|;
block|}
name|argstart
operator|=
name|c
operator|+
literal|1
expr_stmt|;
name|lastState
operator|=
name|state
expr_stmt|;
block|}
block|}
return|return
operator|(
name|String
index|[]
operator|)
name|argList
operator|.
name|toArray
argument_list|(
operator|new
name|String
index|[
literal|0
index|]
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|getName
parameter_list|()
block|{
return|return
name|ScriptOperator
operator|.
name|getOperatorName
argument_list|()
return|;
block|}
specifier|static
specifier|public
name|String
name|getOperatorName
parameter_list|()
block|{
return|return
literal|"SCR"
return|;
block|}
annotation|@
name|Override
specifier|public
name|OperatorType
name|getType
parameter_list|()
block|{
return|return
name|OperatorType
operator|.
name|SCRIPT
return|;
block|}
block|}
end_class

end_unit

