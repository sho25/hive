begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|optimizer
operator|.
name|calcite
operator|.
name|translator
package|;
end_package

begin_import
import|import
name|java
operator|.
name|math
operator|.
name|BigDecimal
import|;
end_import

begin_import
import|import
name|java
operator|.
name|math
operator|.
name|BigInteger
import|;
end_import

begin_import
import|import
name|java
operator|.
name|sql
operator|.
name|Timestamp
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Calendar
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Date
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|GregorianCalendar
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|LinkedHashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|avatica
operator|.
name|util
operator|.
name|TimeUnit
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|avatica
operator|.
name|util
operator|.
name|TimeUnitRange
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|plan
operator|.
name|RelOptCluster
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|RelNode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|core
operator|.
name|CorrelationId
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|type
operator|.
name|RelDataType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|type
operator|.
name|RelDataTypeFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexBuilder
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexCall
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexNode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexSubQuery
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlCollation
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlIntervalQualifier
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlKind
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlOperator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|fun
operator|.
name|SqlCastFunction
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|fun
operator|.
name|SqlStdOperatorTable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|parser
operator|.
name|SqlParserPos
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|type
operator|.
name|SqlTypeName
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|ConversionUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|NlsString
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|common
operator|.
name|type
operator|.
name|Decimal128
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|common
operator|.
name|type
operator|.
name|HiveChar
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|common
operator|.
name|type
operator|.
name|HiveDecimal
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|common
operator|.
name|type
operator|.
name|HiveIntervalDayTime
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|common
operator|.
name|type
operator|.
name|HiveIntervalYearMonth
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|common
operator|.
name|type
operator|.
name|HiveVarchar
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|ErrorMsg
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|FunctionRegistry
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|optimizer
operator|.
name|calcite
operator|.
name|CalciteSemanticException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|optimizer
operator|.
name|calcite
operator|.
name|CalciteSemanticException
operator|.
name|UnsupportedFeature
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|optimizer
operator|.
name|calcite
operator|.
name|reloperators
operator|.
name|HiveExtractDate
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|optimizer
operator|.
name|calcite
operator|.
name|reloperators
operator|.
name|HiveFloorDate
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|parse
operator|.
name|ParseUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|parse
operator|.
name|RowResolver
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|parse
operator|.
name|SemanticException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|ExprNodeColumnDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|ExprNodeConstantDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|ExprNodeDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|ExprNodeDescUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|ExprNodeFieldDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|ExprNodeGenericFuncDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|ExprNodeSubQueryDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|udf
operator|.
name|generic
operator|.
name|GenericUDF
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|udf
operator|.
name|generic
operator|.
name|GenericUDFBaseBinary
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|udf
operator|.
name|generic
operator|.
name|GenericUDFBaseCompare
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|udf
operator|.
name|generic
operator|.
name|GenericUDFBridge
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|udf
operator|.
name|generic
operator|.
name|GenericUDFCase
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|udf
operator|.
name|generic
operator|.
name|GenericUDFTimestamp
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|udf
operator|.
name|generic
operator|.
name|GenericUDFToBinary
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|udf
operator|.
name|generic
operator|.
name|GenericUDFToChar
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|udf
operator|.
name|generic
operator|.
name|GenericUDFToDate
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|udf
operator|.
name|generic
operator|.
name|GenericUDFToDecimal
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|udf
operator|.
name|generic
operator|.
name|GenericUDFToUnixTimeStamp
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|udf
operator|.
name|generic
operator|.
name|GenericUDFToVarchar
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|udf
operator|.
name|generic
operator|.
name|GenericUDFUnixTimeStamp
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|udf
operator|.
name|generic
operator|.
name|GenericUDFWhen
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|objectinspector
operator|.
name|ConstantObjectInspector
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|objectinspector
operator|.
name|ObjectInspector
operator|.
name|Category
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|objectinspector
operator|.
name|ObjectInspectorUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|objectinspector
operator|.
name|PrimitiveObjectInspector
operator|.
name|PrimitiveCategory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|objectinspector
operator|.
name|primitive
operator|.
name|PrimitiveObjectInspectorUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|objectinspector
operator|.
name|primitive
operator|.
name|PrimitiveObjectInspectorUtils
operator|.
name|PrimitiveGrouping
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|typeinfo
operator|.
name|PrimitiveTypeInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|typeinfo
operator|.
name|TypeInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|typeinfo
operator|.
name|TypeInfoUtils
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|ImmutableList
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|ImmutableList
operator|.
name|Builder
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|ImmutableMap
import|;
end_import

begin_class
specifier|public
class|class
name|RexNodeConverter
block|{
specifier|private
specifier|static
class|class
name|InputCtx
block|{
specifier|private
specifier|final
name|RelDataType
name|calciteInpDataType
decl_stmt|;
specifier|private
specifier|final
name|ImmutableMap
argument_list|<
name|String
argument_list|,
name|Integer
argument_list|>
name|hiveNameToPosMap
decl_stmt|;
specifier|private
specifier|final
name|RowResolver
name|hiveRR
decl_stmt|;
specifier|private
specifier|final
name|int
name|offsetInCalciteSchema
decl_stmt|;
specifier|private
name|InputCtx
parameter_list|(
name|RelDataType
name|calciteInpDataType
parameter_list|,
name|ImmutableMap
argument_list|<
name|String
argument_list|,
name|Integer
argument_list|>
name|hiveNameToPosMap
parameter_list|,
name|RowResolver
name|hiveRR
parameter_list|,
name|int
name|offsetInCalciteSchema
parameter_list|)
block|{
name|this
operator|.
name|calciteInpDataType
operator|=
name|calciteInpDataType
expr_stmt|;
name|this
operator|.
name|hiveNameToPosMap
operator|=
name|hiveNameToPosMap
expr_stmt|;
name|this
operator|.
name|hiveRR
operator|=
name|hiveRR
expr_stmt|;
name|this
operator|.
name|offsetInCalciteSchema
operator|=
name|offsetInCalciteSchema
expr_stmt|;
block|}
block|}
empty_stmt|;
specifier|private
specifier|final
name|RelOptCluster
name|cluster
decl_stmt|;
specifier|private
specifier|final
name|ImmutableList
argument_list|<
name|InputCtx
argument_list|>
name|inputCtxs
decl_stmt|;
specifier|private
specifier|final
name|boolean
name|flattenExpr
decl_stmt|;
comment|//outerRR belongs to outer query and is required to resolve correlated references
specifier|private
specifier|final
name|RowResolver
name|outerRR
decl_stmt|;
specifier|private
specifier|final
name|ImmutableMap
argument_list|<
name|String
argument_list|,
name|Integer
argument_list|>
name|outerNameToPosMap
decl_stmt|;
specifier|private
name|int
name|correlatedId
decl_stmt|;
comment|//Constructor used by HiveRexExecutorImpl
specifier|public
name|RexNodeConverter
parameter_list|(
name|RelOptCluster
name|cluster
parameter_list|)
block|{
name|this
argument_list|(
name|cluster
argument_list|,
operator|new
name|ArrayList
argument_list|<
name|InputCtx
argument_list|>
argument_list|()
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
comment|//subqueries will need outer query's row resolver
specifier|public
name|RexNodeConverter
parameter_list|(
name|RelOptCluster
name|cluster
parameter_list|,
name|RelDataType
name|inpDataType
parameter_list|,
name|ImmutableMap
argument_list|<
name|String
argument_list|,
name|Integer
argument_list|>
name|outerNameToPosMap
parameter_list|,
name|ImmutableMap
argument_list|<
name|String
argument_list|,
name|Integer
argument_list|>
name|nameToPosMap
parameter_list|,
name|RowResolver
name|hiveRR
parameter_list|,
name|RowResolver
name|outerRR
parameter_list|,
name|int
name|offset
parameter_list|,
name|boolean
name|flattenExpr
parameter_list|,
name|int
name|correlatedId
parameter_list|)
block|{
name|this
operator|.
name|cluster
operator|=
name|cluster
expr_stmt|;
name|this
operator|.
name|inputCtxs
operator|=
name|ImmutableList
operator|.
name|of
argument_list|(
operator|new
name|InputCtx
argument_list|(
name|inpDataType
argument_list|,
name|nameToPosMap
argument_list|,
name|hiveRR
argument_list|,
name|offset
argument_list|)
argument_list|)
expr_stmt|;
name|this
operator|.
name|flattenExpr
operator|=
name|flattenExpr
expr_stmt|;
name|this
operator|.
name|outerRR
operator|=
name|outerRR
expr_stmt|;
name|this
operator|.
name|outerNameToPosMap
operator|=
name|outerNameToPosMap
expr_stmt|;
name|this
operator|.
name|correlatedId
operator|=
name|correlatedId
expr_stmt|;
block|}
specifier|public
name|RexNodeConverter
parameter_list|(
name|RelOptCluster
name|cluster
parameter_list|,
name|RelDataType
name|inpDataType
parameter_list|,
name|ImmutableMap
argument_list|<
name|String
argument_list|,
name|Integer
argument_list|>
name|nameToPosMap
parameter_list|,
name|int
name|offset
parameter_list|,
name|boolean
name|flattenExpr
parameter_list|)
block|{
name|this
operator|.
name|cluster
operator|=
name|cluster
expr_stmt|;
name|this
operator|.
name|inputCtxs
operator|=
name|ImmutableList
operator|.
name|of
argument_list|(
operator|new
name|InputCtx
argument_list|(
name|inpDataType
argument_list|,
name|nameToPosMap
argument_list|,
literal|null
argument_list|,
name|offset
argument_list|)
argument_list|)
expr_stmt|;
name|this
operator|.
name|flattenExpr
operator|=
name|flattenExpr
expr_stmt|;
name|this
operator|.
name|outerRR
operator|=
literal|null
expr_stmt|;
name|this
operator|.
name|outerNameToPosMap
operator|=
literal|null
expr_stmt|;
block|}
specifier|public
name|RexNodeConverter
parameter_list|(
name|RelOptCluster
name|cluster
parameter_list|,
name|List
argument_list|<
name|InputCtx
argument_list|>
name|inpCtxLst
parameter_list|,
name|boolean
name|flattenExpr
parameter_list|)
block|{
name|this
operator|.
name|cluster
operator|=
name|cluster
expr_stmt|;
name|this
operator|.
name|inputCtxs
operator|=
name|ImmutableList
operator|.
expr|<
name|InputCtx
operator|>
name|builder
argument_list|()
operator|.
name|addAll
argument_list|(
name|inpCtxLst
argument_list|)
operator|.
name|build
argument_list|()
expr_stmt|;
name|this
operator|.
name|flattenExpr
operator|=
name|flattenExpr
expr_stmt|;
name|this
operator|.
name|outerRR
operator|=
literal|null
expr_stmt|;
name|this
operator|.
name|outerNameToPosMap
operator|=
literal|null
expr_stmt|;
block|}
specifier|public
name|RexNode
name|convert
parameter_list|(
name|ExprNodeDesc
name|expr
parameter_list|)
throws|throws
name|SemanticException
block|{
if|if
condition|(
name|expr
operator|instanceof
name|ExprNodeGenericFuncDesc
condition|)
block|{
return|return
name|convert
argument_list|(
operator|(
name|ExprNodeGenericFuncDesc
operator|)
name|expr
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|expr
operator|instanceof
name|ExprNodeConstantDesc
condition|)
block|{
return|return
name|convert
argument_list|(
operator|(
name|ExprNodeConstantDesc
operator|)
name|expr
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|expr
operator|instanceof
name|ExprNodeColumnDesc
condition|)
block|{
return|return
name|convert
argument_list|(
operator|(
name|ExprNodeColumnDesc
operator|)
name|expr
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|expr
operator|instanceof
name|ExprNodeFieldDesc
condition|)
block|{
return|return
name|convert
argument_list|(
operator|(
name|ExprNodeFieldDesc
operator|)
name|expr
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|expr
operator|instanceof
name|ExprNodeSubQueryDesc
condition|)
block|{
return|return
name|convert
argument_list|(
operator|(
name|ExprNodeSubQueryDesc
operator|)
name|expr
argument_list|)
return|;
block|}
else|else
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Unsupported Expression"
argument_list|)
throw|;
block|}
comment|// TODO: handle ExprNodeColumnListDesc
block|}
specifier|private
name|RexNode
name|convert
parameter_list|(
specifier|final
name|ExprNodeSubQueryDesc
name|subQueryDesc
parameter_list|)
throws|throws
name|SemanticException
block|{
if|if
condition|(
name|subQueryDesc
operator|.
name|getType
argument_list|()
operator|==
name|ExprNodeSubQueryDesc
operator|.
name|SubqueryType
operator|.
name|IN
condition|)
block|{
comment|/*       * Check.5.h :: For In and Not In the SubQuery must implicitly or       * explicitly only contain one select item.       */
if|if
condition|(
name|subQueryDesc
operator|.
name|getRexSubQuery
argument_list|()
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldCount
argument_list|()
operator|>
literal|1
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|INVALID_SUBQUERY_EXPRESSION
operator|.
name|getMsg
argument_list|(
literal|"SubQuery can contain only 1 item in Select List."
argument_list|)
argument_list|)
throw|;
block|}
comment|//create RexNode for LHS
name|RexNode
name|rexNodeLhs
init|=
name|convert
argument_list|(
name|subQueryDesc
operator|.
name|getSubQueryLhs
argument_list|()
argument_list|)
decl_stmt|;
comment|//create RexSubQuery node
name|RexNode
name|rexSubQuery
init|=
name|RexSubQuery
operator|.
name|in
argument_list|(
name|subQueryDesc
operator|.
name|getRexSubQuery
argument_list|()
argument_list|,
name|ImmutableList
operator|.
expr|<
name|RexNode
operator|>
name|of
argument_list|(
name|rexNodeLhs
argument_list|)
argument_list|)
decl_stmt|;
return|return
name|rexSubQuery
return|;
block|}
elseif|else
if|if
condition|(
name|subQueryDesc
operator|.
name|getType
argument_list|()
operator|==
name|ExprNodeSubQueryDesc
operator|.
name|SubqueryType
operator|.
name|EXISTS
condition|)
block|{
name|RexNode
name|subQueryNode
init|=
name|RexSubQuery
operator|.
name|exists
argument_list|(
name|subQueryDesc
operator|.
name|getRexSubQuery
argument_list|()
argument_list|)
decl_stmt|;
return|return
name|subQueryNode
return|;
block|}
else|else
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|INVALID_SUBQUERY_EXPRESSION
operator|.
name|getMsg
argument_list|(
literal|"Currently only IN and EXISTS type of subqueries are supported"
argument_list|)
argument_list|)
throw|;
block|}
block|}
specifier|private
name|RexNode
name|convert
parameter_list|(
specifier|final
name|ExprNodeFieldDesc
name|fieldDesc
parameter_list|)
throws|throws
name|SemanticException
block|{
name|RexNode
name|rexNode
init|=
name|convert
argument_list|(
name|fieldDesc
operator|.
name|getDesc
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|rexNode
operator|.
name|getType
argument_list|()
operator|.
name|isStruct
argument_list|()
condition|)
block|{
comment|// regular case of accessing nested field in a column
return|return
name|cluster
operator|.
name|getRexBuilder
argument_list|()
operator|.
name|makeFieldAccess
argument_list|(
name|rexNode
argument_list|,
name|fieldDesc
operator|.
name|getFieldName
argument_list|()
argument_list|,
literal|true
argument_list|)
return|;
block|}
else|else
block|{
comment|// This may happen for schema-less tables, where columns are dynamically
comment|// supplied by serdes.
throw|throw
operator|new
name|CalciteSemanticException
argument_list|(
literal|"Unexpected rexnode : "
operator|+
name|rexNode
operator|.
name|getClass
argument_list|()
operator|.
name|getCanonicalName
argument_list|()
argument_list|,
name|UnsupportedFeature
operator|.
name|Schema_less_table
argument_list|)
throw|;
block|}
block|}
specifier|private
name|RexNode
name|convert
parameter_list|(
name|ExprNodeGenericFuncDesc
name|func
parameter_list|)
throws|throws
name|SemanticException
block|{
name|ExprNodeDesc
name|tmpExprNode
decl_stmt|;
name|RexNode
name|tmpRN
decl_stmt|;
name|List
argument_list|<
name|RexNode
argument_list|>
name|childRexNodeLst
init|=
operator|new
name|ArrayList
argument_list|<
name|RexNode
argument_list|>
argument_list|()
decl_stmt|;
name|Builder
argument_list|<
name|RelDataType
argument_list|>
name|argTypeBldr
init|=
name|ImmutableList
operator|.
expr|<
name|RelDataType
operator|>
name|builder
argument_list|()
decl_stmt|;
comment|// TODO: 1) Expand to other functions as needed 2) What about types other than primitive.
name|TypeInfo
name|tgtDT
init|=
literal|null
decl_stmt|;
name|GenericUDF
name|tgtUdf
init|=
name|func
operator|.
name|getGenericUDF
argument_list|()
decl_stmt|;
name|boolean
name|isNumeric
init|=
operator|(
name|tgtUdf
operator|instanceof
name|GenericUDFBaseBinary
operator|&&
name|func
operator|.
name|getTypeInfo
argument_list|()
operator|.
name|getCategory
argument_list|()
operator|==
name|Category
operator|.
name|PRIMITIVE
operator|&&
operator|(
name|PrimitiveGrouping
operator|.
name|NUMERIC_GROUP
operator|==
name|PrimitiveObjectInspectorUtils
operator|.
name|getPrimitiveGrouping
argument_list|(
operator|(
operator|(
name|PrimitiveTypeInfo
operator|)
name|func
operator|.
name|getTypeInfo
argument_list|()
operator|)
operator|.
name|getPrimitiveCategory
argument_list|()
argument_list|)
operator|)
operator|)
decl_stmt|;
name|boolean
name|isCompare
init|=
operator|!
name|isNumeric
operator|&&
name|tgtUdf
operator|instanceof
name|GenericUDFBaseCompare
decl_stmt|;
name|boolean
name|isWhenCase
init|=
name|tgtUdf
operator|instanceof
name|GenericUDFWhen
operator|||
name|tgtUdf
operator|instanceof
name|GenericUDFCase
decl_stmt|;
name|boolean
name|isTransformableTimeStamp
init|=
name|func
operator|.
name|getGenericUDF
argument_list|()
operator|instanceof
name|GenericUDFUnixTimeStamp
operator|&&
name|func
operator|.
name|getChildren
argument_list|()
operator|.
name|size
argument_list|()
operator|!=
literal|0
decl_stmt|;
if|if
condition|(
name|isNumeric
condition|)
block|{
name|tgtDT
operator|=
name|func
operator|.
name|getTypeInfo
argument_list|()
expr_stmt|;
assert|assert
name|func
operator|.
name|getChildren
argument_list|()
operator|.
name|size
argument_list|()
operator|==
literal|2
assert|;
comment|// TODO: checking 2 children is useless, compare already does that.
block|}
elseif|else
if|if
condition|(
name|isCompare
operator|&&
operator|(
name|func
operator|.
name|getChildren
argument_list|()
operator|.
name|size
argument_list|()
operator|==
literal|2
operator|)
condition|)
block|{
name|tgtDT
operator|=
name|FunctionRegistry
operator|.
name|getCommonClassForComparison
argument_list|(
name|func
operator|.
name|getChildren
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|getTypeInfo
argument_list|()
argument_list|,
name|func
operator|.
name|getChildren
argument_list|()
operator|.
name|get
argument_list|(
literal|1
argument_list|)
operator|.
name|getTypeInfo
argument_list|()
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|isWhenCase
condition|)
block|{
comment|// If it is a CASE or WHEN, we need to check that children do not contain stateful functions
comment|// as they are not allowed
if|if
condition|(
name|checkForStatefulFunctions
argument_list|(
name|func
operator|.
name|getChildren
argument_list|()
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
literal|"Stateful expressions cannot be used inside of CASE"
argument_list|)
throw|;
block|}
block|}
elseif|else
if|if
condition|(
name|isTransformableTimeStamp
condition|)
block|{
comment|// unix_timestamp(args) -> to_unix_timestamp(args)
name|func
operator|=
name|ExprNodeGenericFuncDesc
operator|.
name|newInstance
argument_list|(
operator|new
name|GenericUDFToUnixTimeStamp
argument_list|()
argument_list|,
name|func
operator|.
name|getChildren
argument_list|()
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|ExprNodeDesc
name|childExpr
range|:
name|func
operator|.
name|getChildren
argument_list|()
control|)
block|{
name|tmpExprNode
operator|=
name|childExpr
expr_stmt|;
if|if
condition|(
name|tgtDT
operator|!=
literal|null
operator|&&
name|TypeInfoUtils
operator|.
name|isConversionRequiredForComparison
argument_list|(
name|tgtDT
argument_list|,
name|childExpr
operator|.
name|getTypeInfo
argument_list|()
argument_list|)
condition|)
block|{
if|if
condition|(
name|isCompare
condition|)
block|{
comment|// For compare, we will convert requisite children
name|tmpExprNode
operator|=
name|ParseUtils
operator|.
name|createConversionCast
argument_list|(
name|childExpr
argument_list|,
operator|(
name|PrimitiveTypeInfo
operator|)
name|tgtDT
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|isNumeric
condition|)
block|{
comment|// For numeric, we'll do minimum necessary cast - if we cast to the type
comment|// of expression, bad things will happen.
name|PrimitiveTypeInfo
name|minArgType
init|=
name|ExprNodeDescUtils
operator|.
name|deriveMinArgumentCast
argument_list|(
name|childExpr
argument_list|,
name|tgtDT
argument_list|)
decl_stmt|;
name|tmpExprNode
operator|=
name|ParseUtils
operator|.
name|createConversionCast
argument_list|(
name|childExpr
argument_list|,
name|minArgType
argument_list|)
expr_stmt|;
block|}
else|else
block|{
throw|throw
operator|new
name|AssertionError
argument_list|(
literal|"Unexpected "
operator|+
name|tgtDT
operator|+
literal|" - not a numeric op or compare"
argument_list|)
throw|;
block|}
block|}
name|argTypeBldr
operator|.
name|add
argument_list|(
name|TypeConverter
operator|.
name|convert
argument_list|(
name|tmpExprNode
operator|.
name|getTypeInfo
argument_list|()
argument_list|,
name|cluster
operator|.
name|getTypeFactory
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|tmpRN
operator|=
name|convert
argument_list|(
name|tmpExprNode
argument_list|)
expr_stmt|;
name|childRexNodeLst
operator|.
name|add
argument_list|(
name|tmpRN
argument_list|)
expr_stmt|;
block|}
comment|// See if this is an explicit cast.
name|RexNode
name|expr
init|=
literal|null
decl_stmt|;
name|RelDataType
name|retType
init|=
literal|null
decl_stmt|;
name|expr
operator|=
name|handleExplicitCast
argument_list|(
name|func
argument_list|,
name|childRexNodeLst
argument_list|)
expr_stmt|;
if|if
condition|(
name|expr
operator|==
literal|null
condition|)
block|{
comment|// This is not a cast; process the function.
name|retType
operator|=
name|TypeConverter
operator|.
name|convert
argument_list|(
name|func
operator|.
name|getTypeInfo
argument_list|()
argument_list|,
name|cluster
operator|.
name|getTypeFactory
argument_list|()
argument_list|)
expr_stmt|;
name|SqlOperator
name|calciteOp
init|=
name|SqlFunctionConverter
operator|.
name|getCalciteOperator
argument_list|(
name|func
operator|.
name|getFuncText
argument_list|()
argument_list|,
name|func
operator|.
name|getGenericUDF
argument_list|()
argument_list|,
name|argTypeBldr
operator|.
name|build
argument_list|()
argument_list|,
name|retType
argument_list|)
decl_stmt|;
if|if
condition|(
name|calciteOp
operator|.
name|getKind
argument_list|()
operator|==
name|SqlKind
operator|.
name|CASE
condition|)
block|{
comment|// If it is a case operator, we need to rewrite it
name|childRexNodeLst
operator|=
name|rewriteCaseChildren
argument_list|(
name|func
argument_list|,
name|childRexNodeLst
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|HiveExtractDate
operator|.
name|ALL_FUNCTIONS
operator|.
name|contains
argument_list|(
name|calciteOp
argument_list|)
condition|)
block|{
comment|// If it is a extract operator, we need to rewrite it
name|childRexNodeLst
operator|=
name|rewriteExtractDateChildren
argument_list|(
name|calciteOp
argument_list|,
name|childRexNodeLst
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|HiveFloorDate
operator|.
name|ALL_FUNCTIONS
operator|.
name|contains
argument_list|(
name|calciteOp
argument_list|)
condition|)
block|{
comment|// If it is a floor<date> operator, we need to rewrite it
name|childRexNodeLst
operator|=
name|rewriteFloorDateChildren
argument_list|(
name|calciteOp
argument_list|,
name|childRexNodeLst
argument_list|)
expr_stmt|;
block|}
name|expr
operator|=
name|cluster
operator|.
name|getRexBuilder
argument_list|()
operator|.
name|makeCall
argument_list|(
name|calciteOp
argument_list|,
name|childRexNodeLst
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|retType
operator|=
name|expr
operator|.
name|getType
argument_list|()
expr_stmt|;
block|}
comment|// TODO: Cast Function in Calcite have a bug where it infer type on cast throws
comment|// an exception
if|if
condition|(
name|flattenExpr
operator|&&
operator|(
name|expr
operator|instanceof
name|RexCall
operator|)
operator|&&
operator|!
operator|(
operator|(
operator|(
name|RexCall
operator|)
name|expr
operator|)
operator|.
name|getOperator
argument_list|()
operator|instanceof
name|SqlCastFunction
operator|)
condition|)
block|{
name|RexCall
name|call
init|=
operator|(
name|RexCall
operator|)
name|expr
decl_stmt|;
name|expr
operator|=
name|cluster
operator|.
name|getRexBuilder
argument_list|()
operator|.
name|makeCall
argument_list|(
name|retType
argument_list|,
name|call
operator|.
name|getOperator
argument_list|()
argument_list|,
name|RexUtil
operator|.
name|flatten
argument_list|(
name|call
operator|.
name|getOperands
argument_list|()
argument_list|,
name|call
operator|.
name|getOperator
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|expr
return|;
block|}
specifier|private
name|boolean
name|castExprUsingUDFBridge
parameter_list|(
name|GenericUDF
name|gUDF
parameter_list|)
block|{
name|boolean
name|castExpr
init|=
literal|false
decl_stmt|;
if|if
condition|(
name|gUDF
operator|!=
literal|null
operator|&&
name|gUDF
operator|instanceof
name|GenericUDFBridge
condition|)
block|{
name|String
name|udfClassName
init|=
operator|(
operator|(
name|GenericUDFBridge
operator|)
name|gUDF
operator|)
operator|.
name|getUdfClassName
argument_list|()
decl_stmt|;
if|if
condition|(
name|udfClassName
operator|!=
literal|null
condition|)
block|{
name|int
name|sp
init|=
name|udfClassName
operator|.
name|lastIndexOf
argument_list|(
literal|'.'
argument_list|)
decl_stmt|;
comment|// TODO: add method to UDFBridge to say if it is a cast func
if|if
condition|(
name|sp
operator|>=
literal|0
operator|&
operator|(
name|sp
operator|+
literal|1
operator|)
operator|<
name|udfClassName
operator|.
name|length
argument_list|()
condition|)
block|{
name|udfClassName
operator|=
name|udfClassName
operator|.
name|substring
argument_list|(
name|sp
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|udfClassName
operator|.
name|equals
argument_list|(
literal|"UDFToBoolean"
argument_list|)
operator|||
name|udfClassName
operator|.
name|equals
argument_list|(
literal|"UDFToByte"
argument_list|)
operator|||
name|udfClassName
operator|.
name|equals
argument_list|(
literal|"UDFToDouble"
argument_list|)
operator|||
name|udfClassName
operator|.
name|equals
argument_list|(
literal|"UDFToInteger"
argument_list|)
operator|||
name|udfClassName
operator|.
name|equals
argument_list|(
literal|"UDFToLong"
argument_list|)
operator|||
name|udfClassName
operator|.
name|equals
argument_list|(
literal|"UDFToShort"
argument_list|)
operator|||
name|udfClassName
operator|.
name|equals
argument_list|(
literal|"UDFToFloat"
argument_list|)
operator|||
name|udfClassName
operator|.
name|equals
argument_list|(
literal|"UDFToString"
argument_list|)
condition|)
name|castExpr
operator|=
literal|true
expr_stmt|;
block|}
block|}
block|}
return|return
name|castExpr
return|;
block|}
specifier|private
name|RexNode
name|handleExplicitCast
parameter_list|(
name|ExprNodeGenericFuncDesc
name|func
parameter_list|,
name|List
argument_list|<
name|RexNode
argument_list|>
name|childRexNodeLst
parameter_list|)
throws|throws
name|CalciteSemanticException
block|{
name|RexNode
name|castExpr
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|childRexNodeLst
operator|!=
literal|null
operator|&&
name|childRexNodeLst
operator|.
name|size
argument_list|()
operator|==
literal|1
condition|)
block|{
name|GenericUDF
name|udf
init|=
name|func
operator|.
name|getGenericUDF
argument_list|()
decl_stmt|;
if|if
condition|(
operator|(
name|udf
operator|instanceof
name|GenericUDFToChar
operator|)
operator|||
operator|(
name|udf
operator|instanceof
name|GenericUDFToVarchar
operator|)
operator|||
operator|(
name|udf
operator|instanceof
name|GenericUDFToDecimal
operator|)
operator|||
operator|(
name|udf
operator|instanceof
name|GenericUDFToDate
operator|)
comment|// Calcite can not specify the scale for timestamp. As a result, all
comment|// the millisecond part will be lost
operator|||
operator|(
name|udf
operator|instanceof
name|GenericUDFTimestamp
operator|)
operator|||
operator|(
name|udf
operator|instanceof
name|GenericUDFToBinary
operator|)
operator|||
name|castExprUsingUDFBridge
argument_list|(
name|udf
argument_list|)
condition|)
block|{
name|castExpr
operator|=
name|cluster
operator|.
name|getRexBuilder
argument_list|()
operator|.
name|makeAbstractCast
argument_list|(
name|TypeConverter
operator|.
name|convert
argument_list|(
name|func
operator|.
name|getTypeInfo
argument_list|()
argument_list|,
name|cluster
operator|.
name|getTypeFactory
argument_list|()
argument_list|)
argument_list|,
name|childRexNodeLst
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|castExpr
return|;
block|}
comment|/*    * Hive syntax allows to define CASE expressions in two ways:    * - CASE a WHEN b THEN c [WHEN d THEN e]* [ELSE f] END (translated into the    *   "case" function, ELSE clause is optional)    * - CASE WHEN a THEN b [WHEN c THEN d]* [ELSE e] END (translated into the    *   "when" function, ELSE clause is optional)    * However, Calcite only has the equivalent to the "when" Hive function. Thus,    * we need to transform the "case" function into "when". Further, ELSE clause is    * not optional in Calcite.    *    * Example. Consider the following statement:    * CASE x + y WHEN 1 THEN 'fee' WHEN 2 THEN 'fie' END    * It will be transformed into:    * CASE WHEN =(x + y, 1) THEN 'fee' WHEN =(x + y, 2) THEN 'fie' ELSE null END    */
specifier|private
name|List
argument_list|<
name|RexNode
argument_list|>
name|rewriteCaseChildren
parameter_list|(
name|ExprNodeGenericFuncDesc
name|func
parameter_list|,
name|List
argument_list|<
name|RexNode
argument_list|>
name|childRexNodeLst
parameter_list|)
throws|throws
name|SemanticException
block|{
name|List
argument_list|<
name|RexNode
argument_list|>
name|newChildRexNodeLst
init|=
operator|new
name|ArrayList
argument_list|<
name|RexNode
argument_list|>
argument_list|()
decl_stmt|;
if|if
condition|(
name|FunctionRegistry
operator|.
name|getNormalizedFunctionName
argument_list|(
name|func
operator|.
name|getFuncText
argument_list|()
argument_list|)
operator|.
name|equals
argument_list|(
literal|"case"
argument_list|)
condition|)
block|{
name|RexNode
name|firstPred
init|=
name|childRexNodeLst
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|int
name|length
init|=
name|childRexNodeLst
operator|.
name|size
argument_list|()
operator|%
literal|2
operator|==
literal|1
condition|?
name|childRexNodeLst
operator|.
name|size
argument_list|()
else|:
name|childRexNodeLst
operator|.
name|size
argument_list|()
operator|-
literal|1
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<
name|length
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|%
literal|2
operator|==
literal|1
condition|)
block|{
comment|// We rewrite it
name|newChildRexNodeLst
operator|.
name|add
argument_list|(
name|cluster
operator|.
name|getRexBuilder
argument_list|()
operator|.
name|makeCall
argument_list|(
name|SqlStdOperatorTable
operator|.
name|EQUALS
argument_list|,
name|firstPred
argument_list|,
name|childRexNodeLst
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|newChildRexNodeLst
operator|.
name|add
argument_list|(
name|childRexNodeLst
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|// The else clause
if|if
condition|(
name|length
operator|!=
name|childRexNodeLst
operator|.
name|size
argument_list|()
condition|)
block|{
name|newChildRexNodeLst
operator|.
name|add
argument_list|(
name|childRexNodeLst
operator|.
name|get
argument_list|(
name|childRexNodeLst
operator|.
name|size
argument_list|()
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|newChildRexNodeLst
operator|.
name|addAll
argument_list|(
name|childRexNodeLst
argument_list|)
expr_stmt|;
block|}
comment|// Calcite always needs the else clause to be defined explicitly
if|if
condition|(
name|newChildRexNodeLst
operator|.
name|size
argument_list|()
operator|%
literal|2
operator|==
literal|0
condition|)
block|{
name|newChildRexNodeLst
operator|.
name|add
argument_list|(
name|cluster
operator|.
name|getRexBuilder
argument_list|()
operator|.
name|makeNullLiteral
argument_list|(
name|newChildRexNodeLst
operator|.
name|get
argument_list|(
name|newChildRexNodeLst
operator|.
name|size
argument_list|()
operator|-
literal|1
argument_list|)
operator|.
name|getType
argument_list|()
operator|.
name|getSqlTypeName
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|newChildRexNodeLst
return|;
block|}
specifier|private
name|List
argument_list|<
name|RexNode
argument_list|>
name|rewriteExtractDateChildren
parameter_list|(
name|SqlOperator
name|op
parameter_list|,
name|List
argument_list|<
name|RexNode
argument_list|>
name|childRexNodeLst
parameter_list|)
throws|throws
name|SemanticException
block|{
name|List
argument_list|<
name|RexNode
argument_list|>
name|newChildRexNodeLst
init|=
operator|new
name|ArrayList
argument_list|<
name|RexNode
argument_list|>
argument_list|()
decl_stmt|;
if|if
condition|(
name|op
operator|==
name|HiveExtractDate
operator|.
name|YEAR
condition|)
block|{
name|newChildRexNodeLst
operator|.
name|add
argument_list|(
name|cluster
operator|.
name|getRexBuilder
argument_list|()
operator|.
name|makeFlag
argument_list|(
name|TimeUnitRange
operator|.
name|YEAR
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|op
operator|==
name|HiveExtractDate
operator|.
name|QUARTER
condition|)
block|{
name|newChildRexNodeLst
operator|.
name|add
argument_list|(
name|cluster
operator|.
name|getRexBuilder
argument_list|()
operator|.
name|makeFlag
argument_list|(
name|TimeUnitRange
operator|.
name|QUARTER
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|op
operator|==
name|HiveExtractDate
operator|.
name|MONTH
condition|)
block|{
name|newChildRexNodeLst
operator|.
name|add
argument_list|(
name|cluster
operator|.
name|getRexBuilder
argument_list|()
operator|.
name|makeFlag
argument_list|(
name|TimeUnitRange
operator|.
name|MONTH
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|op
operator|==
name|HiveExtractDate
operator|.
name|WEEK
condition|)
block|{
name|newChildRexNodeLst
operator|.
name|add
argument_list|(
name|cluster
operator|.
name|getRexBuilder
argument_list|()
operator|.
name|makeFlag
argument_list|(
name|TimeUnitRange
operator|.
name|WEEK
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|op
operator|==
name|HiveExtractDate
operator|.
name|DAY
condition|)
block|{
name|newChildRexNodeLst
operator|.
name|add
argument_list|(
name|cluster
operator|.
name|getRexBuilder
argument_list|()
operator|.
name|makeFlag
argument_list|(
name|TimeUnitRange
operator|.
name|DAY
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|op
operator|==
name|HiveExtractDate
operator|.
name|HOUR
condition|)
block|{
name|newChildRexNodeLst
operator|.
name|add
argument_list|(
name|cluster
operator|.
name|getRexBuilder
argument_list|()
operator|.
name|makeFlag
argument_list|(
name|TimeUnitRange
operator|.
name|HOUR
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|op
operator|==
name|HiveExtractDate
operator|.
name|MINUTE
condition|)
block|{
name|newChildRexNodeLst
operator|.
name|add
argument_list|(
name|cluster
operator|.
name|getRexBuilder
argument_list|()
operator|.
name|makeFlag
argument_list|(
name|TimeUnitRange
operator|.
name|MINUTE
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|op
operator|==
name|HiveExtractDate
operator|.
name|SECOND
condition|)
block|{
name|newChildRexNodeLst
operator|.
name|add
argument_list|(
name|cluster
operator|.
name|getRexBuilder
argument_list|()
operator|.
name|makeFlag
argument_list|(
name|TimeUnitRange
operator|.
name|SECOND
argument_list|)
argument_list|)
expr_stmt|;
block|}
assert|assert
name|childRexNodeLst
operator|.
name|size
argument_list|()
operator|==
literal|1
assert|;
name|newChildRexNodeLst
operator|.
name|add
argument_list|(
name|childRexNodeLst
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|newChildRexNodeLst
return|;
block|}
specifier|private
name|List
argument_list|<
name|RexNode
argument_list|>
name|rewriteFloorDateChildren
parameter_list|(
name|SqlOperator
name|op
parameter_list|,
name|List
argument_list|<
name|RexNode
argument_list|>
name|childRexNodeLst
parameter_list|)
throws|throws
name|SemanticException
block|{
name|List
argument_list|<
name|RexNode
argument_list|>
name|newChildRexNodeLst
init|=
operator|new
name|ArrayList
argument_list|<
name|RexNode
argument_list|>
argument_list|()
decl_stmt|;
assert|assert
name|childRexNodeLst
operator|.
name|size
argument_list|()
operator|==
literal|1
assert|;
name|newChildRexNodeLst
operator|.
name|add
argument_list|(
name|childRexNodeLst
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|op
operator|==
name|HiveFloorDate
operator|.
name|YEAR
condition|)
block|{
name|newChildRexNodeLst
operator|.
name|add
argument_list|(
name|cluster
operator|.
name|getRexBuilder
argument_list|()
operator|.
name|makeFlag
argument_list|(
name|TimeUnitRange
operator|.
name|YEAR
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|op
operator|==
name|HiveFloorDate
operator|.
name|QUARTER
condition|)
block|{
name|newChildRexNodeLst
operator|.
name|add
argument_list|(
name|cluster
operator|.
name|getRexBuilder
argument_list|()
operator|.
name|makeFlag
argument_list|(
name|TimeUnitRange
operator|.
name|QUARTER
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|op
operator|==
name|HiveFloorDate
operator|.
name|MONTH
condition|)
block|{
name|newChildRexNodeLst
operator|.
name|add
argument_list|(
name|cluster
operator|.
name|getRexBuilder
argument_list|()
operator|.
name|makeFlag
argument_list|(
name|TimeUnitRange
operator|.
name|MONTH
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|op
operator|==
name|HiveFloorDate
operator|.
name|WEEK
condition|)
block|{
name|newChildRexNodeLst
operator|.
name|add
argument_list|(
name|cluster
operator|.
name|getRexBuilder
argument_list|()
operator|.
name|makeFlag
argument_list|(
name|TimeUnitRange
operator|.
name|WEEK
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|op
operator|==
name|HiveFloorDate
operator|.
name|DAY
condition|)
block|{
name|newChildRexNodeLst
operator|.
name|add
argument_list|(
name|cluster
operator|.
name|getRexBuilder
argument_list|()
operator|.
name|makeFlag
argument_list|(
name|TimeUnitRange
operator|.
name|DAY
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|op
operator|==
name|HiveFloorDate
operator|.
name|HOUR
condition|)
block|{
name|newChildRexNodeLst
operator|.
name|add
argument_list|(
name|cluster
operator|.
name|getRexBuilder
argument_list|()
operator|.
name|makeFlag
argument_list|(
name|TimeUnitRange
operator|.
name|HOUR
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|op
operator|==
name|HiveFloorDate
operator|.
name|MINUTE
condition|)
block|{
name|newChildRexNodeLst
operator|.
name|add
argument_list|(
name|cluster
operator|.
name|getRexBuilder
argument_list|()
operator|.
name|makeFlag
argument_list|(
name|TimeUnitRange
operator|.
name|MINUTE
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|op
operator|==
name|HiveFloorDate
operator|.
name|SECOND
condition|)
block|{
name|newChildRexNodeLst
operator|.
name|add
argument_list|(
name|cluster
operator|.
name|getRexBuilder
argument_list|()
operator|.
name|makeFlag
argument_list|(
name|TimeUnitRange
operator|.
name|SECOND
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|newChildRexNodeLst
return|;
block|}
specifier|private
specifier|static
name|boolean
name|checkForStatefulFunctions
parameter_list|(
name|List
argument_list|<
name|ExprNodeDesc
argument_list|>
name|list
parameter_list|)
block|{
for|for
control|(
name|ExprNodeDesc
name|node
range|:
name|list
control|)
block|{
if|if
condition|(
name|node
operator|instanceof
name|ExprNodeGenericFuncDesc
condition|)
block|{
name|GenericUDF
name|nodeUDF
init|=
operator|(
operator|(
name|ExprNodeGenericFuncDesc
operator|)
name|node
operator|)
operator|.
name|getGenericUDF
argument_list|()
decl_stmt|;
comment|// Stateful?
if|if
condition|(
name|FunctionRegistry
operator|.
name|isStateful
argument_list|(
name|nodeUDF
argument_list|)
condition|)
block|{
return|return
literal|true
return|;
block|}
if|if
condition|(
name|node
operator|.
name|getChildren
argument_list|()
operator|!=
literal|null
operator|&&
operator|!
name|node
operator|.
name|getChildren
argument_list|()
operator|.
name|isEmpty
argument_list|()
operator|&&
name|checkForStatefulFunctions
argument_list|(
name|node
operator|.
name|getChildren
argument_list|()
argument_list|)
condition|)
block|{
return|return
literal|true
return|;
block|}
block|}
block|}
return|return
literal|false
return|;
block|}
specifier|private
name|InputCtx
name|getInputCtx
parameter_list|(
name|ExprNodeColumnDesc
name|col
parameter_list|)
throws|throws
name|SemanticException
block|{
name|InputCtx
name|ctxLookingFor
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|inputCtxs
operator|.
name|size
argument_list|()
operator|==
literal|1
operator|&&
name|inputCtxs
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|hiveRR
operator|==
literal|null
condition|)
block|{
name|ctxLookingFor
operator|=
name|inputCtxs
operator|.
name|get
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|String
name|tableAlias
init|=
name|col
operator|.
name|getTabAlias
argument_list|()
decl_stmt|;
name|String
name|colAlias
init|=
name|col
operator|.
name|getColumn
argument_list|()
decl_stmt|;
name|int
name|noInp
init|=
literal|0
decl_stmt|;
for|for
control|(
name|InputCtx
name|ic
range|:
name|inputCtxs
control|)
block|{
if|if
condition|(
name|tableAlias
operator|==
literal|null
operator|||
name|ic
operator|.
name|hiveRR
operator|.
name|hasTableAlias
argument_list|(
name|tableAlias
argument_list|)
condition|)
block|{
if|if
condition|(
name|ic
operator|.
name|hiveRR
operator|.
name|getPosition
argument_list|(
name|colAlias
argument_list|)
operator|>=
literal|0
condition|)
block|{
name|ctxLookingFor
operator|=
name|ic
expr_stmt|;
name|noInp
operator|++
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|noInp
operator|>
literal|1
condition|)
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Ambiguous column mapping"
argument_list|)
throw|;
block|}
return|return
name|ctxLookingFor
return|;
block|}
specifier|protected
name|RexNode
name|convert
parameter_list|(
name|ExprNodeColumnDesc
name|col
parameter_list|)
throws|throws
name|SemanticException
block|{
comment|//if this is co-rrelated we need to make RexCorrelVariable(with id and type)
comment|// id and type should be retrieved from outerRR
name|InputCtx
name|ic
init|=
name|getInputCtx
argument_list|(
name|col
argument_list|)
decl_stmt|;
if|if
condition|(
name|ic
operator|==
literal|null
condition|)
block|{
comment|// we have correlated column, build data type from outer rr
name|RelDataType
name|rowType
init|=
name|TypeConverter
operator|.
name|getType
argument_list|(
name|cluster
argument_list|,
name|this
operator|.
name|outerRR
argument_list|,
literal|null
argument_list|)
decl_stmt|;
if|if
condition|(
name|this
operator|.
name|outerNameToPosMap
operator|.
name|get
argument_list|(
name|col
operator|.
name|getColumn
argument_list|()
argument_list|)
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|INVALID_COLUMN_NAME
operator|.
name|getMsg
argument_list|(
name|col
operator|.
name|getColumn
argument_list|()
argument_list|)
argument_list|)
throw|;
block|}
name|int
name|pos
init|=
name|this
operator|.
name|outerNameToPosMap
operator|.
name|get
argument_list|(
name|col
operator|.
name|getColumn
argument_list|()
argument_list|)
decl_stmt|;
name|CorrelationId
name|colCorr
init|=
operator|new
name|CorrelationId
argument_list|(
name|this
operator|.
name|correlatedId
argument_list|)
decl_stmt|;
name|RexNode
name|corExpr
init|=
name|cluster
operator|.
name|getRexBuilder
argument_list|()
operator|.
name|makeCorrel
argument_list|(
name|rowType
argument_list|,
name|colCorr
argument_list|)
decl_stmt|;
return|return
name|cluster
operator|.
name|getRexBuilder
argument_list|()
operator|.
name|makeFieldAccess
argument_list|(
name|corExpr
argument_list|,
name|pos
argument_list|)
return|;
block|}
name|int
name|pos
init|=
name|ic
operator|.
name|hiveNameToPosMap
operator|.
name|get
argument_list|(
name|col
operator|.
name|getColumn
argument_list|()
argument_list|)
decl_stmt|;
return|return
name|cluster
operator|.
name|getRexBuilder
argument_list|()
operator|.
name|makeInputRef
argument_list|(
name|ic
operator|.
name|calciteInpDataType
operator|.
name|getFieldList
argument_list|()
operator|.
name|get
argument_list|(
name|pos
argument_list|)
operator|.
name|getType
argument_list|()
argument_list|,
name|pos
operator|+
name|ic
operator|.
name|offsetInCalciteSchema
argument_list|)
return|;
block|}
specifier|private
specifier|static
specifier|final
name|BigInteger
name|MIN_LONG_BI
init|=
name|BigInteger
operator|.
name|valueOf
argument_list|(
name|Long
operator|.
name|MIN_VALUE
argument_list|)
decl_stmt|,
name|MAX_LONG_BI
init|=
name|BigInteger
operator|.
name|valueOf
argument_list|(
name|Long
operator|.
name|MAX_VALUE
argument_list|)
decl_stmt|;
specifier|private
specifier|static
name|NlsString
name|asUnicodeString
parameter_list|(
name|String
name|text
parameter_list|)
block|{
return|return
operator|new
name|NlsString
argument_list|(
name|text
argument_list|,
name|ConversionUtil
operator|.
name|NATIVE_UTF16_CHARSET_NAME
argument_list|,
name|SqlCollation
operator|.
name|IMPLICIT
argument_list|)
return|;
block|}
specifier|protected
name|RexNode
name|convert
parameter_list|(
name|ExprNodeConstantDesc
name|literal
parameter_list|)
throws|throws
name|CalciteSemanticException
block|{
name|RexBuilder
name|rexBuilder
init|=
name|cluster
operator|.
name|getRexBuilder
argument_list|()
decl_stmt|;
name|RelDataTypeFactory
name|dtFactory
init|=
name|rexBuilder
operator|.
name|getTypeFactory
argument_list|()
decl_stmt|;
name|PrimitiveTypeInfo
name|hiveType
init|=
operator|(
name|PrimitiveTypeInfo
operator|)
name|literal
operator|.
name|getTypeInfo
argument_list|()
decl_stmt|;
name|RelDataType
name|calciteDataType
init|=
name|TypeConverter
operator|.
name|convert
argument_list|(
name|hiveType
argument_list|,
name|dtFactory
argument_list|)
decl_stmt|;
name|PrimitiveCategory
name|hiveTypeCategory
init|=
name|hiveType
operator|.
name|getPrimitiveCategory
argument_list|()
decl_stmt|;
name|ConstantObjectInspector
name|coi
init|=
name|literal
operator|.
name|getWritableObjectInspector
argument_list|()
decl_stmt|;
name|Object
name|value
init|=
name|ObjectInspectorUtils
operator|.
name|copyToStandardJavaObject
argument_list|(
name|coi
operator|.
name|getWritableConstantValue
argument_list|()
argument_list|,
name|coi
argument_list|)
decl_stmt|;
name|RexNode
name|calciteLiteral
init|=
literal|null
decl_stmt|;
comment|// If value is null, the type should also be VOID.
if|if
condition|(
name|value
operator|==
literal|null
condition|)
block|{
name|hiveTypeCategory
operator|=
name|PrimitiveCategory
operator|.
name|VOID
expr_stmt|;
block|}
comment|// TODO: Verify if we need to use ConstantObjectInspector to unwrap data
switch|switch
condition|(
name|hiveTypeCategory
condition|)
block|{
case|case
name|BOOLEAN
case|:
name|calciteLiteral
operator|=
name|rexBuilder
operator|.
name|makeLiteral
argument_list|(
operator|(
operator|(
name|Boolean
operator|)
name|value
operator|)
operator|.
name|booleanValue
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|BYTE
case|:
name|calciteLiteral
operator|=
name|rexBuilder
operator|.
name|makeExactLiteral
argument_list|(
operator|new
name|BigDecimal
argument_list|(
operator|(
name|Byte
operator|)
name|value
argument_list|)
argument_list|,
name|calciteDataType
argument_list|)
expr_stmt|;
break|break;
case|case
name|SHORT
case|:
name|calciteLiteral
operator|=
name|rexBuilder
operator|.
name|makeExactLiteral
argument_list|(
operator|new
name|BigDecimal
argument_list|(
operator|(
name|Short
operator|)
name|value
argument_list|)
argument_list|,
name|calciteDataType
argument_list|)
expr_stmt|;
break|break;
case|case
name|INT
case|:
name|calciteLiteral
operator|=
name|rexBuilder
operator|.
name|makeExactLiteral
argument_list|(
operator|new
name|BigDecimal
argument_list|(
operator|(
name|Integer
operator|)
name|value
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|LONG
case|:
name|calciteLiteral
operator|=
name|rexBuilder
operator|.
name|makeBigintLiteral
argument_list|(
operator|new
name|BigDecimal
argument_list|(
operator|(
name|Long
operator|)
name|value
argument_list|)
argument_list|)
expr_stmt|;
break|break;
comment|// TODO: is Decimal an exact numeric or approximate numeric?
case|case
name|DECIMAL
case|:
if|if
condition|(
name|value
operator|instanceof
name|HiveDecimal
condition|)
block|{
name|value
operator|=
operator|(
operator|(
name|HiveDecimal
operator|)
name|value
operator|)
operator|.
name|bigDecimalValue
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|value
operator|instanceof
name|Decimal128
condition|)
block|{
name|value
operator|=
operator|(
operator|(
name|Decimal128
operator|)
name|value
operator|)
operator|.
name|toBigDecimal
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|value
operator|==
literal|null
condition|)
block|{
comment|// We have found an invalid decimal value while enforcing precision and
comment|// scale. Ideally,
comment|// we would replace it with null here, which is what Hive does. However,
comment|// we need to plumb
comment|// this thru up somehow, because otherwise having different expression
comment|// type in AST causes
comment|// the plan generation to fail after CBO, probably due to some residual
comment|// state in SA/QB.
comment|// For now, we will not run CBO in the presence of invalid decimal
comment|// literals.
throw|throw
operator|new
name|CalciteSemanticException
argument_list|(
literal|"Expression "
operator|+
name|literal
operator|.
name|getExprString
argument_list|()
operator|+
literal|" is not a valid decimal"
argument_list|,
name|UnsupportedFeature
operator|.
name|Invalid_decimal
argument_list|)
throw|;
comment|// TODO: return createNullLiteral(literal);
block|}
name|BigDecimal
name|bd
init|=
operator|(
name|BigDecimal
operator|)
name|value
decl_stmt|;
name|BigInteger
name|unscaled
init|=
name|bd
operator|.
name|unscaledValue
argument_list|()
decl_stmt|;
if|if
condition|(
name|unscaled
operator|.
name|compareTo
argument_list|(
name|MIN_LONG_BI
argument_list|)
operator|>=
literal|0
operator|&&
name|unscaled
operator|.
name|compareTo
argument_list|(
name|MAX_LONG_BI
argument_list|)
operator|<=
literal|0
condition|)
block|{
name|calciteLiteral
operator|=
name|rexBuilder
operator|.
name|makeExactLiteral
argument_list|(
name|bd
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// CBO doesn't support unlimited precision decimals. In practice, this
comment|// will work...
comment|// An alternative would be to throw CboSemanticException and fall back
comment|// to no CBO.
name|RelDataType
name|relType
init|=
name|cluster
operator|.
name|getTypeFactory
argument_list|()
operator|.
name|createSqlType
argument_list|(
name|SqlTypeName
operator|.
name|DECIMAL
argument_list|,
name|unscaled
operator|.
name|toString
argument_list|()
operator|.
name|length
argument_list|()
argument_list|,
name|bd
operator|.
name|scale
argument_list|()
argument_list|)
decl_stmt|;
name|calciteLiteral
operator|=
name|rexBuilder
operator|.
name|makeExactLiteral
argument_list|(
name|bd
argument_list|,
name|relType
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|FLOAT
case|:
name|calciteLiteral
operator|=
name|rexBuilder
operator|.
name|makeApproxLiteral
argument_list|(
operator|new
name|BigDecimal
argument_list|(
name|Float
operator|.
name|toString
argument_list|(
operator|(
name|Float
operator|)
name|value
argument_list|)
argument_list|)
argument_list|,
name|calciteDataType
argument_list|)
expr_stmt|;
break|break;
case|case
name|DOUBLE
case|:
comment|// TODO: The best solution is to support NaN in expression reduction.
if|if
condition|(
name|Double
operator|.
name|isNaN
argument_list|(
operator|(
name|Double
operator|)
name|value
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|CalciteSemanticException
argument_list|(
literal|"NaN"
argument_list|,
name|UnsupportedFeature
operator|.
name|Invalid_decimal
argument_list|)
throw|;
block|}
name|calciteLiteral
operator|=
name|rexBuilder
operator|.
name|makeApproxLiteral
argument_list|(
operator|new
name|BigDecimal
argument_list|(
name|Double
operator|.
name|toString
argument_list|(
operator|(
name|Double
operator|)
name|value
argument_list|)
argument_list|)
argument_list|,
name|calciteDataType
argument_list|)
expr_stmt|;
break|break;
case|case
name|CHAR
case|:
if|if
condition|(
name|value
operator|instanceof
name|HiveChar
condition|)
block|{
name|value
operator|=
operator|(
operator|(
name|HiveChar
operator|)
name|value
operator|)
operator|.
name|getValue
argument_list|()
expr_stmt|;
block|}
name|calciteLiteral
operator|=
name|rexBuilder
operator|.
name|makeCharLiteral
argument_list|(
name|asUnicodeString
argument_list|(
operator|(
name|String
operator|)
name|value
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|VARCHAR
case|:
if|if
condition|(
name|value
operator|instanceof
name|HiveVarchar
condition|)
block|{
name|value
operator|=
operator|(
operator|(
name|HiveVarchar
operator|)
name|value
operator|)
operator|.
name|getValue
argument_list|()
expr_stmt|;
block|}
name|calciteLiteral
operator|=
name|rexBuilder
operator|.
name|makeCharLiteral
argument_list|(
name|asUnicodeString
argument_list|(
operator|(
name|String
operator|)
name|value
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|STRING
case|:
name|calciteLiteral
operator|=
name|rexBuilder
operator|.
name|makeCharLiteral
argument_list|(
name|asUnicodeString
argument_list|(
operator|(
name|String
operator|)
name|value
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|DATE
case|:
name|Calendar
name|cal
init|=
operator|new
name|GregorianCalendar
argument_list|()
decl_stmt|;
name|cal
operator|.
name|setTime
argument_list|(
operator|(
name|Date
operator|)
name|value
argument_list|)
expr_stmt|;
name|calciteLiteral
operator|=
name|rexBuilder
operator|.
name|makeDateLiteral
argument_list|(
name|cal
argument_list|)
expr_stmt|;
break|break;
case|case
name|TIMESTAMP
case|:
name|Calendar
name|c
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|value
operator|instanceof
name|Calendar
condition|)
block|{
name|c
operator|=
operator|(
name|Calendar
operator|)
name|value
expr_stmt|;
block|}
else|else
block|{
name|c
operator|=
name|Calendar
operator|.
name|getInstance
argument_list|()
expr_stmt|;
name|c
operator|.
name|setTimeInMillis
argument_list|(
operator|(
operator|(
name|Timestamp
operator|)
name|value
operator|)
operator|.
name|getTime
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|calciteLiteral
operator|=
name|rexBuilder
operator|.
name|makeTimestampLiteral
argument_list|(
name|c
argument_list|,
name|RelDataType
operator|.
name|PRECISION_NOT_SPECIFIED
argument_list|)
expr_stmt|;
break|break;
case|case
name|INTERVAL_YEAR_MONTH
case|:
comment|// Calcite year-month literal value is months as BigDecimal
name|BigDecimal
name|totalMonths
init|=
name|BigDecimal
operator|.
name|valueOf
argument_list|(
operator|(
operator|(
name|HiveIntervalYearMonth
operator|)
name|value
operator|)
operator|.
name|getTotalMonths
argument_list|()
argument_list|)
decl_stmt|;
name|calciteLiteral
operator|=
name|rexBuilder
operator|.
name|makeIntervalLiteral
argument_list|(
name|totalMonths
argument_list|,
operator|new
name|SqlIntervalQualifier
argument_list|(
name|TimeUnit
operator|.
name|YEAR
argument_list|,
name|TimeUnit
operator|.
name|MONTH
argument_list|,
operator|new
name|SqlParserPos
argument_list|(
literal|1
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|INTERVAL_DAY_TIME
case|:
comment|// Calcite day-time interval is millis value as BigDecimal
comment|// Seconds converted to millis
name|BigDecimal
name|secsValueBd
init|=
name|BigDecimal
operator|.
name|valueOf
argument_list|(
operator|(
operator|(
name|HiveIntervalDayTime
operator|)
name|value
operator|)
operator|.
name|getTotalSeconds
argument_list|()
operator|*
literal|1000
argument_list|)
decl_stmt|;
comment|// Nanos converted to millis
name|BigDecimal
name|nanosValueBd
init|=
name|BigDecimal
operator|.
name|valueOf
argument_list|(
operator|(
operator|(
name|HiveIntervalDayTime
operator|)
name|value
operator|)
operator|.
name|getNanos
argument_list|()
argument_list|,
literal|6
argument_list|)
decl_stmt|;
name|calciteLiteral
operator|=
name|rexBuilder
operator|.
name|makeIntervalLiteral
argument_list|(
name|secsValueBd
operator|.
name|add
argument_list|(
name|nanosValueBd
argument_list|)
argument_list|,
operator|new
name|SqlIntervalQualifier
argument_list|(
name|TimeUnit
operator|.
name|MILLISECOND
argument_list|,
literal|null
argument_list|,
operator|new
name|SqlParserPos
argument_list|(
literal|1
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|VOID
case|:
name|calciteLiteral
operator|=
name|cluster
operator|.
name|getRexBuilder
argument_list|()
operator|.
name|makeLiteral
argument_list|(
literal|null
argument_list|,
name|cluster
operator|.
name|getTypeFactory
argument_list|()
operator|.
name|createSqlType
argument_list|(
name|SqlTypeName
operator|.
name|NULL
argument_list|)
argument_list|,
literal|true
argument_list|)
expr_stmt|;
break|break;
case|case
name|BINARY
case|:
case|case
name|UNKNOWN
case|:
default|default:
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"UnSupported Literal"
argument_list|)
throw|;
block|}
return|return
name|calciteLiteral
return|;
block|}
specifier|public
specifier|static
name|RexNode
name|convert
parameter_list|(
name|RelOptCluster
name|cluster
parameter_list|,
name|ExprNodeDesc
name|joinCondnExprNode
parameter_list|,
name|List
argument_list|<
name|RelNode
argument_list|>
name|inputRels
parameter_list|,
name|LinkedHashMap
argument_list|<
name|RelNode
argument_list|,
name|RowResolver
argument_list|>
name|relToHiveRR
parameter_list|,
name|Map
argument_list|<
name|RelNode
argument_list|,
name|ImmutableMap
argument_list|<
name|String
argument_list|,
name|Integer
argument_list|>
argument_list|>
name|relToHiveColNameCalcitePosMap
parameter_list|,
name|boolean
name|flattenExpr
parameter_list|)
throws|throws
name|SemanticException
block|{
name|List
argument_list|<
name|InputCtx
argument_list|>
name|inputCtxLst
init|=
operator|new
name|ArrayList
argument_list|<
name|InputCtx
argument_list|>
argument_list|()
decl_stmt|;
name|int
name|offSet
init|=
literal|0
decl_stmt|;
for|for
control|(
name|RelNode
name|r
range|:
name|inputRels
control|)
block|{
name|inputCtxLst
operator|.
name|add
argument_list|(
operator|new
name|InputCtx
argument_list|(
name|r
operator|.
name|getRowType
argument_list|()
argument_list|,
name|relToHiveColNameCalcitePosMap
operator|.
name|get
argument_list|(
name|r
argument_list|)
argument_list|,
name|relToHiveRR
operator|.
name|get
argument_list|(
name|r
argument_list|)
argument_list|,
name|offSet
argument_list|)
argument_list|)
expr_stmt|;
name|offSet
operator|+=
name|r
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldCount
argument_list|()
expr_stmt|;
block|}
return|return
operator|(
operator|new
name|RexNodeConverter
argument_list|(
name|cluster
argument_list|,
name|inputCtxLst
argument_list|,
name|flattenExpr
argument_list|)
operator|)
operator|.
name|convert
argument_list|(
name|joinCondnExprNode
argument_list|)
return|;
block|}
block|}
end_class

end_unit

