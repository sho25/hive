begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|optimizer
operator|.
name|physical
package|;
end_package

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|ReduceSinkDesc
operator|.
name|ReducerTraits
operator|.
name|UNIFORM
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|Serializable
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|annotation
operator|.
name|Annotation
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|IdentityHashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|LinkedHashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
operator|.
name|Entry
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Properties
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Stack
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|TreeSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|regex
operator|.
name|Pattern
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|lang
operator|.
name|ArrayUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|lang3
operator|.
name|tuple
operator|.
name|ImmutablePair
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|parse
operator|.
name|spark
operator|.
name|SparkPartitionPruningSinkOperator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|Path
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|common
operator|.
name|type
operator|.
name|DataTypePhysicalVariation
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|conf
operator|.
name|HiveConf
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|conf
operator|.
name|HiveConf
operator|.
name|ConfVars
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|llap
operator|.
name|io
operator|.
name|api
operator|.
name|LlapProxy
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|CompilationOpContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|mr
operator|.
name|MapRedTask
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|persistence
operator|.
name|MapJoinKey
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|spark
operator|.
name|SparkTask
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|tez
operator|.
name|TezTask
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|vector
operator|.
name|VectorExpressionDescriptor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|vector
operator|.
name|mapjoin
operator|.
name|VectorMapJoinInnerBigOnlyLongOperator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|vector
operator|.
name|mapjoin
operator|.
name|VectorMapJoinInnerBigOnlyMultiKeyOperator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|vector
operator|.
name|mapjoin
operator|.
name|VectorMapJoinInnerBigOnlyStringOperator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|vector
operator|.
name|mapjoin
operator|.
name|VectorMapJoinInnerLongOperator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|vector
operator|.
name|mapjoin
operator|.
name|VectorMapJoinInnerMultiKeyOperator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|vector
operator|.
name|mapjoin
operator|.
name|VectorMapJoinInnerStringOperator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|vector
operator|.
name|mapjoin
operator|.
name|VectorMapJoinLeftSemiLongOperator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|vector
operator|.
name|mapjoin
operator|.
name|VectorMapJoinLeftSemiMultiKeyOperator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|vector
operator|.
name|mapjoin
operator|.
name|VectorMapJoinLeftSemiStringOperator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|vector
operator|.
name|mapjoin
operator|.
name|VectorMapJoinOuterLongOperator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|vector
operator|.
name|mapjoin
operator|.
name|VectorMapJoinOuterMultiKeyOperator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|vector
operator|.
name|mapjoin
operator|.
name|VectorMapJoinOuterStringOperator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|vector
operator|.
name|ptf
operator|.
name|VectorPTFOperator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|vector
operator|.
name|reducesink
operator|.
name|VectorReduceSinkEmptyKeyOperator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|vector
operator|.
name|reducesink
operator|.
name|VectorReduceSinkLongOperator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|vector
operator|.
name|reducesink
operator|.
name|VectorReduceSinkMultiKeyOperator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|vector
operator|.
name|reducesink
operator|.
name|VectorReduceSinkObjectHashOperator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|vector
operator|.
name|reducesink
operator|.
name|VectorReduceSinkStringOperator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|vector
operator|.
name|udf
operator|.
name|VectorUDFAdaptor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|vector
operator|.
name|ColumnVector
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|vector
operator|.
name|ColumnVector
operator|.
name|Type
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|vector
operator|.
name|VectorAggregationDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|vector
operator|.
name|VectorColumnOutputMapping
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|vector
operator|.
name|VectorColumnSourceMapping
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|vector
operator|.
name|VectorMapJoinOperator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|vector
operator|.
name|VectorMapJoinOuterFilteredOperator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|vector
operator|.
name|VectorizationContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|vector
operator|.
name|VectorizationOperator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|vector
operator|.
name|VectorizedUDAFs
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|vector
operator|.
name|VectorizationContext
operator|.
name|HiveVectorAdaptorUsageMode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|vector
operator|.
name|VectorizationContext
operator|.
name|InConstantType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|vector
operator|.
name|VectorizationContextRegion
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|vector
operator|.
name|VectorizedSupport
operator|.
name|Support
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|vector
operator|.
name|expressions
operator|.
name|IdentityExpression
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|vector
operator|.
name|expressions
operator|.
name|VectorExpression
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|vector
operator|.
name|expressions
operator|.
name|aggregates
operator|.
name|VectorAggregateExpression
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|io
operator|.
name|NullRowsInputFormat
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|io
operator|.
name|OneNullRowInputFormat
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|io
operator|.
name|orc
operator|.
name|OrcInputFormat
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|vector
operator|.
name|VectorizedRowBatchCtx
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|lib
operator|.
name|Dispatcher
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|lib
operator|.
name|Node
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|lib
operator|.
name|NodeProcessor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|lib
operator|.
name|Rule
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|lib
operator|.
name|RuleRegExp
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|lib
operator|.
name|TaskGraphWalker
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|metadata
operator|.
name|HiveException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|metadata
operator|.
name|VirtualColumn
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|parse
operator|.
name|SemanticException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|AbstractOperatorDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|AggregationDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|AppMasterEventDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|BaseWork
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|Explain
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|ExprNodeColumnDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|ExprNodeDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|ExprNodeDesc
operator|.
name|ExprNodeDescEqualityWrapper
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|ExprNodeGenericFuncDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|FileSinkDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|FilterDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|GroupByDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|JoinDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|LimitDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|MapJoinDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|MapWork
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|MapredWork
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|OperatorDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|PTFDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|SelectDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|VectorAppMasterEventDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|VectorDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|VectorFileSinkDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|VectorFilterDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|VectorPTFDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|VectorPTFInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|VectorPTFDesc
operator|.
name|SupportedFunctionType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|VectorTableScanDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|VectorizationCondition
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|VectorGroupByDesc
operator|.
name|ProcessingMode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|VectorSparkHashTableSinkDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|VectorSparkPartitionPruningSinkDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|VectorLimitDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|VectorMapJoinInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|VectorSMBJoinDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|PartitionDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|ReduceSinkDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|ReduceWork
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|SMBJoinDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|SparkHashTableSinkDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|optimizer
operator|.
name|spark
operator|.
name|SparkPartitionPruningSinkDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|SparkWork
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|TableDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|TableScanDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|TezWork
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|VectorGroupByDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|VectorMapJoinDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|VectorMapJoinDesc
operator|.
name|HashTableImplementationType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|VectorMapJoinDesc
operator|.
name|HashTableKeyType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|VectorMapJoinDesc
operator|.
name|HashTableKind
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|VectorMapJoinDesc
operator|.
name|VectorMapJoinVariation
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|VectorPartitionDesc
operator|.
name|VectorDeserializeType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|VectorReduceSinkDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|VectorReduceSinkInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|VectorPartitionDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|VectorSelectDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|api
operator|.
name|OperatorType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|ptf
operator|.
name|OrderExpressionDef
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|ptf
operator|.
name|PTFExpressionDef
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|ptf
operator|.
name|PartitionedTableFunctionDef
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|ptf
operator|.
name|WindowFrameDef
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|ptf
operator|.
name|WindowFunctionDef
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|ptf
operator|.
name|WindowTableFunctionDef
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|udf
operator|.
name|UDFAcos
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|udf
operator|.
name|UDFAsin
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|udf
operator|.
name|UDFAtan
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|udf
operator|.
name|UDFBin
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|udf
operator|.
name|UDFConv
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|udf
operator|.
name|UDFCos
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|udf
operator|.
name|UDFDayOfMonth
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|udf
operator|.
name|UDFDayOfWeek
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|udf
operator|.
name|UDFDegrees
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|udf
operator|.
name|UDFExp
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|udf
operator|.
name|UDFFromUnixTime
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|udf
operator|.
name|UDFHex
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|udf
operator|.
name|UDFHour
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|udf
operator|.
name|UDFLike
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|udf
operator|.
name|UDFLn
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|udf
operator|.
name|UDFLog
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|udf
operator|.
name|UDFLog10
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|udf
operator|.
name|UDFLog2
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|udf
operator|.
name|UDFMinute
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|udf
operator|.
name|UDFMonth
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|udf
operator|.
name|UDFRadians
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|udf
operator|.
name|UDFRand
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|udf
operator|.
name|UDFRegExpExtract
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|udf
operator|.
name|UDFRegExpReplace
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|udf
operator|.
name|UDFSecond
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|udf
operator|.
name|UDFSign
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|udf
operator|.
name|UDFSin
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|udf
operator|.
name|UDFSqrt
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|udf
operator|.
name|UDFSubstr
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|udf
operator|.
name|UDFTan
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|udf
operator|.
name|UDFToBoolean
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|udf
operator|.
name|UDFToByte
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|udf
operator|.
name|UDFToDouble
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|udf
operator|.
name|UDFToFloat
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|udf
operator|.
name|UDFToInteger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|udf
operator|.
name|UDFToLong
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|udf
operator|.
name|UDFToShort
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|udf
operator|.
name|UDFToString
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|udf
operator|.
name|UDFWeekOfYear
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|udf
operator|.
name|UDFYear
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|udf
operator|.
name|generic
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde
operator|.
name|serdeConstants
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|Deserializer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|NullStructSerDe
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|SerDeUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|lazy
operator|.
name|LazySimpleSerDe
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|lazybinary
operator|.
name|LazyBinarySerDe
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|objectinspector
operator|.
name|ObjectInspector
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|objectinspector
operator|.
name|ObjectInspector
operator|.
name|Category
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|objectinspector
operator|.
name|ObjectInspectorUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|objectinspector
operator|.
name|PrimitiveObjectInspector
operator|.
name|PrimitiveCategory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|objectinspector
operator|.
name|StructField
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|objectinspector
operator|.
name|StructObjectInspector
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|typeinfo
operator|.
name|DecimalTypeInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|typeinfo
operator|.
name|PrimitiveTypeInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|typeinfo
operator|.
name|StructTypeInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|typeinfo
operator|.
name|TypeInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|typeinfo
operator|.
name|TypeInfoUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|io
operator|.
name|HiveDecimalWritable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapred
operator|.
name|InputFormat
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapred
operator|.
name|SequenceFileInputFormat
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapred
operator|.
name|TextInputFormat
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hive
operator|.
name|common
operator|.
name|util
operator|.
name|AnnotationUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|ReflectionUtils
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|ImmutableSet
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
import|;
end_import

begin_class
specifier|public
class|class
name|Vectorizer
implements|implements
name|PhysicalPlanResolver
block|{
specifier|protected
specifier|static
specifier|transient
specifier|final
name|Logger
name|LOG
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|Vectorizer
operator|.
name|class
argument_list|)
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|Pattern
name|supportedDataTypesPattern
decl_stmt|;
static|static
block|{
name|StringBuilder
name|patternBuilder
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|patternBuilder
operator|.
name|append
argument_list|(
literal|"int"
argument_list|)
expr_stmt|;
name|patternBuilder
operator|.
name|append
argument_list|(
literal|"|smallint"
argument_list|)
expr_stmt|;
name|patternBuilder
operator|.
name|append
argument_list|(
literal|"|tinyint"
argument_list|)
expr_stmt|;
name|patternBuilder
operator|.
name|append
argument_list|(
literal|"|bigint"
argument_list|)
expr_stmt|;
name|patternBuilder
operator|.
name|append
argument_list|(
literal|"|integer"
argument_list|)
expr_stmt|;
name|patternBuilder
operator|.
name|append
argument_list|(
literal|"|long"
argument_list|)
expr_stmt|;
name|patternBuilder
operator|.
name|append
argument_list|(
literal|"|short"
argument_list|)
expr_stmt|;
name|patternBuilder
operator|.
name|append
argument_list|(
literal|"|timestamp"
argument_list|)
expr_stmt|;
name|patternBuilder
operator|.
name|append
argument_list|(
literal|"|"
operator|+
name|serdeConstants
operator|.
name|INTERVAL_YEAR_MONTH_TYPE_NAME
argument_list|)
expr_stmt|;
name|patternBuilder
operator|.
name|append
argument_list|(
literal|"|"
operator|+
name|serdeConstants
operator|.
name|INTERVAL_DAY_TIME_TYPE_NAME
argument_list|)
expr_stmt|;
name|patternBuilder
operator|.
name|append
argument_list|(
literal|"|boolean"
argument_list|)
expr_stmt|;
name|patternBuilder
operator|.
name|append
argument_list|(
literal|"|binary"
argument_list|)
expr_stmt|;
name|patternBuilder
operator|.
name|append
argument_list|(
literal|"|string"
argument_list|)
expr_stmt|;
name|patternBuilder
operator|.
name|append
argument_list|(
literal|"|byte"
argument_list|)
expr_stmt|;
name|patternBuilder
operator|.
name|append
argument_list|(
literal|"|float"
argument_list|)
expr_stmt|;
name|patternBuilder
operator|.
name|append
argument_list|(
literal|"|double"
argument_list|)
expr_stmt|;
name|patternBuilder
operator|.
name|append
argument_list|(
literal|"|date"
argument_list|)
expr_stmt|;
name|patternBuilder
operator|.
name|append
argument_list|(
literal|"|void"
argument_list|)
expr_stmt|;
comment|// Decimal types can be specified with different precision and scales e.g. decimal(10,5),
comment|// as opposed to other data types which can be represented by constant strings.
comment|// The regex matches only the "decimal" prefix of the type.
name|patternBuilder
operator|.
name|append
argument_list|(
literal|"|decimal.*"
argument_list|)
expr_stmt|;
comment|// CHAR and VARCHAR types can be specified with maximum length.
name|patternBuilder
operator|.
name|append
argument_list|(
literal|"|char.*"
argument_list|)
expr_stmt|;
name|patternBuilder
operator|.
name|append
argument_list|(
literal|"|varchar.*"
argument_list|)
expr_stmt|;
name|supportedDataTypesPattern
operator|=
name|Pattern
operator|.
name|compile
argument_list|(
name|patternBuilder
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
specifier|private
name|Set
argument_list|<
name|Class
argument_list|<
name|?
argument_list|>
argument_list|>
name|supportedGenericUDFs
init|=
operator|new
name|HashSet
argument_list|<
name|Class
argument_list|<
name|?
argument_list|>
argument_list|>
argument_list|()
decl_stmt|;
specifier|private
name|Set
argument_list|<
name|String
argument_list|>
name|supportedAggregationUdfs
init|=
operator|new
name|HashSet
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
comment|// The set of virtual columns that vectorized readers *MAY* support.
specifier|public
specifier|static
specifier|final
name|ImmutableSet
argument_list|<
name|VirtualColumn
argument_list|>
name|vectorizableVirtualColumns
init|=
name|ImmutableSet
operator|.
name|of
argument_list|(
name|VirtualColumn
operator|.
name|ROWID
argument_list|)
decl_stmt|;
specifier|private
name|HiveConf
name|hiveConf
decl_stmt|;
specifier|public
specifier|static
enum|enum
name|VectorizationEnabledOverride
block|{
name|NONE
block|,
name|DISABLE
block|,
name|ENABLE
block|;
specifier|public
specifier|final
specifier|static
name|Map
argument_list|<
name|String
argument_list|,
name|VectorizationEnabledOverride
argument_list|>
name|nameMap
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|VectorizationEnabledOverride
argument_list|>
argument_list|()
decl_stmt|;
static|static
block|{
for|for
control|(
name|VectorizationEnabledOverride
name|vectorizationEnabledOverride
range|:
name|values
argument_list|()
control|)
block|{
name|nameMap
operator|.
name|put
argument_list|(
name|vectorizationEnabledOverride
operator|.
name|name
argument_list|()
operator|.
name|toLowerCase
argument_list|()
argument_list|,
name|vectorizationEnabledOverride
argument_list|)
expr_stmt|;
block|}
block|}
block|;   }
name|boolean
name|isVectorizationEnabled
decl_stmt|;
specifier|private
name|VectorizationEnabledOverride
name|vectorizationEnabledOverride
decl_stmt|;
name|boolean
name|isTestForcedVectorizationEnable
decl_stmt|;
specifier|private
name|boolean
name|useVectorizedInputFileFormat
decl_stmt|;
specifier|private
name|boolean
name|useVectorDeserialize
decl_stmt|;
specifier|private
name|boolean
name|useRowDeserialize
decl_stmt|;
specifier|private
name|boolean
name|isReduceVectorizationEnabled
decl_stmt|;
specifier|private
name|boolean
name|isPtfVectorizationEnabled
decl_stmt|;
specifier|private
name|boolean
name|isVectorizationComplexTypesEnabled
decl_stmt|;
comment|// Now deprecated.
specifier|private
name|boolean
name|isVectorizationGroupByComplexTypesEnabled
decl_stmt|;
specifier|private
name|boolean
name|isVectorizedRowIdentifierEnabled
decl_stmt|;
specifier|private
name|String
name|vectorizedInputFormatSupportEnabled
decl_stmt|;
specifier|private
name|boolean
name|isLlapIoEnabled
decl_stmt|;
specifier|private
name|Set
argument_list|<
name|Support
argument_list|>
name|vectorizedInputFormatSupportEnabledSet
decl_stmt|;
specifier|private
name|Collection
argument_list|<
name|Class
argument_list|<
name|?
argument_list|>
argument_list|>
name|rowDeserializeInputFormatExcludes
decl_stmt|;
specifier|private
name|int
name|vectorizedPTFMaxMemoryBufferingBatchCount
decl_stmt|;
specifier|private
name|int
name|vectorizedTestingReducerBatchSize
decl_stmt|;
specifier|private
name|boolean
name|isTestVectorizerSuppressFatalExceptions
decl_stmt|;
specifier|private
name|boolean
name|isSchemaEvolution
decl_stmt|;
specifier|private
name|HiveVectorAdaptorUsageMode
name|hiveVectorAdaptorUsageMode
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|Set
argument_list|<
name|Support
argument_list|>
name|vectorDeserializeTextSupportSet
init|=
operator|new
name|TreeSet
argument_list|<
name|Support
argument_list|>
argument_list|()
decl_stmt|;
static|static
block|{
name|vectorDeserializeTextSupportSet
operator|.
name|addAll
argument_list|(
name|Arrays
operator|.
name|asList
argument_list|(
name|Support
operator|.
name|values
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|private
specifier|static
specifier|final
name|Set
argument_list|<
name|String
argument_list|>
name|supportedAcidInputFormats
init|=
operator|new
name|TreeSet
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
static|static
block|{
name|supportedAcidInputFormats
operator|.
name|add
argument_list|(
name|OrcInputFormat
operator|.
name|class
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
comment|// For metadataonly or empty rows optimizations, null/onerow input format can be selected.
name|supportedAcidInputFormats
operator|.
name|add
argument_list|(
name|NullRowsInputFormat
operator|.
name|class
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
name|supportedAcidInputFormats
operator|.
name|add
argument_list|(
name|OneNullRowInputFormat
operator|.
name|class
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
block|}
specifier|private
name|boolean
name|isTestVectorizationSuppressExplainExecutionMode
decl_stmt|;
specifier|private
name|BaseWork
name|currentBaseWork
decl_stmt|;
specifier|private
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
name|currentOperator
decl_stmt|;
specifier|private
name|Collection
argument_list|<
name|Class
argument_list|<
name|?
argument_list|>
argument_list|>
name|vectorizedInputFormatExcludes
decl_stmt|;
specifier|private
name|Map
argument_list|<
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
argument_list|,
name|Set
argument_list|<
name|ImmutablePair
argument_list|<
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
argument_list|,
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
argument_list|>
argument_list|>
argument_list|>
name|delayedFixups
init|=
operator|new
name|IdentityHashMap
argument_list|<
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
argument_list|,
name|Set
argument_list|<
name|ImmutablePair
argument_list|<
name|Operator
argument_list|<
name|?
argument_list|>
argument_list|,
name|Operator
argument_list|<
name|?
argument_list|>
argument_list|>
argument_list|>
argument_list|>
argument_list|()
decl_stmt|;
specifier|public
name|void
name|testSetCurrentBaseWork
parameter_list|(
name|BaseWork
name|testBaseWork
parameter_list|)
block|{
name|currentBaseWork
operator|=
name|testBaseWork
expr_stmt|;
block|}
specifier|private
name|void
name|setNodeIssue
parameter_list|(
name|String
name|issue
parameter_list|)
block|{
name|currentBaseWork
operator|.
name|setNotVectorizedReason
argument_list|(
name|VectorizerReason
operator|.
name|createNodeIssue
argument_list|(
name|issue
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|setOperatorIssue
parameter_list|(
name|String
name|issue
parameter_list|)
block|{
name|currentBaseWork
operator|.
name|setNotVectorizedReason
argument_list|(
name|VectorizerReason
operator|.
name|createOperatorIssue
argument_list|(
name|currentOperator
argument_list|,
name|issue
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|setExpressionIssue
parameter_list|(
name|String
name|expressionTitle
parameter_list|,
name|String
name|issue
parameter_list|)
block|{
name|currentBaseWork
operator|.
name|setNotVectorizedReason
argument_list|(
name|VectorizerReason
operator|.
name|createExpressionIssue
argument_list|(
name|currentOperator
argument_list|,
name|expressionTitle
argument_list|,
name|issue
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|clearNotVectorizedReason
parameter_list|()
block|{
name|currentBaseWork
operator|.
name|setNotVectorizedReason
argument_list|(
literal|null
argument_list|)
expr_stmt|;
block|}
specifier|private
name|long
name|vectorizedVertexNum
init|=
operator|-
literal|1
decl_stmt|;
specifier|private
name|Set
argument_list|<
name|VirtualColumn
argument_list|>
name|availableVectorizedVirtualColumnSet
init|=
literal|null
decl_stmt|;
specifier|private
name|Set
argument_list|<
name|VirtualColumn
argument_list|>
name|neededVirtualColumnSet
init|=
literal|null
decl_stmt|;
specifier|public
class|class
name|VectorizerCannotVectorizeException
extends|extends
name|Exception
block|{   }
specifier|public
name|Vectorizer
parameter_list|()
block|{
comment|/*      * We check UDFs against the supportedGenericUDFs when      * hive.vectorized.adaptor.usage.mode=chosen or none.      *      * We allow all UDFs for hive.vectorized.adaptor.usage.mode=all.      */
name|supportedGenericUDFs
operator|.
name|add
argument_list|(
name|GenericUDFOPPlus
operator|.
name|class
argument_list|)
expr_stmt|;
name|supportedGenericUDFs
operator|.
name|add
argument_list|(
name|GenericUDFOPMinus
operator|.
name|class
argument_list|)
expr_stmt|;
name|supportedGenericUDFs
operator|.
name|add
argument_list|(
name|GenericUDFOPMultiply
operator|.
name|class
argument_list|)
expr_stmt|;
name|supportedGenericUDFs
operator|.
name|add
argument_list|(
name|GenericUDFOPDivide
operator|.
name|class
argument_list|)
expr_stmt|;
name|supportedGenericUDFs
operator|.
name|add
argument_list|(
name|GenericUDFOPMod
operator|.
name|class
argument_list|)
expr_stmt|;
name|supportedGenericUDFs
operator|.
name|add
argument_list|(
name|GenericUDFOPNegative
operator|.
name|class
argument_list|)
expr_stmt|;
name|supportedGenericUDFs
operator|.
name|add
argument_list|(
name|GenericUDFOPPositive
operator|.
name|class
argument_list|)
expr_stmt|;
name|supportedGenericUDFs
operator|.
name|add
argument_list|(
name|GenericUDFOPEqualOrLessThan
operator|.
name|class
argument_list|)
expr_stmt|;
name|supportedGenericUDFs
operator|.
name|add
argument_list|(
name|GenericUDFOPEqualOrGreaterThan
operator|.
name|class
argument_list|)
expr_stmt|;
name|supportedGenericUDFs
operator|.
name|add
argument_list|(
name|GenericUDFOPGreaterThan
operator|.
name|class
argument_list|)
expr_stmt|;
name|supportedGenericUDFs
operator|.
name|add
argument_list|(
name|GenericUDFOPLessThan
operator|.
name|class
argument_list|)
expr_stmt|;
name|supportedGenericUDFs
operator|.
name|add
argument_list|(
name|GenericUDFOPNot
operator|.
name|class
argument_list|)
expr_stmt|;
name|supportedGenericUDFs
operator|.
name|add
argument_list|(
name|GenericUDFOPNotEqual
operator|.
name|class
argument_list|)
expr_stmt|;
name|supportedGenericUDFs
operator|.
name|add
argument_list|(
name|GenericUDFOPNotNull
operator|.
name|class
argument_list|)
expr_stmt|;
name|supportedGenericUDFs
operator|.
name|add
argument_list|(
name|GenericUDFOPNull
operator|.
name|class
argument_list|)
expr_stmt|;
name|supportedGenericUDFs
operator|.
name|add
argument_list|(
name|GenericUDFOPOr
operator|.
name|class
argument_list|)
expr_stmt|;
name|supportedGenericUDFs
operator|.
name|add
argument_list|(
name|GenericUDFOPAnd
operator|.
name|class
argument_list|)
expr_stmt|;
name|supportedGenericUDFs
operator|.
name|add
argument_list|(
name|GenericUDFOPEqual
operator|.
name|class
argument_list|)
expr_stmt|;
name|supportedGenericUDFs
operator|.
name|add
argument_list|(
name|GenericUDFLength
operator|.
name|class
argument_list|)
expr_stmt|;
name|supportedGenericUDFs
operator|.
name|add
argument_list|(
name|GenericUDFCharacterLength
operator|.
name|class
argument_list|)
expr_stmt|;
name|supportedGenericUDFs
operator|.
name|add
argument_list|(
name|GenericUDFOctetLength
operator|.
name|class
argument_list|)
expr_stmt|;
name|supportedGenericUDFs
operator|.
name|add
argument_list|(
name|UDFYear
operator|.
name|class
argument_list|)
expr_stmt|;
name|supportedGenericUDFs
operator|.
name|add
argument_list|(
name|UDFMonth
operator|.
name|class
argument_list|)
expr_stmt|;
name|supportedGenericUDFs
operator|.
name|add
argument_list|(
name|UDFDayOfMonth
operator|.
name|class
argument_list|)
expr_stmt|;
name|supportedGenericUDFs
operator|.
name|add
argument_list|(
name|UDFDayOfWeek
operator|.
name|class
argument_list|)
expr_stmt|;
name|supportedGenericUDFs
operator|.
name|add
argument_list|(
name|UDFHour
operator|.
name|class
argument_list|)
expr_stmt|;
name|supportedGenericUDFs
operator|.
name|add
argument_list|(
name|UDFMinute
operator|.
name|class
argument_list|)
expr_stmt|;
name|supportedGenericUDFs
operator|.
name|add
argument_list|(
name|UDFSecond
operator|.
name|class
argument_list|)
expr_stmt|;
name|supportedGenericUDFs
operator|.
name|add
argument_list|(
name|UDFWeekOfYear
operator|.
name|class
argument_list|)
expr_stmt|;
name|supportedGenericUDFs
operator|.
name|add
argument_list|(
name|GenericUDFToUnixTimeStamp
operator|.
name|class
argument_list|)
expr_stmt|;
name|supportedGenericUDFs
operator|.
name|add
argument_list|(
name|UDFFromUnixTime
operator|.
name|class
argument_list|)
expr_stmt|;
name|supportedGenericUDFs
operator|.
name|add
argument_list|(
name|GenericUDFDateAdd
operator|.
name|class
argument_list|)
expr_stmt|;
name|supportedGenericUDFs
operator|.
name|add
argument_list|(
name|GenericUDFDateSub
operator|.
name|class
argument_list|)
expr_stmt|;
name|supportedGenericUDFs
operator|.
name|add
argument_list|(
name|GenericUDFDate
operator|.
name|class
argument_list|)
expr_stmt|;
name|supportedGenericUDFs
operator|.
name|add
argument_list|(
name|GenericUDFDateDiff
operator|.
name|class
argument_list|)
expr_stmt|;
name|supportedGenericUDFs
operator|.
name|add
argument_list|(
name|UDFLike
operator|.
name|class
argument_list|)
expr_stmt|;
name|supportedGenericUDFs
operator|.
name|add
argument_list|(
name|GenericUDFRegExp
operator|.
name|class
argument_list|)
expr_stmt|;
name|supportedGenericUDFs
operator|.
name|add
argument_list|(
name|UDFRegExpExtract
operator|.
name|class
argument_list|)
expr_stmt|;
name|supportedGenericUDFs
operator|.
name|add
argument_list|(
name|UDFRegExpReplace
operator|.
name|class
argument_list|)
expr_stmt|;
name|supportedGenericUDFs
operator|.
name|add
argument_list|(
name|UDFSubstr
operator|.
name|class
argument_list|)
expr_stmt|;
name|supportedGenericUDFs
operator|.
name|add
argument_list|(
name|GenericUDFLTrim
operator|.
name|class
argument_list|)
expr_stmt|;
name|supportedGenericUDFs
operator|.
name|add
argument_list|(
name|GenericUDFRTrim
operator|.
name|class
argument_list|)
expr_stmt|;
name|supportedGenericUDFs
operator|.
name|add
argument_list|(
name|GenericUDFTrim
operator|.
name|class
argument_list|)
expr_stmt|;
name|supportedGenericUDFs
operator|.
name|add
argument_list|(
name|UDFSin
operator|.
name|class
argument_list|)
expr_stmt|;
name|supportedGenericUDFs
operator|.
name|add
argument_list|(
name|UDFCos
operator|.
name|class
argument_list|)
expr_stmt|;
name|supportedGenericUDFs
operator|.
name|add
argument_list|(
name|UDFTan
operator|.
name|class
argument_list|)
expr_stmt|;
name|supportedGenericUDFs
operator|.
name|add
argument_list|(
name|UDFAsin
operator|.
name|class
argument_list|)
expr_stmt|;
name|supportedGenericUDFs
operator|.
name|add
argument_list|(
name|UDFAcos
operator|.
name|class
argument_list|)
expr_stmt|;
name|supportedGenericUDFs
operator|.
name|add
argument_list|(
name|UDFAtan
operator|.
name|class
argument_list|)
expr_stmt|;
name|supportedGenericUDFs
operator|.
name|add
argument_list|(
name|UDFDegrees
operator|.
name|class
argument_list|)
expr_stmt|;
name|supportedGenericUDFs
operator|.
name|add
argument_list|(
name|UDFRadians
operator|.
name|class
argument_list|)
expr_stmt|;
name|supportedGenericUDFs
operator|.
name|add
argument_list|(
name|GenericUDFFloor
operator|.
name|class
argument_list|)
expr_stmt|;
name|supportedGenericUDFs
operator|.
name|add
argument_list|(
name|GenericUDFCeil
operator|.
name|class
argument_list|)
expr_stmt|;
name|supportedGenericUDFs
operator|.
name|add
argument_list|(
name|UDFExp
operator|.
name|class
argument_list|)
expr_stmt|;
name|supportedGenericUDFs
operator|.
name|add
argument_list|(
name|UDFLn
operator|.
name|class
argument_list|)
expr_stmt|;
name|supportedGenericUDFs
operator|.
name|add
argument_list|(
name|UDFLog2
operator|.
name|class
argument_list|)
expr_stmt|;
name|supportedGenericUDFs
operator|.
name|add
argument_list|(
name|UDFLog10
operator|.
name|class
argument_list|)
expr_stmt|;
name|supportedGenericUDFs
operator|.
name|add
argument_list|(
name|UDFLog
operator|.
name|class
argument_list|)
expr_stmt|;
name|supportedGenericUDFs
operator|.
name|add
argument_list|(
name|GenericUDFPower
operator|.
name|class
argument_list|)
expr_stmt|;
name|supportedGenericUDFs
operator|.
name|add
argument_list|(
name|GenericUDFRound
operator|.
name|class
argument_list|)
expr_stmt|;
name|supportedGenericUDFs
operator|.
name|add
argument_list|(
name|GenericUDFBRound
operator|.
name|class
argument_list|)
expr_stmt|;
name|supportedGenericUDFs
operator|.
name|add
argument_list|(
name|GenericUDFPosMod
operator|.
name|class
argument_list|)
expr_stmt|;
name|supportedGenericUDFs
operator|.
name|add
argument_list|(
name|UDFSqrt
operator|.
name|class
argument_list|)
expr_stmt|;
name|supportedGenericUDFs
operator|.
name|add
argument_list|(
name|UDFSign
operator|.
name|class
argument_list|)
expr_stmt|;
name|supportedGenericUDFs
operator|.
name|add
argument_list|(
name|UDFRand
operator|.
name|class
argument_list|)
expr_stmt|;
name|supportedGenericUDFs
operator|.
name|add
argument_list|(
name|UDFBin
operator|.
name|class
argument_list|)
expr_stmt|;
name|supportedGenericUDFs
operator|.
name|add
argument_list|(
name|UDFHex
operator|.
name|class
argument_list|)
expr_stmt|;
name|supportedGenericUDFs
operator|.
name|add
argument_list|(
name|UDFConv
operator|.
name|class
argument_list|)
expr_stmt|;
name|supportedGenericUDFs
operator|.
name|add
argument_list|(
name|GenericUDFLower
operator|.
name|class
argument_list|)
expr_stmt|;
name|supportedGenericUDFs
operator|.
name|add
argument_list|(
name|GenericUDFUpper
operator|.
name|class
argument_list|)
expr_stmt|;
name|supportedGenericUDFs
operator|.
name|add
argument_list|(
name|GenericUDFConcat
operator|.
name|class
argument_list|)
expr_stmt|;
name|supportedGenericUDFs
operator|.
name|add
argument_list|(
name|GenericUDFAbs
operator|.
name|class
argument_list|)
expr_stmt|;
name|supportedGenericUDFs
operator|.
name|add
argument_list|(
name|GenericUDFBetween
operator|.
name|class
argument_list|)
expr_stmt|;
name|supportedGenericUDFs
operator|.
name|add
argument_list|(
name|GenericUDFIn
operator|.
name|class
argument_list|)
expr_stmt|;
name|supportedGenericUDFs
operator|.
name|add
argument_list|(
name|GenericUDFCase
operator|.
name|class
argument_list|)
expr_stmt|;
name|supportedGenericUDFs
operator|.
name|add
argument_list|(
name|GenericUDFWhen
operator|.
name|class
argument_list|)
expr_stmt|;
name|supportedGenericUDFs
operator|.
name|add
argument_list|(
name|GenericUDFCoalesce
operator|.
name|class
argument_list|)
expr_stmt|;
name|supportedGenericUDFs
operator|.
name|add
argument_list|(
name|GenericUDFNvl
operator|.
name|class
argument_list|)
expr_stmt|;
name|supportedGenericUDFs
operator|.
name|add
argument_list|(
name|GenericUDFElt
operator|.
name|class
argument_list|)
expr_stmt|;
name|supportedGenericUDFs
operator|.
name|add
argument_list|(
name|GenericUDFInitCap
operator|.
name|class
argument_list|)
expr_stmt|;
name|supportedGenericUDFs
operator|.
name|add
argument_list|(
name|GenericUDFInBloomFilter
operator|.
name|class
argument_list|)
expr_stmt|;
comment|// For type casts
name|supportedGenericUDFs
operator|.
name|add
argument_list|(
name|UDFToLong
operator|.
name|class
argument_list|)
expr_stmt|;
name|supportedGenericUDFs
operator|.
name|add
argument_list|(
name|UDFToInteger
operator|.
name|class
argument_list|)
expr_stmt|;
name|supportedGenericUDFs
operator|.
name|add
argument_list|(
name|UDFToShort
operator|.
name|class
argument_list|)
expr_stmt|;
name|supportedGenericUDFs
operator|.
name|add
argument_list|(
name|UDFToByte
operator|.
name|class
argument_list|)
expr_stmt|;
name|supportedGenericUDFs
operator|.
name|add
argument_list|(
name|UDFToBoolean
operator|.
name|class
argument_list|)
expr_stmt|;
name|supportedGenericUDFs
operator|.
name|add
argument_list|(
name|UDFToFloat
operator|.
name|class
argument_list|)
expr_stmt|;
name|supportedGenericUDFs
operator|.
name|add
argument_list|(
name|UDFToDouble
operator|.
name|class
argument_list|)
expr_stmt|;
name|supportedGenericUDFs
operator|.
name|add
argument_list|(
name|UDFToString
operator|.
name|class
argument_list|)
expr_stmt|;
name|supportedGenericUDFs
operator|.
name|add
argument_list|(
name|GenericUDFTimestamp
operator|.
name|class
argument_list|)
expr_stmt|;
name|supportedGenericUDFs
operator|.
name|add
argument_list|(
name|GenericUDFToDecimal
operator|.
name|class
argument_list|)
expr_stmt|;
name|supportedGenericUDFs
operator|.
name|add
argument_list|(
name|GenericUDFToDate
operator|.
name|class
argument_list|)
expr_stmt|;
name|supportedGenericUDFs
operator|.
name|add
argument_list|(
name|GenericUDFToChar
operator|.
name|class
argument_list|)
expr_stmt|;
name|supportedGenericUDFs
operator|.
name|add
argument_list|(
name|GenericUDFToVarchar
operator|.
name|class
argument_list|)
expr_stmt|;
name|supportedGenericUDFs
operator|.
name|add
argument_list|(
name|GenericUDFToIntervalYearMonth
operator|.
name|class
argument_list|)
expr_stmt|;
name|supportedGenericUDFs
operator|.
name|add
argument_list|(
name|GenericUDFToIntervalDayTime
operator|.
name|class
argument_list|)
expr_stmt|;
comment|// For conditional expressions
name|supportedGenericUDFs
operator|.
name|add
argument_list|(
name|GenericUDFIf
operator|.
name|class
argument_list|)
expr_stmt|;
name|supportedAggregationUdfs
operator|.
name|add
argument_list|(
literal|"min"
argument_list|)
expr_stmt|;
name|supportedAggregationUdfs
operator|.
name|add
argument_list|(
literal|"max"
argument_list|)
expr_stmt|;
name|supportedAggregationUdfs
operator|.
name|add
argument_list|(
literal|"count"
argument_list|)
expr_stmt|;
name|supportedAggregationUdfs
operator|.
name|add
argument_list|(
literal|"sum"
argument_list|)
expr_stmt|;
name|supportedAggregationUdfs
operator|.
name|add
argument_list|(
literal|"avg"
argument_list|)
expr_stmt|;
name|supportedAggregationUdfs
operator|.
name|add
argument_list|(
literal|"variance"
argument_list|)
expr_stmt|;
name|supportedAggregationUdfs
operator|.
name|add
argument_list|(
literal|"var_pop"
argument_list|)
expr_stmt|;
name|supportedAggregationUdfs
operator|.
name|add
argument_list|(
literal|"var_samp"
argument_list|)
expr_stmt|;
name|supportedAggregationUdfs
operator|.
name|add
argument_list|(
literal|"std"
argument_list|)
expr_stmt|;
name|supportedAggregationUdfs
operator|.
name|add
argument_list|(
literal|"stddev"
argument_list|)
expr_stmt|;
name|supportedAggregationUdfs
operator|.
name|add
argument_list|(
literal|"stddev_pop"
argument_list|)
expr_stmt|;
name|supportedAggregationUdfs
operator|.
name|add
argument_list|(
literal|"stddev_samp"
argument_list|)
expr_stmt|;
name|supportedAggregationUdfs
operator|.
name|add
argument_list|(
literal|"bloom_filter"
argument_list|)
expr_stmt|;
block|}
specifier|private
class|class
name|VectorTaskColumnInfo
block|{
name|List
argument_list|<
name|String
argument_list|>
name|allColumnNames
decl_stmt|;
name|List
argument_list|<
name|TypeInfo
argument_list|>
name|allTypeInfos
decl_stmt|;
name|List
argument_list|<
name|Integer
argument_list|>
name|dataColumnNums
decl_stmt|;
name|int
name|partitionColumnCount
decl_stmt|;
name|List
argument_list|<
name|VirtualColumn
argument_list|>
name|availableVirtualColumnList
decl_stmt|;
name|List
argument_list|<
name|VirtualColumn
argument_list|>
name|neededVirtualColumnList
decl_stmt|;
comment|//not to be confused with useVectorizedInputFileFormat at Vectorizer level
comment|//which represents the value of configuration hive.vectorized.use.vectorized.input.format
specifier|private
name|boolean
name|useVectorizedInputFileFormat
decl_stmt|;
name|Set
argument_list|<
name|Support
argument_list|>
name|inputFormatSupportSet
decl_stmt|;
name|Set
argument_list|<
name|Support
argument_list|>
name|supportSetInUse
decl_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|supportRemovedReasons
decl_stmt|;
name|List
argument_list|<
name|DataTypePhysicalVariation
argument_list|>
name|allDataTypePhysicalVariations
decl_stmt|;
name|boolean
name|allNative
decl_stmt|;
name|boolean
name|usesVectorUDFAdaptor
decl_stmt|;
name|String
index|[]
name|scratchTypeNameArray
decl_stmt|;
name|DataTypePhysicalVariation
index|[]
name|scratchdataTypePhysicalVariations
decl_stmt|;
name|String
name|reduceColumnSortOrder
decl_stmt|;
name|String
name|reduceColumnNullOrder
decl_stmt|;
name|VectorTaskColumnInfo
parameter_list|()
block|{
name|partitionColumnCount
operator|=
literal|0
expr_stmt|;
block|}
specifier|public
name|void
name|assume
parameter_list|()
block|{
name|allNative
operator|=
literal|true
expr_stmt|;
name|usesVectorUDFAdaptor
operator|=
literal|false
expr_stmt|;
block|}
specifier|public
name|void
name|setAllColumnNames
parameter_list|(
name|List
argument_list|<
name|String
argument_list|>
name|allColumnNames
parameter_list|)
block|{
name|this
operator|.
name|allColumnNames
operator|=
name|allColumnNames
expr_stmt|;
block|}
specifier|public
name|void
name|setAllTypeInfos
parameter_list|(
name|List
argument_list|<
name|TypeInfo
argument_list|>
name|allTypeInfos
parameter_list|)
block|{
name|this
operator|.
name|allTypeInfos
operator|=
name|allTypeInfos
expr_stmt|;
block|}
specifier|public
name|void
name|setDataColumnNums
parameter_list|(
name|List
argument_list|<
name|Integer
argument_list|>
name|dataColumnNums
parameter_list|)
block|{
name|this
operator|.
name|dataColumnNums
operator|=
name|dataColumnNums
expr_stmt|;
block|}
specifier|public
name|void
name|setPartitionColumnCount
parameter_list|(
name|int
name|partitionColumnCount
parameter_list|)
block|{
name|this
operator|.
name|partitionColumnCount
operator|=
name|partitionColumnCount
expr_stmt|;
block|}
specifier|public
name|void
name|setAvailableVirtualColumnList
parameter_list|(
name|List
argument_list|<
name|VirtualColumn
argument_list|>
name|availableVirtualColumnList
parameter_list|)
block|{
name|this
operator|.
name|availableVirtualColumnList
operator|=
name|availableVirtualColumnList
expr_stmt|;
block|}
specifier|public
name|void
name|setNeededVirtualColumnList
parameter_list|(
name|List
argument_list|<
name|VirtualColumn
argument_list|>
name|neededVirtualColumnList
parameter_list|)
block|{
name|this
operator|.
name|neededVirtualColumnList
operator|=
name|neededVirtualColumnList
expr_stmt|;
block|}
specifier|public
name|void
name|setSupportSetInUse
parameter_list|(
name|Set
argument_list|<
name|Support
argument_list|>
name|supportSetInUse
parameter_list|)
block|{
name|this
operator|.
name|supportSetInUse
operator|=
name|supportSetInUse
expr_stmt|;
block|}
specifier|public
name|void
name|setSupportRemovedReasons
parameter_list|(
name|List
argument_list|<
name|String
argument_list|>
name|supportRemovedReasons
parameter_list|)
block|{
name|this
operator|.
name|supportRemovedReasons
operator|=
name|supportRemovedReasons
expr_stmt|;
block|}
specifier|public
name|void
name|setAlldataTypePhysicalVariations
parameter_list|(
name|List
argument_list|<
name|DataTypePhysicalVariation
argument_list|>
name|allDataTypePhysicalVariations
parameter_list|)
block|{
name|this
operator|.
name|allDataTypePhysicalVariations
operator|=
name|allDataTypePhysicalVariations
expr_stmt|;
block|}
specifier|public
name|void
name|setScratchTypeNameArray
parameter_list|(
name|String
index|[]
name|scratchTypeNameArray
parameter_list|)
block|{
name|this
operator|.
name|scratchTypeNameArray
operator|=
name|scratchTypeNameArray
expr_stmt|;
block|}
specifier|public
name|void
name|setScratchdataTypePhysicalVariationsArray
parameter_list|(
name|DataTypePhysicalVariation
index|[]
name|scratchdataTypePhysicalVariations
parameter_list|)
block|{
name|this
operator|.
name|scratchdataTypePhysicalVariations
operator|=
name|scratchdataTypePhysicalVariations
expr_stmt|;
block|}
specifier|public
name|void
name|setAllNative
parameter_list|(
name|boolean
name|allNative
parameter_list|)
block|{
name|this
operator|.
name|allNative
operator|=
name|allNative
expr_stmt|;
block|}
specifier|public
name|void
name|setUsesVectorUDFAdaptor
parameter_list|(
name|boolean
name|usesVectorUDFAdaptor
parameter_list|)
block|{
name|this
operator|.
name|usesVectorUDFAdaptor
operator|=
name|usesVectorUDFAdaptor
expr_stmt|;
block|}
specifier|public
name|void
name|setUseVectorizedInputFileFormat
parameter_list|(
name|boolean
name|useVectorizedInputFileFormat
parameter_list|)
block|{
name|this
operator|.
name|useVectorizedInputFileFormat
operator|=
name|useVectorizedInputFileFormat
expr_stmt|;
block|}
specifier|public
name|void
name|setInputFormatSupportSet
parameter_list|(
name|Set
argument_list|<
name|Support
argument_list|>
name|inputFormatSupportSet
parameter_list|)
block|{
name|this
operator|.
name|inputFormatSupportSet
operator|=
name|inputFormatSupportSet
expr_stmt|;
block|}
specifier|public
name|void
name|setReduceColumnSortOrder
parameter_list|(
name|String
name|reduceColumnSortOrder
parameter_list|)
block|{
name|this
operator|.
name|reduceColumnSortOrder
operator|=
name|reduceColumnSortOrder
expr_stmt|;
block|}
specifier|public
name|void
name|setReduceColumnNullOrder
parameter_list|(
name|String
name|reduceColumnNullOrder
parameter_list|)
block|{
name|this
operator|.
name|reduceColumnNullOrder
operator|=
name|reduceColumnNullOrder
expr_stmt|;
block|}
specifier|public
name|void
name|transferToBaseWork
parameter_list|(
name|BaseWork
name|baseWork
parameter_list|)
block|{
specifier|final
name|int
name|virtualColumnCount
init|=
operator|(
name|availableVirtualColumnList
operator|==
literal|null
condition|?
literal|0
else|:
name|availableVirtualColumnList
operator|.
name|size
argument_list|()
operator|)
decl_stmt|;
name|VirtualColumn
index|[]
name|neededVirtualColumns
decl_stmt|;
if|if
condition|(
name|neededVirtualColumnList
operator|!=
literal|null
operator|&&
name|neededVirtualColumnList
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
name|neededVirtualColumns
operator|=
name|neededVirtualColumnList
operator|.
name|toArray
argument_list|(
operator|new
name|VirtualColumn
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|neededVirtualColumns
operator|=
operator|new
name|VirtualColumn
index|[
literal|0
index|]
expr_stmt|;
block|}
name|String
index|[]
name|allColumnNameArray
init|=
name|allColumnNames
operator|.
name|toArray
argument_list|(
operator|new
name|String
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
name|TypeInfo
index|[]
name|allTypeInfoArray
init|=
name|allTypeInfos
operator|.
name|toArray
argument_list|(
operator|new
name|TypeInfo
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
name|int
index|[]
name|dataColumnNumsArray
decl_stmt|;
if|if
condition|(
name|dataColumnNums
operator|!=
literal|null
condition|)
block|{
name|dataColumnNumsArray
operator|=
name|ArrayUtils
operator|.
name|toPrimitive
argument_list|(
name|dataColumnNums
operator|.
name|toArray
argument_list|(
operator|new
name|Integer
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|dataColumnNumsArray
operator|=
literal|null
expr_stmt|;
block|}
name|DataTypePhysicalVariation
index|[]
name|allDataTypePhysicalVariationArray
decl_stmt|;
if|if
condition|(
name|allDataTypePhysicalVariations
operator|==
literal|null
condition|)
block|{
name|allDataTypePhysicalVariationArray
operator|=
operator|new
name|DataTypePhysicalVariation
index|[
name|allTypeInfoArray
operator|.
name|length
index|]
expr_stmt|;
name|Arrays
operator|.
name|fill
argument_list|(
name|allDataTypePhysicalVariationArray
argument_list|,
name|DataTypePhysicalVariation
operator|.
name|NONE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|allDataTypePhysicalVariationArray
operator|=
name|allDataTypePhysicalVariations
operator|.
name|toArray
argument_list|(
operator|new
name|DataTypePhysicalVariation
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
name|VectorizedRowBatchCtx
name|vectorizedRowBatchCtx
init|=
operator|new
name|VectorizedRowBatchCtx
argument_list|(
name|allColumnNameArray
argument_list|,
name|allTypeInfoArray
argument_list|,
name|allDataTypePhysicalVariationArray
argument_list|,
name|dataColumnNumsArray
argument_list|,
name|partitionColumnCount
argument_list|,
name|virtualColumnCount
argument_list|,
name|neededVirtualColumns
argument_list|,
name|scratchTypeNameArray
argument_list|,
name|scratchdataTypePhysicalVariations
argument_list|)
decl_stmt|;
name|baseWork
operator|.
name|setVectorizedRowBatchCtx
argument_list|(
name|vectorizedRowBatchCtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|baseWork
operator|instanceof
name|MapWork
condition|)
block|{
name|MapWork
name|mapWork
init|=
operator|(
name|MapWork
operator|)
name|baseWork
decl_stmt|;
name|mapWork
operator|.
name|setUseVectorizedInputFileFormat
argument_list|(
name|useVectorizedInputFileFormat
argument_list|)
expr_stmt|;
name|mapWork
operator|.
name|setInputFormatSupportSet
argument_list|(
name|inputFormatSupportSet
argument_list|)
expr_stmt|;
name|mapWork
operator|.
name|setSupportSetInUse
argument_list|(
name|supportSetInUse
argument_list|)
expr_stmt|;
name|mapWork
operator|.
name|setSupportRemovedReasons
argument_list|(
name|supportRemovedReasons
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|baseWork
operator|instanceof
name|ReduceWork
condition|)
block|{
name|ReduceWork
name|reduceWork
init|=
operator|(
name|ReduceWork
operator|)
name|baseWork
decl_stmt|;
name|reduceWork
operator|.
name|setVectorReduceColumnSortOrder
argument_list|(
name|reduceColumnSortOrder
argument_list|)
expr_stmt|;
name|reduceWork
operator|.
name|setVectorReduceColumnNullOrder
argument_list|(
name|reduceColumnNullOrder
argument_list|)
expr_stmt|;
block|}
name|baseWork
operator|.
name|setAllNative
argument_list|(
name|allNative
argument_list|)
expr_stmt|;
name|baseWork
operator|.
name|setUsesVectorUDFAdaptor
argument_list|(
name|usesVectorUDFAdaptor
argument_list|)
expr_stmt|;
name|baseWork
operator|.
name|setIsTestForcedVectorizationEnable
argument_list|(
name|isTestForcedVectorizationEnable
argument_list|)
expr_stmt|;
name|baseWork
operator|.
name|setIsTestVectorizationSuppressExplainExecutionMode
argument_list|(
name|isTestVectorizationSuppressExplainExecutionMode
argument_list|)
expr_stmt|;
block|}
block|}
comment|/*    * Used as a dummy root operator to attach vectorized operators that will be built in parallel    * to the current non-vectorized operator tree.    */
specifier|private
specifier|static
class|class
name|DummyRootVectorDesc
extends|extends
name|AbstractOperatorDesc
block|{
specifier|public
name|DummyRootVectorDesc
parameter_list|()
block|{
name|super
argument_list|()
expr_stmt|;
block|}
block|}
specifier|private
specifier|static
class|class
name|DummyOperator
extends|extends
name|Operator
argument_list|<
name|DummyRootVectorDesc
argument_list|>
block|{
specifier|public
name|DummyOperator
parameter_list|()
block|{
name|super
argument_list|(
operator|new
name|CompilationOpContext
argument_list|()
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|process
parameter_list|(
name|Object
name|row
parameter_list|,
name|int
name|tag
parameter_list|)
throws|throws
name|HiveException
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Not used"
argument_list|)
throw|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|getName
parameter_list|()
block|{
return|return
literal|"DUMMY"
return|;
block|}
annotation|@
name|Override
specifier|public
name|OperatorType
name|getType
parameter_list|()
block|{
return|return
literal|null
return|;
block|}
block|}
specifier|private
specifier|static
class|class
name|DummyVectorOperator
extends|extends
name|DummyOperator
implements|implements
name|VectorizationOperator
block|{
specifier|private
name|VectorizationContext
name|vContext
decl_stmt|;
specifier|public
name|DummyVectorOperator
parameter_list|(
name|VectorizationContext
name|vContext
parameter_list|)
block|{
name|super
argument_list|()
expr_stmt|;
name|this
operator|.
name|conf
operator|=
operator|(
name|DummyRootVectorDesc
operator|)
operator|new
name|DummyRootVectorDesc
argument_list|()
expr_stmt|;
name|this
operator|.
name|vContext
operator|=
name|vContext
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|VectorizationContext
name|getInputVectorizationContext
parameter_list|()
block|{
return|return
name|vContext
return|;
block|}
annotation|@
name|Override
specifier|public
name|VectorDesc
name|getVectorDesc
parameter_list|()
block|{
return|return
literal|null
return|;
block|}
block|}
specifier|private
name|List
argument_list|<
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
argument_list|>
name|newOperatorList
parameter_list|()
block|{
return|return
operator|new
name|ArrayList
argument_list|<
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
argument_list|>
argument_list|()
return|;
block|}
specifier|private
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
name|validateAndVectorizeOperatorTree
parameter_list|(
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
name|nonVecRootOperator
parameter_list|,
name|boolean
name|isReduce
parameter_list|,
name|boolean
name|isTezOrSpark
parameter_list|,
name|VectorTaskColumnInfo
name|vectorTaskColumnInfo
parameter_list|)
throws|throws
name|VectorizerCannotVectorizeException
block|{
name|VectorizationContext
name|taskVContext
init|=
operator|new
name|VectorizationContext
argument_list|(
literal|"Task"
argument_list|,
name|vectorTaskColumnInfo
operator|.
name|allColumnNames
argument_list|,
name|vectorTaskColumnInfo
operator|.
name|allTypeInfos
argument_list|,
name|vectorTaskColumnInfo
operator|.
name|allDataTypePhysicalVariations
argument_list|,
name|hiveConf
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
argument_list|>
name|currentParentList
init|=
name|newOperatorList
argument_list|()
decl_stmt|;
name|currentParentList
operator|.
name|add
argument_list|(
name|nonVecRootOperator
argument_list|)
expr_stmt|;
comment|// Start with dummy vector operator as the parent of the parallel vector operator tree we are
comment|// creating
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
name|dummyVectorOperator
init|=
operator|new
name|DummyVectorOperator
argument_list|(
name|taskVContext
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
argument_list|>
name|currentVectorParentList
init|=
name|newOperatorList
argument_list|()
decl_stmt|;
name|currentVectorParentList
operator|.
name|add
argument_list|(
name|dummyVectorOperator
argument_list|)
expr_stmt|;
name|delayedFixups
operator|.
name|clear
argument_list|()
expr_stmt|;
do|do
block|{
name|List
argument_list|<
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
argument_list|>
name|nextParentList
init|=
name|newOperatorList
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
argument_list|>
name|nextVectorParentList
init|=
name|newOperatorList
argument_list|()
decl_stmt|;
specifier|final
name|int
name|count
init|=
name|currentParentList
operator|.
name|size
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
name|parent
init|=
name|currentParentList
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
argument_list|>
name|childrenList
init|=
name|parent
operator|.
name|getChildOperators
argument_list|()
decl_stmt|;
if|if
condition|(
name|childrenList
operator|==
literal|null
operator|||
name|childrenList
operator|.
name|size
argument_list|()
operator|==
literal|0
condition|)
block|{
continue|continue;
block|}
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
name|vectorParent
init|=
name|currentVectorParentList
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
comment|/*          * Vectorize this parent's children.  Plug them into vectorParent's children list.          *          * Add those children / vector children to nextParentList / nextVectorParentList.          */
name|doProcessChildren
argument_list|(
name|parent
argument_list|,
name|vectorParent
argument_list|,
name|nextParentList
argument_list|,
name|nextVectorParentList
argument_list|,
name|isReduce
argument_list|,
name|isTezOrSpark
argument_list|,
name|vectorTaskColumnInfo
argument_list|)
expr_stmt|;
block|}
name|currentParentList
operator|=
name|nextParentList
expr_stmt|;
name|currentVectorParentList
operator|=
name|nextVectorParentList
expr_stmt|;
block|}
do|while
condition|(
name|currentParentList
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
do|;
name|runDelayedFixups
argument_list|()
expr_stmt|;
return|return
name|dummyVectorOperator
return|;
block|}
specifier|private
name|void
name|doProcessChildren
parameter_list|(
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
name|parent
parameter_list|,
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
name|vectorParent
parameter_list|,
name|List
argument_list|<
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
argument_list|>
name|nextParentList
parameter_list|,
name|List
argument_list|<
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
argument_list|>
name|nextVectorParentList
parameter_list|,
name|boolean
name|isReduce
parameter_list|,
name|boolean
name|isTezOrSpark
parameter_list|,
name|VectorTaskColumnInfo
name|vectorTaskColumnInfo
parameter_list|)
throws|throws
name|VectorizerCannotVectorizeException
block|{
name|List
argument_list|<
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
argument_list|>
name|vectorChildren
init|=
name|newOperatorList
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
argument_list|>
name|children
init|=
name|parent
operator|.
name|getChildOperators
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|List
argument_list|<
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
argument_list|>
argument_list|>
name|listOfChildMultipleParents
init|=
operator|new
name|ArrayList
argument_list|<
name|List
argument_list|<
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
argument_list|>
argument_list|>
argument_list|()
decl_stmt|;
specifier|final
name|int
name|childrenCount
init|=
name|children
operator|.
name|size
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|childrenCount
condition|;
name|i
operator|++
control|)
block|{
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
name|child
init|=
name|children
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
name|vectorChild
init|=
name|doProcessChild
argument_list|(
name|child
argument_list|,
name|vectorParent
argument_list|,
name|isReduce
argument_list|,
name|isTezOrSpark
argument_list|,
name|vectorTaskColumnInfo
argument_list|)
decl_stmt|;
name|fixupNewVectorChild
argument_list|(
name|parent
argument_list|,
name|vectorParent
argument_list|,
name|child
argument_list|,
name|vectorChild
argument_list|)
expr_stmt|;
name|nextParentList
operator|.
name|add
argument_list|(
name|child
argument_list|)
expr_stmt|;
name|nextVectorParentList
operator|.
name|add
argument_list|(
name|vectorChild
argument_list|)
expr_stmt|;
block|}
block|}
comment|/*    * Fixup the children and parents of a new vector child.    *    * 1) Add new vector child to the vector parent's children list.    *    * 2) Copy and fixup the parent list of the original child instead of just assuming a 1:1    *    relationship.    *    *    a) When the child is MapJoinOperator, it will have an extra parent HashTableDummyOperator    *       for the MapJoinOperator's small table.  It needs to be fixed up, too.    */
specifier|private
name|void
name|fixupNewVectorChild
parameter_list|(
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
name|parent
parameter_list|,
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
name|vectorParent
parameter_list|,
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
name|child
parameter_list|,
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
name|vectorChild
parameter_list|)
block|{
comment|// 1) Add new vector child to the vector parent's children list.
name|vectorParent
operator|.
name|getChildOperators
argument_list|()
operator|.
name|add
argument_list|(
name|vectorChild
argument_list|)
expr_stmt|;
comment|// 2) Copy and fixup the parent list of the original child instead of just assuming a 1:1
comment|//    relationship.
name|List
argument_list|<
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
argument_list|>
name|childMultipleParents
init|=
name|newOperatorList
argument_list|()
decl_stmt|;
name|childMultipleParents
operator|.
name|addAll
argument_list|(
name|child
operator|.
name|getParentOperators
argument_list|()
argument_list|)
expr_stmt|;
specifier|final
name|int
name|childMultipleParentCount
init|=
name|childMultipleParents
operator|.
name|size
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|childMultipleParentCount
condition|;
name|i
operator|++
control|)
block|{
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
name|childMultipleParent
init|=
name|childMultipleParents
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|childMultipleParent
operator|==
name|parent
condition|)
block|{
name|childMultipleParents
operator|.
name|set
argument_list|(
name|i
argument_list|,
name|vectorParent
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|queueDelayedFixup
argument_list|(
name|childMultipleParent
argument_list|,
name|child
argument_list|,
name|vectorChild
argument_list|)
expr_stmt|;
block|}
block|}
name|vectorChild
operator|.
name|setParentOperators
argument_list|(
name|childMultipleParents
argument_list|)
expr_stmt|;
block|}
comment|/*    * The fix up is delayed so that the parent operators aren't modified until the entire operator    * tree has been vectorized.    */
specifier|private
name|void
name|queueDelayedFixup
parameter_list|(
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
name|parent
parameter_list|,
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
name|child
parameter_list|,
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
name|vectorChild
parameter_list|)
block|{
if|if
condition|(
name|delayedFixups
operator|.
name|get
argument_list|(
name|parent
argument_list|)
operator|==
literal|null
condition|)
block|{
name|HashSet
argument_list|<
name|ImmutablePair
argument_list|<
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
argument_list|,
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
argument_list|>
argument_list|>
name|value
init|=
operator|new
name|HashSet
argument_list|<
name|ImmutablePair
argument_list|<
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
argument_list|,
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
argument_list|>
argument_list|>
argument_list|(
literal|1
argument_list|)
decl_stmt|;
name|delayedFixups
operator|.
name|put
argument_list|(
name|parent
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
name|delayedFixups
operator|.
name|get
argument_list|(
name|parent
argument_list|)
operator|.
name|add
argument_list|(
operator|new
name|ImmutablePair
argument_list|<
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
argument_list|,
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
argument_list|>
argument_list|(
name|child
argument_list|,
name|vectorChild
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|runDelayedFixups
parameter_list|()
block|{
for|for
control|(
name|Entry
argument_list|<
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
argument_list|,
name|Set
argument_list|<
name|ImmutablePair
argument_list|<
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
argument_list|,
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
argument_list|>
argument_list|>
argument_list|>
name|delayed
range|:
name|delayedFixups
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
name|key
init|=
name|delayed
operator|.
name|getKey
argument_list|()
decl_stmt|;
name|Set
argument_list|<
name|ImmutablePair
argument_list|<
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
argument_list|,
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
argument_list|>
argument_list|>
name|value
init|=
name|delayed
operator|.
name|getValue
argument_list|()
decl_stmt|;
for|for
control|(
name|ImmutablePair
argument_list|<
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
argument_list|,
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
argument_list|>
name|swap
range|:
name|value
control|)
block|{
name|fixupOtherParent
argument_list|(
name|key
argument_list|,
name|swap
operator|.
name|getLeft
argument_list|()
argument_list|,
name|swap
operator|.
name|getRight
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
name|delayedFixups
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
specifier|private
name|void
name|fixupOtherParent
parameter_list|(
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
name|childMultipleParent
parameter_list|,
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
name|child
parameter_list|,
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
name|vectorChild
parameter_list|)
block|{
name|List
argument_list|<
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
argument_list|>
name|children
init|=
name|childMultipleParent
operator|.
name|getChildOperators
argument_list|()
decl_stmt|;
specifier|final
name|int
name|childrenCount
init|=
name|children
operator|.
name|size
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|childrenCount
condition|;
name|i
operator|++
control|)
block|{
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
name|myChild
init|=
name|children
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|myChild
operator|==
name|child
condition|)
block|{
name|children
operator|.
name|set
argument_list|(
name|i
argument_list|,
name|vectorChild
argument_list|)
expr_stmt|;
block|}
block|}
block|}
specifier|private
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
name|doProcessChild
parameter_list|(
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
name|child
parameter_list|,
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
name|vectorParent
parameter_list|,
name|boolean
name|isReduce
parameter_list|,
name|boolean
name|isTezOrSpark
parameter_list|,
name|VectorTaskColumnInfo
name|vectorTaskColumnInfo
parameter_list|)
throws|throws
name|VectorizerCannotVectorizeException
block|{
comment|// Use vector parent to get VectorizationContext.
specifier|final
name|VectorizationContext
name|vContext
decl_stmt|;
if|if
condition|(
name|vectorParent
operator|instanceof
name|VectorizationContextRegion
condition|)
block|{
name|vContext
operator|=
operator|(
operator|(
name|VectorizationContextRegion
operator|)
name|vectorParent
operator|)
operator|.
name|getOutputVectorizationContext
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|vContext
operator|=
operator|(
operator|(
name|VectorizationOperator
operator|)
name|vectorParent
operator|)
operator|.
name|getInputVectorizationContext
argument_list|()
expr_stmt|;
block|}
name|OperatorDesc
name|desc
init|=
name|child
operator|.
name|getConf
argument_list|()
decl_stmt|;
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
name|vectorChild
decl_stmt|;
try|try
block|{
name|vectorChild
operator|=
name|validateAndVectorizeOperator
argument_list|(
name|child
argument_list|,
name|vContext
argument_list|,
name|isReduce
argument_list|,
name|isTezOrSpark
argument_list|,
name|vectorTaskColumnInfo
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|HiveException
name|e
parameter_list|)
block|{
name|String
name|issue
init|=
literal|"exception: "
operator|+
name|VectorizationContext
operator|.
name|getStackTraceAsSingleLine
argument_list|(
name|e
argument_list|)
decl_stmt|;
name|setNodeIssue
argument_list|(
name|issue
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|VectorizerCannotVectorizeException
argument_list|()
throw|;
block|}
return|return
name|vectorChild
return|;
block|}
class|class
name|VectorizationDispatcher
implements|implements
name|Dispatcher
block|{
annotation|@
name|Override
specifier|public
name|Object
name|dispatch
parameter_list|(
name|Node
name|nd
parameter_list|,
name|Stack
argument_list|<
name|Node
argument_list|>
name|stack
parameter_list|,
name|Object
modifier|...
name|nodeOutputs
parameter_list|)
throws|throws
name|SemanticException
block|{
name|Task
argument_list|<
name|?
extends|extends
name|Serializable
argument_list|>
name|currTask
init|=
operator|(
name|Task
argument_list|<
name|?
extends|extends
name|Serializable
argument_list|>
operator|)
name|nd
decl_stmt|;
if|if
condition|(
name|currTask
operator|instanceof
name|MapRedTask
condition|)
block|{
name|MapredWork
name|mapredWork
init|=
operator|(
operator|(
name|MapRedTask
operator|)
name|currTask
operator|)
operator|.
name|getWork
argument_list|()
decl_stmt|;
name|MapWork
name|mapWork
init|=
name|mapredWork
operator|.
name|getMapWork
argument_list|()
decl_stmt|;
name|setMapWorkExplainConditions
argument_list|(
name|mapWork
argument_list|)
expr_stmt|;
name|convertMapWork
argument_list|(
name|mapredWork
operator|.
name|getMapWork
argument_list|()
argument_list|,
comment|/* isTezOrSpark */
literal|false
argument_list|)
expr_stmt|;
name|logMapWorkExplainVectorization
argument_list|(
name|mapWork
argument_list|)
expr_stmt|;
name|ReduceWork
name|reduceWork
init|=
name|mapredWork
operator|.
name|getReduceWork
argument_list|()
decl_stmt|;
if|if
condition|(
name|reduceWork
operator|!=
literal|null
condition|)
block|{
comment|// Always set the EXPLAIN conditions.
name|setReduceWorkExplainConditions
argument_list|(
name|reduceWork
argument_list|)
expr_stmt|;
comment|// We do not vectorize MR Reduce.
name|logReduceWorkExplainVectorization
argument_list|(
name|reduceWork
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|currTask
operator|instanceof
name|TezTask
condition|)
block|{
name|TezWork
name|work
init|=
operator|(
operator|(
name|TezTask
operator|)
name|currTask
operator|)
operator|.
name|getWork
argument_list|()
decl_stmt|;
for|for
control|(
name|BaseWork
name|baseWork
range|:
name|work
operator|.
name|getAllWork
argument_list|()
control|)
block|{
if|if
condition|(
name|baseWork
operator|instanceof
name|MapWork
condition|)
block|{
name|MapWork
name|mapWork
init|=
operator|(
name|MapWork
operator|)
name|baseWork
decl_stmt|;
name|setMapWorkExplainConditions
argument_list|(
name|mapWork
argument_list|)
expr_stmt|;
name|convertMapWork
argument_list|(
name|mapWork
argument_list|,
comment|/* isTezOrSpark */
literal|true
argument_list|)
expr_stmt|;
name|logMapWorkExplainVectorization
argument_list|(
name|mapWork
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|baseWork
operator|instanceof
name|ReduceWork
condition|)
block|{
name|ReduceWork
name|reduceWork
init|=
operator|(
name|ReduceWork
operator|)
name|baseWork
decl_stmt|;
comment|// Always set the EXPLAIN conditions.
name|setReduceWorkExplainConditions
argument_list|(
name|reduceWork
argument_list|)
expr_stmt|;
comment|// We are only vectorizing Reduce under Tez/Spark.
if|if
condition|(
name|isReduceVectorizationEnabled
condition|)
block|{
name|convertReduceWork
argument_list|(
name|reduceWork
argument_list|)
expr_stmt|;
block|}
name|logReduceWorkExplainVectorization
argument_list|(
name|reduceWork
argument_list|)
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|currTask
operator|instanceof
name|SparkTask
condition|)
block|{
name|SparkWork
name|sparkWork
init|=
operator|(
name|SparkWork
operator|)
name|currTask
operator|.
name|getWork
argument_list|()
decl_stmt|;
for|for
control|(
name|BaseWork
name|baseWork
range|:
name|sparkWork
operator|.
name|getAllWork
argument_list|()
control|)
block|{
if|if
condition|(
name|baseWork
operator|instanceof
name|MapWork
condition|)
block|{
name|MapWork
name|mapWork
init|=
operator|(
name|MapWork
operator|)
name|baseWork
decl_stmt|;
name|setMapWorkExplainConditions
argument_list|(
name|mapWork
argument_list|)
expr_stmt|;
name|convertMapWork
argument_list|(
name|mapWork
argument_list|,
comment|/* isTezOrSpark */
literal|true
argument_list|)
expr_stmt|;
name|logMapWorkExplainVectorization
argument_list|(
name|mapWork
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|baseWork
operator|instanceof
name|ReduceWork
condition|)
block|{
name|ReduceWork
name|reduceWork
init|=
operator|(
name|ReduceWork
operator|)
name|baseWork
decl_stmt|;
comment|// Always set the EXPLAIN conditions.
name|setReduceWorkExplainConditions
argument_list|(
name|reduceWork
argument_list|)
expr_stmt|;
if|if
condition|(
name|isReduceVectorizationEnabled
condition|)
block|{
name|convertReduceWork
argument_list|(
name|reduceWork
argument_list|)
expr_stmt|;
block|}
name|logReduceWorkExplainVectorization
argument_list|(
name|reduceWork
argument_list|)
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|currTask
operator|instanceof
name|FetchTask
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Vectorizing Fetch not supported"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Ignoring vectorization of "
operator|+
name|currTask
operator|.
name|getClass
argument_list|()
operator|.
name|getSimpleName
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
return|return
literal|null
return|;
block|}
specifier|private
name|void
name|setExplainConditions
parameter_list|(
name|BaseWork
name|baseWork
parameter_list|)
block|{
comment|// Global used when setting errors, etc.
name|currentBaseWork
operator|=
name|baseWork
expr_stmt|;
name|baseWork
operator|.
name|setVectorizedVertexNum
argument_list|(
operator|++
name|vectorizedVertexNum
argument_list|)
expr_stmt|;
name|baseWork
operator|.
name|setVectorizationExamined
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|setMapWorkExplainConditions
parameter_list|(
name|MapWork
name|mapWork
parameter_list|)
block|{
name|setExplainConditions
argument_list|(
name|mapWork
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|setReduceWorkExplainConditions
parameter_list|(
name|ReduceWork
name|reduceWork
parameter_list|)
block|{
name|setExplainConditions
argument_list|(
name|reduceWork
argument_list|)
expr_stmt|;
name|reduceWork
operator|.
name|setReduceVectorizationEnabled
argument_list|(
name|isReduceVectorizationEnabled
argument_list|)
expr_stmt|;
name|reduceWork
operator|.
name|setVectorReduceEngine
argument_list|(
name|HiveConf
operator|.
name|getVar
argument_list|(
name|hiveConf
argument_list|,
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVE_EXECUTION_ENGINE
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|private
name|boolean
name|logExplainVectorization
parameter_list|(
name|BaseWork
name|baseWork
parameter_list|,
name|String
name|name
parameter_list|)
block|{
if|if
condition|(
operator|!
name|baseWork
operator|.
name|getVectorizationExamined
argument_list|()
condition|)
block|{
return|return
literal|false
return|;
block|}
name|LOG
operator|.
name|info
argument_list|(
name|name
operator|+
literal|" vectorization enabled: "
operator|+
name|baseWork
operator|.
name|getVectorizationEnabled
argument_list|()
argument_list|)
expr_stmt|;
name|boolean
name|isVectorized
init|=
name|baseWork
operator|.
name|getVectorMode
argument_list|()
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
name|name
operator|+
literal|" vectorized: "
operator|+
name|isVectorized
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|isVectorized
condition|)
block|{
name|VectorizerReason
name|notVectorizedReason
init|=
name|baseWork
operator|.
name|getNotVectorizedReason
argument_list|()
decl_stmt|;
if|if
condition|(
name|notVectorizedReason
operator|!=
literal|null
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
name|name
operator|+
literal|" notVectorizedReason: "
operator|+
name|notVectorizedReason
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
name|LOG
operator|.
name|info
argument_list|(
name|name
operator|+
literal|" vectorizedVertexNum: "
operator|+
name|baseWork
operator|.
name|getVectorizedVertexNum
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
operator|&&
name|isVectorized
condition|)
block|{
name|VectorizedRowBatchCtx
name|batchContext
init|=
name|baseWork
operator|.
name|getVectorizedRowBatchCtx
argument_list|()
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
name|name
operator|+
literal|" dataColumnCount: "
operator|+
name|batchContext
operator|.
name|getDataColumnCount
argument_list|()
argument_list|)
expr_stmt|;
name|int
index|[]
name|dataColumnNums
init|=
name|batchContext
operator|.
name|getDataColumnNums
argument_list|()
decl_stmt|;
if|if
condition|(
name|dataColumnNums
operator|!=
literal|null
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
name|name
operator|+
literal|" includeColumns: "
operator|+
name|Arrays
operator|.
name|toString
argument_list|(
name|dataColumnNums
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|LOG
operator|.
name|debug
argument_list|(
name|name
operator|+
literal|" partitionColumnCount: "
operator|+
name|batchContext
operator|.
name|getPartitionColumnCount
argument_list|()
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
name|name
operator|+
literal|" dataColumns: "
operator|+
name|BaseWork
operator|.
name|BaseExplainVectorization
operator|.
name|getColumns
argument_list|(
name|batchContext
argument_list|,
literal|0
argument_list|,
name|batchContext
operator|.
name|getDataColumnCount
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
name|name
operator|+
literal|" scratchColumnTypeNames: "
operator|+
name|BaseWork
operator|.
name|BaseExplainVectorization
operator|.
name|getScratchColumns
argument_list|(
name|batchContext
argument_list|)
argument_list|)
expr_stmt|;
name|VirtualColumn
index|[]
name|neededVirtualColumns
init|=
name|batchContext
operator|.
name|getNeededVirtualColumns
argument_list|()
decl_stmt|;
if|if
condition|(
name|neededVirtualColumns
operator|!=
literal|null
operator|&&
name|neededVirtualColumns
operator|.
name|length
operator|!=
literal|0
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
name|name
operator|+
literal|" neededVirtualColumns: "
operator|+
name|Arrays
operator|.
name|toString
argument_list|(
name|neededVirtualColumns
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return
literal|true
return|;
block|}
specifier|private
name|void
name|logMapWorkExplainVectorization
parameter_list|(
name|MapWork
name|mapWork
parameter_list|)
block|{
if|if
condition|(
operator|!
name|logExplainVectorization
argument_list|(
name|mapWork
argument_list|,
literal|"Map"
argument_list|)
condition|)
block|{
return|return;
block|}
comment|// Conditions.
name|List
argument_list|<
name|String
argument_list|>
name|enabledConditionsMet
init|=
name|mapWork
operator|.
name|getVectorizationEnabledConditionsMet
argument_list|()
decl_stmt|;
if|if
condition|(
name|enabledConditionsMet
operator|!=
literal|null
operator|&&
operator|!
name|enabledConditionsMet
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Map enabledConditionsMet: "
operator|+
name|enabledConditionsMet
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|List
argument_list|<
name|String
argument_list|>
name|enabledConditionsNotMet
init|=
name|mapWork
operator|.
name|getVectorizationEnabledConditionsNotMet
argument_list|()
decl_stmt|;
if|if
condition|(
name|enabledConditionsNotMet
operator|!=
literal|null
operator|&&
operator|!
name|enabledConditionsNotMet
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Map enabledConditionsNotMet: "
operator|+
name|enabledConditionsNotMet
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|Set
argument_list|<
name|String
argument_list|>
name|inputFileFormatClassNameSet
init|=
name|mapWork
operator|.
name|getVectorizationInputFileFormatClassNameSet
argument_list|()
decl_stmt|;
if|if
condition|(
name|inputFileFormatClassNameSet
operator|!=
literal|null
operator|&&
operator|!
name|inputFileFormatClassNameSet
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Map inputFileFormatClassNameSet: "
operator|+
name|inputFileFormatClassNameSet
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|logReduceWorkExplainVectorization
parameter_list|(
name|ReduceWork
name|reduceWork
parameter_list|)
block|{
if|if
condition|(
operator|!
name|logExplainVectorization
argument_list|(
name|reduceWork
argument_list|,
literal|"Reduce"
argument_list|)
condition|)
block|{
return|return;
block|}
comment|// Conditions.
name|LOG
operator|.
name|info
argument_list|(
literal|"Reducer "
operator|+
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVE_VECTORIZATION_REDUCE_ENABLED
operator|.
name|varname
operator|+
literal|": "
operator|+
name|reduceWork
operator|.
name|getReduceVectorizationEnabled
argument_list|()
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Reducer engine: "
operator|+
name|reduceWork
operator|.
name|getVectorReduceEngine
argument_list|()
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|convertMapWork
parameter_list|(
name|MapWork
name|mapWork
parameter_list|,
name|boolean
name|isTezOrSpark
parameter_list|)
throws|throws
name|SemanticException
block|{
comment|// We have to evaluate the input format to see if vectorization is enabled, so
comment|// we do not set it right here.
name|VectorTaskColumnInfo
name|vectorTaskColumnInfo
init|=
operator|new
name|VectorTaskColumnInfo
argument_list|()
decl_stmt|;
name|vectorTaskColumnInfo
operator|.
name|assume
argument_list|()
expr_stmt|;
name|validateAndVectorizeMapWork
argument_list|(
name|mapWork
argument_list|,
name|vectorTaskColumnInfo
argument_list|,
name|isTezOrSpark
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|addMapWorkRules
parameter_list|(
name|Map
argument_list|<
name|Rule
argument_list|,
name|NodeProcessor
argument_list|>
name|opRules
parameter_list|,
name|NodeProcessor
name|np
parameter_list|)
block|{
name|opRules
operator|.
name|put
argument_list|(
operator|new
name|RuleRegExp
argument_list|(
literal|"R1"
argument_list|,
name|TableScanOperator
operator|.
name|getOperatorName
argument_list|()
operator|+
literal|".*"
operator|+
name|FileSinkOperator
operator|.
name|getOperatorName
argument_list|()
argument_list|)
argument_list|,
name|np
argument_list|)
expr_stmt|;
name|opRules
operator|.
name|put
argument_list|(
operator|new
name|RuleRegExp
argument_list|(
literal|"R2"
argument_list|,
name|TableScanOperator
operator|.
name|getOperatorName
argument_list|()
operator|+
literal|".*"
operator|+
name|ReduceSinkOperator
operator|.
name|getOperatorName
argument_list|()
argument_list|)
argument_list|,
name|np
argument_list|)
expr_stmt|;
block|}
comment|/*      * Determine if there is only one TableScanOperator.  Currently in Map vectorization, we do not      * try to vectorize multiple input trees.      */
specifier|private
name|ImmutablePair
argument_list|<
name|String
argument_list|,
name|TableScanOperator
argument_list|>
name|verifyOnlyOneTableScanOperator
parameter_list|(
name|MapWork
name|mapWork
parameter_list|)
block|{
comment|// Eliminate MR plans with more than one TableScanOperator.
name|LinkedHashMap
argument_list|<
name|String
argument_list|,
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
argument_list|>
name|aliasToWork
init|=
name|mapWork
operator|.
name|getAliasToWork
argument_list|()
decl_stmt|;
if|if
condition|(
operator|(
name|aliasToWork
operator|==
literal|null
operator|)
operator|||
operator|(
name|aliasToWork
operator|.
name|size
argument_list|()
operator|==
literal|0
operator|)
condition|)
block|{
name|setNodeIssue
argument_list|(
literal|"Vectorized map work requires work"
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
name|int
name|tableScanCount
init|=
literal|0
decl_stmt|;
name|String
name|alias
init|=
literal|""
decl_stmt|;
name|TableScanOperator
name|tableScanOperator
init|=
literal|null
decl_stmt|;
for|for
control|(
name|Entry
argument_list|<
name|String
argument_list|,
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
argument_list|>
name|entry
range|:
name|aliasToWork
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|Operator
argument_list|<
name|?
argument_list|>
name|op
init|=
name|entry
operator|.
name|getValue
argument_list|()
decl_stmt|;
if|if
condition|(
name|op
operator|==
literal|null
condition|)
block|{
name|setNodeIssue
argument_list|(
literal|"Vectorized map work requires a valid alias"
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
if|if
condition|(
name|op
operator|instanceof
name|TableScanOperator
condition|)
block|{
name|tableScanCount
operator|++
expr_stmt|;
name|alias
operator|=
name|entry
operator|.
name|getKey
argument_list|()
expr_stmt|;
name|tableScanOperator
operator|=
operator|(
name|TableScanOperator
operator|)
name|op
expr_stmt|;
block|}
block|}
if|if
condition|(
name|tableScanCount
operator|>
literal|1
condition|)
block|{
name|setNodeIssue
argument_list|(
literal|"Vectorized map work only works with 1 TableScanOperator"
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
return|return
operator|new
name|ImmutablePair
argument_list|(
name|alias
argument_list|,
name|tableScanOperator
argument_list|)
return|;
block|}
specifier|private
name|void
name|getTableScanOperatorSchemaInfo
parameter_list|(
name|TableScanOperator
name|tableScanOperator
parameter_list|,
name|List
argument_list|<
name|String
argument_list|>
name|logicalColumnNameList
parameter_list|,
name|List
argument_list|<
name|TypeInfo
argument_list|>
name|logicalTypeInfoList
parameter_list|,
name|List
argument_list|<
name|VirtualColumn
argument_list|>
name|availableVirtualColumnList
parameter_list|)
block|{
comment|// Add all columns to make a vectorization context for
comment|// the TableScan operator.
name|RowSchema
name|rowSchema
init|=
name|tableScanOperator
operator|.
name|getSchema
argument_list|()
decl_stmt|;
for|for
control|(
name|ColumnInfo
name|c
range|:
name|rowSchema
operator|.
name|getSignature
argument_list|()
control|)
block|{
comment|// Validation will later exclude vectorization of virtual columns usage if necessary.
name|String
name|columnName
init|=
name|c
operator|.
name|getInternalName
argument_list|()
decl_stmt|;
comment|// Turns out partition columns get marked as virtual in ColumnInfo, so we need to
comment|// check the VirtualColumn directly.
name|VirtualColumn
name|virtualColumn
init|=
name|VirtualColumn
operator|.
name|VIRTUAL_COLUMN_NAME_MAP
operator|.
name|get
argument_list|(
name|columnName
argument_list|)
decl_stmt|;
if|if
condition|(
name|virtualColumn
operator|!=
literal|null
condition|)
block|{
comment|// The planner gives us a subset virtual columns available for this table scan.
comment|//    AND
comment|// We only support some virtual columns in vectorization.
comment|//
comment|// So, create the intersection.  Note these are available vectorizable virtual columns.
comment|// Later we remember which virtual columns were *actually used* in the query so
comment|// just those will be included in the Map VectorizedRowBatchCtx that has the
comment|// information for creating the Map VectorizedRowBatch.
comment|//
if|if
condition|(
operator|!
name|vectorizableVirtualColumns
operator|.
name|contains
argument_list|(
name|virtualColumn
argument_list|)
condition|)
block|{
continue|continue;
block|}
if|if
condition|(
name|virtualColumn
operator|==
name|VirtualColumn
operator|.
name|ROWID
operator|&&
operator|!
name|isVectorizedRowIdentifierEnabled
condition|)
block|{
continue|continue;
block|}
name|availableVirtualColumnList
operator|.
name|add
argument_list|(
name|virtualColumn
argument_list|)
expr_stmt|;
block|}
comment|// All columns: data, partition, and virtual are added.
name|logicalColumnNameList
operator|.
name|add
argument_list|(
name|columnName
argument_list|)
expr_stmt|;
name|logicalTypeInfoList
operator|.
name|add
argument_list|(
name|TypeInfoUtils
operator|.
name|getTypeInfoFromTypeString
argument_list|(
name|c
operator|.
name|getTypeName
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|determineDataColumnNums
parameter_list|(
name|TableScanOperator
name|tableScanOperator
parameter_list|,
name|List
argument_list|<
name|String
argument_list|>
name|allColumnNameList
parameter_list|,
name|int
name|dataColumnCount
parameter_list|,
name|List
argument_list|<
name|Integer
argument_list|>
name|dataColumnNums
parameter_list|)
block|{
comment|/*        * The TableScanOperator's needed columns are just the data columns.        */
name|Set
argument_list|<
name|String
argument_list|>
name|neededColumns
init|=
operator|new
name|HashSet
argument_list|<
name|String
argument_list|>
argument_list|(
name|tableScanOperator
operator|.
name|getNeededColumns
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|dataColumnNum
init|=
literal|0
init|;
name|dataColumnNum
operator|<
name|dataColumnCount
condition|;
name|dataColumnNum
operator|++
control|)
block|{
name|String
name|columnName
init|=
name|allColumnNameList
operator|.
name|get
argument_list|(
name|dataColumnNum
argument_list|)
decl_stmt|;
if|if
condition|(
name|neededColumns
operator|.
name|contains
argument_list|(
name|columnName
argument_list|)
condition|)
block|{
name|dataColumnNums
operator|.
name|add
argument_list|(
name|dataColumnNum
argument_list|)
expr_stmt|;
block|}
block|}
block|}
specifier|private
name|Support
index|[]
name|getVectorizedInputFormatSupports
parameter_list|(
name|Class
argument_list|<
name|?
extends|extends
name|InputFormat
argument_list|>
name|inputFileFormatClass
parameter_list|)
block|{
comment|// FUTURE: Decide how to ask an input file format what vectorization features it supports.
return|return
literal|null
return|;
block|}
comment|/*      * Add the support of the VectorizedInputFileFormatInterface.      */
specifier|private
name|void
name|addVectorizedInputFileFormatSupport
parameter_list|(
name|Set
argument_list|<
name|Support
argument_list|>
name|newSupportSet
parameter_list|,
name|boolean
name|isInputFileFormatVectorized
parameter_list|,
name|Class
argument_list|<
name|?
extends|extends
name|InputFormat
argument_list|>
name|inputFileFormatClass
parameter_list|)
block|{
specifier|final
name|Support
index|[]
name|supports
decl_stmt|;
if|if
condition|(
name|isInputFileFormatVectorized
condition|)
block|{
name|supports
operator|=
name|getVectorizedInputFormatSupports
argument_list|(
name|inputFileFormatClass
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|supports
operator|=
literal|null
expr_stmt|;
block|}
if|if
condition|(
name|supports
operator|==
literal|null
condition|)
block|{
comment|// No support.
block|}
else|else
block|{
for|for
control|(
name|Support
name|support
range|:
name|supports
control|)
block|{
name|newSupportSet
operator|.
name|add
argument_list|(
name|support
argument_list|)
expr_stmt|;
block|}
block|}
block|}
specifier|private
name|void
name|handleSupport
parameter_list|(
name|boolean
name|isFirstPartition
parameter_list|,
name|Set
argument_list|<
name|Support
argument_list|>
name|inputFormatSupportSet
parameter_list|,
name|Set
argument_list|<
name|Support
argument_list|>
name|newSupportSet
parameter_list|)
block|{
if|if
condition|(
name|isFirstPartition
condition|)
block|{
name|inputFormatSupportSet
operator|.
name|addAll
argument_list|(
name|newSupportSet
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|newSupportSet
operator|.
name|equals
argument_list|(
name|inputFormatSupportSet
argument_list|)
condition|)
block|{
comment|// Do the intersection so only support in both is kept.
name|inputFormatSupportSet
operator|.
name|retainAll
argument_list|(
name|newSupportSet
argument_list|)
expr_stmt|;
block|}
block|}
comment|/*      * Add a vector partition descriptor to partition descriptor, removing duplicate object.      *      * If the same vector partition descriptor has already been allocated, share that object.      */
specifier|private
name|void
name|addVectorPartitionDesc
parameter_list|(
name|PartitionDesc
name|pd
parameter_list|,
name|VectorPartitionDesc
name|vpd
parameter_list|,
name|Map
argument_list|<
name|VectorPartitionDesc
argument_list|,
name|VectorPartitionDesc
argument_list|>
name|vectorPartitionDescMap
parameter_list|)
block|{
name|VectorPartitionDesc
name|existingEle
init|=
name|vectorPartitionDescMap
operator|.
name|get
argument_list|(
name|vpd
argument_list|)
decl_stmt|;
if|if
condition|(
name|existingEle
operator|!=
literal|null
condition|)
block|{
comment|// Use the object we already have.
name|vpd
operator|=
name|existingEle
expr_stmt|;
block|}
else|else
block|{
name|vectorPartitionDescMap
operator|.
name|put
argument_list|(
name|vpd
argument_list|,
name|vpd
argument_list|)
expr_stmt|;
block|}
name|pd
operator|.
name|setVectorPartitionDesc
argument_list|(
name|vpd
argument_list|)
expr_stmt|;
block|}
comment|/*      * There are 3 modes of reading for vectorization:      *      *   1) One for the Vectorized Input File Format which returns VectorizedRowBatch as the row.      *      *   2) One for using VectorDeserializeRow to deserialize each row into the VectorizedRowBatch.      *      Currently, these Input File Formats:      *        TEXTFILE      *        SEQUENCEFILE      *      *   3) And one using the regular partition deserializer to get the row object and assigning      *      the row object into the VectorizedRowBatch with VectorAssignRow.      *      This picks up Input File Format not supported by the other two.      */
specifier|private
name|boolean
name|verifyAndSetVectorPartDesc
parameter_list|(
name|PartitionDesc
name|pd
parameter_list|,
name|boolean
name|isFullAcidTable
parameter_list|,
name|Set
argument_list|<
name|String
argument_list|>
name|inputFileFormatClassNameSet
parameter_list|,
name|Map
argument_list|<
name|VectorPartitionDesc
argument_list|,
name|VectorPartitionDesc
argument_list|>
name|vectorPartitionDescMap
parameter_list|,
name|Set
argument_list|<
name|String
argument_list|>
name|enabledConditionsMetSet
parameter_list|,
name|ArrayList
argument_list|<
name|String
argument_list|>
name|enabledConditionsNotMetList
parameter_list|,
name|Set
argument_list|<
name|Support
argument_list|>
name|newSupportSet
parameter_list|)
block|{
name|Class
argument_list|<
name|?
extends|extends
name|InputFormat
argument_list|>
name|inputFileFormatClass
init|=
name|pd
operator|.
name|getInputFileFormatClass
argument_list|()
decl_stmt|;
name|String
name|inputFileFormatClassName
init|=
name|inputFileFormatClass
operator|.
name|getName
argument_list|()
decl_stmt|;
comment|// Always collect input file formats.
name|inputFileFormatClassNameSet
operator|.
name|add
argument_list|(
name|inputFileFormatClassName
argument_list|)
expr_stmt|;
name|boolean
name|isInputFileFormatVectorized
init|=
name|Utilities
operator|.
name|isInputFileFormatVectorized
argument_list|(
name|pd
argument_list|)
decl_stmt|;
if|if
condition|(
name|isFullAcidTable
condition|)
block|{
comment|// Today, ACID tables are only ORC and that format is vectorizable.  Verify these
comment|// assumptions.
name|Preconditions
operator|.
name|checkState
argument_list|(
name|isInputFileFormatVectorized
argument_list|)
expr_stmt|;
name|Preconditions
operator|.
name|checkState
argument_list|(
name|supportedAcidInputFormats
operator|.
name|contains
argument_list|(
name|inputFileFormatClassName
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|useVectorizedInputFileFormat
condition|)
block|{
name|enabledConditionsNotMetList
operator|.
name|add
argument_list|(
literal|"Vectorizing ACID tables requires "
operator|+
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVE_VECTORIZATION_USE_VECTORIZED_INPUT_FILE_FORMAT
operator|.
name|varname
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
name|addVectorizedInputFileFormatSupport
argument_list|(
name|newSupportSet
argument_list|,
name|isInputFileFormatVectorized
argument_list|,
name|inputFileFormatClass
argument_list|)
expr_stmt|;
name|addVectorPartitionDesc
argument_list|(
name|pd
argument_list|,
name|VectorPartitionDesc
operator|.
name|createVectorizedInputFileFormat
argument_list|(
name|inputFileFormatClassName
argument_list|,
name|Utilities
operator|.
name|isInputFileFormatSelfDescribing
argument_list|(
name|pd
argument_list|)
argument_list|)
argument_list|,
name|vectorPartitionDescMap
argument_list|)
expr_stmt|;
name|enabledConditionsMetSet
operator|.
name|add
argument_list|(
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVE_VECTORIZATION_USE_VECTORIZED_INPUT_FILE_FORMAT
operator|.
name|varname
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
comment|// Look for Pass-Thru case where InputFileFormat has VectorizedInputFormatInterface
comment|// and reads VectorizedRowBatch as a "row".
if|if
condition|(
name|useVectorizedInputFileFormat
condition|)
block|{
if|if
condition|(
name|isInputFileFormatVectorized
operator|&&
operator|!
name|isInputFormatExcluded
argument_list|(
name|inputFileFormatClassName
argument_list|,
name|vectorizedInputFormatExcludes
argument_list|)
condition|)
block|{
name|addVectorizedInputFileFormatSupport
argument_list|(
name|newSupportSet
argument_list|,
name|isInputFileFormatVectorized
argument_list|,
name|inputFileFormatClass
argument_list|)
expr_stmt|;
name|addVectorPartitionDesc
argument_list|(
name|pd
argument_list|,
name|VectorPartitionDesc
operator|.
name|createVectorizedInputFileFormat
argument_list|(
name|inputFileFormatClassName
argument_list|,
name|Utilities
operator|.
name|isInputFileFormatSelfDescribing
argument_list|(
name|pd
argument_list|)
argument_list|)
argument_list|,
name|vectorPartitionDescMap
argument_list|)
expr_stmt|;
name|enabledConditionsMetSet
operator|.
name|add
argument_list|(
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVE_VECTORIZATION_USE_VECTORIZED_INPUT_FILE_FORMAT
operator|.
name|varname
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
comment|// Fall through and look for other options...
block|}
if|if
condition|(
operator|!
name|isSchemaEvolution
condition|)
block|{
name|enabledConditionsNotMetList
operator|.
name|add
argument_list|(
literal|"Vectorizing tables without Schema Evolution requires "
operator|+
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVE_VECTORIZATION_USE_VECTORIZED_INPUT_FILE_FORMAT
operator|.
name|varname
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
name|String
name|deserializerClassName
init|=
name|pd
operator|.
name|getDeserializerClassName
argument_list|()
decl_stmt|;
comment|// Look for InputFileFormat / Serde combinations we can deserialize more efficiently
comment|// using VectorDeserializeRow and a deserialize class with the DeserializeRead interface.
comment|//
comment|// Do the "vectorized" row-by-row deserialization into a VectorizedRowBatch in the
comment|// VectorMapOperator.
name|boolean
name|isTextFormat
init|=
name|inputFileFormatClassName
operator|.
name|equals
argument_list|(
name|TextInputFormat
operator|.
name|class
operator|.
name|getName
argument_list|()
argument_list|)
operator|&&
name|deserializerClassName
operator|.
name|equals
argument_list|(
name|LazySimpleSerDe
operator|.
name|class
operator|.
name|getName
argument_list|()
argument_list|)
decl_stmt|;
name|boolean
name|isSequenceFormat
init|=
name|inputFileFormatClassName
operator|.
name|equals
argument_list|(
name|SequenceFileInputFormat
operator|.
name|class
operator|.
name|getName
argument_list|()
argument_list|)
operator|&&
name|deserializerClassName
operator|.
name|equals
argument_list|(
name|LazyBinarySerDe
operator|.
name|class
operator|.
name|getName
argument_list|()
argument_list|)
decl_stmt|;
name|boolean
name|isVectorDeserializeEligable
init|=
name|isTextFormat
operator|||
name|isSequenceFormat
decl_stmt|;
if|if
condition|(
name|useVectorDeserialize
condition|)
block|{
comment|// Currently, we support LazySimple deserialization:
comment|//
comment|//    org.apache.hadoop.mapred.TextInputFormat
comment|//    org.apache.hadoop.hive.serde2.lazy.LazySimpleSerDe
comment|//
comment|// AND
comment|//
comment|//    org.apache.hadoop.mapred.SequenceFileInputFormat
comment|//    org.apache.hadoop.hive.serde2.lazybinary.LazyBinarySerDe
if|if
condition|(
name|isTextFormat
condition|)
block|{
name|Properties
name|properties
init|=
name|pd
operator|.
name|getTableDesc
argument_list|()
operator|.
name|getProperties
argument_list|()
decl_stmt|;
name|String
name|lastColumnTakesRestString
init|=
name|properties
operator|.
name|getProperty
argument_list|(
name|serdeConstants
operator|.
name|SERIALIZATION_LAST_COLUMN_TAKES_REST
argument_list|)
decl_stmt|;
name|boolean
name|lastColumnTakesRest
init|=
operator|(
name|lastColumnTakesRestString
operator|!=
literal|null
operator|&&
name|lastColumnTakesRestString
operator|.
name|equalsIgnoreCase
argument_list|(
literal|"true"
argument_list|)
operator|)
decl_stmt|;
if|if
condition|(
name|lastColumnTakesRest
condition|)
block|{
comment|// If row mode will not catch this input file format, then not enabled.
if|if
condition|(
name|useRowDeserialize
operator|&&
operator|!
name|isInputFormatExcluded
argument_list|(
name|inputFileFormatClassName
argument_list|,
name|rowDeserializeInputFormatExcludes
argument_list|)
condition|)
block|{
name|enabledConditionsNotMetList
operator|.
name|add
argument_list|(
name|inputFileFormatClassName
operator|+
literal|" "
operator|+
name|serdeConstants
operator|.
name|SERIALIZATION_LAST_COLUMN_TAKES_REST
operator|+
literal|" must be disabled "
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
else|else
block|{
comment|// Add the support for read variations in Vectorized Text.
name|newSupportSet
operator|.
name|addAll
argument_list|(
name|vectorDeserializeTextSupportSet
argument_list|)
expr_stmt|;
name|addVectorPartitionDesc
argument_list|(
name|pd
argument_list|,
name|VectorPartitionDesc
operator|.
name|createVectorDeserialize
argument_list|(
name|inputFileFormatClassName
argument_list|,
name|VectorDeserializeType
operator|.
name|LAZY_SIMPLE
argument_list|)
argument_list|,
name|vectorPartitionDescMap
argument_list|)
expr_stmt|;
name|enabledConditionsMetSet
operator|.
name|add
argument_list|(
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVE_VECTORIZATION_USE_VECTOR_DESERIALIZE
operator|.
name|varname
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|isSequenceFormat
condition|)
block|{
name|addVectorPartitionDesc
argument_list|(
name|pd
argument_list|,
name|VectorPartitionDesc
operator|.
name|createVectorDeserialize
argument_list|(
name|inputFileFormatClassName
argument_list|,
name|VectorDeserializeType
operator|.
name|LAZY_BINARY
argument_list|)
argument_list|,
name|vectorPartitionDescMap
argument_list|)
expr_stmt|;
name|enabledConditionsMetSet
operator|.
name|add
argument_list|(
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVE_VECTORIZATION_USE_VECTOR_DESERIALIZE
operator|.
name|varname
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
comment|// Fall through and look for other options...
block|}
comment|// Otherwise, if enabled, deserialize rows using regular Serde and add the object
comment|// inspect-able Object[] row to a VectorizedRowBatch in the VectorMapOperator.
if|if
condition|(
name|useRowDeserialize
condition|)
block|{
name|boolean
name|isRowDeserializeExcluded
init|=
name|isInputFormatExcluded
argument_list|(
name|inputFileFormatClassName
argument_list|,
name|rowDeserializeInputFormatExcludes
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|isRowDeserializeExcluded
operator|&&
operator|!
name|isInputFileFormatVectorized
condition|)
block|{
name|addVectorPartitionDesc
argument_list|(
name|pd
argument_list|,
name|VectorPartitionDesc
operator|.
name|createRowDeserialize
argument_list|(
name|inputFileFormatClassName
argument_list|,
name|Utilities
operator|.
name|isInputFileFormatSelfDescribing
argument_list|(
name|pd
argument_list|)
argument_list|,
name|deserializerClassName
argument_list|)
argument_list|,
name|vectorPartitionDescMap
argument_list|)
expr_stmt|;
name|enabledConditionsMetSet
operator|.
name|add
argument_list|(
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVE_VECTORIZATION_USE_ROW_DESERIALIZE
operator|.
name|varname
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
elseif|else
if|if
condition|(
name|isInputFileFormatVectorized
condition|)
block|{
comment|/*            * Vectorizer does not vectorize in row deserialize mode if the input format has            * VectorizedInputFormat so input formats will be clear if the isVectorized flag            * is on, they are doing VRB work.            */
name|enabledConditionsNotMetList
operator|.
name|add
argument_list|(
literal|"Row deserialization of vectorized input format not supported"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|enabledConditionsNotMetList
operator|.
name|add
argument_list|(
name|ConfVars
operator|.
name|HIVE_VECTORIZATION_USE_ROW_DESERIALIZE
operator|.
name|varname
operator|+
literal|" IS true AND "
operator|+
name|ConfVars
operator|.
name|HIVE_VECTORIZATION_ROW_DESERIALIZE_INPUTFORMAT_EXCLUDES
operator|.
name|varname
operator|+
literal|" NOT CONTAINS "
operator|+
name|inputFileFormatClassName
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|isInputFileFormatVectorized
condition|)
block|{
if|if
condition|(
name|useVectorizedInputFileFormat
condition|)
block|{
name|enabledConditionsNotMetList
operator|.
name|add
argument_list|(
name|ConfVars
operator|.
name|HIVE_VECTORIZATION_USE_VECTORIZED_INPUT_FILE_FORMAT
operator|.
name|varname
operator|+
literal|" IS true AND "
operator|+
name|ConfVars
operator|.
name|HIVE_VECTORIZATION_VECTORIZED_INPUT_FILE_FORMAT_EXCLUDES
operator|.
name|varname
operator|+
literal|" NOT CONTAINS "
operator|+
name|inputFileFormatClassName
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|enabledConditionsNotMetList
operator|.
name|add
argument_list|(
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVE_VECTORIZATION_USE_VECTORIZED_INPUT_FILE_FORMAT
operator|.
name|varname
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// Only offer these when the input file format is not the fast vectorized formats.
if|if
condition|(
name|isVectorDeserializeEligable
condition|)
block|{
name|Preconditions
operator|.
name|checkState
argument_list|(
operator|!
name|useVectorDeserialize
argument_list|)
expr_stmt|;
name|enabledConditionsNotMetList
operator|.
name|add
argument_list|(
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVE_VECTORIZATION_USE_VECTOR_DESERIALIZE
operator|.
name|varname
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// Since row mode takes everyone.
name|enabledConditionsNotMetList
operator|.
name|add
argument_list|(
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVE_VECTORIZATION_USE_ROW_DESERIALIZE
operator|.
name|varname
argument_list|)
expr_stmt|;
block|}
block|}
return|return
literal|false
return|;
block|}
specifier|private
name|boolean
name|shouldUseVectorizedInputFormat
parameter_list|(
name|Set
argument_list|<
name|String
argument_list|>
name|inputFileFormatClassNames
parameter_list|)
block|{
if|if
condition|(
name|inputFileFormatClassNames
operator|==
literal|null
operator|||
name|inputFileFormatClassNames
operator|.
name|isEmpty
argument_list|()
operator|||
operator|!
name|useVectorizedInputFileFormat
condition|)
block|{
return|return
name|useVectorizedInputFileFormat
return|;
block|}
comment|//Global config of vectorized input format is enabled; check if these inputformats are excluded
for|for
control|(
name|String
name|inputFormat
range|:
name|inputFileFormatClassNames
control|)
block|{
if|if
condition|(
name|isInputFormatExcluded
argument_list|(
name|inputFormat
argument_list|,
name|vectorizedInputFormatExcludes
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
return|return
literal|true
return|;
block|}
specifier|private
name|boolean
name|isInputFormatExcluded
parameter_list|(
name|String
name|inputFileFormatClassName
parameter_list|,
name|Collection
argument_list|<
name|Class
argument_list|<
name|?
argument_list|>
argument_list|>
name|excludes
parameter_list|)
block|{
name|Class
argument_list|<
name|?
argument_list|>
name|ifClass
init|=
literal|null
decl_stmt|;
try|try
block|{
name|ifClass
operator|=
name|Class
operator|.
name|forName
argument_list|(
name|inputFileFormatClassName
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|ClassNotFoundException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Cannot verify class for "
operator|+
name|inputFileFormatClassName
argument_list|,
name|e
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
if|if
condition|(
name|excludes
operator|==
literal|null
operator|||
name|excludes
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return
literal|false
return|;
block|}
for|for
control|(
name|Class
argument_list|<
name|?
argument_list|>
name|badClass
range|:
name|excludes
control|)
block|{
if|if
condition|(
name|badClass
operator|.
name|isAssignableFrom
argument_list|(
name|ifClass
argument_list|)
condition|)
block|{
return|return
literal|true
return|;
block|}
block|}
return|return
literal|false
return|;
block|}
specifier|private
name|void
name|setValidateInputFormatAndSchemaEvolutionExplain
parameter_list|(
name|MapWork
name|mapWork
parameter_list|,
name|Set
argument_list|<
name|String
argument_list|>
name|inputFileFormatClassNameSet
parameter_list|,
name|Map
argument_list|<
name|VectorPartitionDesc
argument_list|,
name|VectorPartitionDesc
argument_list|>
name|vectorPartitionDescMap
parameter_list|,
name|Set
argument_list|<
name|String
argument_list|>
name|enabledConditionsMetSet
parameter_list|,
name|ArrayList
argument_list|<
name|String
argument_list|>
name|enabledConditionsNotMetList
parameter_list|)
block|{
name|mapWork
operator|.
name|setVectorizationInputFileFormatClassNameSet
argument_list|(
name|inputFileFormatClassNameSet
argument_list|)
expr_stmt|;
name|ArrayList
argument_list|<
name|VectorPartitionDesc
argument_list|>
name|vectorPartitionDescList
init|=
operator|new
name|ArrayList
argument_list|<
name|VectorPartitionDesc
argument_list|>
argument_list|()
decl_stmt|;
name|vectorPartitionDescList
operator|.
name|addAll
argument_list|(
name|vectorPartitionDescMap
operator|.
name|keySet
argument_list|()
argument_list|)
expr_stmt|;
name|mapWork
operator|.
name|setVectorPartitionDescList
argument_list|(
name|vectorPartitionDescList
argument_list|)
expr_stmt|;
name|mapWork
operator|.
name|setVectorizationEnabledConditionsMet
argument_list|(
operator|new
name|ArrayList
argument_list|(
name|enabledConditionsMetSet
argument_list|)
argument_list|)
expr_stmt|;
name|mapWork
operator|.
name|setVectorizationEnabledConditionsNotMet
argument_list|(
name|enabledConditionsNotMetList
argument_list|)
expr_stmt|;
block|}
specifier|private
name|ImmutablePair
argument_list|<
name|Boolean
argument_list|,
name|Boolean
argument_list|>
name|validateInputFormatAndSchemaEvolution
parameter_list|(
name|MapWork
name|mapWork
parameter_list|,
name|String
name|alias
parameter_list|,
name|TableScanOperator
name|tableScanOperator
parameter_list|,
name|VectorTaskColumnInfo
name|vectorTaskColumnInfo
parameter_list|)
throws|throws
name|SemanticException
block|{
name|boolean
name|isFullAcidTable
init|=
name|tableScanOperator
operator|.
name|getConf
argument_list|()
operator|.
name|isFullAcidTable
argument_list|()
decl_stmt|;
comment|// These names/types are the data columns plus partition columns.
specifier|final
name|List
argument_list|<
name|String
argument_list|>
name|allColumnNameList
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
specifier|final
name|List
argument_list|<
name|TypeInfo
argument_list|>
name|allTypeInfoList
init|=
operator|new
name|ArrayList
argument_list|<
name|TypeInfo
argument_list|>
argument_list|()
decl_stmt|;
specifier|final
name|List
argument_list|<
name|VirtualColumn
argument_list|>
name|availableVirtualColumnList
init|=
operator|new
name|ArrayList
argument_list|<
name|VirtualColumn
argument_list|>
argument_list|()
decl_stmt|;
name|getTableScanOperatorSchemaInfo
argument_list|(
name|tableScanOperator
argument_list|,
name|allColumnNameList
argument_list|,
name|allTypeInfoList
argument_list|,
name|availableVirtualColumnList
argument_list|)
expr_stmt|;
specifier|final
name|int
name|virtualColumnCount
init|=
name|availableVirtualColumnList
operator|.
name|size
argument_list|()
decl_stmt|;
specifier|final
name|List
argument_list|<
name|Integer
argument_list|>
name|dataColumnNums
init|=
operator|new
name|ArrayList
argument_list|<
name|Integer
argument_list|>
argument_list|()
decl_stmt|;
specifier|final
name|int
name|dataAndPartColumnCount
init|=
name|allColumnNameList
operator|.
name|size
argument_list|()
operator|-
name|virtualColumnCount
decl_stmt|;
comment|/*        * Validate input formats of all the partitions can be vectorized.        */
name|boolean
name|isFirst
init|=
literal|true
decl_stmt|;
name|int
name|dataColumnCount
init|=
literal|0
decl_stmt|;
name|int
name|partitionColumnCount
init|=
literal|0
decl_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|tableDataColumnList
init|=
literal|null
decl_stmt|;
name|List
argument_list|<
name|TypeInfo
argument_list|>
name|tableDataTypeInfoList
init|=
literal|null
decl_stmt|;
name|LinkedHashMap
argument_list|<
name|Path
argument_list|,
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|>
name|pathToAliases
init|=
name|mapWork
operator|.
name|getPathToAliases
argument_list|()
decl_stmt|;
name|LinkedHashMap
argument_list|<
name|Path
argument_list|,
name|PartitionDesc
argument_list|>
name|pathToPartitionInfo
init|=
name|mapWork
operator|.
name|getPathToPartitionInfo
argument_list|()
decl_stmt|;
comment|// Remember the input file formats we validated and why.
name|Set
argument_list|<
name|String
argument_list|>
name|inputFileFormatClassNameSet
init|=
operator|new
name|HashSet
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
name|Map
argument_list|<
name|VectorPartitionDesc
argument_list|,
name|VectorPartitionDesc
argument_list|>
name|vectorPartitionDescMap
init|=
operator|new
name|LinkedHashMap
argument_list|<
name|VectorPartitionDesc
argument_list|,
name|VectorPartitionDesc
argument_list|>
argument_list|()
decl_stmt|;
name|Set
argument_list|<
name|String
argument_list|>
name|enabledConditionsMetSet
init|=
operator|new
name|HashSet
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
name|ArrayList
argument_list|<
name|String
argument_list|>
name|enabledConditionsNotMetList
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
name|Set
argument_list|<
name|Support
argument_list|>
name|inputFormatSupportSet
init|=
operator|new
name|TreeSet
argument_list|<
name|Support
argument_list|>
argument_list|()
decl_stmt|;
name|boolean
name|outsideLoopIsFirstPartition
init|=
literal|true
decl_stmt|;
for|for
control|(
name|Entry
argument_list|<
name|Path
argument_list|,
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|>
name|entry
range|:
name|pathToAliases
operator|.
name|entrySet
argument_list|()
control|)
block|{
specifier|final
name|boolean
name|isFirstPartition
init|=
name|outsideLoopIsFirstPartition
decl_stmt|;
name|outsideLoopIsFirstPartition
operator|=
literal|false
expr_stmt|;
name|Path
name|path
init|=
name|entry
operator|.
name|getKey
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|aliases
init|=
name|entry
operator|.
name|getValue
argument_list|()
decl_stmt|;
name|boolean
name|isPresent
init|=
operator|(
name|aliases
operator|!=
literal|null
operator|&&
name|aliases
operator|.
name|indexOf
argument_list|(
name|alias
argument_list|)
operator|!=
operator|-
literal|1
operator|)
decl_stmt|;
if|if
condition|(
operator|!
name|isPresent
condition|)
block|{
name|setOperatorIssue
argument_list|(
literal|"Alias "
operator|+
name|alias
operator|+
literal|" not present in aliases "
operator|+
name|aliases
argument_list|)
expr_stmt|;
return|return
operator|new
name|ImmutablePair
argument_list|<
name|Boolean
argument_list|,
name|Boolean
argument_list|>
argument_list|(
literal|false
argument_list|,
literal|false
argument_list|)
return|;
block|}
comment|// TODO: should this use getPartitionDescFromPathRecursively? That's what other code uses.
name|PartitionDesc
name|partDesc
init|=
name|pathToPartitionInfo
operator|.
name|get
argument_list|(
name|path
argument_list|)
decl_stmt|;
if|if
condition|(
name|partDesc
operator|.
name|getVectorPartitionDesc
argument_list|()
operator|!=
literal|null
condition|)
block|{
comment|// We've seen this already.
continue|continue;
block|}
name|Set
argument_list|<
name|Support
argument_list|>
name|newSupportSet
init|=
operator|new
name|TreeSet
argument_list|<
name|Support
argument_list|>
argument_list|()
decl_stmt|;
specifier|final
name|boolean
name|isVerifiedVectorPartDesc
init|=
name|verifyAndSetVectorPartDesc
argument_list|(
name|partDesc
argument_list|,
name|isFullAcidTable
argument_list|,
name|inputFileFormatClassNameSet
argument_list|,
name|vectorPartitionDescMap
argument_list|,
name|enabledConditionsMetSet
argument_list|,
name|enabledConditionsNotMetList
argument_list|,
name|newSupportSet
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|isVerifiedVectorPartDesc
condition|)
block|{
comment|// Always set these so EXPLAIN can see.
name|setValidateInputFormatAndSchemaEvolutionExplain
argument_list|(
name|mapWork
argument_list|,
name|inputFileFormatClassNameSet
argument_list|,
name|vectorPartitionDescMap
argument_list|,
name|enabledConditionsMetSet
argument_list|,
name|enabledConditionsNotMetList
argument_list|)
expr_stmt|;
comment|// We consider this an enable issue, not a not vectorized issue.
return|return
operator|new
name|ImmutablePair
argument_list|<
name|Boolean
argument_list|,
name|Boolean
argument_list|>
argument_list|(
literal|false
argument_list|,
literal|true
argument_list|)
return|;
block|}
name|handleSupport
argument_list|(
name|isFirstPartition
argument_list|,
name|inputFormatSupportSet
argument_list|,
name|newSupportSet
argument_list|)
expr_stmt|;
name|VectorPartitionDesc
name|vectorPartDesc
init|=
name|partDesc
operator|.
name|getVectorPartitionDesc
argument_list|()
decl_stmt|;
if|if
condition|(
name|isFirst
condition|)
block|{
comment|/*            * Determine the data and partition columns using the first partition descriptor's            * partition count.  In other words, how to split the schema columns -- the            * allColumnNameList and allTypeInfoList variables -- into the data and partition columns.            */
name|LinkedHashMap
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|partSpec
init|=
name|partDesc
operator|.
name|getPartSpec
argument_list|()
decl_stmt|;
if|if
condition|(
name|partSpec
operator|!=
literal|null
operator|&&
name|partSpec
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
name|partitionColumnCount
operator|=
name|partSpec
operator|.
name|size
argument_list|()
expr_stmt|;
name|dataColumnCount
operator|=
name|dataAndPartColumnCount
operator|-
name|partitionColumnCount
expr_stmt|;
block|}
else|else
block|{
name|partitionColumnCount
operator|=
literal|0
expr_stmt|;
name|dataColumnCount
operator|=
name|dataAndPartColumnCount
expr_stmt|;
block|}
name|determineDataColumnNums
argument_list|(
name|tableScanOperator
argument_list|,
name|allColumnNameList
argument_list|,
name|dataColumnCount
argument_list|,
name|dataColumnNums
argument_list|)
expr_stmt|;
name|tableDataColumnList
operator|=
name|allColumnNameList
operator|.
name|subList
argument_list|(
literal|0
argument_list|,
name|dataColumnCount
argument_list|)
expr_stmt|;
name|tableDataTypeInfoList
operator|=
name|allTypeInfoList
operator|.
name|subList
argument_list|(
literal|0
argument_list|,
name|dataColumnCount
argument_list|)
expr_stmt|;
name|isFirst
operator|=
literal|false
expr_stmt|;
block|}
comment|// We need to get the partition's column names from the partition serde.
comment|// (e.g. Avro provides the table schema and ignores the partition schema..).
comment|//
name|Deserializer
name|deserializer
decl_stmt|;
name|StructObjectInspector
name|partObjectInspector
decl_stmt|;
try|try
block|{
name|deserializer
operator|=
name|partDesc
operator|.
name|getDeserializer
argument_list|(
name|hiveConf
argument_list|)
expr_stmt|;
name|partObjectInspector
operator|=
operator|(
name|StructObjectInspector
operator|)
name|deserializer
operator|.
name|getObjectInspector
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|e
argument_list|)
throw|;
block|}
name|String
name|nextDataColumnsString
init|=
name|ObjectInspectorUtils
operator|.
name|getFieldNames
argument_list|(
name|partObjectInspector
argument_list|)
decl_stmt|;
name|String
index|[]
name|nextDataColumns
init|=
name|nextDataColumnsString
operator|.
name|split
argument_list|(
literal|","
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|nextDataColumnList
init|=
name|Arrays
operator|.
name|asList
argument_list|(
name|nextDataColumns
argument_list|)
decl_stmt|;
comment|/*          * Validate the column names that are present are the same.  Missing columns will be          * implicitly defaulted to null.          */
if|if
condition|(
name|nextDataColumnList
operator|.
name|size
argument_list|()
operator|>
name|tableDataColumnList
operator|.
name|size
argument_list|()
condition|)
block|{
name|enabledConditionsNotMetList
operator|.
name|add
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"Could not enable vectorization due to "
operator|+
literal|"partition column names size %d is greater than the number of table column names size %d"
argument_list|,
name|nextDataColumnList
operator|.
name|size
argument_list|()
argument_list|,
name|tableDataColumnList
operator|.
name|size
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
comment|// Always set these so EXPLAIN can see.
name|setValidateInputFormatAndSchemaEvolutionExplain
argument_list|(
name|mapWork
argument_list|,
name|inputFileFormatClassNameSet
argument_list|,
name|vectorPartitionDescMap
argument_list|,
name|enabledConditionsMetSet
argument_list|,
name|enabledConditionsNotMetList
argument_list|)
expr_stmt|;
return|return
operator|new
name|ImmutablePair
argument_list|<
name|Boolean
argument_list|,
name|Boolean
argument_list|>
argument_list|(
literal|false
argument_list|,
literal|true
argument_list|)
return|;
block|}
if|if
condition|(
operator|!
operator|(
name|deserializer
operator|instanceof
name|NullStructSerDe
operator|)
condition|)
block|{
comment|// (Don't insist NullStructSerDe produce correct column names).
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|nextDataColumnList
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|String
name|nextColumnName
init|=
name|nextDataColumnList
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|String
name|tableColumnName
init|=
name|tableDataColumnList
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|nextColumnName
operator|.
name|equals
argument_list|(
name|tableColumnName
argument_list|)
condition|)
block|{
name|enabledConditionsNotMetList
operator|.
name|add
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"Could not enable vectorization due to "
operator|+
literal|"partition column name %s does not match table column name %s"
argument_list|,
name|nextColumnName
argument_list|,
name|tableColumnName
argument_list|)
argument_list|)
expr_stmt|;
comment|// Always set these so EXPLAIN can see.
name|setValidateInputFormatAndSchemaEvolutionExplain
argument_list|(
name|mapWork
argument_list|,
name|inputFileFormatClassNameSet
argument_list|,
name|vectorPartitionDescMap
argument_list|,
name|enabledConditionsMetSet
argument_list|,
name|enabledConditionsNotMetList
argument_list|)
expr_stmt|;
return|return
operator|new
name|ImmutablePair
argument_list|<
name|Boolean
argument_list|,
name|Boolean
argument_list|>
argument_list|(
literal|false
argument_list|,
literal|true
argument_list|)
return|;
block|}
block|}
block|}
name|boolean
name|isPartitionRowConversion
init|=
literal|false
decl_stmt|;
name|List
argument_list|<
name|TypeInfo
argument_list|>
name|nextDataTypeInfoList
decl_stmt|;
if|if
condition|(
name|vectorPartDesc
operator|.
name|getIsInputFileFormatSelfDescribing
argument_list|()
condition|)
block|{
comment|/*            * Self-Describing Input Format will convert its data to the table schema. So, there            * will be no VectorMapOperator conversion needed.            */
name|nextDataTypeInfoList
operator|=
name|tableDataTypeInfoList
expr_stmt|;
block|}
else|else
block|{
name|String
name|nextDataTypesString
init|=
name|ObjectInspectorUtils
operator|.
name|getFieldTypes
argument_list|(
name|partObjectInspector
argument_list|)
decl_stmt|;
comment|/*            * We convert to an array of TypeInfo using a library routine since it parses the            * information and can handle use of different separators, etc.  We cannot use the            * raw type string for comparison in the map because of the different separators used.            */
name|nextDataTypeInfoList
operator|=
name|TypeInfoUtils
operator|.
name|getTypeInfosFromTypeString
argument_list|(
name|nextDataTypesString
argument_list|)
expr_stmt|;
specifier|final
name|int
name|nextDataTypeInfoSize
init|=
name|nextDataTypeInfoList
operator|.
name|size
argument_list|()
decl_stmt|;
if|if
condition|(
name|nextDataTypeInfoSize
operator|>
name|tableDataTypeInfoList
operator|.
name|size
argument_list|()
condition|)
block|{
name|enabledConditionsNotMetList
operator|.
name|add
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"Could not enable vectorization due to "
operator|+
literal|"partition column types size %d is greater than the number of table column types size %d"
argument_list|,
name|nextDataTypeInfoSize
argument_list|,
name|tableDataTypeInfoList
operator|.
name|size
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
comment|// Always set these so EXPLAIN can see.
name|setValidateInputFormatAndSchemaEvolutionExplain
argument_list|(
name|mapWork
argument_list|,
name|inputFileFormatClassNameSet
argument_list|,
name|vectorPartitionDescMap
argument_list|,
name|enabledConditionsMetSet
argument_list|,
name|enabledConditionsNotMetList
argument_list|)
expr_stmt|;
return|return
operator|new
name|ImmutablePair
argument_list|<
name|Boolean
argument_list|,
name|Boolean
argument_list|>
argument_list|(
literal|false
argument_list|,
literal|true
argument_list|)
return|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|nextDataTypeInfoSize
condition|;
name|i
operator|++
control|)
block|{
name|TypeInfo
name|tableDataTypeInfo
init|=
name|tableDataTypeInfoList
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|TypeInfo
name|nextDataTypeInfo
init|=
name|nextDataTypeInfoList
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
comment|// FUTURE: We be more sophisticated in our conversion check.
if|if
condition|(
operator|!
name|tableDataTypeInfo
operator|.
name|equals
argument_list|(
name|nextDataTypeInfo
argument_list|)
condition|)
block|{
name|isPartitionRowConversion
operator|=
literal|true
expr_stmt|;
break|break;
block|}
block|}
block|}
if|if
condition|(
name|isPartitionRowConversion
operator|&&
name|isLlapIoEnabled
condition|)
block|{
name|enabledConditionsNotMetList
operator|.
name|add
argument_list|(
literal|"Could not enable vectorization. "
operator|+
literal|"LLAP I/O is enabled wbich automatically deserializes into "
operator|+
literal|"VECTORIZED_INPUT_FILE_FORMAT. "
operator|+
literal|"A partition requires data type conversion and that is not supported"
argument_list|)
expr_stmt|;
comment|// Always set these so EXPLAIN can see.
name|setValidateInputFormatAndSchemaEvolutionExplain
argument_list|(
name|mapWork
argument_list|,
name|inputFileFormatClassNameSet
argument_list|,
name|vectorPartitionDescMap
argument_list|,
name|enabledConditionsMetSet
argument_list|,
name|enabledConditionsNotMetList
argument_list|)
expr_stmt|;
return|return
operator|new
name|ImmutablePair
argument_list|<
name|Boolean
argument_list|,
name|Boolean
argument_list|>
argument_list|(
literal|false
argument_list|,
literal|true
argument_list|)
return|;
block|}
name|vectorPartDesc
operator|.
name|setDataTypeInfos
argument_list|(
name|nextDataTypeInfoList
argument_list|)
expr_stmt|;
block|}
comment|// For now, we don't know which virtual columns are going to be included.  We'll add them
comment|// later...
name|vectorTaskColumnInfo
operator|.
name|setAllColumnNames
argument_list|(
name|allColumnNameList
argument_list|)
expr_stmt|;
name|vectorTaskColumnInfo
operator|.
name|setAllTypeInfos
argument_list|(
name|allTypeInfoList
argument_list|)
expr_stmt|;
name|vectorTaskColumnInfo
operator|.
name|setDataColumnNums
argument_list|(
name|dataColumnNums
argument_list|)
expr_stmt|;
name|vectorTaskColumnInfo
operator|.
name|setPartitionColumnCount
argument_list|(
name|partitionColumnCount
argument_list|)
expr_stmt|;
name|vectorTaskColumnInfo
operator|.
name|setAvailableVirtualColumnList
argument_list|(
name|availableVirtualColumnList
argument_list|)
expr_stmt|;
name|vectorTaskColumnInfo
operator|.
name|setUseVectorizedInputFileFormat
argument_list|(
name|shouldUseVectorizedInputFormat
argument_list|(
name|inputFileFormatClassNameSet
argument_list|)
argument_list|)
expr_stmt|;
name|vectorTaskColumnInfo
operator|.
name|setInputFormatSupportSet
argument_list|(
name|inputFormatSupportSet
argument_list|)
expr_stmt|;
comment|// Always set these so EXPLAIN can see.
name|mapWork
operator|.
name|setVectorizationInputFileFormatClassNameSet
argument_list|(
name|inputFileFormatClassNameSet
argument_list|)
expr_stmt|;
name|ArrayList
argument_list|<
name|VectorPartitionDesc
argument_list|>
name|vectorPartitionDescList
init|=
operator|new
name|ArrayList
argument_list|<
name|VectorPartitionDesc
argument_list|>
argument_list|()
decl_stmt|;
name|vectorPartitionDescList
operator|.
name|addAll
argument_list|(
name|vectorPartitionDescMap
operator|.
name|keySet
argument_list|()
argument_list|)
expr_stmt|;
name|mapWork
operator|.
name|setVectorPartitionDescList
argument_list|(
name|vectorPartitionDescList
argument_list|)
expr_stmt|;
name|mapWork
operator|.
name|setVectorizationEnabledConditionsMet
argument_list|(
operator|new
name|ArrayList
argument_list|(
name|enabledConditionsMetSet
argument_list|)
argument_list|)
expr_stmt|;
name|mapWork
operator|.
name|setVectorizationEnabledConditionsNotMet
argument_list|(
name|enabledConditionsNotMetList
argument_list|)
expr_stmt|;
return|return
operator|new
name|ImmutablePair
argument_list|<
name|Boolean
argument_list|,
name|Boolean
argument_list|>
argument_list|(
literal|true
argument_list|,
literal|false
argument_list|)
return|;
block|}
specifier|private
name|void
name|validateAndVectorizeMapWork
parameter_list|(
name|MapWork
name|mapWork
parameter_list|,
name|VectorTaskColumnInfo
name|vectorTaskColumnInfo
parameter_list|,
name|boolean
name|isTezOrSpark
parameter_list|)
throws|throws
name|SemanticException
block|{
comment|//--------------------------------------------------------------------------------------------
name|LOG
operator|.
name|info
argument_list|(
literal|"Examining input format to see if vectorization is enabled."
argument_list|)
expr_stmt|;
name|ImmutablePair
argument_list|<
name|String
argument_list|,
name|TableScanOperator
argument_list|>
name|onlyOneTableScanPair
init|=
name|verifyOnlyOneTableScanOperator
argument_list|(
name|mapWork
argument_list|)
decl_stmt|;
if|if
condition|(
name|onlyOneTableScanPair
operator|==
literal|null
condition|)
block|{
name|VectorizerReason
name|notVectorizedReason
init|=
name|currentBaseWork
operator|.
name|getNotVectorizedReason
argument_list|()
decl_stmt|;
name|Preconditions
operator|.
name|checkState
argument_list|(
name|notVectorizedReason
operator|!=
literal|null
argument_list|)
expr_stmt|;
name|mapWork
operator|.
name|setVectorizationEnabledConditionsNotMet
argument_list|(
name|Arrays
operator|.
name|asList
argument_list|(
operator|new
name|String
index|[]
block|{
name|notVectorizedReason
operator|.
name|toString
argument_list|()
block|}
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|String
name|alias
init|=
name|onlyOneTableScanPair
operator|.
name|left
decl_stmt|;
name|TableScanOperator
name|tableScanOperator
init|=
name|onlyOneTableScanPair
operator|.
name|right
decl_stmt|;
comment|// This call fills in the column names, types, and partition column count in
comment|// vectorTaskColumnInfo.
name|currentOperator
operator|=
name|tableScanOperator
expr_stmt|;
name|ImmutablePair
argument_list|<
name|Boolean
argument_list|,
name|Boolean
argument_list|>
name|validateInputFormatAndSchemaEvolutionPair
init|=
name|validateInputFormatAndSchemaEvolution
argument_list|(
name|mapWork
argument_list|,
name|alias
argument_list|,
name|tableScanOperator
argument_list|,
name|vectorTaskColumnInfo
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|validateInputFormatAndSchemaEvolutionPair
operator|.
name|left
condition|)
block|{
comment|// Have we already set the enabled conditions not met?
if|if
condition|(
operator|!
name|validateInputFormatAndSchemaEvolutionPair
operator|.
name|right
condition|)
block|{
name|VectorizerReason
name|notVectorizedReason
init|=
name|currentBaseWork
operator|.
name|getNotVectorizedReason
argument_list|()
decl_stmt|;
name|Preconditions
operator|.
name|checkState
argument_list|(
name|notVectorizedReason
operator|!=
literal|null
argument_list|)
expr_stmt|;
name|mapWork
operator|.
name|setVectorizationEnabledConditionsNotMet
argument_list|(
name|Arrays
operator|.
name|asList
argument_list|(
operator|new
name|String
index|[]
block|{
name|notVectorizedReason
operator|.
name|toString
argument_list|()
block|}
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
specifier|final
name|int
name|dataColumnCount
init|=
name|vectorTaskColumnInfo
operator|.
name|allColumnNames
operator|.
name|size
argument_list|()
operator|-
name|vectorTaskColumnInfo
operator|.
name|partitionColumnCount
decl_stmt|;
comment|/*        * Take what all input formats support and eliminate any of them not enabled by        * the Hive variable.        */
name|List
argument_list|<
name|String
argument_list|>
name|supportRemovedReasons
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
name|Set
argument_list|<
name|Support
argument_list|>
name|supportSet
init|=
operator|new
name|TreeSet
argument_list|<
name|Support
argument_list|>
argument_list|()
decl_stmt|;
if|if
condition|(
name|vectorTaskColumnInfo
operator|.
name|inputFormatSupportSet
operator|!=
literal|null
condition|)
block|{
name|supportSet
operator|.
name|addAll
argument_list|(
name|vectorTaskColumnInfo
operator|.
name|inputFormatSupportSet
argument_list|)
expr_stmt|;
block|}
comment|// The retainAll method does set intersection.
name|supportSet
operator|.
name|retainAll
argument_list|(
name|vectorizedInputFormatSupportEnabledSet
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|supportSet
operator|.
name|equals
argument_list|(
name|vectorTaskColumnInfo
operator|.
name|inputFormatSupportSet
argument_list|)
condition|)
block|{
name|Set
argument_list|<
name|Support
argument_list|>
name|removedSet
init|=
operator|new
name|TreeSet
argument_list|<
name|Support
argument_list|>
argument_list|()
decl_stmt|;
name|removedSet
operator|.
name|addAll
argument_list|(
name|vectorizedInputFormatSupportEnabledSet
argument_list|)
expr_stmt|;
name|removedSet
operator|.
name|removeAll
argument_list|(
name|supportSet
argument_list|)
expr_stmt|;
name|String
name|removeString
init|=
name|removedSet
operator|.
name|toString
argument_list|()
operator|+
literal|" is disabled because it is not in "
operator|+
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVE_VECTORIZED_INPUT_FORMAT_SUPPORTS_ENABLED
operator|.
name|varname
operator|+
literal|" "
operator|+
name|vectorizedInputFormatSupportEnabledSet
operator|.
name|toString
argument_list|()
decl_stmt|;
name|supportRemovedReasons
operator|.
name|add
argument_list|(
name|removeString
argument_list|)
expr_stmt|;
block|}
comment|// And, if LLAP is enabled for now, disable DECIMAL_64;
if|if
condition|(
name|isLlapIoEnabled
operator|&&
name|supportSet
operator|.
name|contains
argument_list|(
name|Support
operator|.
name|DECIMAL_64
argument_list|)
condition|)
block|{
name|supportSet
operator|.
name|remove
argument_list|(
name|Support
operator|.
name|DECIMAL_64
argument_list|)
expr_stmt|;
name|String
name|removeString
init|=
literal|"DECIMAL_64 disabled because LLAP is enabled"
decl_stmt|;
name|supportRemovedReasons
operator|.
name|add
argument_list|(
name|removeString
argument_list|)
expr_stmt|;
block|}
comment|// Now rememember what is supported for this query and any support that was
comment|// removed.
name|vectorTaskColumnInfo
operator|.
name|setSupportSetInUse
argument_list|(
name|supportSet
argument_list|)
expr_stmt|;
name|vectorTaskColumnInfo
operator|.
name|setSupportRemovedReasons
argument_list|(
name|supportRemovedReasons
argument_list|)
expr_stmt|;
specifier|final
name|boolean
name|isSupportDecimal64
init|=
name|supportSet
operator|.
name|contains
argument_list|(
name|Support
operator|.
name|DECIMAL_64
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|DataTypePhysicalVariation
argument_list|>
name|dataTypePhysicalVariations
init|=
operator|new
name|ArrayList
argument_list|<
name|DataTypePhysicalVariation
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|dataColumnCount
condition|;
name|i
operator|++
control|)
block|{
name|DataTypePhysicalVariation
name|dataTypePhysicalVariation
init|=
name|DataTypePhysicalVariation
operator|.
name|NONE
decl_stmt|;
if|if
condition|(
name|isSupportDecimal64
condition|)
block|{
name|TypeInfo
name|typeInfo
init|=
name|vectorTaskColumnInfo
operator|.
name|allTypeInfos
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|typeInfo
operator|instanceof
name|DecimalTypeInfo
condition|)
block|{
name|DecimalTypeInfo
name|decimalTypeInfo
init|=
operator|(
name|DecimalTypeInfo
operator|)
name|typeInfo
decl_stmt|;
if|if
condition|(
name|HiveDecimalWritable
operator|.
name|isPrecisionDecimal64
argument_list|(
name|decimalTypeInfo
operator|.
name|precision
argument_list|()
argument_list|)
condition|)
block|{
name|dataTypePhysicalVariation
operator|=
name|DataTypePhysicalVariation
operator|.
name|DECIMAL_64
expr_stmt|;
block|}
block|}
block|}
name|dataTypePhysicalVariations
operator|.
name|add
argument_list|(
name|dataTypePhysicalVariation
argument_list|)
expr_stmt|;
block|}
comment|// It simplifies things to just add default ones for partitions.
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|vectorTaskColumnInfo
operator|.
name|partitionColumnCount
condition|;
name|i
operator|++
control|)
block|{
name|dataTypePhysicalVariations
operator|.
name|add
argument_list|(
name|DataTypePhysicalVariation
operator|.
name|NONE
argument_list|)
expr_stmt|;
block|}
name|vectorTaskColumnInfo
operator|.
name|setAlldataTypePhysicalVariations
argument_list|(
name|dataTypePhysicalVariations
argument_list|)
expr_stmt|;
comment|// Set global member indicating which virtual columns are possible to be used by
comment|// the Map vertex.
name|availableVectorizedVirtualColumnSet
operator|=
operator|new
name|HashSet
argument_list|<
name|VirtualColumn
argument_list|>
argument_list|()
expr_stmt|;
name|availableVectorizedVirtualColumnSet
operator|.
name|addAll
argument_list|(
name|vectorTaskColumnInfo
operator|.
name|availableVirtualColumnList
argument_list|)
expr_stmt|;
comment|// And, use set to remember which virtual columns were actually referenced.
name|neededVirtualColumnSet
operator|=
operator|new
name|HashSet
argument_list|<
name|VirtualColumn
argument_list|>
argument_list|()
expr_stmt|;
name|mapWork
operator|.
name|setVectorizationEnabled
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Vectorization is enabled for input format(s) "
operator|+
name|mapWork
operator|.
name|getVectorizationInputFileFormatClassNameSet
argument_list|()
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
comment|//--------------------------------------------------------------------------------------------
comment|/*        * Validate and vectorize the Map operator tree.        */
if|if
condition|(
operator|!
name|validateAndVectorizeMapOperators
argument_list|(
name|mapWork
argument_list|,
name|tableScanOperator
argument_list|,
name|isTezOrSpark
argument_list|,
name|vectorTaskColumnInfo
argument_list|)
condition|)
block|{
return|return;
block|}
comment|//--------------------------------------------------------------------------------------------
name|vectorTaskColumnInfo
operator|.
name|transferToBaseWork
argument_list|(
name|mapWork
argument_list|)
expr_stmt|;
name|mapWork
operator|.
name|setVectorMode
argument_list|(
literal|true
argument_list|)
expr_stmt|;
return|return;
block|}
specifier|private
name|boolean
name|validateAndVectorizeMapOperators
parameter_list|(
name|MapWork
name|mapWork
parameter_list|,
name|TableScanOperator
name|tableScanOperator
parameter_list|,
name|boolean
name|isTezOrSpark
parameter_list|,
name|VectorTaskColumnInfo
name|vectorTaskColumnInfo
parameter_list|)
throws|throws
name|SemanticException
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Validating and vectorizing MapWork... (vectorizedVertexNum "
operator|+
name|vectorizedVertexNum
operator|+
literal|")"
argument_list|)
expr_stmt|;
comment|// Set "global" member indicating where to store "not vectorized" information if necessary.
name|currentBaseWork
operator|=
name|mapWork
expr_stmt|;
if|if
condition|(
operator|!
name|validateTableScanOperator
argument_list|(
name|tableScanOperator
argument_list|,
name|mapWork
argument_list|)
condition|)
block|{
comment|// The "not vectorized" information has been stored in the MapWork vertex.
return|return
literal|false
return|;
block|}
try|try
block|{
name|validateAndVectorizeMapOperators
argument_list|(
name|tableScanOperator
argument_list|,
name|isTezOrSpark
argument_list|,
name|vectorTaskColumnInfo
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|VectorizerCannotVectorizeException
name|e
parameter_list|)
block|{
comment|// The "not vectorized" information has been stored in the MapWork vertex.
return|return
literal|false
return|;
block|}
catch|catch
parameter_list|(
name|NullPointerException
name|e
parameter_list|)
block|{
if|if
condition|(
operator|!
name|isTestVectorizerSuppressFatalExceptions
condition|)
block|{
comment|// Re-throw without losing original stack trace.
throw|throw
name|e
throw|;
block|}
name|setNodeIssue
argument_list|(
literal|"exception: "
operator|+
name|VectorizationContext
operator|.
name|getStackTraceAsSingleLine
argument_list|(
name|e
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
catch|catch
parameter_list|(
name|ClassCastException
name|e
parameter_list|)
block|{
if|if
condition|(
operator|!
name|isTestVectorizerSuppressFatalExceptions
condition|)
block|{
throw|throw
name|e
throw|;
block|}
name|setNodeIssue
argument_list|(
literal|"exception: "
operator|+
name|VectorizationContext
operator|.
name|getStackTraceAsSingleLine
argument_list|(
name|e
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
catch|catch
parameter_list|(
name|RuntimeException
name|e
parameter_list|)
block|{
if|if
condition|(
operator|!
name|isTestVectorizerSuppressFatalExceptions
condition|)
block|{
throw|throw
name|e
throw|;
block|}
name|setNodeIssue
argument_list|(
literal|"exception: "
operator|+
name|VectorizationContext
operator|.
name|getStackTraceAsSingleLine
argument_list|(
name|e
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
name|vectorTaskColumnInfo
operator|.
name|setNeededVirtualColumnList
argument_list|(
operator|new
name|ArrayList
argument_list|<
name|VirtualColumn
argument_list|>
argument_list|(
name|neededVirtualColumnSet
argument_list|)
argument_list|)
expr_stmt|;
comment|/*        * The scratch column information was collected by the task VectorizationContext.  Go get it.        */
name|VectorizationContext
name|vContext
init|=
operator|(
operator|(
name|VectorizationContextRegion
operator|)
name|tableScanOperator
operator|)
operator|.
name|getOutputVectorizationContext
argument_list|()
decl_stmt|;
name|vectorTaskColumnInfo
operator|.
name|setScratchTypeNameArray
argument_list|(
name|vContext
operator|.
name|getScratchColumnTypeNames
argument_list|()
argument_list|)
expr_stmt|;
name|vectorTaskColumnInfo
operator|.
name|setScratchdataTypePhysicalVariationsArray
argument_list|(
name|vContext
operator|.
name|getScratchDataTypePhysicalVariations
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
specifier|private
name|void
name|validateAndVectorizeMapOperators
parameter_list|(
name|TableScanOperator
name|tableScanOperator
parameter_list|,
name|boolean
name|isTezOrSpark
parameter_list|,
name|VectorTaskColumnInfo
name|vectorTaskColumnInfo
parameter_list|)
throws|throws
name|VectorizerCannotVectorizeException
block|{
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
name|dummyVectorOperator
init|=
name|validateAndVectorizeOperatorTree
argument_list|(
name|tableScanOperator
argument_list|,
literal|false
argument_list|,
name|isTezOrSpark
argument_list|,
name|vectorTaskColumnInfo
argument_list|)
decl_stmt|;
comment|// Fixup parent and child relations.
name|List
argument_list|<
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
argument_list|>
name|vectorChildren
init|=
name|dummyVectorOperator
operator|.
name|getChildOperators
argument_list|()
decl_stmt|;
name|tableScanOperator
operator|.
name|setChildOperators
argument_list|(
name|vectorChildren
argument_list|)
expr_stmt|;
specifier|final
name|int
name|vectorChildCount
init|=
name|vectorChildren
operator|.
name|size
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|vectorChildCount
condition|;
name|i
operator|++
control|)
block|{
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
name|vectorChild
init|=
name|vectorChildren
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
comment|// Replace any occurrence of dummyVectorOperator with our TableScanOperator.
name|List
argument_list|<
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
argument_list|>
name|vectorChildParents
init|=
name|vectorChild
operator|.
name|getParentOperators
argument_list|()
decl_stmt|;
specifier|final
name|int
name|vectorChildParentCount
init|=
name|vectorChildParents
operator|.
name|size
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|p
init|=
literal|0
init|;
name|p
operator|<
name|vectorChildParentCount
condition|;
name|p
operator|++
control|)
block|{
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
name|vectorChildParent
init|=
name|vectorChildParents
operator|.
name|get
argument_list|(
name|p
argument_list|)
decl_stmt|;
if|if
condition|(
name|vectorChildParent
operator|==
name|dummyVectorOperator
condition|)
block|{
name|vectorChildParents
operator|.
name|set
argument_list|(
name|p
argument_list|,
name|tableScanOperator
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|// And, finally, save the VectorizationContext.
name|tableScanOperator
operator|.
name|setTaskVectorizationContext
argument_list|(
operator|(
operator|(
name|VectorizationOperator
operator|)
name|dummyVectorOperator
operator|)
operator|.
name|getInputVectorizationContext
argument_list|()
argument_list|)
expr_stmt|;
comment|// Modify TableScanOperator in-place so it knows to operate vectorized.
name|vectorizeTableScanOperatorInPlace
argument_list|(
name|tableScanOperator
argument_list|,
name|vectorTaskColumnInfo
argument_list|)
expr_stmt|;
block|}
comment|/*      * We are "committing" this vertex to be vectorized.      */
specifier|private
name|void
name|vectorizeTableScanOperatorInPlace
parameter_list|(
name|TableScanOperator
name|tableScanOperator
parameter_list|,
name|VectorTaskColumnInfo
name|vectorTaskColumnInfo
parameter_list|)
block|{
name|TableScanDesc
name|tableScanDesc
init|=
operator|(
name|TableScanDesc
operator|)
name|tableScanOperator
operator|.
name|getConf
argument_list|()
decl_stmt|;
name|VectorTableScanDesc
name|vectorTableScanDesc
init|=
operator|new
name|VectorTableScanDesc
argument_list|()
decl_stmt|;
name|tableScanDesc
operator|.
name|setVectorDesc
argument_list|(
name|vectorTableScanDesc
argument_list|)
expr_stmt|;
name|VectorizationContext
name|vContext
init|=
operator|(
operator|(
name|VectorizationContextRegion
operator|)
name|tableScanOperator
operator|)
operator|.
name|getOutputVectorizationContext
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|Integer
argument_list|>
name|projectedColumns
init|=
name|vContext
operator|.
name|getProjectedColumns
argument_list|()
decl_stmt|;
name|vectorTableScanDesc
operator|.
name|setProjectedColumns
argument_list|(
name|ArrayUtils
operator|.
name|toPrimitive
argument_list|(
name|projectedColumns
operator|.
name|toArray
argument_list|(
operator|new
name|Integer
index|[
literal|0
index|]
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|allColumnNameList
init|=
name|vectorTaskColumnInfo
operator|.
name|allColumnNames
decl_stmt|;
name|List
argument_list|<
name|TypeInfo
argument_list|>
name|allTypeInfoList
init|=
name|vectorTaskColumnInfo
operator|.
name|allTypeInfos
decl_stmt|;
name|List
argument_list|<
name|DataTypePhysicalVariation
argument_list|>
name|allDataTypePhysicalVariationList
init|=
name|vectorTaskColumnInfo
operator|.
name|allDataTypePhysicalVariations
decl_stmt|;
specifier|final
name|int
name|projectedColumnCount
init|=
name|projectedColumns
operator|.
name|size
argument_list|()
decl_stmt|;
name|String
index|[]
name|projectedDataColumnNames
init|=
operator|new
name|String
index|[
name|projectedColumnCount
index|]
decl_stmt|;
name|TypeInfo
index|[]
name|projectedDataColumnTypeInfos
init|=
operator|new
name|TypeInfo
index|[
name|projectedColumnCount
index|]
decl_stmt|;
name|DataTypePhysicalVariation
index|[]
name|projectedDataColumnDataTypePhysicalVariation
init|=
operator|new
name|DataTypePhysicalVariation
index|[
name|projectedColumnCount
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|projectedColumnCount
condition|;
name|i
operator|++
control|)
block|{
specifier|final
name|int
name|projectedColumnNum
init|=
name|projectedColumns
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|projectedDataColumnNames
index|[
name|i
index|]
operator|=
name|allColumnNameList
operator|.
name|get
argument_list|(
name|projectedColumnNum
argument_list|)
expr_stmt|;
name|projectedDataColumnTypeInfos
index|[
name|i
index|]
operator|=
name|allTypeInfoList
operator|.
name|get
argument_list|(
name|projectedColumnNum
argument_list|)
expr_stmt|;
name|projectedDataColumnDataTypePhysicalVariation
index|[
name|i
index|]
operator|=
name|allDataTypePhysicalVariationList
operator|.
name|get
argument_list|(
name|projectedColumnNum
argument_list|)
expr_stmt|;
block|}
name|vectorTableScanDesc
operator|.
name|setProjectedColumnNames
argument_list|(
name|projectedDataColumnNames
argument_list|)
expr_stmt|;
name|vectorTableScanDesc
operator|.
name|setProjectedColumnTypeInfos
argument_list|(
name|projectedDataColumnTypeInfos
argument_list|)
expr_stmt|;
name|vectorTableScanDesc
operator|.
name|setProjectedColumnDataTypePhysicalVariations
argument_list|(
name|projectedDataColumnDataTypePhysicalVariation
argument_list|)
expr_stmt|;
name|tableScanOperator
operator|.
name|getConf
argument_list|()
operator|.
name|setVectorized
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
argument_list|>
name|children
init|=
name|tableScanOperator
operator|.
name|getChildOperators
argument_list|()
decl_stmt|;
while|while
condition|(
name|children
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
name|children
operator|=
name|dosetVectorDesc
argument_list|(
name|children
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
name|List
argument_list|<
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
argument_list|>
name|dosetVectorDesc
parameter_list|(
name|List
argument_list|<
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
argument_list|>
name|children
parameter_list|)
block|{
name|List
argument_list|<
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
argument_list|>
name|newChildren
init|=
operator|new
name|ArrayList
argument_list|<
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
name|child
range|:
name|children
control|)
block|{
comment|// Get the vector description from the operator.
name|VectorDesc
name|vectorDesc
init|=
operator|(
operator|(
name|VectorizationOperator
operator|)
name|child
operator|)
operator|.
name|getVectorDesc
argument_list|()
decl_stmt|;
comment|// Save the vector description for the EXPLAIN.
name|AbstractOperatorDesc
name|desc
init|=
operator|(
name|AbstractOperatorDesc
operator|)
name|child
operator|.
name|getConf
argument_list|()
decl_stmt|;
name|desc
operator|.
name|setVectorDesc
argument_list|(
name|vectorDesc
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
argument_list|>
name|childChildren
init|=
name|child
operator|.
name|getChildOperators
argument_list|()
decl_stmt|;
if|if
condition|(
name|childChildren
operator|!=
literal|null
condition|)
block|{
name|newChildren
operator|.
name|addAll
argument_list|(
name|childChildren
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|newChildren
return|;
block|}
specifier|private
name|void
name|convertReduceWork
parameter_list|(
name|ReduceWork
name|reduceWork
parameter_list|)
throws|throws
name|SemanticException
block|{
name|reduceWork
operator|.
name|setVectorizationEnabled
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|VectorTaskColumnInfo
name|vectorTaskColumnInfo
init|=
operator|new
name|VectorTaskColumnInfo
argument_list|()
decl_stmt|;
name|vectorTaskColumnInfo
operator|.
name|assume
argument_list|()
expr_stmt|;
name|reduceWork
operator|.
name|setVectorizedTestingReducerBatchSize
argument_list|(
name|vectorizedTestingReducerBatchSize
argument_list|)
expr_stmt|;
name|validateAndVectorizeReduceWork
argument_list|(
name|reduceWork
argument_list|,
name|vectorTaskColumnInfo
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|validateAndVectorizeReduceWork
parameter_list|(
name|ReduceWork
name|reduceWork
parameter_list|,
name|VectorTaskColumnInfo
name|vectorTaskColumnInfo
parameter_list|)
throws|throws
name|SemanticException
block|{
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
name|reducer
init|=
name|reduceWork
operator|.
name|getReducer
argument_list|()
decl_stmt|;
comment|// Validate input to ReduceWork.
if|if
condition|(
operator|!
name|getOnlyStructObjectInspectors
argument_list|(
name|reduceWork
argument_list|,
name|vectorTaskColumnInfo
argument_list|)
condition|)
block|{
return|return;
block|}
comment|//--------------------------------------------------------------------------------------------
comment|/*        * Validate and vectorize the Reduce operator tree.        */
if|if
condition|(
operator|!
name|validateAndVectorizeReduceOperators
argument_list|(
name|reduceWork
argument_list|,
name|vectorTaskColumnInfo
argument_list|)
condition|)
block|{
return|return;
block|}
comment|//--------------------------------------------------------------------------------------------
name|vectorTaskColumnInfo
operator|.
name|transferToBaseWork
argument_list|(
name|reduceWork
argument_list|)
expr_stmt|;
name|reduceWork
operator|.
name|setVectorMode
argument_list|(
literal|true
argument_list|)
expr_stmt|;
return|return;
block|}
specifier|private
name|boolean
name|validateAndVectorizeReduceOperators
parameter_list|(
name|ReduceWork
name|reduceWork
parameter_list|,
name|VectorTaskColumnInfo
name|vectorTaskColumnInfo
parameter_list|)
throws|throws
name|SemanticException
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Validating and vectorizing ReduceWork... (vectorizedVertexNum "
operator|+
name|vectorizedVertexNum
operator|+
literal|")"
argument_list|)
expr_stmt|;
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
name|newVectorReducer
decl_stmt|;
try|try
block|{
name|newVectorReducer
operator|=
name|validateAndVectorizeReduceOperators
argument_list|(
name|reduceWork
operator|.
name|getReducer
argument_list|()
argument_list|,
name|vectorTaskColumnInfo
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|VectorizerCannotVectorizeException
name|e
parameter_list|)
block|{
comment|// The "not vectorized" information has been stored in the MapWork vertex.
return|return
literal|false
return|;
block|}
catch|catch
parameter_list|(
name|NullPointerException
name|e
parameter_list|)
block|{
if|if
condition|(
operator|!
name|isTestVectorizerSuppressFatalExceptions
condition|)
block|{
comment|// Re-throw without losing original stack trace.
throw|throw
name|e
throw|;
block|}
name|setNodeIssue
argument_list|(
literal|"exception: "
operator|+
name|VectorizationContext
operator|.
name|getStackTraceAsSingleLine
argument_list|(
name|e
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
catch|catch
parameter_list|(
name|ClassCastException
name|e
parameter_list|)
block|{
if|if
condition|(
operator|!
name|isTestVectorizerSuppressFatalExceptions
condition|)
block|{
throw|throw
name|e
throw|;
block|}
name|setNodeIssue
argument_list|(
literal|"exception: "
operator|+
name|VectorizationContext
operator|.
name|getStackTraceAsSingleLine
argument_list|(
name|e
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
catch|catch
parameter_list|(
name|RuntimeException
name|e
parameter_list|)
block|{
if|if
condition|(
operator|!
name|isTestVectorizerSuppressFatalExceptions
condition|)
block|{
throw|throw
name|e
throw|;
block|}
name|setNodeIssue
argument_list|(
literal|"exception: "
operator|+
name|VectorizationContext
operator|.
name|getStackTraceAsSingleLine
argument_list|(
name|e
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
comment|/*        * The scratch column information was collected by the task VectorizationContext.  Go get it.        */
name|VectorizationContext
name|vContext
init|=
operator|(
operator|(
name|VectorizationOperator
operator|)
name|newVectorReducer
operator|)
operator|.
name|getInputVectorizationContext
argument_list|()
decl_stmt|;
name|vectorTaskColumnInfo
operator|.
name|setScratchTypeNameArray
argument_list|(
name|vContext
operator|.
name|getScratchColumnTypeNames
argument_list|()
argument_list|)
expr_stmt|;
name|vectorTaskColumnInfo
operator|.
name|setScratchdataTypePhysicalVariationsArray
argument_list|(
name|vContext
operator|.
name|getScratchDataTypePhysicalVariations
argument_list|()
argument_list|)
expr_stmt|;
comment|// Replace the reducer with our fully vectorized reduce operator tree.
name|reduceWork
operator|.
name|setReducer
argument_list|(
name|newVectorReducer
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
specifier|private
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
name|validateAndVectorizeReduceOperators
parameter_list|(
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
name|reducerOperator
parameter_list|,
name|VectorTaskColumnInfo
name|vectorTaskColumnInfo
parameter_list|)
throws|throws
name|VectorizerCannotVectorizeException
block|{
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
name|dummyOperator
init|=
operator|new
name|DummyOperator
argument_list|()
decl_stmt|;
name|dummyOperator
operator|.
name|getChildOperators
argument_list|()
operator|.
name|add
argument_list|(
name|reducerOperator
argument_list|)
expr_stmt|;
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
name|dummyVectorOperator
init|=
name|validateAndVectorizeOperatorTree
argument_list|(
name|dummyOperator
argument_list|,
literal|true
argument_list|,
literal|true
argument_list|,
name|vectorTaskColumnInfo
argument_list|)
decl_stmt|;
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
name|newVectorReducer
init|=
name|dummyVectorOperator
operator|.
name|getChildOperators
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
argument_list|>
name|children
init|=
operator|new
name|ArrayList
argument_list|<
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
argument_list|>
argument_list|()
decl_stmt|;
name|children
operator|.
name|add
argument_list|(
name|newVectorReducer
argument_list|)
expr_stmt|;
while|while
condition|(
name|children
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
name|children
operator|=
name|dosetVectorDesc
argument_list|(
name|children
argument_list|)
expr_stmt|;
block|}
return|return
name|newVectorReducer
return|;
block|}
specifier|private
name|boolean
name|getOnlyStructObjectInspectors
parameter_list|(
name|ReduceWork
name|reduceWork
parameter_list|,
name|VectorTaskColumnInfo
name|vectorTaskColumnInfo
parameter_list|)
throws|throws
name|SemanticException
block|{
name|ArrayList
argument_list|<
name|String
argument_list|>
name|reduceColumnNames
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
name|ArrayList
argument_list|<
name|TypeInfo
argument_list|>
name|reduceTypeInfos
init|=
operator|new
name|ArrayList
argument_list|<
name|TypeInfo
argument_list|>
argument_list|()
decl_stmt|;
if|if
condition|(
name|reduceWork
operator|.
name|getNeedsTagging
argument_list|()
condition|)
block|{
name|setNodeIssue
argument_list|(
literal|"Tagging not supported"
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
name|String
name|columnSortOrder
decl_stmt|;
name|String
name|columnNullOrder
decl_stmt|;
try|try
block|{
name|TableDesc
name|keyTableDesc
init|=
name|reduceWork
operator|.
name|getKeyDesc
argument_list|()
decl_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Using reduce tag "
operator|+
name|reduceWork
operator|.
name|getTag
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|TableDesc
name|valueTableDesc
init|=
name|reduceWork
operator|.
name|getTagToValueDesc
argument_list|()
operator|.
name|get
argument_list|(
name|reduceWork
operator|.
name|getTag
argument_list|()
argument_list|)
decl_stmt|;
name|Properties
name|keyTableProperties
init|=
name|keyTableDesc
operator|.
name|getProperties
argument_list|()
decl_stmt|;
name|Deserializer
name|keyDeserializer
init|=
name|ReflectionUtils
operator|.
name|newInstance
argument_list|(
name|keyTableDesc
operator|.
name|getDeserializerClass
argument_list|()
argument_list|,
literal|null
argument_list|)
decl_stmt|;
name|SerDeUtils
operator|.
name|initializeSerDe
argument_list|(
name|keyDeserializer
argument_list|,
literal|null
argument_list|,
name|keyTableProperties
argument_list|,
literal|null
argument_list|)
expr_stmt|;
name|ObjectInspector
name|keyObjectInspector
init|=
name|keyDeserializer
operator|.
name|getObjectInspector
argument_list|()
decl_stmt|;
if|if
condition|(
name|keyObjectInspector
operator|==
literal|null
condition|)
block|{
name|setNodeIssue
argument_list|(
literal|"Key object inspector null"
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
operator|!
operator|(
name|keyObjectInspector
operator|instanceof
name|StructObjectInspector
operator|)
condition|)
block|{
name|setNodeIssue
argument_list|(
literal|"Key object inspector not StructObjectInspector"
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
name|StructObjectInspector
name|keyStructObjectInspector
init|=
operator|(
name|StructObjectInspector
operator|)
name|keyObjectInspector
decl_stmt|;
name|List
argument_list|<
name|?
extends|extends
name|StructField
argument_list|>
name|keyFields
init|=
name|keyStructObjectInspector
operator|.
name|getAllStructFieldRefs
argument_list|()
decl_stmt|;
for|for
control|(
name|StructField
name|field
range|:
name|keyFields
control|)
block|{
name|reduceColumnNames
operator|.
name|add
argument_list|(
name|Utilities
operator|.
name|ReduceField
operator|.
name|KEY
operator|.
name|toString
argument_list|()
operator|+
literal|"."
operator|+
name|field
operator|.
name|getFieldName
argument_list|()
argument_list|)
expr_stmt|;
name|reduceTypeInfos
operator|.
name|add
argument_list|(
name|TypeInfoUtils
operator|.
name|getTypeInfoFromTypeString
argument_list|(
name|field
operator|.
name|getFieldObjectInspector
argument_list|()
operator|.
name|getTypeName
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|columnSortOrder
operator|=
name|keyTableProperties
operator|.
name|getProperty
argument_list|(
name|serdeConstants
operator|.
name|SERIALIZATION_SORT_ORDER
argument_list|)
expr_stmt|;
name|columnNullOrder
operator|=
name|keyTableProperties
operator|.
name|getProperty
argument_list|(
name|serdeConstants
operator|.
name|SERIALIZATION_NULL_SORT_ORDER
argument_list|)
expr_stmt|;
name|Deserializer
name|valueDeserializer
init|=
name|ReflectionUtils
operator|.
name|newInstance
argument_list|(
name|valueTableDesc
operator|.
name|getDeserializerClass
argument_list|()
argument_list|,
literal|null
argument_list|)
decl_stmt|;
name|SerDeUtils
operator|.
name|initializeSerDe
argument_list|(
name|valueDeserializer
argument_list|,
literal|null
argument_list|,
name|valueTableDesc
operator|.
name|getProperties
argument_list|()
argument_list|,
literal|null
argument_list|)
expr_stmt|;
name|ObjectInspector
name|valueObjectInspector
init|=
name|valueDeserializer
operator|.
name|getObjectInspector
argument_list|()
decl_stmt|;
if|if
condition|(
name|valueObjectInspector
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|valueObjectInspector
operator|instanceof
name|StructObjectInspector
operator|)
condition|)
block|{
name|setNodeIssue
argument_list|(
literal|"Value object inspector not StructObjectInspector"
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
name|StructObjectInspector
name|valueStructObjectInspector
init|=
operator|(
name|StructObjectInspector
operator|)
name|valueObjectInspector
decl_stmt|;
name|List
argument_list|<
name|?
extends|extends
name|StructField
argument_list|>
name|valueFields
init|=
name|valueStructObjectInspector
operator|.
name|getAllStructFieldRefs
argument_list|()
decl_stmt|;
for|for
control|(
name|StructField
name|field
range|:
name|valueFields
control|)
block|{
name|reduceColumnNames
operator|.
name|add
argument_list|(
name|Utilities
operator|.
name|ReduceField
operator|.
name|VALUE
operator|.
name|toString
argument_list|()
operator|+
literal|"."
operator|+
name|field
operator|.
name|getFieldName
argument_list|()
argument_list|)
expr_stmt|;
name|reduceTypeInfos
operator|.
name|add
argument_list|(
name|TypeInfoUtils
operator|.
name|getTypeInfoFromTypeString
argument_list|(
name|field
operator|.
name|getFieldObjectInspector
argument_list|()
operator|.
name|getTypeName
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|e
argument_list|)
throw|;
block|}
name|vectorTaskColumnInfo
operator|.
name|setAllColumnNames
argument_list|(
name|reduceColumnNames
argument_list|)
expr_stmt|;
name|vectorTaskColumnInfo
operator|.
name|setAllTypeInfos
argument_list|(
name|reduceTypeInfos
argument_list|)
expr_stmt|;
name|vectorTaskColumnInfo
operator|.
name|setReduceColumnSortOrder
argument_list|(
name|columnSortOrder
argument_list|)
expr_stmt|;
name|vectorTaskColumnInfo
operator|.
name|setReduceColumnNullOrder
argument_list|(
name|columnNullOrder
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|PhysicalContext
name|resolve
parameter_list|(
name|PhysicalContext
name|physicalContext
parameter_list|)
throws|throws
name|SemanticException
block|{
name|hiveConf
operator|=
name|physicalContext
operator|.
name|getConf
argument_list|()
expr_stmt|;
name|String
name|vectorizationEnabledOverrideString
init|=
name|HiveConf
operator|.
name|getVar
argument_list|(
name|hiveConf
argument_list|,
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVE_TEST_VECTORIZATION_ENABLED_OVERRIDE
argument_list|)
decl_stmt|;
name|vectorizationEnabledOverride
operator|=
name|VectorizationEnabledOverride
operator|.
name|nameMap
operator|.
name|get
argument_list|(
name|vectorizationEnabledOverrideString
argument_list|)
expr_stmt|;
name|isVectorizationEnabled
operator|=
name|HiveConf
operator|.
name|getBoolVar
argument_list|(
name|hiveConf
argument_list|,
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVE_VECTORIZATION_ENABLED
argument_list|)
expr_stmt|;
specifier|final
name|boolean
name|weCanAttemptVectorization
decl_stmt|;
name|isTestForcedVectorizationEnable
operator|=
literal|false
expr_stmt|;
switch|switch
condition|(
name|vectorizationEnabledOverride
condition|)
block|{
case|case
name|NONE
case|:
name|weCanAttemptVectorization
operator|=
name|isVectorizationEnabled
expr_stmt|;
break|break;
case|case
name|DISABLE
case|:
name|weCanAttemptVectorization
operator|=
literal|false
expr_stmt|;
break|break;
case|case
name|ENABLE
case|:
name|weCanAttemptVectorization
operator|=
literal|true
expr_stmt|;
name|isTestForcedVectorizationEnable
operator|=
operator|!
name|isVectorizationEnabled
expr_stmt|;
comment|// Different parts of the code rely on this being set...
name|HiveConf
operator|.
name|setBoolVar
argument_list|(
name|hiveConf
argument_list|,
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVE_VECTORIZATION_ENABLED
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|isVectorizationEnabled
operator|=
literal|true
expr_stmt|;
break|break;
default|default:
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Unexpected vectorization enabled override "
operator|+
name|vectorizationEnabledOverride
argument_list|)
throw|;
block|}
if|if
condition|(
operator|!
name|weCanAttemptVectorization
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Vectorization is disabled"
argument_list|)
expr_stmt|;
return|return
name|physicalContext
return|;
block|}
name|useVectorizedInputFileFormat
operator|=
name|HiveConf
operator|.
name|getBoolVar
argument_list|(
name|hiveConf
argument_list|,
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVE_VECTORIZATION_USE_VECTORIZED_INPUT_FILE_FORMAT
argument_list|)
expr_stmt|;
if|if
condition|(
name|useVectorizedInputFileFormat
condition|)
block|{
name|initVectorizedInputFormatExcludeClasses
argument_list|()
expr_stmt|;
block|}
name|useVectorDeserialize
operator|=
name|HiveConf
operator|.
name|getBoolVar
argument_list|(
name|hiveConf
argument_list|,
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVE_VECTORIZATION_USE_VECTOR_DESERIALIZE
argument_list|)
expr_stmt|;
name|useRowDeserialize
operator|=
name|HiveConf
operator|.
name|getBoolVar
argument_list|(
name|hiveConf
argument_list|,
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVE_VECTORIZATION_USE_ROW_DESERIALIZE
argument_list|)
expr_stmt|;
if|if
condition|(
name|useRowDeserialize
condition|)
block|{
name|initRowDeserializeExcludeClasses
argument_list|()
expr_stmt|;
block|}
comment|// TODO: we could also vectorize some formats based on hive.llap.io.encode.formats if LLAP IO
comment|//       is enabled and we are going to run in LLAP. However, we don't know if we end up in
comment|//       LLAP or not at this stage, so don't do this now. We may need to add a 'force' option.
name|isReduceVectorizationEnabled
operator|=
name|HiveConf
operator|.
name|getBoolVar
argument_list|(
name|hiveConf
argument_list|,
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVE_VECTORIZATION_REDUCE_ENABLED
argument_list|)
expr_stmt|;
name|isPtfVectorizationEnabled
operator|=
name|HiveConf
operator|.
name|getBoolVar
argument_list|(
name|hiveConf
argument_list|,
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVE_VECTORIZATION_PTF_ENABLED
argument_list|)
expr_stmt|;
name|isVectorizationComplexTypesEnabled
operator|=
name|HiveConf
operator|.
name|getBoolVar
argument_list|(
name|hiveConf
argument_list|,
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVE_VECTORIZATION_COMPLEX_TYPES_ENABLED
argument_list|)
expr_stmt|;
name|isVectorizationGroupByComplexTypesEnabled
operator|=
name|HiveConf
operator|.
name|getBoolVar
argument_list|(
name|hiveConf
argument_list|,
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVE_VECTORIZATION_GROUPBY_COMPLEX_TYPES_ENABLED
argument_list|)
expr_stmt|;
name|isVectorizedRowIdentifierEnabled
operator|=
name|HiveConf
operator|.
name|getBoolVar
argument_list|(
name|hiveConf
argument_list|,
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVE_VECTORIZATION_ROW_IDENTIFIER_ENABLED
argument_list|)
expr_stmt|;
name|vectorizedPTFMaxMemoryBufferingBatchCount
operator|=
name|HiveConf
operator|.
name|getIntVar
argument_list|(
name|hiveConf
argument_list|,
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVE_VECTORIZATION_PTF_MAX_MEMORY_BUFFERING_BATCH_COUNT
argument_list|)
expr_stmt|;
name|vectorizedTestingReducerBatchSize
operator|=
name|HiveConf
operator|.
name|getIntVar
argument_list|(
name|hiveConf
argument_list|,
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVE_VECTORIZATION_TESTING_REDUCER_BATCH_SIZE
argument_list|)
expr_stmt|;
name|isTestVectorizerSuppressFatalExceptions
operator|=
name|HiveConf
operator|.
name|getBoolVar
argument_list|(
name|hiveConf
argument_list|,
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVE_TEST_VECTORIZER_SUPPRESS_FATAL_EXCEPTIONS
argument_list|)
expr_stmt|;
name|vectorizedInputFormatSupportEnabled
operator|=
name|HiveConf
operator|.
name|getVar
argument_list|(
name|hiveConf
argument_list|,
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVE_VECTORIZED_INPUT_FORMAT_SUPPORTS_ENABLED
argument_list|)
expr_stmt|;
name|String
index|[]
name|supportEnabledStrings
init|=
name|vectorizedInputFormatSupportEnabled
operator|.
name|toLowerCase
argument_list|()
operator|.
name|split
argument_list|(
literal|","
argument_list|)
decl_stmt|;
name|vectorizedInputFormatSupportEnabledSet
operator|=
operator|new
name|TreeSet
argument_list|<
name|Support
argument_list|>
argument_list|()
expr_stmt|;
for|for
control|(
name|String
name|supportEnabledString
range|:
name|supportEnabledStrings
control|)
block|{
name|Support
name|support
init|=
name|Support
operator|.
name|nameToSupportMap
operator|.
name|get
argument_list|(
name|supportEnabledString
argument_list|)
decl_stmt|;
comment|// Known?
if|if
condition|(
name|support
operator|!=
literal|null
condition|)
block|{
name|vectorizedInputFormatSupportEnabledSet
operator|.
name|add
argument_list|(
name|support
argument_list|)
expr_stmt|;
block|}
block|}
comment|/*      * Notice the default value for LLAP_IO_ENABLED is overridden to be whether we are      * executing under LLAP.      */
name|isLlapIoEnabled
operator|=
name|HiveConf
operator|.
name|getBoolVar
argument_list|(
name|hiveConf
argument_list|,
name|HiveConf
operator|.
name|ConfVars
operator|.
name|LLAP_IO_ENABLED
argument_list|,
name|LlapProxy
operator|.
name|isDaemon
argument_list|()
argument_list|)
expr_stmt|;
name|isSchemaEvolution
operator|=
name|HiveConf
operator|.
name|getBoolVar
argument_list|(
name|hiveConf
argument_list|,
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVE_SCHEMA_EVOLUTION
argument_list|)
expr_stmt|;
name|hiveVectorAdaptorUsageMode
operator|=
name|HiveVectorAdaptorUsageMode
operator|.
name|getHiveConfValue
argument_list|(
name|hiveConf
argument_list|)
expr_stmt|;
name|isTestVectorizationSuppressExplainExecutionMode
operator|=
name|HiveConf
operator|.
name|getBoolVar
argument_list|(
name|hiveConf
argument_list|,
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVE_TEST_VECTORIZATION_SUPPRESS_EXPLAIN_EXECUTION_MODE
argument_list|)
expr_stmt|;
comment|// create dispatcher and graph walker
name|Dispatcher
name|disp
init|=
operator|new
name|VectorizationDispatcher
argument_list|()
decl_stmt|;
name|TaskGraphWalker
name|ogw
init|=
operator|new
name|TaskGraphWalker
argument_list|(
name|disp
argument_list|)
decl_stmt|;
comment|// get all the tasks nodes from root task
name|ArrayList
argument_list|<
name|Node
argument_list|>
name|topNodes
init|=
operator|new
name|ArrayList
argument_list|<
name|Node
argument_list|>
argument_list|()
decl_stmt|;
name|topNodes
operator|.
name|addAll
argument_list|(
name|physicalContext
operator|.
name|getRootTasks
argument_list|()
argument_list|)
expr_stmt|;
comment|// begin to walk through the task tree.
name|ogw
operator|.
name|startWalking
argument_list|(
name|topNodes
argument_list|,
literal|null
argument_list|)
expr_stmt|;
return|return
name|physicalContext
return|;
block|}
specifier|private
name|void
name|initVectorizedInputFormatExcludeClasses
parameter_list|()
block|{
name|vectorizedInputFormatExcludes
operator|=
name|Utilities
operator|.
name|getClassNamesFromConfig
argument_list|(
name|hiveConf
argument_list|,
name|ConfVars
operator|.
name|HIVE_VECTORIZATION_VECTORIZED_INPUT_FILE_FORMAT_EXCLUDES
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|initRowDeserializeExcludeClasses
parameter_list|()
block|{
name|rowDeserializeInputFormatExcludes
operator|=
name|Utilities
operator|.
name|getClassNamesFromConfig
argument_list|(
name|hiveConf
argument_list|,
name|ConfVars
operator|.
name|HIVE_VECTORIZATION_ROW_DESERIALIZE_INPUTFORMAT_EXCLUDES
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|setOperatorNotSupported
parameter_list|(
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
name|op
parameter_list|)
block|{
name|OperatorDesc
name|desc
init|=
name|op
operator|.
name|getConf
argument_list|()
decl_stmt|;
name|Annotation
name|note
init|=
name|AnnotationUtils
operator|.
name|getAnnotation
argument_list|(
name|desc
operator|.
name|getClass
argument_list|()
argument_list|,
name|Explain
operator|.
name|class
argument_list|)
decl_stmt|;
if|if
condition|(
name|note
operator|!=
literal|null
condition|)
block|{
name|Explain
name|explainNote
init|=
operator|(
name|Explain
operator|)
name|note
decl_stmt|;
name|setNodeIssue
argument_list|(
name|explainNote
operator|.
name|displayName
argument_list|()
operator|+
literal|" ("
operator|+
name|op
operator|.
name|getType
argument_list|()
operator|+
literal|") not supported"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|setNodeIssue
argument_list|(
literal|"Operator "
operator|+
name|op
operator|.
name|getType
argument_list|()
operator|+
literal|" not supported"
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
name|boolean
name|validateSMBMapJoinOperator
parameter_list|(
name|SMBMapJoinOperator
name|op
parameter_list|)
block|{
name|SMBJoinDesc
name|desc
init|=
name|op
operator|.
name|getConf
argument_list|()
decl_stmt|;
comment|// Validation is the same as for map join, since the 'small' tables are not vectorized
return|return
name|validateMapJoinDesc
argument_list|(
name|desc
argument_list|)
return|;
block|}
specifier|private
name|boolean
name|validateTableScanOperator
parameter_list|(
name|TableScanOperator
name|op
parameter_list|,
name|MapWork
name|mWork
parameter_list|)
block|{
name|TableScanDesc
name|desc
init|=
name|op
operator|.
name|getConf
argument_list|()
decl_stmt|;
if|if
condition|(
name|desc
operator|.
name|isGatherStats
argument_list|()
condition|)
block|{
name|setOperatorIssue
argument_list|(
literal|"gather stats not supported"
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
return|return
literal|true
return|;
block|}
specifier|private
name|boolean
name|validateMapJoinOperator
parameter_list|(
name|MapJoinOperator
name|op
parameter_list|)
block|{
name|MapJoinDesc
name|desc
init|=
name|op
operator|.
name|getConf
argument_list|()
decl_stmt|;
return|return
name|validateMapJoinDesc
argument_list|(
name|desc
argument_list|)
return|;
block|}
specifier|private
name|boolean
name|validateMapJoinDesc
parameter_list|(
name|MapJoinDesc
name|desc
parameter_list|)
block|{
name|byte
name|posBigTable
init|=
operator|(
name|byte
operator|)
name|desc
operator|.
name|getPosBigTable
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|ExprNodeDesc
argument_list|>
name|filterExprs
init|=
name|desc
operator|.
name|getFilters
argument_list|()
operator|.
name|get
argument_list|(
name|posBigTable
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|validateExprNodeDesc
argument_list|(
name|filterExprs
argument_list|,
literal|"Filter"
argument_list|,
name|VectorExpressionDescriptor
operator|.
name|Mode
operator|.
name|FILTER
argument_list|,
comment|/* allowComplex */
literal|true
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
name|List
argument_list|<
name|ExprNodeDesc
argument_list|>
name|keyExprs
init|=
name|desc
operator|.
name|getKeys
argument_list|()
operator|.
name|get
argument_list|(
name|posBigTable
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|validateExprNodeDesc
argument_list|(
name|keyExprs
argument_list|,
literal|"Key"
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
name|List
argument_list|<
name|ExprNodeDesc
argument_list|>
name|valueExprs
init|=
name|desc
operator|.
name|getExprs
argument_list|()
operator|.
name|get
argument_list|(
name|posBigTable
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|validateExprNodeDesc
argument_list|(
name|valueExprs
argument_list|,
literal|"Value"
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
name|Byte
index|[]
name|order
init|=
name|desc
operator|.
name|getTagOrder
argument_list|()
decl_stmt|;
name|Byte
name|posSingleVectorMapJoinSmallTable
init|=
operator|(
name|order
index|[
literal|0
index|]
operator|==
name|posBigTable
condition|?
name|order
index|[
literal|1
index|]
else|:
name|order
index|[
literal|0
index|]
operator|)
decl_stmt|;
name|List
argument_list|<
name|ExprNodeDesc
argument_list|>
name|smallTableExprs
init|=
name|desc
operator|.
name|getExprs
argument_list|()
operator|.
name|get
argument_list|(
name|posSingleVectorMapJoinSmallTable
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|validateExprNodeDesc
argument_list|(
name|smallTableExprs
argument_list|,
literal|"Small Table"
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
if|if
condition|(
name|desc
operator|.
name|getResidualFilterExprs
argument_list|()
operator|!=
literal|null
operator|&&
operator|!
name|desc
operator|.
name|getResidualFilterExprs
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|setOperatorIssue
argument_list|(
literal|"Non-equi joins not supported"
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
return|return
literal|true
return|;
block|}
specifier|private
name|boolean
name|validateSparkHashTableSinkOperator
parameter_list|(
name|SparkHashTableSinkOperator
name|op
parameter_list|)
block|{
name|SparkHashTableSinkDesc
name|desc
init|=
name|op
operator|.
name|getConf
argument_list|()
decl_stmt|;
name|byte
name|tag
init|=
name|desc
operator|.
name|getTag
argument_list|()
decl_stmt|;
comment|// it's essentially a MapJoinDesc
name|List
argument_list|<
name|ExprNodeDesc
argument_list|>
name|filterExprs
init|=
name|desc
operator|.
name|getFilters
argument_list|()
operator|.
name|get
argument_list|(
name|tag
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|ExprNodeDesc
argument_list|>
name|keyExprs
init|=
name|desc
operator|.
name|getKeys
argument_list|()
operator|.
name|get
argument_list|(
name|tag
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|ExprNodeDesc
argument_list|>
name|valueExprs
init|=
name|desc
operator|.
name|getExprs
argument_list|()
operator|.
name|get
argument_list|(
name|tag
argument_list|)
decl_stmt|;
return|return
name|validateExprNodeDesc
argument_list|(
name|filterExprs
argument_list|,
literal|"Filter"
argument_list|,
name|VectorExpressionDescriptor
operator|.
name|Mode
operator|.
name|FILTER
argument_list|,
comment|/* allowComplex */
literal|true
argument_list|)
operator|&&
name|validateExprNodeDesc
argument_list|(
name|keyExprs
argument_list|,
literal|"Key"
argument_list|)
operator|&&
name|validateExprNodeDesc
argument_list|(
name|valueExprs
argument_list|,
literal|"Value"
argument_list|)
return|;
block|}
specifier|private
name|boolean
name|validateReduceSinkOperator
parameter_list|(
name|ReduceSinkOperator
name|op
parameter_list|)
block|{
name|List
argument_list|<
name|ExprNodeDesc
argument_list|>
name|keyDescs
init|=
name|op
operator|.
name|getConf
argument_list|()
operator|.
name|getKeyCols
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|ExprNodeDesc
argument_list|>
name|partitionDescs
init|=
name|op
operator|.
name|getConf
argument_list|()
operator|.
name|getPartitionCols
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|ExprNodeDesc
argument_list|>
name|valueDesc
init|=
name|op
operator|.
name|getConf
argument_list|()
operator|.
name|getValueCols
argument_list|()
decl_stmt|;
return|return
name|validateExprNodeDesc
argument_list|(
name|keyDescs
argument_list|,
literal|"Key"
argument_list|)
operator|&&
name|validateExprNodeDesc
argument_list|(
name|partitionDescs
argument_list|,
literal|"Partition"
argument_list|)
operator|&&
name|validateExprNodeDesc
argument_list|(
name|valueDesc
argument_list|,
literal|"Value"
argument_list|)
return|;
block|}
specifier|private
name|boolean
name|validateSelectOperator
parameter_list|(
name|SelectOperator
name|op
parameter_list|)
block|{
name|List
argument_list|<
name|ExprNodeDesc
argument_list|>
name|descList
init|=
name|op
operator|.
name|getConf
argument_list|()
operator|.
name|getColList
argument_list|()
decl_stmt|;
for|for
control|(
name|ExprNodeDesc
name|desc
range|:
name|descList
control|)
block|{
name|boolean
name|ret
init|=
name|validateExprNodeDesc
argument_list|(
name|desc
argument_list|,
literal|"Select"
argument_list|,
name|VectorExpressionDescriptor
operator|.
name|Mode
operator|.
name|PROJECTION
argument_list|,
comment|/* allowComplex */
literal|true
argument_list|,
comment|/* allowVoidProjection */
literal|true
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|ret
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
return|return
literal|true
return|;
block|}
specifier|private
name|boolean
name|validateFilterOperator
parameter_list|(
name|FilterOperator
name|op
parameter_list|)
block|{
name|ExprNodeDesc
name|desc
init|=
name|op
operator|.
name|getConf
argument_list|()
operator|.
name|getPredicate
argument_list|()
decl_stmt|;
return|return
name|validateExprNodeDesc
argument_list|(
name|desc
argument_list|,
literal|"Predicate"
argument_list|,
name|VectorExpressionDescriptor
operator|.
name|Mode
operator|.
name|FILTER
argument_list|,
comment|/* allowComplex */
literal|true
argument_list|)
return|;
block|}
specifier|private
name|boolean
name|validateGroupByOperator
parameter_list|(
name|GroupByOperator
name|op
parameter_list|,
name|boolean
name|isReduce
parameter_list|,
name|boolean
name|isTezOrSpark
parameter_list|,
name|VectorGroupByDesc
name|vectorGroupByDesc
parameter_list|)
block|{
name|GroupByDesc
name|desc
init|=
name|op
operator|.
name|getConf
argument_list|()
decl_stmt|;
if|if
condition|(
name|desc
operator|.
name|getMode
argument_list|()
operator|!=
name|GroupByDesc
operator|.
name|Mode
operator|.
name|HASH
operator|&&
name|desc
operator|.
name|isDistinct
argument_list|()
condition|)
block|{
name|setOperatorIssue
argument_list|(
literal|"DISTINCT not supported"
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
name|boolean
name|ret
init|=
name|validateExprNodeDescNoComplex
argument_list|(
name|desc
operator|.
name|getKeys
argument_list|()
argument_list|,
literal|"Key"
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|ret
condition|)
block|{
return|return
literal|false
return|;
block|}
comment|/**      *      * GROUP BY DEFINITIONS:      *      * GroupByDesc.Mode enumeration:      *      *    The different modes of a GROUP BY operator.      *      *    These descriptions are hopefully less cryptic than the comments for GroupByDesc.Mode.      *      *        COMPLETE       Aggregates original rows into full aggregation row(s).      *      *                       If the key length is 0, this is also called Global aggregation and      *                       1 output row is produced.      *      *                       When the key length is> 0, the original rows come in ALREADY GROUPED.      *      *                       An example for key length> 0 is a GROUP BY being applied to the      *                       ALREADY GROUPED rows coming from an upstream JOIN operator.  Or,      *                       ALREADY GROUPED rows coming from upstream MERGEPARTIAL GROUP BY      *                       operator.      *      *        PARTIAL1       The first of 2 (or more) phases that aggregates ALREADY GROUPED      *                       original rows into partial aggregations.      *      *                       Subsequent phases PARTIAL2 (optional) and MERGEPARTIAL will merge      *                       the partial aggregations and output full aggregations.      *      *        PARTIAL2       Accept ALREADY GROUPED partial aggregations and merge them into another      *                       partial aggregation.  Output the merged partial aggregations.      *      *                       (Haven't seen this one used)      *      *        PARTIALS       (Behaves for non-distinct the same as PARTIAL2; and behaves for      *                       distinct the same as PARTIAL1.)      *      *        FINAL          Accept ALREADY GROUPED original rows and aggregate them into      *                       full aggregations.      *      *                       Example is a GROUP BY being applied to rows from a sorted table, where      *                       the group key is the table sort key (or a prefix).      *      *        HASH           Accept UNORDERED original rows and aggregate them into a memory table.      *                       Output the partial aggregations on closeOp (or low memory).      *      *                       Similar to PARTIAL1 except original rows are UNORDERED.      *      *                       Commonly used in both Mapper and Reducer nodes.  Always followed by      *                       a Reducer with MERGEPARTIAL GROUP BY.      *      *        MERGEPARTIAL   Always first operator of a Reducer.  Data is grouped by reduce-shuffle.      *      *                       (Behaves for non-distinct aggregations the same as FINAL; and behaves      *                       for distinct aggregations the same as COMPLETE.)      *      *                       The output is full aggregation(s).      *      *                       Used in Reducers after a stage with a HASH GROUP BY operator.      *      *      *  VectorGroupByDesc.ProcessingMode for VectorGroupByOperator:      *      *     GLOBAL         No key.  All rows --> 1 full aggregation on end of input      *      *     HASH           Rows aggregated in to hash table on group key -->      *                        1 partial aggregation per key (normally, unless there is spilling)      *      *     MERGE_PARTIAL  As first operator in a REDUCER, partial aggregations come grouped from      *                    reduce-shuffle -->      *                        aggregate the partial aggregations and emit full aggregation on      *                        endGroup / closeOp      *      *     STREAMING      Rows come from PARENT operator ALREADY GROUPED -->      *                        aggregate the rows and emit full aggregation on key change / closeOp      *      *     NOTE: Hash can spill partial result rows prematurely if it runs low on memory.      *     NOTE: Streaming has to compare keys where MergePartial gets an endGroup call.      *      *      *  DECIDER: Which VectorGroupByDesc.ProcessingMode for VectorGroupByOperator?      *      *     Decides using GroupByDesc.Mode and whether there are keys with the      *     VectorGroupByDesc.groupByDescModeToVectorProcessingMode method.      *      *         Mode.COMPLETE      --> (numKeys == 0 ? ProcessingMode.GLOBAL : ProcessingMode.STREAMING)      *      *         Mode.HASH          --> ProcessingMode.HASH      *      *         Mode.MERGEPARTIAL  --> (numKeys == 0 ? ProcessingMode.GLOBAL : ProcessingMode.MERGE_PARTIAL)      *      *         Mode.PARTIAL1,      *         Mode.PARTIAL2,      *         Mode.PARTIALS,      *         Mode.FINAL        --> ProcessingMode.STREAMING      *      */
name|boolean
name|hasKeys
init|=
operator|(
name|desc
operator|.
name|getKeys
argument_list|()
operator|.
name|size
argument_list|()
operator|>
literal|0
operator|)
decl_stmt|;
name|ProcessingMode
name|processingMode
init|=
name|VectorGroupByDesc
operator|.
name|groupByDescModeToVectorProcessingMode
argument_list|(
name|desc
operator|.
name|getMode
argument_list|()
argument_list|,
name|hasKeys
argument_list|)
decl_stmt|;
if|if
condition|(
name|desc
operator|.
name|isGroupingSetsPresent
argument_list|()
operator|&&
operator|(
name|processingMode
operator|!=
name|ProcessingMode
operator|.
name|HASH
operator|&&
name|processingMode
operator|!=
name|ProcessingMode
operator|.
name|STREAMING
operator|)
condition|)
block|{
name|setOperatorIssue
argument_list|(
literal|"Vectorized GROUPING SETS only expected for HASH and STREAMING processing modes"
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
operator|!
name|validateAggregationDescs
argument_list|(
name|desc
operator|.
name|getAggregators
argument_list|()
argument_list|,
name|desc
operator|.
name|getMode
argument_list|()
argument_list|,
name|hasKeys
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
name|vectorGroupByDesc
operator|.
name|setProcessingMode
argument_list|(
name|processingMode
argument_list|)
expr_stmt|;
name|vectorGroupByDesc
operator|.
name|setIsVectorizationComplexTypesEnabled
argument_list|(
name|isVectorizationComplexTypesEnabled
argument_list|)
expr_stmt|;
name|vectorGroupByDesc
operator|.
name|setIsVectorizationGroupByComplexTypesEnabled
argument_list|(
name|isVectorizationGroupByComplexTypesEnabled
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Vector GROUP BY operator will use processing mode "
operator|+
name|processingMode
operator|.
name|name
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
specifier|private
name|boolean
name|validateFileSinkOperator
parameter_list|(
name|FileSinkOperator
name|op
parameter_list|)
block|{
return|return
literal|true
return|;
block|}
comment|/*    * Determine recursively if the PTF LEAD or LAG function is being used in an expression.    */
specifier|private
name|boolean
name|containsLeadLag
parameter_list|(
name|ExprNodeDesc
name|exprNodeDesc
parameter_list|)
block|{
if|if
condition|(
name|exprNodeDesc
operator|instanceof
name|ExprNodeGenericFuncDesc
condition|)
block|{
name|ExprNodeGenericFuncDesc
name|genericFuncDesc
init|=
operator|(
name|ExprNodeGenericFuncDesc
operator|)
name|exprNodeDesc
decl_stmt|;
name|GenericUDF
name|genFuncClass
init|=
name|genericFuncDesc
operator|.
name|getGenericUDF
argument_list|()
decl_stmt|;
if|if
condition|(
name|genFuncClass
operator|instanceof
name|GenericUDFLag
operator|||
name|genFuncClass
operator|instanceof
name|GenericUDFLead
condition|)
block|{
return|return
literal|true
return|;
block|}
return|return
name|containsLeadLag
argument_list|(
name|genericFuncDesc
operator|.
name|getChildren
argument_list|()
argument_list|)
return|;
block|}
else|else
block|{
comment|// ExprNodeColumnDesc, ExprNodeConstantDesc, ExprNodeDynamicValueDesc, etc do not have
comment|// LEAD/LAG inside.
return|return
literal|false
return|;
block|}
block|}
specifier|private
name|boolean
name|containsLeadLag
parameter_list|(
name|List
argument_list|<
name|ExprNodeDesc
argument_list|>
name|exprNodeDescList
parameter_list|)
block|{
for|for
control|(
name|ExprNodeDesc
name|exprNodeDesc
range|:
name|exprNodeDescList
control|)
block|{
if|if
condition|(
name|containsLeadLag
argument_list|(
name|exprNodeDesc
argument_list|)
condition|)
block|{
return|return
literal|true
return|;
block|}
block|}
return|return
literal|false
return|;
block|}
specifier|private
name|boolean
name|validatePTFOperator
parameter_list|(
name|PTFOperator
name|op
parameter_list|,
name|VectorizationContext
name|vContext
parameter_list|,
name|VectorPTFDesc
name|vectorPTFDesc
parameter_list|)
throws|throws
name|HiveException
block|{
if|if
condition|(
operator|!
name|isPtfVectorizationEnabled
condition|)
block|{
name|setNodeIssue
argument_list|(
literal|"Vectorization of PTF is not enabled ("
operator|+
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVE_VECTORIZATION_PTF_ENABLED
operator|.
name|varname
operator|+
literal|" IS false)"
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
name|PTFDesc
name|ptfDesc
init|=
operator|(
name|PTFDesc
operator|)
name|op
operator|.
name|getConf
argument_list|()
decl_stmt|;
name|boolean
name|isMapSide
init|=
name|ptfDesc
operator|.
name|isMapSide
argument_list|()
decl_stmt|;
if|if
condition|(
name|isMapSide
condition|)
block|{
name|setOperatorIssue
argument_list|(
literal|"PTF Mapper not supported"
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
name|List
argument_list|<
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
argument_list|>
name|ptfParents
init|=
name|op
operator|.
name|getParentOperators
argument_list|()
decl_stmt|;
if|if
condition|(
name|ptfParents
operator|!=
literal|null
operator|&&
name|ptfParents
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
name|ptfParent
init|=
name|op
operator|.
name|getParentOperators
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|ptfParent
operator|instanceof
name|ReduceSinkOperator
operator|)
condition|)
block|{
name|boolean
name|isReduceShufflePtf
init|=
literal|false
decl_stmt|;
if|if
condition|(
name|ptfParent
operator|instanceof
name|SelectOperator
condition|)
block|{
name|ptfParents
operator|=
name|ptfParent
operator|.
name|getParentOperators
argument_list|()
expr_stmt|;
if|if
condition|(
name|ptfParents
operator|==
literal|null
operator|||
name|ptfParents
operator|.
name|size
argument_list|()
operator|==
literal|0
condition|)
block|{
name|isReduceShufflePtf
operator|=
literal|true
expr_stmt|;
block|}
else|else
block|{
name|ptfParent
operator|=
name|ptfParent
operator|.
name|getParentOperators
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|isReduceShufflePtf
operator|=
operator|(
name|ptfParent
operator|instanceof
name|ReduceSinkOperator
operator|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|isReduceShufflePtf
condition|)
block|{
name|setOperatorIssue
argument_list|(
literal|"Only PTF directly under reduce-shuffle is supported"
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
block|}
name|boolean
name|forNoop
init|=
name|ptfDesc
operator|.
name|forNoop
argument_list|()
decl_stmt|;
if|if
condition|(
name|forNoop
condition|)
block|{
name|setOperatorIssue
argument_list|(
literal|"NOOP not supported"
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
name|boolean
name|forWindowing
init|=
name|ptfDesc
operator|.
name|forWindowing
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|forWindowing
condition|)
block|{
name|setOperatorIssue
argument_list|(
literal|"Windowing required"
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
name|PartitionedTableFunctionDef
name|funcDef
init|=
name|ptfDesc
operator|.
name|getFuncDef
argument_list|()
decl_stmt|;
name|boolean
name|isWindowTableFunctionDef
init|=
operator|(
name|funcDef
operator|instanceof
name|WindowTableFunctionDef
operator|)
decl_stmt|;
if|if
condition|(
operator|!
name|isWindowTableFunctionDef
condition|)
block|{
name|setOperatorIssue
argument_list|(
literal|"Must be a WindowTableFunctionDef"
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
comment|// We collect information in VectorPTFDesc that doesn't need the VectorizationContext.
comment|// We use this information for validation.  Later when creating the vector operator
comment|// we create an additional object VectorPTFInfo.
try|try
block|{
name|createVectorPTFDesc
argument_list|(
name|op
argument_list|,
name|ptfDesc
argument_list|,
name|vContext
argument_list|,
name|vectorPTFDesc
argument_list|,
name|vectorizedPTFMaxMemoryBufferingBatchCount
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|HiveException
name|e
parameter_list|)
block|{
name|setOperatorIssue
argument_list|(
literal|"exception: "
operator|+
name|VectorizationContext
operator|.
name|getStackTraceAsSingleLine
argument_list|(
name|e
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
comment|// Output columns ok?
name|String
index|[]
name|outputColumnNames
init|=
name|vectorPTFDesc
operator|.
name|getOutputColumnNames
argument_list|()
decl_stmt|;
name|TypeInfo
index|[]
name|outputTypeInfos
init|=
name|vectorPTFDesc
operator|.
name|getOutputTypeInfos
argument_list|()
decl_stmt|;
specifier|final
name|int
name|outputCount
init|=
name|outputColumnNames
operator|.
name|length
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|outputCount
condition|;
name|i
operator|++
control|)
block|{
name|String
name|typeName
init|=
name|outputTypeInfos
index|[
name|i
index|]
operator|.
name|getTypeName
argument_list|()
decl_stmt|;
name|boolean
name|ret
init|=
name|validateDataType
argument_list|(
name|typeName
argument_list|,
name|VectorExpressionDescriptor
operator|.
name|Mode
operator|.
name|PROJECTION
argument_list|,
comment|/* allowComplex */
literal|false
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|ret
condition|)
block|{
name|setExpressionIssue
argument_list|(
literal|"PTF Output Columns"
argument_list|,
literal|"Data type "
operator|+
name|typeName
operator|+
literal|" of column "
operator|+
name|outputColumnNames
index|[
name|i
index|]
operator|+
literal|" not supported"
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
name|boolean
name|isPartitionOrderBy
init|=
name|vectorPTFDesc
operator|.
name|getIsPartitionOrderBy
argument_list|()
decl_stmt|;
name|String
index|[]
name|evaluatorFunctionNames
init|=
name|vectorPTFDesc
operator|.
name|getEvaluatorFunctionNames
argument_list|()
decl_stmt|;
specifier|final
name|int
name|count
init|=
name|evaluatorFunctionNames
operator|.
name|length
decl_stmt|;
name|WindowFrameDef
index|[]
name|evaluatorWindowFrameDefs
init|=
name|vectorPTFDesc
operator|.
name|getEvaluatorWindowFrameDefs
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|ExprNodeDesc
argument_list|>
index|[]
name|evaluatorInputExprNodeDescLists
init|=
name|vectorPTFDesc
operator|.
name|getEvaluatorInputExprNodeDescLists
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|String
name|functionName
init|=
name|evaluatorFunctionNames
index|[
name|i
index|]
decl_stmt|;
name|SupportedFunctionType
name|supportedFunctionType
init|=
name|VectorPTFDesc
operator|.
name|supportedFunctionsMap
operator|.
name|get
argument_list|(
name|functionName
argument_list|)
decl_stmt|;
if|if
condition|(
name|supportedFunctionType
operator|==
literal|null
condition|)
block|{
name|setOperatorIssue
argument_list|(
name|functionName
operator|+
literal|" not in supported functions "
operator|+
name|VectorPTFDesc
operator|.
name|supportedFunctionNames
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
name|WindowFrameDef
name|windowFrameDef
init|=
name|evaluatorWindowFrameDefs
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|windowFrameDef
operator|.
name|isStartUnbounded
argument_list|()
condition|)
block|{
name|setOperatorIssue
argument_list|(
name|functionName
operator|+
literal|" only UNBOUNDED start frame is supported"
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
switch|switch
condition|(
name|windowFrameDef
operator|.
name|getWindowType
argument_list|()
condition|)
block|{
case|case
name|RANGE
case|:
if|if
condition|(
operator|!
name|windowFrameDef
operator|.
name|getEnd
argument_list|()
operator|.
name|isCurrentRow
argument_list|()
condition|)
block|{
name|setOperatorIssue
argument_list|(
name|functionName
operator|+
literal|" only CURRENT ROW end frame is supported for RANGE"
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
break|break;
case|case
name|ROWS
case|:
if|if
condition|(
operator|!
name|windowFrameDef
operator|.
name|isEndUnbounded
argument_list|()
condition|)
block|{
name|setOperatorIssue
argument_list|(
name|functionName
operator|+
literal|" UNBOUNDED end frame is not supported for ROWS window type"
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
break|break;
default|default:
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Unexpected window type "
operator|+
name|windowFrameDef
operator|.
name|getWindowType
argument_list|()
argument_list|)
throw|;
block|}
name|List
argument_list|<
name|ExprNodeDesc
argument_list|>
name|exprNodeDescList
init|=
name|evaluatorInputExprNodeDescLists
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|exprNodeDescList
operator|!=
literal|null
operator|&&
name|exprNodeDescList
operator|.
name|size
argument_list|()
operator|>
literal|1
condition|)
block|{
name|setOperatorIssue
argument_list|(
literal|"More than 1 argument expression of aggregation function "
operator|+
name|functionName
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
name|exprNodeDescList
operator|!=
literal|null
condition|)
block|{
name|ExprNodeDesc
name|exprNodeDesc
init|=
name|exprNodeDescList
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|containsLeadLag
argument_list|(
name|exprNodeDesc
argument_list|)
condition|)
block|{
name|setOperatorIssue
argument_list|(
literal|"lead and lag function not supported in argument expression of aggregation function "
operator|+
name|functionName
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
name|supportedFunctionType
operator|!=
name|SupportedFunctionType
operator|.
name|COUNT
operator|&&
name|supportedFunctionType
operator|!=
name|SupportedFunctionType
operator|.
name|DENSE_RANK
operator|&&
name|supportedFunctionType
operator|!=
name|SupportedFunctionType
operator|.
name|RANK
condition|)
block|{
comment|// COUNT, DENSE_RANK, and RANK do not care about column types.  The rest do.
name|TypeInfo
name|typeInfo
init|=
name|exprNodeDesc
operator|.
name|getTypeInfo
argument_list|()
decl_stmt|;
name|Category
name|category
init|=
name|typeInfo
operator|.
name|getCategory
argument_list|()
decl_stmt|;
name|boolean
name|isSupportedType
decl_stmt|;
if|if
condition|(
name|category
operator|!=
name|Category
operator|.
name|PRIMITIVE
condition|)
block|{
name|isSupportedType
operator|=
literal|false
expr_stmt|;
block|}
else|else
block|{
name|ColumnVector
operator|.
name|Type
name|colVecType
init|=
name|VectorizationContext
operator|.
name|getColumnVectorTypeFromTypeInfo
argument_list|(
name|typeInfo
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|colVecType
condition|)
block|{
case|case
name|LONG
case|:
case|case
name|DOUBLE
case|:
case|case
name|DECIMAL
case|:
name|isSupportedType
operator|=
literal|true
expr_stmt|;
break|break;
default|default:
name|isSupportedType
operator|=
literal|false
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|isSupportedType
condition|)
block|{
name|setOperatorIssue
argument_list|(
name|typeInfo
operator|.
name|getTypeName
argument_list|()
operator|+
literal|" data type not supported in argument expression of aggregation function "
operator|+
name|functionName
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
block|}
block|}
return|return
literal|true
return|;
block|}
specifier|private
name|boolean
name|validateExprNodeDesc
parameter_list|(
name|List
argument_list|<
name|ExprNodeDesc
argument_list|>
name|descs
parameter_list|,
name|String
name|expressionTitle
parameter_list|)
block|{
return|return
name|validateExprNodeDesc
argument_list|(
name|descs
argument_list|,
name|expressionTitle
argument_list|,
name|VectorExpressionDescriptor
operator|.
name|Mode
operator|.
name|PROJECTION
argument_list|,
comment|/* allowComplex */
literal|true
argument_list|)
return|;
block|}
specifier|private
name|boolean
name|validateExprNodeDescNoComplex
parameter_list|(
name|List
argument_list|<
name|ExprNodeDesc
argument_list|>
name|descs
parameter_list|,
name|String
name|expressionTitle
parameter_list|)
block|{
return|return
name|validateExprNodeDesc
argument_list|(
name|descs
argument_list|,
name|expressionTitle
argument_list|,
name|VectorExpressionDescriptor
operator|.
name|Mode
operator|.
name|PROJECTION
argument_list|,
comment|/* allowComplex */
literal|false
argument_list|)
return|;
block|}
specifier|private
name|boolean
name|validateExprNodeDesc
parameter_list|(
name|List
argument_list|<
name|ExprNodeDesc
argument_list|>
name|descs
parameter_list|,
name|String
name|expressionTitle
parameter_list|,
name|VectorExpressionDescriptor
operator|.
name|Mode
name|mode
parameter_list|,
name|boolean
name|allowComplex
parameter_list|)
block|{
for|for
control|(
name|ExprNodeDesc
name|d
range|:
name|descs
control|)
block|{
name|boolean
name|ret
init|=
name|validateExprNodeDesc
argument_list|(
name|d
argument_list|,
name|expressionTitle
argument_list|,
name|mode
argument_list|,
name|allowComplex
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|ret
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
return|return
literal|true
return|;
block|}
specifier|private
name|boolean
name|validateAggregationDescs
parameter_list|(
name|List
argument_list|<
name|AggregationDesc
argument_list|>
name|descs
parameter_list|,
name|GroupByDesc
operator|.
name|Mode
name|groupByMode
parameter_list|,
name|boolean
name|hasKeys
parameter_list|)
block|{
for|for
control|(
name|AggregationDesc
name|d
range|:
name|descs
control|)
block|{
if|if
condition|(
operator|!
name|validateAggregationDesc
argument_list|(
name|d
argument_list|,
name|groupByMode
argument_list|,
name|hasKeys
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
return|return
literal|true
return|;
block|}
specifier|private
name|boolean
name|validateExprNodeDescRecursive
parameter_list|(
name|ExprNodeDesc
name|desc
parameter_list|,
name|String
name|expressionTitle
parameter_list|,
name|VectorExpressionDescriptor
operator|.
name|Mode
name|mode
parameter_list|,
name|boolean
name|allowComplex
parameter_list|)
block|{
return|return
name|validateExprNodeDescRecursive
argument_list|(
name|desc
argument_list|,
name|expressionTitle
argument_list|,
name|mode
argument_list|,
name|allowComplex
argument_list|,
comment|/* allowVoidProjection */
literal|false
argument_list|)
return|;
block|}
specifier|private
name|boolean
name|validateExprNodeDescRecursive
parameter_list|(
name|ExprNodeDesc
name|desc
parameter_list|,
name|String
name|expressionTitle
parameter_list|,
name|VectorExpressionDescriptor
operator|.
name|Mode
name|mode
parameter_list|,
name|boolean
name|allowComplex
parameter_list|,
name|boolean
name|allowVoidProjection
parameter_list|)
block|{
if|if
condition|(
name|desc
operator|instanceof
name|ExprNodeColumnDesc
condition|)
block|{
name|ExprNodeColumnDesc
name|c
init|=
operator|(
name|ExprNodeColumnDesc
operator|)
name|desc
decl_stmt|;
name|String
name|columnName
init|=
name|c
operator|.
name|getColumn
argument_list|()
decl_stmt|;
if|if
condition|(
name|availableVectorizedVirtualColumnSet
operator|!=
literal|null
condition|)
block|{
comment|// For Map, check for virtual columns.
name|VirtualColumn
name|virtualColumn
init|=
name|VirtualColumn
operator|.
name|VIRTUAL_COLUMN_NAME_MAP
operator|.
name|get
argument_list|(
name|columnName
argument_list|)
decl_stmt|;
if|if
condition|(
name|virtualColumn
operator|!=
literal|null
condition|)
block|{
comment|// We support some virtual columns in vectorization for this table scan.
if|if
condition|(
operator|!
name|availableVectorizedVirtualColumnSet
operator|.
name|contains
argument_list|(
name|virtualColumn
argument_list|)
condition|)
block|{
name|setExpressionIssue
argument_list|(
name|expressionTitle
argument_list|,
literal|"Virtual column "
operator|+
name|columnName
operator|+
literal|" is not supported"
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
comment|// Remember we used this one in the query.
name|neededVirtualColumnSet
operator|.
name|add
argument_list|(
name|virtualColumn
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|String
name|typeName
init|=
name|desc
operator|.
name|getTypeInfo
argument_list|()
operator|.
name|getTypeName
argument_list|()
decl_stmt|;
name|boolean
name|ret
init|=
name|validateDataType
argument_list|(
name|typeName
argument_list|,
name|mode
argument_list|,
name|allowComplex
operator|&&
name|isVectorizationComplexTypesEnabled
argument_list|,
name|allowVoidProjection
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|ret
condition|)
block|{
name|setExpressionIssue
argument_list|(
name|expressionTitle
argument_list|,
name|getValidateDataTypeErrorMsg
argument_list|(
name|typeName
argument_list|,
name|mode
argument_list|,
name|allowComplex
argument_list|,
name|isVectorizationComplexTypesEnabled
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
name|boolean
name|isInExpression
init|=
literal|false
decl_stmt|;
if|if
condition|(
name|desc
operator|instanceof
name|ExprNodeGenericFuncDesc
condition|)
block|{
name|ExprNodeGenericFuncDesc
name|d
init|=
operator|(
name|ExprNodeGenericFuncDesc
operator|)
name|desc
decl_stmt|;
name|boolean
name|r
init|=
name|validateGenericUdf
argument_list|(
name|d
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|r
condition|)
block|{
name|setExpressionIssue
argument_list|(
name|expressionTitle
argument_list|,
literal|"UDF "
operator|+
name|d
operator|+
literal|" not supported"
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
name|GenericUDF
name|genericUDF
init|=
name|d
operator|.
name|getGenericUDF
argument_list|()
decl_stmt|;
name|isInExpression
operator|=
operator|(
name|genericUDF
operator|instanceof
name|GenericUDFIn
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|desc
operator|.
name|getChildren
argument_list|()
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|isInExpression
operator|&&
name|desc
operator|.
name|getChildren
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|getTypeInfo
argument_list|()
operator|.
name|getCategory
argument_list|()
operator|==
name|Category
operator|.
name|STRUCT
condition|)
block|{
comment|// Don't restrict child expressions for projection.
comment|// Always use loose FILTER mode.
if|if
condition|(
operator|!
name|validateStructInExpression
argument_list|(
name|desc
argument_list|,
name|expressionTitle
argument_list|,
name|VectorExpressionDescriptor
operator|.
name|Mode
operator|.
name|FILTER
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
else|else
block|{
for|for
control|(
name|ExprNodeDesc
name|d
range|:
name|desc
operator|.
name|getChildren
argument_list|()
control|)
block|{
comment|// Don't restrict child expressions for projection.
comment|// Always use loose FILTER mode.
if|if
condition|(
operator|!
name|validateExprNodeDescRecursive
argument_list|(
name|d
argument_list|,
name|expressionTitle
argument_list|,
name|VectorExpressionDescriptor
operator|.
name|Mode
operator|.
name|FILTER
argument_list|,
comment|/* allowComplex */
literal|true
argument_list|,
name|allowVoidProjection
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
block|}
block|}
return|return
literal|true
return|;
block|}
specifier|private
name|boolean
name|validateStructInExpression
parameter_list|(
name|ExprNodeDesc
name|desc
parameter_list|,
name|String
name|expressionTitle
parameter_list|,
name|VectorExpressionDescriptor
operator|.
name|Mode
name|mode
parameter_list|)
block|{
for|for
control|(
name|ExprNodeDesc
name|d
range|:
name|desc
operator|.
name|getChildren
argument_list|()
control|)
block|{
name|TypeInfo
name|typeInfo
init|=
name|d
operator|.
name|getTypeInfo
argument_list|()
decl_stmt|;
if|if
condition|(
name|typeInfo
operator|.
name|getCategory
argument_list|()
operator|!=
name|Category
operator|.
name|STRUCT
condition|)
block|{
return|return
literal|false
return|;
block|}
name|StructTypeInfo
name|structTypeInfo
init|=
operator|(
name|StructTypeInfo
operator|)
name|typeInfo
decl_stmt|;
name|ArrayList
argument_list|<
name|TypeInfo
argument_list|>
name|fieldTypeInfos
init|=
name|structTypeInfo
operator|.
name|getAllStructFieldTypeInfos
argument_list|()
decl_stmt|;
name|ArrayList
argument_list|<
name|String
argument_list|>
name|fieldNames
init|=
name|structTypeInfo
operator|.
name|getAllStructFieldNames
argument_list|()
decl_stmt|;
specifier|final
name|int
name|fieldCount
init|=
name|fieldTypeInfos
operator|.
name|size
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|f
init|=
literal|0
init|;
name|f
operator|<
name|fieldCount
condition|;
name|f
operator|++
control|)
block|{
name|TypeInfo
name|fieldTypeInfo
init|=
name|fieldTypeInfos
operator|.
name|get
argument_list|(
name|f
argument_list|)
decl_stmt|;
name|Category
name|category
init|=
name|fieldTypeInfo
operator|.
name|getCategory
argument_list|()
decl_stmt|;
if|if
condition|(
name|category
operator|!=
name|Category
operator|.
name|PRIMITIVE
condition|)
block|{
name|setExpressionIssue
argument_list|(
name|expressionTitle
argument_list|,
literal|"Cannot vectorize struct field "
operator|+
name|fieldNames
operator|.
name|get
argument_list|(
name|f
argument_list|)
operator|+
literal|" of type "
operator|+
name|fieldTypeInfo
operator|.
name|getTypeName
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
name|PrimitiveTypeInfo
name|fieldPrimitiveTypeInfo
init|=
operator|(
name|PrimitiveTypeInfo
operator|)
name|fieldTypeInfo
decl_stmt|;
name|InConstantType
name|inConstantType
init|=
name|VectorizationContext
operator|.
name|getInConstantTypeFromPrimitiveCategory
argument_list|(
name|fieldPrimitiveTypeInfo
operator|.
name|getPrimitiveCategory
argument_list|()
argument_list|)
decl_stmt|;
comment|// For now, limit the data types we support for Vectorized Struct IN().
if|if
condition|(
name|inConstantType
operator|!=
name|InConstantType
operator|.
name|INT_FAMILY
operator|&&
name|inConstantType
operator|!=
name|InConstantType
operator|.
name|FLOAT_FAMILY
operator|&&
name|inConstantType
operator|!=
name|InConstantType
operator|.
name|STRING_FAMILY
condition|)
block|{
name|setExpressionIssue
argument_list|(
name|expressionTitle
argument_list|,
literal|"Cannot vectorize struct field "
operator|+
name|fieldNames
operator|.
name|get
argument_list|(
name|f
argument_list|)
operator|+
literal|" of type "
operator|+
name|fieldTypeInfo
operator|.
name|getTypeName
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
block|}
return|return
literal|true
return|;
block|}
specifier|private
name|boolean
name|validateExprNodeDesc
parameter_list|(
name|ExprNodeDesc
name|desc
parameter_list|,
name|String
name|expressionTitle
parameter_list|)
block|{
return|return
name|validateExprNodeDesc
argument_list|(
name|desc
argument_list|,
name|expressionTitle
argument_list|,
name|VectorExpressionDescriptor
operator|.
name|Mode
operator|.
name|PROJECTION
argument_list|,
comment|/* allowComplex */
literal|true
argument_list|,
comment|/* allowVoidProjection */
literal|false
argument_list|)
return|;
block|}
name|boolean
name|validateExprNodeDesc
parameter_list|(
name|ExprNodeDesc
name|desc
parameter_list|,
name|String
name|expressionTitle
parameter_list|,
name|VectorExpressionDescriptor
operator|.
name|Mode
name|mode
parameter_list|,
name|boolean
name|allowComplex
parameter_list|)
block|{
return|return
name|validateExprNodeDescRecursive
argument_list|(
name|desc
argument_list|,
name|expressionTitle
argument_list|,
name|mode
argument_list|,
name|allowComplex
argument_list|)
return|;
block|}
name|boolean
name|validateExprNodeDesc
parameter_list|(
name|ExprNodeDesc
name|desc
parameter_list|,
name|String
name|expressionTitle
parameter_list|,
name|VectorExpressionDescriptor
operator|.
name|Mode
name|mode
parameter_list|,
name|boolean
name|allowComplex
parameter_list|,
name|boolean
name|allowVoidProjection
parameter_list|)
block|{
return|return
name|validateExprNodeDescRecursive
argument_list|(
name|desc
argument_list|,
name|expressionTitle
argument_list|,
name|mode
argument_list|,
name|allowComplex
argument_list|,
name|allowVoidProjection
argument_list|)
return|;
block|}
specifier|private
name|boolean
name|validateGenericUdf
parameter_list|(
name|ExprNodeGenericFuncDesc
name|genericUDFExpr
parameter_list|)
block|{
if|if
condition|(
name|VectorizationContext
operator|.
name|isCustomUDF
argument_list|(
name|genericUDFExpr
argument_list|)
condition|)
block|{
return|return
literal|true
return|;
block|}
if|if
condition|(
name|hiveVectorAdaptorUsageMode
operator|==
name|HiveVectorAdaptorUsageMode
operator|.
name|NONE
operator|||
name|hiveVectorAdaptorUsageMode
operator|==
name|HiveVectorAdaptorUsageMode
operator|.
name|CHOSEN
condition|)
block|{
name|GenericUDF
name|genericUDF
init|=
name|genericUDFExpr
operator|.
name|getGenericUDF
argument_list|()
decl_stmt|;
if|if
condition|(
name|genericUDF
operator|instanceof
name|GenericUDFBridge
condition|)
block|{
name|Class
argument_list|<
name|?
extends|extends
name|UDF
argument_list|>
name|udf
init|=
operator|(
operator|(
name|GenericUDFBridge
operator|)
name|genericUDF
operator|)
operator|.
name|getUdfClass
argument_list|()
decl_stmt|;
return|return
name|supportedGenericUDFs
operator|.
name|contains
argument_list|(
name|udf
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|supportedGenericUDFs
operator|.
name|contains
argument_list|(
name|genericUDF
operator|.
name|getClass
argument_list|()
argument_list|)
return|;
block|}
block|}
return|return
literal|true
return|;
block|}
specifier|private
name|boolean
name|validateAggregationDesc
parameter_list|(
name|AggregationDesc
name|aggDesc
parameter_list|,
name|GroupByDesc
operator|.
name|Mode
name|groupByMode
parameter_list|,
name|boolean
name|hasKeys
parameter_list|)
block|{
name|String
name|udfName
init|=
name|aggDesc
operator|.
name|getGenericUDAFName
argument_list|()
operator|.
name|toLowerCase
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|supportedAggregationUdfs
operator|.
name|contains
argument_list|(
name|udfName
argument_list|)
condition|)
block|{
name|setExpressionIssue
argument_list|(
literal|"Aggregation Function"
argument_list|,
literal|"UDF "
operator|+
name|udfName
operator|+
literal|" not supported"
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
comment|// The planner seems to pull this one out.
if|if
condition|(
name|aggDesc
operator|.
name|getDistinct
argument_list|()
condition|)
block|{
name|setExpressionIssue
argument_list|(
literal|"Aggregation Function"
argument_list|,
literal|"DISTINCT not supported"
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
name|ArrayList
argument_list|<
name|ExprNodeDesc
argument_list|>
name|parameters
init|=
name|aggDesc
operator|.
name|getParameters
argument_list|()
decl_stmt|;
if|if
condition|(
name|parameters
operator|!=
literal|null
operator|&&
operator|!
name|validateExprNodeDesc
argument_list|(
name|parameters
argument_list|,
literal|"Aggregation Function UDF "
operator|+
name|udfName
operator|+
literal|" parameter"
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
return|return
literal|true
return|;
block|}
specifier|public
specifier|static
name|boolean
name|validateDataType
parameter_list|(
name|String
name|type
parameter_list|,
name|VectorExpressionDescriptor
operator|.
name|Mode
name|mode
parameter_list|,
name|boolean
name|allowComplex
parameter_list|)
block|{
return|return
name|validateDataType
argument_list|(
name|type
argument_list|,
name|mode
argument_list|,
name|allowComplex
argument_list|,
comment|/* allowVoidProjection */
literal|false
argument_list|)
return|;
block|}
specifier|public
specifier|static
name|boolean
name|validateDataType
parameter_list|(
name|String
name|type
parameter_list|,
name|VectorExpressionDescriptor
operator|.
name|Mode
name|mode
parameter_list|,
name|boolean
name|allowComplex
parameter_list|,
name|boolean
name|allowVoidProjection
parameter_list|)
block|{
name|type
operator|=
name|type
operator|.
name|toLowerCase
argument_list|()
expr_stmt|;
name|boolean
name|result
init|=
name|supportedDataTypesPattern
operator|.
name|matcher
argument_list|(
name|type
argument_list|)
operator|.
name|matches
argument_list|()
decl_stmt|;
if|if
condition|(
name|result
operator|&&
operator|!
name|allowVoidProjection
operator|&&
name|mode
operator|==
name|VectorExpressionDescriptor
operator|.
name|Mode
operator|.
name|PROJECTION
operator|&&
name|type
operator|.
name|equals
argument_list|(
literal|"void"
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
if|if
condition|(
operator|!
name|result
condition|)
block|{
name|TypeInfo
name|typeInfo
init|=
name|TypeInfoUtils
operator|.
name|getTypeInfoFromTypeString
argument_list|(
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
name|typeInfo
operator|.
name|getCategory
argument_list|()
operator|!=
name|Category
operator|.
name|PRIMITIVE
condition|)
block|{
if|if
condition|(
name|allowComplex
condition|)
block|{
return|return
literal|true
return|;
block|}
block|}
block|}
return|return
name|result
return|;
block|}
specifier|public
specifier|static
name|String
name|getValidateDataTypeErrorMsg
parameter_list|(
name|String
name|type
parameter_list|,
name|VectorExpressionDescriptor
operator|.
name|Mode
name|mode
parameter_list|,
name|boolean
name|allowComplex
parameter_list|,
name|boolean
name|isVectorizationComplexTypesEnabled
parameter_list|)
block|{
return|return
name|getValidateDataTypeErrorMsg
argument_list|(
name|type
argument_list|,
name|mode
argument_list|,
name|allowComplex
argument_list|,
name|isVectorizationComplexTypesEnabled
argument_list|,
literal|false
argument_list|)
return|;
block|}
specifier|public
specifier|static
name|String
name|getValidateDataTypeErrorMsg
parameter_list|(
name|String
name|type
parameter_list|,
name|VectorExpressionDescriptor
operator|.
name|Mode
name|mode
parameter_list|,
name|boolean
name|allowComplex
parameter_list|,
name|boolean
name|isVectorizationComplexTypesEnabled
parameter_list|,
name|boolean
name|allowVoidProjection
parameter_list|)
block|{
name|type
operator|=
name|type
operator|.
name|toLowerCase
argument_list|()
expr_stmt|;
name|boolean
name|result
init|=
name|supportedDataTypesPattern
operator|.
name|matcher
argument_list|(
name|type
argument_list|)
operator|.
name|matches
argument_list|()
decl_stmt|;
if|if
condition|(
name|result
operator|&&
operator|!
name|allowVoidProjection
operator|&&
name|mode
operator|==
name|VectorExpressionDescriptor
operator|.
name|Mode
operator|.
name|PROJECTION
operator|&&
name|type
operator|.
name|equals
argument_list|(
literal|"void"
argument_list|)
condition|)
block|{
return|return
literal|"Vectorizing data type void not supported when mode = PROJECTION"
return|;
block|}
if|if
condition|(
operator|!
name|result
condition|)
block|{
name|TypeInfo
name|typeInfo
init|=
name|TypeInfoUtils
operator|.
name|getTypeInfoFromTypeString
argument_list|(
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
name|typeInfo
operator|.
name|getCategory
argument_list|()
operator|!=
name|Category
operator|.
name|PRIMITIVE
condition|)
block|{
if|if
condition|(
name|allowComplex
operator|&&
name|isVectorizationComplexTypesEnabled
condition|)
block|{
return|return
literal|null
return|;
block|}
elseif|else
if|if
condition|(
operator|!
name|allowComplex
condition|)
block|{
return|return
literal|"Vectorizing complex type "
operator|+
name|typeInfo
operator|.
name|getCategory
argument_list|()
operator|+
literal|" not supported"
return|;
block|}
else|else
block|{
return|return
literal|"Vectorizing complex type "
operator|+
name|typeInfo
operator|.
name|getCategory
argument_list|()
operator|+
literal|" not enabled ("
operator|+
name|type
operator|+
literal|") since "
operator|+
name|GroupByDesc
operator|.
name|getComplexTypeEnabledCondition
argument_list|(
name|isVectorizationComplexTypesEnabled
argument_list|)
return|;
block|}
block|}
block|}
return|return
operator|(
name|result
condition|?
literal|null
else|:
literal|"Vectorizing data type "
operator|+
name|type
operator|+
literal|" not supported"
operator|)
return|;
block|}
specifier|private
name|VectorizationContext
name|getVectorizationContext
parameter_list|(
name|String
name|contextName
parameter_list|,
name|VectorTaskColumnInfo
name|vectorTaskColumnInfo
parameter_list|)
block|{
name|VectorizationContext
name|vContext
init|=
operator|new
name|VectorizationContext
argument_list|(
name|contextName
argument_list|,
name|vectorTaskColumnInfo
operator|.
name|allColumnNames
argument_list|,
name|vectorTaskColumnInfo
operator|.
name|allTypeInfos
argument_list|,
name|vectorTaskColumnInfo
operator|.
name|allDataTypePhysicalVariations
argument_list|,
name|hiveConf
argument_list|)
decl_stmt|;
return|return
name|vContext
return|;
block|}
specifier|private
name|void
name|fixupParentChildOperators
parameter_list|(
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
name|op
parameter_list|,
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
name|vectorOp
parameter_list|)
block|{
if|if
condition|(
name|op
operator|.
name|getParentOperators
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|vectorOp
operator|.
name|setParentOperators
argument_list|(
name|op
operator|.
name|getParentOperators
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
name|p
range|:
name|op
operator|.
name|getParentOperators
argument_list|()
control|)
block|{
name|p
operator|.
name|replaceChild
argument_list|(
name|op
argument_list|,
name|vectorOp
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|op
operator|.
name|getChildOperators
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|vectorOp
operator|.
name|setChildOperators
argument_list|(
name|op
operator|.
name|getChildOperators
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
name|c
range|:
name|op
operator|.
name|getChildOperators
argument_list|()
control|)
block|{
name|c
operator|.
name|replaceParent
argument_list|(
name|op
argument_list|,
name|vectorOp
argument_list|)
expr_stmt|;
block|}
block|}
block|}
specifier|private
name|boolean
name|isBigTableOnlyResults
parameter_list|(
name|MapJoinDesc
name|desc
parameter_list|)
block|{
name|Byte
index|[]
name|order
init|=
name|desc
operator|.
name|getTagOrder
argument_list|()
decl_stmt|;
name|byte
name|posBigTable
init|=
operator|(
name|byte
operator|)
name|desc
operator|.
name|getPosBigTable
argument_list|()
decl_stmt|;
name|Byte
name|posSingleVectorMapJoinSmallTable
init|=
operator|(
name|order
index|[
literal|0
index|]
operator|==
name|posBigTable
condition|?
name|order
index|[
literal|1
index|]
else|:
name|order
index|[
literal|0
index|]
operator|)
decl_stmt|;
name|int
index|[]
name|smallTableIndices
decl_stmt|;
name|int
name|smallTableIndicesSize
decl_stmt|;
if|if
condition|(
name|desc
operator|.
name|getValueIndices
argument_list|()
operator|!=
literal|null
operator|&&
name|desc
operator|.
name|getValueIndices
argument_list|()
operator|.
name|get
argument_list|(
name|posSingleVectorMapJoinSmallTable
argument_list|)
operator|!=
literal|null
condition|)
block|{
name|smallTableIndices
operator|=
name|desc
operator|.
name|getValueIndices
argument_list|()
operator|.
name|get
argument_list|(
name|posSingleVectorMapJoinSmallTable
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Vectorizer isBigTableOnlyResults smallTableIndices "
operator|+
name|Arrays
operator|.
name|toString
argument_list|(
name|smallTableIndices
argument_list|)
argument_list|)
expr_stmt|;
name|smallTableIndicesSize
operator|=
name|smallTableIndices
operator|.
name|length
expr_stmt|;
block|}
else|else
block|{
name|smallTableIndices
operator|=
literal|null
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Vectorizer isBigTableOnlyResults smallTableIndices EMPTY"
argument_list|)
expr_stmt|;
name|smallTableIndicesSize
operator|=
literal|0
expr_stmt|;
block|}
name|List
argument_list|<
name|Integer
argument_list|>
name|smallTableRetainList
init|=
name|desc
operator|.
name|getRetainList
argument_list|()
operator|.
name|get
argument_list|(
name|posSingleVectorMapJoinSmallTable
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Vectorizer isBigTableOnlyResults smallTableRetainList "
operator|+
name|smallTableRetainList
argument_list|)
expr_stmt|;
name|int
name|smallTableRetainSize
init|=
name|smallTableRetainList
operator|.
name|size
argument_list|()
decl_stmt|;
if|if
condition|(
name|smallTableIndicesSize
operator|>
literal|0
condition|)
block|{
comment|// Small table indices has priority over retain.
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|smallTableIndicesSize
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|smallTableIndices
index|[
name|i
index|]
operator|<
literal|0
condition|)
block|{
comment|// Negative numbers indicate a column to be (deserialize) read from the small table's
comment|// LazyBinary value row.
name|setOperatorIssue
argument_list|(
literal|"Vectorizer isBigTableOnlyResults smallTableIndices[i]< 0 returning false"
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|smallTableRetainSize
operator|>
literal|0
condition|)
block|{
name|setOperatorIssue
argument_list|(
literal|"Vectorizer isBigTableOnlyResults smallTableRetainSize> 0 returning false"
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"Vectorizer isBigTableOnlyResults returning true"
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
name|specializeMapJoinOperator
parameter_list|(
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
name|op
parameter_list|,
name|VectorizationContext
name|vContext
parameter_list|,
name|MapJoinDesc
name|desc
parameter_list|,
name|VectorMapJoinDesc
name|vectorDesc
parameter_list|)
throws|throws
name|HiveException
block|{
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
name|vectorOp
init|=
literal|null
decl_stmt|;
name|Class
argument_list|<
name|?
extends|extends
name|Operator
argument_list|<
name|?
argument_list|>
argument_list|>
name|opClass
init|=
literal|null
decl_stmt|;
name|VectorMapJoinInfo
name|vectorMapJoinInfo
init|=
name|vectorDesc
operator|.
name|getVectorMapJoinInfo
argument_list|()
decl_stmt|;
name|HashTableImplementationType
name|hashTableImplementationType
init|=
name|HashTableImplementationType
operator|.
name|NONE
decl_stmt|;
name|HashTableKind
name|hashTableKind
init|=
name|HashTableKind
operator|.
name|NONE
decl_stmt|;
name|HashTableKeyType
name|hashTableKeyType
init|=
name|HashTableKeyType
operator|.
name|NONE
decl_stmt|;
name|VectorMapJoinVariation
name|vectorMapJoinVariation
init|=
name|VectorMapJoinVariation
operator|.
name|NONE
decl_stmt|;
if|if
condition|(
name|vectorDesc
operator|.
name|getIsFastHashTableEnabled
argument_list|()
condition|)
block|{
name|hashTableImplementationType
operator|=
name|HashTableImplementationType
operator|.
name|FAST
expr_stmt|;
block|}
else|else
block|{
name|hashTableImplementationType
operator|=
name|HashTableImplementationType
operator|.
name|OPTIMIZED
expr_stmt|;
block|}
name|int
name|joinType
init|=
name|desc
operator|.
name|getConds
argument_list|()
index|[
literal|0
index|]
operator|.
name|getType
argument_list|()
decl_stmt|;
name|boolean
name|isInnerBigOnly
init|=
literal|false
decl_stmt|;
if|if
condition|(
name|joinType
operator|==
name|JoinDesc
operator|.
name|INNER_JOIN
operator|&&
name|isBigTableOnlyResults
argument_list|(
name|desc
argument_list|)
condition|)
block|{
name|isInnerBigOnly
operator|=
literal|true
expr_stmt|;
block|}
comment|// By default, we can always use the multi-key class.
name|hashTableKeyType
operator|=
name|HashTableKeyType
operator|.
name|MULTI_KEY
expr_stmt|;
if|if
condition|(
operator|!
name|HiveConf
operator|.
name|getBoolVar
argument_list|(
name|hiveConf
argument_list|,
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVE_VECTORIZATION_MAPJOIN_NATIVE_MULTIKEY_ONLY_ENABLED
argument_list|)
condition|)
block|{
comment|// Look for single column optimization.
name|byte
name|posBigTable
init|=
operator|(
name|byte
operator|)
name|desc
operator|.
name|getPosBigTable
argument_list|()
decl_stmt|;
name|Map
argument_list|<
name|Byte
argument_list|,
name|List
argument_list|<
name|ExprNodeDesc
argument_list|>
argument_list|>
name|keyExprs
init|=
name|desc
operator|.
name|getKeys
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|ExprNodeDesc
argument_list|>
name|bigTableKeyExprs
init|=
name|keyExprs
operator|.
name|get
argument_list|(
name|posBigTable
argument_list|)
decl_stmt|;
if|if
condition|(
name|bigTableKeyExprs
operator|.
name|size
argument_list|()
operator|==
literal|1
condition|)
block|{
name|TypeInfo
name|typeInfo
init|=
name|bigTableKeyExprs
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|getTypeInfo
argument_list|()
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Vectorizer vectorizeOperator map join typeName "
operator|+
name|typeInfo
operator|.
name|getTypeName
argument_list|()
argument_list|)
expr_stmt|;
switch|switch
condition|(
operator|(
operator|(
name|PrimitiveTypeInfo
operator|)
name|typeInfo
operator|)
operator|.
name|getPrimitiveCategory
argument_list|()
condition|)
block|{
case|case
name|BOOLEAN
case|:
name|hashTableKeyType
operator|=
name|HashTableKeyType
operator|.
name|BOOLEAN
expr_stmt|;
break|break;
case|case
name|BYTE
case|:
name|hashTableKeyType
operator|=
name|HashTableKeyType
operator|.
name|BYTE
expr_stmt|;
break|break;
case|case
name|SHORT
case|:
name|hashTableKeyType
operator|=
name|HashTableKeyType
operator|.
name|SHORT
expr_stmt|;
break|break;
case|case
name|INT
case|:
name|hashTableKeyType
operator|=
name|HashTableKeyType
operator|.
name|INT
expr_stmt|;
break|break;
case|case
name|LONG
case|:
name|hashTableKeyType
operator|=
name|HashTableKeyType
operator|.
name|LONG
expr_stmt|;
break|break;
case|case
name|STRING
case|:
case|case
name|CHAR
case|:
case|case
name|VARCHAR
case|:
case|case
name|BINARY
case|:
name|hashTableKeyType
operator|=
name|HashTableKeyType
operator|.
name|STRING
expr_stmt|;
default|default:
comment|// Stay with multi-key.
block|}
block|}
block|}
switch|switch
condition|(
name|joinType
condition|)
block|{
case|case
name|JoinDesc
operator|.
name|INNER_JOIN
case|:
if|if
condition|(
operator|!
name|isInnerBigOnly
condition|)
block|{
name|vectorMapJoinVariation
operator|=
name|VectorMapJoinVariation
operator|.
name|INNER
expr_stmt|;
name|hashTableKind
operator|=
name|HashTableKind
operator|.
name|HASH_MAP
expr_stmt|;
block|}
else|else
block|{
name|vectorMapJoinVariation
operator|=
name|VectorMapJoinVariation
operator|.
name|INNER_BIG_ONLY
expr_stmt|;
name|hashTableKind
operator|=
name|HashTableKind
operator|.
name|HASH_MULTISET
expr_stmt|;
block|}
break|break;
case|case
name|JoinDesc
operator|.
name|LEFT_OUTER_JOIN
case|:
case|case
name|JoinDesc
operator|.
name|RIGHT_OUTER_JOIN
case|:
name|vectorMapJoinVariation
operator|=
name|VectorMapJoinVariation
operator|.
name|OUTER
expr_stmt|;
name|hashTableKind
operator|=
name|HashTableKind
operator|.
name|HASH_MAP
expr_stmt|;
break|break;
case|case
name|JoinDesc
operator|.
name|LEFT_SEMI_JOIN
case|:
name|vectorMapJoinVariation
operator|=
name|VectorMapJoinVariation
operator|.
name|LEFT_SEMI
expr_stmt|;
name|hashTableKind
operator|=
name|HashTableKind
operator|.
name|HASH_SET
expr_stmt|;
break|break;
default|default:
throw|throw
operator|new
name|HiveException
argument_list|(
literal|"Unknown join type "
operator|+
name|joinType
argument_list|)
throw|;
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"Vectorizer vectorizeOperator map join hashTableKind "
operator|+
name|hashTableKind
operator|.
name|name
argument_list|()
operator|+
literal|" hashTableKeyType "
operator|+
name|hashTableKeyType
operator|.
name|name
argument_list|()
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|hashTableKeyType
condition|)
block|{
case|case
name|BOOLEAN
case|:
case|case
name|BYTE
case|:
case|case
name|SHORT
case|:
case|case
name|INT
case|:
case|case
name|LONG
case|:
switch|switch
condition|(
name|vectorMapJoinVariation
condition|)
block|{
case|case
name|INNER
case|:
name|opClass
operator|=
name|VectorMapJoinInnerLongOperator
operator|.
name|class
expr_stmt|;
break|break;
case|case
name|INNER_BIG_ONLY
case|:
name|opClass
operator|=
name|VectorMapJoinInnerBigOnlyLongOperator
operator|.
name|class
expr_stmt|;
break|break;
case|case
name|LEFT_SEMI
case|:
name|opClass
operator|=
name|VectorMapJoinLeftSemiLongOperator
operator|.
name|class
expr_stmt|;
break|break;
case|case
name|OUTER
case|:
name|opClass
operator|=
name|VectorMapJoinOuterLongOperator
operator|.
name|class
expr_stmt|;
break|break;
default|default:
throw|throw
operator|new
name|HiveException
argument_list|(
literal|"Unknown operator variation "
operator|+
name|vectorMapJoinVariation
argument_list|)
throw|;
block|}
break|break;
case|case
name|STRING
case|:
switch|switch
condition|(
name|vectorMapJoinVariation
condition|)
block|{
case|case
name|INNER
case|:
name|opClass
operator|=
name|VectorMapJoinInnerStringOperator
operator|.
name|class
expr_stmt|;
break|break;
case|case
name|INNER_BIG_ONLY
case|:
name|opClass
operator|=
name|VectorMapJoinInnerBigOnlyStringOperator
operator|.
name|class
expr_stmt|;
break|break;
case|case
name|LEFT_SEMI
case|:
name|opClass
operator|=
name|VectorMapJoinLeftSemiStringOperator
operator|.
name|class
expr_stmt|;
break|break;
case|case
name|OUTER
case|:
name|opClass
operator|=
name|VectorMapJoinOuterStringOperator
operator|.
name|class
expr_stmt|;
break|break;
default|default:
throw|throw
operator|new
name|HiveException
argument_list|(
literal|"Unknown operator variation "
operator|+
name|vectorMapJoinVariation
argument_list|)
throw|;
block|}
break|break;
case|case
name|MULTI_KEY
case|:
switch|switch
condition|(
name|vectorMapJoinVariation
condition|)
block|{
case|case
name|INNER
case|:
name|opClass
operator|=
name|VectorMapJoinInnerMultiKeyOperator
operator|.
name|class
expr_stmt|;
break|break;
case|case
name|INNER_BIG_ONLY
case|:
name|opClass
operator|=
name|VectorMapJoinInnerBigOnlyMultiKeyOperator
operator|.
name|class
expr_stmt|;
break|break;
case|case
name|LEFT_SEMI
case|:
name|opClass
operator|=
name|VectorMapJoinLeftSemiMultiKeyOperator
operator|.
name|class
expr_stmt|;
break|break;
case|case
name|OUTER
case|:
name|opClass
operator|=
name|VectorMapJoinOuterMultiKeyOperator
operator|.
name|class
expr_stmt|;
break|break;
default|default:
throw|throw
operator|new
name|HiveException
argument_list|(
literal|"Unknown operator variation "
operator|+
name|vectorMapJoinVariation
argument_list|)
throw|;
block|}
break|break;
default|default:
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Unexpected hash table key type "
operator|+
name|hashTableKeyType
operator|.
name|name
argument_list|()
argument_list|)
throw|;
block|}
name|boolean
name|minMaxEnabled
init|=
name|HiveConf
operator|.
name|getBoolVar
argument_list|(
name|hiveConf
argument_list|,
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVE_VECTORIZATION_MAPJOIN_NATIVE_MINMAX_ENABLED
argument_list|)
decl_stmt|;
name|vectorDesc
operator|.
name|setHashTableImplementationType
argument_list|(
name|hashTableImplementationType
argument_list|)
expr_stmt|;
name|vectorDesc
operator|.
name|setHashTableKind
argument_list|(
name|hashTableKind
argument_list|)
expr_stmt|;
name|vectorDesc
operator|.
name|setHashTableKeyType
argument_list|(
name|hashTableKeyType
argument_list|)
expr_stmt|;
name|vectorDesc
operator|.
name|setVectorMapJoinVariation
argument_list|(
name|vectorMapJoinVariation
argument_list|)
expr_stmt|;
name|vectorDesc
operator|.
name|setMinMaxEnabled
argument_list|(
name|minMaxEnabled
argument_list|)
expr_stmt|;
name|vectorDesc
operator|.
name|setVectorMapJoinInfo
argument_list|(
name|vectorMapJoinInfo
argument_list|)
expr_stmt|;
name|vectorOp
operator|=
name|OperatorFactory
operator|.
name|getVectorOperator
argument_list|(
name|opClass
argument_list|,
name|op
operator|.
name|getCompilationOpContext
argument_list|()
argument_list|,
name|op
operator|.
name|getConf
argument_list|()
argument_list|,
name|vContext
argument_list|,
name|vectorDesc
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Vectorizer vectorizeOperator map join class "
operator|+
name|vectorOp
operator|.
name|getClass
argument_list|()
operator|.
name|getSimpleName
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|vectorOp
return|;
block|}
specifier|public
specifier|static
name|boolean
name|onExpressionHasNullSafes
parameter_list|(
name|MapJoinDesc
name|desc
parameter_list|)
block|{
name|boolean
index|[]
name|nullSafes
init|=
name|desc
operator|.
name|getNullSafes
argument_list|()
decl_stmt|;
if|if
condition|(
name|nullSafes
operator|==
literal|null
condition|)
block|{
return|return
literal|false
return|;
block|}
for|for
control|(
name|boolean
name|nullSafe
range|:
name|nullSafes
control|)
block|{
if|if
condition|(
name|nullSafe
condition|)
block|{
return|return
literal|true
return|;
block|}
block|}
return|return
literal|false
return|;
block|}
specifier|private
name|boolean
name|canSpecializeMapJoin
parameter_list|(
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
name|op
parameter_list|,
name|MapJoinDesc
name|desc
parameter_list|,
name|boolean
name|isTezOrSpark
parameter_list|,
name|VectorizationContext
name|vContext
parameter_list|,
name|VectorMapJoinDesc
name|vectorDesc
parameter_list|)
throws|throws
name|HiveException
block|{
name|Preconditions
operator|.
name|checkState
argument_list|(
name|op
operator|instanceof
name|MapJoinOperator
argument_list|)
expr_stmt|;
name|VectorMapJoinInfo
name|vectorMapJoinInfo
init|=
operator|new
name|VectorMapJoinInfo
argument_list|()
decl_stmt|;
name|boolean
name|isVectorizationMapJoinNativeEnabled
init|=
name|HiveConf
operator|.
name|getBoolVar
argument_list|(
name|hiveConf
argument_list|,
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVE_VECTORIZATION_MAPJOIN_NATIVE_ENABLED
argument_list|)
decl_stmt|;
name|String
name|engine
init|=
name|HiveConf
operator|.
name|getVar
argument_list|(
name|hiveConf
argument_list|,
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVE_EXECUTION_ENGINE
argument_list|)
decl_stmt|;
name|boolean
name|oneMapJoinCondition
init|=
operator|(
name|desc
operator|.
name|getConds
argument_list|()
operator|.
name|length
operator|==
literal|1
operator|)
decl_stmt|;
name|boolean
name|hasNullSafes
init|=
name|onExpressionHasNullSafes
argument_list|(
name|desc
argument_list|)
decl_stmt|;
name|byte
name|posBigTable
init|=
operator|(
name|byte
operator|)
name|desc
operator|.
name|getPosBigTable
argument_list|()
decl_stmt|;
comment|// Since we want to display all the met and not met conditions in EXPLAIN, we determine all
comment|// information first....
name|List
argument_list|<
name|ExprNodeDesc
argument_list|>
name|keyDesc
init|=
name|desc
operator|.
name|getKeys
argument_list|()
operator|.
name|get
argument_list|(
name|posBigTable
argument_list|)
decl_stmt|;
name|boolean
name|outerJoinHasNoKeys
init|=
operator|(
operator|!
name|desc
operator|.
name|isNoOuterJoin
argument_list|()
operator|&&
name|keyDesc
operator|.
name|size
argument_list|()
operator|==
literal|0
operator|)
decl_stmt|;
comment|// For now, we don't support joins on or using DECIMAL_64.
name|VectorExpression
index|[]
name|allBigTableKeyExpressions
init|=
name|vContext
operator|.
name|getVectorExpressionsUpConvertDecimal64
argument_list|(
name|keyDesc
argument_list|)
decl_stmt|;
specifier|final
name|int
name|allBigTableKeyExpressionsLength
init|=
name|allBigTableKeyExpressions
operator|.
name|length
decl_stmt|;
name|boolean
name|supportsKeyTypes
init|=
literal|true
decl_stmt|;
comment|// Assume.
name|HashSet
argument_list|<
name|String
argument_list|>
name|notSupportedKeyTypes
init|=
operator|new
name|HashSet
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
comment|// Since a key expression can be a calculation and the key will go into a scratch column,
comment|// we need the mapping and type information.
name|int
index|[]
name|bigTableKeyColumnMap
init|=
operator|new
name|int
index|[
name|allBigTableKeyExpressionsLength
index|]
decl_stmt|;
name|String
index|[]
name|bigTableKeyColumnNames
init|=
operator|new
name|String
index|[
name|allBigTableKeyExpressionsLength
index|]
decl_stmt|;
name|TypeInfo
index|[]
name|bigTableKeyTypeInfos
init|=
operator|new
name|TypeInfo
index|[
name|allBigTableKeyExpressionsLength
index|]
decl_stmt|;
name|ArrayList
argument_list|<
name|VectorExpression
argument_list|>
name|bigTableKeyExpressionsList
init|=
operator|new
name|ArrayList
argument_list|<
name|VectorExpression
argument_list|>
argument_list|()
decl_stmt|;
name|VectorExpression
index|[]
name|slimmedBigTableKeyExpressions
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|allBigTableKeyExpressionsLength
condition|;
name|i
operator|++
control|)
block|{
name|VectorExpression
name|ve
init|=
name|allBigTableKeyExpressions
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|IdentityExpression
operator|.
name|isColumnOnly
argument_list|(
name|ve
argument_list|)
condition|)
block|{
name|bigTableKeyExpressionsList
operator|.
name|add
argument_list|(
name|ve
argument_list|)
expr_stmt|;
block|}
name|bigTableKeyColumnMap
index|[
name|i
index|]
operator|=
name|ve
operator|.
name|getOutputColumnNum
argument_list|()
expr_stmt|;
name|ExprNodeDesc
name|exprNode
init|=
name|keyDesc
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|bigTableKeyColumnNames
index|[
name|i
index|]
operator|=
name|exprNode
operator|.
name|toString
argument_list|()
expr_stmt|;
name|TypeInfo
name|typeInfo
init|=
name|exprNode
operator|.
name|getTypeInfo
argument_list|()
decl_stmt|;
comment|// Verify we handle the key column types for an optimized table.  This is the effectively the
comment|// same check used in HashTableLoader.
if|if
condition|(
operator|!
name|MapJoinKey
operator|.
name|isSupportedField
argument_list|(
name|typeInfo
argument_list|)
condition|)
block|{
name|supportsKeyTypes
operator|=
literal|false
expr_stmt|;
name|Category
name|category
init|=
name|typeInfo
operator|.
name|getCategory
argument_list|()
decl_stmt|;
name|notSupportedKeyTypes
operator|.
name|add
argument_list|(
operator|(
name|category
operator|!=
name|Category
operator|.
name|PRIMITIVE
condition|?
name|category
operator|.
name|toString
argument_list|()
else|:
operator|(
operator|(
name|PrimitiveTypeInfo
operator|)
name|typeInfo
operator|)
operator|.
name|getPrimitiveCategory
argument_list|()
operator|.
name|toString
argument_list|()
operator|)
argument_list|)
expr_stmt|;
block|}
name|bigTableKeyTypeInfos
index|[
name|i
index|]
operator|=
name|typeInfo
expr_stmt|;
block|}
if|if
condition|(
name|bigTableKeyExpressionsList
operator|.
name|size
argument_list|()
operator|==
literal|0
condition|)
block|{
name|slimmedBigTableKeyExpressions
operator|=
literal|null
expr_stmt|;
block|}
else|else
block|{
name|slimmedBigTableKeyExpressions
operator|=
name|bigTableKeyExpressionsList
operator|.
name|toArray
argument_list|(
operator|new
name|VectorExpression
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
name|List
argument_list|<
name|ExprNodeDesc
argument_list|>
name|bigTableExprs
init|=
name|desc
operator|.
name|getExprs
argument_list|()
operator|.
name|get
argument_list|(
name|posBigTable
argument_list|)
decl_stmt|;
comment|// For now, we don't support joins on or using DECIMAL_64.
name|VectorExpression
index|[]
name|allBigTableValueExpressions
init|=
name|vContext
operator|.
name|getVectorExpressionsUpConvertDecimal64
argument_list|(
name|bigTableExprs
argument_list|)
decl_stmt|;
name|boolean
name|isFastHashTableEnabled
init|=
name|HiveConf
operator|.
name|getBoolVar
argument_list|(
name|hiveConf
argument_list|,
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVE_VECTORIZATION_MAPJOIN_NATIVE_FAST_HASHTABLE_ENABLED
argument_list|)
decl_stmt|;
comment|// Especially since LLAP is prone to turn it off in the MapJoinDesc in later
comment|// physical optimizer stages...
name|boolean
name|isHybridHashJoin
init|=
name|desc
operator|.
name|isHybridHashJoin
argument_list|()
decl_stmt|;
comment|/*      * Populate vectorMapJoininfo.      */
comment|/*      * Similarly, we need a mapping since a value expression can be a calculation and the value      * will go into a scratch column.      */
name|int
index|[]
name|bigTableValueColumnMap
init|=
operator|new
name|int
index|[
name|allBigTableValueExpressions
operator|.
name|length
index|]
decl_stmt|;
name|String
index|[]
name|bigTableValueColumnNames
init|=
operator|new
name|String
index|[
name|allBigTableValueExpressions
operator|.
name|length
index|]
decl_stmt|;
name|TypeInfo
index|[]
name|bigTableValueTypeInfos
init|=
operator|new
name|TypeInfo
index|[
name|allBigTableValueExpressions
operator|.
name|length
index|]
decl_stmt|;
name|ArrayList
argument_list|<
name|VectorExpression
argument_list|>
name|bigTableValueExpressionsList
init|=
operator|new
name|ArrayList
argument_list|<
name|VectorExpression
argument_list|>
argument_list|()
decl_stmt|;
name|VectorExpression
index|[]
name|slimmedBigTableValueExpressions
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|bigTableValueColumnMap
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|VectorExpression
name|ve
init|=
name|allBigTableValueExpressions
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|IdentityExpression
operator|.
name|isColumnOnly
argument_list|(
name|ve
argument_list|)
condition|)
block|{
name|bigTableValueExpressionsList
operator|.
name|add
argument_list|(
name|ve
argument_list|)
expr_stmt|;
block|}
name|bigTableValueColumnMap
index|[
name|i
index|]
operator|=
name|ve
operator|.
name|getOutputColumnNum
argument_list|()
expr_stmt|;
name|ExprNodeDesc
name|exprNode
init|=
name|bigTableExprs
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|bigTableValueColumnNames
index|[
name|i
index|]
operator|=
name|exprNode
operator|.
name|toString
argument_list|()
expr_stmt|;
name|bigTableValueTypeInfos
index|[
name|i
index|]
operator|=
name|exprNode
operator|.
name|getTypeInfo
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|bigTableValueExpressionsList
operator|.
name|size
argument_list|()
operator|==
literal|0
condition|)
block|{
name|slimmedBigTableValueExpressions
operator|=
literal|null
expr_stmt|;
block|}
else|else
block|{
name|slimmedBigTableValueExpressions
operator|=
name|bigTableValueExpressionsList
operator|.
name|toArray
argument_list|(
operator|new
name|VectorExpression
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
name|vectorMapJoinInfo
operator|.
name|setBigTableKeyColumnMap
argument_list|(
name|bigTableKeyColumnMap
argument_list|)
expr_stmt|;
name|vectorMapJoinInfo
operator|.
name|setBigTableKeyColumnNames
argument_list|(
name|bigTableKeyColumnNames
argument_list|)
expr_stmt|;
name|vectorMapJoinInfo
operator|.
name|setBigTableKeyTypeInfos
argument_list|(
name|bigTableKeyTypeInfos
argument_list|)
expr_stmt|;
name|vectorMapJoinInfo
operator|.
name|setSlimmedBigTableKeyExpressions
argument_list|(
name|slimmedBigTableKeyExpressions
argument_list|)
expr_stmt|;
name|vectorDesc
operator|.
name|setAllBigTableKeyExpressions
argument_list|(
name|allBigTableKeyExpressions
argument_list|)
expr_stmt|;
name|vectorMapJoinInfo
operator|.
name|setBigTableValueColumnMap
argument_list|(
name|bigTableValueColumnMap
argument_list|)
expr_stmt|;
name|vectorMapJoinInfo
operator|.
name|setBigTableValueColumnNames
argument_list|(
name|bigTableValueColumnNames
argument_list|)
expr_stmt|;
name|vectorMapJoinInfo
operator|.
name|setBigTableValueTypeInfos
argument_list|(
name|bigTableValueTypeInfos
argument_list|)
expr_stmt|;
name|vectorMapJoinInfo
operator|.
name|setSlimmedBigTableValueExpressions
argument_list|(
name|slimmedBigTableValueExpressions
argument_list|)
expr_stmt|;
name|vectorDesc
operator|.
name|setAllBigTableValueExpressions
argument_list|(
name|allBigTableValueExpressions
argument_list|)
expr_stmt|;
comment|/*      * Small table information.      */
name|VectorColumnOutputMapping
name|bigTableRetainedMapping
init|=
operator|new
name|VectorColumnOutputMapping
argument_list|(
literal|"Big Table Retained Mapping"
argument_list|)
decl_stmt|;
name|VectorColumnOutputMapping
name|bigTableOuterKeyMapping
init|=
operator|new
name|VectorColumnOutputMapping
argument_list|(
literal|"Big Table Outer Key Mapping"
argument_list|)
decl_stmt|;
comment|// The order of the fields in the LazyBinary small table value must be used, so
comment|// we use the source ordering flavor for the mapping.
name|VectorColumnSourceMapping
name|smallTableMapping
init|=
operator|new
name|VectorColumnSourceMapping
argument_list|(
literal|"Small Table Mapping"
argument_list|)
decl_stmt|;
name|Byte
index|[]
name|order
init|=
name|desc
operator|.
name|getTagOrder
argument_list|()
decl_stmt|;
name|Byte
name|posSingleVectorMapJoinSmallTable
init|=
operator|(
name|order
index|[
literal|0
index|]
operator|==
name|posBigTable
condition|?
name|order
index|[
literal|1
index|]
else|:
name|order
index|[
literal|0
index|]
operator|)
decl_stmt|;
name|boolean
name|isOuterJoin
init|=
operator|!
name|desc
operator|.
name|getNoOuterJoin
argument_list|()
decl_stmt|;
comment|/*      * Gather up big and small table output result information from the MapJoinDesc.      */
name|List
argument_list|<
name|Integer
argument_list|>
name|bigTableRetainList
init|=
name|desc
operator|.
name|getRetainList
argument_list|()
operator|.
name|get
argument_list|(
name|posBigTable
argument_list|)
decl_stmt|;
name|int
name|bigTableRetainSize
init|=
name|bigTableRetainList
operator|.
name|size
argument_list|()
decl_stmt|;
name|int
index|[]
name|smallTableIndices
decl_stmt|;
name|int
name|smallTableIndicesSize
decl_stmt|;
name|List
argument_list|<
name|ExprNodeDesc
argument_list|>
name|smallTableExprs
init|=
name|desc
operator|.
name|getExprs
argument_list|()
operator|.
name|get
argument_list|(
name|posSingleVectorMapJoinSmallTable
argument_list|)
decl_stmt|;
if|if
condition|(
name|desc
operator|.
name|getValueIndices
argument_list|()
operator|!=
literal|null
operator|&&
name|desc
operator|.
name|getValueIndices
argument_list|()
operator|.
name|get
argument_list|(
name|posSingleVectorMapJoinSmallTable
argument_list|)
operator|!=
literal|null
condition|)
block|{
name|smallTableIndices
operator|=
name|desc
operator|.
name|getValueIndices
argument_list|()
operator|.
name|get
argument_list|(
name|posSingleVectorMapJoinSmallTable
argument_list|)
expr_stmt|;
name|smallTableIndicesSize
operator|=
name|smallTableIndices
operator|.
name|length
expr_stmt|;
block|}
else|else
block|{
name|smallTableIndices
operator|=
literal|null
expr_stmt|;
name|smallTableIndicesSize
operator|=
literal|0
expr_stmt|;
block|}
name|List
argument_list|<
name|Integer
argument_list|>
name|smallTableRetainList
init|=
name|desc
operator|.
name|getRetainList
argument_list|()
operator|.
name|get
argument_list|(
name|posSingleVectorMapJoinSmallTable
argument_list|)
decl_stmt|;
name|int
name|smallTableRetainSize
init|=
name|smallTableRetainList
operator|.
name|size
argument_list|()
decl_stmt|;
name|int
name|smallTableResultSize
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|smallTableIndicesSize
operator|>
literal|0
condition|)
block|{
name|smallTableResultSize
operator|=
name|smallTableIndicesSize
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|smallTableRetainSize
operator|>
literal|0
condition|)
block|{
name|smallTableResultSize
operator|=
name|smallTableRetainSize
expr_stmt|;
block|}
comment|/*      * Determine the big table retained mapping first so we can optimize out (with      * projection) copying inner join big table keys in the subsequent small table results section.      */
comment|// We use a mapping object here so we can build the projection in any order and
comment|// get the ordered by 0 to n-1 output columns at the end.
comment|//
comment|// Also, to avoid copying a big table key into the small table result area for inner joins,
comment|// we reference it with the projection so there can be duplicate output columns
comment|// in the projection.
name|VectorColumnSourceMapping
name|projectionMapping
init|=
operator|new
name|VectorColumnSourceMapping
argument_list|(
literal|"Projection Mapping"
argument_list|)
decl_stmt|;
name|int
name|nextOutputColumn
init|=
operator|(
name|order
index|[
literal|0
index|]
operator|==
name|posBigTable
condition|?
literal|0
else|:
name|smallTableResultSize
operator|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|bigTableRetainSize
condition|;
name|i
operator|++
control|)
block|{
comment|// Since bigTableValueExpressions may do a calculation and produce a scratch column, we
comment|// need to map to the right batch column.
name|int
name|retainColumn
init|=
name|bigTableRetainList
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|int
name|batchColumnIndex
init|=
name|bigTableValueColumnMap
index|[
name|retainColumn
index|]
decl_stmt|;
name|TypeInfo
name|typeInfo
init|=
name|bigTableValueTypeInfos
index|[
name|i
index|]
decl_stmt|;
comment|// With this map we project the big table batch to make it look like an output batch.
name|projectionMapping
operator|.
name|add
argument_list|(
name|nextOutputColumn
argument_list|,
name|batchColumnIndex
argument_list|,
name|typeInfo
argument_list|)
expr_stmt|;
comment|// Collect columns we copy from the big table batch to the overflow batch.
if|if
condition|(
operator|!
name|bigTableRetainedMapping
operator|.
name|containsOutputColumn
argument_list|(
name|batchColumnIndex
argument_list|)
condition|)
block|{
comment|// Tolerate repeated use of a big table column.
name|bigTableRetainedMapping
operator|.
name|add
argument_list|(
name|batchColumnIndex
argument_list|,
name|batchColumnIndex
argument_list|,
name|typeInfo
argument_list|)
expr_stmt|;
block|}
name|nextOutputColumn
operator|++
expr_stmt|;
block|}
comment|/*      * Now determine the small table results.      */
name|boolean
name|smallTableExprVectorizes
init|=
literal|true
decl_stmt|;
name|int
name|firstSmallTableOutputColumn
decl_stmt|;
name|firstSmallTableOutputColumn
operator|=
operator|(
name|order
index|[
literal|0
index|]
operator|==
name|posBigTable
condition|?
name|bigTableRetainSize
else|:
literal|0
operator|)
expr_stmt|;
name|int
name|smallTableOutputCount
init|=
literal|0
decl_stmt|;
name|nextOutputColumn
operator|=
name|firstSmallTableOutputColumn
expr_stmt|;
comment|// Small table indices has more information (i.e. keys) than retain, so use it if it exists...
name|String
index|[]
name|bigTableRetainedNames
decl_stmt|;
if|if
condition|(
name|smallTableIndicesSize
operator|>
literal|0
condition|)
block|{
name|smallTableOutputCount
operator|=
name|smallTableIndicesSize
expr_stmt|;
name|bigTableRetainedNames
operator|=
operator|new
name|String
index|[
name|smallTableOutputCount
index|]
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|smallTableIndicesSize
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|smallTableIndices
index|[
name|i
index|]
operator|>=
literal|0
condition|)
block|{
comment|// Zero and above numbers indicate a big table key is needed for
comment|// small table result "area".
name|int
name|keyIndex
init|=
name|smallTableIndices
index|[
name|i
index|]
decl_stmt|;
comment|// Since bigTableKeyExpressions may do a calculation and produce a scratch column, we
comment|// need to map the right column.
name|int
name|batchKeyColumn
init|=
name|bigTableKeyColumnMap
index|[
name|keyIndex
index|]
decl_stmt|;
name|bigTableRetainedNames
index|[
name|i
index|]
operator|=
name|bigTableKeyColumnNames
index|[
name|keyIndex
index|]
expr_stmt|;
name|TypeInfo
name|typeInfo
init|=
name|bigTableKeyTypeInfos
index|[
name|keyIndex
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|isOuterJoin
condition|)
block|{
comment|// Optimize inner join keys of small table results.
comment|// Project the big table key into the small table result "area".
name|projectionMapping
operator|.
name|add
argument_list|(
name|nextOutputColumn
argument_list|,
name|batchKeyColumn
argument_list|,
name|typeInfo
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bigTableRetainedMapping
operator|.
name|containsOutputColumn
argument_list|(
name|batchKeyColumn
argument_list|)
condition|)
block|{
comment|// If necessary, copy the big table key into the overflow batch's small table
comment|// result "area".
name|bigTableRetainedMapping
operator|.
name|add
argument_list|(
name|batchKeyColumn
argument_list|,
name|batchKeyColumn
argument_list|,
name|typeInfo
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// For outer joins, since the small table key can be null when there is no match,
comment|// we must have a physical (scratch) column for those keys.  We cannot use the
comment|// projection optimization used by inner joins above.
name|int
name|scratchColumn
init|=
name|vContext
operator|.
name|allocateScratchColumn
argument_list|(
name|typeInfo
argument_list|)
decl_stmt|;
name|projectionMapping
operator|.
name|add
argument_list|(
name|nextOutputColumn
argument_list|,
name|scratchColumn
argument_list|,
name|typeInfo
argument_list|)
expr_stmt|;
name|bigTableRetainedMapping
operator|.
name|add
argument_list|(
name|batchKeyColumn
argument_list|,
name|scratchColumn
argument_list|,
name|typeInfo
argument_list|)
expr_stmt|;
name|bigTableOuterKeyMapping
operator|.
name|add
argument_list|(
name|batchKeyColumn
argument_list|,
name|scratchColumn
argument_list|,
name|typeInfo
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// Negative numbers indicate a column to be (deserialize) read from the small table's
comment|// LazyBinary value row.
name|int
name|smallTableValueIndex
init|=
operator|-
name|smallTableIndices
index|[
name|i
index|]
operator|-
literal|1
decl_stmt|;
name|ExprNodeDesc
name|smallTableExprNode
init|=
name|smallTableExprs
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|validateExprNodeDesc
argument_list|(
name|smallTableExprNode
argument_list|,
literal|"Small Table"
argument_list|)
condition|)
block|{
name|clearNotVectorizedReason
argument_list|()
expr_stmt|;
name|smallTableExprVectorizes
operator|=
literal|false
expr_stmt|;
block|}
name|bigTableRetainedNames
index|[
name|i
index|]
operator|=
name|smallTableExprNode
operator|.
name|toString
argument_list|()
expr_stmt|;
name|TypeInfo
name|typeInfo
init|=
name|smallTableExprNode
operator|.
name|getTypeInfo
argument_list|()
decl_stmt|;
comment|// Make a new big table scratch column for the small table value.
name|int
name|scratchColumn
init|=
name|vContext
operator|.
name|allocateScratchColumn
argument_list|(
name|typeInfo
argument_list|)
decl_stmt|;
name|projectionMapping
operator|.
name|add
argument_list|(
name|nextOutputColumn
argument_list|,
name|scratchColumn
argument_list|,
name|typeInfo
argument_list|)
expr_stmt|;
name|smallTableMapping
operator|.
name|add
argument_list|(
name|smallTableValueIndex
argument_list|,
name|scratchColumn
argument_list|,
name|typeInfo
argument_list|)
expr_stmt|;
block|}
name|nextOutputColumn
operator|++
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|smallTableRetainSize
operator|>
literal|0
condition|)
block|{
name|smallTableOutputCount
operator|=
name|smallTableRetainSize
expr_stmt|;
name|bigTableRetainedNames
operator|=
operator|new
name|String
index|[
name|smallTableOutputCount
index|]
expr_stmt|;
comment|// Only small table values appear in join output result.
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|smallTableRetainSize
condition|;
name|i
operator|++
control|)
block|{
name|int
name|smallTableValueIndex
init|=
name|smallTableRetainList
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|ExprNodeDesc
name|smallTableExprNode
init|=
name|smallTableExprs
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|validateExprNodeDesc
argument_list|(
name|smallTableExprNode
argument_list|,
literal|"Small Table"
argument_list|)
condition|)
block|{
name|clearNotVectorizedReason
argument_list|()
expr_stmt|;
name|smallTableExprVectorizes
operator|=
literal|false
expr_stmt|;
block|}
name|bigTableRetainedNames
index|[
name|i
index|]
operator|=
name|smallTableExprNode
operator|.
name|toString
argument_list|()
expr_stmt|;
comment|// Make a new big table scratch column for the small table value.
name|TypeInfo
name|typeInfo
init|=
name|smallTableExprNode
operator|.
name|getTypeInfo
argument_list|()
decl_stmt|;
name|int
name|scratchColumn
init|=
name|vContext
operator|.
name|allocateScratchColumn
argument_list|(
name|typeInfo
argument_list|)
decl_stmt|;
name|projectionMapping
operator|.
name|add
argument_list|(
name|nextOutputColumn
argument_list|,
name|scratchColumn
argument_list|,
name|typeInfo
argument_list|)
expr_stmt|;
name|smallTableMapping
operator|.
name|add
argument_list|(
name|smallTableValueIndex
argument_list|,
name|scratchColumn
argument_list|,
name|typeInfo
argument_list|)
expr_stmt|;
name|nextOutputColumn
operator|++
expr_stmt|;
block|}
block|}
else|else
block|{
name|bigTableRetainedNames
operator|=
operator|new
name|String
index|[
literal|0
index|]
expr_stmt|;
block|}
name|boolean
name|useOptimizedTable
init|=
name|HiveConf
operator|.
name|getBoolVar
argument_list|(
name|hiveConf
argument_list|,
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVEMAPJOINUSEOPTIMIZEDTABLE
argument_list|)
decl_stmt|;
comment|// Remember the condition variables for EXPLAIN regardless of whether we specialize or not.
name|vectorDesc
operator|.
name|setVectorMapJoinInfo
argument_list|(
name|vectorMapJoinInfo
argument_list|)
expr_stmt|;
name|vectorDesc
operator|.
name|setUseOptimizedTable
argument_list|(
name|useOptimizedTable
argument_list|)
expr_stmt|;
name|vectorDesc
operator|.
name|setIsVectorizationMapJoinNativeEnabled
argument_list|(
name|isVectorizationMapJoinNativeEnabled
argument_list|)
expr_stmt|;
name|vectorDesc
operator|.
name|setEngine
argument_list|(
name|engine
argument_list|)
expr_stmt|;
name|vectorDesc
operator|.
name|setOneMapJoinCondition
argument_list|(
name|oneMapJoinCondition
argument_list|)
expr_stmt|;
name|vectorDesc
operator|.
name|setHasNullSafes
argument_list|(
name|hasNullSafes
argument_list|)
expr_stmt|;
name|vectorDesc
operator|.
name|setSmallTableExprVectorizes
argument_list|(
name|smallTableExprVectorizes
argument_list|)
expr_stmt|;
name|vectorDesc
operator|.
name|setOuterJoinHasNoKeys
argument_list|(
name|outerJoinHasNoKeys
argument_list|)
expr_stmt|;
name|vectorDesc
operator|.
name|setIsFastHashTableEnabled
argument_list|(
name|isFastHashTableEnabled
argument_list|)
expr_stmt|;
name|vectorDesc
operator|.
name|setIsHybridHashJoin
argument_list|(
name|isHybridHashJoin
argument_list|)
expr_stmt|;
name|vectorDesc
operator|.
name|setSupportsKeyTypes
argument_list|(
name|supportsKeyTypes
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|supportsKeyTypes
condition|)
block|{
name|vectorDesc
operator|.
name|setNotSupportedKeyTypes
argument_list|(
operator|new
name|ArrayList
argument_list|(
name|notSupportedKeyTypes
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// Check common conditions for both Optimized and Fast Hash Tables.
name|boolean
name|result
init|=
literal|true
decl_stmt|;
comment|// Assume.
if|if
condition|(
operator|!
name|useOptimizedTable
operator|||
operator|!
name|isVectorizationMapJoinNativeEnabled
operator|||
operator|!
name|isTezOrSpark
operator|||
operator|!
name|oneMapJoinCondition
operator|||
name|hasNullSafes
operator|||
operator|!
name|smallTableExprVectorizes
operator|||
name|outerJoinHasNoKeys
condition|)
block|{
name|result
operator|=
literal|false
expr_stmt|;
block|}
comment|// supportsKeyTypes
if|if
condition|(
operator|!
name|isFastHashTableEnabled
condition|)
block|{
comment|// Check optimized-only hash table restrictions.
if|if
condition|(
operator|!
name|supportsKeyTypes
condition|)
block|{
name|result
operator|=
literal|false
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// With the fast hash table implementation, we currently do not support
comment|// Hybrid Grace Hash Join.
if|if
condition|(
name|isHybridHashJoin
condition|)
block|{
name|result
operator|=
literal|false
expr_stmt|;
block|}
block|}
comment|// Convert dynamic arrays and maps to simple arrays.
name|bigTableRetainedMapping
operator|.
name|finalize
argument_list|()
expr_stmt|;
name|bigTableOuterKeyMapping
operator|.
name|finalize
argument_list|()
expr_stmt|;
name|smallTableMapping
operator|.
name|finalize
argument_list|()
expr_stmt|;
name|vectorMapJoinInfo
operator|.
name|setBigTableRetainedMapping
argument_list|(
name|bigTableRetainedMapping
argument_list|)
expr_stmt|;
name|vectorMapJoinInfo
operator|.
name|setBigTableOuterKeyMapping
argument_list|(
name|bigTableOuterKeyMapping
argument_list|)
expr_stmt|;
name|vectorMapJoinInfo
operator|.
name|setSmallTableMapping
argument_list|(
name|smallTableMapping
argument_list|)
expr_stmt|;
name|projectionMapping
operator|.
name|finalize
argument_list|()
expr_stmt|;
comment|// Verify we added an entry for each output.
assert|assert
name|projectionMapping
operator|.
name|isSourceSequenceGood
argument_list|()
assert|;
name|vectorMapJoinInfo
operator|.
name|setProjectionMapping
argument_list|(
name|projectionMapping
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
specifier|private
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
name|specializeReduceSinkOperator
parameter_list|(
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
name|op
parameter_list|,
name|VectorizationContext
name|vContext
parameter_list|,
name|ReduceSinkDesc
name|desc
parameter_list|,
name|VectorReduceSinkDesc
name|vectorDesc
parameter_list|)
throws|throws
name|HiveException
block|{
name|VectorReduceSinkInfo
name|vectorReduceSinkInfo
init|=
name|vectorDesc
operator|.
name|getVectorReduceSinkInfo
argument_list|()
decl_stmt|;
name|Type
index|[]
name|reduceSinkKeyColumnVectorTypes
init|=
name|vectorReduceSinkInfo
operator|.
name|getReduceSinkKeyColumnVectorTypes
argument_list|()
decl_stmt|;
comment|// By default, we can always use the multi-key class.
name|VectorReduceSinkDesc
operator|.
name|ReduceSinkKeyType
name|reduceSinkKeyType
init|=
name|VectorReduceSinkDesc
operator|.
name|ReduceSinkKeyType
operator|.
name|MULTI_KEY
decl_stmt|;
comment|// Look for single column optimization.
if|if
condition|(
name|reduceSinkKeyColumnVectorTypes
operator|!=
literal|null
operator|&&
name|reduceSinkKeyColumnVectorTypes
operator|.
name|length
operator|==
literal|1
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Vectorizer vectorizeOperator groupby typeName "
operator|+
name|vectorReduceSinkInfo
operator|.
name|getReduceSinkKeyTypeInfos
argument_list|()
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|Type
name|columnVectorType
init|=
name|reduceSinkKeyColumnVectorTypes
index|[
literal|0
index|]
decl_stmt|;
switch|switch
condition|(
name|columnVectorType
condition|)
block|{
case|case
name|LONG
case|:
block|{
name|PrimitiveCategory
name|primitiveCategory
init|=
operator|(
operator|(
name|PrimitiveTypeInfo
operator|)
name|vectorReduceSinkInfo
operator|.
name|getReduceSinkKeyTypeInfos
argument_list|()
index|[
literal|0
index|]
operator|)
operator|.
name|getPrimitiveCategory
argument_list|()
decl_stmt|;
switch|switch
condition|(
name|primitiveCategory
condition|)
block|{
case|case
name|BOOLEAN
case|:
case|case
name|BYTE
case|:
case|case
name|SHORT
case|:
case|case
name|INT
case|:
case|case
name|LONG
case|:
name|reduceSinkKeyType
operator|=
name|VectorReduceSinkDesc
operator|.
name|ReduceSinkKeyType
operator|.
name|LONG
expr_stmt|;
break|break;
default|default:
comment|// Other integer types not supported yet.
break|break;
block|}
block|}
break|break;
case|case
name|BYTES
case|:
name|reduceSinkKeyType
operator|=
name|VectorReduceSinkDesc
operator|.
name|ReduceSinkKeyType
operator|.
name|STRING
expr_stmt|;
default|default:
comment|// Stay with multi-key.
break|break;
block|}
block|}
name|Class
argument_list|<
name|?
extends|extends
name|Operator
argument_list|<
name|?
argument_list|>
argument_list|>
name|opClass
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|vectorReduceSinkInfo
operator|.
name|getUseUniformHash
argument_list|()
condition|)
block|{
if|if
condition|(
name|vectorDesc
operator|.
name|getIsEmptyKey
argument_list|()
condition|)
block|{
name|opClass
operator|=
name|VectorReduceSinkEmptyKeyOperator
operator|.
name|class
expr_stmt|;
block|}
else|else
block|{
switch|switch
condition|(
name|reduceSinkKeyType
condition|)
block|{
case|case
name|LONG
case|:
name|opClass
operator|=
name|VectorReduceSinkLongOperator
operator|.
name|class
expr_stmt|;
break|break;
case|case
name|STRING
case|:
name|opClass
operator|=
name|VectorReduceSinkStringOperator
operator|.
name|class
expr_stmt|;
break|break;
case|case
name|MULTI_KEY
case|:
name|opClass
operator|=
name|VectorReduceSinkMultiKeyOperator
operator|.
name|class
expr_stmt|;
break|break;
default|default:
throw|throw
operator|new
name|HiveException
argument_list|(
literal|"Unknown reduce sink key type "
operator|+
name|reduceSinkKeyType
argument_list|)
throw|;
block|}
block|}
block|}
else|else
block|{
if|if
condition|(
name|vectorDesc
operator|.
name|getIsEmptyKey
argument_list|()
operator|&&
name|vectorDesc
operator|.
name|getIsEmptyBuckets
argument_list|()
operator|&&
name|vectorDesc
operator|.
name|getIsEmptyPartitions
argument_list|()
condition|)
block|{
name|opClass
operator|=
name|VectorReduceSinkEmptyKeyOperator
operator|.
name|class
expr_stmt|;
block|}
else|else
block|{
name|opClass
operator|=
name|VectorReduceSinkObjectHashOperator
operator|.
name|class
expr_stmt|;
block|}
block|}
name|vectorDesc
operator|.
name|setReduceSinkKeyType
argument_list|(
name|reduceSinkKeyType
argument_list|)
expr_stmt|;
name|vectorDesc
operator|.
name|setVectorReduceSinkInfo
argument_list|(
name|vectorReduceSinkInfo
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Vectorizer vectorizeOperator reduce sink class "
operator|+
name|opClass
operator|.
name|getSimpleName
argument_list|()
argument_list|)
expr_stmt|;
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
name|vectorOp
init|=
literal|null
decl_stmt|;
try|try
block|{
name|vectorOp
operator|=
name|OperatorFactory
operator|.
name|getVectorOperator
argument_list|(
name|opClass
argument_list|,
name|op
operator|.
name|getCompilationOpContext
argument_list|()
argument_list|,
name|op
operator|.
name|getConf
argument_list|()
argument_list|,
name|vContext
argument_list|,
name|vectorDesc
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Vectorizer vectorizeOperator reduce sink class exception "
operator|+
name|opClass
operator|.
name|getSimpleName
argument_list|()
operator|+
literal|" exception "
operator|+
name|e
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|HiveException
argument_list|(
name|e
argument_list|)
throw|;
block|}
return|return
name|vectorOp
return|;
block|}
specifier|private
name|boolean
name|canSpecializeReduceSink
parameter_list|(
name|ReduceSinkDesc
name|desc
parameter_list|,
name|boolean
name|isTezOrSpark
parameter_list|,
name|VectorizationContext
name|vContext
parameter_list|,
name|VectorReduceSinkDesc
name|vectorDesc
parameter_list|)
throws|throws
name|HiveException
block|{
name|VectorReduceSinkInfo
name|vectorReduceSinkInfo
init|=
operator|new
name|VectorReduceSinkInfo
argument_list|()
decl_stmt|;
comment|// Various restrictions.
comment|// Set this if we encounter a condition we were not expecting.
name|boolean
name|isUnexpectedCondition
init|=
literal|false
decl_stmt|;
name|boolean
name|isVectorizationReduceSinkNativeEnabled
init|=
name|HiveConf
operator|.
name|getBoolVar
argument_list|(
name|hiveConf
argument_list|,
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVE_VECTORIZATION_REDUCESINK_NEW_ENABLED
argument_list|)
decl_stmt|;
name|String
name|engine
init|=
name|HiveConf
operator|.
name|getVar
argument_list|(
name|hiveConf
argument_list|,
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVE_EXECUTION_ENGINE
argument_list|)
decl_stmt|;
name|int
name|limit
init|=
name|desc
operator|.
name|getTopN
argument_list|()
decl_stmt|;
name|float
name|memUsage
init|=
name|desc
operator|.
name|getTopNMemoryUsage
argument_list|()
decl_stmt|;
name|boolean
name|hasPTFTopN
init|=
operator|(
name|limit
operator|>=
literal|0
operator|&&
name|memUsage
operator|>
literal|0
operator|&&
name|desc
operator|.
name|isPTFReduceSink
argument_list|()
operator|)
decl_stmt|;
name|boolean
name|hasDistinctColumns
init|=
operator|(
name|desc
operator|.
name|getDistinctColumnIndices
argument_list|()
operator|.
name|size
argument_list|()
operator|>
literal|0
operator|)
decl_stmt|;
name|TableDesc
name|keyTableDesc
init|=
name|desc
operator|.
name|getKeySerializeInfo
argument_list|()
decl_stmt|;
name|Class
argument_list|<
name|?
extends|extends
name|Deserializer
argument_list|>
name|keySerializerClass
init|=
name|keyTableDesc
operator|.
name|getDeserializerClass
argument_list|()
decl_stmt|;
name|boolean
name|isKeyBinarySortable
init|=
operator|(
name|keySerializerClass
operator|==
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|binarysortable
operator|.
name|BinarySortableSerDe
operator|.
name|class
operator|)
decl_stmt|;
name|TableDesc
name|valueTableDesc
init|=
name|desc
operator|.
name|getValueSerializeInfo
argument_list|()
decl_stmt|;
name|Class
argument_list|<
name|?
extends|extends
name|Deserializer
argument_list|>
name|valueDeserializerClass
init|=
name|valueTableDesc
operator|.
name|getDeserializerClass
argument_list|()
decl_stmt|;
name|boolean
name|isValueLazyBinary
init|=
operator|(
name|valueDeserializerClass
operator|==
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|lazybinary
operator|.
name|LazyBinarySerDe
operator|.
name|class
operator|)
decl_stmt|;
comment|// We are doing work here we'd normally do in VectorGroupByCommonOperator's constructor.
comment|// So if we later decide not to specialize, we'll just waste any scratch columns allocated...
name|List
argument_list|<
name|ExprNodeDesc
argument_list|>
name|keysDescs
init|=
name|desc
operator|.
name|getKeyCols
argument_list|()
decl_stmt|;
specifier|final
name|boolean
name|isEmptyKey
init|=
operator|(
name|keysDescs
operator|.
name|size
argument_list|()
operator|==
literal|0
operator|)
decl_stmt|;
if|if
condition|(
operator|!
name|isEmptyKey
condition|)
block|{
name|VectorExpression
index|[]
name|allKeyExpressions
init|=
name|vContext
operator|.
name|getVectorExpressions
argument_list|(
name|keysDescs
argument_list|)
decl_stmt|;
specifier|final
name|int
index|[]
name|reduceSinkKeyColumnMap
init|=
operator|new
name|int
index|[
name|allKeyExpressions
operator|.
name|length
index|]
decl_stmt|;
specifier|final
name|TypeInfo
index|[]
name|reduceSinkKeyTypeInfos
init|=
operator|new
name|TypeInfo
index|[
name|allKeyExpressions
operator|.
name|length
index|]
decl_stmt|;
specifier|final
name|Type
index|[]
name|reduceSinkKeyColumnVectorTypes
init|=
operator|new
name|Type
index|[
name|allKeyExpressions
operator|.
name|length
index|]
decl_stmt|;
specifier|final
name|VectorExpression
index|[]
name|reduceSinkKeyExpressions
decl_stmt|;
comment|// Since a key expression can be a calculation and the key will go into a scratch column,
comment|// we need the mapping and type information.
name|ArrayList
argument_list|<
name|VectorExpression
argument_list|>
name|groupByKeyExpressionsList
init|=
operator|new
name|ArrayList
argument_list|<
name|VectorExpression
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|reduceSinkKeyColumnMap
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|VectorExpression
name|ve
init|=
name|allKeyExpressions
index|[
name|i
index|]
decl_stmt|;
name|reduceSinkKeyColumnMap
index|[
name|i
index|]
operator|=
name|ve
operator|.
name|getOutputColumnNum
argument_list|()
expr_stmt|;
name|reduceSinkKeyTypeInfos
index|[
name|i
index|]
operator|=
name|keysDescs
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|getTypeInfo
argument_list|()
expr_stmt|;
name|reduceSinkKeyColumnVectorTypes
index|[
name|i
index|]
operator|=
name|VectorizationContext
operator|.
name|getColumnVectorTypeFromTypeInfo
argument_list|(
name|reduceSinkKeyTypeInfos
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|IdentityExpression
operator|.
name|isColumnOnly
argument_list|(
name|ve
argument_list|)
condition|)
block|{
name|groupByKeyExpressionsList
operator|.
name|add
argument_list|(
name|ve
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|groupByKeyExpressionsList
operator|.
name|size
argument_list|()
operator|==
literal|0
condition|)
block|{
name|reduceSinkKeyExpressions
operator|=
literal|null
expr_stmt|;
block|}
else|else
block|{
name|reduceSinkKeyExpressions
operator|=
name|groupByKeyExpressionsList
operator|.
name|toArray
argument_list|(
operator|new
name|VectorExpression
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
name|vectorReduceSinkInfo
operator|.
name|setReduceSinkKeyColumnMap
argument_list|(
name|reduceSinkKeyColumnMap
argument_list|)
expr_stmt|;
name|vectorReduceSinkInfo
operator|.
name|setReduceSinkKeyTypeInfos
argument_list|(
name|reduceSinkKeyTypeInfos
argument_list|)
expr_stmt|;
name|vectorReduceSinkInfo
operator|.
name|setReduceSinkKeyColumnVectorTypes
argument_list|(
name|reduceSinkKeyColumnVectorTypes
argument_list|)
expr_stmt|;
name|vectorReduceSinkInfo
operator|.
name|setReduceSinkKeyExpressions
argument_list|(
name|reduceSinkKeyExpressions
argument_list|)
expr_stmt|;
block|}
name|ArrayList
argument_list|<
name|ExprNodeDesc
argument_list|>
name|valueDescs
init|=
name|desc
operator|.
name|getValueCols
argument_list|()
decl_stmt|;
specifier|final
name|boolean
name|isEmptyValue
init|=
operator|(
name|valueDescs
operator|.
name|size
argument_list|()
operator|==
literal|0
operator|)
decl_stmt|;
if|if
condition|(
operator|!
name|isEmptyValue
condition|)
block|{
name|VectorExpression
index|[]
name|allValueExpressions
init|=
name|vContext
operator|.
name|getVectorExpressions
argument_list|(
name|valueDescs
argument_list|)
decl_stmt|;
specifier|final
name|int
index|[]
name|reduceSinkValueColumnMap
init|=
operator|new
name|int
index|[
name|allValueExpressions
operator|.
name|length
index|]
decl_stmt|;
specifier|final
name|TypeInfo
index|[]
name|reduceSinkValueTypeInfos
init|=
operator|new
name|TypeInfo
index|[
name|allValueExpressions
operator|.
name|length
index|]
decl_stmt|;
specifier|final
name|Type
index|[]
name|reduceSinkValueColumnVectorTypes
init|=
operator|new
name|Type
index|[
name|allValueExpressions
operator|.
name|length
index|]
decl_stmt|;
name|VectorExpression
index|[]
name|reduceSinkValueExpressions
decl_stmt|;
name|ArrayList
argument_list|<
name|VectorExpression
argument_list|>
name|reduceSinkValueExpressionsList
init|=
operator|new
name|ArrayList
argument_list|<
name|VectorExpression
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|valueDescs
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|VectorExpression
name|ve
init|=
name|allValueExpressions
index|[
name|i
index|]
decl_stmt|;
name|reduceSinkValueColumnMap
index|[
name|i
index|]
operator|=
name|ve
operator|.
name|getOutputColumnNum
argument_list|()
expr_stmt|;
name|reduceSinkValueTypeInfos
index|[
name|i
index|]
operator|=
name|valueDescs
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|getTypeInfo
argument_list|()
expr_stmt|;
name|reduceSinkValueColumnVectorTypes
index|[
name|i
index|]
operator|=
name|VectorizationContext
operator|.
name|getColumnVectorTypeFromTypeInfo
argument_list|(
name|reduceSinkValueTypeInfos
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|IdentityExpression
operator|.
name|isColumnOnly
argument_list|(
name|ve
argument_list|)
condition|)
block|{
name|reduceSinkValueExpressionsList
operator|.
name|add
argument_list|(
name|ve
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|reduceSinkValueExpressionsList
operator|.
name|size
argument_list|()
operator|==
literal|0
condition|)
block|{
name|reduceSinkValueExpressions
operator|=
literal|null
expr_stmt|;
block|}
else|else
block|{
name|reduceSinkValueExpressions
operator|=
name|reduceSinkValueExpressionsList
operator|.
name|toArray
argument_list|(
operator|new
name|VectorExpression
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
name|vectorReduceSinkInfo
operator|.
name|setReduceSinkValueColumnMap
argument_list|(
name|reduceSinkValueColumnMap
argument_list|)
expr_stmt|;
name|vectorReduceSinkInfo
operator|.
name|setReduceSinkValueTypeInfos
argument_list|(
name|reduceSinkValueTypeInfos
argument_list|)
expr_stmt|;
name|vectorReduceSinkInfo
operator|.
name|setReduceSinkValueColumnVectorTypes
argument_list|(
name|reduceSinkValueColumnVectorTypes
argument_list|)
expr_stmt|;
name|vectorReduceSinkInfo
operator|.
name|setReduceSinkValueExpressions
argument_list|(
name|reduceSinkValueExpressions
argument_list|)
expr_stmt|;
block|}
name|boolean
name|useUniformHash
init|=
name|desc
operator|.
name|getReducerTraits
argument_list|()
operator|.
name|contains
argument_list|(
name|UNIFORM
argument_list|)
decl_stmt|;
name|vectorReduceSinkInfo
operator|.
name|setUseUniformHash
argument_list|(
name|useUniformHash
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|ExprNodeDesc
argument_list|>
name|bucketDescs
init|=
name|desc
operator|.
name|getBucketCols
argument_list|()
decl_stmt|;
specifier|final
name|boolean
name|isEmptyBuckets
init|=
operator|(
name|bucketDescs
operator|==
literal|null
operator|||
name|bucketDescs
operator|.
name|size
argument_list|()
operator|==
literal|0
operator|)
decl_stmt|;
name|List
argument_list|<
name|ExprNodeDesc
argument_list|>
name|partitionDescs
init|=
name|desc
operator|.
name|getPartitionCols
argument_list|()
decl_stmt|;
specifier|final
name|boolean
name|isEmptyPartitions
init|=
operator|(
name|partitionDescs
operator|==
literal|null
operator|||
name|partitionDescs
operator|.
name|size
argument_list|()
operator|==
literal|0
operator|)
decl_stmt|;
if|if
condition|(
name|useUniformHash
operator|||
operator|(
name|isEmptyKey
operator|&&
name|isEmptyBuckets
operator|&&
name|isEmptyPartitions
operator|)
condition|)
block|{
comment|// NOTE: For Uniform Hash or no buckets/partitions, when the key is empty, we will use the VectorReduceSinkEmptyKeyOperator instead.
block|}
else|else
block|{
comment|// Collect bucket and/or partition information for object hashing.
name|int
index|[]
name|reduceSinkBucketColumnMap
init|=
literal|null
decl_stmt|;
name|TypeInfo
index|[]
name|reduceSinkBucketTypeInfos
init|=
literal|null
decl_stmt|;
name|Type
index|[]
name|reduceSinkBucketColumnVectorTypes
init|=
literal|null
decl_stmt|;
name|VectorExpression
index|[]
name|reduceSinkBucketExpressions
init|=
literal|null
decl_stmt|;
if|if
condition|(
operator|!
name|isEmptyBuckets
condition|)
block|{
name|VectorExpression
index|[]
name|allBucketExpressions
init|=
name|vContext
operator|.
name|getVectorExpressions
argument_list|(
name|bucketDescs
argument_list|)
decl_stmt|;
name|reduceSinkBucketColumnMap
operator|=
operator|new
name|int
index|[
name|bucketDescs
operator|.
name|size
argument_list|()
index|]
expr_stmt|;
name|reduceSinkBucketTypeInfos
operator|=
operator|new
name|TypeInfo
index|[
name|bucketDescs
operator|.
name|size
argument_list|()
index|]
expr_stmt|;
name|reduceSinkBucketColumnVectorTypes
operator|=
operator|new
name|Type
index|[
name|bucketDescs
operator|.
name|size
argument_list|()
index|]
expr_stmt|;
name|ArrayList
argument_list|<
name|VectorExpression
argument_list|>
name|reduceSinkBucketExpressionsList
init|=
operator|new
name|ArrayList
argument_list|<
name|VectorExpression
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|bucketDescs
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|VectorExpression
name|ve
init|=
name|allBucketExpressions
index|[
name|i
index|]
decl_stmt|;
name|reduceSinkBucketColumnMap
index|[
name|i
index|]
operator|=
name|ve
operator|.
name|getOutputColumnNum
argument_list|()
expr_stmt|;
name|reduceSinkBucketTypeInfos
index|[
name|i
index|]
operator|=
name|bucketDescs
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|getTypeInfo
argument_list|()
expr_stmt|;
name|reduceSinkBucketColumnVectorTypes
index|[
name|i
index|]
operator|=
name|VectorizationContext
operator|.
name|getColumnVectorTypeFromTypeInfo
argument_list|(
name|reduceSinkBucketTypeInfos
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|IdentityExpression
operator|.
name|isColumnOnly
argument_list|(
name|ve
argument_list|)
condition|)
block|{
name|reduceSinkBucketExpressionsList
operator|.
name|add
argument_list|(
name|ve
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|reduceSinkBucketExpressionsList
operator|.
name|size
argument_list|()
operator|==
literal|0
condition|)
block|{
name|reduceSinkBucketExpressions
operator|=
literal|null
expr_stmt|;
block|}
else|else
block|{
name|reduceSinkBucketExpressions
operator|=
name|reduceSinkBucketExpressionsList
operator|.
name|toArray
argument_list|(
operator|new
name|VectorExpression
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
block|}
name|int
index|[]
name|reduceSinkPartitionColumnMap
init|=
literal|null
decl_stmt|;
name|TypeInfo
index|[]
name|reduceSinkPartitionTypeInfos
init|=
literal|null
decl_stmt|;
name|Type
index|[]
name|reduceSinkPartitionColumnVectorTypes
init|=
literal|null
decl_stmt|;
name|VectorExpression
index|[]
name|reduceSinkPartitionExpressions
init|=
literal|null
decl_stmt|;
if|if
condition|(
operator|!
name|isEmptyPartitions
condition|)
block|{
name|VectorExpression
index|[]
name|allPartitionExpressions
init|=
name|vContext
operator|.
name|getVectorExpressions
argument_list|(
name|partitionDescs
argument_list|)
decl_stmt|;
name|reduceSinkPartitionColumnMap
operator|=
operator|new
name|int
index|[
name|partitionDescs
operator|.
name|size
argument_list|()
index|]
expr_stmt|;
name|reduceSinkPartitionTypeInfos
operator|=
operator|new
name|TypeInfo
index|[
name|partitionDescs
operator|.
name|size
argument_list|()
index|]
expr_stmt|;
name|reduceSinkPartitionColumnVectorTypes
operator|=
operator|new
name|Type
index|[
name|partitionDescs
operator|.
name|size
argument_list|()
index|]
expr_stmt|;
name|ArrayList
argument_list|<
name|VectorExpression
argument_list|>
name|reduceSinkPartitionExpressionsList
init|=
operator|new
name|ArrayList
argument_list|<
name|VectorExpression
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|partitionDescs
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|VectorExpression
name|ve
init|=
name|allPartitionExpressions
index|[
name|i
index|]
decl_stmt|;
name|reduceSinkPartitionColumnMap
index|[
name|i
index|]
operator|=
name|ve
operator|.
name|getOutputColumnNum
argument_list|()
expr_stmt|;
name|reduceSinkPartitionTypeInfos
index|[
name|i
index|]
operator|=
name|partitionDescs
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|getTypeInfo
argument_list|()
expr_stmt|;
name|reduceSinkPartitionColumnVectorTypes
index|[
name|i
index|]
operator|=
name|VectorizationContext
operator|.
name|getColumnVectorTypeFromTypeInfo
argument_list|(
name|reduceSinkPartitionTypeInfos
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|IdentityExpression
operator|.
name|isColumnOnly
argument_list|(
name|ve
argument_list|)
condition|)
block|{
name|reduceSinkPartitionExpressionsList
operator|.
name|add
argument_list|(
name|ve
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|reduceSinkPartitionExpressionsList
operator|.
name|size
argument_list|()
operator|==
literal|0
condition|)
block|{
name|reduceSinkPartitionExpressions
operator|=
literal|null
expr_stmt|;
block|}
else|else
block|{
name|reduceSinkPartitionExpressions
operator|=
name|reduceSinkPartitionExpressionsList
operator|.
name|toArray
argument_list|(
operator|new
name|VectorExpression
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
block|}
name|vectorReduceSinkInfo
operator|.
name|setReduceSinkBucketColumnMap
argument_list|(
name|reduceSinkBucketColumnMap
argument_list|)
expr_stmt|;
name|vectorReduceSinkInfo
operator|.
name|setReduceSinkBucketTypeInfos
argument_list|(
name|reduceSinkBucketTypeInfos
argument_list|)
expr_stmt|;
name|vectorReduceSinkInfo
operator|.
name|setReduceSinkBucketColumnVectorTypes
argument_list|(
name|reduceSinkBucketColumnVectorTypes
argument_list|)
expr_stmt|;
name|vectorReduceSinkInfo
operator|.
name|setReduceSinkBucketExpressions
argument_list|(
name|reduceSinkBucketExpressions
argument_list|)
expr_stmt|;
name|vectorReduceSinkInfo
operator|.
name|setReduceSinkPartitionColumnMap
argument_list|(
name|reduceSinkPartitionColumnMap
argument_list|)
expr_stmt|;
name|vectorReduceSinkInfo
operator|.
name|setReduceSinkPartitionTypeInfos
argument_list|(
name|reduceSinkPartitionTypeInfos
argument_list|)
expr_stmt|;
name|vectorReduceSinkInfo
operator|.
name|setReduceSinkPartitionColumnVectorTypes
argument_list|(
name|reduceSinkPartitionColumnVectorTypes
argument_list|)
expr_stmt|;
name|vectorReduceSinkInfo
operator|.
name|setReduceSinkPartitionExpressions
argument_list|(
name|reduceSinkPartitionExpressions
argument_list|)
expr_stmt|;
block|}
comment|// Remember the condition variables for EXPLAIN regardless.
name|vectorDesc
operator|.
name|setVectorReduceSinkInfo
argument_list|(
name|vectorReduceSinkInfo
argument_list|)
expr_stmt|;
name|vectorDesc
operator|.
name|setIsVectorizationReduceSinkNativeEnabled
argument_list|(
name|isVectorizationReduceSinkNativeEnabled
argument_list|)
expr_stmt|;
name|vectorDesc
operator|.
name|setEngine
argument_list|(
name|engine
argument_list|)
expr_stmt|;
name|vectorDesc
operator|.
name|setIsEmptyKey
argument_list|(
name|isEmptyKey
argument_list|)
expr_stmt|;
name|vectorDesc
operator|.
name|setIsEmptyValue
argument_list|(
name|isEmptyValue
argument_list|)
expr_stmt|;
name|vectorDesc
operator|.
name|setIsEmptyBuckets
argument_list|(
name|isEmptyBuckets
argument_list|)
expr_stmt|;
name|vectorDesc
operator|.
name|setIsEmptyPartitions
argument_list|(
name|isEmptyPartitions
argument_list|)
expr_stmt|;
name|vectorDesc
operator|.
name|setHasPTFTopN
argument_list|(
name|hasPTFTopN
argument_list|)
expr_stmt|;
name|vectorDesc
operator|.
name|setHasDistinctColumns
argument_list|(
name|hasDistinctColumns
argument_list|)
expr_stmt|;
name|vectorDesc
operator|.
name|setIsKeyBinarySortable
argument_list|(
name|isKeyBinarySortable
argument_list|)
expr_stmt|;
name|vectorDesc
operator|.
name|setIsValueLazyBinary
argument_list|(
name|isValueLazyBinary
argument_list|)
expr_stmt|;
comment|// This indicates we logged an inconsistency (from our point-of-view) and will not make this
comment|// operator native...
name|vectorDesc
operator|.
name|setIsUnexpectedCondition
argument_list|(
name|isUnexpectedCondition
argument_list|)
expr_stmt|;
comment|// Many restrictions.
if|if
condition|(
operator|!
name|isVectorizationReduceSinkNativeEnabled
operator|||
operator|!
name|isTezOrSpark
operator|||
name|hasPTFTopN
operator|||
name|hasDistinctColumns
operator|||
operator|!
name|isKeyBinarySortable
operator|||
operator|!
name|isValueLazyBinary
operator|||
name|isUnexpectedCondition
condition|)
block|{
return|return
literal|false
return|;
block|}
return|return
literal|true
return|;
block|}
specifier|private
name|boolean
name|usesVectorUDFAdaptor
parameter_list|(
name|VectorExpression
name|vecExpr
parameter_list|)
block|{
if|if
condition|(
name|vecExpr
operator|==
literal|null
condition|)
block|{
return|return
literal|false
return|;
block|}
if|if
condition|(
name|vecExpr
operator|instanceof
name|VectorUDFAdaptor
condition|)
block|{
return|return
literal|true
return|;
block|}
if|if
condition|(
name|usesVectorUDFAdaptor
argument_list|(
name|vecExpr
operator|.
name|getChildExpressions
argument_list|()
argument_list|)
condition|)
block|{
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
specifier|private
name|boolean
name|usesVectorUDFAdaptor
parameter_list|(
name|VectorExpression
index|[]
name|vecExprs
parameter_list|)
block|{
if|if
condition|(
name|vecExprs
operator|==
literal|null
condition|)
block|{
return|return
literal|false
return|;
block|}
for|for
control|(
name|VectorExpression
name|vecExpr
range|:
name|vecExprs
control|)
block|{
if|if
condition|(
name|usesVectorUDFAdaptor
argument_list|(
name|vecExpr
argument_list|)
condition|)
block|{
return|return
literal|true
return|;
block|}
block|}
return|return
literal|false
return|;
block|}
specifier|public
specifier|static
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
name|vectorizeFilterOperator
parameter_list|(
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
name|filterOp
parameter_list|,
name|VectorizationContext
name|vContext
parameter_list|,
name|VectorFilterDesc
name|vectorFilterDesc
parameter_list|)
throws|throws
name|HiveException
block|{
name|FilterDesc
name|filterDesc
init|=
operator|(
name|FilterDesc
operator|)
name|filterOp
operator|.
name|getConf
argument_list|()
decl_stmt|;
name|ExprNodeDesc
name|predicateExpr
init|=
name|filterDesc
operator|.
name|getPredicate
argument_list|()
decl_stmt|;
name|VectorExpression
name|vectorPredicateExpr
init|=
name|vContext
operator|.
name|getVectorExpression
argument_list|(
name|predicateExpr
argument_list|,
name|VectorExpressionDescriptor
operator|.
name|Mode
operator|.
name|FILTER
argument_list|)
decl_stmt|;
name|vectorFilterDesc
operator|.
name|setPredicateExpression
argument_list|(
name|vectorPredicateExpr
argument_list|)
expr_stmt|;
return|return
name|OperatorFactory
operator|.
name|getVectorOperator
argument_list|(
name|filterOp
operator|.
name|getCompilationOpContext
argument_list|()
argument_list|,
name|filterDesc
argument_list|,
name|vContext
argument_list|,
name|vectorFilterDesc
argument_list|)
return|;
block|}
specifier|private
specifier|static
name|Class
argument_list|<
name|?
extends|extends
name|VectorAggregateExpression
argument_list|>
name|findVecAggrClass
parameter_list|(
name|Class
argument_list|<
name|?
extends|extends
name|VectorAggregateExpression
argument_list|>
index|[]
name|vecAggrClasses
parameter_list|,
name|String
name|aggregateName
parameter_list|,
name|ColumnVector
operator|.
name|Type
name|inputColVectorType
parameter_list|,
name|ColumnVector
operator|.
name|Type
name|outputColumnVecType
parameter_list|,
name|GenericUDAFEvaluator
operator|.
name|Mode
name|udafEvaluatorMode
parameter_list|)
throws|throws
name|HiveException
block|{
for|for
control|(
name|Class
argument_list|<
name|?
extends|extends
name|VectorAggregateExpression
argument_list|>
name|vecAggrClass
range|:
name|vecAggrClasses
control|)
block|{
name|VectorAggregateExpression
name|vecAggrExprCheck
decl_stmt|;
try|try
block|{
name|vecAggrExprCheck
operator|=
name|vecAggrClass
operator|.
name|newInstance
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|HiveException
argument_list|(
name|vecAggrClass
operator|.
name|getSimpleName
argument_list|()
operator|+
literal|"() failed to initialize"
argument_list|,
name|e
argument_list|)
throw|;
block|}
if|if
condition|(
name|vecAggrExprCheck
operator|.
name|matches
argument_list|(
name|aggregateName
argument_list|,
name|inputColVectorType
argument_list|,
name|outputColumnVecType
argument_list|,
name|udafEvaluatorMode
argument_list|)
condition|)
block|{
return|return
name|vecAggrClass
return|;
block|}
block|}
return|return
literal|null
return|;
block|}
specifier|private
specifier|static
name|ImmutablePair
argument_list|<
name|VectorAggregationDesc
argument_list|,
name|String
argument_list|>
name|getVectorAggregationDesc
parameter_list|(
name|AggregationDesc
name|aggrDesc
parameter_list|,
name|VectorizationContext
name|vContext
parameter_list|)
throws|throws
name|HiveException
block|{
name|String
name|aggregateName
init|=
name|aggrDesc
operator|.
name|getGenericUDAFName
argument_list|()
decl_stmt|;
name|ArrayList
argument_list|<
name|ExprNodeDesc
argument_list|>
name|parameterList
init|=
name|aggrDesc
operator|.
name|getParameters
argument_list|()
decl_stmt|;
specifier|final
name|int
name|parameterCount
init|=
name|parameterList
operator|.
name|size
argument_list|()
decl_stmt|;
specifier|final
name|GenericUDAFEvaluator
operator|.
name|Mode
name|udafEvaluatorMode
init|=
name|aggrDesc
operator|.
name|getMode
argument_list|()
decl_stmt|;
comment|/*      * Look at evaluator to get output type info.      */
name|GenericUDAFEvaluator
name|evaluator
init|=
name|aggrDesc
operator|.
name|getGenericUDAFEvaluator
argument_list|()
decl_stmt|;
name|ArrayList
argument_list|<
name|ExprNodeDesc
argument_list|>
name|parameters
init|=
name|aggrDesc
operator|.
name|getParameters
argument_list|()
decl_stmt|;
name|ObjectInspector
index|[]
name|parameterObjectInspectors
init|=
operator|new
name|ObjectInspector
index|[
name|parameterCount
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|parameterCount
condition|;
name|i
operator|++
control|)
block|{
name|TypeInfo
name|typeInfo
init|=
name|parameters
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|getTypeInfo
argument_list|()
decl_stmt|;
name|parameterObjectInspectors
index|[
name|i
index|]
operator|=
name|TypeInfoUtils
operator|.
name|getStandardWritableObjectInspectorFromTypeInfo
argument_list|(
name|typeInfo
argument_list|)
expr_stmt|;
block|}
comment|// The only way to get the return object inspector (and its return type) is to
comment|// initialize it...
name|ObjectInspector
name|returnOI
init|=
name|evaluator
operator|.
name|init
argument_list|(
name|aggrDesc
operator|.
name|getMode
argument_list|()
argument_list|,
name|parameterObjectInspectors
argument_list|)
decl_stmt|;
name|VectorizedUDAFs
name|annotation
init|=
name|AnnotationUtils
operator|.
name|getAnnotation
argument_list|(
name|evaluator
operator|.
name|getClass
argument_list|()
argument_list|,
name|VectorizedUDAFs
operator|.
name|class
argument_list|)
decl_stmt|;
if|if
condition|(
name|annotation
operator|==
literal|null
condition|)
block|{
name|String
name|issue
init|=
literal|"Evaluator "
operator|+
name|evaluator
operator|.
name|getClass
argument_list|()
operator|.
name|getSimpleName
argument_list|()
operator|+
literal|" does not have a "
operator|+
literal|"vectorized UDAF annotation (aggregation: \""
operator|+
name|aggregateName
operator|+
literal|"\"). "
operator|+
literal|"Vectorization not supported"
decl_stmt|;
return|return
operator|new
name|ImmutablePair
argument_list|<
name|VectorAggregationDesc
argument_list|,
name|String
argument_list|>
argument_list|(
literal|null
argument_list|,
name|issue
argument_list|)
return|;
block|}
specifier|final
name|Class
argument_list|<
name|?
extends|extends
name|VectorAggregateExpression
argument_list|>
index|[]
name|vecAggrClasses
init|=
name|annotation
operator|.
name|value
argument_list|()
decl_stmt|;
specifier|final
name|TypeInfo
name|outputTypeInfo
init|=
name|TypeInfoUtils
operator|.
name|getTypeInfoFromTypeString
argument_list|(
name|returnOI
operator|.
name|getTypeName
argument_list|()
argument_list|)
decl_stmt|;
comment|// Not final since it may change later due to DECIMAL_64.
name|ColumnVector
operator|.
name|Type
name|outputColVectorType
init|=
name|VectorizationContext
operator|.
name|getColumnVectorTypeFromTypeInfo
argument_list|(
name|outputTypeInfo
argument_list|)
decl_stmt|;
comment|/*      * Determine input type info.      */
specifier|final
name|TypeInfo
name|inputTypeInfo
decl_stmt|;
comment|// Not final since it may change later due to DECIMAL_64.
name|VectorExpression
name|inputExpression
decl_stmt|;
name|ColumnVector
operator|.
name|Type
name|inputColVectorType
decl_stmt|;
if|if
condition|(
name|parameterCount
operator|==
literal|0
condition|)
block|{
comment|// COUNT(*)
name|inputTypeInfo
operator|=
literal|null
expr_stmt|;
name|inputColVectorType
operator|=
literal|null
expr_stmt|;
name|inputExpression
operator|=
literal|null
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|parameterCount
operator|==
literal|1
condition|)
block|{
name|ExprNodeDesc
name|exprNodeDesc
init|=
name|parameterList
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|inputTypeInfo
operator|=
name|exprNodeDesc
operator|.
name|getTypeInfo
argument_list|()
expr_stmt|;
if|if
condition|(
name|inputTypeInfo
operator|==
literal|null
condition|)
block|{
name|String
name|issue
init|=
literal|"Aggregations with null parameter type not supported "
operator|+
name|aggregateName
operator|+
literal|"("
operator|+
name|parameterList
operator|.
name|toString
argument_list|()
operator|+
literal|")"
decl_stmt|;
return|return
operator|new
name|ImmutablePair
argument_list|<
name|VectorAggregationDesc
argument_list|,
name|String
argument_list|>
argument_list|(
literal|null
argument_list|,
name|issue
argument_list|)
return|;
block|}
comment|/*        * Determine an *initial* input vector expression.        *        * Note: we may have to convert it later from DECIMAL_64 to regular decimal.        */
name|inputExpression
operator|=
name|vContext
operator|.
name|getVectorExpression
argument_list|(
name|exprNodeDesc
argument_list|,
name|VectorExpressionDescriptor
operator|.
name|Mode
operator|.
name|PROJECTION
argument_list|)
expr_stmt|;
if|if
condition|(
name|inputExpression
operator|==
literal|null
condition|)
block|{
name|String
name|issue
init|=
literal|"Parameter expression "
operator|+
name|exprNodeDesc
operator|.
name|toString
argument_list|()
operator|+
literal|" not supported "
operator|+
name|aggregateName
operator|+
literal|"("
operator|+
name|parameterList
operator|.
name|toString
argument_list|()
operator|+
literal|")"
decl_stmt|;
return|return
operator|new
name|ImmutablePair
argument_list|<
name|VectorAggregationDesc
argument_list|,
name|String
argument_list|>
argument_list|(
literal|null
argument_list|,
name|issue
argument_list|)
return|;
block|}
if|if
condition|(
name|inputExpression
operator|.
name|getOutputTypeInfo
argument_list|()
operator|==
literal|null
condition|)
block|{
name|String
name|issue
init|=
literal|"Parameter expression "
operator|+
name|exprNodeDesc
operator|.
name|toString
argument_list|()
operator|+
literal|" with null type not supported "
operator|+
name|aggregateName
operator|+
literal|"("
operator|+
name|parameterList
operator|.
name|toString
argument_list|()
operator|+
literal|")"
decl_stmt|;
return|return
operator|new
name|ImmutablePair
argument_list|<
name|VectorAggregationDesc
argument_list|,
name|String
argument_list|>
argument_list|(
literal|null
argument_list|,
name|issue
argument_list|)
return|;
block|}
name|inputColVectorType
operator|=
name|inputExpression
operator|.
name|getOutputColumnVectorType
argument_list|()
expr_stmt|;
block|}
else|else
block|{
comment|// No multi-parameter aggregations supported.
name|String
name|issue
init|=
literal|"Aggregations with> 1 parameter are not supported "
operator|+
name|aggregateName
operator|+
literal|"("
operator|+
name|parameterList
operator|.
name|toString
argument_list|()
operator|+
literal|")"
decl_stmt|;
return|return
operator|new
name|ImmutablePair
argument_list|<
name|VectorAggregationDesc
argument_list|,
name|String
argument_list|>
argument_list|(
literal|null
argument_list|,
name|issue
argument_list|)
return|;
block|}
comment|/*      * When we have DECIMAL_64 as the input parameter then we have to see if there is a special      * vector UDAF for it.  If not we will need to convert the input parameter.      */
if|if
condition|(
name|inputTypeInfo
operator|!=
literal|null
operator|&&
name|inputColVectorType
operator|==
name|ColumnVector
operator|.
name|Type
operator|.
name|DECIMAL_64
condition|)
block|{
if|if
condition|(
name|outputColVectorType
operator|==
name|ColumnVector
operator|.
name|Type
operator|.
name|DECIMAL
condition|)
block|{
name|DecimalTypeInfo
name|outputDecimalTypeInfo
init|=
operator|(
name|DecimalTypeInfo
operator|)
name|outputTypeInfo
decl_stmt|;
if|if
condition|(
name|HiveDecimalWritable
operator|.
name|isPrecisionDecimal64
argument_list|(
name|outputDecimalTypeInfo
operator|.
name|getPrecision
argument_list|()
argument_list|)
condition|)
block|{
comment|// Try with DECIMAL_64 input and DECIMAL_64 output.
specifier|final
name|Class
argument_list|<
name|?
extends|extends
name|VectorAggregateExpression
argument_list|>
name|vecAggrClass
init|=
name|findVecAggrClass
argument_list|(
name|vecAggrClasses
argument_list|,
name|aggregateName
argument_list|,
name|inputColVectorType
argument_list|,
name|ColumnVector
operator|.
name|Type
operator|.
name|DECIMAL_64
argument_list|,
name|udafEvaluatorMode
argument_list|)
decl_stmt|;
if|if
condition|(
name|vecAggrClass
operator|!=
literal|null
condition|)
block|{
specifier|final
name|VectorAggregationDesc
name|vecAggrDesc
init|=
operator|new
name|VectorAggregationDesc
argument_list|(
name|aggrDesc
argument_list|,
name|evaluator
argument_list|,
name|inputTypeInfo
argument_list|,
name|inputColVectorType
argument_list|,
name|inputExpression
argument_list|,
name|outputTypeInfo
argument_list|,
name|ColumnVector
operator|.
name|Type
operator|.
name|DECIMAL_64
argument_list|,
name|vecAggrClass
argument_list|)
decl_stmt|;
return|return
operator|new
name|ImmutablePair
argument_list|<
name|VectorAggregationDesc
argument_list|,
name|String
argument_list|>
argument_list|(
name|vecAggrDesc
argument_list|,
literal|null
argument_list|)
return|;
block|}
block|}
comment|// Try with regular DECIMAL output type.
specifier|final
name|Class
argument_list|<
name|?
extends|extends
name|VectorAggregateExpression
argument_list|>
name|vecAggrClass
init|=
name|findVecAggrClass
argument_list|(
name|vecAggrClasses
argument_list|,
name|aggregateName
argument_list|,
name|inputColVectorType
argument_list|,
name|outputColVectorType
argument_list|,
name|udafEvaluatorMode
argument_list|)
decl_stmt|;
if|if
condition|(
name|vecAggrClass
operator|!=
literal|null
condition|)
block|{
specifier|final
name|VectorAggregationDesc
name|vecAggrDesc
init|=
operator|new
name|VectorAggregationDesc
argument_list|(
name|aggrDesc
argument_list|,
name|evaluator
argument_list|,
name|inputTypeInfo
argument_list|,
name|inputColVectorType
argument_list|,
name|inputExpression
argument_list|,
name|outputTypeInfo
argument_list|,
name|outputColVectorType
argument_list|,
name|vecAggrClass
argument_list|)
decl_stmt|;
return|return
operator|new
name|ImmutablePair
argument_list|<
name|VectorAggregationDesc
argument_list|,
name|String
argument_list|>
argument_list|(
name|vecAggrDesc
argument_list|,
literal|null
argument_list|)
return|;
block|}
comment|// No support for DECIMAL_64 input.  We must convert.
name|inputExpression
operator|=
name|vContext
operator|.
name|wrapWithDecimal64ToDecimalConversion
argument_list|(
name|inputExpression
argument_list|)
expr_stmt|;
name|inputColVectorType
operator|=
name|ColumnVector
operator|.
name|Type
operator|.
name|DECIMAL
expr_stmt|;
comment|// Fall through...
block|}
else|else
block|{
comment|// Try with with DECIMAL_64 input and desired output type.
specifier|final
name|Class
argument_list|<
name|?
extends|extends
name|VectorAggregateExpression
argument_list|>
name|vecAggrClass
init|=
name|findVecAggrClass
argument_list|(
name|vecAggrClasses
argument_list|,
name|aggregateName
argument_list|,
name|inputColVectorType
argument_list|,
name|outputColVectorType
argument_list|,
name|udafEvaluatorMode
argument_list|)
decl_stmt|;
if|if
condition|(
name|vecAggrClass
operator|!=
literal|null
condition|)
block|{
specifier|final
name|VectorAggregationDesc
name|vecAggrDesc
init|=
operator|new
name|VectorAggregationDesc
argument_list|(
name|aggrDesc
argument_list|,
name|evaluator
argument_list|,
name|inputTypeInfo
argument_list|,
name|inputColVectorType
argument_list|,
name|inputExpression
argument_list|,
name|outputTypeInfo
argument_list|,
name|outputColVectorType
argument_list|,
name|vecAggrClass
argument_list|)
decl_stmt|;
return|return
operator|new
name|ImmutablePair
argument_list|<
name|VectorAggregationDesc
argument_list|,
name|String
argument_list|>
argument_list|(
name|vecAggrDesc
argument_list|,
literal|null
argument_list|)
return|;
block|}
comment|// No support for DECIMAL_64 input.  We must convert.
name|inputExpression
operator|=
name|vContext
operator|.
name|wrapWithDecimal64ToDecimalConversion
argument_list|(
name|inputExpression
argument_list|)
expr_stmt|;
name|inputColVectorType
operator|=
name|ColumnVector
operator|.
name|Type
operator|.
name|DECIMAL
expr_stmt|;
comment|// Fall through...
block|}
block|}
comment|/*      * Look for normal match.      */
name|Class
argument_list|<
name|?
extends|extends
name|VectorAggregateExpression
argument_list|>
name|vecAggrClass
init|=
name|findVecAggrClass
argument_list|(
name|vecAggrClasses
argument_list|,
name|aggregateName
argument_list|,
name|inputColVectorType
argument_list|,
name|outputColVectorType
argument_list|,
name|udafEvaluatorMode
argument_list|)
decl_stmt|;
if|if
condition|(
name|vecAggrClass
operator|!=
literal|null
condition|)
block|{
specifier|final
name|VectorAggregationDesc
name|vecAggrDesc
init|=
operator|new
name|VectorAggregationDesc
argument_list|(
name|aggrDesc
argument_list|,
name|evaluator
argument_list|,
name|inputTypeInfo
argument_list|,
name|inputColVectorType
argument_list|,
name|inputExpression
argument_list|,
name|outputTypeInfo
argument_list|,
name|outputColVectorType
argument_list|,
name|vecAggrClass
argument_list|)
decl_stmt|;
return|return
operator|new
name|ImmutablePair
argument_list|<
name|VectorAggregationDesc
argument_list|,
name|String
argument_list|>
argument_list|(
name|vecAggrDesc
argument_list|,
literal|null
argument_list|)
return|;
block|}
comment|// No match?
name|String
name|issue
init|=
literal|"Vector aggregation : \""
operator|+
name|aggregateName
operator|+
literal|"\" "
operator|+
literal|"for input type: "
operator|+
operator|(
name|inputColVectorType
operator|==
literal|null
condition|?
literal|"any"
else|:
literal|"\""
operator|+
name|inputColVectorType
operator|)
operator|+
literal|"\" "
operator|+
literal|"and output type: \""
operator|+
name|outputColVectorType
operator|+
literal|"\" "
operator|+
literal|"and mode: "
operator|+
name|udafEvaluatorMode
operator|+
literal|" not supported for "
operator|+
literal|"evaluator "
operator|+
name|evaluator
operator|.
name|getClass
argument_list|()
operator|.
name|getSimpleName
argument_list|()
decl_stmt|;
return|return
operator|new
name|ImmutablePair
argument_list|<
name|VectorAggregationDesc
argument_list|,
name|String
argument_list|>
argument_list|(
literal|null
argument_list|,
name|issue
argument_list|)
return|;
block|}
specifier|public
specifier|static
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
name|vectorizeGroupByOperator
parameter_list|(
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
name|groupByOp
parameter_list|,
name|VectorizationContext
name|vContext
parameter_list|,
name|VectorGroupByDesc
name|vectorGroupByDesc
parameter_list|)
throws|throws
name|HiveException
block|{
name|ImmutablePair
argument_list|<
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
argument_list|,
name|String
argument_list|>
name|pair
init|=
name|doVectorizeGroupByOperator
argument_list|(
name|groupByOp
argument_list|,
name|vContext
argument_list|,
name|vectorGroupByDesc
argument_list|)
decl_stmt|;
return|return
name|pair
operator|.
name|left
return|;
block|}
comment|/*    * NOTE: The VectorGroupByDesc has already been allocated and will be updated here.    */
specifier|private
specifier|static
name|ImmutablePair
argument_list|<
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
argument_list|,
name|String
argument_list|>
name|doVectorizeGroupByOperator
parameter_list|(
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
name|groupByOp
parameter_list|,
name|VectorizationContext
name|vContext
parameter_list|,
name|VectorGroupByDesc
name|vectorGroupByDesc
parameter_list|)
throws|throws
name|HiveException
block|{
name|GroupByDesc
name|groupByDesc
init|=
operator|(
name|GroupByDesc
operator|)
name|groupByOp
operator|.
name|getConf
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|ExprNodeDesc
argument_list|>
name|keysDesc
init|=
name|groupByDesc
operator|.
name|getKeys
argument_list|()
decl_stmt|;
comment|// For now, we don't support group by on DECIMAL_64 keys.
name|VectorExpression
index|[]
name|vecKeyExpressions
init|=
name|vContext
operator|.
name|getVectorExpressionsUpConvertDecimal64
argument_list|(
name|keysDesc
argument_list|)
decl_stmt|;
name|ArrayList
argument_list|<
name|AggregationDesc
argument_list|>
name|aggrDesc
init|=
name|groupByDesc
operator|.
name|getAggregators
argument_list|()
decl_stmt|;
specifier|final
name|int
name|size
init|=
name|aggrDesc
operator|.
name|size
argument_list|()
decl_stmt|;
name|VectorAggregationDesc
index|[]
name|vecAggrDescs
init|=
operator|new
name|VectorAggregationDesc
index|[
name|size
index|]
decl_stmt|;
name|int
index|[]
name|projectedOutputColumns
init|=
operator|new
name|int
index|[
name|size
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|size
condition|;
operator|++
name|i
control|)
block|{
name|AggregationDesc
name|aggDesc
init|=
name|aggrDesc
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|ImmutablePair
argument_list|<
name|VectorAggregationDesc
argument_list|,
name|String
argument_list|>
name|pair
init|=
name|getVectorAggregationDesc
argument_list|(
name|aggDesc
argument_list|,
name|vContext
argument_list|)
decl_stmt|;
if|if
condition|(
name|pair
operator|.
name|left
operator|==
literal|null
condition|)
block|{
return|return
operator|new
name|ImmutablePair
argument_list|<
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
argument_list|,
name|String
argument_list|>
argument_list|(
literal|null
argument_list|,
name|pair
operator|.
name|right
argument_list|)
return|;
block|}
name|vecAggrDescs
index|[
name|i
index|]
operator|=
name|pair
operator|.
name|left
expr_stmt|;
comment|// GroupBy generates a new vectorized row batch...
name|projectedOutputColumns
index|[
name|i
index|]
operator|=
name|i
expr_stmt|;
block|}
name|vectorGroupByDesc
operator|.
name|setKeyExpressions
argument_list|(
name|vecKeyExpressions
argument_list|)
expr_stmt|;
name|vectorGroupByDesc
operator|.
name|setVecAggrDescs
argument_list|(
name|vecAggrDescs
argument_list|)
expr_stmt|;
name|vectorGroupByDesc
operator|.
name|setProjectedOutputColumns
argument_list|(
name|projectedOutputColumns
argument_list|)
expr_stmt|;
name|Operator
argument_list|<
name|GroupByDesc
argument_list|>
name|vectorOp
init|=
name|OperatorFactory
operator|.
name|getVectorOperator
argument_list|(
name|groupByOp
operator|.
name|getCompilationOpContext
argument_list|()
argument_list|,
name|groupByDesc
argument_list|,
name|vContext
argument_list|,
name|vectorGroupByDesc
argument_list|)
decl_stmt|;
return|return
operator|new
name|ImmutablePair
argument_list|<
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
argument_list|,
name|String
argument_list|>
argument_list|(
name|vectorOp
argument_list|,
literal|null
argument_list|)
return|;
block|}
specifier|static
name|int
name|fake
decl_stmt|;
specifier|public
specifier|static
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
name|vectorizeSelectOperator
parameter_list|(
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
name|selectOp
parameter_list|,
name|VectorizationContext
name|vContext
parameter_list|,
name|VectorSelectDesc
name|vectorSelectDesc
parameter_list|)
throws|throws
name|HiveException
block|{
name|SelectDesc
name|selectDesc
init|=
operator|(
name|SelectDesc
operator|)
name|selectOp
operator|.
name|getConf
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|ExprNodeDesc
argument_list|>
name|colList
init|=
name|selectDesc
operator|.
name|getColList
argument_list|()
decl_stmt|;
name|int
name|index
init|=
literal|0
decl_stmt|;
specifier|final
name|int
name|size
init|=
name|colList
operator|.
name|size
argument_list|()
decl_stmt|;
name|VectorExpression
index|[]
name|vectorSelectExprs
init|=
operator|new
name|VectorExpression
index|[
name|size
index|]
decl_stmt|;
name|int
index|[]
name|projectedOutputColumns
init|=
operator|new
name|int
index|[
name|size
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|size
condition|;
name|i
operator|++
control|)
block|{
name|ExprNodeDesc
name|expr
init|=
name|colList
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|VectorExpression
name|ve
init|=
name|vContext
operator|.
name|getVectorExpression
argument_list|(
name|expr
argument_list|)
decl_stmt|;
name|projectedOutputColumns
index|[
name|i
index|]
operator|=
name|ve
operator|.
name|getOutputColumnNum
argument_list|()
expr_stmt|;
if|if
condition|(
name|ve
operator|instanceof
name|IdentityExpression
condition|)
block|{
comment|// Suppress useless evaluation.
continue|continue;
block|}
name|vectorSelectExprs
index|[
name|index
operator|++
index|]
operator|=
name|ve
expr_stmt|;
block|}
if|if
condition|(
name|index
operator|<
name|size
condition|)
block|{
name|vectorSelectExprs
operator|=
name|Arrays
operator|.
name|copyOf
argument_list|(
name|vectorSelectExprs
argument_list|,
name|index
argument_list|)
expr_stmt|;
block|}
name|vectorSelectDesc
operator|.
name|setSelectExpressions
argument_list|(
name|vectorSelectExprs
argument_list|)
expr_stmt|;
name|vectorSelectDesc
operator|.
name|setProjectedOutputColumns
argument_list|(
name|projectedOutputColumns
argument_list|)
expr_stmt|;
return|return
name|OperatorFactory
operator|.
name|getVectorOperator
argument_list|(
name|selectOp
operator|.
name|getCompilationOpContext
argument_list|()
argument_list|,
name|selectDesc
argument_list|,
name|vContext
argument_list|,
name|vectorSelectDesc
argument_list|)
return|;
block|}
specifier|private
specifier|static
name|void
name|fillInPTFEvaluators
parameter_list|(
name|List
argument_list|<
name|WindowFunctionDef
argument_list|>
name|windowsFunctions
parameter_list|,
name|String
index|[]
name|evaluatorFunctionNames
parameter_list|,
name|WindowFrameDef
index|[]
name|evaluatorWindowFrameDefs
parameter_list|,
name|List
argument_list|<
name|ExprNodeDesc
argument_list|>
index|[]
name|evaluatorInputExprNodeDescLists
parameter_list|)
throws|throws
name|HiveException
block|{
specifier|final
name|int
name|functionCount
init|=
name|windowsFunctions
operator|.
name|size
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|functionCount
condition|;
name|i
operator|++
control|)
block|{
name|WindowFunctionDef
name|winFunc
init|=
name|windowsFunctions
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|evaluatorFunctionNames
index|[
name|i
index|]
operator|=
name|winFunc
operator|.
name|getName
argument_list|()
expr_stmt|;
name|evaluatorWindowFrameDefs
index|[
name|i
index|]
operator|=
name|winFunc
operator|.
name|getWindowFrame
argument_list|()
expr_stmt|;
name|List
argument_list|<
name|PTFExpressionDef
argument_list|>
name|args
init|=
name|winFunc
operator|.
name|getArgs
argument_list|()
decl_stmt|;
if|if
condition|(
name|args
operator|!=
literal|null
condition|)
block|{
name|List
argument_list|<
name|ExprNodeDesc
argument_list|>
name|exprNodeDescList
init|=
operator|new
name|ArrayList
argument_list|<
name|ExprNodeDesc
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|PTFExpressionDef
name|arg
range|:
name|args
control|)
block|{
name|exprNodeDescList
operator|.
name|add
argument_list|(
name|arg
operator|.
name|getExprNode
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|evaluatorInputExprNodeDescLists
index|[
name|i
index|]
operator|=
name|exprNodeDescList
expr_stmt|;
block|}
block|}
block|}
specifier|private
specifier|static
name|ExprNodeDesc
index|[]
name|getPartitionExprNodeDescs
parameter_list|(
name|List
argument_list|<
name|PTFExpressionDef
argument_list|>
name|partitionExpressions
parameter_list|)
block|{
specifier|final
name|int
name|size
init|=
name|partitionExpressions
operator|.
name|size
argument_list|()
decl_stmt|;
name|ExprNodeDesc
index|[]
name|exprNodeDescs
init|=
operator|new
name|ExprNodeDesc
index|[
name|size
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|size
condition|;
name|i
operator|++
control|)
block|{
name|exprNodeDescs
index|[
name|i
index|]
operator|=
name|partitionExpressions
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|getExprNode
argument_list|()
expr_stmt|;
block|}
return|return
name|exprNodeDescs
return|;
block|}
specifier|private
specifier|static
name|ExprNodeDesc
index|[]
name|getOrderExprNodeDescs
parameter_list|(
name|List
argument_list|<
name|OrderExpressionDef
argument_list|>
name|orderExpressions
parameter_list|)
block|{
specifier|final
name|int
name|size
init|=
name|orderExpressions
operator|.
name|size
argument_list|()
decl_stmt|;
name|ExprNodeDesc
index|[]
name|exprNodeDescs
init|=
operator|new
name|ExprNodeDesc
index|[
name|size
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|size
condition|;
name|i
operator|++
control|)
block|{
name|exprNodeDescs
index|[
name|i
index|]
operator|=
name|orderExpressions
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|getExprNode
argument_list|()
expr_stmt|;
block|}
return|return
name|exprNodeDescs
return|;
block|}
comment|/*    * Update the VectorPTFDesc with data that is used during validation and that doesn't rely on    * VectorizationContext to lookup column names, etc.    */
specifier|private
specifier|static
name|void
name|createVectorPTFDesc
parameter_list|(
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
name|ptfOp
parameter_list|,
name|PTFDesc
name|ptfDesc
parameter_list|,
name|VectorizationContext
name|vContext
parameter_list|,
name|VectorPTFDesc
name|vectorPTFDesc
parameter_list|,
name|int
name|vectorizedPTFMaxMemoryBufferingBatchCount
parameter_list|)
throws|throws
name|HiveException
block|{
name|PartitionedTableFunctionDef
name|funcDef
init|=
name|ptfDesc
operator|.
name|getFuncDef
argument_list|()
decl_stmt|;
name|WindowTableFunctionDef
name|windowTableFunctionDef
init|=
operator|(
name|WindowTableFunctionDef
operator|)
name|funcDef
decl_stmt|;
name|List
argument_list|<
name|WindowFunctionDef
argument_list|>
name|windowsFunctions
init|=
name|windowTableFunctionDef
operator|.
name|getWindowFunctions
argument_list|()
decl_stmt|;
specifier|final
name|int
name|functionCount
init|=
name|windowsFunctions
operator|.
name|size
argument_list|()
decl_stmt|;
name|ArrayList
argument_list|<
name|ColumnInfo
argument_list|>
name|outputSignature
init|=
name|ptfOp
operator|.
name|getSchema
argument_list|()
operator|.
name|getSignature
argument_list|()
decl_stmt|;
specifier|final
name|int
name|outputSize
init|=
name|outputSignature
operator|.
name|size
argument_list|()
decl_stmt|;
comment|/*      * Output columns.      */
comment|// Evaluator results are first.
name|String
index|[]
name|outputColumnNames
init|=
operator|new
name|String
index|[
name|outputSize
index|]
decl_stmt|;
name|TypeInfo
index|[]
name|outputTypeInfos
init|=
operator|new
name|TypeInfo
index|[
name|outputSize
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|functionCount
condition|;
name|i
operator|++
control|)
block|{
name|ColumnInfo
name|colInfo
init|=
name|outputSignature
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|TypeInfo
name|typeInfo
init|=
name|colInfo
operator|.
name|getType
argument_list|()
decl_stmt|;
name|outputColumnNames
index|[
name|i
index|]
operator|=
name|colInfo
operator|.
name|getInternalName
argument_list|()
expr_stmt|;
name|outputTypeInfos
index|[
name|i
index|]
operator|=
name|typeInfo
expr_stmt|;
block|}
comment|// Followed by key and non-key input columns (some may be missing).
for|for
control|(
name|int
name|i
init|=
name|functionCount
init|;
name|i
operator|<
name|outputSize
condition|;
name|i
operator|++
control|)
block|{
name|ColumnInfo
name|colInfo
init|=
name|outputSignature
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|outputColumnNames
index|[
name|i
index|]
operator|=
name|colInfo
operator|.
name|getInternalName
argument_list|()
expr_stmt|;
name|outputTypeInfos
index|[
name|i
index|]
operator|=
name|colInfo
operator|.
name|getType
argument_list|()
expr_stmt|;
block|}
name|List
argument_list|<
name|PTFExpressionDef
argument_list|>
name|partitionExpressions
init|=
name|funcDef
operator|.
name|getPartition
argument_list|()
operator|.
name|getExpressions
argument_list|()
decl_stmt|;
specifier|final
name|int
name|partitionKeyCount
init|=
name|partitionExpressions
operator|.
name|size
argument_list|()
decl_stmt|;
name|ExprNodeDesc
index|[]
name|partitionExprNodeDescs
init|=
name|getPartitionExprNodeDescs
argument_list|(
name|partitionExpressions
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|OrderExpressionDef
argument_list|>
name|orderExpressions
init|=
name|funcDef
operator|.
name|getOrder
argument_list|()
operator|.
name|getExpressions
argument_list|()
decl_stmt|;
specifier|final
name|int
name|orderKeyCount
init|=
name|orderExpressions
operator|.
name|size
argument_list|()
decl_stmt|;
name|ExprNodeDesc
index|[]
name|orderExprNodeDescs
init|=
name|getOrderExprNodeDescs
argument_list|(
name|orderExpressions
argument_list|)
decl_stmt|;
comment|// When there are PARTITION and ORDER BY clauses, will have different partition expressions.
comment|// Otherwise, only order by expressions.
name|boolean
name|isPartitionOrderBy
init|=
literal|false
decl_stmt|;
if|if
condition|(
name|partitionKeyCount
operator|!=
name|orderKeyCount
condition|)
block|{
comment|// Obviously different expressions.
name|isPartitionOrderBy
operator|=
literal|true
expr_stmt|;
block|}
else|else
block|{
comment|// Check each ExprNodeDesc.
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|partitionKeyCount
condition|;
name|i
operator|++
control|)
block|{
specifier|final
name|ExprNodeDescEqualityWrapper
name|partitionExprEqualityWrapper
init|=
operator|new
name|ExprNodeDesc
operator|.
name|ExprNodeDescEqualityWrapper
argument_list|(
name|partitionExprNodeDescs
index|[
name|i
index|]
argument_list|)
decl_stmt|;
specifier|final
name|ExprNodeDescEqualityWrapper
name|orderExprEqualityWrapper
init|=
operator|new
name|ExprNodeDesc
operator|.
name|ExprNodeDescEqualityWrapper
argument_list|(
name|orderExprNodeDescs
index|[
name|i
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|partitionExprEqualityWrapper
operator|.
name|equals
argument_list|(
name|orderExprEqualityWrapper
argument_list|)
condition|)
block|{
name|isPartitionOrderBy
operator|=
literal|true
expr_stmt|;
break|break;
block|}
block|}
block|}
name|String
index|[]
name|evaluatorFunctionNames
init|=
operator|new
name|String
index|[
name|functionCount
index|]
decl_stmt|;
name|WindowFrameDef
index|[]
name|evaluatorWindowFrameDefs
init|=
operator|new
name|WindowFrameDef
index|[
name|functionCount
index|]
decl_stmt|;
name|List
argument_list|<
name|ExprNodeDesc
argument_list|>
index|[]
name|evaluatorInputExprNodeDescLists
init|=
operator|(
name|List
argument_list|<
name|ExprNodeDesc
argument_list|>
index|[]
operator|)
operator|new
name|List
argument_list|<
name|?
argument_list|>
index|[
name|functionCount
index|]
decl_stmt|;
name|fillInPTFEvaluators
argument_list|(
name|windowsFunctions
argument_list|,
name|evaluatorFunctionNames
argument_list|,
name|evaluatorWindowFrameDefs
argument_list|,
name|evaluatorInputExprNodeDescLists
argument_list|)
expr_stmt|;
name|TypeInfo
index|[]
name|reducerBatchTypeInfos
init|=
name|vContext
operator|.
name|getAllTypeInfos
argument_list|()
decl_stmt|;
name|vectorPTFDesc
operator|.
name|setReducerBatchTypeInfos
argument_list|(
name|reducerBatchTypeInfos
argument_list|)
expr_stmt|;
name|vectorPTFDesc
operator|.
name|setIsPartitionOrderBy
argument_list|(
name|isPartitionOrderBy
argument_list|)
expr_stmt|;
name|vectorPTFDesc
operator|.
name|setOrderExprNodeDescs
argument_list|(
name|orderExprNodeDescs
argument_list|)
expr_stmt|;
name|vectorPTFDesc
operator|.
name|setPartitionExprNodeDescs
argument_list|(
name|partitionExprNodeDescs
argument_list|)
expr_stmt|;
name|vectorPTFDesc
operator|.
name|setEvaluatorFunctionNames
argument_list|(
name|evaluatorFunctionNames
argument_list|)
expr_stmt|;
name|vectorPTFDesc
operator|.
name|setEvaluatorWindowFrameDefs
argument_list|(
name|evaluatorWindowFrameDefs
argument_list|)
expr_stmt|;
name|vectorPTFDesc
operator|.
name|setEvaluatorInputExprNodeDescLists
argument_list|(
name|evaluatorInputExprNodeDescLists
argument_list|)
expr_stmt|;
name|vectorPTFDesc
operator|.
name|setOutputColumnNames
argument_list|(
name|outputColumnNames
argument_list|)
expr_stmt|;
name|vectorPTFDesc
operator|.
name|setOutputTypeInfos
argument_list|(
name|outputTypeInfos
argument_list|)
expr_stmt|;
name|vectorPTFDesc
operator|.
name|setVectorizedPTFMaxMemoryBufferingBatchCount
argument_list|(
name|vectorizedPTFMaxMemoryBufferingBatchCount
argument_list|)
expr_stmt|;
block|}
specifier|private
specifier|static
name|void
name|determineKeyAndNonKeyInputColumnMap
parameter_list|(
name|int
index|[]
name|outputColumnProjectionMap
parameter_list|,
name|boolean
name|isPartitionOrderBy
parameter_list|,
name|int
index|[]
name|orderColumnMap
parameter_list|,
name|int
index|[]
name|partitionColumnMap
parameter_list|,
name|int
name|evaluatorCount
parameter_list|,
name|ArrayList
argument_list|<
name|Integer
argument_list|>
name|keyInputColumns
parameter_list|,
name|ArrayList
argument_list|<
name|Integer
argument_list|>
name|nonKeyInputColumns
parameter_list|)
block|{
specifier|final
name|int
name|outputSize
init|=
name|outputColumnProjectionMap
operator|.
name|length
decl_stmt|;
specifier|final
name|int
name|orderKeyCount
init|=
name|orderColumnMap
operator|.
name|length
decl_stmt|;
specifier|final
name|int
name|partitionKeyCount
init|=
operator|(
name|isPartitionOrderBy
condition|?
name|partitionColumnMap
operator|.
name|length
else|:
literal|0
operator|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
name|evaluatorCount
init|;
name|i
operator|<
name|outputSize
condition|;
name|i
operator|++
control|)
block|{
specifier|final
name|int
name|nonEvalColumnNum
init|=
name|outputColumnProjectionMap
index|[
name|i
index|]
decl_stmt|;
name|boolean
name|isKey
init|=
literal|false
decl_stmt|;
for|for
control|(
name|int
name|o
init|=
literal|0
init|;
name|o
operator|<
name|orderKeyCount
condition|;
name|o
operator|++
control|)
block|{
if|if
condition|(
name|nonEvalColumnNum
operator|==
name|orderColumnMap
index|[
name|o
index|]
condition|)
block|{
name|isKey
operator|=
literal|true
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|isKey
operator|&&
name|isPartitionOrderBy
condition|)
block|{
for|for
control|(
name|int
name|p
init|=
literal|0
init|;
name|p
operator|<
name|partitionKeyCount
condition|;
name|p
operator|++
control|)
block|{
if|if
condition|(
name|nonEvalColumnNum
operator|==
name|partitionColumnMap
index|[
name|p
index|]
condition|)
block|{
name|isKey
operator|=
literal|true
expr_stmt|;
break|break;
block|}
block|}
block|}
if|if
condition|(
name|isKey
condition|)
block|{
name|keyInputColumns
operator|.
name|add
argument_list|(
name|nonEvalColumnNum
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|nonKeyInputColumns
operator|.
name|add
argument_list|(
name|nonEvalColumnNum
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/*    * Create the additional vectorization PTF information needed by the VectorPTFOperator during    * execution.    */
specifier|private
specifier|static
name|VectorPTFInfo
name|createVectorPTFInfo
parameter_list|(
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
name|ptfOp
parameter_list|,
name|PTFDesc
name|ptfDesc
parameter_list|,
name|VectorizationContext
name|vContext
parameter_list|,
name|VectorPTFDesc
name|vectorPTFDesc
parameter_list|)
throws|throws
name|HiveException
block|{
name|PartitionedTableFunctionDef
name|funcDef
init|=
name|ptfDesc
operator|.
name|getFuncDef
argument_list|()
decl_stmt|;
name|ArrayList
argument_list|<
name|ColumnInfo
argument_list|>
name|outputSignature
init|=
name|ptfOp
operator|.
name|getSchema
argument_list|()
operator|.
name|getSignature
argument_list|()
decl_stmt|;
specifier|final
name|int
name|outputSize
init|=
name|outputSignature
operator|.
name|size
argument_list|()
decl_stmt|;
name|boolean
name|isPartitionOrderBy
init|=
name|vectorPTFDesc
operator|.
name|getIsPartitionOrderBy
argument_list|()
decl_stmt|;
name|ExprNodeDesc
index|[]
name|orderExprNodeDescs
init|=
name|vectorPTFDesc
operator|.
name|getOrderExprNodeDescs
argument_list|()
decl_stmt|;
name|ExprNodeDesc
index|[]
name|partitionExprNodeDescs
init|=
name|vectorPTFDesc
operator|.
name|getPartitionExprNodeDescs
argument_list|()
decl_stmt|;
name|String
index|[]
name|evaluatorFunctionNames
init|=
name|vectorPTFDesc
operator|.
name|getEvaluatorFunctionNames
argument_list|()
decl_stmt|;
specifier|final
name|int
name|evaluatorCount
init|=
name|evaluatorFunctionNames
operator|.
name|length
decl_stmt|;
name|WindowFrameDef
index|[]
name|evaluatorWindowFrameDefs
init|=
name|vectorPTFDesc
operator|.
name|getEvaluatorWindowFrameDefs
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|ExprNodeDesc
argument_list|>
index|[]
name|evaluatorInputExprNodeDescLists
init|=
name|vectorPTFDesc
operator|.
name|getEvaluatorInputExprNodeDescLists
argument_list|()
decl_stmt|;
comment|/*      * Output columns.      */
name|int
index|[]
name|outputColumnProjectionMap
init|=
operator|new
name|int
index|[
name|outputSize
index|]
decl_stmt|;
comment|// Evaluator results are first.
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|evaluatorCount
condition|;
name|i
operator|++
control|)
block|{
name|ColumnInfo
name|colInfo
init|=
name|outputSignature
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|TypeInfo
name|typeInfo
init|=
name|colInfo
operator|.
name|getType
argument_list|()
decl_stmt|;
specifier|final
name|int
name|outputColumnNum
decl_stmt|;
name|outputColumnNum
operator|=
name|vContext
operator|.
name|allocateScratchColumn
argument_list|(
name|typeInfo
argument_list|)
expr_stmt|;
name|outputColumnProjectionMap
index|[
name|i
index|]
operator|=
name|outputColumnNum
expr_stmt|;
block|}
comment|// Followed by key and non-key input columns (some may be missing).
for|for
control|(
name|int
name|i
init|=
name|evaluatorCount
init|;
name|i
operator|<
name|outputSize
condition|;
name|i
operator|++
control|)
block|{
name|ColumnInfo
name|colInfo
init|=
name|outputSignature
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|outputColumnProjectionMap
index|[
name|i
index|]
operator|=
name|vContext
operator|.
name|getInputColumnIndex
argument_list|(
name|colInfo
operator|.
name|getInternalName
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/*      * Partition and order by.      */
name|int
index|[]
name|partitionColumnMap
decl_stmt|;
name|Type
index|[]
name|partitionColumnVectorTypes
decl_stmt|;
name|VectorExpression
index|[]
name|partitionExpressions
decl_stmt|;
if|if
condition|(
operator|!
name|isPartitionOrderBy
condition|)
block|{
name|partitionColumnMap
operator|=
literal|null
expr_stmt|;
name|partitionColumnVectorTypes
operator|=
literal|null
expr_stmt|;
name|partitionExpressions
operator|=
literal|null
expr_stmt|;
block|}
else|else
block|{
specifier|final
name|int
name|partitionKeyCount
init|=
name|partitionExprNodeDescs
operator|.
name|length
decl_stmt|;
name|partitionColumnMap
operator|=
operator|new
name|int
index|[
name|partitionKeyCount
index|]
expr_stmt|;
name|partitionColumnVectorTypes
operator|=
operator|new
name|Type
index|[
name|partitionKeyCount
index|]
expr_stmt|;
name|partitionExpressions
operator|=
operator|new
name|VectorExpression
index|[
name|partitionKeyCount
index|]
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|partitionKeyCount
condition|;
name|i
operator|++
control|)
block|{
name|VectorExpression
name|partitionExpression
init|=
name|vContext
operator|.
name|getVectorExpression
argument_list|(
name|partitionExprNodeDescs
index|[
name|i
index|]
argument_list|)
decl_stmt|;
name|TypeInfo
name|typeInfo
init|=
name|partitionExpression
operator|.
name|getOutputTypeInfo
argument_list|()
decl_stmt|;
name|Type
name|columnVectorType
init|=
name|VectorizationContext
operator|.
name|getColumnVectorTypeFromTypeInfo
argument_list|(
name|typeInfo
argument_list|)
decl_stmt|;
name|partitionColumnVectorTypes
index|[
name|i
index|]
operator|=
name|columnVectorType
expr_stmt|;
name|partitionColumnMap
index|[
name|i
index|]
operator|=
name|partitionExpression
operator|.
name|getOutputColumnNum
argument_list|()
expr_stmt|;
name|partitionExpressions
index|[
name|i
index|]
operator|=
name|partitionExpression
expr_stmt|;
block|}
block|}
specifier|final
name|int
name|orderKeyCount
init|=
name|orderExprNodeDescs
operator|.
name|length
decl_stmt|;
name|int
index|[]
name|orderColumnMap
init|=
operator|new
name|int
index|[
name|orderKeyCount
index|]
decl_stmt|;
name|Type
index|[]
name|orderColumnVectorTypes
init|=
operator|new
name|Type
index|[
name|orderKeyCount
index|]
decl_stmt|;
name|VectorExpression
index|[]
name|orderExpressions
init|=
operator|new
name|VectorExpression
index|[
name|orderKeyCount
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|orderKeyCount
condition|;
name|i
operator|++
control|)
block|{
name|VectorExpression
name|orderExpression
init|=
name|vContext
operator|.
name|getVectorExpression
argument_list|(
name|orderExprNodeDescs
index|[
name|i
index|]
argument_list|)
decl_stmt|;
name|TypeInfo
name|typeInfo
init|=
name|orderExpression
operator|.
name|getOutputTypeInfo
argument_list|()
decl_stmt|;
name|Type
name|columnVectorType
init|=
name|VectorizationContext
operator|.
name|getColumnVectorTypeFromTypeInfo
argument_list|(
name|typeInfo
argument_list|)
decl_stmt|;
name|orderColumnVectorTypes
index|[
name|i
index|]
operator|=
name|columnVectorType
expr_stmt|;
name|orderColumnMap
index|[
name|i
index|]
operator|=
name|orderExpression
operator|.
name|getOutputColumnNum
argument_list|()
expr_stmt|;
name|orderExpressions
index|[
name|i
index|]
operator|=
name|orderExpression
expr_stmt|;
block|}
name|ArrayList
argument_list|<
name|Integer
argument_list|>
name|keyInputColumns
init|=
operator|new
name|ArrayList
argument_list|<
name|Integer
argument_list|>
argument_list|()
decl_stmt|;
name|ArrayList
argument_list|<
name|Integer
argument_list|>
name|nonKeyInputColumns
init|=
operator|new
name|ArrayList
argument_list|<
name|Integer
argument_list|>
argument_list|()
decl_stmt|;
name|determineKeyAndNonKeyInputColumnMap
argument_list|(
name|outputColumnProjectionMap
argument_list|,
name|isPartitionOrderBy
argument_list|,
name|orderColumnMap
argument_list|,
name|partitionColumnMap
argument_list|,
name|evaluatorCount
argument_list|,
name|keyInputColumns
argument_list|,
name|nonKeyInputColumns
argument_list|)
expr_stmt|;
name|int
index|[]
name|keyInputColumnMap
init|=
name|ArrayUtils
operator|.
name|toPrimitive
argument_list|(
name|keyInputColumns
operator|.
name|toArray
argument_list|(
operator|new
name|Integer
index|[
literal|0
index|]
argument_list|)
argument_list|)
decl_stmt|;
name|int
index|[]
name|nonKeyInputColumnMap
init|=
name|ArrayUtils
operator|.
name|toPrimitive
argument_list|(
name|nonKeyInputColumns
operator|.
name|toArray
argument_list|(
operator|new
name|Integer
index|[
literal|0
index|]
argument_list|)
argument_list|)
decl_stmt|;
name|VectorExpression
index|[]
name|evaluatorInputExpressions
init|=
operator|new
name|VectorExpression
index|[
name|evaluatorCount
index|]
decl_stmt|;
name|Type
index|[]
name|evaluatorInputColumnVectorTypes
init|=
operator|new
name|Type
index|[
name|evaluatorCount
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|evaluatorCount
condition|;
name|i
operator|++
control|)
block|{
name|String
name|functionName
init|=
name|evaluatorFunctionNames
index|[
name|i
index|]
decl_stmt|;
name|WindowFrameDef
name|windowFrameDef
init|=
name|evaluatorWindowFrameDefs
index|[
name|i
index|]
decl_stmt|;
name|SupportedFunctionType
name|functionType
init|=
name|VectorPTFDesc
operator|.
name|supportedFunctionsMap
operator|.
name|get
argument_list|(
name|functionName
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|ExprNodeDesc
argument_list|>
name|exprNodeDescList
init|=
name|evaluatorInputExprNodeDescLists
index|[
name|i
index|]
decl_stmt|;
name|VectorExpression
name|inputVectorExpression
decl_stmt|;
specifier|final
name|Type
name|columnVectorType
decl_stmt|;
if|if
condition|(
name|exprNodeDescList
operator|!=
literal|null
condition|)
block|{
comment|// Validation has limited evaluatorInputExprNodeDescLists to size 1.
name|ExprNodeDesc
name|exprNodeDesc
init|=
name|exprNodeDescList
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
comment|// Determine input vector expression using the VectorizationContext.
name|inputVectorExpression
operator|=
name|vContext
operator|.
name|getVectorExpression
argument_list|(
name|exprNodeDesc
argument_list|)
expr_stmt|;
name|TypeInfo
name|typeInfo
init|=
name|exprNodeDesc
operator|.
name|getTypeInfo
argument_list|()
decl_stmt|;
name|PrimitiveCategory
name|primitiveCategory
init|=
operator|(
operator|(
name|PrimitiveTypeInfo
operator|)
name|typeInfo
operator|)
operator|.
name|getPrimitiveCategory
argument_list|()
decl_stmt|;
name|columnVectorType
operator|=
name|VectorizationContext
operator|.
name|getColumnVectorTypeFromTypeInfo
argument_list|(
name|typeInfo
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|inputVectorExpression
operator|=
literal|null
expr_stmt|;
name|columnVectorType
operator|=
name|ColumnVector
operator|.
name|Type
operator|.
name|NONE
expr_stmt|;
block|}
name|evaluatorInputExpressions
index|[
name|i
index|]
operator|=
name|inputVectorExpression
expr_stmt|;
name|evaluatorInputColumnVectorTypes
index|[
name|i
index|]
operator|=
name|columnVectorType
expr_stmt|;
block|}
name|VectorPTFInfo
name|vectorPTFInfo
init|=
operator|new
name|VectorPTFInfo
argument_list|()
decl_stmt|;
name|vectorPTFInfo
operator|.
name|setOutputColumnMap
argument_list|(
name|outputColumnProjectionMap
argument_list|)
expr_stmt|;
name|vectorPTFInfo
operator|.
name|setPartitionColumnMap
argument_list|(
name|partitionColumnMap
argument_list|)
expr_stmt|;
name|vectorPTFInfo
operator|.
name|setPartitionColumnVectorTypes
argument_list|(
name|partitionColumnVectorTypes
argument_list|)
expr_stmt|;
name|vectorPTFInfo
operator|.
name|setPartitionExpressions
argument_list|(
name|partitionExpressions
argument_list|)
expr_stmt|;
name|vectorPTFInfo
operator|.
name|setOrderColumnMap
argument_list|(
name|orderColumnMap
argument_list|)
expr_stmt|;
name|vectorPTFInfo
operator|.
name|setOrderColumnVectorTypes
argument_list|(
name|orderColumnVectorTypes
argument_list|)
expr_stmt|;
name|vectorPTFInfo
operator|.
name|setOrderExpressions
argument_list|(
name|orderExpressions
argument_list|)
expr_stmt|;
name|vectorPTFInfo
operator|.
name|setEvaluatorInputExpressions
argument_list|(
name|evaluatorInputExpressions
argument_list|)
expr_stmt|;
name|vectorPTFInfo
operator|.
name|setEvaluatorInputColumnVectorTypes
argument_list|(
name|evaluatorInputColumnVectorTypes
argument_list|)
expr_stmt|;
name|vectorPTFInfo
operator|.
name|setKeyInputColumnMap
argument_list|(
name|keyInputColumnMap
argument_list|)
expr_stmt|;
name|vectorPTFInfo
operator|.
name|setNonKeyInputColumnMap
argument_list|(
name|nonKeyInputColumnMap
argument_list|)
expr_stmt|;
return|return
name|vectorPTFInfo
return|;
block|}
comment|/*    * NOTE: The VectorPTFDesc has already been allocated and populated.    */
specifier|public
specifier|static
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
name|vectorizePTFOperator
parameter_list|(
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
name|ptfOp
parameter_list|,
name|VectorizationContext
name|vContext
parameter_list|,
name|VectorPTFDesc
name|vectorPTFDesc
parameter_list|)
throws|throws
name|HiveException
block|{
name|PTFDesc
name|ptfDesc
init|=
operator|(
name|PTFDesc
operator|)
name|ptfOp
operator|.
name|getConf
argument_list|()
decl_stmt|;
name|VectorPTFInfo
name|vectorPTFInfo
init|=
name|createVectorPTFInfo
argument_list|(
name|ptfOp
argument_list|,
name|ptfDesc
argument_list|,
name|vContext
argument_list|,
name|vectorPTFDesc
argument_list|)
decl_stmt|;
name|vectorPTFDesc
operator|.
name|setVectorPTFInfo
argument_list|(
name|vectorPTFInfo
argument_list|)
expr_stmt|;
name|Class
argument_list|<
name|?
extends|extends
name|Operator
argument_list|<
name|?
argument_list|>
argument_list|>
name|opClass
init|=
name|VectorPTFOperator
operator|.
name|class
decl_stmt|;
return|return
name|OperatorFactory
operator|.
name|getVectorOperator
argument_list|(
name|opClass
argument_list|,
name|ptfOp
operator|.
name|getCompilationOpContext
argument_list|()
argument_list|,
name|ptfOp
operator|.
name|getConf
argument_list|()
argument_list|,
name|vContext
argument_list|,
name|vectorPTFDesc
argument_list|)
return|;
block|}
comment|// UNDONE: Used by tests...
specifier|public
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
name|vectorizeOperator
parameter_list|(
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
name|op
parameter_list|,
name|VectorizationContext
name|vContext
parameter_list|,
name|boolean
name|isReduce
parameter_list|,
name|boolean
name|isTezOrSpark
parameter_list|,
name|VectorTaskColumnInfo
name|vectorTaskColumnInfo
parameter_list|)
throws|throws
name|HiveException
throws|,
name|VectorizerCannotVectorizeException
block|{
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
name|vectorOp
init|=
name|validateAndVectorizeOperator
argument_list|(
name|op
argument_list|,
name|vContext
argument_list|,
name|isReduce
argument_list|,
name|isTezOrSpark
argument_list|,
name|vectorTaskColumnInfo
argument_list|)
decl_stmt|;
if|if
condition|(
name|vectorOp
operator|!=
name|op
condition|)
block|{
name|fixupParentChildOperators
argument_list|(
name|op
argument_list|,
name|vectorOp
argument_list|)
expr_stmt|;
block|}
return|return
name|vectorOp
return|;
block|}
specifier|public
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
name|validateAndVectorizeOperator
parameter_list|(
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
name|op
parameter_list|,
name|VectorizationContext
name|vContext
parameter_list|,
name|boolean
name|isReduce
parameter_list|,
name|boolean
name|isTezOrSpark
parameter_list|,
name|VectorTaskColumnInfo
name|vectorTaskColumnInfo
parameter_list|)
throws|throws
name|HiveException
throws|,
name|VectorizerCannotVectorizeException
block|{
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
name|vectorOp
init|=
literal|null
decl_stmt|;
comment|// This "global" allows various validation methods to set the "not vectorized" reason.
name|currentOperator
operator|=
name|op
expr_stmt|;
name|boolean
name|isNative
decl_stmt|;
try|try
block|{
switch|switch
condition|(
name|op
operator|.
name|getType
argument_list|()
condition|)
block|{
case|case
name|MAPJOIN
case|:
block|{
if|if
condition|(
name|op
operator|instanceof
name|MapJoinOperator
condition|)
block|{
if|if
condition|(
operator|!
name|validateMapJoinOperator
argument_list|(
operator|(
name|MapJoinOperator
operator|)
name|op
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|VectorizerCannotVectorizeException
argument_list|()
throw|;
block|}
block|}
elseif|else
if|if
condition|(
name|op
operator|instanceof
name|SMBMapJoinOperator
condition|)
block|{
if|if
condition|(
operator|!
name|validateSMBMapJoinOperator
argument_list|(
operator|(
name|SMBMapJoinOperator
operator|)
name|op
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|VectorizerCannotVectorizeException
argument_list|()
throw|;
block|}
block|}
else|else
block|{
name|setOperatorNotSupported
argument_list|(
name|op
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|VectorizerCannotVectorizeException
argument_list|()
throw|;
block|}
if|if
condition|(
name|op
operator|instanceof
name|MapJoinOperator
condition|)
block|{
name|MapJoinDesc
name|desc
init|=
operator|(
name|MapJoinDesc
operator|)
name|op
operator|.
name|getConf
argument_list|()
decl_stmt|;
name|VectorMapJoinDesc
name|vectorMapJoinDesc
init|=
operator|new
name|VectorMapJoinDesc
argument_list|()
decl_stmt|;
name|boolean
name|specialize
init|=
name|canSpecializeMapJoin
argument_list|(
name|op
argument_list|,
name|desc
argument_list|,
name|isTezOrSpark
argument_list|,
name|vContext
argument_list|,
name|vectorMapJoinDesc
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|specialize
condition|)
block|{
name|Class
argument_list|<
name|?
extends|extends
name|Operator
argument_list|<
name|?
argument_list|>
argument_list|>
name|opClass
init|=
literal|null
decl_stmt|;
comment|// *NON-NATIVE* vector map differences for LEFT OUTER JOIN and Filtered...
name|List
argument_list|<
name|ExprNodeDesc
argument_list|>
name|bigTableFilters
init|=
name|desc
operator|.
name|getFilters
argument_list|()
operator|.
name|get
argument_list|(
operator|(
name|byte
operator|)
name|desc
operator|.
name|getPosBigTable
argument_list|()
argument_list|)
decl_stmt|;
name|boolean
name|isOuterAndFiltered
init|=
operator|(
operator|!
name|desc
operator|.
name|isNoOuterJoin
argument_list|()
operator|&&
name|bigTableFilters
operator|.
name|size
argument_list|()
operator|>
literal|0
operator|)
decl_stmt|;
if|if
condition|(
operator|!
name|isOuterAndFiltered
condition|)
block|{
name|opClass
operator|=
name|VectorMapJoinOperator
operator|.
name|class
expr_stmt|;
block|}
else|else
block|{
name|opClass
operator|=
name|VectorMapJoinOuterFilteredOperator
operator|.
name|class
expr_stmt|;
block|}
name|vectorOp
operator|=
name|OperatorFactory
operator|.
name|getVectorOperator
argument_list|(
name|opClass
argument_list|,
name|op
operator|.
name|getCompilationOpContext
argument_list|()
argument_list|,
name|desc
argument_list|,
name|vContext
argument_list|,
name|vectorMapJoinDesc
argument_list|)
expr_stmt|;
name|isNative
operator|=
literal|false
expr_stmt|;
block|}
else|else
block|{
comment|// TEMPORARY Until Native Vector Map Join with Hybrid passes tests...
comment|// HiveConf.setBoolVar(physicalContext.getConf(),
comment|//    HiveConf.ConfVars.HIVEUSEHYBRIDGRACEHASHJOIN, false);
name|vectorOp
operator|=
name|specializeMapJoinOperator
argument_list|(
name|op
argument_list|,
name|vContext
argument_list|,
name|desc
argument_list|,
name|vectorMapJoinDesc
argument_list|)
expr_stmt|;
name|isNative
operator|=
literal|true
expr_stmt|;
if|if
condition|(
name|vectorTaskColumnInfo
operator|!=
literal|null
condition|)
block|{
name|VectorMapJoinInfo
name|vectorMapJoinInfo
init|=
name|vectorMapJoinDesc
operator|.
name|getVectorMapJoinInfo
argument_list|()
decl_stmt|;
if|if
condition|(
name|usesVectorUDFAdaptor
argument_list|(
name|vectorMapJoinDesc
operator|.
name|getAllBigTableKeyExpressions
argument_list|()
argument_list|)
condition|)
block|{
name|vectorTaskColumnInfo
operator|.
name|setUsesVectorUDFAdaptor
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|usesVectorUDFAdaptor
argument_list|(
name|vectorMapJoinDesc
operator|.
name|getAllBigTableValueExpressions
argument_list|()
argument_list|)
condition|)
block|{
name|vectorTaskColumnInfo
operator|.
name|setUsesVectorUDFAdaptor
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
else|else
block|{
name|Preconditions
operator|.
name|checkState
argument_list|(
name|op
operator|instanceof
name|SMBMapJoinOperator
argument_list|)
expr_stmt|;
name|SMBJoinDesc
name|smbJoinSinkDesc
init|=
operator|(
name|SMBJoinDesc
operator|)
name|op
operator|.
name|getConf
argument_list|()
decl_stmt|;
comment|// Check additional constraint.
if|if
condition|(
name|smbJoinSinkDesc
operator|.
name|getFilterMap
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|setOperatorIssue
argument_list|(
literal|"FilterMaps not supported for Vector Pass-Thru SMB MapJoin"
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|VectorizerCannotVectorizeException
argument_list|()
throw|;
block|}
name|VectorSMBJoinDesc
name|vectorSMBJoinDesc
init|=
operator|new
name|VectorSMBJoinDesc
argument_list|()
decl_stmt|;
name|vectorOp
operator|=
name|OperatorFactory
operator|.
name|getVectorOperator
argument_list|(
name|op
operator|.
name|getCompilationOpContext
argument_list|()
argument_list|,
name|smbJoinSinkDesc
argument_list|,
name|vContext
argument_list|,
name|vectorSMBJoinDesc
argument_list|)
expr_stmt|;
name|isNative
operator|=
literal|false
expr_stmt|;
block|}
block|}
break|break;
case|case
name|REDUCESINK
case|:
block|{
if|if
condition|(
operator|!
name|validateReduceSinkOperator
argument_list|(
operator|(
name|ReduceSinkOperator
operator|)
name|op
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|VectorizerCannotVectorizeException
argument_list|()
throw|;
block|}
name|ReduceSinkDesc
name|reduceDesc
init|=
operator|(
name|ReduceSinkDesc
operator|)
name|op
operator|.
name|getConf
argument_list|()
decl_stmt|;
name|VectorReduceSinkDesc
name|vectorReduceSinkDesc
init|=
operator|new
name|VectorReduceSinkDesc
argument_list|()
decl_stmt|;
name|boolean
name|specialize
init|=
name|canSpecializeReduceSink
argument_list|(
name|reduceDesc
argument_list|,
name|isTezOrSpark
argument_list|,
name|vContext
argument_list|,
name|vectorReduceSinkDesc
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|specialize
condition|)
block|{
name|vectorOp
operator|=
name|OperatorFactory
operator|.
name|getVectorOperator
argument_list|(
name|op
operator|.
name|getCompilationOpContext
argument_list|()
argument_list|,
name|reduceDesc
argument_list|,
name|vContext
argument_list|,
name|vectorReduceSinkDesc
argument_list|)
expr_stmt|;
name|isNative
operator|=
literal|false
expr_stmt|;
block|}
else|else
block|{
name|vectorOp
operator|=
name|specializeReduceSinkOperator
argument_list|(
name|op
argument_list|,
name|vContext
argument_list|,
name|reduceDesc
argument_list|,
name|vectorReduceSinkDesc
argument_list|)
expr_stmt|;
name|isNative
operator|=
literal|true
expr_stmt|;
if|if
condition|(
name|vectorTaskColumnInfo
operator|!=
literal|null
condition|)
block|{
name|VectorReduceSinkInfo
name|vectorReduceSinkInfo
init|=
name|vectorReduceSinkDesc
operator|.
name|getVectorReduceSinkInfo
argument_list|()
decl_stmt|;
if|if
condition|(
name|usesVectorUDFAdaptor
argument_list|(
name|vectorReduceSinkInfo
operator|.
name|getReduceSinkKeyExpressions
argument_list|()
argument_list|)
condition|)
block|{
name|vectorTaskColumnInfo
operator|.
name|setUsesVectorUDFAdaptor
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|usesVectorUDFAdaptor
argument_list|(
name|vectorReduceSinkInfo
operator|.
name|getReduceSinkValueExpressions
argument_list|()
argument_list|)
condition|)
block|{
name|vectorTaskColumnInfo
operator|.
name|setUsesVectorUDFAdaptor
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
break|break;
case|case
name|FILTER
case|:
block|{
if|if
condition|(
operator|!
name|validateFilterOperator
argument_list|(
operator|(
name|FilterOperator
operator|)
name|op
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|VectorizerCannotVectorizeException
argument_list|()
throw|;
block|}
name|VectorFilterDesc
name|vectorFilterDesc
init|=
operator|new
name|VectorFilterDesc
argument_list|()
decl_stmt|;
name|vectorOp
operator|=
name|vectorizeFilterOperator
argument_list|(
name|op
argument_list|,
name|vContext
argument_list|,
name|vectorFilterDesc
argument_list|)
expr_stmt|;
name|isNative
operator|=
literal|true
expr_stmt|;
if|if
condition|(
name|vectorTaskColumnInfo
operator|!=
literal|null
condition|)
block|{
name|VectorExpression
name|vectorPredicateExpr
init|=
name|vectorFilterDesc
operator|.
name|getPredicateExpression
argument_list|()
decl_stmt|;
if|if
condition|(
name|usesVectorUDFAdaptor
argument_list|(
name|vectorPredicateExpr
argument_list|)
condition|)
block|{
name|vectorTaskColumnInfo
operator|.
name|setUsesVectorUDFAdaptor
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
block|}
block|}
break|break;
case|case
name|SELECT
case|:
block|{
if|if
condition|(
operator|!
name|validateSelectOperator
argument_list|(
operator|(
name|SelectOperator
operator|)
name|op
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|VectorizerCannotVectorizeException
argument_list|()
throw|;
block|}
name|VectorSelectDesc
name|vectorSelectDesc
init|=
operator|new
name|VectorSelectDesc
argument_list|()
decl_stmt|;
name|vectorOp
operator|=
name|vectorizeSelectOperator
argument_list|(
name|op
argument_list|,
name|vContext
argument_list|,
name|vectorSelectDesc
argument_list|)
expr_stmt|;
name|isNative
operator|=
literal|true
expr_stmt|;
if|if
condition|(
name|vectorTaskColumnInfo
operator|!=
literal|null
condition|)
block|{
name|VectorExpression
index|[]
name|vectorSelectExprs
init|=
name|vectorSelectDesc
operator|.
name|getSelectExpressions
argument_list|()
decl_stmt|;
if|if
condition|(
name|usesVectorUDFAdaptor
argument_list|(
name|vectorSelectExprs
argument_list|)
condition|)
block|{
name|vectorTaskColumnInfo
operator|.
name|setUsesVectorUDFAdaptor
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
block|}
block|}
break|break;
case|case
name|GROUPBY
case|:
block|{
comment|// The validateGroupByOperator method will update vectorGroupByDesc.
name|VectorGroupByDesc
name|vectorGroupByDesc
init|=
operator|new
name|VectorGroupByDesc
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|validateGroupByOperator
argument_list|(
operator|(
name|GroupByOperator
operator|)
name|op
argument_list|,
name|isReduce
argument_list|,
name|isTezOrSpark
argument_list|,
name|vectorGroupByDesc
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|VectorizerCannotVectorizeException
argument_list|()
throw|;
block|}
name|ImmutablePair
argument_list|<
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
argument_list|,
name|String
argument_list|>
name|pair
init|=
name|doVectorizeGroupByOperator
argument_list|(
name|op
argument_list|,
name|vContext
argument_list|,
name|vectorGroupByDesc
argument_list|)
decl_stmt|;
if|if
condition|(
name|pair
operator|.
name|left
operator|==
literal|null
condition|)
block|{
name|setOperatorIssue
argument_list|(
name|pair
operator|.
name|right
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|VectorizerCannotVectorizeException
argument_list|()
throw|;
block|}
name|vectorOp
operator|=
name|pair
operator|.
name|left
expr_stmt|;
name|isNative
operator|=
literal|false
expr_stmt|;
if|if
condition|(
name|vectorTaskColumnInfo
operator|!=
literal|null
condition|)
block|{
name|VectorExpression
index|[]
name|vecKeyExpressions
init|=
name|vectorGroupByDesc
operator|.
name|getKeyExpressions
argument_list|()
decl_stmt|;
if|if
condition|(
name|usesVectorUDFAdaptor
argument_list|(
name|vecKeyExpressions
argument_list|)
condition|)
block|{
name|vectorTaskColumnInfo
operator|.
name|setUsesVectorUDFAdaptor
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
name|VectorAggregationDesc
index|[]
name|vecAggrDescs
init|=
name|vectorGroupByDesc
operator|.
name|getVecAggrDescs
argument_list|()
decl_stmt|;
for|for
control|(
name|VectorAggregationDesc
name|vecAggrDesc
range|:
name|vecAggrDescs
control|)
block|{
if|if
condition|(
name|usesVectorUDFAdaptor
argument_list|(
name|vecAggrDesc
operator|.
name|getInputExpression
argument_list|()
argument_list|)
condition|)
block|{
name|vectorTaskColumnInfo
operator|.
name|setUsesVectorUDFAdaptor
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
break|break;
case|case
name|FILESINK
case|:
block|{
if|if
condition|(
operator|!
name|validateFileSinkOperator
argument_list|(
operator|(
name|FileSinkOperator
operator|)
name|op
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|VectorizerCannotVectorizeException
argument_list|()
throw|;
block|}
name|FileSinkDesc
name|fileSinkDesc
init|=
operator|(
name|FileSinkDesc
operator|)
name|op
operator|.
name|getConf
argument_list|()
decl_stmt|;
name|VectorFileSinkDesc
name|vectorFileSinkDesc
init|=
operator|new
name|VectorFileSinkDesc
argument_list|()
decl_stmt|;
name|vectorOp
operator|=
name|OperatorFactory
operator|.
name|getVectorOperator
argument_list|(
name|op
operator|.
name|getCompilationOpContext
argument_list|()
argument_list|,
name|fileSinkDesc
argument_list|,
name|vContext
argument_list|,
name|vectorFileSinkDesc
argument_list|)
expr_stmt|;
name|isNative
operator|=
literal|false
expr_stmt|;
block|}
break|break;
case|case
name|LIMIT
case|:
block|{
comment|// No validation.
name|LimitDesc
name|limitDesc
init|=
operator|(
name|LimitDesc
operator|)
name|op
operator|.
name|getConf
argument_list|()
decl_stmt|;
name|VectorLimitDesc
name|vectorLimitDesc
init|=
operator|new
name|VectorLimitDesc
argument_list|()
decl_stmt|;
name|vectorOp
operator|=
name|OperatorFactory
operator|.
name|getVectorOperator
argument_list|(
name|op
operator|.
name|getCompilationOpContext
argument_list|()
argument_list|,
name|limitDesc
argument_list|,
name|vContext
argument_list|,
name|vectorLimitDesc
argument_list|)
expr_stmt|;
name|isNative
operator|=
literal|true
expr_stmt|;
block|}
break|break;
case|case
name|EVENT
case|:
block|{
comment|// No validation.
name|AppMasterEventDesc
name|eventDesc
init|=
operator|(
name|AppMasterEventDesc
operator|)
name|op
operator|.
name|getConf
argument_list|()
decl_stmt|;
name|VectorAppMasterEventDesc
name|vectorEventDesc
init|=
operator|new
name|VectorAppMasterEventDesc
argument_list|()
decl_stmt|;
name|vectorOp
operator|=
name|OperatorFactory
operator|.
name|getVectorOperator
argument_list|(
name|op
operator|.
name|getCompilationOpContext
argument_list|()
argument_list|,
name|eventDesc
argument_list|,
name|vContext
argument_list|,
name|vectorEventDesc
argument_list|)
expr_stmt|;
name|isNative
operator|=
literal|true
expr_stmt|;
block|}
break|break;
case|case
name|PTF
case|:
block|{
comment|// The validatePTFOperator method will update vectorPTFDesc.
name|VectorPTFDesc
name|vectorPTFDesc
init|=
operator|new
name|VectorPTFDesc
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|validatePTFOperator
argument_list|(
operator|(
name|PTFOperator
operator|)
name|op
argument_list|,
name|vContext
argument_list|,
name|vectorPTFDesc
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|VectorizerCannotVectorizeException
argument_list|()
throw|;
block|}
name|vectorOp
operator|=
name|vectorizePTFOperator
argument_list|(
name|op
argument_list|,
name|vContext
argument_list|,
name|vectorPTFDesc
argument_list|)
expr_stmt|;
name|isNative
operator|=
literal|true
expr_stmt|;
block|}
break|break;
case|case
name|HASHTABLESINK
case|:
block|{
comment|// No validation.
name|SparkHashTableSinkDesc
name|sparkHashTableSinkDesc
init|=
operator|(
name|SparkHashTableSinkDesc
operator|)
name|op
operator|.
name|getConf
argument_list|()
decl_stmt|;
name|VectorSparkHashTableSinkDesc
name|vectorSparkHashTableSinkDesc
init|=
operator|new
name|VectorSparkHashTableSinkDesc
argument_list|()
decl_stmt|;
name|vectorOp
operator|=
name|OperatorFactory
operator|.
name|getVectorOperator
argument_list|(
name|op
operator|.
name|getCompilationOpContext
argument_list|()
argument_list|,
name|sparkHashTableSinkDesc
argument_list|,
name|vContext
argument_list|,
name|vectorSparkHashTableSinkDesc
argument_list|)
expr_stmt|;
name|isNative
operator|=
literal|true
expr_stmt|;
block|}
break|break;
case|case
name|SPARKPRUNINGSINK
case|:
block|{
comment|// No validation.
name|SparkPartitionPruningSinkDesc
name|sparkPartitionPruningSinkDesc
init|=
operator|(
name|SparkPartitionPruningSinkDesc
operator|)
name|op
operator|.
name|getConf
argument_list|()
decl_stmt|;
name|VectorSparkPartitionPruningSinkDesc
name|vectorSparkPartitionPruningSinkDesc
init|=
operator|new
name|VectorSparkPartitionPruningSinkDesc
argument_list|()
decl_stmt|;
name|vectorOp
operator|=
name|OperatorFactory
operator|.
name|getVectorOperator
argument_list|(
name|op
operator|.
name|getCompilationOpContext
argument_list|()
argument_list|,
name|sparkPartitionPruningSinkDesc
argument_list|,
name|vContext
argument_list|,
name|vectorSparkPartitionPruningSinkDesc
argument_list|)
expr_stmt|;
comment|// need to maintain the unique ID so that target map works can
comment|// read the output
operator|(
operator|(
name|SparkPartitionPruningSinkOperator
operator|)
name|vectorOp
operator|)
operator|.
name|setUniqueId
argument_list|(
operator|(
operator|(
name|SparkPartitionPruningSinkOperator
operator|)
name|op
operator|)
operator|.
name|getUniqueId
argument_list|()
argument_list|)
expr_stmt|;
name|isNative
operator|=
literal|true
expr_stmt|;
block|}
break|break;
default|default:
name|setOperatorNotSupported
argument_list|(
name|op
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|VectorizerCannotVectorizeException
argument_list|()
throw|;
block|}
block|}
catch|catch
parameter_list|(
name|HiveException
name|e
parameter_list|)
block|{
name|setOperatorIssue
argument_list|(
name|e
operator|.
name|getMessage
argument_list|()
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|VectorizerCannotVectorizeException
argument_list|()
throw|;
block|}
name|Preconditions
operator|.
name|checkState
argument_list|(
name|vectorOp
operator|!=
literal|null
argument_list|)
expr_stmt|;
if|if
condition|(
name|vectorTaskColumnInfo
operator|!=
literal|null
operator|&&
operator|!
name|isNative
condition|)
block|{
name|vectorTaskColumnInfo
operator|.
name|setAllNative
argument_list|(
literal|false
argument_list|)
expr_stmt|;
block|}
name|LOG
operator|.
name|debug
argument_list|(
literal|"vectorizeOperator "
operator|+
name|vectorOp
operator|.
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"vectorizeOperator "
operator|+
name|vectorOp
operator|.
name|getConf
argument_list|()
operator|.
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|vectorOp
return|;
block|}
block|}
end_class

end_unit

