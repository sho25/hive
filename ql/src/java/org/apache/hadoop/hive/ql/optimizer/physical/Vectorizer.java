begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|optimizer
operator|.
name|physical
package|;
end_package

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|ReduceSinkDesc
operator|.
name|ReducerTraits
operator|.
name|UNIFORM
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|Serializable
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|annotation
operator|.
name|Annotation
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|LinkedHashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
operator|.
name|Entry
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Properties
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Stack
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|regex
operator|.
name|Pattern
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|lang
operator|.
name|ArrayUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|Pair
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|lang3
operator|.
name|tuple
operator|.
name|ImmutablePair
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|Path
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|conf
operator|.
name|HiveConf
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|mr
operator|.
name|MapRedTask
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|persistence
operator|.
name|MapJoinKey
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|spark
operator|.
name|SparkTask
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|tez
operator|.
name|TezTask
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|vector
operator|.
name|VectorExpressionDescriptor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|vector
operator|.
name|mapjoin
operator|.
name|VectorMapJoinInnerBigOnlyLongOperator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|vector
operator|.
name|mapjoin
operator|.
name|VectorMapJoinInnerBigOnlyMultiKeyOperator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|vector
operator|.
name|mapjoin
operator|.
name|VectorMapJoinInnerBigOnlyStringOperator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|vector
operator|.
name|mapjoin
operator|.
name|VectorMapJoinInnerLongOperator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|vector
operator|.
name|mapjoin
operator|.
name|VectorMapJoinInnerMultiKeyOperator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|vector
operator|.
name|mapjoin
operator|.
name|VectorMapJoinInnerStringOperator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|vector
operator|.
name|mapjoin
operator|.
name|VectorMapJoinLeftSemiLongOperator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|vector
operator|.
name|mapjoin
operator|.
name|VectorMapJoinLeftSemiMultiKeyOperator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|vector
operator|.
name|mapjoin
operator|.
name|VectorMapJoinLeftSemiStringOperator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|vector
operator|.
name|mapjoin
operator|.
name|VectorMapJoinOuterLongOperator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|vector
operator|.
name|mapjoin
operator|.
name|VectorMapJoinOuterMultiKeyOperator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|vector
operator|.
name|mapjoin
operator|.
name|VectorMapJoinOuterStringOperator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|vector
operator|.
name|reducesink
operator|.
name|VectorReduceSinkLongOperator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|vector
operator|.
name|reducesink
operator|.
name|VectorReduceSinkMultiKeyOperator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|vector
operator|.
name|reducesink
operator|.
name|VectorReduceSinkStringOperator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|vector
operator|.
name|udf
operator|.
name|VectorUDFAdaptor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|vector
operator|.
name|ColumnVector
operator|.
name|Type
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|vector
operator|.
name|VectorColumnOutputMapping
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|vector
operator|.
name|VectorColumnSourceMapping
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|vector
operator|.
name|VectorMapJoinOperator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|vector
operator|.
name|VectorMapJoinOuterFilteredOperator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|vector
operator|.
name|VectorizationContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|vector
operator|.
name|VectorizationContext
operator|.
name|HiveVectorAdaptorUsageMode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|vector
operator|.
name|VectorizationContext
operator|.
name|InConstantType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|vector
operator|.
name|VectorizationContextRegion
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|vector
operator|.
name|expressions
operator|.
name|IdentityExpression
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|vector
operator|.
name|expressions
operator|.
name|VectorExpression
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|vector
operator|.
name|expressions
operator|.
name|aggregates
operator|.
name|VectorAggregateExpression
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|io
operator|.
name|orc
operator|.
name|OrcInputFormat
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|vector
operator|.
name|VectorizedRowBatchCtx
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|lib
operator|.
name|DefaultGraphWalker
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|lib
operator|.
name|DefaultRuleDispatcher
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|lib
operator|.
name|Dispatcher
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|lib
operator|.
name|GraphWalker
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|lib
operator|.
name|Node
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|lib
operator|.
name|NodeProcessor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|lib
operator|.
name|NodeProcessorCtx
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|lib
operator|.
name|PreOrderOnceWalker
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|lib
operator|.
name|PreOrderWalker
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|lib
operator|.
name|Rule
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|lib
operator|.
name|RuleRegExp
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|lib
operator|.
name|TaskGraphWalker
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|metadata
operator|.
name|HiveException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|metadata
operator|.
name|VirtualColumn
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|parse
operator|.
name|SemanticException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|AbstractOperatorDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|AggregationDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|AppMasterEventDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|BaseWork
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|Explain
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|ExprNodeColumnDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|ExprNodeDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|ExprNodeGenericFuncDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|FileSinkDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|FilterDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|GroupByDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|JoinDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|LimitDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|MapJoinDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|MapWork
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|MapredWork
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|OperatorDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|SelectDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|VectorAppMasterEventDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|VectorFileSinkDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|VectorFilterDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|VectorTableScanDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|VectorizationCondition
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|VectorGroupByDesc
operator|.
name|ProcessingMode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|VectorSparkHashTableSinkDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|VectorSparkPartitionPruningSinkDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|VectorLimitDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|VectorMapJoinInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|VectorSMBJoinDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|PartitionDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|ReduceSinkDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|ReduceWork
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|SMBJoinDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|SparkHashTableSinkDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|optimizer
operator|.
name|spark
operator|.
name|SparkPartitionPruningSinkDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|SparkWork
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|TableDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|TableScanDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|TezWork
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|VectorGroupByDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|VectorMapJoinDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|VectorMapJoinDesc
operator|.
name|HashTableImplementationType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|VectorMapJoinDesc
operator|.
name|HashTableKeyType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|VectorMapJoinDesc
operator|.
name|HashTableKind
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|VectorMapJoinDesc
operator|.
name|OperatorVariation
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|VectorPartitionDesc
operator|.
name|VectorDeserializeType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|VectorReduceSinkDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|VectorReduceSinkInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|VectorPartitionDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|VectorSelectDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|api
operator|.
name|OperatorType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|udf
operator|.
name|UDFAcos
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|udf
operator|.
name|UDFAsin
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|udf
operator|.
name|UDFAtan
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|udf
operator|.
name|UDFBin
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|udf
operator|.
name|UDFConv
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|udf
operator|.
name|UDFCos
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|udf
operator|.
name|UDFDayOfMonth
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|udf
operator|.
name|UDFDayOfWeek
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|udf
operator|.
name|UDFDegrees
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|udf
operator|.
name|UDFExp
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|udf
operator|.
name|UDFFromUnixTime
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|udf
operator|.
name|UDFHex
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|udf
operator|.
name|UDFHour
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|udf
operator|.
name|UDFLike
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|udf
operator|.
name|UDFLn
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|udf
operator|.
name|UDFLog
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|udf
operator|.
name|UDFLog10
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|udf
operator|.
name|UDFLog2
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|udf
operator|.
name|UDFMinute
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|udf
operator|.
name|UDFMonth
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|udf
operator|.
name|UDFRadians
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|udf
operator|.
name|UDFRand
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|udf
operator|.
name|UDFRegExpExtract
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|udf
operator|.
name|UDFRegExpReplace
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|udf
operator|.
name|UDFSecond
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|udf
operator|.
name|UDFSign
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|udf
operator|.
name|UDFSin
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|udf
operator|.
name|UDFSqrt
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|udf
operator|.
name|UDFSubstr
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|udf
operator|.
name|UDFTan
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|udf
operator|.
name|UDFToBoolean
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|udf
operator|.
name|UDFToByte
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|udf
operator|.
name|UDFToDouble
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|udf
operator|.
name|UDFToFloat
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|udf
operator|.
name|UDFToInteger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|udf
operator|.
name|UDFToLong
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|udf
operator|.
name|UDFToShort
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|udf
operator|.
name|UDFToString
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|udf
operator|.
name|UDFWeekOfYear
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|udf
operator|.
name|UDFYear
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|udf
operator|.
name|generic
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde
operator|.
name|serdeConstants
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|Deserializer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|NullStructSerDe
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|SerDeUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|lazy
operator|.
name|LazySimpleSerDe
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|lazybinary
operator|.
name|LazyBinarySerDe
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|objectinspector
operator|.
name|ObjectInspector
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|objectinspector
operator|.
name|ObjectInspector
operator|.
name|Category
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|objectinspector
operator|.
name|ObjectInspectorUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|objectinspector
operator|.
name|PrimitiveObjectInspector
operator|.
name|PrimitiveCategory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|objectinspector
operator|.
name|StructField
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|objectinspector
operator|.
name|StructObjectInspector
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|typeinfo
operator|.
name|PrimitiveTypeInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|typeinfo
operator|.
name|StructTypeInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|typeinfo
operator|.
name|TypeInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|typeinfo
operator|.
name|TypeInfoUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapred
operator|.
name|SequenceFileInputFormat
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapred
operator|.
name|TextInputFormat
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hive
operator|.
name|common
operator|.
name|util
operator|.
name|AnnotationUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|ReflectionUtils
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
import|;
end_import

begin_class
specifier|public
class|class
name|Vectorizer
implements|implements
name|PhysicalPlanResolver
block|{
specifier|protected
specifier|static
specifier|transient
specifier|final
name|Logger
name|LOG
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|Vectorizer
operator|.
name|class
argument_list|)
decl_stmt|;
specifier|static
name|Pattern
name|supportedDataTypesPattern
decl_stmt|;
static|static
block|{
name|StringBuilder
name|patternBuilder
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|patternBuilder
operator|.
name|append
argument_list|(
literal|"int"
argument_list|)
expr_stmt|;
name|patternBuilder
operator|.
name|append
argument_list|(
literal|"|smallint"
argument_list|)
expr_stmt|;
name|patternBuilder
operator|.
name|append
argument_list|(
literal|"|tinyint"
argument_list|)
expr_stmt|;
name|patternBuilder
operator|.
name|append
argument_list|(
literal|"|bigint"
argument_list|)
expr_stmt|;
name|patternBuilder
operator|.
name|append
argument_list|(
literal|"|integer"
argument_list|)
expr_stmt|;
name|patternBuilder
operator|.
name|append
argument_list|(
literal|"|long"
argument_list|)
expr_stmt|;
name|patternBuilder
operator|.
name|append
argument_list|(
literal|"|short"
argument_list|)
expr_stmt|;
name|patternBuilder
operator|.
name|append
argument_list|(
literal|"|timestamp"
argument_list|)
expr_stmt|;
name|patternBuilder
operator|.
name|append
argument_list|(
literal|"|"
operator|+
name|serdeConstants
operator|.
name|INTERVAL_YEAR_MONTH_TYPE_NAME
argument_list|)
expr_stmt|;
name|patternBuilder
operator|.
name|append
argument_list|(
literal|"|"
operator|+
name|serdeConstants
operator|.
name|INTERVAL_DAY_TIME_TYPE_NAME
argument_list|)
expr_stmt|;
name|patternBuilder
operator|.
name|append
argument_list|(
literal|"|boolean"
argument_list|)
expr_stmt|;
name|patternBuilder
operator|.
name|append
argument_list|(
literal|"|binary"
argument_list|)
expr_stmt|;
name|patternBuilder
operator|.
name|append
argument_list|(
literal|"|string"
argument_list|)
expr_stmt|;
name|patternBuilder
operator|.
name|append
argument_list|(
literal|"|byte"
argument_list|)
expr_stmt|;
name|patternBuilder
operator|.
name|append
argument_list|(
literal|"|float"
argument_list|)
expr_stmt|;
name|patternBuilder
operator|.
name|append
argument_list|(
literal|"|double"
argument_list|)
expr_stmt|;
name|patternBuilder
operator|.
name|append
argument_list|(
literal|"|date"
argument_list|)
expr_stmt|;
name|patternBuilder
operator|.
name|append
argument_list|(
literal|"|void"
argument_list|)
expr_stmt|;
comment|// Decimal types can be specified with different precision and scales e.g. decimal(10,5),
comment|// as opposed to other data types which can be represented by constant strings.
comment|// The regex matches only the "decimal" prefix of the type.
name|patternBuilder
operator|.
name|append
argument_list|(
literal|"|decimal.*"
argument_list|)
expr_stmt|;
comment|// CHAR and VARCHAR types can be specified with maximum length.
name|patternBuilder
operator|.
name|append
argument_list|(
literal|"|char.*"
argument_list|)
expr_stmt|;
name|patternBuilder
operator|.
name|append
argument_list|(
literal|"|varchar.*"
argument_list|)
expr_stmt|;
name|supportedDataTypesPattern
operator|=
name|Pattern
operator|.
name|compile
argument_list|(
name|patternBuilder
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
specifier|private
name|Set
argument_list|<
name|Class
argument_list|<
name|?
argument_list|>
argument_list|>
name|supportedGenericUDFs
init|=
operator|new
name|HashSet
argument_list|<
name|Class
argument_list|<
name|?
argument_list|>
argument_list|>
argument_list|()
decl_stmt|;
specifier|private
name|Set
argument_list|<
name|String
argument_list|>
name|supportedAggregationUdfs
init|=
operator|new
name|HashSet
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
specifier|private
name|HiveConf
name|hiveConf
decl_stmt|;
specifier|private
name|boolean
name|useVectorizedInputFileFormat
decl_stmt|;
specifier|private
name|boolean
name|useVectorDeserialize
decl_stmt|;
specifier|private
name|boolean
name|useRowDeserialize
decl_stmt|;
specifier|private
name|boolean
name|isReduceVectorizationEnabled
decl_stmt|;
specifier|private
name|boolean
name|isSchemaEvolution
decl_stmt|;
specifier|private
name|HiveVectorAdaptorUsageMode
name|hiveVectorAdaptorUsageMode
decl_stmt|;
specifier|private
name|BaseWork
name|currentBaseWork
decl_stmt|;
specifier|private
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
name|currentOperator
decl_stmt|;
specifier|public
name|void
name|testSetCurrentBaseWork
parameter_list|(
name|BaseWork
name|testBaseWork
parameter_list|)
block|{
name|currentBaseWork
operator|=
name|testBaseWork
expr_stmt|;
block|}
specifier|private
name|void
name|setNodeIssue
parameter_list|(
name|String
name|issue
parameter_list|)
block|{
name|currentBaseWork
operator|.
name|setNotVectorizedReason
argument_list|(
name|VectorizerReason
operator|.
name|createNodeIssue
argument_list|(
name|issue
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|setOperatorIssue
parameter_list|(
name|String
name|issue
parameter_list|)
block|{
name|currentBaseWork
operator|.
name|setNotVectorizedReason
argument_list|(
name|VectorizerReason
operator|.
name|createOperatorIssue
argument_list|(
name|currentOperator
argument_list|,
name|issue
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|setExpressionIssue
parameter_list|(
name|String
name|expressionTitle
parameter_list|,
name|String
name|issue
parameter_list|)
block|{
name|currentBaseWork
operator|.
name|setNotVectorizedReason
argument_list|(
name|VectorizerReason
operator|.
name|createExpressionIssue
argument_list|(
name|currentOperator
argument_list|,
name|expressionTitle
argument_list|,
name|issue
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|clearNotVectorizedReason
parameter_list|()
block|{
name|currentBaseWork
operator|.
name|setNotVectorizedReason
argument_list|(
literal|null
argument_list|)
expr_stmt|;
block|}
specifier|private
name|long
name|vectorizedVertexNum
init|=
operator|-
literal|1
decl_stmt|;
specifier|public
name|Vectorizer
parameter_list|()
block|{
comment|/*      * We check UDFs against the supportedGenericUDFs when      * hive.vectorized.adaptor.usage.mode=chosen or none.      *      * We allow all UDFs for hive.vectorized.adaptor.usage.mode=all.      */
name|supportedGenericUDFs
operator|.
name|add
argument_list|(
name|GenericUDFOPPlus
operator|.
name|class
argument_list|)
expr_stmt|;
name|supportedGenericUDFs
operator|.
name|add
argument_list|(
name|GenericUDFOPMinus
operator|.
name|class
argument_list|)
expr_stmt|;
name|supportedGenericUDFs
operator|.
name|add
argument_list|(
name|GenericUDFOPMultiply
operator|.
name|class
argument_list|)
expr_stmt|;
name|supportedGenericUDFs
operator|.
name|add
argument_list|(
name|GenericUDFOPDivide
operator|.
name|class
argument_list|)
expr_stmt|;
name|supportedGenericUDFs
operator|.
name|add
argument_list|(
name|GenericUDFOPMod
operator|.
name|class
argument_list|)
expr_stmt|;
name|supportedGenericUDFs
operator|.
name|add
argument_list|(
name|GenericUDFOPNegative
operator|.
name|class
argument_list|)
expr_stmt|;
name|supportedGenericUDFs
operator|.
name|add
argument_list|(
name|GenericUDFOPPositive
operator|.
name|class
argument_list|)
expr_stmt|;
name|supportedGenericUDFs
operator|.
name|add
argument_list|(
name|GenericUDFOPEqualOrLessThan
operator|.
name|class
argument_list|)
expr_stmt|;
name|supportedGenericUDFs
operator|.
name|add
argument_list|(
name|GenericUDFOPEqualOrGreaterThan
operator|.
name|class
argument_list|)
expr_stmt|;
name|supportedGenericUDFs
operator|.
name|add
argument_list|(
name|GenericUDFOPGreaterThan
operator|.
name|class
argument_list|)
expr_stmt|;
name|supportedGenericUDFs
operator|.
name|add
argument_list|(
name|GenericUDFOPLessThan
operator|.
name|class
argument_list|)
expr_stmt|;
name|supportedGenericUDFs
operator|.
name|add
argument_list|(
name|GenericUDFOPNot
operator|.
name|class
argument_list|)
expr_stmt|;
name|supportedGenericUDFs
operator|.
name|add
argument_list|(
name|GenericUDFOPNotEqual
operator|.
name|class
argument_list|)
expr_stmt|;
name|supportedGenericUDFs
operator|.
name|add
argument_list|(
name|GenericUDFOPNotNull
operator|.
name|class
argument_list|)
expr_stmt|;
name|supportedGenericUDFs
operator|.
name|add
argument_list|(
name|GenericUDFOPNull
operator|.
name|class
argument_list|)
expr_stmt|;
name|supportedGenericUDFs
operator|.
name|add
argument_list|(
name|GenericUDFOPOr
operator|.
name|class
argument_list|)
expr_stmt|;
name|supportedGenericUDFs
operator|.
name|add
argument_list|(
name|GenericUDFOPAnd
operator|.
name|class
argument_list|)
expr_stmt|;
name|supportedGenericUDFs
operator|.
name|add
argument_list|(
name|GenericUDFOPEqual
operator|.
name|class
argument_list|)
expr_stmt|;
name|supportedGenericUDFs
operator|.
name|add
argument_list|(
name|GenericUDFLength
operator|.
name|class
argument_list|)
expr_stmt|;
name|supportedGenericUDFs
operator|.
name|add
argument_list|(
name|GenericUDFCharacterLength
operator|.
name|class
argument_list|)
expr_stmt|;
name|supportedGenericUDFs
operator|.
name|add
argument_list|(
name|GenericUDFOctetLength
operator|.
name|class
argument_list|)
expr_stmt|;
name|supportedGenericUDFs
operator|.
name|add
argument_list|(
name|UDFYear
operator|.
name|class
argument_list|)
expr_stmt|;
name|supportedGenericUDFs
operator|.
name|add
argument_list|(
name|UDFMonth
operator|.
name|class
argument_list|)
expr_stmt|;
name|supportedGenericUDFs
operator|.
name|add
argument_list|(
name|UDFDayOfMonth
operator|.
name|class
argument_list|)
expr_stmt|;
name|supportedGenericUDFs
operator|.
name|add
argument_list|(
name|UDFDayOfWeek
operator|.
name|class
argument_list|)
expr_stmt|;
name|supportedGenericUDFs
operator|.
name|add
argument_list|(
name|UDFHour
operator|.
name|class
argument_list|)
expr_stmt|;
name|supportedGenericUDFs
operator|.
name|add
argument_list|(
name|UDFMinute
operator|.
name|class
argument_list|)
expr_stmt|;
name|supportedGenericUDFs
operator|.
name|add
argument_list|(
name|UDFSecond
operator|.
name|class
argument_list|)
expr_stmt|;
name|supportedGenericUDFs
operator|.
name|add
argument_list|(
name|UDFWeekOfYear
operator|.
name|class
argument_list|)
expr_stmt|;
name|supportedGenericUDFs
operator|.
name|add
argument_list|(
name|GenericUDFToUnixTimeStamp
operator|.
name|class
argument_list|)
expr_stmt|;
name|supportedGenericUDFs
operator|.
name|add
argument_list|(
name|UDFFromUnixTime
operator|.
name|class
argument_list|)
expr_stmt|;
name|supportedGenericUDFs
operator|.
name|add
argument_list|(
name|GenericUDFDateAdd
operator|.
name|class
argument_list|)
expr_stmt|;
name|supportedGenericUDFs
operator|.
name|add
argument_list|(
name|GenericUDFDateSub
operator|.
name|class
argument_list|)
expr_stmt|;
name|supportedGenericUDFs
operator|.
name|add
argument_list|(
name|GenericUDFDate
operator|.
name|class
argument_list|)
expr_stmt|;
name|supportedGenericUDFs
operator|.
name|add
argument_list|(
name|GenericUDFDateDiff
operator|.
name|class
argument_list|)
expr_stmt|;
name|supportedGenericUDFs
operator|.
name|add
argument_list|(
name|UDFLike
operator|.
name|class
argument_list|)
expr_stmt|;
name|supportedGenericUDFs
operator|.
name|add
argument_list|(
name|GenericUDFRegExp
operator|.
name|class
argument_list|)
expr_stmt|;
name|supportedGenericUDFs
operator|.
name|add
argument_list|(
name|UDFRegExpExtract
operator|.
name|class
argument_list|)
expr_stmt|;
name|supportedGenericUDFs
operator|.
name|add
argument_list|(
name|UDFRegExpReplace
operator|.
name|class
argument_list|)
expr_stmt|;
name|supportedGenericUDFs
operator|.
name|add
argument_list|(
name|UDFSubstr
operator|.
name|class
argument_list|)
expr_stmt|;
name|supportedGenericUDFs
operator|.
name|add
argument_list|(
name|GenericUDFLTrim
operator|.
name|class
argument_list|)
expr_stmt|;
name|supportedGenericUDFs
operator|.
name|add
argument_list|(
name|GenericUDFRTrim
operator|.
name|class
argument_list|)
expr_stmt|;
name|supportedGenericUDFs
operator|.
name|add
argument_list|(
name|GenericUDFTrim
operator|.
name|class
argument_list|)
expr_stmt|;
name|supportedGenericUDFs
operator|.
name|add
argument_list|(
name|UDFSin
operator|.
name|class
argument_list|)
expr_stmt|;
name|supportedGenericUDFs
operator|.
name|add
argument_list|(
name|UDFCos
operator|.
name|class
argument_list|)
expr_stmt|;
name|supportedGenericUDFs
operator|.
name|add
argument_list|(
name|UDFTan
operator|.
name|class
argument_list|)
expr_stmt|;
name|supportedGenericUDFs
operator|.
name|add
argument_list|(
name|UDFAsin
operator|.
name|class
argument_list|)
expr_stmt|;
name|supportedGenericUDFs
operator|.
name|add
argument_list|(
name|UDFAcos
operator|.
name|class
argument_list|)
expr_stmt|;
name|supportedGenericUDFs
operator|.
name|add
argument_list|(
name|UDFAtan
operator|.
name|class
argument_list|)
expr_stmt|;
name|supportedGenericUDFs
operator|.
name|add
argument_list|(
name|UDFDegrees
operator|.
name|class
argument_list|)
expr_stmt|;
name|supportedGenericUDFs
operator|.
name|add
argument_list|(
name|UDFRadians
operator|.
name|class
argument_list|)
expr_stmt|;
name|supportedGenericUDFs
operator|.
name|add
argument_list|(
name|GenericUDFFloor
operator|.
name|class
argument_list|)
expr_stmt|;
name|supportedGenericUDFs
operator|.
name|add
argument_list|(
name|GenericUDFCeil
operator|.
name|class
argument_list|)
expr_stmt|;
name|supportedGenericUDFs
operator|.
name|add
argument_list|(
name|UDFExp
operator|.
name|class
argument_list|)
expr_stmt|;
name|supportedGenericUDFs
operator|.
name|add
argument_list|(
name|UDFLn
operator|.
name|class
argument_list|)
expr_stmt|;
name|supportedGenericUDFs
operator|.
name|add
argument_list|(
name|UDFLog2
operator|.
name|class
argument_list|)
expr_stmt|;
name|supportedGenericUDFs
operator|.
name|add
argument_list|(
name|UDFLog10
operator|.
name|class
argument_list|)
expr_stmt|;
name|supportedGenericUDFs
operator|.
name|add
argument_list|(
name|UDFLog
operator|.
name|class
argument_list|)
expr_stmt|;
name|supportedGenericUDFs
operator|.
name|add
argument_list|(
name|GenericUDFPower
operator|.
name|class
argument_list|)
expr_stmt|;
name|supportedGenericUDFs
operator|.
name|add
argument_list|(
name|GenericUDFRound
operator|.
name|class
argument_list|)
expr_stmt|;
name|supportedGenericUDFs
operator|.
name|add
argument_list|(
name|GenericUDFBRound
operator|.
name|class
argument_list|)
expr_stmt|;
name|supportedGenericUDFs
operator|.
name|add
argument_list|(
name|GenericUDFPosMod
operator|.
name|class
argument_list|)
expr_stmt|;
name|supportedGenericUDFs
operator|.
name|add
argument_list|(
name|UDFSqrt
operator|.
name|class
argument_list|)
expr_stmt|;
name|supportedGenericUDFs
operator|.
name|add
argument_list|(
name|UDFSign
operator|.
name|class
argument_list|)
expr_stmt|;
name|supportedGenericUDFs
operator|.
name|add
argument_list|(
name|UDFRand
operator|.
name|class
argument_list|)
expr_stmt|;
name|supportedGenericUDFs
operator|.
name|add
argument_list|(
name|UDFBin
operator|.
name|class
argument_list|)
expr_stmt|;
name|supportedGenericUDFs
operator|.
name|add
argument_list|(
name|UDFHex
operator|.
name|class
argument_list|)
expr_stmt|;
name|supportedGenericUDFs
operator|.
name|add
argument_list|(
name|UDFConv
operator|.
name|class
argument_list|)
expr_stmt|;
name|supportedGenericUDFs
operator|.
name|add
argument_list|(
name|GenericUDFLower
operator|.
name|class
argument_list|)
expr_stmt|;
name|supportedGenericUDFs
operator|.
name|add
argument_list|(
name|GenericUDFUpper
operator|.
name|class
argument_list|)
expr_stmt|;
name|supportedGenericUDFs
operator|.
name|add
argument_list|(
name|GenericUDFConcat
operator|.
name|class
argument_list|)
expr_stmt|;
name|supportedGenericUDFs
operator|.
name|add
argument_list|(
name|GenericUDFAbs
operator|.
name|class
argument_list|)
expr_stmt|;
name|supportedGenericUDFs
operator|.
name|add
argument_list|(
name|GenericUDFBetween
operator|.
name|class
argument_list|)
expr_stmt|;
name|supportedGenericUDFs
operator|.
name|add
argument_list|(
name|GenericUDFIn
operator|.
name|class
argument_list|)
expr_stmt|;
name|supportedGenericUDFs
operator|.
name|add
argument_list|(
name|GenericUDFCase
operator|.
name|class
argument_list|)
expr_stmt|;
name|supportedGenericUDFs
operator|.
name|add
argument_list|(
name|GenericUDFWhen
operator|.
name|class
argument_list|)
expr_stmt|;
name|supportedGenericUDFs
operator|.
name|add
argument_list|(
name|GenericUDFCoalesce
operator|.
name|class
argument_list|)
expr_stmt|;
name|supportedGenericUDFs
operator|.
name|add
argument_list|(
name|GenericUDFNvl
operator|.
name|class
argument_list|)
expr_stmt|;
name|supportedGenericUDFs
operator|.
name|add
argument_list|(
name|GenericUDFElt
operator|.
name|class
argument_list|)
expr_stmt|;
name|supportedGenericUDFs
operator|.
name|add
argument_list|(
name|GenericUDFInitCap
operator|.
name|class
argument_list|)
expr_stmt|;
name|supportedGenericUDFs
operator|.
name|add
argument_list|(
name|GenericUDFInBloomFilter
operator|.
name|class
argument_list|)
expr_stmt|;
comment|// For type casts
name|supportedGenericUDFs
operator|.
name|add
argument_list|(
name|UDFToLong
operator|.
name|class
argument_list|)
expr_stmt|;
name|supportedGenericUDFs
operator|.
name|add
argument_list|(
name|UDFToInteger
operator|.
name|class
argument_list|)
expr_stmt|;
name|supportedGenericUDFs
operator|.
name|add
argument_list|(
name|UDFToShort
operator|.
name|class
argument_list|)
expr_stmt|;
name|supportedGenericUDFs
operator|.
name|add
argument_list|(
name|UDFToByte
operator|.
name|class
argument_list|)
expr_stmt|;
name|supportedGenericUDFs
operator|.
name|add
argument_list|(
name|UDFToBoolean
operator|.
name|class
argument_list|)
expr_stmt|;
name|supportedGenericUDFs
operator|.
name|add
argument_list|(
name|UDFToFloat
operator|.
name|class
argument_list|)
expr_stmt|;
name|supportedGenericUDFs
operator|.
name|add
argument_list|(
name|UDFToDouble
operator|.
name|class
argument_list|)
expr_stmt|;
name|supportedGenericUDFs
operator|.
name|add
argument_list|(
name|UDFToString
operator|.
name|class
argument_list|)
expr_stmt|;
name|supportedGenericUDFs
operator|.
name|add
argument_list|(
name|GenericUDFTimestamp
operator|.
name|class
argument_list|)
expr_stmt|;
name|supportedGenericUDFs
operator|.
name|add
argument_list|(
name|GenericUDFToDecimal
operator|.
name|class
argument_list|)
expr_stmt|;
name|supportedGenericUDFs
operator|.
name|add
argument_list|(
name|GenericUDFToDate
operator|.
name|class
argument_list|)
expr_stmt|;
name|supportedGenericUDFs
operator|.
name|add
argument_list|(
name|GenericUDFToChar
operator|.
name|class
argument_list|)
expr_stmt|;
name|supportedGenericUDFs
operator|.
name|add
argument_list|(
name|GenericUDFToVarchar
operator|.
name|class
argument_list|)
expr_stmt|;
name|supportedGenericUDFs
operator|.
name|add
argument_list|(
name|GenericUDFToIntervalYearMonth
operator|.
name|class
argument_list|)
expr_stmt|;
name|supportedGenericUDFs
operator|.
name|add
argument_list|(
name|GenericUDFToIntervalDayTime
operator|.
name|class
argument_list|)
expr_stmt|;
comment|// For conditional expressions
name|supportedGenericUDFs
operator|.
name|add
argument_list|(
name|GenericUDFIf
operator|.
name|class
argument_list|)
expr_stmt|;
name|supportedAggregationUdfs
operator|.
name|add
argument_list|(
literal|"min"
argument_list|)
expr_stmt|;
name|supportedAggregationUdfs
operator|.
name|add
argument_list|(
literal|"max"
argument_list|)
expr_stmt|;
name|supportedAggregationUdfs
operator|.
name|add
argument_list|(
literal|"count"
argument_list|)
expr_stmt|;
name|supportedAggregationUdfs
operator|.
name|add
argument_list|(
literal|"sum"
argument_list|)
expr_stmt|;
name|supportedAggregationUdfs
operator|.
name|add
argument_list|(
literal|"avg"
argument_list|)
expr_stmt|;
name|supportedAggregationUdfs
operator|.
name|add
argument_list|(
literal|"variance"
argument_list|)
expr_stmt|;
name|supportedAggregationUdfs
operator|.
name|add
argument_list|(
literal|"var_pop"
argument_list|)
expr_stmt|;
name|supportedAggregationUdfs
operator|.
name|add
argument_list|(
literal|"var_samp"
argument_list|)
expr_stmt|;
name|supportedAggregationUdfs
operator|.
name|add
argument_list|(
literal|"std"
argument_list|)
expr_stmt|;
name|supportedAggregationUdfs
operator|.
name|add
argument_list|(
literal|"stddev"
argument_list|)
expr_stmt|;
name|supportedAggregationUdfs
operator|.
name|add
argument_list|(
literal|"stddev_pop"
argument_list|)
expr_stmt|;
name|supportedAggregationUdfs
operator|.
name|add
argument_list|(
literal|"stddev_samp"
argument_list|)
expr_stmt|;
name|supportedAggregationUdfs
operator|.
name|add
argument_list|(
literal|"bloom_filter"
argument_list|)
expr_stmt|;
block|}
specifier|private
class|class
name|VectorTaskColumnInfo
block|{
name|List
argument_list|<
name|String
argument_list|>
name|allColumnNames
decl_stmt|;
name|List
argument_list|<
name|TypeInfo
argument_list|>
name|allTypeInfos
decl_stmt|;
name|List
argument_list|<
name|Integer
argument_list|>
name|dataColumnNums
decl_stmt|;
name|int
name|partitionColumnCount
decl_stmt|;
name|boolean
name|useVectorizedInputFileFormat
decl_stmt|;
name|boolean
name|groupByVectorOutput
decl_stmt|;
name|boolean
name|allNative
decl_stmt|;
name|boolean
name|usesVectorUDFAdaptor
decl_stmt|;
name|String
index|[]
name|scratchTypeNameArray
decl_stmt|;
name|Set
argument_list|<
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
argument_list|>
name|nonVectorizedOps
decl_stmt|;
name|VectorTaskColumnInfo
parameter_list|()
block|{
name|partitionColumnCount
operator|=
literal|0
expr_stmt|;
block|}
specifier|public
name|void
name|assume
parameter_list|()
block|{
name|groupByVectorOutput
operator|=
literal|true
expr_stmt|;
name|allNative
operator|=
literal|true
expr_stmt|;
name|usesVectorUDFAdaptor
operator|=
literal|false
expr_stmt|;
block|}
specifier|public
name|void
name|setAllColumnNames
parameter_list|(
name|List
argument_list|<
name|String
argument_list|>
name|allColumnNames
parameter_list|)
block|{
name|this
operator|.
name|allColumnNames
operator|=
name|allColumnNames
expr_stmt|;
block|}
specifier|public
name|void
name|setAllTypeInfos
parameter_list|(
name|List
argument_list|<
name|TypeInfo
argument_list|>
name|allTypeInfos
parameter_list|)
block|{
name|this
operator|.
name|allTypeInfos
operator|=
name|allTypeInfos
expr_stmt|;
block|}
specifier|public
name|void
name|setDataColumnNums
parameter_list|(
name|List
argument_list|<
name|Integer
argument_list|>
name|dataColumnNums
parameter_list|)
block|{
name|this
operator|.
name|dataColumnNums
operator|=
name|dataColumnNums
expr_stmt|;
block|}
specifier|public
name|void
name|setPartitionColumnCount
parameter_list|(
name|int
name|partitionColumnCount
parameter_list|)
block|{
name|this
operator|.
name|partitionColumnCount
operator|=
name|partitionColumnCount
expr_stmt|;
block|}
specifier|public
name|void
name|setScratchTypeNameArray
parameter_list|(
name|String
index|[]
name|scratchTypeNameArray
parameter_list|)
block|{
name|this
operator|.
name|scratchTypeNameArray
operator|=
name|scratchTypeNameArray
expr_stmt|;
block|}
specifier|public
name|void
name|setGroupByVectorOutput
parameter_list|(
name|boolean
name|groupByVectorOutput
parameter_list|)
block|{
name|this
operator|.
name|groupByVectorOutput
operator|=
name|groupByVectorOutput
expr_stmt|;
block|}
specifier|public
name|void
name|setAllNative
parameter_list|(
name|boolean
name|allNative
parameter_list|)
block|{
name|this
operator|.
name|allNative
operator|=
name|allNative
expr_stmt|;
block|}
specifier|public
name|void
name|setUsesVectorUDFAdaptor
parameter_list|(
name|boolean
name|usesVectorUDFAdaptor
parameter_list|)
block|{
name|this
operator|.
name|usesVectorUDFAdaptor
operator|=
name|usesVectorUDFAdaptor
expr_stmt|;
block|}
specifier|public
name|void
name|setUseVectorizedInputFileFormat
parameter_list|(
name|boolean
name|useVectorizedInputFileFormat
parameter_list|)
block|{
name|this
operator|.
name|useVectorizedInputFileFormat
operator|=
name|useVectorizedInputFileFormat
expr_stmt|;
block|}
specifier|public
name|void
name|setNonVectorizedOps
parameter_list|(
name|Set
argument_list|<
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
argument_list|>
name|nonVectorizedOps
parameter_list|)
block|{
name|this
operator|.
name|nonVectorizedOps
operator|=
name|nonVectorizedOps
expr_stmt|;
block|}
specifier|public
name|Set
argument_list|<
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
argument_list|>
name|getNonVectorizedOps
parameter_list|()
block|{
return|return
name|nonVectorizedOps
return|;
block|}
specifier|public
name|void
name|transferToBaseWork
parameter_list|(
name|BaseWork
name|baseWork
parameter_list|)
block|{
name|String
index|[]
name|allColumnNameArray
init|=
name|allColumnNames
operator|.
name|toArray
argument_list|(
operator|new
name|String
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
name|TypeInfo
index|[]
name|allTypeInfoArray
init|=
name|allTypeInfos
operator|.
name|toArray
argument_list|(
operator|new
name|TypeInfo
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
name|int
index|[]
name|dataColumnNumsArray
decl_stmt|;
if|if
condition|(
name|dataColumnNums
operator|!=
literal|null
condition|)
block|{
name|dataColumnNumsArray
operator|=
name|ArrayUtils
operator|.
name|toPrimitive
argument_list|(
name|dataColumnNums
operator|.
name|toArray
argument_list|(
operator|new
name|Integer
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|dataColumnNumsArray
operator|=
literal|null
expr_stmt|;
block|}
name|VectorizedRowBatchCtx
name|vectorizedRowBatchCtx
init|=
operator|new
name|VectorizedRowBatchCtx
argument_list|(
name|allColumnNameArray
argument_list|,
name|allTypeInfoArray
argument_list|,
name|dataColumnNumsArray
argument_list|,
name|partitionColumnCount
argument_list|,
name|scratchTypeNameArray
argument_list|)
decl_stmt|;
name|baseWork
operator|.
name|setVectorizedRowBatchCtx
argument_list|(
name|vectorizedRowBatchCtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|baseWork
operator|instanceof
name|MapWork
condition|)
block|{
name|MapWork
name|mapWork
init|=
operator|(
name|MapWork
operator|)
name|baseWork
decl_stmt|;
name|mapWork
operator|.
name|setUseVectorizedInputFileFormat
argument_list|(
name|useVectorizedInputFileFormat
argument_list|)
expr_stmt|;
block|}
name|baseWork
operator|.
name|setAllNative
argument_list|(
name|allNative
argument_list|)
expr_stmt|;
name|baseWork
operator|.
name|setGroupByVectorOutput
argument_list|(
name|groupByVectorOutput
argument_list|)
expr_stmt|;
name|baseWork
operator|.
name|setUsesVectorUDFAdaptor
argument_list|(
name|usesVectorUDFAdaptor
argument_list|)
expr_stmt|;
block|}
block|}
class|class
name|VectorizationDispatcher
implements|implements
name|Dispatcher
block|{
annotation|@
name|Override
specifier|public
name|Object
name|dispatch
parameter_list|(
name|Node
name|nd
parameter_list|,
name|Stack
argument_list|<
name|Node
argument_list|>
name|stack
parameter_list|,
name|Object
modifier|...
name|nodeOutputs
parameter_list|)
throws|throws
name|SemanticException
block|{
name|Task
argument_list|<
name|?
extends|extends
name|Serializable
argument_list|>
name|currTask
init|=
operator|(
name|Task
argument_list|<
name|?
extends|extends
name|Serializable
argument_list|>
operator|)
name|nd
decl_stmt|;
if|if
condition|(
name|currTask
operator|instanceof
name|MapRedTask
condition|)
block|{
name|MapredWork
name|mapredWork
init|=
operator|(
operator|(
name|MapRedTask
operator|)
name|currTask
operator|)
operator|.
name|getWork
argument_list|()
decl_stmt|;
name|convertMapWork
argument_list|(
name|mapredWork
operator|.
name|getMapWork
argument_list|()
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|ReduceWork
name|reduceWork
init|=
name|mapredWork
operator|.
name|getReduceWork
argument_list|()
decl_stmt|;
if|if
condition|(
name|reduceWork
operator|!=
literal|null
condition|)
block|{
comment|// Always set the EXPLAIN conditions.
name|setReduceWorkExplainConditions
argument_list|(
name|reduceWork
argument_list|)
expr_stmt|;
comment|// We do not vectorize MR Reduce.
block|}
block|}
elseif|else
if|if
condition|(
name|currTask
operator|instanceof
name|TezTask
condition|)
block|{
name|TezWork
name|work
init|=
operator|(
operator|(
name|TezTask
operator|)
name|currTask
operator|)
operator|.
name|getWork
argument_list|()
decl_stmt|;
for|for
control|(
name|BaseWork
name|baseWork
range|:
name|work
operator|.
name|getAllWork
argument_list|()
control|)
block|{
if|if
condition|(
name|baseWork
operator|instanceof
name|MapWork
condition|)
block|{
name|convertMapWork
argument_list|(
operator|(
name|MapWork
operator|)
name|baseWork
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|baseWork
operator|instanceof
name|ReduceWork
condition|)
block|{
name|ReduceWork
name|reduceWork
init|=
operator|(
name|ReduceWork
operator|)
name|baseWork
decl_stmt|;
comment|// Always set the EXPLAIN conditions.
name|setReduceWorkExplainConditions
argument_list|(
name|reduceWork
argument_list|)
expr_stmt|;
comment|// We are only vectorizing Reduce under Tez/Spark.
if|if
condition|(
name|isReduceVectorizationEnabled
condition|)
block|{
name|convertReduceWork
argument_list|(
name|reduceWork
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|currTask
operator|instanceof
name|SparkTask
condition|)
block|{
name|SparkWork
name|sparkWork
init|=
operator|(
name|SparkWork
operator|)
name|currTask
operator|.
name|getWork
argument_list|()
decl_stmt|;
for|for
control|(
name|BaseWork
name|baseWork
range|:
name|sparkWork
operator|.
name|getAllWork
argument_list|()
control|)
block|{
if|if
condition|(
name|baseWork
operator|instanceof
name|MapWork
condition|)
block|{
name|convertMapWork
argument_list|(
operator|(
name|MapWork
operator|)
name|baseWork
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|baseWork
operator|instanceof
name|ReduceWork
condition|)
block|{
name|ReduceWork
name|reduceWork
init|=
operator|(
name|ReduceWork
operator|)
name|baseWork
decl_stmt|;
comment|// Always set the EXPLAIN conditions.
name|setReduceWorkExplainConditions
argument_list|(
name|reduceWork
argument_list|)
expr_stmt|;
if|if
condition|(
name|isReduceVectorizationEnabled
condition|)
block|{
name|convertReduceWork
argument_list|(
name|reduceWork
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
return|return
literal|null
return|;
block|}
specifier|private
name|void
name|convertMapWork
parameter_list|(
name|MapWork
name|mapWork
parameter_list|,
name|boolean
name|isTezOrSpark
parameter_list|)
throws|throws
name|SemanticException
block|{
name|mapWork
operator|.
name|setVectorizationExamined
argument_list|(
literal|true
argument_list|)
expr_stmt|;
comment|// Global used when setting errors, etc.
name|currentBaseWork
operator|=
name|mapWork
expr_stmt|;
name|VectorTaskColumnInfo
name|vectorTaskColumnInfo
init|=
operator|new
name|VectorTaskColumnInfo
argument_list|()
decl_stmt|;
name|vectorTaskColumnInfo
operator|.
name|assume
argument_list|()
expr_stmt|;
name|mapWork
operator|.
name|setVectorizedVertexNum
argument_list|(
operator|++
name|vectorizedVertexNum
argument_list|)
expr_stmt|;
name|boolean
name|ret
decl_stmt|;
try|try
block|{
name|ret
operator|=
name|validateMapWork
argument_list|(
name|mapWork
argument_list|,
name|vectorTaskColumnInfo
argument_list|,
name|isTezOrSpark
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|String
name|issue
init|=
literal|"exception: "
operator|+
name|VectorizationContext
operator|.
name|getStackTraceAsSingleLine
argument_list|(
name|e
argument_list|)
decl_stmt|;
name|setNodeIssue
argument_list|(
name|issue
argument_list|)
expr_stmt|;
name|ret
operator|=
literal|false
expr_stmt|;
block|}
if|if
condition|(
name|ret
condition|)
block|{
name|vectorizeMapWork
argument_list|(
name|mapWork
argument_list|,
name|vectorTaskColumnInfo
argument_list|,
name|isTezOrSpark
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|currentBaseWork
operator|.
name|getVectorizationEnabled
argument_list|()
condition|)
block|{
name|VectorizerReason
name|notVectorizedReason
init|=
name|currentBaseWork
operator|.
name|getNotVectorizedReason
argument_list|()
decl_stmt|;
if|if
condition|(
name|notVectorizedReason
operator|==
literal|null
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Cannot vectorize: unknown"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Cannot vectorize: "
operator|+
name|notVectorizedReason
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|clearMapWorkVectorDescs
argument_list|(
name|mapWork
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|addMapWorkRules
parameter_list|(
name|Map
argument_list|<
name|Rule
argument_list|,
name|NodeProcessor
argument_list|>
name|opRules
parameter_list|,
name|NodeProcessor
name|np
parameter_list|)
block|{
name|opRules
operator|.
name|put
argument_list|(
operator|new
name|RuleRegExp
argument_list|(
literal|"R1"
argument_list|,
name|TableScanOperator
operator|.
name|getOperatorName
argument_list|()
operator|+
literal|".*"
operator|+
name|FileSinkOperator
operator|.
name|getOperatorName
argument_list|()
argument_list|)
argument_list|,
name|np
argument_list|)
expr_stmt|;
name|opRules
operator|.
name|put
argument_list|(
operator|new
name|RuleRegExp
argument_list|(
literal|"R2"
argument_list|,
name|TableScanOperator
operator|.
name|getOperatorName
argument_list|()
operator|+
literal|".*"
operator|+
name|ReduceSinkOperator
operator|.
name|getOperatorName
argument_list|()
argument_list|)
argument_list|,
name|np
argument_list|)
expr_stmt|;
block|}
comment|/*      * Determine if there is only one TableScanOperator.  Currently in Map vectorization, we do not      * try to vectorize multiple input trees.      */
specifier|private
name|ImmutablePair
argument_list|<
name|String
argument_list|,
name|TableScanOperator
argument_list|>
name|verifyOnlyOneTableScanOperator
parameter_list|(
name|MapWork
name|mapWork
parameter_list|)
block|{
comment|// Eliminate MR plans with more than one TableScanOperator.
name|LinkedHashMap
argument_list|<
name|String
argument_list|,
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
argument_list|>
name|aliasToWork
init|=
name|mapWork
operator|.
name|getAliasToWork
argument_list|()
decl_stmt|;
if|if
condition|(
operator|(
name|aliasToWork
operator|==
literal|null
operator|)
operator|||
operator|(
name|aliasToWork
operator|.
name|size
argument_list|()
operator|==
literal|0
operator|)
condition|)
block|{
name|setNodeIssue
argument_list|(
literal|"Vectorized map work requires work"
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
name|int
name|tableScanCount
init|=
literal|0
decl_stmt|;
name|String
name|alias
init|=
literal|""
decl_stmt|;
name|TableScanOperator
name|tableScanOperator
init|=
literal|null
decl_stmt|;
for|for
control|(
name|Entry
argument_list|<
name|String
argument_list|,
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
argument_list|>
name|entry
range|:
name|aliasToWork
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|Operator
argument_list|<
name|?
argument_list|>
name|op
init|=
name|entry
operator|.
name|getValue
argument_list|()
decl_stmt|;
if|if
condition|(
name|op
operator|==
literal|null
condition|)
block|{
name|setNodeIssue
argument_list|(
literal|"Vectorized map work requires a valid alias"
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
if|if
condition|(
name|op
operator|instanceof
name|TableScanOperator
condition|)
block|{
name|tableScanCount
operator|++
expr_stmt|;
name|alias
operator|=
name|entry
operator|.
name|getKey
argument_list|()
expr_stmt|;
name|tableScanOperator
operator|=
operator|(
name|TableScanOperator
operator|)
name|op
expr_stmt|;
block|}
block|}
if|if
condition|(
name|tableScanCount
operator|>
literal|1
condition|)
block|{
name|setNodeIssue
argument_list|(
literal|"Vectorized map work only works with 1 TableScanOperator"
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
return|return
operator|new
name|ImmutablePair
argument_list|(
name|alias
argument_list|,
name|tableScanOperator
argument_list|)
return|;
block|}
specifier|private
name|void
name|getTableScanOperatorSchemaInfo
parameter_list|(
name|TableScanOperator
name|tableScanOperator
parameter_list|,
name|List
argument_list|<
name|String
argument_list|>
name|logicalColumnNameList
parameter_list|,
name|List
argument_list|<
name|TypeInfo
argument_list|>
name|logicalTypeInfoList
parameter_list|)
block|{
comment|// Add all non-virtual columns to make a vectorization context for
comment|// the TableScan operator.
name|RowSchema
name|rowSchema
init|=
name|tableScanOperator
operator|.
name|getSchema
argument_list|()
decl_stmt|;
for|for
control|(
name|ColumnInfo
name|c
range|:
name|rowSchema
operator|.
name|getSignature
argument_list|()
control|)
block|{
comment|// Validation will later exclude vectorization of virtual columns usage (HIVE-5560).
if|if
condition|(
operator|!
name|isVirtualColumn
argument_list|(
name|c
argument_list|)
condition|)
block|{
name|String
name|columnName
init|=
name|c
operator|.
name|getInternalName
argument_list|()
decl_stmt|;
name|String
name|typeName
init|=
name|c
operator|.
name|getTypeName
argument_list|()
decl_stmt|;
name|TypeInfo
name|typeInfo
init|=
name|TypeInfoUtils
operator|.
name|getTypeInfoFromTypeString
argument_list|(
name|typeName
argument_list|)
decl_stmt|;
name|logicalColumnNameList
operator|.
name|add
argument_list|(
name|columnName
argument_list|)
expr_stmt|;
name|logicalTypeInfoList
operator|.
name|add
argument_list|(
name|typeInfo
argument_list|)
expr_stmt|;
block|}
block|}
block|}
specifier|private
name|void
name|determineDataColumnNums
parameter_list|(
name|TableScanOperator
name|tableScanOperator
parameter_list|,
name|List
argument_list|<
name|String
argument_list|>
name|allColumnNameList
parameter_list|,
name|int
name|dataColumnCount
parameter_list|,
name|List
argument_list|<
name|Integer
argument_list|>
name|dataColumnNums
parameter_list|)
block|{
comment|/*        * The TableScanOperator's needed columns are just the data columns.        */
name|Set
argument_list|<
name|String
argument_list|>
name|neededColumns
init|=
operator|new
name|HashSet
argument_list|<
name|String
argument_list|>
argument_list|(
name|tableScanOperator
operator|.
name|getNeededColumns
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|dataColumnNum
init|=
literal|0
init|;
name|dataColumnNum
operator|<
name|dataColumnCount
condition|;
name|dataColumnNum
operator|++
control|)
block|{
name|String
name|columnName
init|=
name|allColumnNameList
operator|.
name|get
argument_list|(
name|dataColumnNum
argument_list|)
decl_stmt|;
if|if
condition|(
name|neededColumns
operator|.
name|contains
argument_list|(
name|columnName
argument_list|)
condition|)
block|{
name|dataColumnNums
operator|.
name|add
argument_list|(
name|dataColumnNum
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/*      * There are 3 modes of reading for vectorization:      *      *   1) One for the Vectorized Input File Format which returns VectorizedRowBatch as the row.      *      *   2) One for using VectorDeserializeRow to deserialize each row into the VectorizedRowBatch.      *      Currently, these Input File Formats:      *        TEXTFILE      *        SEQUENCEFILE      *      *   3) And one using the regular partition deserializer to get the row object and assigning      *      the row object into the VectorizedRowBatch with VectorAssignRow.      *      This picks up Input File Format not supported by the other two.      */
specifier|private
name|boolean
name|verifyAndSetVectorPartDesc
parameter_list|(
name|PartitionDesc
name|pd
parameter_list|,
name|boolean
name|isAcidTable
parameter_list|,
name|HashSet
argument_list|<
name|String
argument_list|>
name|inputFileFormatClassNameSet
parameter_list|,
name|HashSet
argument_list|<
name|String
argument_list|>
name|enabledConditionsMetSet
parameter_list|,
name|ArrayList
argument_list|<
name|String
argument_list|>
name|enabledConditionsNotMetList
parameter_list|)
block|{
name|String
name|inputFileFormatClassName
init|=
name|pd
operator|.
name|getInputFileFormatClassName
argument_list|()
decl_stmt|;
comment|// Always collect input file formats.
name|inputFileFormatClassNameSet
operator|.
name|add
argument_list|(
name|inputFileFormatClassName
argument_list|)
expr_stmt|;
name|boolean
name|isInputFileFormatVectorized
init|=
name|Utilities
operator|.
name|isInputFileFormatVectorized
argument_list|(
name|pd
argument_list|)
decl_stmt|;
if|if
condition|(
name|isAcidTable
condition|)
block|{
comment|// Today, ACID tables are only ORC and that format is vectorizable.  Verify these
comment|// assumptions.
name|Preconditions
operator|.
name|checkState
argument_list|(
name|isInputFileFormatVectorized
argument_list|)
expr_stmt|;
name|Preconditions
operator|.
name|checkState
argument_list|(
name|inputFileFormatClassName
operator|.
name|equals
argument_list|(
name|OrcInputFormat
operator|.
name|class
operator|.
name|getName
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|useVectorizedInputFileFormat
condition|)
block|{
name|enabledConditionsNotMetList
operator|.
name|add
argument_list|(
literal|"Vectorizing ACID tables requires "
operator|+
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVE_VECTORIZATION_USE_VECTORIZED_INPUT_FILE_FORMAT
operator|.
name|varname
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
name|pd
operator|.
name|setVectorPartitionDesc
argument_list|(
name|VectorPartitionDesc
operator|.
name|createVectorizedInputFileFormat
argument_list|(
name|inputFileFormatClassName
argument_list|,
name|Utilities
operator|.
name|isInputFileFormatSelfDescribing
argument_list|(
name|pd
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|enabledConditionsMetSet
operator|.
name|add
argument_list|(
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVE_VECTORIZATION_USE_VECTORIZED_INPUT_FILE_FORMAT
operator|.
name|varname
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
comment|// Look for Pass-Thru case where InputFileFormat has VectorizedInputFormatInterface
comment|// and reads VectorizedRowBatch as a "row".
if|if
condition|(
name|useVectorizedInputFileFormat
condition|)
block|{
if|if
condition|(
name|isInputFileFormatVectorized
condition|)
block|{
name|pd
operator|.
name|setVectorPartitionDesc
argument_list|(
name|VectorPartitionDesc
operator|.
name|createVectorizedInputFileFormat
argument_list|(
name|inputFileFormatClassName
argument_list|,
name|Utilities
operator|.
name|isInputFileFormatSelfDescribing
argument_list|(
name|pd
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|enabledConditionsMetSet
operator|.
name|add
argument_list|(
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVE_VECTORIZATION_USE_VECTORIZED_INPUT_FILE_FORMAT
operator|.
name|varname
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
comment|// Fall through and look for other options...
block|}
if|if
condition|(
operator|!
name|isSchemaEvolution
condition|)
block|{
name|enabledConditionsNotMetList
operator|.
name|add
argument_list|(
literal|"Vectorizing tables without Schema Evolution requires "
operator|+
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVE_VECTORIZATION_USE_VECTORIZED_INPUT_FILE_FORMAT
operator|.
name|varname
argument_list|)
expr_stmt|;
block|}
name|String
name|deserializerClassName
init|=
name|pd
operator|.
name|getDeserializerClassName
argument_list|()
decl_stmt|;
comment|// Look for InputFileFormat / Serde combinations we can deserialize more efficiently
comment|// using VectorDeserializeRow and a deserialize class with the DeserializeRead interface.
comment|//
comment|// Do the "vectorized" row-by-row deserialization into a VectorizedRowBatch in the
comment|// VectorMapOperator.
name|boolean
name|isTextFormat
init|=
name|inputFileFormatClassName
operator|.
name|equals
argument_list|(
name|TextInputFormat
operator|.
name|class
operator|.
name|getName
argument_list|()
argument_list|)
operator|&&
name|deserializerClassName
operator|.
name|equals
argument_list|(
name|LazySimpleSerDe
operator|.
name|class
operator|.
name|getName
argument_list|()
argument_list|)
decl_stmt|;
name|boolean
name|isSequenceFormat
init|=
name|inputFileFormatClassName
operator|.
name|equals
argument_list|(
name|SequenceFileInputFormat
operator|.
name|class
operator|.
name|getName
argument_list|()
argument_list|)
operator|&&
name|deserializerClassName
operator|.
name|equals
argument_list|(
name|LazyBinarySerDe
operator|.
name|class
operator|.
name|getName
argument_list|()
argument_list|)
decl_stmt|;
name|boolean
name|isVectorDeserializeEligable
init|=
name|isTextFormat
operator|||
name|isSequenceFormat
decl_stmt|;
if|if
condition|(
name|useVectorDeserialize
condition|)
block|{
comment|// Currently, we support LazySimple deserialization:
comment|//
comment|//    org.apache.hadoop.mapred.TextInputFormat
comment|//    org.apache.hadoop.hive.serde2.lazy.LazySimpleSerDe
comment|//
comment|// AND
comment|//
comment|//    org.apache.hadoop.mapred.SequenceFileInputFormat
comment|//    org.apache.hadoop.hive.serde2.lazybinary.LazyBinarySerDe
if|if
condition|(
name|isTextFormat
condition|)
block|{
name|Properties
name|properties
init|=
name|pd
operator|.
name|getTableDesc
argument_list|()
operator|.
name|getProperties
argument_list|()
decl_stmt|;
name|String
name|lastColumnTakesRestString
init|=
name|properties
operator|.
name|getProperty
argument_list|(
name|serdeConstants
operator|.
name|SERIALIZATION_LAST_COLUMN_TAKES_REST
argument_list|)
decl_stmt|;
name|boolean
name|lastColumnTakesRest
init|=
operator|(
name|lastColumnTakesRestString
operator|!=
literal|null
operator|&&
name|lastColumnTakesRestString
operator|.
name|equalsIgnoreCase
argument_list|(
literal|"true"
argument_list|)
operator|)
decl_stmt|;
if|if
condition|(
name|lastColumnTakesRest
condition|)
block|{
comment|// If row mode will not catch this input file format, then not enabled.
if|if
condition|(
name|useRowDeserialize
condition|)
block|{
name|enabledConditionsNotMetList
operator|.
name|add
argument_list|(
name|inputFileFormatClassName
operator|+
literal|" "
operator|+
name|serdeConstants
operator|.
name|SERIALIZATION_LAST_COLUMN_TAKES_REST
operator|+
literal|" must be disabled "
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
else|else
block|{
name|pd
operator|.
name|setVectorPartitionDesc
argument_list|(
name|VectorPartitionDesc
operator|.
name|createVectorDeserialize
argument_list|(
name|inputFileFormatClassName
argument_list|,
name|VectorDeserializeType
operator|.
name|LAZY_SIMPLE
argument_list|)
argument_list|)
expr_stmt|;
name|enabledConditionsMetSet
operator|.
name|add
argument_list|(
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVE_VECTORIZATION_USE_VECTOR_DESERIALIZE
operator|.
name|varname
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|isSequenceFormat
condition|)
block|{
name|pd
operator|.
name|setVectorPartitionDesc
argument_list|(
name|VectorPartitionDesc
operator|.
name|createVectorDeserialize
argument_list|(
name|inputFileFormatClassName
argument_list|,
name|VectorDeserializeType
operator|.
name|LAZY_BINARY
argument_list|)
argument_list|)
expr_stmt|;
name|enabledConditionsMetSet
operator|.
name|add
argument_list|(
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVE_VECTORIZATION_USE_VECTOR_DESERIALIZE
operator|.
name|varname
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
comment|// Fall through and look for other options...
block|}
comment|// Otherwise, if enabled, deserialize rows using regular Serde and add the object
comment|// inspect-able Object[] row to a VectorizedRowBatch in the VectorMapOperator.
if|if
condition|(
name|useRowDeserialize
condition|)
block|{
name|pd
operator|.
name|setVectorPartitionDesc
argument_list|(
name|VectorPartitionDesc
operator|.
name|createRowDeserialize
argument_list|(
name|inputFileFormatClassName
argument_list|,
name|Utilities
operator|.
name|isInputFileFormatSelfDescribing
argument_list|(
name|pd
argument_list|)
argument_list|,
name|deserializerClassName
argument_list|)
argument_list|)
expr_stmt|;
name|enabledConditionsMetSet
operator|.
name|add
argument_list|(
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVE_VECTORIZATION_USE_ROW_DESERIALIZE
operator|.
name|varname
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
if|if
condition|(
name|isInputFileFormatVectorized
condition|)
block|{
name|Preconditions
operator|.
name|checkState
argument_list|(
operator|!
name|useVectorizedInputFileFormat
argument_list|)
expr_stmt|;
name|enabledConditionsNotMetList
operator|.
name|add
argument_list|(
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVE_VECTORIZATION_USE_VECTORIZED_INPUT_FILE_FORMAT
operator|.
name|varname
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// Only offer these when the input file format is not the fast vectorized formats.
if|if
condition|(
name|isVectorDeserializeEligable
condition|)
block|{
name|Preconditions
operator|.
name|checkState
argument_list|(
operator|!
name|useVectorDeserialize
argument_list|)
expr_stmt|;
name|enabledConditionsNotMetList
operator|.
name|add
argument_list|(
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVE_VECTORIZATION_USE_VECTOR_DESERIALIZE
operator|.
name|varname
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// Since row mode takes everyone.
name|enabledConditionsNotMetList
operator|.
name|add
argument_list|(
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVE_VECTORIZATION_USE_ROW_DESERIALIZE
operator|.
name|varname
argument_list|)
expr_stmt|;
block|}
block|}
return|return
literal|false
return|;
block|}
specifier|private
name|ImmutablePair
argument_list|<
name|Boolean
argument_list|,
name|Boolean
argument_list|>
name|validateInputFormatAndSchemaEvolution
parameter_list|(
name|MapWork
name|mapWork
parameter_list|,
name|String
name|alias
parameter_list|,
name|TableScanOperator
name|tableScanOperator
parameter_list|,
name|VectorTaskColumnInfo
name|vectorTaskColumnInfo
parameter_list|)
throws|throws
name|SemanticException
block|{
name|boolean
name|isAcidTable
init|=
name|tableScanOperator
operator|.
name|getConf
argument_list|()
operator|.
name|isAcidTable
argument_list|()
decl_stmt|;
comment|// These names/types are the data columns plus partition columns.
specifier|final
name|List
argument_list|<
name|String
argument_list|>
name|allColumnNameList
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
specifier|final
name|List
argument_list|<
name|TypeInfo
argument_list|>
name|allTypeInfoList
init|=
operator|new
name|ArrayList
argument_list|<
name|TypeInfo
argument_list|>
argument_list|()
decl_stmt|;
name|getTableScanOperatorSchemaInfo
argument_list|(
name|tableScanOperator
argument_list|,
name|allColumnNameList
argument_list|,
name|allTypeInfoList
argument_list|)
expr_stmt|;
specifier|final
name|List
argument_list|<
name|Integer
argument_list|>
name|dataColumnNums
init|=
operator|new
name|ArrayList
argument_list|<
name|Integer
argument_list|>
argument_list|()
decl_stmt|;
specifier|final
name|int
name|allColumnCount
init|=
name|allColumnNameList
operator|.
name|size
argument_list|()
decl_stmt|;
comment|/*        * Validate input formats of all the partitions can be vectorized.        */
name|boolean
name|isFirst
init|=
literal|true
decl_stmt|;
name|int
name|dataColumnCount
init|=
literal|0
decl_stmt|;
name|int
name|partitionColumnCount
init|=
literal|0
decl_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|tableDataColumnList
init|=
literal|null
decl_stmt|;
name|List
argument_list|<
name|TypeInfo
argument_list|>
name|tableDataTypeInfoList
init|=
literal|null
decl_stmt|;
name|LinkedHashMap
argument_list|<
name|Path
argument_list|,
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|>
name|pathToAliases
init|=
name|mapWork
operator|.
name|getPathToAliases
argument_list|()
decl_stmt|;
name|LinkedHashMap
argument_list|<
name|Path
argument_list|,
name|PartitionDesc
argument_list|>
name|pathToPartitionInfo
init|=
name|mapWork
operator|.
name|getPathToPartitionInfo
argument_list|()
decl_stmt|;
comment|// Remember the input file formats we validated and why.
name|HashSet
argument_list|<
name|String
argument_list|>
name|inputFileFormatClassNameSet
init|=
operator|new
name|HashSet
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
name|HashSet
argument_list|<
name|String
argument_list|>
name|enabledConditionsMetSet
init|=
operator|new
name|HashSet
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
name|ArrayList
argument_list|<
name|String
argument_list|>
name|enabledConditionsNotMetList
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|Entry
argument_list|<
name|Path
argument_list|,
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|>
name|entry
range|:
name|pathToAliases
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|Path
name|path
init|=
name|entry
operator|.
name|getKey
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|aliases
init|=
name|entry
operator|.
name|getValue
argument_list|()
decl_stmt|;
name|boolean
name|isPresent
init|=
operator|(
name|aliases
operator|!=
literal|null
operator|&&
name|aliases
operator|.
name|indexOf
argument_list|(
name|alias
argument_list|)
operator|!=
operator|-
literal|1
operator|)
decl_stmt|;
if|if
condition|(
operator|!
name|isPresent
condition|)
block|{
name|setOperatorIssue
argument_list|(
literal|"Alias "
operator|+
name|alias
operator|+
literal|" not present in aliases "
operator|+
name|aliases
argument_list|)
expr_stmt|;
return|return
operator|new
name|ImmutablePair
argument_list|<
name|Boolean
argument_list|,
name|Boolean
argument_list|>
argument_list|(
literal|false
argument_list|,
literal|false
argument_list|)
return|;
block|}
name|PartitionDesc
name|partDesc
init|=
name|pathToPartitionInfo
operator|.
name|get
argument_list|(
name|path
argument_list|)
decl_stmt|;
if|if
condition|(
name|partDesc
operator|.
name|getVectorPartitionDesc
argument_list|()
operator|!=
literal|null
condition|)
block|{
comment|// We've seen this already.
continue|continue;
block|}
if|if
condition|(
operator|!
name|verifyAndSetVectorPartDesc
argument_list|(
name|partDesc
argument_list|,
name|isAcidTable
argument_list|,
name|inputFileFormatClassNameSet
argument_list|,
name|enabledConditionsMetSet
argument_list|,
name|enabledConditionsNotMetList
argument_list|)
condition|)
block|{
comment|// Always set these so EXPLAIN can see.
name|mapWork
operator|.
name|setVectorizationInputFileFormatClassNameSet
argument_list|(
name|inputFileFormatClassNameSet
argument_list|)
expr_stmt|;
name|mapWork
operator|.
name|setVectorizationEnabledConditionsMet
argument_list|(
operator|new
name|ArrayList
argument_list|(
name|enabledConditionsMetSet
argument_list|)
argument_list|)
expr_stmt|;
name|mapWork
operator|.
name|setVectorizationEnabledConditionsNotMet
argument_list|(
name|enabledConditionsNotMetList
argument_list|)
expr_stmt|;
comment|// We consider this an enable issue, not a not vectorized issue.
name|LOG
operator|.
name|info
argument_list|(
literal|"Cannot enable vectorization because input file format(s) "
operator|+
name|inputFileFormatClassNameSet
operator|+
literal|" do not met conditions "
operator|+
name|VectorizationCondition
operator|.
name|addBooleans
argument_list|(
name|enabledConditionsNotMetList
argument_list|,
literal|false
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|new
name|ImmutablePair
argument_list|<
name|Boolean
argument_list|,
name|Boolean
argument_list|>
argument_list|(
literal|false
argument_list|,
literal|true
argument_list|)
return|;
block|}
name|VectorPartitionDesc
name|vectorPartDesc
init|=
name|partDesc
operator|.
name|getVectorPartitionDesc
argument_list|()
decl_stmt|;
if|if
condition|(
name|isFirst
condition|)
block|{
comment|// Determine the data and partition columns using the first partition descriptor.
name|LinkedHashMap
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|partSpec
init|=
name|partDesc
operator|.
name|getPartSpec
argument_list|()
decl_stmt|;
if|if
condition|(
name|partSpec
operator|!=
literal|null
operator|&&
name|partSpec
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
name|partitionColumnCount
operator|=
name|partSpec
operator|.
name|size
argument_list|()
expr_stmt|;
name|dataColumnCount
operator|=
name|allColumnCount
operator|-
name|partitionColumnCount
expr_stmt|;
block|}
else|else
block|{
name|partitionColumnCount
operator|=
literal|0
expr_stmt|;
name|dataColumnCount
operator|=
name|allColumnCount
expr_stmt|;
block|}
name|determineDataColumnNums
argument_list|(
name|tableScanOperator
argument_list|,
name|allColumnNameList
argument_list|,
name|dataColumnCount
argument_list|,
name|dataColumnNums
argument_list|)
expr_stmt|;
name|tableDataColumnList
operator|=
name|allColumnNameList
operator|.
name|subList
argument_list|(
literal|0
argument_list|,
name|dataColumnCount
argument_list|)
expr_stmt|;
name|tableDataTypeInfoList
operator|=
name|allTypeInfoList
operator|.
name|subList
argument_list|(
literal|0
argument_list|,
name|dataColumnCount
argument_list|)
expr_stmt|;
name|isFirst
operator|=
literal|false
expr_stmt|;
block|}
comment|// We need to get the partition's column names from the partition serde.
comment|// (e.g. Avro provides the table schema and ignores the partition schema..).
comment|//
name|Deserializer
name|deserializer
decl_stmt|;
name|StructObjectInspector
name|partObjectInspector
decl_stmt|;
try|try
block|{
name|deserializer
operator|=
name|partDesc
operator|.
name|getDeserializer
argument_list|(
name|hiveConf
argument_list|)
expr_stmt|;
name|partObjectInspector
operator|=
operator|(
name|StructObjectInspector
operator|)
name|deserializer
operator|.
name|getObjectInspector
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|e
argument_list|)
throw|;
block|}
name|String
name|nextDataColumnsString
init|=
name|ObjectInspectorUtils
operator|.
name|getFieldNames
argument_list|(
name|partObjectInspector
argument_list|)
decl_stmt|;
name|String
index|[]
name|nextDataColumns
init|=
name|nextDataColumnsString
operator|.
name|split
argument_list|(
literal|","
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|nextDataColumnList
init|=
name|Arrays
operator|.
name|asList
argument_list|(
name|nextDataColumns
argument_list|)
decl_stmt|;
comment|/*          * Validate the column names that are present are the same.  Missing columns will be          * implicitly defaulted to null.          */
if|if
condition|(
name|nextDataColumnList
operator|.
name|size
argument_list|()
operator|>
name|tableDataColumnList
operator|.
name|size
argument_list|()
condition|)
block|{
name|setOperatorIssue
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"Could not vectorize partition %s "
operator|+
literal|"(deserializer "
operator|+
name|deserializer
operator|.
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
operator|+
literal|")"
operator|+
literal|"The partition column names %d is greater than the number of table columns %d"
argument_list|,
name|path
argument_list|,
name|nextDataColumnList
operator|.
name|size
argument_list|()
argument_list|,
name|tableDataColumnList
operator|.
name|size
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|new
name|ImmutablePair
argument_list|<
name|Boolean
argument_list|,
name|Boolean
argument_list|>
argument_list|(
literal|false
argument_list|,
literal|false
argument_list|)
return|;
block|}
if|if
condition|(
operator|!
operator|(
name|deserializer
operator|instanceof
name|NullStructSerDe
operator|)
condition|)
block|{
comment|// (Don't insist NullStructSerDe produce correct column names).
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|nextDataColumnList
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|String
name|nextColumnName
init|=
name|nextDataColumnList
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|String
name|tableColumnName
init|=
name|tableDataColumnList
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|nextColumnName
operator|.
name|equals
argument_list|(
name|tableColumnName
argument_list|)
condition|)
block|{
name|setOperatorIssue
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"Could not vectorize partition %s "
operator|+
literal|"(deserializer "
operator|+
name|deserializer
operator|.
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
operator|+
literal|")"
operator|+
literal|"The partition column name %s is does not match table column name %s"
argument_list|,
name|path
argument_list|,
name|nextColumnName
argument_list|,
name|tableColumnName
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|new
name|ImmutablePair
argument_list|<
name|Boolean
argument_list|,
name|Boolean
argument_list|>
argument_list|(
literal|false
argument_list|,
literal|false
argument_list|)
return|;
block|}
block|}
block|}
name|List
argument_list|<
name|TypeInfo
argument_list|>
name|nextDataTypeInfoList
decl_stmt|;
if|if
condition|(
name|vectorPartDesc
operator|.
name|getIsInputFileFormatSelfDescribing
argument_list|()
condition|)
block|{
comment|/*            * Self-Describing Input Format will convert its data to the table schema.            */
name|nextDataTypeInfoList
operator|=
name|tableDataTypeInfoList
expr_stmt|;
block|}
else|else
block|{
name|String
name|nextDataTypesString
init|=
name|ObjectInspectorUtils
operator|.
name|getFieldTypes
argument_list|(
name|partObjectInspector
argument_list|)
decl_stmt|;
comment|// We convert to an array of TypeInfo using a library routine since it parses the information
comment|// and can handle use of different separators, etc.  We cannot use the raw type string
comment|// for comparison in the map because of the different separators used.
name|nextDataTypeInfoList
operator|=
name|TypeInfoUtils
operator|.
name|getTypeInfosFromTypeString
argument_list|(
name|nextDataTypesString
argument_list|)
expr_stmt|;
block|}
name|vectorPartDesc
operator|.
name|setDataTypeInfos
argument_list|(
name|nextDataTypeInfoList
argument_list|)
expr_stmt|;
block|}
name|vectorTaskColumnInfo
operator|.
name|setAllColumnNames
argument_list|(
name|allColumnNameList
argument_list|)
expr_stmt|;
name|vectorTaskColumnInfo
operator|.
name|setAllTypeInfos
argument_list|(
name|allTypeInfoList
argument_list|)
expr_stmt|;
name|vectorTaskColumnInfo
operator|.
name|setDataColumnNums
argument_list|(
name|dataColumnNums
argument_list|)
expr_stmt|;
name|vectorTaskColumnInfo
operator|.
name|setPartitionColumnCount
argument_list|(
name|partitionColumnCount
argument_list|)
expr_stmt|;
name|vectorTaskColumnInfo
operator|.
name|setUseVectorizedInputFileFormat
argument_list|(
name|useVectorizedInputFileFormat
argument_list|)
expr_stmt|;
comment|// Always set these so EXPLAIN can see.
name|mapWork
operator|.
name|setVectorizationInputFileFormatClassNameSet
argument_list|(
name|inputFileFormatClassNameSet
argument_list|)
expr_stmt|;
name|mapWork
operator|.
name|setVectorizationEnabledConditionsMet
argument_list|(
operator|new
name|ArrayList
argument_list|(
name|enabledConditionsMetSet
argument_list|)
argument_list|)
expr_stmt|;
name|mapWork
operator|.
name|setVectorizationEnabledConditionsNotMet
argument_list|(
name|enabledConditionsNotMetList
argument_list|)
expr_stmt|;
return|return
operator|new
name|ImmutablePair
argument_list|<
name|Boolean
argument_list|,
name|Boolean
argument_list|>
argument_list|(
literal|true
argument_list|,
literal|false
argument_list|)
return|;
block|}
specifier|private
name|boolean
name|validateMapWork
parameter_list|(
name|MapWork
name|mapWork
parameter_list|,
name|VectorTaskColumnInfo
name|vectorTaskColumnInfo
parameter_list|,
name|boolean
name|isTezOrSpark
parameter_list|)
throws|throws
name|SemanticException
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Validating MapWork..."
argument_list|)
expr_stmt|;
name|ImmutablePair
argument_list|<
name|String
argument_list|,
name|TableScanOperator
argument_list|>
name|onlyOneTableScanPair
init|=
name|verifyOnlyOneTableScanOperator
argument_list|(
name|mapWork
argument_list|)
decl_stmt|;
if|if
condition|(
name|onlyOneTableScanPair
operator|==
literal|null
condition|)
block|{
name|VectorizerReason
name|notVectorizedReason
init|=
name|currentBaseWork
operator|.
name|getNotVectorizedReason
argument_list|()
decl_stmt|;
name|Preconditions
operator|.
name|checkState
argument_list|(
name|notVectorizedReason
operator|!=
literal|null
argument_list|)
expr_stmt|;
name|mapWork
operator|.
name|setVectorizationEnabledConditionsNotMet
argument_list|(
name|Arrays
operator|.
name|asList
argument_list|(
operator|new
name|String
index|[]
block|{
name|notVectorizedReason
operator|.
name|toString
argument_list|()
block|}
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
name|String
name|alias
init|=
name|onlyOneTableScanPair
operator|.
name|left
decl_stmt|;
name|TableScanOperator
name|tableScanOperator
init|=
name|onlyOneTableScanPair
operator|.
name|right
decl_stmt|;
comment|// This call fills in the column names, types, and partition column count in
comment|// vectorTaskColumnInfo.
name|currentOperator
operator|=
name|tableScanOperator
expr_stmt|;
name|ImmutablePair
argument_list|<
name|Boolean
argument_list|,
name|Boolean
argument_list|>
name|validateInputFormatAndSchemaEvolutionPair
init|=
name|validateInputFormatAndSchemaEvolution
argument_list|(
name|mapWork
argument_list|,
name|alias
argument_list|,
name|tableScanOperator
argument_list|,
name|vectorTaskColumnInfo
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|validateInputFormatAndSchemaEvolutionPair
operator|.
name|left
condition|)
block|{
comment|// Have we already set the enabled conditions not met?
if|if
condition|(
operator|!
name|validateInputFormatAndSchemaEvolutionPair
operator|.
name|right
condition|)
block|{
name|VectorizerReason
name|notVectorizedReason
init|=
name|currentBaseWork
operator|.
name|getNotVectorizedReason
argument_list|()
decl_stmt|;
name|Preconditions
operator|.
name|checkState
argument_list|(
name|notVectorizedReason
operator|!=
literal|null
argument_list|)
expr_stmt|;
name|mapWork
operator|.
name|setVectorizationEnabledConditionsNotMet
argument_list|(
name|Arrays
operator|.
name|asList
argument_list|(
operator|new
name|String
index|[]
block|{
name|notVectorizedReason
operator|.
name|toString
argument_list|()
block|}
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
literal|false
return|;
block|}
comment|// Now we are enabled and any issues found from here on out are considered
comment|// not vectorized issues.
name|mapWork
operator|.
name|setVectorizationEnabled
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|Map
argument_list|<
name|Rule
argument_list|,
name|NodeProcessor
argument_list|>
name|opRules
init|=
operator|new
name|LinkedHashMap
argument_list|<
name|Rule
argument_list|,
name|NodeProcessor
argument_list|>
argument_list|()
decl_stmt|;
name|MapWorkValidationNodeProcessor
name|vnp
init|=
operator|new
name|MapWorkValidationNodeProcessor
argument_list|(
name|mapWork
argument_list|,
name|isTezOrSpark
argument_list|)
decl_stmt|;
name|addMapWorkRules
argument_list|(
name|opRules
argument_list|,
name|vnp
argument_list|)
expr_stmt|;
name|Dispatcher
name|disp
init|=
operator|new
name|DefaultRuleDispatcher
argument_list|(
name|vnp
argument_list|,
name|opRules
argument_list|,
literal|null
argument_list|)
decl_stmt|;
name|GraphWalker
name|ogw
init|=
operator|new
name|DefaultGraphWalker
argument_list|(
name|disp
argument_list|)
decl_stmt|;
comment|// iterator the mapper operator tree
name|ArrayList
argument_list|<
name|Node
argument_list|>
name|topNodes
init|=
operator|new
name|ArrayList
argument_list|<
name|Node
argument_list|>
argument_list|()
decl_stmt|;
name|topNodes
operator|.
name|addAll
argument_list|(
name|mapWork
operator|.
name|getAliasToWork
argument_list|()
operator|.
name|values
argument_list|()
argument_list|)
expr_stmt|;
name|HashMap
argument_list|<
name|Node
argument_list|,
name|Object
argument_list|>
name|nodeOutput
init|=
operator|new
name|HashMap
argument_list|<
name|Node
argument_list|,
name|Object
argument_list|>
argument_list|()
decl_stmt|;
name|ogw
operator|.
name|startWalking
argument_list|(
name|topNodes
argument_list|,
name|nodeOutput
argument_list|)
expr_stmt|;
for|for
control|(
name|Node
name|n
range|:
name|nodeOutput
operator|.
name|keySet
argument_list|()
control|)
block|{
if|if
condition|(
name|nodeOutput
operator|.
name|get
argument_list|(
name|n
argument_list|)
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|Boolean
operator|)
name|nodeOutput
operator|.
name|get
argument_list|(
name|n
argument_list|)
operator|)
operator|.
name|booleanValue
argument_list|()
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
block|}
name|vectorTaskColumnInfo
operator|.
name|setNonVectorizedOps
argument_list|(
name|vnp
operator|.
name|getNonVectorizedOps
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
specifier|private
name|void
name|vectorizeMapWork
parameter_list|(
name|MapWork
name|mapWork
parameter_list|,
name|VectorTaskColumnInfo
name|vectorTaskColumnInfo
parameter_list|,
name|boolean
name|isTezOrSpark
parameter_list|)
throws|throws
name|SemanticException
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Vectorizing MapWork..."
argument_list|)
expr_stmt|;
name|mapWork
operator|.
name|setVectorMode
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|Map
argument_list|<
name|Rule
argument_list|,
name|NodeProcessor
argument_list|>
name|opRules
init|=
operator|new
name|LinkedHashMap
argument_list|<
name|Rule
argument_list|,
name|NodeProcessor
argument_list|>
argument_list|()
decl_stmt|;
name|MapWorkVectorizationNodeProcessor
name|vnp
init|=
operator|new
name|MapWorkVectorizationNodeProcessor
argument_list|(
name|mapWork
argument_list|,
name|isTezOrSpark
argument_list|,
name|vectorTaskColumnInfo
argument_list|)
decl_stmt|;
name|addMapWorkRules
argument_list|(
name|opRules
argument_list|,
name|vnp
argument_list|)
expr_stmt|;
name|Dispatcher
name|disp
init|=
operator|new
name|DefaultRuleDispatcher
argument_list|(
name|vnp
argument_list|,
name|opRules
argument_list|,
literal|null
argument_list|)
decl_stmt|;
name|GraphWalker
name|ogw
init|=
operator|new
name|PreOrderOnceWalker
argument_list|(
name|disp
argument_list|)
decl_stmt|;
comment|// iterator the mapper operator tree
name|ArrayList
argument_list|<
name|Node
argument_list|>
name|topNodes
init|=
operator|new
name|ArrayList
argument_list|<
name|Node
argument_list|>
argument_list|()
decl_stmt|;
name|topNodes
operator|.
name|addAll
argument_list|(
name|mapWork
operator|.
name|getAliasToWork
argument_list|()
operator|.
name|values
argument_list|()
argument_list|)
expr_stmt|;
name|HashMap
argument_list|<
name|Node
argument_list|,
name|Object
argument_list|>
name|nodeOutput
init|=
operator|new
name|HashMap
argument_list|<
name|Node
argument_list|,
name|Object
argument_list|>
argument_list|()
decl_stmt|;
name|ogw
operator|.
name|startWalking
argument_list|(
name|topNodes
argument_list|,
name|nodeOutput
argument_list|)
expr_stmt|;
name|vectorTaskColumnInfo
operator|.
name|setScratchTypeNameArray
argument_list|(
name|vnp
operator|.
name|getVectorScratchColumnTypeNames
argument_list|()
argument_list|)
expr_stmt|;
name|vectorTaskColumnInfo
operator|.
name|transferToBaseWork
argument_list|(
name|mapWork
argument_list|)
expr_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|debugDisplayAllMaps
argument_list|(
name|mapWork
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
specifier|private
name|void
name|setReduceWorkExplainConditions
parameter_list|(
name|ReduceWork
name|reduceWork
parameter_list|)
block|{
name|reduceWork
operator|.
name|setVectorizationExamined
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|reduceWork
operator|.
name|setReduceVectorizationEnabled
argument_list|(
name|isReduceVectorizationEnabled
argument_list|)
expr_stmt|;
name|reduceWork
operator|.
name|setVectorReduceEngine
argument_list|(
name|HiveConf
operator|.
name|getVar
argument_list|(
name|hiveConf
argument_list|,
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVE_EXECUTION_ENGINE
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|convertReduceWork
parameter_list|(
name|ReduceWork
name|reduceWork
parameter_list|)
throws|throws
name|SemanticException
block|{
comment|// Global used when setting errors, etc.
name|currentBaseWork
operator|=
name|reduceWork
expr_stmt|;
name|currentBaseWork
operator|.
name|setVectorizationEnabled
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|VectorTaskColumnInfo
name|vectorTaskColumnInfo
init|=
operator|new
name|VectorTaskColumnInfo
argument_list|()
decl_stmt|;
name|vectorTaskColumnInfo
operator|.
name|assume
argument_list|()
expr_stmt|;
name|reduceWork
operator|.
name|setVectorizedVertexNum
argument_list|(
operator|++
name|vectorizedVertexNum
argument_list|)
expr_stmt|;
name|boolean
name|ret
decl_stmt|;
try|try
block|{
name|ret
operator|=
name|validateReduceWork
argument_list|(
name|reduceWork
argument_list|,
name|vectorTaskColumnInfo
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|String
name|issue
init|=
literal|"exception: "
operator|+
name|VectorizationContext
operator|.
name|getStackTraceAsSingleLine
argument_list|(
name|e
argument_list|)
decl_stmt|;
name|setNodeIssue
argument_list|(
name|issue
argument_list|)
expr_stmt|;
name|ret
operator|=
literal|false
expr_stmt|;
block|}
if|if
condition|(
name|ret
condition|)
block|{
name|vectorizeReduceWork
argument_list|(
name|reduceWork
argument_list|,
name|vectorTaskColumnInfo
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|currentBaseWork
operator|.
name|getVectorizationEnabled
argument_list|()
condition|)
block|{
name|VectorizerReason
name|notVectorizedReason
init|=
name|currentBaseWork
operator|.
name|getNotVectorizedReason
argument_list|()
decl_stmt|;
if|if
condition|(
name|notVectorizedReason
operator|==
literal|null
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Cannot vectorize: unknown"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Cannot vectorize: "
operator|+
name|notVectorizedReason
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|clearReduceWorkVectorDescs
argument_list|(
name|reduceWork
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
name|boolean
name|getOnlyStructObjectInspectors
parameter_list|(
name|ReduceWork
name|reduceWork
parameter_list|,
name|VectorTaskColumnInfo
name|vectorTaskColumnInfo
parameter_list|)
throws|throws
name|SemanticException
block|{
name|ArrayList
argument_list|<
name|String
argument_list|>
name|reduceColumnNames
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
name|ArrayList
argument_list|<
name|TypeInfo
argument_list|>
name|reduceTypeInfos
init|=
operator|new
name|ArrayList
argument_list|<
name|TypeInfo
argument_list|>
argument_list|()
decl_stmt|;
if|if
condition|(
name|reduceWork
operator|.
name|getNeedsTagging
argument_list|()
condition|)
block|{
name|setNodeIssue
argument_list|(
literal|"Tagging not supported"
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
try|try
block|{
name|TableDesc
name|keyTableDesc
init|=
name|reduceWork
operator|.
name|getKeyDesc
argument_list|()
decl_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Using reduce tag "
operator|+
name|reduceWork
operator|.
name|getTag
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|TableDesc
name|valueTableDesc
init|=
name|reduceWork
operator|.
name|getTagToValueDesc
argument_list|()
operator|.
name|get
argument_list|(
name|reduceWork
operator|.
name|getTag
argument_list|()
argument_list|)
decl_stmt|;
name|Deserializer
name|keyDeserializer
init|=
name|ReflectionUtils
operator|.
name|newInstance
argument_list|(
name|keyTableDesc
operator|.
name|getDeserializerClass
argument_list|()
argument_list|,
literal|null
argument_list|)
decl_stmt|;
name|SerDeUtils
operator|.
name|initializeSerDe
argument_list|(
name|keyDeserializer
argument_list|,
literal|null
argument_list|,
name|keyTableDesc
operator|.
name|getProperties
argument_list|()
argument_list|,
literal|null
argument_list|)
expr_stmt|;
name|ObjectInspector
name|keyObjectInspector
init|=
name|keyDeserializer
operator|.
name|getObjectInspector
argument_list|()
decl_stmt|;
if|if
condition|(
name|keyObjectInspector
operator|==
literal|null
condition|)
block|{
name|setNodeIssue
argument_list|(
literal|"Key object inspector null"
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
operator|!
operator|(
name|keyObjectInspector
operator|instanceof
name|StructObjectInspector
operator|)
condition|)
block|{
name|setNodeIssue
argument_list|(
literal|"Key object inspector not StructObjectInspector"
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
name|StructObjectInspector
name|keyStructObjectInspector
init|=
operator|(
name|StructObjectInspector
operator|)
name|keyObjectInspector
decl_stmt|;
name|List
argument_list|<
name|?
extends|extends
name|StructField
argument_list|>
name|keyFields
init|=
name|keyStructObjectInspector
operator|.
name|getAllStructFieldRefs
argument_list|()
decl_stmt|;
for|for
control|(
name|StructField
name|field
range|:
name|keyFields
control|)
block|{
name|reduceColumnNames
operator|.
name|add
argument_list|(
name|Utilities
operator|.
name|ReduceField
operator|.
name|KEY
operator|.
name|toString
argument_list|()
operator|+
literal|"."
operator|+
name|field
operator|.
name|getFieldName
argument_list|()
argument_list|)
expr_stmt|;
name|reduceTypeInfos
operator|.
name|add
argument_list|(
name|TypeInfoUtils
operator|.
name|getTypeInfoFromTypeString
argument_list|(
name|field
operator|.
name|getFieldObjectInspector
argument_list|()
operator|.
name|getTypeName
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|Deserializer
name|valueDeserializer
init|=
name|ReflectionUtils
operator|.
name|newInstance
argument_list|(
name|valueTableDesc
operator|.
name|getDeserializerClass
argument_list|()
argument_list|,
literal|null
argument_list|)
decl_stmt|;
name|SerDeUtils
operator|.
name|initializeSerDe
argument_list|(
name|valueDeserializer
argument_list|,
literal|null
argument_list|,
name|valueTableDesc
operator|.
name|getProperties
argument_list|()
argument_list|,
literal|null
argument_list|)
expr_stmt|;
name|ObjectInspector
name|valueObjectInspector
init|=
name|valueDeserializer
operator|.
name|getObjectInspector
argument_list|()
decl_stmt|;
if|if
condition|(
name|valueObjectInspector
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|valueObjectInspector
operator|instanceof
name|StructObjectInspector
operator|)
condition|)
block|{
name|setNodeIssue
argument_list|(
literal|"Value object inspector not StructObjectInspector"
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
name|StructObjectInspector
name|valueStructObjectInspector
init|=
operator|(
name|StructObjectInspector
operator|)
name|valueObjectInspector
decl_stmt|;
name|List
argument_list|<
name|?
extends|extends
name|StructField
argument_list|>
name|valueFields
init|=
name|valueStructObjectInspector
operator|.
name|getAllStructFieldRefs
argument_list|()
decl_stmt|;
for|for
control|(
name|StructField
name|field
range|:
name|valueFields
control|)
block|{
name|reduceColumnNames
operator|.
name|add
argument_list|(
name|Utilities
operator|.
name|ReduceField
operator|.
name|VALUE
operator|.
name|toString
argument_list|()
operator|+
literal|"."
operator|+
name|field
operator|.
name|getFieldName
argument_list|()
argument_list|)
expr_stmt|;
name|reduceTypeInfos
operator|.
name|add
argument_list|(
name|TypeInfoUtils
operator|.
name|getTypeInfoFromTypeString
argument_list|(
name|field
operator|.
name|getFieldObjectInspector
argument_list|()
operator|.
name|getTypeName
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|e
argument_list|)
throw|;
block|}
name|vectorTaskColumnInfo
operator|.
name|setAllColumnNames
argument_list|(
name|reduceColumnNames
argument_list|)
expr_stmt|;
name|vectorTaskColumnInfo
operator|.
name|setAllTypeInfos
argument_list|(
name|reduceTypeInfos
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
specifier|private
name|void
name|addReduceWorkRules
parameter_list|(
name|Map
argument_list|<
name|Rule
argument_list|,
name|NodeProcessor
argument_list|>
name|opRules
parameter_list|,
name|NodeProcessor
name|np
parameter_list|)
block|{
name|opRules
operator|.
name|put
argument_list|(
operator|new
name|RuleRegExp
argument_list|(
literal|"R1"
argument_list|,
name|GroupByOperator
operator|.
name|getOperatorName
argument_list|()
operator|+
literal|".*"
argument_list|)
argument_list|,
name|np
argument_list|)
expr_stmt|;
name|opRules
operator|.
name|put
argument_list|(
operator|new
name|RuleRegExp
argument_list|(
literal|"R2"
argument_list|,
name|SelectOperator
operator|.
name|getOperatorName
argument_list|()
operator|+
literal|".*"
argument_list|)
argument_list|,
name|np
argument_list|)
expr_stmt|;
block|}
specifier|private
name|boolean
name|validateReduceWork
parameter_list|(
name|ReduceWork
name|reduceWork
parameter_list|,
name|VectorTaskColumnInfo
name|vectorTaskColumnInfo
parameter_list|)
throws|throws
name|SemanticException
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Validating ReduceWork..."
argument_list|)
expr_stmt|;
comment|// Validate input to ReduceWork.
if|if
condition|(
operator|!
name|getOnlyStructObjectInspectors
argument_list|(
name|reduceWork
argument_list|,
name|vectorTaskColumnInfo
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
comment|// Now check the reduce operator tree.
name|Map
argument_list|<
name|Rule
argument_list|,
name|NodeProcessor
argument_list|>
name|opRules
init|=
operator|new
name|LinkedHashMap
argument_list|<
name|Rule
argument_list|,
name|NodeProcessor
argument_list|>
argument_list|()
decl_stmt|;
name|ReduceWorkValidationNodeProcessor
name|vnp
init|=
operator|new
name|ReduceWorkValidationNodeProcessor
argument_list|()
decl_stmt|;
name|addReduceWorkRules
argument_list|(
name|opRules
argument_list|,
name|vnp
argument_list|)
expr_stmt|;
name|Dispatcher
name|disp
init|=
operator|new
name|DefaultRuleDispatcher
argument_list|(
name|vnp
argument_list|,
name|opRules
argument_list|,
literal|null
argument_list|)
decl_stmt|;
name|GraphWalker
name|ogw
init|=
operator|new
name|DefaultGraphWalker
argument_list|(
name|disp
argument_list|)
decl_stmt|;
comment|// iterator the reduce operator tree
name|ArrayList
argument_list|<
name|Node
argument_list|>
name|topNodes
init|=
operator|new
name|ArrayList
argument_list|<
name|Node
argument_list|>
argument_list|()
decl_stmt|;
name|topNodes
operator|.
name|add
argument_list|(
name|reduceWork
operator|.
name|getReducer
argument_list|()
argument_list|)
expr_stmt|;
name|HashMap
argument_list|<
name|Node
argument_list|,
name|Object
argument_list|>
name|nodeOutput
init|=
operator|new
name|HashMap
argument_list|<
name|Node
argument_list|,
name|Object
argument_list|>
argument_list|()
decl_stmt|;
name|ogw
operator|.
name|startWalking
argument_list|(
name|topNodes
argument_list|,
name|nodeOutput
argument_list|)
expr_stmt|;
for|for
control|(
name|Node
name|n
range|:
name|nodeOutput
operator|.
name|keySet
argument_list|()
control|)
block|{
if|if
condition|(
name|nodeOutput
operator|.
name|get
argument_list|(
name|n
argument_list|)
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|Boolean
operator|)
name|nodeOutput
operator|.
name|get
argument_list|(
name|n
argument_list|)
operator|)
operator|.
name|booleanValue
argument_list|()
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
block|}
name|vectorTaskColumnInfo
operator|.
name|setNonVectorizedOps
argument_list|(
name|vnp
operator|.
name|getNonVectorizedOps
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
specifier|private
name|void
name|vectorizeReduceWork
parameter_list|(
name|ReduceWork
name|reduceWork
parameter_list|,
name|VectorTaskColumnInfo
name|vectorTaskColumnInfo
parameter_list|)
throws|throws
name|SemanticException
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Vectorizing ReduceWork..."
argument_list|)
expr_stmt|;
name|reduceWork
operator|.
name|setVectorMode
argument_list|(
literal|true
argument_list|)
expr_stmt|;
comment|// For some reason, the DefaultGraphWalker does not descend down from the reducer Operator as
comment|// expected.  We need to descend down, otherwise it breaks our algorithm that determines
comment|// VectorizationContext...  Do we use PreOrderWalker instead of DefaultGraphWalker.
name|Map
argument_list|<
name|Rule
argument_list|,
name|NodeProcessor
argument_list|>
name|opRules
init|=
operator|new
name|LinkedHashMap
argument_list|<
name|Rule
argument_list|,
name|NodeProcessor
argument_list|>
argument_list|()
decl_stmt|;
name|ReduceWorkVectorizationNodeProcessor
name|vnp
init|=
operator|new
name|ReduceWorkVectorizationNodeProcessor
argument_list|(
name|vectorTaskColumnInfo
argument_list|)
decl_stmt|;
name|addReduceWorkRules
argument_list|(
name|opRules
argument_list|,
name|vnp
argument_list|)
expr_stmt|;
name|Dispatcher
name|disp
init|=
operator|new
name|DefaultRuleDispatcher
argument_list|(
name|vnp
argument_list|,
name|opRules
argument_list|,
literal|null
argument_list|)
decl_stmt|;
name|GraphWalker
name|ogw
init|=
operator|new
name|PreOrderWalker
argument_list|(
name|disp
argument_list|)
decl_stmt|;
comment|// iterator the reduce operator tree
name|ArrayList
argument_list|<
name|Node
argument_list|>
name|topNodes
init|=
operator|new
name|ArrayList
argument_list|<
name|Node
argument_list|>
argument_list|()
decl_stmt|;
name|topNodes
operator|.
name|add
argument_list|(
name|reduceWork
operator|.
name|getReducer
argument_list|()
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"vectorizeReduceWork reducer Operator: "
operator|+
name|reduceWork
operator|.
name|getReducer
argument_list|()
operator|.
name|getName
argument_list|()
operator|+
literal|"..."
argument_list|)
expr_stmt|;
name|HashMap
argument_list|<
name|Node
argument_list|,
name|Object
argument_list|>
name|nodeOutput
init|=
operator|new
name|HashMap
argument_list|<
name|Node
argument_list|,
name|Object
argument_list|>
argument_list|()
decl_stmt|;
name|ogw
operator|.
name|startWalking
argument_list|(
name|topNodes
argument_list|,
name|nodeOutput
argument_list|)
expr_stmt|;
comment|// Necessary since we are vectorizing the root operator in reduce.
name|reduceWork
operator|.
name|setReducer
argument_list|(
name|vnp
operator|.
name|getRootVectorOp
argument_list|()
argument_list|)
expr_stmt|;
name|vectorTaskColumnInfo
operator|.
name|setScratchTypeNameArray
argument_list|(
name|vnp
operator|.
name|getVectorScratchColumnTypeNames
argument_list|()
argument_list|)
expr_stmt|;
name|vectorTaskColumnInfo
operator|.
name|transferToBaseWork
argument_list|(
name|reduceWork
argument_list|)
expr_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|debugDisplayAllMaps
argument_list|(
name|reduceWork
argument_list|)
expr_stmt|;
block|}
block|}
class|class
name|ClearVectorDescsNodeProcessor
implements|implements
name|NodeProcessor
block|{
specifier|public
name|ClearVectorDescsNodeProcessor
parameter_list|()
block|{       }
annotation|@
name|Override
specifier|public
name|Object
name|process
parameter_list|(
name|Node
name|nd
parameter_list|,
name|Stack
argument_list|<
name|Node
argument_list|>
name|stack
parameter_list|,
name|NodeProcessorCtx
name|procCtx
parameter_list|,
name|Object
modifier|...
name|nodeOutputs
parameter_list|)
throws|throws
name|SemanticException
block|{
for|for
control|(
name|Node
name|n
range|:
name|stack
control|)
block|{
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
name|op
init|=
operator|(
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
operator|)
name|n
decl_stmt|;
name|OperatorDesc
name|desc
init|=
name|op
operator|.
name|getConf
argument_list|()
decl_stmt|;
if|if
condition|(
name|desc
operator|instanceof
name|AbstractOperatorDesc
condition|)
block|{
name|AbstractOperatorDesc
name|abstractDesc
init|=
operator|(
name|AbstractOperatorDesc
operator|)
name|desc
decl_stmt|;
name|abstractDesc
operator|.
name|setVectorDesc
argument_list|(
literal|null
argument_list|)
expr_stmt|;
block|}
block|}
return|return
literal|null
return|;
block|}
block|}
specifier|private
name|void
name|clearMapWorkVectorDescs
parameter_list|(
name|MapWork
name|mapWork
parameter_list|)
throws|throws
name|SemanticException
block|{
name|Map
argument_list|<
name|Rule
argument_list|,
name|NodeProcessor
argument_list|>
name|opRules
init|=
operator|new
name|LinkedHashMap
argument_list|<
name|Rule
argument_list|,
name|NodeProcessor
argument_list|>
argument_list|()
decl_stmt|;
name|ClearVectorDescsNodeProcessor
name|vnp
init|=
operator|new
name|ClearVectorDescsNodeProcessor
argument_list|()
decl_stmt|;
name|addMapWorkRules
argument_list|(
name|opRules
argument_list|,
name|vnp
argument_list|)
expr_stmt|;
name|Dispatcher
name|disp
init|=
operator|new
name|DefaultRuleDispatcher
argument_list|(
name|vnp
argument_list|,
name|opRules
argument_list|,
literal|null
argument_list|)
decl_stmt|;
name|GraphWalker
name|ogw
init|=
operator|new
name|DefaultGraphWalker
argument_list|(
name|disp
argument_list|)
decl_stmt|;
name|ArrayList
argument_list|<
name|Node
argument_list|>
name|topNodes
init|=
operator|new
name|ArrayList
argument_list|<
name|Node
argument_list|>
argument_list|()
decl_stmt|;
name|topNodes
operator|.
name|addAll
argument_list|(
name|mapWork
operator|.
name|getAliasToWork
argument_list|()
operator|.
name|values
argument_list|()
argument_list|)
expr_stmt|;
name|ogw
operator|.
name|startWalking
argument_list|(
name|topNodes
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|clearReduceWorkVectorDescs
parameter_list|(
name|ReduceWork
name|reduceWork
parameter_list|)
throws|throws
name|SemanticException
block|{
name|Map
argument_list|<
name|Rule
argument_list|,
name|NodeProcessor
argument_list|>
name|opRules
init|=
operator|new
name|LinkedHashMap
argument_list|<
name|Rule
argument_list|,
name|NodeProcessor
argument_list|>
argument_list|()
decl_stmt|;
name|ClearVectorDescsNodeProcessor
name|vnp
init|=
operator|new
name|ClearVectorDescsNodeProcessor
argument_list|()
decl_stmt|;
name|addReduceWorkRules
argument_list|(
name|opRules
argument_list|,
name|vnp
argument_list|)
expr_stmt|;
name|Dispatcher
name|disp
init|=
operator|new
name|DefaultRuleDispatcher
argument_list|(
name|vnp
argument_list|,
name|opRules
argument_list|,
literal|null
argument_list|)
decl_stmt|;
name|GraphWalker
name|ogw
init|=
operator|new
name|DefaultGraphWalker
argument_list|(
name|disp
argument_list|)
decl_stmt|;
name|ArrayList
argument_list|<
name|Node
argument_list|>
name|topNodes
init|=
operator|new
name|ArrayList
argument_list|<
name|Node
argument_list|>
argument_list|()
decl_stmt|;
name|topNodes
operator|.
name|add
argument_list|(
name|reduceWork
operator|.
name|getReducer
argument_list|()
argument_list|)
expr_stmt|;
name|ogw
operator|.
name|startWalking
argument_list|(
name|topNodes
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
block|}
class|class
name|MapWorkValidationNodeProcessor
implements|implements
name|NodeProcessor
block|{
specifier|private
specifier|final
name|MapWork
name|mapWork
decl_stmt|;
specifier|private
specifier|final
name|boolean
name|isTezOrSpark
decl_stmt|;
comment|// Children of Vectorized GROUPBY that outputs rows instead of vectorized row batchs.
specifier|protected
specifier|final
name|Set
argument_list|<
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
argument_list|>
name|nonVectorizedOps
init|=
operator|new
name|HashSet
argument_list|<
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
argument_list|>
argument_list|()
decl_stmt|;
specifier|public
name|Set
argument_list|<
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
argument_list|>
name|getNonVectorizedOps
parameter_list|()
block|{
return|return
name|nonVectorizedOps
return|;
block|}
specifier|public
name|MapWorkValidationNodeProcessor
parameter_list|(
name|MapWork
name|mapWork
parameter_list|,
name|boolean
name|isTezOrSpark
parameter_list|)
block|{
name|this
operator|.
name|mapWork
operator|=
name|mapWork
expr_stmt|;
name|this
operator|.
name|isTezOrSpark
operator|=
name|isTezOrSpark
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|Object
name|process
parameter_list|(
name|Node
name|nd
parameter_list|,
name|Stack
argument_list|<
name|Node
argument_list|>
name|stack
parameter_list|,
name|NodeProcessorCtx
name|procCtx
parameter_list|,
name|Object
modifier|...
name|nodeOutputs
parameter_list|)
throws|throws
name|SemanticException
block|{
for|for
control|(
name|Node
name|n
range|:
name|stack
control|)
block|{
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
name|op
init|=
operator|(
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
operator|)
name|n
decl_stmt|;
if|if
condition|(
name|nonVectorizedOps
operator|.
name|contains
argument_list|(
name|op
argument_list|)
condition|)
block|{
return|return
operator|new
name|Boolean
argument_list|(
literal|true
argument_list|)
return|;
block|}
name|boolean
name|ret
decl_stmt|;
name|currentOperator
operator|=
name|op
expr_stmt|;
try|try
block|{
name|ret
operator|=
name|validateMapWorkOperator
argument_list|(
name|op
argument_list|,
name|mapWork
argument_list|,
name|isTezOrSpark
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|e
argument_list|)
throw|;
block|}
if|if
condition|(
operator|!
name|ret
condition|)
block|{
return|return
operator|new
name|Boolean
argument_list|(
literal|false
argument_list|)
return|;
block|}
comment|// When Vectorized GROUPBY outputs rows instead of vectorized row batches, we don't
comment|// vectorize the operators below it.
if|if
condition|(
name|isVectorizedGroupByThatOutputsRows
argument_list|(
name|op
argument_list|)
condition|)
block|{
name|addOperatorChildrenToSet
argument_list|(
name|op
argument_list|,
name|nonVectorizedOps
argument_list|)
expr_stmt|;
return|return
operator|new
name|Boolean
argument_list|(
literal|true
argument_list|)
return|;
block|}
block|}
return|return
operator|new
name|Boolean
argument_list|(
literal|true
argument_list|)
return|;
block|}
block|}
class|class
name|ReduceWorkValidationNodeProcessor
implements|implements
name|NodeProcessor
block|{
comment|// Children of Vectorized GROUPBY that outputs rows instead of vectorized row batchs.
specifier|protected
specifier|final
name|Set
argument_list|<
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
argument_list|>
name|nonVectorizedOps
init|=
operator|new
name|HashSet
argument_list|<
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
argument_list|>
argument_list|()
decl_stmt|;
specifier|public
name|Set
argument_list|<
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
argument_list|>
name|getNonVectorizeOps
parameter_list|()
block|{
return|return
name|nonVectorizedOps
return|;
block|}
specifier|public
name|Set
argument_list|<
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
argument_list|>
name|getNonVectorizedOps
parameter_list|()
block|{
return|return
name|nonVectorizedOps
return|;
block|}
annotation|@
name|Override
specifier|public
name|Object
name|process
parameter_list|(
name|Node
name|nd
parameter_list|,
name|Stack
argument_list|<
name|Node
argument_list|>
name|stack
parameter_list|,
name|NodeProcessorCtx
name|procCtx
parameter_list|,
name|Object
modifier|...
name|nodeOutputs
parameter_list|)
throws|throws
name|SemanticException
block|{
for|for
control|(
name|Node
name|n
range|:
name|stack
control|)
block|{
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
name|op
init|=
operator|(
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
operator|)
name|n
decl_stmt|;
if|if
condition|(
name|nonVectorizedOps
operator|.
name|contains
argument_list|(
name|op
argument_list|)
condition|)
block|{
return|return
operator|new
name|Boolean
argument_list|(
literal|true
argument_list|)
return|;
block|}
name|currentOperator
operator|=
name|op
expr_stmt|;
name|boolean
name|ret
init|=
name|validateReduceWorkOperator
argument_list|(
name|op
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|ret
condition|)
block|{
return|return
operator|new
name|Boolean
argument_list|(
literal|false
argument_list|)
return|;
block|}
comment|// When Vectorized GROUPBY outputs rows instead of vectorized row batches, we don't
comment|// vectorize the operators below it.
if|if
condition|(
name|isVectorizedGroupByThatOutputsRows
argument_list|(
name|op
argument_list|)
condition|)
block|{
name|addOperatorChildrenToSet
argument_list|(
name|op
argument_list|,
name|nonVectorizedOps
argument_list|)
expr_stmt|;
return|return
operator|new
name|Boolean
argument_list|(
literal|true
argument_list|)
return|;
block|}
block|}
return|return
operator|new
name|Boolean
argument_list|(
literal|true
argument_list|)
return|;
block|}
block|}
comment|// This class has common code used by both MapWorkVectorizationNodeProcessor and
comment|// ReduceWorkVectorizationNodeProcessor.
class|class
name|VectorizationNodeProcessor
implements|implements
name|NodeProcessor
block|{
comment|// The vectorization context for the Map or Reduce task.
specifier|protected
name|VectorizationContext
name|taskVectorizationContext
decl_stmt|;
specifier|protected
specifier|final
name|VectorTaskColumnInfo
name|vectorTaskColumnInfo
decl_stmt|;
specifier|protected
specifier|final
name|Set
argument_list|<
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
argument_list|>
name|nonVectorizedOps
decl_stmt|;
name|VectorizationNodeProcessor
parameter_list|(
name|VectorTaskColumnInfo
name|vectorTaskColumnInfo
parameter_list|,
name|Set
argument_list|<
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
argument_list|>
name|nonVectorizedOps
parameter_list|)
block|{
name|this
operator|.
name|vectorTaskColumnInfo
operator|=
name|vectorTaskColumnInfo
expr_stmt|;
name|this
operator|.
name|nonVectorizedOps
operator|=
name|nonVectorizedOps
expr_stmt|;
block|}
specifier|public
name|String
index|[]
name|getVectorScratchColumnTypeNames
parameter_list|()
block|{
return|return
name|taskVectorizationContext
operator|.
name|getScratchColumnTypeNames
argument_list|()
return|;
block|}
specifier|protected
specifier|final
name|Set
argument_list|<
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
argument_list|>
name|opsDone
init|=
operator|new
name|HashSet
argument_list|<
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
argument_list|>
argument_list|()
decl_stmt|;
specifier|protected
specifier|final
name|Map
argument_list|<
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
argument_list|,
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
argument_list|>
name|opToVectorOpMap
init|=
operator|new
name|HashMap
argument_list|<
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
argument_list|,
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
argument_list|>
argument_list|()
decl_stmt|;
specifier|public
name|VectorizationContext
name|walkStackToFindVectorizationContext
parameter_list|(
name|Stack
argument_list|<
name|Node
argument_list|>
name|stack
parameter_list|,
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
name|op
parameter_list|)
throws|throws
name|SemanticException
block|{
name|VectorizationContext
name|vContext
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|stack
operator|.
name|size
argument_list|()
operator|<=
literal|1
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"Expected operator stack for operator %s to have at least 2 operators"
argument_list|,
name|op
operator|.
name|getName
argument_list|()
argument_list|)
argument_list|)
throw|;
block|}
comment|// Walk down the stack of operators until we found one willing to give us a context.
comment|// At the bottom will be the root operator, guaranteed to have a context
name|int
name|i
init|=
name|stack
operator|.
name|size
argument_list|()
operator|-
literal|2
decl_stmt|;
while|while
condition|(
name|vContext
operator|==
literal|null
condition|)
block|{
if|if
condition|(
name|i
operator|<
literal|0
condition|)
block|{
return|return
literal|null
return|;
block|}
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
name|opParent
init|=
operator|(
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
operator|)
name|stack
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
name|vectorOpParent
init|=
name|opToVectorOpMap
operator|.
name|get
argument_list|(
name|opParent
argument_list|)
decl_stmt|;
if|if
condition|(
name|vectorOpParent
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|vectorOpParent
operator|instanceof
name|VectorizationContextRegion
condition|)
block|{
name|VectorizationContextRegion
name|vcRegion
init|=
operator|(
name|VectorizationContextRegion
operator|)
name|vectorOpParent
decl_stmt|;
name|vContext
operator|=
name|vcRegion
operator|.
name|getOuputVectorizationContext
argument_list|()
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"walkStackToFindVectorizationContext "
operator|+
name|vectorOpParent
operator|.
name|getName
argument_list|()
operator|+
literal|" has new vectorization context "
operator|+
name|vContext
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"walkStackToFindVectorizationContext "
operator|+
name|vectorOpParent
operator|.
name|getName
argument_list|()
operator|+
literal|" does not have new vectorization context"
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"walkStackToFindVectorizationContext "
operator|+
name|opParent
operator|.
name|getName
argument_list|()
operator|+
literal|" is not vectorized"
argument_list|)
expr_stmt|;
block|}
operator|--
name|i
expr_stmt|;
block|}
return|return
name|vContext
return|;
block|}
specifier|public
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
name|doVectorize
parameter_list|(
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
name|op
parameter_list|,
name|VectorizationContext
name|vContext
parameter_list|,
name|boolean
name|isTezOrSpark
parameter_list|)
throws|throws
name|SemanticException
block|{
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
name|vectorOp
init|=
name|op
decl_stmt|;
try|try
block|{
if|if
condition|(
operator|!
name|opsDone
operator|.
name|contains
argument_list|(
name|op
argument_list|)
condition|)
block|{
name|vectorOp
operator|=
name|vectorizeOperator
argument_list|(
name|op
argument_list|,
name|vContext
argument_list|,
name|isTezOrSpark
argument_list|,
name|vectorTaskColumnInfo
argument_list|)
expr_stmt|;
name|opsDone
operator|.
name|add
argument_list|(
name|op
argument_list|)
expr_stmt|;
if|if
condition|(
name|vectorOp
operator|!=
name|op
condition|)
block|{
name|opToVectorOpMap
operator|.
name|put
argument_list|(
name|op
argument_list|,
name|vectorOp
argument_list|)
expr_stmt|;
name|opsDone
operator|.
name|add
argument_list|(
name|vectorOp
argument_list|)
expr_stmt|;
block|}
block|}
block|}
catch|catch
parameter_list|(
name|HiveException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|e
argument_list|)
throw|;
block|}
return|return
name|vectorOp
return|;
block|}
annotation|@
name|Override
specifier|public
name|Object
name|process
parameter_list|(
name|Node
name|nd
parameter_list|,
name|Stack
argument_list|<
name|Node
argument_list|>
name|stack
parameter_list|,
name|NodeProcessorCtx
name|procCtx
parameter_list|,
name|Object
modifier|...
name|nodeOutputs
parameter_list|)
throws|throws
name|SemanticException
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
literal|"Must be overridden"
argument_list|)
throw|;
block|}
block|}
class|class
name|MapWorkVectorizationNodeProcessor
extends|extends
name|VectorizationNodeProcessor
block|{
specifier|private
specifier|final
name|VectorTaskColumnInfo
name|vectorTaskColumnInfo
decl_stmt|;
specifier|private
specifier|final
name|boolean
name|isTezOrSpark
decl_stmt|;
specifier|public
name|MapWorkVectorizationNodeProcessor
parameter_list|(
name|MapWork
name|mWork
parameter_list|,
name|boolean
name|isTezOrSpark
parameter_list|,
name|VectorTaskColumnInfo
name|vectorTaskColumnInfo
parameter_list|)
block|{
name|super
argument_list|(
name|vectorTaskColumnInfo
argument_list|,
name|vectorTaskColumnInfo
operator|.
name|getNonVectorizedOps
argument_list|()
argument_list|)
expr_stmt|;
name|this
operator|.
name|vectorTaskColumnInfo
operator|=
name|vectorTaskColumnInfo
expr_stmt|;
name|this
operator|.
name|isTezOrSpark
operator|=
name|isTezOrSpark
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|Object
name|process
parameter_list|(
name|Node
name|nd
parameter_list|,
name|Stack
argument_list|<
name|Node
argument_list|>
name|stack
parameter_list|,
name|NodeProcessorCtx
name|procCtx
parameter_list|,
name|Object
modifier|...
name|nodeOutputs
parameter_list|)
throws|throws
name|SemanticException
block|{
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
name|op
init|=
operator|(
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
operator|)
name|nd
decl_stmt|;
if|if
condition|(
name|nonVectorizedOps
operator|.
name|contains
argument_list|(
name|op
argument_list|)
condition|)
block|{
return|return
literal|null
return|;
block|}
name|VectorizationContext
name|vContext
init|=
literal|null
decl_stmt|;
name|currentOperator
operator|=
name|op
expr_stmt|;
if|if
condition|(
name|op
operator|instanceof
name|TableScanOperator
condition|)
block|{
if|if
condition|(
name|taskVectorizationContext
operator|==
literal|null
condition|)
block|{
name|taskVectorizationContext
operator|=
name|getVectorizationContext
argument_list|(
name|op
operator|.
name|getName
argument_list|()
argument_list|,
name|vectorTaskColumnInfo
argument_list|)
expr_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isInfoEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"MapWorkVectorizationNodeProcessor process vectorizedVertexNum "
operator|+
name|vectorizedVertexNum
operator|+
literal|" mapColumnNames "
operator|+
name|vectorTaskColumnInfo
operator|.
name|allColumnNames
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"MapWorkVectorizationNodeProcessor process vectorizedVertexNum "
operator|+
name|vectorizedVertexNum
operator|+
literal|" mapTypeInfos "
operator|+
name|vectorTaskColumnInfo
operator|.
name|allTypeInfos
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
name|vContext
operator|=
name|taskVectorizationContext
expr_stmt|;
block|}
else|else
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"MapWorkVectorizationNodeProcessor process going to walk the operator stack to get vectorization context for "
operator|+
name|op
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
name|vContext
operator|=
name|walkStackToFindVectorizationContext
argument_list|(
name|stack
argument_list|,
name|op
argument_list|)
expr_stmt|;
if|if
condition|(
name|vContext
operator|==
literal|null
condition|)
block|{
comment|// No operator has "pushed" a new context -- so use the task vectorization context.
name|vContext
operator|=
name|taskVectorizationContext
expr_stmt|;
block|}
block|}
assert|assert
name|vContext
operator|!=
literal|null
assert|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"MapWorkVectorizationNodeProcessor process operator "
operator|+
name|op
operator|.
name|getName
argument_list|()
operator|+
literal|" using vectorization context"
operator|+
name|vContext
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
name|vectorOp
init|=
name|doVectorize
argument_list|(
name|op
argument_list|,
name|vContext
argument_list|,
name|isTezOrSpark
argument_list|)
decl_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
if|if
condition|(
name|vectorOp
operator|instanceof
name|VectorizationContextRegion
condition|)
block|{
name|VectorizationContextRegion
name|vcRegion
init|=
operator|(
name|VectorizationContextRegion
operator|)
name|vectorOp
decl_stmt|;
name|VectorizationContext
name|vNewContext
init|=
name|vcRegion
operator|.
name|getOuputVectorizationContext
argument_list|()
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Vectorized MapWork operator "
operator|+
name|vectorOp
operator|.
name|getName
argument_list|()
operator|+
literal|" added vectorization context "
operator|+
name|vNewContext
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
return|return
literal|null
return|;
block|}
block|}
class|class
name|ReduceWorkVectorizationNodeProcessor
extends|extends
name|VectorizationNodeProcessor
block|{
specifier|private
specifier|final
name|VectorTaskColumnInfo
name|vectorTaskColumnInfo
decl_stmt|;
specifier|private
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
name|rootVectorOp
decl_stmt|;
specifier|public
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
name|getRootVectorOp
parameter_list|()
block|{
return|return
name|rootVectorOp
return|;
block|}
specifier|public
name|ReduceWorkVectorizationNodeProcessor
parameter_list|(
name|VectorTaskColumnInfo
name|vectorTaskColumnInfo
parameter_list|)
block|{
name|super
argument_list|(
name|vectorTaskColumnInfo
argument_list|,
name|vectorTaskColumnInfo
operator|.
name|getNonVectorizedOps
argument_list|()
argument_list|)
expr_stmt|;
name|this
operator|.
name|vectorTaskColumnInfo
operator|=
name|vectorTaskColumnInfo
expr_stmt|;
name|rootVectorOp
operator|=
literal|null
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|Object
name|process
parameter_list|(
name|Node
name|nd
parameter_list|,
name|Stack
argument_list|<
name|Node
argument_list|>
name|stack
parameter_list|,
name|NodeProcessorCtx
name|procCtx
parameter_list|,
name|Object
modifier|...
name|nodeOutputs
parameter_list|)
throws|throws
name|SemanticException
block|{
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
name|op
init|=
operator|(
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
operator|)
name|nd
decl_stmt|;
if|if
condition|(
name|nonVectorizedOps
operator|.
name|contains
argument_list|(
name|op
argument_list|)
condition|)
block|{
return|return
literal|null
return|;
block|}
name|VectorizationContext
name|vContext
init|=
literal|null
decl_stmt|;
name|boolean
name|saveRootVectorOp
init|=
literal|false
decl_stmt|;
name|currentOperator
operator|=
name|op
expr_stmt|;
if|if
condition|(
name|op
operator|.
name|getParentOperators
argument_list|()
operator|.
name|size
argument_list|()
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isInfoEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"ReduceWorkVectorizationNodeProcessor process vectorizedVertexNum "
operator|+
name|vectorizedVertexNum
operator|+
literal|" reduceColumnNames "
operator|+
name|vectorTaskColumnInfo
operator|.
name|allColumnNames
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"ReduceWorkVectorizationNodeProcessor process vectorizedVertexNum "
operator|+
name|vectorizedVertexNum
operator|+
literal|" reduceTypeInfos "
operator|+
name|vectorTaskColumnInfo
operator|.
name|allTypeInfos
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|vContext
operator|=
operator|new
name|VectorizationContext
argument_list|(
literal|"__Reduce_Shuffle__"
argument_list|,
name|vectorTaskColumnInfo
operator|.
name|allColumnNames
argument_list|,
name|hiveConf
argument_list|)
expr_stmt|;
name|taskVectorizationContext
operator|=
name|vContext
expr_stmt|;
name|saveRootVectorOp
operator|=
literal|true
expr_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Vectorized ReduceWork reduce shuffle vectorization context "
operator|+
name|vContext
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"ReduceWorkVectorizationNodeProcessor process going to walk the operator stack to get vectorization context for "
operator|+
name|op
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
name|vContext
operator|=
name|walkStackToFindVectorizationContext
argument_list|(
name|stack
argument_list|,
name|op
argument_list|)
expr_stmt|;
if|if
condition|(
name|vContext
operator|==
literal|null
condition|)
block|{
comment|// If we didn't find a context among the operators, assume the top -- reduce shuffle's
comment|// vectorization context.
name|vContext
operator|=
name|taskVectorizationContext
expr_stmt|;
block|}
block|}
assert|assert
name|vContext
operator|!=
literal|null
assert|;
name|LOG
operator|.
name|info
argument_list|(
literal|"ReduceWorkVectorizationNodeProcessor process operator "
operator|+
name|op
operator|.
name|getName
argument_list|()
operator|+
literal|" using vectorization context"
operator|+
name|vContext
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
name|vectorOp
init|=
name|doVectorize
argument_list|(
name|op
argument_list|,
name|vContext
argument_list|,
literal|true
argument_list|)
decl_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
if|if
condition|(
name|vectorOp
operator|instanceof
name|VectorizationContextRegion
condition|)
block|{
name|VectorizationContextRegion
name|vcRegion
init|=
operator|(
name|VectorizationContextRegion
operator|)
name|vectorOp
decl_stmt|;
name|VectorizationContext
name|vNewContext
init|=
name|vcRegion
operator|.
name|getOuputVectorizationContext
argument_list|()
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Vectorized ReduceWork operator "
operator|+
name|vectorOp
operator|.
name|getName
argument_list|()
operator|+
literal|" added vectorization context "
operator|+
name|vNewContext
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|saveRootVectorOp
operator|&&
name|op
operator|!=
name|vectorOp
condition|)
block|{
name|rootVectorOp
operator|=
name|vectorOp
expr_stmt|;
block|}
return|return
literal|null
return|;
block|}
block|}
specifier|private
specifier|static
class|class
name|ValidatorVectorizationContext
extends|extends
name|VectorizationContext
block|{
specifier|private
name|ValidatorVectorizationContext
parameter_list|(
name|HiveConf
name|hiveConf
parameter_list|)
block|{
name|super
argument_list|(
literal|"No Name"
argument_list|,
name|hiveConf
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|protected
name|int
name|getInputColumnIndex
parameter_list|(
name|String
name|name
parameter_list|)
block|{
return|return
literal|0
return|;
block|}
annotation|@
name|Override
specifier|protected
name|int
name|getInputColumnIndex
parameter_list|(
name|ExprNodeColumnDesc
name|colExpr
parameter_list|)
block|{
return|return
literal|0
return|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|PhysicalContext
name|resolve
parameter_list|(
name|PhysicalContext
name|physicalContext
parameter_list|)
throws|throws
name|SemanticException
block|{
name|hiveConf
operator|=
name|physicalContext
operator|.
name|getConf
argument_list|()
expr_stmt|;
name|boolean
name|vectorPath
init|=
name|HiveConf
operator|.
name|getBoolVar
argument_list|(
name|hiveConf
argument_list|,
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVE_VECTORIZATION_ENABLED
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|vectorPath
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Vectorization is disabled"
argument_list|)
expr_stmt|;
return|return
name|physicalContext
return|;
block|}
name|useVectorizedInputFileFormat
operator|=
name|HiveConf
operator|.
name|getBoolVar
argument_list|(
name|hiveConf
argument_list|,
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVE_VECTORIZATION_USE_VECTORIZED_INPUT_FILE_FORMAT
argument_list|)
expr_stmt|;
name|useVectorDeserialize
operator|=
name|HiveConf
operator|.
name|getBoolVar
argument_list|(
name|hiveConf
argument_list|,
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVE_VECTORIZATION_USE_VECTOR_DESERIALIZE
argument_list|)
expr_stmt|;
name|useRowDeserialize
operator|=
name|HiveConf
operator|.
name|getBoolVar
argument_list|(
name|hiveConf
argument_list|,
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVE_VECTORIZATION_USE_ROW_DESERIALIZE
argument_list|)
expr_stmt|;
comment|// TODO: we could also vectorize some formats based on hive.llap.io.encode.formats if LLAP IO
comment|//       is enabled and we are going to run in LLAP. However, we don't know if we end up in
comment|//       LLAP or not at this stage, so don't do this now. We may need to add a 'force' option.
name|isReduceVectorizationEnabled
operator|=
name|HiveConf
operator|.
name|getBoolVar
argument_list|(
name|hiveConf
argument_list|,
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVE_VECTORIZATION_REDUCE_ENABLED
argument_list|)
expr_stmt|;
name|isSchemaEvolution
operator|=
name|HiveConf
operator|.
name|getBoolVar
argument_list|(
name|hiveConf
argument_list|,
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVE_SCHEMA_EVOLUTION
argument_list|)
expr_stmt|;
name|hiveVectorAdaptorUsageMode
operator|=
name|HiveVectorAdaptorUsageMode
operator|.
name|getHiveConfValue
argument_list|(
name|hiveConf
argument_list|)
expr_stmt|;
comment|// create dispatcher and graph walker
name|Dispatcher
name|disp
init|=
operator|new
name|VectorizationDispatcher
argument_list|()
decl_stmt|;
name|TaskGraphWalker
name|ogw
init|=
operator|new
name|TaskGraphWalker
argument_list|(
name|disp
argument_list|)
decl_stmt|;
comment|// get all the tasks nodes from root task
name|ArrayList
argument_list|<
name|Node
argument_list|>
name|topNodes
init|=
operator|new
name|ArrayList
argument_list|<
name|Node
argument_list|>
argument_list|()
decl_stmt|;
name|topNodes
operator|.
name|addAll
argument_list|(
name|physicalContext
operator|.
name|getRootTasks
argument_list|()
argument_list|)
expr_stmt|;
comment|// begin to walk through the task tree.
name|ogw
operator|.
name|startWalking
argument_list|(
name|topNodes
argument_list|,
literal|null
argument_list|)
expr_stmt|;
return|return
name|physicalContext
return|;
block|}
specifier|private
name|void
name|setOperatorNotSupported
parameter_list|(
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
name|op
parameter_list|)
block|{
name|OperatorDesc
name|desc
init|=
name|op
operator|.
name|getConf
argument_list|()
decl_stmt|;
name|Annotation
name|note
init|=
name|AnnotationUtils
operator|.
name|getAnnotation
argument_list|(
name|desc
operator|.
name|getClass
argument_list|()
argument_list|,
name|Explain
operator|.
name|class
argument_list|)
decl_stmt|;
if|if
condition|(
name|note
operator|!=
literal|null
condition|)
block|{
name|Explain
name|explainNote
init|=
operator|(
name|Explain
operator|)
name|note
decl_stmt|;
name|setNodeIssue
argument_list|(
name|explainNote
operator|.
name|displayName
argument_list|()
operator|+
literal|" ("
operator|+
name|op
operator|.
name|getType
argument_list|()
operator|+
literal|") not supported"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|setNodeIssue
argument_list|(
literal|"Operator "
operator|+
name|op
operator|.
name|getType
argument_list|()
operator|+
literal|" not supported"
argument_list|)
expr_stmt|;
block|}
block|}
name|boolean
name|validateMapWorkOperator
parameter_list|(
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
name|op
parameter_list|,
name|MapWork
name|mWork
parameter_list|,
name|boolean
name|isTezOrSpark
parameter_list|)
block|{
name|boolean
name|ret
decl_stmt|;
switch|switch
condition|(
name|op
operator|.
name|getType
argument_list|()
condition|)
block|{
case|case
name|MAPJOIN
case|:
if|if
condition|(
name|op
operator|instanceof
name|MapJoinOperator
condition|)
block|{
name|ret
operator|=
name|validateMapJoinOperator
argument_list|(
operator|(
name|MapJoinOperator
operator|)
name|op
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|op
operator|instanceof
name|SMBMapJoinOperator
condition|)
block|{
name|ret
operator|=
name|validateSMBMapJoinOperator
argument_list|(
operator|(
name|SMBMapJoinOperator
operator|)
name|op
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|setOperatorNotSupported
argument_list|(
name|op
argument_list|)
expr_stmt|;
name|ret
operator|=
literal|false
expr_stmt|;
block|}
break|break;
case|case
name|GROUPBY
case|:
name|ret
operator|=
name|validateGroupByOperator
argument_list|(
operator|(
name|GroupByOperator
operator|)
name|op
argument_list|,
literal|false
argument_list|,
name|isTezOrSpark
argument_list|)
expr_stmt|;
break|break;
case|case
name|FILTER
case|:
name|ret
operator|=
name|validateFilterOperator
argument_list|(
operator|(
name|FilterOperator
operator|)
name|op
argument_list|)
expr_stmt|;
break|break;
case|case
name|SELECT
case|:
name|ret
operator|=
name|validateSelectOperator
argument_list|(
operator|(
name|SelectOperator
operator|)
name|op
argument_list|)
expr_stmt|;
break|break;
case|case
name|REDUCESINK
case|:
name|ret
operator|=
name|validateReduceSinkOperator
argument_list|(
operator|(
name|ReduceSinkOperator
operator|)
name|op
argument_list|)
expr_stmt|;
break|break;
case|case
name|TABLESCAN
case|:
name|ret
operator|=
name|validateTableScanOperator
argument_list|(
operator|(
name|TableScanOperator
operator|)
name|op
argument_list|,
name|mWork
argument_list|)
expr_stmt|;
break|break;
case|case
name|FILESINK
case|:
case|case
name|LIMIT
case|:
case|case
name|EVENT
case|:
case|case
name|SPARKPRUNINGSINK
case|:
name|ret
operator|=
literal|true
expr_stmt|;
break|break;
case|case
name|HASHTABLESINK
case|:
name|ret
operator|=
name|op
operator|instanceof
name|SparkHashTableSinkOperator
operator|&&
name|validateSparkHashTableSinkOperator
argument_list|(
operator|(
name|SparkHashTableSinkOperator
operator|)
name|op
argument_list|)
expr_stmt|;
break|break;
default|default:
name|setOperatorNotSupported
argument_list|(
name|op
argument_list|)
expr_stmt|;
name|ret
operator|=
literal|false
expr_stmt|;
break|break;
block|}
return|return
name|ret
return|;
block|}
name|boolean
name|validateReduceWorkOperator
parameter_list|(
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
name|op
parameter_list|)
block|{
name|boolean
name|ret
decl_stmt|;
switch|switch
condition|(
name|op
operator|.
name|getType
argument_list|()
condition|)
block|{
case|case
name|MAPJOIN
case|:
comment|// Does MAPJOIN actually get planned in Reduce?
if|if
condition|(
name|op
operator|instanceof
name|MapJoinOperator
condition|)
block|{
name|ret
operator|=
name|validateMapJoinOperator
argument_list|(
operator|(
name|MapJoinOperator
operator|)
name|op
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|op
operator|instanceof
name|SMBMapJoinOperator
condition|)
block|{
name|ret
operator|=
name|validateSMBMapJoinOperator
argument_list|(
operator|(
name|SMBMapJoinOperator
operator|)
name|op
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|setOperatorNotSupported
argument_list|(
name|op
argument_list|)
expr_stmt|;
name|ret
operator|=
literal|false
expr_stmt|;
block|}
break|break;
case|case
name|GROUPBY
case|:
if|if
condition|(
name|HiveConf
operator|.
name|getBoolVar
argument_list|(
name|hiveConf
argument_list|,
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVE_VECTORIZATION_REDUCE_GROUPBY_ENABLED
argument_list|)
condition|)
block|{
name|ret
operator|=
name|validateGroupByOperator
argument_list|(
operator|(
name|GroupByOperator
operator|)
name|op
argument_list|,
literal|true
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|setNodeIssue
argument_list|(
literal|"Operator "
operator|+
name|op
operator|.
name|getType
argument_list|()
operator|+
literal|" not enabled ("
operator|+
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVE_VECTORIZATION_REDUCE_GROUPBY_ENABLED
operator|.
name|name
argument_list|()
operator|+
literal|"=true IS false)"
argument_list|)
expr_stmt|;
name|ret
operator|=
literal|false
expr_stmt|;
block|}
break|break;
case|case
name|FILTER
case|:
name|ret
operator|=
name|validateFilterOperator
argument_list|(
operator|(
name|FilterOperator
operator|)
name|op
argument_list|)
expr_stmt|;
break|break;
case|case
name|SELECT
case|:
name|ret
operator|=
name|validateSelectOperator
argument_list|(
operator|(
name|SelectOperator
operator|)
name|op
argument_list|)
expr_stmt|;
break|break;
case|case
name|REDUCESINK
case|:
name|ret
operator|=
name|validateReduceSinkOperator
argument_list|(
operator|(
name|ReduceSinkOperator
operator|)
name|op
argument_list|)
expr_stmt|;
break|break;
case|case
name|FILESINK
case|:
name|ret
operator|=
name|validateFileSinkOperator
argument_list|(
operator|(
name|FileSinkOperator
operator|)
name|op
argument_list|)
expr_stmt|;
break|break;
case|case
name|LIMIT
case|:
case|case
name|EVENT
case|:
case|case
name|SPARKPRUNINGSINK
case|:
name|ret
operator|=
literal|true
expr_stmt|;
break|break;
case|case
name|HASHTABLESINK
case|:
name|ret
operator|=
name|op
operator|instanceof
name|SparkHashTableSinkOperator
operator|&&
name|validateSparkHashTableSinkOperator
argument_list|(
operator|(
name|SparkHashTableSinkOperator
operator|)
name|op
argument_list|)
expr_stmt|;
break|break;
default|default:
name|setOperatorNotSupported
argument_list|(
name|op
argument_list|)
expr_stmt|;
name|ret
operator|=
literal|false
expr_stmt|;
break|break;
block|}
return|return
name|ret
return|;
block|}
specifier|private
name|void
name|addOperatorChildrenToSet
parameter_list|(
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
name|op
parameter_list|,
name|Set
argument_list|<
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
argument_list|>
name|nonVectorizedOps
parameter_list|)
block|{
for|for
control|(
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
name|childOp
range|:
name|op
operator|.
name|getChildOperators
argument_list|()
control|)
block|{
if|if
condition|(
operator|!
name|nonVectorizedOps
operator|.
name|contains
argument_list|(
name|childOp
argument_list|)
condition|)
block|{
name|nonVectorizedOps
operator|.
name|add
argument_list|(
name|childOp
argument_list|)
expr_stmt|;
name|addOperatorChildrenToSet
argument_list|(
name|childOp
argument_list|,
name|nonVectorizedOps
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|// When Vectorized GROUPBY outputs rows instead of vectorized row batchs, we don't
comment|// vectorize the operators below it.
specifier|private
name|Boolean
name|isVectorizedGroupByThatOutputsRows
parameter_list|(
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
name|op
parameter_list|)
throws|throws
name|SemanticException
block|{
if|if
condition|(
name|op
operator|.
name|getType
argument_list|()
operator|.
name|equals
argument_list|(
name|OperatorType
operator|.
name|GROUPBY
argument_list|)
condition|)
block|{
name|GroupByDesc
name|desc
init|=
operator|(
name|GroupByDesc
operator|)
name|op
operator|.
name|getConf
argument_list|()
decl_stmt|;
return|return
operator|!
operator|(
operator|(
name|VectorGroupByDesc
operator|)
name|desc
operator|.
name|getVectorDesc
argument_list|()
operator|)
operator|.
name|isVectorOutput
argument_list|()
return|;
block|}
return|return
literal|false
return|;
block|}
specifier|private
name|boolean
name|validateSMBMapJoinOperator
parameter_list|(
name|SMBMapJoinOperator
name|op
parameter_list|)
block|{
name|SMBJoinDesc
name|desc
init|=
name|op
operator|.
name|getConf
argument_list|()
decl_stmt|;
comment|// Validation is the same as for map join, since the 'small' tables are not vectorized
return|return
name|validateMapJoinDesc
argument_list|(
name|desc
argument_list|)
return|;
block|}
specifier|private
name|boolean
name|validateTableScanOperator
parameter_list|(
name|TableScanOperator
name|op
parameter_list|,
name|MapWork
name|mWork
parameter_list|)
block|{
name|TableScanDesc
name|desc
init|=
name|op
operator|.
name|getConf
argument_list|()
decl_stmt|;
if|if
condition|(
name|desc
operator|.
name|isGatherStats
argument_list|()
condition|)
block|{
name|setOperatorIssue
argument_list|(
literal|"gather stats not supported"
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
return|return
literal|true
return|;
block|}
specifier|private
name|boolean
name|validateMapJoinOperator
parameter_list|(
name|MapJoinOperator
name|op
parameter_list|)
block|{
name|MapJoinDesc
name|desc
init|=
name|op
operator|.
name|getConf
argument_list|()
decl_stmt|;
return|return
name|validateMapJoinDesc
argument_list|(
name|desc
argument_list|)
return|;
block|}
specifier|private
name|boolean
name|validateMapJoinDesc
parameter_list|(
name|MapJoinDesc
name|desc
parameter_list|)
block|{
name|byte
name|posBigTable
init|=
operator|(
name|byte
operator|)
name|desc
operator|.
name|getPosBigTable
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|ExprNodeDesc
argument_list|>
name|filterExprs
init|=
name|desc
operator|.
name|getFilters
argument_list|()
operator|.
name|get
argument_list|(
name|posBigTable
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|validateExprNodeDesc
argument_list|(
name|filterExprs
argument_list|,
literal|"Filter"
argument_list|,
name|VectorExpressionDescriptor
operator|.
name|Mode
operator|.
name|FILTER
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
name|List
argument_list|<
name|ExprNodeDesc
argument_list|>
name|keyExprs
init|=
name|desc
operator|.
name|getKeys
argument_list|()
operator|.
name|get
argument_list|(
name|posBigTable
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|validateExprNodeDesc
argument_list|(
name|keyExprs
argument_list|,
literal|"Key"
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
name|List
argument_list|<
name|ExprNodeDesc
argument_list|>
name|valueExprs
init|=
name|desc
operator|.
name|getExprs
argument_list|()
operator|.
name|get
argument_list|(
name|posBigTable
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|validateExprNodeDesc
argument_list|(
name|valueExprs
argument_list|,
literal|"Value"
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
name|Byte
index|[]
name|order
init|=
name|desc
operator|.
name|getTagOrder
argument_list|()
decl_stmt|;
name|Byte
name|posSingleVectorMapJoinSmallTable
init|=
operator|(
name|order
index|[
literal|0
index|]
operator|==
name|posBigTable
condition|?
name|order
index|[
literal|1
index|]
else|:
name|order
index|[
literal|0
index|]
operator|)
decl_stmt|;
name|List
argument_list|<
name|ExprNodeDesc
argument_list|>
name|smallTableExprs
init|=
name|desc
operator|.
name|getExprs
argument_list|()
operator|.
name|get
argument_list|(
name|posSingleVectorMapJoinSmallTable
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|validateExprNodeDesc
argument_list|(
name|smallTableExprs
argument_list|,
literal|"Small Table"
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
if|if
condition|(
name|desc
operator|.
name|getResidualFilterExprs
argument_list|()
operator|!=
literal|null
operator|&&
operator|!
name|desc
operator|.
name|getResidualFilterExprs
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Cannot vectorize outer join with complex ON clause"
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
return|return
literal|true
return|;
block|}
specifier|private
name|boolean
name|validateSparkHashTableSinkOperator
parameter_list|(
name|SparkHashTableSinkOperator
name|op
parameter_list|)
block|{
name|SparkHashTableSinkDesc
name|desc
init|=
name|op
operator|.
name|getConf
argument_list|()
decl_stmt|;
name|byte
name|tag
init|=
name|desc
operator|.
name|getTag
argument_list|()
decl_stmt|;
comment|// it's essentially a MapJoinDesc
name|List
argument_list|<
name|ExprNodeDesc
argument_list|>
name|filterExprs
init|=
name|desc
operator|.
name|getFilters
argument_list|()
operator|.
name|get
argument_list|(
name|tag
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|ExprNodeDesc
argument_list|>
name|keyExprs
init|=
name|desc
operator|.
name|getKeys
argument_list|()
operator|.
name|get
argument_list|(
name|tag
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|ExprNodeDesc
argument_list|>
name|valueExprs
init|=
name|desc
operator|.
name|getExprs
argument_list|()
operator|.
name|get
argument_list|(
name|tag
argument_list|)
decl_stmt|;
return|return
name|validateExprNodeDesc
argument_list|(
name|filterExprs
argument_list|,
literal|"Filter"
argument_list|,
name|VectorExpressionDescriptor
operator|.
name|Mode
operator|.
name|FILTER
argument_list|)
operator|&&
name|validateExprNodeDesc
argument_list|(
name|keyExprs
argument_list|,
literal|"Key"
argument_list|)
operator|&&
name|validateExprNodeDesc
argument_list|(
name|valueExprs
argument_list|,
literal|"Value"
argument_list|)
return|;
block|}
specifier|private
name|boolean
name|validateReduceSinkOperator
parameter_list|(
name|ReduceSinkOperator
name|op
parameter_list|)
block|{
name|List
argument_list|<
name|ExprNodeDesc
argument_list|>
name|keyDescs
init|=
name|op
operator|.
name|getConf
argument_list|()
operator|.
name|getKeyCols
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|ExprNodeDesc
argument_list|>
name|partitionDescs
init|=
name|op
operator|.
name|getConf
argument_list|()
operator|.
name|getPartitionCols
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|ExprNodeDesc
argument_list|>
name|valueDesc
init|=
name|op
operator|.
name|getConf
argument_list|()
operator|.
name|getValueCols
argument_list|()
decl_stmt|;
return|return
name|validateExprNodeDesc
argument_list|(
name|keyDescs
argument_list|,
literal|"Key"
argument_list|)
operator|&&
name|validateExprNodeDesc
argument_list|(
name|partitionDescs
argument_list|,
literal|"Partition"
argument_list|)
operator|&&
name|validateExprNodeDesc
argument_list|(
name|valueDesc
argument_list|,
literal|"Value"
argument_list|)
return|;
block|}
specifier|private
name|boolean
name|validateSelectOperator
parameter_list|(
name|SelectOperator
name|op
parameter_list|)
block|{
name|List
argument_list|<
name|ExprNodeDesc
argument_list|>
name|descList
init|=
name|op
operator|.
name|getConf
argument_list|()
operator|.
name|getColList
argument_list|()
decl_stmt|;
for|for
control|(
name|ExprNodeDesc
name|desc
range|:
name|descList
control|)
block|{
name|boolean
name|ret
init|=
name|validateExprNodeDesc
argument_list|(
name|desc
argument_list|,
literal|"Select"
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|ret
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
return|return
literal|true
return|;
block|}
specifier|private
name|boolean
name|validateFilterOperator
parameter_list|(
name|FilterOperator
name|op
parameter_list|)
block|{
name|ExprNodeDesc
name|desc
init|=
name|op
operator|.
name|getConf
argument_list|()
operator|.
name|getPredicate
argument_list|()
decl_stmt|;
return|return
name|validateExprNodeDesc
argument_list|(
name|desc
argument_list|,
literal|"Predicate"
argument_list|,
name|VectorExpressionDescriptor
operator|.
name|Mode
operator|.
name|FILTER
argument_list|)
return|;
block|}
specifier|private
name|boolean
name|validateGroupByOperator
parameter_list|(
name|GroupByOperator
name|op
parameter_list|,
name|boolean
name|isReduce
parameter_list|,
name|boolean
name|isTezOrSpark
parameter_list|)
block|{
name|GroupByDesc
name|desc
init|=
name|op
operator|.
name|getConf
argument_list|()
decl_stmt|;
if|if
condition|(
name|desc
operator|.
name|isGroupingSetsPresent
argument_list|()
condition|)
block|{
name|setOperatorIssue
argument_list|(
literal|"Grouping sets not supported"
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
name|desc
operator|.
name|pruneGroupingSetId
argument_list|()
condition|)
block|{
name|setOperatorIssue
argument_list|(
literal|"Pruning grouping set id not supported"
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
name|desc
operator|.
name|getMode
argument_list|()
operator|!=
name|GroupByDesc
operator|.
name|Mode
operator|.
name|HASH
operator|&&
name|desc
operator|.
name|isDistinct
argument_list|()
condition|)
block|{
name|setOperatorIssue
argument_list|(
literal|"DISTINCT not supported"
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
name|boolean
name|ret
init|=
name|validateExprNodeDesc
argument_list|(
name|desc
operator|.
name|getKeys
argument_list|()
argument_list|,
literal|"Key"
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|ret
condition|)
block|{
return|return
literal|false
return|;
block|}
comment|/**      *      * GROUP BY DEFINITIONS:      *      * GroupByDesc.Mode enumeration:      *      *    The different modes of a GROUP BY operator.      *      *    These descriptions are hopefully less cryptic than the comments for GroupByDesc.Mode.      *      *        COMPLETE       Aggregates original rows into full aggregation row(s).      *      *                       If the key length is 0, this is also called Global aggregation and      *                       1 output row is produced.      *      *                       When the key length is> 0, the original rows come in ALREADY GROUPED.      *      *                       An example for key length> 0 is a GROUP BY being applied to the      *                       ALREADY GROUPED rows coming from an upstream JOIN operator.  Or,      *                       ALREADY GROUPED rows coming from upstream MERGEPARTIAL GROUP BY      *                       operator.      *      *        PARTIAL1       The first of 2 (or more) phases that aggregates ALREADY GROUPED      *                       original rows into partial aggregations.      *      *                       Subsequent phases PARTIAL2 (optional) and MERGEPARTIAL will merge      *                       the partial aggregations and output full aggregations.      *      *        PARTIAL2       Accept ALREADY GROUPED partial aggregations and merge them into another      *                       partial aggregation.  Output the merged partial aggregations.      *      *                       (Haven't seen this one used)      *      *        PARTIALS       (Behaves for non-distinct the same as PARTIAL2; and behaves for      *                       distinct the same as PARTIAL1.)      *      *        FINAL          Accept ALREADY GROUPED original rows and aggregate them into      *                       full aggregations.      *      *                       Example is a GROUP BY being applied to rows from a sorted table, where      *                       the group key is the table sort key (or a prefix).      *      *        HASH           Accept UNORDERED original rows and aggregate them into a memory table.      *                       Output the partial aggregations on closeOp (or low memory).      *      *                       Similar to PARTIAL1 except original rows are UNORDERED.      *      *                       Commonly used in both Mapper and Reducer nodes.  Always followed by      *                       a Reducer with MERGEPARTIAL GROUP BY.      *      *        MERGEPARTIAL   Always first operator of a Reducer.  Data is grouped by reduce-shuffle.      *      *                       (Behaves for non-distinct aggregations the same as FINAL; and behaves      *                       for distinct aggregations the same as COMPLETE.)      *      *                       The output is full aggregation(s).      *      *                       Used in Reducers after a stage with a HASH GROUP BY operator.      *      *      *  VectorGroupByDesc.ProcessingMode for VectorGroupByOperator:      *      *     GLOBAL         No key.  All rows --> 1 full aggregation on end of input      *      *     HASH           Rows aggregated in to hash table on group key -->      *                        1 partial aggregation per key (normally, unless there is spilling)      *      *     MERGE_PARTIAL  As first operator in a REDUCER, partial aggregations come grouped from      *                    reduce-shuffle -->      *                        aggregate the partial aggregations and emit full aggregation on      *                        endGroup / closeOp      *      *     STREAMING      Rows come from PARENT operator ALREADY GROUPED -->      *                        aggregate the rows and emit full aggregation on key change / closeOp      *      *     NOTE: Hash can spill partial result rows prematurely if it runs low on memory.      *     NOTE: Streaming has to compare keys where MergePartial gets an endGroup call.      *      *      *  DECIDER: Which VectorGroupByDesc.ProcessingMode for VectorGroupByOperator?      *      *     Decides using GroupByDesc.Mode and whether there are keys with the      *     VectorGroupByDesc.groupByDescModeToVectorProcessingMode method.      *      *         Mode.COMPLETE      --> (numKeys == 0 ? ProcessingMode.GLOBAL : ProcessingMode.STREAMING)      *      *         Mode.HASH          --> ProcessingMode.HASH      *      *         Mode.MERGEPARTIAL  --> (numKeys == 0 ? ProcessingMode.GLOBAL : ProcessingMode.MERGE_PARTIAL)      *      *         Mode.PARTIAL1,      *         Mode.PARTIAL2,      *         Mode.PARTIALS,      *         Mode.FINAL        --> ProcessingMode.STREAMING      *      */
name|boolean
name|hasKeys
init|=
operator|(
name|desc
operator|.
name|getKeys
argument_list|()
operator|.
name|size
argument_list|()
operator|>
literal|0
operator|)
decl_stmt|;
name|ProcessingMode
name|processingMode
init|=
name|VectorGroupByDesc
operator|.
name|groupByDescModeToVectorProcessingMode
argument_list|(
name|desc
operator|.
name|getMode
argument_list|()
argument_list|,
name|hasKeys
argument_list|)
decl_stmt|;
name|Pair
argument_list|<
name|Boolean
argument_list|,
name|Boolean
argument_list|>
name|retPair
init|=
name|validateAggregationDescs
argument_list|(
name|desc
operator|.
name|getAggregators
argument_list|()
argument_list|,
name|processingMode
argument_list|,
name|hasKeys
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|retPair
operator|.
name|left
condition|)
block|{
return|return
literal|false
return|;
block|}
comment|// If all the aggregation outputs are primitive, we can output VectorizedRowBatch.
comment|// Otherwise, we the rest of the operator tree will be row mode.
name|VectorGroupByDesc
name|vectorDesc
init|=
operator|new
name|VectorGroupByDesc
argument_list|()
decl_stmt|;
name|desc
operator|.
name|setVectorDesc
argument_list|(
name|vectorDesc
argument_list|)
expr_stmt|;
name|vectorDesc
operator|.
name|setVectorOutput
argument_list|(
name|retPair
operator|.
name|right
argument_list|)
expr_stmt|;
name|vectorDesc
operator|.
name|setProcessingMode
argument_list|(
name|processingMode
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Vector GROUP BY operator will use processing mode "
operator|+
name|processingMode
operator|.
name|name
argument_list|()
operator|+
literal|", isVectorOutput "
operator|+
name|vectorDesc
operator|.
name|isVectorOutput
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
specifier|private
name|boolean
name|validateFileSinkOperator
parameter_list|(
name|FileSinkOperator
name|op
parameter_list|)
block|{
return|return
literal|true
return|;
block|}
specifier|private
name|boolean
name|validateExprNodeDesc
parameter_list|(
name|List
argument_list|<
name|ExprNodeDesc
argument_list|>
name|descs
parameter_list|,
name|String
name|expressionTitle
parameter_list|)
block|{
return|return
name|validateExprNodeDesc
argument_list|(
name|descs
argument_list|,
name|expressionTitle
argument_list|,
name|VectorExpressionDescriptor
operator|.
name|Mode
operator|.
name|PROJECTION
argument_list|)
return|;
block|}
specifier|private
name|boolean
name|validateExprNodeDesc
parameter_list|(
name|List
argument_list|<
name|ExprNodeDesc
argument_list|>
name|descs
parameter_list|,
name|String
name|expressionTitle
parameter_list|,
name|VectorExpressionDescriptor
operator|.
name|Mode
name|mode
parameter_list|)
block|{
for|for
control|(
name|ExprNodeDesc
name|d
range|:
name|descs
control|)
block|{
name|boolean
name|ret
init|=
name|validateExprNodeDesc
argument_list|(
name|d
argument_list|,
name|expressionTitle
argument_list|,
name|mode
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|ret
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
return|return
literal|true
return|;
block|}
specifier|private
name|Pair
argument_list|<
name|Boolean
argument_list|,
name|Boolean
argument_list|>
name|validateAggregationDescs
parameter_list|(
name|List
argument_list|<
name|AggregationDesc
argument_list|>
name|descs
parameter_list|,
name|ProcessingMode
name|processingMode
parameter_list|,
name|boolean
name|hasKeys
parameter_list|)
block|{
name|boolean
name|outputIsPrimitive
init|=
literal|true
decl_stmt|;
for|for
control|(
name|AggregationDesc
name|d
range|:
name|descs
control|)
block|{
name|Pair
argument_list|<
name|Boolean
argument_list|,
name|Boolean
argument_list|>
name|retPair
init|=
name|validateAggregationDesc
argument_list|(
name|d
argument_list|,
name|processingMode
argument_list|,
name|hasKeys
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|retPair
operator|.
name|left
condition|)
block|{
return|return
name|retPair
return|;
block|}
if|if
condition|(
operator|!
name|retPair
operator|.
name|right
condition|)
block|{
name|outputIsPrimitive
operator|=
literal|false
expr_stmt|;
block|}
block|}
return|return
operator|new
name|Pair
argument_list|<
name|Boolean
argument_list|,
name|Boolean
argument_list|>
argument_list|(
literal|true
argument_list|,
name|outputIsPrimitive
argument_list|)
return|;
block|}
specifier|private
name|boolean
name|validateExprNodeDescRecursive
parameter_list|(
name|ExprNodeDesc
name|desc
parameter_list|,
name|String
name|expressionTitle
parameter_list|,
name|VectorExpressionDescriptor
operator|.
name|Mode
name|mode
parameter_list|)
block|{
if|if
condition|(
name|desc
operator|instanceof
name|ExprNodeColumnDesc
condition|)
block|{
name|ExprNodeColumnDesc
name|c
init|=
operator|(
name|ExprNodeColumnDesc
operator|)
name|desc
decl_stmt|;
comment|// Currently, we do not support vectorized virtual columns (see HIVE-5570).
if|if
condition|(
name|VirtualColumn
operator|.
name|VIRTUAL_COLUMN_NAMES
operator|.
name|contains
argument_list|(
name|c
operator|.
name|getColumn
argument_list|()
argument_list|)
condition|)
block|{
name|setExpressionIssue
argument_list|(
name|expressionTitle
argument_list|,
literal|"Virtual columns not supported ("
operator|+
name|c
operator|.
name|getColumn
argument_list|()
operator|+
literal|")"
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
name|String
name|typeName
init|=
name|desc
operator|.
name|getTypeInfo
argument_list|()
operator|.
name|getTypeName
argument_list|()
decl_stmt|;
name|boolean
name|ret
init|=
name|validateDataType
argument_list|(
name|typeName
argument_list|,
name|mode
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|ret
condition|)
block|{
name|setExpressionIssue
argument_list|(
name|expressionTitle
argument_list|,
literal|"Data type "
operator|+
name|typeName
operator|+
literal|" of "
operator|+
name|desc
operator|.
name|toString
argument_list|()
operator|+
literal|" not supported"
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
name|boolean
name|isInExpression
init|=
literal|false
decl_stmt|;
if|if
condition|(
name|desc
operator|instanceof
name|ExprNodeGenericFuncDesc
condition|)
block|{
name|ExprNodeGenericFuncDesc
name|d
init|=
operator|(
name|ExprNodeGenericFuncDesc
operator|)
name|desc
decl_stmt|;
name|boolean
name|r
init|=
name|validateGenericUdf
argument_list|(
name|d
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|r
condition|)
block|{
name|setExpressionIssue
argument_list|(
name|expressionTitle
argument_list|,
literal|"UDF "
operator|+
name|d
operator|+
literal|" not supported"
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
name|GenericUDF
name|genericUDF
init|=
name|d
operator|.
name|getGenericUDF
argument_list|()
decl_stmt|;
name|isInExpression
operator|=
operator|(
name|genericUDF
operator|instanceof
name|GenericUDFIn
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|desc
operator|.
name|getChildren
argument_list|()
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|isInExpression
operator|&&
name|desc
operator|.
name|getChildren
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|getTypeInfo
argument_list|()
operator|.
name|getCategory
argument_list|()
operator|==
name|Category
operator|.
name|STRUCT
condition|)
block|{
comment|// Don't restrict child expressions for projection.
comment|// Always use loose FILTER mode.
if|if
condition|(
operator|!
name|validateStructInExpression
argument_list|(
name|desc
argument_list|,
name|expressionTitle
argument_list|,
name|VectorExpressionDescriptor
operator|.
name|Mode
operator|.
name|FILTER
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
else|else
block|{
for|for
control|(
name|ExprNodeDesc
name|d
range|:
name|desc
operator|.
name|getChildren
argument_list|()
control|)
block|{
comment|// Don't restrict child expressions for projection.
comment|// Always use loose FILTER mode.
if|if
condition|(
operator|!
name|validateExprNodeDescRecursive
argument_list|(
name|d
argument_list|,
name|expressionTitle
argument_list|,
name|VectorExpressionDescriptor
operator|.
name|Mode
operator|.
name|FILTER
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
block|}
block|}
return|return
literal|true
return|;
block|}
specifier|private
name|boolean
name|validateStructInExpression
parameter_list|(
name|ExprNodeDesc
name|desc
parameter_list|,
name|String
name|expressionTitle
parameter_list|,
name|VectorExpressionDescriptor
operator|.
name|Mode
name|mode
parameter_list|)
block|{
for|for
control|(
name|ExprNodeDesc
name|d
range|:
name|desc
operator|.
name|getChildren
argument_list|()
control|)
block|{
name|TypeInfo
name|typeInfo
init|=
name|d
operator|.
name|getTypeInfo
argument_list|()
decl_stmt|;
if|if
condition|(
name|typeInfo
operator|.
name|getCategory
argument_list|()
operator|!=
name|Category
operator|.
name|STRUCT
condition|)
block|{
return|return
literal|false
return|;
block|}
name|StructTypeInfo
name|structTypeInfo
init|=
operator|(
name|StructTypeInfo
operator|)
name|typeInfo
decl_stmt|;
name|ArrayList
argument_list|<
name|TypeInfo
argument_list|>
name|fieldTypeInfos
init|=
name|structTypeInfo
operator|.
name|getAllStructFieldTypeInfos
argument_list|()
decl_stmt|;
name|ArrayList
argument_list|<
name|String
argument_list|>
name|fieldNames
init|=
name|structTypeInfo
operator|.
name|getAllStructFieldNames
argument_list|()
decl_stmt|;
specifier|final
name|int
name|fieldCount
init|=
name|fieldTypeInfos
operator|.
name|size
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|f
init|=
literal|0
init|;
name|f
operator|<
name|fieldCount
condition|;
name|f
operator|++
control|)
block|{
name|TypeInfo
name|fieldTypeInfo
init|=
name|fieldTypeInfos
operator|.
name|get
argument_list|(
name|f
argument_list|)
decl_stmt|;
name|Category
name|category
init|=
name|fieldTypeInfo
operator|.
name|getCategory
argument_list|()
decl_stmt|;
if|if
condition|(
name|category
operator|!=
name|Category
operator|.
name|PRIMITIVE
condition|)
block|{
name|setExpressionIssue
argument_list|(
name|expressionTitle
argument_list|,
literal|"Cannot vectorize struct field "
operator|+
name|fieldNames
operator|.
name|get
argument_list|(
name|f
argument_list|)
operator|+
literal|" of type "
operator|+
name|fieldTypeInfo
operator|.
name|getTypeName
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
name|PrimitiveTypeInfo
name|fieldPrimitiveTypeInfo
init|=
operator|(
name|PrimitiveTypeInfo
operator|)
name|fieldTypeInfo
decl_stmt|;
name|InConstantType
name|inConstantType
init|=
name|VectorizationContext
operator|.
name|getInConstantTypeFromPrimitiveCategory
argument_list|(
name|fieldPrimitiveTypeInfo
operator|.
name|getPrimitiveCategory
argument_list|()
argument_list|)
decl_stmt|;
comment|// For now, limit the data types we support for Vectorized Struct IN().
if|if
condition|(
name|inConstantType
operator|!=
name|InConstantType
operator|.
name|INT_FAMILY
operator|&&
name|inConstantType
operator|!=
name|InConstantType
operator|.
name|FLOAT_FAMILY
operator|&&
name|inConstantType
operator|!=
name|InConstantType
operator|.
name|STRING_FAMILY
condition|)
block|{
name|setExpressionIssue
argument_list|(
name|expressionTitle
argument_list|,
literal|"Cannot vectorize struct field "
operator|+
name|fieldNames
operator|.
name|get
argument_list|(
name|f
argument_list|)
operator|+
literal|" of type "
operator|+
name|fieldTypeInfo
operator|.
name|getTypeName
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
block|}
return|return
literal|true
return|;
block|}
specifier|private
name|boolean
name|validateExprNodeDesc
parameter_list|(
name|ExprNodeDesc
name|desc
parameter_list|,
name|String
name|expressionTitle
parameter_list|)
block|{
return|return
name|validateExprNodeDesc
argument_list|(
name|desc
argument_list|,
name|expressionTitle
argument_list|,
name|VectorExpressionDescriptor
operator|.
name|Mode
operator|.
name|PROJECTION
argument_list|)
return|;
block|}
name|boolean
name|validateExprNodeDesc
parameter_list|(
name|ExprNodeDesc
name|desc
parameter_list|,
name|String
name|expressionTitle
parameter_list|,
name|VectorExpressionDescriptor
operator|.
name|Mode
name|mode
parameter_list|)
block|{
if|if
condition|(
operator|!
name|validateExprNodeDescRecursive
argument_list|(
name|desc
argument_list|,
name|expressionTitle
argument_list|,
name|mode
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
try|try
block|{
name|VectorizationContext
name|vc
init|=
operator|new
name|ValidatorVectorizationContext
argument_list|(
name|hiveConf
argument_list|)
decl_stmt|;
if|if
condition|(
name|vc
operator|.
name|getVectorExpression
argument_list|(
name|desc
argument_list|,
name|mode
argument_list|)
operator|==
literal|null
condition|)
block|{
comment|// TODO: this cannot happen - VectorizationContext throws in such cases.
name|setExpressionIssue
argument_list|(
name|expressionTitle
argument_list|,
literal|"getVectorExpression returned null"
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
if|if
condition|(
name|e
operator|instanceof
name|HiveException
condition|)
block|{
name|setExpressionIssue
argument_list|(
name|expressionTitle
argument_list|,
name|e
operator|.
name|getMessage
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|String
name|issue
init|=
literal|"exception: "
operator|+
name|VectorizationContext
operator|.
name|getStackTraceAsSingleLine
argument_list|(
name|e
argument_list|)
decl_stmt|;
name|setExpressionIssue
argument_list|(
name|expressionTitle
argument_list|,
name|issue
argument_list|)
expr_stmt|;
block|}
return|return
literal|false
return|;
block|}
return|return
literal|true
return|;
block|}
specifier|private
name|boolean
name|validateGenericUdf
parameter_list|(
name|ExprNodeGenericFuncDesc
name|genericUDFExpr
parameter_list|)
block|{
if|if
condition|(
name|VectorizationContext
operator|.
name|isCustomUDF
argument_list|(
name|genericUDFExpr
argument_list|)
condition|)
block|{
return|return
literal|true
return|;
block|}
if|if
condition|(
name|hiveVectorAdaptorUsageMode
operator|==
name|HiveVectorAdaptorUsageMode
operator|.
name|NONE
operator|||
name|hiveVectorAdaptorUsageMode
operator|==
name|HiveVectorAdaptorUsageMode
operator|.
name|CHOSEN
condition|)
block|{
name|GenericUDF
name|genericUDF
init|=
name|genericUDFExpr
operator|.
name|getGenericUDF
argument_list|()
decl_stmt|;
if|if
condition|(
name|genericUDF
operator|instanceof
name|GenericUDFBridge
condition|)
block|{
name|Class
argument_list|<
name|?
extends|extends
name|UDF
argument_list|>
name|udf
init|=
operator|(
operator|(
name|GenericUDFBridge
operator|)
name|genericUDF
operator|)
operator|.
name|getUdfClass
argument_list|()
decl_stmt|;
return|return
name|supportedGenericUDFs
operator|.
name|contains
argument_list|(
name|udf
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|supportedGenericUDFs
operator|.
name|contains
argument_list|(
name|genericUDF
operator|.
name|getClass
argument_list|()
argument_list|)
return|;
block|}
block|}
return|return
literal|true
return|;
block|}
specifier|public
specifier|static
name|ObjectInspector
operator|.
name|Category
name|aggregationOutputCategory
parameter_list|(
name|VectorAggregateExpression
name|vectorAggrExpr
parameter_list|)
block|{
name|ObjectInspector
name|outputObjInspector
init|=
name|vectorAggrExpr
operator|.
name|getOutputObjectInspector
argument_list|()
decl_stmt|;
return|return
name|outputObjInspector
operator|.
name|getCategory
argument_list|()
return|;
block|}
specifier|private
name|Pair
argument_list|<
name|Boolean
argument_list|,
name|Boolean
argument_list|>
name|validateAggregationDesc
parameter_list|(
name|AggregationDesc
name|aggDesc
parameter_list|,
name|ProcessingMode
name|processingMode
parameter_list|,
name|boolean
name|hasKeys
parameter_list|)
block|{
name|String
name|udfName
init|=
name|aggDesc
operator|.
name|getGenericUDAFName
argument_list|()
operator|.
name|toLowerCase
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|supportedAggregationUdfs
operator|.
name|contains
argument_list|(
name|udfName
argument_list|)
condition|)
block|{
name|setExpressionIssue
argument_list|(
literal|"Aggregation Function"
argument_list|,
literal|"UDF "
operator|+
name|udfName
operator|+
literal|" not supported"
argument_list|)
expr_stmt|;
return|return
operator|new
name|Pair
argument_list|<
name|Boolean
argument_list|,
name|Boolean
argument_list|>
argument_list|(
literal|false
argument_list|,
literal|false
argument_list|)
return|;
block|}
if|if
condition|(
name|aggDesc
operator|.
name|getParameters
argument_list|()
operator|!=
literal|null
operator|&&
operator|!
name|validateExprNodeDesc
argument_list|(
name|aggDesc
operator|.
name|getParameters
argument_list|()
argument_list|,
literal|"Aggregation Function UDF "
operator|+
name|udfName
operator|+
literal|" parameter"
argument_list|)
condition|)
block|{
return|return
operator|new
name|Pair
argument_list|<
name|Boolean
argument_list|,
name|Boolean
argument_list|>
argument_list|(
literal|false
argument_list|,
literal|false
argument_list|)
return|;
block|}
comment|// See if we can vectorize the aggregation.
name|VectorizationContext
name|vc
init|=
operator|new
name|ValidatorVectorizationContext
argument_list|(
name|hiveConf
argument_list|)
decl_stmt|;
name|VectorAggregateExpression
name|vectorAggrExpr
decl_stmt|;
try|try
block|{
name|vectorAggrExpr
operator|=
name|vc
operator|.
name|getAggregatorExpression
argument_list|(
name|aggDesc
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
comment|// We should have already attempted to vectorize in validateAggregationDesc.
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Vectorization of aggregation should have succeeded "
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
name|setExpressionIssue
argument_list|(
literal|"Aggregation Function"
argument_list|,
literal|"Vectorization of aggreation should have succeeded "
operator|+
name|e
argument_list|)
expr_stmt|;
return|return
operator|new
name|Pair
argument_list|<
name|Boolean
argument_list|,
name|Boolean
argument_list|>
argument_list|(
literal|false
argument_list|,
literal|false
argument_list|)
return|;
block|}
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Aggregation "
operator|+
name|aggDesc
operator|.
name|getExprString
argument_list|()
operator|+
literal|" --> "
operator|+
literal|" vector expression "
operator|+
name|vectorAggrExpr
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|ObjectInspector
operator|.
name|Category
name|outputCategory
init|=
name|aggregationOutputCategory
argument_list|(
name|vectorAggrExpr
argument_list|)
decl_stmt|;
name|boolean
name|outputIsPrimitive
init|=
operator|(
name|outputCategory
operator|==
name|ObjectInspector
operator|.
name|Category
operator|.
name|PRIMITIVE
operator|)
decl_stmt|;
if|if
condition|(
name|processingMode
operator|==
name|ProcessingMode
operator|.
name|MERGE_PARTIAL
operator|&&
name|hasKeys
operator|&&
operator|!
name|outputIsPrimitive
condition|)
block|{
name|setOperatorIssue
argument_list|(
literal|"Vectorized Reduce MergePartial GROUP BY keys can only handle aggregate outputs that are primitive types"
argument_list|)
expr_stmt|;
return|return
operator|new
name|Pair
argument_list|<
name|Boolean
argument_list|,
name|Boolean
argument_list|>
argument_list|(
literal|false
argument_list|,
literal|false
argument_list|)
return|;
block|}
return|return
operator|new
name|Pair
argument_list|<
name|Boolean
argument_list|,
name|Boolean
argument_list|>
argument_list|(
literal|true
argument_list|,
name|outputIsPrimitive
argument_list|)
return|;
block|}
specifier|public
specifier|static
name|boolean
name|validateDataType
parameter_list|(
name|String
name|type
parameter_list|,
name|VectorExpressionDescriptor
operator|.
name|Mode
name|mode
parameter_list|)
block|{
name|type
operator|=
name|type
operator|.
name|toLowerCase
argument_list|()
expr_stmt|;
name|boolean
name|result
init|=
name|supportedDataTypesPattern
operator|.
name|matcher
argument_list|(
name|type
argument_list|)
operator|.
name|matches
argument_list|()
decl_stmt|;
if|if
condition|(
name|result
operator|&&
name|mode
operator|==
name|VectorExpressionDescriptor
operator|.
name|Mode
operator|.
name|PROJECTION
operator|&&
name|type
operator|.
name|equals
argument_list|(
literal|"void"
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
return|return
name|result
return|;
block|}
specifier|private
name|VectorizationContext
name|getVectorizationContext
parameter_list|(
name|String
name|contextName
parameter_list|,
name|VectorTaskColumnInfo
name|vectorTaskColumnInfo
parameter_list|)
block|{
name|VectorizationContext
name|vContext
init|=
operator|new
name|VectorizationContext
argument_list|(
name|contextName
argument_list|,
name|vectorTaskColumnInfo
operator|.
name|allColumnNames
argument_list|,
name|hiveConf
argument_list|)
decl_stmt|;
return|return
name|vContext
return|;
block|}
specifier|private
name|void
name|fixupParentChildOperators
parameter_list|(
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
name|op
parameter_list|,
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
name|vectorOp
parameter_list|)
block|{
if|if
condition|(
name|op
operator|.
name|getParentOperators
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|vectorOp
operator|.
name|setParentOperators
argument_list|(
name|op
operator|.
name|getParentOperators
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
name|p
range|:
name|op
operator|.
name|getParentOperators
argument_list|()
control|)
block|{
name|p
operator|.
name|replaceChild
argument_list|(
name|op
argument_list|,
name|vectorOp
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|op
operator|.
name|getChildOperators
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|vectorOp
operator|.
name|setChildOperators
argument_list|(
name|op
operator|.
name|getChildOperators
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
name|c
range|:
name|op
operator|.
name|getChildOperators
argument_list|()
control|)
block|{
name|c
operator|.
name|replaceParent
argument_list|(
name|op
argument_list|,
name|vectorOp
argument_list|)
expr_stmt|;
block|}
block|}
block|}
specifier|private
name|boolean
name|isBigTableOnlyResults
parameter_list|(
name|MapJoinDesc
name|desc
parameter_list|)
block|{
name|Byte
index|[]
name|order
init|=
name|desc
operator|.
name|getTagOrder
argument_list|()
decl_stmt|;
name|byte
name|posBigTable
init|=
operator|(
name|byte
operator|)
name|desc
operator|.
name|getPosBigTable
argument_list|()
decl_stmt|;
name|Byte
name|posSingleVectorMapJoinSmallTable
init|=
operator|(
name|order
index|[
literal|0
index|]
operator|==
name|posBigTable
condition|?
name|order
index|[
literal|1
index|]
else|:
name|order
index|[
literal|0
index|]
operator|)
decl_stmt|;
name|int
index|[]
name|smallTableIndices
decl_stmt|;
name|int
name|smallTableIndicesSize
decl_stmt|;
if|if
condition|(
name|desc
operator|.
name|getValueIndices
argument_list|()
operator|!=
literal|null
operator|&&
name|desc
operator|.
name|getValueIndices
argument_list|()
operator|.
name|get
argument_list|(
name|posSingleVectorMapJoinSmallTable
argument_list|)
operator|!=
literal|null
condition|)
block|{
name|smallTableIndices
operator|=
name|desc
operator|.
name|getValueIndices
argument_list|()
operator|.
name|get
argument_list|(
name|posSingleVectorMapJoinSmallTable
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Vectorizer isBigTableOnlyResults smallTableIndices "
operator|+
name|Arrays
operator|.
name|toString
argument_list|(
name|smallTableIndices
argument_list|)
argument_list|)
expr_stmt|;
name|smallTableIndicesSize
operator|=
name|smallTableIndices
operator|.
name|length
expr_stmt|;
block|}
else|else
block|{
name|smallTableIndices
operator|=
literal|null
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Vectorizer isBigTableOnlyResults smallTableIndices EMPTY"
argument_list|)
expr_stmt|;
name|smallTableIndicesSize
operator|=
literal|0
expr_stmt|;
block|}
name|List
argument_list|<
name|Integer
argument_list|>
name|smallTableRetainList
init|=
name|desc
operator|.
name|getRetainList
argument_list|()
operator|.
name|get
argument_list|(
name|posSingleVectorMapJoinSmallTable
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Vectorizer isBigTableOnlyResults smallTableRetainList "
operator|+
name|smallTableRetainList
argument_list|)
expr_stmt|;
name|int
name|smallTableRetainSize
init|=
name|smallTableRetainList
operator|.
name|size
argument_list|()
decl_stmt|;
if|if
condition|(
name|smallTableIndicesSize
operator|>
literal|0
condition|)
block|{
comment|// Small table indices has priority over retain.
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|smallTableIndicesSize
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|smallTableIndices
index|[
name|i
index|]
operator|<
literal|0
condition|)
block|{
comment|// Negative numbers indicate a column to be (deserialize) read from the small table's
comment|// LazyBinary value row.
name|setOperatorIssue
argument_list|(
literal|"Vectorizer isBigTableOnlyResults smallTableIndices[i]< 0 returning false"
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|smallTableRetainSize
operator|>
literal|0
condition|)
block|{
name|setOperatorIssue
argument_list|(
literal|"Vectorizer isBigTableOnlyResults smallTableRetainSize> 0 returning false"
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"Vectorizer isBigTableOnlyResults returning true"
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
name|specializeMapJoinOperator
parameter_list|(
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
name|op
parameter_list|,
name|VectorizationContext
name|vContext
parameter_list|,
name|MapJoinDesc
name|desc
parameter_list|,
name|VectorMapJoinInfo
name|vectorMapJoinInfo
parameter_list|)
throws|throws
name|HiveException
block|{
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
name|vectorOp
init|=
literal|null
decl_stmt|;
name|Class
argument_list|<
name|?
extends|extends
name|Operator
argument_list|<
name|?
argument_list|>
argument_list|>
name|opClass
init|=
literal|null
decl_stmt|;
name|VectorMapJoinDesc
name|vectorDesc
init|=
operator|(
name|VectorMapJoinDesc
operator|)
name|desc
operator|.
name|getVectorDesc
argument_list|()
decl_stmt|;
name|HashTableImplementationType
name|hashTableImplementationType
init|=
name|HashTableImplementationType
operator|.
name|NONE
decl_stmt|;
name|HashTableKind
name|hashTableKind
init|=
name|HashTableKind
operator|.
name|NONE
decl_stmt|;
name|HashTableKeyType
name|hashTableKeyType
init|=
name|HashTableKeyType
operator|.
name|NONE
decl_stmt|;
name|OperatorVariation
name|operatorVariation
init|=
name|OperatorVariation
operator|.
name|NONE
decl_stmt|;
if|if
condition|(
name|vectorDesc
operator|.
name|getIsFastHashTableEnabled
argument_list|()
condition|)
block|{
name|hashTableImplementationType
operator|=
name|HashTableImplementationType
operator|.
name|FAST
expr_stmt|;
block|}
else|else
block|{
name|hashTableImplementationType
operator|=
name|HashTableImplementationType
operator|.
name|OPTIMIZED
expr_stmt|;
block|}
name|int
name|joinType
init|=
name|desc
operator|.
name|getConds
argument_list|()
index|[
literal|0
index|]
operator|.
name|getType
argument_list|()
decl_stmt|;
name|boolean
name|isInnerBigOnly
init|=
literal|false
decl_stmt|;
if|if
condition|(
name|joinType
operator|==
name|JoinDesc
operator|.
name|INNER_JOIN
operator|&&
name|isBigTableOnlyResults
argument_list|(
name|desc
argument_list|)
condition|)
block|{
name|isInnerBigOnly
operator|=
literal|true
expr_stmt|;
block|}
comment|// By default, we can always use the multi-key class.
name|hashTableKeyType
operator|=
name|HashTableKeyType
operator|.
name|MULTI_KEY
expr_stmt|;
if|if
condition|(
operator|!
name|HiveConf
operator|.
name|getBoolVar
argument_list|(
name|hiveConf
argument_list|,
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVE_VECTORIZATION_MAPJOIN_NATIVE_MULTIKEY_ONLY_ENABLED
argument_list|)
condition|)
block|{
comment|// Look for single column optimization.
name|byte
name|posBigTable
init|=
operator|(
name|byte
operator|)
name|desc
operator|.
name|getPosBigTable
argument_list|()
decl_stmt|;
name|Map
argument_list|<
name|Byte
argument_list|,
name|List
argument_list|<
name|ExprNodeDesc
argument_list|>
argument_list|>
name|keyExprs
init|=
name|desc
operator|.
name|getKeys
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|ExprNodeDesc
argument_list|>
name|bigTableKeyExprs
init|=
name|keyExprs
operator|.
name|get
argument_list|(
name|posBigTable
argument_list|)
decl_stmt|;
if|if
condition|(
name|bigTableKeyExprs
operator|.
name|size
argument_list|()
operator|==
literal|1
condition|)
block|{
name|TypeInfo
name|typeInfo
init|=
name|bigTableKeyExprs
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|getTypeInfo
argument_list|()
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Vectorizer vectorizeOperator map join typeName "
operator|+
name|typeInfo
operator|.
name|getTypeName
argument_list|()
argument_list|)
expr_stmt|;
switch|switch
condition|(
operator|(
operator|(
name|PrimitiveTypeInfo
operator|)
name|typeInfo
operator|)
operator|.
name|getPrimitiveCategory
argument_list|()
condition|)
block|{
case|case
name|BOOLEAN
case|:
name|hashTableKeyType
operator|=
name|HashTableKeyType
operator|.
name|BOOLEAN
expr_stmt|;
break|break;
case|case
name|BYTE
case|:
name|hashTableKeyType
operator|=
name|HashTableKeyType
operator|.
name|BYTE
expr_stmt|;
break|break;
case|case
name|SHORT
case|:
name|hashTableKeyType
operator|=
name|HashTableKeyType
operator|.
name|SHORT
expr_stmt|;
break|break;
case|case
name|INT
case|:
name|hashTableKeyType
operator|=
name|HashTableKeyType
operator|.
name|INT
expr_stmt|;
break|break;
case|case
name|LONG
case|:
name|hashTableKeyType
operator|=
name|HashTableKeyType
operator|.
name|LONG
expr_stmt|;
break|break;
case|case
name|STRING
case|:
case|case
name|CHAR
case|:
case|case
name|VARCHAR
case|:
case|case
name|BINARY
case|:
name|hashTableKeyType
operator|=
name|HashTableKeyType
operator|.
name|STRING
expr_stmt|;
default|default:
comment|// Stay with multi-key.
block|}
block|}
block|}
switch|switch
condition|(
name|joinType
condition|)
block|{
case|case
name|JoinDesc
operator|.
name|INNER_JOIN
case|:
if|if
condition|(
operator|!
name|isInnerBigOnly
condition|)
block|{
name|operatorVariation
operator|=
name|OperatorVariation
operator|.
name|INNER
expr_stmt|;
name|hashTableKind
operator|=
name|HashTableKind
operator|.
name|HASH_MAP
expr_stmt|;
block|}
else|else
block|{
name|operatorVariation
operator|=
name|OperatorVariation
operator|.
name|INNER_BIG_ONLY
expr_stmt|;
name|hashTableKind
operator|=
name|HashTableKind
operator|.
name|HASH_MULTISET
expr_stmt|;
block|}
break|break;
case|case
name|JoinDesc
operator|.
name|LEFT_OUTER_JOIN
case|:
case|case
name|JoinDesc
operator|.
name|RIGHT_OUTER_JOIN
case|:
name|operatorVariation
operator|=
name|OperatorVariation
operator|.
name|OUTER
expr_stmt|;
name|hashTableKind
operator|=
name|HashTableKind
operator|.
name|HASH_MAP
expr_stmt|;
break|break;
case|case
name|JoinDesc
operator|.
name|LEFT_SEMI_JOIN
case|:
name|operatorVariation
operator|=
name|OperatorVariation
operator|.
name|LEFT_SEMI
expr_stmt|;
name|hashTableKind
operator|=
name|HashTableKind
operator|.
name|HASH_SET
expr_stmt|;
break|break;
default|default:
throw|throw
operator|new
name|HiveException
argument_list|(
literal|"Unknown join type "
operator|+
name|joinType
argument_list|)
throw|;
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"Vectorizer vectorizeOperator map join hashTableKind "
operator|+
name|hashTableKind
operator|.
name|name
argument_list|()
operator|+
literal|" hashTableKeyType "
operator|+
name|hashTableKeyType
operator|.
name|name
argument_list|()
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|hashTableKeyType
condition|)
block|{
case|case
name|BOOLEAN
case|:
case|case
name|BYTE
case|:
case|case
name|SHORT
case|:
case|case
name|INT
case|:
case|case
name|LONG
case|:
switch|switch
condition|(
name|operatorVariation
condition|)
block|{
case|case
name|INNER
case|:
name|opClass
operator|=
name|VectorMapJoinInnerLongOperator
operator|.
name|class
expr_stmt|;
break|break;
case|case
name|INNER_BIG_ONLY
case|:
name|opClass
operator|=
name|VectorMapJoinInnerBigOnlyLongOperator
operator|.
name|class
expr_stmt|;
break|break;
case|case
name|LEFT_SEMI
case|:
name|opClass
operator|=
name|VectorMapJoinLeftSemiLongOperator
operator|.
name|class
expr_stmt|;
break|break;
case|case
name|OUTER
case|:
name|opClass
operator|=
name|VectorMapJoinOuterLongOperator
operator|.
name|class
expr_stmt|;
break|break;
default|default:
throw|throw
operator|new
name|HiveException
argument_list|(
literal|"Unknown operator variation "
operator|+
name|operatorVariation
argument_list|)
throw|;
block|}
break|break;
case|case
name|STRING
case|:
switch|switch
condition|(
name|operatorVariation
condition|)
block|{
case|case
name|INNER
case|:
name|opClass
operator|=
name|VectorMapJoinInnerStringOperator
operator|.
name|class
expr_stmt|;
break|break;
case|case
name|INNER_BIG_ONLY
case|:
name|opClass
operator|=
name|VectorMapJoinInnerBigOnlyStringOperator
operator|.
name|class
expr_stmt|;
break|break;
case|case
name|LEFT_SEMI
case|:
name|opClass
operator|=
name|VectorMapJoinLeftSemiStringOperator
operator|.
name|class
expr_stmt|;
break|break;
case|case
name|OUTER
case|:
name|opClass
operator|=
name|VectorMapJoinOuterStringOperator
operator|.
name|class
expr_stmt|;
break|break;
default|default:
throw|throw
operator|new
name|HiveException
argument_list|(
literal|"Unknown operator variation "
operator|+
name|operatorVariation
argument_list|)
throw|;
block|}
break|break;
case|case
name|MULTI_KEY
case|:
switch|switch
condition|(
name|operatorVariation
condition|)
block|{
case|case
name|INNER
case|:
name|opClass
operator|=
name|VectorMapJoinInnerMultiKeyOperator
operator|.
name|class
expr_stmt|;
break|break;
case|case
name|INNER_BIG_ONLY
case|:
name|opClass
operator|=
name|VectorMapJoinInnerBigOnlyMultiKeyOperator
operator|.
name|class
expr_stmt|;
break|break;
case|case
name|LEFT_SEMI
case|:
name|opClass
operator|=
name|VectorMapJoinLeftSemiMultiKeyOperator
operator|.
name|class
expr_stmt|;
break|break;
case|case
name|OUTER
case|:
name|opClass
operator|=
name|VectorMapJoinOuterMultiKeyOperator
operator|.
name|class
expr_stmt|;
break|break;
default|default:
throw|throw
operator|new
name|HiveException
argument_list|(
literal|"Unknown operator variation "
operator|+
name|operatorVariation
argument_list|)
throw|;
block|}
break|break;
default|default:
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Unexpected hash table key type "
operator|+
name|hashTableKeyType
operator|.
name|name
argument_list|()
argument_list|)
throw|;
block|}
name|boolean
name|minMaxEnabled
init|=
name|HiveConf
operator|.
name|getBoolVar
argument_list|(
name|hiveConf
argument_list|,
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVE_VECTORIZATION_MAPJOIN_NATIVE_MINMAX_ENABLED
argument_list|)
decl_stmt|;
name|vectorDesc
operator|.
name|setHashTableImplementationType
argument_list|(
name|hashTableImplementationType
argument_list|)
expr_stmt|;
name|vectorDesc
operator|.
name|setHashTableKind
argument_list|(
name|hashTableKind
argument_list|)
expr_stmt|;
name|vectorDesc
operator|.
name|setHashTableKeyType
argument_list|(
name|hashTableKeyType
argument_list|)
expr_stmt|;
name|vectorDesc
operator|.
name|setOperatorVariation
argument_list|(
name|operatorVariation
argument_list|)
expr_stmt|;
name|vectorDesc
operator|.
name|setMinMaxEnabled
argument_list|(
name|minMaxEnabled
argument_list|)
expr_stmt|;
name|vectorDesc
operator|.
name|setVectorMapJoinInfo
argument_list|(
name|vectorMapJoinInfo
argument_list|)
expr_stmt|;
name|vectorOp
operator|=
name|OperatorFactory
operator|.
name|getVectorOperator
argument_list|(
name|opClass
argument_list|,
name|op
operator|.
name|getCompilationOpContext
argument_list|()
argument_list|,
name|op
operator|.
name|getConf
argument_list|()
argument_list|,
name|vContext
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Vectorizer vectorizeOperator map join class "
operator|+
name|vectorOp
operator|.
name|getClass
argument_list|()
operator|.
name|getSimpleName
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|vectorOp
return|;
block|}
specifier|public
specifier|static
name|boolean
name|onExpressionHasNullSafes
parameter_list|(
name|MapJoinDesc
name|desc
parameter_list|)
block|{
name|boolean
index|[]
name|nullSafes
init|=
name|desc
operator|.
name|getNullSafes
argument_list|()
decl_stmt|;
if|if
condition|(
name|nullSafes
operator|==
literal|null
condition|)
block|{
return|return
literal|false
return|;
block|}
for|for
control|(
name|boolean
name|nullSafe
range|:
name|nullSafes
control|)
block|{
if|if
condition|(
name|nullSafe
condition|)
block|{
return|return
literal|true
return|;
block|}
block|}
return|return
literal|false
return|;
block|}
specifier|private
name|boolean
name|canSpecializeMapJoin
parameter_list|(
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
name|op
parameter_list|,
name|MapJoinDesc
name|desc
parameter_list|,
name|boolean
name|isTezOrSpark
parameter_list|,
name|VectorizationContext
name|vContext
parameter_list|,
name|VectorMapJoinInfo
name|vectorMapJoinInfo
parameter_list|)
throws|throws
name|HiveException
block|{
name|Preconditions
operator|.
name|checkState
argument_list|(
name|op
operator|instanceof
name|MapJoinOperator
argument_list|)
expr_stmt|;
comment|// Allocate a VectorReduceSinkDesc initially with implementation type NONE so EXPLAIN
comment|// can report this operator was vectorized, but not native.  And, the conditions.
name|VectorMapJoinDesc
name|vectorDesc
init|=
operator|new
name|VectorMapJoinDesc
argument_list|()
decl_stmt|;
name|desc
operator|.
name|setVectorDesc
argument_list|(
name|vectorDesc
argument_list|)
expr_stmt|;
name|boolean
name|isVectorizationMapJoinNativeEnabled
init|=
name|HiveConf
operator|.
name|getBoolVar
argument_list|(
name|hiveConf
argument_list|,
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVE_VECTORIZATION_MAPJOIN_NATIVE_ENABLED
argument_list|)
decl_stmt|;
name|String
name|engine
init|=
name|HiveConf
operator|.
name|getVar
argument_list|(
name|hiveConf
argument_list|,
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVE_EXECUTION_ENGINE
argument_list|)
decl_stmt|;
name|boolean
name|oneMapJoinCondition
init|=
operator|(
name|desc
operator|.
name|getConds
argument_list|()
operator|.
name|length
operator|==
literal|1
operator|)
decl_stmt|;
name|boolean
name|hasNullSafes
init|=
name|onExpressionHasNullSafes
argument_list|(
name|desc
argument_list|)
decl_stmt|;
name|byte
name|posBigTable
init|=
operator|(
name|byte
operator|)
name|desc
operator|.
name|getPosBigTable
argument_list|()
decl_stmt|;
comment|// Since we want to display all the met and not met conditions in EXPLAIN, we determine all
comment|// information first....
name|List
argument_list|<
name|ExprNodeDesc
argument_list|>
name|keyDesc
init|=
name|desc
operator|.
name|getKeys
argument_list|()
operator|.
name|get
argument_list|(
name|posBigTable
argument_list|)
decl_stmt|;
name|VectorExpression
index|[]
name|allBigTableKeyExpressions
init|=
name|vContext
operator|.
name|getVectorExpressions
argument_list|(
name|keyDesc
argument_list|)
decl_stmt|;
specifier|final
name|int
name|allBigTableKeyExpressionsLength
init|=
name|allBigTableKeyExpressions
operator|.
name|length
decl_stmt|;
name|boolean
name|supportsKeyTypes
init|=
literal|true
decl_stmt|;
comment|// Assume.
name|HashSet
argument_list|<
name|String
argument_list|>
name|notSupportedKeyTypes
init|=
operator|new
name|HashSet
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
comment|// Since a key expression can be a calculation and the key will go into a scratch column,
comment|// we need the mapping and type information.
name|int
index|[]
name|bigTableKeyColumnMap
init|=
operator|new
name|int
index|[
name|allBigTableKeyExpressionsLength
index|]
decl_stmt|;
name|String
index|[]
name|bigTableKeyColumnNames
init|=
operator|new
name|String
index|[
name|allBigTableKeyExpressionsLength
index|]
decl_stmt|;
name|TypeInfo
index|[]
name|bigTableKeyTypeInfos
init|=
operator|new
name|TypeInfo
index|[
name|allBigTableKeyExpressionsLength
index|]
decl_stmt|;
name|ArrayList
argument_list|<
name|VectorExpression
argument_list|>
name|bigTableKeyExpressionsList
init|=
operator|new
name|ArrayList
argument_list|<
name|VectorExpression
argument_list|>
argument_list|()
decl_stmt|;
name|VectorExpression
index|[]
name|bigTableKeyExpressions
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|allBigTableKeyExpressionsLength
condition|;
name|i
operator|++
control|)
block|{
name|VectorExpression
name|ve
init|=
name|allBigTableKeyExpressions
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|IdentityExpression
operator|.
name|isColumnOnly
argument_list|(
name|ve
argument_list|)
condition|)
block|{
name|bigTableKeyExpressionsList
operator|.
name|add
argument_list|(
name|ve
argument_list|)
expr_stmt|;
block|}
name|bigTableKeyColumnMap
index|[
name|i
index|]
operator|=
name|ve
operator|.
name|getOutputColumn
argument_list|()
expr_stmt|;
name|ExprNodeDesc
name|exprNode
init|=
name|keyDesc
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|bigTableKeyColumnNames
index|[
name|i
index|]
operator|=
name|exprNode
operator|.
name|toString
argument_list|()
expr_stmt|;
name|TypeInfo
name|typeInfo
init|=
name|exprNode
operator|.
name|getTypeInfo
argument_list|()
decl_stmt|;
comment|// Verify we handle the key column types for an optimized table.  This is the effectively the
comment|// same check used in HashTableLoader.
if|if
condition|(
operator|!
name|MapJoinKey
operator|.
name|isSupportedField
argument_list|(
name|typeInfo
argument_list|)
condition|)
block|{
name|supportsKeyTypes
operator|=
literal|false
expr_stmt|;
name|Category
name|category
init|=
name|typeInfo
operator|.
name|getCategory
argument_list|()
decl_stmt|;
name|notSupportedKeyTypes
operator|.
name|add
argument_list|(
operator|(
name|category
operator|!=
name|Category
operator|.
name|PRIMITIVE
condition|?
name|category
operator|.
name|toString
argument_list|()
else|:
operator|(
operator|(
name|PrimitiveTypeInfo
operator|)
name|typeInfo
operator|)
operator|.
name|getPrimitiveCategory
argument_list|()
operator|.
name|toString
argument_list|()
operator|)
argument_list|)
expr_stmt|;
block|}
name|bigTableKeyTypeInfos
index|[
name|i
index|]
operator|=
name|typeInfo
expr_stmt|;
block|}
if|if
condition|(
name|bigTableKeyExpressionsList
operator|.
name|size
argument_list|()
operator|==
literal|0
condition|)
block|{
name|bigTableKeyExpressions
operator|=
literal|null
expr_stmt|;
block|}
else|else
block|{
name|bigTableKeyExpressions
operator|=
name|bigTableKeyExpressionsList
operator|.
name|toArray
argument_list|(
operator|new
name|VectorExpression
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
name|List
argument_list|<
name|ExprNodeDesc
argument_list|>
name|bigTableExprs
init|=
name|desc
operator|.
name|getExprs
argument_list|()
operator|.
name|get
argument_list|(
name|posBigTable
argument_list|)
decl_stmt|;
name|VectorExpression
index|[]
name|allBigTableValueExpressions
init|=
name|vContext
operator|.
name|getVectorExpressions
argument_list|(
name|bigTableExprs
argument_list|)
decl_stmt|;
name|boolean
name|isFastHashTableEnabled
init|=
name|HiveConf
operator|.
name|getBoolVar
argument_list|(
name|hiveConf
argument_list|,
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVE_VECTORIZATION_MAPJOIN_NATIVE_FAST_HASHTABLE_ENABLED
argument_list|)
decl_stmt|;
comment|// Especially since LLAP is prone to turn it off in the MapJoinDesc in later
comment|// physical optimizer stages...
name|boolean
name|isHybridHashJoin
init|=
name|desc
operator|.
name|isHybridHashJoin
argument_list|()
decl_stmt|;
comment|/*      * Populate vectorMapJoininfo.      */
comment|/*      * Similarly, we need a mapping since a value expression can be a calculation and the value      * will go into a scratch column.      */
name|int
index|[]
name|bigTableValueColumnMap
init|=
operator|new
name|int
index|[
name|allBigTableValueExpressions
operator|.
name|length
index|]
decl_stmt|;
name|String
index|[]
name|bigTableValueColumnNames
init|=
operator|new
name|String
index|[
name|allBigTableValueExpressions
operator|.
name|length
index|]
decl_stmt|;
name|TypeInfo
index|[]
name|bigTableValueTypeInfos
init|=
operator|new
name|TypeInfo
index|[
name|allBigTableValueExpressions
operator|.
name|length
index|]
decl_stmt|;
name|ArrayList
argument_list|<
name|VectorExpression
argument_list|>
name|bigTableValueExpressionsList
init|=
operator|new
name|ArrayList
argument_list|<
name|VectorExpression
argument_list|>
argument_list|()
decl_stmt|;
name|VectorExpression
index|[]
name|bigTableValueExpressions
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|bigTableValueColumnMap
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|VectorExpression
name|ve
init|=
name|allBigTableValueExpressions
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|IdentityExpression
operator|.
name|isColumnOnly
argument_list|(
name|ve
argument_list|)
condition|)
block|{
name|bigTableValueExpressionsList
operator|.
name|add
argument_list|(
name|ve
argument_list|)
expr_stmt|;
block|}
name|bigTableValueColumnMap
index|[
name|i
index|]
operator|=
name|ve
operator|.
name|getOutputColumn
argument_list|()
expr_stmt|;
name|ExprNodeDesc
name|exprNode
init|=
name|bigTableExprs
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|bigTableValueColumnNames
index|[
name|i
index|]
operator|=
name|exprNode
operator|.
name|toString
argument_list|()
expr_stmt|;
name|bigTableValueTypeInfos
index|[
name|i
index|]
operator|=
name|exprNode
operator|.
name|getTypeInfo
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|bigTableValueExpressionsList
operator|.
name|size
argument_list|()
operator|==
literal|0
condition|)
block|{
name|bigTableValueExpressions
operator|=
literal|null
expr_stmt|;
block|}
else|else
block|{
name|bigTableValueExpressions
operator|=
name|bigTableValueExpressionsList
operator|.
name|toArray
argument_list|(
operator|new
name|VectorExpression
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
name|vectorMapJoinInfo
operator|.
name|setBigTableKeyColumnMap
argument_list|(
name|bigTableKeyColumnMap
argument_list|)
expr_stmt|;
name|vectorMapJoinInfo
operator|.
name|setBigTableKeyColumnNames
argument_list|(
name|bigTableKeyColumnNames
argument_list|)
expr_stmt|;
name|vectorMapJoinInfo
operator|.
name|setBigTableKeyTypeInfos
argument_list|(
name|bigTableKeyTypeInfos
argument_list|)
expr_stmt|;
name|vectorMapJoinInfo
operator|.
name|setBigTableKeyExpressions
argument_list|(
name|bigTableKeyExpressions
argument_list|)
expr_stmt|;
name|vectorMapJoinInfo
operator|.
name|setBigTableValueColumnMap
argument_list|(
name|bigTableValueColumnMap
argument_list|)
expr_stmt|;
name|vectorMapJoinInfo
operator|.
name|setBigTableValueColumnNames
argument_list|(
name|bigTableValueColumnNames
argument_list|)
expr_stmt|;
name|vectorMapJoinInfo
operator|.
name|setBigTableValueTypeInfos
argument_list|(
name|bigTableValueTypeInfos
argument_list|)
expr_stmt|;
name|vectorMapJoinInfo
operator|.
name|setBigTableValueExpressions
argument_list|(
name|bigTableValueExpressions
argument_list|)
expr_stmt|;
comment|/*      * Small table information.      */
name|VectorColumnOutputMapping
name|bigTableRetainedMapping
init|=
operator|new
name|VectorColumnOutputMapping
argument_list|(
literal|"Big Table Retained Mapping"
argument_list|)
decl_stmt|;
name|VectorColumnOutputMapping
name|bigTableOuterKeyMapping
init|=
operator|new
name|VectorColumnOutputMapping
argument_list|(
literal|"Big Table Outer Key Mapping"
argument_list|)
decl_stmt|;
comment|// The order of the fields in the LazyBinary small table value must be used, so
comment|// we use the source ordering flavor for the mapping.
name|VectorColumnSourceMapping
name|smallTableMapping
init|=
operator|new
name|VectorColumnSourceMapping
argument_list|(
literal|"Small Table Mapping"
argument_list|)
decl_stmt|;
name|Byte
index|[]
name|order
init|=
name|desc
operator|.
name|getTagOrder
argument_list|()
decl_stmt|;
name|Byte
name|posSingleVectorMapJoinSmallTable
init|=
operator|(
name|order
index|[
literal|0
index|]
operator|==
name|posBigTable
condition|?
name|order
index|[
literal|1
index|]
else|:
name|order
index|[
literal|0
index|]
operator|)
decl_stmt|;
name|boolean
name|isOuterJoin
init|=
operator|!
name|desc
operator|.
name|getNoOuterJoin
argument_list|()
decl_stmt|;
comment|/*      * Gather up big and small table output result information from the MapJoinDesc.      */
name|List
argument_list|<
name|Integer
argument_list|>
name|bigTableRetainList
init|=
name|desc
operator|.
name|getRetainList
argument_list|()
operator|.
name|get
argument_list|(
name|posBigTable
argument_list|)
decl_stmt|;
name|int
name|bigTableRetainSize
init|=
name|bigTableRetainList
operator|.
name|size
argument_list|()
decl_stmt|;
name|int
index|[]
name|smallTableIndices
decl_stmt|;
name|int
name|smallTableIndicesSize
decl_stmt|;
name|List
argument_list|<
name|ExprNodeDesc
argument_list|>
name|smallTableExprs
init|=
name|desc
operator|.
name|getExprs
argument_list|()
operator|.
name|get
argument_list|(
name|posSingleVectorMapJoinSmallTable
argument_list|)
decl_stmt|;
if|if
condition|(
name|desc
operator|.
name|getValueIndices
argument_list|()
operator|!=
literal|null
operator|&&
name|desc
operator|.
name|getValueIndices
argument_list|()
operator|.
name|get
argument_list|(
name|posSingleVectorMapJoinSmallTable
argument_list|)
operator|!=
literal|null
condition|)
block|{
name|smallTableIndices
operator|=
name|desc
operator|.
name|getValueIndices
argument_list|()
operator|.
name|get
argument_list|(
name|posSingleVectorMapJoinSmallTable
argument_list|)
expr_stmt|;
name|smallTableIndicesSize
operator|=
name|smallTableIndices
operator|.
name|length
expr_stmt|;
block|}
else|else
block|{
name|smallTableIndices
operator|=
literal|null
expr_stmt|;
name|smallTableIndicesSize
operator|=
literal|0
expr_stmt|;
block|}
name|List
argument_list|<
name|Integer
argument_list|>
name|smallTableRetainList
init|=
name|desc
operator|.
name|getRetainList
argument_list|()
operator|.
name|get
argument_list|(
name|posSingleVectorMapJoinSmallTable
argument_list|)
decl_stmt|;
name|int
name|smallTableRetainSize
init|=
name|smallTableRetainList
operator|.
name|size
argument_list|()
decl_stmt|;
name|int
name|smallTableResultSize
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|smallTableIndicesSize
operator|>
literal|0
condition|)
block|{
name|smallTableResultSize
operator|=
name|smallTableIndicesSize
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|smallTableRetainSize
operator|>
literal|0
condition|)
block|{
name|smallTableResultSize
operator|=
name|smallTableRetainSize
expr_stmt|;
block|}
comment|/*      * Determine the big table retained mapping first so we can optimize out (with      * projection) copying inner join big table keys in the subsequent small table results section.      */
comment|// We use a mapping object here so we can build the projection in any order and
comment|// get the ordered by 0 to n-1 output columns at the end.
comment|//
comment|// Also, to avoid copying a big table key into the small table result area for inner joins,
comment|// we reference it with the projection so there can be duplicate output columns
comment|// in the projection.
name|VectorColumnSourceMapping
name|projectionMapping
init|=
operator|new
name|VectorColumnSourceMapping
argument_list|(
literal|"Projection Mapping"
argument_list|)
decl_stmt|;
name|int
name|nextOutputColumn
init|=
operator|(
name|order
index|[
literal|0
index|]
operator|==
name|posBigTable
condition|?
literal|0
else|:
name|smallTableResultSize
operator|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|bigTableRetainSize
condition|;
name|i
operator|++
control|)
block|{
comment|// Since bigTableValueExpressions may do a calculation and produce a scratch column, we
comment|// need to map to the right batch column.
name|int
name|retainColumn
init|=
name|bigTableRetainList
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|int
name|batchColumnIndex
init|=
name|bigTableValueColumnMap
index|[
name|retainColumn
index|]
decl_stmt|;
name|TypeInfo
name|typeInfo
init|=
name|bigTableValueTypeInfos
index|[
name|i
index|]
decl_stmt|;
comment|// With this map we project the big table batch to make it look like an output batch.
name|projectionMapping
operator|.
name|add
argument_list|(
name|nextOutputColumn
argument_list|,
name|batchColumnIndex
argument_list|,
name|typeInfo
argument_list|)
expr_stmt|;
comment|// Collect columns we copy from the big table batch to the overflow batch.
if|if
condition|(
operator|!
name|bigTableRetainedMapping
operator|.
name|containsOutputColumn
argument_list|(
name|batchColumnIndex
argument_list|)
condition|)
block|{
comment|// Tolerate repeated use of a big table column.
name|bigTableRetainedMapping
operator|.
name|add
argument_list|(
name|batchColumnIndex
argument_list|,
name|batchColumnIndex
argument_list|,
name|typeInfo
argument_list|)
expr_stmt|;
block|}
name|nextOutputColumn
operator|++
expr_stmt|;
block|}
comment|/*      * Now determine the small table results.      */
name|boolean
name|smallTableExprVectorizes
init|=
literal|true
decl_stmt|;
name|int
name|firstSmallTableOutputColumn
decl_stmt|;
name|firstSmallTableOutputColumn
operator|=
operator|(
name|order
index|[
literal|0
index|]
operator|==
name|posBigTable
condition|?
name|bigTableRetainSize
else|:
literal|0
operator|)
expr_stmt|;
name|int
name|smallTableOutputCount
init|=
literal|0
decl_stmt|;
name|nextOutputColumn
operator|=
name|firstSmallTableOutputColumn
expr_stmt|;
comment|// Small table indices has more information (i.e. keys) than retain, so use it if it exists...
name|String
index|[]
name|bigTableRetainedNames
decl_stmt|;
if|if
condition|(
name|smallTableIndicesSize
operator|>
literal|0
condition|)
block|{
name|smallTableOutputCount
operator|=
name|smallTableIndicesSize
expr_stmt|;
name|bigTableRetainedNames
operator|=
operator|new
name|String
index|[
name|smallTableOutputCount
index|]
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|smallTableIndicesSize
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|smallTableIndices
index|[
name|i
index|]
operator|>=
literal|0
condition|)
block|{
comment|// Zero and above numbers indicate a big table key is needed for
comment|// small table result "area".
name|int
name|keyIndex
init|=
name|smallTableIndices
index|[
name|i
index|]
decl_stmt|;
comment|// Since bigTableKeyExpressions may do a calculation and produce a scratch column, we
comment|// need to map the right column.
name|int
name|batchKeyColumn
init|=
name|bigTableKeyColumnMap
index|[
name|keyIndex
index|]
decl_stmt|;
name|bigTableRetainedNames
index|[
name|i
index|]
operator|=
name|bigTableKeyColumnNames
index|[
name|keyIndex
index|]
expr_stmt|;
name|TypeInfo
name|typeInfo
init|=
name|bigTableKeyTypeInfos
index|[
name|keyIndex
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|isOuterJoin
condition|)
block|{
comment|// Optimize inner join keys of small table results.
comment|// Project the big table key into the small table result "area".
name|projectionMapping
operator|.
name|add
argument_list|(
name|nextOutputColumn
argument_list|,
name|batchKeyColumn
argument_list|,
name|typeInfo
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bigTableRetainedMapping
operator|.
name|containsOutputColumn
argument_list|(
name|batchKeyColumn
argument_list|)
condition|)
block|{
comment|// If necessary, copy the big table key into the overflow batch's small table
comment|// result "area".
name|bigTableRetainedMapping
operator|.
name|add
argument_list|(
name|batchKeyColumn
argument_list|,
name|batchKeyColumn
argument_list|,
name|typeInfo
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// For outer joins, since the small table key can be null when there is no match,
comment|// we must have a physical (scratch) column for those keys.  We cannot use the
comment|// projection optimization used by inner joins above.
name|int
name|scratchColumn
init|=
name|vContext
operator|.
name|allocateScratchColumn
argument_list|(
name|typeInfo
argument_list|)
decl_stmt|;
name|projectionMapping
operator|.
name|add
argument_list|(
name|nextOutputColumn
argument_list|,
name|scratchColumn
argument_list|,
name|typeInfo
argument_list|)
expr_stmt|;
name|bigTableRetainedMapping
operator|.
name|add
argument_list|(
name|batchKeyColumn
argument_list|,
name|scratchColumn
argument_list|,
name|typeInfo
argument_list|)
expr_stmt|;
name|bigTableOuterKeyMapping
operator|.
name|add
argument_list|(
name|batchKeyColumn
argument_list|,
name|scratchColumn
argument_list|,
name|typeInfo
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// Negative numbers indicate a column to be (deserialize) read from the small table's
comment|// LazyBinary value row.
name|int
name|smallTableValueIndex
init|=
operator|-
name|smallTableIndices
index|[
name|i
index|]
operator|-
literal|1
decl_stmt|;
name|ExprNodeDesc
name|smallTableExprNode
init|=
name|smallTableExprs
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|validateExprNodeDesc
argument_list|(
name|smallTableExprNode
argument_list|,
literal|"Small Table"
argument_list|)
condition|)
block|{
name|clearNotVectorizedReason
argument_list|()
expr_stmt|;
name|smallTableExprVectorizes
operator|=
literal|false
expr_stmt|;
block|}
name|bigTableRetainedNames
index|[
name|i
index|]
operator|=
name|smallTableExprNode
operator|.
name|toString
argument_list|()
expr_stmt|;
name|TypeInfo
name|typeInfo
init|=
name|smallTableExprNode
operator|.
name|getTypeInfo
argument_list|()
decl_stmt|;
comment|// Make a new big table scratch column for the small table value.
name|int
name|scratchColumn
init|=
name|vContext
operator|.
name|allocateScratchColumn
argument_list|(
name|typeInfo
argument_list|)
decl_stmt|;
name|projectionMapping
operator|.
name|add
argument_list|(
name|nextOutputColumn
argument_list|,
name|scratchColumn
argument_list|,
name|typeInfo
argument_list|)
expr_stmt|;
name|smallTableMapping
operator|.
name|add
argument_list|(
name|smallTableValueIndex
argument_list|,
name|scratchColumn
argument_list|,
name|typeInfo
argument_list|)
expr_stmt|;
block|}
name|nextOutputColumn
operator|++
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|smallTableRetainSize
operator|>
literal|0
condition|)
block|{
name|smallTableOutputCount
operator|=
name|smallTableRetainSize
expr_stmt|;
name|bigTableRetainedNames
operator|=
operator|new
name|String
index|[
name|smallTableOutputCount
index|]
expr_stmt|;
comment|// Only small table values appear in join output result.
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|smallTableRetainSize
condition|;
name|i
operator|++
control|)
block|{
name|int
name|smallTableValueIndex
init|=
name|smallTableRetainList
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|ExprNodeDesc
name|smallTableExprNode
init|=
name|smallTableExprs
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|validateExprNodeDesc
argument_list|(
name|smallTableExprNode
argument_list|,
literal|"Small Table"
argument_list|)
condition|)
block|{
name|clearNotVectorizedReason
argument_list|()
expr_stmt|;
name|smallTableExprVectorizes
operator|=
literal|false
expr_stmt|;
block|}
name|bigTableRetainedNames
index|[
name|i
index|]
operator|=
name|smallTableExprNode
operator|.
name|toString
argument_list|()
expr_stmt|;
comment|// Make a new big table scratch column for the small table value.
name|TypeInfo
name|typeInfo
init|=
name|smallTableExprNode
operator|.
name|getTypeInfo
argument_list|()
decl_stmt|;
name|int
name|scratchColumn
init|=
name|vContext
operator|.
name|allocateScratchColumn
argument_list|(
name|typeInfo
argument_list|)
decl_stmt|;
name|projectionMapping
operator|.
name|add
argument_list|(
name|nextOutputColumn
argument_list|,
name|scratchColumn
argument_list|,
name|typeInfo
argument_list|)
expr_stmt|;
name|smallTableMapping
operator|.
name|add
argument_list|(
name|smallTableValueIndex
argument_list|,
name|scratchColumn
argument_list|,
name|typeInfo
argument_list|)
expr_stmt|;
name|nextOutputColumn
operator|++
expr_stmt|;
block|}
block|}
else|else
block|{
name|bigTableRetainedNames
operator|=
operator|new
name|String
index|[
literal|0
index|]
expr_stmt|;
block|}
name|boolean
name|useOptimizedTable
init|=
name|HiveConf
operator|.
name|getBoolVar
argument_list|(
name|hiveConf
argument_list|,
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVEMAPJOINUSEOPTIMIZEDTABLE
argument_list|)
decl_stmt|;
comment|// Remember the condition variables for EXPLAIN regardless of whether we specialize or not.
name|vectorDesc
operator|.
name|setUseOptimizedTable
argument_list|(
name|useOptimizedTable
argument_list|)
expr_stmt|;
name|vectorDesc
operator|.
name|setIsVectorizationMapJoinNativeEnabled
argument_list|(
name|isVectorizationMapJoinNativeEnabled
argument_list|)
expr_stmt|;
name|vectorDesc
operator|.
name|setEngine
argument_list|(
name|engine
argument_list|)
expr_stmt|;
name|vectorDesc
operator|.
name|setOneMapJoinCondition
argument_list|(
name|oneMapJoinCondition
argument_list|)
expr_stmt|;
name|vectorDesc
operator|.
name|setHasNullSafes
argument_list|(
name|hasNullSafes
argument_list|)
expr_stmt|;
name|vectorDesc
operator|.
name|setSmallTableExprVectorizes
argument_list|(
name|smallTableExprVectorizes
argument_list|)
expr_stmt|;
name|vectorDesc
operator|.
name|setIsFastHashTableEnabled
argument_list|(
name|isFastHashTableEnabled
argument_list|)
expr_stmt|;
name|vectorDesc
operator|.
name|setIsHybridHashJoin
argument_list|(
name|isHybridHashJoin
argument_list|)
expr_stmt|;
name|vectorDesc
operator|.
name|setSupportsKeyTypes
argument_list|(
name|supportsKeyTypes
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|supportsKeyTypes
condition|)
block|{
name|vectorDesc
operator|.
name|setNotSupportedKeyTypes
argument_list|(
operator|new
name|ArrayList
argument_list|(
name|notSupportedKeyTypes
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// Check common conditions for both Optimized and Fast Hash Tables.
name|boolean
name|result
init|=
literal|true
decl_stmt|;
comment|// Assume.
if|if
condition|(
operator|!
name|useOptimizedTable
operator|||
operator|!
name|isVectorizationMapJoinNativeEnabled
operator|||
operator|!
name|isTezOrSpark
operator|||
operator|!
name|oneMapJoinCondition
operator|||
name|hasNullSafes
operator|||
operator|!
name|smallTableExprVectorizes
condition|)
block|{
name|result
operator|=
literal|false
expr_stmt|;
block|}
comment|// supportsKeyTypes
if|if
condition|(
operator|!
name|isFastHashTableEnabled
condition|)
block|{
comment|// Check optimized-only hash table restrictions.
if|if
condition|(
operator|!
name|supportsKeyTypes
condition|)
block|{
name|result
operator|=
literal|false
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// With the fast hash table implementation, we currently do not support
comment|// Hybrid Grace Hash Join.
if|if
condition|(
name|isHybridHashJoin
condition|)
block|{
name|result
operator|=
literal|false
expr_stmt|;
block|}
block|}
comment|// Convert dynamic arrays and maps to simple arrays.
name|bigTableRetainedMapping
operator|.
name|finalize
argument_list|()
expr_stmt|;
name|bigTableOuterKeyMapping
operator|.
name|finalize
argument_list|()
expr_stmt|;
name|smallTableMapping
operator|.
name|finalize
argument_list|()
expr_stmt|;
name|vectorMapJoinInfo
operator|.
name|setBigTableRetainedMapping
argument_list|(
name|bigTableRetainedMapping
argument_list|)
expr_stmt|;
name|vectorMapJoinInfo
operator|.
name|setBigTableOuterKeyMapping
argument_list|(
name|bigTableOuterKeyMapping
argument_list|)
expr_stmt|;
name|vectorMapJoinInfo
operator|.
name|setSmallTableMapping
argument_list|(
name|smallTableMapping
argument_list|)
expr_stmt|;
name|projectionMapping
operator|.
name|finalize
argument_list|()
expr_stmt|;
comment|// Verify we added an entry for each output.
assert|assert
name|projectionMapping
operator|.
name|isSourceSequenceGood
argument_list|()
assert|;
name|vectorMapJoinInfo
operator|.
name|setProjectionMapping
argument_list|(
name|projectionMapping
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
specifier|private
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
name|specializeReduceSinkOperator
parameter_list|(
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
name|op
parameter_list|,
name|VectorizationContext
name|vContext
parameter_list|,
name|ReduceSinkDesc
name|desc
parameter_list|,
name|VectorReduceSinkInfo
name|vectorReduceSinkInfo
parameter_list|)
throws|throws
name|HiveException
block|{
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
name|vectorOp
init|=
literal|null
decl_stmt|;
name|Class
argument_list|<
name|?
extends|extends
name|Operator
argument_list|<
name|?
argument_list|>
argument_list|>
name|opClass
init|=
literal|null
decl_stmt|;
name|Type
index|[]
name|reduceSinkKeyColumnVectorTypes
init|=
name|vectorReduceSinkInfo
operator|.
name|getReduceSinkKeyColumnVectorTypes
argument_list|()
decl_stmt|;
comment|// By default, we can always use the multi-key class.
name|VectorReduceSinkDesc
operator|.
name|ReduceSinkKeyType
name|reduceSinkKeyType
init|=
name|VectorReduceSinkDesc
operator|.
name|ReduceSinkKeyType
operator|.
name|MULTI_KEY
decl_stmt|;
comment|// Look for single column optimization.
if|if
condition|(
name|reduceSinkKeyColumnVectorTypes
operator|.
name|length
operator|==
literal|1
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Vectorizer vectorizeOperator groupby typeName "
operator|+
name|vectorReduceSinkInfo
operator|.
name|getReduceSinkKeyTypeInfos
argument_list|()
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|Type
name|columnVectorType
init|=
name|reduceSinkKeyColumnVectorTypes
index|[
literal|0
index|]
decl_stmt|;
switch|switch
condition|(
name|columnVectorType
condition|)
block|{
case|case
name|LONG
case|:
block|{
name|PrimitiveCategory
name|primitiveCategory
init|=
operator|(
operator|(
name|PrimitiveTypeInfo
operator|)
name|vectorReduceSinkInfo
operator|.
name|getReduceSinkKeyTypeInfos
argument_list|()
index|[
literal|0
index|]
operator|)
operator|.
name|getPrimitiveCategory
argument_list|()
decl_stmt|;
switch|switch
condition|(
name|primitiveCategory
condition|)
block|{
case|case
name|BOOLEAN
case|:
case|case
name|BYTE
case|:
case|case
name|SHORT
case|:
case|case
name|INT
case|:
case|case
name|LONG
case|:
name|reduceSinkKeyType
operator|=
name|VectorReduceSinkDesc
operator|.
name|ReduceSinkKeyType
operator|.
name|LONG
expr_stmt|;
break|break;
default|default:
comment|// Other integer types not supported yet.
break|break;
block|}
block|}
break|break;
case|case
name|BYTES
case|:
name|reduceSinkKeyType
operator|=
name|VectorReduceSinkDesc
operator|.
name|ReduceSinkKeyType
operator|.
name|STRING
expr_stmt|;
default|default:
comment|// Stay with multi-key.
break|break;
block|}
block|}
switch|switch
condition|(
name|reduceSinkKeyType
condition|)
block|{
case|case
name|LONG
case|:
name|opClass
operator|=
name|VectorReduceSinkLongOperator
operator|.
name|class
expr_stmt|;
break|break;
case|case
name|STRING
case|:
name|opClass
operator|=
name|VectorReduceSinkStringOperator
operator|.
name|class
expr_stmt|;
break|break;
case|case
name|MULTI_KEY
case|:
name|opClass
operator|=
name|VectorReduceSinkMultiKeyOperator
operator|.
name|class
expr_stmt|;
break|break;
default|default:
throw|throw
operator|new
name|HiveException
argument_list|(
literal|"Unknown reduce sink key type "
operator|+
name|reduceSinkKeyType
argument_list|)
throw|;
block|}
name|VectorReduceSinkDesc
name|vectorDesc
init|=
operator|(
name|VectorReduceSinkDesc
operator|)
name|desc
operator|.
name|getVectorDesc
argument_list|()
decl_stmt|;
name|vectorDesc
operator|.
name|setReduceSinkKeyType
argument_list|(
name|reduceSinkKeyType
argument_list|)
expr_stmt|;
name|vectorDesc
operator|.
name|setVectorReduceSinkInfo
argument_list|(
name|vectorReduceSinkInfo
argument_list|)
expr_stmt|;
name|vectorOp
operator|=
name|OperatorFactory
operator|.
name|getVectorOperator
argument_list|(
name|opClass
argument_list|,
name|op
operator|.
name|getCompilationOpContext
argument_list|()
argument_list|,
name|op
operator|.
name|getConf
argument_list|()
argument_list|,
name|vContext
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Vectorizer vectorizeOperator reduce sink class "
operator|+
name|vectorOp
operator|.
name|getClass
argument_list|()
operator|.
name|getSimpleName
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|vectorOp
return|;
block|}
specifier|private
name|boolean
name|canSpecializeReduceSink
parameter_list|(
name|ReduceSinkDesc
name|desc
parameter_list|,
name|boolean
name|isTezOrSpark
parameter_list|,
name|VectorizationContext
name|vContext
parameter_list|,
name|VectorReduceSinkInfo
name|vectorReduceSinkInfo
parameter_list|)
throws|throws
name|HiveException
block|{
comment|// Allocate a VectorReduceSinkDesc initially with key type NONE so EXPLAIN can report this
comment|// operator was vectorized, but not native.  And, the conditions.
name|VectorReduceSinkDesc
name|vectorDesc
init|=
operator|new
name|VectorReduceSinkDesc
argument_list|()
decl_stmt|;
name|desc
operator|.
name|setVectorDesc
argument_list|(
name|vectorDesc
argument_list|)
expr_stmt|;
name|boolean
name|isVectorizationReduceSinkNativeEnabled
init|=
name|HiveConf
operator|.
name|getBoolVar
argument_list|(
name|hiveConf
argument_list|,
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVE_VECTORIZATION_REDUCESINK_NEW_ENABLED
argument_list|)
decl_stmt|;
name|String
name|engine
init|=
name|HiveConf
operator|.
name|getVar
argument_list|(
name|hiveConf
argument_list|,
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVE_EXECUTION_ENGINE
argument_list|)
decl_stmt|;
name|boolean
name|hasBuckets
init|=
name|desc
operator|.
name|getBucketCols
argument_list|()
operator|!=
literal|null
operator|&&
operator|!
name|desc
operator|.
name|getBucketCols
argument_list|()
operator|.
name|isEmpty
argument_list|()
decl_stmt|;
name|boolean
name|hasTopN
init|=
name|desc
operator|.
name|getTopN
argument_list|()
operator|>=
literal|0
decl_stmt|;
name|boolean
name|useUniformHash
init|=
name|desc
operator|.
name|getReducerTraits
argument_list|()
operator|.
name|contains
argument_list|(
name|UNIFORM
argument_list|)
decl_stmt|;
name|boolean
name|hasDistinctColumns
init|=
name|desc
operator|.
name|getDistinctColumnIndices
argument_list|()
operator|.
name|size
argument_list|()
operator|>
literal|0
decl_stmt|;
name|TableDesc
name|keyTableDesc
init|=
name|desc
operator|.
name|getKeySerializeInfo
argument_list|()
decl_stmt|;
name|Class
argument_list|<
name|?
extends|extends
name|Deserializer
argument_list|>
name|keySerializerClass
init|=
name|keyTableDesc
operator|.
name|getDeserializerClass
argument_list|()
decl_stmt|;
name|boolean
name|isKeyBinarySortable
init|=
operator|(
name|keySerializerClass
operator|==
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|binarysortable
operator|.
name|BinarySortableSerDe
operator|.
name|class
operator|)
decl_stmt|;
name|TableDesc
name|valueTableDesc
init|=
name|desc
operator|.
name|getValueSerializeInfo
argument_list|()
decl_stmt|;
name|Class
argument_list|<
name|?
extends|extends
name|Deserializer
argument_list|>
name|valueDeserializerClass
init|=
name|valueTableDesc
operator|.
name|getDeserializerClass
argument_list|()
decl_stmt|;
name|boolean
name|isValueLazyBinary
init|=
operator|(
name|valueDeserializerClass
operator|==
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|lazybinary
operator|.
name|LazyBinarySerDe
operator|.
name|class
operator|)
decl_stmt|;
comment|// Remember the condition variables for EXPLAIN regardless.
name|vectorDesc
operator|.
name|setIsVectorizationReduceSinkNativeEnabled
argument_list|(
name|isVectorizationReduceSinkNativeEnabled
argument_list|)
expr_stmt|;
name|vectorDesc
operator|.
name|setEngine
argument_list|(
name|engine
argument_list|)
expr_stmt|;
name|vectorDesc
operator|.
name|setHasBuckets
argument_list|(
name|hasBuckets
argument_list|)
expr_stmt|;
name|vectorDesc
operator|.
name|setHasTopN
argument_list|(
name|hasTopN
argument_list|)
expr_stmt|;
name|vectorDesc
operator|.
name|setUseUniformHash
argument_list|(
name|useUniformHash
argument_list|)
expr_stmt|;
name|vectorDesc
operator|.
name|setHasDistinctColumns
argument_list|(
name|hasDistinctColumns
argument_list|)
expr_stmt|;
name|vectorDesc
operator|.
name|setIsKeyBinarySortable
argument_list|(
name|isKeyBinarySortable
argument_list|)
expr_stmt|;
name|vectorDesc
operator|.
name|setIsValueLazyBinary
argument_list|(
name|isValueLazyBinary
argument_list|)
expr_stmt|;
comment|// Many restrictions.
if|if
condition|(
operator|!
name|isVectorizationReduceSinkNativeEnabled
operator|||
operator|!
name|isTezOrSpark
operator|||
name|hasBuckets
operator|||
name|hasTopN
operator|||
operator|!
name|useUniformHash
operator|||
name|hasDistinctColumns
operator|||
operator|!
name|isKeyBinarySortable
operator|||
operator|!
name|isValueLazyBinary
condition|)
block|{
return|return
literal|false
return|;
block|}
comment|// We are doing work here we'd normally do in VectorGroupByCommonOperator's constructor.
comment|// So if we later decide not to specialize, we'll just waste any scratch columns allocated...
name|List
argument_list|<
name|ExprNodeDesc
argument_list|>
name|keysDescs
init|=
name|desc
operator|.
name|getKeyCols
argument_list|()
decl_stmt|;
name|VectorExpression
index|[]
name|allKeyExpressions
init|=
name|vContext
operator|.
name|getVectorExpressions
argument_list|(
name|keysDescs
argument_list|)
decl_stmt|;
comment|// Since a key expression can be a calculation and the key will go into a scratch column,
comment|// we need the mapping and type information.
name|int
index|[]
name|reduceSinkKeyColumnMap
init|=
operator|new
name|int
index|[
name|allKeyExpressions
operator|.
name|length
index|]
decl_stmt|;
name|TypeInfo
index|[]
name|reduceSinkKeyTypeInfos
init|=
operator|new
name|TypeInfo
index|[
name|allKeyExpressions
operator|.
name|length
index|]
decl_stmt|;
name|Type
index|[]
name|reduceSinkKeyColumnVectorTypes
init|=
operator|new
name|Type
index|[
name|allKeyExpressions
operator|.
name|length
index|]
decl_stmt|;
name|ArrayList
argument_list|<
name|VectorExpression
argument_list|>
name|groupByKeyExpressionsList
init|=
operator|new
name|ArrayList
argument_list|<
name|VectorExpression
argument_list|>
argument_list|()
decl_stmt|;
name|VectorExpression
index|[]
name|reduceSinkKeyExpressions
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|reduceSinkKeyColumnMap
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|VectorExpression
name|ve
init|=
name|allKeyExpressions
index|[
name|i
index|]
decl_stmt|;
name|reduceSinkKeyColumnMap
index|[
name|i
index|]
operator|=
name|ve
operator|.
name|getOutputColumn
argument_list|()
expr_stmt|;
name|reduceSinkKeyTypeInfos
index|[
name|i
index|]
operator|=
name|keysDescs
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|getTypeInfo
argument_list|()
expr_stmt|;
name|reduceSinkKeyColumnVectorTypes
index|[
name|i
index|]
operator|=
name|VectorizationContext
operator|.
name|getColumnVectorTypeFromTypeInfo
argument_list|(
name|reduceSinkKeyTypeInfos
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|IdentityExpression
operator|.
name|isColumnOnly
argument_list|(
name|ve
argument_list|)
condition|)
block|{
name|groupByKeyExpressionsList
operator|.
name|add
argument_list|(
name|ve
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|groupByKeyExpressionsList
operator|.
name|size
argument_list|()
operator|==
literal|0
condition|)
block|{
name|reduceSinkKeyExpressions
operator|=
literal|null
expr_stmt|;
block|}
else|else
block|{
name|reduceSinkKeyExpressions
operator|=
name|groupByKeyExpressionsList
operator|.
name|toArray
argument_list|(
operator|new
name|VectorExpression
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
name|ArrayList
argument_list|<
name|ExprNodeDesc
argument_list|>
name|valueDescs
init|=
name|desc
operator|.
name|getValueCols
argument_list|()
decl_stmt|;
name|VectorExpression
index|[]
name|allValueExpressions
init|=
name|vContext
operator|.
name|getVectorExpressions
argument_list|(
name|valueDescs
argument_list|)
decl_stmt|;
name|int
index|[]
name|reduceSinkValueColumnMap
init|=
operator|new
name|int
index|[
name|valueDescs
operator|.
name|size
argument_list|()
index|]
decl_stmt|;
name|TypeInfo
index|[]
name|reduceSinkValueTypeInfos
init|=
operator|new
name|TypeInfo
index|[
name|valueDescs
operator|.
name|size
argument_list|()
index|]
decl_stmt|;
name|Type
index|[]
name|reduceSinkValueColumnVectorTypes
init|=
operator|new
name|Type
index|[
name|valueDescs
operator|.
name|size
argument_list|()
index|]
decl_stmt|;
name|ArrayList
argument_list|<
name|VectorExpression
argument_list|>
name|reduceSinkValueExpressionsList
init|=
operator|new
name|ArrayList
argument_list|<
name|VectorExpression
argument_list|>
argument_list|()
decl_stmt|;
name|VectorExpression
index|[]
name|reduceSinkValueExpressions
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|valueDescs
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|VectorExpression
name|ve
init|=
name|allValueExpressions
index|[
name|i
index|]
decl_stmt|;
name|reduceSinkValueColumnMap
index|[
name|i
index|]
operator|=
name|ve
operator|.
name|getOutputColumn
argument_list|()
expr_stmt|;
name|reduceSinkValueTypeInfos
index|[
name|i
index|]
operator|=
name|valueDescs
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|getTypeInfo
argument_list|()
expr_stmt|;
name|reduceSinkValueColumnVectorTypes
index|[
name|i
index|]
operator|=
name|VectorizationContext
operator|.
name|getColumnVectorTypeFromTypeInfo
argument_list|(
name|reduceSinkValueTypeInfos
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|IdentityExpression
operator|.
name|isColumnOnly
argument_list|(
name|ve
argument_list|)
condition|)
block|{
name|reduceSinkValueExpressionsList
operator|.
name|add
argument_list|(
name|ve
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|reduceSinkValueExpressionsList
operator|.
name|size
argument_list|()
operator|==
literal|0
condition|)
block|{
name|reduceSinkValueExpressions
operator|=
literal|null
expr_stmt|;
block|}
else|else
block|{
name|reduceSinkValueExpressions
operator|=
name|reduceSinkValueExpressionsList
operator|.
name|toArray
argument_list|(
operator|new
name|VectorExpression
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
name|vectorReduceSinkInfo
operator|.
name|setReduceSinkKeyColumnMap
argument_list|(
name|reduceSinkKeyColumnMap
argument_list|)
expr_stmt|;
name|vectorReduceSinkInfo
operator|.
name|setReduceSinkKeyTypeInfos
argument_list|(
name|reduceSinkKeyTypeInfos
argument_list|)
expr_stmt|;
name|vectorReduceSinkInfo
operator|.
name|setReduceSinkKeyColumnVectorTypes
argument_list|(
name|reduceSinkKeyColumnVectorTypes
argument_list|)
expr_stmt|;
name|vectorReduceSinkInfo
operator|.
name|setReduceSinkKeyExpressions
argument_list|(
name|reduceSinkKeyExpressions
argument_list|)
expr_stmt|;
name|vectorReduceSinkInfo
operator|.
name|setReduceSinkValueColumnMap
argument_list|(
name|reduceSinkValueColumnMap
argument_list|)
expr_stmt|;
name|vectorReduceSinkInfo
operator|.
name|setReduceSinkValueTypeInfos
argument_list|(
name|reduceSinkValueTypeInfos
argument_list|)
expr_stmt|;
name|vectorReduceSinkInfo
operator|.
name|setReduceSinkValueColumnVectorTypes
argument_list|(
name|reduceSinkValueColumnVectorTypes
argument_list|)
expr_stmt|;
name|vectorReduceSinkInfo
operator|.
name|setReduceSinkValueExpressions
argument_list|(
name|reduceSinkValueExpressions
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
specifier|private
name|boolean
name|usesVectorUDFAdaptor
parameter_list|(
name|VectorExpression
name|vecExpr
parameter_list|)
block|{
if|if
condition|(
name|vecExpr
operator|==
literal|null
condition|)
block|{
return|return
literal|false
return|;
block|}
if|if
condition|(
name|vecExpr
operator|instanceof
name|VectorUDFAdaptor
condition|)
block|{
return|return
literal|true
return|;
block|}
if|if
condition|(
name|usesVectorUDFAdaptor
argument_list|(
name|vecExpr
operator|.
name|getChildExpressions
argument_list|()
argument_list|)
condition|)
block|{
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
specifier|private
name|boolean
name|usesVectorUDFAdaptor
parameter_list|(
name|VectorExpression
index|[]
name|vecExprs
parameter_list|)
block|{
if|if
condition|(
name|vecExprs
operator|==
literal|null
condition|)
block|{
return|return
literal|false
return|;
block|}
for|for
control|(
name|VectorExpression
name|vecExpr
range|:
name|vecExprs
control|)
block|{
if|if
condition|(
name|usesVectorUDFAdaptor
argument_list|(
name|vecExpr
argument_list|)
condition|)
block|{
return|return
literal|true
return|;
block|}
block|}
return|return
literal|false
return|;
block|}
specifier|public
specifier|static
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
name|vectorizeTableScanOperator
parameter_list|(
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
name|tableScanOp
parameter_list|,
name|VectorizationContext
name|vContext
parameter_list|)
throws|throws
name|HiveException
block|{
name|TableScanDesc
name|tableScanDesc
init|=
operator|(
name|TableScanDesc
operator|)
name|tableScanOp
operator|.
name|getConf
argument_list|()
decl_stmt|;
name|VectorTableScanDesc
name|vectorTableScanDesc
init|=
operator|new
name|VectorTableScanDesc
argument_list|()
decl_stmt|;
name|tableScanDesc
operator|.
name|setVectorDesc
argument_list|(
name|vectorTableScanDesc
argument_list|)
expr_stmt|;
name|vectorTableScanDesc
operator|.
name|setProjectedOutputColumns
argument_list|(
name|ArrayUtils
operator|.
name|toPrimitive
argument_list|(
name|vContext
operator|.
name|getProjectedColumns
argument_list|()
operator|.
name|toArray
argument_list|(
operator|new
name|Integer
index|[
literal|0
index|]
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|tableScanOp
return|;
block|}
specifier|public
specifier|static
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
name|vectorizeFilterOperator
parameter_list|(
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
name|filterOp
parameter_list|,
name|VectorizationContext
name|vContext
parameter_list|)
throws|throws
name|HiveException
block|{
name|FilterDesc
name|filterDesc
init|=
operator|(
name|FilterDesc
operator|)
name|filterOp
operator|.
name|getConf
argument_list|()
decl_stmt|;
name|VectorFilterDesc
name|vectorFilterDesc
init|=
operator|new
name|VectorFilterDesc
argument_list|()
decl_stmt|;
name|filterDesc
operator|.
name|setVectorDesc
argument_list|(
name|vectorFilterDesc
argument_list|)
expr_stmt|;
name|ExprNodeDesc
name|predicateExpr
init|=
name|filterDesc
operator|.
name|getPredicate
argument_list|()
decl_stmt|;
name|VectorExpression
name|vectorPredicateExpr
init|=
name|vContext
operator|.
name|getVectorExpression
argument_list|(
name|predicateExpr
argument_list|,
name|VectorExpressionDescriptor
operator|.
name|Mode
operator|.
name|FILTER
argument_list|)
decl_stmt|;
name|vectorFilterDesc
operator|.
name|setPredicateExpression
argument_list|(
name|vectorPredicateExpr
argument_list|)
expr_stmt|;
return|return
name|OperatorFactory
operator|.
name|getVectorOperator
argument_list|(
name|filterOp
operator|.
name|getCompilationOpContext
argument_list|()
argument_list|,
name|filterDesc
argument_list|,
name|vContext
argument_list|)
return|;
block|}
comment|/*    * NOTE: The VectorGroupByDesc has already been allocated and partially populated.    */
specifier|public
specifier|static
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
name|vectorizeGroupByOperator
parameter_list|(
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
name|groupByOp
parameter_list|,
name|VectorizationContext
name|vContext
parameter_list|)
throws|throws
name|HiveException
block|{
name|GroupByDesc
name|groupByDesc
init|=
operator|(
name|GroupByDesc
operator|)
name|groupByOp
operator|.
name|getConf
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|ExprNodeDesc
argument_list|>
name|keysDesc
init|=
name|groupByDesc
operator|.
name|getKeys
argument_list|()
decl_stmt|;
name|VectorExpression
index|[]
name|vecKeyExpressions
init|=
name|vContext
operator|.
name|getVectorExpressions
argument_list|(
name|keysDesc
argument_list|)
decl_stmt|;
name|ArrayList
argument_list|<
name|AggregationDesc
argument_list|>
name|aggrDesc
init|=
name|groupByDesc
operator|.
name|getAggregators
argument_list|()
decl_stmt|;
specifier|final
name|int
name|size
init|=
name|aggrDesc
operator|.
name|size
argument_list|()
decl_stmt|;
name|VectorAggregateExpression
index|[]
name|vecAggregators
init|=
operator|new
name|VectorAggregateExpression
index|[
name|size
index|]
decl_stmt|;
name|int
index|[]
name|projectedOutputColumns
init|=
operator|new
name|int
index|[
name|size
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|size
condition|;
operator|++
name|i
control|)
block|{
name|AggregationDesc
name|aggDesc
init|=
name|aggrDesc
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|vecAggregators
index|[
name|i
index|]
operator|=
name|vContext
operator|.
name|getAggregatorExpression
argument_list|(
name|aggDesc
argument_list|)
expr_stmt|;
comment|// GroupBy generates a new vectorized row batch...
name|projectedOutputColumns
index|[
name|i
index|]
operator|=
name|i
expr_stmt|;
block|}
name|VectorGroupByDesc
name|vectorGroupByDesc
init|=
operator|(
name|VectorGroupByDesc
operator|)
name|groupByDesc
operator|.
name|getVectorDesc
argument_list|()
decl_stmt|;
name|vectorGroupByDesc
operator|.
name|setKeyExpressions
argument_list|(
name|vecKeyExpressions
argument_list|)
expr_stmt|;
name|vectorGroupByDesc
operator|.
name|setAggregators
argument_list|(
name|vecAggregators
argument_list|)
expr_stmt|;
name|vectorGroupByDesc
operator|.
name|setProjectedOutputColumns
argument_list|(
name|projectedOutputColumns
argument_list|)
expr_stmt|;
return|return
name|OperatorFactory
operator|.
name|getVectorOperator
argument_list|(
name|groupByOp
operator|.
name|getCompilationOpContext
argument_list|()
argument_list|,
name|groupByDesc
argument_list|,
name|vContext
argument_list|)
return|;
block|}
specifier|public
specifier|static
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
name|vectorizeSelectOperator
parameter_list|(
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
name|selectOp
parameter_list|,
name|VectorizationContext
name|vContext
parameter_list|)
throws|throws
name|HiveException
block|{
name|SelectDesc
name|selectDesc
init|=
operator|(
name|SelectDesc
operator|)
name|selectOp
operator|.
name|getConf
argument_list|()
decl_stmt|;
name|VectorSelectDesc
name|vectorSelectDesc
init|=
operator|new
name|VectorSelectDesc
argument_list|()
decl_stmt|;
name|selectDesc
operator|.
name|setVectorDesc
argument_list|(
name|vectorSelectDesc
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|ExprNodeDesc
argument_list|>
name|colList
init|=
name|selectDesc
operator|.
name|getColList
argument_list|()
decl_stmt|;
name|int
name|index
init|=
literal|0
decl_stmt|;
specifier|final
name|int
name|size
init|=
name|colList
operator|.
name|size
argument_list|()
decl_stmt|;
name|VectorExpression
index|[]
name|vectorSelectExprs
init|=
operator|new
name|VectorExpression
index|[
name|size
index|]
decl_stmt|;
name|int
index|[]
name|projectedOutputColumns
init|=
operator|new
name|int
index|[
name|size
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|size
condition|;
name|i
operator|++
control|)
block|{
name|ExprNodeDesc
name|expr
init|=
name|colList
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|VectorExpression
name|ve
init|=
name|vContext
operator|.
name|getVectorExpression
argument_list|(
name|expr
argument_list|)
decl_stmt|;
name|projectedOutputColumns
index|[
name|i
index|]
operator|=
name|ve
operator|.
name|getOutputColumn
argument_list|()
expr_stmt|;
if|if
condition|(
name|ve
operator|instanceof
name|IdentityExpression
condition|)
block|{
comment|// Suppress useless evaluation.
continue|continue;
block|}
name|vectorSelectExprs
index|[
name|index
operator|++
index|]
operator|=
name|ve
expr_stmt|;
block|}
if|if
condition|(
name|index
operator|<
name|size
condition|)
block|{
name|vectorSelectExprs
operator|=
name|Arrays
operator|.
name|copyOf
argument_list|(
name|vectorSelectExprs
argument_list|,
name|index
argument_list|)
expr_stmt|;
block|}
name|vectorSelectDesc
operator|.
name|setSelectExpressions
argument_list|(
name|vectorSelectExprs
argument_list|)
expr_stmt|;
name|vectorSelectDesc
operator|.
name|setProjectedOutputColumns
argument_list|(
name|projectedOutputColumns
argument_list|)
expr_stmt|;
return|return
name|OperatorFactory
operator|.
name|getVectorOperator
argument_list|(
name|selectOp
operator|.
name|getCompilationOpContext
argument_list|()
argument_list|,
name|selectDesc
argument_list|,
name|vContext
argument_list|)
return|;
block|}
specifier|public
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
name|vectorizeOperator
parameter_list|(
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
name|op
parameter_list|,
name|VectorizationContext
name|vContext
parameter_list|,
name|boolean
name|isTezOrSpark
parameter_list|,
name|VectorTaskColumnInfo
name|vectorTaskColumnInfo
parameter_list|)
throws|throws
name|HiveException
block|{
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
name|vectorOp
init|=
literal|null
decl_stmt|;
name|boolean
name|isNative
decl_stmt|;
switch|switch
condition|(
name|op
operator|.
name|getType
argument_list|()
condition|)
block|{
case|case
name|TABLESCAN
case|:
name|vectorOp
operator|=
name|vectorizeTableScanOperator
argument_list|(
name|op
argument_list|,
name|vContext
argument_list|)
expr_stmt|;
name|isNative
operator|=
literal|true
expr_stmt|;
break|break;
case|case
name|MAPJOIN
case|:
block|{
if|if
condition|(
name|op
operator|instanceof
name|MapJoinOperator
condition|)
block|{
name|VectorMapJoinInfo
name|vectorMapJoinInfo
init|=
operator|new
name|VectorMapJoinInfo
argument_list|()
decl_stmt|;
name|MapJoinDesc
name|desc
init|=
operator|(
name|MapJoinDesc
operator|)
name|op
operator|.
name|getConf
argument_list|()
decl_stmt|;
name|boolean
name|specialize
init|=
name|canSpecializeMapJoin
argument_list|(
name|op
argument_list|,
name|desc
argument_list|,
name|isTezOrSpark
argument_list|,
name|vContext
argument_list|,
name|vectorMapJoinInfo
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|specialize
condition|)
block|{
name|Class
argument_list|<
name|?
extends|extends
name|Operator
argument_list|<
name|?
argument_list|>
argument_list|>
name|opClass
init|=
literal|null
decl_stmt|;
comment|// *NON-NATIVE* vector map differences for LEFT OUTER JOIN and Filtered...
name|List
argument_list|<
name|ExprNodeDesc
argument_list|>
name|bigTableFilters
init|=
name|desc
operator|.
name|getFilters
argument_list|()
operator|.
name|get
argument_list|(
operator|(
name|byte
operator|)
name|desc
operator|.
name|getPosBigTable
argument_list|()
argument_list|)
decl_stmt|;
name|boolean
name|isOuterAndFiltered
init|=
operator|(
operator|!
name|desc
operator|.
name|isNoOuterJoin
argument_list|()
operator|&&
name|bigTableFilters
operator|.
name|size
argument_list|()
operator|>
literal|0
operator|)
decl_stmt|;
if|if
condition|(
operator|!
name|isOuterAndFiltered
condition|)
block|{
name|opClass
operator|=
name|VectorMapJoinOperator
operator|.
name|class
expr_stmt|;
block|}
else|else
block|{
name|opClass
operator|=
name|VectorMapJoinOuterFilteredOperator
operator|.
name|class
expr_stmt|;
block|}
name|vectorOp
operator|=
name|OperatorFactory
operator|.
name|getVectorOperator
argument_list|(
name|opClass
argument_list|,
name|op
operator|.
name|getCompilationOpContext
argument_list|()
argument_list|,
name|op
operator|.
name|getConf
argument_list|()
argument_list|,
name|vContext
argument_list|)
expr_stmt|;
name|isNative
operator|=
literal|false
expr_stmt|;
block|}
else|else
block|{
comment|// TEMPORARY Until Native Vector Map Join with Hybrid passes tests...
comment|// HiveConf.setBoolVar(physicalContext.getConf(),
comment|//    HiveConf.ConfVars.HIVEUSEHYBRIDGRACEHASHJOIN, false);
name|vectorOp
operator|=
name|specializeMapJoinOperator
argument_list|(
name|op
argument_list|,
name|vContext
argument_list|,
name|desc
argument_list|,
name|vectorMapJoinInfo
argument_list|)
expr_stmt|;
name|isNative
operator|=
literal|true
expr_stmt|;
if|if
condition|(
name|vectorTaskColumnInfo
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|usesVectorUDFAdaptor
argument_list|(
name|vectorMapJoinInfo
operator|.
name|getBigTableKeyExpressions
argument_list|()
argument_list|)
condition|)
block|{
name|vectorTaskColumnInfo
operator|.
name|setUsesVectorUDFAdaptor
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|usesVectorUDFAdaptor
argument_list|(
name|vectorMapJoinInfo
operator|.
name|getBigTableValueExpressions
argument_list|()
argument_list|)
condition|)
block|{
name|vectorTaskColumnInfo
operator|.
name|setUsesVectorUDFAdaptor
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
else|else
block|{
name|Preconditions
operator|.
name|checkState
argument_list|(
name|op
operator|instanceof
name|SMBMapJoinOperator
argument_list|)
expr_stmt|;
name|SMBJoinDesc
name|smbJoinSinkDesc
init|=
operator|(
name|SMBJoinDesc
operator|)
name|op
operator|.
name|getConf
argument_list|()
decl_stmt|;
name|VectorSMBJoinDesc
name|vectorSMBJoinDesc
init|=
operator|new
name|VectorSMBJoinDesc
argument_list|()
decl_stmt|;
name|smbJoinSinkDesc
operator|.
name|setVectorDesc
argument_list|(
name|vectorSMBJoinDesc
argument_list|)
expr_stmt|;
name|vectorOp
operator|=
name|OperatorFactory
operator|.
name|getVectorOperator
argument_list|(
name|op
operator|.
name|getCompilationOpContext
argument_list|()
argument_list|,
name|smbJoinSinkDesc
argument_list|,
name|vContext
argument_list|)
expr_stmt|;
name|isNative
operator|=
literal|false
expr_stmt|;
block|}
block|}
break|break;
case|case
name|REDUCESINK
case|:
block|{
name|VectorReduceSinkInfo
name|vectorReduceSinkInfo
init|=
operator|new
name|VectorReduceSinkInfo
argument_list|()
decl_stmt|;
name|ReduceSinkDesc
name|desc
init|=
operator|(
name|ReduceSinkDesc
operator|)
name|op
operator|.
name|getConf
argument_list|()
decl_stmt|;
name|boolean
name|specialize
init|=
name|canSpecializeReduceSink
argument_list|(
name|desc
argument_list|,
name|isTezOrSpark
argument_list|,
name|vContext
argument_list|,
name|vectorReduceSinkInfo
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|specialize
condition|)
block|{
name|vectorOp
operator|=
name|OperatorFactory
operator|.
name|getVectorOperator
argument_list|(
name|op
operator|.
name|getCompilationOpContext
argument_list|()
argument_list|,
name|op
operator|.
name|getConf
argument_list|()
argument_list|,
name|vContext
argument_list|)
expr_stmt|;
name|isNative
operator|=
literal|false
expr_stmt|;
block|}
else|else
block|{
name|vectorOp
operator|=
name|specializeReduceSinkOperator
argument_list|(
name|op
argument_list|,
name|vContext
argument_list|,
name|desc
argument_list|,
name|vectorReduceSinkInfo
argument_list|)
expr_stmt|;
name|isNative
operator|=
literal|true
expr_stmt|;
if|if
condition|(
name|vectorTaskColumnInfo
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|usesVectorUDFAdaptor
argument_list|(
name|vectorReduceSinkInfo
operator|.
name|getReduceSinkKeyExpressions
argument_list|()
argument_list|)
condition|)
block|{
name|vectorTaskColumnInfo
operator|.
name|setUsesVectorUDFAdaptor
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|usesVectorUDFAdaptor
argument_list|(
name|vectorReduceSinkInfo
operator|.
name|getReduceSinkValueExpressions
argument_list|()
argument_list|)
condition|)
block|{
name|vectorTaskColumnInfo
operator|.
name|setUsesVectorUDFAdaptor
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
break|break;
case|case
name|FILTER
case|:
block|{
name|vectorOp
operator|=
name|vectorizeFilterOperator
argument_list|(
name|op
argument_list|,
name|vContext
argument_list|)
expr_stmt|;
name|isNative
operator|=
literal|true
expr_stmt|;
if|if
condition|(
name|vectorTaskColumnInfo
operator|!=
literal|null
condition|)
block|{
name|VectorFilterDesc
name|vectorFilterDesc
init|=
call|(
name|VectorFilterDesc
call|)
argument_list|(
operator|(
name|AbstractOperatorDesc
operator|)
name|vectorOp
operator|.
name|getConf
argument_list|()
argument_list|)
operator|.
name|getVectorDesc
argument_list|()
decl_stmt|;
name|VectorExpression
name|vectorPredicateExpr
init|=
name|vectorFilterDesc
operator|.
name|getPredicateExpression
argument_list|()
decl_stmt|;
if|if
condition|(
name|usesVectorUDFAdaptor
argument_list|(
name|vectorPredicateExpr
argument_list|)
condition|)
block|{
name|vectorTaskColumnInfo
operator|.
name|setUsesVectorUDFAdaptor
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
block|}
block|}
break|break;
case|case
name|SELECT
case|:
block|{
name|vectorOp
operator|=
name|vectorizeSelectOperator
argument_list|(
name|op
argument_list|,
name|vContext
argument_list|)
expr_stmt|;
name|isNative
operator|=
literal|true
expr_stmt|;
if|if
condition|(
name|vectorTaskColumnInfo
operator|!=
literal|null
condition|)
block|{
name|VectorSelectDesc
name|vectorSelectDesc
init|=
call|(
name|VectorSelectDesc
call|)
argument_list|(
operator|(
name|AbstractOperatorDesc
operator|)
name|vectorOp
operator|.
name|getConf
argument_list|()
argument_list|)
operator|.
name|getVectorDesc
argument_list|()
decl_stmt|;
name|VectorExpression
index|[]
name|vectorSelectExprs
init|=
name|vectorSelectDesc
operator|.
name|getSelectExpressions
argument_list|()
decl_stmt|;
if|if
condition|(
name|usesVectorUDFAdaptor
argument_list|(
name|vectorSelectExprs
argument_list|)
condition|)
block|{
name|vectorTaskColumnInfo
operator|.
name|setUsesVectorUDFAdaptor
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
block|}
block|}
break|break;
case|case
name|GROUPBY
case|:
block|{
name|vectorOp
operator|=
name|vectorizeGroupByOperator
argument_list|(
name|op
argument_list|,
name|vContext
argument_list|)
expr_stmt|;
name|isNative
operator|=
literal|false
expr_stmt|;
if|if
condition|(
name|vectorTaskColumnInfo
operator|!=
literal|null
condition|)
block|{
name|VectorGroupByDesc
name|vectorGroupByDesc
init|=
call|(
name|VectorGroupByDesc
call|)
argument_list|(
operator|(
name|AbstractOperatorDesc
operator|)
name|vectorOp
operator|.
name|getConf
argument_list|()
argument_list|)
operator|.
name|getVectorDesc
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|vectorGroupByDesc
operator|.
name|isVectorOutput
argument_list|()
condition|)
block|{
name|vectorTaskColumnInfo
operator|.
name|setGroupByVectorOutput
argument_list|(
literal|false
argument_list|)
expr_stmt|;
block|}
name|VectorExpression
index|[]
name|vecKeyExpressions
init|=
name|vectorGroupByDesc
operator|.
name|getKeyExpressions
argument_list|()
decl_stmt|;
if|if
condition|(
name|usesVectorUDFAdaptor
argument_list|(
name|vecKeyExpressions
argument_list|)
condition|)
block|{
name|vectorTaskColumnInfo
operator|.
name|setUsesVectorUDFAdaptor
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
name|VectorAggregateExpression
index|[]
name|vecAggregators
init|=
name|vectorGroupByDesc
operator|.
name|getAggregators
argument_list|()
decl_stmt|;
for|for
control|(
name|VectorAggregateExpression
name|vecAggr
range|:
name|vecAggregators
control|)
block|{
if|if
condition|(
name|usesVectorUDFAdaptor
argument_list|(
name|vecAggr
operator|.
name|inputExpression
argument_list|()
argument_list|)
condition|)
block|{
name|vectorTaskColumnInfo
operator|.
name|setUsesVectorUDFAdaptor
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
break|break;
case|case
name|FILESINK
case|:
block|{
name|FileSinkDesc
name|fileSinkDesc
init|=
operator|(
name|FileSinkDesc
operator|)
name|op
operator|.
name|getConf
argument_list|()
decl_stmt|;
name|VectorFileSinkDesc
name|vectorFileSinkDesc
init|=
operator|new
name|VectorFileSinkDesc
argument_list|()
decl_stmt|;
name|fileSinkDesc
operator|.
name|setVectorDesc
argument_list|(
name|vectorFileSinkDesc
argument_list|)
expr_stmt|;
name|vectorOp
operator|=
name|OperatorFactory
operator|.
name|getVectorOperator
argument_list|(
name|op
operator|.
name|getCompilationOpContext
argument_list|()
argument_list|,
name|fileSinkDesc
argument_list|,
name|vContext
argument_list|)
expr_stmt|;
name|isNative
operator|=
literal|false
expr_stmt|;
block|}
break|break;
case|case
name|LIMIT
case|:
block|{
name|LimitDesc
name|limitDesc
init|=
operator|(
name|LimitDesc
operator|)
name|op
operator|.
name|getConf
argument_list|()
decl_stmt|;
name|VectorLimitDesc
name|vectorLimitDesc
init|=
operator|new
name|VectorLimitDesc
argument_list|()
decl_stmt|;
name|limitDesc
operator|.
name|setVectorDesc
argument_list|(
name|vectorLimitDesc
argument_list|)
expr_stmt|;
name|vectorOp
operator|=
name|OperatorFactory
operator|.
name|getVectorOperator
argument_list|(
name|op
operator|.
name|getCompilationOpContext
argument_list|()
argument_list|,
name|limitDesc
argument_list|,
name|vContext
argument_list|)
expr_stmt|;
name|isNative
operator|=
literal|true
expr_stmt|;
block|}
break|break;
case|case
name|EVENT
case|:
block|{
name|AppMasterEventDesc
name|eventDesc
init|=
operator|(
name|AppMasterEventDesc
operator|)
name|op
operator|.
name|getConf
argument_list|()
decl_stmt|;
name|VectorAppMasterEventDesc
name|vectorEventDesc
init|=
operator|new
name|VectorAppMasterEventDesc
argument_list|()
decl_stmt|;
name|eventDesc
operator|.
name|setVectorDesc
argument_list|(
name|vectorEventDesc
argument_list|)
expr_stmt|;
name|vectorOp
operator|=
name|OperatorFactory
operator|.
name|getVectorOperator
argument_list|(
name|op
operator|.
name|getCompilationOpContext
argument_list|()
argument_list|,
name|eventDesc
argument_list|,
name|vContext
argument_list|)
expr_stmt|;
name|isNative
operator|=
literal|true
expr_stmt|;
block|}
break|break;
case|case
name|HASHTABLESINK
case|:
block|{
name|SparkHashTableSinkDesc
name|sparkHashTableSinkDesc
init|=
operator|(
name|SparkHashTableSinkDesc
operator|)
name|op
operator|.
name|getConf
argument_list|()
decl_stmt|;
name|VectorSparkHashTableSinkDesc
name|vectorSparkHashTableSinkDesc
init|=
operator|new
name|VectorSparkHashTableSinkDesc
argument_list|()
decl_stmt|;
name|sparkHashTableSinkDesc
operator|.
name|setVectorDesc
argument_list|(
name|vectorSparkHashTableSinkDesc
argument_list|)
expr_stmt|;
name|vectorOp
operator|=
name|OperatorFactory
operator|.
name|getVectorOperator
argument_list|(
name|op
operator|.
name|getCompilationOpContext
argument_list|()
argument_list|,
name|sparkHashTableSinkDesc
argument_list|,
name|vContext
argument_list|)
expr_stmt|;
name|isNative
operator|=
literal|true
expr_stmt|;
block|}
break|break;
case|case
name|SPARKPRUNINGSINK
case|:
block|{
name|SparkPartitionPruningSinkDesc
name|sparkPartitionPruningSinkDesc
init|=
operator|(
name|SparkPartitionPruningSinkDesc
operator|)
name|op
operator|.
name|getConf
argument_list|()
decl_stmt|;
name|VectorSparkPartitionPruningSinkDesc
name|vectorSparkPartitionPruningSinkDesc
init|=
operator|new
name|VectorSparkPartitionPruningSinkDesc
argument_list|()
decl_stmt|;
name|sparkPartitionPruningSinkDesc
operator|.
name|setVectorDesc
argument_list|(
name|vectorSparkPartitionPruningSinkDesc
argument_list|)
expr_stmt|;
name|vectorOp
operator|=
name|OperatorFactory
operator|.
name|getVectorOperator
argument_list|(
name|op
operator|.
name|getCompilationOpContext
argument_list|()
argument_list|,
name|sparkPartitionPruningSinkDesc
argument_list|,
name|vContext
argument_list|)
expr_stmt|;
name|isNative
operator|=
literal|true
expr_stmt|;
block|}
break|break;
default|default:
comment|// These are children of GROUP BY operators with non-vector outputs.
name|isNative
operator|=
literal|false
expr_stmt|;
name|vectorOp
operator|=
name|op
expr_stmt|;
break|break;
block|}
name|Preconditions
operator|.
name|checkState
argument_list|(
name|vectorOp
operator|!=
literal|null
argument_list|)
expr_stmt|;
if|if
condition|(
name|vectorTaskColumnInfo
operator|!=
literal|null
operator|&&
operator|!
name|isNative
condition|)
block|{
name|vectorTaskColumnInfo
operator|.
name|setAllNative
argument_list|(
literal|false
argument_list|)
expr_stmt|;
block|}
name|LOG
operator|.
name|debug
argument_list|(
literal|"vectorizeOperator "
operator|+
name|vectorOp
operator|.
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"vectorizeOperator "
operator|+
name|vectorOp
operator|.
name|getConf
argument_list|()
operator|.
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|vectorOp
operator|!=
name|op
condition|)
block|{
name|fixupParentChildOperators
argument_list|(
name|op
argument_list|,
name|vectorOp
argument_list|)
expr_stmt|;
operator|(
operator|(
name|AbstractOperatorDesc
operator|)
name|vectorOp
operator|.
name|getConf
argument_list|()
operator|)
operator|.
name|setVectorMode
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
return|return
name|vectorOp
return|;
block|}
specifier|private
name|boolean
name|isVirtualColumn
parameter_list|(
name|ColumnInfo
name|column
parameter_list|)
block|{
comment|// Not using method column.getIsVirtualCol() because partitioning columns are also
comment|// treated as virtual columns in ColumnInfo.
if|if
condition|(
name|VirtualColumn
operator|.
name|VIRTUAL_COLUMN_NAMES
operator|.
name|contains
argument_list|(
name|column
operator|.
name|getInternalName
argument_list|()
argument_list|)
condition|)
block|{
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
specifier|public
name|void
name|debugDisplayAllMaps
parameter_list|(
name|BaseWork
name|work
parameter_list|)
block|{
name|VectorizedRowBatchCtx
name|vectorizedRowBatchCtx
init|=
name|work
operator|.
name|getVectorizedRowBatchCtx
argument_list|()
decl_stmt|;
name|String
index|[]
name|allColumnNames
init|=
name|vectorizedRowBatchCtx
operator|.
name|getRowColumnNames
argument_list|()
decl_stmt|;
name|Object
name|columnTypeInfos
init|=
name|vectorizedRowBatchCtx
operator|.
name|getRowColumnTypeInfos
argument_list|()
decl_stmt|;
name|int
name|partitionColumnCount
init|=
name|vectorizedRowBatchCtx
operator|.
name|getPartitionColumnCount
argument_list|()
decl_stmt|;
name|String
index|[]
name|scratchColumnTypeNames
init|=
name|vectorizedRowBatchCtx
operator|.
name|getScratchColumnTypeNames
argument_list|()
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"debugDisplayAllMaps allColumnNames "
operator|+
name|Arrays
operator|.
name|toString
argument_list|(
name|allColumnNames
argument_list|)
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"debugDisplayAllMaps columnTypeInfos "
operator|+
name|Arrays
operator|.
name|deepToString
argument_list|(
operator|(
name|Object
index|[]
operator|)
name|columnTypeInfos
argument_list|)
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"debugDisplayAllMaps partitionColumnCount "
operator|+
name|partitionColumnCount
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"debugDisplayAllMaps scratchColumnTypeNames "
operator|+
name|Arrays
operator|.
name|toString
argument_list|(
name|scratchColumnTypeNames
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_class

end_unit

