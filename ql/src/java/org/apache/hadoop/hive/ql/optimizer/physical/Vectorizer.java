begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|optimizer
operator|.
name|physical
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|Serializable
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Comparator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|LinkedHashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Properties
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Stack
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|TreeMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|regex
operator|.
name|Pattern
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|Log
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|LogFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|conf
operator|.
name|HiveConf
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|metastore
operator|.
name|api
operator|.
name|hive_metastoreConstants
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|mr
operator|.
name|MapRedTask
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|tez
operator|.
name|TezTask
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|vector
operator|.
name|VectorExtractOperator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|vector
operator|.
name|VectorExpressionDescriptor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|vector
operator|.
name|VectorGroupByOperator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|vector
operator|.
name|VectorizationContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|vector
operator|.
name|VectorizationContextRegion
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|vector
operator|.
name|VectorizedInputFormatInterface
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|vector
operator|.
name|expressions
operator|.
name|aggregates
operator|.
name|VectorAggregateExpression
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|lib
operator|.
name|DefaultGraphWalker
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|lib
operator|.
name|DefaultRuleDispatcher
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|lib
operator|.
name|Dispatcher
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|lib
operator|.
name|GraphWalker
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|lib
operator|.
name|Node
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|lib
operator|.
name|NodeProcessor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|lib
operator|.
name|NodeProcessorCtx
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|lib
operator|.
name|PreOrderWalker
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|lib
operator|.
name|Rule
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|lib
operator|.
name|RuleRegExp
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|lib
operator|.
name|TaskGraphWalker
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|metadata
operator|.
name|HiveException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|metadata
operator|.
name|VirtualColumn
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|parse
operator|.
name|SemanticException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|AbstractOperatorDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|AggregationDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|BaseWork
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|ExprNodeColumnDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|ExprNodeDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|ExprNodeGenericFuncDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|GroupByDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|MapJoinDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|MapWork
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|OperatorDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|PartitionDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|ReduceWork
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|SMBJoinDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|TableScanDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|TezWork
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|VectorGroupByDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|api
operator|.
name|OperatorType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|udf
operator|.
name|UDFAcos
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|udf
operator|.
name|UDFAsin
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|udf
operator|.
name|UDFAtan
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|udf
operator|.
name|UDFBin
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|udf
operator|.
name|UDFConv
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|udf
operator|.
name|UDFCos
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|udf
operator|.
name|UDFDayOfMonth
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|udf
operator|.
name|UDFDegrees
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|udf
operator|.
name|UDFExp
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|udf
operator|.
name|UDFHex
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|udf
operator|.
name|UDFHour
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|udf
operator|.
name|UDFLength
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|udf
operator|.
name|UDFLike
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|udf
operator|.
name|UDFLn
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|udf
operator|.
name|UDFLog
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|udf
operator|.
name|UDFLog10
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|udf
operator|.
name|UDFLog2
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|udf
operator|.
name|UDFMinute
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|udf
operator|.
name|UDFMonth
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|udf
operator|.
name|UDFRadians
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|udf
operator|.
name|UDFRand
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|udf
operator|.
name|UDFRegExp
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|udf
operator|.
name|UDFSecond
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|udf
operator|.
name|UDFSign
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|udf
operator|.
name|UDFSin
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|udf
operator|.
name|UDFSqrt
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|udf
operator|.
name|UDFSubstr
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|udf
operator|.
name|UDFTan
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|udf
operator|.
name|UDFToBoolean
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|udf
operator|.
name|UDFToByte
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|udf
operator|.
name|UDFToDouble
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|udf
operator|.
name|UDFToFloat
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|udf
operator|.
name|UDFToInteger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|udf
operator|.
name|UDFToLong
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|udf
operator|.
name|UDFToShort
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|udf
operator|.
name|UDFToString
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|udf
operator|.
name|UDFWeekOfYear
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|udf
operator|.
name|UDFYear
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|udf
operator|.
name|generic
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|objectinspector
operator|.
name|ObjectInspector
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|objectinspector
operator|.
name|StructField
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|objectinspector
operator|.
name|StructObjectInspector
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|typeinfo
operator|.
name|TypeInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|typeinfo
operator|.
name|TypeInfoUtils
import|;
end_import

begin_class
specifier|public
class|class
name|Vectorizer
implements|implements
name|PhysicalPlanResolver
block|{
specifier|protected
specifier|static
specifier|transient
specifier|final
name|Log
name|LOG
init|=
name|LogFactory
operator|.
name|getLog
argument_list|(
name|Vectorizer
operator|.
name|class
argument_list|)
decl_stmt|;
name|Pattern
name|supportedDataTypesPattern
decl_stmt|;
name|List
argument_list|<
name|Task
argument_list|<
name|?
extends|extends
name|Serializable
argument_list|>
argument_list|>
name|vectorizableTasks
init|=
operator|new
name|ArrayList
argument_list|<
name|Task
argument_list|<
name|?
extends|extends
name|Serializable
argument_list|>
argument_list|>
argument_list|()
decl_stmt|;
name|Set
argument_list|<
name|Class
argument_list|<
name|?
argument_list|>
argument_list|>
name|supportedGenericUDFs
init|=
operator|new
name|HashSet
argument_list|<
name|Class
argument_list|<
name|?
argument_list|>
argument_list|>
argument_list|()
decl_stmt|;
name|Set
argument_list|<
name|String
argument_list|>
name|supportedAggregationUdfs
init|=
operator|new
name|HashSet
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
specifier|private
name|PhysicalContext
name|physicalContext
init|=
literal|null
decl_stmt|;
empty_stmt|;
specifier|public
name|Vectorizer
parameter_list|()
block|{
name|StringBuilder
name|patternBuilder
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|patternBuilder
operator|.
name|append
argument_list|(
literal|"int"
argument_list|)
expr_stmt|;
name|patternBuilder
operator|.
name|append
argument_list|(
literal|"|smallint"
argument_list|)
expr_stmt|;
name|patternBuilder
operator|.
name|append
argument_list|(
literal|"|tinyint"
argument_list|)
expr_stmt|;
name|patternBuilder
operator|.
name|append
argument_list|(
literal|"|bigint"
argument_list|)
expr_stmt|;
name|patternBuilder
operator|.
name|append
argument_list|(
literal|"|integer"
argument_list|)
expr_stmt|;
name|patternBuilder
operator|.
name|append
argument_list|(
literal|"|long"
argument_list|)
expr_stmt|;
name|patternBuilder
operator|.
name|append
argument_list|(
literal|"|short"
argument_list|)
expr_stmt|;
name|patternBuilder
operator|.
name|append
argument_list|(
literal|"|timestamp"
argument_list|)
expr_stmt|;
name|patternBuilder
operator|.
name|append
argument_list|(
literal|"|boolean"
argument_list|)
expr_stmt|;
name|patternBuilder
operator|.
name|append
argument_list|(
literal|"|binary"
argument_list|)
expr_stmt|;
name|patternBuilder
operator|.
name|append
argument_list|(
literal|"|string"
argument_list|)
expr_stmt|;
name|patternBuilder
operator|.
name|append
argument_list|(
literal|"|byte"
argument_list|)
expr_stmt|;
name|patternBuilder
operator|.
name|append
argument_list|(
literal|"|float"
argument_list|)
expr_stmt|;
name|patternBuilder
operator|.
name|append
argument_list|(
literal|"|double"
argument_list|)
expr_stmt|;
name|patternBuilder
operator|.
name|append
argument_list|(
literal|"|date"
argument_list|)
expr_stmt|;
name|patternBuilder
operator|.
name|append
argument_list|(
literal|"|void"
argument_list|)
expr_stmt|;
comment|// Decimal types can be specified with different precision and scales e.g. decimal(10,5),
comment|// as opposed to other data types which can be represented by constant strings.
comment|// The regex matches only the "decimal" prefix of the type.
name|patternBuilder
operator|.
name|append
argument_list|(
literal|"|decimal.*"
argument_list|)
expr_stmt|;
comment|// CHAR and VARCHAR types can be specified with maximum length.
name|patternBuilder
operator|.
name|append
argument_list|(
literal|"|char.*"
argument_list|)
expr_stmt|;
name|patternBuilder
operator|.
name|append
argument_list|(
literal|"|varchar.*"
argument_list|)
expr_stmt|;
name|supportedDataTypesPattern
operator|=
name|Pattern
operator|.
name|compile
argument_list|(
name|patternBuilder
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|supportedGenericUDFs
operator|.
name|add
argument_list|(
name|GenericUDFOPPlus
operator|.
name|class
argument_list|)
expr_stmt|;
name|supportedGenericUDFs
operator|.
name|add
argument_list|(
name|GenericUDFOPMinus
operator|.
name|class
argument_list|)
expr_stmt|;
name|supportedGenericUDFs
operator|.
name|add
argument_list|(
name|GenericUDFOPMultiply
operator|.
name|class
argument_list|)
expr_stmt|;
name|supportedGenericUDFs
operator|.
name|add
argument_list|(
name|GenericUDFOPDivide
operator|.
name|class
argument_list|)
expr_stmt|;
name|supportedGenericUDFs
operator|.
name|add
argument_list|(
name|GenericUDFOPMod
operator|.
name|class
argument_list|)
expr_stmt|;
name|supportedGenericUDFs
operator|.
name|add
argument_list|(
name|GenericUDFOPNegative
operator|.
name|class
argument_list|)
expr_stmt|;
name|supportedGenericUDFs
operator|.
name|add
argument_list|(
name|GenericUDFOPPositive
operator|.
name|class
argument_list|)
expr_stmt|;
name|supportedGenericUDFs
operator|.
name|add
argument_list|(
name|GenericUDFOPEqualOrLessThan
operator|.
name|class
argument_list|)
expr_stmt|;
name|supportedGenericUDFs
operator|.
name|add
argument_list|(
name|GenericUDFOPEqualOrGreaterThan
operator|.
name|class
argument_list|)
expr_stmt|;
name|supportedGenericUDFs
operator|.
name|add
argument_list|(
name|GenericUDFOPGreaterThan
operator|.
name|class
argument_list|)
expr_stmt|;
name|supportedGenericUDFs
operator|.
name|add
argument_list|(
name|GenericUDFOPLessThan
operator|.
name|class
argument_list|)
expr_stmt|;
name|supportedGenericUDFs
operator|.
name|add
argument_list|(
name|GenericUDFOPNot
operator|.
name|class
argument_list|)
expr_stmt|;
name|supportedGenericUDFs
operator|.
name|add
argument_list|(
name|GenericUDFOPNotEqual
operator|.
name|class
argument_list|)
expr_stmt|;
name|supportedGenericUDFs
operator|.
name|add
argument_list|(
name|GenericUDFOPNotNull
operator|.
name|class
argument_list|)
expr_stmt|;
name|supportedGenericUDFs
operator|.
name|add
argument_list|(
name|GenericUDFOPNull
operator|.
name|class
argument_list|)
expr_stmt|;
name|supportedGenericUDFs
operator|.
name|add
argument_list|(
name|GenericUDFOPOr
operator|.
name|class
argument_list|)
expr_stmt|;
name|supportedGenericUDFs
operator|.
name|add
argument_list|(
name|GenericUDFOPAnd
operator|.
name|class
argument_list|)
expr_stmt|;
name|supportedGenericUDFs
operator|.
name|add
argument_list|(
name|GenericUDFOPEqual
operator|.
name|class
argument_list|)
expr_stmt|;
name|supportedGenericUDFs
operator|.
name|add
argument_list|(
name|UDFLength
operator|.
name|class
argument_list|)
expr_stmt|;
name|supportedGenericUDFs
operator|.
name|add
argument_list|(
name|UDFYear
operator|.
name|class
argument_list|)
expr_stmt|;
name|supportedGenericUDFs
operator|.
name|add
argument_list|(
name|UDFMonth
operator|.
name|class
argument_list|)
expr_stmt|;
name|supportedGenericUDFs
operator|.
name|add
argument_list|(
name|UDFDayOfMonth
operator|.
name|class
argument_list|)
expr_stmt|;
name|supportedGenericUDFs
operator|.
name|add
argument_list|(
name|UDFHour
operator|.
name|class
argument_list|)
expr_stmt|;
name|supportedGenericUDFs
operator|.
name|add
argument_list|(
name|UDFMinute
operator|.
name|class
argument_list|)
expr_stmt|;
name|supportedGenericUDFs
operator|.
name|add
argument_list|(
name|UDFSecond
operator|.
name|class
argument_list|)
expr_stmt|;
name|supportedGenericUDFs
operator|.
name|add
argument_list|(
name|UDFWeekOfYear
operator|.
name|class
argument_list|)
expr_stmt|;
name|supportedGenericUDFs
operator|.
name|add
argument_list|(
name|GenericUDFToUnixTimeStamp
operator|.
name|class
argument_list|)
expr_stmt|;
name|supportedGenericUDFs
operator|.
name|add
argument_list|(
name|GenericUDFDateAdd
operator|.
name|class
argument_list|)
expr_stmt|;
name|supportedGenericUDFs
operator|.
name|add
argument_list|(
name|GenericUDFDateSub
operator|.
name|class
argument_list|)
expr_stmt|;
name|supportedGenericUDFs
operator|.
name|add
argument_list|(
name|GenericUDFDate
operator|.
name|class
argument_list|)
expr_stmt|;
name|supportedGenericUDFs
operator|.
name|add
argument_list|(
name|GenericUDFDateDiff
operator|.
name|class
argument_list|)
expr_stmt|;
name|supportedGenericUDFs
operator|.
name|add
argument_list|(
name|UDFLike
operator|.
name|class
argument_list|)
expr_stmt|;
name|supportedGenericUDFs
operator|.
name|add
argument_list|(
name|UDFRegExp
operator|.
name|class
argument_list|)
expr_stmt|;
name|supportedGenericUDFs
operator|.
name|add
argument_list|(
name|UDFSubstr
operator|.
name|class
argument_list|)
expr_stmt|;
name|supportedGenericUDFs
operator|.
name|add
argument_list|(
name|GenericUDFLTrim
operator|.
name|class
argument_list|)
expr_stmt|;
name|supportedGenericUDFs
operator|.
name|add
argument_list|(
name|GenericUDFRTrim
operator|.
name|class
argument_list|)
expr_stmt|;
name|supportedGenericUDFs
operator|.
name|add
argument_list|(
name|GenericUDFTrim
operator|.
name|class
argument_list|)
expr_stmt|;
name|supportedGenericUDFs
operator|.
name|add
argument_list|(
name|UDFSin
operator|.
name|class
argument_list|)
expr_stmt|;
name|supportedGenericUDFs
operator|.
name|add
argument_list|(
name|UDFCos
operator|.
name|class
argument_list|)
expr_stmt|;
name|supportedGenericUDFs
operator|.
name|add
argument_list|(
name|UDFTan
operator|.
name|class
argument_list|)
expr_stmt|;
name|supportedGenericUDFs
operator|.
name|add
argument_list|(
name|UDFAsin
operator|.
name|class
argument_list|)
expr_stmt|;
name|supportedGenericUDFs
operator|.
name|add
argument_list|(
name|UDFAcos
operator|.
name|class
argument_list|)
expr_stmt|;
name|supportedGenericUDFs
operator|.
name|add
argument_list|(
name|UDFAtan
operator|.
name|class
argument_list|)
expr_stmt|;
name|supportedGenericUDFs
operator|.
name|add
argument_list|(
name|UDFDegrees
operator|.
name|class
argument_list|)
expr_stmt|;
name|supportedGenericUDFs
operator|.
name|add
argument_list|(
name|UDFRadians
operator|.
name|class
argument_list|)
expr_stmt|;
name|supportedGenericUDFs
operator|.
name|add
argument_list|(
name|GenericUDFFloor
operator|.
name|class
argument_list|)
expr_stmt|;
name|supportedGenericUDFs
operator|.
name|add
argument_list|(
name|GenericUDFCeil
operator|.
name|class
argument_list|)
expr_stmt|;
name|supportedGenericUDFs
operator|.
name|add
argument_list|(
name|UDFExp
operator|.
name|class
argument_list|)
expr_stmt|;
name|supportedGenericUDFs
operator|.
name|add
argument_list|(
name|UDFLn
operator|.
name|class
argument_list|)
expr_stmt|;
name|supportedGenericUDFs
operator|.
name|add
argument_list|(
name|UDFLog2
operator|.
name|class
argument_list|)
expr_stmt|;
name|supportedGenericUDFs
operator|.
name|add
argument_list|(
name|UDFLog10
operator|.
name|class
argument_list|)
expr_stmt|;
name|supportedGenericUDFs
operator|.
name|add
argument_list|(
name|UDFLog
operator|.
name|class
argument_list|)
expr_stmt|;
name|supportedGenericUDFs
operator|.
name|add
argument_list|(
name|GenericUDFPower
operator|.
name|class
argument_list|)
expr_stmt|;
name|supportedGenericUDFs
operator|.
name|add
argument_list|(
name|GenericUDFRound
operator|.
name|class
argument_list|)
expr_stmt|;
name|supportedGenericUDFs
operator|.
name|add
argument_list|(
name|GenericUDFPosMod
operator|.
name|class
argument_list|)
expr_stmt|;
name|supportedGenericUDFs
operator|.
name|add
argument_list|(
name|UDFSqrt
operator|.
name|class
argument_list|)
expr_stmt|;
name|supportedGenericUDFs
operator|.
name|add
argument_list|(
name|UDFSign
operator|.
name|class
argument_list|)
expr_stmt|;
name|supportedGenericUDFs
operator|.
name|add
argument_list|(
name|UDFRand
operator|.
name|class
argument_list|)
expr_stmt|;
name|supportedGenericUDFs
operator|.
name|add
argument_list|(
name|UDFBin
operator|.
name|class
argument_list|)
expr_stmt|;
name|supportedGenericUDFs
operator|.
name|add
argument_list|(
name|UDFHex
operator|.
name|class
argument_list|)
expr_stmt|;
name|supportedGenericUDFs
operator|.
name|add
argument_list|(
name|UDFConv
operator|.
name|class
argument_list|)
expr_stmt|;
name|supportedGenericUDFs
operator|.
name|add
argument_list|(
name|GenericUDFLower
operator|.
name|class
argument_list|)
expr_stmt|;
name|supportedGenericUDFs
operator|.
name|add
argument_list|(
name|GenericUDFUpper
operator|.
name|class
argument_list|)
expr_stmt|;
name|supportedGenericUDFs
operator|.
name|add
argument_list|(
name|GenericUDFConcat
operator|.
name|class
argument_list|)
expr_stmt|;
name|supportedGenericUDFs
operator|.
name|add
argument_list|(
name|GenericUDFAbs
operator|.
name|class
argument_list|)
expr_stmt|;
name|supportedGenericUDFs
operator|.
name|add
argument_list|(
name|GenericUDFBetween
operator|.
name|class
argument_list|)
expr_stmt|;
name|supportedGenericUDFs
operator|.
name|add
argument_list|(
name|GenericUDFIn
operator|.
name|class
argument_list|)
expr_stmt|;
name|supportedGenericUDFs
operator|.
name|add
argument_list|(
name|GenericUDFCase
operator|.
name|class
argument_list|)
expr_stmt|;
name|supportedGenericUDFs
operator|.
name|add
argument_list|(
name|GenericUDFWhen
operator|.
name|class
argument_list|)
expr_stmt|;
name|supportedGenericUDFs
operator|.
name|add
argument_list|(
name|GenericUDFCoalesce
operator|.
name|class
argument_list|)
expr_stmt|;
name|supportedGenericUDFs
operator|.
name|add
argument_list|(
name|GenericUDFElt
operator|.
name|class
argument_list|)
expr_stmt|;
comment|// For type casts
name|supportedGenericUDFs
operator|.
name|add
argument_list|(
name|UDFToLong
operator|.
name|class
argument_list|)
expr_stmt|;
name|supportedGenericUDFs
operator|.
name|add
argument_list|(
name|UDFToInteger
operator|.
name|class
argument_list|)
expr_stmt|;
name|supportedGenericUDFs
operator|.
name|add
argument_list|(
name|UDFToShort
operator|.
name|class
argument_list|)
expr_stmt|;
name|supportedGenericUDFs
operator|.
name|add
argument_list|(
name|UDFToByte
operator|.
name|class
argument_list|)
expr_stmt|;
name|supportedGenericUDFs
operator|.
name|add
argument_list|(
name|UDFToBoolean
operator|.
name|class
argument_list|)
expr_stmt|;
name|supportedGenericUDFs
operator|.
name|add
argument_list|(
name|UDFToFloat
operator|.
name|class
argument_list|)
expr_stmt|;
name|supportedGenericUDFs
operator|.
name|add
argument_list|(
name|UDFToDouble
operator|.
name|class
argument_list|)
expr_stmt|;
name|supportedGenericUDFs
operator|.
name|add
argument_list|(
name|UDFToString
operator|.
name|class
argument_list|)
expr_stmt|;
name|supportedGenericUDFs
operator|.
name|add
argument_list|(
name|GenericUDFTimestamp
operator|.
name|class
argument_list|)
expr_stmt|;
name|supportedGenericUDFs
operator|.
name|add
argument_list|(
name|GenericUDFToDecimal
operator|.
name|class
argument_list|)
expr_stmt|;
name|supportedGenericUDFs
operator|.
name|add
argument_list|(
name|GenericUDFToDate
operator|.
name|class
argument_list|)
expr_stmt|;
name|supportedGenericUDFs
operator|.
name|add
argument_list|(
name|GenericUDFToChar
operator|.
name|class
argument_list|)
expr_stmt|;
name|supportedGenericUDFs
operator|.
name|add
argument_list|(
name|GenericUDFToVarchar
operator|.
name|class
argument_list|)
expr_stmt|;
comment|// For conditional expressions
name|supportedGenericUDFs
operator|.
name|add
argument_list|(
name|GenericUDFIf
operator|.
name|class
argument_list|)
expr_stmt|;
name|supportedAggregationUdfs
operator|.
name|add
argument_list|(
literal|"min"
argument_list|)
expr_stmt|;
name|supportedAggregationUdfs
operator|.
name|add
argument_list|(
literal|"max"
argument_list|)
expr_stmt|;
name|supportedAggregationUdfs
operator|.
name|add
argument_list|(
literal|"count"
argument_list|)
expr_stmt|;
name|supportedAggregationUdfs
operator|.
name|add
argument_list|(
literal|"sum"
argument_list|)
expr_stmt|;
name|supportedAggregationUdfs
operator|.
name|add
argument_list|(
literal|"avg"
argument_list|)
expr_stmt|;
name|supportedAggregationUdfs
operator|.
name|add
argument_list|(
literal|"variance"
argument_list|)
expr_stmt|;
name|supportedAggregationUdfs
operator|.
name|add
argument_list|(
literal|"var_pop"
argument_list|)
expr_stmt|;
name|supportedAggregationUdfs
operator|.
name|add
argument_list|(
literal|"var_samp"
argument_list|)
expr_stmt|;
name|supportedAggregationUdfs
operator|.
name|add
argument_list|(
literal|"std"
argument_list|)
expr_stmt|;
name|supportedAggregationUdfs
operator|.
name|add
argument_list|(
literal|"stddev"
argument_list|)
expr_stmt|;
name|supportedAggregationUdfs
operator|.
name|add
argument_list|(
literal|"stddev_pop"
argument_list|)
expr_stmt|;
name|supportedAggregationUdfs
operator|.
name|add
argument_list|(
literal|"stddev_samp"
argument_list|)
expr_stmt|;
block|}
class|class
name|VectorizationDispatcher
implements|implements
name|Dispatcher
block|{
specifier|private
name|PhysicalContext
name|pctx
decl_stmt|;
specifier|private
name|List
argument_list|<
name|String
argument_list|>
name|reduceColumnNames
decl_stmt|;
specifier|private
name|List
argument_list|<
name|TypeInfo
argument_list|>
name|reduceTypeInfos
decl_stmt|;
specifier|public
name|VectorizationDispatcher
parameter_list|(
name|PhysicalContext
name|pctx
parameter_list|)
block|{
name|this
operator|.
name|pctx
operator|=
name|pctx
expr_stmt|;
name|reduceColumnNames
operator|=
literal|null
expr_stmt|;
name|reduceTypeInfos
operator|=
literal|null
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|Object
name|dispatch
parameter_list|(
name|Node
name|nd
parameter_list|,
name|Stack
argument_list|<
name|Node
argument_list|>
name|stack
parameter_list|,
name|Object
modifier|...
name|nodeOutputs
parameter_list|)
throws|throws
name|SemanticException
block|{
name|Task
argument_list|<
name|?
extends|extends
name|Serializable
argument_list|>
name|currTask
init|=
operator|(
name|Task
argument_list|<
name|?
extends|extends
name|Serializable
argument_list|>
operator|)
name|nd
decl_stmt|;
if|if
condition|(
name|currTask
operator|instanceof
name|MapRedTask
condition|)
block|{
name|convertMapWork
argument_list|(
operator|(
operator|(
name|MapRedTask
operator|)
name|currTask
operator|)
operator|.
name|getWork
argument_list|()
operator|.
name|getMapWork
argument_list|()
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|currTask
operator|instanceof
name|TezTask
condition|)
block|{
name|TezWork
name|work
init|=
operator|(
operator|(
name|TezTask
operator|)
name|currTask
operator|)
operator|.
name|getWork
argument_list|()
decl_stmt|;
for|for
control|(
name|BaseWork
name|w
range|:
name|work
operator|.
name|getAllWork
argument_list|()
control|)
block|{
if|if
condition|(
name|w
operator|instanceof
name|MapWork
condition|)
block|{
name|convertMapWork
argument_list|(
operator|(
name|MapWork
operator|)
name|w
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|w
operator|instanceof
name|ReduceWork
condition|)
block|{
comment|// We are only vectorizing Reduce under Tez.
if|if
condition|(
name|HiveConf
operator|.
name|getBoolVar
argument_list|(
name|pctx
operator|.
name|getConf
argument_list|()
argument_list|,
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVE_VECTORIZATION_REDUCE_ENABLED
argument_list|)
condition|)
block|{
name|convertReduceWork
argument_list|(
operator|(
name|ReduceWork
operator|)
name|w
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
return|return
literal|null
return|;
block|}
specifier|private
name|void
name|convertMapWork
parameter_list|(
name|MapWork
name|mapWork
parameter_list|,
name|boolean
name|isTez
parameter_list|)
throws|throws
name|SemanticException
block|{
name|boolean
name|ret
init|=
name|validateMapWork
argument_list|(
name|mapWork
argument_list|,
name|isTez
argument_list|)
decl_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
name|vectorizeMapWork
argument_list|(
name|mapWork
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|addMapWorkRules
parameter_list|(
name|Map
argument_list|<
name|Rule
argument_list|,
name|NodeProcessor
argument_list|>
name|opRules
parameter_list|,
name|NodeProcessor
name|np
parameter_list|)
block|{
name|opRules
operator|.
name|put
argument_list|(
operator|new
name|RuleRegExp
argument_list|(
literal|"R1"
argument_list|,
name|TableScanOperator
operator|.
name|getOperatorName
argument_list|()
operator|+
literal|".*"
operator|+
name|FileSinkOperator
operator|.
name|getOperatorName
argument_list|()
argument_list|)
argument_list|,
name|np
argument_list|)
expr_stmt|;
name|opRules
operator|.
name|put
argument_list|(
operator|new
name|RuleRegExp
argument_list|(
literal|"R2"
argument_list|,
name|TableScanOperator
operator|.
name|getOperatorName
argument_list|()
operator|+
literal|".*"
operator|+
name|ReduceSinkOperator
operator|.
name|getOperatorName
argument_list|()
argument_list|)
argument_list|,
name|np
argument_list|)
expr_stmt|;
block|}
specifier|private
name|boolean
name|validateMapWork
parameter_list|(
name|MapWork
name|mapWork
parameter_list|,
name|boolean
name|isTez
parameter_list|)
throws|throws
name|SemanticException
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Validating MapWork..."
argument_list|)
expr_stmt|;
comment|// Validate the input format
for|for
control|(
name|String
name|path
range|:
name|mapWork
operator|.
name|getPathToPartitionInfo
argument_list|()
operator|.
name|keySet
argument_list|()
control|)
block|{
name|PartitionDesc
name|pd
init|=
name|mapWork
operator|.
name|getPathToPartitionInfo
argument_list|()
operator|.
name|get
argument_list|(
name|path
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|Class
argument_list|<
name|?
argument_list|>
argument_list|>
name|interfaceList
init|=
name|Arrays
operator|.
name|asList
argument_list|(
name|pd
operator|.
name|getInputFileFormatClass
argument_list|()
operator|.
name|getInterfaces
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|interfaceList
operator|.
name|contains
argument_list|(
name|VectorizedInputFormatInterface
operator|.
name|class
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Input format: "
operator|+
name|pd
operator|.
name|getInputFileFormatClassName
argument_list|()
operator|+
literal|", doesn't provide vectorized input"
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
name|Map
argument_list|<
name|Rule
argument_list|,
name|NodeProcessor
argument_list|>
name|opRules
init|=
operator|new
name|LinkedHashMap
argument_list|<
name|Rule
argument_list|,
name|NodeProcessor
argument_list|>
argument_list|()
decl_stmt|;
name|MapWorkValidationNodeProcessor
name|vnp
init|=
operator|new
name|MapWorkValidationNodeProcessor
argument_list|(
name|mapWork
argument_list|,
name|isTez
argument_list|)
decl_stmt|;
name|addMapWorkRules
argument_list|(
name|opRules
argument_list|,
name|vnp
argument_list|)
expr_stmt|;
name|Dispatcher
name|disp
init|=
operator|new
name|DefaultRuleDispatcher
argument_list|(
name|vnp
argument_list|,
name|opRules
argument_list|,
literal|null
argument_list|)
decl_stmt|;
name|GraphWalker
name|ogw
init|=
operator|new
name|DefaultGraphWalker
argument_list|(
name|disp
argument_list|)
decl_stmt|;
comment|// iterator the mapper operator tree
name|ArrayList
argument_list|<
name|Node
argument_list|>
name|topNodes
init|=
operator|new
name|ArrayList
argument_list|<
name|Node
argument_list|>
argument_list|()
decl_stmt|;
name|topNodes
operator|.
name|addAll
argument_list|(
name|mapWork
operator|.
name|getAliasToWork
argument_list|()
operator|.
name|values
argument_list|()
argument_list|)
expr_stmt|;
name|HashMap
argument_list|<
name|Node
argument_list|,
name|Object
argument_list|>
name|nodeOutput
init|=
operator|new
name|HashMap
argument_list|<
name|Node
argument_list|,
name|Object
argument_list|>
argument_list|()
decl_stmt|;
name|ogw
operator|.
name|startWalking
argument_list|(
name|topNodes
argument_list|,
name|nodeOutput
argument_list|)
expr_stmt|;
for|for
control|(
name|Node
name|n
range|:
name|nodeOutput
operator|.
name|keySet
argument_list|()
control|)
block|{
if|if
condition|(
name|nodeOutput
operator|.
name|get
argument_list|(
name|n
argument_list|)
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|Boolean
operator|)
name|nodeOutput
operator|.
name|get
argument_list|(
name|n
argument_list|)
operator|)
operator|.
name|booleanValue
argument_list|()
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
block|}
return|return
literal|true
return|;
block|}
specifier|private
name|void
name|vectorizeMapWork
parameter_list|(
name|MapWork
name|mapWork
parameter_list|)
throws|throws
name|SemanticException
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Vectorizing MapWork..."
argument_list|)
expr_stmt|;
name|mapWork
operator|.
name|setVectorMode
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|Map
argument_list|<
name|Rule
argument_list|,
name|NodeProcessor
argument_list|>
name|opRules
init|=
operator|new
name|LinkedHashMap
argument_list|<
name|Rule
argument_list|,
name|NodeProcessor
argument_list|>
argument_list|()
decl_stmt|;
name|MapWorkVectorizationNodeProcessor
name|vnp
init|=
operator|new
name|MapWorkVectorizationNodeProcessor
argument_list|(
name|mapWork
argument_list|)
decl_stmt|;
name|addMapWorkRules
argument_list|(
name|opRules
argument_list|,
name|vnp
argument_list|)
expr_stmt|;
name|Dispatcher
name|disp
init|=
operator|new
name|DefaultRuleDispatcher
argument_list|(
name|vnp
argument_list|,
name|opRules
argument_list|,
literal|null
argument_list|)
decl_stmt|;
name|GraphWalker
name|ogw
init|=
operator|new
name|PreOrderWalker
argument_list|(
name|disp
argument_list|)
decl_stmt|;
comment|// iterator the mapper operator tree
name|ArrayList
argument_list|<
name|Node
argument_list|>
name|topNodes
init|=
operator|new
name|ArrayList
argument_list|<
name|Node
argument_list|>
argument_list|()
decl_stmt|;
name|topNodes
operator|.
name|addAll
argument_list|(
name|mapWork
operator|.
name|getAliasToWork
argument_list|()
operator|.
name|values
argument_list|()
argument_list|)
expr_stmt|;
name|HashMap
argument_list|<
name|Node
argument_list|,
name|Object
argument_list|>
name|nodeOutput
init|=
operator|new
name|HashMap
argument_list|<
name|Node
argument_list|,
name|Object
argument_list|>
argument_list|()
decl_stmt|;
name|ogw
operator|.
name|startWalking
argument_list|(
name|topNodes
argument_list|,
name|nodeOutput
argument_list|)
expr_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|Map
argument_list|<
name|Integer
argument_list|,
name|String
argument_list|>
argument_list|>
name|allScratchColumnVectorTypeMaps
init|=
name|vnp
operator|.
name|getAllScratchColumnVectorTypeMaps
argument_list|()
decl_stmt|;
name|mapWork
operator|.
name|setAllScratchColumnVectorTypeMaps
argument_list|(
name|allScratchColumnVectorTypeMaps
argument_list|)
expr_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|Integer
argument_list|>
argument_list|>
name|allColumnVectorMaps
init|=
name|vnp
operator|.
name|getAllColumnVectorMaps
argument_list|()
decl_stmt|;
name|mapWork
operator|.
name|setAllColumnVectorMaps
argument_list|(
name|allColumnVectorMaps
argument_list|)
expr_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|debugDisplayAllMaps
argument_list|(
name|allColumnVectorMaps
argument_list|,
name|allScratchColumnVectorTypeMaps
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
specifier|private
name|void
name|convertReduceWork
parameter_list|(
name|ReduceWork
name|reduceWork
parameter_list|)
throws|throws
name|SemanticException
block|{
name|boolean
name|ret
init|=
name|validateReduceWork
argument_list|(
name|reduceWork
argument_list|)
decl_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
name|vectorizeReduceWork
argument_list|(
name|reduceWork
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
name|boolean
name|getOnlyStructObjectInspectors
parameter_list|(
name|ReduceWork
name|reduceWork
parameter_list|)
throws|throws
name|SemanticException
block|{
try|try
block|{
comment|// Check key ObjectInspector.
name|ObjectInspector
name|keyObjectInspector
init|=
name|reduceWork
operator|.
name|getKeyObjectInspector
argument_list|()
decl_stmt|;
if|if
condition|(
name|keyObjectInspector
operator|==
literal|null
operator|||
operator|!
operator|(
name|keyObjectInspector
operator|instanceof
name|StructObjectInspector
operator|)
condition|)
block|{
return|return
literal|false
return|;
block|}
name|StructObjectInspector
name|keyStructObjectInspector
init|=
operator|(
name|StructObjectInspector
operator|)
name|keyObjectInspector
decl_stmt|;
name|List
argument_list|<
name|?
extends|extends
name|StructField
argument_list|>
name|keyFields
init|=
name|keyStructObjectInspector
operator|.
name|getAllStructFieldRefs
argument_list|()
decl_stmt|;
comment|// Tez doesn't use tagging...
if|if
condition|(
name|reduceWork
operator|.
name|getNeedsTagging
argument_list|()
condition|)
block|{
return|return
literal|false
return|;
block|}
comment|// Check value ObjectInspector.
name|ObjectInspector
name|valueObjectInspector
init|=
name|reduceWork
operator|.
name|getValueObjectInspector
argument_list|()
decl_stmt|;
if|if
condition|(
name|valueObjectInspector
operator|==
literal|null
operator|||
operator|!
operator|(
name|valueObjectInspector
operator|instanceof
name|StructObjectInspector
operator|)
condition|)
block|{
return|return
literal|false
return|;
block|}
name|StructObjectInspector
name|valueStructObjectInspector
init|=
operator|(
name|StructObjectInspector
operator|)
name|valueObjectInspector
decl_stmt|;
name|List
argument_list|<
name|?
extends|extends
name|StructField
argument_list|>
name|valueFields
init|=
name|valueStructObjectInspector
operator|.
name|getAllStructFieldRefs
argument_list|()
decl_stmt|;
name|reduceColumnNames
operator|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
expr_stmt|;
name|reduceTypeInfos
operator|=
operator|new
name|ArrayList
argument_list|<
name|TypeInfo
argument_list|>
argument_list|()
expr_stmt|;
for|for
control|(
name|StructField
name|field
range|:
name|keyFields
control|)
block|{
name|reduceColumnNames
operator|.
name|add
argument_list|(
name|Utilities
operator|.
name|ReduceField
operator|.
name|KEY
operator|.
name|toString
argument_list|()
operator|+
literal|"."
operator|+
name|field
operator|.
name|getFieldName
argument_list|()
argument_list|)
expr_stmt|;
name|reduceTypeInfos
operator|.
name|add
argument_list|(
name|TypeInfoUtils
operator|.
name|getTypeInfoFromTypeString
argument_list|(
name|field
operator|.
name|getFieldObjectInspector
argument_list|()
operator|.
name|getTypeName
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|StructField
name|field
range|:
name|valueFields
control|)
block|{
name|reduceColumnNames
operator|.
name|add
argument_list|(
name|Utilities
operator|.
name|ReduceField
operator|.
name|VALUE
operator|.
name|toString
argument_list|()
operator|+
literal|"."
operator|+
name|field
operator|.
name|getFieldName
argument_list|()
argument_list|)
expr_stmt|;
name|reduceTypeInfos
operator|.
name|add
argument_list|(
name|TypeInfoUtils
operator|.
name|getTypeInfoFromTypeString
argument_list|(
name|field
operator|.
name|getFieldObjectInspector
argument_list|()
operator|.
name|getTypeName
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|e
argument_list|)
throw|;
block|}
return|return
literal|true
return|;
block|}
specifier|private
name|void
name|addReduceWorkRules
parameter_list|(
name|Map
argument_list|<
name|Rule
argument_list|,
name|NodeProcessor
argument_list|>
name|opRules
parameter_list|,
name|NodeProcessor
name|np
parameter_list|)
block|{
name|opRules
operator|.
name|put
argument_list|(
operator|new
name|RuleRegExp
argument_list|(
literal|"R1"
argument_list|,
name|ExtractOperator
operator|.
name|getOperatorName
argument_list|()
operator|+
literal|".*"
argument_list|)
argument_list|,
name|np
argument_list|)
expr_stmt|;
name|opRules
operator|.
name|put
argument_list|(
operator|new
name|RuleRegExp
argument_list|(
literal|"R2"
argument_list|,
name|GroupByOperator
operator|.
name|getOperatorName
argument_list|()
operator|+
literal|".*"
argument_list|)
argument_list|,
name|np
argument_list|)
expr_stmt|;
name|opRules
operator|.
name|put
argument_list|(
operator|new
name|RuleRegExp
argument_list|(
literal|"R3"
argument_list|,
name|SelectOperator
operator|.
name|getOperatorName
argument_list|()
operator|+
literal|".*"
argument_list|)
argument_list|,
name|np
argument_list|)
expr_stmt|;
block|}
specifier|private
name|boolean
name|validateReduceWork
parameter_list|(
name|ReduceWork
name|reduceWork
parameter_list|)
throws|throws
name|SemanticException
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Validating ReduceWork..."
argument_list|)
expr_stmt|;
comment|// Validate input to ReduceWork.
if|if
condition|(
operator|!
name|getOnlyStructObjectInspectors
argument_list|(
name|reduceWork
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
comment|// Now check the reduce operator tree.
name|Map
argument_list|<
name|Rule
argument_list|,
name|NodeProcessor
argument_list|>
name|opRules
init|=
operator|new
name|LinkedHashMap
argument_list|<
name|Rule
argument_list|,
name|NodeProcessor
argument_list|>
argument_list|()
decl_stmt|;
name|ReduceWorkValidationNodeProcessor
name|vnp
init|=
operator|new
name|ReduceWorkValidationNodeProcessor
argument_list|()
decl_stmt|;
name|addReduceWorkRules
argument_list|(
name|opRules
argument_list|,
name|vnp
argument_list|)
expr_stmt|;
name|Dispatcher
name|disp
init|=
operator|new
name|DefaultRuleDispatcher
argument_list|(
name|vnp
argument_list|,
name|opRules
argument_list|,
literal|null
argument_list|)
decl_stmt|;
name|GraphWalker
name|ogw
init|=
operator|new
name|DefaultGraphWalker
argument_list|(
name|disp
argument_list|)
decl_stmt|;
comment|// iterator the reduce operator tree
name|ArrayList
argument_list|<
name|Node
argument_list|>
name|topNodes
init|=
operator|new
name|ArrayList
argument_list|<
name|Node
argument_list|>
argument_list|()
decl_stmt|;
name|topNodes
operator|.
name|add
argument_list|(
name|reduceWork
operator|.
name|getReducer
argument_list|()
argument_list|)
expr_stmt|;
name|HashMap
argument_list|<
name|Node
argument_list|,
name|Object
argument_list|>
name|nodeOutput
init|=
operator|new
name|HashMap
argument_list|<
name|Node
argument_list|,
name|Object
argument_list|>
argument_list|()
decl_stmt|;
name|ogw
operator|.
name|startWalking
argument_list|(
name|topNodes
argument_list|,
name|nodeOutput
argument_list|)
expr_stmt|;
for|for
control|(
name|Node
name|n
range|:
name|nodeOutput
operator|.
name|keySet
argument_list|()
control|)
block|{
if|if
condition|(
name|nodeOutput
operator|.
name|get
argument_list|(
name|n
argument_list|)
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|Boolean
operator|)
name|nodeOutput
operator|.
name|get
argument_list|(
name|n
argument_list|)
operator|)
operator|.
name|booleanValue
argument_list|()
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
block|}
return|return
literal|true
return|;
block|}
specifier|private
name|void
name|vectorizeReduceWork
parameter_list|(
name|ReduceWork
name|reduceWork
parameter_list|)
throws|throws
name|SemanticException
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Vectorizing ReduceWork..."
argument_list|)
expr_stmt|;
name|reduceWork
operator|.
name|setVectorMode
argument_list|(
literal|true
argument_list|)
expr_stmt|;
comment|// For some reason, the DefaultGraphWalker does not descend down from the reducer Operator as
comment|// expected.  We need to descend down, otherwise it breaks our algorithm that determines
comment|// VectorizationContext...  Do we use PreOrderWalker instead of DefaultGraphWalker.
name|Map
argument_list|<
name|Rule
argument_list|,
name|NodeProcessor
argument_list|>
name|opRules
init|=
operator|new
name|LinkedHashMap
argument_list|<
name|Rule
argument_list|,
name|NodeProcessor
argument_list|>
argument_list|()
decl_stmt|;
name|ReduceWorkVectorizationNodeProcessor
name|vnp
init|=
operator|new
name|ReduceWorkVectorizationNodeProcessor
argument_list|(
name|reduceColumnNames
argument_list|)
decl_stmt|;
name|addReduceWorkRules
argument_list|(
name|opRules
argument_list|,
name|vnp
argument_list|)
expr_stmt|;
name|Dispatcher
name|disp
init|=
operator|new
name|DefaultRuleDispatcher
argument_list|(
name|vnp
argument_list|,
name|opRules
argument_list|,
literal|null
argument_list|)
decl_stmt|;
name|GraphWalker
name|ogw
init|=
operator|new
name|PreOrderWalker
argument_list|(
name|disp
argument_list|)
decl_stmt|;
comment|// iterator the reduce operator tree
name|ArrayList
argument_list|<
name|Node
argument_list|>
name|topNodes
init|=
operator|new
name|ArrayList
argument_list|<
name|Node
argument_list|>
argument_list|()
decl_stmt|;
name|topNodes
operator|.
name|add
argument_list|(
name|reduceWork
operator|.
name|getReducer
argument_list|()
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"vectorizeReduceWork reducer Operator: "
operator|+
name|reduceWork
operator|.
name|getReducer
argument_list|()
operator|.
name|getName
argument_list|()
operator|+
literal|"..."
argument_list|)
expr_stmt|;
name|HashMap
argument_list|<
name|Node
argument_list|,
name|Object
argument_list|>
name|nodeOutput
init|=
operator|new
name|HashMap
argument_list|<
name|Node
argument_list|,
name|Object
argument_list|>
argument_list|()
decl_stmt|;
name|ogw
operator|.
name|startWalking
argument_list|(
name|topNodes
argument_list|,
name|nodeOutput
argument_list|)
expr_stmt|;
comment|// Necessary since we are vectorizing the root operator in reduce.
name|reduceWork
operator|.
name|setReducer
argument_list|(
name|vnp
operator|.
name|getRootVectorOp
argument_list|()
argument_list|)
expr_stmt|;
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
name|reducer
init|=
name|reduceWork
operator|.
name|getReducer
argument_list|()
decl_stmt|;
if|if
condition|(
name|reducer
operator|.
name|getType
argument_list|()
operator|.
name|equals
argument_list|(
name|OperatorType
operator|.
name|EXTRACT
argument_list|)
condition|)
block|{
operator|(
operator|(
name|VectorExtractOperator
operator|)
name|reducer
operator|)
operator|.
name|setReduceTypeInfos
argument_list|(
name|reduceTypeInfos
argument_list|)
expr_stmt|;
block|}
name|Map
argument_list|<
name|String
argument_list|,
name|Map
argument_list|<
name|Integer
argument_list|,
name|String
argument_list|>
argument_list|>
name|allScratchColumnVectorTypeMaps
init|=
name|vnp
operator|.
name|getAllScratchColumnVectorTypeMaps
argument_list|()
decl_stmt|;
name|reduceWork
operator|.
name|setAllScratchColumnVectorTypeMaps
argument_list|(
name|allScratchColumnVectorTypeMaps
argument_list|)
expr_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|Integer
argument_list|>
argument_list|>
name|allColumnVectorMaps
init|=
name|vnp
operator|.
name|getAllColumnVectorMaps
argument_list|()
decl_stmt|;
name|reduceWork
operator|.
name|setAllColumnVectorMaps
argument_list|(
name|allColumnVectorMaps
argument_list|)
expr_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|debugDisplayAllMaps
argument_list|(
name|allColumnVectorMaps
argument_list|,
name|allScratchColumnVectorTypeMaps
argument_list|)
expr_stmt|;
block|}
block|}
block|}
class|class
name|MapWorkValidationNodeProcessor
implements|implements
name|NodeProcessor
block|{
specifier|private
name|MapWork
name|mapWork
decl_stmt|;
specifier|private
name|boolean
name|isTez
decl_stmt|;
specifier|public
name|MapWorkValidationNodeProcessor
parameter_list|(
name|MapWork
name|mapWork
parameter_list|,
name|boolean
name|isTez
parameter_list|)
block|{
name|this
operator|.
name|mapWork
operator|=
name|mapWork
expr_stmt|;
name|this
operator|.
name|isTez
operator|=
name|isTez
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|Object
name|process
parameter_list|(
name|Node
name|nd
parameter_list|,
name|Stack
argument_list|<
name|Node
argument_list|>
name|stack
parameter_list|,
name|NodeProcessorCtx
name|procCtx
parameter_list|,
name|Object
modifier|...
name|nodeOutputs
parameter_list|)
throws|throws
name|SemanticException
block|{
for|for
control|(
name|Node
name|n
range|:
name|stack
control|)
block|{
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
name|op
init|=
operator|(
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
operator|)
name|n
decl_stmt|;
if|if
condition|(
name|nonVectorizableChildOfGroupBy
argument_list|(
name|op
argument_list|)
condition|)
block|{
return|return
operator|new
name|Boolean
argument_list|(
literal|true
argument_list|)
return|;
block|}
name|boolean
name|ret
init|=
name|validateMapWorkOperator
argument_list|(
name|op
argument_list|,
name|mapWork
argument_list|,
name|isTez
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|ret
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"MapWork Operator: "
operator|+
name|op
operator|.
name|getName
argument_list|()
operator|+
literal|" could not be vectorized."
argument_list|)
expr_stmt|;
return|return
operator|new
name|Boolean
argument_list|(
literal|false
argument_list|)
return|;
block|}
block|}
return|return
operator|new
name|Boolean
argument_list|(
literal|true
argument_list|)
return|;
block|}
block|}
class|class
name|ReduceWorkValidationNodeProcessor
implements|implements
name|NodeProcessor
block|{
annotation|@
name|Override
specifier|public
name|Object
name|process
parameter_list|(
name|Node
name|nd
parameter_list|,
name|Stack
argument_list|<
name|Node
argument_list|>
name|stack
parameter_list|,
name|NodeProcessorCtx
name|procCtx
parameter_list|,
name|Object
modifier|...
name|nodeOutputs
parameter_list|)
throws|throws
name|SemanticException
block|{
for|for
control|(
name|Node
name|n
range|:
name|stack
control|)
block|{
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
name|op
init|=
operator|(
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
operator|)
name|n
decl_stmt|;
if|if
condition|(
name|nonVectorizableChildOfGroupBy
argument_list|(
name|op
argument_list|)
condition|)
block|{
return|return
operator|new
name|Boolean
argument_list|(
literal|true
argument_list|)
return|;
block|}
name|boolean
name|ret
init|=
name|validateReduceWorkOperator
argument_list|(
name|op
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|ret
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"ReduceWork Operator: "
operator|+
name|op
operator|.
name|getName
argument_list|()
operator|+
literal|" could not be vectorized."
argument_list|)
expr_stmt|;
return|return
operator|new
name|Boolean
argument_list|(
literal|false
argument_list|)
return|;
block|}
block|}
return|return
operator|new
name|Boolean
argument_list|(
literal|true
argument_list|)
return|;
block|}
block|}
comment|// This class has common code used by both MapWorkVectorizationNodeProcessor and
comment|// ReduceWorkVectorizationNodeProcessor.
class|class
name|VectorizationNodeProcessor
implements|implements
name|NodeProcessor
block|{
comment|// This is used to extract scratch column types for each file key
specifier|protected
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|VectorizationContext
argument_list|>
name|scratchColumnContext
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|VectorizationContext
argument_list|>
argument_list|()
decl_stmt|;
specifier|protected
specifier|final
name|Map
argument_list|<
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
argument_list|,
name|VectorizationContext
argument_list|>
name|vContextsByOp
init|=
operator|new
name|HashMap
argument_list|<
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
argument_list|,
name|VectorizationContext
argument_list|>
argument_list|()
decl_stmt|;
specifier|protected
specifier|final
name|Set
argument_list|<
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
argument_list|>
name|opsDone
init|=
operator|new
name|HashSet
argument_list|<
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
argument_list|>
argument_list|()
decl_stmt|;
specifier|public
name|Map
argument_list|<
name|String
argument_list|,
name|Map
argument_list|<
name|Integer
argument_list|,
name|String
argument_list|>
argument_list|>
name|getAllScratchColumnVectorTypeMaps
parameter_list|()
block|{
name|Map
argument_list|<
name|String
argument_list|,
name|Map
argument_list|<
name|Integer
argument_list|,
name|String
argument_list|>
argument_list|>
name|allScratchColumnVectorTypeMaps
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|Map
argument_list|<
name|Integer
argument_list|,
name|String
argument_list|>
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|String
name|onefile
range|:
name|scratchColumnContext
operator|.
name|keySet
argument_list|()
control|)
block|{
name|VectorizationContext
name|vc
init|=
name|scratchColumnContext
operator|.
name|get
argument_list|(
name|onefile
argument_list|)
decl_stmt|;
name|Map
argument_list|<
name|Integer
argument_list|,
name|String
argument_list|>
name|cmap
init|=
name|vc
operator|.
name|getScratchColumnTypeMap
argument_list|()
decl_stmt|;
name|allScratchColumnVectorTypeMaps
operator|.
name|put
argument_list|(
name|onefile
argument_list|,
name|cmap
argument_list|)
expr_stmt|;
block|}
return|return
name|allScratchColumnVectorTypeMaps
return|;
block|}
specifier|public
name|Map
argument_list|<
name|String
argument_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|Integer
argument_list|>
argument_list|>
name|getAllColumnVectorMaps
parameter_list|()
block|{
name|Map
argument_list|<
name|String
argument_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|Integer
argument_list|>
argument_list|>
name|allColumnVectorMaps
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|Integer
argument_list|>
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|String
name|oneFile
range|:
name|scratchColumnContext
operator|.
name|keySet
argument_list|()
control|)
block|{
name|VectorizationContext
name|vc
init|=
name|scratchColumnContext
operator|.
name|get
argument_list|(
name|oneFile
argument_list|)
decl_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|Integer
argument_list|>
name|cmap
init|=
name|vc
operator|.
name|getProjectionColumnMap
argument_list|()
decl_stmt|;
name|allColumnVectorMaps
operator|.
name|put
argument_list|(
name|oneFile
argument_list|,
name|cmap
argument_list|)
expr_stmt|;
block|}
return|return
name|allColumnVectorMaps
return|;
block|}
specifier|public
name|VectorizationContext
name|walkStackToFindVectorizationContext
parameter_list|(
name|Stack
argument_list|<
name|Node
argument_list|>
name|stack
parameter_list|,
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
name|op
parameter_list|)
throws|throws
name|SemanticException
block|{
name|VectorizationContext
name|vContext
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|stack
operator|.
name|size
argument_list|()
operator|<=
literal|1
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"Expected operator stack for operator %s to have at least 2 operators"
argument_list|,
name|op
operator|.
name|getName
argument_list|()
argument_list|)
argument_list|)
throw|;
block|}
comment|// Walk down the stack of operators until we found one willing to give us a context.
comment|// At the bottom will be the root operator, guaranteed to have a context
name|int
name|i
init|=
name|stack
operator|.
name|size
argument_list|()
operator|-
literal|2
decl_stmt|;
while|while
condition|(
name|vContext
operator|==
literal|null
condition|)
block|{
if|if
condition|(
name|i
operator|<
literal|0
condition|)
block|{
return|return
literal|null
return|;
block|}
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
name|opParent
init|=
operator|(
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
operator|)
name|stack
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|vContext
operator|=
name|vContextsByOp
operator|.
name|get
argument_list|(
name|opParent
argument_list|)
expr_stmt|;
operator|--
name|i
expr_stmt|;
block|}
return|return
name|vContext
return|;
block|}
specifier|public
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
name|doVectorize
parameter_list|(
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
name|op
parameter_list|,
name|VectorizationContext
name|vContext
parameter_list|)
throws|throws
name|SemanticException
block|{
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
name|vectorOp
init|=
name|op
decl_stmt|;
try|try
block|{
if|if
condition|(
operator|!
name|opsDone
operator|.
name|contains
argument_list|(
name|op
argument_list|)
condition|)
block|{
name|vectorOp
operator|=
name|vectorizeOperator
argument_list|(
name|op
argument_list|,
name|vContext
argument_list|)
expr_stmt|;
name|opsDone
operator|.
name|add
argument_list|(
name|op
argument_list|)
expr_stmt|;
if|if
condition|(
name|vectorOp
operator|!=
name|op
condition|)
block|{
name|opsDone
operator|.
name|add
argument_list|(
name|vectorOp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|vectorOp
operator|instanceof
name|VectorizationContextRegion
condition|)
block|{
name|VectorizationContextRegion
name|vcRegion
init|=
operator|(
name|VectorizationContextRegion
operator|)
name|vectorOp
decl_stmt|;
name|VectorizationContext
name|vOutContext
init|=
name|vcRegion
operator|.
name|getOuputVectorizationContext
argument_list|()
decl_stmt|;
name|vContextsByOp
operator|.
name|put
argument_list|(
name|op
argument_list|,
name|vOutContext
argument_list|)
expr_stmt|;
name|scratchColumnContext
operator|.
name|put
argument_list|(
name|vOutContext
operator|.
name|getFileKey
argument_list|()
argument_list|,
name|vOutContext
argument_list|)
expr_stmt|;
block|}
block|}
block|}
catch|catch
parameter_list|(
name|HiveException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|e
argument_list|)
throw|;
block|}
return|return
name|vectorOp
return|;
block|}
annotation|@
name|Override
specifier|public
name|Object
name|process
parameter_list|(
name|Node
name|nd
parameter_list|,
name|Stack
argument_list|<
name|Node
argument_list|>
name|stack
parameter_list|,
name|NodeProcessorCtx
name|procCtx
parameter_list|,
name|Object
modifier|...
name|nodeOutputs
parameter_list|)
throws|throws
name|SemanticException
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
literal|"Must be overridden"
argument_list|)
throw|;
block|}
block|}
class|class
name|MapWorkVectorizationNodeProcessor
extends|extends
name|VectorizationNodeProcessor
block|{
specifier|private
specifier|final
name|MapWork
name|mWork
decl_stmt|;
specifier|public
name|MapWorkVectorizationNodeProcessor
parameter_list|(
name|MapWork
name|mWork
parameter_list|)
block|{
name|this
operator|.
name|mWork
operator|=
name|mWork
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|Object
name|process
parameter_list|(
name|Node
name|nd
parameter_list|,
name|Stack
argument_list|<
name|Node
argument_list|>
name|stack
parameter_list|,
name|NodeProcessorCtx
name|procCtx
parameter_list|,
name|Object
modifier|...
name|nodeOutputs
parameter_list|)
throws|throws
name|SemanticException
block|{
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
name|op
init|=
operator|(
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
operator|)
name|nd
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"MapWorkVectorizationNodeProcessor processing Operator: "
operator|+
name|op
operator|.
name|getName
argument_list|()
operator|+
literal|"..."
argument_list|)
expr_stmt|;
name|VectorizationContext
name|vContext
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|op
operator|instanceof
name|TableScanOperator
condition|)
block|{
name|vContext
operator|=
name|getVectorizationContext
argument_list|(
name|op
argument_list|,
name|physicalContext
argument_list|)
expr_stmt|;
for|for
control|(
name|String
name|onefile
range|:
name|mWork
operator|.
name|getPathToAliases
argument_list|()
operator|.
name|keySet
argument_list|()
control|)
block|{
name|List
argument_list|<
name|String
argument_list|>
name|aliases
init|=
name|mWork
operator|.
name|getPathToAliases
argument_list|()
operator|.
name|get
argument_list|(
name|onefile
argument_list|)
decl_stmt|;
for|for
control|(
name|String
name|alias
range|:
name|aliases
control|)
block|{
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
name|opRoot
init|=
name|mWork
operator|.
name|getAliasToWork
argument_list|()
operator|.
name|get
argument_list|(
name|alias
argument_list|)
decl_stmt|;
if|if
condition|(
name|op
operator|==
name|opRoot
condition|)
block|{
comment|// The same vectorization context is copied multiple times into
comment|// the MapWork scratch columnMap
comment|// Each partition gets a copy
comment|//
name|vContext
operator|.
name|setFileKey
argument_list|(
name|onefile
argument_list|)
expr_stmt|;
name|scratchColumnContext
operator|.
name|put
argument_list|(
name|onefile
argument_list|,
name|vContext
argument_list|)
expr_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Vectorized MapWork operator "
operator|+
name|op
operator|.
name|getName
argument_list|()
operator|+
literal|" vectorization context "
operator|+
name|vContext
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
block|}
block|}
name|vContextsByOp
operator|.
name|put
argument_list|(
name|op
argument_list|,
name|vContext
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|vContext
operator|=
name|walkStackToFindVectorizationContext
argument_list|(
name|stack
argument_list|,
name|op
argument_list|)
expr_stmt|;
if|if
condition|(
name|vContext
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"Did not find vectorization context for operator %s in operator stack"
argument_list|,
name|op
operator|.
name|getName
argument_list|()
argument_list|)
argument_list|)
throw|;
block|}
block|}
assert|assert
name|vContext
operator|!=
literal|null
assert|;
comment|// When Vectorized GROUPBY outputs rows instead of vectorized row batchs, we don't
comment|// vectorize the operators below it.
if|if
condition|(
name|nonVectorizableChildOfGroupBy
argument_list|(
name|op
argument_list|)
condition|)
block|{
comment|// No need to vectorize
if|if
condition|(
operator|!
name|opsDone
operator|.
name|contains
argument_list|(
name|op
argument_list|)
condition|)
block|{
name|opsDone
operator|.
name|add
argument_list|(
name|op
argument_list|)
expr_stmt|;
block|}
return|return
literal|null
return|;
block|}
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
name|vectorOp
init|=
name|doVectorize
argument_list|(
name|op
argument_list|,
name|vContext
argument_list|)
decl_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Vectorized MapWork operator "
operator|+
name|vectorOp
operator|.
name|getName
argument_list|()
operator|+
literal|" vectorization context "
operator|+
name|vContext
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|vectorOp
operator|instanceof
name|VectorizationContextRegion
condition|)
block|{
name|VectorizationContextRegion
name|vcRegion
init|=
operator|(
name|VectorizationContextRegion
operator|)
name|vectorOp
decl_stmt|;
name|VectorizationContext
name|vOutContext
init|=
name|vcRegion
operator|.
name|getOuputVectorizationContext
argument_list|()
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Vectorized MapWork operator "
operator|+
name|vectorOp
operator|.
name|getName
argument_list|()
operator|+
literal|" added vectorization context "
operator|+
name|vContext
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
return|return
literal|null
return|;
block|}
block|}
class|class
name|ReduceWorkVectorizationNodeProcessor
extends|extends
name|VectorizationNodeProcessor
block|{
specifier|private
name|List
argument_list|<
name|String
argument_list|>
name|reduceColumnNames
decl_stmt|;
specifier|private
name|VectorizationContext
name|reduceShuffleVectorizationContext
decl_stmt|;
specifier|private
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
name|rootVectorOp
decl_stmt|;
specifier|public
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
name|getRootVectorOp
parameter_list|()
block|{
return|return
name|rootVectorOp
return|;
block|}
specifier|public
name|ReduceWorkVectorizationNodeProcessor
parameter_list|(
name|List
argument_list|<
name|String
argument_list|>
name|reduceColumnNames
parameter_list|)
block|{
name|this
operator|.
name|reduceColumnNames
operator|=
name|reduceColumnNames
expr_stmt|;
name|rootVectorOp
operator|=
literal|null
expr_stmt|;
name|reduceShuffleVectorizationContext
operator|=
literal|null
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|Object
name|process
parameter_list|(
name|Node
name|nd
parameter_list|,
name|Stack
argument_list|<
name|Node
argument_list|>
name|stack
parameter_list|,
name|NodeProcessorCtx
name|procCtx
parameter_list|,
name|Object
modifier|...
name|nodeOutputs
parameter_list|)
throws|throws
name|SemanticException
block|{
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
name|op
init|=
operator|(
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
operator|)
name|nd
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"ReduceWorkVectorizationNodeProcessor processing Operator: "
operator|+
name|op
operator|.
name|getName
argument_list|()
operator|+
literal|"..."
argument_list|)
expr_stmt|;
name|VectorizationContext
name|vContext
init|=
literal|null
decl_stmt|;
name|boolean
name|saveRootVectorOp
init|=
literal|false
decl_stmt|;
if|if
condition|(
name|op
operator|.
name|getParentOperators
argument_list|()
operator|.
name|size
argument_list|()
operator|==
literal|0
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"ReduceWorkVectorizationNodeProcessor process reduceColumnNames "
operator|+
name|reduceColumnNames
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|vContext
operator|=
operator|new
name|VectorizationContext
argument_list|(
name|reduceColumnNames
argument_list|)
expr_stmt|;
name|vContext
operator|.
name|setFileKey
argument_list|(
literal|"_REDUCE_SHUFFLE_"
argument_list|)
expr_stmt|;
name|scratchColumnContext
operator|.
name|put
argument_list|(
literal|"_REDUCE_SHUFFLE_"
argument_list|,
name|vContext
argument_list|)
expr_stmt|;
name|reduceShuffleVectorizationContext
operator|=
name|vContext
expr_stmt|;
name|saveRootVectorOp
operator|=
literal|true
expr_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Vectorized ReduceWork reduce shuffle vectorization context "
operator|+
name|vContext
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|vContext
operator|=
name|walkStackToFindVectorizationContext
argument_list|(
name|stack
argument_list|,
name|op
argument_list|)
expr_stmt|;
if|if
condition|(
name|vContext
operator|==
literal|null
condition|)
block|{
comment|// If we didn't find a context among the operators, assume the top -- reduce shuffle's
comment|// vectorization context.
name|vContext
operator|=
name|reduceShuffleVectorizationContext
expr_stmt|;
block|}
block|}
assert|assert
name|vContext
operator|!=
literal|null
assert|;
comment|// When Vectorized GROUPBY outputs rows instead of vectorized row batchs, we don't
comment|// vectorize the operators below it.
if|if
condition|(
name|nonVectorizableChildOfGroupBy
argument_list|(
name|op
argument_list|)
condition|)
block|{
comment|// No need to vectorize
if|if
condition|(
operator|!
name|opsDone
operator|.
name|contains
argument_list|(
name|op
argument_list|)
condition|)
block|{
name|opsDone
operator|.
name|add
argument_list|(
name|op
argument_list|)
expr_stmt|;
block|}
return|return
literal|null
return|;
block|}
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
name|vectorOp
init|=
name|doVectorize
argument_list|(
name|op
argument_list|,
name|vContext
argument_list|)
decl_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Vectorized ReduceWork operator "
operator|+
name|vectorOp
operator|.
name|getName
argument_list|()
operator|+
literal|" vectorization context "
operator|+
name|vContext
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|vectorOp
operator|instanceof
name|VectorizationContextRegion
condition|)
block|{
name|VectorizationContextRegion
name|vcRegion
init|=
operator|(
name|VectorizationContextRegion
operator|)
name|vectorOp
decl_stmt|;
name|VectorizationContext
name|vOutContext
init|=
name|vcRegion
operator|.
name|getOuputVectorizationContext
argument_list|()
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Vectorized ReduceWork operator "
operator|+
name|vectorOp
operator|.
name|getName
argument_list|()
operator|+
literal|" added vectorization context "
operator|+
name|vContext
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|vectorOp
operator|instanceof
name|VectorGroupByOperator
condition|)
block|{
name|VectorGroupByOperator
name|groupBy
init|=
operator|(
name|VectorGroupByOperator
operator|)
name|vectorOp
decl_stmt|;
name|VectorGroupByDesc
name|vectorDesc
init|=
name|groupBy
operator|.
name|getConf
argument_list|()
operator|.
name|getVectorDesc
argument_list|()
decl_stmt|;
name|vectorDesc
operator|.
name|setVectorGroupBatches
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|saveRootVectorOp
operator|&&
name|op
operator|!=
name|vectorOp
condition|)
block|{
name|rootVectorOp
operator|=
name|vectorOp
expr_stmt|;
block|}
return|return
literal|null
return|;
block|}
block|}
specifier|private
specifier|static
class|class
name|ValidatorVectorizationContext
extends|extends
name|VectorizationContext
block|{
specifier|private
name|ValidatorVectorizationContext
parameter_list|()
block|{
name|super
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Override
specifier|protected
name|int
name|getInputColumnIndex
parameter_list|(
name|String
name|name
parameter_list|)
block|{
return|return
literal|0
return|;
block|}
annotation|@
name|Override
specifier|protected
name|int
name|getInputColumnIndex
parameter_list|(
name|ExprNodeColumnDesc
name|colExpr
parameter_list|)
block|{
return|return
literal|0
return|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|PhysicalContext
name|resolve
parameter_list|(
name|PhysicalContext
name|pctx
parameter_list|)
throws|throws
name|SemanticException
block|{
name|this
operator|.
name|physicalContext
operator|=
name|pctx
expr_stmt|;
name|boolean
name|vectorPath
init|=
name|HiveConf
operator|.
name|getBoolVar
argument_list|(
name|pctx
operator|.
name|getConf
argument_list|()
argument_list|,
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVE_VECTORIZATION_ENABLED
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|vectorPath
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Vectorization is disabled"
argument_list|)
expr_stmt|;
return|return
name|pctx
return|;
block|}
comment|// create dispatcher and graph walker
name|Dispatcher
name|disp
init|=
operator|new
name|VectorizationDispatcher
argument_list|(
name|pctx
argument_list|)
decl_stmt|;
name|TaskGraphWalker
name|ogw
init|=
operator|new
name|TaskGraphWalker
argument_list|(
name|disp
argument_list|)
decl_stmt|;
comment|// get all the tasks nodes from root task
name|ArrayList
argument_list|<
name|Node
argument_list|>
name|topNodes
init|=
operator|new
name|ArrayList
argument_list|<
name|Node
argument_list|>
argument_list|()
decl_stmt|;
name|topNodes
operator|.
name|addAll
argument_list|(
name|pctx
operator|.
name|getRootTasks
argument_list|()
argument_list|)
expr_stmt|;
comment|// begin to walk through the task tree.
name|ogw
operator|.
name|startWalking
argument_list|(
name|topNodes
argument_list|,
literal|null
argument_list|)
expr_stmt|;
return|return
name|pctx
return|;
block|}
name|boolean
name|validateMapWorkOperator
parameter_list|(
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
name|op
parameter_list|,
name|MapWork
name|mWork
parameter_list|,
name|boolean
name|isTez
parameter_list|)
block|{
name|boolean
name|ret
init|=
literal|false
decl_stmt|;
switch|switch
condition|(
name|op
operator|.
name|getType
argument_list|()
condition|)
block|{
case|case
name|MAPJOIN
case|:
if|if
condition|(
name|op
operator|instanceof
name|MapJoinOperator
condition|)
block|{
name|ret
operator|=
name|validateMapJoinOperator
argument_list|(
operator|(
name|MapJoinOperator
operator|)
name|op
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|op
operator|instanceof
name|SMBMapJoinOperator
condition|)
block|{
name|ret
operator|=
name|validateSMBMapJoinOperator
argument_list|(
operator|(
name|SMBMapJoinOperator
operator|)
name|op
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|GROUPBY
case|:
name|ret
operator|=
name|validateGroupByOperator
argument_list|(
operator|(
name|GroupByOperator
operator|)
name|op
argument_list|,
literal|false
argument_list|,
name|isTez
argument_list|)
expr_stmt|;
break|break;
case|case
name|FILTER
case|:
name|ret
operator|=
name|validateFilterOperator
argument_list|(
operator|(
name|FilterOperator
operator|)
name|op
argument_list|)
expr_stmt|;
break|break;
case|case
name|SELECT
case|:
name|ret
operator|=
name|validateSelectOperator
argument_list|(
operator|(
name|SelectOperator
operator|)
name|op
argument_list|)
expr_stmt|;
break|break;
case|case
name|REDUCESINK
case|:
name|ret
operator|=
name|validateReduceSinkOperator
argument_list|(
operator|(
name|ReduceSinkOperator
operator|)
name|op
argument_list|)
expr_stmt|;
break|break;
case|case
name|TABLESCAN
case|:
name|ret
operator|=
name|validateTableScanOperator
argument_list|(
operator|(
name|TableScanOperator
operator|)
name|op
argument_list|,
name|mWork
argument_list|)
expr_stmt|;
break|break;
case|case
name|FILESINK
case|:
case|case
name|LIMIT
case|:
case|case
name|EVENT
case|:
name|ret
operator|=
literal|true
expr_stmt|;
break|break;
default|default:
name|ret
operator|=
literal|false
expr_stmt|;
break|break;
block|}
return|return
name|ret
return|;
block|}
name|boolean
name|validateReduceWorkOperator
parameter_list|(
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
name|op
parameter_list|)
block|{
name|boolean
name|ret
init|=
literal|false
decl_stmt|;
switch|switch
condition|(
name|op
operator|.
name|getType
argument_list|()
condition|)
block|{
case|case
name|EXTRACT
case|:
name|ret
operator|=
name|validateExtractOperator
argument_list|(
operator|(
name|ExtractOperator
operator|)
name|op
argument_list|)
expr_stmt|;
break|break;
case|case
name|MAPJOIN
case|:
comment|// Does MAPJOIN actually get planned in Reduce?
if|if
condition|(
name|op
operator|instanceof
name|MapJoinOperator
condition|)
block|{
name|ret
operator|=
name|validateMapJoinOperator
argument_list|(
operator|(
name|MapJoinOperator
operator|)
name|op
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|op
operator|instanceof
name|SMBMapJoinOperator
condition|)
block|{
name|ret
operator|=
name|validateSMBMapJoinOperator
argument_list|(
operator|(
name|SMBMapJoinOperator
operator|)
name|op
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|GROUPBY
case|:
if|if
condition|(
name|HiveConf
operator|.
name|getBoolVar
argument_list|(
name|physicalContext
operator|.
name|getConf
argument_list|()
argument_list|,
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVE_VECTORIZATION_REDUCE_GROUPBY_ENABLED
argument_list|)
condition|)
block|{
name|ret
operator|=
name|validateGroupByOperator
argument_list|(
operator|(
name|GroupByOperator
operator|)
name|op
argument_list|,
literal|true
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ret
operator|=
literal|false
expr_stmt|;
block|}
break|break;
case|case
name|FILTER
case|:
name|ret
operator|=
name|validateFilterOperator
argument_list|(
operator|(
name|FilterOperator
operator|)
name|op
argument_list|)
expr_stmt|;
break|break;
case|case
name|SELECT
case|:
name|ret
operator|=
name|validateSelectOperator
argument_list|(
operator|(
name|SelectOperator
operator|)
name|op
argument_list|)
expr_stmt|;
break|break;
case|case
name|REDUCESINK
case|:
name|ret
operator|=
name|validateReduceSinkOperator
argument_list|(
operator|(
name|ReduceSinkOperator
operator|)
name|op
argument_list|)
expr_stmt|;
break|break;
case|case
name|FILESINK
case|:
name|ret
operator|=
name|validateFileSinkOperator
argument_list|(
operator|(
name|FileSinkOperator
operator|)
name|op
argument_list|)
expr_stmt|;
break|break;
case|case
name|LIMIT
case|:
case|case
name|EVENT
case|:
name|ret
operator|=
literal|true
expr_stmt|;
break|break;
default|default:
name|ret
operator|=
literal|false
expr_stmt|;
break|break;
block|}
return|return
name|ret
return|;
block|}
specifier|public
name|Boolean
name|nonVectorizableChildOfGroupBy
parameter_list|(
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
name|op
parameter_list|)
block|{
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
name|currentOp
init|=
name|op
decl_stmt|;
while|while
condition|(
name|currentOp
operator|.
name|getParentOperators
argument_list|()
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
name|currentOp
operator|=
name|currentOp
operator|.
name|getParentOperators
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|currentOp
operator|.
name|getType
argument_list|()
operator|.
name|equals
argument_list|(
name|OperatorType
operator|.
name|GROUPBY
argument_list|)
condition|)
block|{
name|GroupByDesc
name|desc
init|=
operator|(
name|GroupByDesc
operator|)
name|currentOp
operator|.
name|getConf
argument_list|()
decl_stmt|;
name|boolean
name|isVectorOutput
init|=
name|desc
operator|.
name|getVectorDesc
argument_list|()
operator|.
name|isVectorOutput
argument_list|()
decl_stmt|;
if|if
condition|(
name|isVectorOutput
condition|)
block|{
comment|// This GROUP BY does vectorize its output.
return|return
literal|false
return|;
block|}
return|return
literal|true
return|;
block|}
block|}
return|return
literal|false
return|;
block|}
specifier|private
name|boolean
name|validateSMBMapJoinOperator
parameter_list|(
name|SMBMapJoinOperator
name|op
parameter_list|)
block|{
name|SMBJoinDesc
name|desc
init|=
name|op
operator|.
name|getConf
argument_list|()
decl_stmt|;
comment|// Validation is the same as for map join, since the 'small' tables are not vectorized
return|return
name|validateMapJoinDesc
argument_list|(
name|desc
argument_list|)
return|;
block|}
specifier|private
name|boolean
name|validateTableScanOperator
parameter_list|(
name|TableScanOperator
name|op
parameter_list|,
name|MapWork
name|mWork
parameter_list|)
block|{
name|TableScanDesc
name|desc
init|=
name|op
operator|.
name|getConf
argument_list|()
decl_stmt|;
if|if
condition|(
name|desc
operator|.
name|isGatherStats
argument_list|()
condition|)
block|{
return|return
literal|false
return|;
block|}
name|String
name|columns
init|=
literal|""
decl_stmt|;
name|String
name|types
init|=
literal|""
decl_stmt|;
name|String
name|partitionColumns
init|=
literal|""
decl_stmt|;
name|String
name|partitionTypes
init|=
literal|""
decl_stmt|;
name|boolean
name|haveInfo
init|=
literal|false
decl_stmt|;
comment|// This over-reaches slightly, since we can have> 1 table-scan  per map-work.
comment|// It needs path to partition, path to alias, then check the alias == the same table-scan, to be accurate.
comment|// That said, that is a TODO item to be fixed when we support>1 TableScans per vectorized pipeline later.
name|LinkedHashMap
argument_list|<
name|String
argument_list|,
name|PartitionDesc
argument_list|>
name|partitionDescs
init|=
name|mWork
operator|.
name|getPathToPartitionInfo
argument_list|()
decl_stmt|;
comment|// For vectorization, compare each partition information for against the others.
comment|// We assume the table information will be from one of the partitions, so it will
comment|// work to focus on the partition information and not compare against the TableScanOperator
comment|// columns (in the VectorizationContext)....
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|PartitionDesc
argument_list|>
name|entry
range|:
name|partitionDescs
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|PartitionDesc
name|partDesc
init|=
name|entry
operator|.
name|getValue
argument_list|()
decl_stmt|;
if|if
condition|(
name|partDesc
operator|.
name|getPartSpec
argument_list|()
operator|==
literal|null
operator|||
name|partDesc
operator|.
name|getPartSpec
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
comment|// No partition information -- we match because we would default to using the table description.
continue|continue;
block|}
name|Properties
name|partProps
init|=
name|partDesc
operator|.
name|getProperties
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|haveInfo
condition|)
block|{
name|columns
operator|=
name|partProps
operator|.
name|getProperty
argument_list|(
name|hive_metastoreConstants
operator|.
name|META_TABLE_COLUMNS
argument_list|)
expr_stmt|;
name|types
operator|=
name|partProps
operator|.
name|getProperty
argument_list|(
name|hive_metastoreConstants
operator|.
name|META_TABLE_COLUMN_TYPES
argument_list|)
expr_stmt|;
name|partitionColumns
operator|=
name|partProps
operator|.
name|getProperty
argument_list|(
name|hive_metastoreConstants
operator|.
name|META_TABLE_PARTITION_COLUMNS
argument_list|)
expr_stmt|;
name|partitionTypes
operator|=
name|partProps
operator|.
name|getProperty
argument_list|(
name|hive_metastoreConstants
operator|.
name|META_TABLE_PARTITION_COLUMN_TYPES
argument_list|)
expr_stmt|;
name|haveInfo
operator|=
literal|true
expr_stmt|;
block|}
else|else
block|{
name|String
name|nextColumns
init|=
name|partProps
operator|.
name|getProperty
argument_list|(
name|hive_metastoreConstants
operator|.
name|META_TABLE_COLUMNS
argument_list|)
decl_stmt|;
name|String
name|nextTypes
init|=
name|partProps
operator|.
name|getProperty
argument_list|(
name|hive_metastoreConstants
operator|.
name|META_TABLE_COLUMN_TYPES
argument_list|)
decl_stmt|;
name|String
name|nextPartitionColumns
init|=
name|partProps
operator|.
name|getProperty
argument_list|(
name|hive_metastoreConstants
operator|.
name|META_TABLE_PARTITION_COLUMNS
argument_list|)
decl_stmt|;
name|String
name|nextPartitionTypes
init|=
name|partProps
operator|.
name|getProperty
argument_list|(
name|hive_metastoreConstants
operator|.
name|META_TABLE_PARTITION_COLUMN_TYPES
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|columns
operator|.
name|equalsIgnoreCase
argument_list|(
name|nextColumns
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"Could not vectorize partition %s.  Its column names %s do not match the other column names %s"
argument_list|,
name|entry
operator|.
name|getKey
argument_list|()
argument_list|,
name|nextColumns
argument_list|,
name|columns
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
operator|!
name|types
operator|.
name|equalsIgnoreCase
argument_list|(
name|nextTypes
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"Could not vectorize partition %s.  Its column types %s do not match the other column types %s"
argument_list|,
name|entry
operator|.
name|getKey
argument_list|()
argument_list|,
name|nextTypes
argument_list|,
name|types
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
operator|!
name|partitionColumns
operator|.
name|equalsIgnoreCase
argument_list|(
name|nextPartitionColumns
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"Could not vectorize partition %s.  Its partition column names %s do not match the other partition column names %s"
argument_list|,
name|entry
operator|.
name|getKey
argument_list|()
argument_list|,
name|nextPartitionColumns
argument_list|,
name|partitionColumns
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
operator|!
name|partitionTypes
operator|.
name|equalsIgnoreCase
argument_list|(
name|nextPartitionTypes
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"Could not vectorize partition %s.  Its partition column types %s do not match the other partition column types %s"
argument_list|,
name|entry
operator|.
name|getKey
argument_list|()
argument_list|,
name|nextPartitionTypes
argument_list|,
name|partitionTypes
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
block|}
return|return
literal|true
return|;
block|}
specifier|private
name|boolean
name|validateMapJoinOperator
parameter_list|(
name|MapJoinOperator
name|op
parameter_list|)
block|{
name|MapJoinDesc
name|desc
init|=
name|op
operator|.
name|getConf
argument_list|()
decl_stmt|;
return|return
name|validateMapJoinDesc
argument_list|(
name|desc
argument_list|)
return|;
block|}
specifier|private
name|boolean
name|validateMapJoinDesc
parameter_list|(
name|MapJoinDesc
name|desc
parameter_list|)
block|{
name|byte
name|posBigTable
init|=
operator|(
name|byte
operator|)
name|desc
operator|.
name|getPosBigTable
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|ExprNodeDesc
argument_list|>
name|filterExprs
init|=
name|desc
operator|.
name|getFilters
argument_list|()
operator|.
name|get
argument_list|(
name|posBigTable
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|ExprNodeDesc
argument_list|>
name|keyExprs
init|=
name|desc
operator|.
name|getKeys
argument_list|()
operator|.
name|get
argument_list|(
name|posBigTable
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|ExprNodeDesc
argument_list|>
name|valueExprs
init|=
name|desc
operator|.
name|getExprs
argument_list|()
operator|.
name|get
argument_list|(
name|posBigTable
argument_list|)
decl_stmt|;
return|return
name|validateExprNodeDesc
argument_list|(
name|filterExprs
argument_list|,
name|VectorExpressionDescriptor
operator|.
name|Mode
operator|.
name|FILTER
argument_list|)
operator|&&
name|validateExprNodeDesc
argument_list|(
name|keyExprs
argument_list|)
operator|&&
name|validateExprNodeDesc
argument_list|(
name|valueExprs
argument_list|)
return|;
block|}
specifier|private
name|boolean
name|validateReduceSinkOperator
parameter_list|(
name|ReduceSinkOperator
name|op
parameter_list|)
block|{
name|List
argument_list|<
name|ExprNodeDesc
argument_list|>
name|keyDescs
init|=
name|op
operator|.
name|getConf
argument_list|()
operator|.
name|getKeyCols
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|ExprNodeDesc
argument_list|>
name|partitionDescs
init|=
name|op
operator|.
name|getConf
argument_list|()
operator|.
name|getPartitionCols
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|ExprNodeDesc
argument_list|>
name|valueDesc
init|=
name|op
operator|.
name|getConf
argument_list|()
operator|.
name|getValueCols
argument_list|()
decl_stmt|;
return|return
name|validateExprNodeDesc
argument_list|(
name|keyDescs
argument_list|)
operator|&&
name|validateExprNodeDesc
argument_list|(
name|partitionDescs
argument_list|)
operator|&&
name|validateExprNodeDesc
argument_list|(
name|valueDesc
argument_list|)
return|;
block|}
specifier|private
name|boolean
name|validateSelectOperator
parameter_list|(
name|SelectOperator
name|op
parameter_list|)
block|{
name|List
argument_list|<
name|ExprNodeDesc
argument_list|>
name|descList
init|=
name|op
operator|.
name|getConf
argument_list|()
operator|.
name|getColList
argument_list|()
decl_stmt|;
for|for
control|(
name|ExprNodeDesc
name|desc
range|:
name|descList
control|)
block|{
name|boolean
name|ret
init|=
name|validateExprNodeDesc
argument_list|(
name|desc
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|ret
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
return|return
literal|true
return|;
block|}
specifier|private
name|boolean
name|validateFilterOperator
parameter_list|(
name|FilterOperator
name|op
parameter_list|)
block|{
name|ExprNodeDesc
name|desc
init|=
name|op
operator|.
name|getConf
argument_list|()
operator|.
name|getPredicate
argument_list|()
decl_stmt|;
return|return
name|validateExprNodeDesc
argument_list|(
name|desc
argument_list|,
name|VectorExpressionDescriptor
operator|.
name|Mode
operator|.
name|FILTER
argument_list|)
return|;
block|}
specifier|private
name|boolean
name|validateGroupByOperator
parameter_list|(
name|GroupByOperator
name|op
parameter_list|,
name|boolean
name|isReduce
parameter_list|,
name|boolean
name|isTez
parameter_list|)
block|{
name|GroupByDesc
name|desc
init|=
name|op
operator|.
name|getConf
argument_list|()
decl_stmt|;
name|VectorGroupByDesc
name|vectorDesc
init|=
name|desc
operator|.
name|getVectorDesc
argument_list|()
decl_stmt|;
if|if
condition|(
name|desc
operator|.
name|isGroupingSetsPresent
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Grouping sets not supported in vector mode"
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
name|boolean
name|ret
init|=
name|validateExprNodeDesc
argument_list|(
name|desc
operator|.
name|getKeys
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|ret
condition|)
block|{
return|return
literal|false
return|;
block|}
name|ret
operator|=
name|validateAggregationDesc
argument_list|(
name|desc
operator|.
name|getAggregators
argument_list|()
argument_list|,
name|isReduce
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ret
condition|)
block|{
return|return
literal|false
return|;
block|}
if|if
condition|(
name|isReduce
condition|)
block|{
if|if
condition|(
name|desc
operator|.
name|isDistinct
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Distinct not supported in reduce vector mode"
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
comment|// Sort-based GroupBy?
if|if
condition|(
name|desc
operator|.
name|getMode
argument_list|()
operator|!=
name|GroupByDesc
operator|.
name|Mode
operator|.
name|COMPLETE
operator|&&
name|desc
operator|.
name|getMode
argument_list|()
operator|!=
name|GroupByDesc
operator|.
name|Mode
operator|.
name|PARTIAL1
operator|&&
name|desc
operator|.
name|getMode
argument_list|()
operator|!=
name|GroupByDesc
operator|.
name|Mode
operator|.
name|PARTIAL2
operator|&&
name|desc
operator|.
name|getMode
argument_list|()
operator|!=
name|GroupByDesc
operator|.
name|Mode
operator|.
name|MERGEPARTIAL
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Reduce vector mode not supported when input for GROUP BY not sorted"
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"Reduce GROUP BY mode is "
operator|+
name|desc
operator|.
name|getMode
argument_list|()
operator|.
name|name
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|desc
operator|.
name|getGroupKeyNotReductionKey
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Reduce vector mode not supported when group key is not reduction key"
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
operator|!
name|aggregatorsOutputIsPrimitive
argument_list|(
name|desc
operator|.
name|getAggregators
argument_list|()
argument_list|,
name|isReduce
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Reduce vector mode only supported when aggregate outputs are primitive types"
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
name|desc
operator|.
name|getKeys
argument_list|()
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|op
operator|.
name|getParentOperators
argument_list|()
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Reduce vector mode can only handle a key group GROUP BY operator when it is fed by reduce-shuffle"
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"Reduce-side GROUP BY will process key groups"
argument_list|)
expr_stmt|;
name|vectorDesc
operator|.
name|setVectorGroupBatches
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Reduce-side GROUP BY will do global aggregation"
argument_list|)
expr_stmt|;
block|}
name|vectorDesc
operator|.
name|setVectorOutput
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|vectorDesc
operator|.
name|setIsReduce
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
return|return
literal|true
return|;
block|}
specifier|private
name|boolean
name|validateExtractOperator
parameter_list|(
name|ExtractOperator
name|op
parameter_list|)
block|{
name|ExprNodeDesc
name|expr
init|=
name|op
operator|.
name|getConf
argument_list|()
operator|.
name|getCol
argument_list|()
decl_stmt|;
name|boolean
name|ret
init|=
name|validateExprNodeDesc
argument_list|(
name|expr
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|ret
condition|)
block|{
return|return
literal|false
return|;
block|}
return|return
literal|true
return|;
block|}
specifier|private
name|boolean
name|validateFileSinkOperator
parameter_list|(
name|FileSinkOperator
name|op
parameter_list|)
block|{
return|return
literal|true
return|;
block|}
specifier|private
name|boolean
name|validateExprNodeDesc
parameter_list|(
name|List
argument_list|<
name|ExprNodeDesc
argument_list|>
name|descs
parameter_list|)
block|{
return|return
name|validateExprNodeDesc
argument_list|(
name|descs
argument_list|,
name|VectorExpressionDescriptor
operator|.
name|Mode
operator|.
name|PROJECTION
argument_list|)
return|;
block|}
specifier|private
name|boolean
name|validateExprNodeDesc
parameter_list|(
name|List
argument_list|<
name|ExprNodeDesc
argument_list|>
name|descs
parameter_list|,
name|VectorExpressionDescriptor
operator|.
name|Mode
name|mode
parameter_list|)
block|{
for|for
control|(
name|ExprNodeDesc
name|d
range|:
name|descs
control|)
block|{
name|boolean
name|ret
init|=
name|validateExprNodeDesc
argument_list|(
name|d
argument_list|,
name|mode
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|ret
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
return|return
literal|true
return|;
block|}
specifier|private
name|boolean
name|validateAggregationDesc
parameter_list|(
name|List
argument_list|<
name|AggregationDesc
argument_list|>
name|descs
parameter_list|,
name|boolean
name|isReduce
parameter_list|)
block|{
for|for
control|(
name|AggregationDesc
name|d
range|:
name|descs
control|)
block|{
name|boolean
name|ret
init|=
name|validateAggregationDesc
argument_list|(
name|d
argument_list|,
name|isReduce
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|ret
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
return|return
literal|true
return|;
block|}
specifier|private
name|boolean
name|validateExprNodeDescRecursive
parameter_list|(
name|ExprNodeDesc
name|desc
parameter_list|)
block|{
if|if
condition|(
name|desc
operator|instanceof
name|ExprNodeColumnDesc
condition|)
block|{
name|ExprNodeColumnDesc
name|c
init|=
operator|(
name|ExprNodeColumnDesc
operator|)
name|desc
decl_stmt|;
comment|// Currently, we do not support vectorized virtual columns (see HIVE-5570).
if|if
condition|(
name|VirtualColumn
operator|.
name|VIRTUAL_COLUMN_NAMES
operator|.
name|contains
argument_list|(
name|c
operator|.
name|getColumn
argument_list|()
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Cannot vectorize virtual column "
operator|+
name|c
operator|.
name|getColumn
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
name|String
name|typeName
init|=
name|desc
operator|.
name|getTypeInfo
argument_list|()
operator|.
name|getTypeName
argument_list|()
decl_stmt|;
name|boolean
name|ret
init|=
name|validateDataType
argument_list|(
name|typeName
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|ret
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Cannot vectorize "
operator|+
name|desc
operator|.
name|toString
argument_list|()
operator|+
literal|" of type "
operator|+
name|typeName
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
name|desc
operator|instanceof
name|ExprNodeGenericFuncDesc
condition|)
block|{
name|ExprNodeGenericFuncDesc
name|d
init|=
operator|(
name|ExprNodeGenericFuncDesc
operator|)
name|desc
decl_stmt|;
name|boolean
name|r
init|=
name|validateGenericUdf
argument_list|(
name|d
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|r
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
if|if
condition|(
name|desc
operator|.
name|getChildren
argument_list|()
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|ExprNodeDesc
name|d
range|:
name|desc
operator|.
name|getChildren
argument_list|()
control|)
block|{
name|boolean
name|r
init|=
name|validateExprNodeDescRecursive
argument_list|(
name|d
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|r
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
block|}
return|return
literal|true
return|;
block|}
specifier|private
name|boolean
name|validateExprNodeDesc
parameter_list|(
name|ExprNodeDesc
name|desc
parameter_list|)
block|{
return|return
name|validateExprNodeDesc
argument_list|(
name|desc
argument_list|,
name|VectorExpressionDescriptor
operator|.
name|Mode
operator|.
name|PROJECTION
argument_list|)
return|;
block|}
name|boolean
name|validateExprNodeDesc
parameter_list|(
name|ExprNodeDesc
name|desc
parameter_list|,
name|VectorExpressionDescriptor
operator|.
name|Mode
name|mode
parameter_list|)
block|{
if|if
condition|(
operator|!
name|validateExprNodeDescRecursive
argument_list|(
name|desc
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
try|try
block|{
name|VectorizationContext
name|vc
init|=
operator|new
name|ValidatorVectorizationContext
argument_list|()
decl_stmt|;
if|if
condition|(
name|vc
operator|.
name|getVectorExpression
argument_list|(
name|desc
argument_list|,
name|mode
argument_list|)
operator|==
literal|null
condition|)
block|{
comment|// TODO: this cannot happen - VectorizationContext throws in such cases.
name|LOG
operator|.
name|info
argument_list|(
literal|"getVectorExpression returned null"
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Failed to vectorize"
argument_list|,
name|e
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
return|return
literal|true
return|;
block|}
specifier|private
name|boolean
name|validateGenericUdf
parameter_list|(
name|ExprNodeGenericFuncDesc
name|genericUDFExpr
parameter_list|)
block|{
if|if
condition|(
name|VectorizationContext
operator|.
name|isCustomUDF
argument_list|(
name|genericUDFExpr
argument_list|)
condition|)
block|{
return|return
literal|true
return|;
block|}
name|GenericUDF
name|genericUDF
init|=
name|genericUDFExpr
operator|.
name|getGenericUDF
argument_list|()
decl_stmt|;
if|if
condition|(
name|genericUDF
operator|instanceof
name|GenericUDFBridge
condition|)
block|{
name|Class
argument_list|<
name|?
extends|extends
name|UDF
argument_list|>
name|udf
init|=
operator|(
operator|(
name|GenericUDFBridge
operator|)
name|genericUDF
operator|)
operator|.
name|getUdfClass
argument_list|()
decl_stmt|;
return|return
name|supportedGenericUDFs
operator|.
name|contains
argument_list|(
name|udf
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|supportedGenericUDFs
operator|.
name|contains
argument_list|(
name|genericUDF
operator|.
name|getClass
argument_list|()
argument_list|)
return|;
block|}
block|}
specifier|private
name|boolean
name|validateAggregationDesc
parameter_list|(
name|AggregationDesc
name|aggDesc
parameter_list|,
name|boolean
name|isReduce
parameter_list|)
block|{
if|if
condition|(
operator|!
name|supportedAggregationUdfs
operator|.
name|contains
argument_list|(
name|aggDesc
operator|.
name|getGenericUDAFName
argument_list|()
operator|.
name|toLowerCase
argument_list|()
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
if|if
condition|(
name|aggDesc
operator|.
name|getParameters
argument_list|()
operator|!=
literal|null
operator|&&
operator|!
name|validateExprNodeDesc
argument_list|(
name|aggDesc
operator|.
name|getParameters
argument_list|()
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
comment|// See if we can vectorize the aggregation.
try|try
block|{
name|VectorizationContext
name|vc
init|=
operator|new
name|ValidatorVectorizationContext
argument_list|()
decl_stmt|;
if|if
condition|(
name|vc
operator|.
name|getAggregatorExpression
argument_list|(
name|aggDesc
argument_list|,
name|isReduce
argument_list|)
operator|==
literal|null
condition|)
block|{
comment|// TODO: this cannot happen - VectorizationContext throws in such cases.
name|LOG
operator|.
name|info
argument_list|(
literal|"getAggregatorExpression returned null"
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Failed to vectorize"
argument_list|,
name|e
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
return|return
literal|true
return|;
block|}
specifier|private
name|boolean
name|aggregatorsOutputIsPrimitive
parameter_list|(
name|List
argument_list|<
name|AggregationDesc
argument_list|>
name|descs
parameter_list|,
name|boolean
name|isReduce
parameter_list|)
block|{
for|for
control|(
name|AggregationDesc
name|d
range|:
name|descs
control|)
block|{
name|boolean
name|ret
init|=
name|aggregatorsOutputIsPrimitive
argument_list|(
name|d
argument_list|,
name|isReduce
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|ret
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
return|return
literal|true
return|;
block|}
specifier|private
name|boolean
name|aggregatorsOutputIsPrimitive
parameter_list|(
name|AggregationDesc
name|aggDesc
parameter_list|,
name|boolean
name|isReduce
parameter_list|)
block|{
name|VectorizationContext
name|vc
init|=
operator|new
name|ValidatorVectorizationContext
argument_list|()
decl_stmt|;
name|VectorAggregateExpression
name|vectorAggrExpr
decl_stmt|;
try|try
block|{
name|vectorAggrExpr
operator|=
name|vc
operator|.
name|getAggregatorExpression
argument_list|(
name|aggDesc
argument_list|,
name|isReduce
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
comment|// We should have already attempted to vectorize in validateAggregationDesc.
name|LOG
operator|.
name|info
argument_list|(
literal|"Vectorization of aggreation should have succeeded "
argument_list|,
name|e
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
name|ObjectInspector
name|outputObjInspector
init|=
name|vectorAggrExpr
operator|.
name|getOutputObjectInspector
argument_list|()
decl_stmt|;
if|if
condition|(
name|outputObjInspector
operator|.
name|getCategory
argument_list|()
operator|==
name|ObjectInspector
operator|.
name|Category
operator|.
name|PRIMITIVE
condition|)
block|{
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
specifier|private
name|boolean
name|validateDataType
parameter_list|(
name|String
name|type
parameter_list|)
block|{
return|return
name|supportedDataTypesPattern
operator|.
name|matcher
argument_list|(
name|type
operator|.
name|toLowerCase
argument_list|()
argument_list|)
operator|.
name|matches
argument_list|()
return|;
block|}
specifier|private
name|VectorizationContext
name|getVectorizationContext
parameter_list|(
name|Operator
name|op
parameter_list|,
name|PhysicalContext
name|pctx
parameter_list|)
block|{
name|RowSchema
name|rs
init|=
name|op
operator|.
name|getSchema
argument_list|()
decl_stmt|;
comment|// Add all non-virtual columns to make a vectorization context for
comment|// the TableScan operator.
name|VectorizationContext
name|vContext
init|=
operator|new
name|VectorizationContext
argument_list|()
decl_stmt|;
for|for
control|(
name|ColumnInfo
name|c
range|:
name|rs
operator|.
name|getSignature
argument_list|()
control|)
block|{
comment|// Earlier, validation code should have eliminated virtual columns usage (HIVE-5560).
if|if
condition|(
operator|!
name|isVirtualColumn
argument_list|(
name|c
argument_list|)
condition|)
block|{
name|vContext
operator|.
name|addInitialColumn
argument_list|(
name|c
operator|.
name|getInternalName
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
name|vContext
operator|.
name|finishedAddingInitialColumns
argument_list|()
expr_stmt|;
return|return
name|vContext
return|;
block|}
specifier|private
name|void
name|fixupParentChildOperators
parameter_list|(
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
name|op
parameter_list|,
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
name|vectorOp
parameter_list|)
block|{
if|if
condition|(
name|op
operator|.
name|getParentOperators
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|vectorOp
operator|.
name|setParentOperators
argument_list|(
name|op
operator|.
name|getParentOperators
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
name|p
range|:
name|op
operator|.
name|getParentOperators
argument_list|()
control|)
block|{
name|p
operator|.
name|replaceChild
argument_list|(
name|op
argument_list|,
name|vectorOp
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|op
operator|.
name|getChildOperators
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|vectorOp
operator|.
name|setChildOperators
argument_list|(
name|op
operator|.
name|getChildOperators
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
name|c
range|:
name|op
operator|.
name|getChildOperators
argument_list|()
control|)
block|{
name|c
operator|.
name|replaceParent
argument_list|(
name|op
argument_list|,
name|vectorOp
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
name|vectorizeOperator
parameter_list|(
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
name|op
parameter_list|,
name|VectorizationContext
name|vContext
parameter_list|)
throws|throws
name|HiveException
block|{
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
name|vectorOp
init|=
literal|null
decl_stmt|;
switch|switch
condition|(
name|op
operator|.
name|getType
argument_list|()
condition|)
block|{
case|case
name|MAPJOIN
case|:
case|case
name|GROUPBY
case|:
case|case
name|FILTER
case|:
case|case
name|SELECT
case|:
case|case
name|FILESINK
case|:
case|case
name|REDUCESINK
case|:
case|case
name|LIMIT
case|:
case|case
name|EXTRACT
case|:
case|case
name|EVENT
case|:
name|vectorOp
operator|=
name|OperatorFactory
operator|.
name|getVectorOperator
argument_list|(
name|op
operator|.
name|getConf
argument_list|()
argument_list|,
name|vContext
argument_list|)
expr_stmt|;
break|break;
default|default:
name|vectorOp
operator|=
name|op
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|vectorOp
operator|!=
name|op
condition|)
block|{
name|fixupParentChildOperators
argument_list|(
name|op
argument_list|,
name|vectorOp
argument_list|)
expr_stmt|;
operator|(
operator|(
name|AbstractOperatorDesc
operator|)
name|vectorOp
operator|.
name|getConf
argument_list|()
operator|)
operator|.
name|setVectorMode
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
return|return
name|vectorOp
return|;
block|}
specifier|private
name|boolean
name|isVirtualColumn
parameter_list|(
name|ColumnInfo
name|column
parameter_list|)
block|{
comment|// Not using method column.getIsVirtualCol() because partitioning columns are also
comment|// treated as virtual columns in ColumnInfo.
if|if
condition|(
name|VirtualColumn
operator|.
name|VIRTUAL_COLUMN_NAMES
operator|.
name|contains
argument_list|(
name|column
operator|.
name|getInternalName
argument_list|()
argument_list|)
condition|)
block|{
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
specifier|public
name|void
name|debugDisplayAllMaps
parameter_list|(
name|Map
argument_list|<
name|String
argument_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|Integer
argument_list|>
argument_list|>
name|allColumnVectorMaps
parameter_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|Map
argument_list|<
name|Integer
argument_list|,
name|String
argument_list|>
argument_list|>
name|allScratchColumnVectorTypeMaps
parameter_list|)
block|{
comment|// Context keys grow in length since they are a path...
name|Comparator
argument_list|<
name|String
argument_list|>
name|comparerShorterString
init|=
operator|new
name|Comparator
argument_list|<
name|String
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|int
name|compare
parameter_list|(
name|String
name|o1
parameter_list|,
name|String
name|o2
parameter_list|)
block|{
name|Integer
name|length1
init|=
name|o1
operator|.
name|length
argument_list|()
decl_stmt|;
name|Integer
name|length2
init|=
name|o2
operator|.
name|length
argument_list|()
decl_stmt|;
return|return
name|length1
operator|.
name|compareTo
argument_list|(
name|length2
argument_list|)
return|;
block|}
block|}
decl_stmt|;
name|Comparator
argument_list|<
name|Integer
argument_list|>
name|comparerInteger
init|=
operator|new
name|Comparator
argument_list|<
name|Integer
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|int
name|compare
parameter_list|(
name|Integer
name|o1
parameter_list|,
name|Integer
name|o2
parameter_list|)
block|{
return|return
name|o1
operator|.
name|compareTo
argument_list|(
name|o2
argument_list|)
return|;
block|}
block|}
decl_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|Map
argument_list|<
name|Integer
argument_list|,
name|String
argument_list|>
argument_list|>
name|sortedAllColumnVectorMaps
init|=
operator|new
name|TreeMap
argument_list|<
name|String
argument_list|,
name|Map
argument_list|<
name|Integer
argument_list|,
name|String
argument_list|>
argument_list|>
argument_list|(
name|comparerShorterString
argument_list|)
decl_stmt|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|Integer
argument_list|>
argument_list|>
name|entry
range|:
name|allColumnVectorMaps
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|Map
argument_list|<
name|Integer
argument_list|,
name|String
argument_list|>
name|sortedColumnMap
init|=
operator|new
name|TreeMap
argument_list|<
name|Integer
argument_list|,
name|String
argument_list|>
argument_list|(
name|comparerInteger
argument_list|)
decl_stmt|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|Integer
argument_list|>
name|innerEntry
range|:
name|entry
operator|.
name|getValue
argument_list|()
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|sortedColumnMap
operator|.
name|put
argument_list|(
name|innerEntry
operator|.
name|getValue
argument_list|()
argument_list|,
name|innerEntry
operator|.
name|getKey
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|sortedAllColumnVectorMaps
operator|.
name|put
argument_list|(
name|entry
operator|.
name|getKey
argument_list|()
argument_list|,
name|sortedColumnMap
argument_list|)
expr_stmt|;
block|}
name|LOG
operator|.
name|debug
argument_list|(
literal|"sortedAllColumnVectorMaps "
operator|+
name|sortedAllColumnVectorMaps
argument_list|)
expr_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|Map
argument_list|<
name|Integer
argument_list|,
name|String
argument_list|>
argument_list|>
name|sortedAllScratchColumnVectorTypeMap
init|=
operator|new
name|TreeMap
argument_list|<
name|String
argument_list|,
name|Map
argument_list|<
name|Integer
argument_list|,
name|String
argument_list|>
argument_list|>
argument_list|(
name|comparerShorterString
argument_list|)
decl_stmt|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|Map
argument_list|<
name|Integer
argument_list|,
name|String
argument_list|>
argument_list|>
name|entry
range|:
name|allScratchColumnVectorTypeMaps
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|Map
argument_list|<
name|Integer
argument_list|,
name|String
argument_list|>
name|sortedScratchColumnTypeMap
init|=
operator|new
name|TreeMap
argument_list|<
name|Integer
argument_list|,
name|String
argument_list|>
argument_list|(
name|comparerInteger
argument_list|)
decl_stmt|;
name|sortedScratchColumnTypeMap
operator|.
name|putAll
argument_list|(
name|entry
operator|.
name|getValue
argument_list|()
argument_list|)
expr_stmt|;
name|sortedAllScratchColumnVectorTypeMap
operator|.
name|put
argument_list|(
name|entry
operator|.
name|getKey
argument_list|()
argument_list|,
name|sortedScratchColumnTypeMap
argument_list|)
expr_stmt|;
block|}
name|LOG
operator|.
name|debug
argument_list|(
literal|"sortedAllScratchColumnVectorTypeMap "
operator|+
name|sortedAllScratchColumnVectorTypeMap
argument_list|)
expr_stmt|;
block|}
block|}
end_class

end_unit

