begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_comment
comment|/**  * JDBM LICENSE v1.00  *  * Redistribution and use of this software and associated documentation  * ("Software"), with or without modification, are permitted provided  * that the following conditions are met:  *  * 1. Redistributions of source code must retain copyright  *    statements and notices.  Redistributions must also contain a  *    copy of this document.  *  * 2. Redistributions in binary form must reproduce the  *    above copyright notice, this list of conditions and the  *    following disclaimer in the documentation and/or other  *    materials provided with the distribution.  *  * 3. The name "JDBM" must not be used to endorse or promote  *    products derived from this Software without prior written  *    permission of Cees de Groot.  For written permission,  *    please contact cg@cdegroot.com.  *  * 4. Products derived from this Software may not be called "JDBM"  *    nor may "JDBM" appear in their names without prior written  *    permission of Cees de Groot.  *  * 5. Due credit should be given to the JDBM Project  *    (http://jdbm.sourceforge.net/).  *  * THIS SOFTWARE IS PROVIDED BY THE JDBM PROJECT AND CONTRIBUTORS  * ``AS IS'' AND ANY EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT  * NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND  * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL  * CEES DE GROOT OR ANY CONTRIBUTORS BE LIABLE FOR ANY DIRECT,  * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR  * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,  * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED  * OF THE POSSIBILITY OF SUCH DAMAGE.  *  * Copyright 2000 (C) Cees de Groot. All Rights Reserved.  * Contributions are Copyright (C) 2000 by their associated contributors.  *  * $Id: TransactionManager.java,v 1.7 2005/06/25 23:12:32 doomdark Exp $  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|util
operator|.
name|jdbm
operator|.
name|recman
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|File
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|FileInputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|FileOutputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|ObjectInputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|ObjectOutputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Comparator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|TreeSet
import|;
end_import

begin_comment
comment|/**  * This class manages the transaction log that belongs to every  * {@link RecordFile}. The transaction log is either clean, or in progress. In  * the latter case, the transaction manager takes care of a roll forward.  *<p>  * Implementation note: this is a proof-of-concept implementation which hasn't  * been optimized for speed. For instance, all sorts of streams are created for  * every transaction.  */
end_comment

begin_comment
comment|// TODO: Handle the case where we are recovering lg9 and lg0, were we
end_comment

begin_comment
comment|// should start with lg9 instead of lg0!
end_comment

begin_class
specifier|public
specifier|final
class|class
name|TransactionManager
block|{
specifier|private
specifier|final
name|RecordFile
name|owner
decl_stmt|;
comment|// streams for transaction log.
specifier|private
name|FileOutputStream
name|fos
decl_stmt|;
specifier|private
name|ObjectOutputStream
name|oos
decl_stmt|;
comment|/**    * By default, we keep 10 transactions in the log file before synchronizing it    * with the main database file.    */
specifier|static
specifier|final
name|int
name|DEFAULT_TXNS_IN_LOG
init|=
literal|10
decl_stmt|;
comment|/**    * Maximum number of transactions before the log file is synchronized with the    * main database file.    */
specifier|private
name|int
name|_maxTxns
init|=
name|DEFAULT_TXNS_IN_LOG
decl_stmt|;
comment|/**    * In-core copy of transactions. We could read everything back from the log    * file, but the RecordFile needs to keep the dirty blocks in core anyway, so    * we might as well point to them and spare us a lot of hassle.    */
specifier|private
name|ArrayList
index|[]
name|txns
init|=
operator|new
name|ArrayList
index|[
name|DEFAULT_TXNS_IN_LOG
index|]
decl_stmt|;
specifier|private
name|int
name|curTxn
init|=
operator|-
literal|1
decl_stmt|;
comment|/** Extension of a log file. */
specifier|static
specifier|final
name|String
name|extension
init|=
literal|".lg"
decl_stmt|;
comment|/** log file name */
specifier|private
name|String
name|logFileName
decl_stmt|;
comment|/**    * Instantiates a transaction manager instance. If recovery needs to be    * performed, it is done.    *     * @param owner    *          the RecordFile instance that owns this transaction mgr.    */
name|TransactionManager
parameter_list|(
name|RecordFile
name|owner
parameter_list|)
throws|throws
name|IOException
block|{
name|this
operator|.
name|owner
operator|=
name|owner
expr_stmt|;
name|logFileName
operator|=
literal|null
expr_stmt|;
name|recover
argument_list|()
expr_stmt|;
name|open
argument_list|()
expr_stmt|;
block|}
comment|/**    * Synchronize log file data with the main database file.    *<p>    * After this call, the main database file is guaranteed to be consistent and    * guaranteed to be the only file needed for backup purposes.    */
specifier|public
name|void
name|synchronizeLog
parameter_list|()
throws|throws
name|IOException
block|{
name|synchronizeLogFromMemory
argument_list|()
expr_stmt|;
block|}
comment|/**    * Set the maximum number of transactions to record in the log (and keep in    * memory) before the log is synchronized with the main database file.    *<p>    * This method must be called while there are no pending transactions in the    * log.    */
specifier|public
name|void
name|setMaximumTransactionsInLog
parameter_list|(
name|int
name|maxTxns
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|maxTxns
operator|<=
literal|0
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Argument 'maxTxns' must be greater than 0."
argument_list|)
throw|;
block|}
if|if
condition|(
name|curTxn
operator|!=
operator|-
literal|1
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"Cannot change setting while transactions are pending in the log"
argument_list|)
throw|;
block|}
name|_maxTxns
operator|=
name|maxTxns
expr_stmt|;
name|txns
operator|=
operator|new
name|ArrayList
index|[
name|maxTxns
index|]
expr_stmt|;
block|}
comment|/** Builds logfile name */
specifier|private
name|String
name|makeLogName
parameter_list|()
block|{
return|return
name|owner
operator|.
name|getFileName
argument_list|()
operator|+
name|extension
return|;
block|}
comment|/** Synchs in-core transactions to data file and opens a fresh log */
specifier|private
name|void
name|synchronizeLogFromMemory
parameter_list|()
throws|throws
name|IOException
block|{
name|close
argument_list|()
expr_stmt|;
name|TreeSet
name|blockList
init|=
operator|new
name|TreeSet
argument_list|(
operator|new
name|BlockIoComparator
argument_list|()
argument_list|)
decl_stmt|;
name|int
name|numBlocks
init|=
literal|0
decl_stmt|;
name|int
name|writtenBlocks
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|_maxTxns
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|txns
index|[
name|i
index|]
operator|==
literal|null
condition|)
block|{
continue|continue;
block|}
comment|// Add each block to the blockList, replacing the old copy of this
comment|// block if necessary, thus avoiding writing the same block twice
for|for
control|(
name|Iterator
name|k
init|=
name|txns
index|[
name|i
index|]
operator|.
name|iterator
argument_list|()
init|;
name|k
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|BlockIo
name|block
init|=
operator|(
name|BlockIo
operator|)
name|k
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
name|blockList
operator|.
name|contains
argument_list|(
name|block
argument_list|)
condition|)
block|{
name|block
operator|.
name|decrementTransactionCount
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|writtenBlocks
operator|++
expr_stmt|;
name|blockList
operator|.
name|add
argument_list|(
name|block
argument_list|)
expr_stmt|;
block|}
name|numBlocks
operator|++
expr_stmt|;
block|}
name|txns
index|[
name|i
index|]
operator|=
literal|null
expr_stmt|;
block|}
comment|// Write the blocks from the blockList to disk
name|synchronizeBlocks
argument_list|(
name|blockList
operator|.
name|iterator
argument_list|()
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|owner
operator|.
name|sync
argument_list|()
expr_stmt|;
name|open
argument_list|()
expr_stmt|;
block|}
comment|/** Opens the log file */
specifier|private
name|void
name|open
parameter_list|()
throws|throws
name|IOException
block|{
name|logFileName
operator|=
name|makeLogName
argument_list|()
expr_stmt|;
name|fos
operator|=
operator|new
name|FileOutputStream
argument_list|(
name|logFileName
argument_list|)
expr_stmt|;
name|oos
operator|=
operator|new
name|ObjectOutputStream
argument_list|(
name|fos
argument_list|)
expr_stmt|;
name|oos
operator|.
name|writeShort
argument_list|(
name|Magic
operator|.
name|LOGFILE_HEADER
argument_list|)
expr_stmt|;
name|oos
operator|.
name|flush
argument_list|()
expr_stmt|;
name|curTxn
operator|=
operator|-
literal|1
expr_stmt|;
block|}
comment|/** Startup recovery on all files */
specifier|private
name|void
name|recover
parameter_list|()
throws|throws
name|IOException
block|{
name|String
name|logName
init|=
name|makeLogName
argument_list|()
decl_stmt|;
name|File
name|logFile
init|=
operator|new
name|File
argument_list|(
name|logName
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|logFile
operator|.
name|exists
argument_list|()
condition|)
block|{
return|return;
block|}
if|if
condition|(
name|logFile
operator|.
name|length
argument_list|()
operator|==
literal|0
condition|)
block|{
name|logFile
operator|.
name|delete
argument_list|()
expr_stmt|;
return|return;
block|}
name|FileInputStream
name|fis
init|=
operator|new
name|FileInputStream
argument_list|(
name|logFile
argument_list|)
decl_stmt|;
name|ObjectInputStream
name|ois
init|=
operator|new
name|ObjectInputStream
argument_list|(
name|fis
argument_list|)
decl_stmt|;
try|try
block|{
if|if
condition|(
name|ois
operator|.
name|readShort
argument_list|()
operator|!=
name|Magic
operator|.
name|LOGFILE_HEADER
condition|)
block|{
throw|throw
operator|new
name|Error
argument_list|(
literal|"Bad magic on log file"
argument_list|)
throw|;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
comment|// corrupted/empty logfile
name|logFile
operator|.
name|delete
argument_list|()
expr_stmt|;
return|return;
block|}
while|while
condition|(
literal|true
condition|)
block|{
name|ArrayList
name|blocks
init|=
literal|null
decl_stmt|;
try|try
block|{
name|blocks
operator|=
operator|(
name|ArrayList
operator|)
name|ois
operator|.
name|readObject
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|ClassNotFoundException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|Error
argument_list|(
literal|"Unexcepted exception: "
operator|+
name|e
argument_list|)
throw|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
comment|// corrupted logfile, ignore rest of transactions
break|break;
block|}
name|synchronizeBlocks
argument_list|(
name|blocks
operator|.
name|iterator
argument_list|()
argument_list|,
literal|false
argument_list|)
expr_stmt|;
comment|// ObjectInputStream must match exactly each
comment|// ObjectOutputStream created during writes
try|try
block|{
name|ois
operator|=
operator|new
name|ObjectInputStream
argument_list|(
name|fis
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
comment|// corrupted logfile, ignore rest of transactions
break|break;
block|}
block|}
name|owner
operator|.
name|sync
argument_list|()
expr_stmt|;
name|logFile
operator|.
name|delete
argument_list|()
expr_stmt|;
block|}
comment|/** Synchronizes the indicated blocks with the owner. */
specifier|private
name|void
name|synchronizeBlocks
parameter_list|(
name|Iterator
name|blockIterator
parameter_list|,
name|boolean
name|fromCore
parameter_list|)
throws|throws
name|IOException
block|{
comment|// write block vector elements to the data file.
while|while
condition|(
name|blockIterator
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|BlockIo
name|cur
init|=
operator|(
name|BlockIo
operator|)
name|blockIterator
operator|.
name|next
argument_list|()
decl_stmt|;
name|owner
operator|.
name|synch
argument_list|(
name|cur
argument_list|)
expr_stmt|;
if|if
condition|(
name|fromCore
condition|)
block|{
name|cur
operator|.
name|decrementTransactionCount
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|cur
operator|.
name|isInTransaction
argument_list|()
condition|)
block|{
name|owner
operator|.
name|releaseFromTransaction
argument_list|(
name|cur
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/** Set clean flag on the blocks. */
specifier|private
name|void
name|setClean
parameter_list|(
name|ArrayList
name|blocks
parameter_list|)
throws|throws
name|IOException
block|{
for|for
control|(
name|Iterator
name|k
init|=
name|blocks
operator|.
name|iterator
argument_list|()
init|;
name|k
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|BlockIo
name|cur
init|=
operator|(
name|BlockIo
operator|)
name|k
operator|.
name|next
argument_list|()
decl_stmt|;
name|cur
operator|.
name|setClean
argument_list|()
expr_stmt|;
block|}
block|}
comment|/** Discards the indicated blocks and notify the owner. */
specifier|private
name|void
name|discardBlocks
parameter_list|(
name|ArrayList
name|blocks
parameter_list|)
throws|throws
name|IOException
block|{
for|for
control|(
name|Iterator
name|k
init|=
name|blocks
operator|.
name|iterator
argument_list|()
init|;
name|k
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|BlockIo
name|cur
init|=
operator|(
name|BlockIo
operator|)
name|k
operator|.
name|next
argument_list|()
decl_stmt|;
name|cur
operator|.
name|decrementTransactionCount
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|cur
operator|.
name|isInTransaction
argument_list|()
condition|)
block|{
name|owner
operator|.
name|releaseFromTransaction
argument_list|(
name|cur
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**    * Starts a transaction. This can block if all slots have been filled with    * full transactions, waiting for the synchronization thread to clean out    * slots.    */
name|void
name|start
parameter_list|()
throws|throws
name|IOException
block|{
name|curTxn
operator|++
expr_stmt|;
if|if
condition|(
name|curTxn
operator|==
name|_maxTxns
condition|)
block|{
name|synchronizeLogFromMemory
argument_list|()
expr_stmt|;
name|curTxn
operator|=
literal|0
expr_stmt|;
block|}
name|txns
index|[
name|curTxn
index|]
operator|=
operator|new
name|ArrayList
argument_list|()
expr_stmt|;
block|}
comment|/**    * Indicates the block is part of the transaction.    */
name|void
name|add
parameter_list|(
name|BlockIo
name|block
parameter_list|)
throws|throws
name|IOException
block|{
name|block
operator|.
name|incrementTransactionCount
argument_list|()
expr_stmt|;
name|txns
index|[
name|curTxn
index|]
operator|.
name|add
argument_list|(
name|block
argument_list|)
expr_stmt|;
block|}
comment|/**    * Commits the transaction to the log file.    */
name|void
name|commit
parameter_list|()
throws|throws
name|IOException
block|{
name|oos
operator|.
name|writeObject
argument_list|(
name|txns
index|[
name|curTxn
index|]
argument_list|)
expr_stmt|;
name|sync
argument_list|()
expr_stmt|;
comment|// set clean flag to indicate blocks have been written to log
name|setClean
argument_list|(
name|txns
index|[
name|curTxn
index|]
argument_list|)
expr_stmt|;
comment|// open a new ObjectOutputStream in order to store
comment|// newer states of BlockIo
name|oos
operator|=
operator|new
name|ObjectOutputStream
argument_list|(
name|fos
argument_list|)
expr_stmt|;
block|}
comment|/** Flushes and syncs */
specifier|private
name|void
name|sync
parameter_list|()
throws|throws
name|IOException
block|{
name|oos
operator|.
name|flush
argument_list|()
expr_stmt|;
name|fos
operator|.
name|flush
argument_list|()
expr_stmt|;
name|fos
operator|.
name|getFD
argument_list|()
operator|.
name|sync
argument_list|()
expr_stmt|;
block|}
comment|/**    * Shutdowns the transaction manager. Resynchronizes outstanding logs.    */
name|void
name|shutdown
parameter_list|()
throws|throws
name|IOException
block|{
name|synchronizeLogFromMemory
argument_list|()
expr_stmt|;
name|close
argument_list|()
expr_stmt|;
block|}
comment|/**    * Closes open files.    */
specifier|private
name|void
name|close
parameter_list|()
throws|throws
name|IOException
block|{
name|sync
argument_list|()
expr_stmt|;
name|oos
operator|.
name|close
argument_list|()
expr_stmt|;
name|fos
operator|.
name|close
argument_list|()
expr_stmt|;
name|oos
operator|=
literal|null
expr_stmt|;
name|fos
operator|=
literal|null
expr_stmt|;
block|}
specifier|public
name|void
name|removeLogFile
parameter_list|()
block|{
comment|// if file is not closed yet, just return
if|if
condition|(
name|oos
operator|!=
literal|null
condition|)
block|{
return|return;
block|}
if|if
condition|(
name|logFileName
operator|!=
literal|null
condition|)
block|{
name|File
name|file
init|=
operator|new
name|File
argument_list|(
name|logFileName
argument_list|)
decl_stmt|;
name|file
operator|.
name|delete
argument_list|()
expr_stmt|;
name|logFileName
operator|=
literal|null
expr_stmt|;
block|}
block|}
comment|/**    * Force closing the file without synchronizing pending transaction data. Used    * for testing purposes only.    */
name|void
name|forceClose
parameter_list|()
throws|throws
name|IOException
block|{
name|oos
operator|.
name|close
argument_list|()
expr_stmt|;
name|fos
operator|.
name|close
argument_list|()
expr_stmt|;
name|oos
operator|=
literal|null
expr_stmt|;
name|fos
operator|=
literal|null
expr_stmt|;
block|}
comment|/**    * Use the disk-based transaction log to synchronize the data file.    * Outstanding memory logs are discarded because they are believed to be    * inconsistent.    */
name|void
name|synchronizeLogFromDisk
parameter_list|()
throws|throws
name|IOException
block|{
name|close
argument_list|()
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|_maxTxns
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|txns
index|[
name|i
index|]
operator|==
literal|null
condition|)
block|{
continue|continue;
block|}
name|discardBlocks
argument_list|(
name|txns
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|txns
index|[
name|i
index|]
operator|=
literal|null
expr_stmt|;
block|}
name|recover
argument_list|()
expr_stmt|;
name|open
argument_list|()
expr_stmt|;
block|}
comment|/**    * INNER CLASS. Comparator class for use by the tree set used to store the    * blocks to write for this transaction. The BlockIo objects are ordered by    * their blockIds.    */
specifier|public
specifier|static
class|class
name|BlockIoComparator
implements|implements
name|Comparator
block|{
specifier|public
name|int
name|compare
parameter_list|(
name|Object
name|o1
parameter_list|,
name|Object
name|o2
parameter_list|)
block|{
name|BlockIo
name|block1
init|=
operator|(
name|BlockIo
operator|)
name|o1
decl_stmt|;
name|BlockIo
name|block2
init|=
operator|(
name|BlockIo
operator|)
name|o2
decl_stmt|;
name|int
name|result
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|block1
operator|.
name|getBlockId
argument_list|()
operator|==
name|block2
operator|.
name|getBlockId
argument_list|()
condition|)
block|{
name|result
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|block1
operator|.
name|getBlockId
argument_list|()
operator|<
name|block2
operator|.
name|getBlockId
argument_list|()
condition|)
block|{
name|result
operator|=
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
name|result
operator|=
literal|1
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|equals
parameter_list|(
name|Object
name|obj
parameter_list|)
block|{
return|return
name|super
operator|.
name|equals
argument_list|(
name|obj
argument_list|)
return|;
block|}
block|}
comment|// class BlockIOComparator
block|}
end_class

end_unit

