begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|tez
package|;
end_package

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|VisibleForTesting
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|URISyntaxException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicInteger
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicReference
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ArrayBlockingQueue
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|BlockingQueue
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ConcurrentLinkedQueue
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|PriorityBlockingQueue
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|LinkedBlockingQueue
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|Semaphore
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|TimeUnit
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Comparator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|LinkedList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Queue
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Random
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|security
operator|.
name|auth
operator|.
name|login
operator|.
name|LoginException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|tez
operator|.
name|dag
operator|.
name|api
operator|.
name|TezConfiguration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|Path
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|conf
operator|.
name|HiveConf
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|conf
operator|.
name|HiveConf
operator|.
name|ConfVars
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|metadata
operator|.
name|HiveException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|session
operator|.
name|SessionState
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|session
operator|.
name|SessionState
operator|.
name|LogHelper
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|shims
operator|.
name|Utils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|security
operator|.
name|UserGroupInformation
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|tez
operator|.
name|dag
operator|.
name|api
operator|.
name|TezException
import|;
end_import

begin_comment
comment|/**  * This class is for managing multiple tez sessions particularly when  * HiveServer2 is being used to submit queries.  *  * In case the user specifies a queue explicitly, a new session is created  * on that queue and assigned to the session state.  */
end_comment

begin_class
specifier|public
class|class
name|TezSessionPoolManager
block|{
specifier|private
enum|enum
name|CustomQueueAllowed
block|{
name|TRUE
block|,
name|FALSE
block|,
name|IGNORE
block|}
specifier|private
specifier|static
specifier|final
name|Logger
name|LOG
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|TezSessionPoolManager
operator|.
name|class
argument_list|)
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|Random
name|rdm
init|=
operator|new
name|Random
argument_list|()
decl_stmt|;
specifier|private
name|BlockingQueue
argument_list|<
name|TezSessionPoolSession
argument_list|>
name|defaultQueuePool
decl_stmt|;
comment|/** Priority queue sorted by expiration time of live sessions that could be expired. */
specifier|private
name|PriorityBlockingQueue
argument_list|<
name|TezSessionPoolSession
argument_list|>
name|expirationQueue
decl_stmt|;
comment|/** The background restart queue that is populated when expiration is triggered by a foreground    * thread (i.e. getting or returning a session), to avoid delaying it. */
specifier|private
name|BlockingQueue
argument_list|<
name|TezSessionPoolSession
argument_list|>
name|restartQueue
decl_stmt|;
specifier|private
name|Thread
name|expirationThread
decl_stmt|;
specifier|private
name|Thread
name|restartThread
decl_stmt|;
specifier|private
name|Semaphore
name|llapQueue
decl_stmt|;
specifier|private
name|HiveConf
name|initConf
init|=
literal|null
decl_stmt|;
comment|// Config settings.
specifier|private
name|int
name|numConcurrentLlapQueries
init|=
operator|-
literal|1
decl_stmt|;
specifier|private
name|long
name|sessionLifetimeMs
init|=
literal|0
decl_stmt|;
specifier|private
name|long
name|sessionLifetimeJitterMs
init|=
literal|0
decl_stmt|;
specifier|private
name|CustomQueueAllowed
name|customQueueAllowed
init|=
name|CustomQueueAllowed
operator|.
name|TRUE
decl_stmt|;
specifier|private
name|List
argument_list|<
name|ConfVars
argument_list|>
name|restrictedHiveConf
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
specifier|private
name|List
argument_list|<
name|String
argument_list|>
name|restrictedNonHiveConf
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
comment|/** A queue for initial sessions that have not been started yet. */
specifier|private
name|Queue
argument_list|<
name|TezSessionPoolSession
argument_list|>
name|initialSessions
init|=
operator|new
name|ConcurrentLinkedQueue
argument_list|<
name|TezSessionPoolSession
argument_list|>
argument_list|()
decl_stmt|;
comment|/**    * Indicates whether we should try to use defaultSessionPool.    * We assume that setupPool is either called before any activity, or not called at all.    */
specifier|private
specifier|volatile
name|boolean
name|hasInitialSessions
init|=
literal|false
decl_stmt|;
specifier|private
specifier|static
name|TezSessionPoolManager
name|sessionPool
init|=
literal|null
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|List
argument_list|<
name|TezSessionPoolSession
argument_list|>
name|openSessions
init|=
operator|new
name|LinkedList
argument_list|<
name|TezSessionPoolSession
argument_list|>
argument_list|()
decl_stmt|;
specifier|public
specifier|static
name|TezSessionPoolManager
name|getInstance
parameter_list|()
throws|throws
name|Exception
block|{
if|if
condition|(
name|sessionPool
operator|==
literal|null
condition|)
block|{
name|sessionPool
operator|=
operator|new
name|TezSessionPoolManager
argument_list|()
expr_stmt|;
block|}
return|return
name|sessionPool
return|;
block|}
specifier|protected
name|TezSessionPoolManager
parameter_list|()
block|{   }
specifier|private
name|void
name|startInitialSession
parameter_list|(
name|TezSessionPoolSession
name|sessionState
parameter_list|)
throws|throws
name|Exception
block|{
name|HiveConf
name|newConf
init|=
operator|new
name|HiveConf
argument_list|(
name|initConf
argument_list|)
decl_stmt|;
comment|// TODO Why is this configuration management not happening inside TezSessionPool.
comment|// Makes no senses for it to be mixed up like this.
name|boolean
name|isUsable
init|=
name|sessionState
operator|.
name|tryUse
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|isUsable
condition|)
throw|throw
operator|new
name|IOException
argument_list|(
name|sessionState
operator|+
literal|" is not usable at pool startup"
argument_list|)
throw|;
name|newConf
operator|.
name|set
argument_list|(
name|TezConfiguration
operator|.
name|TEZ_QUEUE_NAME
argument_list|,
name|sessionState
operator|.
name|getQueueName
argument_list|()
argument_list|)
expr_stmt|;
name|sessionState
operator|.
name|open
argument_list|(
name|newConf
argument_list|)
expr_stmt|;
if|if
condition|(
name|sessionState
operator|.
name|returnAfterUse
argument_list|()
condition|)
block|{
name|defaultQueuePool
operator|.
name|put
argument_list|(
name|sessionState
argument_list|)
expr_stmt|;
block|}
block|}
specifier|public
name|void
name|startPool
parameter_list|()
throws|throws
name|Exception
block|{
if|if
condition|(
name|initialSessions
operator|.
name|isEmpty
argument_list|()
condition|)
return|return;
name|int
name|threadCount
init|=
name|Math
operator|.
name|min
argument_list|(
name|initialSessions
operator|.
name|size
argument_list|()
argument_list|,
name|HiveConf
operator|.
name|getIntVar
argument_list|(
name|initConf
argument_list|,
name|ConfVars
operator|.
name|HIVE_SERVER2_TEZ_SESSION_MAX_INIT_THREADS
argument_list|)
argument_list|)
decl_stmt|;
name|Preconditions
operator|.
name|checkArgument
argument_list|(
name|threadCount
operator|>
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|threadCount
operator|==
literal|1
condition|)
block|{
while|while
condition|(
literal|true
condition|)
block|{
name|TezSessionPoolSession
name|session
init|=
name|initialSessions
operator|.
name|poll
argument_list|()
decl_stmt|;
if|if
condition|(
name|session
operator|==
literal|null
condition|)
break|break;
name|startInitialSession
argument_list|(
name|session
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// TODO What is this doing now ?
specifier|final
name|SessionState
name|parentSessionState
init|=
name|SessionState
operator|.
name|get
argument_list|()
decl_stmt|;
comment|// The runnable has no mutable state, so each thread can run the same thing.
specifier|final
name|AtomicReference
argument_list|<
name|Exception
argument_list|>
name|firstError
init|=
operator|new
name|AtomicReference
argument_list|<>
argument_list|(
literal|null
argument_list|)
decl_stmt|;
name|Runnable
name|runnable
init|=
operator|new
name|Runnable
argument_list|()
block|{
specifier|public
name|void
name|run
parameter_list|()
block|{
if|if
condition|(
name|parentSessionState
operator|!=
literal|null
condition|)
block|{
name|SessionState
operator|.
name|setCurrentSessionState
argument_list|(
name|parentSessionState
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
literal|true
condition|)
block|{
name|TezSessionPoolSession
name|session
init|=
name|initialSessions
operator|.
name|poll
argument_list|()
decl_stmt|;
if|if
condition|(
name|session
operator|==
literal|null
condition|)
break|break;
try|try
block|{
name|startInitialSession
argument_list|(
name|session
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
if|if
condition|(
operator|!
name|firstError
operator|.
name|compareAndSet
argument_list|(
literal|null
argument_list|,
name|e
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Failed to start session; ignoring due to previous error"
argument_list|,
name|e
argument_list|)
expr_stmt|;
comment|// TODO Why even continue after this. We're already in a state where things are messed up ?
block|}
block|}
block|}
block|}
block|}
decl_stmt|;
name|Thread
index|[]
name|threads
init|=
operator|new
name|Thread
index|[
name|threadCount
operator|-
literal|1
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|threads
operator|.
name|length
condition|;
operator|++
name|i
control|)
block|{
name|threads
index|[
name|i
index|]
operator|=
operator|new
name|Thread
argument_list|(
name|runnable
argument_list|,
literal|"Tez session init "
operator|+
name|i
argument_list|)
expr_stmt|;
name|threads
index|[
name|i
index|]
operator|.
name|start
argument_list|()
expr_stmt|;
block|}
name|runnable
operator|.
name|run
argument_list|()
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|threads
operator|.
name|length
condition|;
operator|++
name|i
control|)
block|{
name|threads
index|[
name|i
index|]
operator|.
name|join
argument_list|()
expr_stmt|;
block|}
name|Exception
name|ex
init|=
name|firstError
operator|.
name|get
argument_list|()
decl_stmt|;
if|if
condition|(
name|ex
operator|!=
literal|null
condition|)
block|{
throw|throw
name|ex
throw|;
block|}
block|}
if|if
condition|(
name|expirationThread
operator|!=
literal|null
condition|)
block|{
name|expirationThread
operator|.
name|start
argument_list|()
expr_stmt|;
name|restartThread
operator|.
name|start
argument_list|()
expr_stmt|;
block|}
block|}
specifier|public
name|void
name|setupPool
parameter_list|(
name|HiveConf
name|conf
parameter_list|)
throws|throws
name|InterruptedException
block|{
name|String
index|[]
name|defaultQueueList
init|=
name|HiveConf
operator|.
name|getTrimmedStringsVar
argument_list|(
name|conf
argument_list|,
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVE_SERVER2_TEZ_DEFAULT_QUEUES
argument_list|)
decl_stmt|;
name|int
name|emptyNames
init|=
literal|0
decl_stmt|;
comment|// We don't create sessions for empty entries.
for|for
control|(
name|String
name|queueName
range|:
name|defaultQueueList
control|)
block|{
if|if
condition|(
name|queueName
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
operator|++
name|emptyNames
expr_stmt|;
block|}
block|}
name|int
name|numSessions
init|=
name|conf
operator|.
name|getIntVar
argument_list|(
name|ConfVars
operator|.
name|HIVE_SERVER2_TEZ_SESSIONS_PER_DEFAULT_QUEUE
argument_list|)
decl_stmt|;
name|int
name|numSessionsTotal
init|=
name|numSessions
operator|*
operator|(
name|defaultQueueList
operator|.
name|length
operator|-
name|emptyNames
operator|)
decl_stmt|;
if|if
condition|(
name|numSessionsTotal
operator|>
literal|0
condition|)
block|{
name|defaultQueuePool
operator|=
operator|new
name|ArrayBlockingQueue
argument_list|<
name|TezSessionPoolSession
argument_list|>
argument_list|(
name|numSessionsTotal
argument_list|)
expr_stmt|;
block|}
name|numConcurrentLlapQueries
operator|=
name|conf
operator|.
name|getIntVar
argument_list|(
name|ConfVars
operator|.
name|HIVE_SERVER2_LLAP_CONCURRENT_QUERIES
argument_list|)
expr_stmt|;
name|llapQueue
operator|=
operator|new
name|Semaphore
argument_list|(
name|numConcurrentLlapQueries
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|this
operator|.
name|initConf
operator|=
name|conf
expr_stmt|;
name|String
name|queueAllowedStr
init|=
name|HiveConf
operator|.
name|getVar
argument_list|(
name|initConf
argument_list|,
name|ConfVars
operator|.
name|HIVE_SERVER2_TEZ_SESSION_CUSTOM_QUEUE_ALLOWED
argument_list|)
decl_stmt|;
try|try
block|{
name|this
operator|.
name|customQueueAllowed
operator|=
name|CustomQueueAllowed
operator|.
name|valueOf
argument_list|(
name|queueAllowedStr
operator|.
name|toUpperCase
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|ex
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Invalid value '"
operator|+
name|queueAllowedStr
operator|+
literal|"' for "
operator|+
name|ConfVars
operator|.
name|HIVE_SERVER2_TEZ_SESSION_CUSTOM_QUEUE_ALLOWED
operator|.
name|varname
argument_list|)
throw|;
block|}
name|String
index|[]
name|restrictedConfigs
init|=
name|HiveConf
operator|.
name|getTrimmedStringsVar
argument_list|(
name|initConf
argument_list|,
name|ConfVars
operator|.
name|HIVE_SERVER2_TEZ_SESSION_RESTRICTED_CONFIGS
argument_list|)
decl_stmt|;
if|if
condition|(
name|restrictedConfigs
operator|!=
literal|null
operator|&&
name|restrictedConfigs
operator|.
name|length
operator|>
literal|0
condition|)
block|{
name|HashMap
argument_list|<
name|String
argument_list|,
name|ConfVars
argument_list|>
name|confVars
init|=
name|HiveConf
operator|.
name|getOrCreateReverseMap
argument_list|()
decl_stmt|;
for|for
control|(
name|String
name|confName
range|:
name|restrictedConfigs
control|)
block|{
if|if
condition|(
name|confName
operator|==
literal|null
operator|||
name|confName
operator|.
name|isEmpty
argument_list|()
condition|)
continue|continue;
name|confName
operator|=
name|confName
operator|.
name|toLowerCase
argument_list|()
expr_stmt|;
name|ConfVars
name|cv
init|=
name|confVars
operator|.
name|get
argument_list|(
name|confName
argument_list|)
decl_stmt|;
if|if
condition|(
name|cv
operator|!=
literal|null
condition|)
block|{
name|restrictedHiveConf
operator|.
name|add
argument_list|(
name|cv
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"A restricted config "
operator|+
name|confName
operator|+
literal|" is not recognized as a Hive setting."
argument_list|)
expr_stmt|;
name|restrictedNonHiveConf
operator|.
name|add
argument_list|(
name|confName
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|sessionLifetimeMs
operator|=
name|conf
operator|.
name|getTimeVar
argument_list|(
name|ConfVars
operator|.
name|HIVE_SERVER2_TEZ_SESSION_LIFETIME
argument_list|,
name|TimeUnit
operator|.
name|MILLISECONDS
argument_list|)
expr_stmt|;
if|if
condition|(
name|sessionLifetimeMs
operator|!=
literal|0
condition|)
block|{
name|sessionLifetimeJitterMs
operator|=
name|conf
operator|.
name|getTimeVar
argument_list|(
name|ConfVars
operator|.
name|HIVE_SERVER2_TEZ_SESSION_LIFETIME_JITTER
argument_list|,
name|TimeUnit
operator|.
name|MILLISECONDS
argument_list|)
expr_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Session expiration is enabled; session lifetime is "
operator|+
name|sessionLifetimeMs
operator|+
literal|" + [0, "
operator|+
name|sessionLifetimeJitterMs
operator|+
literal|") ms"
argument_list|)
expr_stmt|;
block|}
name|expirationQueue
operator|=
operator|new
name|PriorityBlockingQueue
argument_list|<>
argument_list|(
literal|11
argument_list|,
operator|new
name|Comparator
argument_list|<
name|TezSessionPoolSession
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|int
name|compare
parameter_list|(
name|TezSessionPoolSession
name|o1
parameter_list|,
name|TezSessionPoolSession
name|o2
parameter_list|)
block|{
assert|assert
name|o1
operator|.
name|expirationNs
operator|!=
literal|null
operator|&&
name|o2
operator|.
name|expirationNs
operator|!=
literal|null
assert|;
return|return
name|o1
operator|.
name|expirationNs
operator|.
name|compareTo
argument_list|(
name|o2
operator|.
name|expirationNs
argument_list|)
return|;
block|}
block|}
argument_list|)
expr_stmt|;
name|restartQueue
operator|=
operator|new
name|LinkedBlockingQueue
argument_list|<>
argument_list|()
expr_stmt|;
block|}
name|this
operator|.
name|hasInitialSessions
operator|=
name|numSessionsTotal
operator|>
literal|0
expr_stmt|;
comment|// From this point on, session creation will wait for the default pool (if # of sessions> 0).
if|if
condition|(
name|sessionLifetimeMs
operator|!=
literal|0
condition|)
block|{
name|expirationThread
operator|=
operator|new
name|Thread
argument_list|(
operator|new
name|Runnable
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|void
name|run
parameter_list|()
block|{
name|runExpirationThread
argument_list|()
expr_stmt|;
block|}
block|}
argument_list|,
literal|"TezSessionPool-expiration"
argument_list|)
expr_stmt|;
name|restartThread
operator|=
operator|new
name|Thread
argument_list|(
operator|new
name|Runnable
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|void
name|run
parameter_list|()
block|{
name|runRestartThread
argument_list|()
expr_stmt|;
block|}
block|}
argument_list|,
literal|"TezSessionPool-cleanup"
argument_list|)
expr_stmt|;
block|}
comment|/*      * In a single-threaded init case, with this the ordering of sessions in the queue will be      * (with 2 sessions 3 queues) s1q1, s1q2, s1q3, s2q1, s2q2, s2q3 there by ensuring uniform      * distribution of the sessions across queues at least to begin with. Then as sessions get      * freed up, the list may change this ordering.      * In a multi threaded init case it's a free for all.      */
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numSessions
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|String
name|queueName
range|:
name|defaultQueueList
control|)
block|{
if|if
condition|(
name|queueName
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
continue|continue;
block|}
name|initialSessions
operator|.
name|add
argument_list|(
name|createAndInitSession
argument_list|(
name|queueName
argument_list|,
literal|true
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|// TODO Create and init session sets up queue, isDefault - but does not initialize the configuration
specifier|private
name|TezSessionPoolSession
name|createAndInitSession
parameter_list|(
name|String
name|queue
parameter_list|,
name|boolean
name|isDefault
parameter_list|)
block|{
name|TezSessionPoolSession
name|sessionState
init|=
name|createSession
argument_list|(
name|TezSessionState
operator|.
name|makeSessionId
argument_list|()
argument_list|)
decl_stmt|;
comment|// TODO When will the queue ever be null.
comment|// Pass queue and default in as constructor parameters, and make them final.
if|if
condition|(
name|queue
operator|!=
literal|null
condition|)
block|{
name|sessionState
operator|.
name|setQueueName
argument_list|(
name|queue
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|isDefault
condition|)
block|{
name|sessionState
operator|.
name|setDefault
argument_list|()
expr_stmt|;
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"Created new tez session for queue: "
operator|+
name|queue
operator|+
literal|" with session id: "
operator|+
name|sessionState
operator|.
name|getSessionId
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|sessionState
return|;
block|}
specifier|private
name|TezSessionState
name|getSession
parameter_list|(
name|HiveConf
name|conf
parameter_list|,
name|boolean
name|doOpen
parameter_list|)
throws|throws
name|Exception
block|{
name|String
name|queueName
init|=
name|conf
operator|.
name|get
argument_list|(
literal|"tez.queue.name"
argument_list|)
decl_stmt|;
name|boolean
name|hasQueue
init|=
operator|(
name|queueName
operator|!=
literal|null
operator|)
operator|&&
operator|!
name|queueName
operator|.
name|isEmpty
argument_list|()
decl_stmt|;
if|if
condition|(
name|hasQueue
condition|)
block|{
switch|switch
condition|(
name|customQueueAllowed
condition|)
block|{
case|case
name|FALSE
case|:
throw|throw
operator|new
name|HiveException
argument_list|(
literal|"Specifying tez.queue.name is not allowed"
argument_list|)
throw|;
case|case
name|IGNORE
case|:
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"User has specified "
operator|+
name|queueName
operator|+
literal|" queue; ignoring the setting"
argument_list|)
expr_stmt|;
name|queueName
operator|=
literal|null
expr_stmt|;
name|hasQueue
operator|=
literal|false
expr_stmt|;
name|conf
operator|.
name|unset
argument_list|(
literal|"tez.queue.name"
argument_list|)
expr_stmt|;
block|}
default|default:
comment|// All good.
block|}
block|}
for|for
control|(
name|ConfVars
name|var
range|:
name|restrictedHiveConf
control|)
block|{
name|String
name|userValue
init|=
name|HiveConf
operator|.
name|getVarWithoutType
argument_list|(
name|conf
argument_list|,
name|var
argument_list|)
decl_stmt|,
name|serverValue
init|=
name|HiveConf
operator|.
name|getVarWithoutType
argument_list|(
name|initConf
argument_list|,
name|var
argument_list|)
decl_stmt|;
comment|// Note: with some trickery, we could add logic for each type in ConfVars; for now the
comment|// potential spurious mismatches (e.g. 0 and 0.0 for float) should be easy to work around.
name|validateRestrictedConfigValues
argument_list|(
name|var
operator|.
name|varname
argument_list|,
name|userValue
argument_list|,
name|serverValue
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|String
name|var
range|:
name|restrictedNonHiveConf
control|)
block|{
name|String
name|userValue
init|=
name|conf
operator|.
name|get
argument_list|(
name|var
argument_list|)
decl_stmt|,
name|serverValue
init|=
name|initConf
operator|.
name|get
argument_list|(
name|var
argument_list|)
decl_stmt|;
name|validateRestrictedConfigValues
argument_list|(
name|var
argument_list|,
name|userValue
argument_list|,
name|serverValue
argument_list|)
expr_stmt|;
block|}
comment|// TODO Session re-use completely disabled for doAs=true. Always launches a new session.
name|boolean
name|nonDefaultUser
init|=
name|conf
operator|.
name|getBoolVar
argument_list|(
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVE_SERVER2_ENABLE_DOAS
argument_list|)
decl_stmt|;
comment|/*      * if the user has specified a queue name themselves, we create a new session.      * also a new session is created if the user tries to submit to a queue using      * their own credentials. We expect that with the new security model, things will      * run as user hive in most cases.      */
if|if
condition|(
name|nonDefaultUser
operator|||
operator|!
name|hasInitialSessions
operator|||
name|hasQueue
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"QueueName: {} nonDefaultUser: {} defaultQueuePool: {} hasInitialSessions: {}"
argument_list|,
name|queueName
argument_list|,
name|nonDefaultUser
argument_list|,
name|defaultQueuePool
argument_list|,
name|hasInitialSessions
argument_list|)
expr_stmt|;
return|return
name|getNewSessionState
argument_list|(
name|conf
argument_list|,
name|queueName
argument_list|,
name|doOpen
argument_list|)
return|;
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"Choosing a session from the defaultQueuePool"
argument_list|)
expr_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
name|TezSessionPoolSession
name|result
init|=
name|defaultQueuePool
operator|.
name|take
argument_list|()
decl_stmt|;
if|if
condition|(
name|result
operator|.
name|tryUse
argument_list|()
condition|)
return|return
name|result
return|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Couldn't use a session ["
operator|+
name|result
operator|+
literal|"]; attempting another one"
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|validateRestrictedConfigValues
parameter_list|(
name|String
name|var
parameter_list|,
name|String
name|userValue
parameter_list|,
name|String
name|serverValue
parameter_list|)
throws|throws
name|HiveException
block|{
if|if
condition|(
operator|(
name|userValue
operator|==
literal|null
operator|)
operator|!=
operator|(
name|serverValue
operator|==
literal|null
operator|)
operator|||
operator|(
name|userValue
operator|!=
literal|null
operator|&&
operator|!
name|userValue
operator|.
name|equals
argument_list|(
name|serverValue
argument_list|)
operator|)
condition|)
block|{
name|String
name|logValue
init|=
name|initConf
operator|.
name|isHiddenConfig
argument_list|(
name|var
argument_list|)
condition|?
literal|"(hidden)"
else|:
name|serverValue
decl_stmt|;
throw|throw
operator|new
name|HiveException
argument_list|(
name|var
operator|+
literal|" is restricted from being set; server is configured"
operator|+
literal|" to use "
operator|+
name|logValue
operator|+
literal|", but the query configuration specifies "
operator|+
name|userValue
argument_list|)
throw|;
block|}
block|}
comment|/**    * @param conf HiveConf that is used to initialize the session    * @param queueName could be null. Set in the tez session.    * @param doOpen    * @return    * @throws Exception    */
specifier|private
name|TezSessionState
name|getNewSessionState
parameter_list|(
name|HiveConf
name|conf
parameter_list|,
name|String
name|queueName
parameter_list|,
name|boolean
name|doOpen
parameter_list|)
throws|throws
name|Exception
block|{
name|TezSessionPoolSession
name|retTezSessionState
init|=
name|createAndInitSession
argument_list|(
name|queueName
argument_list|,
literal|false
argument_list|)
decl_stmt|;
if|if
condition|(
name|queueName
operator|!=
literal|null
condition|)
block|{
name|conf
operator|.
name|set
argument_list|(
literal|"tez.queue.name"
argument_list|,
name|queueName
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|doOpen
condition|)
block|{
name|retTezSessionState
operator|.
name|open
argument_list|(
name|conf
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Started a new session for queue: "
operator|+
name|queueName
operator|+
literal|" session id: "
operator|+
name|retTezSessionState
operator|.
name|getSessionId
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|retTezSessionState
return|;
block|}
specifier|public
name|void
name|returnSession
parameter_list|(
name|TezSessionState
name|tezSessionState
parameter_list|,
name|boolean
name|llap
parameter_list|)
throws|throws
name|Exception
block|{
comment|// Ignore the interrupt status while returning the session, but set it back
comment|// on the thread in case anything else needs to deal with it.
name|boolean
name|isInterrupted
init|=
name|Thread
operator|.
name|interrupted
argument_list|()
decl_stmt|;
try|try
block|{
if|if
condition|(
name|isInterrupted
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"returnSession invoked with interrupt status set"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|llap
operator|&&
operator|(
name|this
operator|.
name|numConcurrentLlapQueries
operator|>
literal|0
operator|)
condition|)
block|{
name|llapQueue
operator|.
name|release
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|tezSessionState
operator|.
name|isDefault
argument_list|()
operator|&&
name|tezSessionState
operator|instanceof
name|TezSessionPoolSession
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"The session "
operator|+
name|tezSessionState
operator|.
name|getSessionId
argument_list|()
operator|+
literal|" belongs to the pool. Put it back in"
argument_list|)
expr_stmt|;
name|SessionState
name|sessionState
init|=
name|SessionState
operator|.
name|get
argument_list|()
decl_stmt|;
if|if
condition|(
name|sessionState
operator|!=
literal|null
condition|)
block|{
name|sessionState
operator|.
name|setTezSession
argument_list|(
literal|null
argument_list|)
expr_stmt|;
block|}
name|TezSessionPoolSession
name|poolSession
init|=
operator|(
name|TezSessionPoolSession
operator|)
name|tezSessionState
decl_stmt|;
if|if
condition|(
name|poolSession
operator|.
name|returnAfterUse
argument_list|()
condition|)
block|{
name|defaultQueuePool
operator|.
name|put
argument_list|(
name|poolSession
argument_list|)
expr_stmt|;
block|}
block|}
comment|// non default session nothing changes. The user can continue to use the existing
comment|// session in the SessionState
block|}
finally|finally
block|{
comment|// Reset the interrupt status.
if|if
condition|(
name|isInterrupted
condition|)
block|{
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|interrupt
argument_list|()
expr_stmt|;
block|}
block|}
block|}
specifier|public
specifier|static
name|void
name|closeIfNotDefault
parameter_list|(
name|TezSessionState
name|tezSessionState
parameter_list|,
name|boolean
name|keepTmpDir
parameter_list|)
throws|throws
name|Exception
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Closing tez session if not default: "
operator|+
name|tezSessionState
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|tezSessionState
operator|.
name|isDefault
argument_list|()
condition|)
block|{
name|tezSessionState
operator|.
name|close
argument_list|(
name|keepTmpDir
argument_list|)
expr_stmt|;
block|}
block|}
specifier|public
name|void
name|stop
parameter_list|()
throws|throws
name|Exception
block|{
if|if
condition|(
operator|(
name|sessionPool
operator|==
literal|null
operator|)
operator|||
operator|!
name|this
operator|.
name|hasInitialSessions
condition|)
block|{
return|return;
block|}
name|List
argument_list|<
name|TezSessionPoolSession
argument_list|>
name|sessionsToClose
init|=
literal|null
decl_stmt|;
synchronized|synchronized
init|(
name|openSessions
init|)
block|{
name|sessionsToClose
operator|=
operator|new
name|ArrayList
argument_list|<
name|TezSessionPoolSession
argument_list|>
argument_list|(
name|openSessions
argument_list|)
expr_stmt|;
block|}
comment|// we can just stop all the sessions
for|for
control|(
name|TezSessionState
name|sessionState
range|:
name|sessionsToClose
control|)
block|{
if|if
condition|(
name|sessionState
operator|.
name|isDefault
argument_list|()
condition|)
block|{
name|sessionState
operator|.
name|close
argument_list|(
literal|false
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|expirationThread
operator|!=
literal|null
condition|)
block|{
name|expirationThread
operator|.
name|interrupt
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|restartThread
operator|!=
literal|null
condition|)
block|{
name|restartThread
operator|.
name|interrupt
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * This is called only in extreme cases where even our retry of submit fails. This method would    * close even default sessions and remove it from the queue.    *    * @param tezSessionState    *          the session to be closed    * @throws Exception    */
specifier|public
name|void
name|destroySession
parameter_list|(
name|TezSessionState
name|tezSessionState
parameter_list|)
throws|throws
name|Exception
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"We are closing a "
operator|+
operator|(
name|tezSessionState
operator|.
name|isDefault
argument_list|()
condition|?
literal|"default"
else|:
literal|"non-default"
operator|)
operator|+
literal|" session because of retry failure."
argument_list|)
expr_stmt|;
name|tezSessionState
operator|.
name|close
argument_list|(
literal|false
argument_list|)
expr_stmt|;
block|}
specifier|protected
name|TezSessionPoolSession
name|createSession
parameter_list|(
name|String
name|sessionId
parameter_list|)
block|{
return|return
operator|new
name|TezSessionPoolSession
argument_list|(
name|sessionId
argument_list|,
name|this
argument_list|)
return|;
block|}
comment|/*    * This method helps to re-use a session in case there has been no change in    * the configuration of a session. This will happen only in the case of non-hive-server2    * sessions for e.g. when a CLI session is started. The CLI session could re-use the    * same tez session eliminating the latencies of new AM and containers.    */
specifier|private
specifier|static
name|boolean
name|canWorkWithSameSession
parameter_list|(
name|TezSessionState
name|session
parameter_list|,
name|HiveConf
name|conf
parameter_list|)
throws|throws
name|HiveException
block|{
if|if
condition|(
name|session
operator|==
literal|null
operator|||
name|conf
operator|==
literal|null
condition|)
block|{
return|return
literal|false
return|;
block|}
try|try
block|{
name|UserGroupInformation
name|ugi
init|=
name|Utils
operator|.
name|getUGI
argument_list|()
decl_stmt|;
name|String
name|userName
init|=
name|ugi
operator|.
name|getShortUserName
argument_list|()
decl_stmt|;
comment|// TODO Will these checks work if some other user logs in. Isn't a doAs check required somewhere here as well.
comment|// Should a doAs check happen here instead of after the user test.
comment|// With HiveServer2 - who is the incoming user in terms of UGI (the hive user itself, or the user who actually submitted the query)
comment|// Working in the assumption that the user here will be the hive user if doAs = false, we'll make it past this false check.
name|LOG
operator|.
name|info
argument_list|(
literal|"The current user: "
operator|+
name|userName
operator|+
literal|", session user: "
operator|+
name|session
operator|.
name|getUser
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|userName
operator|.
name|equals
argument_list|(
name|session
operator|.
name|getUser
argument_list|()
argument_list|)
operator|==
literal|false
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Different users incoming: "
operator|+
name|userName
operator|+
literal|" existing: "
operator|+
name|session
operator|.
name|getUser
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|HiveException
argument_list|(
name|e
argument_list|)
throw|;
block|}
name|boolean
name|doAsEnabled
init|=
name|conf
operator|.
name|getBoolVar
argument_list|(
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVE_SERVER2_ENABLE_DOAS
argument_list|)
decl_stmt|;
comment|// either variables will never be null because a default value is returned in case of absence
if|if
condition|(
name|doAsEnabled
operator|!=
name|session
operator|.
name|getConf
argument_list|()
operator|.
name|getBoolVar
argument_list|(
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVE_SERVER2_ENABLE_DOAS
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
if|if
condition|(
operator|!
name|session
operator|.
name|isDefault
argument_list|()
condition|)
block|{
name|String
name|queueName
init|=
name|session
operator|.
name|getQueueName
argument_list|()
decl_stmt|;
name|String
name|confQueueName
init|=
name|conf
operator|.
name|get
argument_list|(
name|TezConfiguration
operator|.
name|TEZ_QUEUE_NAME
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Current queue name is "
operator|+
name|queueName
operator|+
literal|" incoming queue name is "
operator|+
name|confQueueName
argument_list|)
expr_stmt|;
return|return
operator|(
name|queueName
operator|==
literal|null
operator|)
condition|?
name|confQueueName
operator|==
literal|null
else|:
name|queueName
operator|.
name|equals
argument_list|(
name|confQueueName
argument_list|)
return|;
block|}
else|else
block|{
comment|// this session should never be a default session unless something has messed up.
throw|throw
operator|new
name|HiveException
argument_list|(
literal|"The pool session "
operator|+
name|session
operator|+
literal|" should have been returned to the pool"
argument_list|)
throw|;
block|}
block|}
specifier|public
name|TezSessionState
name|getSession
parameter_list|(
name|TezSessionState
name|session
parameter_list|,
name|HiveConf
name|conf
parameter_list|,
name|boolean
name|doOpen
parameter_list|,
name|boolean
name|llap
parameter_list|)
throws|throws
name|Exception
block|{
if|if
condition|(
name|llap
operator|&&
operator|(
name|this
operator|.
name|numConcurrentLlapQueries
operator|>
literal|0
operator|)
condition|)
block|{
name|llapQueue
operator|.
name|acquire
argument_list|()
expr_stmt|;
comment|// blocks if no more llap queries can be submitted.
block|}
if|if
condition|(
name|canWorkWithSameSession
argument_list|(
name|session
argument_list|,
name|conf
argument_list|)
condition|)
block|{
return|return
name|session
return|;
block|}
if|if
condition|(
name|session
operator|!=
literal|null
condition|)
block|{
name|closeIfNotDefault
argument_list|(
name|session
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
return|return
name|getSession
argument_list|(
name|conf
argument_list|,
name|doOpen
argument_list|)
return|;
block|}
comment|/** Reopens the session that was found to not be running. */
specifier|public
name|void
name|reopenSession
parameter_list|(
name|TezSessionState
name|sessionState
parameter_list|,
name|HiveConf
name|conf
parameter_list|,
name|String
index|[]
name|additionalFiles
parameter_list|,
name|boolean
name|keepTmpDir
parameter_list|)
throws|throws
name|Exception
block|{
name|HiveConf
name|sessionConf
init|=
name|sessionState
operator|.
name|getConf
argument_list|()
decl_stmt|;
if|if
condition|(
name|sessionConf
operator|!=
literal|null
operator|&&
name|sessionConf
operator|.
name|get
argument_list|(
name|TezConfiguration
operator|.
name|TEZ_QUEUE_NAME
argument_list|)
operator|!=
literal|null
condition|)
block|{
comment|// user has explicitly specified queue name
name|conf
operator|.
name|set
argument_list|(
name|TezConfiguration
operator|.
name|TEZ_QUEUE_NAME
argument_list|,
name|sessionConf
operator|.
name|get
argument_list|(
name|TezConfiguration
operator|.
name|TEZ_QUEUE_NAME
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// default queue name when the initial session was created
if|if
condition|(
name|sessionState
operator|.
name|getQueueName
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|conf
operator|.
name|set
argument_list|(
name|TezConfiguration
operator|.
name|TEZ_QUEUE_NAME
argument_list|,
name|sessionState
operator|.
name|getQueueName
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
comment|// TODO: close basically resets the object to a bunch of nulls.
comment|//       We should ideally not reuse the object because it's pointless and error-prone.
name|sessionState
operator|.
name|close
argument_list|(
name|keepTmpDir
argument_list|)
expr_stmt|;
comment|// Clean up stuff.
name|sessionState
operator|.
name|open
argument_list|(
name|conf
argument_list|,
name|additionalFiles
argument_list|)
expr_stmt|;
block|}
specifier|public
name|void
name|closeNonDefaultSessions
parameter_list|(
name|boolean
name|keepTmpDir
parameter_list|)
throws|throws
name|Exception
block|{
name|List
argument_list|<
name|TezSessionPoolSession
argument_list|>
name|sessionsToClose
init|=
literal|null
decl_stmt|;
synchronized|synchronized
init|(
name|openSessions
init|)
block|{
name|sessionsToClose
operator|=
operator|new
name|ArrayList
argument_list|<
name|TezSessionPoolSession
argument_list|>
argument_list|(
name|openSessions
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|TezSessionPoolSession
name|sessionState
range|:
name|sessionsToClose
control|)
block|{
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"Shutting down tez session."
argument_list|)
expr_stmt|;
name|closeIfNotDefault
argument_list|(
name|sessionState
argument_list|,
name|keepTmpDir
argument_list|)
expr_stmt|;
block|}
block|}
comment|/** Closes a running (expired) pool session and reopens it. */
specifier|private
name|void
name|closeAndReopenPoolSession
parameter_list|(
name|TezSessionPoolSession
name|oldSession
parameter_list|)
throws|throws
name|Exception
block|{
name|String
name|queueName
init|=
name|oldSession
operator|.
name|getQueueName
argument_list|()
decl_stmt|;
if|if
condition|(
name|queueName
operator|==
literal|null
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Pool session has a null queue: "
operator|+
name|oldSession
argument_list|)
expr_stmt|;
block|}
name|HiveConf
name|conf
init|=
name|oldSession
operator|.
name|getConf
argument_list|()
decl_stmt|;
name|Path
name|scratchDir
init|=
name|oldSession
operator|.
name|getTezScratchDir
argument_list|()
decl_stmt|;
name|boolean
name|isDefault
init|=
name|oldSession
operator|.
name|isDefault
argument_list|()
decl_stmt|;
name|Set
argument_list|<
name|String
argument_list|>
name|additionalFiles
init|=
name|oldSession
operator|.
name|getAdditionalFilesNotFromConf
argument_list|()
decl_stmt|;
try|try
block|{
name|oldSession
operator|.
name|close
argument_list|(
literal|false
argument_list|)
expr_stmt|;
name|defaultQueuePool
operator|.
name|remove
argument_list|(
name|oldSession
argument_list|)
expr_stmt|;
comment|// Make sure it's removed.
block|}
finally|finally
block|{
name|TezSessionPoolSession
name|newSession
init|=
name|createAndInitSession
argument_list|(
name|queueName
argument_list|,
name|isDefault
argument_list|)
decl_stmt|;
comment|// There's some bogus code that can modify the queue name. Force-set it for pool sessions.
name|conf
operator|.
name|set
argument_list|(
name|TezConfiguration
operator|.
name|TEZ_QUEUE_NAME
argument_list|,
name|queueName
argument_list|)
expr_stmt|;
name|newSession
operator|.
name|open
argument_list|(
name|conf
argument_list|,
name|additionalFiles
argument_list|,
name|scratchDir
argument_list|)
expr_stmt|;
name|defaultQueuePool
operator|.
name|put
argument_list|(
name|newSession
argument_list|)
expr_stmt|;
block|}
block|}
comment|/** Logic for the thread that restarts the sessions expired during foreground operations. */
specifier|private
name|void
name|runRestartThread
parameter_list|()
block|{
try|try
block|{
while|while
condition|(
literal|true
condition|)
block|{
name|TezSessionPoolSession
name|next
init|=
name|restartQueue
operator|.
name|take
argument_list|()
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Restarting the expired session ["
operator|+
name|next
operator|+
literal|"]"
argument_list|)
expr_stmt|;
try|try
block|{
name|closeAndReopenPoolSession
argument_list|(
name|next
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|ie
parameter_list|)
block|{
throw|throw
name|ie
throw|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Failed to close or restart a session, ignoring"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Restart thread is exiting due to an interruption"
argument_list|)
expr_stmt|;
block|}
block|}
comment|/** Logic for the thread that tracks session expiration and restarts sessions in background. */
specifier|private
name|void
name|runExpirationThread
parameter_list|()
block|{
try|try
block|{
while|while
condition|(
literal|true
condition|)
block|{
name|TezSessionPoolSession
name|nextToExpire
init|=
literal|null
decl_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
comment|// Restart the sessions until one of them refuses to restart.
name|nextToExpire
operator|=
name|expirationQueue
operator|.
name|take
argument_list|()
expr_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Seeing if we can expire ["
operator|+
name|nextToExpire
operator|+
literal|"]"
argument_list|)
expr_stmt|;
block|}
try|try
block|{
if|if
condition|(
operator|!
name|nextToExpire
operator|.
name|tryExpire
argument_list|(
literal|false
argument_list|)
condition|)
break|break;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
comment|// Reopen happens even when close fails, so there's not much to do here.
name|LOG
operator|.
name|error
argument_list|(
literal|"Failed to expire session "
operator|+
name|nextToExpire
operator|+
literal|"; ignoring"
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|nextToExpire
operator|=
literal|null
expr_stmt|;
break|break;
comment|// Not strictly necessary; do the whole queue check again.
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"Tez session ["
operator|+
name|nextToExpire
operator|+
literal|"] has expired"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|nextToExpire
operator|!=
literal|null
operator|&&
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"["
operator|+
name|nextToExpire
operator|+
literal|"] is not ready to expire; adding it back"
argument_list|)
expr_stmt|;
block|}
comment|// See addToExpirationQueue for why we re-check the queue.
synchronized|synchronized
init|(
name|expirationQueue
init|)
block|{
comment|// Add back the non-expired session. No need to notify, we are the only ones waiting.
if|if
condition|(
name|nextToExpire
operator|!=
literal|null
condition|)
block|{
name|expirationQueue
operator|.
name|add
argument_list|(
name|nextToExpire
argument_list|)
expr_stmt|;
block|}
name|nextToExpire
operator|=
name|expirationQueue
operator|.
name|peek
argument_list|()
expr_stmt|;
if|if
condition|(
name|nextToExpire
operator|!=
literal|null
condition|)
block|{
comment|// Add some margin to the wait to avoid rechecking close to the boundary.
name|long
name|timeToWaitMs
init|=
literal|10
operator|+
operator|(
name|nextToExpire
operator|.
name|expirationNs
operator|-
name|System
operator|.
name|nanoTime
argument_list|()
operator|)
operator|/
literal|1000000L
decl_stmt|;
name|timeToWaitMs
operator|=
name|Math
operator|.
name|max
argument_list|(
literal|1
argument_list|,
name|timeToWaitMs
argument_list|)
expr_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Waiting for ~"
operator|+
name|timeToWaitMs
operator|+
literal|"ms to expire ["
operator|+
name|nextToExpire
operator|+
literal|"]"
argument_list|)
expr_stmt|;
block|}
name|expirationQueue
operator|.
name|wait
argument_list|(
name|timeToWaitMs
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
comment|// Don't wait if empty - go to take() above, that will wait for us.
name|LOG
operator|.
name|debug
argument_list|(
literal|"Expiration queue is empty"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Expiration thread is exiting due to an interruption"
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * TezSession that keeps track of expiration and use.    * It has 3 states - not in use, in use, and expired. When in the pool, it is not in use;    * use and expiration may compete to take the session out of the pool and change it to the    * corresponding states. When someone tries to get a session, they check for expiration time;    * if it's time, the expiration is triggered; in that case, or if it was already triggered, the    * caller gets a different session. When the session is in use when it expires, the expiration    * thread ignores it and lets the return to the pool take care of the expiration.    */
annotation|@
name|VisibleForTesting
specifier|static
class|class
name|TezSessionPoolSession
extends|extends
name|TezSessionState
block|{
specifier|private
specifier|static
specifier|final
name|int
name|STATE_NONE
init|=
literal|0
decl_stmt|,
name|STATE_IN_USE
init|=
literal|1
decl_stmt|,
name|STATE_EXPIRED
init|=
literal|2
decl_stmt|;
specifier|private
specifier|final
name|AtomicInteger
name|sessionState
init|=
operator|new
name|AtomicInteger
argument_list|(
name|STATE_NONE
argument_list|)
decl_stmt|;
specifier|private
name|Long
name|expirationNs
decl_stmt|;
specifier|private
specifier|final
name|TezSessionPoolManager
name|parent
decl_stmt|;
comment|// Static class allows us to be used in tests.
specifier|public
name|TezSessionPoolSession
parameter_list|(
name|String
name|sessionId
parameter_list|,
name|TezSessionPoolManager
name|parent
parameter_list|)
block|{
name|super
argument_list|(
name|sessionId
argument_list|)
expr_stmt|;
name|this
operator|.
name|parent
operator|=
name|parent
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|close
parameter_list|(
name|boolean
name|keepTmpDir
parameter_list|)
throws|throws
name|Exception
block|{
try|try
block|{
name|super
operator|.
name|close
argument_list|(
name|keepTmpDir
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Closed a pool session ["
operator|+
name|this
operator|+
literal|"]"
argument_list|)
expr_stmt|;
block|}
synchronized|synchronized
init|(
name|openSessions
init|)
block|{
name|openSessions
operator|.
name|remove
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|parent
operator|.
name|expirationQueue
operator|!=
literal|null
condition|)
block|{
name|parent
operator|.
name|expirationQueue
operator|.
name|remove
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
block|}
block|}
annotation|@
name|Override
specifier|protected
name|void
name|openInternal
parameter_list|(
name|HiveConf
name|conf
parameter_list|,
name|Collection
argument_list|<
name|String
argument_list|>
name|additionalFiles
parameter_list|,
name|boolean
name|isAsync
parameter_list|,
name|LogHelper
name|console
parameter_list|,
name|Path
name|scratchDir
parameter_list|)
throws|throws
name|IOException
throws|,
name|LoginException
throws|,
name|URISyntaxException
throws|,
name|TezException
block|{
name|super
operator|.
name|openInternal
argument_list|(
name|conf
argument_list|,
name|additionalFiles
argument_list|,
name|isAsync
argument_list|,
name|console
argument_list|,
name|scratchDir
argument_list|)
expr_stmt|;
synchronized|synchronized
init|(
name|openSessions
init|)
block|{
name|openSessions
operator|.
name|add
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|parent
operator|.
name|expirationQueue
operator|!=
literal|null
condition|)
block|{
name|long
name|jitterModMs
init|=
call|(
name|long
call|)
argument_list|(
name|parent
operator|.
name|sessionLifetimeJitterMs
operator|*
name|rdm
operator|.
name|nextFloat
argument_list|()
argument_list|)
decl_stmt|;
name|expirationNs
operator|=
name|System
operator|.
name|nanoTime
argument_list|()
operator|+
operator|(
name|parent
operator|.
name|sessionLifetimeMs
operator|+
name|jitterModMs
operator|)
operator|*
literal|1000000L
expr_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Adding a pool session ["
operator|+
name|this
operator|+
literal|"] to expiration queue"
argument_list|)
expr_stmt|;
block|}
name|parent
operator|.
name|addToExpirationQueue
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|String
name|toString
parameter_list|()
block|{
if|if
condition|(
name|expirationNs
operator|==
literal|null
condition|)
return|return
name|super
operator|.
name|toString
argument_list|()
return|;
name|long
name|expiresInMs
init|=
operator|(
name|expirationNs
operator|-
name|System
operator|.
name|nanoTime
argument_list|()
operator|)
operator|/
literal|1000000L
decl_stmt|;
return|return
name|super
operator|.
name|toString
argument_list|()
operator|+
literal|", expires in "
operator|+
name|expiresInMs
operator|+
literal|"ms"
return|;
block|}
comment|/**      * Tries to use this session. When the session is in use, it will not expire.      * @return true if the session can be used; false if it has already expired.      */
specifier|public
name|boolean
name|tryUse
parameter_list|()
throws|throws
name|Exception
block|{
while|while
condition|(
literal|true
condition|)
block|{
name|int
name|oldValue
init|=
name|sessionState
operator|.
name|get
argument_list|()
decl_stmt|;
if|if
condition|(
name|oldValue
operator|==
name|STATE_IN_USE
condition|)
throw|throw
operator|new
name|AssertionError
argument_list|(
name|this
operator|+
literal|" is already in use"
argument_list|)
throw|;
if|if
condition|(
name|oldValue
operator|==
name|STATE_EXPIRED
condition|)
return|return
literal|false
return|;
name|int
name|finalState
init|=
name|shouldExpire
argument_list|()
condition|?
name|STATE_EXPIRED
else|:
name|STATE_IN_USE
decl_stmt|;
if|if
condition|(
name|sessionState
operator|.
name|compareAndSet
argument_list|(
name|STATE_NONE
argument_list|,
name|finalState
argument_list|)
condition|)
block|{
if|if
condition|(
name|finalState
operator|==
name|STATE_IN_USE
condition|)
return|return
literal|true
return|;
name|closeAndRestartExpiredSession
argument_list|(
literal|true
argument_list|)
expr_stmt|;
comment|// Restart asynchronously, don't block the caller.
return|return
literal|false
return|;
block|}
block|}
block|}
comment|/**      * Notifies the session that it's no longer in use. If the session has expired while in use,      * this method will take care of the expiration.      * @return True if the session was returned, false if it was restarted.      */
specifier|public
name|boolean
name|returnAfterUse
parameter_list|()
throws|throws
name|Exception
block|{
name|int
name|finalState
init|=
name|shouldExpire
argument_list|()
condition|?
name|STATE_EXPIRED
else|:
name|STATE_NONE
decl_stmt|;
if|if
condition|(
operator|!
name|sessionState
operator|.
name|compareAndSet
argument_list|(
name|STATE_IN_USE
argument_list|,
name|finalState
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|AssertionError
argument_list|(
literal|"Unexpected state change; currently "
operator|+
name|sessionState
operator|.
name|get
argument_list|()
argument_list|)
throw|;
block|}
if|if
condition|(
name|finalState
operator|==
name|STATE_NONE
condition|)
return|return
literal|true
return|;
name|closeAndRestartExpiredSession
argument_list|(
literal|true
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
comment|/**      * Tries to expire and restart the session.      * @param isAsync Whether the restart should happen asynchronously.      * @return True if the session was, or will be restarted.      */
specifier|public
name|boolean
name|tryExpire
parameter_list|(
name|boolean
name|isAsync
parameter_list|)
throws|throws
name|Exception
block|{
if|if
condition|(
name|expirationNs
operator|==
literal|null
condition|)
return|return
literal|true
return|;
if|if
condition|(
operator|!
name|shouldExpire
argument_list|()
condition|)
return|return
literal|false
return|;
comment|// Try to expire the session if it's not in use; if in use, bail.
while|while
condition|(
literal|true
condition|)
block|{
if|if
condition|(
name|sessionState
operator|.
name|get
argument_list|()
operator|!=
name|STATE_NONE
condition|)
return|return
literal|true
return|;
comment|// returnAfterUse will take care of this
if|if
condition|(
name|sessionState
operator|.
name|compareAndSet
argument_list|(
name|STATE_NONE
argument_list|,
name|STATE_EXPIRED
argument_list|)
condition|)
block|{
name|closeAndRestartExpiredSession
argument_list|(
name|isAsync
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
block|}
block|}
specifier|private
name|void
name|closeAndRestartExpiredSession
parameter_list|(
name|boolean
name|async
parameter_list|)
throws|throws
name|Exception
block|{
if|if
condition|(
name|async
condition|)
block|{
name|parent
operator|.
name|restartQueue
operator|.
name|add
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|parent
operator|.
name|closeAndReopenPoolSession
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
name|boolean
name|shouldExpire
parameter_list|()
block|{
return|return
name|expirationNs
operator|!=
literal|null
operator|&&
operator|(
name|System
operator|.
name|nanoTime
argument_list|()
operator|-
name|expirationNs
operator|)
operator|>=
literal|0
return|;
block|}
block|}
specifier|private
name|void
name|addToExpirationQueue
parameter_list|(
name|TezSessionPoolSession
name|session
parameter_list|)
block|{
comment|// Expiration queue is synchronized and notified upon when adding elements. Without jitter, we
comment|// wouldn't need this, and could simple look at the first element and sleep for the wait time.
comment|// However, when many things are added at once, it may happen that we will see the one that
comment|// expires later first, and will sleep past the earlier expiration times. When we wake up we
comment|// may kill many sessions at once. To avoid this, we will add to queue under lock and recheck
comment|// time before we wait. We don't have to worry about removals; at worst we'd wake up in vain.
comment|// Example: expirations of 1:03:00, 1:00:00, 1:02:00 are added (in this order due to jitter).
comment|// If the expiration threads sees that 1:03 first, it will sleep for 1:03, then wake up and
comment|// kill all 3 sessions at once because they all have expired, removing any effect from jitter.
comment|// Instead, expiration thread rechecks the first queue item and waits on the queue. If nothing
comment|// is added to the queue, the item examined is still the earliest to be expired. If someone
comment|// adds to the queue while it is waiting, it will notify the thread and it would wake up and
comment|// recheck the queue.
synchronized|synchronized
init|(
name|expirationQueue
init|)
block|{
name|expirationQueue
operator|.
name|add
argument_list|(
name|session
argument_list|)
expr_stmt|;
name|expirationQueue
operator|.
name|notifyAll
argument_list|()
expr_stmt|;
block|}
block|}
block|}
end_class

end_unit

