begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|tez
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|URISyntaxException
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|security
operator|.
name|auth
operator|.
name|login
operator|.
name|LoginException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|tez
operator|.
name|dag
operator|.
name|api
operator|.
name|TezException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|LinkedList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|Semaphore
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|conf
operator|.
name|HiveConf
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|conf
operator|.
name|HiveConf
operator|.
name|ConfVars
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|tez
operator|.
name|TezSessionPoolSession
operator|.
name|Manager
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|metadata
operator|.
name|Hive
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|metadata
operator|.
name|HiveException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|wm
operator|.
name|MetastoreGlobalTriggersFetcher
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|wm
operator|.
name|SessionTriggerProvider
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|wm
operator|.
name|Trigger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|wm
operator|.
name|TriggerActionHandler
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|shims
operator|.
name|Utils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|security
operator|.
name|UserGroupInformation
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|tez
operator|.
name|dag
operator|.
name|api
operator|.
name|TezConfiguration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|VisibleForTesting
import|;
end_import

begin_comment
comment|/**  * This class is for managing multiple tez sessions particularly when  * HiveServer2 is being used to submit queries.  *  * In case the user specifies a queue explicitly, a new session is created  * on that queue and assigned to the session state.  */
end_comment

begin_class
specifier|public
class|class
name|TezSessionPoolManager
extends|extends
name|TezSessionPoolSession
operator|.
name|AbstractTriggerValidator
implements|implements
name|Manager
implements|,
name|SessionExpirationTracker
operator|.
name|RestartImpl
block|{
specifier|private
enum|enum
name|CustomQueueAllowed
block|{
name|TRUE
block|,
name|FALSE
block|,
name|IGNORE
block|}
specifier|private
specifier|static
specifier|final
name|Logger
name|LOG
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|TezSessionPoolManager
operator|.
name|class
argument_list|)
decl_stmt|;
specifier|private
name|Semaphore
name|llapQueue
decl_stmt|;
specifier|private
name|HiveConf
name|initConf
init|=
literal|null
decl_stmt|;
comment|// Config settings.
specifier|private
name|int
name|numConcurrentLlapQueries
init|=
operator|-
literal|1
decl_stmt|;
specifier|private
name|CustomQueueAllowed
name|customQueueAllowed
init|=
name|CustomQueueAllowed
operator|.
name|TRUE
decl_stmt|;
specifier|private
name|TezSessionPool
argument_list|<
name|TezSessionPoolSession
argument_list|>
name|defaultSessionPool
decl_stmt|;
specifier|private
name|SessionExpirationTracker
name|expirationTracker
decl_stmt|;
specifier|private
name|RestrictedConfigChecker
name|restrictedConfig
decl_stmt|;
comment|/**    * Indicates whether we should try to use defaultSessionPool.    * We assume that setupPool is either called before any activity, or not called at all.    */
specifier|private
specifier|volatile
name|boolean
name|hasInitialSessions
init|=
literal|false
decl_stmt|;
specifier|private
specifier|static
name|TezSessionPoolManager
name|instance
init|=
literal|null
decl_stmt|;
comment|/** This is used to close non-default sessions, and also all sessions when stopping. */
specifier|private
specifier|final
name|List
argument_list|<
name|TezSessionState
argument_list|>
name|openSessions
init|=
operator|new
name|LinkedList
argument_list|<>
argument_list|()
decl_stmt|;
specifier|private
name|MetastoreGlobalTriggersFetcher
name|globalTriggersFetcher
decl_stmt|;
specifier|private
name|SessionTriggerProvider
name|sessionTriggerProvider
decl_stmt|;
specifier|private
name|TriggerActionHandler
name|triggerActionHandler
decl_stmt|;
specifier|private
name|TriggerValidatorRunnable
name|triggerValidatorRunnable
decl_stmt|;
comment|/** Note: this is not thread-safe. */
specifier|public
specifier|static
name|TezSessionPoolManager
name|getInstance
parameter_list|()
throws|throws
name|Exception
block|{
name|TezSessionPoolManager
name|local
init|=
name|instance
decl_stmt|;
if|if
condition|(
name|local
operator|==
literal|null
condition|)
block|{
name|instance
operator|=
name|local
operator|=
operator|new
name|TezSessionPoolManager
argument_list|()
expr_stmt|;
block|}
return|return
name|local
return|;
block|}
specifier|protected
name|TezSessionPoolManager
parameter_list|()
block|{   }
specifier|public
name|void
name|startPool
parameter_list|()
throws|throws
name|Exception
block|{
if|if
condition|(
name|defaultSessionPool
operator|!=
literal|null
condition|)
block|{
name|defaultSessionPool
operator|.
name|start
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|expirationTracker
operator|!=
literal|null
condition|)
block|{
name|expirationTracker
operator|.
name|start
argument_list|()
expr_stmt|;
block|}
block|}
specifier|public
name|void
name|setupPool
parameter_list|(
name|HiveConf
name|conf
parameter_list|)
throws|throws
name|Exception
block|{
specifier|final
name|String
index|[]
name|defaultQueueList
init|=
name|HiveConf
operator|.
name|getTrimmedStringsVar
argument_list|(
name|conf
argument_list|,
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVE_SERVER2_TEZ_DEFAULT_QUEUES
argument_list|)
decl_stmt|;
name|this
operator|.
name|initConf
operator|=
name|conf
expr_stmt|;
name|int
name|emptyNames
init|=
literal|0
decl_stmt|;
comment|// We don't create sessions for empty entries.
for|for
control|(
name|String
name|queueName
range|:
name|defaultQueueList
control|)
block|{
if|if
condition|(
name|queueName
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
operator|++
name|emptyNames
expr_stmt|;
block|}
block|}
name|int
name|numSessions
init|=
name|conf
operator|.
name|getIntVar
argument_list|(
name|ConfVars
operator|.
name|HIVE_SERVER2_TEZ_SESSIONS_PER_DEFAULT_QUEUE
argument_list|)
decl_stmt|;
name|int
name|numSessionsTotal
init|=
name|numSessions
operator|*
operator|(
name|defaultQueueList
operator|.
name|length
operator|-
name|emptyNames
operator|)
decl_stmt|;
if|if
condition|(
name|numSessionsTotal
operator|>
literal|0
condition|)
block|{
name|boolean
name|enableAmRegistry
init|=
literal|false
decl_stmt|;
name|defaultSessionPool
operator|=
operator|new
name|TezSessionPool
argument_list|<>
argument_list|(
name|initConf
argument_list|,
name|numSessionsTotal
argument_list|,
name|enableAmRegistry
argument_list|,
operator|new
name|TezSessionPool
operator|.
name|SessionObjectFactory
argument_list|<
name|TezSessionPoolSession
argument_list|>
argument_list|()
block|{
name|int
name|queueIx
init|=
literal|0
decl_stmt|;
annotation|@
name|Override
specifier|public
name|TezSessionPoolSession
name|create
parameter_list|(
name|TezSessionPoolSession
name|oldSession
parameter_list|)
block|{
if|if
condition|(
name|oldSession
operator|!=
literal|null
condition|)
block|{
return|return
name|createAndInitSession
argument_list|(
name|oldSession
operator|.
name|getQueueName
argument_list|()
argument_list|,
name|oldSession
operator|.
name|isDefault
argument_list|()
argument_list|,
name|oldSession
operator|.
name|getConf
argument_list|()
argument_list|)
return|;
block|}
comment|// We never resize the pool, so assume this is initialization.
comment|// If that changes, we might have to make the factory interface more complicated.
comment|/*                * In a single-threaded init case, with this the ordering of sessions in the queue will be                * (with 2 sessions 3 queues) s1q1, s1q2, s1q3, s2q1, s2q2, s2q3 there by ensuring uniform                * distribution of the sessions across queues at least to begin with. Then as sessions get                * freed up, the list may change this ordering.                * In a multi threaded init case it's a free for all.                */
name|int
name|localQueueIx
decl_stmt|;
synchronized|synchronized
init|(
name|defaultQueueList
init|)
block|{
name|localQueueIx
operator|=
name|queueIx
expr_stmt|;
operator|++
name|queueIx
expr_stmt|;
if|if
condition|(
name|queueIx
operator|==
name|defaultQueueList
operator|.
name|length
condition|)
block|{
name|queueIx
operator|=
literal|0
expr_stmt|;
block|}
block|}
name|HiveConf
name|sessionConf
init|=
operator|new
name|HiveConf
argument_list|(
name|initConf
argument_list|)
decl_stmt|;
return|return
name|createAndInitSession
argument_list|(
name|defaultQueueList
index|[
name|localQueueIx
index|]
argument_list|,
literal|true
argument_list|,
name|sessionConf
argument_list|)
return|;
block|}
block|}
argument_list|)
expr_stmt|;
block|}
name|numConcurrentLlapQueries
operator|=
name|conf
operator|.
name|getIntVar
argument_list|(
name|ConfVars
operator|.
name|HIVE_SERVER2_LLAP_CONCURRENT_QUERIES
argument_list|)
expr_stmt|;
name|llapQueue
operator|=
operator|new
name|Semaphore
argument_list|(
name|numConcurrentLlapQueries
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|initTriggers
argument_list|(
name|conf
argument_list|)
expr_stmt|;
name|String
name|queueAllowedStr
init|=
name|HiveConf
operator|.
name|getVar
argument_list|(
name|initConf
argument_list|,
name|ConfVars
operator|.
name|HIVE_SERVER2_TEZ_SESSION_CUSTOM_QUEUE_ALLOWED
argument_list|)
decl_stmt|;
try|try
block|{
name|this
operator|.
name|customQueueAllowed
operator|=
name|CustomQueueAllowed
operator|.
name|valueOf
argument_list|(
name|queueAllowedStr
operator|.
name|toUpperCase
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|ex
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Invalid value '"
operator|+
name|queueAllowedStr
operator|+
literal|"' for "
operator|+
name|ConfVars
operator|.
name|HIVE_SERVER2_TEZ_SESSION_CUSTOM_QUEUE_ALLOWED
operator|.
name|varname
argument_list|)
throw|;
block|}
name|restrictedConfig
operator|=
operator|new
name|RestrictedConfigChecker
argument_list|(
name|conf
argument_list|)
expr_stmt|;
comment|// Only creates the expiration tracker if expiration is configured.
name|expirationTracker
operator|=
name|SessionExpirationTracker
operator|.
name|create
argument_list|(
name|conf
argument_list|,
name|this
argument_list|)
expr_stmt|;
comment|// From this point on, session creation will wait for the default pool (if # of sessions> 0).
name|this
operator|.
name|hasInitialSessions
operator|=
name|numSessionsTotal
operator|>
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|hasInitialSessions
condition|)
block|{
return|return;
block|}
block|}
specifier|public
name|void
name|initTriggers
parameter_list|(
specifier|final
name|HiveConf
name|conf
parameter_list|)
throws|throws
name|HiveException
block|{
if|if
condition|(
name|globalTriggersFetcher
operator|==
literal|null
condition|)
block|{
name|Hive
name|db
init|=
name|Hive
operator|.
name|get
argument_list|(
name|conf
argument_list|)
decl_stmt|;
name|globalTriggersFetcher
operator|=
operator|new
name|MetastoreGlobalTriggersFetcher
argument_list|(
name|db
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|triggerValidatorRunnable
operator|==
literal|null
condition|)
block|{
name|sessionTriggerProvider
operator|=
operator|new
name|SessionTriggerProvider
argument_list|(
name|openSessions
argument_list|,
name|globalTriggersFetcher
operator|.
name|fetch
argument_list|()
argument_list|)
expr_stmt|;
name|triggerActionHandler
operator|=
operator|new
name|KillTriggerActionHandler
argument_list|()
expr_stmt|;
name|triggerValidatorRunnable
operator|=
operator|new
name|TriggerValidatorRunnable
argument_list|(
name|getSessionTriggerProvider
argument_list|()
argument_list|,
name|getTriggerActionHandler
argument_list|()
argument_list|)
expr_stmt|;
name|startTriggerValidator
argument_list|(
name|conf
argument_list|)
expr_stmt|;
block|}
block|}
comment|// TODO Create and init session sets up queue, isDefault - but does not initialize the configuration
specifier|private
name|TezSessionPoolSession
name|createAndInitSession
parameter_list|(
name|String
name|queue
parameter_list|,
name|boolean
name|isDefault
parameter_list|,
name|HiveConf
name|conf
parameter_list|)
block|{
name|TezSessionPoolSession
name|sessionState
init|=
name|createSession
argument_list|(
name|TezSessionState
operator|.
name|makeSessionId
argument_list|()
argument_list|,
name|conf
argument_list|)
decl_stmt|;
comment|// TODO When will the queue ever be null.
comment|// Pass queue and default in as constructor parameters, and make them final.
if|if
condition|(
name|queue
operator|!=
literal|null
condition|)
block|{
name|sessionState
operator|.
name|setQueueName
argument_list|(
name|queue
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|isDefault
condition|)
block|{
name|sessionState
operator|.
name|setDefault
argument_list|()
expr_stmt|;
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"Created new tez session for queue: "
operator|+
name|queue
operator|+
literal|" with session id: "
operator|+
name|sessionState
operator|.
name|getSessionId
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|sessionState
return|;
block|}
specifier|private
name|TezSessionState
name|getSession
parameter_list|(
name|HiveConf
name|conf
parameter_list|,
name|boolean
name|doOpen
parameter_list|)
throws|throws
name|Exception
block|{
comment|// NOTE: this can be called outside of HS2, without calling setupPool. Basically it should be
comment|//       able to handle not being initialized. Perhaps we should get rid of the instance and
comment|//       move the setupPool code to ctor. For now, at least hasInitialSessions will be false.
name|String
name|queueName
init|=
name|conf
operator|.
name|get
argument_list|(
name|TezConfiguration
operator|.
name|TEZ_QUEUE_NAME
argument_list|)
decl_stmt|;
name|boolean
name|hasQueue
init|=
operator|(
name|queueName
operator|!=
literal|null
operator|)
operator|&&
operator|!
name|queueName
operator|.
name|isEmpty
argument_list|()
decl_stmt|;
if|if
condition|(
name|hasQueue
condition|)
block|{
switch|switch
condition|(
name|customQueueAllowed
condition|)
block|{
case|case
name|FALSE
case|:
throw|throw
operator|new
name|HiveException
argument_list|(
literal|"Specifying "
operator|+
name|TezConfiguration
operator|.
name|TEZ_QUEUE_NAME
operator|+
literal|" is not allowed"
argument_list|)
throw|;
case|case
name|IGNORE
case|:
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"User has specified "
operator|+
name|queueName
operator|+
literal|" queue; ignoring the setting"
argument_list|)
expr_stmt|;
name|queueName
operator|=
literal|null
expr_stmt|;
name|hasQueue
operator|=
literal|false
expr_stmt|;
name|conf
operator|.
name|unset
argument_list|(
name|TezConfiguration
operator|.
name|TEZ_QUEUE_NAME
argument_list|)
expr_stmt|;
block|}
default|default:
comment|// All good.
block|}
block|}
comment|// Check the restricted configs that the users cannot set.
if|if
condition|(
name|restrictedConfig
operator|!=
literal|null
condition|)
block|{
name|restrictedConfig
operator|.
name|validate
argument_list|(
name|conf
argument_list|)
expr_stmt|;
block|}
comment|// Propagate this value from HS2; don't allow users to set it.
comment|// In HS2, initConf will be set; it won't be set otherwise as noone calls setupPool.
comment|// TODO: add a section like the restricted configs for overrides when there's more than one.
if|if
condition|(
name|initConf
operator|!=
literal|null
condition|)
block|{
name|conf
operator|.
name|set
argument_list|(
name|ConfVars
operator|.
name|LLAP_CACHE_DEFAULT_FS_FILE_ID
operator|.
name|varname
argument_list|,
name|HiveConf
operator|.
name|getVarWithoutType
argument_list|(
name|initConf
argument_list|,
name|ConfVars
operator|.
name|LLAP_CACHE_DEFAULT_FS_FILE_ID
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// TODO Session re-use completely disabled for doAs=true. Always launches a new session.
name|boolean
name|nonDefaultUser
init|=
name|conf
operator|.
name|getBoolVar
argument_list|(
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVE_SERVER2_ENABLE_DOAS
argument_list|)
decl_stmt|;
comment|/*      * if the user has specified a queue name themselves, we create a new session.      * also a new session is created if the user tries to submit to a queue using      * their own credentials. We expect that with the new security model, things will      * run as user hive in most cases.      */
if|if
condition|(
name|nonDefaultUser
operator|||
operator|!
name|hasInitialSessions
operator|||
name|hasQueue
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"QueueName: {} nonDefaultUser: {} defaultQueuePool: {} hasInitialSessions: {}"
argument_list|,
name|queueName
argument_list|,
name|nonDefaultUser
argument_list|,
name|defaultSessionPool
argument_list|,
name|hasInitialSessions
argument_list|)
expr_stmt|;
return|return
name|getNewSessionState
argument_list|(
name|conf
argument_list|,
name|queueName
argument_list|,
name|doOpen
argument_list|)
return|;
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"Choosing a session from the defaultQueuePool"
argument_list|)
expr_stmt|;
return|return
name|defaultSessionPool
operator|.
name|getSession
argument_list|()
return|;
block|}
comment|/**    * @param conf HiveConf that is used to initialize the session    * @param queueName could be null. Set in the tez session.    * @param doOpen    * @return    * @throws Exception    */
specifier|private
name|TezSessionState
name|getNewSessionState
parameter_list|(
name|HiveConf
name|conf
parameter_list|,
name|String
name|queueName
parameter_list|,
name|boolean
name|doOpen
parameter_list|)
throws|throws
name|Exception
block|{
name|TezSessionPoolSession
name|retTezSessionState
init|=
name|createAndInitSession
argument_list|(
name|queueName
argument_list|,
literal|false
argument_list|,
name|conf
argument_list|)
decl_stmt|;
if|if
condition|(
name|queueName
operator|!=
literal|null
condition|)
block|{
name|conf
operator|.
name|set
argument_list|(
name|TezConfiguration
operator|.
name|TEZ_QUEUE_NAME
argument_list|,
name|queueName
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|doOpen
condition|)
block|{
name|retTezSessionState
operator|.
name|open
argument_list|()
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Started a new session for queue: "
operator|+
name|queueName
operator|+
literal|" session id: "
operator|+
name|retTezSessionState
operator|.
name|getSessionId
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|retTezSessionState
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|returnAfterUse
parameter_list|(
name|TezSessionPoolSession
name|session
parameter_list|)
throws|throws
name|Exception
block|{
name|returnSession
argument_list|(
name|session
argument_list|)
expr_stmt|;
block|}
name|void
name|returnSession
parameter_list|(
name|TezSessionState
name|tezSessionState
parameter_list|)
throws|throws
name|Exception
block|{
comment|// Ignore the interrupt status while returning the session, but set it back
comment|// on the thread in case anything else needs to deal with it.
name|boolean
name|isInterrupted
init|=
name|Thread
operator|.
name|interrupted
argument_list|()
decl_stmt|;
name|boolean
name|llap
init|=
name|tezSessionState
operator|.
name|getLegacyLlapMode
argument_list|()
decl_stmt|;
try|try
block|{
if|if
condition|(
name|isInterrupted
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"returnSession invoked with interrupt status set"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|llap
operator|&&
operator|(
name|this
operator|.
name|numConcurrentLlapQueries
operator|>
literal|0
operator|)
condition|)
block|{
name|llapQueue
operator|.
name|release
argument_list|()
expr_stmt|;
block|}
name|tezSessionState
operator|.
name|setLegacyLlapMode
argument_list|(
literal|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|tezSessionState
operator|.
name|isDefault
argument_list|()
operator|&&
name|tezSessionState
operator|instanceof
name|TezSessionPoolSession
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"The session "
operator|+
name|tezSessionState
operator|.
name|getSessionId
argument_list|()
operator|+
literal|" belongs to the pool. Put it back in"
argument_list|)
expr_stmt|;
name|defaultSessionPool
operator|.
name|returnSession
argument_list|(
operator|(
name|TezSessionPoolSession
operator|)
name|tezSessionState
argument_list|)
expr_stmt|;
block|}
comment|// non default session nothing changes. The user can continue to use the existing
comment|// session in the SessionState
block|}
finally|finally
block|{
comment|// Reset the interrupt status.
if|if
condition|(
name|isInterrupted
condition|)
block|{
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|interrupt
argument_list|()
expr_stmt|;
block|}
block|}
block|}
specifier|public
specifier|static
name|void
name|closeIfNotDefault
parameter_list|(
name|TezSessionState
name|tezSessionState
parameter_list|,
name|boolean
name|keepTmpDir
parameter_list|)
throws|throws
name|Exception
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Closing tez session if not default: "
operator|+
name|tezSessionState
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|tezSessionState
operator|.
name|isDefault
argument_list|()
condition|)
block|{
name|tezSessionState
operator|.
name|close
argument_list|(
name|keepTmpDir
argument_list|)
expr_stmt|;
block|}
block|}
specifier|public
name|void
name|stop
parameter_list|()
throws|throws
name|Exception
block|{
if|if
condition|(
operator|(
name|instance
operator|==
literal|null
operator|)
operator|||
operator|!
name|this
operator|.
name|hasInitialSessions
condition|)
block|{
return|return;
block|}
name|List
argument_list|<
name|TezSessionState
argument_list|>
name|sessionsToClose
init|=
literal|null
decl_stmt|;
synchronized|synchronized
init|(
name|openSessions
init|)
block|{
name|sessionsToClose
operator|=
operator|new
name|ArrayList
argument_list|<
name|TezSessionState
argument_list|>
argument_list|(
name|openSessions
argument_list|)
expr_stmt|;
block|}
comment|// we can just stop all the sessions
for|for
control|(
name|TezSessionState
name|sessionState
range|:
name|sessionsToClose
control|)
block|{
if|if
condition|(
name|sessionState
operator|.
name|isDefault
argument_list|()
condition|)
block|{
name|sessionState
operator|.
name|close
argument_list|(
literal|false
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|expirationTracker
operator|!=
literal|null
condition|)
block|{
name|expirationTracker
operator|.
name|stop
argument_list|()
expr_stmt|;
block|}
name|instance
operator|=
literal|null
expr_stmt|;
block|}
comment|/**    * This is called only in extreme cases where even our retry of submit fails. This method would    * close even default sessions and remove it from the queue.    *    * @param tezSessionState    *          the session to be closed    * @throws Exception    */
annotation|@
name|Override
specifier|public
name|void
name|destroy
parameter_list|(
name|TezSessionState
name|tezSessionState
parameter_list|)
throws|throws
name|Exception
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"We are closing a "
operator|+
operator|(
name|tezSessionState
operator|.
name|isDefault
argument_list|()
condition|?
literal|"default"
else|:
literal|"non-default"
operator|)
operator|+
literal|" session because of retry failure."
argument_list|)
expr_stmt|;
name|tezSessionState
operator|.
name|close
argument_list|(
literal|false
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
name|SessionTriggerProvider
name|getSessionTriggerProvider
parameter_list|()
block|{
return|return
name|sessionTriggerProvider
return|;
block|}
annotation|@
name|Override
name|TriggerActionHandler
name|getTriggerActionHandler
parameter_list|()
block|{
return|return
name|triggerActionHandler
return|;
block|}
annotation|@
name|Override
name|TriggerValidatorRunnable
name|getTriggerValidatorRunnable
parameter_list|()
block|{
return|return
name|triggerValidatorRunnable
return|;
block|}
specifier|protected
name|TezSessionPoolSession
name|createSession
parameter_list|(
name|String
name|sessionId
parameter_list|,
name|HiveConf
name|conf
parameter_list|)
block|{
return|return
operator|new
name|TezSessionPoolSession
argument_list|(
name|sessionId
argument_list|,
name|this
argument_list|,
name|expirationTracker
argument_list|,
name|conf
argument_list|)
return|;
block|}
comment|/*    * This method helps to re-use a session in case there has been no change in    * the configuration of a session. This will happen only in the case of non-hive-server2    * sessions for e.g. when a CLI session is started. The CLI session could re-use the    * same tez session eliminating the latencies of new AM and containers.    */
specifier|private
specifier|static
name|boolean
name|canWorkWithSameSession
parameter_list|(
name|TezSessionState
name|session
parameter_list|,
name|HiveConf
name|conf
parameter_list|)
throws|throws
name|HiveException
block|{
if|if
condition|(
name|session
operator|==
literal|null
operator|||
name|conf
operator|==
literal|null
operator|||
operator|!
name|session
operator|.
name|isOpen
argument_list|()
condition|)
block|{
return|return
literal|false
return|;
block|}
try|try
block|{
name|UserGroupInformation
name|ugi
init|=
name|Utils
operator|.
name|getUGI
argument_list|()
decl_stmt|;
name|String
name|userName
init|=
name|ugi
operator|.
name|getShortUserName
argument_list|()
decl_stmt|;
comment|// TODO Will these checks work if some other user logs in. Isn't a doAs check required somewhere here as well.
comment|// Should a doAs check happen here instead of after the user test.
comment|// With HiveServer2 - who is the incoming user in terms of UGI (the hive user itself, or the user who actually submitted the query)
comment|// Working in the assumption that the user here will be the hive user if doAs = false, we'll make it past this false check.
name|LOG
operator|.
name|info
argument_list|(
literal|"The current user: "
operator|+
name|userName
operator|+
literal|", session user: "
operator|+
name|session
operator|.
name|getUser
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|userName
operator|.
name|equals
argument_list|(
name|session
operator|.
name|getUser
argument_list|()
argument_list|)
operator|==
literal|false
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Different users incoming: "
operator|+
name|userName
operator|+
literal|" existing: "
operator|+
name|session
operator|.
name|getUser
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|HiveException
argument_list|(
name|e
argument_list|)
throw|;
block|}
name|boolean
name|doAsEnabled
init|=
name|conf
operator|.
name|getBoolVar
argument_list|(
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVE_SERVER2_ENABLE_DOAS
argument_list|)
decl_stmt|;
comment|// either variables will never be null because a default value is returned in case of absence
if|if
condition|(
name|doAsEnabled
operator|!=
name|session
operator|.
name|getConf
argument_list|()
operator|.
name|getBoolVar
argument_list|(
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVE_SERVER2_ENABLE_DOAS
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
if|if
condition|(
operator|!
name|session
operator|.
name|isDefault
argument_list|()
condition|)
block|{
name|String
name|queueName
init|=
name|session
operator|.
name|getQueueName
argument_list|()
decl_stmt|;
name|String
name|confQueueName
init|=
name|conf
operator|.
name|get
argument_list|(
name|TezConfiguration
operator|.
name|TEZ_QUEUE_NAME
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Current queue name is "
operator|+
name|queueName
operator|+
literal|" incoming queue name is "
operator|+
name|confQueueName
argument_list|)
expr_stmt|;
return|return
operator|(
name|queueName
operator|==
literal|null
operator|)
condition|?
name|confQueueName
operator|==
literal|null
else|:
name|queueName
operator|.
name|equals
argument_list|(
name|confQueueName
argument_list|)
return|;
block|}
else|else
block|{
comment|// this session should never be a default session unless something has messed up.
throw|throw
operator|new
name|HiveException
argument_list|(
literal|"The pool session "
operator|+
name|session
operator|+
literal|" should have been returned to the pool"
argument_list|)
throw|;
block|}
block|}
specifier|public
name|TezSessionState
name|getSession
parameter_list|(
name|TezSessionState
name|session
parameter_list|,
name|HiveConf
name|conf
parameter_list|,
name|boolean
name|doOpen
parameter_list|,
name|boolean
name|llap
parameter_list|)
throws|throws
name|Exception
block|{
if|if
condition|(
name|llap
operator|&&
operator|(
name|this
operator|.
name|numConcurrentLlapQueries
operator|>
literal|0
operator|)
condition|)
block|{
name|llapQueue
operator|.
name|acquire
argument_list|()
expr_stmt|;
comment|// blocks if no more llap queries can be submitted.
block|}
if|if
condition|(
name|canWorkWithSameSession
argument_list|(
name|session
argument_list|,
name|conf
argument_list|)
condition|)
block|{
name|session
operator|.
name|setLegacyLlapMode
argument_list|(
name|llap
argument_list|)
expr_stmt|;
return|return
name|session
return|;
block|}
if|if
condition|(
name|session
operator|!=
literal|null
condition|)
block|{
name|closeIfNotDefault
argument_list|(
name|session
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
name|session
operator|=
name|getSession
argument_list|(
name|conf
argument_list|,
name|doOpen
argument_list|)
expr_stmt|;
name|session
operator|.
name|setLegacyLlapMode
argument_list|(
name|llap
argument_list|)
expr_stmt|;
return|return
name|session
return|;
block|}
comment|/** Reopens the session that was found to not be running. */
annotation|@
name|Override
specifier|public
name|TezSessionState
name|reopen
parameter_list|(
name|TezSessionState
name|sessionState
parameter_list|,
name|Configuration
name|conf
parameter_list|,
name|String
index|[]
name|additionalFiles
parameter_list|)
throws|throws
name|Exception
block|{
name|HiveConf
name|sessionConf
init|=
name|sessionState
operator|.
name|getConf
argument_list|()
decl_stmt|;
if|if
condition|(
name|sessionState
operator|.
name|getQueueName
argument_list|()
operator|!=
literal|null
operator|&&
name|sessionConf
operator|.
name|get
argument_list|(
name|TezConfiguration
operator|.
name|TEZ_QUEUE_NAME
argument_list|)
operator|==
literal|null
condition|)
block|{
name|sessionConf
operator|.
name|set
argument_list|(
name|TezConfiguration
operator|.
name|TEZ_QUEUE_NAME
argument_list|,
name|sessionState
operator|.
name|getQueueName
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|reopenInternal
argument_list|(
name|sessionState
argument_list|,
name|additionalFiles
argument_list|)
expr_stmt|;
return|return
name|sessionState
return|;
block|}
specifier|static
name|void
name|reopenInternal
parameter_list|(
name|TezSessionState
name|sessionState
parameter_list|,
name|String
index|[]
name|additionalFiles
parameter_list|)
throws|throws
name|Exception
block|{
name|Set
argument_list|<
name|String
argument_list|>
name|oldAdditionalFiles
init|=
name|sessionState
operator|.
name|getAdditionalFilesNotFromConf
argument_list|()
decl_stmt|;
comment|// TODO: implies the session files and the array are the same if not null; why? very brittle
if|if
condition|(
operator|(
name|oldAdditionalFiles
operator|==
literal|null
operator|||
name|oldAdditionalFiles
operator|.
name|isEmpty
argument_list|()
operator|)
operator|&&
operator|(
name|additionalFiles
operator|!=
literal|null
operator|)
condition|)
block|{
name|oldAdditionalFiles
operator|=
operator|new
name|HashSet
argument_list|<>
argument_list|()
expr_stmt|;
for|for
control|(
name|String
name|file
range|:
name|additionalFiles
control|)
block|{
name|oldAdditionalFiles
operator|.
name|add
argument_list|(
name|file
argument_list|)
expr_stmt|;
block|}
block|}
comment|// TODO: close basically resets the object to a bunch of nulls.
comment|//       We should ideally not reuse the object because it's pointless and error-prone.
name|sessionState
operator|.
name|close
argument_list|(
literal|true
argument_list|)
expr_stmt|;
comment|// Note: scratchdir is reused implicitly because the sessionId is the same.
name|sessionState
operator|.
name|open
argument_list|(
name|oldAdditionalFiles
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
specifier|public
name|void
name|closeNonDefaultSessions
parameter_list|(
name|boolean
name|keepTmpDir
parameter_list|)
throws|throws
name|Exception
block|{
name|List
argument_list|<
name|TezSessionState
argument_list|>
name|sessionsToClose
init|=
literal|null
decl_stmt|;
synchronized|synchronized
init|(
name|openSessions
init|)
block|{
name|sessionsToClose
operator|=
operator|new
name|ArrayList
argument_list|<
name|TezSessionState
argument_list|>
argument_list|(
name|openSessions
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|TezSessionState
name|sessionState
range|:
name|sessionsToClose
control|)
block|{
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"Shutting down tez session."
argument_list|)
expr_stmt|;
name|closeIfNotDefault
argument_list|(
name|sessionState
argument_list|,
name|keepTmpDir
argument_list|)
expr_stmt|;
block|}
block|}
comment|/** Closes a running (expired) pool session and reopens it. */
annotation|@
name|Override
specifier|public
name|void
name|closeAndReopenExpiredSession
parameter_list|(
name|TezSessionPoolSession
name|oldSession
parameter_list|)
throws|throws
name|Exception
block|{
name|String
name|queueName
init|=
name|oldSession
operator|.
name|getQueueName
argument_list|()
decl_stmt|;
if|if
condition|(
name|queueName
operator|==
literal|null
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Pool session has a null queue: "
operator|+
name|oldSession
argument_list|)
expr_stmt|;
block|}
name|TezSessionPoolSession
name|newSession
init|=
name|createAndInitSession
argument_list|(
name|queueName
argument_list|,
name|oldSession
operator|.
name|isDefault
argument_list|()
argument_list|,
name|oldSession
operator|.
name|getConf
argument_list|()
argument_list|)
decl_stmt|;
name|defaultSessionPool
operator|.
name|replaceSession
argument_list|(
name|oldSession
argument_list|,
literal|false
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
comment|/** Called by TezSessionPoolSession when opened. */
annotation|@
name|Override
specifier|public
name|void
name|registerOpenSession
parameter_list|(
name|TezSessionPoolSession
name|session
parameter_list|)
block|{
synchronized|synchronized
init|(
name|openSessions
init|)
block|{
name|openSessions
operator|.
name|add
argument_list|(
name|session
argument_list|)
expr_stmt|;
block|}
name|updateSessionsTriggers
argument_list|()
expr_stmt|;
block|}
specifier|private
name|void
name|updateSessionsTriggers
parameter_list|()
block|{
if|if
condition|(
name|sessionTriggerProvider
operator|!=
literal|null
operator|&&
name|globalTriggersFetcher
operator|!=
literal|null
condition|)
block|{
name|sessionTriggerProvider
operator|.
name|setOpenSessions
argument_list|(
name|Collections
operator|.
name|unmodifiableList
argument_list|(
name|openSessions
argument_list|)
argument_list|)
expr_stmt|;
name|sessionTriggerProvider
operator|.
name|setActiveTriggers
argument_list|(
name|Collections
operator|.
name|unmodifiableList
argument_list|(
name|globalTriggersFetcher
operator|.
name|fetch
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/** Called by TezSessionPoolSession when closed. */
annotation|@
name|Override
specifier|public
name|void
name|unregisterOpenSession
parameter_list|(
name|TezSessionPoolSession
name|session
parameter_list|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Closed a pool session ["
operator|+
name|this
operator|+
literal|"]"
argument_list|)
expr_stmt|;
block|}
synchronized|synchronized
init|(
name|openSessions
init|)
block|{
name|openSessions
operator|.
name|remove
argument_list|(
name|session
argument_list|)
expr_stmt|;
block|}
name|updateSessionsTriggers
argument_list|()
expr_stmt|;
block|}
annotation|@
name|VisibleForTesting
specifier|public
name|SessionExpirationTracker
name|getExpirationTracker
parameter_list|()
block|{
return|return
name|expirationTracker
return|;
block|}
annotation|@
name|VisibleForTesting
specifier|public
name|void
name|setGlobalTriggersFetcher
parameter_list|(
name|MetastoreGlobalTriggersFetcher
name|metastoreGlobalTriggersFetcher
parameter_list|)
block|{
name|this
operator|.
name|globalTriggersFetcher
operator|=
name|metastoreGlobalTriggersFetcher
expr_stmt|;
name|updateSessionsTriggers
argument_list|()
expr_stmt|;
block|}
specifier|public
name|List
argument_list|<
name|String
argument_list|>
name|getTriggerCounterNames
parameter_list|()
block|{
name|List
argument_list|<
name|String
argument_list|>
name|counterNames
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
if|if
condition|(
name|sessionTriggerProvider
operator|!=
literal|null
condition|)
block|{
name|List
argument_list|<
name|Trigger
argument_list|>
name|activeTriggers
init|=
name|sessionTriggerProvider
operator|.
name|getActiveTriggers
argument_list|()
decl_stmt|;
for|for
control|(
name|Trigger
name|trigger
range|:
name|activeTriggers
control|)
block|{
name|counterNames
operator|.
name|add
argument_list|(
name|trigger
operator|.
name|getExpression
argument_list|()
operator|.
name|getCounterLimit
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|counterNames
return|;
block|}
block|}
end_class

end_unit

