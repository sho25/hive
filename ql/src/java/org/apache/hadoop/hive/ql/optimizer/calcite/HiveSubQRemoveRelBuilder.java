begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|optimizer
operator|.
name|calcite
package|;
end_package

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|linq4j
operator|.
name|Ord
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|plan
operator|.
name|Context
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|plan
operator|.
name|Contexts
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|plan
operator|.
name|RelOptCluster
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|plan
operator|.
name|RelOptSchema
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|plan
operator|.
name|RelOptTable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|plan
operator|.
name|RelOptUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|RelCollation
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|RelCollations
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|RelFieldCollation
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|RelNode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|core
operator|.
name|Aggregate
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|core
operator|.
name|AggregateCall
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|core
operator|.
name|CorrelationId
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|core
operator|.
name|JoinRelType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|core
operator|.
name|Project
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|core
operator|.
name|RelFactories
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|core
operator|.
name|Sort
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|core
operator|.
name|TableScan
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|core
operator|.
name|Values
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|type
operator|.
name|RelDataType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|type
operator|.
name|RelDataTypeFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|type
operator|.
name|RelDataTypeField
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexBuilder
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexCall
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexCorrelVariable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexInputRef
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexLiteral
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexNode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexShuttle
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|schema
operator|.
name|SchemaPlus
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|server
operator|.
name|CalciteServerStatement
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SemiJoinType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlAggFunction
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlKind
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|SqlOperator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|fun
operator|.
name|SqlStdOperatorTable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|type
operator|.
name|SqlTypeName
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|sql
operator|.
name|validate
operator|.
name|SqlValidatorUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|tools
operator|.
name|RelBuilder
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|tools
operator|.
name|FrameworkConfig
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|tools
operator|.
name|Frameworks
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|CompositeList
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|Holder
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|ImmutableBitSet
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|ImmutableIntList
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|Litmus
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|NlsString
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|Pair
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|Static
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|Util
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|mapping
operator|.
name|Mapping
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|mapping
operator|.
name|Mappings
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Function
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Joiner
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|ImmutableList
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|ImmutableSet
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Iterables
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Lists
import|;
end_import

begin_import
import|import
name|java
operator|.
name|math
operator|.
name|BigDecimal
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|AbstractList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayDeque
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Deque
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|LinkedList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Objects
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|SortedSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|TreeSet
import|;
end_import

begin_comment
comment|/**  * Builder for relational expressions.  * TODO:  *  Note that this is copied from Calcite's RelBulder  *  because CALCITE-1493 hasn't been fixed yet  *  This should be deleted and replaced with RelBuilder in SubqueryRemoveRule  *  once CALCITE-1493 is fixed.  *  *<p>{@code RelBuilder} does not make possible anything that you could not  * also accomplish by calling the factory methods of the particular relational  * expression. But it makes common tasks more straightforward and concise.  *  *<p>{@code RelBuilder} uses factories to create relational expressions.  * By default, it uses the default factories, which create logical relational  * expressions ({@link org.apache.calcite.rel.logical.LogicalFilter},  * {@link org.apache.calcite.rel.logical.LogicalProject} and so forth).  * But you could override those factories so that, say, {@code filter} creates  * instead a {@code HiveFilter}.  *  *<p>It is not thread-safe.  */
end_comment

begin_class
specifier|public
class|class
name|HiveSubQRemoveRelBuilder
block|{
specifier|private
specifier|static
specifier|final
name|Function
argument_list|<
name|RexNode
argument_list|,
name|String
argument_list|>
name|FN_TYPE
init|=
operator|new
name|Function
argument_list|<
name|RexNode
argument_list|,
name|String
argument_list|>
argument_list|()
block|{
specifier|public
name|String
name|apply
parameter_list|(
name|RexNode
name|input
parameter_list|)
block|{
return|return
name|input
operator|+
literal|": "
operator|+
name|input
operator|.
name|getType
argument_list|()
return|;
block|}
block|}
decl_stmt|;
specifier|protected
specifier|final
name|RelOptCluster
name|cluster
decl_stmt|;
specifier|protected
specifier|final
name|RelOptSchema
name|relOptSchema
decl_stmt|;
specifier|private
specifier|final
name|RelFactories
operator|.
name|FilterFactory
name|filterFactory
decl_stmt|;
specifier|private
specifier|final
name|RelFactories
operator|.
name|ProjectFactory
name|projectFactory
decl_stmt|;
specifier|private
specifier|final
name|RelFactories
operator|.
name|AggregateFactory
name|aggregateFactory
decl_stmt|;
specifier|private
specifier|final
name|RelFactories
operator|.
name|SortFactory
name|sortFactory
decl_stmt|;
specifier|private
specifier|final
name|RelFactories
operator|.
name|SetOpFactory
name|setOpFactory
decl_stmt|;
specifier|private
specifier|final
name|RelFactories
operator|.
name|JoinFactory
name|joinFactory
decl_stmt|;
specifier|private
specifier|final
name|RelFactories
operator|.
name|SemiJoinFactory
name|semiJoinFactory
decl_stmt|;
specifier|private
specifier|final
name|RelFactories
operator|.
name|CorrelateFactory
name|correlateFactory
decl_stmt|;
specifier|private
specifier|final
name|RelFactories
operator|.
name|ValuesFactory
name|valuesFactory
decl_stmt|;
specifier|private
specifier|final
name|RelFactories
operator|.
name|TableScanFactory
name|scanFactory
decl_stmt|;
specifier|private
specifier|final
name|Deque
argument_list|<
name|Frame
argument_list|>
name|stack
init|=
operator|new
name|ArrayDeque
argument_list|<>
argument_list|()
decl_stmt|;
specifier|public
name|HiveSubQRemoveRelBuilder
parameter_list|(
name|Context
name|context
parameter_list|,
name|RelOptCluster
name|cluster
parameter_list|,
name|RelOptSchema
name|relOptSchema
parameter_list|)
block|{
name|this
operator|.
name|cluster
operator|=
name|cluster
expr_stmt|;
name|this
operator|.
name|relOptSchema
operator|=
name|relOptSchema
expr_stmt|;
if|if
condition|(
name|context
operator|==
literal|null
condition|)
block|{
name|context
operator|=
name|Contexts
operator|.
name|EMPTY_CONTEXT
expr_stmt|;
block|}
name|this
operator|.
name|aggregateFactory
operator|=
name|Util
operator|.
name|first
argument_list|(
name|context
operator|.
name|unwrap
argument_list|(
name|RelFactories
operator|.
name|AggregateFactory
operator|.
name|class
argument_list|)
argument_list|,
name|RelFactories
operator|.
name|DEFAULT_AGGREGATE_FACTORY
argument_list|)
expr_stmt|;
name|this
operator|.
name|filterFactory
operator|=
name|Util
operator|.
name|first
argument_list|(
name|context
operator|.
name|unwrap
argument_list|(
name|RelFactories
operator|.
name|FilterFactory
operator|.
name|class
argument_list|)
argument_list|,
name|RelFactories
operator|.
name|DEFAULT_FILTER_FACTORY
argument_list|)
expr_stmt|;
name|this
operator|.
name|projectFactory
operator|=
name|Util
operator|.
name|first
argument_list|(
name|context
operator|.
name|unwrap
argument_list|(
name|RelFactories
operator|.
name|ProjectFactory
operator|.
name|class
argument_list|)
argument_list|,
name|RelFactories
operator|.
name|DEFAULT_PROJECT_FACTORY
argument_list|)
expr_stmt|;
name|this
operator|.
name|sortFactory
operator|=
name|Util
operator|.
name|first
argument_list|(
name|context
operator|.
name|unwrap
argument_list|(
name|RelFactories
operator|.
name|SortFactory
operator|.
name|class
argument_list|)
argument_list|,
name|RelFactories
operator|.
name|DEFAULT_SORT_FACTORY
argument_list|)
expr_stmt|;
name|this
operator|.
name|setOpFactory
operator|=
name|Util
operator|.
name|first
argument_list|(
name|context
operator|.
name|unwrap
argument_list|(
name|RelFactories
operator|.
name|SetOpFactory
operator|.
name|class
argument_list|)
argument_list|,
name|RelFactories
operator|.
name|DEFAULT_SET_OP_FACTORY
argument_list|)
expr_stmt|;
name|this
operator|.
name|joinFactory
operator|=
name|Util
operator|.
name|first
argument_list|(
name|context
operator|.
name|unwrap
argument_list|(
name|RelFactories
operator|.
name|JoinFactory
operator|.
name|class
argument_list|)
argument_list|,
name|RelFactories
operator|.
name|DEFAULT_JOIN_FACTORY
argument_list|)
expr_stmt|;
name|this
operator|.
name|semiJoinFactory
operator|=
name|Util
operator|.
name|first
argument_list|(
name|context
operator|.
name|unwrap
argument_list|(
name|RelFactories
operator|.
name|SemiJoinFactory
operator|.
name|class
argument_list|)
argument_list|,
name|RelFactories
operator|.
name|DEFAULT_SEMI_JOIN_FACTORY
argument_list|)
expr_stmt|;
name|this
operator|.
name|correlateFactory
operator|=
name|Util
operator|.
name|first
argument_list|(
name|context
operator|.
name|unwrap
argument_list|(
name|RelFactories
operator|.
name|CorrelateFactory
operator|.
name|class
argument_list|)
argument_list|,
name|RelFactories
operator|.
name|DEFAULT_CORRELATE_FACTORY
argument_list|)
expr_stmt|;
name|this
operator|.
name|valuesFactory
operator|=
name|Util
operator|.
name|first
argument_list|(
name|context
operator|.
name|unwrap
argument_list|(
name|RelFactories
operator|.
name|ValuesFactory
operator|.
name|class
argument_list|)
argument_list|,
name|RelFactories
operator|.
name|DEFAULT_VALUES_FACTORY
argument_list|)
expr_stmt|;
name|this
operator|.
name|scanFactory
operator|=
name|Util
operator|.
name|first
argument_list|(
name|context
operator|.
name|unwrap
argument_list|(
name|RelFactories
operator|.
name|TableScanFactory
operator|.
name|class
argument_list|)
argument_list|,
name|RelFactories
operator|.
name|DEFAULT_TABLE_SCAN_FACTORY
argument_list|)
expr_stmt|;
block|}
comment|/** Creates a RelBuilder. */
specifier|public
specifier|static
name|HiveSubQRemoveRelBuilder
name|create
parameter_list|(
name|FrameworkConfig
name|config
parameter_list|)
block|{
specifier|final
name|RelOptCluster
index|[]
name|clusters
init|=
block|{
literal|null
block|}
decl_stmt|;
specifier|final
name|RelOptSchema
index|[]
name|relOptSchemas
init|=
block|{
literal|null
block|}
decl_stmt|;
name|Frameworks
operator|.
name|withPrepare
argument_list|(
operator|new
name|Frameworks
operator|.
name|PrepareAction
argument_list|<
name|Void
argument_list|>
argument_list|(
name|config
argument_list|)
block|{
specifier|public
name|Void
name|apply
parameter_list|(
name|RelOptCluster
name|cluster
parameter_list|,
name|RelOptSchema
name|relOptSchema
parameter_list|,
name|SchemaPlus
name|rootSchema
parameter_list|,
name|CalciteServerStatement
name|statement
parameter_list|)
block|{
name|clusters
index|[
literal|0
index|]
operator|=
name|cluster
expr_stmt|;
name|relOptSchemas
index|[
literal|0
index|]
operator|=
name|relOptSchema
expr_stmt|;
return|return
literal|null
return|;
block|}
block|}
argument_list|)
expr_stmt|;
return|return
operator|new
name|HiveSubQRemoveRelBuilder
argument_list|(
name|config
operator|.
name|getContext
argument_list|()
argument_list|,
name|clusters
index|[
literal|0
index|]
argument_list|,
name|relOptSchemas
index|[
literal|0
index|]
argument_list|)
return|;
block|}
comment|/** Returns the type factory. */
specifier|public
name|RelDataTypeFactory
name|getTypeFactory
parameter_list|()
block|{
return|return
name|cluster
operator|.
name|getTypeFactory
argument_list|()
return|;
block|}
comment|/** Returns the builder for {@link RexNode} expressions. */
specifier|public
name|RexBuilder
name|getRexBuilder
parameter_list|()
block|{
return|return
name|cluster
operator|.
name|getRexBuilder
argument_list|()
return|;
block|}
comment|/** Adds a relational expression to be the input to the next relational    * expression constructed.    *    *<p>This method is usual when you want to weave in relational expressions    * that are not supported by the builder. If, while creating such expressions,    * you need to use previously built expressions as inputs, call    * {@link #build()} to pop those inputs. */
specifier|public
name|HiveSubQRemoveRelBuilder
name|push
parameter_list|(
name|RelNode
name|node
parameter_list|)
block|{
name|stack
operator|.
name|push
argument_list|(
operator|new
name|Frame
argument_list|(
name|node
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/** Pushes a collection of relational expressions. */
specifier|public
name|HiveSubQRemoveRelBuilder
name|pushAll
parameter_list|(
name|Iterable
argument_list|<
name|?
extends|extends
name|RelNode
argument_list|>
name|nodes
parameter_list|)
block|{
for|for
control|(
name|RelNode
name|node
range|:
name|nodes
control|)
block|{
name|push
argument_list|(
name|node
argument_list|)
expr_stmt|;
block|}
return|return
name|this
return|;
block|}
comment|/** Returns the final relational expression.    *    *<p>Throws if the stack is empty.    */
specifier|public
name|RelNode
name|build
parameter_list|()
block|{
return|return
name|stack
operator|.
name|pop
argument_list|()
operator|.
name|rel
return|;
block|}
comment|/** Returns the relational expression at the top of the stack, but does not    * remove it. */
specifier|public
name|RelNode
name|peek
parameter_list|()
block|{
return|return
name|peek_
argument_list|()
operator|.
name|rel
return|;
block|}
specifier|private
name|Frame
name|peek_
parameter_list|()
block|{
return|return
name|stack
operator|.
name|peek
argument_list|()
return|;
block|}
comment|/** Returns the relational expression {@code n} positions from the top of the    * stack, but does not remove it. */
specifier|public
name|RelNode
name|peek
parameter_list|(
name|int
name|n
parameter_list|)
block|{
return|return
name|peek_
argument_list|(
name|n
argument_list|)
operator|.
name|rel
return|;
block|}
specifier|private
name|Frame
name|peek_
parameter_list|(
name|int
name|n
parameter_list|)
block|{
return|return
name|Iterables
operator|.
name|get
argument_list|(
name|stack
argument_list|,
name|n
argument_list|)
return|;
block|}
comment|/** Returns the relational expression {@code n} positions from the top of the    * stack, but does not remove it. */
specifier|public
name|RelNode
name|peek
parameter_list|(
name|int
name|inputCount
parameter_list|,
name|int
name|inputOrdinal
parameter_list|)
block|{
return|return
name|peek_
argument_list|(
name|inputCount
argument_list|,
name|inputOrdinal
argument_list|)
operator|.
name|rel
return|;
block|}
specifier|private
name|Frame
name|peek_
parameter_list|(
name|int
name|inputCount
parameter_list|,
name|int
name|inputOrdinal
parameter_list|)
block|{
return|return
name|peek_
argument_list|(
name|inputCount
operator|-
literal|1
operator|-
name|inputOrdinal
argument_list|)
return|;
block|}
comment|/** Returns the number of fields in all inputs before (to the left of)    * the given input.    *    * @param inputCount Number of inputs    * @param inputOrdinal Input ordinal    */
specifier|private
name|int
name|inputOffset
parameter_list|(
name|int
name|inputCount
parameter_list|,
name|int
name|inputOrdinal
parameter_list|)
block|{
name|int
name|offset
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|inputOrdinal
condition|;
name|i
operator|++
control|)
block|{
name|offset
operator|+=
name|peek
argument_list|(
name|inputCount
argument_list|,
name|i
argument_list|)
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldCount
argument_list|()
expr_stmt|;
block|}
return|return
name|offset
return|;
block|}
comment|// Methods that return scalar expressions
comment|/** Creates a literal (constant expression). */
specifier|public
name|RexNode
name|literal
parameter_list|(
name|Object
name|value
parameter_list|)
block|{
specifier|final
name|RexBuilder
name|rexBuilder
init|=
name|cluster
operator|.
name|getRexBuilder
argument_list|()
decl_stmt|;
if|if
condition|(
name|value
operator|==
literal|null
condition|)
block|{
return|return
name|rexBuilder
operator|.
name|constantNull
argument_list|()
return|;
block|}
elseif|else
if|if
condition|(
name|value
operator|instanceof
name|Boolean
condition|)
block|{
return|return
name|rexBuilder
operator|.
name|makeLiteral
argument_list|(
operator|(
name|Boolean
operator|)
name|value
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|value
operator|instanceof
name|BigDecimal
condition|)
block|{
return|return
name|rexBuilder
operator|.
name|makeExactLiteral
argument_list|(
operator|(
name|BigDecimal
operator|)
name|value
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|value
operator|instanceof
name|Float
operator|||
name|value
operator|instanceof
name|Double
condition|)
block|{
return|return
name|rexBuilder
operator|.
name|makeApproxLiteral
argument_list|(
name|BigDecimal
operator|.
name|valueOf
argument_list|(
operator|(
operator|(
name|Number
operator|)
name|value
operator|)
operator|.
name|doubleValue
argument_list|()
argument_list|)
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|value
operator|instanceof
name|Number
condition|)
block|{
return|return
name|rexBuilder
operator|.
name|makeExactLiteral
argument_list|(
name|BigDecimal
operator|.
name|valueOf
argument_list|(
operator|(
operator|(
name|Number
operator|)
name|value
operator|)
operator|.
name|longValue
argument_list|()
argument_list|)
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|value
operator|instanceof
name|String
condition|)
block|{
return|return
name|rexBuilder
operator|.
name|makeLiteral
argument_list|(
operator|(
name|String
operator|)
name|value
argument_list|)
return|;
block|}
else|else
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"cannot convert "
operator|+
name|value
operator|+
literal|" ("
operator|+
name|value
operator|.
name|getClass
argument_list|()
operator|+
literal|") to a constant"
argument_list|)
throw|;
block|}
block|}
comment|/** Creates a reference to a field by name.    *    *<p>Equivalent to {@code field(1, 0, fieldName)}.    *    * @param fieldName Field name    */
specifier|public
name|RexInputRef
name|field
parameter_list|(
name|String
name|fieldName
parameter_list|)
block|{
return|return
name|field
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
name|fieldName
argument_list|)
return|;
block|}
comment|/** Creates a reference to a field of given input relational expression    * by name.    *    * @param inputCount Number of inputs    * @param inputOrdinal Input ordinal    * @param fieldName Field name    */
specifier|public
name|RexInputRef
name|field
parameter_list|(
name|int
name|inputCount
parameter_list|,
name|int
name|inputOrdinal
parameter_list|,
name|String
name|fieldName
parameter_list|)
block|{
specifier|final
name|Frame
name|frame
init|=
name|peek_
argument_list|(
name|inputCount
argument_list|,
name|inputOrdinal
argument_list|)
decl_stmt|;
specifier|final
name|List
argument_list|<
name|String
argument_list|>
name|fieldNames
init|=
name|Pair
operator|.
name|left
argument_list|(
name|frame
operator|.
name|fields
argument_list|()
argument_list|)
decl_stmt|;
name|int
name|i
init|=
name|fieldNames
operator|.
name|indexOf
argument_list|(
name|fieldName
argument_list|)
decl_stmt|;
if|if
condition|(
name|i
operator|>=
literal|0
condition|)
block|{
return|return
name|field
argument_list|(
name|inputCount
argument_list|,
name|inputOrdinal
argument_list|,
name|i
argument_list|)
return|;
block|}
else|else
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"field ["
operator|+
name|fieldName
operator|+
literal|"] not found; input fields are: "
operator|+
name|fieldNames
argument_list|)
throw|;
block|}
block|}
comment|/** Creates a reference to an input field by ordinal.    *    *<p>Equivalent to {@code field(1, 0, ordinal)}.    *    * @param fieldOrdinal Field ordinal    */
specifier|public
name|RexInputRef
name|field
parameter_list|(
name|int
name|fieldOrdinal
parameter_list|)
block|{
return|return
operator|(
name|RexInputRef
operator|)
name|field
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
name|fieldOrdinal
argument_list|,
literal|false
argument_list|)
return|;
block|}
comment|/** Creates a reference to a field of a given input relational expression    * by ordinal.    *    * @param inputCount Number of inputs    * @param inputOrdinal Input ordinal    * @param fieldOrdinal Field ordinal within input    */
specifier|public
name|RexInputRef
name|field
parameter_list|(
name|int
name|inputCount
parameter_list|,
name|int
name|inputOrdinal
parameter_list|,
name|int
name|fieldOrdinal
parameter_list|)
block|{
return|return
operator|(
name|RexInputRef
operator|)
name|field
argument_list|(
name|inputCount
argument_list|,
name|inputOrdinal
argument_list|,
name|fieldOrdinal
argument_list|,
literal|false
argument_list|)
return|;
block|}
comment|/** As {@link #field(int, int, int)}, but if {@code alias} is true, the method    * may apply an alias to make sure that the field has the same name as in the    * input frame. If no alias is applied the expression is definitely a    * {@link RexInputRef}. */
specifier|private
name|RexNode
name|field
parameter_list|(
name|int
name|inputCount
parameter_list|,
name|int
name|inputOrdinal
parameter_list|,
name|int
name|fieldOrdinal
parameter_list|,
name|boolean
name|alias
parameter_list|)
block|{
specifier|final
name|Frame
name|frame
init|=
name|peek_
argument_list|(
name|inputCount
argument_list|,
name|inputOrdinal
argument_list|)
decl_stmt|;
specifier|final
name|RelNode
name|input
init|=
name|frame
operator|.
name|rel
decl_stmt|;
specifier|final
name|RelDataType
name|rowType
init|=
name|input
operator|.
name|getRowType
argument_list|()
decl_stmt|;
if|if
condition|(
name|fieldOrdinal
argument_list|<
literal|0
operator|||
name|fieldOrdinal
argument_list|>
name|rowType
operator|.
name|getFieldCount
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"field ordinal ["
operator|+
name|fieldOrdinal
operator|+
literal|"] out of range; input fields are: "
operator|+
name|rowType
operator|.
name|getFieldNames
argument_list|()
argument_list|)
throw|;
block|}
specifier|final
name|RelDataTypeField
name|field
init|=
name|rowType
operator|.
name|getFieldList
argument_list|()
operator|.
name|get
argument_list|(
name|fieldOrdinal
argument_list|)
decl_stmt|;
specifier|final
name|int
name|offset
init|=
name|inputOffset
argument_list|(
name|inputCount
argument_list|,
name|inputOrdinal
argument_list|)
decl_stmt|;
specifier|final
name|RexInputRef
name|ref
init|=
name|cluster
operator|.
name|getRexBuilder
argument_list|()
operator|.
name|makeInputRef
argument_list|(
name|field
operator|.
name|getType
argument_list|()
argument_list|,
name|offset
operator|+
name|fieldOrdinal
argument_list|)
decl_stmt|;
specifier|final
name|RelDataTypeField
name|aliasField
init|=
name|frame
operator|.
name|fields
argument_list|()
operator|.
name|get
argument_list|(
name|fieldOrdinal
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|alias
operator|||
name|field
operator|.
name|getName
argument_list|()
operator|.
name|equals
argument_list|(
name|aliasField
operator|.
name|getName
argument_list|()
argument_list|)
condition|)
block|{
return|return
name|ref
return|;
block|}
else|else
block|{
return|return
name|alias
argument_list|(
name|ref
argument_list|,
name|aliasField
operator|.
name|getName
argument_list|()
argument_list|)
return|;
block|}
block|}
comment|/** Creates a reference to a field of the current record which originated    * in a relation with a given alias. */
specifier|public
name|RexNode
name|field
parameter_list|(
name|String
name|alias
parameter_list|,
name|String
name|fieldName
parameter_list|)
block|{
name|Preconditions
operator|.
name|checkNotNull
argument_list|(
name|alias
argument_list|)
expr_stmt|;
name|Preconditions
operator|.
name|checkNotNull
argument_list|(
name|fieldName
argument_list|)
expr_stmt|;
specifier|final
name|Frame
name|frame
init|=
name|stack
operator|.
name|peek
argument_list|()
decl_stmt|;
specifier|final
name|List
argument_list|<
name|String
argument_list|>
name|aliases
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|int
name|offset
init|=
literal|0
decl_stmt|;
for|for
control|(
name|Pair
argument_list|<
name|String
argument_list|,
name|RelDataType
argument_list|>
name|pair
range|:
name|frame
operator|.
name|right
control|)
block|{
if|if
condition|(
name|pair
operator|.
name|left
operator|!=
literal|null
operator|&&
name|pair
operator|.
name|left
operator|.
name|equals
argument_list|(
name|alias
argument_list|)
condition|)
block|{
name|int
name|i
init|=
name|pair
operator|.
name|right
operator|.
name|getFieldNames
argument_list|()
operator|.
name|indexOf
argument_list|(
name|fieldName
argument_list|)
decl_stmt|;
if|if
condition|(
name|i
operator|>=
literal|0
condition|)
block|{
return|return
name|field
argument_list|(
name|offset
operator|+
name|i
argument_list|)
return|;
block|}
else|else
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"no field '"
operator|+
name|fieldName
operator|+
literal|"' in relation '"
operator|+
name|alias
operator|+
literal|"'; fields are: "
operator|+
name|pair
operator|.
name|right
operator|.
name|getFieldNames
argument_list|()
argument_list|)
throw|;
block|}
block|}
name|aliases
operator|.
name|add
argument_list|(
name|pair
operator|.
name|left
argument_list|)
expr_stmt|;
name|offset
operator|+=
name|pair
operator|.
name|right
operator|.
name|getFieldCount
argument_list|()
expr_stmt|;
block|}
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"no relation wtih alias '"
operator|+
name|alias
operator|+
literal|"'; aliases are: "
operator|+
name|aliases
argument_list|)
throw|;
block|}
comment|/** Returns references to the fields of the top input. */
specifier|public
name|ImmutableList
argument_list|<
name|RexNode
argument_list|>
name|fields
parameter_list|()
block|{
return|return
name|fields
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|)
return|;
block|}
comment|/** Returns references to the fields of a given input. */
specifier|public
name|ImmutableList
argument_list|<
name|RexNode
argument_list|>
name|fields
parameter_list|(
name|int
name|inputCount
parameter_list|,
name|int
name|inputOrdinal
parameter_list|)
block|{
specifier|final
name|RelNode
name|input
init|=
name|peek
argument_list|(
name|inputCount
argument_list|,
name|inputOrdinal
argument_list|)
decl_stmt|;
specifier|final
name|RelDataType
name|rowType
init|=
name|input
operator|.
name|getRowType
argument_list|()
decl_stmt|;
specifier|final
name|ImmutableList
operator|.
name|Builder
argument_list|<
name|RexNode
argument_list|>
name|nodes
init|=
name|ImmutableList
operator|.
name|builder
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|fieldOrdinal
range|:
name|Util
operator|.
name|range
argument_list|(
name|rowType
operator|.
name|getFieldCount
argument_list|()
argument_list|)
control|)
block|{
name|nodes
operator|.
name|add
argument_list|(
name|field
argument_list|(
name|inputCount
argument_list|,
name|inputOrdinal
argument_list|,
name|fieldOrdinal
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|nodes
operator|.
name|build
argument_list|()
return|;
block|}
comment|/** Returns references to fields for a given collation. */
specifier|public
name|ImmutableList
argument_list|<
name|RexNode
argument_list|>
name|fields
parameter_list|(
name|RelCollation
name|collation
parameter_list|)
block|{
specifier|final
name|ImmutableList
operator|.
name|Builder
argument_list|<
name|RexNode
argument_list|>
name|nodes
init|=
name|ImmutableList
operator|.
name|builder
argument_list|()
decl_stmt|;
for|for
control|(
name|RelFieldCollation
name|fieldCollation
range|:
name|collation
operator|.
name|getFieldCollations
argument_list|()
control|)
block|{
name|RexNode
name|node
init|=
name|field
argument_list|(
name|fieldCollation
operator|.
name|getFieldIndex
argument_list|()
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|fieldCollation
operator|.
name|direction
condition|)
block|{
case|case
name|DESCENDING
case|:
name|node
operator|=
name|desc
argument_list|(
name|node
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|fieldCollation
operator|.
name|nullDirection
condition|)
block|{
case|case
name|FIRST
case|:
name|node
operator|=
name|nullsFirst
argument_list|(
name|node
argument_list|)
expr_stmt|;
break|break;
case|case
name|LAST
case|:
name|node
operator|=
name|nullsLast
argument_list|(
name|node
argument_list|)
expr_stmt|;
break|break;
block|}
name|nodes
operator|.
name|add
argument_list|(
name|node
argument_list|)
expr_stmt|;
block|}
return|return
name|nodes
operator|.
name|build
argument_list|()
return|;
block|}
comment|/** Returns references to fields for a given list of input ordinals. */
specifier|public
name|ImmutableList
argument_list|<
name|RexNode
argument_list|>
name|fields
parameter_list|(
name|List
argument_list|<
name|?
extends|extends
name|Number
argument_list|>
name|ordinals
parameter_list|)
block|{
specifier|final
name|ImmutableList
operator|.
name|Builder
argument_list|<
name|RexNode
argument_list|>
name|nodes
init|=
name|ImmutableList
operator|.
name|builder
argument_list|()
decl_stmt|;
for|for
control|(
name|Number
name|ordinal
range|:
name|ordinals
control|)
block|{
name|RexNode
name|node
init|=
name|field
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
name|ordinal
operator|.
name|intValue
argument_list|()
argument_list|,
literal|true
argument_list|)
decl_stmt|;
name|nodes
operator|.
name|add
argument_list|(
name|node
argument_list|)
expr_stmt|;
block|}
return|return
name|nodes
operator|.
name|build
argument_list|()
return|;
block|}
comment|/** Returns references to fields identified by name. */
specifier|public
name|ImmutableList
argument_list|<
name|RexNode
argument_list|>
name|fields
parameter_list|(
name|Iterable
argument_list|<
name|String
argument_list|>
name|fieldNames
parameter_list|)
block|{
specifier|final
name|ImmutableList
operator|.
name|Builder
argument_list|<
name|RexNode
argument_list|>
name|builder
init|=
name|ImmutableList
operator|.
name|builder
argument_list|()
decl_stmt|;
for|for
control|(
name|String
name|fieldName
range|:
name|fieldNames
control|)
block|{
name|builder
operator|.
name|add
argument_list|(
name|field
argument_list|(
name|fieldName
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|builder
operator|.
name|build
argument_list|()
return|;
block|}
comment|/** Returns references to fields identified by a mapping. */
specifier|public
name|ImmutableList
argument_list|<
name|RexNode
argument_list|>
name|fields
parameter_list|(
name|Mappings
operator|.
name|TargetMapping
name|mapping
parameter_list|)
block|{
return|return
name|fields
argument_list|(
name|Mappings
operator|.
name|asList
argument_list|(
name|mapping
argument_list|)
argument_list|)
return|;
block|}
comment|/** Creates an access to a field by name. */
specifier|public
name|RexNode
name|dot
parameter_list|(
name|RexNode
name|node
parameter_list|,
name|String
name|fieldName
parameter_list|)
block|{
specifier|final
name|RexBuilder
name|builder
init|=
name|cluster
operator|.
name|getRexBuilder
argument_list|()
decl_stmt|;
return|return
name|builder
operator|.
name|makeFieldAccess
argument_list|(
name|node
argument_list|,
name|fieldName
argument_list|,
literal|true
argument_list|)
return|;
block|}
comment|/** Creates an access to a field by ordinal. */
specifier|public
name|RexNode
name|dot
parameter_list|(
name|RexNode
name|node
parameter_list|,
name|int
name|fieldOrdinal
parameter_list|)
block|{
specifier|final
name|RexBuilder
name|builder
init|=
name|cluster
operator|.
name|getRexBuilder
argument_list|()
decl_stmt|;
return|return
name|builder
operator|.
name|makeFieldAccess
argument_list|(
name|node
argument_list|,
name|fieldOrdinal
argument_list|)
return|;
block|}
comment|/** Creates a call to a scalar operator. */
specifier|public
name|RexNode
name|call
parameter_list|(
name|SqlOperator
name|operator
parameter_list|,
name|RexNode
modifier|...
name|operands
parameter_list|)
block|{
specifier|final
name|RexBuilder
name|builder
init|=
name|cluster
operator|.
name|getRexBuilder
argument_list|()
decl_stmt|;
specifier|final
name|List
argument_list|<
name|RexNode
argument_list|>
name|operandList
init|=
name|ImmutableList
operator|.
name|copyOf
argument_list|(
name|operands
argument_list|)
decl_stmt|;
specifier|final
name|RelDataType
name|type
init|=
name|builder
operator|.
name|deriveReturnType
argument_list|(
name|operator
argument_list|,
name|operandList
argument_list|)
decl_stmt|;
if|if
condition|(
name|type
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"cannot derive type: "
operator|+
name|operator
operator|+
literal|"; operands: "
operator|+
name|Lists
operator|.
name|transform
argument_list|(
name|operandList
argument_list|,
name|FN_TYPE
argument_list|)
argument_list|)
throw|;
block|}
return|return
name|builder
operator|.
name|makeCall
argument_list|(
name|type
argument_list|,
name|operator
argument_list|,
name|operandList
argument_list|)
return|;
block|}
comment|/** Creates a call to a scalar operator. */
specifier|public
name|RexNode
name|call
parameter_list|(
name|SqlOperator
name|operator
parameter_list|,
name|Iterable
argument_list|<
name|?
extends|extends
name|RexNode
argument_list|>
name|operands
parameter_list|)
block|{
return|return
name|cluster
operator|.
name|getRexBuilder
argument_list|()
operator|.
name|makeCall
argument_list|(
name|operator
argument_list|,
name|ImmutableList
operator|.
name|copyOf
argument_list|(
name|operands
argument_list|)
argument_list|)
return|;
block|}
comment|/** Creates an AND. */
specifier|public
name|RexNode
name|and
parameter_list|(
name|RexNode
modifier|...
name|operands
parameter_list|)
block|{
return|return
name|and
argument_list|(
name|ImmutableList
operator|.
name|copyOf
argument_list|(
name|operands
argument_list|)
argument_list|)
return|;
block|}
comment|/** Creates an AND.    *    *<p>Simplifies the expression a little:    * {@code e AND TRUE} becomes {@code e};    * {@code e AND e2 AND NOT e} becomes {@code e2}. */
specifier|public
name|RexNode
name|and
parameter_list|(
name|Iterable
argument_list|<
name|?
extends|extends
name|RexNode
argument_list|>
name|operands
parameter_list|)
block|{
return|return
name|RexUtil
operator|.
name|simplifyAnds
argument_list|(
name|cluster
operator|.
name|getRexBuilder
argument_list|()
argument_list|,
name|operands
argument_list|)
return|;
block|}
comment|/** Creates an OR. */
specifier|public
name|RexNode
name|or
parameter_list|(
name|RexNode
modifier|...
name|operands
parameter_list|)
block|{
return|return
name|or
argument_list|(
name|ImmutableList
operator|.
name|copyOf
argument_list|(
name|operands
argument_list|)
argument_list|)
return|;
block|}
comment|/** Creates an OR. */
specifier|public
name|RexNode
name|or
parameter_list|(
name|Iterable
argument_list|<
name|?
extends|extends
name|RexNode
argument_list|>
name|operands
parameter_list|)
block|{
return|return
name|RexUtil
operator|.
name|composeDisjunction
argument_list|(
name|cluster
operator|.
name|getRexBuilder
argument_list|()
argument_list|,
name|operands
argument_list|,
literal|false
argument_list|)
return|;
block|}
comment|/** Creates a NOT. */
specifier|public
name|RexNode
name|not
parameter_list|(
name|RexNode
name|operand
parameter_list|)
block|{
return|return
name|call
argument_list|(
name|SqlStdOperatorTable
operator|.
name|NOT
argument_list|,
name|operand
argument_list|)
return|;
block|}
comment|/** Creates an =. */
specifier|public
name|RexNode
name|equals
parameter_list|(
name|RexNode
name|operand0
parameter_list|,
name|RexNode
name|operand1
parameter_list|)
block|{
return|return
name|call
argument_list|(
name|SqlStdOperatorTable
operator|.
name|EQUALS
argument_list|,
name|operand0
argument_list|,
name|operand1
argument_list|)
return|;
block|}
comment|/** Creates a IS NULL. */
specifier|public
name|RexNode
name|isNull
parameter_list|(
name|RexNode
name|operand
parameter_list|)
block|{
return|return
name|call
argument_list|(
name|SqlStdOperatorTable
operator|.
name|IS_NULL
argument_list|,
name|operand
argument_list|)
return|;
block|}
comment|/** Creates a IS NOT NULL. */
specifier|public
name|RexNode
name|isNotNull
parameter_list|(
name|RexNode
name|operand
parameter_list|)
block|{
return|return
name|call
argument_list|(
name|SqlStdOperatorTable
operator|.
name|IS_NOT_NULL
argument_list|,
name|operand
argument_list|)
return|;
block|}
comment|/** Creates an expression that casts an expression to a given type. */
specifier|public
name|RexNode
name|cast
parameter_list|(
name|RexNode
name|expr
parameter_list|,
name|SqlTypeName
name|typeName
parameter_list|)
block|{
specifier|final
name|RelDataType
name|type
init|=
name|cluster
operator|.
name|getTypeFactory
argument_list|()
operator|.
name|createSqlType
argument_list|(
name|typeName
argument_list|)
decl_stmt|;
return|return
name|cluster
operator|.
name|getRexBuilder
argument_list|()
operator|.
name|makeCast
argument_list|(
name|type
argument_list|,
name|expr
argument_list|)
return|;
block|}
comment|/** Creates an expression that casts an expression to a type with a given name    * and precision or length. */
specifier|public
name|RexNode
name|cast
parameter_list|(
name|RexNode
name|expr
parameter_list|,
name|SqlTypeName
name|typeName
parameter_list|,
name|int
name|precision
parameter_list|)
block|{
specifier|final
name|RelDataType
name|type
init|=
name|cluster
operator|.
name|getTypeFactory
argument_list|()
operator|.
name|createSqlType
argument_list|(
name|typeName
argument_list|,
name|precision
argument_list|)
decl_stmt|;
return|return
name|cluster
operator|.
name|getRexBuilder
argument_list|()
operator|.
name|makeCast
argument_list|(
name|type
argument_list|,
name|expr
argument_list|)
return|;
block|}
comment|/** Creates an expression that casts an expression to a type with a given    * name, precision and scale. */
specifier|public
name|RexNode
name|cast
parameter_list|(
name|RexNode
name|expr
parameter_list|,
name|SqlTypeName
name|typeName
parameter_list|,
name|int
name|precision
parameter_list|,
name|int
name|scale
parameter_list|)
block|{
specifier|final
name|RelDataType
name|type
init|=
name|cluster
operator|.
name|getTypeFactory
argument_list|()
operator|.
name|createSqlType
argument_list|(
name|typeName
argument_list|,
name|precision
argument_list|,
name|scale
argument_list|)
decl_stmt|;
return|return
name|cluster
operator|.
name|getRexBuilder
argument_list|()
operator|.
name|makeCast
argument_list|(
name|type
argument_list|,
name|expr
argument_list|)
return|;
block|}
comment|/**    * Returns an expression wrapped in an alias.    *    * @see #project    */
specifier|public
name|RexNode
name|alias
parameter_list|(
name|RexNode
name|expr
parameter_list|,
name|String
name|alias
parameter_list|)
block|{
return|return
name|call
argument_list|(
name|SqlStdOperatorTable
operator|.
name|AS
argument_list|,
name|expr
argument_list|,
name|literal
argument_list|(
name|alias
argument_list|)
argument_list|)
return|;
block|}
comment|/** Converts a sort expression to descending. */
specifier|public
name|RexNode
name|desc
parameter_list|(
name|RexNode
name|node
parameter_list|)
block|{
return|return
name|call
argument_list|(
name|SqlStdOperatorTable
operator|.
name|DESC
argument_list|,
name|node
argument_list|)
return|;
block|}
comment|/** Converts a sort expression to nulls last. */
specifier|public
name|RexNode
name|nullsLast
parameter_list|(
name|RexNode
name|node
parameter_list|)
block|{
return|return
name|call
argument_list|(
name|SqlStdOperatorTable
operator|.
name|NULLS_LAST
argument_list|,
name|node
argument_list|)
return|;
block|}
comment|/** Converts a sort expression to nulls first. */
specifier|public
name|RexNode
name|nullsFirst
parameter_list|(
name|RexNode
name|node
parameter_list|)
block|{
return|return
name|call
argument_list|(
name|SqlStdOperatorTable
operator|.
name|NULLS_FIRST
argument_list|,
name|node
argument_list|)
return|;
block|}
comment|// Methods that create group keys and aggregate calls
comment|/** Creates an empty group key. */
specifier|public
name|GroupKey
name|groupKey
parameter_list|()
block|{
return|return
name|groupKey
argument_list|(
name|ImmutableList
operator|.
expr|<
name|RexNode
operator|>
name|of
argument_list|()
argument_list|)
return|;
block|}
comment|/** Creates a group key. */
specifier|public
name|GroupKey
name|groupKey
parameter_list|(
name|RexNode
modifier|...
name|nodes
parameter_list|)
block|{
return|return
name|groupKey
argument_list|(
name|ImmutableList
operator|.
name|copyOf
argument_list|(
name|nodes
argument_list|)
argument_list|)
return|;
block|}
comment|/** Creates a group key. */
specifier|public
name|GroupKey
name|groupKey
parameter_list|(
name|Iterable
argument_list|<
name|?
extends|extends
name|RexNode
argument_list|>
name|nodes
parameter_list|)
block|{
return|return
operator|new
name|GroupKeyImpl
argument_list|(
name|ImmutableList
operator|.
name|copyOf
argument_list|(
name|nodes
argument_list|)
argument_list|,
literal|false
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
return|;
block|}
comment|/** Creates a group key with grouping sets. */
specifier|public
name|GroupKey
name|groupKey
parameter_list|(
name|Iterable
argument_list|<
name|?
extends|extends
name|RexNode
argument_list|>
name|nodes
parameter_list|,
name|boolean
name|indicator
parameter_list|,
name|Iterable
argument_list|<
name|?
extends|extends
name|Iterable
argument_list|<
name|?
extends|extends
name|RexNode
argument_list|>
argument_list|>
name|nodeLists
parameter_list|)
block|{
specifier|final
name|ImmutableList
operator|.
name|Builder
argument_list|<
name|ImmutableList
argument_list|<
name|RexNode
argument_list|>
argument_list|>
name|builder
init|=
name|ImmutableList
operator|.
name|builder
argument_list|()
decl_stmt|;
for|for
control|(
name|Iterable
argument_list|<
name|?
extends|extends
name|RexNode
argument_list|>
name|nodeList
range|:
name|nodeLists
control|)
block|{
name|builder
operator|.
name|add
argument_list|(
name|ImmutableList
operator|.
name|copyOf
argument_list|(
name|nodeList
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
operator|new
name|GroupKeyImpl
argument_list|(
name|ImmutableList
operator|.
name|copyOf
argument_list|(
name|nodes
argument_list|)
argument_list|,
name|indicator
argument_list|,
name|builder
operator|.
name|build
argument_list|()
argument_list|,
literal|null
argument_list|)
return|;
block|}
comment|/** Creates a group key of fields identified by ordinal. */
specifier|public
name|GroupKey
name|groupKey
parameter_list|(
name|int
modifier|...
name|fieldOrdinals
parameter_list|)
block|{
return|return
name|groupKey
argument_list|(
name|fields
argument_list|(
name|ImmutableIntList
operator|.
name|of
argument_list|(
name|fieldOrdinals
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
comment|/** Creates a group key of fields identified by name. */
specifier|public
name|GroupKey
name|groupKey
parameter_list|(
name|String
modifier|...
name|fieldNames
parameter_list|)
block|{
return|return
name|groupKey
argument_list|(
name|fields
argument_list|(
name|ImmutableList
operator|.
name|copyOf
argument_list|(
name|fieldNames
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
comment|/** Creates a group key with grouping sets, both identified by field positions    * in the underlying relational expression.    *    *<p>This method of creating a group key does not allow you to group on new    * expressions, only column projections, but is efficient, especially when you    * are coming from an existing {@link Aggregate}. */
specifier|public
name|GroupKey
name|groupKey
parameter_list|(
name|ImmutableBitSet
name|groupSet
parameter_list|,
name|boolean
name|indicator
parameter_list|,
name|ImmutableList
argument_list|<
name|ImmutableBitSet
argument_list|>
name|groupSets
parameter_list|)
block|{
if|if
condition|(
name|groupSet
operator|.
name|length
argument_list|()
operator|>
name|peek
argument_list|()
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldCount
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"out of bounds: "
operator|+
name|groupSet
argument_list|)
throw|;
block|}
if|if
condition|(
name|groupSets
operator|==
literal|null
condition|)
block|{
name|groupSets
operator|=
name|ImmutableList
operator|.
name|of
argument_list|(
name|groupSet
argument_list|)
expr_stmt|;
block|}
specifier|final
name|ImmutableList
argument_list|<
name|RexNode
argument_list|>
name|nodes
init|=
name|fields
argument_list|(
name|ImmutableIntList
operator|.
name|of
argument_list|(
name|groupSet
operator|.
name|toArray
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
specifier|final
name|List
argument_list|<
name|ImmutableList
argument_list|<
name|RexNode
argument_list|>
argument_list|>
name|nodeLists
init|=
name|Lists
operator|.
name|transform
argument_list|(
name|groupSets
argument_list|,
operator|new
name|Function
argument_list|<
name|ImmutableBitSet
argument_list|,
name|ImmutableList
argument_list|<
name|RexNode
argument_list|>
argument_list|>
argument_list|()
block|{
specifier|public
name|ImmutableList
argument_list|<
name|RexNode
argument_list|>
name|apply
parameter_list|(
name|ImmutableBitSet
name|input
parameter_list|)
block|{
return|return
name|fields
argument_list|(
name|ImmutableIntList
operator|.
name|of
argument_list|(
name|input
operator|.
name|toArray
argument_list|()
argument_list|)
argument_list|)
return|;
block|}
block|}
argument_list|)
decl_stmt|;
return|return
name|groupKey
argument_list|(
name|nodes
argument_list|,
name|indicator
argument_list|,
name|nodeLists
argument_list|)
return|;
block|}
comment|/** Creates a call to an aggregate function. */
specifier|public
name|AggCall
name|aggregateCall
parameter_list|(
name|SqlAggFunction
name|aggFunction
parameter_list|,
name|boolean
name|distinct
parameter_list|,
name|RexNode
name|filter
parameter_list|,
name|String
name|alias
parameter_list|,
name|RexNode
modifier|...
name|operands
parameter_list|)
block|{
return|return
name|aggregateCall
argument_list|(
name|aggFunction
argument_list|,
name|distinct
argument_list|,
name|filter
argument_list|,
name|alias
argument_list|,
name|ImmutableList
operator|.
name|copyOf
argument_list|(
name|operands
argument_list|)
argument_list|)
return|;
block|}
comment|/** Creates a call to an aggregate function. */
specifier|public
name|AggCall
name|aggregateCall
parameter_list|(
name|SqlAggFunction
name|aggFunction
parameter_list|,
name|boolean
name|distinct
parameter_list|,
name|RexNode
name|filter
parameter_list|,
name|String
name|alias
parameter_list|,
name|Iterable
argument_list|<
name|?
extends|extends
name|RexNode
argument_list|>
name|operands
parameter_list|)
block|{
if|if
condition|(
name|filter
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|filter
operator|.
name|getType
argument_list|()
operator|.
name|getSqlTypeName
argument_list|()
operator|!=
name|SqlTypeName
operator|.
name|BOOLEAN
condition|)
block|{
throw|throw
name|Static
operator|.
name|RESOURCE
operator|.
name|filterMustBeBoolean
argument_list|()
operator|.
name|ex
argument_list|()
throw|;
block|}
if|if
condition|(
name|filter
operator|.
name|getType
argument_list|()
operator|.
name|isNullable
argument_list|()
condition|)
block|{
name|filter
operator|=
name|call
argument_list|(
name|SqlStdOperatorTable
operator|.
name|IS_TRUE
argument_list|,
name|filter
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|new
name|AggCallImpl
argument_list|(
name|aggFunction
argument_list|,
name|distinct
argument_list|,
name|filter
argument_list|,
name|alias
argument_list|,
name|ImmutableList
operator|.
name|copyOf
argument_list|(
name|operands
argument_list|)
argument_list|)
return|;
block|}
comment|/** Creates a call to the COUNT aggregate function. */
specifier|public
name|AggCall
name|count
parameter_list|(
name|boolean
name|distinct
parameter_list|,
name|String
name|alias
parameter_list|,
name|RexNode
modifier|...
name|operands
parameter_list|)
block|{
return|return
name|aggregateCall
argument_list|(
name|SqlStdOperatorTable
operator|.
name|COUNT
argument_list|,
name|distinct
argument_list|,
literal|null
argument_list|,
name|alias
argument_list|,
name|operands
argument_list|)
return|;
block|}
comment|/** Creates a call to the COUNT(*) aggregate function. */
specifier|public
name|AggCall
name|countStar
parameter_list|(
name|String
name|alias
parameter_list|)
block|{
return|return
name|aggregateCall
argument_list|(
name|SqlStdOperatorTable
operator|.
name|COUNT
argument_list|,
literal|false
argument_list|,
literal|null
argument_list|,
name|alias
argument_list|)
return|;
block|}
comment|/** Creates a call to the SUM aggregate function. */
specifier|public
name|AggCall
name|sum
parameter_list|(
name|boolean
name|distinct
parameter_list|,
name|String
name|alias
parameter_list|,
name|RexNode
name|operand
parameter_list|)
block|{
return|return
name|aggregateCall
argument_list|(
name|SqlStdOperatorTable
operator|.
name|SUM
argument_list|,
name|distinct
argument_list|,
literal|null
argument_list|,
name|alias
argument_list|,
name|operand
argument_list|)
return|;
block|}
comment|/** Creates a call to the AVG aggregate function. */
specifier|public
name|AggCall
name|avg
parameter_list|(
name|boolean
name|distinct
parameter_list|,
name|String
name|alias
parameter_list|,
name|RexNode
name|operand
parameter_list|)
block|{
return|return
name|aggregateCall
argument_list|(
name|SqlStdOperatorTable
operator|.
name|AVG
argument_list|,
name|distinct
argument_list|,
literal|null
argument_list|,
name|alias
argument_list|,
name|operand
argument_list|)
return|;
block|}
comment|/** Creates a call to the MIN aggregate function. */
specifier|public
name|AggCall
name|min
parameter_list|(
name|String
name|alias
parameter_list|,
name|RexNode
name|operand
parameter_list|)
block|{
return|return
name|aggregateCall
argument_list|(
name|SqlStdOperatorTable
operator|.
name|MIN
argument_list|,
literal|false
argument_list|,
literal|null
argument_list|,
name|alias
argument_list|,
name|operand
argument_list|)
return|;
block|}
comment|/** Creates a call to the MAX aggregate function. */
specifier|public
name|AggCall
name|max
parameter_list|(
name|String
name|alias
parameter_list|,
name|RexNode
name|operand
parameter_list|)
block|{
return|return
name|aggregateCall
argument_list|(
name|SqlStdOperatorTable
operator|.
name|MAX
argument_list|,
literal|false
argument_list|,
literal|null
argument_list|,
name|alias
argument_list|,
name|operand
argument_list|)
return|;
block|}
comment|// Methods that create relational expressions
comment|/** Creates a {@link org.apache.calcite.rel.core.TableScan} of the table    * with a given name.    *    *<p>Throws if the table does not exist.    *    *<p>Returns this builder.    *    * @param tableNames Name of table (can optionally be qualified)    */
specifier|public
name|HiveSubQRemoveRelBuilder
name|scan
parameter_list|(
name|Iterable
argument_list|<
name|String
argument_list|>
name|tableNames
parameter_list|)
block|{
specifier|final
name|List
argument_list|<
name|String
argument_list|>
name|names
init|=
name|ImmutableList
operator|.
name|copyOf
argument_list|(
name|tableNames
argument_list|)
decl_stmt|;
specifier|final
name|RelOptTable
name|relOptTable
init|=
name|relOptSchema
operator|.
name|getTableForMember
argument_list|(
name|names
argument_list|)
decl_stmt|;
if|if
condition|(
name|relOptTable
operator|==
literal|null
condition|)
block|{
throw|throw
name|Static
operator|.
name|RESOURCE
operator|.
name|tableNotFound
argument_list|(
name|Joiner
operator|.
name|on
argument_list|(
literal|"."
argument_list|)
operator|.
name|join
argument_list|(
name|names
argument_list|)
argument_list|)
operator|.
name|ex
argument_list|()
throw|;
block|}
specifier|final
name|RelNode
name|scan
init|=
name|scanFactory
operator|.
name|createScan
argument_list|(
name|cluster
argument_list|,
name|relOptTable
argument_list|)
decl_stmt|;
name|push
argument_list|(
name|scan
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/** Creates a {@link org.apache.calcite.rel.core.TableScan} of the table    * with a given name.    *    *<p>Throws if the table does not exist.    *    *<p>Returns this builder.    *    * @param tableNames Name of table (can optionally be qualified)    */
specifier|public
name|HiveSubQRemoveRelBuilder
name|scan
parameter_list|(
name|String
modifier|...
name|tableNames
parameter_list|)
block|{
return|return
name|scan
argument_list|(
name|ImmutableList
operator|.
name|copyOf
argument_list|(
name|tableNames
argument_list|)
argument_list|)
return|;
block|}
comment|/** Creates a {@link org.apache.calcite.rel.core.Filter} of an array of    * predicates.    *    *<p>The predicates are combined using AND,    * and optimized in a similar way to the {@link #and} method.    * If the result is TRUE no filter is created. */
specifier|public
name|HiveSubQRemoveRelBuilder
name|filter
parameter_list|(
name|RexNode
modifier|...
name|predicates
parameter_list|)
block|{
return|return
name|filter
argument_list|(
name|ImmutableList
operator|.
name|copyOf
argument_list|(
name|predicates
argument_list|)
argument_list|)
return|;
block|}
comment|/** Creates a {@link org.apache.calcite.rel.core.Filter} of a list of    * predicates.    *    *<p>The predicates are combined using AND,    * and optimized in a similar way to the {@link #and} method.    * If the result is TRUE no filter is created. */
specifier|public
name|HiveSubQRemoveRelBuilder
name|filter
parameter_list|(
name|Iterable
argument_list|<
name|?
extends|extends
name|RexNode
argument_list|>
name|predicates
parameter_list|)
block|{
specifier|final
name|RexNode
name|x
init|=
name|RexUtil
operator|.
name|simplifyAnds
argument_list|(
name|cluster
operator|.
name|getRexBuilder
argument_list|()
argument_list|,
name|predicates
argument_list|,
literal|true
argument_list|)
decl_stmt|;
if|if
condition|(
name|x
operator|.
name|isAlwaysFalse
argument_list|()
condition|)
block|{
return|return
name|empty
argument_list|()
return|;
block|}
if|if
condition|(
operator|!
name|x
operator|.
name|isAlwaysTrue
argument_list|()
condition|)
block|{
specifier|final
name|Frame
name|frame
init|=
name|stack
operator|.
name|pop
argument_list|()
decl_stmt|;
specifier|final
name|RelNode
name|filter
init|=
name|filterFactory
operator|.
name|createFilter
argument_list|(
name|frame
operator|.
name|rel
argument_list|,
name|x
argument_list|)
decl_stmt|;
name|stack
operator|.
name|push
argument_list|(
operator|new
name|Frame
argument_list|(
name|filter
argument_list|,
name|frame
operator|.
name|right
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|this
return|;
block|}
comment|/** Creates a {@link org.apache.calcite.rel.core.Project} of the given list    * of expressions.    *    *<p>Infers names as would {@link #project(Iterable, Iterable)} if all    * suggested names were null.    *    * @param nodes Expressions    */
specifier|public
name|HiveSubQRemoveRelBuilder
name|project
parameter_list|(
name|Iterable
argument_list|<
name|?
extends|extends
name|RexNode
argument_list|>
name|nodes
parameter_list|)
block|{
return|return
name|project
argument_list|(
name|nodes
argument_list|,
name|ImmutableList
operator|.
expr|<
name|String
operator|>
name|of
argument_list|()
argument_list|)
return|;
block|}
comment|/** Creates a {@link org.apache.calcite.rel.core.Project} of the given list    * of expressions and field names.    *    *<p>Infers names as would {@link #project(Iterable, Iterable)} if all    * suggested names were null.    *    * @param nodes Expressions    * @param fieldNames field names for expressions    */
specifier|public
name|HiveSubQRemoveRelBuilder
name|project
parameter_list|(
name|Iterable
argument_list|<
name|?
extends|extends
name|RexNode
argument_list|>
name|nodes
parameter_list|,
name|Iterable
argument_list|<
name|String
argument_list|>
name|fieldNames
parameter_list|)
block|{
return|return
name|project
argument_list|(
name|nodes
argument_list|,
name|fieldNames
argument_list|,
literal|false
argument_list|)
return|;
block|}
comment|/** Creates a {@link org.apache.calcite.rel.core.Project} of the given list    * of expressions, using the given names.    *    *<p>Names are deduced as follows:    *<ul>    *<li>If the length of {@code fieldNames} is greater than the index of    *     the current entry in {@code nodes}, and the entry in    *     {@code fieldNames} is not null, uses it; otherwise    *<li>If an expression projects an input field,    *     or is a cast an input field,    *     uses the input field name; otherwise    *<li>If an expression is a call to    *     {@link org.apache.calcite.sql.fun.SqlStdOperatorTable#AS}    *     (see {@link #alias}), removes the call but uses the intended alias.    *</ul>    *    *<p>After the field names have been inferred, makes the    * field names unique by appending numeric suffixes.    *    * @param nodes Expressions    * @param fieldNames Suggested field names    * @param force create project even if it is identity    */
specifier|public
name|HiveSubQRemoveRelBuilder
name|project
parameter_list|(
name|Iterable
argument_list|<
name|?
extends|extends
name|RexNode
argument_list|>
name|nodes
parameter_list|,
name|Iterable
argument_list|<
name|String
argument_list|>
name|fieldNames
parameter_list|,
name|boolean
name|force
parameter_list|)
block|{
specifier|final
name|List
argument_list|<
name|String
argument_list|>
name|names
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
specifier|final
name|List
argument_list|<
name|RexNode
argument_list|>
name|exprList
init|=
name|Lists
operator|.
name|newArrayList
argument_list|(
name|nodes
argument_list|)
decl_stmt|;
specifier|final
name|Iterator
argument_list|<
name|String
argument_list|>
name|nameIterator
init|=
name|fieldNames
operator|.
name|iterator
argument_list|()
decl_stmt|;
for|for
control|(
name|RexNode
name|node
range|:
name|nodes
control|)
block|{
specifier|final
name|String
name|name
init|=
name|nameIterator
operator|.
name|hasNext
argument_list|()
condition|?
name|nameIterator
operator|.
name|next
argument_list|()
else|:
literal|null
decl_stmt|;
specifier|final
name|String
name|name2
init|=
name|inferAlias
argument_list|(
name|exprList
argument_list|,
name|node
argument_list|)
decl_stmt|;
name|names
operator|.
name|add
argument_list|(
name|Util
operator|.
name|first
argument_list|(
name|name
argument_list|,
name|name2
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|final
name|RelDataType
name|inputRowType
init|=
name|peek
argument_list|()
operator|.
name|getRowType
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|force
operator|&&
name|RexUtil
operator|.
name|isIdentity
argument_list|(
name|exprList
argument_list|,
name|inputRowType
argument_list|)
condition|)
block|{
if|if
condition|(
name|names
operator|.
name|equals
argument_list|(
name|inputRowType
operator|.
name|getFieldNames
argument_list|()
argument_list|)
condition|)
block|{
comment|// Do not create an identity project if it does not rename any fields
return|return
name|this
return|;
block|}
else|else
block|{
comment|// create "virtual" row type for project only rename fields
specifier|final
name|Frame
name|frame
init|=
name|stack
operator|.
name|pop
argument_list|()
decl_stmt|;
specifier|final
name|RelDataType
name|rowType
init|=
name|RexUtil
operator|.
name|createStructType
argument_list|(
name|cluster
operator|.
name|getTypeFactory
argument_list|()
argument_list|,
name|exprList
argument_list|,
name|names
argument_list|,
name|SqlValidatorUtil
operator|.
name|F_SUGGESTER
argument_list|)
decl_stmt|;
name|stack
operator|.
name|push
argument_list|(
operator|new
name|Frame
argument_list|(
name|frame
operator|.
name|rel
argument_list|,
name|ImmutableList
operator|.
name|of
argument_list|(
name|Pair
operator|.
name|of
argument_list|(
name|frame
operator|.
name|right
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|left
argument_list|,
name|rowType
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
block|}
specifier|final
name|RelNode
name|project
init|=
name|projectFactory
operator|.
name|createProject
argument_list|(
name|build
argument_list|()
argument_list|,
name|ImmutableList
operator|.
name|copyOf
argument_list|(
name|exprList
argument_list|)
argument_list|,
name|names
argument_list|)
decl_stmt|;
name|push
argument_list|(
name|project
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/** Creates a {@link org.apache.calcite.rel.core.Project} of the given    * expressions. */
specifier|public
name|HiveSubQRemoveRelBuilder
name|project
parameter_list|(
name|RexNode
modifier|...
name|nodes
parameter_list|)
block|{
return|return
name|project
argument_list|(
name|ImmutableList
operator|.
name|copyOf
argument_list|(
name|nodes
argument_list|)
argument_list|)
return|;
block|}
comment|/** Infers the alias of an expression.    *    *<p>If the expression was created by {@link #alias}, replaces the expression    * in the project list.    */
specifier|private
name|String
name|inferAlias
parameter_list|(
name|List
argument_list|<
name|RexNode
argument_list|>
name|exprList
parameter_list|,
name|RexNode
name|expr
parameter_list|)
block|{
switch|switch
condition|(
name|expr
operator|.
name|getKind
argument_list|()
condition|)
block|{
case|case
name|INPUT_REF
case|:
specifier|final
name|RexInputRef
name|ref
init|=
operator|(
name|RexInputRef
operator|)
name|expr
decl_stmt|;
return|return
name|peek
argument_list|(
literal|0
argument_list|)
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldNames
argument_list|()
operator|.
name|get
argument_list|(
name|ref
operator|.
name|getIndex
argument_list|()
argument_list|)
return|;
case|case
name|CAST
case|:
return|return
name|inferAlias
argument_list|(
name|exprList
argument_list|,
operator|(
operator|(
name|RexCall
operator|)
name|expr
operator|)
operator|.
name|getOperands
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|)
return|;
case|case
name|AS
case|:
specifier|final
name|RexCall
name|call
init|=
operator|(
name|RexCall
operator|)
name|expr
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
specifier|final
name|int
name|i
init|=
name|exprList
operator|.
name|indexOf
argument_list|(
name|expr
argument_list|)
decl_stmt|;
if|if
condition|(
name|i
operator|<
literal|0
condition|)
block|{
break|break;
block|}
name|exprList
operator|.
name|set
argument_list|(
name|i
argument_list|,
name|call
operator|.
name|getOperands
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
call|(
name|NlsString
call|)
argument_list|(
operator|(
name|RexLiteral
operator|)
name|call
operator|.
name|getOperands
argument_list|()
operator|.
name|get
argument_list|(
literal|1
argument_list|)
argument_list|)
operator|.
name|getValue
argument_list|()
operator|)
operator|.
name|getValue
argument_list|()
return|;
default|default:
return|return
literal|null
return|;
block|}
block|}
comment|/** Creates an {@link org.apache.calcite.rel.core.Aggregate} that makes the    * relational expression distinct on all fields. */
specifier|public
name|HiveSubQRemoveRelBuilder
name|distinct
parameter_list|()
block|{
return|return
name|aggregate
argument_list|(
name|groupKey
argument_list|(
name|fields
argument_list|()
argument_list|)
argument_list|)
return|;
block|}
comment|/** Creates an {@link org.apache.calcite.rel.core.Aggregate} with an array of    * calls. */
specifier|public
name|HiveSubQRemoveRelBuilder
name|aggregate
parameter_list|(
name|GroupKey
name|groupKey
parameter_list|,
name|AggCall
modifier|...
name|aggCalls
parameter_list|)
block|{
return|return
name|aggregate
argument_list|(
name|groupKey
argument_list|,
name|ImmutableList
operator|.
name|copyOf
argument_list|(
name|aggCalls
argument_list|)
argument_list|)
return|;
block|}
comment|/** Creates an {@link org.apache.calcite.rel.core.Aggregate} with a list of    * calls. */
specifier|public
name|HiveSubQRemoveRelBuilder
name|aggregate
parameter_list|(
name|GroupKey
name|groupKey
parameter_list|,
name|Iterable
argument_list|<
name|AggCall
argument_list|>
name|aggCalls
parameter_list|)
block|{
specifier|final
name|RelDataType
name|inputRowType
init|=
name|peek
argument_list|()
operator|.
name|getRowType
argument_list|()
decl_stmt|;
specifier|final
name|List
argument_list|<
name|RexNode
argument_list|>
name|extraNodes
init|=
name|projects
argument_list|(
name|inputRowType
argument_list|)
decl_stmt|;
specifier|final
name|GroupKeyImpl
name|groupKey_
init|=
operator|(
name|GroupKeyImpl
operator|)
name|groupKey
decl_stmt|;
specifier|final
name|ImmutableBitSet
name|groupSet
init|=
name|ImmutableBitSet
operator|.
name|of
argument_list|(
name|registerExpressions
argument_list|(
name|extraNodes
argument_list|,
name|groupKey_
operator|.
name|nodes
argument_list|)
argument_list|)
decl_stmt|;
specifier|final
name|ImmutableList
argument_list|<
name|ImmutableBitSet
argument_list|>
name|groupSets
decl_stmt|;
if|if
condition|(
name|groupKey_
operator|.
name|nodeLists
operator|!=
literal|null
condition|)
block|{
specifier|final
name|int
name|sizeBefore
init|=
name|extraNodes
operator|.
name|size
argument_list|()
decl_stmt|;
specifier|final
name|SortedSet
argument_list|<
name|ImmutableBitSet
argument_list|>
name|groupSetSet
init|=
operator|new
name|TreeSet
argument_list|<>
argument_list|(
name|ImmutableBitSet
operator|.
name|ORDERING
argument_list|)
decl_stmt|;
for|for
control|(
name|ImmutableList
argument_list|<
name|RexNode
argument_list|>
name|nodeList
range|:
name|groupKey_
operator|.
name|nodeLists
control|)
block|{
specifier|final
name|ImmutableBitSet
name|groupSet2
init|=
name|ImmutableBitSet
operator|.
name|of
argument_list|(
name|registerExpressions
argument_list|(
name|extraNodes
argument_list|,
name|nodeList
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|groupSet
operator|.
name|contains
argument_list|(
name|groupSet2
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"group set element "
operator|+
name|nodeList
operator|+
literal|" must be a subset of group key"
argument_list|)
throw|;
block|}
name|groupSetSet
operator|.
name|add
argument_list|(
name|groupSet2
argument_list|)
expr_stmt|;
block|}
name|groupSets
operator|=
name|ImmutableList
operator|.
name|copyOf
argument_list|(
name|groupSetSet
argument_list|)
expr_stmt|;
if|if
condition|(
name|extraNodes
operator|.
name|size
argument_list|()
operator|>
name|sizeBefore
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"group sets contained expressions not in group key: "
operator|+
name|extraNodes
operator|.
name|subList
argument_list|(
name|sizeBefore
argument_list|,
name|extraNodes
operator|.
name|size
argument_list|()
argument_list|)
argument_list|)
throw|;
block|}
block|}
else|else
block|{
name|groupSets
operator|=
name|ImmutableList
operator|.
name|of
argument_list|(
name|groupSet
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|AggCall
name|aggCall
range|:
name|aggCalls
control|)
block|{
if|if
condition|(
name|aggCall
operator|instanceof
name|AggCallImpl
condition|)
block|{
specifier|final
name|AggCallImpl
name|aggCall1
init|=
operator|(
name|AggCallImpl
operator|)
name|aggCall
decl_stmt|;
name|registerExpressions
argument_list|(
name|extraNodes
argument_list|,
name|aggCall1
operator|.
name|operands
argument_list|)
expr_stmt|;
if|if
condition|(
name|aggCall1
operator|.
name|filter
operator|!=
literal|null
condition|)
block|{
name|registerExpression
argument_list|(
name|extraNodes
argument_list|,
name|aggCall1
operator|.
name|filter
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|extraNodes
operator|.
name|size
argument_list|()
operator|>
name|inputRowType
operator|.
name|getFieldCount
argument_list|()
condition|)
block|{
name|project
argument_list|(
name|extraNodes
argument_list|)
expr_stmt|;
block|}
specifier|final
name|RelNode
name|r
init|=
name|build
argument_list|()
decl_stmt|;
specifier|final
name|List
argument_list|<
name|AggregateCall
argument_list|>
name|aggregateCalls
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|AggCall
name|aggCall
range|:
name|aggCalls
control|)
block|{
specifier|final
name|AggregateCall
name|aggregateCall
decl_stmt|;
if|if
condition|(
name|aggCall
operator|instanceof
name|AggCallImpl
condition|)
block|{
specifier|final
name|AggCallImpl
name|aggCall1
init|=
operator|(
name|AggCallImpl
operator|)
name|aggCall
decl_stmt|;
specifier|final
name|List
argument_list|<
name|Integer
argument_list|>
name|args
init|=
name|registerExpressions
argument_list|(
name|extraNodes
argument_list|,
name|aggCall1
operator|.
name|operands
argument_list|)
decl_stmt|;
specifier|final
name|int
name|filterArg
init|=
name|aggCall1
operator|.
name|filter
operator|==
literal|null
condition|?
operator|-
literal|1
else|:
name|registerExpression
argument_list|(
name|extraNodes
argument_list|,
name|aggCall1
operator|.
name|filter
argument_list|)
decl_stmt|;
name|aggregateCall
operator|=
name|AggregateCall
operator|.
name|create
argument_list|(
name|aggCall1
operator|.
name|aggFunction
argument_list|,
name|aggCall1
operator|.
name|distinct
argument_list|,
name|args
argument_list|,
name|filterArg
argument_list|,
name|groupSet
operator|.
name|cardinality
argument_list|()
argument_list|,
name|r
argument_list|,
literal|null
argument_list|,
name|aggCall1
operator|.
name|alias
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|aggregateCall
operator|=
operator|(
operator|(
name|AggCallImpl2
operator|)
name|aggCall
operator|)
operator|.
name|aggregateCall
expr_stmt|;
block|}
name|aggregateCalls
operator|.
name|add
argument_list|(
name|aggregateCall
argument_list|)
expr_stmt|;
block|}
assert|assert
name|ImmutableBitSet
operator|.
name|ORDERING
operator|.
name|isStrictlyOrdered
argument_list|(
name|groupSets
argument_list|)
operator|:
name|groupSets
assert|;
for|for
control|(
name|ImmutableBitSet
name|set
range|:
name|groupSets
control|)
block|{
assert|assert
name|groupSet
operator|.
name|contains
argument_list|(
name|set
argument_list|)
assert|;
block|}
name|RelNode
name|aggregate
init|=
name|aggregateFactory
operator|.
name|createAggregate
argument_list|(
name|r
argument_list|,
name|groupKey_
operator|.
name|indicator
argument_list|,
name|groupSet
argument_list|,
name|groupSets
argument_list|,
name|aggregateCalls
argument_list|)
decl_stmt|;
name|push
argument_list|(
name|aggregate
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
specifier|private
name|List
argument_list|<
name|RexNode
argument_list|>
name|projects
parameter_list|(
name|RelDataType
name|inputRowType
parameter_list|)
block|{
specifier|final
name|List
argument_list|<
name|RexNode
argument_list|>
name|exprList
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|RelDataTypeField
name|field
range|:
name|inputRowType
operator|.
name|getFieldList
argument_list|()
control|)
block|{
specifier|final
name|RexBuilder
name|rexBuilder
init|=
name|cluster
operator|.
name|getRexBuilder
argument_list|()
decl_stmt|;
name|exprList
operator|.
name|add
argument_list|(
name|rexBuilder
operator|.
name|makeInputRef
argument_list|(
name|field
operator|.
name|getType
argument_list|()
argument_list|,
name|field
operator|.
name|getIndex
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|exprList
return|;
block|}
specifier|private
specifier|static
name|int
name|registerExpression
parameter_list|(
name|List
argument_list|<
name|RexNode
argument_list|>
name|exprList
parameter_list|,
name|RexNode
name|node
parameter_list|)
block|{
name|int
name|i
init|=
name|exprList
operator|.
name|indexOf
argument_list|(
name|node
argument_list|)
decl_stmt|;
if|if
condition|(
name|i
operator|<
literal|0
condition|)
block|{
name|i
operator|=
name|exprList
operator|.
name|size
argument_list|()
expr_stmt|;
name|exprList
operator|.
name|add
argument_list|(
name|node
argument_list|)
expr_stmt|;
block|}
return|return
name|i
return|;
block|}
specifier|private
specifier|static
name|List
argument_list|<
name|Integer
argument_list|>
name|registerExpressions
parameter_list|(
name|List
argument_list|<
name|RexNode
argument_list|>
name|extraNodes
parameter_list|,
name|Iterable
argument_list|<
name|?
extends|extends
name|RexNode
argument_list|>
name|nodes
parameter_list|)
block|{
specifier|final
name|List
argument_list|<
name|Integer
argument_list|>
name|builder
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|RexNode
name|node
range|:
name|nodes
control|)
block|{
name|builder
operator|.
name|add
argument_list|(
name|registerExpression
argument_list|(
name|extraNodes
argument_list|,
name|node
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|builder
return|;
block|}
specifier|private
name|HiveSubQRemoveRelBuilder
name|setOp
parameter_list|(
name|boolean
name|all
parameter_list|,
name|SqlKind
name|kind
parameter_list|,
name|int
name|n
parameter_list|)
block|{
name|List
argument_list|<
name|RelNode
argument_list|>
name|inputs
init|=
operator|new
name|LinkedList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
block|{
name|inputs
operator|.
name|add
argument_list|(
literal|0
argument_list|,
name|build
argument_list|()
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|kind
condition|)
block|{
case|case
name|UNION
case|:
case|case
name|INTERSECT
case|:
case|case
name|EXCEPT
case|:
if|if
condition|(
name|n
operator|<
literal|1
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"bad INTERSECT/UNION/EXCEPT input count"
argument_list|)
throw|;
block|}
break|break;
default|default:
throw|throw
operator|new
name|AssertionError
argument_list|(
literal|"bad setOp "
operator|+
name|kind
argument_list|)
throw|;
block|}
switch|switch
condition|(
name|n
condition|)
block|{
case|case
literal|1
case|:
return|return
name|push
argument_list|(
name|inputs
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|)
return|;
default|default:
return|return
name|push
argument_list|(
name|setOpFactory
operator|.
name|createSetOp
argument_list|(
name|kind
argument_list|,
name|inputs
argument_list|,
name|all
argument_list|)
argument_list|)
return|;
block|}
block|}
comment|/** Creates a {@link org.apache.calcite.rel.core.Union} of the two most recent    * relational expressions on the stack.    *    * @param all Whether to create UNION ALL    */
specifier|public
name|HiveSubQRemoveRelBuilder
name|union
parameter_list|(
name|boolean
name|all
parameter_list|)
block|{
return|return
name|union
argument_list|(
name|all
argument_list|,
literal|2
argument_list|)
return|;
block|}
comment|/** Creates a {@link org.apache.calcite.rel.core.Union} of the {@code n}    * most recent relational expressions on the stack.    *    * @param all Whether to create UNION ALL    * @param n Number of inputs to the UNION operator    */
specifier|public
name|HiveSubQRemoveRelBuilder
name|union
parameter_list|(
name|boolean
name|all
parameter_list|,
name|int
name|n
parameter_list|)
block|{
return|return
name|setOp
argument_list|(
name|all
argument_list|,
name|SqlKind
operator|.
name|UNION
argument_list|,
name|n
argument_list|)
return|;
block|}
comment|/** Creates an {@link org.apache.calcite.rel.core.Intersect} of the two most    * recent relational expressions on the stack.    *    * @param all Whether to create INTERSECT ALL    */
specifier|public
name|HiveSubQRemoveRelBuilder
name|intersect
parameter_list|(
name|boolean
name|all
parameter_list|)
block|{
return|return
name|intersect
argument_list|(
name|all
argument_list|,
literal|2
argument_list|)
return|;
block|}
comment|/** Creates an {@link org.apache.calcite.rel.core.Intersect} of the {@code n}    * most recent relational expressions on the stack.    *    * @param all Whether to create INTERSECT ALL    * @param n Number of inputs to the INTERSECT operator    */
specifier|public
name|HiveSubQRemoveRelBuilder
name|intersect
parameter_list|(
name|boolean
name|all
parameter_list|,
name|int
name|n
parameter_list|)
block|{
return|return
name|setOp
argument_list|(
name|all
argument_list|,
name|SqlKind
operator|.
name|INTERSECT
argument_list|,
name|n
argument_list|)
return|;
block|}
comment|/** Creates a {@link org.apache.calcite.rel.core.Minus} of the two most recent    * relational expressions on the stack.    *    * @param all Whether to create EXCEPT ALL    */
specifier|public
name|HiveSubQRemoveRelBuilder
name|minus
parameter_list|(
name|boolean
name|all
parameter_list|)
block|{
return|return
name|minus
argument_list|(
name|all
argument_list|,
literal|2
argument_list|)
return|;
block|}
comment|/** Creates a {@link org.apache.calcite.rel.core.Minus} of the {@code n}    * most recent relational expressions on the stack.    *    * @param all Whether to create EXCEPT ALL    */
specifier|public
name|HiveSubQRemoveRelBuilder
name|minus
parameter_list|(
name|boolean
name|all
parameter_list|,
name|int
name|n
parameter_list|)
block|{
return|return
name|setOp
argument_list|(
name|all
argument_list|,
name|SqlKind
operator|.
name|EXCEPT
argument_list|,
name|n
argument_list|)
return|;
block|}
comment|/** Creates a {@link org.apache.calcite.rel.core.Join}. */
specifier|public
name|HiveSubQRemoveRelBuilder
name|join
parameter_list|(
name|JoinRelType
name|joinType
parameter_list|,
name|RexNode
name|condition0
parameter_list|,
name|RexNode
modifier|...
name|conditions
parameter_list|)
block|{
return|return
name|join
argument_list|(
name|joinType
argument_list|,
name|Lists
operator|.
name|asList
argument_list|(
name|condition0
argument_list|,
name|conditions
argument_list|)
argument_list|)
return|;
block|}
comment|/** Creates a {@link org.apache.calcite.rel.core.Join} with multiple    * conditions. */
specifier|public
name|HiveSubQRemoveRelBuilder
name|join
parameter_list|(
name|JoinRelType
name|joinType
parameter_list|,
name|Iterable
argument_list|<
name|?
extends|extends
name|RexNode
argument_list|>
name|conditions
parameter_list|)
block|{
return|return
name|join
argument_list|(
name|joinType
argument_list|,
name|and
argument_list|(
name|conditions
argument_list|)
argument_list|,
name|ImmutableSet
operator|.
expr|<
name|CorrelationId
operator|>
name|of
argument_list|()
argument_list|)
return|;
block|}
specifier|public
name|HiveSubQRemoveRelBuilder
name|join
parameter_list|(
name|JoinRelType
name|joinType
parameter_list|,
name|RexNode
name|condition
parameter_list|)
block|{
return|return
name|join
argument_list|(
name|joinType
argument_list|,
name|condition
argument_list|,
name|ImmutableSet
operator|.
expr|<
name|CorrelationId
operator|>
name|of
argument_list|()
argument_list|)
return|;
block|}
comment|/** Creates a correlation variable for the current input, and writes it into    * a Holder. */
specifier|public
name|HiveSubQRemoveRelBuilder
name|variable
parameter_list|(
name|Holder
argument_list|<
name|RexCorrelVariable
argument_list|>
name|v
parameter_list|)
block|{
name|v
operator|.
name|set
argument_list|(
operator|(
name|RexCorrelVariable
operator|)
name|getRexBuilder
argument_list|()
operator|.
name|makeCorrel
argument_list|(
name|peek
argument_list|()
operator|.
name|getRowType
argument_list|()
argument_list|,
name|cluster
operator|.
name|createCorrel
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/** Returns a reference to a given field of a record-valued expression. */
specifier|public
name|RexNode
name|field
parameter_list|(
name|RexNode
name|e
parameter_list|,
name|String
name|name
parameter_list|)
block|{
return|return
name|getRexBuilder
argument_list|()
operator|.
name|makeFieldAccess
argument_list|(
name|e
argument_list|,
name|name
argument_list|,
literal|false
argument_list|)
return|;
block|}
comment|/** Creates a {@link org.apache.calcite.rel.core.Join} with correlating    * variables. */
specifier|public
name|HiveSubQRemoveRelBuilder
name|join
parameter_list|(
name|JoinRelType
name|joinType
parameter_list|,
name|RexNode
name|condition
parameter_list|,
name|Set
argument_list|<
name|CorrelationId
argument_list|>
name|variablesSet
parameter_list|)
block|{
name|Frame
name|right
init|=
name|stack
operator|.
name|pop
argument_list|()
decl_stmt|;
specifier|final
name|Frame
name|left
init|=
name|stack
operator|.
name|pop
argument_list|()
decl_stmt|;
specifier|final
name|RelNode
name|join
decl_stmt|;
specifier|final
name|boolean
name|correlate
init|=
name|variablesSet
operator|.
name|size
argument_list|()
operator|==
literal|1
decl_stmt|;
name|RexNode
name|postCondition
init|=
name|literal
argument_list|(
literal|true
argument_list|)
decl_stmt|;
if|if
condition|(
name|correlate
condition|)
block|{
specifier|final
name|CorrelationId
name|id
init|=
name|Iterables
operator|.
name|getOnlyElement
argument_list|(
name|variablesSet
argument_list|)
decl_stmt|;
specifier|final
name|ImmutableBitSet
name|requiredColumns
init|=
name|RelOptUtil
operator|.
name|correlationColumns
argument_list|(
name|id
argument_list|,
name|right
operator|.
name|rel
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|RelOptUtil
operator|.
name|notContainsCorrelation
argument_list|(
name|left
operator|.
name|rel
argument_list|,
name|id
argument_list|,
name|Litmus
operator|.
name|IGNORE
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"variable "
operator|+
name|id
operator|+
literal|" must not be used by left input to correlation"
argument_list|)
throw|;
block|}
switch|switch
condition|(
name|joinType
condition|)
block|{
case|case
name|LEFT
case|:
comment|// Correlate does not have an ON clause.
comment|// For a LEFT correlate, predicate must be evaluated first.
comment|// For INNER, we can defer.
name|stack
operator|.
name|push
argument_list|(
name|right
argument_list|)
expr_stmt|;
name|filter
argument_list|(
name|condition
operator|.
name|accept
argument_list|(
operator|new
name|Shifter
argument_list|(
name|left
operator|.
name|rel
argument_list|,
name|id
argument_list|,
name|right
operator|.
name|rel
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|right
operator|=
name|stack
operator|.
name|pop
argument_list|()
expr_stmt|;
break|break;
default|default:
name|postCondition
operator|=
name|condition
expr_stmt|;
block|}
name|join
operator|=
name|correlateFactory
operator|.
name|createCorrelate
argument_list|(
name|left
operator|.
name|rel
argument_list|,
name|right
operator|.
name|rel
argument_list|,
name|id
argument_list|,
name|requiredColumns
argument_list|,
name|SemiJoinType
operator|.
name|of
argument_list|(
name|joinType
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|join
operator|=
name|joinFactory
operator|.
name|createJoin
argument_list|(
name|left
operator|.
name|rel
argument_list|,
name|right
operator|.
name|rel
argument_list|,
name|condition
argument_list|,
name|variablesSet
argument_list|,
name|joinType
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
specifier|final
name|List
argument_list|<
name|Pair
argument_list|<
name|String
argument_list|,
name|RelDataType
argument_list|>
argument_list|>
name|pairs
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|pairs
operator|.
name|addAll
argument_list|(
name|left
operator|.
name|right
argument_list|)
expr_stmt|;
name|pairs
operator|.
name|addAll
argument_list|(
name|right
operator|.
name|right
argument_list|)
expr_stmt|;
name|stack
operator|.
name|push
argument_list|(
operator|new
name|Frame
argument_list|(
name|join
argument_list|,
name|ImmutableList
operator|.
name|copyOf
argument_list|(
name|pairs
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|filter
argument_list|(
name|postCondition
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/** Creates a {@link org.apache.calcite.rel.core.Join} using USING syntax.    *    *<p>For each of the field names, both left and right inputs must have a    * field of that name. Constructs a join condition that the left and right    * fields are equal.    *    * @param joinType Join type    * @param fieldNames Field names    */
specifier|public
name|HiveSubQRemoveRelBuilder
name|join
parameter_list|(
name|JoinRelType
name|joinType
parameter_list|,
name|String
modifier|...
name|fieldNames
parameter_list|)
block|{
specifier|final
name|List
argument_list|<
name|RexNode
argument_list|>
name|conditions
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|String
name|fieldName
range|:
name|fieldNames
control|)
block|{
name|conditions
operator|.
name|add
argument_list|(
name|call
argument_list|(
name|SqlStdOperatorTable
operator|.
name|EQUALS
argument_list|,
name|field
argument_list|(
literal|2
argument_list|,
literal|0
argument_list|,
name|fieldName
argument_list|)
argument_list|,
name|field
argument_list|(
literal|2
argument_list|,
literal|1
argument_list|,
name|fieldName
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|join
argument_list|(
name|joinType
argument_list|,
name|conditions
argument_list|)
return|;
block|}
comment|/** Creates a {@link org.apache.calcite.rel.core.SemiJoin}. */
specifier|public
name|HiveSubQRemoveRelBuilder
name|semiJoin
parameter_list|(
name|Iterable
argument_list|<
name|?
extends|extends
name|RexNode
argument_list|>
name|conditions
parameter_list|)
block|{
specifier|final
name|Frame
name|right
init|=
name|stack
operator|.
name|pop
argument_list|()
decl_stmt|;
specifier|final
name|Frame
name|left
init|=
name|stack
operator|.
name|pop
argument_list|()
decl_stmt|;
specifier|final
name|RelNode
name|semiJoin
init|=
name|semiJoinFactory
operator|.
name|createSemiJoin
argument_list|(
name|left
operator|.
name|rel
argument_list|,
name|right
operator|.
name|rel
argument_list|,
name|and
argument_list|(
name|conditions
argument_list|)
argument_list|)
decl_stmt|;
name|stack
operator|.
name|push
argument_list|(
operator|new
name|Frame
argument_list|(
name|semiJoin
argument_list|,
name|left
operator|.
name|right
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/** Creates a {@link org.apache.calcite.rel.core.SemiJoin}. */
specifier|public
name|HiveSubQRemoveRelBuilder
name|semiJoin
parameter_list|(
name|RexNode
modifier|...
name|conditions
parameter_list|)
block|{
return|return
name|semiJoin
argument_list|(
name|ImmutableList
operator|.
name|copyOf
argument_list|(
name|conditions
argument_list|)
argument_list|)
return|;
block|}
comment|/** Assigns a table alias to the top entry on the stack. */
specifier|public
name|HiveSubQRemoveRelBuilder
name|as
parameter_list|(
name|String
name|alias
parameter_list|)
block|{
specifier|final
name|Frame
name|pair
init|=
name|stack
operator|.
name|pop
argument_list|()
decl_stmt|;
name|stack
operator|.
name|push
argument_list|(
operator|new
name|Frame
argument_list|(
name|pair
operator|.
name|rel
argument_list|,
name|ImmutableList
operator|.
name|of
argument_list|(
name|Pair
operator|.
name|of
argument_list|(
name|alias
argument_list|,
name|pair
operator|.
name|right
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|right
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/** Creates a {@link Values}.    *    *<p>The {@code values} array must have the same number of entries as    * {@code fieldNames}, or an integer multiple if you wish to create multiple    * rows.    *    *<p>If there are zero rows, or if all values of a any column are    * null, this method cannot deduce the type of columns. For these cases,    * call {@link #values(Iterable, RelDataType)}.    *    * @param fieldNames Field names    * @param values Values    */
specifier|public
name|HiveSubQRemoveRelBuilder
name|values
parameter_list|(
name|String
index|[]
name|fieldNames
parameter_list|,
name|Object
modifier|...
name|values
parameter_list|)
block|{
if|if
condition|(
name|fieldNames
operator|==
literal|null
operator|||
name|fieldNames
operator|.
name|length
operator|==
literal|0
operator|||
name|values
operator|.
name|length
operator|%
name|fieldNames
operator|.
name|length
operator|!=
literal|0
operator|||
name|values
operator|.
name|length
operator|<
name|fieldNames
operator|.
name|length
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Value count must be a positive multiple of field count"
argument_list|)
throw|;
block|}
specifier|final
name|int
name|rowCount
init|=
name|values
operator|.
name|length
operator|/
name|fieldNames
operator|.
name|length
decl_stmt|;
for|for
control|(
name|Ord
argument_list|<
name|String
argument_list|>
name|fieldName
range|:
name|Ord
operator|.
name|zip
argument_list|(
name|fieldNames
argument_list|)
control|)
block|{
if|if
condition|(
name|allNull
argument_list|(
name|values
argument_list|,
name|fieldName
operator|.
name|i
argument_list|,
name|fieldNames
operator|.
name|length
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"All values of field '"
operator|+
name|fieldName
operator|.
name|e
operator|+
literal|"' are null; cannot deduce type"
argument_list|)
throw|;
block|}
block|}
specifier|final
name|ImmutableList
argument_list|<
name|ImmutableList
argument_list|<
name|RexLiteral
argument_list|>
argument_list|>
name|tupleList
init|=
name|tupleList
argument_list|(
name|fieldNames
operator|.
name|length
argument_list|,
name|values
argument_list|)
decl_stmt|;
specifier|final
name|RelDataTypeFactory
operator|.
name|FieldInfoBuilder
name|rowTypeBuilder
init|=
name|cluster
operator|.
name|getTypeFactory
argument_list|()
operator|.
name|builder
argument_list|()
decl_stmt|;
for|for
control|(
specifier|final
name|Ord
argument_list|<
name|String
argument_list|>
name|fieldName
range|:
name|Ord
operator|.
name|zip
argument_list|(
name|fieldNames
argument_list|)
control|)
block|{
specifier|final
name|String
name|name
init|=
name|fieldName
operator|.
name|e
operator|!=
literal|null
condition|?
name|fieldName
operator|.
name|e
else|:
literal|"expr$"
operator|+
name|fieldName
operator|.
name|i
decl_stmt|;
specifier|final
name|RelDataType
name|type
init|=
name|cluster
operator|.
name|getTypeFactory
argument_list|()
operator|.
name|leastRestrictive
argument_list|(
operator|new
name|AbstractList
argument_list|<
name|RelDataType
argument_list|>
argument_list|()
block|{
specifier|public
name|RelDataType
name|get
parameter_list|(
name|int
name|index
parameter_list|)
block|{
return|return
name|tupleList
operator|.
name|get
argument_list|(
name|index
argument_list|)
operator|.
name|get
argument_list|(
name|fieldName
operator|.
name|i
argument_list|)
operator|.
name|getType
argument_list|()
return|;
block|}
specifier|public
name|int
name|size
parameter_list|()
block|{
return|return
name|rowCount
return|;
block|}
block|}
argument_list|)
decl_stmt|;
name|rowTypeBuilder
operator|.
name|add
argument_list|(
name|name
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
specifier|final
name|RelDataType
name|rowType
init|=
name|rowTypeBuilder
operator|.
name|build
argument_list|()
decl_stmt|;
return|return
name|values
argument_list|(
name|tupleList
argument_list|,
name|rowType
argument_list|)
return|;
block|}
specifier|private
name|ImmutableList
argument_list|<
name|ImmutableList
argument_list|<
name|RexLiteral
argument_list|>
argument_list|>
name|tupleList
parameter_list|(
name|int
name|columnCount
parameter_list|,
name|Object
index|[]
name|values
parameter_list|)
block|{
specifier|final
name|ImmutableList
operator|.
name|Builder
argument_list|<
name|ImmutableList
argument_list|<
name|RexLiteral
argument_list|>
argument_list|>
name|listBuilder
init|=
name|ImmutableList
operator|.
name|builder
argument_list|()
decl_stmt|;
specifier|final
name|List
argument_list|<
name|RexLiteral
argument_list|>
name|valueList
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|values
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|Object
name|value
init|=
name|values
index|[
name|i
index|]
decl_stmt|;
name|valueList
operator|.
name|add
argument_list|(
operator|(
name|RexLiteral
operator|)
name|literal
argument_list|(
name|value
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|i
operator|+
literal|1
operator|)
operator|%
name|columnCount
operator|==
literal|0
condition|)
block|{
name|listBuilder
operator|.
name|add
argument_list|(
name|ImmutableList
operator|.
name|copyOf
argument_list|(
name|valueList
argument_list|)
argument_list|)
expr_stmt|;
name|valueList
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
block|}
return|return
name|listBuilder
operator|.
name|build
argument_list|()
return|;
block|}
comment|/** Returns whether all values for a given column are null. */
specifier|private
name|boolean
name|allNull
parameter_list|(
name|Object
index|[]
name|values
parameter_list|,
name|int
name|column
parameter_list|,
name|int
name|columnCount
parameter_list|)
block|{
for|for
control|(
name|int
name|i
init|=
name|column
init|;
name|i
operator|<
name|values
operator|.
name|length
condition|;
name|i
operator|+=
name|columnCount
control|)
block|{
if|if
condition|(
name|values
index|[
name|i
index|]
operator|!=
literal|null
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
return|return
literal|true
return|;
block|}
comment|/**    * Empty relationship can be expressed in many different ways, e.g.,    * filter(cond=false), empty LogicalValues(), etc. Calcite default implementation    * uses empty LogicalValues(); however, currently there is not an equivalent to    * this expression in Hive. Thus, we use limit 0, since Hive already includes    * optimizations that will do early pruning of the result tree when it is found,    * e.g., GlobalLimitOptimizer.    */
specifier|public
name|HiveSubQRemoveRelBuilder
name|empty
parameter_list|()
block|{
specifier|final
name|RelNode
name|input
init|=
name|build
argument_list|()
decl_stmt|;
specifier|final
name|RelNode
name|sort
init|=
name|HiveRelFactories
operator|.
name|HIVE_SORT_FACTORY
operator|.
name|createSort
argument_list|(
name|input
argument_list|,
name|RelCollations
operator|.
name|of
argument_list|()
argument_list|,
literal|null
argument_list|,
name|literal
argument_list|(
literal|0
argument_list|)
argument_list|)
decl_stmt|;
return|return
name|this
operator|.
name|push
argument_list|(
name|sort
argument_list|)
return|;
block|}
comment|/** Creates a {@link Values} with a specified row type.    *    *<p>This method can handle cases that {@link #values(String[], Object...)}    * cannot, such as all values of a column being null, or there being zero    * rows.    *    * @param rowType Row type    * @param columnValues Values    */
specifier|public
name|HiveSubQRemoveRelBuilder
name|values
parameter_list|(
name|RelDataType
name|rowType
parameter_list|,
name|Object
modifier|...
name|columnValues
parameter_list|)
block|{
specifier|final
name|ImmutableList
argument_list|<
name|ImmutableList
argument_list|<
name|RexLiteral
argument_list|>
argument_list|>
name|tupleList
init|=
name|tupleList
argument_list|(
name|rowType
operator|.
name|getFieldCount
argument_list|()
argument_list|,
name|columnValues
argument_list|)
decl_stmt|;
name|RelNode
name|values
init|=
name|valuesFactory
operator|.
name|createValues
argument_list|(
name|cluster
argument_list|,
name|rowType
argument_list|,
name|ImmutableList
operator|.
name|copyOf
argument_list|(
name|tupleList
argument_list|)
argument_list|)
decl_stmt|;
name|push
argument_list|(
name|values
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/** Creates a {@link Values} with a specified row type.    *    *<p>This method can handle cases that {@link #values(String[], Object...)}    * cannot, such as all values of a column being null, or there being zero    * rows.    *    * @param tupleList Tuple list    * @param rowType Row type    */
specifier|public
name|HiveSubQRemoveRelBuilder
name|values
parameter_list|(
name|Iterable
argument_list|<
name|?
extends|extends
name|List
argument_list|<
name|RexLiteral
argument_list|>
argument_list|>
name|tupleList
parameter_list|,
name|RelDataType
name|rowType
parameter_list|)
block|{
name|RelNode
name|values
init|=
name|valuesFactory
operator|.
name|createValues
argument_list|(
name|cluster
argument_list|,
name|rowType
argument_list|,
name|copy
argument_list|(
name|tupleList
argument_list|)
argument_list|)
decl_stmt|;
name|push
argument_list|(
name|values
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/** Creates a {@link Values} with a specified row type and    * zero rows.    *    * @param rowType Row type    */
specifier|public
name|HiveSubQRemoveRelBuilder
name|values
parameter_list|(
name|RelDataType
name|rowType
parameter_list|)
block|{
return|return
name|values
argument_list|(
name|ImmutableList
operator|.
expr|<
name|ImmutableList
argument_list|<
name|RexLiteral
argument_list|>
operator|>
name|of
argument_list|()
argument_list|,
name|rowType
argument_list|)
return|;
block|}
comment|/** Converts an iterable of lists into an immutable list of immutable lists    * with the same contents. Returns the same object if possible. */
specifier|private
specifier|static
parameter_list|<
name|E
parameter_list|>
name|ImmutableList
argument_list|<
name|ImmutableList
argument_list|<
name|E
argument_list|>
argument_list|>
name|copy
parameter_list|(
name|Iterable
argument_list|<
name|?
extends|extends
name|List
argument_list|<
name|E
argument_list|>
argument_list|>
name|tupleList
parameter_list|)
block|{
specifier|final
name|ImmutableList
operator|.
name|Builder
argument_list|<
name|ImmutableList
argument_list|<
name|E
argument_list|>
argument_list|>
name|builder
init|=
name|ImmutableList
operator|.
name|builder
argument_list|()
decl_stmt|;
name|int
name|changeCount
init|=
literal|0
decl_stmt|;
for|for
control|(
name|List
argument_list|<
name|E
argument_list|>
name|literals
range|:
name|tupleList
control|)
block|{
specifier|final
name|ImmutableList
argument_list|<
name|E
argument_list|>
name|literals2
init|=
name|ImmutableList
operator|.
name|copyOf
argument_list|(
name|literals
argument_list|)
decl_stmt|;
name|builder
operator|.
name|add
argument_list|(
name|literals2
argument_list|)
expr_stmt|;
if|if
condition|(
name|literals
operator|!=
name|literals2
condition|)
block|{
operator|++
name|changeCount
expr_stmt|;
block|}
block|}
if|if
condition|(
name|changeCount
operator|==
literal|0
condition|)
block|{
comment|// don't make a copy if we don't have to
comment|//noinspection unchecked
return|return
operator|(
name|ImmutableList
argument_list|<
name|ImmutableList
argument_list|<
name|E
argument_list|>
argument_list|>
operator|)
name|tupleList
return|;
block|}
return|return
name|builder
operator|.
name|build
argument_list|()
return|;
block|}
comment|/** Creates a limit without a sort. */
specifier|public
name|HiveSubQRemoveRelBuilder
name|limit
parameter_list|(
name|int
name|offset
parameter_list|,
name|int
name|fetch
parameter_list|)
block|{
return|return
name|sortLimit
argument_list|(
name|offset
argument_list|,
name|fetch
argument_list|,
name|ImmutableList
operator|.
expr|<
name|RexNode
operator|>
name|of
argument_list|()
argument_list|)
return|;
block|}
comment|/** Creates a {@link Sort} by field ordinals.    *    *<p>Negative fields mean descending: -1 means field(0) descending,    * -2 means field(1) descending, etc.    */
specifier|public
name|HiveSubQRemoveRelBuilder
name|sort
parameter_list|(
name|int
modifier|...
name|fields
parameter_list|)
block|{
specifier|final
name|ImmutableList
operator|.
name|Builder
argument_list|<
name|RexNode
argument_list|>
name|builder
init|=
name|ImmutableList
operator|.
name|builder
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|field
range|:
name|fields
control|)
block|{
name|builder
operator|.
name|add
argument_list|(
name|field
operator|<
literal|0
condition|?
name|desc
argument_list|(
name|field
argument_list|(
operator|-
name|field
operator|-
literal|1
argument_list|)
argument_list|)
else|:
name|field
argument_list|(
name|field
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|sortLimit
argument_list|(
operator|-
literal|1
argument_list|,
operator|-
literal|1
argument_list|,
name|builder
operator|.
name|build
argument_list|()
argument_list|)
return|;
block|}
comment|/** Creates a {@link Sort} by expressions. */
specifier|public
name|HiveSubQRemoveRelBuilder
name|sort
parameter_list|(
name|RexNode
modifier|...
name|nodes
parameter_list|)
block|{
return|return
name|sortLimit
argument_list|(
operator|-
literal|1
argument_list|,
operator|-
literal|1
argument_list|,
name|ImmutableList
operator|.
name|copyOf
argument_list|(
name|nodes
argument_list|)
argument_list|)
return|;
block|}
comment|/** Creates a {@link Sort} by expressions. */
specifier|public
name|HiveSubQRemoveRelBuilder
name|sort
parameter_list|(
name|Iterable
argument_list|<
name|?
extends|extends
name|RexNode
argument_list|>
name|nodes
parameter_list|)
block|{
return|return
name|sortLimit
argument_list|(
operator|-
literal|1
argument_list|,
operator|-
literal|1
argument_list|,
name|nodes
argument_list|)
return|;
block|}
comment|/** Creates a {@link Sort} by expressions, with limit and offset. */
specifier|public
name|HiveSubQRemoveRelBuilder
name|sortLimit
parameter_list|(
name|int
name|offset
parameter_list|,
name|int
name|fetch
parameter_list|,
name|RexNode
modifier|...
name|nodes
parameter_list|)
block|{
return|return
name|sortLimit
argument_list|(
name|offset
argument_list|,
name|fetch
argument_list|,
name|ImmutableList
operator|.
name|copyOf
argument_list|(
name|nodes
argument_list|)
argument_list|)
return|;
block|}
comment|/** Creates a {@link Sort} by a list of expressions, with limit and offset.    *    * @param offset Number of rows to skip; non-positive means don't skip any    * @param fetch Maximum number of rows to fetch; negative means no limit    * @param nodes Sort expressions    */
specifier|public
name|HiveSubQRemoveRelBuilder
name|sortLimit
parameter_list|(
name|int
name|offset
parameter_list|,
name|int
name|fetch
parameter_list|,
name|Iterable
argument_list|<
name|?
extends|extends
name|RexNode
argument_list|>
name|nodes
parameter_list|)
block|{
specifier|final
name|List
argument_list|<
name|RelFieldCollation
argument_list|>
name|fieldCollations
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
specifier|final
name|RelDataType
name|inputRowType
init|=
name|peek
argument_list|()
operator|.
name|getRowType
argument_list|()
decl_stmt|;
specifier|final
name|List
argument_list|<
name|RexNode
argument_list|>
name|extraNodes
init|=
name|projects
argument_list|(
name|inputRowType
argument_list|)
decl_stmt|;
specifier|final
name|List
argument_list|<
name|RexNode
argument_list|>
name|originalExtraNodes
init|=
name|ImmutableList
operator|.
name|copyOf
argument_list|(
name|extraNodes
argument_list|)
decl_stmt|;
for|for
control|(
name|RexNode
name|node
range|:
name|nodes
control|)
block|{
name|fieldCollations
operator|.
name|add
argument_list|(
name|collation
argument_list|(
name|node
argument_list|,
name|RelFieldCollation
operator|.
name|Direction
operator|.
name|ASCENDING
argument_list|,
literal|null
argument_list|,
name|extraNodes
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|final
name|RexNode
name|offsetNode
init|=
name|offset
operator|<=
literal|0
condition|?
literal|null
else|:
name|literal
argument_list|(
name|offset
argument_list|)
decl_stmt|;
specifier|final
name|RexNode
name|fetchNode
init|=
name|fetch
operator|<
literal|0
condition|?
literal|null
else|:
name|literal
argument_list|(
name|fetch
argument_list|)
decl_stmt|;
if|if
condition|(
name|offsetNode
operator|==
literal|null
operator|&&
name|fetch
operator|==
literal|0
condition|)
block|{
return|return
name|empty
argument_list|()
return|;
block|}
if|if
condition|(
name|offsetNode
operator|==
literal|null
operator|&&
name|fetchNode
operator|==
literal|null
operator|&&
name|fieldCollations
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return
name|this
return|;
comment|// sort is trivial
block|}
specifier|final
name|boolean
name|addedFields
init|=
name|extraNodes
operator|.
name|size
argument_list|()
operator|>
name|originalExtraNodes
operator|.
name|size
argument_list|()
decl_stmt|;
if|if
condition|(
name|fieldCollations
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
assert|assert
operator|!
name|addedFields
assert|;
name|RelNode
name|top
init|=
name|peek
argument_list|()
decl_stmt|;
if|if
condition|(
name|top
operator|instanceof
name|Sort
condition|)
block|{
specifier|final
name|Sort
name|sort2
init|=
operator|(
name|Sort
operator|)
name|top
decl_stmt|;
if|if
condition|(
name|sort2
operator|.
name|offset
operator|==
literal|null
operator|&&
name|sort2
operator|.
name|fetch
operator|==
literal|null
condition|)
block|{
name|stack
operator|.
name|pop
argument_list|()
expr_stmt|;
name|push
argument_list|(
name|sort2
operator|.
name|getInput
argument_list|()
argument_list|)
expr_stmt|;
specifier|final
name|RelNode
name|sort
init|=
name|sortFactory
operator|.
name|createSort
argument_list|(
name|build
argument_list|()
argument_list|,
name|sort2
operator|.
name|collation
argument_list|,
name|offsetNode
argument_list|,
name|fetchNode
argument_list|)
decl_stmt|;
name|push
argument_list|(
name|sort
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
block|}
if|if
condition|(
name|top
operator|instanceof
name|Project
condition|)
block|{
specifier|final
name|Project
name|project
init|=
operator|(
name|Project
operator|)
name|top
decl_stmt|;
if|if
condition|(
name|project
operator|.
name|getInput
argument_list|()
operator|instanceof
name|Sort
condition|)
block|{
specifier|final
name|Sort
name|sort2
init|=
operator|(
name|Sort
operator|)
name|project
operator|.
name|getInput
argument_list|()
decl_stmt|;
if|if
condition|(
name|sort2
operator|.
name|offset
operator|==
literal|null
operator|&&
name|sort2
operator|.
name|fetch
operator|==
literal|null
condition|)
block|{
name|stack
operator|.
name|pop
argument_list|()
expr_stmt|;
name|push
argument_list|(
name|sort2
operator|.
name|getInput
argument_list|()
argument_list|)
expr_stmt|;
specifier|final
name|RelNode
name|sort
init|=
name|sortFactory
operator|.
name|createSort
argument_list|(
name|build
argument_list|()
argument_list|,
name|sort2
operator|.
name|collation
argument_list|,
name|offsetNode
argument_list|,
name|fetchNode
argument_list|)
decl_stmt|;
name|push
argument_list|(
name|sort
argument_list|)
expr_stmt|;
name|project
argument_list|(
name|project
operator|.
name|getProjects
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
block|}
block|}
block|}
if|if
condition|(
name|addedFields
condition|)
block|{
name|project
argument_list|(
name|extraNodes
argument_list|)
expr_stmt|;
block|}
specifier|final
name|RelNode
name|sort
init|=
name|sortFactory
operator|.
name|createSort
argument_list|(
name|build
argument_list|()
argument_list|,
name|RelCollations
operator|.
name|of
argument_list|(
name|fieldCollations
argument_list|)
argument_list|,
name|offsetNode
argument_list|,
name|fetchNode
argument_list|)
decl_stmt|;
name|push
argument_list|(
name|sort
argument_list|)
expr_stmt|;
if|if
condition|(
name|addedFields
condition|)
block|{
name|project
argument_list|(
name|originalExtraNodes
argument_list|)
expr_stmt|;
block|}
return|return
name|this
return|;
block|}
specifier|private
specifier|static
name|RelFieldCollation
name|collation
parameter_list|(
name|RexNode
name|node
parameter_list|,
name|RelFieldCollation
operator|.
name|Direction
name|direction
parameter_list|,
name|RelFieldCollation
operator|.
name|NullDirection
name|nullDirection
parameter_list|,
name|List
argument_list|<
name|RexNode
argument_list|>
name|extraNodes
parameter_list|)
block|{
switch|switch
condition|(
name|node
operator|.
name|getKind
argument_list|()
condition|)
block|{
case|case
name|INPUT_REF
case|:
return|return
operator|new
name|RelFieldCollation
argument_list|(
operator|(
operator|(
name|RexInputRef
operator|)
name|node
operator|)
operator|.
name|getIndex
argument_list|()
argument_list|,
name|direction
argument_list|,
name|Util
operator|.
name|first
argument_list|(
name|nullDirection
argument_list|,
name|direction
operator|.
name|defaultNullDirection
argument_list|()
argument_list|)
argument_list|)
return|;
case|case
name|DESCENDING
case|:
return|return
name|collation
argument_list|(
operator|(
operator|(
name|RexCall
operator|)
name|node
operator|)
operator|.
name|getOperands
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|,
name|RelFieldCollation
operator|.
name|Direction
operator|.
name|DESCENDING
argument_list|,
name|nullDirection
argument_list|,
name|extraNodes
argument_list|)
return|;
case|case
name|NULLS_FIRST
case|:
return|return
name|collation
argument_list|(
operator|(
operator|(
name|RexCall
operator|)
name|node
operator|)
operator|.
name|getOperands
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|,
name|direction
argument_list|,
name|RelFieldCollation
operator|.
name|NullDirection
operator|.
name|FIRST
argument_list|,
name|extraNodes
argument_list|)
return|;
case|case
name|NULLS_LAST
case|:
return|return
name|collation
argument_list|(
operator|(
operator|(
name|RexCall
operator|)
name|node
operator|)
operator|.
name|getOperands
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|,
name|direction
argument_list|,
name|RelFieldCollation
operator|.
name|NullDirection
operator|.
name|LAST
argument_list|,
name|extraNodes
argument_list|)
return|;
default|default:
specifier|final
name|int
name|fieldIndex
init|=
name|extraNodes
operator|.
name|size
argument_list|()
decl_stmt|;
name|extraNodes
operator|.
name|add
argument_list|(
name|node
argument_list|)
expr_stmt|;
return|return
operator|new
name|RelFieldCollation
argument_list|(
name|fieldIndex
argument_list|,
name|direction
argument_list|,
name|Util
operator|.
name|first
argument_list|(
name|nullDirection
argument_list|,
name|direction
operator|.
name|defaultNullDirection
argument_list|()
argument_list|)
argument_list|)
return|;
block|}
block|}
comment|/**    * Creates a projection that converts the current relational expression's    * output to a desired row type.    *    * @param castRowType row type after cast    * @param rename      if true, use field names from castRowType; if false,    *                    preserve field names from rel    */
specifier|public
name|HiveSubQRemoveRelBuilder
name|convert
parameter_list|(
name|RelDataType
name|castRowType
parameter_list|,
name|boolean
name|rename
parameter_list|)
block|{
specifier|final
name|RelNode
name|r
init|=
name|build
argument_list|()
decl_stmt|;
specifier|final
name|RelNode
name|r2
init|=
name|RelOptUtil
operator|.
name|createCastRel
argument_list|(
name|r
argument_list|,
name|castRowType
argument_list|,
name|rename
argument_list|,
name|projectFactory
argument_list|)
decl_stmt|;
name|push
argument_list|(
name|r2
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
specifier|public
name|HiveSubQRemoveRelBuilder
name|permute
parameter_list|(
name|Mapping
name|mapping
parameter_list|)
block|{
assert|assert
name|mapping
operator|.
name|getMappingType
argument_list|()
operator|.
name|isSingleSource
argument_list|()
assert|;
assert|assert
name|mapping
operator|.
name|getMappingType
argument_list|()
operator|.
name|isMandatorySource
argument_list|()
assert|;
if|if
condition|(
name|mapping
operator|.
name|isIdentity
argument_list|()
condition|)
block|{
return|return
name|this
return|;
block|}
specifier|final
name|List
argument_list|<
name|RexNode
argument_list|>
name|exprList
init|=
name|Lists
operator|.
name|newArrayList
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|mapping
operator|.
name|getTargetCount
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|exprList
operator|.
name|add
argument_list|(
name|field
argument_list|(
name|mapping
operator|.
name|getSource
argument_list|(
name|i
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|project
argument_list|(
name|exprList
argument_list|)
return|;
block|}
specifier|public
name|HiveSubQRemoveRelBuilder
name|aggregate
parameter_list|(
name|GroupKey
name|groupKey
parameter_list|,
name|List
argument_list|<
name|AggregateCall
argument_list|>
name|aggregateCalls
parameter_list|)
block|{
return|return
name|aggregate
argument_list|(
name|groupKey
argument_list|,
name|Lists
operator|.
name|transform
argument_list|(
name|aggregateCalls
argument_list|,
operator|new
name|Function
argument_list|<
name|AggregateCall
argument_list|,
name|AggCall
argument_list|>
argument_list|()
block|{
specifier|public
name|AggCall
name|apply
parameter_list|(
name|AggregateCall
name|input
parameter_list|)
block|{
return|return
operator|new
name|AggCallImpl2
argument_list|(
name|input
argument_list|)
return|;
block|}
block|}
argument_list|)
argument_list|)
return|;
block|}
comment|/** Clears the stack.    *    *<p>The builder's state is now the same as when it was created. */
specifier|public
name|void
name|clear
parameter_list|()
block|{
name|stack
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
specifier|protected
name|String
name|getAlias
parameter_list|()
block|{
specifier|final
name|Frame
name|frame
init|=
name|stack
operator|.
name|peek
argument_list|()
decl_stmt|;
return|return
name|frame
operator|.
name|right
operator|.
name|size
argument_list|()
operator|==
literal|1
condition|?
name|frame
operator|.
name|right
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|left
else|:
literal|null
return|;
block|}
comment|/** Information necessary to create a call to an aggregate function.    *    * @see RelBuilder#aggregateCall */
specifier|public
interface|interface
name|AggCall
block|{   }
comment|/** Information necessary to create the GROUP BY clause of an Aggregate.    *    * @see RelBuilder#groupKey */
specifier|public
interface|interface
name|GroupKey
block|{
comment|/** Assigns an alias to this group key.      *      *<p>Used to assign field names in the {@code group} operation. */
name|GroupKey
name|alias
parameter_list|(
name|String
name|alias
parameter_list|)
function_decl|;
block|}
comment|/** Implementation of {@link RelBuilder.GroupKey}. */
specifier|protected
specifier|static
class|class
name|GroupKeyImpl
implements|implements
name|GroupKey
block|{
specifier|final
name|ImmutableList
argument_list|<
name|RexNode
argument_list|>
name|nodes
decl_stmt|;
specifier|final
name|boolean
name|indicator
decl_stmt|;
specifier|final
name|ImmutableList
argument_list|<
name|ImmutableList
argument_list|<
name|RexNode
argument_list|>
argument_list|>
name|nodeLists
decl_stmt|;
specifier|final
name|String
name|alias
decl_stmt|;
name|GroupKeyImpl
parameter_list|(
name|ImmutableList
argument_list|<
name|RexNode
argument_list|>
name|nodes
parameter_list|,
name|boolean
name|indicator
parameter_list|,
name|ImmutableList
argument_list|<
name|ImmutableList
argument_list|<
name|RexNode
argument_list|>
argument_list|>
name|nodeLists
parameter_list|,
name|String
name|alias
parameter_list|)
block|{
name|this
operator|.
name|nodes
operator|=
name|Preconditions
operator|.
name|checkNotNull
argument_list|(
name|nodes
argument_list|)
expr_stmt|;
name|this
operator|.
name|indicator
operator|=
name|indicator
expr_stmt|;
name|this
operator|.
name|nodeLists
operator|=
name|nodeLists
expr_stmt|;
name|this
operator|.
name|alias
operator|=
name|alias
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
name|alias
operator|==
literal|null
condition|?
name|nodes
operator|.
name|toString
argument_list|()
else|:
name|nodes
operator|+
literal|" as "
operator|+
name|alias
return|;
block|}
specifier|public
name|GroupKey
name|alias
parameter_list|(
name|String
name|alias
parameter_list|)
block|{
return|return
name|Objects
operator|.
name|equals
argument_list|(
name|this
operator|.
name|alias
argument_list|,
name|alias
argument_list|)
condition|?
name|this
else|:
operator|new
name|GroupKeyImpl
argument_list|(
name|nodes
argument_list|,
name|indicator
argument_list|,
name|nodeLists
argument_list|,
name|alias
argument_list|)
return|;
block|}
block|}
comment|/** Implementation of {@link RelBuilder.AggCall}. */
specifier|private
specifier|static
class|class
name|AggCallImpl
implements|implements
name|AggCall
block|{
specifier|private
specifier|final
name|SqlAggFunction
name|aggFunction
decl_stmt|;
specifier|private
specifier|final
name|boolean
name|distinct
decl_stmt|;
specifier|private
specifier|final
name|RexNode
name|filter
decl_stmt|;
specifier|private
specifier|final
name|String
name|alias
decl_stmt|;
specifier|private
specifier|final
name|ImmutableList
argument_list|<
name|RexNode
argument_list|>
name|operands
decl_stmt|;
name|AggCallImpl
parameter_list|(
name|SqlAggFunction
name|aggFunction
parameter_list|,
name|boolean
name|distinct
parameter_list|,
name|RexNode
name|filter
parameter_list|,
name|String
name|alias
parameter_list|,
name|ImmutableList
argument_list|<
name|RexNode
argument_list|>
name|operands
parameter_list|)
block|{
name|this
operator|.
name|aggFunction
operator|=
name|aggFunction
expr_stmt|;
name|this
operator|.
name|distinct
operator|=
name|distinct
expr_stmt|;
name|this
operator|.
name|filter
operator|=
name|filter
expr_stmt|;
name|this
operator|.
name|alias
operator|=
name|alias
expr_stmt|;
name|this
operator|.
name|operands
operator|=
name|operands
expr_stmt|;
block|}
block|}
comment|/** Implementation of {@link RelBuilder.AggCall} that wraps an    * {@link AggregateCall}. */
specifier|private
specifier|static
class|class
name|AggCallImpl2
implements|implements
name|AggCall
block|{
specifier|private
specifier|final
name|AggregateCall
name|aggregateCall
decl_stmt|;
name|AggCallImpl2
parameter_list|(
name|AggregateCall
name|aggregateCall
parameter_list|)
block|{
name|this
operator|.
name|aggregateCall
operator|=
name|Preconditions
operator|.
name|checkNotNull
argument_list|(
name|aggregateCall
argument_list|)
expr_stmt|;
block|}
block|}
comment|/** Builder stack frame.    *    *<p>Describes a previously created relational expression and    * information about how table aliases map into its row type. */
specifier|private
specifier|static
class|class
name|Frame
block|{
specifier|static
specifier|final
name|Function
argument_list|<
name|Pair
argument_list|<
name|String
argument_list|,
name|RelDataType
argument_list|>
argument_list|,
name|List
argument_list|<
name|RelDataTypeField
argument_list|>
argument_list|>
name|FN
init|=
operator|new
name|Function
argument_list|<
name|Pair
argument_list|<
name|String
argument_list|,
name|RelDataType
argument_list|>
argument_list|,
name|List
argument_list|<
name|RelDataTypeField
argument_list|>
argument_list|>
argument_list|()
block|{
specifier|public
name|List
argument_list|<
name|RelDataTypeField
argument_list|>
name|apply
parameter_list|(
name|Pair
argument_list|<
name|String
argument_list|,
name|RelDataType
argument_list|>
name|input
parameter_list|)
block|{
return|return
name|input
operator|.
name|right
operator|.
name|getFieldList
argument_list|()
return|;
block|}
block|}
decl_stmt|;
specifier|final
name|RelNode
name|rel
decl_stmt|;
specifier|final
name|ImmutableList
argument_list|<
name|Pair
argument_list|<
name|String
argument_list|,
name|RelDataType
argument_list|>
argument_list|>
name|right
decl_stmt|;
specifier|private
name|Frame
parameter_list|(
name|RelNode
name|rel
parameter_list|,
name|ImmutableList
argument_list|<
name|Pair
argument_list|<
name|String
argument_list|,
name|RelDataType
argument_list|>
argument_list|>
name|pairs
parameter_list|)
block|{
name|this
operator|.
name|rel
operator|=
name|rel
expr_stmt|;
name|this
operator|.
name|right
operator|=
name|pairs
expr_stmt|;
block|}
specifier|private
name|Frame
parameter_list|(
name|RelNode
name|rel
parameter_list|)
block|{
name|this
argument_list|(
name|rel
argument_list|,
name|ImmutableList
operator|.
name|of
argument_list|(
name|Pair
operator|.
name|of
argument_list|(
name|deriveAlias
argument_list|(
name|rel
argument_list|)
argument_list|,
name|rel
operator|.
name|getRowType
argument_list|()
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|private
specifier|static
name|String
name|deriveAlias
parameter_list|(
name|RelNode
name|rel
parameter_list|)
block|{
if|if
condition|(
name|rel
operator|instanceof
name|TableScan
condition|)
block|{
specifier|final
name|List
argument_list|<
name|String
argument_list|>
name|names
init|=
name|rel
operator|.
name|getTable
argument_list|()
operator|.
name|getQualifiedName
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|names
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return
name|Util
operator|.
name|last
argument_list|(
name|names
argument_list|)
return|;
block|}
block|}
return|return
literal|null
return|;
block|}
name|List
argument_list|<
name|RelDataTypeField
argument_list|>
name|fields
parameter_list|()
block|{
return|return
name|CompositeList
operator|.
name|ofCopy
argument_list|(
name|Iterables
operator|.
name|transform
argument_list|(
name|right
argument_list|,
name|FN
argument_list|)
argument_list|)
return|;
block|}
block|}
comment|/** Shuttle that shifts a predicate's inputs to the left, replacing early    * ones with references to a    * {@link org.apache.calcite.rex.RexCorrelVariable}. */
specifier|private
class|class
name|Shifter
extends|extends
name|RexShuttle
block|{
specifier|private
specifier|final
name|RelNode
name|left
decl_stmt|;
specifier|private
specifier|final
name|CorrelationId
name|id
decl_stmt|;
specifier|private
specifier|final
name|RelNode
name|right
decl_stmt|;
name|Shifter
parameter_list|(
name|RelNode
name|left
parameter_list|,
name|CorrelationId
name|id
parameter_list|,
name|RelNode
name|right
parameter_list|)
block|{
name|this
operator|.
name|left
operator|=
name|left
expr_stmt|;
name|this
operator|.
name|id
operator|=
name|id
expr_stmt|;
name|this
operator|.
name|right
operator|=
name|right
expr_stmt|;
block|}
specifier|public
name|RexNode
name|visitInputRef
parameter_list|(
name|RexInputRef
name|inputRef
parameter_list|)
block|{
specifier|final
name|RelDataType
name|leftRowType
init|=
name|left
operator|.
name|getRowType
argument_list|()
decl_stmt|;
specifier|final
name|RexBuilder
name|rexBuilder
init|=
name|getRexBuilder
argument_list|()
decl_stmt|;
specifier|final
name|int
name|leftCount
init|=
name|leftRowType
operator|.
name|getFieldCount
argument_list|()
decl_stmt|;
if|if
condition|(
name|inputRef
operator|.
name|getIndex
argument_list|()
operator|<
name|leftCount
condition|)
block|{
specifier|final
name|RexNode
name|v
init|=
name|rexBuilder
operator|.
name|makeCorrel
argument_list|(
name|leftRowType
argument_list|,
name|id
argument_list|)
decl_stmt|;
return|return
name|rexBuilder
operator|.
name|makeFieldAccess
argument_list|(
name|v
argument_list|,
name|inputRef
operator|.
name|getIndex
argument_list|()
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|rexBuilder
operator|.
name|makeInputRef
argument_list|(
name|right
argument_list|,
name|inputRef
operator|.
name|getIndex
argument_list|()
operator|-
name|leftCount
argument_list|)
return|;
block|}
block|}
block|}
block|}
end_class

begin_comment
comment|// End RelBuilder.java
end_comment

end_unit

