begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|optimizer
operator|.
name|optiq
package|;
end_package

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
operator|.
name|Entry
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|optimizer
operator|.
name|optiq
operator|.
name|reloperators
operator|.
name|HiveJoinRel
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|relopt
operator|.
name|RelOptUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|relopt
operator|.
name|RelOptUtil
operator|.
name|InputReferencedVisitor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|rex
operator|.
name|RexNode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|eigenbase
operator|.
name|sql
operator|.
name|SqlKind
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|ImmutableList
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|ImmutableMap
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|ImmutableSet
import|;
end_import

begin_comment
comment|/**  * Utility for inspecting Join Conditions.<br>  *<p>  * Main Elements:<br>  * 1. JoinPredicateInfo - represents Join Condition.<br>  * 2. JoinLeafPredicateInfo - represents leaf predicates with in join condition.  *   * TODO: Move this to Optiq Framework  */
end_comment

begin_class
specifier|public
class|class
name|JoinUtil
block|{
comment|/**    * JoinPredicateInfo represents Join condition; JoinPredicate Info uses    * JoinLeafPredicateInfo to represent individual conjunctive elements in the    * predicate.<br>    * JoinPredicateInfo = JoinLeafPredicateInfo1 and JoinLeafPredicateInfo2...<br>    *<p>    * JoinPredicateInfo:<br>    * 1. preserves the order of conjuctive elements for    * equi-join(m_equiJoinPredicateElements)<br>    * 2. Stores set of projection indexes from left and right child which is part    * of equi join keys; the indexes are both in child and Join node schema.<br>    * 3. Keeps a map of projection indexes that are part of join keys to list of    * conjuctive elements(JoinLeafPredicateInfo) that uses them.    *     */
specifier|public
specifier|static
class|class
name|JoinPredicateInfo
block|{
specifier|private
specifier|final
name|ImmutableList
argument_list|<
name|JoinLeafPredicateInfo
argument_list|>
name|m_nonEquiJoinPredicateElements
decl_stmt|;
specifier|private
specifier|final
name|ImmutableList
argument_list|<
name|JoinLeafPredicateInfo
argument_list|>
name|m_equiJoinPredicateElements
decl_stmt|;
specifier|private
specifier|final
name|ImmutableSet
argument_list|<
name|Integer
argument_list|>
name|m_projsFromLeftPartOfJoinKeysInChildSchema
decl_stmt|;
specifier|private
specifier|final
name|ImmutableSet
argument_list|<
name|Integer
argument_list|>
name|m_projsFromRightPartOfJoinKeysInChildSchema
decl_stmt|;
specifier|private
specifier|final
name|ImmutableSet
argument_list|<
name|Integer
argument_list|>
name|m_projsFromRightPartOfJoinKeysInJoinSchema
decl_stmt|;
specifier|private
specifier|final
name|ImmutableMap
argument_list|<
name|Integer
argument_list|,
name|ImmutableList
argument_list|<
name|JoinLeafPredicateInfo
argument_list|>
argument_list|>
name|m_mapOfProjIndxInJoinSchemaToLeafPInfo
decl_stmt|;
specifier|public
name|JoinPredicateInfo
parameter_list|(
name|List
argument_list|<
name|JoinLeafPredicateInfo
argument_list|>
name|nonEquiJoinPredicateElements
parameter_list|,
name|List
argument_list|<
name|JoinLeafPredicateInfo
argument_list|>
name|equiJoinPredicateElements
parameter_list|,
name|Set
argument_list|<
name|Integer
argument_list|>
name|projsFromLeftPartOfJoinKeysInChildSchema
parameter_list|,
name|Set
argument_list|<
name|Integer
argument_list|>
name|projsFromRightPartOfJoinKeysInChildSchema
parameter_list|,
name|Set
argument_list|<
name|Integer
argument_list|>
name|projsFromRightPartOfJoinKeysInJoinSchema
parameter_list|,
name|Map
argument_list|<
name|Integer
argument_list|,
name|ImmutableList
argument_list|<
name|JoinLeafPredicateInfo
argument_list|>
argument_list|>
name|mapOfProjIndxInJoinSchemaToLeafPInfo
parameter_list|)
block|{
name|m_nonEquiJoinPredicateElements
operator|=
name|ImmutableList
operator|.
name|copyOf
argument_list|(
name|nonEquiJoinPredicateElements
argument_list|)
expr_stmt|;
name|m_equiJoinPredicateElements
operator|=
name|ImmutableList
operator|.
name|copyOf
argument_list|(
name|equiJoinPredicateElements
argument_list|)
expr_stmt|;
name|m_projsFromLeftPartOfJoinKeysInChildSchema
operator|=
name|ImmutableSet
operator|.
name|copyOf
argument_list|(
name|projsFromLeftPartOfJoinKeysInChildSchema
argument_list|)
expr_stmt|;
name|m_projsFromRightPartOfJoinKeysInChildSchema
operator|=
name|ImmutableSet
operator|.
name|copyOf
argument_list|(
name|projsFromRightPartOfJoinKeysInChildSchema
argument_list|)
expr_stmt|;
name|m_projsFromRightPartOfJoinKeysInJoinSchema
operator|=
name|ImmutableSet
operator|.
name|copyOf
argument_list|(
name|projsFromRightPartOfJoinKeysInJoinSchema
argument_list|)
expr_stmt|;
name|m_mapOfProjIndxInJoinSchemaToLeafPInfo
operator|=
name|ImmutableMap
operator|.
name|copyOf
argument_list|(
name|mapOfProjIndxInJoinSchemaToLeafPInfo
argument_list|)
expr_stmt|;
block|}
specifier|public
name|List
argument_list|<
name|JoinLeafPredicateInfo
argument_list|>
name|getNonEquiJoinPredicateElements
parameter_list|()
block|{
return|return
name|m_nonEquiJoinPredicateElements
return|;
block|}
specifier|public
name|List
argument_list|<
name|JoinLeafPredicateInfo
argument_list|>
name|getEquiJoinPredicateElements
parameter_list|()
block|{
return|return
name|m_equiJoinPredicateElements
return|;
block|}
specifier|public
name|Set
argument_list|<
name|Integer
argument_list|>
name|getProjsFromLeftPartOfJoinKeysInChildSchema
parameter_list|()
block|{
return|return
name|m_projsFromLeftPartOfJoinKeysInChildSchema
return|;
block|}
specifier|public
name|Set
argument_list|<
name|Integer
argument_list|>
name|getProjsFromRightPartOfJoinKeysInChildSchema
parameter_list|()
block|{
return|return
name|m_projsFromRightPartOfJoinKeysInChildSchema
return|;
block|}
comment|/**      * NOTE: Join Schema = left Schema + (right Schema offset by      * left.fieldcount). Hence its ok to return projections from left in child      * schema.      */
specifier|public
name|Set
argument_list|<
name|Integer
argument_list|>
name|getProjsFromLeftPartOfJoinKeysInJoinSchema
parameter_list|()
block|{
return|return
name|m_projsFromLeftPartOfJoinKeysInChildSchema
return|;
block|}
specifier|public
name|Set
argument_list|<
name|Integer
argument_list|>
name|getProjsFromRightPartOfJoinKeysInJoinSchema
parameter_list|()
block|{
return|return
name|m_projsFromRightPartOfJoinKeysInJoinSchema
return|;
block|}
specifier|public
name|Map
argument_list|<
name|Integer
argument_list|,
name|ImmutableList
argument_list|<
name|JoinLeafPredicateInfo
argument_list|>
argument_list|>
name|getMapOfProjIndxToLeafPInfo
parameter_list|()
block|{
return|return
name|m_mapOfProjIndxInJoinSchemaToLeafPInfo
return|;
block|}
specifier|public
specifier|static
name|JoinPredicateInfo
name|constructJoinPredicateInfo
parameter_list|(
name|HiveJoinRel
name|j
parameter_list|)
block|{
return|return
name|constructJoinPredicateInfo
argument_list|(
name|j
argument_list|,
name|j
operator|.
name|getCondition
argument_list|()
argument_list|)
return|;
block|}
specifier|public
specifier|static
name|JoinPredicateInfo
name|constructJoinPredicateInfo
parameter_list|(
name|HiveJoinRel
name|j
parameter_list|,
name|RexNode
name|predicate
parameter_list|)
block|{
name|JoinPredicateInfo
name|jpi
init|=
literal|null
decl_stmt|;
name|JoinLeafPredicateInfo
name|jlpi
init|=
literal|null
decl_stmt|;
name|List
argument_list|<
name|JoinLeafPredicateInfo
argument_list|>
name|equiLPIList
init|=
operator|new
name|ArrayList
argument_list|<
name|JoinLeafPredicateInfo
argument_list|>
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|JoinLeafPredicateInfo
argument_list|>
name|nonEquiLPIList
init|=
operator|new
name|ArrayList
argument_list|<
name|JoinLeafPredicateInfo
argument_list|>
argument_list|()
decl_stmt|;
name|Set
argument_list|<
name|Integer
argument_list|>
name|projsFromLeftPartOfJoinKeys
init|=
operator|new
name|HashSet
argument_list|<
name|Integer
argument_list|>
argument_list|()
decl_stmt|;
name|Set
argument_list|<
name|Integer
argument_list|>
name|projsFromRightPartOfJoinKeys
init|=
operator|new
name|HashSet
argument_list|<
name|Integer
argument_list|>
argument_list|()
decl_stmt|;
name|Set
argument_list|<
name|Integer
argument_list|>
name|projsFromRightPartOfJoinKeysInJoinSchema
init|=
operator|new
name|HashSet
argument_list|<
name|Integer
argument_list|>
argument_list|()
decl_stmt|;
name|Map
argument_list|<
name|Integer
argument_list|,
name|List
argument_list|<
name|JoinLeafPredicateInfo
argument_list|>
argument_list|>
name|tmpMapOfProjIndxInJoinSchemaToLeafPInfo
init|=
operator|new
name|HashMap
argument_list|<
name|Integer
argument_list|,
name|List
argument_list|<
name|JoinLeafPredicateInfo
argument_list|>
argument_list|>
argument_list|()
decl_stmt|;
name|Map
argument_list|<
name|Integer
argument_list|,
name|ImmutableList
argument_list|<
name|JoinLeafPredicateInfo
argument_list|>
argument_list|>
name|mapOfProjIndxInJoinSchemaToLeafPInfo
init|=
operator|new
name|HashMap
argument_list|<
name|Integer
argument_list|,
name|ImmutableList
argument_list|<
name|JoinLeafPredicateInfo
argument_list|>
argument_list|>
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|JoinLeafPredicateInfo
argument_list|>
name|tmpJLPILst
init|=
literal|null
decl_stmt|;
name|int
name|rightOffSet
init|=
name|j
operator|.
name|getLeft
argument_list|()
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldCount
argument_list|()
decl_stmt|;
name|int
name|projIndxInJoin
decl_stmt|;
name|List
argument_list|<
name|RexNode
argument_list|>
name|conjuctiveElements
decl_stmt|;
name|todo
argument_list|(
literal|"Move this to Optiq"
argument_list|)
expr_stmt|;
comment|// 1. Decompose Join condition to a number of leaf predicates
comment|// (conjuctive elements)
name|conjuctiveElements
operator|=
name|RelOptUtil
operator|.
name|conjunctions
argument_list|(
name|predicate
argument_list|)
expr_stmt|;
comment|// 2. Walk through leaf predicates building up JoinLeafPredicateInfo
for|for
control|(
name|RexNode
name|ce
range|:
name|conjuctiveElements
control|)
block|{
comment|// 2.1 Construct JoinLeafPredicateInfo
name|jlpi
operator|=
name|JoinLeafPredicateInfo
operator|.
name|constructJoinLeafPredicateInfo
argument_list|(
name|j
argument_list|,
name|ce
argument_list|)
expr_stmt|;
comment|// 2.2 Classify leaf predicate as Equi vs Non Equi
if|if
condition|(
name|jlpi
operator|.
name|m_comparisonType
operator|.
name|equals
argument_list|(
name|SqlKind
operator|.
name|EQUALS
argument_list|)
condition|)
block|{
name|equiLPIList
operator|.
name|add
argument_list|(
name|jlpi
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|nonEquiLPIList
operator|.
name|add
argument_list|(
name|jlpi
argument_list|)
expr_stmt|;
block|}
comment|// 2.3 Maintain join keys coming from left vs right (in child&
comment|// Join Schema)
name|projsFromLeftPartOfJoinKeys
operator|.
name|addAll
argument_list|(
name|jlpi
operator|.
name|getProjsFromLeftPartOfJoinKeysInChildSchema
argument_list|()
argument_list|)
expr_stmt|;
name|projsFromRightPartOfJoinKeys
operator|.
name|addAll
argument_list|(
name|jlpi
operator|.
name|getProjsFromRightPartOfJoinKeysInChildSchema
argument_list|()
argument_list|)
expr_stmt|;
name|projsFromRightPartOfJoinKeysInJoinSchema
operator|.
name|addAll
argument_list|(
name|jlpi
operator|.
name|getProjsFromRightPartOfJoinKeysInJoinSchema
argument_list|()
argument_list|)
expr_stmt|;
comment|// 2.4 Update Join Key to JoinLeafPredicateInfo map with keys
comment|// from left
for|for
control|(
name|Integer
name|projIndx
range|:
name|jlpi
operator|.
name|getProjsFromLeftPartOfJoinKeysInChildSchema
argument_list|()
control|)
block|{
name|tmpJLPILst
operator|=
name|tmpMapOfProjIndxInJoinSchemaToLeafPInfo
operator|.
name|get
argument_list|(
name|projIndx
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmpJLPILst
operator|==
literal|null
condition|)
name|tmpJLPILst
operator|=
operator|new
name|ArrayList
argument_list|<
name|JoinLeafPredicateInfo
argument_list|>
argument_list|()
expr_stmt|;
name|tmpJLPILst
operator|.
name|add
argument_list|(
name|jlpi
argument_list|)
expr_stmt|;
name|tmpMapOfProjIndxInJoinSchemaToLeafPInfo
operator|.
name|put
argument_list|(
name|projIndx
argument_list|,
name|tmpJLPILst
argument_list|)
expr_stmt|;
block|}
comment|// 2.5 Update Join Key to JoinLeafPredicateInfo map with keys
comment|// from right
for|for
control|(
name|Integer
name|projIndx
range|:
name|jlpi
operator|.
name|getProjsFromRightPartOfJoinKeysInChildSchema
argument_list|()
control|)
block|{
name|projIndxInJoin
operator|=
name|projIndx
operator|+
name|rightOffSet
expr_stmt|;
name|tmpJLPILst
operator|=
name|tmpMapOfProjIndxInJoinSchemaToLeafPInfo
operator|.
name|get
argument_list|(
name|projIndxInJoin
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmpJLPILst
operator|==
literal|null
condition|)
name|tmpJLPILst
operator|=
operator|new
name|ArrayList
argument_list|<
name|JoinLeafPredicateInfo
argument_list|>
argument_list|()
expr_stmt|;
name|tmpJLPILst
operator|.
name|add
argument_list|(
name|jlpi
argument_list|)
expr_stmt|;
name|tmpMapOfProjIndxInJoinSchemaToLeafPInfo
operator|.
name|put
argument_list|(
name|projIndxInJoin
argument_list|,
name|tmpJLPILst
argument_list|)
expr_stmt|;
block|}
block|}
comment|// 3. Update Update Join Key to List<JoinLeafPredicateInfo> to use
comment|// ImmutableList
for|for
control|(
name|Entry
argument_list|<
name|Integer
argument_list|,
name|List
argument_list|<
name|JoinLeafPredicateInfo
argument_list|>
argument_list|>
name|e
range|:
name|tmpMapOfProjIndxInJoinSchemaToLeafPInfo
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|mapOfProjIndxInJoinSchemaToLeafPInfo
operator|.
name|put
argument_list|(
name|e
operator|.
name|getKey
argument_list|()
argument_list|,
name|ImmutableList
operator|.
name|copyOf
argument_list|(
name|e
operator|.
name|getValue
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// 4. Construct JoinPredicateInfo
name|jpi
operator|=
operator|new
name|JoinPredicateInfo
argument_list|(
name|nonEquiLPIList
argument_list|,
name|equiLPIList
argument_list|,
name|projsFromLeftPartOfJoinKeys
argument_list|,
name|projsFromRightPartOfJoinKeys
argument_list|,
name|projsFromRightPartOfJoinKeysInJoinSchema
argument_list|,
name|mapOfProjIndxInJoinSchemaToLeafPInfo
argument_list|)
expr_stmt|;
return|return
name|jpi
return|;
block|}
block|}
comment|/**    * JoinLeafPredicateInfo represents leaf predicate in Join condition    * (conjuctive lement).<br>    *<p>    * JoinLeafPredicateInfo:<br>    * 1. Stores list of expressions from left and right child which is part of    * equi join keys.<br>    * 2. Stores set of projection indexes from left and right child which is part    * of equi join keys; the indexes are both in child and Join node schema.<br>    */
specifier|public
specifier|static
class|class
name|JoinLeafPredicateInfo
block|{
specifier|private
specifier|final
name|SqlKind
name|m_comparisonType
decl_stmt|;
specifier|private
specifier|final
name|ImmutableList
argument_list|<
name|RexNode
argument_list|>
name|m_joinKeyExprsFromLeft
decl_stmt|;
specifier|private
specifier|final
name|ImmutableList
argument_list|<
name|RexNode
argument_list|>
name|m_joinKeyExprsFromRight
decl_stmt|;
specifier|private
specifier|final
name|ImmutableSet
argument_list|<
name|Integer
argument_list|>
name|m_projsFromLeftPartOfJoinKeysInChildSchema
decl_stmt|;
specifier|private
specifier|final
name|ImmutableSet
argument_list|<
name|Integer
argument_list|>
name|m_projsFromRightPartOfJoinKeysInChildSchema
decl_stmt|;
specifier|private
specifier|final
name|ImmutableSet
argument_list|<
name|Integer
argument_list|>
name|m_projsFromRightPartOfJoinKeysInJoinSchema
decl_stmt|;
specifier|public
name|JoinLeafPredicateInfo
parameter_list|(
name|SqlKind
name|comparisonType
parameter_list|,
name|List
argument_list|<
name|RexNode
argument_list|>
name|joinKeyExprsFromLeft
parameter_list|,
name|List
argument_list|<
name|RexNode
argument_list|>
name|joinKeyExprsFromRight
parameter_list|,
name|Set
argument_list|<
name|Integer
argument_list|>
name|projsFromLeftPartOfJoinKeysInChildSchema
parameter_list|,
name|Set
argument_list|<
name|Integer
argument_list|>
name|projsFromRightPartOfJoinKeysInChildSchema
parameter_list|,
name|Set
argument_list|<
name|Integer
argument_list|>
name|projsFromRightPartOfJoinKeysInJoinSchema
parameter_list|)
block|{
name|m_comparisonType
operator|=
name|comparisonType
expr_stmt|;
name|m_joinKeyExprsFromLeft
operator|=
name|ImmutableList
operator|.
name|copyOf
argument_list|(
name|joinKeyExprsFromLeft
argument_list|)
expr_stmt|;
name|m_joinKeyExprsFromRight
operator|=
name|ImmutableList
operator|.
name|copyOf
argument_list|(
name|joinKeyExprsFromRight
argument_list|)
expr_stmt|;
name|m_projsFromLeftPartOfJoinKeysInChildSchema
operator|=
name|ImmutableSet
operator|.
name|copyOf
argument_list|(
name|projsFromLeftPartOfJoinKeysInChildSchema
argument_list|)
expr_stmt|;
name|m_projsFromRightPartOfJoinKeysInChildSchema
operator|=
name|ImmutableSet
operator|.
name|copyOf
argument_list|(
name|projsFromRightPartOfJoinKeysInChildSchema
argument_list|)
expr_stmt|;
name|m_projsFromRightPartOfJoinKeysInJoinSchema
operator|=
name|ImmutableSet
operator|.
name|copyOf
argument_list|(
name|projsFromRightPartOfJoinKeysInJoinSchema
argument_list|)
expr_stmt|;
block|}
specifier|public
name|List
argument_list|<
name|RexNode
argument_list|>
name|getJoinKeyExprsFromLeft
parameter_list|()
block|{
return|return
name|m_joinKeyExprsFromLeft
return|;
block|}
specifier|public
name|List
argument_list|<
name|RexNode
argument_list|>
name|getJoinKeyExprsFromRight
parameter_list|()
block|{
return|return
name|m_joinKeyExprsFromRight
return|;
block|}
specifier|public
name|Set
argument_list|<
name|Integer
argument_list|>
name|getProjsFromLeftPartOfJoinKeysInChildSchema
parameter_list|()
block|{
return|return
name|m_projsFromLeftPartOfJoinKeysInChildSchema
return|;
block|}
comment|/**      * NOTE: Join Schema = left Schema + (right Schema offset by      * left.fieldcount). Hence its ok to return projections from left in child      * schema.      */
specifier|public
name|Set
argument_list|<
name|Integer
argument_list|>
name|getProjsFromLeftPartOfJoinKeysInJoinSchema
parameter_list|()
block|{
return|return
name|m_projsFromLeftPartOfJoinKeysInChildSchema
return|;
block|}
specifier|public
name|Set
argument_list|<
name|Integer
argument_list|>
name|getProjsFromRightPartOfJoinKeysInChildSchema
parameter_list|()
block|{
return|return
name|m_projsFromRightPartOfJoinKeysInChildSchema
return|;
block|}
specifier|public
name|Set
argument_list|<
name|Integer
argument_list|>
name|getProjsFromRightPartOfJoinKeysInJoinSchema
parameter_list|()
block|{
return|return
name|m_projsFromRightPartOfJoinKeysInJoinSchema
return|;
block|}
specifier|public
specifier|static
name|JoinLeafPredicateInfo
name|constructJoinLeafPredicateInfo
parameter_list|(
name|HiveJoinRel
name|j
parameter_list|,
name|RexNode
name|pe
parameter_list|)
block|{
name|JoinLeafPredicateInfo
name|jlpi
init|=
literal|null
decl_stmt|;
name|List
argument_list|<
name|Integer
argument_list|>
name|filterNulls
init|=
operator|new
name|ArrayList
argument_list|<
name|Integer
argument_list|>
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|RexNode
argument_list|>
name|joinKeyExprsFromLeft
init|=
operator|new
name|ArrayList
argument_list|<
name|RexNode
argument_list|>
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|RexNode
argument_list|>
name|joinKeyExprsFromRight
init|=
operator|new
name|ArrayList
argument_list|<
name|RexNode
argument_list|>
argument_list|()
decl_stmt|;
name|Set
argument_list|<
name|Integer
argument_list|>
name|projsFromLeftPartOfJoinKeysInChildSchema
init|=
operator|new
name|HashSet
argument_list|<
name|Integer
argument_list|>
argument_list|()
decl_stmt|;
name|Set
argument_list|<
name|Integer
argument_list|>
name|projsFromRightPartOfJoinKeysInChildSchema
init|=
operator|new
name|HashSet
argument_list|<
name|Integer
argument_list|>
argument_list|()
decl_stmt|;
name|Set
argument_list|<
name|Integer
argument_list|>
name|projsFromRightPartOfJoinKeysInJoinSchema
init|=
operator|new
name|HashSet
argument_list|<
name|Integer
argument_list|>
argument_list|()
decl_stmt|;
name|int
name|rightOffSet
init|=
name|j
operator|.
name|getLeft
argument_list|()
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldCount
argument_list|()
decl_stmt|;
name|todo
argument_list|(
literal|"Move this to Optiq"
argument_list|)
expr_stmt|;
comment|// 1. Split leaf join predicate to expressions from left, right
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unused"
argument_list|)
name|RexNode
name|nonEquiPredicate
init|=
name|RelOptUtil
operator|.
name|splitJoinCondition
argument_list|(
name|j
operator|.
name|getSystemFieldList
argument_list|()
argument_list|,
name|j
operator|.
name|getLeft
argument_list|()
argument_list|,
name|j
operator|.
name|getRight
argument_list|()
argument_list|,
name|pe
argument_list|,
name|joinKeyExprsFromLeft
argument_list|,
name|joinKeyExprsFromRight
argument_list|,
name|filterNulls
argument_list|,
literal|null
argument_list|)
decl_stmt|;
comment|// 2. For left expressions, collect child projection indexes used
name|InputReferencedVisitor
name|irvLeft
init|=
operator|new
name|InputReferencedVisitor
argument_list|()
decl_stmt|;
name|irvLeft
operator|.
name|apply
argument_list|(
name|joinKeyExprsFromLeft
argument_list|)
expr_stmt|;
name|projsFromLeftPartOfJoinKeysInChildSchema
operator|.
name|addAll
argument_list|(
name|irvLeft
operator|.
name|inputPosReferenced
argument_list|)
expr_stmt|;
comment|// 3. For right expressions, collect child projection indexes used
name|InputReferencedVisitor
name|irvRight
init|=
operator|new
name|InputReferencedVisitor
argument_list|()
decl_stmt|;
name|irvRight
operator|.
name|apply
argument_list|(
name|joinKeyExprsFromRight
argument_list|)
expr_stmt|;
name|projsFromRightPartOfJoinKeysInChildSchema
operator|.
name|addAll
argument_list|(
name|irvRight
operator|.
name|inputPosReferenced
argument_list|)
expr_stmt|;
comment|// 3. Translate projection indexes from right to join schema, by adding
comment|// offset.
for|for
control|(
name|Integer
name|indx
range|:
name|projsFromRightPartOfJoinKeysInChildSchema
control|)
block|{
name|projsFromRightPartOfJoinKeysInJoinSchema
operator|.
name|add
argument_list|(
name|indx
operator|+
name|rightOffSet
argument_list|)
expr_stmt|;
block|}
comment|// 4. Construct JoinLeafPredicateInfo
name|jlpi
operator|=
operator|new
name|JoinLeafPredicateInfo
argument_list|(
name|pe
operator|.
name|getKind
argument_list|()
argument_list|,
name|joinKeyExprsFromLeft
argument_list|,
name|joinKeyExprsFromRight
argument_list|,
name|projsFromLeftPartOfJoinKeysInChildSchema
argument_list|,
name|projsFromRightPartOfJoinKeysInChildSchema
argument_list|,
name|projsFromRightPartOfJoinKeysInJoinSchema
argument_list|)
expr_stmt|;
return|return
name|jlpi
return|;
block|}
block|}
annotation|@
name|Deprecated
specifier|public
specifier|static
name|void
name|todo
parameter_list|(
name|String
name|s
parameter_list|)
block|{   }
block|}
end_class

end_unit

