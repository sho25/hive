begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|io
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|DataInput
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|EOFException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|FilterInputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|PushbackInputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|UTFDataFormatException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|common
operator|.
name|io
operator|.
name|NonSyncByteArrayInputStream
import|;
end_import

begin_comment
comment|/**  * A thread-not-safe version of Hadoop's DataInputBuffer, which removes all  * synchronized modifiers.  */
end_comment

begin_class
specifier|public
class|class
name|NonSyncDataInputBuffer
extends|extends
name|FilterInputStream
implements|implements
name|DataInput
block|{
specifier|private
specifier|final
name|NonSyncByteArrayInputStream
name|buffer
decl_stmt|;
name|byte
index|[]
name|buff
init|=
operator|new
name|byte
index|[
literal|16
index|]
decl_stmt|;
comment|/** Constructs a new empty buffer. */
specifier|public
name|NonSyncDataInputBuffer
parameter_list|()
block|{
name|this
argument_list|(
operator|new
name|NonSyncByteArrayInputStream
argument_list|()
argument_list|)
expr_stmt|;
block|}
specifier|private
name|NonSyncDataInputBuffer
parameter_list|(
name|NonSyncByteArrayInputStream
name|buffer
parameter_list|)
block|{
name|super
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
name|this
operator|.
name|buffer
operator|=
name|buffer
expr_stmt|;
block|}
comment|/** Resets the data that the buffer reads. */
specifier|public
name|void
name|reset
parameter_list|(
name|byte
index|[]
name|input
parameter_list|,
name|int
name|length
parameter_list|)
block|{
name|buffer
operator|.
name|reset
argument_list|(
name|input
argument_list|,
literal|0
argument_list|,
name|length
argument_list|)
expr_stmt|;
block|}
comment|/** Resets the data that the buffer reads. */
specifier|public
name|void
name|reset
parameter_list|(
name|byte
index|[]
name|input
parameter_list|,
name|int
name|start
parameter_list|,
name|int
name|length
parameter_list|)
block|{
name|buffer
operator|.
name|reset
argument_list|(
name|input
argument_list|,
name|start
argument_list|,
name|length
argument_list|)
expr_stmt|;
block|}
comment|/** Returns the current position in the input. */
specifier|public
name|int
name|getPosition
parameter_list|()
block|{
return|return
name|buffer
operator|.
name|getPosition
argument_list|()
return|;
block|}
comment|/** Returns the length of the input. */
specifier|public
name|int
name|getLength
parameter_list|()
block|{
return|return
name|buffer
operator|.
name|getLength
argument_list|()
return|;
block|}
comment|/**    * Reads bytes from the source stream into the byte array<code>buffer</code>.    * The number of bytes actually read is returned.    *     * @param buffer    *          the buffer to read bytes into    * @return the number of bytes actually read or -1 if end of stream.    *     * @throws IOException    *           If a problem occurs reading from this DataInputStream.    *     */
annotation|@
name|Override
specifier|public
specifier|final
name|int
name|read
parameter_list|(
name|byte
index|[]
name|buffer
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|in
operator|.
name|read
argument_list|(
name|buffer
argument_list|,
literal|0
argument_list|,
name|buffer
operator|.
name|length
argument_list|)
return|;
block|}
comment|/**    * Read at most<code>length</code> bytes from this DataInputStream and stores    * them in byte array<code>buffer</code> starting at<code>offset</code>.    * Answer the number of bytes actually read or -1 if no bytes were read and    * end of stream was encountered.    *     * @param buffer    *          the byte array in which to store the read bytes.    * @param offset    *          the offset in<code>buffer</code> to store the read bytes.    * @param length    *          the maximum number of bytes to store in<code>buffer</code>.    * @return the number of bytes actually read or -1 if end of stream.    *     * @throws IOException    *           If a problem occurs reading from this DataInputStream.    *     */
annotation|@
name|Override
specifier|public
specifier|final
name|int
name|read
parameter_list|(
name|byte
index|[]
name|buffer
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|length
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|in
operator|.
name|read
argument_list|(
name|buffer
argument_list|,
name|offset
argument_list|,
name|length
argument_list|)
return|;
block|}
comment|/**    * Reads a boolean from this stream.    *     * @return the next boolean value from the source stream.    *     * @throws IOException    *           If a problem occurs reading from this DataInputStream.    *     */
specifier|public
specifier|final
name|boolean
name|readBoolean
parameter_list|()
throws|throws
name|IOException
block|{
name|int
name|temp
init|=
name|in
operator|.
name|read
argument_list|()
decl_stmt|;
if|if
condition|(
name|temp
operator|<
literal|0
condition|)
block|{
throw|throw
operator|new
name|EOFException
argument_list|()
throw|;
block|}
return|return
name|temp
operator|!=
literal|0
return|;
block|}
comment|/**    * Reads an 8-bit byte value from this stream.    *     * @return the next byte value from the source stream.    *     * @throws IOException    *           If a problem occurs reading from this DataInputStream.    *     */
specifier|public
specifier|final
name|byte
name|readByte
parameter_list|()
throws|throws
name|IOException
block|{
name|int
name|temp
init|=
name|in
operator|.
name|read
argument_list|()
decl_stmt|;
if|if
condition|(
name|temp
operator|<
literal|0
condition|)
block|{
throw|throw
operator|new
name|EOFException
argument_list|()
throw|;
block|}
return|return
operator|(
name|byte
operator|)
name|temp
return|;
block|}
comment|/**    * Reads a 16-bit character value from this stream.    *     * @return the next<code>char</code> value from the source stream.    *     * @throws IOException    *           If a problem occurs reading from this DataInputStream.    *     */
specifier|private
name|int
name|readToBuff
parameter_list|(
name|int
name|count
parameter_list|)
throws|throws
name|IOException
block|{
name|int
name|offset
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|offset
operator|<
name|count
condition|)
block|{
name|int
name|bytesRead
init|=
name|in
operator|.
name|read
argument_list|(
name|buff
argument_list|,
name|offset
argument_list|,
name|count
operator|-
name|offset
argument_list|)
decl_stmt|;
if|if
condition|(
name|bytesRead
operator|==
operator|-
literal|1
condition|)
block|{
return|return
name|bytesRead
return|;
block|}
name|offset
operator|+=
name|bytesRead
expr_stmt|;
block|}
return|return
name|offset
return|;
block|}
specifier|public
specifier|final
name|char
name|readChar
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|readToBuff
argument_list|(
literal|2
argument_list|)
operator|<
literal|0
condition|)
block|{
throw|throw
operator|new
name|EOFException
argument_list|()
throw|;
block|}
return|return
call|(
name|char
call|)
argument_list|(
operator|(
operator|(
name|buff
index|[
literal|0
index|]
operator|&
literal|0xff
operator|)
operator|<<
literal|8
operator|)
operator||
operator|(
name|buff
index|[
literal|1
index|]
operator|&
literal|0xff
operator|)
argument_list|)
return|;
block|}
comment|/**    * Reads a 64-bit<code>double</code> value from this stream.    *     * @return the next<code>double</code> value from the source stream.    *     * @throws IOException    *           If a problem occurs reading from this DataInputStream.    *     */
specifier|public
specifier|final
name|double
name|readDouble
parameter_list|()
throws|throws
name|IOException
block|{
return|return
name|Double
operator|.
name|longBitsToDouble
argument_list|(
name|readLong
argument_list|()
argument_list|)
return|;
block|}
comment|/**    * Reads a 32-bit<code>float</code> value from this stream.    *     * @return the next<code>float</code> value from the source stream.    *     * @throws IOException    *           If a problem occurs reading from this DataInputStream.    *     */
specifier|public
specifier|final
name|float
name|readFloat
parameter_list|()
throws|throws
name|IOException
block|{
return|return
name|Float
operator|.
name|intBitsToFloat
argument_list|(
name|readInt
argument_list|()
argument_list|)
return|;
block|}
comment|/**    * Reads bytes from this stream into the byte array<code>buffer</code>. This    * method will block until<code>buffer.length</code> number of bytes have    * been read.    *     * @param buffer    *          to read bytes into    *     * @throws IOException    *           If a problem occurs reading from this DataInputStream.    *     */
specifier|public
specifier|final
name|void
name|readFully
parameter_list|(
name|byte
index|[]
name|buffer
parameter_list|)
throws|throws
name|IOException
block|{
name|readFully
argument_list|(
name|buffer
argument_list|,
literal|0
argument_list|,
name|buffer
operator|.
name|length
argument_list|)
expr_stmt|;
block|}
comment|/**    * Reads bytes from this stream and stores them in the byte array    *<code>buffer</code> starting at the position<code>offset</code>. This    * method blocks until<code>count</code> bytes have been read.    *     * @param buffer    *          the byte array into which the data is read    * @param offset    *          the offset the operation start at    * @param length    *          the maximum number of bytes to read    *     * @throws IOException    *           if a problem occurs while reading from this stream    * @throws EOFException    *           if reaches the end of the stream before enough bytes have been    *           read    */
specifier|public
specifier|final
name|void
name|readFully
parameter_list|(
name|byte
index|[]
name|buffer
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|length
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|length
operator|<
literal|0
condition|)
block|{
throw|throw
operator|new
name|IndexOutOfBoundsException
argument_list|()
throw|;
block|}
if|if
condition|(
name|length
operator|==
literal|0
condition|)
block|{
return|return;
block|}
if|if
condition|(
name|in
operator|==
literal|null
operator|||
name|buffer
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|NullPointerException
argument_list|(
literal|"Null Pointer to underlying input stream"
argument_list|)
throw|;
block|}
if|if
condition|(
name|offset
argument_list|<
literal|0
operator|||
name|offset
argument_list|>
name|buffer
operator|.
name|length
operator|-
name|length
condition|)
block|{
throw|throw
operator|new
name|IndexOutOfBoundsException
argument_list|()
throw|;
block|}
while|while
condition|(
name|length
operator|>
literal|0
condition|)
block|{
name|int
name|result
init|=
name|in
operator|.
name|read
argument_list|(
name|buffer
argument_list|,
name|offset
argument_list|,
name|length
argument_list|)
decl_stmt|;
if|if
condition|(
name|result
operator|<
literal|0
condition|)
block|{
throw|throw
operator|new
name|EOFException
argument_list|()
throw|;
block|}
name|offset
operator|+=
name|result
expr_stmt|;
name|length
operator|-=
name|result
expr_stmt|;
block|}
block|}
comment|/**    * Reads a 32-bit integer value from this stream.    *     * @return the next<code>int</code> value from the source stream.    *     * @throws IOException    *           If a problem occurs reading from this DataInputStream.    *     */
specifier|public
specifier|final
name|int
name|readInt
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|readToBuff
argument_list|(
literal|4
argument_list|)
operator|<
literal|0
condition|)
block|{
throw|throw
operator|new
name|EOFException
argument_list|()
throw|;
block|}
return|return
operator|(
operator|(
name|buff
index|[
literal|0
index|]
operator|&
literal|0xff
operator|)
operator|<<
literal|24
operator|)
operator||
operator|(
operator|(
name|buff
index|[
literal|1
index|]
operator|&
literal|0xff
operator|)
operator|<<
literal|16
operator|)
operator||
operator|(
operator|(
name|buff
index|[
literal|2
index|]
operator|&
literal|0xff
operator|)
operator|<<
literal|8
operator|)
operator||
operator|(
name|buff
index|[
literal|3
index|]
operator|&
literal|0xff
operator|)
return|;
block|}
comment|/**    * Answers a<code>String</code> representing the next line of text available    * in this BufferedReader. A line is represented by 0 or more characters    * followed by<code>'\n'</code>,<code>'\r'</code>,<code>"\n\r"</code> or    * end of stream. The<code>String</code> does not include the newline    * sequence.    *     * @return the contents of the line or null if no characters were read before    *         end of stream.    *     * @throws IOException    *           If the DataInputStream is already closed or some other IO error    *           occurs.    *     * @deprecated Use BufferedReader    */
annotation|@
name|Deprecated
specifier|public
specifier|final
name|String
name|readLine
parameter_list|()
throws|throws
name|IOException
block|{
name|StringBuffer
name|line
init|=
operator|new
name|StringBuffer
argument_list|(
literal|80
argument_list|)
decl_stmt|;
comment|// Typical line length
name|boolean
name|foundTerminator
init|=
literal|false
decl_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
name|int
name|nextByte
init|=
name|in
operator|.
name|read
argument_list|()
decl_stmt|;
switch|switch
condition|(
name|nextByte
condition|)
block|{
case|case
operator|-
literal|1
case|:
if|if
condition|(
name|line
operator|.
name|length
argument_list|()
operator|==
literal|0
operator|&&
operator|!
name|foundTerminator
condition|)
block|{
return|return
literal|null
return|;
block|}
return|return
name|line
operator|.
name|toString
argument_list|()
return|;
case|case
operator|(
name|byte
operator|)
literal|'\r'
case|:
if|if
condition|(
name|foundTerminator
condition|)
block|{
operator|(
operator|(
name|PushbackInputStream
operator|)
name|in
operator|)
operator|.
name|unread
argument_list|(
name|nextByte
argument_list|)
expr_stmt|;
return|return
name|line
operator|.
name|toString
argument_list|()
return|;
block|}
name|foundTerminator
operator|=
literal|true
expr_stmt|;
comment|/* Have to be able to peek ahead one byte */
if|if
condition|(
operator|!
operator|(
name|in
operator|.
name|getClass
argument_list|()
operator|==
name|PushbackInputStream
operator|.
name|class
operator|)
condition|)
block|{
name|in
operator|=
operator|new
name|PushbackInputStream
argument_list|(
name|in
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
operator|(
name|byte
operator|)
literal|'\n'
case|:
return|return
name|line
operator|.
name|toString
argument_list|()
return|;
default|default:
if|if
condition|(
name|foundTerminator
condition|)
block|{
operator|(
operator|(
name|PushbackInputStream
operator|)
name|in
operator|)
operator|.
name|unread
argument_list|(
name|nextByte
argument_list|)
expr_stmt|;
return|return
name|line
operator|.
name|toString
argument_list|()
return|;
block|}
name|line
operator|.
name|append
argument_list|(
operator|(
name|char
operator|)
name|nextByte
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**    * Reads a 64-bit<code>long</code> value from this stream.    *     * @return the next<code>long</code> value from the source stream.    *     * @throws IOException    *           If a problem occurs reading from this DataInputStream.    *     */
specifier|public
specifier|final
name|long
name|readLong
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|readToBuff
argument_list|(
literal|8
argument_list|)
operator|<
literal|0
condition|)
block|{
throw|throw
operator|new
name|EOFException
argument_list|()
throw|;
block|}
name|int
name|i1
init|=
operator|(
operator|(
name|buff
index|[
literal|0
index|]
operator|&
literal|0xff
operator|)
operator|<<
literal|24
operator|)
operator||
operator|(
operator|(
name|buff
index|[
literal|1
index|]
operator|&
literal|0xff
operator|)
operator|<<
literal|16
operator|)
operator||
operator|(
operator|(
name|buff
index|[
literal|2
index|]
operator|&
literal|0xff
operator|)
operator|<<
literal|8
operator|)
operator||
operator|(
name|buff
index|[
literal|3
index|]
operator|&
literal|0xff
operator|)
decl_stmt|;
name|int
name|i2
init|=
operator|(
operator|(
name|buff
index|[
literal|4
index|]
operator|&
literal|0xff
operator|)
operator|<<
literal|24
operator|)
operator||
operator|(
operator|(
name|buff
index|[
literal|5
index|]
operator|&
literal|0xff
operator|)
operator|<<
literal|16
operator|)
operator||
operator|(
operator|(
name|buff
index|[
literal|6
index|]
operator|&
literal|0xff
operator|)
operator|<<
literal|8
operator|)
operator||
operator|(
name|buff
index|[
literal|7
index|]
operator|&
literal|0xff
operator|)
decl_stmt|;
return|return
operator|(
operator|(
name|i1
operator|&
literal|0xffffffffL
operator|)
operator|<<
literal|32
operator|)
operator||
operator|(
name|i2
operator|&
literal|0xffffffffL
operator|)
return|;
block|}
comment|/**    * Reads a 16-bit<code>short</code> value from this stream.    *     * @return the next<code>short</code> value from the source stream.    *     * @throws IOException    *           If a problem occurs reading from this DataInputStream.    *     */
specifier|public
specifier|final
name|short
name|readShort
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|readToBuff
argument_list|(
literal|2
argument_list|)
operator|<
literal|0
condition|)
block|{
throw|throw
operator|new
name|EOFException
argument_list|()
throw|;
block|}
return|return
call|(
name|short
call|)
argument_list|(
operator|(
operator|(
name|buff
index|[
literal|0
index|]
operator|&
literal|0xff
operator|)
operator|<<
literal|8
operator|)
operator||
operator|(
name|buff
index|[
literal|1
index|]
operator|&
literal|0xff
operator|)
argument_list|)
return|;
block|}
comment|/**    * Reads an unsigned 8-bit<code>byte</code> value from this stream and    * returns it as an int.    *     * @return the next unsigned byte value from the source stream.    *     * @throws IOException    *           If a problem occurs reading from this DataInputStream.    *     */
specifier|public
specifier|final
name|int
name|readUnsignedByte
parameter_list|()
throws|throws
name|IOException
block|{
name|int
name|temp
init|=
name|in
operator|.
name|read
argument_list|()
decl_stmt|;
if|if
condition|(
name|temp
operator|<
literal|0
condition|)
block|{
throw|throw
operator|new
name|EOFException
argument_list|()
throw|;
block|}
return|return
name|temp
return|;
block|}
comment|/**    * Reads a 16-bit unsigned<code>short</code> value from this stream and    * returns it as an int.    *     * @return the next unsigned<code>short</code> value from the source stream.    *     * @throws IOException    *           If a problem occurs reading from this DataInputStream.    *     */
specifier|public
specifier|final
name|int
name|readUnsignedShort
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|readToBuff
argument_list|(
literal|2
argument_list|)
operator|<
literal|0
condition|)
block|{
throw|throw
operator|new
name|EOFException
argument_list|()
throw|;
block|}
return|return
call|(
name|char
call|)
argument_list|(
operator|(
operator|(
name|buff
index|[
literal|0
index|]
operator|&
literal|0xff
operator|)
operator|<<
literal|8
operator|)
operator||
operator|(
name|buff
index|[
literal|1
index|]
operator|&
literal|0xff
operator|)
argument_list|)
return|;
block|}
comment|/**    * Reads a UTF format String from this Stream.    *     * @return the next UTF String from the source stream.    *     * @throws IOException    *           If a problem occurs reading from this DataInputStream.    *     */
specifier|public
specifier|final
name|String
name|readUTF
parameter_list|()
throws|throws
name|IOException
block|{
return|return
name|decodeUTF
argument_list|(
name|readUnsignedShort
argument_list|()
argument_list|)
return|;
block|}
name|String
name|decodeUTF
parameter_list|(
name|int
name|utfSize
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|decodeUTF
argument_list|(
name|utfSize
argument_list|,
name|this
argument_list|)
return|;
block|}
specifier|private
specifier|static
name|String
name|decodeUTF
parameter_list|(
name|int
name|utfSize
parameter_list|,
name|DataInput
name|in
parameter_list|)
throws|throws
name|IOException
block|{
name|byte
index|[]
name|buf
init|=
operator|new
name|byte
index|[
name|utfSize
index|]
decl_stmt|;
name|char
index|[]
name|out
init|=
operator|new
name|char
index|[
name|utfSize
index|]
decl_stmt|;
name|in
operator|.
name|readFully
argument_list|(
name|buf
argument_list|,
literal|0
argument_list|,
name|utfSize
argument_list|)
expr_stmt|;
return|return
name|convertUTF8WithBuf
argument_list|(
name|buf
argument_list|,
name|out
argument_list|,
literal|0
argument_list|,
name|utfSize
argument_list|)
return|;
block|}
comment|/**    * Reads a UTF format String from the DataInput Stream<code>in</code>.    *     * @param in    *          the input stream to read from    * @return the next UTF String from the source stream.    *     * @throws IOException    *           If a problem occurs reading from this DataInputStream.    *     */
specifier|public
specifier|static
specifier|final
name|String
name|readUTF
parameter_list|(
name|DataInput
name|in
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|decodeUTF
argument_list|(
name|in
operator|.
name|readUnsignedShort
argument_list|()
argument_list|,
name|in
argument_list|)
return|;
block|}
comment|/**    * Skips<code>count</code> number of bytes in this stream. Subsequent    *<code>read()</code>'s will not return these bytes unless    *<code>reset()</code> is used.    *     * @param count    *          the number of bytes to skip.    * @return the number of bytes actually skipped.    *     * @throws IOException    *           If the stream is already closed or another IOException occurs.    */
specifier|public
specifier|final
name|int
name|skipBytes
parameter_list|(
name|int
name|count
parameter_list|)
throws|throws
name|IOException
block|{
name|int
name|skipped
init|=
literal|0
decl_stmt|;
name|long
name|skip
decl_stmt|;
while|while
condition|(
name|skipped
operator|<
name|count
operator|&&
operator|(
name|skip
operator|=
name|in
operator|.
name|skip
argument_list|(
name|count
operator|-
name|skipped
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|skipped
operator|+=
name|skip
expr_stmt|;
block|}
if|if
condition|(
name|skipped
operator|<
literal|0
condition|)
block|{
throw|throw
operator|new
name|EOFException
argument_list|()
throw|;
block|}
return|return
name|skipped
return|;
block|}
specifier|public
specifier|static
name|String
name|convertUTF8WithBuf
parameter_list|(
name|byte
index|[]
name|buf
parameter_list|,
name|char
index|[]
name|out
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|utfSize
parameter_list|)
throws|throws
name|UTFDataFormatException
block|{
name|int
name|count
init|=
literal|0
decl_stmt|,
name|s
init|=
literal|0
decl_stmt|,
name|a
decl_stmt|;
while|while
condition|(
name|count
operator|<
name|utfSize
condition|)
block|{
if|if
condition|(
operator|(
name|out
index|[
name|s
index|]
operator|=
operator|(
name|char
operator|)
name|buf
index|[
name|offset
operator|+
name|count
operator|++
index|]
operator|)
operator|<
literal|'\u0080'
condition|)
block|{
name|s
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
operator|(
name|a
operator|=
name|out
index|[
name|s
index|]
operator|)
operator|&
literal|0xe0
operator|)
operator|==
literal|0xc0
condition|)
block|{
if|if
condition|(
name|count
operator|>=
name|utfSize
condition|)
block|{
throw|throw
operator|new
name|UTFDataFormatException
argument_list|()
throw|;
block|}
name|int
name|b
init|=
name|buf
index|[
name|count
operator|++
index|]
decl_stmt|;
if|if
condition|(
operator|(
name|b
operator|&
literal|0xC0
operator|)
operator|!=
literal|0x80
condition|)
block|{
throw|throw
operator|new
name|UTFDataFormatException
argument_list|()
throw|;
block|}
name|out
index|[
name|s
operator|++
index|]
operator|=
call|(
name|char
call|)
argument_list|(
operator|(
operator|(
name|a
operator|&
literal|0x1F
operator|)
operator|<<
literal|6
operator|)
operator||
operator|(
name|b
operator|&
literal|0x3F
operator|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|a
operator|&
literal|0xf0
operator|)
operator|==
literal|0xe0
condition|)
block|{
if|if
condition|(
name|count
operator|+
literal|1
operator|>=
name|utfSize
condition|)
block|{
throw|throw
operator|new
name|UTFDataFormatException
argument_list|()
throw|;
block|}
name|int
name|b
init|=
name|buf
index|[
name|count
operator|++
index|]
decl_stmt|;
name|int
name|c
init|=
name|buf
index|[
name|count
operator|++
index|]
decl_stmt|;
if|if
condition|(
operator|(
operator|(
name|b
operator|&
literal|0xC0
operator|)
operator|!=
literal|0x80
operator|)
operator|||
operator|(
operator|(
name|c
operator|&
literal|0xC0
operator|)
operator|!=
literal|0x80
operator|)
condition|)
block|{
throw|throw
operator|new
name|UTFDataFormatException
argument_list|()
throw|;
block|}
name|out
index|[
name|s
operator|++
index|]
operator|=
call|(
name|char
call|)
argument_list|(
operator|(
operator|(
name|a
operator|&
literal|0x0F
operator|)
operator|<<
literal|12
operator|)
operator||
operator|(
operator|(
name|b
operator|&
literal|0x3F
operator|)
operator|<<
literal|6
operator|)
operator||
operator|(
name|c
operator|&
literal|0x3F
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
throw|throw
operator|new
name|UTFDataFormatException
argument_list|()
throw|;
block|}
block|}
return|return
operator|new
name|String
argument_list|(
name|out
argument_list|,
literal|0
argument_list|,
name|s
argument_list|)
return|;
block|}
block|}
end_class

end_unit

