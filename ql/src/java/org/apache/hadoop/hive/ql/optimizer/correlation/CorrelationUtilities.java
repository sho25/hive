begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|optimizer
operator|.
name|correlation
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|Serializable
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|reflect
operator|.
name|Array
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|LinkedHashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
operator|.
name|Entry
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|ColumnInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|FilterOperator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|ForwardOperator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|GroupByOperator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|JoinOperator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|Operator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|OperatorFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|ReduceSinkOperator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|RowSchema
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|ScriptOperator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|SelectOperator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|TableScanOperator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|Utilities
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|Utilities
operator|.
name|ReduceField
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|metadata
operator|.
name|HiveException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|parse
operator|.
name|ParseContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|parse
operator|.
name|SemanticException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|AggregationDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|ExprNodeColumnDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|ExprNodeDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|ExprNodeDescUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|GroupByDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|JoinCondDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|JoinDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|OperatorDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|SelectDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|udf
operator|.
name|generic
operator|.
name|GenericUDAFEvaluator
import|;
end_import

begin_comment
comment|/**  * Utilities for both CorrelationOptimizer and ReduceSinkDeDuplication.  *  */
end_comment

begin_class
specifier|public
specifier|final
class|class
name|CorrelationUtilities
block|{
specifier|protected
specifier|static
name|boolean
name|isExisted
parameter_list|(
name|ExprNodeDesc
name|expr
parameter_list|,
name|List
argument_list|<
name|ExprNodeDesc
argument_list|>
name|columns
parameter_list|)
block|{
for|for
control|(
name|ExprNodeDesc
name|thisExpr
range|:
name|columns
control|)
block|{
if|if
condition|(
name|thisExpr
operator|!=
literal|null
operator|&&
name|thisExpr
operator|.
name|isSame
argument_list|(
name|expr
argument_list|)
condition|)
block|{
return|return
literal|true
return|;
block|}
block|}
return|return
literal|false
return|;
block|}
specifier|protected
specifier|static
name|String
name|getColumnName
parameter_list|(
name|Map
argument_list|<
name|String
argument_list|,
name|ExprNodeDesc
argument_list|>
name|opColumnExprMap
parameter_list|,
name|ExprNodeDesc
name|expr
parameter_list|)
block|{
for|for
control|(
name|Entry
argument_list|<
name|String
argument_list|,
name|ExprNodeDesc
argument_list|>
name|entry
range|:
name|opColumnExprMap
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|ExprNodeDesc
name|thisExpr
init|=
name|entry
operator|.
name|getValue
argument_list|()
decl_stmt|;
if|if
condition|(
name|thisExpr
operator|!=
literal|null
operator|&&
name|thisExpr
operator|.
name|isSame
argument_list|(
name|expr
argument_list|)
condition|)
block|{
return|return
name|entry
operator|.
name|getKey
argument_list|()
return|;
block|}
block|}
return|return
literal|null
return|;
block|}
specifier|protected
specifier|static
name|boolean
name|hasGroupingSet
parameter_list|(
name|ReduceSinkOperator
name|cRS
parameter_list|)
throws|throws
name|SemanticException
block|{
name|GroupByOperator
name|cGBYm
init|=
name|getSingleParent
argument_list|(
name|cRS
argument_list|,
name|GroupByOperator
operator|.
name|class
argument_list|)
decl_stmt|;
if|if
condition|(
name|cGBYm
operator|!=
literal|null
operator|&&
name|cGBYm
operator|.
name|getConf
argument_list|()
operator|.
name|isGroupingSetsPresent
argument_list|()
condition|)
block|{
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
comment|/**    * @param operator the input operator    * @param throwException if throw a exception when the input operator has multiple parents    * @return the single parent or null when the input operator has multiple parents and    *         throwException is false;    * @throws HiveException    */
specifier|protected
specifier|static
name|Operator
argument_list|<
name|?
argument_list|>
name|getSingleParent
parameter_list|(
name|Operator
argument_list|<
name|?
argument_list|>
name|operator
parameter_list|,
name|boolean
name|throwException
parameter_list|)
throws|throws
name|SemanticException
block|{
name|List
argument_list|<
name|Operator
argument_list|<
name|?
argument_list|>
argument_list|>
name|parents
init|=
name|operator
operator|.
name|getParentOperators
argument_list|()
decl_stmt|;
if|if
condition|(
name|parents
operator|!=
literal|null
operator|&&
name|parents
operator|.
name|size
argument_list|()
operator|==
literal|1
condition|)
block|{
return|return
name|parents
operator|.
name|get
argument_list|(
literal|0
argument_list|)
return|;
block|}
if|if
condition|(
name|throwException
condition|)
block|{
if|if
condition|(
name|parents
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
literal|"Operator "
operator|+
name|operator
operator|.
name|getName
argument_list|()
operator|+
literal|" (ID: "
operator|+
name|operator
operator|.
name|getIdentifier
argument_list|()
operator|+
literal|") does not have any parent, but we expect 1 parent."
argument_list|)
throw|;
block|}
elseif|else
if|if
condition|(
name|parents
operator|.
name|size
argument_list|()
operator|>
literal|1
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
literal|"Operator "
operator|+
name|operator
operator|.
name|getName
argument_list|()
operator|+
literal|" (ID: "
operator|+
name|operator
operator|.
name|getIdentifier
argument_list|()
operator|+
literal|") has "
operator|+
name|parents
operator|.
name|size
argument_list|()
operator|+
literal|" parents, but we expect 1 parent."
argument_list|)
throw|;
block|}
block|}
return|return
literal|null
return|;
block|}
specifier|protected
specifier|static
name|Operator
argument_list|<
name|?
argument_list|>
name|getSingleParent
parameter_list|(
name|Operator
argument_list|<
name|?
argument_list|>
name|operator
parameter_list|)
throws|throws
name|SemanticException
block|{
return|return
name|getSingleParent
argument_list|(
name|operator
argument_list|,
literal|false
argument_list|)
return|;
block|}
comment|/**    * @param operator the input operator    * @param throwException if throw a exception when the input operator has multiple children    * @return the single child or null when the input operator has multiple children and    *         throwException is false;    * @throws HiveException    */
specifier|protected
specifier|static
name|Operator
argument_list|<
name|?
argument_list|>
name|getSingleChild
parameter_list|(
name|Operator
argument_list|<
name|?
argument_list|>
name|operator
parameter_list|,
name|boolean
name|throwException
parameter_list|)
throws|throws
name|SemanticException
block|{
name|List
argument_list|<
name|Operator
argument_list|<
name|?
argument_list|>
argument_list|>
name|children
init|=
name|operator
operator|.
name|getChildOperators
argument_list|()
decl_stmt|;
if|if
condition|(
name|children
operator|!=
literal|null
operator|&&
name|children
operator|.
name|size
argument_list|()
operator|==
literal|1
condition|)
block|{
return|return
name|children
operator|.
name|get
argument_list|(
literal|0
argument_list|)
return|;
block|}
if|if
condition|(
name|throwException
condition|)
block|{
if|if
condition|(
name|children
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
literal|"Operator "
operator|+
name|operator
operator|.
name|getName
argument_list|()
operator|+
literal|" (ID: "
operator|+
name|operator
operator|.
name|getIdentifier
argument_list|()
operator|+
literal|") does not have any parent, but we expect 1 parent."
argument_list|)
throw|;
block|}
elseif|else
if|if
condition|(
name|children
operator|.
name|size
argument_list|()
operator|>
literal|1
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
literal|"Operator "
operator|+
name|operator
operator|.
name|getName
argument_list|()
operator|+
literal|" (ID: "
operator|+
name|operator
operator|.
name|getIdentifier
argument_list|()
operator|+
literal|") has "
operator|+
name|children
operator|.
name|size
argument_list|()
operator|+
literal|" parents, but we expect 1 parent."
argument_list|)
throw|;
block|}
block|}
return|return
literal|null
return|;
block|}
specifier|protected
specifier|static
name|Operator
argument_list|<
name|?
argument_list|>
name|getSingleChild
parameter_list|(
name|Operator
argument_list|<
name|?
argument_list|>
name|operator
parameter_list|)
throws|throws
name|SemanticException
block|{
return|return
name|getSingleChild
argument_list|(
name|operator
argument_list|,
literal|false
argument_list|)
return|;
block|}
specifier|protected
specifier|static
parameter_list|<
name|T
parameter_list|>
name|T
name|getSingleChild
parameter_list|(
name|Operator
argument_list|<
name|?
argument_list|>
name|operator
parameter_list|,
name|Class
argument_list|<
name|T
argument_list|>
name|type
parameter_list|)
throws|throws
name|SemanticException
block|{
name|Operator
argument_list|<
name|?
argument_list|>
name|parent
init|=
name|getSingleChild
argument_list|(
name|operator
argument_list|)
decl_stmt|;
return|return
name|type
operator|.
name|isInstance
argument_list|(
name|parent
argument_list|)
condition|?
operator|(
name|T
operator|)
name|parent
else|:
literal|null
return|;
block|}
specifier|protected
specifier|static
parameter_list|<
name|T
parameter_list|>
name|T
name|getSingleParent
parameter_list|(
name|Operator
argument_list|<
name|?
argument_list|>
name|operator
parameter_list|,
name|Class
argument_list|<
name|T
argument_list|>
name|type
parameter_list|)
throws|throws
name|SemanticException
block|{
name|Operator
argument_list|<
name|?
argument_list|>
name|parent
init|=
name|getSingleParent
argument_list|(
name|operator
argument_list|)
decl_stmt|;
return|return
name|type
operator|.
name|isInstance
argument_list|(
name|parent
argument_list|)
condition|?
operator|(
name|T
operator|)
name|parent
else|:
literal|null
return|;
block|}
specifier|protected
specifier|static
name|Operator
argument_list|<
name|?
argument_list|>
name|getStartForGroupBy
parameter_list|(
name|ReduceSinkOperator
name|cRS
parameter_list|)
throws|throws
name|SemanticException
block|{
name|Operator
argument_list|<
name|?
extends|extends
name|Serializable
argument_list|>
name|parent
init|=
name|getSingleParent
argument_list|(
name|cRS
argument_list|)
decl_stmt|;
return|return
name|parent
operator|instanceof
name|GroupByOperator
condition|?
name|parent
else|:
name|cRS
return|;
comment|// skip map-aggr GBY
block|}
specifier|protected
specifier|static
name|boolean
index|[]
name|getSortedTags
parameter_list|(
name|JoinOperator
name|joinOp
parameter_list|)
block|{
name|boolean
index|[]
name|result
init|=
operator|new
name|boolean
index|[
name|joinOp
operator|.
name|getParentOperators
argument_list|()
operator|.
name|size
argument_list|()
index|]
decl_stmt|;
for|for
control|(
name|int
name|tag
init|=
literal|0
init|;
name|tag
operator|<
name|result
operator|.
name|length
condition|;
name|tag
operator|++
control|)
block|{
name|result
index|[
name|tag
index|]
operator|=
name|isSortedTag
argument_list|(
name|joinOp
argument_list|,
name|tag
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
comment|// for left outer joins, left alias is sorted but right alias might be not
comment|// (nulls, etc.). vice versa.
specifier|protected
specifier|static
name|boolean
name|isSortedTag
parameter_list|(
name|JoinOperator
name|joinOp
parameter_list|,
name|int
name|tag
parameter_list|)
block|{
for|for
control|(
name|JoinCondDesc
name|cond
range|:
name|joinOp
operator|.
name|getConf
argument_list|()
operator|.
name|getConds
argument_list|()
control|)
block|{
switch|switch
condition|(
name|cond
operator|.
name|getType
argument_list|()
condition|)
block|{
case|case
name|JoinDesc
operator|.
name|LEFT_OUTER_JOIN
case|:
if|if
condition|(
name|cond
operator|.
name|getRight
argument_list|()
operator|==
name|tag
condition|)
block|{
return|return
literal|false
return|;
block|}
continue|continue;
case|case
name|JoinDesc
operator|.
name|RIGHT_OUTER_JOIN
case|:
if|if
condition|(
name|cond
operator|.
name|getLeft
argument_list|()
operator|==
name|tag
condition|)
block|{
return|return
literal|false
return|;
block|}
continue|continue;
case|case
name|JoinDesc
operator|.
name|FULL_OUTER_JOIN
case|:
if|if
condition|(
name|cond
operator|.
name|getLeft
argument_list|()
operator|==
name|tag
operator|||
name|cond
operator|.
name|getRight
argument_list|()
operator|==
name|tag
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
block|}
return|return
literal|true
return|;
block|}
specifier|protected
specifier|static
name|int
name|indexOf
parameter_list|(
name|ExprNodeDesc
name|cexpr
parameter_list|,
name|ExprNodeDesc
index|[]
name|pexprs
parameter_list|,
name|Operator
name|child
parameter_list|,
name|Operator
index|[]
name|parents
parameter_list|,
name|boolean
index|[]
name|sorted
parameter_list|)
throws|throws
name|SemanticException
block|{
for|for
control|(
name|int
name|tag
init|=
literal|0
init|;
name|tag
operator|<
name|parents
operator|.
name|length
condition|;
name|tag
operator|++
control|)
block|{
if|if
condition|(
name|sorted
index|[
name|tag
index|]
operator|&&
name|pexprs
index|[
name|tag
index|]
operator|.
name|isSame
argument_list|(
name|ExprNodeDescUtils
operator|.
name|backtrack
argument_list|(
name|cexpr
argument_list|,
name|child
argument_list|,
name|parents
index|[
name|tag
index|]
argument_list|)
argument_list|)
condition|)
block|{
return|return
name|tag
return|;
block|}
block|}
return|return
operator|-
literal|1
return|;
block|}
specifier|protected
specifier|static
parameter_list|<
name|T
extends|extends
name|Operator
argument_list|<
name|?
argument_list|>
parameter_list|>
name|T
name|findPossibleParent
parameter_list|(
name|Operator
argument_list|<
name|?
argument_list|>
name|start
parameter_list|,
name|Class
argument_list|<
name|T
argument_list|>
name|target
parameter_list|,
name|boolean
name|trustScript
parameter_list|)
throws|throws
name|SemanticException
block|{
name|T
index|[]
name|parents
init|=
name|findPossibleParents
argument_list|(
name|start
argument_list|,
name|target
argument_list|,
name|trustScript
argument_list|)
decl_stmt|;
return|return
name|parents
operator|!=
literal|null
operator|&&
name|parents
operator|.
name|length
operator|==
literal|1
condition|?
name|parents
index|[
literal|0
index|]
else|:
literal|null
return|;
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
specifier|protected
specifier|static
parameter_list|<
name|T
extends|extends
name|Operator
argument_list|<
name|?
argument_list|>
parameter_list|>
name|T
index|[]
name|findPossibleParents
parameter_list|(
name|Operator
argument_list|<
name|?
argument_list|>
name|start
parameter_list|,
name|Class
argument_list|<
name|T
argument_list|>
name|target
parameter_list|,
name|boolean
name|trustScript
parameter_list|)
throws|throws
name|SemanticException
block|{
name|Operator
argument_list|<
name|?
argument_list|>
name|cursor
init|=
name|getSingleParent
argument_list|(
name|start
argument_list|)
decl_stmt|;
for|for
control|(
init|;
name|cursor
operator|!=
literal|null
condition|;
name|cursor
operator|=
name|getSingleParent
argument_list|(
name|cursor
argument_list|)
control|)
block|{
if|if
condition|(
name|target
operator|.
name|isAssignableFrom
argument_list|(
name|cursor
operator|.
name|getClass
argument_list|()
argument_list|)
condition|)
block|{
name|T
index|[]
name|array
init|=
operator|(
name|T
index|[]
operator|)
name|Array
operator|.
name|newInstance
argument_list|(
name|target
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|array
index|[
literal|0
index|]
operator|=
operator|(
name|T
operator|)
name|cursor
expr_stmt|;
return|return
name|array
return|;
block|}
if|if
condition|(
name|cursor
operator|instanceof
name|JoinOperator
condition|)
block|{
return|return
name|findParents
argument_list|(
operator|(
name|JoinOperator
operator|)
name|cursor
argument_list|,
name|target
argument_list|)
return|;
block|}
if|if
condition|(
name|cursor
operator|instanceof
name|ScriptOperator
operator|&&
operator|!
name|trustScript
condition|)
block|{
return|return
literal|null
return|;
block|}
if|if
condition|(
operator|!
operator|(
name|cursor
operator|instanceof
name|SelectOperator
operator|||
name|cursor
operator|instanceof
name|FilterOperator
operator|||
name|cursor
operator|instanceof
name|ForwardOperator
operator|||
name|cursor
operator|instanceof
name|ScriptOperator
operator|||
name|cursor
operator|instanceof
name|ReduceSinkOperator
operator|)
condition|)
block|{
return|return
literal|null
return|;
block|}
block|}
return|return
literal|null
return|;
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
specifier|protected
specifier|static
parameter_list|<
name|T
extends|extends
name|Operator
argument_list|<
name|?
argument_list|>
parameter_list|>
name|T
index|[]
name|findParents
parameter_list|(
name|JoinOperator
name|join
parameter_list|,
name|Class
argument_list|<
name|T
argument_list|>
name|target
parameter_list|)
throws|throws
name|SemanticException
block|{
name|List
argument_list|<
name|Operator
argument_list|<
name|?
argument_list|>
argument_list|>
name|parents
init|=
name|join
operator|.
name|getParentOperators
argument_list|()
decl_stmt|;
name|T
index|[]
name|result
init|=
operator|(
name|T
index|[]
operator|)
name|Array
operator|.
name|newInstance
argument_list|(
name|target
argument_list|,
name|parents
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|tag
init|=
literal|0
init|;
name|tag
operator|<
name|result
operator|.
name|length
condition|;
name|tag
operator|++
control|)
block|{
name|Operator
argument_list|<
name|?
argument_list|>
name|cursor
init|=
name|parents
operator|.
name|get
argument_list|(
name|tag
argument_list|)
decl_stmt|;
for|for
control|(
init|;
name|cursor
operator|!=
literal|null
condition|;
name|cursor
operator|=
name|getSingleParent
argument_list|(
name|cursor
argument_list|)
control|)
block|{
if|if
condition|(
name|target
operator|.
name|isAssignableFrom
argument_list|(
name|cursor
operator|.
name|getClass
argument_list|()
argument_list|)
condition|)
block|{
name|result
index|[
name|tag
index|]
operator|=
operator|(
name|T
operator|)
name|cursor
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|result
index|[
name|tag
index|]
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"failed to find "
operator|+
name|target
operator|.
name|getSimpleName
argument_list|()
operator|+
literal|" from "
operator|+
name|join
operator|+
literal|" on tag "
operator|+
name|tag
argument_list|)
throw|;
block|}
block|}
return|return
name|result
return|;
block|}
comment|/**    * Search the query plan tree from startPoint to the bottom. If there is no ReduceSinkOperator    * between startPoint and the corresponding TableScanOperator, return the corresponding    * TableScanOperator. Otherwise, return null.    * @param startPoint the operator which the search will start at    * @return the TableScanOperator traced from startPoint. Null, if the search encounters any    * ReduceSinkOperator.    */
specifier|protected
specifier|static
name|Set
argument_list|<
name|TableScanOperator
argument_list|>
name|findTableScanOperators
parameter_list|(
name|Operator
argument_list|<
name|?
argument_list|>
name|startPoint
parameter_list|)
block|{
if|if
condition|(
name|startPoint
operator|instanceof
name|ReduceSinkOperator
condition|)
block|{
assert|assert
name|startPoint
operator|.
name|getNumParent
argument_list|()
operator|==
literal|1
assert|;
comment|// for now
name|startPoint
operator|=
name|startPoint
operator|.
name|getParentOperators
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
return|return
name|findTableScanOperators
argument_list|(
name|startPoint
argument_list|,
operator|new
name|LinkedHashSet
argument_list|<
name|TableScanOperator
argument_list|>
argument_list|()
argument_list|)
return|;
block|}
specifier|private
specifier|static
name|Set
argument_list|<
name|TableScanOperator
argument_list|>
name|findTableScanOperators
parameter_list|(
name|Operator
argument_list|<
name|?
argument_list|>
name|current
parameter_list|,
name|Set
argument_list|<
name|TableScanOperator
argument_list|>
name|found
parameter_list|)
block|{
if|if
condition|(
name|current
operator|instanceof
name|TableScanOperator
condition|)
block|{
name|found
operator|.
name|add
argument_list|(
operator|(
name|TableScanOperator
operator|)
name|current
argument_list|)
expr_stmt|;
return|return
name|found
return|;
block|}
if|if
condition|(
name|current
operator|instanceof
name|ReduceSinkOperator
operator|||
name|current
operator|.
name|getNumParent
argument_list|()
operator|==
literal|0
condition|)
block|{
return|return
name|found
return|;
block|}
for|for
control|(
name|Operator
argument_list|<
name|?
argument_list|>
name|parent
range|:
name|current
operator|.
name|getParentOperators
argument_list|()
control|)
block|{
name|findTableScanOperators
argument_list|(
name|parent
argument_list|,
name|found
argument_list|)
expr_stmt|;
block|}
return|return
name|found
return|;
block|}
comment|/**    * Find all sibling ReduceSinkOperators (which have the same child operator of op) of op (op    * included).    * @throws SemanticException    */
specifier|public
specifier|static
name|List
argument_list|<
name|ReduceSinkOperator
argument_list|>
name|findSiblingReduceSinkOperators
parameter_list|(
name|ReduceSinkOperator
name|op
parameter_list|)
throws|throws
name|SemanticException
block|{
name|List
argument_list|<
name|ReduceSinkOperator
argument_list|>
name|siblingRSs
init|=
operator|new
name|ArrayList
argument_list|<
name|ReduceSinkOperator
argument_list|>
argument_list|()
decl_stmt|;
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
name|child
init|=
name|getSingleChild
argument_list|(
name|op
argument_list|,
literal|true
argument_list|)
decl_stmt|;
for|for
control|(
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
name|parent
range|:
name|child
operator|.
name|getParentOperators
argument_list|()
control|)
block|{
if|if
condition|(
name|parent
operator|instanceof
name|ReduceSinkOperator
condition|)
block|{
name|siblingRSs
operator|.
name|add
argument_list|(
operator|(
name|ReduceSinkOperator
operator|)
name|parent
argument_list|)
expr_stmt|;
block|}
else|else
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
literal|"An sibling of a ReduceSinkOperatpr is not a"
operator|+
literal|"ReduceSinkOperatpr."
argument_list|)
throw|;
block|}
block|}
return|return
name|siblingRSs
return|;
block|}
comment|/**    * Find all sibling operators (which have the same child operator of op) of op (op    * included).    * @throws SemanticException    */
specifier|public
specifier|static
name|List
argument_list|<
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
argument_list|>
name|findSiblingOperators
parameter_list|(
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
name|op
parameter_list|)
throws|throws
name|SemanticException
block|{
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
name|child
init|=
name|getSingleChild
argument_list|(
name|op
argument_list|,
literal|true
argument_list|)
decl_stmt|;
return|return
name|child
operator|.
name|getParentOperators
argument_list|()
return|;
block|}
comment|// replace the cRS to SEL operator
specifier|protected
specifier|static
name|SelectOperator
name|replaceReduceSinkWithSelectOperator
parameter_list|(
name|ReduceSinkOperator
name|childRS
parameter_list|,
name|ParseContext
name|context
parameter_list|,
name|AbstractCorrelationProcCtx
name|procCtx
parameter_list|)
throws|throws
name|SemanticException
block|{
name|RowSchema
name|inputRS
init|=
name|childRS
operator|.
name|getSchema
argument_list|()
decl_stmt|;
name|SelectDesc
name|select
init|=
operator|new
name|SelectDesc
argument_list|(
name|childRS
operator|.
name|getConf
argument_list|()
operator|.
name|getValueCols
argument_list|()
argument_list|,
name|childRS
operator|.
name|getConf
argument_list|()
operator|.
name|getOutputValueColumnNames
argument_list|()
argument_list|)
decl_stmt|;
name|Operator
argument_list|<
name|?
argument_list|>
name|parent
init|=
name|getSingleParent
argument_list|(
name|childRS
argument_list|)
decl_stmt|;
name|parent
operator|.
name|getChildOperators
argument_list|()
operator|.
name|clear
argument_list|()
expr_stmt|;
name|SelectOperator
name|sel
init|=
operator|(
name|SelectOperator
operator|)
name|OperatorFactory
operator|.
name|getAndMakeChild
argument_list|(
name|select
argument_list|,
operator|new
name|RowSchema
argument_list|(
name|inputRS
operator|.
name|getSignature
argument_list|()
argument_list|)
argument_list|,
name|parent
argument_list|)
decl_stmt|;
name|sel
operator|.
name|setColumnExprMap
argument_list|(
name|childRS
operator|.
name|getColumnExprMap
argument_list|()
argument_list|)
expr_stmt|;
name|sel
operator|.
name|setChildOperators
argument_list|(
name|childRS
operator|.
name|getChildOperators
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|Operator
argument_list|<
name|?
extends|extends
name|Serializable
argument_list|>
name|ch
range|:
name|childRS
operator|.
name|getChildOperators
argument_list|()
control|)
block|{
name|ch
operator|.
name|replaceParent
argument_list|(
name|childRS
argument_list|,
name|sel
argument_list|)
expr_stmt|;
block|}
name|removeChildSelIfApplicable
argument_list|(
name|getSingleChild
argument_list|(
name|childRS
argument_list|)
argument_list|,
name|sel
argument_list|,
name|context
argument_list|,
name|procCtx
argument_list|)
expr_stmt|;
name|childRS
operator|.
name|setChildOperators
argument_list|(
literal|null
argument_list|)
expr_stmt|;
name|childRS
operator|.
name|setParentOperators
argument_list|(
literal|null
argument_list|)
expr_stmt|;
name|procCtx
operator|.
name|addRemovedOperator
argument_list|(
name|childRS
argument_list|)
expr_stmt|;
return|return
name|sel
return|;
block|}
comment|//TODO: ideally this method should be removed in future, as in we need not to rely on removing
comment|// this select operator which likely is introduced by SortedDynPartitionOptimizer.
comment|// NonblockingdedupOptimizer should be able to merge this select Operator with its
comment|// parent. But, that is not working at the moment. See: dynpart_sort_optimization2.q
specifier|private
specifier|static
name|void
name|removeChildSelIfApplicable
parameter_list|(
name|Operator
argument_list|<
name|?
argument_list|>
name|child
parameter_list|,
name|SelectOperator
name|sel
parameter_list|,
name|ParseContext
name|context
parameter_list|,
name|AbstractCorrelationProcCtx
name|procCtx
parameter_list|)
throws|throws
name|SemanticException
block|{
if|if
condition|(
operator|!
operator|(
name|child
operator|instanceof
name|SelectOperator
operator|)
condition|)
block|{
return|return;
block|}
if|if
condition|(
name|child
operator|.
name|getColumnExprMap
argument_list|()
operator|!=
literal|null
condition|)
block|{
return|return;
block|}
name|SelectOperator
name|selOp
init|=
operator|(
name|SelectOperator
operator|)
name|child
decl_stmt|;
for|for
control|(
name|ExprNodeDesc
name|desc
range|:
name|selOp
operator|.
name|getConf
argument_list|()
operator|.
name|getColList
argument_list|()
control|)
block|{
if|if
condition|(
operator|!
operator|(
name|desc
operator|instanceof
name|ExprNodeColumnDesc
operator|)
condition|)
block|{
return|return;
block|}
name|ExprNodeColumnDesc
name|col
init|=
operator|(
name|ExprNodeColumnDesc
operator|)
name|desc
decl_stmt|;
if|if
condition|(
operator|!
name|col
operator|.
name|getColumn
argument_list|()
operator|.
name|startsWith
argument_list|(
name|ReduceField
operator|.
name|VALUE
operator|.
name|toString
argument_list|()
operator|+
literal|"."
argument_list|)
operator|||
name|col
operator|.
name|getTabAlias
argument_list|()
operator|!=
literal|null
operator|||
name|col
operator|.
name|getIsPartitionColOrVirtualCol
argument_list|()
condition|)
block|{
return|return;
block|}
block|}
name|removeOperator
argument_list|(
name|child
argument_list|,
name|getSingleChild
argument_list|(
name|child
argument_list|)
argument_list|,
name|sel
argument_list|,
name|context
argument_list|)
expr_stmt|;
name|procCtx
operator|.
name|addRemovedOperator
argument_list|(
name|child
argument_list|)
expr_stmt|;
block|}
specifier|protected
specifier|static
name|void
name|removeReduceSinkForGroupBy
parameter_list|(
name|ReduceSinkOperator
name|cRS
parameter_list|,
name|GroupByOperator
name|cGBYr
parameter_list|,
name|ParseContext
name|context
parameter_list|,
name|AbstractCorrelationProcCtx
name|procCtx
parameter_list|)
throws|throws
name|SemanticException
block|{
name|Operator
argument_list|<
name|?
argument_list|>
name|parent
init|=
name|getSingleParent
argument_list|(
name|cRS
argument_list|)
decl_stmt|;
if|if
condition|(
name|parent
operator|instanceof
name|GroupByOperator
condition|)
block|{
comment|// pRS-cGBYm-cRS-cGBYr (map aggregation) --> pRS-cGBYr(COMPLETE)
comment|// copies desc of cGBYm to cGBYr and remove cGBYm and cRS
name|GroupByOperator
name|cGBYm
init|=
operator|(
name|GroupByOperator
operator|)
name|parent
decl_stmt|;
name|cGBYr
operator|.
name|getConf
argument_list|()
operator|.
name|setKeys
argument_list|(
name|ExprNodeDescUtils
operator|.
name|backtrack
argument_list|(
name|ExprNodeDescUtils
operator|.
name|backtrack
argument_list|(
name|cGBYr
operator|.
name|getConf
argument_list|()
operator|.
name|getKeys
argument_list|()
argument_list|,
name|cGBYr
argument_list|,
name|cRS
argument_list|)
argument_list|,
name|cRS
argument_list|,
name|cGBYm
argument_list|)
argument_list|)
expr_stmt|;
name|cGBYr
operator|.
name|getConf
argument_list|()
operator|.
name|setAggregators
argument_list|(
name|cGBYm
operator|.
name|getConf
argument_list|()
operator|.
name|getAggregators
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|AggregationDesc
name|aggr
range|:
name|cGBYm
operator|.
name|getConf
argument_list|()
operator|.
name|getAggregators
argument_list|()
control|)
block|{
name|aggr
operator|.
name|setMode
argument_list|(
name|GenericUDAFEvaluator
operator|.
name|Mode
operator|.
name|COMPLETE
argument_list|)
expr_stmt|;
block|}
name|cGBYr
operator|.
name|setColumnExprMap
argument_list|(
name|cGBYm
operator|.
name|getColumnExprMap
argument_list|()
argument_list|)
expr_stmt|;
name|cGBYr
operator|.
name|setSchema
argument_list|(
name|cGBYm
operator|.
name|getSchema
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// pRS-cRS-cGBYr (no map aggregation) --> pRS-cGBYr(COMPLETE)
comment|// revert expressions of cGBYr to that of cRS
name|cGBYr
operator|.
name|getConf
argument_list|()
operator|.
name|setKeys
argument_list|(
name|ExprNodeDescUtils
operator|.
name|backtrack
argument_list|(
name|cGBYr
operator|.
name|getConf
argument_list|()
operator|.
name|getKeys
argument_list|()
argument_list|,
name|cGBYr
argument_list|,
name|cRS
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|AggregationDesc
name|aggr
range|:
name|cGBYr
operator|.
name|getConf
argument_list|()
operator|.
name|getAggregators
argument_list|()
control|)
block|{
name|aggr
operator|.
name|setParameters
argument_list|(
name|ExprNodeDescUtils
operator|.
name|backtrack
argument_list|(
name|aggr
operator|.
name|getParameters
argument_list|()
argument_list|,
name|cGBYr
argument_list|,
name|cRS
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|Map
argument_list|<
name|String
argument_list|,
name|ExprNodeDesc
argument_list|>
name|oldMap
init|=
name|cGBYr
operator|.
name|getColumnExprMap
argument_list|()
decl_stmt|;
name|RowSchema
name|oldRS
init|=
name|cGBYr
operator|.
name|getSchema
argument_list|()
decl_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|ExprNodeDesc
argument_list|>
name|newMap
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|ExprNodeDesc
argument_list|>
argument_list|()
decl_stmt|;
name|ArrayList
argument_list|<
name|ColumnInfo
argument_list|>
name|newRS
init|=
operator|new
name|ArrayList
argument_list|<
name|ColumnInfo
argument_list|>
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|outputCols
init|=
name|cGBYr
operator|.
name|getConf
argument_list|()
operator|.
name|getOutputColumnNames
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|outputCols
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|String
name|colName
init|=
name|outputCols
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|ColumnInfo
name|colInfo
init|=
name|oldRS
operator|.
name|getColumnInfo
argument_list|(
name|colName
argument_list|)
decl_stmt|;
name|newRS
operator|.
name|add
argument_list|(
name|colInfo
argument_list|)
expr_stmt|;
name|ExprNodeDesc
name|colExpr
init|=
name|ExprNodeDescUtils
operator|.
name|backtrack
argument_list|(
name|oldMap
operator|.
name|get
argument_list|(
name|colName
argument_list|)
argument_list|,
name|cGBYr
argument_list|,
name|cRS
argument_list|)
decl_stmt|;
if|if
condition|(
name|colExpr
operator|!=
literal|null
condition|)
block|{
name|newMap
operator|.
name|put
argument_list|(
name|colInfo
operator|.
name|getInternalName
argument_list|()
argument_list|,
name|colExpr
argument_list|)
expr_stmt|;
block|}
block|}
name|cGBYr
operator|.
name|setColumnExprMap
argument_list|(
name|newMap
argument_list|)
expr_stmt|;
name|cGBYr
operator|.
name|setSchema
argument_list|(
operator|new
name|RowSchema
argument_list|(
name|newRS
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|cGBYr
operator|.
name|getConf
argument_list|()
operator|.
name|setMode
argument_list|(
name|GroupByDesc
operator|.
name|Mode
operator|.
name|COMPLETE
argument_list|)
expr_stmt|;
name|removeOperator
argument_list|(
name|cRS
argument_list|,
name|cGBYr
argument_list|,
name|parent
argument_list|,
name|context
argument_list|)
expr_stmt|;
name|procCtx
operator|.
name|addRemovedOperator
argument_list|(
name|cRS
argument_list|)
expr_stmt|;
if|if
condition|(
name|parent
operator|instanceof
name|GroupByOperator
condition|)
block|{
name|removeOperator
argument_list|(
name|parent
argument_list|,
name|cGBYr
argument_list|,
name|getSingleParent
argument_list|(
name|parent
argument_list|)
argument_list|,
name|context
argument_list|)
expr_stmt|;
name|procCtx
operator|.
name|addRemovedOperator
argument_list|(
name|cGBYr
argument_list|)
expr_stmt|;
block|}
block|}
comment|/** throw a exception if the input operator is null    * @param operator    * @throws HiveException    */
specifier|protected
specifier|static
name|void
name|isNullOperator
parameter_list|(
name|Operator
argument_list|<
name|?
argument_list|>
name|operator
parameter_list|)
throws|throws
name|SemanticException
block|{
if|if
condition|(
name|operator
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
literal|"Operator "
operator|+
name|operator
operator|.
name|getName
argument_list|()
operator|+
literal|" (ID: "
operator|+
name|operator
operator|.
name|getIdentifier
argument_list|()
operator|+
literal|") is null."
argument_list|)
throw|;
block|}
block|}
comment|/**    * @param newOperator the operator will be inserted between child and parent    * @param child    * @param parent    * @param context    * @throws HiveException    */
specifier|protected
specifier|static
name|void
name|insertOperatorBetween
parameter_list|(
name|Operator
argument_list|<
name|?
argument_list|>
name|newOperator
parameter_list|,
name|Operator
argument_list|<
name|?
argument_list|>
name|parent
parameter_list|,
name|Operator
argument_list|<
name|?
argument_list|>
name|child
parameter_list|)
throws|throws
name|SemanticException
block|{
name|isNullOperator
argument_list|(
name|newOperator
argument_list|)
expr_stmt|;
name|isNullOperator
argument_list|(
name|parent
argument_list|)
expr_stmt|;
name|isNullOperator
argument_list|(
name|child
argument_list|)
expr_stmt|;
if|if
condition|(
name|parent
operator|!=
name|getSingleParent
argument_list|(
name|child
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
literal|"Operator "
operator|+
name|parent
operator|.
name|getName
argument_list|()
operator|+
literal|" (ID: "
operator|+
name|parent
operator|.
name|getIdentifier
argument_list|()
operator|+
literal|") is not the only parent of Operator "
operator|+
name|child
operator|.
name|getName
argument_list|()
operator|+
literal|" (ID: "
operator|+
name|child
operator|.
name|getIdentifier
argument_list|()
operator|+
literal|")"
argument_list|)
throw|;
block|}
if|if
condition|(
name|child
operator|!=
name|getSingleChild
argument_list|(
name|parent
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
literal|"Operator "
operator|+
name|child
operator|.
name|getName
argument_list|()
operator|+
literal|" (ID: "
operator|+
name|child
operator|.
name|getIdentifier
argument_list|()
operator|+
literal|") is not the only child of Operator "
operator|+
name|parent
operator|.
name|getName
argument_list|()
operator|+
literal|" (ID: "
operator|+
name|parent
operator|.
name|getIdentifier
argument_list|()
operator|+
literal|")"
argument_list|)
throw|;
block|}
name|newOperator
operator|.
name|setParentOperators
argument_list|(
name|Utilities
operator|.
name|makeList
argument_list|(
name|parent
argument_list|)
argument_list|)
expr_stmt|;
name|newOperator
operator|.
name|setChildOperators
argument_list|(
name|Utilities
operator|.
name|makeList
argument_list|(
name|child
argument_list|)
argument_list|)
expr_stmt|;
name|child
operator|.
name|setParentOperators
argument_list|(
name|Utilities
operator|.
name|makeList
argument_list|(
name|newOperator
argument_list|)
argument_list|)
expr_stmt|;
name|parent
operator|.
name|setChildOperators
argument_list|(
name|Utilities
operator|.
name|makeList
argument_list|(
name|newOperator
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|public
specifier|static
name|void
name|removeOperator
parameter_list|(
name|Operator
argument_list|<
name|?
argument_list|>
name|target
parameter_list|,
name|ParseContext
name|context
parameter_list|)
block|{
assert|assert
name|target
operator|.
name|getNumParent
argument_list|()
operator|==
literal|1
operator|&&
name|target
operator|.
name|getNumChild
argument_list|()
operator|==
literal|1
assert|;
name|removeOperator
argument_list|(
name|target
argument_list|,
name|target
operator|.
name|getChildOperators
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|,
name|target
operator|.
name|getParentOperators
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|,
name|context
argument_list|)
expr_stmt|;
block|}
specifier|protected
specifier|static
name|void
name|removeOperator
parameter_list|(
name|Operator
argument_list|<
name|?
argument_list|>
name|target
parameter_list|,
name|Operator
argument_list|<
name|?
argument_list|>
name|child
parameter_list|,
name|Operator
argument_list|<
name|?
argument_list|>
name|parent
parameter_list|,
name|ParseContext
name|context
parameter_list|)
block|{
for|for
control|(
name|Operator
argument_list|<
name|?
argument_list|>
name|aparent
range|:
name|target
operator|.
name|getParentOperators
argument_list|()
control|)
block|{
name|aparent
operator|.
name|replaceChild
argument_list|(
name|target
argument_list|,
name|child
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|Operator
argument_list|<
name|?
argument_list|>
name|achild
range|:
name|target
operator|.
name|getChildOperators
argument_list|()
control|)
block|{
name|achild
operator|.
name|replaceParent
argument_list|(
name|target
argument_list|,
name|parent
argument_list|)
expr_stmt|;
block|}
name|target
operator|.
name|setChildOperators
argument_list|(
literal|null
argument_list|)
expr_stmt|;
name|target
operator|.
name|setParentOperators
argument_list|(
literal|null
argument_list|)
expr_stmt|;
block|}
block|}
end_class

end_unit

