begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|log
operator|.
name|syslog
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|ByteArrayOutputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|Closeable
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|EOFException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|InputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|OutputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|charset
operator|.
name|Charset
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|charset
operator|.
name|StandardCharsets
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Calendar
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|GregorianCalendar
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Locale
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|TimeZone
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|lang3
operator|.
name|StringEscapeUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|common
operator|.
name|type
operator|.
name|Timestamp
import|;
end_import

begin_comment
comment|/**  * A Syslog protocol parser.  * It should be capable of parsing RFC 3164 (BSD syslog) streams as well as RFC 5424 (defined in 2009.).  * Adapted from https://github.com/spotify/flume-syslog-source2 and modified it for several assumptions  * about the way hive logs using syslog format (specifically RFC5424).  *  * This implementation also parses structured data, returns all parsed fields as map and also un-escapes messages.  * This parser also gracefully handles some corner cases where 'msg' can be empty or line can start with '<' but not  * a valid RFC5424 format etc.  *  * Assumption:  * 1) This parser assumes the linebreaks '\n' in stack traces for example are replaced by '\r' to make single  * line message. The reader will do replacement of '\r' with '\n' at the time of read.  * 2) This parser assumes structured data values are html escaped. So it will html unescape when parsing structured  * data. (hive writes log lines directly to stderr that look like rfc5424 layout starting with '<' so the expectation  * from log4j2 is to escape those lines using html escaping).  * 3) Read event returns List<Object> conforming to sys.logs table schema in hive. The schema for sys.logs table is  * expected to be (facility STRING, severity STRING, version STRING, ts TIMESTAMP, hostname STRING, app_name STRING,  * proc_id STRING, msg_id STRING, structured_data map<STRING,STRING>, msg BINARY, unmatched BINARY)  * 4) Timestamps are in UTC  *  * This parser is tested with Log4j2's RFC5424 layout generated using the following properties  * appenders = console  * appender.console.layout.type = Rfc5424Layout  * appender.console.layout.appName = ${env:APP_NAME}  * appender.console.layout.facility = USER  * appender.console.layout.includeMDC = true  * appender.console.layout.mdcId = mdc  * appender.console.layout.messageId = ${env:MSG_ID}  * appender.console.layout.newLine = true  * appender.console.layout.newLineEscape = \\r  * appender.console.layout.exceptionPattern = %ex{full}  * appender.console.layout.loggerfields.type = LoggerFields  * appender.console.layout.loggerfields.pairs1.type = KeyValuePair  * appender.console.layout.loggerfields.pairs1.key = level  * appender.console.layout.loggerfields.pairs1.value = %p  * appender.console.layout.loggerfields.pairs2.type = KeyValuePair  * appender.console.layout.loggerfields.pairs2.key = thread  * appender.console.layout.loggerfields.pairs2.value = %enc{%t}  * appender.console.layout.loggerfields.pairs3.type = KeyValuePair  * appender.console.layout.loggerfields.pairs3.key = class  * appender.console.layout.loggerfields.pairs3.value = %c{2}  */
end_comment

begin_class
specifier|public
class|class
name|SyslogParser
implements|implements
name|Closeable
block|{
comment|// RFC 5424 section 6.
comment|// SYSLOG-MSG  format
comment|// PRI VERSION SP TIMESTAMP SP HOSTNAME SP APP-NAME SP PROCID SP MSGID SP STRUCTURED-DATA [SP MSG]
comment|// facility + severity forms PRI
comment|// Version 0 is the RFC 3164 format, 1 for RFC 5424 format.
comment|// Read event returns the following schema
comment|// facility STRING
comment|// severity STRING
comment|// version STRING
comment|// ts TIMESTAMP
comment|// hostname STRING
comment|// app_name STRING
comment|// proc_id STRING
comment|// msg_id STRING
comment|// structured_data map<STRING,STRING>
comment|// msg BINARY
comment|// unmatched BINARY
specifier|private
specifier|final
specifier|static
name|int
name|EXPECTED_COLUMNS
init|=
literal|11
decl_stmt|;
specifier|private
specifier|final
specifier|static
name|String
index|[]
name|FACILITIES
init|=
operator|new
name|String
index|[]
block|{
literal|"KERN"
block|,
literal|"USER"
block|,
literal|"MAIL"
block|,
literal|"DAEMON"
block|,
literal|"AUTH"
block|,
literal|"SYSLOG"
block|,
literal|"LPR"
block|,
literal|"NEWS"
block|,
literal|"UUCP"
block|,
literal|"CRON"
block|,
literal|"AUTHPRIV"
block|,
literal|"FTP"
block|,
literal|"NTP"
block|,
literal|"AUDIT"
block|,
literal|"ALERT"
block|,
literal|"CLOCK"
block|,
literal|"LOCAL0"
block|,
literal|"LOCAL1"
block|,
literal|"LOCAL2"
block|,
literal|"LOCAL3"
block|,
literal|"LOCAL4"
block|,
literal|"LOCAL5"
block|,
literal|"LOCAL6"
block|,
literal|"LOCAL7"
block|}
decl_stmt|;
comment|// As defined in RFC 5424.
specifier|private
specifier|final
specifier|static
name|int
name|MAX_SUPPORTED_VERSION
init|=
literal|1
decl_stmt|;
specifier|private
name|InputStream
name|in
decl_stmt|;
specifier|private
name|boolean
name|parseTag
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|Charset
name|UTF8
init|=
name|StandardCharsets
operator|.
name|UTF_8
decl_stmt|;
specifier|private
name|Charset
name|charset
decl_stmt|;
comment|/// Push back buffer. -1 indicates that it is empty.
specifier|private
name|int
name|pushBack
init|=
operator|-
literal|1
decl_stmt|;
specifier|public
name|SyslogParser
parameter_list|()
block|{
name|this
argument_list|(
literal|null
argument_list|)
expr_stmt|;
block|}
comment|/**    * Construct a new Syslog protocol parser.    * Tags are parsed, and the encoding is assumed to be UTF-8.    */
specifier|public
name|SyslogParser
parameter_list|(
name|InputStream
name|in
parameter_list|)
block|{
name|this
argument_list|(
name|in
argument_list|,
literal|true
argument_list|,
name|UTF8
argument_list|)
expr_stmt|;
block|}
comment|/**    * Construct a new Syslog protocol parser.    *    * @param in       the stream to read data from. The InputStream#read()    *                 function is heavily used, so make sure it is buffered.    * @param parseTag true to parse the "tag[pid]:", false to leave it as    *                 part of the message body.    * @param encoding the encoding to use for various string conversions,    *                 most notably the hostname.    */
specifier|public
name|SyslogParser
parameter_list|(
name|InputStream
name|in
parameter_list|,
name|boolean
name|parseTag
parameter_list|,
name|Charset
name|encoding
parameter_list|)
block|{
name|this
operator|.
name|in
operator|=
name|in
expr_stmt|;
name|this
operator|.
name|parseTag
operator|=
name|parseTag
expr_stmt|;
name|this
operator|.
name|charset
operator|=
name|encoding
expr_stmt|;
block|}
comment|/**    * Free the resources used by this parser.    * Note that the parser cannot be reused. Closes the underlying input    * stream.    */
specifier|public
name|void
name|close
parameter_list|()
throws|throws
name|IOException
block|{
name|in
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
comment|/**    * Read the next Syslog message from the stream.    *    * @return a parsed map of object, or null on EOF.    * @throw EOFException if EOF is found in an inappropriate place.    * @throw IOException if the underlying stream fails, or unexpected    * bytes are seen.    */
specifier|public
name|List
argument_list|<
name|Object
argument_list|>
name|readEvent
parameter_list|()
throws|throws
name|IOException
block|{
name|int
name|priority
decl_stmt|;
name|int
name|c
init|=
name|read
argument_list|(
literal|false
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|Object
argument_list|>
name|row
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|EXPECTED_COLUMNS
argument_list|)
decl_stmt|;
comment|// Return null on initial EOF.
if|if
condition|(
name|c
operator|==
operator|-
literal|1
condition|)
block|{
return|return
literal|null
return|;
block|}
if|if
condition|(
name|c
operator|==
literal|'<'
condition|)
block|{
name|priority
operator|=
name|readInt
argument_list|()
expr_stmt|;
if|if
condition|(
name|priority
operator|==
operator|-
literal|1
condition|)
block|{
return|return
name|unmatchedEvent
argument_list|(
name|c
argument_list|)
return|;
block|}
name|expect
argument_list|(
literal|'>'
argument_list|)
expr_stmt|;
block|}
else|else
block|{
return|return
name|unmatchedEvent
argument_list|(
name|c
argument_list|)
return|;
block|}
name|int
name|version
init|=
literal|0
decl_stmt|;
name|Calendar
name|cal
decl_stmt|;
if|if
condition|(
name|Character
operator|.
name|isDigit
argument_list|(
name|peek
argument_list|()
argument_list|)
condition|)
block|{
comment|// Assume ISO date and time
name|int
name|y
init|=
name|readInt
argument_list|()
decl_stmt|;
name|c
operator|=
name|read
argument_list|(
literal|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|' '
condition|)
block|{
comment|// Assume this is a RFC 5424 message.
name|version
operator|=
name|y
expr_stmt|;
if|if
condition|(
name|version
operator|>
name|MAX_SUPPORTED_VERSION
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Unsupported syslog version: "
operator|+
name|version
argument_list|)
throw|;
block|}
name|skipSpaces
argument_list|()
expr_stmt|;
name|y
operator|=
name|readInt
argument_list|()
expr_stmt|;
name|expect
argument_list|(
literal|'-'
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|!=
literal|'-'
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Unexpected syslog character: "
operator|+
operator|(
name|char
operator|)
name|c
argument_list|)
throw|;
block|}
name|int
name|m
init|=
name|readInt
argument_list|()
decl_stmt|;
name|expect
argument_list|(
literal|'-'
argument_list|)
expr_stmt|;
name|int
name|d
init|=
name|readInt
argument_list|()
decl_stmt|;
name|c
operator|=
name|read
argument_list|(
literal|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|!=
literal|'T'
operator|&&
name|c
operator|!=
literal|' '
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Unexpected syslog character: "
operator|+
operator|(
name|char
operator|)
name|c
argument_list|)
throw|;
block|}
name|int
name|hh
init|=
name|readInt
argument_list|()
decl_stmt|;
name|expect
argument_list|(
literal|':'
argument_list|)
expr_stmt|;
name|int
name|mm
init|=
name|readInt
argument_list|()
decl_stmt|;
name|expect
argument_list|(
literal|':'
argument_list|)
expr_stmt|;
name|int
name|ss
init|=
name|readInt
argument_list|()
decl_stmt|;
name|double
name|subss
init|=
literal|0
decl_stmt|;
name|c
operator|=
name|read
argument_list|(
literal|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'.'
condition|)
block|{
comment|// Fractions of seconds
name|subss
operator|=
name|readFractions
argument_list|()
expr_stmt|;
name|c
operator|=
name|read
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
name|int
name|tz
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|c
operator|==
literal|'Z'
condition|)
block|{
comment|// UTC
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'-'
condition|)
block|{
name|tz
operator|=
name|readInt
argument_list|()
expr_stmt|;
if|if
condition|(
name|peek
argument_list|()
operator|==
literal|':'
condition|)
block|{
name|read
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|tz
operator|=
operator|-
operator|(
name|tz
operator|*
literal|60
operator|+
name|readInt
argument_list|()
operator|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'+'
condition|)
block|{
name|tz
operator|=
name|readInt
argument_list|()
expr_stmt|;
if|if
condition|(
name|peek
argument_list|()
operator|==
literal|':'
condition|)
block|{
name|read
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|tz
operator|=
name|tz
operator|*
literal|60
operator|+
name|readInt
argument_list|()
expr_stmt|;
block|}
block|}
name|cal
operator|=
operator|new
name|GregorianCalendar
argument_list|(
name|TimeZone
operator|.
name|getTimeZone
argument_list|(
literal|"UTC"
argument_list|)
argument_list|,
name|Locale
operator|.
name|getDefault
argument_list|()
argument_list|)
expr_stmt|;
name|cal
operator|.
name|set
argument_list|(
name|y
argument_list|,
name|m
operator|-
literal|1
argument_list|,
name|d
argument_list|,
name|hh
argument_list|,
name|mm
argument_list|,
name|ss
argument_list|)
expr_stmt|;
name|cal
operator|.
name|set
argument_list|(
name|Calendar
operator|.
name|MILLISECOND
argument_list|,
call|(
name|int
call|)
argument_list|(
name|subss
operator|*
literal|1000
argument_list|)
argument_list|)
expr_stmt|;
name|cal
operator|.
name|add
argument_list|(
name|Calendar
operator|.
name|MINUTE
argument_list|,
name|tz
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// Assume BSD date and time
name|int
name|m
init|=
name|readMonthAbbreviation
argument_list|()
decl_stmt|;
name|expect
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
name|skipSpaces
argument_list|()
expr_stmt|;
name|int
name|d
init|=
name|readInt
argument_list|()
decl_stmt|;
name|expect
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
name|skipSpaces
argument_list|()
expr_stmt|;
name|int
name|hh
init|=
name|readInt
argument_list|()
decl_stmt|;
name|expect
argument_list|(
literal|':'
argument_list|)
expr_stmt|;
name|int
name|mm
init|=
name|readInt
argument_list|()
decl_stmt|;
name|expect
argument_list|(
literal|':'
argument_list|)
expr_stmt|;
name|int
name|ss
init|=
name|readInt
argument_list|()
decl_stmt|;
name|cal
operator|=
operator|new
name|GregorianCalendar
argument_list|(
name|Locale
operator|.
name|ROOT
argument_list|)
expr_stmt|;
name|cal
operator|.
name|set
argument_list|(
name|Calendar
operator|.
name|MONTH
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|cal
operator|.
name|set
argument_list|(
name|Calendar
operator|.
name|DAY_OF_MONTH
argument_list|,
name|d
argument_list|)
expr_stmt|;
name|cal
operator|.
name|set
argument_list|(
name|Calendar
operator|.
name|HOUR_OF_DAY
argument_list|,
name|hh
argument_list|)
expr_stmt|;
name|cal
operator|.
name|set
argument_list|(
name|Calendar
operator|.
name|MINUTE
argument_list|,
name|mm
argument_list|)
expr_stmt|;
name|cal
operator|.
name|set
argument_list|(
name|Calendar
operator|.
name|SECOND
argument_list|,
name|ss
argument_list|)
expr_stmt|;
block|}
name|expect
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
name|skipSpaces
argument_list|()
expr_stmt|;
name|String
name|hostname
init|=
name|readWordString
argument_list|()
decl_stmt|;
name|expect
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
name|byte
index|[]
name|appname
init|=
literal|null
decl_stmt|;
name|byte
index|[]
name|procId
init|=
literal|null
decl_stmt|;
name|byte
index|[]
name|msgId
init|=
literal|null
decl_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|structuredData
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|version
operator|>=
literal|1
condition|)
block|{
name|appname
operator|=
name|readWordOrNil
argument_list|(
literal|48
argument_list|)
expr_stmt|;
name|expect
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
name|procId
operator|=
name|readWordOrNil
argument_list|(
literal|12
argument_list|)
expr_stmt|;
name|expect
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
name|msgId
operator|=
name|readWordOrNil
argument_list|(
literal|32
argument_list|)
expr_stmt|;
name|expect
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
name|structuredData
operator|=
name|readAndParseStructuredData
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|version
operator|==
literal|0
operator|&&
name|parseTag
condition|)
block|{
comment|// Try to find a colon terminated tag.
name|appname
operator|=
name|readTag
argument_list|()
expr_stmt|;
if|if
condition|(
name|peek
argument_list|()
operator|==
literal|'['
condition|)
block|{
name|procId
operator|=
name|readPid
argument_list|()
expr_stmt|;
block|}
name|expect
argument_list|(
literal|':'
argument_list|)
expr_stmt|;
block|}
name|c
operator|=
name|skipSpaces
argument_list|()
expr_stmt|;
name|byte
index|[]
name|msg
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|c
operator|!=
operator|-
literal|1
condition|)
block|{
name|msg
operator|=
name|readLine
argument_list|()
expr_stmt|;
block|}
name|createEvent
argument_list|(
name|version
argument_list|,
name|priority
argument_list|,
name|cal
argument_list|,
name|hostname
argument_list|,
name|appname
argument_list|,
name|procId
argument_list|,
name|msgId
argument_list|,
name|structuredData
argument_list|,
name|msg
argument_list|,
name|row
argument_list|)
expr_stmt|;
return|return
name|row
return|;
block|}
specifier|private
name|List
argument_list|<
name|Object
argument_list|>
name|unmatchedEvent
parameter_list|(
name|int
name|c
parameter_list|)
throws|throws
name|IOException
block|{
name|List
argument_list|<
name|Object
argument_list|>
name|row
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|EXPECTED_COLUMNS
argument_list|)
decl_stmt|;
name|byte
index|[]
name|msg
init|=
name|readLine
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|SyslogParser
operator|.
name|EXPECTED_COLUMNS
condition|;
name|i
operator|++
control|)
block|{
name|row
operator|.
name|add
argument_list|(
literal|null
argument_list|)
expr_stmt|;
block|}
name|row
operator|.
name|set
argument_list|(
literal|10
argument_list|,
operator|(
operator|(
name|char
operator|)
name|c
operator|+
operator|new
name|String
argument_list|(
name|msg
argument_list|)
operator|)
operator|.
name|getBytes
argument_list|(
name|charset
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|row
return|;
block|}
comment|/**    * Create a log event from the given parameters.    *    * @param version        the syslog version, 0 for RFC 3164    * @param priority       the syslog priority, according to RFC 5424    * @param cal            the timestamp of the message. Note that timezone matters    * @param hostname       the hostname    * @param appname        the RFC 5424 appname    * @param procId         the RFC 5424 proc-id    * @param msgId          the RFC 5424 msg-id    * @param structuredData the RFC 5424 structured-data    * @param body           the message body    */
specifier|private
name|void
name|createEvent
parameter_list|(
name|int
name|version
parameter_list|,
name|int
name|priority
parameter_list|,
name|Calendar
name|cal
parameter_list|,
name|String
name|hostname
parameter_list|,
name|byte
index|[]
name|appname
parameter_list|,
name|byte
index|[]
name|procId
parameter_list|,
name|byte
index|[]
name|msgId
parameter_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|structuredData
parameter_list|,
name|byte
index|[]
name|body
parameter_list|,
name|List
argument_list|<
name|Object
argument_list|>
name|row
parameter_list|)
block|{
name|row
operator|.
name|add
argument_list|(
name|FACILITIES
index|[
name|priority
operator|/
literal|8
index|]
argument_list|)
expr_stmt|;
name|row
operator|.
name|add
argument_list|(
name|getEventPriorityBySyslog
argument_list|(
name|priority
argument_list|)
argument_list|)
expr_stmt|;
name|row
operator|.
name|add
argument_list|(
name|version
operator|==
literal|0
condition|?
literal|"RFC3164"
else|:
literal|"RFC5424"
argument_list|)
expr_stmt|;
name|row
operator|.
name|add
argument_list|(
name|Timestamp
operator|.
name|ofEpochMilli
argument_list|(
name|cal
operator|.
name|getTimeInMillis
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|row
operator|.
name|add
argument_list|(
name|hostname
argument_list|)
expr_stmt|;
name|row
operator|.
name|add
argument_list|(
operator|new
name|String
argument_list|(
name|appname
argument_list|)
argument_list|)
expr_stmt|;
name|row
operator|.
name|add
argument_list|(
operator|new
name|String
argument_list|(
name|procId
argument_list|)
argument_list|)
expr_stmt|;
name|row
operator|.
name|add
argument_list|(
operator|new
name|String
argument_list|(
name|msgId
argument_list|)
argument_list|)
expr_stmt|;
name|row
operator|.
name|add
argument_list|(
name|structuredData
argument_list|)
expr_stmt|;
name|row
operator|.
name|add
argument_list|(
name|body
argument_list|)
expr_stmt|;
block|}
comment|/**    * Resolve the given syslog priority as a log priority.    */
specifier|private
name|String
name|getEventPriorityBySyslog
parameter_list|(
name|int
name|priority
parameter_list|)
block|{
switch|switch
condition|(
name|priority
operator|%
literal|8
condition|)
block|{
case|case
literal|0
case|:
case|case
literal|1
case|:
case|case
literal|2
case|:
return|return
literal|"FATAL"
return|;
case|case
literal|3
case|:
return|return
literal|"ERROR"
return|;
case|case
literal|4
case|:
return|return
literal|"WARN"
return|;
case|case
literal|5
case|:
case|case
literal|6
case|:
return|return
literal|"INFO"
return|;
case|case
literal|7
case|:
return|return
literal|"DEBUG"
return|;
default|default:
comment|// If this happens, we should tell the world.
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Failed to look up Syslog priority"
argument_list|)
throw|;
block|}
block|}
comment|/**    * Read a month value as an English abbreviation.    * see RFC 3164, Sec. 4.1.2.    */
specifier|private
name|int
name|readMonthAbbreviation
parameter_list|()
throws|throws
name|IOException
block|{
switch|switch
condition|(
name|read
argument_list|(
literal|true
argument_list|)
condition|)
block|{
case|case
literal|'A'
case|:
switch|switch
condition|(
name|read
argument_list|(
literal|true
argument_list|)
condition|)
block|{
case|case
literal|'p'
case|:
name|skipWord
argument_list|()
expr_stmt|;
return|return
name|Calendar
operator|.
name|APRIL
return|;
case|case
literal|'u'
case|:
name|skipWord
argument_list|()
expr_stmt|;
return|return
name|Calendar
operator|.
name|AUGUST
return|;
default|default:
return|return
operator|-
literal|1
return|;
block|}
case|case
literal|'D'
case|:
name|skipWord
argument_list|()
expr_stmt|;
return|return
name|Calendar
operator|.
name|DECEMBER
return|;
case|case
literal|'F'
case|:
name|skipWord
argument_list|()
expr_stmt|;
return|return
name|Calendar
operator|.
name|FEBRUARY
return|;
case|case
literal|'J'
case|:
name|read
argument_list|(
literal|true
argument_list|)
expr_stmt|;
comment|// Second letter is ambiguous.
name|read
argument_list|(
literal|true
argument_list|)
expr_stmt|;
comment|// Third letter is also ambiguous.
switch|switch
condition|(
name|read
argument_list|(
literal|true
argument_list|)
condition|)
block|{
case|case
literal|'e'
case|:
name|skipWord
argument_list|()
expr_stmt|;
return|return
name|Calendar
operator|.
name|JUNE
return|;
case|case
literal|'u'
case|:
name|skipWord
argument_list|()
expr_stmt|;
return|return
name|Calendar
operator|.
name|JANUARY
return|;
case|case
literal|'y'
case|:
name|skipWord
argument_list|()
expr_stmt|;
return|return
name|Calendar
operator|.
name|JULY
return|;
default|default:
return|return
operator|-
literal|1
return|;
block|}
case|case
literal|'M'
case|:
name|read
argument_list|(
literal|true
argument_list|)
expr_stmt|;
comment|// Second letter is ambiguous.
switch|switch
condition|(
name|read
argument_list|(
literal|true
argument_list|)
condition|)
block|{
case|case
literal|'r'
case|:
name|skipWord
argument_list|()
expr_stmt|;
return|return
name|Calendar
operator|.
name|MARCH
return|;
case|case
literal|'y'
case|:
name|skipWord
argument_list|()
expr_stmt|;
return|return
name|Calendar
operator|.
name|MAY
return|;
default|default:
return|return
operator|-
literal|1
return|;
block|}
case|case
literal|'N'
case|:
name|skipWord
argument_list|()
expr_stmt|;
return|return
name|Calendar
operator|.
name|NOVEMBER
return|;
case|case
literal|'O'
case|:
name|skipWord
argument_list|()
expr_stmt|;
return|return
name|Calendar
operator|.
name|OCTOBER
return|;
case|case
literal|'S'
case|:
name|skipWord
argument_list|()
expr_stmt|;
return|return
name|Calendar
operator|.
name|SEPTEMBER
return|;
default|default:
return|return
operator|-
literal|1
return|;
block|}
block|}
comment|/**    * Read a byte and assert the value.    *    * @throw IOException if the character was unexpected    */
specifier|private
name|void
name|expect
parameter_list|(
name|int
name|c
parameter_list|)
throws|throws
name|IOException
block|{
name|int
name|d
init|=
name|read
argument_list|(
literal|true
argument_list|)
decl_stmt|;
if|if
condition|(
name|d
operator|!=
name|c
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Unexpected syslog character: "
operator|+
operator|(
name|char
operator|)
name|d
argument_list|)
throw|;
block|}
block|}
comment|/**    * Read until a non-whitespace ASCII byte is seen.    */
specifier|private
name|int
name|skipSpaces
parameter_list|()
throws|throws
name|IOException
block|{
name|int
name|c
decl_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|read
argument_list|(
literal|false
argument_list|)
operator|)
operator|==
literal|' '
condition|)
block|{
continue|continue;
block|}
if|if
condition|(
name|c
operator|!=
operator|-
literal|1
condition|)
block|{
name|unread
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
return|return
name|c
return|;
block|}
comment|/**    * Read the next byte, but then unread it again.    */
specifier|private
name|int
name|peek
parameter_list|()
throws|throws
name|IOException
block|{
name|int
name|c
init|=
name|read
argument_list|(
literal|true
argument_list|)
decl_stmt|;
name|unread
argument_list|(
name|c
argument_list|)
expr_stmt|;
return|return
name|c
return|;
block|}
comment|/**    * Read the next byte.    *    * @param checkEof true to throw EOFException on EOF, false to return -1.    * @return the byte, or -1 on EOF.    */
specifier|private
name|int
name|read
parameter_list|(
name|boolean
name|checkEof
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|pushBack
operator|!=
operator|-
literal|1
condition|)
block|{
name|int
name|c
init|=
name|pushBack
decl_stmt|;
name|pushBack
operator|=
operator|-
literal|1
expr_stmt|;
return|return
name|c
return|;
block|}
name|int
name|c
init|=
name|in
operator|.
name|read
argument_list|()
decl_stmt|;
if|if
condition|(
name|checkEof
operator|&&
name|c
operator|==
operator|-
literal|1
condition|)
block|{
throw|throw
operator|new
name|EOFException
argument_list|(
literal|"Unexpected end of syslog stream"
argument_list|)
throw|;
block|}
return|return
name|c
return|;
block|}
comment|/**    * Push back a character.    * Only a single character can be pushed back simultaneously.    */
specifier|private
name|void
name|unread
parameter_list|(
name|int
name|c
parameter_list|)
block|{
assert|assert
name|c
operator|!=
operator|-
literal|1
operator|:
literal|"Trying to push back EOF"
assert|;
assert|assert
name|pushBack
operator|==
operator|-
literal|1
operator|:
literal|"Trying to push back two bytes"
assert|;
name|pushBack
operator|=
name|c
expr_stmt|;
block|}
comment|/**    * Read a positive integer and convert it from decimal text form.    * EOF silently terminates the number.    */
specifier|private
name|int
name|readInt
parameter_list|()
throws|throws
name|IOException
block|{
name|int
name|c
decl_stmt|;
name|int
name|ret
init|=
literal|0
decl_stmt|;
name|boolean
name|foundDigit
init|=
literal|false
decl_stmt|;
while|while
condition|(
name|Character
operator|.
name|isDigit
argument_list|(
name|c
operator|=
name|read
argument_list|(
literal|false
argument_list|)
argument_list|)
condition|)
block|{
name|foundDigit
operator|=
literal|true
expr_stmt|;
name|ret
operator|=
name|ret
operator|*
literal|10
operator|+
operator|(
name|c
operator|-
literal|'0'
operator|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|foundDigit
condition|)
block|{
name|unread
argument_list|(
name|c
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|c
operator|!=
operator|-
literal|1
condition|)
block|{
name|unread
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
comment|/**    * Read fractions (digits after a decimal point.)    *    * @return a value in the range [0, 1).    */
specifier|private
name|double
name|readFractions
parameter_list|()
throws|throws
name|IOException
block|{
name|int
name|c
decl_stmt|;
name|int
name|ret
init|=
literal|0
decl_stmt|;
name|int
name|order
init|=
literal|1
decl_stmt|;
while|while
condition|(
name|Character
operator|.
name|isDigit
argument_list|(
name|c
operator|=
name|read
argument_list|(
literal|false
argument_list|)
argument_list|)
condition|)
block|{
name|ret
operator|=
name|ret
operator|*
literal|10
operator|+
operator|(
name|c
operator|-
literal|'0'
operator|)
expr_stmt|;
name|order
operator|*=
literal|10
expr_stmt|;
block|}
if|if
condition|(
name|c
operator|!=
operator|-
literal|1
condition|)
block|{
name|unread
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|double
operator|)
name|ret
operator|/
name|order
return|;
block|}
comment|/**    * Read until EOF or a space.    * The input is discarded.    */
specifier|private
name|void
name|skipWord
parameter_list|()
throws|throws
name|IOException
block|{
name|int
name|c
decl_stmt|;
do|do
block|{
name|c
operator|=
name|read
argument_list|(
literal|false
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|c
operator|!=
literal|' '
operator|&&
name|c
operator|!=
operator|-
literal|1
condition|)
do|;
if|if
condition|(
name|c
operator|!=
operator|-
literal|1
condition|)
block|{
name|unread
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Read a word into the given output stream.    * Usually the output stream will be a ByteArrayOutputStream.    */
specifier|private
name|void
name|readWord
parameter_list|(
name|OutputStream
name|out
parameter_list|)
throws|throws
name|IOException
block|{
name|int
name|c
decl_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|read
argument_list|(
literal|false
argument_list|)
operator|)
operator|!=
literal|' '
operator|&&
name|c
operator|!=
operator|-
literal|1
condition|)
block|{
name|out
operator|.
name|write
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|c
operator|!=
operator|-
literal|1
condition|)
block|{
name|unread
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Read a word (until next ASCII space or EOF) as a string.    * The encoding chosen while constructing the parser is used for decoding.    *    * @return a valid, but perhaps empty, word.    */
specifier|private
name|String
name|readWordString
parameter_list|()
throws|throws
name|IOException
block|{
name|ByteArrayOutputStream
name|out
init|=
operator|new
name|ByteArrayOutputStream
argument_list|(
literal|256
argument_list|)
decl_stmt|;
name|readWord
argument_list|(
name|out
argument_list|)
expr_stmt|;
return|return
name|out
operator|.
name|toString
argument_list|(
name|charset
operator|.
name|name
argument_list|()
argument_list|)
return|;
block|}
comment|/**    * Read a word (until next ASCII space or EOF) as a byte array.    *    * @param sizeHint an guess on how large string will be, in bytes.    * @return a valid, but perhaps empty, word.    */
specifier|private
name|byte
index|[]
name|readWord
parameter_list|(
name|int
name|sizeHint
parameter_list|)
throws|throws
name|IOException
block|{
name|ByteArrayOutputStream
name|out
init|=
operator|new
name|ByteArrayOutputStream
argument_list|(
name|sizeHint
argument_list|)
decl_stmt|;
name|readWord
argument_list|(
name|out
argument_list|)
expr_stmt|;
return|return
name|out
operator|.
name|toByteArray
argument_list|()
return|;
block|}
comment|/**    * Read a word (until next space or EOF) as a byte array.    * If the complete word is "-", return null.    *    * @param sizeHint an guess on how large string will be, in bytes.    */
specifier|private
name|byte
index|[]
name|readWordOrNil
parameter_list|(
name|int
name|sizeHint
parameter_list|)
throws|throws
name|IOException
block|{
name|byte
index|[]
name|ret
init|=
name|readWord
argument_list|(
name|sizeHint
argument_list|)
decl_stmt|;
if|if
condition|(
name|ret
operator|.
name|length
operator|==
literal|1
operator|&&
name|ret
index|[
literal|0
index|]
operator|==
literal|'-'
condition|)
block|{
return|return
literal|null
return|;
block|}
return|return
name|ret
return|;
block|}
comment|/**    * Read a line (until next ASCII NL or EOF) as a byte array.    */
specifier|private
name|byte
index|[]
name|readLine
parameter_list|()
throws|throws
name|IOException
block|{
name|ByteArrayOutputStream
name|ret
init|=
operator|new
name|ByteArrayOutputStream
argument_list|(
literal|1024
argument_list|)
decl_stmt|;
name|int
name|c
decl_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|read
argument_list|(
literal|false
argument_list|)
operator|)
operator|!=
literal|'\n'
operator|&&
name|c
operator|!=
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|c
operator|!=
literal|'\r'
condition|)
block|{
name|ret
operator|.
name|write
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// CR replaced with LF
name|ret
operator|.
name|write
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|ret
operator|.
name|toByteArray
argument_list|()
return|;
block|}
comment|/**    * Read a RFC 3164 tag.    * Tags end with left bracket, colon, ASCII CR, or ASCII NL.    */
specifier|private
name|byte
index|[]
name|readTag
parameter_list|()
throws|throws
name|IOException
block|{
name|ByteArrayOutputStream
name|ret
init|=
operator|new
name|ByteArrayOutputStream
argument_list|(
literal|16
argument_list|)
decl_stmt|;
name|int
name|c
decl_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|read
argument_list|(
literal|true
argument_list|)
operator|)
operator|!=
literal|':'
operator|&&
name|c
operator|!=
literal|'['
operator|&&
name|c
operator|!=
literal|'\r'
operator|&&
name|c
operator|!=
literal|'\n'
condition|)
block|{
name|ret
operator|.
name|write
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
name|unread
argument_list|(
name|c
argument_list|)
expr_stmt|;
return|return
name|ret
operator|.
name|toByteArray
argument_list|()
return|;
block|}
comment|/**    * Read a RFC 3164 pid.    * The format is "[1234]".    */
specifier|private
name|byte
index|[]
name|readPid
parameter_list|()
throws|throws
name|IOException
block|{
name|ByteArrayOutputStream
name|ret
init|=
operator|new
name|ByteArrayOutputStream
argument_list|(
literal|8
argument_list|)
decl_stmt|;
name|int
name|c
decl_stmt|;
name|expect
argument_list|(
literal|'['
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|read
argument_list|(
literal|true
argument_list|)
operator|)
operator|!=
literal|']'
operator|&&
name|c
operator|!=
literal|'\r'
operator|&&
name|c
operator|!=
literal|'\n'
condition|)
block|{
name|ret
operator|.
name|write
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
return|return
name|ret
operator|.
name|toByteArray
argument_list|()
return|;
block|}
comment|/**    * Read RFC 5424 structured data and parse it into map.    */
specifier|private
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|readAndParseStructuredData
parameter_list|()
throws|throws
name|IOException
block|{
name|int
name|c
init|=
name|read
argument_list|(
literal|true
argument_list|)
decl_stmt|;
if|if
condition|(
name|c
operator|==
literal|'-'
condition|)
block|{
return|return
literal|null
return|;
block|}
name|ByteArrayOutputStream
name|ret
init|=
operator|new
name|ByteArrayOutputStream
argument_list|(
literal|128
argument_list|)
decl_stmt|;
if|if
condition|(
name|c
operator|!=
literal|'['
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Unexpected syslog character: "
operator|+
operator|(
name|char
operator|)
name|c
argument_list|)
throw|;
block|}
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|structuredData
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
while|while
condition|(
name|c
operator|==
literal|'['
condition|)
block|{
comment|// Read SD-ID
while|while
condition|(
operator|(
name|c
operator|=
name|read
argument_list|(
literal|true
argument_list|)
operator|)
operator|!=
literal|' '
operator|&&
name|c
operator|!=
literal|']'
condition|)
block|{
name|ret
operator|.
name|write
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
name|String
name|sdId
init|=
operator|new
name|String
argument_list|(
name|ret
operator|.
name|toByteArray
argument_list|()
argument_list|)
decl_stmt|;
name|structuredData
operator|.
name|put
argument_list|(
literal|"sdId"
argument_list|,
name|sdId
argument_list|)
expr_stmt|;
name|ret
operator|.
name|reset
argument_list|()
expr_stmt|;
while|while
condition|(
name|c
operator|==
literal|' '
condition|)
block|{
comment|// Read PARAM-NAME
while|while
condition|(
operator|(
name|c
operator|=
name|read
argument_list|(
literal|true
argument_list|)
operator|)
operator|!=
literal|'='
condition|)
block|{
name|ret
operator|.
name|write
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
name|String
name|sdKey
init|=
operator|new
name|String
argument_list|(
name|ret
operator|.
name|toByteArray
argument_list|()
argument_list|)
decl_stmt|;
name|ret
operator|.
name|reset
argument_list|()
expr_stmt|;
name|expect
argument_list|(
literal|'"'
argument_list|)
expr_stmt|;
comment|// Read PARAM-DATA
while|while
condition|(
operator|(
name|c
operator|=
name|read
argument_list|(
literal|true
argument_list|)
operator|)
operator|!=
literal|'"'
condition|)
block|{
name|ret
operator|.
name|write
argument_list|(
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\\'
condition|)
block|{
name|c
operator|=
name|read
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|ret
operator|.
name|write
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
block|}
name|String
name|sdValue
init|=
operator|new
name|String
argument_list|(
name|ret
operator|.
name|toByteArray
argument_list|()
argument_list|)
decl_stmt|;
name|ret
operator|.
name|reset
argument_list|()
expr_stmt|;
name|structuredData
operator|.
name|put
argument_list|(
name|sdKey
argument_list|,
name|StringEscapeUtils
operator|.
name|unescapeHtml4
argument_list|(
name|sdValue
argument_list|)
argument_list|)
expr_stmt|;
name|c
operator|=
name|read
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|c
operator|!=
literal|']'
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Unexpected syslog character: "
operator|+
operator|(
name|char
operator|)
name|c
argument_list|)
throw|;
block|}
name|c
operator|=
name|read
argument_list|(
literal|false
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|c
operator|!=
operator|-
literal|1
condition|)
block|{
name|unread
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
return|return
name|structuredData
return|;
block|}
specifier|public
name|void
name|setInputStream
parameter_list|(
specifier|final
name|InputStream
name|in
parameter_list|)
block|{
name|this
operator|.
name|in
operator|=
name|in
expr_stmt|;
block|}
block|}
end_class

end_unit

