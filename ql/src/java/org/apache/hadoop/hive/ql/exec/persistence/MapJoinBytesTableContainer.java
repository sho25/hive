begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|persistence
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|ObjectOutputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|Log
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|LogFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|conf
operator|.
name|HiveConf
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|ExprNodeEvaluator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|vector
operator|.
name|VectorHashKeyWrapper
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|vector
operator|.
name|VectorHashKeyWrapperBatch
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|vector
operator|.
name|expressions
operator|.
name|VectorExpressionWriter
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|metadata
operator|.
name|HiveException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|SerDe
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|SerDeException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|ByteStream
operator|.
name|Output
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|ByteStream
operator|.
name|RandomAccessOutput
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|WriteBuffers
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|binarysortable
operator|.
name|BinarySortableSerDe
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|io
operator|.
name|ShortWritable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|lazy
operator|.
name|ByteArrayRef
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|lazybinary
operator|.
name|LazyBinaryFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|lazybinary
operator|.
name|LazyBinarySerDe
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|lazybinary
operator|.
name|LazyBinaryStruct
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|lazybinary
operator|.
name|LazyBinaryUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|lazybinary
operator|.
name|objectinspector
operator|.
name|LazyBinaryObjectInspectorFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|lazybinary
operator|.
name|objectinspector
operator|.
name|LazyBinaryStructObjectInspector
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|objectinspector
operator|.
name|ObjectInspector
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|objectinspector
operator|.
name|StructField
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|objectinspector
operator|.
name|StructObjectInspector
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|objectinspector
operator|.
name|primitive
operator|.
name|ShortObjectInspector
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|typeinfo
operator|.
name|TypeInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|typeinfo
operator|.
name|TypeInfoUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|BinaryComparable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|Writable
import|;
end_import

begin_comment
comment|/**  * Table container that serializes keys and values using LazyBinarySerDe into  * BytesBytesMultiHashMap, with very low memory overhead. However,  * there may be some perf overhead when retrieving rows.  */
end_comment

begin_class
specifier|public
class|class
name|MapJoinBytesTableContainer
implements|implements
name|MapJoinTableContainer
block|{
specifier|private
specifier|static
specifier|final
name|Log
name|LOG
init|=
name|LogFactory
operator|.
name|getLog
argument_list|(
name|MapJoinTableContainer
operator|.
name|class
argument_list|)
decl_stmt|;
specifier|private
specifier|final
name|BytesBytesMultiHashMap
name|hashMap
decl_stmt|;
comment|/** The OI used to deserialize values. We never deserialize keys. */
specifier|private
name|LazyBinaryStructObjectInspector
name|internalValueOi
decl_stmt|;
comment|/**    * This is kind of hacky. Currently we get BinarySortableSerDe-serialized keys; we could    * re-serialize them into LazyBinarySerDe, but instead we just reuse the bytes. However, to    * compare the large table keys correctly when we do, we need to serialize them with correct    * ordering. Hence, remember the ordering here; it is null if we do use LazyBinarySerDe.    */
specifier|private
name|boolean
index|[]
name|sortableSortOrders
decl_stmt|;
specifier|private
name|KeyValueHelper
name|writeHelper
decl_stmt|;
specifier|private
name|List
argument_list|<
name|Object
argument_list|>
name|EMPTY_LIST
init|=
operator|new
name|ArrayList
argument_list|<
name|Object
argument_list|>
argument_list|(
literal|0
argument_list|)
decl_stmt|;
specifier|public
name|MapJoinBytesTableContainer
parameter_list|(
name|Configuration
name|hconf
parameter_list|,
name|MapJoinObjectSerDeContext
name|valCtx
parameter_list|)
throws|throws
name|SerDeException
block|{
name|this
argument_list|(
name|HiveConf
operator|.
name|getIntVar
argument_list|(
name|hconf
argument_list|,
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVEHASHTABLETHRESHOLD
argument_list|)
argument_list|,
name|HiveConf
operator|.
name|getFloatVar
argument_list|(
name|hconf
argument_list|,
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVEHASHTABLELOADFACTOR
argument_list|)
argument_list|,
name|HiveConf
operator|.
name|getIntVar
argument_list|(
name|hconf
argument_list|,
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVEHASHTABLEWBSIZE
argument_list|)
argument_list|,
name|valCtx
argument_list|)
expr_stmt|;
block|}
specifier|private
name|MapJoinBytesTableContainer
parameter_list|(
name|int
name|threshold
parameter_list|,
name|float
name|loadFactor
parameter_list|,
name|int
name|wbSize
parameter_list|,
name|MapJoinObjectSerDeContext
name|valCtx
parameter_list|)
throws|throws
name|SerDeException
block|{
name|hashMap
operator|=
operator|new
name|BytesBytesMultiHashMap
argument_list|(
name|threshold
argument_list|,
name|loadFactor
argument_list|,
name|wbSize
argument_list|)
expr_stmt|;
block|}
specifier|private
name|LazyBinaryStructObjectInspector
name|createInternalOi
parameter_list|(
name|MapJoinObjectSerDeContext
name|valCtx
parameter_list|)
throws|throws
name|SerDeException
block|{
comment|// We are going to use LBSerDe to serialize values; create OI for retrieval.
name|List
argument_list|<
name|?
extends|extends
name|StructField
argument_list|>
name|fields
init|=
operator|(
operator|(
name|StructObjectInspector
operator|)
name|valCtx
operator|.
name|getSerDe
argument_list|()
operator|.
name|getObjectInspector
argument_list|()
operator|)
operator|.
name|getAllStructFieldRefs
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|colNames
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|(
name|fields
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|ObjectInspector
argument_list|>
name|colOis
init|=
operator|new
name|ArrayList
argument_list|<
name|ObjectInspector
argument_list|>
argument_list|(
name|fields
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|fields
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|StructField
name|field
init|=
name|fields
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|colNames
operator|.
name|add
argument_list|(
name|field
operator|.
name|getFieldName
argument_list|()
argument_list|)
expr_stmt|;
comment|// It would be nice if OI could return typeInfo...
name|TypeInfo
name|typeInfo
init|=
name|TypeInfoUtils
operator|.
name|getTypeInfoFromTypeString
argument_list|(
name|field
operator|.
name|getFieldObjectInspector
argument_list|()
operator|.
name|getTypeName
argument_list|()
argument_list|)
decl_stmt|;
name|colOis
operator|.
name|add
argument_list|(
name|LazyBinaryUtils
operator|.
name|getLazyBinaryObjectInspectorFromTypeInfo
argument_list|(
name|typeInfo
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|LazyBinaryObjectInspectorFactory
operator|.
name|getLazyBinaryStructObjectInspector
argument_list|(
name|colNames
argument_list|,
name|colOis
argument_list|)
return|;
block|}
specifier|private
specifier|static
interface|interface
name|KeyValueHelper
extends|extends
name|BytesBytesMultiHashMap
operator|.
name|KvSource
block|{
name|void
name|setKeyValue
parameter_list|(
name|Writable
name|key
parameter_list|,
name|Writable
name|val
parameter_list|)
throws|throws
name|SerDeException
function_decl|;
block|}
specifier|private
specifier|static
class|class
name|KeyValueWriter
implements|implements
name|KeyValueHelper
block|{
specifier|private
specifier|final
name|SerDe
name|keySerDe
decl_stmt|,
name|valSerDe
decl_stmt|;
specifier|private
specifier|final
name|StructObjectInspector
name|keySoi
decl_stmt|,
name|valSoi
decl_stmt|;
specifier|private
specifier|final
name|List
argument_list|<
name|ObjectInspector
argument_list|>
name|keyOis
decl_stmt|,
name|valOis
decl_stmt|;
specifier|private
specifier|final
name|Object
index|[]
name|keyObjs
decl_stmt|,
name|valObjs
decl_stmt|;
specifier|private
specifier|final
name|boolean
name|hasFilterTag
decl_stmt|;
specifier|public
name|KeyValueWriter
parameter_list|(
name|SerDe
name|keySerDe
parameter_list|,
name|SerDe
name|valSerDe
parameter_list|,
name|boolean
name|hasFilterTag
parameter_list|)
throws|throws
name|SerDeException
block|{
name|this
operator|.
name|keySerDe
operator|=
name|keySerDe
expr_stmt|;
name|this
operator|.
name|valSerDe
operator|=
name|valSerDe
expr_stmt|;
name|keySoi
operator|=
operator|(
name|StructObjectInspector
operator|)
name|keySerDe
operator|.
name|getObjectInspector
argument_list|()
expr_stmt|;
name|valSoi
operator|=
operator|(
name|StructObjectInspector
operator|)
name|valSerDe
operator|.
name|getObjectInspector
argument_list|()
expr_stmt|;
name|List
argument_list|<
name|?
extends|extends
name|StructField
argument_list|>
name|keyFields
init|=
name|keySoi
operator|.
name|getAllStructFieldRefs
argument_list|()
decl_stmt|,
name|valFields
init|=
name|valSoi
operator|.
name|getAllStructFieldRefs
argument_list|()
decl_stmt|;
name|keyOis
operator|=
operator|new
name|ArrayList
argument_list|<
name|ObjectInspector
argument_list|>
argument_list|(
name|keyFields
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|valOis
operator|=
operator|new
name|ArrayList
argument_list|<
name|ObjectInspector
argument_list|>
argument_list|(
name|valFields
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|keyFields
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|keyOis
operator|.
name|add
argument_list|(
name|keyFields
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|getFieldObjectInspector
argument_list|()
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|valFields
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|valOis
operator|.
name|add
argument_list|(
name|valFields
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|getFieldObjectInspector
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|keyObjs
operator|=
operator|new
name|Object
index|[
name|keyOis
operator|.
name|size
argument_list|()
index|]
expr_stmt|;
name|valObjs
operator|=
operator|new
name|Object
index|[
name|valOis
operator|.
name|size
argument_list|()
index|]
expr_stmt|;
name|this
operator|.
name|hasFilterTag
operator|=
name|hasFilterTag
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|writeKey
parameter_list|(
name|RandomAccessOutput
name|dest
parameter_list|)
throws|throws
name|SerDeException
block|{
name|LazyBinarySerDe
operator|.
name|serializeStruct
argument_list|(
name|dest
argument_list|,
name|keyObjs
argument_list|,
name|keyOis
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|writeValue
parameter_list|(
name|RandomAccessOutput
name|dest
parameter_list|)
throws|throws
name|SerDeException
block|{
name|LazyBinarySerDe
operator|.
name|serializeStruct
argument_list|(
name|dest
argument_list|,
name|valObjs
argument_list|,
name|valOis
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|setKeyValue
parameter_list|(
name|Writable
name|key
parameter_list|,
name|Writable
name|val
parameter_list|)
throws|throws
name|SerDeException
block|{
name|Object
name|keyObj
init|=
name|keySerDe
operator|.
name|deserialize
argument_list|(
name|key
argument_list|)
decl_stmt|,
name|valObj
init|=
name|valSerDe
operator|.
name|deserialize
argument_list|(
name|val
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|?
extends|extends
name|StructField
argument_list|>
name|keyFields
init|=
name|keySoi
operator|.
name|getAllStructFieldRefs
argument_list|()
decl_stmt|,
name|valFields
init|=
name|valSoi
operator|.
name|getAllStructFieldRefs
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|keyFields
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|keyObjs
index|[
name|i
index|]
operator|=
name|keySoi
operator|.
name|getStructFieldData
argument_list|(
name|keyObj
argument_list|,
name|keyFields
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|valFields
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|valObjs
index|[
name|i
index|]
operator|=
name|valSoi
operator|.
name|getStructFieldData
argument_list|(
name|valObj
argument_list|,
name|valFields
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|byte
name|updateStateByte
parameter_list|(
name|Byte
name|previousValue
parameter_list|)
block|{
if|if
condition|(
operator|!
name|hasFilterTag
condition|)
return|return
operator|(
name|byte
operator|)
literal|0xff
return|;
name|byte
name|aliasFilter
init|=
operator|(
name|previousValue
operator|==
literal|null
operator|)
condition|?
operator|(
name|byte
operator|)
literal|0xff
else|:
name|previousValue
operator|.
name|byteValue
argument_list|()
decl_stmt|;
name|aliasFilter
operator|&=
operator|(
operator|(
name|ShortWritable
operator|)
name|valObjs
index|[
name|valObjs
operator|.
name|length
operator|-
literal|1
index|]
operator|)
operator|.
name|get
argument_list|()
expr_stmt|;
return|return
name|aliasFilter
return|;
block|}
block|}
specifier|private
specifier|static
class|class
name|LazyBinaryKvWriter
implements|implements
name|KeyValueHelper
block|{
specifier|private
specifier|final
name|LazyBinaryStruct
operator|.
name|SingleFieldGetter
name|filterGetter
decl_stmt|;
specifier|private
name|Writable
name|key
decl_stmt|,
name|value
decl_stmt|;
specifier|private
specifier|final
name|SerDe
name|keySerDe
decl_stmt|;
specifier|private
name|Boolean
name|hasTag
init|=
literal|null
decl_stmt|;
comment|// sanity check - we should not receive keys with tags
specifier|public
name|LazyBinaryKvWriter
parameter_list|(
name|SerDe
name|keySerDe
parameter_list|,
name|LazyBinaryStructObjectInspector
name|valSoi
parameter_list|,
name|boolean
name|hasFilterTag
parameter_list|)
throws|throws
name|SerDeException
block|{
name|this
operator|.
name|keySerDe
operator|=
name|keySerDe
expr_stmt|;
if|if
condition|(
name|hasFilterTag
condition|)
block|{
name|List
argument_list|<
name|?
extends|extends
name|StructField
argument_list|>
name|fields
init|=
name|valSoi
operator|.
name|getAllStructFieldRefs
argument_list|()
decl_stmt|;
name|int
name|ix
init|=
name|fields
operator|.
name|size
argument_list|()
operator|-
literal|1
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|fields
operator|.
name|get
argument_list|(
name|ix
argument_list|)
operator|.
name|getFieldObjectInspector
argument_list|()
operator|instanceof
name|ShortObjectInspector
operator|)
condition|)
block|{
throw|throw
operator|new
name|SerDeException
argument_list|(
literal|"Has filter tag, but corresponding OI is "
operator|+
name|fields
operator|.
name|get
argument_list|(
name|ix
argument_list|)
operator|.
name|getFieldObjectInspector
argument_list|()
argument_list|)
throw|;
block|}
name|filterGetter
operator|=
operator|new
name|LazyBinaryStruct
operator|.
name|SingleFieldGetter
argument_list|(
name|valSoi
argument_list|,
name|fields
operator|.
name|size
argument_list|()
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|filterGetter
operator|=
literal|null
expr_stmt|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|void
name|writeKey
parameter_list|(
name|RandomAccessOutput
name|dest
parameter_list|)
throws|throws
name|SerDeException
block|{
if|if
condition|(
operator|!
operator|(
name|key
operator|instanceof
name|BinaryComparable
operator|)
condition|)
block|{
throw|throw
operator|new
name|SerDeException
argument_list|(
literal|"Unexpected type "
operator|+
name|key
operator|.
name|getClass
argument_list|()
operator|.
name|getCanonicalName
argument_list|()
argument_list|)
throw|;
block|}
name|sanityCheckKeyForTag
argument_list|()
expr_stmt|;
name|BinaryComparable
name|b
init|=
operator|(
name|BinaryComparable
operator|)
name|key
decl_stmt|;
name|dest
operator|.
name|write
argument_list|(
name|b
operator|.
name|getBytes
argument_list|()
argument_list|,
literal|0
argument_list|,
name|b
operator|.
name|getLength
argument_list|()
operator|-
operator|(
name|hasTag
condition|?
literal|1
else|:
literal|0
operator|)
argument_list|)
expr_stmt|;
block|}
comment|/**      * If we received data with tags from ReduceSinkOperators, no keys will match. This should      * not happen, but is important enough that we want to find out and work around it if some      * optimized change causes RSO to pass on tags.      */
specifier|private
name|void
name|sanityCheckKeyForTag
parameter_list|()
throws|throws
name|SerDeException
block|{
if|if
condition|(
name|hasTag
operator|!=
literal|null
condition|)
return|return;
name|BinaryComparable
name|b
init|=
operator|(
name|BinaryComparable
operator|)
name|key
decl_stmt|;
name|Object
name|o
init|=
name|keySerDe
operator|.
name|deserialize
argument_list|(
name|key
argument_list|)
decl_stmt|;
name|StructObjectInspector
name|soi
init|=
operator|(
name|StructObjectInspector
operator|)
name|keySerDe
operator|.
name|getObjectInspector
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|?
extends|extends
name|StructField
argument_list|>
name|fields
init|=
name|soi
operator|.
name|getAllStructFieldRefs
argument_list|()
decl_stmt|;
name|Object
index|[]
name|data
init|=
operator|new
name|Object
index|[
name|fields
operator|.
name|size
argument_list|()
index|]
decl_stmt|;
name|List
argument_list|<
name|ObjectInspector
argument_list|>
name|fois
init|=
operator|new
name|ArrayList
argument_list|<
name|ObjectInspector
argument_list|>
argument_list|(
name|fields
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|fields
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|data
index|[
name|i
index|]
operator|=
name|soi
operator|.
name|getStructFieldData
argument_list|(
name|o
argument_list|,
name|fields
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|fois
operator|.
name|add
argument_list|(
name|fields
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|getFieldObjectInspector
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|Output
name|output
init|=
operator|new
name|Output
argument_list|()
decl_stmt|;
name|BinarySortableSerDe
operator|.
name|serializeStruct
argument_list|(
name|output
argument_list|,
name|data
argument_list|,
name|fois
argument_list|,
operator|new
name|boolean
index|[
name|fields
operator|.
name|size
argument_list|()
index|]
argument_list|)
expr_stmt|;
name|hasTag
operator|=
operator|(
name|output
operator|.
name|getLength
argument_list|()
operator|!=
name|b
operator|.
name|getLength
argument_list|()
operator|)
expr_stmt|;
if|if
condition|(
name|hasTag
condition|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Tag found in keys and will be removed. This should not happen."
argument_list|)
expr_stmt|;
if|if
condition|(
name|output
operator|.
name|getLength
argument_list|()
operator|!=
operator|(
name|b
operator|.
name|getLength
argument_list|()
operator|-
literal|1
operator|)
condition|)
block|{
throw|throw
operator|new
name|SerDeException
argument_list|(
literal|"Unexpected tag: "
operator|+
name|b
operator|.
name|getLength
argument_list|()
operator|+
literal|" reserialized to "
operator|+
name|output
operator|.
name|getLength
argument_list|()
argument_list|)
throw|;
block|}
block|}
block|}
annotation|@
name|Override
specifier|public
name|void
name|writeValue
parameter_list|(
name|RandomAccessOutput
name|dest
parameter_list|)
throws|throws
name|SerDeException
block|{
if|if
condition|(
operator|!
operator|(
name|value
operator|instanceof
name|BinaryComparable
operator|)
condition|)
block|{
throw|throw
operator|new
name|SerDeException
argument_list|(
literal|"Unexpected type "
operator|+
name|value
operator|.
name|getClass
argument_list|()
operator|.
name|getCanonicalName
argument_list|()
argument_list|)
throw|;
block|}
name|BinaryComparable
name|b
init|=
operator|(
name|BinaryComparable
operator|)
name|value
decl_stmt|;
name|dest
operator|.
name|write
argument_list|(
name|b
operator|.
name|getBytes
argument_list|()
argument_list|,
literal|0
argument_list|,
name|b
operator|.
name|getLength
argument_list|()
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|setKeyValue
parameter_list|(
name|Writable
name|key
parameter_list|,
name|Writable
name|val
parameter_list|)
block|{
name|this
operator|.
name|key
operator|=
name|key
expr_stmt|;
name|this
operator|.
name|value
operator|=
name|val
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|byte
name|updateStateByte
parameter_list|(
name|Byte
name|previousValue
parameter_list|)
block|{
if|if
condition|(
name|filterGetter
operator|==
literal|null
condition|)
return|return
operator|(
name|byte
operator|)
literal|0xff
return|;
name|byte
name|aliasFilter
init|=
operator|(
name|previousValue
operator|==
literal|null
operator|)
condition|?
operator|(
name|byte
operator|)
literal|0xff
else|:
name|previousValue
operator|.
name|byteValue
argument_list|()
decl_stmt|;
name|filterGetter
operator|.
name|init
argument_list|(
operator|(
name|BinaryComparable
operator|)
name|value
argument_list|)
expr_stmt|;
name|aliasFilter
operator|&=
name|filterGetter
operator|.
name|getShort
argument_list|()
expr_stmt|;
return|return
name|aliasFilter
return|;
block|}
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"deprecation"
argument_list|)
annotation|@
name|Override
specifier|public
name|MapJoinKey
name|putRow
parameter_list|(
name|MapJoinObjectSerDeContext
name|keyContext
parameter_list|,
name|Writable
name|currentKey
parameter_list|,
name|MapJoinObjectSerDeContext
name|valueContext
parameter_list|,
name|Writable
name|currentValue
parameter_list|)
throws|throws
name|SerDeException
block|{
name|SerDe
name|keySerde
init|=
name|keyContext
operator|.
name|getSerDe
argument_list|()
decl_stmt|,
name|valSerde
init|=
name|valueContext
operator|.
name|getSerDe
argument_list|()
decl_stmt|;
if|if
condition|(
name|writeHelper
operator|==
literal|null
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Initializing container with "
operator|+
name|keySerde
operator|.
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
operator|+
literal|" and "
operator|+
name|valSerde
operator|.
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|keySerde
operator|instanceof
name|BinarySortableSerDe
operator|&&
name|valSerde
operator|instanceof
name|LazyBinarySerDe
condition|)
block|{
name|LazyBinaryStructObjectInspector
name|valSoi
init|=
operator|(
name|LazyBinaryStructObjectInspector
operator|)
name|valSerde
operator|.
name|getObjectInspector
argument_list|()
decl_stmt|;
name|writeHelper
operator|=
operator|new
name|LazyBinaryKvWriter
argument_list|(
name|keySerde
argument_list|,
name|valSoi
argument_list|,
name|valueContext
operator|.
name|hasFilterTag
argument_list|()
argument_list|)
expr_stmt|;
name|internalValueOi
operator|=
name|valSoi
expr_stmt|;
name|sortableSortOrders
operator|=
operator|(
operator|(
name|BinarySortableSerDe
operator|)
name|keySerde
operator|)
operator|.
name|getSortOrders
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|writeHelper
operator|=
operator|new
name|KeyValueWriter
argument_list|(
name|keySerde
argument_list|,
name|valSerde
argument_list|,
name|valueContext
operator|.
name|hasFilterTag
argument_list|()
argument_list|)
expr_stmt|;
name|internalValueOi
operator|=
name|createInternalOi
argument_list|(
name|valueContext
argument_list|)
expr_stmt|;
name|sortableSortOrders
operator|=
literal|null
expr_stmt|;
block|}
block|}
name|writeHelper
operator|.
name|setKeyValue
argument_list|(
name|currentKey
argument_list|,
name|currentValue
argument_list|)
expr_stmt|;
name|hashMap
operator|.
name|put
argument_list|(
name|writeHelper
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
comment|// there's no key to return
block|}
annotation|@
name|Override
specifier|public
name|void
name|clear
parameter_list|()
block|{
name|hashMap
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|MapJoinKey
name|getAnyKey
parameter_list|()
block|{
return|return
literal|null
return|;
comment|// This table has no keys.
block|}
annotation|@
name|Override
specifier|public
name|ReusableGetAdaptor
name|createGetter
parameter_list|(
name|MapJoinKey
name|keyTypeFromLoader
parameter_list|)
block|{
if|if
condition|(
name|keyTypeFromLoader
operator|!=
literal|null
condition|)
block|{
throw|throw
operator|new
name|AssertionError
argument_list|(
literal|"No key expected from loader but got "
operator|+
name|keyTypeFromLoader
argument_list|)
throw|;
block|}
return|return
operator|new
name|GetAdaptor
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|seal
parameter_list|()
block|{
name|hashMap
operator|.
name|seal
argument_list|()
expr_stmt|;
block|}
comment|/** Implementation of ReusableGetAdaptor that has Output for key serialization; row    * container is also created once and reused for every row. */
specifier|private
class|class
name|GetAdaptor
implements|implements
name|ReusableGetAdaptor
block|{
specifier|private
name|Object
index|[]
name|currentKey
decl_stmt|;
specifier|private
name|boolean
index|[]
name|nulls
decl_stmt|;
specifier|private
name|List
argument_list|<
name|ObjectInspector
argument_list|>
name|vectorKeyOIs
decl_stmt|;
specifier|private
specifier|final
name|ReusableRowContainer
name|currentValue
decl_stmt|;
specifier|private
specifier|final
name|Output
name|output
decl_stmt|;
specifier|public
name|GetAdaptor
parameter_list|()
block|{
name|currentValue
operator|=
operator|new
name|ReusableRowContainer
argument_list|()
expr_stmt|;
name|output
operator|=
operator|new
name|Output
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|setFromVector
parameter_list|(
name|VectorHashKeyWrapper
name|kw
parameter_list|,
name|VectorExpressionWriter
index|[]
name|keyOutputWriters
parameter_list|,
name|VectorHashKeyWrapperBatch
name|keyWrapperBatch
parameter_list|)
throws|throws
name|HiveException
block|{
if|if
condition|(
name|nulls
operator|==
literal|null
condition|)
block|{
name|nulls
operator|=
operator|new
name|boolean
index|[
name|keyOutputWriters
operator|.
name|length
index|]
expr_stmt|;
name|currentKey
operator|=
operator|new
name|Object
index|[
name|keyOutputWriters
operator|.
name|length
index|]
expr_stmt|;
name|vectorKeyOIs
operator|=
operator|new
name|ArrayList
argument_list|<
name|ObjectInspector
argument_list|>
argument_list|()
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|keyOutputWriters
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|vectorKeyOIs
operator|.
name|add
argument_list|(
name|keyOutputWriters
index|[
name|i
index|]
operator|.
name|getObjectInspector
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
assert|assert
name|nulls
operator|.
name|length
operator|==
name|keyOutputWriters
operator|.
name|length
assert|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|keyOutputWriters
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|currentKey
index|[
name|i
index|]
operator|=
name|keyWrapperBatch
operator|.
name|getWritableKeyValue
argument_list|(
name|kw
argument_list|,
name|i
argument_list|,
name|keyOutputWriters
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|nulls
index|[
name|i
index|]
operator|=
name|currentKey
index|[
name|i
index|]
operator|==
literal|null
expr_stmt|;
block|}
name|currentValue
operator|.
name|setFromOutput
argument_list|(
name|MapJoinKey
operator|.
name|serializeRow
argument_list|(
name|output
argument_list|,
name|currentKey
argument_list|,
name|vectorKeyOIs
argument_list|,
name|sortableSortOrders
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|setFromRow
parameter_list|(
name|Object
name|row
parameter_list|,
name|List
argument_list|<
name|ExprNodeEvaluator
argument_list|>
name|fields
parameter_list|,
name|List
argument_list|<
name|ObjectInspector
argument_list|>
name|ois
parameter_list|)
throws|throws
name|HiveException
block|{
if|if
condition|(
name|nulls
operator|==
literal|null
condition|)
block|{
name|nulls
operator|=
operator|new
name|boolean
index|[
name|fields
operator|.
name|size
argument_list|()
index|]
expr_stmt|;
name|currentKey
operator|=
operator|new
name|Object
index|[
name|fields
operator|.
name|size
argument_list|()
index|]
expr_stmt|;
block|}
for|for
control|(
name|int
name|keyIndex
init|=
literal|0
init|;
name|keyIndex
operator|<
name|fields
operator|.
name|size
argument_list|()
condition|;
operator|++
name|keyIndex
control|)
block|{
name|currentKey
index|[
name|keyIndex
index|]
operator|=
name|fields
operator|.
name|get
argument_list|(
name|keyIndex
argument_list|)
operator|.
name|evaluate
argument_list|(
name|row
argument_list|)
expr_stmt|;
name|nulls
index|[
name|keyIndex
index|]
operator|=
name|currentKey
index|[
name|keyIndex
index|]
operator|==
literal|null
expr_stmt|;
block|}
name|currentValue
operator|.
name|setFromOutput
argument_list|(
name|MapJoinKey
operator|.
name|serializeRow
argument_list|(
name|output
argument_list|,
name|currentKey
argument_list|,
name|ois
argument_list|,
name|sortableSortOrders
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|setFromOther
parameter_list|(
name|ReusableGetAdaptor
name|other
parameter_list|)
block|{
assert|assert
name|other
operator|instanceof
name|GetAdaptor
assert|;
name|GetAdaptor
name|other2
init|=
operator|(
name|GetAdaptor
operator|)
name|other
decl_stmt|;
name|nulls
operator|=
name|other2
operator|.
name|nulls
expr_stmt|;
name|currentKey
operator|=
name|other2
operator|.
name|currentKey
expr_stmt|;
name|currentValue
operator|.
name|setFromOutput
argument_list|(
name|other2
operator|.
name|output
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|hasAnyNulls
parameter_list|(
name|int
name|fieldCount
parameter_list|,
name|boolean
index|[]
name|nullsafes
parameter_list|)
block|{
if|if
condition|(
name|nulls
operator|==
literal|null
operator|||
name|nulls
operator|.
name|length
operator|==
literal|0
condition|)
return|return
literal|false
return|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|nulls
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|nulls
index|[
name|i
index|]
operator|==
literal|true
operator|&&
operator|(
name|nullsafes
operator|==
literal|null
operator|||
operator|!
name|nullsafes
index|[
name|i
index|]
operator|)
condition|)
block|{
return|return
literal|true
return|;
block|}
block|}
return|return
literal|false
return|;
block|}
annotation|@
name|Override
specifier|public
name|MapJoinRowContainer
name|getCurrentRows
parameter_list|()
block|{
return|return
name|currentValue
operator|.
name|isEmpty
argument_list|()
condition|?
literal|null
else|:
name|currentValue
return|;
block|}
annotation|@
name|Override
specifier|public
name|Object
index|[]
name|getCurrentKey
parameter_list|()
block|{
return|return
name|currentKey
return|;
block|}
block|}
comment|/** Row container that gets and deserializes the rows on demand from bytes provided. */
specifier|private
class|class
name|ReusableRowContainer
implements|implements
name|MapJoinRowContainer
implements|,
name|AbstractRowContainer
operator|.
name|RowIterator
argument_list|<
name|List
argument_list|<
name|Object
argument_list|>
argument_list|>
block|{
specifier|private
name|byte
name|aliasFilter
decl_stmt|;
specifier|private
name|List
argument_list|<
name|WriteBuffers
operator|.
name|ByteSegmentRef
argument_list|>
name|refs
decl_stmt|;
specifier|private
name|int
name|currentRow
decl_stmt|;
comment|/**      * Sometimes, when container is empty in multi-table mapjoin, we need to add a dummy row.      * This container does not normally support adding rows; this is for the dummy row.      */
specifier|private
name|List
argument_list|<
name|Object
argument_list|>
name|dummyRow
init|=
literal|null
decl_stmt|;
specifier|private
specifier|final
name|ByteArrayRef
name|uselessIndirection
decl_stmt|;
comment|// LBStruct needs ByteArrayRef
specifier|private
specifier|final
name|LazyBinaryStruct
name|valueStruct
decl_stmt|;
specifier|public
name|ReusableRowContainer
parameter_list|()
block|{
if|if
condition|(
name|internalValueOi
operator|!=
literal|null
condition|)
block|{
name|valueStruct
operator|=
operator|(
name|LazyBinaryStruct
operator|)
name|LazyBinaryFactory
operator|.
name|createLazyBinaryObject
argument_list|(
name|internalValueOi
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|valueStruct
operator|=
literal|null
expr_stmt|;
comment|// No rows?
block|}
name|uselessIndirection
operator|=
operator|new
name|ByteArrayRef
argument_list|()
expr_stmt|;
name|clearRows
argument_list|()
expr_stmt|;
block|}
specifier|public
name|void
name|setFromOutput
parameter_list|(
name|Output
name|output
parameter_list|)
block|{
if|if
condition|(
name|refs
operator|==
literal|null
condition|)
block|{
name|refs
operator|=
operator|new
name|ArrayList
argument_list|<
name|WriteBuffers
operator|.
name|ByteSegmentRef
argument_list|>
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
name|byte
name|aliasFilter
init|=
name|hashMap
operator|.
name|getValueRefs
argument_list|(
name|output
operator|.
name|getData
argument_list|()
argument_list|,
name|output
operator|.
name|getLength
argument_list|()
argument_list|,
name|refs
argument_list|)
decl_stmt|;
name|this
operator|.
name|aliasFilter
operator|=
name|refs
operator|.
name|isEmpty
argument_list|()
condition|?
operator|(
name|byte
operator|)
literal|0xff
else|:
name|aliasFilter
expr_stmt|;
name|this
operator|.
name|dummyRow
operator|=
literal|null
expr_stmt|;
block|}
specifier|public
name|boolean
name|isEmpty
parameter_list|()
block|{
return|return
name|refs
operator|.
name|isEmpty
argument_list|()
operator|&&
operator|(
name|dummyRow
operator|==
literal|null
operator|)
return|;
block|}
comment|// Implementation of row container
annotation|@
name|Override
specifier|public
name|AbstractRowContainer
operator|.
name|RowIterator
argument_list|<
name|List
argument_list|<
name|Object
argument_list|>
argument_list|>
name|rowIter
parameter_list|()
throws|throws
name|HiveException
block|{
name|currentRow
operator|=
operator|-
literal|1
expr_stmt|;
return|return
name|this
return|;
block|}
annotation|@
name|Override
specifier|public
name|int
name|rowCount
parameter_list|()
throws|throws
name|HiveException
block|{
return|return
name|dummyRow
operator|!=
literal|null
condition|?
literal|1
else|:
name|refs
operator|.
name|size
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|clearRows
parameter_list|()
block|{
comment|// Doesn't clear underlying hashtable
if|if
condition|(
name|refs
operator|!=
literal|null
condition|)
block|{
name|refs
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
name|dummyRow
operator|=
literal|null
expr_stmt|;
name|currentRow
operator|=
operator|-
literal|1
expr_stmt|;
name|aliasFilter
operator|=
operator|(
name|byte
operator|)
literal|0xff
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|byte
name|getAliasFilter
parameter_list|()
throws|throws
name|HiveException
block|{
return|return
name|aliasFilter
return|;
block|}
annotation|@
name|Override
specifier|public
name|MapJoinRowContainer
name|copy
parameter_list|()
throws|throws
name|HiveException
block|{
return|return
name|this
return|;
comment|// Independent of hashtable and can be modified, no need to copy.
block|}
comment|// Implementation of row iterator
annotation|@
name|Override
specifier|public
name|List
argument_list|<
name|Object
argument_list|>
name|first
parameter_list|()
throws|throws
name|HiveException
block|{
name|currentRow
operator|=
literal|0
expr_stmt|;
return|return
name|next
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|List
argument_list|<
name|Object
argument_list|>
name|next
parameter_list|()
throws|throws
name|HiveException
block|{
if|if
condition|(
name|dummyRow
operator|!=
literal|null
condition|)
block|{
name|List
argument_list|<
name|Object
argument_list|>
name|result
init|=
name|dummyRow
decl_stmt|;
name|dummyRow
operator|=
literal|null
expr_stmt|;
return|return
name|result
return|;
block|}
if|if
condition|(
name|currentRow
operator|<
literal|0
operator|||
name|refs
operator|.
name|size
argument_list|()
operator|<
name|currentRow
condition|)
throw|throw
operator|new
name|HiveException
argument_list|(
literal|"No rows"
argument_list|)
throw|;
if|if
condition|(
name|refs
operator|.
name|size
argument_list|()
operator|==
name|currentRow
condition|)
return|return
literal|null
return|;
name|WriteBuffers
operator|.
name|ByteSegmentRef
name|ref
init|=
name|refs
operator|.
name|get
argument_list|(
name|currentRow
operator|++
argument_list|)
decl_stmt|;
if|if
condition|(
name|ref
operator|.
name|getLength
argument_list|()
operator|==
literal|0
condition|)
block|{
return|return
name|EMPTY_LIST
return|;
comment|// shortcut, 0 length means no fields
block|}
if|if
condition|(
name|ref
operator|.
name|getBytes
argument_list|()
operator|==
literal|null
condition|)
block|{
name|hashMap
operator|.
name|populateValue
argument_list|(
name|ref
argument_list|)
expr_stmt|;
block|}
name|uselessIndirection
operator|.
name|setData
argument_list|(
name|ref
operator|.
name|getBytes
argument_list|()
argument_list|)
expr_stmt|;
name|valueStruct
operator|.
name|init
argument_list|(
name|uselessIndirection
argument_list|,
operator|(
name|int
operator|)
name|ref
operator|.
name|getOffset
argument_list|()
argument_list|,
name|ref
operator|.
name|getLength
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|valueStruct
operator|.
name|getFieldsAsList
argument_list|()
return|;
comment|// TODO: should we unset bytes after that?
block|}
specifier|public
name|void
name|addRow
parameter_list|(
name|List
argument_list|<
name|Object
argument_list|>
name|t
parameter_list|)
block|{
if|if
condition|(
name|dummyRow
operator|!=
literal|null
operator|||
operator|!
name|refs
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Cannot add rows when not empty"
argument_list|)
throw|;
block|}
name|dummyRow
operator|=
name|t
expr_stmt|;
block|}
comment|// Various unsupported methods.
specifier|public
name|void
name|addRow
parameter_list|(
name|Object
index|[]
name|value
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
name|this
operator|.
name|getClass
argument_list|()
operator|.
name|getCanonicalName
argument_list|()
operator|+
literal|" cannot add arrays"
argument_list|)
throw|;
block|}
specifier|public
name|void
name|write
parameter_list|(
name|MapJoinObjectSerDeContext
name|valueContext
parameter_list|,
name|ObjectOutputStream
name|out
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
name|this
operator|.
name|getClass
argument_list|()
operator|.
name|getCanonicalName
argument_list|()
operator|+
literal|" cannot be serialized"
argument_list|)
throw|;
block|}
block|}
specifier|public
specifier|static
name|boolean
name|isSupportedKey
parameter_list|(
name|ObjectInspector
name|keyOi
parameter_list|)
block|{
name|List
argument_list|<
name|?
extends|extends
name|StructField
argument_list|>
name|keyFields
init|=
operator|(
operator|(
name|StructObjectInspector
operator|)
name|keyOi
operator|)
operator|.
name|getAllStructFieldRefs
argument_list|()
decl_stmt|;
for|for
control|(
name|StructField
name|field
range|:
name|keyFields
control|)
block|{
if|if
condition|(
operator|!
name|MapJoinKey
operator|.
name|isSupportedField
argument_list|(
name|field
operator|.
name|getFieldObjectInspector
argument_list|()
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
return|return
literal|true
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|dumpMetrics
parameter_list|()
block|{
name|hashMap
operator|.
name|debugDumpMetrics
argument_list|()
expr_stmt|;
block|}
block|}
end_class

end_unit

