begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|persistence
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|ObjectOutputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|conf
operator|.
name|HiveConf
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|ExprNodeEvaluator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|JoinUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|vector
operator|.
name|VectorHashKeyWrapper
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|vector
operator|.
name|VectorHashKeyWrapperBatch
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|vector
operator|.
name|expressions
operator|.
name|VectorExpressionWriter
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|metadata
operator|.
name|HiveException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|ByteStream
operator|.
name|Output
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|ByteStream
operator|.
name|RandomAccessOutput
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|SerDe
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|SerDeException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|WriteBuffers
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|binarysortable
operator|.
name|BinarySortableSerDe
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|io
operator|.
name|ShortWritable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|lazy
operator|.
name|ByteArrayRef
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|lazybinary
operator|.
name|LazyBinaryFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|lazybinary
operator|.
name|LazyBinarySerDe
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|lazybinary
operator|.
name|LazyBinaryStruct
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|lazybinary
operator|.
name|LazyBinaryUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|lazybinary
operator|.
name|objectinspector
operator|.
name|LazyBinaryObjectInspectorFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|lazybinary
operator|.
name|objectinspector
operator|.
name|LazyBinaryStructObjectInspector
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|objectinspector
operator|.
name|ObjectInspector
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|objectinspector
operator|.
name|ObjectInspector
operator|.
name|Category
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|objectinspector
operator|.
name|ObjectInspectorUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|objectinspector
operator|.
name|StructField
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|objectinspector
operator|.
name|StructObjectInspector
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|objectinspector
operator|.
name|ObjectInspectorUtils
operator|.
name|ObjectInspectorCopyOption
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|objectinspector
operator|.
name|primitive
operator|.
name|ShortObjectInspector
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|typeinfo
operator|.
name|TypeInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|typeinfo
operator|.
name|TypeInfoUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|BinaryComparable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|BytesWritable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|Writable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hive
operator|.
name|common
operator|.
name|util
operator|.
name|HashCodeUtil
import|;
end_import

begin_comment
comment|/**  * Table container that serializes keys and values using LazyBinarySerDe into  * BytesBytesMultiHashMap, with very low memory overhead. However,  * there may be some perf overhead when retrieving rows.  */
end_comment

begin_class
specifier|public
class|class
name|MapJoinBytesTableContainer
implements|implements
name|MapJoinTableContainer
implements|,
name|MapJoinTableContainerDirectAccess
block|{
specifier|private
specifier|static
specifier|final
name|Logger
name|LOG
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|MapJoinTableContainer
operator|.
name|class
argument_list|)
decl_stmt|;
specifier|private
specifier|final
name|BytesBytesMultiHashMap
name|hashMap
decl_stmt|;
comment|/** The OI used to deserialize values. We never deserialize keys. */
specifier|private
name|LazyBinaryStructObjectInspector
name|internalValueOi
decl_stmt|;
comment|/**    * This is kind of hacky. Currently we get BinarySortableSerDe-serialized keys; we could    * re-serialize them into LazyBinarySerDe, but instead we just reuse the bytes. However, to    * compare the large table keys correctly when we do, we need to serialize them with correct    * ordering. Hence, remember the ordering here; it is null if we do use LazyBinarySerDe.    */
specifier|private
name|boolean
index|[]
name|sortableSortOrders
decl_stmt|;
specifier|private
name|KeyValueHelper
name|writeHelper
decl_stmt|;
specifier|private
name|DirectKeyValueWriter
name|directWriteHelper
decl_stmt|;
specifier|private
specifier|final
name|List
argument_list|<
name|Object
argument_list|>
name|EMPTY_LIST
init|=
operator|new
name|ArrayList
argument_list|<
name|Object
argument_list|>
argument_list|(
literal|0
argument_list|)
decl_stmt|;
specifier|public
name|MapJoinBytesTableContainer
parameter_list|(
name|Configuration
name|hconf
parameter_list|,
name|MapJoinObjectSerDeContext
name|valCtx
parameter_list|,
name|long
name|keyCount
parameter_list|,
name|long
name|memUsage
parameter_list|)
throws|throws
name|SerDeException
block|{
name|this
argument_list|(
name|HiveConf
operator|.
name|getFloatVar
argument_list|(
name|hconf
argument_list|,
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVEHASHTABLEKEYCOUNTADJUSTMENT
argument_list|)
argument_list|,
name|HiveConf
operator|.
name|getIntVar
argument_list|(
name|hconf
argument_list|,
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVEHASHTABLETHRESHOLD
argument_list|)
argument_list|,
name|HiveConf
operator|.
name|getFloatVar
argument_list|(
name|hconf
argument_list|,
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVEHASHTABLELOADFACTOR
argument_list|)
argument_list|,
name|HiveConf
operator|.
name|getIntVar
argument_list|(
name|hconf
argument_list|,
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVEHASHTABLEWBSIZE
argument_list|)
argument_list|,
name|valCtx
argument_list|,
name|keyCount
argument_list|,
name|memUsage
argument_list|)
expr_stmt|;
block|}
specifier|private
name|MapJoinBytesTableContainer
parameter_list|(
name|float
name|keyCountAdj
parameter_list|,
name|int
name|threshold
parameter_list|,
name|float
name|loadFactor
parameter_list|,
name|int
name|wbSize
parameter_list|,
name|MapJoinObjectSerDeContext
name|valCtx
parameter_list|,
name|long
name|keyCount
parameter_list|,
name|long
name|memUsage
parameter_list|)
throws|throws
name|SerDeException
block|{
name|int
name|newThreshold
init|=
name|HashMapWrapper
operator|.
name|calculateTableSize
argument_list|(
name|keyCountAdj
argument_list|,
name|threshold
argument_list|,
name|loadFactor
argument_list|,
name|keyCount
argument_list|)
decl_stmt|;
name|hashMap
operator|=
operator|new
name|BytesBytesMultiHashMap
argument_list|(
name|newThreshold
argument_list|,
name|loadFactor
argument_list|,
name|wbSize
argument_list|,
name|memUsage
argument_list|)
expr_stmt|;
name|directWriteHelper
operator|=
operator|new
name|DirectKeyValueWriter
argument_list|()
expr_stmt|;
block|}
specifier|public
name|MapJoinBytesTableContainer
parameter_list|(
name|BytesBytesMultiHashMap
name|hashMap
parameter_list|)
block|{
name|this
operator|.
name|hashMap
operator|=
name|hashMap
expr_stmt|;
block|}
specifier|private
name|LazyBinaryStructObjectInspector
name|createInternalOi
parameter_list|(
name|MapJoinObjectSerDeContext
name|valCtx
parameter_list|)
throws|throws
name|SerDeException
block|{
comment|// We are going to use LBSerDe to serialize values; create OI for retrieval.
name|List
argument_list|<
name|?
extends|extends
name|StructField
argument_list|>
name|fields
init|=
operator|(
operator|(
name|StructObjectInspector
operator|)
name|valCtx
operator|.
name|getSerDe
argument_list|()
operator|.
name|getObjectInspector
argument_list|()
operator|)
operator|.
name|getAllStructFieldRefs
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|colNames
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|(
name|fields
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|ObjectInspector
argument_list|>
name|colOis
init|=
operator|new
name|ArrayList
argument_list|<
name|ObjectInspector
argument_list|>
argument_list|(
name|fields
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|fields
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|StructField
name|field
init|=
name|fields
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|colNames
operator|.
name|add
argument_list|(
name|field
operator|.
name|getFieldName
argument_list|()
argument_list|)
expr_stmt|;
comment|// It would be nice if OI could return typeInfo...
name|TypeInfo
name|typeInfo
init|=
name|TypeInfoUtils
operator|.
name|getTypeInfoFromTypeString
argument_list|(
name|field
operator|.
name|getFieldObjectInspector
argument_list|()
operator|.
name|getTypeName
argument_list|()
argument_list|)
decl_stmt|;
name|colOis
operator|.
name|add
argument_list|(
name|LazyBinaryUtils
operator|.
name|getLazyBinaryObjectInspectorFromTypeInfo
argument_list|(
name|typeInfo
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|LazyBinaryObjectInspectorFactory
operator|.
name|getLazyBinaryStructObjectInspector
argument_list|(
name|colNames
argument_list|,
name|colOis
argument_list|)
return|;
block|}
specifier|public
name|void
name|setInternalValueOi
parameter_list|(
name|LazyBinaryStructObjectInspector
name|internalValueOi
parameter_list|)
block|{
name|this
operator|.
name|internalValueOi
operator|=
name|internalValueOi
expr_stmt|;
block|}
specifier|public
name|void
name|setSortableSortOrders
parameter_list|(
name|boolean
index|[]
name|sortableSortOrders
parameter_list|)
block|{
name|this
operator|.
name|sortableSortOrders
operator|=
name|sortableSortOrders
expr_stmt|;
block|}
specifier|public
specifier|static
interface|interface
name|KeyValueHelper
extends|extends
name|BytesBytesMultiHashMap
operator|.
name|KvSource
block|{
name|void
name|setKeyValue
parameter_list|(
name|Writable
name|key
parameter_list|,
name|Writable
name|val
parameter_list|)
throws|throws
name|SerDeException
function_decl|;
comment|/** Get hash value from the key. */
name|int
name|getHashFromKey
parameter_list|()
throws|throws
name|SerDeException
function_decl|;
block|}
specifier|private
specifier|static
class|class
name|KeyValueWriter
implements|implements
name|KeyValueHelper
block|{
specifier|private
specifier|final
name|SerDe
name|keySerDe
decl_stmt|,
name|valSerDe
decl_stmt|;
specifier|private
specifier|final
name|StructObjectInspector
name|keySoi
decl_stmt|,
name|valSoi
decl_stmt|;
specifier|private
specifier|final
name|List
argument_list|<
name|ObjectInspector
argument_list|>
name|keyOis
decl_stmt|,
name|valOis
decl_stmt|;
specifier|private
specifier|final
name|Object
index|[]
name|keyObjs
decl_stmt|,
name|valObjs
decl_stmt|;
specifier|private
specifier|final
name|boolean
name|hasFilterTag
decl_stmt|;
specifier|public
name|KeyValueWriter
parameter_list|(
name|SerDe
name|keySerDe
parameter_list|,
name|SerDe
name|valSerDe
parameter_list|,
name|boolean
name|hasFilterTag
parameter_list|)
throws|throws
name|SerDeException
block|{
name|this
operator|.
name|keySerDe
operator|=
name|keySerDe
expr_stmt|;
name|this
operator|.
name|valSerDe
operator|=
name|valSerDe
expr_stmt|;
name|keySoi
operator|=
operator|(
name|StructObjectInspector
operator|)
name|keySerDe
operator|.
name|getObjectInspector
argument_list|()
expr_stmt|;
name|valSoi
operator|=
operator|(
name|StructObjectInspector
operator|)
name|valSerDe
operator|.
name|getObjectInspector
argument_list|()
expr_stmt|;
name|List
argument_list|<
name|?
extends|extends
name|StructField
argument_list|>
name|keyFields
init|=
name|keySoi
operator|.
name|getAllStructFieldRefs
argument_list|()
decl_stmt|,
name|valFields
init|=
name|valSoi
operator|.
name|getAllStructFieldRefs
argument_list|()
decl_stmt|;
name|keyOis
operator|=
operator|new
name|ArrayList
argument_list|<
name|ObjectInspector
argument_list|>
argument_list|(
name|keyFields
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|valOis
operator|=
operator|new
name|ArrayList
argument_list|<
name|ObjectInspector
argument_list|>
argument_list|(
name|valFields
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|keyFields
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|keyOis
operator|.
name|add
argument_list|(
name|keyFields
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|getFieldObjectInspector
argument_list|()
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|valFields
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|valOis
operator|.
name|add
argument_list|(
name|valFields
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|getFieldObjectInspector
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|keyObjs
operator|=
operator|new
name|Object
index|[
name|keyOis
operator|.
name|size
argument_list|()
index|]
expr_stmt|;
name|valObjs
operator|=
operator|new
name|Object
index|[
name|valOis
operator|.
name|size
argument_list|()
index|]
expr_stmt|;
name|this
operator|.
name|hasFilterTag
operator|=
name|hasFilterTag
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|writeKey
parameter_list|(
name|RandomAccessOutput
name|dest
parameter_list|)
throws|throws
name|SerDeException
block|{
name|LazyBinarySerDe
operator|.
name|serializeStruct
argument_list|(
name|dest
argument_list|,
name|keyObjs
argument_list|,
name|keyOis
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|writeValue
parameter_list|(
name|RandomAccessOutput
name|dest
parameter_list|)
throws|throws
name|SerDeException
block|{
name|LazyBinarySerDe
operator|.
name|serializeStruct
argument_list|(
name|dest
argument_list|,
name|valObjs
argument_list|,
name|valOis
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|setKeyValue
parameter_list|(
name|Writable
name|key
parameter_list|,
name|Writable
name|val
parameter_list|)
throws|throws
name|SerDeException
block|{
name|Object
name|keyObj
init|=
name|keySerDe
operator|.
name|deserialize
argument_list|(
name|key
argument_list|)
decl_stmt|,
name|valObj
init|=
name|valSerDe
operator|.
name|deserialize
argument_list|(
name|val
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|?
extends|extends
name|StructField
argument_list|>
name|keyFields
init|=
name|keySoi
operator|.
name|getAllStructFieldRefs
argument_list|()
decl_stmt|,
name|valFields
init|=
name|valSoi
operator|.
name|getAllStructFieldRefs
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|keyFields
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|keyObjs
index|[
name|i
index|]
operator|=
name|keySoi
operator|.
name|getStructFieldData
argument_list|(
name|keyObj
argument_list|,
name|keyFields
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|valFields
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|valObjs
index|[
name|i
index|]
operator|=
name|valSoi
operator|.
name|getStructFieldData
argument_list|(
name|valObj
argument_list|,
name|valFields
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|byte
name|updateStateByte
parameter_list|(
name|Byte
name|previousValue
parameter_list|)
block|{
if|if
condition|(
operator|!
name|hasFilterTag
condition|)
return|return
operator|(
name|byte
operator|)
literal|0xff
return|;
name|byte
name|aliasFilter
init|=
operator|(
name|previousValue
operator|==
literal|null
operator|)
condition|?
operator|(
name|byte
operator|)
literal|0xff
else|:
name|previousValue
operator|.
name|byteValue
argument_list|()
decl_stmt|;
name|aliasFilter
operator|&=
operator|(
operator|(
name|ShortWritable
operator|)
name|valObjs
index|[
name|valObjs
operator|.
name|length
operator|-
literal|1
index|]
operator|)
operator|.
name|get
argument_list|()
expr_stmt|;
return|return
name|aliasFilter
return|;
block|}
annotation|@
name|Override
specifier|public
name|int
name|getHashFromKey
parameter_list|()
throws|throws
name|SerDeException
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|(
literal|"Not supported for MapJoinBytesTableContainer"
argument_list|)
throw|;
block|}
block|}
specifier|static
class|class
name|LazyBinaryKvWriter
implements|implements
name|KeyValueHelper
block|{
specifier|private
specifier|final
name|LazyBinaryStruct
operator|.
name|SingleFieldGetter
name|filterGetter
decl_stmt|;
specifier|private
name|Writable
name|key
decl_stmt|,
name|value
decl_stmt|;
specifier|private
specifier|final
name|SerDe
name|keySerDe
decl_stmt|;
specifier|private
name|Boolean
name|hasTag
init|=
literal|null
decl_stmt|;
comment|// sanity check - we should not receive keys with tags
specifier|public
name|LazyBinaryKvWriter
parameter_list|(
name|SerDe
name|keySerDe
parameter_list|,
name|LazyBinaryStructObjectInspector
name|valSoi
parameter_list|,
name|boolean
name|hasFilterTag
parameter_list|)
throws|throws
name|SerDeException
block|{
name|this
operator|.
name|keySerDe
operator|=
name|keySerDe
expr_stmt|;
if|if
condition|(
name|hasFilterTag
condition|)
block|{
name|List
argument_list|<
name|?
extends|extends
name|StructField
argument_list|>
name|fields
init|=
name|valSoi
operator|.
name|getAllStructFieldRefs
argument_list|()
decl_stmt|;
name|int
name|ix
init|=
name|fields
operator|.
name|size
argument_list|()
operator|-
literal|1
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|fields
operator|.
name|get
argument_list|(
name|ix
argument_list|)
operator|.
name|getFieldObjectInspector
argument_list|()
operator|instanceof
name|ShortObjectInspector
operator|)
condition|)
block|{
throw|throw
operator|new
name|SerDeException
argument_list|(
literal|"Has filter tag, but corresponding OI is "
operator|+
name|fields
operator|.
name|get
argument_list|(
name|ix
argument_list|)
operator|.
name|getFieldObjectInspector
argument_list|()
argument_list|)
throw|;
block|}
name|filterGetter
operator|=
operator|new
name|LazyBinaryStruct
operator|.
name|SingleFieldGetter
argument_list|(
name|valSoi
argument_list|,
name|fields
operator|.
name|size
argument_list|()
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|filterGetter
operator|=
literal|null
expr_stmt|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|void
name|writeKey
parameter_list|(
name|RandomAccessOutput
name|dest
parameter_list|)
throws|throws
name|SerDeException
block|{
if|if
condition|(
operator|!
operator|(
name|key
operator|instanceof
name|BinaryComparable
operator|)
condition|)
block|{
throw|throw
operator|new
name|SerDeException
argument_list|(
literal|"Unexpected type "
operator|+
name|key
operator|.
name|getClass
argument_list|()
operator|.
name|getCanonicalName
argument_list|()
argument_list|)
throw|;
block|}
name|sanityCheckKeyForTag
argument_list|()
expr_stmt|;
name|BinaryComparable
name|b
init|=
operator|(
name|BinaryComparable
operator|)
name|key
decl_stmt|;
name|dest
operator|.
name|write
argument_list|(
name|b
operator|.
name|getBytes
argument_list|()
argument_list|,
literal|0
argument_list|,
name|b
operator|.
name|getLength
argument_list|()
operator|-
operator|(
name|hasTag
condition|?
literal|1
else|:
literal|0
operator|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|int
name|getHashFromKey
parameter_list|()
throws|throws
name|SerDeException
block|{
if|if
condition|(
operator|!
operator|(
name|key
operator|instanceof
name|BinaryComparable
operator|)
condition|)
block|{
throw|throw
operator|new
name|SerDeException
argument_list|(
literal|"Unexpected type "
operator|+
name|key
operator|.
name|getClass
argument_list|()
operator|.
name|getCanonicalName
argument_list|()
argument_list|)
throw|;
block|}
name|sanityCheckKeyForTag
argument_list|()
expr_stmt|;
name|BinaryComparable
name|b
init|=
operator|(
name|BinaryComparable
operator|)
name|key
decl_stmt|;
return|return
name|HashCodeUtil
operator|.
name|murmurHash
argument_list|(
name|b
operator|.
name|getBytes
argument_list|()
argument_list|,
literal|0
argument_list|,
name|b
operator|.
name|getLength
argument_list|()
operator|-
operator|(
name|hasTag
condition|?
literal|1
else|:
literal|0
operator|)
argument_list|)
return|;
block|}
comment|/**      * If we received data with tags from ReduceSinkOperators, no keys will match. This should      * not happen, but is important enough that we want to find out and work around it if some      * optimized change causes RSO to pass on tags.      */
specifier|private
name|void
name|sanityCheckKeyForTag
parameter_list|()
throws|throws
name|SerDeException
block|{
if|if
condition|(
name|hasTag
operator|!=
literal|null
condition|)
return|return;
name|BinaryComparable
name|b
init|=
operator|(
name|BinaryComparable
operator|)
name|key
decl_stmt|;
name|Object
name|o
init|=
name|keySerDe
operator|.
name|deserialize
argument_list|(
name|key
argument_list|)
decl_stmt|;
name|StructObjectInspector
name|soi
init|=
operator|(
name|StructObjectInspector
operator|)
name|keySerDe
operator|.
name|getObjectInspector
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|?
extends|extends
name|StructField
argument_list|>
name|fields
init|=
name|soi
operator|.
name|getAllStructFieldRefs
argument_list|()
decl_stmt|;
name|Object
index|[]
name|data
init|=
operator|new
name|Object
index|[
name|fields
operator|.
name|size
argument_list|()
index|]
decl_stmt|;
name|List
argument_list|<
name|ObjectInspector
argument_list|>
name|fois
init|=
operator|new
name|ArrayList
argument_list|<
name|ObjectInspector
argument_list|>
argument_list|(
name|fields
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|fields
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|data
index|[
name|i
index|]
operator|=
name|soi
operator|.
name|getStructFieldData
argument_list|(
name|o
argument_list|,
name|fields
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|fois
operator|.
name|add
argument_list|(
name|fields
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|getFieldObjectInspector
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|Output
name|output
init|=
operator|new
name|Output
argument_list|()
decl_stmt|;
name|BinarySortableSerDe
operator|.
name|serializeStruct
argument_list|(
name|output
argument_list|,
name|data
argument_list|,
name|fois
argument_list|,
operator|new
name|boolean
index|[
name|fields
operator|.
name|size
argument_list|()
index|]
argument_list|)
expr_stmt|;
name|hasTag
operator|=
operator|(
name|output
operator|.
name|getLength
argument_list|()
operator|!=
name|b
operator|.
name|getLength
argument_list|()
operator|)
expr_stmt|;
if|if
condition|(
name|hasTag
condition|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Tag found in keys and will be removed. This should not happen."
argument_list|)
expr_stmt|;
if|if
condition|(
name|output
operator|.
name|getLength
argument_list|()
operator|!=
operator|(
name|b
operator|.
name|getLength
argument_list|()
operator|-
literal|1
operator|)
condition|)
block|{
throw|throw
operator|new
name|SerDeException
argument_list|(
literal|"Unexpected tag: "
operator|+
name|b
operator|.
name|getLength
argument_list|()
operator|+
literal|" reserialized to "
operator|+
name|output
operator|.
name|getLength
argument_list|()
argument_list|)
throw|;
block|}
block|}
block|}
annotation|@
name|Override
specifier|public
name|void
name|writeValue
parameter_list|(
name|RandomAccessOutput
name|dest
parameter_list|)
throws|throws
name|SerDeException
block|{
if|if
condition|(
operator|!
operator|(
name|value
operator|instanceof
name|BinaryComparable
operator|)
condition|)
block|{
throw|throw
operator|new
name|SerDeException
argument_list|(
literal|"Unexpected type "
operator|+
name|value
operator|.
name|getClass
argument_list|()
operator|.
name|getCanonicalName
argument_list|()
argument_list|)
throw|;
block|}
name|BinaryComparable
name|b
init|=
operator|(
name|BinaryComparable
operator|)
name|value
decl_stmt|;
name|dest
operator|.
name|write
argument_list|(
name|b
operator|.
name|getBytes
argument_list|()
argument_list|,
literal|0
argument_list|,
name|b
operator|.
name|getLength
argument_list|()
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|setKeyValue
parameter_list|(
name|Writable
name|key
parameter_list|,
name|Writable
name|val
parameter_list|)
block|{
name|this
operator|.
name|key
operator|=
name|key
expr_stmt|;
name|this
operator|.
name|value
operator|=
name|val
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|byte
name|updateStateByte
parameter_list|(
name|Byte
name|previousValue
parameter_list|)
block|{
if|if
condition|(
name|filterGetter
operator|==
literal|null
condition|)
return|return
operator|(
name|byte
operator|)
literal|0xff
return|;
name|byte
name|aliasFilter
init|=
operator|(
name|previousValue
operator|==
literal|null
operator|)
condition|?
operator|(
name|byte
operator|)
literal|0xff
else|:
name|previousValue
operator|.
name|byteValue
argument_list|()
decl_stmt|;
name|filterGetter
operator|.
name|init
argument_list|(
operator|(
name|BinaryComparable
operator|)
name|value
argument_list|)
expr_stmt|;
name|aliasFilter
operator|&=
name|filterGetter
operator|.
name|getShort
argument_list|()
expr_stmt|;
return|return
name|aliasFilter
return|;
block|}
block|}
comment|/*    * An implementation of KvSource that can handle key and value as BytesWritable objects.    */
specifier|protected
specifier|static
class|class
name|DirectKeyValueWriter
implements|implements
name|KeyValueHelper
block|{
specifier|private
name|BytesWritable
name|key
decl_stmt|;
specifier|private
name|BytesWritable
name|val
decl_stmt|;
annotation|@
name|Override
specifier|public
name|void
name|setKeyValue
parameter_list|(
name|Writable
name|key
parameter_list|,
name|Writable
name|val
parameter_list|)
throws|throws
name|SerDeException
block|{
name|this
operator|.
name|key
operator|=
operator|(
name|BytesWritable
operator|)
name|key
expr_stmt|;
name|this
operator|.
name|val
operator|=
operator|(
name|BytesWritable
operator|)
name|val
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|writeKey
parameter_list|(
name|RandomAccessOutput
name|dest
parameter_list|)
throws|throws
name|SerDeException
block|{
name|byte
index|[]
name|keyBytes
init|=
name|key
operator|.
name|getBytes
argument_list|()
decl_stmt|;
name|int
name|keyLength
init|=
name|key
operator|.
name|getLength
argument_list|()
decl_stmt|;
name|dest
operator|.
name|write
argument_list|(
name|keyBytes
argument_list|,
literal|0
argument_list|,
name|keyLength
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|writeValue
parameter_list|(
name|RandomAccessOutput
name|dest
parameter_list|)
throws|throws
name|SerDeException
block|{
name|byte
index|[]
name|valueBytes
init|=
name|val
operator|.
name|getBytes
argument_list|()
decl_stmt|;
name|int
name|valueLength
init|=
name|val
operator|.
name|getLength
argument_list|()
decl_stmt|;
name|dest
operator|.
name|write
argument_list|(
name|valueBytes
argument_list|,
literal|0
argument_list|,
name|valueLength
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|byte
name|updateStateByte
parameter_list|(
name|Byte
name|previousValue
parameter_list|)
block|{
comment|// Not used by the direct access client -- native vector map join.
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|(
literal|"Updating the state by not supported"
argument_list|)
throw|;
block|}
annotation|@
name|Override
specifier|public
name|int
name|getHashFromKey
parameter_list|()
throws|throws
name|SerDeException
block|{
name|byte
index|[]
name|keyBytes
init|=
name|key
operator|.
name|getBytes
argument_list|()
decl_stmt|;
name|int
name|keyLength
init|=
name|key
operator|.
name|getLength
argument_list|()
decl_stmt|;
return|return
name|HashCodeUtil
operator|.
name|murmurHash
argument_list|(
name|keyBytes
argument_list|,
literal|0
argument_list|,
name|keyLength
argument_list|)
return|;
block|}
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"deprecation"
argument_list|)
annotation|@
name|Override
specifier|public
name|MapJoinKey
name|putRow
parameter_list|(
name|MapJoinObjectSerDeContext
name|keyContext
parameter_list|,
name|Writable
name|currentKey
parameter_list|,
name|MapJoinObjectSerDeContext
name|valueContext
parameter_list|,
name|Writable
name|currentValue
parameter_list|)
throws|throws
name|SerDeException
block|{
name|SerDe
name|keySerde
init|=
name|keyContext
operator|.
name|getSerDe
argument_list|()
decl_stmt|,
name|valSerde
init|=
name|valueContext
operator|.
name|getSerDe
argument_list|()
decl_stmt|;
if|if
condition|(
name|writeHelper
operator|==
literal|null
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Initializing container with "
operator|+
name|keySerde
operator|.
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
operator|+
literal|" and "
operator|+
name|valSerde
operator|.
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|keySerde
operator|instanceof
name|BinarySortableSerDe
operator|&&
name|valSerde
operator|instanceof
name|LazyBinarySerDe
condition|)
block|{
name|LazyBinaryStructObjectInspector
name|valSoi
init|=
operator|(
name|LazyBinaryStructObjectInspector
operator|)
name|valSerde
operator|.
name|getObjectInspector
argument_list|()
decl_stmt|;
name|writeHelper
operator|=
operator|new
name|LazyBinaryKvWriter
argument_list|(
name|keySerde
argument_list|,
name|valSoi
argument_list|,
name|valueContext
operator|.
name|hasFilterTag
argument_list|()
argument_list|)
expr_stmt|;
name|internalValueOi
operator|=
name|valSoi
expr_stmt|;
name|sortableSortOrders
operator|=
operator|(
operator|(
name|BinarySortableSerDe
operator|)
name|keySerde
operator|)
operator|.
name|getSortOrders
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|writeHelper
operator|=
operator|new
name|KeyValueWriter
argument_list|(
name|keySerde
argument_list|,
name|valSerde
argument_list|,
name|valueContext
operator|.
name|hasFilterTag
argument_list|()
argument_list|)
expr_stmt|;
name|internalValueOi
operator|=
name|createInternalOi
argument_list|(
name|valueContext
argument_list|)
expr_stmt|;
name|sortableSortOrders
operator|=
literal|null
expr_stmt|;
block|}
block|}
name|writeHelper
operator|.
name|setKeyValue
argument_list|(
name|currentKey
argument_list|,
name|currentValue
argument_list|)
expr_stmt|;
name|hashMap
operator|.
name|put
argument_list|(
name|writeHelper
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
comment|// there's no key to return
block|}
annotation|@
name|Override
specifier|public
name|void
name|clear
parameter_list|()
block|{
comment|// Don't clear the hash table - reuse is possible. GC will take care of it.
block|}
annotation|@
name|Override
specifier|public
name|MapJoinKey
name|getAnyKey
parameter_list|()
block|{
return|return
literal|null
return|;
comment|// This table has no keys.
block|}
annotation|@
name|Override
specifier|public
name|ReusableGetAdaptor
name|createGetter
parameter_list|(
name|MapJoinKey
name|keyTypeFromLoader
parameter_list|)
block|{
if|if
condition|(
name|keyTypeFromLoader
operator|!=
literal|null
condition|)
block|{
throw|throw
operator|new
name|AssertionError
argument_list|(
literal|"No key expected from loader but got "
operator|+
name|keyTypeFromLoader
argument_list|)
throw|;
block|}
return|return
operator|new
name|GetAdaptor
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|seal
parameter_list|()
block|{
name|hashMap
operator|.
name|seal
argument_list|()
expr_stmt|;
block|}
comment|// Direct access interfaces.
annotation|@
name|Override
specifier|public
name|void
name|put
parameter_list|(
name|Writable
name|currentKey
parameter_list|,
name|Writable
name|currentValue
parameter_list|)
throws|throws
name|SerDeException
block|{
name|directWriteHelper
operator|.
name|setKeyValue
argument_list|(
name|currentKey
argument_list|,
name|currentValue
argument_list|)
expr_stmt|;
name|hashMap
operator|.
name|put
argument_list|(
name|directWriteHelper
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
specifier|public
specifier|static
name|boolean
name|hasComplexObjects
parameter_list|(
name|LazyBinaryStructObjectInspector
name|lazyBinaryStructObjectInspector
parameter_list|)
block|{
name|List
argument_list|<
name|?
extends|extends
name|StructField
argument_list|>
name|fields
init|=
name|lazyBinaryStructObjectInspector
operator|.
name|getAllStructFieldRefs
argument_list|()
decl_stmt|;
for|for
control|(
name|StructField
name|field
range|:
name|fields
control|)
block|{
if|if
condition|(
name|field
operator|.
name|getFieldObjectInspector
argument_list|()
operator|.
name|getCategory
argument_list|()
operator|!=
name|Category
operator|.
name|PRIMITIVE
condition|)
block|{
return|return
literal|true
return|;
block|}
block|}
return|return
literal|false
return|;
block|}
comment|/*    * For primitive types, use LazyBinary's object.    * For complex types, make a standard (Java) object from LazyBinary's object.    */
specifier|public
specifier|static
name|List
argument_list|<
name|Object
argument_list|>
name|getComplexFieldsAsList
parameter_list|(
name|LazyBinaryStruct
name|lazyBinaryStruct
parameter_list|,
name|ArrayList
argument_list|<
name|Object
argument_list|>
name|objectArrayBuffer
parameter_list|,
name|LazyBinaryStructObjectInspector
name|lazyBinaryStructObjectInspector
parameter_list|)
block|{
name|List
argument_list|<
name|?
extends|extends
name|StructField
argument_list|>
name|fields
init|=
name|lazyBinaryStructObjectInspector
operator|.
name|getAllStructFieldRefs
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|fields
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|StructField
name|field
init|=
name|fields
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|ObjectInspector
name|objectInspector
init|=
name|field
operator|.
name|getFieldObjectInspector
argument_list|()
decl_stmt|;
name|Category
name|category
init|=
name|objectInspector
operator|.
name|getCategory
argument_list|()
decl_stmt|;
name|Object
name|object
init|=
name|lazyBinaryStruct
operator|.
name|getField
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|category
operator|==
name|Category
operator|.
name|PRIMITIVE
condition|)
block|{
name|objectArrayBuffer
operator|.
name|set
argument_list|(
name|i
argument_list|,
name|object
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|objectArrayBuffer
operator|.
name|set
argument_list|(
name|i
argument_list|,
name|ObjectInspectorUtils
operator|.
name|copyToStandardObject
argument_list|(
name|object
argument_list|,
name|objectInspector
argument_list|,
name|ObjectInspectorCopyOption
operator|.
name|WRITABLE
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|objectArrayBuffer
return|;
block|}
comment|/** Implementation of ReusableGetAdaptor that has Output for key serialization; row    * container is also created once and reused for every row. */
specifier|private
class|class
name|GetAdaptor
implements|implements
name|ReusableGetAdaptor
implements|,
name|ReusableGetAdaptorDirectAccess
block|{
specifier|private
name|Object
index|[]
name|currentKey
decl_stmt|;
specifier|private
name|boolean
index|[]
name|nulls
decl_stmt|;
specifier|private
name|List
argument_list|<
name|ObjectInspector
argument_list|>
name|vectorKeyOIs
decl_stmt|;
specifier|private
specifier|final
name|ReusableRowContainer
name|currentValue
decl_stmt|;
specifier|private
specifier|final
name|Output
name|output
decl_stmt|;
specifier|public
name|GetAdaptor
parameter_list|()
block|{
name|currentValue
operator|=
operator|new
name|ReusableRowContainer
argument_list|()
expr_stmt|;
name|output
operator|=
operator|new
name|Output
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|JoinUtil
operator|.
name|JoinResult
name|setFromVector
parameter_list|(
name|VectorHashKeyWrapper
name|kw
parameter_list|,
name|VectorExpressionWriter
index|[]
name|keyOutputWriters
parameter_list|,
name|VectorHashKeyWrapperBatch
name|keyWrapperBatch
parameter_list|)
throws|throws
name|HiveException
block|{
if|if
condition|(
name|nulls
operator|==
literal|null
condition|)
block|{
name|nulls
operator|=
operator|new
name|boolean
index|[
name|keyOutputWriters
operator|.
name|length
index|]
expr_stmt|;
name|currentKey
operator|=
operator|new
name|Object
index|[
name|keyOutputWriters
operator|.
name|length
index|]
expr_stmt|;
name|vectorKeyOIs
operator|=
operator|new
name|ArrayList
argument_list|<
name|ObjectInspector
argument_list|>
argument_list|()
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|keyOutputWriters
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|vectorKeyOIs
operator|.
name|add
argument_list|(
name|keyOutputWriters
index|[
name|i
index|]
operator|.
name|getObjectInspector
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
assert|assert
name|nulls
operator|.
name|length
operator|==
name|keyOutputWriters
operator|.
name|length
assert|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|keyOutputWriters
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|currentKey
index|[
name|i
index|]
operator|=
name|keyWrapperBatch
operator|.
name|getWritableKeyValue
argument_list|(
name|kw
argument_list|,
name|i
argument_list|,
name|keyOutputWriters
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|nulls
index|[
name|i
index|]
operator|=
name|currentKey
index|[
name|i
index|]
operator|==
literal|null
expr_stmt|;
block|}
return|return
name|currentValue
operator|.
name|setFromOutput
argument_list|(
name|MapJoinKey
operator|.
name|serializeRow
argument_list|(
name|output
argument_list|,
name|currentKey
argument_list|,
name|vectorKeyOIs
argument_list|,
name|sortableSortOrders
argument_list|)
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|JoinUtil
operator|.
name|JoinResult
name|setFromRow
parameter_list|(
name|Object
name|row
parameter_list|,
name|List
argument_list|<
name|ExprNodeEvaluator
argument_list|>
name|fields
parameter_list|,
name|List
argument_list|<
name|ObjectInspector
argument_list|>
name|ois
parameter_list|)
throws|throws
name|HiveException
block|{
if|if
condition|(
name|nulls
operator|==
literal|null
condition|)
block|{
name|nulls
operator|=
operator|new
name|boolean
index|[
name|fields
operator|.
name|size
argument_list|()
index|]
expr_stmt|;
name|currentKey
operator|=
operator|new
name|Object
index|[
name|fields
operator|.
name|size
argument_list|()
index|]
expr_stmt|;
block|}
for|for
control|(
name|int
name|keyIndex
init|=
literal|0
init|;
name|keyIndex
operator|<
name|fields
operator|.
name|size
argument_list|()
condition|;
operator|++
name|keyIndex
control|)
block|{
name|currentKey
index|[
name|keyIndex
index|]
operator|=
name|fields
operator|.
name|get
argument_list|(
name|keyIndex
argument_list|)
operator|.
name|evaluate
argument_list|(
name|row
argument_list|)
expr_stmt|;
name|nulls
index|[
name|keyIndex
index|]
operator|=
name|currentKey
index|[
name|keyIndex
index|]
operator|==
literal|null
expr_stmt|;
block|}
return|return
name|currentValue
operator|.
name|setFromOutput
argument_list|(
name|MapJoinKey
operator|.
name|serializeRow
argument_list|(
name|output
argument_list|,
name|currentKey
argument_list|,
name|ois
argument_list|,
name|sortableSortOrders
argument_list|)
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|JoinUtil
operator|.
name|JoinResult
name|setFromOther
parameter_list|(
name|ReusableGetAdaptor
name|other
parameter_list|)
block|{
assert|assert
name|other
operator|instanceof
name|GetAdaptor
assert|;
name|GetAdaptor
name|other2
init|=
operator|(
name|GetAdaptor
operator|)
name|other
decl_stmt|;
name|nulls
operator|=
name|other2
operator|.
name|nulls
expr_stmt|;
name|currentKey
operator|=
name|other2
operator|.
name|currentKey
expr_stmt|;
return|return
name|currentValue
operator|.
name|setFromOutput
argument_list|(
name|other2
operator|.
name|output
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|hasAnyNulls
parameter_list|(
name|int
name|fieldCount
parameter_list|,
name|boolean
index|[]
name|nullsafes
parameter_list|)
block|{
if|if
condition|(
name|nulls
operator|==
literal|null
operator|||
name|nulls
operator|.
name|length
operator|==
literal|0
condition|)
return|return
literal|false
return|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|nulls
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|nulls
index|[
name|i
index|]
operator|&&
operator|(
name|nullsafes
operator|==
literal|null
operator|||
operator|!
name|nullsafes
index|[
name|i
index|]
operator|)
condition|)
block|{
return|return
literal|true
return|;
block|}
block|}
return|return
literal|false
return|;
block|}
annotation|@
name|Override
specifier|public
name|MapJoinRowContainer
name|getCurrentRows
parameter_list|()
block|{
return|return
operator|!
name|currentValue
operator|.
name|hasRows
argument_list|()
condition|?
literal|null
else|:
name|currentValue
return|;
block|}
annotation|@
name|Override
specifier|public
name|Object
index|[]
name|getCurrentKey
parameter_list|()
block|{
return|return
name|currentKey
return|;
block|}
comment|// Direct access interfaces.
annotation|@
name|Override
specifier|public
name|JoinUtil
operator|.
name|JoinResult
name|setDirect
parameter_list|(
name|byte
index|[]
name|bytes
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|length
parameter_list|,
name|BytesBytesMultiHashMap
operator|.
name|Result
name|hashMapResult
parameter_list|)
block|{
return|return
name|currentValue
operator|.
name|setDirect
argument_list|(
name|bytes
argument_list|,
name|offset
argument_list|,
name|length
argument_list|,
name|hashMapResult
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|int
name|directSpillPartitionId
parameter_list|()
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|(
literal|"Getting the spill hash partition not supported"
argument_list|)
throw|;
block|}
block|}
comment|/** Row container that gets and deserializes the rows on demand from bytes provided. */
specifier|private
class|class
name|ReusableRowContainer
implements|implements
name|MapJoinRowContainer
implements|,
name|AbstractRowContainer
operator|.
name|RowIterator
argument_list|<
name|List
argument_list|<
name|Object
argument_list|>
argument_list|>
block|{
specifier|private
name|byte
name|aliasFilter
decl_stmt|;
comment|/** Hash table wrapper specific to the container. */
specifier|private
name|BytesBytesMultiHashMap
operator|.
name|Result
name|hashMapResult
decl_stmt|;
comment|/**      * Sometimes, when container is empty in multi-table mapjoin, we need to add a dummy row.      * This container does not normally support adding rows; this is for the dummy row.      */
specifier|private
name|List
argument_list|<
name|Object
argument_list|>
name|dummyRow
init|=
literal|null
decl_stmt|;
specifier|private
specifier|final
name|ByteArrayRef
name|uselessIndirection
decl_stmt|;
comment|// LBStruct needs ByteArrayRef
specifier|private
specifier|final
name|LazyBinaryStruct
name|valueStruct
decl_stmt|;
specifier|private
specifier|final
name|boolean
name|needsComplexObjectFixup
decl_stmt|;
specifier|private
specifier|final
name|ArrayList
argument_list|<
name|Object
argument_list|>
name|complexObjectArrayBuffer
decl_stmt|;
specifier|public
name|ReusableRowContainer
parameter_list|()
block|{
if|if
condition|(
name|internalValueOi
operator|!=
literal|null
condition|)
block|{
name|valueStruct
operator|=
operator|(
name|LazyBinaryStruct
operator|)
name|LazyBinaryFactory
operator|.
name|createLazyBinaryObject
argument_list|(
name|internalValueOi
argument_list|)
expr_stmt|;
name|needsComplexObjectFixup
operator|=
name|hasComplexObjects
argument_list|(
name|internalValueOi
argument_list|)
expr_stmt|;
if|if
condition|(
name|needsComplexObjectFixup
condition|)
block|{
name|complexObjectArrayBuffer
operator|=
operator|new
name|ArrayList
argument_list|<
name|Object
argument_list|>
argument_list|(
name|Collections
operator|.
name|nCopies
argument_list|(
name|internalValueOi
operator|.
name|getAllStructFieldRefs
argument_list|()
operator|.
name|size
argument_list|()
argument_list|,
literal|null
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|complexObjectArrayBuffer
operator|=
literal|null
expr_stmt|;
block|}
block|}
else|else
block|{
name|valueStruct
operator|=
literal|null
expr_stmt|;
comment|// No rows?
name|needsComplexObjectFixup
operator|=
literal|false
expr_stmt|;
name|complexObjectArrayBuffer
operator|=
literal|null
expr_stmt|;
block|}
name|uselessIndirection
operator|=
operator|new
name|ByteArrayRef
argument_list|()
expr_stmt|;
name|hashMapResult
operator|=
operator|new
name|BytesBytesMultiHashMap
operator|.
name|Result
argument_list|()
expr_stmt|;
name|clearRows
argument_list|()
expr_stmt|;
block|}
specifier|public
name|JoinUtil
operator|.
name|JoinResult
name|setFromOutput
parameter_list|(
name|Output
name|output
parameter_list|)
block|{
name|aliasFilter
operator|=
name|hashMap
operator|.
name|getValueResult
argument_list|(
name|output
operator|.
name|getData
argument_list|()
argument_list|,
literal|0
argument_list|,
name|output
operator|.
name|getLength
argument_list|()
argument_list|,
name|hashMapResult
argument_list|)
expr_stmt|;
name|dummyRow
operator|=
literal|null
expr_stmt|;
if|if
condition|(
name|hashMapResult
operator|.
name|hasRows
argument_list|()
condition|)
block|{
return|return
name|JoinUtil
operator|.
name|JoinResult
operator|.
name|MATCH
return|;
block|}
else|else
block|{
name|aliasFilter
operator|=
operator|(
name|byte
operator|)
literal|0xff
expr_stmt|;
return|return
name|JoinUtil
operator|.
name|JoinResult
operator|.
name|NOMATCH
return|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|hasRows
parameter_list|()
block|{
return|return
name|hashMapResult
operator|.
name|hasRows
argument_list|()
operator|||
operator|(
name|dummyRow
operator|!=
literal|null
operator|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|isSingleRow
parameter_list|()
block|{
if|if
condition|(
operator|!
name|hashMapResult
operator|.
name|hasRows
argument_list|()
condition|)
block|{
return|return
operator|(
name|dummyRow
operator|!=
literal|null
operator|)
return|;
block|}
return|return
name|hashMapResult
operator|.
name|isSingleRow
argument_list|()
return|;
block|}
comment|// Implementation of row container
annotation|@
name|Override
specifier|public
name|AbstractRowContainer
operator|.
name|RowIterator
argument_list|<
name|List
argument_list|<
name|Object
argument_list|>
argument_list|>
name|rowIter
parameter_list|()
throws|throws
name|HiveException
block|{
return|return
name|this
return|;
block|}
annotation|@
name|Override
specifier|public
name|int
name|rowCount
parameter_list|()
throws|throws
name|HiveException
block|{
comment|// For performance reasons we do not want to chase the values to the end to determine
comment|// the count.  Use hasRows and isSingleRow instead.
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|(
literal|"Getting the row count not supported"
argument_list|)
throw|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|clearRows
parameter_list|()
block|{
comment|// Doesn't clear underlying hashtable
name|hashMapResult
operator|.
name|forget
argument_list|()
expr_stmt|;
name|dummyRow
operator|=
literal|null
expr_stmt|;
name|aliasFilter
operator|=
operator|(
name|byte
operator|)
literal|0xff
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|byte
name|getAliasFilter
parameter_list|()
throws|throws
name|HiveException
block|{
return|return
name|aliasFilter
return|;
block|}
annotation|@
name|Override
specifier|public
name|MapJoinRowContainer
name|copy
parameter_list|()
throws|throws
name|HiveException
block|{
return|return
name|this
return|;
comment|// Independent of hashtable and can be modified, no need to copy.
block|}
comment|// Implementation of row iterator
annotation|@
name|Override
specifier|public
name|List
argument_list|<
name|Object
argument_list|>
name|first
parameter_list|()
throws|throws
name|HiveException
block|{
comment|// A little strange that we forget the dummy row on read.
if|if
condition|(
name|dummyRow
operator|!=
literal|null
condition|)
block|{
name|List
argument_list|<
name|Object
argument_list|>
name|result
init|=
name|dummyRow
decl_stmt|;
name|dummyRow
operator|=
literal|null
expr_stmt|;
return|return
name|result
return|;
block|}
name|WriteBuffers
operator|.
name|ByteSegmentRef
name|byteSegmentRef
init|=
name|hashMapResult
operator|.
name|first
argument_list|()
decl_stmt|;
if|if
condition|(
name|byteSegmentRef
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
else|else
block|{
return|return
name|unpack
argument_list|(
name|byteSegmentRef
argument_list|)
return|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|List
argument_list|<
name|Object
argument_list|>
name|next
parameter_list|()
throws|throws
name|HiveException
block|{
name|WriteBuffers
operator|.
name|ByteSegmentRef
name|byteSegmentRef
init|=
name|hashMapResult
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
name|byteSegmentRef
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
else|else
block|{
return|return
name|unpack
argument_list|(
name|byteSegmentRef
argument_list|)
return|;
block|}
block|}
specifier|private
name|List
argument_list|<
name|Object
argument_list|>
name|unpack
parameter_list|(
name|WriteBuffers
operator|.
name|ByteSegmentRef
name|ref
parameter_list|)
throws|throws
name|HiveException
block|{
if|if
condition|(
name|ref
operator|.
name|getLength
argument_list|()
operator|==
literal|0
condition|)
block|{
return|return
name|EMPTY_LIST
return|;
comment|// shortcut, 0 length means no fields
block|}
name|uselessIndirection
operator|.
name|setData
argument_list|(
name|ref
operator|.
name|getBytes
argument_list|()
argument_list|)
expr_stmt|;
name|valueStruct
operator|.
name|init
argument_list|(
name|uselessIndirection
argument_list|,
operator|(
name|int
operator|)
name|ref
operator|.
name|getOffset
argument_list|()
argument_list|,
name|ref
operator|.
name|getLength
argument_list|()
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|Object
argument_list|>
name|result
decl_stmt|;
if|if
condition|(
operator|!
name|needsComplexObjectFixup
condition|)
block|{
comment|// Good performance for common case where small table has no complex objects.
name|result
operator|=
name|valueStruct
operator|.
name|getFieldsAsList
argument_list|()
expr_stmt|;
block|}
else|else
block|{
comment|// Convert the complex LazyBinary objects to standard (Java) objects so downstream
comment|// operators like FileSinkOperator can serialize complex objects in the form they expect
comment|// (i.e. Java objects).
name|result
operator|=
name|getComplexFieldsAsList
argument_list|(
name|valueStruct
argument_list|,
name|complexObjectArrayBuffer
argument_list|,
name|internalValueOi
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|addRow
parameter_list|(
name|List
argument_list|<
name|Object
argument_list|>
name|t
parameter_list|)
block|{
if|if
condition|(
name|dummyRow
operator|!=
literal|null
operator|||
name|hashMapResult
operator|.
name|hasRows
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Cannot add rows when not empty"
argument_list|)
throw|;
block|}
name|dummyRow
operator|=
name|t
expr_stmt|;
block|}
comment|// Various unsupported methods.
annotation|@
name|Override
specifier|public
name|void
name|addRow
parameter_list|(
name|Object
index|[]
name|value
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
name|this
operator|.
name|getClass
argument_list|()
operator|.
name|getCanonicalName
argument_list|()
operator|+
literal|" cannot add arrays"
argument_list|)
throw|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|write
parameter_list|(
name|MapJoinObjectSerDeContext
name|valueContext
parameter_list|,
name|ObjectOutputStream
name|out
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
name|this
operator|.
name|getClass
argument_list|()
operator|.
name|getCanonicalName
argument_list|()
operator|+
literal|" cannot be serialized"
argument_list|)
throw|;
block|}
comment|// Direct access.
specifier|public
name|JoinUtil
operator|.
name|JoinResult
name|setDirect
parameter_list|(
name|byte
index|[]
name|bytes
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|length
parameter_list|,
name|BytesBytesMultiHashMap
operator|.
name|Result
name|hashMapResult
parameter_list|)
block|{
name|aliasFilter
operator|=
name|hashMap
operator|.
name|getValueResult
argument_list|(
name|bytes
argument_list|,
name|offset
argument_list|,
name|length
argument_list|,
name|hashMapResult
argument_list|)
expr_stmt|;
name|dummyRow
operator|=
literal|null
expr_stmt|;
if|if
condition|(
name|hashMapResult
operator|.
name|hasRows
argument_list|()
condition|)
block|{
return|return
name|JoinUtil
operator|.
name|JoinResult
operator|.
name|MATCH
return|;
block|}
else|else
block|{
name|aliasFilter
operator|=
operator|(
name|byte
operator|)
literal|0xff
expr_stmt|;
return|return
name|JoinUtil
operator|.
name|JoinResult
operator|.
name|NOMATCH
return|;
block|}
block|}
block|}
specifier|public
specifier|static
name|boolean
name|isSupportedKey
parameter_list|(
name|ObjectInspector
name|keyOi
parameter_list|)
block|{
name|List
argument_list|<
name|?
extends|extends
name|StructField
argument_list|>
name|keyFields
init|=
operator|(
operator|(
name|StructObjectInspector
operator|)
name|keyOi
operator|)
operator|.
name|getAllStructFieldRefs
argument_list|()
decl_stmt|;
for|for
control|(
name|StructField
name|field
range|:
name|keyFields
control|)
block|{
if|if
condition|(
operator|!
name|MapJoinKey
operator|.
name|isSupportedField
argument_list|(
name|field
operator|.
name|getFieldObjectInspector
argument_list|()
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
return|return
literal|true
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|dumpMetrics
parameter_list|()
block|{
name|hashMap
operator|.
name|debugDumpMetrics
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|hasSpill
parameter_list|()
block|{
return|return
literal|false
return|;
block|}
annotation|@
name|Override
specifier|public
name|int
name|size
parameter_list|()
block|{
return|return
name|hashMap
operator|.
name|size
argument_list|()
return|;
block|}
block|}
end_class

end_unit

