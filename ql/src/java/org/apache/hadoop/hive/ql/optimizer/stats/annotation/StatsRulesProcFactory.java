begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|optimizer
operator|.
name|stats
operator|.
name|annotation
package|;
end_package

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Lists
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Maps
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|Log
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|LogFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|conf
operator|.
name|HiveConf
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|ErrorMsg
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|ColumnInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|CommonJoinOperator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|FilterOperator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|GroupByOperator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|LimitOperator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|Operator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|ReduceSinkOperator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|RowSchema
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|SelectOperator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|TableScanOperator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|lib
operator|.
name|Node
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|lib
operator|.
name|NodeProcessor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|lib
operator|.
name|NodeProcessorCtx
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|metadata
operator|.
name|HiveException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|metadata
operator|.
name|Table
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|parse
operator|.
name|PrunedPartitionList
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|parse
operator|.
name|SemanticException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|AggregationDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|ColStatistics
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|ExprNodeColumnDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|ExprNodeConstantDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|ExprNodeDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|ExprNodeGenericFuncDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|JoinDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|OperatorDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|Statistics
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|stats
operator|.
name|StatsUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|udf
operator|.
name|generic
operator|.
name|GenericUDF
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|udf
operator|.
name|generic
operator|.
name|GenericUDFOPAnd
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|udf
operator|.
name|generic
operator|.
name|GenericUDFOPEqual
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|udf
operator|.
name|generic
operator|.
name|GenericUDFOPEqualNS
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|udf
operator|.
name|generic
operator|.
name|GenericUDFOPEqualOrGreaterThan
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|udf
operator|.
name|generic
operator|.
name|GenericUDFOPEqualOrLessThan
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|udf
operator|.
name|generic
operator|.
name|GenericUDFOPGreaterThan
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|udf
operator|.
name|generic
operator|.
name|GenericUDFOPLessThan
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|udf
operator|.
name|generic
operator|.
name|GenericUDFOPNot
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|udf
operator|.
name|generic
operator|.
name|GenericUDFOPNotEqual
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|udf
operator|.
name|generic
operator|.
name|GenericUDFOPNotNull
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|udf
operator|.
name|generic
operator|.
name|GenericUDFOPNull
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|udf
operator|.
name|generic
operator|.
name|GenericUDFOPOr
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde
operator|.
name|serdeConstants
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Stack
import|;
end_import

begin_class
specifier|public
class|class
name|StatsRulesProcFactory
block|{
specifier|private
specifier|static
specifier|final
name|Log
name|LOG
init|=
name|LogFactory
operator|.
name|getLog
argument_list|(
name|StatsRulesProcFactory
operator|.
name|class
operator|.
name|getName
argument_list|()
argument_list|)
decl_stmt|;
comment|/**    * Collect basic statistics like number of rows, data size and column level statistics from the    * table. Also sets the state of the available statistics. Basic and column statistics can have    * one of the following states COMPLETE, PARTIAL, NONE. In case of partitioned table, the basic    * and column stats are aggregated together to table level statistics. Column statistics will not    * be collected if hive.stats.fetch.column.stats is set to false. If basic statistics is not    * available then number of rows will be estimated from file size and average row size (computed    * from schema).    */
specifier|public
specifier|static
class|class
name|TableScanStatsRule
extends|extends
name|DefaultStatsRule
implements|implements
name|NodeProcessor
block|{
annotation|@
name|Override
specifier|public
name|Object
name|process
parameter_list|(
name|Node
name|nd
parameter_list|,
name|Stack
argument_list|<
name|Node
argument_list|>
name|stack
parameter_list|,
name|NodeProcessorCtx
name|procCtx
parameter_list|,
name|Object
modifier|...
name|nodeOutputs
parameter_list|)
throws|throws
name|SemanticException
block|{
name|TableScanOperator
name|tsop
init|=
operator|(
name|TableScanOperator
operator|)
name|nd
decl_stmt|;
name|AnnotateStatsProcCtx
name|aspCtx
init|=
operator|(
name|AnnotateStatsProcCtx
operator|)
name|procCtx
decl_stmt|;
name|PrunedPartitionList
name|partList
init|=
name|aspCtx
operator|.
name|getParseContext
argument_list|()
operator|.
name|getPrunedPartitions
argument_list|(
name|tsop
operator|.
name|getName
argument_list|()
argument_list|,
name|tsop
argument_list|)
decl_stmt|;
name|Table
name|table
init|=
name|aspCtx
operator|.
name|getParseContext
argument_list|()
operator|.
name|getTopToTable
argument_list|()
operator|.
name|get
argument_list|(
name|tsop
argument_list|)
decl_stmt|;
try|try
block|{
comment|// gather statistics for the first time and the attach it to table scan operator
name|Statistics
name|stats
init|=
name|StatsUtils
operator|.
name|collectStatistics
argument_list|(
name|aspCtx
operator|.
name|getConf
argument_list|()
argument_list|,
name|partList
argument_list|,
name|table
argument_list|,
name|tsop
argument_list|)
decl_stmt|;
name|tsop
operator|.
name|setStatistics
argument_list|(
name|stats
operator|.
name|clone
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"[0] STATS-"
operator|+
name|tsop
operator|.
name|toString
argument_list|()
operator|+
literal|": "
operator|+
name|stats
operator|.
name|extendedToString
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|CloneNotSupportedException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|STATISTICS_CLONING_FAILED
operator|.
name|getMsg
argument_list|()
argument_list|)
throw|;
block|}
catch|catch
parameter_list|(
name|HiveException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
name|e
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|SemanticException
argument_list|(
name|e
argument_list|)
throw|;
block|}
return|return
literal|null
return|;
block|}
block|}
comment|/**    * SELECT operator doesn't change the number of rows emitted from the parent operator. It changes    * the size of each tuple emitted. In a typical case, where only subset of columns are selected    * the average row size will reduce as some of the columns will be pruned. In order to accurately    * compute the average row size, column level statistics is required. Column level statistics    * stores average size of values in column which can be used to more reliably estimate the    * reduction in size of each tuple. In the absence of column level statistics, size of columns    * will be based on data type. For primitive data types size from    * {@link org.apache.hadoop.hive.ql.util.JavaDataModel} will be used and for variable length data    * types worst case will be assumed.    *<p>    *<i>For more information, refer 'Estimating The Cost Of Operations' chapter in    * "Database Systems: The Complete Book" by Garcia-Molina et. al.</i>    *</p>    */
specifier|public
specifier|static
class|class
name|SelectStatsRule
extends|extends
name|DefaultStatsRule
implements|implements
name|NodeProcessor
block|{
annotation|@
name|Override
specifier|public
name|Object
name|process
parameter_list|(
name|Node
name|nd
parameter_list|,
name|Stack
argument_list|<
name|Node
argument_list|>
name|stack
parameter_list|,
name|NodeProcessorCtx
name|procCtx
parameter_list|,
name|Object
modifier|...
name|nodeOutputs
parameter_list|)
throws|throws
name|SemanticException
block|{
name|SelectOperator
name|sop
init|=
operator|(
name|SelectOperator
operator|)
name|nd
decl_stmt|;
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
name|parent
init|=
name|sop
operator|.
name|getParentOperators
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|Statistics
name|parentStats
init|=
name|parent
operator|.
name|getStatistics
argument_list|()
decl_stmt|;
name|AnnotateStatsProcCtx
name|aspCtx
init|=
operator|(
name|AnnotateStatsProcCtx
operator|)
name|procCtx
decl_stmt|;
name|HiveConf
name|conf
init|=
name|aspCtx
operator|.
name|getConf
argument_list|()
decl_stmt|;
comment|// SELECT (*) does not change the statistics. Just pass on the parent statistics
if|if
condition|(
name|sop
operator|.
name|getConf
argument_list|()
operator|.
name|isSelectStar
argument_list|()
condition|)
block|{
try|try
block|{
if|if
condition|(
name|parentStats
operator|!=
literal|null
condition|)
block|{
name|sop
operator|.
name|setStatistics
argument_list|(
name|parentStats
operator|.
name|clone
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|CloneNotSupportedException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|STATISTICS_CLONING_FAILED
operator|.
name|getMsg
argument_list|()
argument_list|)
throw|;
block|}
return|return
literal|null
return|;
block|}
try|try
block|{
if|if
condition|(
name|satisfyPrecondition
argument_list|(
name|parentStats
argument_list|)
condition|)
block|{
name|Statistics
name|stats
init|=
name|parentStats
operator|.
name|clone
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|ColStatistics
argument_list|>
name|colStats
init|=
name|StatsUtils
operator|.
name|getColStatisticsFromExprMap
argument_list|(
name|conf
argument_list|,
name|parentStats
argument_list|,
name|sop
operator|.
name|getColumnExprMap
argument_list|()
argument_list|,
name|sop
operator|.
name|getSchema
argument_list|()
argument_list|)
decl_stmt|;
name|long
name|dataSize
init|=
name|StatsUtils
operator|.
name|getDataSizeFromColumnStats
argument_list|(
name|stats
operator|.
name|getNumRows
argument_list|()
argument_list|,
name|colStats
argument_list|)
decl_stmt|;
name|stats
operator|.
name|setColumnStats
argument_list|(
name|colStats
argument_list|)
expr_stmt|;
name|stats
operator|.
name|setDataSize
argument_list|(
name|dataSize
argument_list|)
expr_stmt|;
name|sop
operator|.
name|setStatistics
argument_list|(
name|stats
argument_list|)
expr_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"[0] STATS-"
operator|+
name|sop
operator|.
name|toString
argument_list|()
operator|+
literal|": "
operator|+
name|stats
operator|.
name|extendedToString
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|parentStats
operator|!=
literal|null
condition|)
block|{
name|sop
operator|.
name|setStatistics
argument_list|(
name|parentStats
operator|.
name|clone
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"[1] STATS-"
operator|+
name|sop
operator|.
name|toString
argument_list|()
operator|+
literal|": "
operator|+
name|parentStats
operator|.
name|extendedToString
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
catch|catch
parameter_list|(
name|CloneNotSupportedException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|STATISTICS_CLONING_FAILED
operator|.
name|getMsg
argument_list|()
argument_list|)
throw|;
block|}
return|return
literal|null
return|;
block|}
block|}
comment|/**    * FILTER operator does not change the average row size but it does change the number of rows    * emitted. The reduction in the number of rows emitted is dependent on the filter expression.    *<ul>    *<i>Notations:</i>    *<li>T(S) - Number of tuples in relations S</li>    *<li>V(S,A) - Number of distinct values of attribute A in relation S</li>    *</ul>    *<ul>    *<i>Rules:</i><b>    *<li>Column equals a constant</li></b> T(S) = T(R) / V(R,A)    *<p>    *<b>    *<li>Inequality conditions</li></b> T(S) = T(R) / 3    *<p>    *<b>    *<li>Not equals comparison</li></b> - Simple formula T(S) = T(R)    *<p>    * - Alternate formula T(S) = T(R) (V(R,A) - 1) / V(R,A)    *<p>    *<b>    *<li>NOT condition</li></b> T(S) = 1 - T(S'), where T(S') is the satisfying condition    *<p>    *<b>    *<li>Multiple AND conditions</li></b> Cascadingly apply the rules 1 to 3 (order doesn't matter)    *<p>    *<b>    *<li>Multiple OR conditions</li></b> - Simple formula is to evaluate conditions independently    * and sum the results T(S) = m1 + m2    *<p>    * - Alternate formula T(S) = T(R) * ( 1 - ( 1 - m1/T(R) ) * ( 1 - m2/T(R) ))    *<p>    * where, m1 is the number of tuples that satisfy condition1 and m2 is the number of tuples that    * satisfy condition2    *</ul>    *<p>    *<i>Worst case:</i> If no column statistics are available, then evaluation of predicate    * expression will assume worst case (i.e; half the input rows) for each of predicate expression.    *<p>    *<i>For more information, refer 'Estimating The Cost Of Operations' chapter in    * "Database Systems: The Complete Book" by Garcia-Molina et. al.</i>    *</p>    */
specifier|public
specifier|static
class|class
name|FilterStatsRule
extends|extends
name|DefaultStatsRule
implements|implements
name|NodeProcessor
block|{
annotation|@
name|Override
specifier|public
name|Object
name|process
parameter_list|(
name|Node
name|nd
parameter_list|,
name|Stack
argument_list|<
name|Node
argument_list|>
name|stack
parameter_list|,
name|NodeProcessorCtx
name|procCtx
parameter_list|,
name|Object
modifier|...
name|nodeOutputs
parameter_list|)
throws|throws
name|SemanticException
block|{
name|AnnotateStatsProcCtx
name|aspCtx
init|=
operator|(
name|AnnotateStatsProcCtx
operator|)
name|procCtx
decl_stmt|;
name|FilterOperator
name|fop
init|=
operator|(
name|FilterOperator
operator|)
name|nd
decl_stmt|;
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
name|parent
init|=
name|fop
operator|.
name|getParentOperators
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|Statistics
name|parentStats
init|=
name|parent
operator|.
name|getStatistics
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|neededCols
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|parent
operator|instanceof
name|TableScanOperator
condition|)
block|{
name|TableScanOperator
name|tsop
init|=
operator|(
name|TableScanOperator
operator|)
name|parent
decl_stmt|;
name|neededCols
operator|=
name|tsop
operator|.
name|getNeededColumns
argument_list|()
expr_stmt|;
block|}
try|try
block|{
if|if
condition|(
name|parentStats
operator|!=
literal|null
condition|)
block|{
name|ExprNodeDesc
name|pred
init|=
name|fop
operator|.
name|getConf
argument_list|()
operator|.
name|getPredicate
argument_list|()
decl_stmt|;
comment|// evaluate filter expression and update statistics
name|long
name|newNumRows
init|=
name|evaluateExpression
argument_list|(
name|parentStats
argument_list|,
name|pred
argument_list|,
name|aspCtx
argument_list|,
name|neededCols
argument_list|)
decl_stmt|;
name|Statistics
name|st
init|=
name|parentStats
operator|.
name|clone
argument_list|()
decl_stmt|;
if|if
condition|(
name|satisfyPrecondition
argument_list|(
name|parentStats
argument_list|)
condition|)
block|{
comment|// update statistics based on column statistics.
comment|// OR conditions keeps adding the stats independently, this may
comment|// result in number of rows getting more than the input rows in
comment|// which case stats need not be updated
if|if
condition|(
name|newNumRows
operator|<=
name|parentStats
operator|.
name|getNumRows
argument_list|()
condition|)
block|{
name|updateStats
argument_list|(
name|st
argument_list|,
name|newNumRows
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"[0] STATS-"
operator|+
name|fop
operator|.
name|toString
argument_list|()
operator|+
literal|": "
operator|+
name|st
operator|.
name|extendedToString
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// update only the basic statistics in the absence of column statistics
if|if
condition|(
name|newNumRows
operator|<=
name|parentStats
operator|.
name|getNumRows
argument_list|()
condition|)
block|{
name|updateStats
argument_list|(
name|st
argument_list|,
name|newNumRows
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"[1] STATS-"
operator|+
name|fop
operator|.
name|toString
argument_list|()
operator|+
literal|": "
operator|+
name|st
operator|.
name|extendedToString
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
name|fop
operator|.
name|setStatistics
argument_list|(
name|st
argument_list|)
expr_stmt|;
name|aspCtx
operator|.
name|setAndExprStats
argument_list|(
literal|null
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|CloneNotSupportedException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|STATISTICS_CLONING_FAILED
operator|.
name|getMsg
argument_list|()
argument_list|)
throw|;
block|}
return|return
literal|null
return|;
block|}
specifier|private
name|long
name|evaluateExpression
parameter_list|(
name|Statistics
name|stats
parameter_list|,
name|ExprNodeDesc
name|pred
parameter_list|,
name|AnnotateStatsProcCtx
name|aspCtx
parameter_list|,
name|List
argument_list|<
name|String
argument_list|>
name|neededCols
parameter_list|)
throws|throws
name|CloneNotSupportedException
block|{
name|long
name|newNumRows
init|=
literal|0
decl_stmt|;
name|Statistics
name|andStats
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|pred
operator|instanceof
name|ExprNodeGenericFuncDesc
condition|)
block|{
name|ExprNodeGenericFuncDesc
name|genFunc
init|=
operator|(
name|ExprNodeGenericFuncDesc
operator|)
name|pred
decl_stmt|;
name|GenericUDF
name|udf
init|=
name|genFunc
operator|.
name|getGenericUDF
argument_list|()
decl_stmt|;
comment|// for AND condition cascadingly update stats
if|if
condition|(
name|udf
operator|instanceof
name|GenericUDFOPAnd
condition|)
block|{
name|andStats
operator|=
name|stats
operator|.
name|clone
argument_list|()
expr_stmt|;
name|aspCtx
operator|.
name|setAndExprStats
argument_list|(
name|andStats
argument_list|)
expr_stmt|;
comment|// evaluate children
for|for
control|(
name|ExprNodeDesc
name|child
range|:
name|genFunc
operator|.
name|getChildren
argument_list|()
control|)
block|{
name|newNumRows
operator|=
name|evaluateChildExpr
argument_list|(
name|aspCtx
operator|.
name|getAndExprStats
argument_list|()
argument_list|,
name|child
argument_list|,
name|aspCtx
argument_list|,
name|neededCols
argument_list|)
expr_stmt|;
if|if
condition|(
name|satisfyPrecondition
argument_list|(
name|aspCtx
operator|.
name|getAndExprStats
argument_list|()
argument_list|)
condition|)
block|{
name|updateStats
argument_list|(
name|aspCtx
operator|.
name|getAndExprStats
argument_list|()
argument_list|,
name|newNumRows
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|updateStats
argument_list|(
name|aspCtx
operator|.
name|getAndExprStats
argument_list|()
argument_list|,
name|newNumRows
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|udf
operator|instanceof
name|GenericUDFOPOr
condition|)
block|{
comment|// for OR condition independently compute and update stats
for|for
control|(
name|ExprNodeDesc
name|child
range|:
name|genFunc
operator|.
name|getChildren
argument_list|()
control|)
block|{
name|newNumRows
operator|+=
name|evaluateChildExpr
argument_list|(
name|stats
argument_list|,
name|child
argument_list|,
name|aspCtx
argument_list|,
name|neededCols
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|udf
operator|instanceof
name|GenericUDFOPNot
condition|)
block|{
name|newNumRows
operator|=
name|evaluateNotExpr
argument_list|(
name|stats
argument_list|,
name|pred
argument_list|,
name|aspCtx
argument_list|,
name|neededCols
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// single predicate condition
name|newNumRows
operator|=
name|evaluateChildExpr
argument_list|(
name|stats
argument_list|,
name|pred
argument_list|,
name|aspCtx
argument_list|,
name|neededCols
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|pred
operator|instanceof
name|ExprNodeColumnDesc
condition|)
block|{
comment|// can be boolean column in which case return true count
name|ExprNodeColumnDesc
name|encd
init|=
operator|(
name|ExprNodeColumnDesc
operator|)
name|pred
decl_stmt|;
name|String
name|colName
init|=
name|encd
operator|.
name|getColumn
argument_list|()
decl_stmt|;
name|String
name|tabAlias
init|=
name|encd
operator|.
name|getTabAlias
argument_list|()
decl_stmt|;
name|String
name|colType
init|=
name|encd
operator|.
name|getTypeString
argument_list|()
decl_stmt|;
if|if
condition|(
name|colType
operator|.
name|equalsIgnoreCase
argument_list|(
name|serdeConstants
operator|.
name|BOOLEAN_TYPE_NAME
argument_list|)
condition|)
block|{
name|ColStatistics
name|cs
init|=
name|stats
operator|.
name|getColumnStatisticsForColumn
argument_list|(
name|tabAlias
argument_list|,
name|colName
argument_list|)
decl_stmt|;
if|if
condition|(
name|cs
operator|!=
literal|null
condition|)
block|{
return|return
name|cs
operator|.
name|getNumTrues
argument_list|()
return|;
block|}
block|}
comment|// if not boolean column return half the number of rows
return|return
name|stats
operator|.
name|getNumRows
argument_list|()
operator|/
literal|2
return|;
block|}
elseif|else
if|if
condition|(
name|pred
operator|instanceof
name|ExprNodeConstantDesc
condition|)
block|{
comment|// special case for handling false constants
name|ExprNodeConstantDesc
name|encd
init|=
operator|(
name|ExprNodeConstantDesc
operator|)
name|pred
decl_stmt|;
if|if
condition|(
name|encd
operator|.
name|getValue
argument_list|()
operator|.
name|equals
argument_list|(
literal|false
argument_list|)
condition|)
block|{
return|return
literal|0
return|;
block|}
else|else
block|{
return|return
name|stats
operator|.
name|getNumRows
argument_list|()
return|;
block|}
block|}
return|return
name|newNumRows
return|;
block|}
specifier|private
name|long
name|evaluateNotExpr
parameter_list|(
name|Statistics
name|stats
parameter_list|,
name|ExprNodeDesc
name|pred
parameter_list|,
name|AnnotateStatsProcCtx
name|aspCtx
parameter_list|,
name|List
argument_list|<
name|String
argument_list|>
name|neededCols
parameter_list|)
throws|throws
name|CloneNotSupportedException
block|{
name|long
name|numRows
init|=
name|stats
operator|.
name|getNumRows
argument_list|()
decl_stmt|;
comment|// if the evaluate yields true then pass all rows else pass 0 rows
if|if
condition|(
name|pred
operator|instanceof
name|ExprNodeGenericFuncDesc
condition|)
block|{
name|ExprNodeGenericFuncDesc
name|genFunc
init|=
operator|(
name|ExprNodeGenericFuncDesc
operator|)
name|pred
decl_stmt|;
for|for
control|(
name|ExprNodeDesc
name|leaf
range|:
name|genFunc
operator|.
name|getChildren
argument_list|()
control|)
block|{
if|if
condition|(
name|leaf
operator|instanceof
name|ExprNodeGenericFuncDesc
condition|)
block|{
comment|// GenericUDF
name|long
name|newNumRows
init|=
literal|0
decl_stmt|;
for|for
control|(
name|ExprNodeDesc
name|child
range|:
operator|(
operator|(
name|ExprNodeGenericFuncDesc
operator|)
name|pred
operator|)
operator|.
name|getChildren
argument_list|()
control|)
block|{
name|newNumRows
operator|=
name|evaluateChildExpr
argument_list|(
name|stats
argument_list|,
name|child
argument_list|,
name|aspCtx
argument_list|,
name|neededCols
argument_list|)
expr_stmt|;
block|}
return|return
name|numRows
operator|-
name|newNumRows
return|;
block|}
elseif|else
if|if
condition|(
name|leaf
operator|instanceof
name|ExprNodeConstantDesc
condition|)
block|{
name|ExprNodeConstantDesc
name|encd
init|=
operator|(
name|ExprNodeConstantDesc
operator|)
name|leaf
decl_stmt|;
if|if
condition|(
name|encd
operator|.
name|getValue
argument_list|()
operator|.
name|equals
argument_list|(
literal|true
argument_list|)
condition|)
block|{
return|return
literal|0
return|;
block|}
else|else
block|{
return|return
name|numRows
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|leaf
operator|instanceof
name|ExprNodeColumnDesc
condition|)
block|{
comment|// NOT on boolean columns is possible. in which case return false count.
name|ExprNodeColumnDesc
name|encd
init|=
operator|(
name|ExprNodeColumnDesc
operator|)
name|leaf
decl_stmt|;
name|String
name|colName
init|=
name|encd
operator|.
name|getColumn
argument_list|()
decl_stmt|;
name|String
name|tabAlias
init|=
name|encd
operator|.
name|getTabAlias
argument_list|()
decl_stmt|;
name|String
name|colType
init|=
name|encd
operator|.
name|getTypeString
argument_list|()
decl_stmt|;
if|if
condition|(
name|colType
operator|.
name|equalsIgnoreCase
argument_list|(
name|serdeConstants
operator|.
name|BOOLEAN_TYPE_NAME
argument_list|)
condition|)
block|{
name|ColStatistics
name|cs
init|=
name|stats
operator|.
name|getColumnStatisticsForColumn
argument_list|(
name|tabAlias
argument_list|,
name|colName
argument_list|)
decl_stmt|;
if|if
condition|(
name|cs
operator|!=
literal|null
condition|)
block|{
return|return
name|cs
operator|.
name|getNumFalses
argument_list|()
return|;
block|}
block|}
comment|// if not boolean column return half the number of rows
return|return
name|numRows
operator|/
literal|2
return|;
block|}
block|}
block|}
comment|// worst case
return|return
name|numRows
operator|/
literal|2
return|;
block|}
specifier|private
name|long
name|evaluateColEqualsNullExpr
parameter_list|(
name|Statistics
name|stats
parameter_list|,
name|ExprNodeDesc
name|pred
parameter_list|,
name|AnnotateStatsProcCtx
name|aspCtx
parameter_list|)
block|{
name|long
name|numRows
init|=
name|stats
operator|.
name|getNumRows
argument_list|()
decl_stmt|;
if|if
condition|(
name|pred
operator|instanceof
name|ExprNodeGenericFuncDesc
condition|)
block|{
name|ExprNodeGenericFuncDesc
name|genFunc
init|=
operator|(
name|ExprNodeGenericFuncDesc
operator|)
name|pred
decl_stmt|;
for|for
control|(
name|ExprNodeDesc
name|leaf
range|:
name|genFunc
operator|.
name|getChildren
argument_list|()
control|)
block|{
if|if
condition|(
name|leaf
operator|instanceof
name|ExprNodeColumnDesc
condition|)
block|{
name|ExprNodeColumnDesc
name|colDesc
init|=
operator|(
name|ExprNodeColumnDesc
operator|)
name|leaf
decl_stmt|;
name|String
name|colName
init|=
name|colDesc
operator|.
name|getColumn
argument_list|()
decl_stmt|;
name|String
name|tabAlias
init|=
name|colDesc
operator|.
name|getTabAlias
argument_list|()
decl_stmt|;
name|ColStatistics
name|cs
init|=
name|stats
operator|.
name|getColumnStatisticsForColumn
argument_list|(
name|tabAlias
argument_list|,
name|colName
argument_list|)
decl_stmt|;
if|if
condition|(
name|cs
operator|!=
literal|null
condition|)
block|{
return|return
name|cs
operator|.
name|getNumNulls
argument_list|()
return|;
block|}
block|}
block|}
block|}
comment|// worst case
return|return
name|numRows
operator|/
literal|2
return|;
block|}
specifier|private
name|long
name|evaluateChildExpr
parameter_list|(
name|Statistics
name|stats
parameter_list|,
name|ExprNodeDesc
name|child
parameter_list|,
name|AnnotateStatsProcCtx
name|aspCtx
parameter_list|,
name|List
argument_list|<
name|String
argument_list|>
name|neededCols
parameter_list|)
throws|throws
name|CloneNotSupportedException
block|{
name|long
name|numRows
init|=
name|stats
operator|.
name|getNumRows
argument_list|()
decl_stmt|;
if|if
condition|(
name|child
operator|instanceof
name|ExprNodeGenericFuncDesc
condition|)
block|{
name|ExprNodeGenericFuncDesc
name|genFunc
init|=
operator|(
name|ExprNodeGenericFuncDesc
operator|)
name|child
decl_stmt|;
name|GenericUDF
name|udf
init|=
name|genFunc
operator|.
name|getGenericUDF
argument_list|()
decl_stmt|;
if|if
condition|(
name|udf
operator|instanceof
name|GenericUDFOPEqual
operator|||
name|udf
operator|instanceof
name|GenericUDFOPEqualNS
condition|)
block|{
name|String
name|colName
init|=
literal|null
decl_stmt|;
name|String
name|tabAlias
init|=
literal|null
decl_stmt|;
name|boolean
name|isConst
init|=
literal|false
decl_stmt|;
name|Object
name|prevConst
init|=
literal|null
decl_stmt|;
for|for
control|(
name|ExprNodeDesc
name|leaf
range|:
name|genFunc
operator|.
name|getChildren
argument_list|()
control|)
block|{
if|if
condition|(
name|leaf
operator|instanceof
name|ExprNodeConstantDesc
condition|)
block|{
comment|// constant = constant expressions. We shouldn't be getting this
comment|// after constant folding
if|if
condition|(
name|isConst
condition|)
block|{
comment|// special case: if both constants are not equal then return 0
if|if
condition|(
name|prevConst
operator|!=
literal|null
operator|&&
operator|!
name|prevConst
operator|.
name|equals
argument_list|(
operator|(
operator|(
name|ExprNodeConstantDesc
operator|)
name|leaf
operator|)
operator|.
name|getValue
argument_list|()
argument_list|)
condition|)
block|{
return|return
literal|0
return|;
block|}
return|return
name|numRows
return|;
block|}
comment|// if the first argument is const then just set the flag and continue
if|if
condition|(
name|colName
operator|==
literal|null
condition|)
block|{
name|isConst
operator|=
literal|true
expr_stmt|;
name|prevConst
operator|=
operator|(
operator|(
name|ExprNodeConstantDesc
operator|)
name|leaf
operator|)
operator|.
name|getValue
argument_list|()
expr_stmt|;
continue|continue;
block|}
comment|// if column name is not contained in needed column list then it
comment|// is a partition column. We do not need to evaluate partition columns
comment|// in filter expression since it will be taken care by partitio pruner
if|if
condition|(
name|neededCols
operator|!=
literal|null
operator|&&
operator|!
name|neededCols
operator|.
name|contains
argument_list|(
name|colName
argument_list|)
condition|)
block|{
return|return
name|numRows
return|;
block|}
name|ColStatistics
name|cs
init|=
name|stats
operator|.
name|getColumnStatisticsForColumn
argument_list|(
name|tabAlias
argument_list|,
name|colName
argument_list|)
decl_stmt|;
if|if
condition|(
name|cs
operator|!=
literal|null
condition|)
block|{
name|long
name|dvs
init|=
name|cs
operator|.
name|getCountDistint
argument_list|()
decl_stmt|;
name|numRows
operator|=
name|dvs
operator|==
literal|0
condition|?
name|numRows
operator|/
literal|2
else|:
name|numRows
operator|/
name|dvs
expr_stmt|;
return|return
name|numRows
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|leaf
operator|instanceof
name|ExprNodeColumnDesc
condition|)
block|{
name|ExprNodeColumnDesc
name|colDesc
init|=
operator|(
name|ExprNodeColumnDesc
operator|)
name|leaf
decl_stmt|;
name|colName
operator|=
name|colDesc
operator|.
name|getColumn
argument_list|()
expr_stmt|;
name|tabAlias
operator|=
name|colDesc
operator|.
name|getTabAlias
argument_list|()
expr_stmt|;
comment|// if const is first argument then evaluate the result
if|if
condition|(
name|isConst
condition|)
block|{
comment|// if column name is not contained in needed column list then it
comment|// is a partition column. We do not need to evaluate partition columns
comment|// in filter expression since it will be taken care by partitio pruner
if|if
condition|(
name|neededCols
operator|!=
literal|null
operator|&&
name|neededCols
operator|.
name|indexOf
argument_list|(
name|colName
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
return|return
name|numRows
return|;
block|}
name|ColStatistics
name|cs
init|=
name|stats
operator|.
name|getColumnStatisticsForColumn
argument_list|(
name|tabAlias
argument_list|,
name|colName
argument_list|)
decl_stmt|;
if|if
condition|(
name|cs
operator|!=
literal|null
condition|)
block|{
name|long
name|dvs
init|=
name|cs
operator|.
name|getCountDistint
argument_list|()
decl_stmt|;
name|numRows
operator|=
name|dvs
operator|==
literal|0
condition|?
name|numRows
operator|/
literal|2
else|:
name|numRows
operator|/
name|dvs
expr_stmt|;
return|return
name|numRows
return|;
block|}
block|}
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|udf
operator|instanceof
name|GenericUDFOPNotEqual
condition|)
block|{
return|return
name|numRows
return|;
block|}
elseif|else
if|if
condition|(
name|udf
operator|instanceof
name|GenericUDFOPEqualOrGreaterThan
operator|||
name|udf
operator|instanceof
name|GenericUDFOPEqualOrLessThan
operator|||
name|udf
operator|instanceof
name|GenericUDFOPGreaterThan
operator|||
name|udf
operator|instanceof
name|GenericUDFOPLessThan
condition|)
block|{
return|return
name|numRows
operator|/
literal|3
return|;
block|}
elseif|else
if|if
condition|(
name|udf
operator|instanceof
name|GenericUDFOPNotNull
condition|)
block|{
name|long
name|newNumRows
init|=
name|evaluateColEqualsNullExpr
argument_list|(
name|stats
argument_list|,
name|genFunc
argument_list|,
name|aspCtx
argument_list|)
decl_stmt|;
return|return
name|stats
operator|.
name|getNumRows
argument_list|()
operator|-
name|newNumRows
return|;
block|}
elseif|else
if|if
condition|(
name|udf
operator|instanceof
name|GenericUDFOPNull
condition|)
block|{
return|return
name|evaluateColEqualsNullExpr
argument_list|(
name|stats
argument_list|,
name|genFunc
argument_list|,
name|aspCtx
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|udf
operator|instanceof
name|GenericUDFOPAnd
operator|||
name|udf
operator|instanceof
name|GenericUDFOPOr
operator|||
name|udf
operator|instanceof
name|GenericUDFOPNot
condition|)
block|{
return|return
name|evaluateExpression
argument_list|(
name|stats
argument_list|,
name|genFunc
argument_list|,
name|aspCtx
argument_list|,
name|neededCols
argument_list|)
return|;
block|}
block|}
comment|// worst case
return|return
name|numRows
operator|/
literal|2
return|;
block|}
block|}
comment|/**    * GROUPBY operator changes the number of rows. The number of rows emitted by GBY operator will be    * atleast 1 or utmost T(R) (number of rows in relation T) based on the aggregation. A better    * estimate can be found if we have column statistics on the columns that we are grouping on.    *<p>    * Suppose if we are grouping by attributes A,B,C and if statistics for columns A,B,C are    * available then a better estimate can be found by taking the smaller of product of V(R,[A,B,C])    * (product of distinct cardinalities of A,B,C) and T(R)/2.    *<p>    * T(R) = min (T(R)/2 , V(R,[A,B,C]) ---> [1]    *<p>    * In the presence of grouping sets, map-side GBY will emit more rows depending on the size of    * grouping set (input rows * size of grouping set). These rows will get reduced because of    * map-side hash aggregation. Hash aggregation is an optimization in hive to reduce the number of    * rows shuffled between map and reduce stage. This optimization will be disabled if the memory    * used for hash aggregation exceeds 90% of max available memory for hash aggregation. The number    * of rows emitted from map-side will vary if hash aggregation is enabled throughout execution or    * disabled. In the presence of grouping sets, following rules will be applied    *<p>    * If<b>hash-aggregation is enabled</b>, for query SELECT * FROM table GROUP BY (A,B) WITH CUBE    *<p>    * T(R) = min(T(R)/2, T(R, GBY(A,B)) + T(R, GBY(A)) + T(R, GBY(B)) + 1))    *<p>    * where, GBY(A,B), GBY(B), GBY(B) are the GBY rules mentioned above [1]    *<p>    * If<b>hash-aggregation is disabled</b>, apply the GBY rule [1] and then multiply the result by    * number of elements in grouping set T(R) = T(R) * length_of_grouping_set. Since we do not know    * if hash-aggregation is enabled or disabled during compile time, we will assume worst-case i.e,    * hash-aggregation is disabled    *<p>    * NOTE: The number of rows from map-side GBY operator is dependent on map-side parallelism i.e,    * number of mappers. The map-side parallelism is expected from hive config    * "hive.stats.map.parallelism". If the config is not set then default parallelism of 1 will be    * assumed.    *<p>    *<i>Worst case:</i> If no column statistics are available, then T(R) = T(R)/2 will be used as    * heuristics.    *<p>    *<i>For more information, refer 'Estimating The Cost Of Operations' chapter in    * "Database Systems: The Complete Book" by Garcia-Molina et. al.</i>    *</p>    */
specifier|public
specifier|static
class|class
name|GroupByStatsRule
extends|extends
name|DefaultStatsRule
implements|implements
name|NodeProcessor
block|{
annotation|@
name|Override
specifier|public
name|Object
name|process
parameter_list|(
name|Node
name|nd
parameter_list|,
name|Stack
argument_list|<
name|Node
argument_list|>
name|stack
parameter_list|,
name|NodeProcessorCtx
name|procCtx
parameter_list|,
name|Object
modifier|...
name|nodeOutputs
parameter_list|)
throws|throws
name|SemanticException
block|{
name|GroupByOperator
name|gop
init|=
operator|(
name|GroupByOperator
operator|)
name|nd
decl_stmt|;
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
name|parent
init|=
name|gop
operator|.
name|getParentOperators
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|Statistics
name|parentStats
init|=
name|parent
operator|.
name|getStatistics
argument_list|()
decl_stmt|;
name|AnnotateStatsProcCtx
name|aspCtx
init|=
operator|(
name|AnnotateStatsProcCtx
operator|)
name|procCtx
decl_stmt|;
name|HiveConf
name|conf
init|=
name|aspCtx
operator|.
name|getConf
argument_list|()
decl_stmt|;
name|int
name|mapSideParallelism
init|=
name|HiveConf
operator|.
name|getIntVar
argument_list|(
name|conf
argument_list|,
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVE_STATS_MAP_SIDE_PARALLELISM
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|AggregationDesc
argument_list|>
name|aggDesc
init|=
name|gop
operator|.
name|getConf
argument_list|()
operator|.
name|getAggregators
argument_list|()
decl_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|ExprNodeDesc
argument_list|>
name|colExprMap
init|=
name|gop
operator|.
name|getColumnExprMap
argument_list|()
decl_stmt|;
name|RowSchema
name|rs
init|=
name|gop
operator|.
name|getSchema
argument_list|()
decl_stmt|;
name|Statistics
name|stats
init|=
literal|null
decl_stmt|;
try|try
block|{
if|if
condition|(
name|satisfyPrecondition
argument_list|(
name|parentStats
argument_list|)
condition|)
block|{
name|stats
operator|=
name|parentStats
operator|.
name|clone
argument_list|()
expr_stmt|;
name|List
argument_list|<
name|ColStatistics
argument_list|>
name|colStats
init|=
name|StatsUtils
operator|.
name|getColStatisticsFromExprMap
argument_list|(
name|conf
argument_list|,
name|parentStats
argument_list|,
name|colExprMap
argument_list|,
name|rs
argument_list|)
decl_stmt|;
name|stats
operator|.
name|setColumnStats
argument_list|(
name|colStats
argument_list|)
expr_stmt|;
name|long
name|dvProd
init|=
literal|1
decl_stmt|;
name|long
name|newNumRows
init|=
literal|0
decl_stmt|;
comment|// compute product of distinct values of grouping columns
for|for
control|(
name|ColStatistics
name|cs
range|:
name|colStats
control|)
block|{
if|if
condition|(
name|cs
operator|!=
literal|null
condition|)
block|{
name|long
name|dv
init|=
name|cs
operator|.
name|getCountDistint
argument_list|()
decl_stmt|;
if|if
condition|(
name|cs
operator|.
name|getNumNulls
argument_list|()
operator|>
literal|0
condition|)
block|{
name|dv
operator|+=
literal|1
expr_stmt|;
block|}
name|dvProd
operator|*=
name|dv
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|parentStats
operator|.
name|getColumnStatsState
argument_list|()
operator|.
name|equals
argument_list|(
name|Statistics
operator|.
name|State
operator|.
name|COMPLETE
argument_list|)
condition|)
block|{
comment|// the column must be an aggregate column inserted by GBY. We
comment|// don't have to account for this column when computing product
comment|// of NDVs
continue|continue;
block|}
else|else
block|{
comment|// partial column statistics on grouping attributes case.
comment|// if column statistics on grouping attribute is missing, then
comment|// assume worst case.
comment|// GBY rule will emit half the number of rows if dvProd is 0
name|dvProd
operator|=
literal|0
expr_stmt|;
block|}
break|break;
block|}
block|}
comment|// map side
if|if
condition|(
name|gop
operator|.
name|getChildOperators
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|instanceof
name|ReduceSinkOperator
condition|)
block|{
comment|// since we do not know if hash-aggregation will be enabled or disabled
comment|// at runtime we will assume that map-side group by does not do any
comment|// reduction.hence no group by rule will be applied
comment|// map-side grouping set present. if grouping set is present then
comment|// multiply the number of rows by number of elements in grouping set
if|if
condition|(
name|gop
operator|.
name|getConf
argument_list|()
operator|.
name|isGroupingSetsPresent
argument_list|()
condition|)
block|{
name|int
name|multiplier
init|=
name|gop
operator|.
name|getConf
argument_list|()
operator|.
name|getListGroupingSets
argument_list|()
operator|.
name|size
argument_list|()
decl_stmt|;
comment|// take into account the map-side parallelism as well, default is 1
name|multiplier
operator|*=
name|mapSideParallelism
expr_stmt|;
name|newNumRows
operator|=
name|multiplier
operator|*
name|stats
operator|.
name|getNumRows
argument_list|()
expr_stmt|;
name|long
name|dataSize
init|=
name|multiplier
operator|*
name|stats
operator|.
name|getDataSize
argument_list|()
decl_stmt|;
name|stats
operator|.
name|setNumRows
argument_list|(
name|newNumRows
argument_list|)
expr_stmt|;
name|stats
operator|.
name|setDataSize
argument_list|(
name|dataSize
argument_list|)
expr_stmt|;
for|for
control|(
name|ColStatistics
name|cs
range|:
name|colStats
control|)
block|{
if|if
condition|(
name|cs
operator|!=
literal|null
condition|)
block|{
name|long
name|oldNumNulls
init|=
name|cs
operator|.
name|getNumNulls
argument_list|()
decl_stmt|;
name|long
name|newNumNulls
init|=
name|multiplier
operator|*
name|oldNumNulls
decl_stmt|;
name|cs
operator|.
name|setNumNulls
argument_list|(
name|newNumNulls
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
comment|// map side no grouping set
name|newNumRows
operator|=
name|stats
operator|.
name|getNumRows
argument_list|()
operator|*
name|mapSideParallelism
expr_stmt|;
name|updateStats
argument_list|(
name|stats
argument_list|,
name|newNumRows
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// reduce side
name|newNumRows
operator|=
name|applyGBYRule
argument_list|(
name|stats
operator|.
name|getNumRows
argument_list|()
argument_list|,
name|dvProd
argument_list|)
expr_stmt|;
name|updateStats
argument_list|(
name|stats
argument_list|,
name|newNumRows
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|parentStats
operator|!=
literal|null
condition|)
block|{
comment|// worst case, in the absence of column statistics assume half the rows are emitted
if|if
condition|(
name|gop
operator|.
name|getChildOperators
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|instanceof
name|ReduceSinkOperator
condition|)
block|{
comment|// map side
name|stats
operator|=
name|parentStats
operator|.
name|clone
argument_list|()
expr_stmt|;
block|}
else|else
block|{
comment|// reduce side
name|stats
operator|=
name|parentStats
operator|.
name|clone
argument_list|()
expr_stmt|;
name|long
name|newNumRows
init|=
name|parentStats
operator|.
name|getNumRows
argument_list|()
operator|/
literal|2
decl_stmt|;
name|updateStats
argument_list|(
name|stats
argument_list|,
name|newNumRows
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|// if UDAFs are present, new columns needs to be added
if|if
condition|(
operator|!
name|aggDesc
operator|.
name|isEmpty
argument_list|()
operator|&&
name|stats
operator|!=
literal|null
condition|)
block|{
name|List
argument_list|<
name|ColStatistics
argument_list|>
name|aggColStats
init|=
name|Lists
operator|.
name|newArrayList
argument_list|()
decl_stmt|;
for|for
control|(
name|ColumnInfo
name|ci
range|:
name|rs
operator|.
name|getSignature
argument_list|()
control|)
block|{
comment|// if the columns in row schema is not contained in column
comment|// expression map, then those are the aggregate columns that
comment|// are added GBY operator. we will estimate the column statistics
comment|// for those newly added columns
if|if
condition|(
operator|!
name|colExprMap
operator|.
name|containsKey
argument_list|(
name|ci
operator|.
name|getInternalName
argument_list|()
argument_list|)
condition|)
block|{
name|String
name|colName
init|=
name|ci
operator|.
name|getInternalName
argument_list|()
decl_stmt|;
name|colName
operator|=
name|StatsUtils
operator|.
name|stripPrefixFromColumnName
argument_list|(
name|colName
argument_list|)
expr_stmt|;
name|String
name|tabAlias
init|=
name|ci
operator|.
name|getTabAlias
argument_list|()
decl_stmt|;
name|String
name|colType
init|=
name|ci
operator|.
name|getTypeName
argument_list|()
decl_stmt|;
name|ColStatistics
name|cs
init|=
operator|new
name|ColStatistics
argument_list|(
name|tabAlias
argument_list|,
name|colName
argument_list|,
name|colType
argument_list|)
decl_stmt|;
name|cs
operator|.
name|setCountDistint
argument_list|(
name|stats
operator|.
name|getNumRows
argument_list|()
argument_list|)
expr_stmt|;
name|cs
operator|.
name|setNumNulls
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|cs
operator|.
name|setAvgColLen
argument_list|(
name|StatsUtils
operator|.
name|getAvgColLenOfFixedLengthTypes
argument_list|(
name|colType
argument_list|)
argument_list|)
expr_stmt|;
name|aggColStats
operator|.
name|add
argument_list|(
name|cs
argument_list|)
expr_stmt|;
block|}
block|}
comment|// add the new aggregate column and recompute data size
if|if
condition|(
name|aggColStats
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
name|stats
operator|.
name|addToColumnStats
argument_list|(
name|aggColStats
argument_list|)
expr_stmt|;
comment|// only if the column stats is available, update the data size from
comment|// the column stats
if|if
condition|(
operator|!
name|stats
operator|.
name|getColumnStatsState
argument_list|()
operator|.
name|equals
argument_list|(
name|Statistics
operator|.
name|State
operator|.
name|NONE
argument_list|)
condition|)
block|{
name|updateStats
argument_list|(
name|stats
argument_list|,
name|stats
operator|.
name|getNumRows
argument_list|()
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
block|}
comment|// if UDAF present and if column expression map is empty then it must
comment|// be full aggregation query like count(*) in which case number of
comment|// rows will be 1
if|if
condition|(
name|colExprMap
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|stats
operator|.
name|setNumRows
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|updateStats
argument_list|(
name|stats
argument_list|,
literal|1
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
block|}
name|gop
operator|.
name|setStatistics
argument_list|(
name|stats
argument_list|)
expr_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
operator|&&
name|stats
operator|!=
literal|null
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"[0] STATS-"
operator|+
name|gop
operator|.
name|toString
argument_list|()
operator|+
literal|": "
operator|+
name|stats
operator|.
name|extendedToString
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|CloneNotSupportedException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|STATISTICS_CLONING_FAILED
operator|.
name|getMsg
argument_list|()
argument_list|)
throw|;
block|}
return|return
literal|null
return|;
block|}
specifier|private
name|long
name|applyGBYRule
parameter_list|(
name|long
name|numRows
parameter_list|,
name|long
name|dvProd
parameter_list|)
block|{
name|long
name|newNumRows
init|=
name|numRows
decl_stmt|;
comment|// to avoid divide by 2 to become 0
if|if
condition|(
name|numRows
operator|>
literal|1
condition|)
block|{
if|if
condition|(
name|dvProd
operator|!=
literal|0
condition|)
block|{
name|newNumRows
operator|=
name|Math
operator|.
name|min
argument_list|(
name|numRows
operator|/
literal|2
argument_list|,
name|dvProd
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|newNumRows
operator|=
name|numRows
operator|/
literal|2
expr_stmt|;
block|}
block|}
return|return
name|newNumRows
return|;
block|}
block|}
comment|/**    * JOIN operator can yield any of the following three cases<li>The values of join keys are    * disjoint in both relations in which case T(RXS) = 0 (we need histograms for this)</li><li>Join    * key is primary key on relation R and foreign key on relation S in which case every tuple in S    * will have a tuple in R T(RXS) = T(S) (we need histograms for this)</li><li>Both R& S relation    * have same value for join-key. Ex: bool column with all true values T(RXS) = T(R) * T(S) (we    * need histograms for this. counDistinct = 1 and same value)</li>    *<p>    * In the absence of histograms, we can use the following general case    *<p>    *<b>2 Relations, 1 attribute</b>    *<p>    * T(RXS) = (T(R)*T(S))/max(V(R,Y), V(S,Y)) where Y is the join attribute    *<p>    *<b>2 Relations, 2 attributes</b>    *<p>    * T(RXS) = T(R)*T(S)/max(V(R,y1), V(S,y1)) * max(V(R,y2), V(S,y2)), where y1 and y2 are the join    * attributes    *<p>    *<b>3 Relations, 1 attributes</b>    *<p>    * T(RXSXQ) = T(R)*T(S)*T(Q)/top2largest(V(R,y), V(S,y), V(Q,y)), where y is the join attribute    *<p>    *<b>3 Relations, 2 attributes</b>    *<p>    * T(RXSXQ) = T(R)*T(S)*T(Q)/top2largest(V(R,y1), V(S,y1), V(Q,y1)) * top2largest(V(R,y2), V(S,y2), V(Q,y2)),    * where y1 and y2 are the join attributes    *<p>    *<i>Worst case:</i> If no column statistics are available, then T(RXS) = joinFactor * max(T(R),    * T(S)) * (numParents - 1) will be used as heuristics. joinFactor is from hive.stats.join.factor    * hive config. In the worst case, since we do not know any information about join keys (and hence    * which of the 3 cases to use), we let it to the user to provide the join factor.    *<p>    *<i>For more information, refer 'Estimating The Cost Of Operations' chapter in    * "Database Systems: The Complete Book" by Garcia-Molina et. al.</i>    *</p>    */
specifier|public
specifier|static
class|class
name|JoinStatsRule
extends|extends
name|DefaultStatsRule
implements|implements
name|NodeProcessor
block|{
annotation|@
name|Override
specifier|public
name|Object
name|process
parameter_list|(
name|Node
name|nd
parameter_list|,
name|Stack
argument_list|<
name|Node
argument_list|>
name|stack
parameter_list|,
name|NodeProcessorCtx
name|procCtx
parameter_list|,
name|Object
modifier|...
name|nodeOutputs
parameter_list|)
throws|throws
name|SemanticException
block|{
name|CommonJoinOperator
argument_list|<
name|?
extends|extends
name|JoinDesc
argument_list|>
name|jop
init|=
operator|(
name|CommonJoinOperator
argument_list|<
name|?
extends|extends
name|JoinDesc
argument_list|>
operator|)
name|nd
decl_stmt|;
name|List
argument_list|<
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
argument_list|>
name|parents
init|=
name|jop
operator|.
name|getParentOperators
argument_list|()
decl_stmt|;
name|AnnotateStatsProcCtx
name|aspCtx
init|=
operator|(
name|AnnotateStatsProcCtx
operator|)
name|procCtx
decl_stmt|;
name|HiveConf
name|conf
init|=
name|aspCtx
operator|.
name|getConf
argument_list|()
decl_stmt|;
name|boolean
name|allStatsAvail
init|=
literal|true
decl_stmt|;
name|boolean
name|allSatisfyPreCondition
init|=
literal|true
decl_stmt|;
for|for
control|(
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
name|op
range|:
name|parents
control|)
block|{
if|if
condition|(
name|op
operator|.
name|getStatistics
argument_list|()
operator|==
literal|null
condition|)
block|{
name|allStatsAvail
operator|=
literal|false
expr_stmt|;
block|}
block|}
if|if
condition|(
name|allStatsAvail
condition|)
block|{
for|for
control|(
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
name|op
range|:
name|parents
control|)
block|{
if|if
condition|(
operator|!
name|satisfyPrecondition
argument_list|(
name|op
operator|.
name|getStatistics
argument_list|()
argument_list|)
condition|)
block|{
name|allSatisfyPreCondition
operator|=
literal|false
expr_stmt|;
block|}
block|}
if|if
condition|(
name|allSatisfyPreCondition
condition|)
block|{
comment|// statistics object that is combination of statistics from all
comment|// relations involved in JOIN
name|Statistics
name|stats
init|=
operator|new
name|Statistics
argument_list|()
decl_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|Long
argument_list|>
name|rowCountParents
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|Long
argument_list|>
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|Long
argument_list|>
name|distinctVals
init|=
name|Lists
operator|.
name|newArrayList
argument_list|()
decl_stmt|;
comment|// 2 relations, multiple attributes
name|boolean
name|multiAttr
init|=
literal|false
decl_stmt|;
name|int
name|numAttr
init|=
literal|1
decl_stmt|;
name|int
name|numParent
init|=
name|parents
operator|.
name|size
argument_list|()
decl_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|ColStatistics
argument_list|>
name|joinedColStats
init|=
name|Maps
operator|.
name|newHashMap
argument_list|()
decl_stmt|;
name|Map
argument_list|<
name|Integer
argument_list|,
name|List
argument_list|<
name|String
argument_list|>
argument_list|>
name|joinKeys
init|=
name|Maps
operator|.
name|newHashMap
argument_list|()
decl_stmt|;
comment|// get the join keys from parent ReduceSink operators
for|for
control|(
name|int
name|pos
init|=
literal|0
init|;
name|pos
operator|<
name|parents
operator|.
name|size
argument_list|()
condition|;
name|pos
operator|++
control|)
block|{
name|ReduceSinkOperator
name|parent
init|=
operator|(
name|ReduceSinkOperator
operator|)
name|jop
operator|.
name|getParentOperators
argument_list|()
operator|.
name|get
argument_list|(
name|pos
argument_list|)
decl_stmt|;
name|Statistics
name|parentStats
init|=
name|parent
operator|.
name|getStatistics
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|ExprNodeDesc
argument_list|>
name|keyExprs
init|=
name|parent
operator|.
name|getConf
argument_list|()
operator|.
name|getKeyCols
argument_list|()
decl_stmt|;
comment|// Parent RS may have column statistics from multiple parents.
comment|// Populate table alias to row count map, this will be used later to
comment|// scale down/up column statistics based on new row count
comment|// NOTE: JOIN with UNION as parent of RS will not have table alias
comment|// propagated properly. UNION operator does not propagate the table
comment|// alias of subqueries properly to expression nodes. Hence union20.q
comment|// will have wrong number of rows.
name|Set
argument_list|<
name|String
argument_list|>
name|tableAliases
init|=
name|StatsUtils
operator|.
name|getAllTableAlias
argument_list|(
name|parent
operator|.
name|getColumnExprMap
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|String
name|tabAlias
range|:
name|tableAliases
control|)
block|{
name|rowCountParents
operator|.
name|put
argument_list|(
name|tabAlias
argument_list|,
name|parentStats
operator|.
name|getNumRows
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// multi-attribute join key
if|if
condition|(
name|keyExprs
operator|.
name|size
argument_list|()
operator|>
literal|1
condition|)
block|{
name|multiAttr
operator|=
literal|true
expr_stmt|;
name|numAttr
operator|=
name|keyExprs
operator|.
name|size
argument_list|()
expr_stmt|;
block|}
comment|// compute fully qualified join key column names. this name will be
comment|// used to quickly look-up for column statistics of join key.
comment|// TODO: expressions in join condition will be ignored. assign
comment|// internal name for expressions and estimate column statistics for expression.
name|List
argument_list|<
name|String
argument_list|>
name|fqCols
init|=
name|StatsUtils
operator|.
name|getFullQualifedColNameFromExprs
argument_list|(
name|keyExprs
argument_list|,
name|parent
operator|.
name|getColumnExprMap
argument_list|()
argument_list|)
decl_stmt|;
name|joinKeys
operator|.
name|put
argument_list|(
name|pos
argument_list|,
name|fqCols
argument_list|)
expr_stmt|;
comment|// get column statistics for all output columns
for|for
control|(
name|ColStatistics
name|cs
range|:
name|parentStats
operator|.
name|getColumnStats
argument_list|()
control|)
block|{
name|joinedColStats
operator|.
name|put
argument_list|(
name|cs
operator|.
name|getFullyQualifiedColName
argument_list|()
argument_list|,
name|cs
argument_list|)
expr_stmt|;
block|}
comment|// since new statistics is derived from all relations involved in
comment|// JOIN, we need to update the state information accordingly
name|stats
operator|.
name|updateColumnStatsState
argument_list|(
name|parentStats
operator|.
name|getColumnStatsState
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// compute denominator i.e, max(V(R,Y), V(S,Y)) in case of single
comment|// attribute join, else max(V(R,y1), V(S,y1)) * max(V(R,y2), V(S,y2))
comment|// in case of multi-attribute join
name|long
name|denom
init|=
literal|1
decl_stmt|;
if|if
condition|(
name|multiAttr
condition|)
block|{
name|List
argument_list|<
name|Long
argument_list|>
name|perAttrDVs
init|=
name|Lists
operator|.
name|newArrayList
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|idx
init|=
literal|0
init|;
name|idx
operator|<
name|numAttr
condition|;
name|idx
operator|++
control|)
block|{
for|for
control|(
name|Integer
name|i
range|:
name|joinKeys
operator|.
name|keySet
argument_list|()
control|)
block|{
name|String
name|col
init|=
name|joinKeys
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|get
argument_list|(
name|idx
argument_list|)
decl_stmt|;
name|col
operator|=
name|StatsUtils
operator|.
name|stripPrefixFromColumnName
argument_list|(
name|col
argument_list|)
expr_stmt|;
name|ColStatistics
name|cs
init|=
name|joinedColStats
operator|.
name|get
argument_list|(
name|col
argument_list|)
decl_stmt|;
if|if
condition|(
name|cs
operator|!=
literal|null
condition|)
block|{
name|perAttrDVs
operator|.
name|add
argument_list|(
name|cs
operator|.
name|getCountDistint
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
name|distinctVals
operator|.
name|add
argument_list|(
name|getDenominator
argument_list|(
name|perAttrDVs
argument_list|)
argument_list|)
expr_stmt|;
name|perAttrDVs
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|numAttr
operator|>
name|numParent
condition|)
block|{
comment|// To avoid denominator getting larger and aggressively reducing
comment|// number of rows, we will ease out denominator.
name|denom
operator|=
name|getEasedOutDenominator
argument_list|(
name|distinctVals
argument_list|)
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|Long
name|l
range|:
name|distinctVals
control|)
block|{
name|denom
operator|*=
name|l
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
for|for
control|(
name|List
argument_list|<
name|String
argument_list|>
name|jkeys
range|:
name|joinKeys
operator|.
name|values
argument_list|()
control|)
block|{
for|for
control|(
name|String
name|jk
range|:
name|jkeys
control|)
block|{
name|jk
operator|=
name|StatsUtils
operator|.
name|stripPrefixFromColumnName
argument_list|(
name|jk
argument_list|)
expr_stmt|;
name|ColStatistics
name|cs
init|=
name|joinedColStats
operator|.
name|get
argument_list|(
name|jk
argument_list|)
decl_stmt|;
if|if
condition|(
name|cs
operator|!=
literal|null
condition|)
block|{
name|distinctVals
operator|.
name|add
argument_list|(
name|cs
operator|.
name|getCountDistint
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|denom
operator|=
name|getDenominator
argument_list|(
name|distinctVals
argument_list|)
expr_stmt|;
block|}
comment|// Update NDV of joined columns to be min(V(R,y), V(S,y))
if|if
condition|(
name|multiAttr
condition|)
block|{
name|updateJoinColumnsNDV
argument_list|(
name|joinKeys
argument_list|,
name|joinedColStats
argument_list|,
name|numAttr
argument_list|)
expr_stmt|;
block|}
comment|// column statistics from different sources are put together and rename
comment|// fully qualified column names based on output schema of join operator
name|Map
argument_list|<
name|String
argument_list|,
name|ExprNodeDesc
argument_list|>
name|colExprMap
init|=
name|jop
operator|.
name|getColumnExprMap
argument_list|()
decl_stmt|;
name|RowSchema
name|rs
init|=
name|jop
operator|.
name|getSchema
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|ColStatistics
argument_list|>
name|outColStats
init|=
name|Lists
operator|.
name|newArrayList
argument_list|()
decl_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|outInTabAlias
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|ColumnInfo
name|ci
range|:
name|rs
operator|.
name|getSignature
argument_list|()
control|)
block|{
name|String
name|key
init|=
name|ci
operator|.
name|getInternalName
argument_list|()
decl_stmt|;
name|ExprNodeDesc
name|end
init|=
name|colExprMap
operator|.
name|get
argument_list|(
name|key
argument_list|)
decl_stmt|;
if|if
condition|(
name|end
operator|instanceof
name|ExprNodeColumnDesc
condition|)
block|{
name|String
name|colName
init|=
operator|(
operator|(
name|ExprNodeColumnDesc
operator|)
name|end
operator|)
operator|.
name|getColumn
argument_list|()
decl_stmt|;
name|colName
operator|=
name|StatsUtils
operator|.
name|stripPrefixFromColumnName
argument_list|(
name|colName
argument_list|)
expr_stmt|;
name|String
name|tabAlias
init|=
operator|(
operator|(
name|ExprNodeColumnDesc
operator|)
name|end
operator|)
operator|.
name|getTabAlias
argument_list|()
decl_stmt|;
name|String
name|fqColName
init|=
name|StatsUtils
operator|.
name|getFullyQualifiedColumnName
argument_list|(
name|tabAlias
argument_list|,
name|colName
argument_list|)
decl_stmt|;
name|ColStatistics
name|cs
init|=
name|joinedColStats
operator|.
name|get
argument_list|(
name|fqColName
argument_list|)
decl_stmt|;
name|String
name|outColName
init|=
name|key
decl_stmt|;
name|String
name|outTabAlias
init|=
name|ci
operator|.
name|getTabAlias
argument_list|()
decl_stmt|;
name|outInTabAlias
operator|.
name|put
argument_list|(
name|outTabAlias
argument_list|,
name|tabAlias
argument_list|)
expr_stmt|;
if|if
condition|(
name|cs
operator|!=
literal|null
condition|)
block|{
name|cs
operator|.
name|setColumnName
argument_list|(
name|outColName
argument_list|)
expr_stmt|;
name|cs
operator|.
name|setTableAlias
argument_list|(
name|outTabAlias
argument_list|)
expr_stmt|;
block|}
name|outColStats
operator|.
name|add
argument_list|(
name|cs
argument_list|)
expr_stmt|;
block|}
block|}
comment|// update join statistics
name|stats
operator|.
name|setColumnStats
argument_list|(
name|outColStats
argument_list|)
expr_stmt|;
name|long
name|newRowCount
init|=
name|computeNewRowCount
argument_list|(
name|Lists
operator|.
name|newArrayList
argument_list|(
name|rowCountParents
operator|.
name|values
argument_list|()
argument_list|)
argument_list|,
name|denom
argument_list|)
decl_stmt|;
if|if
condition|(
name|newRowCount
operator|<=
literal|0
operator|&&
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|newRowCount
operator|=
literal|0
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"[0] STATS-"
operator|+
name|jop
operator|.
name|toString
argument_list|()
operator|+
literal|": Product of #rows might be greater than"
operator|+
literal|" denominator or overflow might have occurred. Resetting row count to 0."
operator|+
literal|" #Rows of parents: "
operator|+
name|rowCountParents
operator|.
name|toString
argument_list|()
operator|+
literal|". Denominator: "
operator|+
name|denom
argument_list|)
expr_stmt|;
block|}
name|updateStatsForJoinType
argument_list|(
name|stats
argument_list|,
name|newRowCount
argument_list|,
name|jop
operator|.
name|getConf
argument_list|()
argument_list|,
name|rowCountParents
argument_list|,
name|outInTabAlias
argument_list|)
expr_stmt|;
name|jop
operator|.
name|setStatistics
argument_list|(
name|stats
argument_list|)
expr_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"[1] STATS-"
operator|+
name|jop
operator|.
name|toString
argument_list|()
operator|+
literal|": "
operator|+
name|stats
operator|.
name|extendedToString
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// worst case when there are no column statistics
name|float
name|joinFactor
init|=
name|HiveConf
operator|.
name|getFloatVar
argument_list|(
name|conf
argument_list|,
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVE_STATS_JOIN_FACTOR
argument_list|)
decl_stmt|;
name|int
name|numParents
init|=
name|parents
operator|.
name|size
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|Long
argument_list|>
name|parentRows
init|=
name|Lists
operator|.
name|newArrayList
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|Long
argument_list|>
name|parentSizes
init|=
name|Lists
operator|.
name|newArrayList
argument_list|()
decl_stmt|;
name|int
name|maxRowIdx
init|=
literal|0
decl_stmt|;
name|long
name|maxRowCount
init|=
literal|0
decl_stmt|;
name|int
name|idx
init|=
literal|0
decl_stmt|;
for|for
control|(
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
name|op
range|:
name|parents
control|)
block|{
name|Statistics
name|ps
init|=
name|op
operator|.
name|getStatistics
argument_list|()
decl_stmt|;
name|long
name|rowCount
init|=
name|ps
operator|.
name|getNumRows
argument_list|()
decl_stmt|;
if|if
condition|(
name|rowCount
operator|>
name|maxRowCount
condition|)
block|{
name|maxRowCount
operator|=
name|rowCount
expr_stmt|;
name|maxRowIdx
operator|=
name|idx
expr_stmt|;
block|}
name|parentRows
operator|.
name|add
argument_list|(
name|rowCount
argument_list|)
expr_stmt|;
name|parentSizes
operator|.
name|add
argument_list|(
name|ps
operator|.
name|getDataSize
argument_list|()
argument_list|)
expr_stmt|;
name|idx
operator|++
expr_stmt|;
block|}
name|long
name|maxDataSize
init|=
name|parentSizes
operator|.
name|get
argument_list|(
name|maxRowIdx
argument_list|)
decl_stmt|;
name|long
name|newNumRows
init|=
call|(
name|long
call|)
argument_list|(
name|joinFactor
operator|*
name|maxRowCount
operator|*
operator|(
name|numParents
operator|-
literal|1
operator|)
argument_list|)
decl_stmt|;
name|long
name|newDataSize
init|=
call|(
name|long
call|)
argument_list|(
name|joinFactor
operator|*
name|maxDataSize
operator|*
operator|(
name|numParents
operator|-
literal|1
operator|)
argument_list|)
decl_stmt|;
name|Statistics
name|wcStats
init|=
operator|new
name|Statistics
argument_list|()
decl_stmt|;
name|wcStats
operator|.
name|setNumRows
argument_list|(
name|newNumRows
argument_list|)
expr_stmt|;
name|wcStats
operator|.
name|setDataSize
argument_list|(
name|newDataSize
argument_list|)
expr_stmt|;
name|jop
operator|.
name|setStatistics
argument_list|(
name|wcStats
argument_list|)
expr_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"[2] STATS-"
operator|+
name|jop
operator|.
name|toString
argument_list|()
operator|+
literal|": "
operator|+
name|wcStats
operator|.
name|extendedToString
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
literal|null
return|;
block|}
specifier|private
name|Long
name|getEasedOutDenominator
parameter_list|(
name|List
argument_list|<
name|Long
argument_list|>
name|distinctVals
parameter_list|)
block|{
comment|// Exponential back-off for NDVs.
comment|// 1) Descending order sort of NDVs
comment|// 2) denominator = NDV1 * (NDV2 ^ (1/2)) * (NDV3 ^ (1/4))) * ....
name|Collections
operator|.
name|sort
argument_list|(
name|distinctVals
argument_list|,
name|Collections
operator|.
name|reverseOrder
argument_list|()
argument_list|)
expr_stmt|;
name|long
name|denom
init|=
name|distinctVals
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<
name|distinctVals
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|denom
operator|=
call|(
name|long
call|)
argument_list|(
name|denom
operator|*
name|Math
operator|.
name|pow
argument_list|(
name|distinctVals
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|,
literal|1.0
operator|/
operator|(
literal|1
operator|<<
name|i
operator|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|denom
return|;
block|}
specifier|private
name|void
name|updateStatsForJoinType
parameter_list|(
name|Statistics
name|stats
parameter_list|,
name|long
name|newNumRows
parameter_list|,
name|JoinDesc
name|conf
parameter_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|Long
argument_list|>
name|rowCountParents
parameter_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|outInTabAlias
parameter_list|)
block|{
name|stats
operator|.
name|setNumRows
argument_list|(
name|newNumRows
argument_list|)
expr_stmt|;
comment|// scale down/up the column statistics based on the changes in number of
comment|// rows from each parent. For ex: If there are 2 parents for JOIN operator
comment|// with 1st parent having 200 rows and 2nd parent having 2000 rows. Now if
comment|// the new number of rows after applying join rule is 10, then the column
comment|// stats for columns from 1st parent should be scaled down by 200/10 = 20x
comment|// and stats for columns from 2nd parent should be scaled down by 200x
name|List
argument_list|<
name|ColStatistics
argument_list|>
name|colStats
init|=
name|stats
operator|.
name|getColumnStats
argument_list|()
decl_stmt|;
for|for
control|(
name|ColStatistics
name|cs
range|:
name|colStats
control|)
block|{
name|long
name|oldRowCount
init|=
name|rowCountParents
operator|.
name|get
argument_list|(
name|outInTabAlias
operator|.
name|get
argument_list|(
name|cs
operator|.
name|getTableAlias
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
name|double
name|ratio
init|=
operator|(
name|double
operator|)
name|newNumRows
operator|/
operator|(
name|double
operator|)
name|oldRowCount
decl_stmt|;
name|long
name|oldDV
init|=
name|cs
operator|.
name|getCountDistint
argument_list|()
decl_stmt|;
name|long
name|newDV
init|=
name|oldDV
decl_stmt|;
comment|// if ratio is greater than 1, then number of rows increases. This can happen
comment|// when some operators like GROUPBY duplicates the input rows in which case
comment|// number of distincts should not change. Update the distinct count only when
comment|// the output number of rows is less than input number of rows.
if|if
condition|(
name|ratio
operator|<=
literal|1.0
condition|)
block|{
name|newDV
operator|=
operator|(
name|long
operator|)
name|Math
operator|.
name|ceil
argument_list|(
name|ratio
operator|*
name|oldDV
argument_list|)
expr_stmt|;
block|}
comment|// Assumes inner join
comment|// TODO: HIVE-5579 will handle different join types
name|cs
operator|.
name|setNumNulls
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|cs
operator|.
name|setCountDistint
argument_list|(
name|newDV
argument_list|)
expr_stmt|;
block|}
name|stats
operator|.
name|setColumnStats
argument_list|(
name|colStats
argument_list|)
expr_stmt|;
name|long
name|newDataSize
init|=
name|StatsUtils
operator|.
name|getDataSizeFromColumnStats
argument_list|(
name|newNumRows
argument_list|,
name|colStats
argument_list|)
decl_stmt|;
name|stats
operator|.
name|setDataSize
argument_list|(
name|newDataSize
argument_list|)
expr_stmt|;
block|}
specifier|private
name|long
name|computeNewRowCount
parameter_list|(
name|List
argument_list|<
name|Long
argument_list|>
name|rowCountParents
parameter_list|,
name|long
name|denom
parameter_list|)
block|{
name|double
name|factor
init|=
literal|0.0d
decl_stmt|;
name|long
name|result
init|=
literal|1
decl_stmt|;
name|long
name|max
init|=
name|rowCountParents
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|long
name|maxIdx
init|=
literal|0
decl_stmt|;
comment|// To avoid long overflow, we will divide the max row count by denominator
comment|// and use that factor to multiply with other row counts
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<
name|rowCountParents
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|rowCountParents
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|>
name|max
condition|)
block|{
name|max
operator|=
name|rowCountParents
operator|.
name|get
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|maxIdx
operator|=
name|i
expr_stmt|;
block|}
block|}
name|factor
operator|=
operator|(
name|double
operator|)
name|max
operator|/
operator|(
name|double
operator|)
name|denom
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|rowCountParents
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|!=
name|maxIdx
condition|)
block|{
name|result
operator|*=
name|rowCountParents
operator|.
name|get
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
block|}
name|result
operator|=
call|(
name|long
call|)
argument_list|(
name|result
operator|*
name|factor
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
specifier|private
name|void
name|updateJoinColumnsNDV
parameter_list|(
name|Map
argument_list|<
name|Integer
argument_list|,
name|List
argument_list|<
name|String
argument_list|>
argument_list|>
name|joinKeys
parameter_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|ColStatistics
argument_list|>
name|joinedColStats
parameter_list|,
name|int
name|numAttr
parameter_list|)
block|{
name|int
name|joinColIdx
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|numAttr
operator|>
literal|0
condition|)
block|{
name|long
name|minNDV
init|=
name|Long
operator|.
name|MAX_VALUE
decl_stmt|;
comment|// find min NDV for joining columns
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|Integer
argument_list|,
name|List
argument_list|<
name|String
argument_list|>
argument_list|>
name|entry
range|:
name|joinKeys
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|String
name|key
init|=
name|entry
operator|.
name|getValue
argument_list|()
operator|.
name|get
argument_list|(
name|joinColIdx
argument_list|)
decl_stmt|;
name|key
operator|=
name|StatsUtils
operator|.
name|stripPrefixFromColumnName
argument_list|(
name|key
argument_list|)
expr_stmt|;
name|ColStatistics
name|cs
init|=
name|joinedColStats
operator|.
name|get
argument_list|(
name|key
argument_list|)
decl_stmt|;
if|if
condition|(
name|cs
operator|!=
literal|null
operator|&&
name|cs
operator|.
name|getCountDistint
argument_list|()
operator|<
name|minNDV
condition|)
block|{
name|minNDV
operator|=
name|cs
operator|.
name|getCountDistint
argument_list|()
expr_stmt|;
block|}
block|}
comment|// set min NDV value to both columns involved in join
if|if
condition|(
name|minNDV
operator|!=
name|Long
operator|.
name|MAX_VALUE
condition|)
block|{
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|Integer
argument_list|,
name|List
argument_list|<
name|String
argument_list|>
argument_list|>
name|entry
range|:
name|joinKeys
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|String
name|key
init|=
name|entry
operator|.
name|getValue
argument_list|()
operator|.
name|get
argument_list|(
name|joinColIdx
argument_list|)
decl_stmt|;
name|key
operator|=
name|StatsUtils
operator|.
name|stripPrefixFromColumnName
argument_list|(
name|key
argument_list|)
expr_stmt|;
name|ColStatistics
name|cs
init|=
name|joinedColStats
operator|.
name|get
argument_list|(
name|key
argument_list|)
decl_stmt|;
name|cs
operator|.
name|setCountDistint
argument_list|(
name|minNDV
argument_list|)
expr_stmt|;
block|}
block|}
name|joinColIdx
operator|++
expr_stmt|;
name|numAttr
operator|--
expr_stmt|;
block|}
block|}
specifier|private
name|long
name|getDenominator
parameter_list|(
name|List
argument_list|<
name|Long
argument_list|>
name|distinctVals
parameter_list|)
block|{
if|if
condition|(
name|distinctVals
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
comment|// TODO: in union20.q the tab alias is not properly propagated down the
comment|// operator tree. This happens when UNION ALL is used as sub query. Hence, even
comment|// if column statistics are available, the tab alias will be null which will fail
comment|// to get proper column statistics. For now assume, worst case in which
comment|// denominator is 2.
return|return
literal|2
return|;
block|}
comment|// simple join from 2 relations: denom = max(v1, v2)
if|if
condition|(
name|distinctVals
operator|.
name|size
argument_list|()
operator|<=
literal|2
condition|)
block|{
return|return
name|Collections
operator|.
name|max
argument_list|(
name|distinctVals
argument_list|)
return|;
block|}
else|else
block|{
comment|// remember min value and ignore it from the denominator
name|long
name|minNDV
init|=
name|distinctVals
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|int
name|minIdx
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<
name|distinctVals
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|distinctVals
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|<
name|minNDV
condition|)
block|{
name|minNDV
operator|=
name|distinctVals
operator|.
name|get
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|minIdx
operator|=
name|i
expr_stmt|;
block|}
block|}
comment|// join from multiple relations:
comment|// denom = Product of all NDVs except the least of all
name|long
name|denom
init|=
literal|1
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|distinctVals
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|!=
name|minIdx
condition|)
block|{
name|denom
operator|*=
name|distinctVals
operator|.
name|get
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|denom
return|;
block|}
block|}
block|}
comment|/**    * LIMIT operator changes the number of rows and thereby the data size.    */
specifier|public
specifier|static
class|class
name|LimitStatsRule
extends|extends
name|DefaultStatsRule
implements|implements
name|NodeProcessor
block|{
annotation|@
name|Override
specifier|public
name|Object
name|process
parameter_list|(
name|Node
name|nd
parameter_list|,
name|Stack
argument_list|<
name|Node
argument_list|>
name|stack
parameter_list|,
name|NodeProcessorCtx
name|procCtx
parameter_list|,
name|Object
modifier|...
name|nodeOutputs
parameter_list|)
throws|throws
name|SemanticException
block|{
name|LimitOperator
name|lop
init|=
operator|(
name|LimitOperator
operator|)
name|nd
decl_stmt|;
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
name|parent
init|=
name|lop
operator|.
name|getParentOperators
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|Statistics
name|parentStats
init|=
name|parent
operator|.
name|getStatistics
argument_list|()
decl_stmt|;
try|try
block|{
name|long
name|limit
init|=
operator|-
literal|1
decl_stmt|;
name|limit
operator|=
name|lop
operator|.
name|getConf
argument_list|()
operator|.
name|getLimit
argument_list|()
expr_stmt|;
if|if
condition|(
name|satisfyPrecondition
argument_list|(
name|parentStats
argument_list|)
condition|)
block|{
name|Statistics
name|stats
init|=
name|parentStats
operator|.
name|clone
argument_list|()
decl_stmt|;
comment|// if limit is greater than available rows then do not update
comment|// statistics
if|if
condition|(
name|limit
operator|<=
name|parentStats
operator|.
name|getNumRows
argument_list|()
condition|)
block|{
name|updateStats
argument_list|(
name|stats
argument_list|,
name|limit
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
name|lop
operator|.
name|setStatistics
argument_list|(
name|stats
argument_list|)
expr_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"[0] STATS-"
operator|+
name|lop
operator|.
name|toString
argument_list|()
operator|+
literal|": "
operator|+
name|stats
operator|.
name|extendedToString
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|parentStats
operator|!=
literal|null
condition|)
block|{
comment|// in the absence of column statistics, compute data size based on
comment|// based on average row size
name|Statistics
name|wcStats
init|=
name|parentStats
operator|.
name|clone
argument_list|()
decl_stmt|;
if|if
condition|(
name|limit
operator|<=
name|parentStats
operator|.
name|getNumRows
argument_list|()
condition|)
block|{
name|long
name|numRows
init|=
name|limit
decl_stmt|;
name|long
name|avgRowSize
init|=
name|parentStats
operator|.
name|getAvgRowSize
argument_list|()
decl_stmt|;
name|long
name|dataSize
init|=
name|avgRowSize
operator|*
name|limit
decl_stmt|;
name|wcStats
operator|.
name|setNumRows
argument_list|(
name|numRows
argument_list|)
expr_stmt|;
name|wcStats
operator|.
name|setDataSize
argument_list|(
name|dataSize
argument_list|)
expr_stmt|;
block|}
name|lop
operator|.
name|setStatistics
argument_list|(
name|wcStats
argument_list|)
expr_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"[1] STATS-"
operator|+
name|lop
operator|.
name|toString
argument_list|()
operator|+
literal|": "
operator|+
name|wcStats
operator|.
name|extendedToString
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
catch|catch
parameter_list|(
name|CloneNotSupportedException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|STATISTICS_CLONING_FAILED
operator|.
name|getMsg
argument_list|()
argument_list|)
throw|;
block|}
return|return
literal|null
return|;
block|}
block|}
comment|/**    * ReduceSink operator does not change any of the statistics. But it renames    * the column statistics from its parent based on the output key and value    * column names to make it easy for the downstream operators. This is different    * from the default stats which just aggregates and passes along the statistics    * without actually renaming based on output schema of the operator.    */
specifier|public
specifier|static
class|class
name|ReduceSinkStatsRule
extends|extends
name|DefaultStatsRule
implements|implements
name|NodeProcessor
block|{
annotation|@
name|Override
specifier|public
name|Object
name|process
parameter_list|(
name|Node
name|nd
parameter_list|,
name|Stack
argument_list|<
name|Node
argument_list|>
name|stack
parameter_list|,
name|NodeProcessorCtx
name|procCtx
parameter_list|,
name|Object
modifier|...
name|nodeOutputs
parameter_list|)
throws|throws
name|SemanticException
block|{
name|ReduceSinkOperator
name|rop
init|=
operator|(
name|ReduceSinkOperator
operator|)
name|nd
decl_stmt|;
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
name|parent
init|=
name|rop
operator|.
name|getParentOperators
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|Statistics
name|parentStats
init|=
name|parent
operator|.
name|getStatistics
argument_list|()
decl_stmt|;
if|if
condition|(
name|parentStats
operator|!=
literal|null
condition|)
block|{
name|AnnotateStatsProcCtx
name|aspCtx
init|=
operator|(
name|AnnotateStatsProcCtx
operator|)
name|procCtx
decl_stmt|;
name|HiveConf
name|conf
init|=
name|aspCtx
operator|.
name|getConf
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|outKeyColNames
init|=
name|rop
operator|.
name|getConf
argument_list|()
operator|.
name|getOutputKeyColumnNames
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|outValueColNames
init|=
name|rop
operator|.
name|getConf
argument_list|()
operator|.
name|getOutputValueColumnNames
argument_list|()
decl_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|ExprNodeDesc
argument_list|>
name|colExprMap
init|=
name|rop
operator|.
name|getColumnExprMap
argument_list|()
decl_stmt|;
try|try
block|{
name|Statistics
name|outStats
init|=
name|parentStats
operator|.
name|clone
argument_list|()
decl_stmt|;
if|if
condition|(
name|satisfyPrecondition
argument_list|(
name|parentStats
argument_list|)
condition|)
block|{
name|List
argument_list|<
name|ColStatistics
argument_list|>
name|colStats
init|=
name|Lists
operator|.
name|newArrayList
argument_list|()
decl_stmt|;
for|for
control|(
name|String
name|key
range|:
name|outKeyColNames
control|)
block|{
name|String
name|prefixedKey
init|=
literal|"KEY."
operator|+
name|key
decl_stmt|;
name|ExprNodeDesc
name|end
init|=
name|colExprMap
operator|.
name|get
argument_list|(
name|prefixedKey
argument_list|)
decl_stmt|;
if|if
condition|(
name|end
operator|!=
literal|null
condition|)
block|{
name|ColStatistics
name|cs
init|=
name|StatsUtils
operator|.
name|getColStatisticsFromExpression
argument_list|(
name|conf
argument_list|,
name|parentStats
argument_list|,
name|end
argument_list|)
decl_stmt|;
if|if
condition|(
name|cs
operator|!=
literal|null
condition|)
block|{
name|cs
operator|.
name|setColumnName
argument_list|(
name|key
argument_list|)
expr_stmt|;
name|colStats
operator|.
name|add
argument_list|(
name|cs
argument_list|)
expr_stmt|;
block|}
block|}
block|}
for|for
control|(
name|String
name|val
range|:
name|outValueColNames
control|)
block|{
name|String
name|prefixedVal
init|=
literal|"VALUE."
operator|+
name|val
decl_stmt|;
name|ExprNodeDesc
name|end
init|=
name|colExprMap
operator|.
name|get
argument_list|(
name|prefixedVal
argument_list|)
decl_stmt|;
if|if
condition|(
name|end
operator|!=
literal|null
condition|)
block|{
name|ColStatistics
name|cs
init|=
name|StatsUtils
operator|.
name|getColStatisticsFromExpression
argument_list|(
name|conf
argument_list|,
name|parentStats
argument_list|,
name|end
argument_list|)
decl_stmt|;
if|if
condition|(
name|cs
operator|!=
literal|null
condition|)
block|{
name|cs
operator|.
name|setColumnName
argument_list|(
name|val
argument_list|)
expr_stmt|;
name|colStats
operator|.
name|add
argument_list|(
name|cs
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|outStats
operator|.
name|setColumnStats
argument_list|(
name|colStats
argument_list|)
expr_stmt|;
block|}
name|rop
operator|.
name|setStatistics
argument_list|(
name|outStats
argument_list|)
expr_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"[0] STATS-"
operator|+
name|rop
operator|.
name|toString
argument_list|()
operator|+
literal|": "
operator|+
name|outStats
operator|.
name|extendedToString
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|CloneNotSupportedException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|STATISTICS_CLONING_FAILED
operator|.
name|getMsg
argument_list|()
argument_list|)
throw|;
block|}
block|}
return|return
literal|null
return|;
block|}
block|}
comment|/**    * Default rule is to aggregate the statistics from all its parent operators.    */
specifier|public
specifier|static
class|class
name|DefaultStatsRule
implements|implements
name|NodeProcessor
block|{
annotation|@
name|Override
specifier|public
name|Object
name|process
parameter_list|(
name|Node
name|nd
parameter_list|,
name|Stack
argument_list|<
name|Node
argument_list|>
name|stack
parameter_list|,
name|NodeProcessorCtx
name|procCtx
parameter_list|,
name|Object
modifier|...
name|nodeOutputs
parameter_list|)
throws|throws
name|SemanticException
block|{
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
name|op
init|=
operator|(
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
operator|)
name|nd
decl_stmt|;
name|OperatorDesc
name|conf
init|=
name|op
operator|.
name|getConf
argument_list|()
decl_stmt|;
if|if
condition|(
name|conf
operator|!=
literal|null
condition|)
block|{
name|Statistics
name|stats
init|=
name|conf
operator|.
name|getStatistics
argument_list|()
decl_stmt|;
if|if
condition|(
name|stats
operator|==
literal|null
condition|)
block|{
if|if
condition|(
name|op
operator|.
name|getParentOperators
argument_list|()
operator|!=
literal|null
condition|)
block|{
comment|// if parent statistics is null then that branch of the tree is not
comment|// walked yet. don't update the stats until all branches are walked
if|if
condition|(
name|isAllParentsContainStatistics
argument_list|(
name|op
argument_list|)
condition|)
block|{
name|stats
operator|=
operator|new
name|Statistics
argument_list|()
expr_stmt|;
for|for
control|(
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
name|parent
range|:
name|op
operator|.
name|getParentOperators
argument_list|()
control|)
block|{
if|if
condition|(
name|parent
operator|.
name|getStatistics
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|Statistics
name|parentStats
init|=
name|parent
operator|.
name|getStatistics
argument_list|()
decl_stmt|;
name|stats
operator|.
name|addToNumRows
argument_list|(
name|parentStats
operator|.
name|getNumRows
argument_list|()
argument_list|)
expr_stmt|;
name|stats
operator|.
name|addToDataSize
argument_list|(
name|parentStats
operator|.
name|getDataSize
argument_list|()
argument_list|)
expr_stmt|;
name|stats
operator|.
name|updateColumnStatsState
argument_list|(
name|parentStats
operator|.
name|getColumnStatsState
argument_list|()
argument_list|)
expr_stmt|;
name|stats
operator|.
name|addToColumnStats
argument_list|(
name|parentStats
operator|.
name|getColumnStats
argument_list|()
argument_list|)
expr_stmt|;
name|op
operator|.
name|getConf
argument_list|()
operator|.
name|setStatistics
argument_list|(
name|stats
argument_list|)
expr_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"[0] STATS-"
operator|+
name|op
operator|.
name|toString
argument_list|()
operator|+
literal|": "
operator|+
name|stats
operator|.
name|extendedToString
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
block|}
block|}
return|return
literal|null
return|;
block|}
comment|// check if all parent statistics are available
specifier|private
name|boolean
name|isAllParentsContainStatistics
parameter_list|(
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
name|op
parameter_list|)
block|{
for|for
control|(
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
name|parent
range|:
name|op
operator|.
name|getParentOperators
argument_list|()
control|)
block|{
if|if
condition|(
name|parent
operator|.
name|getStatistics
argument_list|()
operator|==
literal|null
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
return|return
literal|true
return|;
block|}
block|}
specifier|public
specifier|static
name|NodeProcessor
name|getTableScanRule
parameter_list|()
block|{
return|return
operator|new
name|TableScanStatsRule
argument_list|()
return|;
block|}
specifier|public
specifier|static
name|NodeProcessor
name|getSelectRule
parameter_list|()
block|{
return|return
operator|new
name|SelectStatsRule
argument_list|()
return|;
block|}
specifier|public
specifier|static
name|NodeProcessor
name|getFilterRule
parameter_list|()
block|{
return|return
operator|new
name|FilterStatsRule
argument_list|()
return|;
block|}
specifier|public
specifier|static
name|NodeProcessor
name|getGroupByRule
parameter_list|()
block|{
return|return
operator|new
name|GroupByStatsRule
argument_list|()
return|;
block|}
specifier|public
specifier|static
name|NodeProcessor
name|getJoinRule
parameter_list|()
block|{
return|return
operator|new
name|JoinStatsRule
argument_list|()
return|;
block|}
specifier|public
specifier|static
name|NodeProcessor
name|getLimitRule
parameter_list|()
block|{
return|return
operator|new
name|LimitStatsRule
argument_list|()
return|;
block|}
specifier|public
specifier|static
name|NodeProcessor
name|getReduceSinkRule
parameter_list|()
block|{
return|return
operator|new
name|ReduceSinkStatsRule
argument_list|()
return|;
block|}
specifier|public
specifier|static
name|NodeProcessor
name|getDefaultRule
parameter_list|()
block|{
return|return
operator|new
name|DefaultStatsRule
argument_list|()
return|;
block|}
comment|/**    * Update the basic statistics of the statistics object based on the row number    * @param stats    *          - statistics to be updated    * @param newNumRows    *          - new number of rows    * @param useColStats    *          - use column statistics to compute data size    */
specifier|static
name|void
name|updateStats
parameter_list|(
name|Statistics
name|stats
parameter_list|,
name|long
name|newNumRows
parameter_list|,
name|boolean
name|useColStats
parameter_list|)
block|{
name|long
name|oldRowCount
init|=
name|stats
operator|.
name|getNumRows
argument_list|()
decl_stmt|;
name|double
name|ratio
init|=
operator|(
name|double
operator|)
name|newNumRows
operator|/
operator|(
name|double
operator|)
name|oldRowCount
decl_stmt|;
name|stats
operator|.
name|setNumRows
argument_list|(
name|newNumRows
argument_list|)
expr_stmt|;
if|if
condition|(
name|useColStats
condition|)
block|{
name|List
argument_list|<
name|ColStatistics
argument_list|>
name|colStats
init|=
name|stats
operator|.
name|getColumnStats
argument_list|()
decl_stmt|;
for|for
control|(
name|ColStatistics
name|cs
range|:
name|colStats
control|)
block|{
name|long
name|oldNumNulls
init|=
name|cs
operator|.
name|getNumNulls
argument_list|()
decl_stmt|;
name|long
name|oldDV
init|=
name|cs
operator|.
name|getCountDistint
argument_list|()
decl_stmt|;
name|long
name|newNumNulls
init|=
name|Math
operator|.
name|round
argument_list|(
name|ratio
operator|*
name|oldNumNulls
argument_list|)
decl_stmt|;
name|long
name|newDV
init|=
name|oldDV
decl_stmt|;
comment|// if ratio is greater than 1, then number of rows increases. This can happen
comment|// when some operators like GROUPBY duplicates the input rows in which case
comment|// number of distincts should not change. Update the distinct count only when
comment|// the output number of rows is less than input number of rows.
if|if
condition|(
name|ratio
operator|<=
literal|1.0
condition|)
block|{
name|newDV
operator|=
operator|(
name|long
operator|)
name|Math
operator|.
name|ceil
argument_list|(
name|ratio
operator|*
name|oldDV
argument_list|)
expr_stmt|;
block|}
name|cs
operator|.
name|setNumNulls
argument_list|(
name|newNumNulls
argument_list|)
expr_stmt|;
name|cs
operator|.
name|setCountDistint
argument_list|(
name|newDV
argument_list|)
expr_stmt|;
block|}
name|stats
operator|.
name|setColumnStats
argument_list|(
name|colStats
argument_list|)
expr_stmt|;
name|long
name|newDataSize
init|=
name|StatsUtils
operator|.
name|getDataSizeFromColumnStats
argument_list|(
name|newNumRows
argument_list|,
name|colStats
argument_list|)
decl_stmt|;
name|stats
operator|.
name|setDataSize
argument_list|(
name|newDataSize
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|long
name|newDataSize
init|=
call|(
name|long
call|)
argument_list|(
name|ratio
operator|*
name|stats
operator|.
name|getDataSize
argument_list|()
argument_list|)
decl_stmt|;
name|stats
operator|.
name|setDataSize
argument_list|(
name|newDataSize
argument_list|)
expr_stmt|;
block|}
block|}
specifier|static
name|boolean
name|satisfyPrecondition
parameter_list|(
name|Statistics
name|stats
parameter_list|)
block|{
return|return
name|stats
operator|!=
literal|null
operator|&&
name|stats
operator|.
name|getBasicStatsState
argument_list|()
operator|.
name|equals
argument_list|(
name|Statistics
operator|.
name|State
operator|.
name|COMPLETE
argument_list|)
operator|&&
operator|!
name|stats
operator|.
name|getColumnStatsState
argument_list|()
operator|.
name|equals
argument_list|(
name|Statistics
operator|.
name|State
operator|.
name|NONE
argument_list|)
return|;
block|}
block|}
end_class

end_unit

