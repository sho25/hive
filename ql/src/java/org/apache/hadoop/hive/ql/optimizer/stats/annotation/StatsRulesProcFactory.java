begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|optimizer
operator|.
name|stats
operator|.
name|annotation
package|;
end_package

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Stack
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|conf
operator|.
name|HiveConf
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|conf
operator|.
name|HiveConf
operator|.
name|ConfVars
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|ErrorMsg
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|ColumnInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|CommonJoinOperator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|DemuxOperator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|FilterOperator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|GroupByOperator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|LimitOperator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|Operator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|ReduceSinkOperator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|RowSchema
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|SelectOperator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|TableScanOperator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|lib
operator|.
name|Node
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|lib
operator|.
name|NodeProcessor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|lib
operator|.
name|NodeProcessorCtx
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|metadata
operator|.
name|HiveException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|metadata
operator|.
name|Table
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|parse
operator|.
name|PrunedPartitionList
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|parse
operator|.
name|SemanticException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|AggregationDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|ColStatistics
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|ExprNodeColumnDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|ExprNodeConstantDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|ExprNodeDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|ExprNodeGenericFuncDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|JoinDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|OperatorDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|Statistics
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|stats
operator|.
name|StatsUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|udf
operator|.
name|generic
operator|.
name|GenericUDF
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|udf
operator|.
name|generic
operator|.
name|GenericUDFOPAnd
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|udf
operator|.
name|generic
operator|.
name|GenericUDFOPEqual
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|udf
operator|.
name|generic
operator|.
name|GenericUDFOPEqualNS
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|udf
operator|.
name|generic
operator|.
name|GenericUDFOPEqualOrGreaterThan
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|udf
operator|.
name|generic
operator|.
name|GenericUDFOPEqualOrLessThan
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|udf
operator|.
name|generic
operator|.
name|GenericUDFOPGreaterThan
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|udf
operator|.
name|generic
operator|.
name|GenericUDFOPLessThan
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|udf
operator|.
name|generic
operator|.
name|GenericUDFOPNot
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|udf
operator|.
name|generic
operator|.
name|GenericUDFOPNotEqual
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|udf
operator|.
name|generic
operator|.
name|GenericUDFOPNotNull
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|udf
operator|.
name|generic
operator|.
name|GenericUDFOPNull
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|udf
operator|.
name|generic
operator|.
name|GenericUDFOPOr
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde
operator|.
name|serdeConstants
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Lists
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Maps
import|;
end_import

begin_class
specifier|public
class|class
name|StatsRulesProcFactory
block|{
comment|/**    * Collect basic statistics like number of rows, data size and column level    * statistics from the table. Also sets the state of the available statistics.    * Basic and column statistics can have one of the following states    * COMPLETE, PARTIAL, NONE. In case of partitioned table, the basic and column    * stats are aggregated together to table level statistics.    *    */
specifier|public
specifier|static
class|class
name|TableScanStatsRule
extends|extends
name|DefaultStatsRule
implements|implements
name|NodeProcessor
block|{
annotation|@
name|Override
specifier|public
name|Object
name|process
parameter_list|(
name|Node
name|nd
parameter_list|,
name|Stack
argument_list|<
name|Node
argument_list|>
name|stack
parameter_list|,
name|NodeProcessorCtx
name|procCtx
parameter_list|,
name|Object
modifier|...
name|nodeOutputs
parameter_list|)
throws|throws
name|SemanticException
block|{
name|TableScanOperator
name|tsop
init|=
operator|(
name|TableScanOperator
operator|)
name|nd
decl_stmt|;
name|AnnotateStatsProcCtx
name|aspCtx
init|=
operator|(
name|AnnotateStatsProcCtx
operator|)
name|procCtx
decl_stmt|;
name|PrunedPartitionList
name|partList
init|=
literal|null
decl_stmt|;
try|try
block|{
name|partList
operator|=
name|aspCtx
operator|.
name|getParseContext
argument_list|()
operator|.
name|getPrunedPartitions
argument_list|(
name|tsop
operator|.
name|getName
argument_list|()
argument_list|,
name|tsop
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|HiveException
name|e1
parameter_list|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|e1
argument_list|)
throw|;
block|}
name|Table
name|table
init|=
name|aspCtx
operator|.
name|getParseContext
argument_list|()
operator|.
name|getTopToTable
argument_list|()
operator|.
name|get
argument_list|(
name|tsop
argument_list|)
decl_stmt|;
comment|// gather statistics for the first time and the attach it to table scan operator
name|Statistics
name|stats
init|=
name|StatsUtils
operator|.
name|collectStatistics
argument_list|(
name|aspCtx
operator|.
name|getConf
argument_list|()
argument_list|,
name|partList
argument_list|,
name|table
argument_list|,
name|tsop
argument_list|)
decl_stmt|;
try|try
block|{
name|tsop
operator|.
name|setStatistics
argument_list|(
name|stats
operator|.
name|clone
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|CloneNotSupportedException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|STATISTICS_CLONING_FAILED
operator|.
name|getMsg
argument_list|()
argument_list|)
throw|;
block|}
return|return
literal|null
return|;
block|}
block|}
comment|/**    * SELECT operator doesn't change the number of rows emitted from the parent    * operator. It changes the size of each tuple emitted. In a typical case,    * where only subset of columns are selected the average row size will    * reduce as some of the columns will be pruned. In order to accurately    * compute the average row size, column level statistics is required.    * Column level statistics stores average size of values in column which    * can be used to more reliably estimate the reduction in size of each    * tuple. In the absence of column level statistics, size of columns will be    * based on data type. For primitive data types size from    * {@link org.apache.hadoop.hive.ql.util.JavaDataModel} will be    * used and for variable length data types worst case will be assumed.    *    *<p>    *<i>For more information, refer 'Estimating The Cost Of Operations' chapter in    * "Database Systems: The Complete Book" by Garcia-Molina et. al.</i>    *</p>    *    */
specifier|public
specifier|static
class|class
name|SelectStatsRule
extends|extends
name|DefaultStatsRule
implements|implements
name|NodeProcessor
block|{
annotation|@
name|Override
specifier|public
name|Object
name|process
parameter_list|(
name|Node
name|nd
parameter_list|,
name|Stack
argument_list|<
name|Node
argument_list|>
name|stack
parameter_list|,
name|NodeProcessorCtx
name|procCtx
parameter_list|,
name|Object
modifier|...
name|nodeOutputs
parameter_list|)
throws|throws
name|SemanticException
block|{
name|SelectOperator
name|sop
init|=
operator|(
name|SelectOperator
operator|)
name|nd
decl_stmt|;
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
name|parent
init|=
name|sop
operator|.
name|getParentOperators
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|Statistics
name|parentStats
init|=
name|parent
operator|.
name|getStatistics
argument_list|()
decl_stmt|;
name|AnnotateStatsProcCtx
name|aspCtx
init|=
operator|(
name|AnnotateStatsProcCtx
operator|)
name|procCtx
decl_stmt|;
name|HiveConf
name|conf
init|=
name|aspCtx
operator|.
name|getConf
argument_list|()
decl_stmt|;
comment|// SELECT (*) does not change the statistics. Just pass on the parent statistics
if|if
condition|(
name|sop
operator|.
name|getConf
argument_list|()
operator|.
name|isSelectStar
argument_list|()
condition|)
block|{
try|try
block|{
if|if
condition|(
name|parentStats
operator|!=
literal|null
condition|)
block|{
name|sop
operator|.
name|setStatistics
argument_list|(
name|parentStats
operator|.
name|clone
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|CloneNotSupportedException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|STATISTICS_CLONING_FAILED
operator|.
name|getMsg
argument_list|()
argument_list|)
throw|;
block|}
return|return
literal|null
return|;
block|}
try|try
block|{
if|if
condition|(
name|satisfyPrecondition
argument_list|(
name|parentStats
argument_list|)
condition|)
block|{
name|Statistics
name|stats
init|=
name|parentStats
operator|.
name|clone
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|ColStatistics
argument_list|>
name|colStats
init|=
name|StatsUtils
operator|.
name|getColStatisticsFromExprMap
argument_list|(
name|conf
argument_list|,
name|parentStats
argument_list|,
name|sop
operator|.
name|getColumnExprMap
argument_list|()
argument_list|,
name|sop
operator|.
name|getSchema
argument_list|()
argument_list|)
decl_stmt|;
name|long
name|dataSize
init|=
name|StatsUtils
operator|.
name|getDataSizeFromColumnStats
argument_list|(
name|stats
operator|.
name|getNumRows
argument_list|()
argument_list|,
name|colStats
argument_list|)
decl_stmt|;
name|stats
operator|.
name|setColumnStats
argument_list|(
name|colStats
argument_list|)
expr_stmt|;
name|stats
operator|.
name|setDataSize
argument_list|(
name|dataSize
argument_list|)
expr_stmt|;
name|sop
operator|.
name|setStatistics
argument_list|(
name|stats
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|parentStats
operator|!=
literal|null
condition|)
block|{
name|sop
operator|.
name|setStatistics
argument_list|(
name|parentStats
operator|.
name|clone
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
catch|catch
parameter_list|(
name|CloneNotSupportedException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|STATISTICS_CLONING_FAILED
operator|.
name|getMsg
argument_list|()
argument_list|)
throw|;
block|}
return|return
literal|null
return|;
block|}
block|}
comment|/**    * FILTER operator does not change the average row size but it does change    * the number of rows emitted. The reduction in the number of rows emitted    * is dependent on the filter expression.    *    *<ul>    *<i>Notations:</i>    *<li>T(S) - Number of tuples in relations S</li>    *<li>V(S,A) - Number of distinct values of attribute A in relation S</li>    *</ul>    *    *<ul>    *<i>Rules:</i><b>    *<li>Column equals a constant</li></b> T(S) = T(R) / V(R,A)    *<p>    *<b>    *<li>Inequality conditions</li></b> T(S) = T(R) / 3    *<p>    *<b>    *<li>Not equals comparison</li></b> - Simple formula T(S) = T(R)    *<p>    * - Alternate formula T(S) = T(R) (V(R,A) - 1) / V(R,A)    *<p>    *<b>    *<li>NOT condition</li></b> T(S) = 1 - T(S'), where T(S') is the satisfying condition    *<p>    *<b>    *<li>Multiple AND conditions</li></b> Cascadingly apply the rules 1 to 3 (order doesn't matter)    *<p>    *<b>    *<li>Multiple OR conditions</li></b> - Simple formula is to evaluate conditions independently    * and sum the results T(S) = m1 + m2    *<p>    *    * - Alternate formula T(S) = T(R) * ( 1 - ( 1 - m1/T(R) ) * ( 1 - m2/T(R) ))    *<p>    * where, m1 is the number of tuples that satisfy condition1 and m2 is the number of tuples that    * satisfy condition2    *</ul>    *<p>    *<i>For more information, refer 'Estimating The Cost Of Operations' chapter in    * "Database Systems: The Complete Book" by Garcia-Molina et. al.</i>    *</p>    *    */
specifier|public
specifier|static
class|class
name|FilterStatsRule
extends|extends
name|DefaultStatsRule
implements|implements
name|NodeProcessor
block|{
annotation|@
name|Override
specifier|public
name|Object
name|process
parameter_list|(
name|Node
name|nd
parameter_list|,
name|Stack
argument_list|<
name|Node
argument_list|>
name|stack
parameter_list|,
name|NodeProcessorCtx
name|procCtx
parameter_list|,
name|Object
modifier|...
name|nodeOutputs
parameter_list|)
throws|throws
name|SemanticException
block|{
name|AnnotateStatsProcCtx
name|aspCtx
init|=
operator|(
name|AnnotateStatsProcCtx
operator|)
name|procCtx
decl_stmt|;
name|FilterOperator
name|fop
init|=
operator|(
name|FilterOperator
operator|)
name|nd
decl_stmt|;
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
name|parent
init|=
name|fop
operator|.
name|getParentOperators
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|Statistics
name|parentStats
init|=
name|parent
operator|.
name|getStatistics
argument_list|()
decl_stmt|;
try|try
block|{
if|if
condition|(
name|satisfyPrecondition
argument_list|(
name|parentStats
argument_list|)
condition|)
block|{
name|ExprNodeDesc
name|pred
init|=
name|fop
operator|.
name|getConf
argument_list|()
operator|.
name|getPredicate
argument_list|()
decl_stmt|;
comment|// evaluate filter expression and update statistics
name|long
name|newNumRows
init|=
name|evaluateExpression
argument_list|(
name|parentStats
argument_list|,
name|pred
argument_list|,
name|aspCtx
argument_list|)
decl_stmt|;
name|Statistics
name|st
init|=
name|parentStats
operator|.
name|clone
argument_list|()
decl_stmt|;
name|updateStats
argument_list|(
name|st
argument_list|,
name|newNumRows
argument_list|)
expr_stmt|;
name|fop
operator|.
name|setStatistics
argument_list|(
name|st
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|parentStats
operator|!=
literal|null
condition|)
block|{
name|fop
operator|.
name|setStatistics
argument_list|(
name|parentStats
operator|.
name|clone
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
name|aspCtx
operator|.
name|setAndExprStats
argument_list|(
literal|null
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|CloneNotSupportedException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|STATISTICS_CLONING_FAILED
operator|.
name|getMsg
argument_list|()
argument_list|)
throw|;
block|}
return|return
literal|null
return|;
block|}
specifier|private
name|long
name|evaluateExpression
parameter_list|(
name|Statistics
name|stats
parameter_list|,
name|ExprNodeDesc
name|pred
parameter_list|,
name|AnnotateStatsProcCtx
name|aspCtx
parameter_list|)
throws|throws
name|CloneNotSupportedException
block|{
name|long
name|newNumRows
init|=
literal|0
decl_stmt|;
name|Statistics
name|andStats
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|pred
operator|instanceof
name|ExprNodeGenericFuncDesc
condition|)
block|{
name|ExprNodeGenericFuncDesc
name|genFunc
init|=
operator|(
name|ExprNodeGenericFuncDesc
operator|)
name|pred
decl_stmt|;
name|GenericUDF
name|udf
init|=
name|genFunc
operator|.
name|getGenericUDF
argument_list|()
decl_stmt|;
comment|// for AND condition cascadingly update stats
if|if
condition|(
name|udf
operator|instanceof
name|GenericUDFOPAnd
condition|)
block|{
name|andStats
operator|=
name|stats
operator|.
name|clone
argument_list|()
expr_stmt|;
name|aspCtx
operator|.
name|setAndExprStats
argument_list|(
name|andStats
argument_list|)
expr_stmt|;
comment|// evaluate children
for|for
control|(
name|ExprNodeDesc
name|child
range|:
name|genFunc
operator|.
name|getChildren
argument_list|()
control|)
block|{
name|newNumRows
operator|=
name|evaluateChildExpr
argument_list|(
name|aspCtx
operator|.
name|getAndExprStats
argument_list|()
argument_list|,
name|child
argument_list|,
name|aspCtx
argument_list|)
expr_stmt|;
name|updateStats
argument_list|(
name|aspCtx
operator|.
name|getAndExprStats
argument_list|()
argument_list|,
name|newNumRows
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// for OR condition independently compute and update stats
if|if
condition|(
name|udf
operator|instanceof
name|GenericUDFOPOr
condition|)
block|{
for|for
control|(
name|ExprNodeDesc
name|child
range|:
name|genFunc
operator|.
name|getChildren
argument_list|()
control|)
block|{
name|newNumRows
operator|+=
name|evaluateChildExpr
argument_list|(
name|stats
argument_list|,
name|child
argument_list|,
name|aspCtx
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|udf
operator|instanceof
name|GenericUDFOPNot
condition|)
block|{
name|newNumRows
operator|=
name|evaluateNotExpr
argument_list|(
name|stats
argument_list|,
name|pred
argument_list|,
name|aspCtx
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|udf
operator|instanceof
name|GenericUDFOPNotNull
condition|)
block|{
name|newNumRows
operator|=
name|evaluateColEqualsNullExpr
argument_list|(
name|stats
argument_list|,
name|pred
argument_list|,
name|aspCtx
argument_list|)
expr_stmt|;
name|newNumRows
operator|=
name|stats
operator|.
name|getNumRows
argument_list|()
operator|-
name|newNumRows
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|udf
operator|instanceof
name|GenericUDFOPNull
condition|)
block|{
name|newNumRows
operator|=
name|evaluateColEqualsNullExpr
argument_list|(
name|stats
argument_list|,
name|pred
argument_list|,
name|aspCtx
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// single predicate condition
name|newNumRows
operator|=
name|evaluateChildExpr
argument_list|(
name|stats
argument_list|,
name|pred
argument_list|,
name|aspCtx
argument_list|)
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|pred
operator|instanceof
name|ExprNodeColumnDesc
condition|)
block|{
comment|// can be boolean column in which case return true count
name|ExprNodeColumnDesc
name|encd
init|=
operator|(
name|ExprNodeColumnDesc
operator|)
name|pred
decl_stmt|;
name|String
name|colName
init|=
name|encd
operator|.
name|getColumn
argument_list|()
decl_stmt|;
name|String
name|tabAlias
init|=
name|encd
operator|.
name|getTabAlias
argument_list|()
decl_stmt|;
name|String
name|colType
init|=
name|encd
operator|.
name|getTypeString
argument_list|()
decl_stmt|;
if|if
condition|(
name|colType
operator|.
name|equalsIgnoreCase
argument_list|(
name|serdeConstants
operator|.
name|BOOLEAN_TYPE_NAME
argument_list|)
condition|)
block|{
name|ColStatistics
name|cs
init|=
name|stats
operator|.
name|getColumnStatisticsForColumn
argument_list|(
name|tabAlias
argument_list|,
name|colName
argument_list|)
decl_stmt|;
return|return
name|cs
operator|.
name|getNumTrues
argument_list|()
return|;
block|}
else|else
block|{
comment|// if not boolean column return half the number of rows
return|return
name|stats
operator|.
name|getNumRows
argument_list|()
operator|/
literal|2
return|;
block|}
block|}
return|return
name|newNumRows
return|;
block|}
specifier|private
name|long
name|evaluateNotExpr
parameter_list|(
name|Statistics
name|stats
parameter_list|,
name|ExprNodeDesc
name|pred
parameter_list|,
name|AnnotateStatsProcCtx
name|aspCtx
parameter_list|)
throws|throws
name|CloneNotSupportedException
block|{
name|long
name|numRows
init|=
name|stats
operator|.
name|getNumRows
argument_list|()
decl_stmt|;
comment|// if the evaluate yields true then pass all rows else pass 0 rows
if|if
condition|(
name|pred
operator|instanceof
name|ExprNodeGenericFuncDesc
condition|)
block|{
name|ExprNodeGenericFuncDesc
name|genFunc
init|=
operator|(
name|ExprNodeGenericFuncDesc
operator|)
name|pred
decl_stmt|;
for|for
control|(
name|ExprNodeDesc
name|leaf
range|:
name|genFunc
operator|.
name|getChildren
argument_list|()
control|)
block|{
if|if
condition|(
name|leaf
operator|instanceof
name|ExprNodeGenericFuncDesc
condition|)
block|{
comment|// GenericUDF
name|long
name|newNumRows
init|=
literal|0
decl_stmt|;
for|for
control|(
name|ExprNodeDesc
name|child
range|:
operator|(
operator|(
name|ExprNodeGenericFuncDesc
operator|)
name|pred
operator|)
operator|.
name|getChildren
argument_list|()
control|)
block|{
name|newNumRows
operator|=
name|evaluateChildExpr
argument_list|(
name|stats
argument_list|,
name|child
argument_list|,
name|aspCtx
argument_list|)
expr_stmt|;
block|}
return|return
name|numRows
operator|-
name|newNumRows
return|;
block|}
elseif|else
if|if
condition|(
name|leaf
operator|instanceof
name|ExprNodeConstantDesc
condition|)
block|{
name|ExprNodeConstantDesc
name|encd
init|=
operator|(
name|ExprNodeConstantDesc
operator|)
name|leaf
decl_stmt|;
if|if
condition|(
name|encd
operator|.
name|getValue
argument_list|()
operator|.
name|equals
argument_list|(
literal|true
argument_list|)
condition|)
block|{
return|return
literal|0
return|;
block|}
else|else
block|{
return|return
name|numRows
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|leaf
operator|instanceof
name|ExprNodeColumnDesc
condition|)
block|{
comment|// NOT on boolean columns is possible. in which case return false count.
name|ExprNodeColumnDesc
name|encd
init|=
operator|(
name|ExprNodeColumnDesc
operator|)
name|leaf
decl_stmt|;
name|String
name|colName
init|=
name|encd
operator|.
name|getColumn
argument_list|()
decl_stmt|;
name|String
name|tabAlias
init|=
name|encd
operator|.
name|getTabAlias
argument_list|()
decl_stmt|;
name|String
name|colType
init|=
name|encd
operator|.
name|getTypeString
argument_list|()
decl_stmt|;
if|if
condition|(
name|colType
operator|.
name|equalsIgnoreCase
argument_list|(
name|serdeConstants
operator|.
name|BOOLEAN_TYPE_NAME
argument_list|)
condition|)
block|{
name|ColStatistics
name|cs
init|=
name|stats
operator|.
name|getColumnStatisticsForColumn
argument_list|(
name|tabAlias
argument_list|,
name|colName
argument_list|)
decl_stmt|;
return|return
name|cs
operator|.
name|getNumFalses
argument_list|()
return|;
block|}
else|else
block|{
comment|// if not boolean column return half the number of rows
return|return
name|numRows
operator|/
literal|2
return|;
block|}
block|}
block|}
block|}
comment|// worst case
return|return
name|numRows
return|;
block|}
specifier|private
name|long
name|evaluateColEqualsNullExpr
parameter_list|(
name|Statistics
name|stats
parameter_list|,
name|ExprNodeDesc
name|pred
parameter_list|,
name|AnnotateStatsProcCtx
name|aspCtx
parameter_list|)
block|{
name|long
name|numRows
init|=
name|stats
operator|.
name|getNumRows
argument_list|()
decl_stmt|;
comment|// evaluate similar to "col = constant" expr
if|if
condition|(
name|pred
operator|instanceof
name|ExprNodeGenericFuncDesc
condition|)
block|{
name|ExprNodeGenericFuncDesc
name|genFunc
init|=
operator|(
name|ExprNodeGenericFuncDesc
operator|)
name|pred
decl_stmt|;
for|for
control|(
name|ExprNodeDesc
name|leaf
range|:
name|genFunc
operator|.
name|getChildren
argument_list|()
control|)
block|{
if|if
condition|(
name|leaf
operator|instanceof
name|ExprNodeColumnDesc
condition|)
block|{
name|ExprNodeColumnDesc
name|colDesc
init|=
operator|(
name|ExprNodeColumnDesc
operator|)
name|leaf
decl_stmt|;
name|String
name|colName
init|=
name|colDesc
operator|.
name|getColumn
argument_list|()
decl_stmt|;
name|String
name|tabAlias
init|=
name|colDesc
operator|.
name|getTabAlias
argument_list|()
decl_stmt|;
name|ColStatistics
name|cs
init|=
name|stats
operator|.
name|getColumnStatisticsForColumn
argument_list|(
name|tabAlias
argument_list|,
name|colName
argument_list|)
decl_stmt|;
if|if
condition|(
name|cs
operator|!=
literal|null
condition|)
block|{
name|long
name|dvs
init|=
name|cs
operator|.
name|getCountDistint
argument_list|()
decl_stmt|;
comment|// if NULLs exists, add 1 to distinct count
if|if
condition|(
name|cs
operator|.
name|getNumNulls
argument_list|()
operator|>
literal|0
condition|)
block|{
name|dvs
operator|+=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|dvs
operator|!=
literal|0
condition|)
block|{
return|return
name|numRows
operator|/
name|dvs
return|;
block|}
else|else
block|{
return|return
name|numRows
return|;
block|}
block|}
block|}
block|}
block|}
comment|// worst case
return|return
name|numRows
return|;
block|}
specifier|private
name|long
name|evaluateChildExpr
parameter_list|(
name|Statistics
name|stats
parameter_list|,
name|ExprNodeDesc
name|child
parameter_list|,
name|AnnotateStatsProcCtx
name|aspCtx
parameter_list|)
throws|throws
name|CloneNotSupportedException
block|{
name|long
name|numRows
init|=
name|stats
operator|.
name|getNumRows
argument_list|()
decl_stmt|;
if|if
condition|(
name|child
operator|instanceof
name|ExprNodeGenericFuncDesc
condition|)
block|{
name|ExprNodeGenericFuncDesc
name|genFunc
init|=
operator|(
name|ExprNodeGenericFuncDesc
operator|)
name|child
decl_stmt|;
name|GenericUDF
name|udf
init|=
name|genFunc
operator|.
name|getGenericUDF
argument_list|()
decl_stmt|;
if|if
condition|(
name|udf
operator|instanceof
name|GenericUDFOPEqual
operator|||
name|udf
operator|instanceof
name|GenericUDFOPEqualNS
condition|)
block|{
name|String
name|colName
init|=
literal|null
decl_stmt|;
name|String
name|tabAlias
init|=
literal|null
decl_stmt|;
name|boolean
name|isConst
init|=
literal|false
decl_stmt|;
for|for
control|(
name|ExprNodeDesc
name|leaf
range|:
name|genFunc
operator|.
name|getChildren
argument_list|()
control|)
block|{
if|if
condition|(
name|leaf
operator|instanceof
name|ExprNodeConstantDesc
condition|)
block|{
comment|// if the first argument is const then just set the flag and continue
if|if
condition|(
name|colName
operator|==
literal|null
condition|)
block|{
name|isConst
operator|=
literal|true
expr_stmt|;
continue|continue;
block|}
name|ColStatistics
name|cs
init|=
name|stats
operator|.
name|getColumnStatisticsForColumn
argument_list|(
name|tabAlias
argument_list|,
name|colName
argument_list|)
decl_stmt|;
if|if
condition|(
name|cs
operator|!=
literal|null
condition|)
block|{
name|long
name|dvs
init|=
name|cs
operator|.
name|getCountDistint
argument_list|()
decl_stmt|;
comment|// if NULLs exists, add 1 to distinct count
if|if
condition|(
name|cs
operator|.
name|getNumNulls
argument_list|()
operator|>
literal|0
condition|)
block|{
name|dvs
operator|+=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|dvs
operator|!=
literal|0
condition|)
block|{
return|return
name|numRows
operator|/
name|dvs
return|;
block|}
else|else
block|{
return|return
name|numRows
return|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|leaf
operator|instanceof
name|ExprNodeColumnDesc
condition|)
block|{
name|ExprNodeColumnDesc
name|colDesc
init|=
operator|(
name|ExprNodeColumnDesc
operator|)
name|leaf
decl_stmt|;
name|colName
operator|=
name|colDesc
operator|.
name|getColumn
argument_list|()
expr_stmt|;
name|tabAlias
operator|=
name|colDesc
operator|.
name|getTabAlias
argument_list|()
expr_stmt|;
comment|// if const is first argument then evaluate the result
if|if
condition|(
name|isConst
condition|)
block|{
name|ColStatistics
name|cs
init|=
name|stats
operator|.
name|getColumnStatisticsForColumn
argument_list|(
name|tabAlias
argument_list|,
name|colName
argument_list|)
decl_stmt|;
if|if
condition|(
name|cs
operator|!=
literal|null
condition|)
block|{
name|long
name|dvs
init|=
name|cs
operator|.
name|getCountDistint
argument_list|()
decl_stmt|;
comment|// if NULLs exists, add 1 to distinct count
if|if
condition|(
name|cs
operator|.
name|getNumNulls
argument_list|()
operator|>
literal|0
condition|)
block|{
name|dvs
operator|+=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|dvs
operator|!=
literal|0
condition|)
block|{
return|return
name|numRows
operator|/
name|dvs
return|;
block|}
else|else
block|{
return|return
name|numRows
return|;
block|}
block|}
block|}
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|udf
operator|instanceof
name|GenericUDFOPNotEqual
condition|)
block|{
return|return
name|numRows
return|;
block|}
elseif|else
if|if
condition|(
name|udf
operator|instanceof
name|GenericUDFOPEqualOrGreaterThan
operator|||
name|udf
operator|instanceof
name|GenericUDFOPEqualOrLessThan
operator|||
name|udf
operator|instanceof
name|GenericUDFOPGreaterThan
operator|||
name|udf
operator|instanceof
name|GenericUDFOPLessThan
condition|)
block|{
return|return
name|numRows
operator|/
literal|3
return|;
block|}
else|else
block|{
return|return
name|evaluateExpression
argument_list|(
name|stats
argument_list|,
name|genFunc
argument_list|,
name|aspCtx
argument_list|)
return|;
block|}
block|}
comment|// worst case
return|return
name|numRows
return|;
block|}
block|}
comment|/**    * GROUPBY operator changes the number of rows. The number of rows emitted    * by GBY operator will be atleast 1 or utmost T(R) (number of rows in relation T)    * based on the aggregation. A better estimate can be found if we have column statistics    * on the columns that we are grouping on.    *<p>    * Suppose if we are grouping by attributes A,B,C and if statistics for columns A,B,C are    * available then a better estimate can be found by taking the smaller of product of V(R,[A,B,C])    * (product of distinct cardinalities of A,B,C) and T(R)/2.    *<p>    * T(R) = min (T(R)/2 , V(R,[A,B,C]) ---> [1]    *    *<p>    * In the presence of grouping sets, map-side GBY will emit more rows depending on the size of    * grouping set (input rows * size of grouping set). These rows will get reduced because of    * map-side hash aggregation. Hash aggregation is an optimization in hive to reduce the number of    * rows shuffled between map and reduce stage. This optimization will be disabled if the memory    * used for hash aggregation exceeds 90% of max available memory for hash aggregation. The number    * of rows emitted from map-side will vary if hash aggregation is enabled throughout execution or    * disabled. In the presence of grouping sets, following rules will be applied    *<p>    * If<b>hash-aggregation is enabled</b>, for query SELECT * FROM table GROUP BY (A,B) WITH CUBE    *<p>    * T(R) = min(T(R)/2, T(R, GBY(A,B)) + T(R, GBY(A)) + T(R, GBY(B)) + 1))    *<p>    * where, GBY(A,B), GBY(B), GBY(B) are the GBY rules mentioned above [1]    *    *<p>    * If<b>hash-aggregation is disabled</b>, apply the GBY rule [1] and then multiply the result by    * number of elements in grouping set T(R) = T(R) * length_of_grouping_set. Since we do not know    * if hash-aggregation is enabled or disabled during compile time, we will assume worst-case i.e,    * hash-aggregation is disabled    *    *<p>    * NOTE: The number of rows from map-side GBY operator is dependent on map-side parallelism i.e,    * number of mappers. The map-side parallelism is expected from hive config    * "hive.stats.map.parallelism". If the config is not set then default parallelism of 1 will be    * assumed.    *    *<p>    *<i>For more information, refer 'Estimating The Cost Of Operations' chapter in    * "Database Systems: The Complete Book" by Garcia-Molina et. al.</i>    *</p>    *    */
specifier|public
specifier|static
class|class
name|GroupByStatsRule
extends|extends
name|DefaultStatsRule
implements|implements
name|NodeProcessor
block|{
annotation|@
name|Override
specifier|public
name|Object
name|process
parameter_list|(
name|Node
name|nd
parameter_list|,
name|Stack
argument_list|<
name|Node
argument_list|>
name|stack
parameter_list|,
name|NodeProcessorCtx
name|procCtx
parameter_list|,
name|Object
modifier|...
name|nodeOutputs
parameter_list|)
throws|throws
name|SemanticException
block|{
name|GroupByOperator
name|gop
init|=
operator|(
name|GroupByOperator
operator|)
name|nd
decl_stmt|;
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
name|parent
init|=
name|gop
operator|.
name|getParentOperators
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|Statistics
name|parentStats
init|=
name|parent
operator|.
name|getStatistics
argument_list|()
decl_stmt|;
name|AnnotateStatsProcCtx
name|aspCtx
init|=
operator|(
name|AnnotateStatsProcCtx
operator|)
name|procCtx
decl_stmt|;
name|HiveConf
name|conf
init|=
name|aspCtx
operator|.
name|getConf
argument_list|()
decl_stmt|;
name|int
name|mapSideParallelism
init|=
name|HiveConf
operator|.
name|getIntVar
argument_list|(
name|conf
argument_list|,
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVE_STATS_MAP_SIDE_PARALLELISM
argument_list|)
decl_stmt|;
try|try
block|{
if|if
condition|(
name|satisfyPrecondition
argument_list|(
name|parentStats
argument_list|)
condition|)
block|{
name|Statistics
name|stats
init|=
name|parentStats
operator|.
name|clone
argument_list|()
decl_stmt|;
name|RowSchema
name|rs
init|=
name|gop
operator|.
name|getSchema
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|AggregationDesc
argument_list|>
name|aggDesc
init|=
name|gop
operator|.
name|getConf
argument_list|()
operator|.
name|getAggregators
argument_list|()
decl_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|ExprNodeDesc
argument_list|>
name|colExprMap
init|=
name|gop
operator|.
name|getColumnExprMap
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|ColStatistics
argument_list|>
name|colStats
init|=
name|StatsUtils
operator|.
name|getColStatisticsFromExprMap
argument_list|(
name|conf
argument_list|,
name|parentStats
argument_list|,
name|colExprMap
argument_list|,
name|rs
argument_list|)
decl_stmt|;
name|stats
operator|.
name|setColumnStats
argument_list|(
name|colStats
argument_list|)
expr_stmt|;
name|long
name|dvProd
init|=
literal|1
decl_stmt|;
name|long
name|newNumRows
init|=
literal|0
decl_stmt|;
comment|// compute product of distinct values of grouping columns
for|for
control|(
name|ColStatistics
name|cs
range|:
name|colStats
control|)
block|{
if|if
condition|(
name|cs
operator|!=
literal|null
condition|)
block|{
name|long
name|dv
init|=
name|cs
operator|.
name|getCountDistint
argument_list|()
decl_stmt|;
if|if
condition|(
name|cs
operator|.
name|getNumNulls
argument_list|()
operator|>
literal|0
condition|)
block|{
name|dv
operator|+=
literal|1
expr_stmt|;
block|}
name|dvProd
operator|*=
name|dv
expr_stmt|;
block|}
block|}
comment|// map side
if|if
condition|(
name|gop
operator|.
name|getChildOperators
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|instanceof
name|ReduceSinkOperator
condition|)
block|{
comment|// since we do not know if hash-aggregation will be enabled or disabled
comment|// at runtime we will assume that map-side group by does not do any reduction.
comment|// hence no group by rule will be applied
comment|// map-side grouping set present. if grouping set is present then
comment|// multiply the number of rows by number of elements in grouping set
if|if
condition|(
name|gop
operator|.
name|getConf
argument_list|()
operator|.
name|isGroupingSetsPresent
argument_list|()
condition|)
block|{
name|int
name|multiplier
init|=
name|gop
operator|.
name|getConf
argument_list|()
operator|.
name|getListGroupingSets
argument_list|()
operator|.
name|size
argument_list|()
decl_stmt|;
comment|// take into account the map-side parallelism as well, default is 1
name|multiplier
operator|*=
name|mapSideParallelism
expr_stmt|;
name|newNumRows
operator|=
name|multiplier
operator|*
name|stats
operator|.
name|getNumRows
argument_list|()
expr_stmt|;
name|long
name|dataSize
init|=
name|multiplier
operator|*
name|stats
operator|.
name|getDataSize
argument_list|()
decl_stmt|;
name|stats
operator|.
name|setNumRows
argument_list|(
name|newNumRows
argument_list|)
expr_stmt|;
name|stats
operator|.
name|setDataSize
argument_list|(
name|dataSize
argument_list|)
expr_stmt|;
for|for
control|(
name|ColStatistics
name|cs
range|:
name|colStats
control|)
block|{
if|if
condition|(
name|cs
operator|!=
literal|null
condition|)
block|{
name|long
name|oldNumNulls
init|=
name|cs
operator|.
name|getNumNulls
argument_list|()
decl_stmt|;
name|long
name|newNumNulls
init|=
name|multiplier
operator|*
name|oldNumNulls
decl_stmt|;
name|cs
operator|.
name|setNumNulls
argument_list|(
name|newNumNulls
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
comment|// map side no grouping set
name|newNumRows
operator|=
name|stats
operator|.
name|getNumRows
argument_list|()
operator|*
name|mapSideParallelism
expr_stmt|;
name|updateStats
argument_list|(
name|stats
argument_list|,
name|newNumRows
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// reduce side
name|newNumRows
operator|=
name|applyGBYRule
argument_list|(
name|stats
operator|.
name|getNumRows
argument_list|()
argument_list|,
name|dvProd
argument_list|)
expr_stmt|;
name|updateStats
argument_list|(
name|stats
argument_list|,
name|newNumRows
argument_list|)
expr_stmt|;
block|}
comment|// if UDAFs are present, new columns needs to be added
if|if
condition|(
operator|!
name|aggDesc
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|List
argument_list|<
name|ColStatistics
argument_list|>
name|aggColStats
init|=
name|Lists
operator|.
name|newArrayList
argument_list|()
decl_stmt|;
for|for
control|(
name|ColumnInfo
name|ci
range|:
name|rs
operator|.
name|getSignature
argument_list|()
control|)
block|{
comment|// if the columns in row schema is not contained in column
comment|// expression map, then those are the aggregate columns that
comment|// are added GBY operator. we will estimate the column statistics
comment|// for those newly added columns
if|if
condition|(
operator|!
name|colExprMap
operator|.
name|containsKey
argument_list|(
name|ci
operator|.
name|getInternalName
argument_list|()
argument_list|)
condition|)
block|{
name|String
name|colName
init|=
name|ci
operator|.
name|getInternalName
argument_list|()
decl_stmt|;
name|colName
operator|=
name|StatsUtils
operator|.
name|stripPrefixFromColumnName
argument_list|(
name|colName
argument_list|)
expr_stmt|;
name|String
name|tabAlias
init|=
name|ci
operator|.
name|getTabAlias
argument_list|()
decl_stmt|;
name|String
name|colType
init|=
name|ci
operator|.
name|getTypeName
argument_list|()
decl_stmt|;
name|ColStatistics
name|cs
init|=
operator|new
name|ColStatistics
argument_list|(
name|tabAlias
argument_list|,
name|colName
argument_list|,
name|colType
argument_list|)
decl_stmt|;
name|cs
operator|.
name|setCountDistint
argument_list|(
name|stats
operator|.
name|getNumRows
argument_list|()
argument_list|)
expr_stmt|;
name|cs
operator|.
name|setNumNulls
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|cs
operator|.
name|setAvgColLen
argument_list|(
name|StatsUtils
operator|.
name|getAvgColLenOfFixedLengthTypes
argument_list|(
name|colType
argument_list|)
argument_list|)
expr_stmt|;
name|aggColStats
operator|.
name|add
argument_list|(
name|cs
argument_list|)
expr_stmt|;
block|}
block|}
name|stats
operator|.
name|addToColumnStats
argument_list|(
name|aggColStats
argument_list|)
expr_stmt|;
comment|// if UDAF present and if column expression map is empty then it must
comment|// be full aggregation query like count(*) in which case number of rows will be 1
if|if
condition|(
name|colExprMap
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|stats
operator|.
name|setNumRows
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|updateStats
argument_list|(
name|stats
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
name|gop
operator|.
name|setStatistics
argument_list|(
name|stats
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|parentStats
operator|!=
literal|null
condition|)
block|{
name|gop
operator|.
name|setStatistics
argument_list|(
name|parentStats
operator|.
name|clone
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
catch|catch
parameter_list|(
name|CloneNotSupportedException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|STATISTICS_CLONING_FAILED
operator|.
name|getMsg
argument_list|()
argument_list|)
throw|;
block|}
return|return
literal|null
return|;
block|}
specifier|private
name|long
name|applyGBYRule
parameter_list|(
name|long
name|numRows
parameter_list|,
name|long
name|dvProd
parameter_list|)
block|{
name|long
name|newNumRows
init|=
name|numRows
decl_stmt|;
comment|// to avoid divide by 2 to become 0
if|if
condition|(
name|numRows
operator|>
literal|1
condition|)
block|{
if|if
condition|(
name|dvProd
operator|!=
literal|0
condition|)
block|{
name|newNumRows
operator|=
name|Math
operator|.
name|min
argument_list|(
name|numRows
operator|/
literal|2
argument_list|,
name|dvProd
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|newNumRows
operator|=
name|numRows
operator|/
literal|2
expr_stmt|;
block|}
block|}
return|return
name|newNumRows
return|;
block|}
block|}
comment|/**    * JOIN operator can yield any of the following three cases<li>The values of join keys are    * disjoint in both relations in which case T(RXS) = 0 (we need histograms for this)</li><li>Join    * key is primary key on relation R and foreign key on relation S in which case every tuple in S    * will have a tuple in R T(RXS) = T(S) (we need histograms for this)</li><li>Both R& S relation    * have same value for join-key. Ex: bool column with all true values T(RXS) = T(R) * T(S) (we    * need histograms for this. counDistinct = 1 and same value)</li>    *    *<p>    * In the absence of histograms, we can use the following general case    *<p>    *<b>Single attribute</b>    *<p>    * T(RXS) = (T(R)*T(S))/max(V(R,Y), V(S,Y)) where Y is the join attribute    *<p>    *<b>Multiple attributes</b>    *<p>    * T(RXS) = T(R)*T(S)/max(V(R,y1), V(S,y1)) * max(V(R,y2), V(S,y2)), where y1 and y2 are the join    * attributes    *    *<p>    *<i>For more information, refer 'Estimating The Cost Of Operations' chapter in    * "Database Systems: The Complete Book" by Garcia-Molina et. al.</i>    *</p>    */
specifier|public
specifier|static
class|class
name|JoinStatsRule
extends|extends
name|DefaultStatsRule
implements|implements
name|NodeProcessor
block|{
annotation|@
name|Override
specifier|public
name|Object
name|process
parameter_list|(
name|Node
name|nd
parameter_list|,
name|Stack
argument_list|<
name|Node
argument_list|>
name|stack
parameter_list|,
name|NodeProcessorCtx
name|procCtx
parameter_list|,
name|Object
modifier|...
name|nodeOutputs
parameter_list|)
throws|throws
name|SemanticException
block|{
name|CommonJoinOperator
argument_list|<
name|?
extends|extends
name|JoinDesc
argument_list|>
name|jop
init|=
operator|(
name|CommonJoinOperator
argument_list|<
name|?
extends|extends
name|JoinDesc
argument_list|>
operator|)
name|nd
decl_stmt|;
name|List
argument_list|<
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
argument_list|>
name|parents
init|=
name|jop
operator|.
name|getParentOperators
argument_list|()
decl_stmt|;
name|AnnotateStatsProcCtx
name|aspCtx
init|=
operator|(
name|AnnotateStatsProcCtx
operator|)
name|procCtx
decl_stmt|;
name|HiveConf
name|conf
init|=
name|aspCtx
operator|.
name|getConf
argument_list|()
decl_stmt|;
name|boolean
name|allStatsAvail
init|=
literal|true
decl_stmt|;
name|boolean
name|allSatisfyPreCondition
init|=
literal|true
decl_stmt|;
for|for
control|(
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
name|op
range|:
name|parents
control|)
block|{
if|if
condition|(
name|op
operator|.
name|getStatistics
argument_list|()
operator|==
literal|null
condition|)
block|{
name|allStatsAvail
operator|=
literal|false
expr_stmt|;
block|}
block|}
if|if
condition|(
name|allStatsAvail
condition|)
block|{
for|for
control|(
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
name|op
range|:
name|parents
control|)
block|{
if|if
condition|(
operator|!
name|satisfyPrecondition
argument_list|(
name|op
operator|.
name|getStatistics
argument_list|()
argument_list|)
condition|)
block|{
name|allSatisfyPreCondition
operator|=
literal|false
expr_stmt|;
block|}
block|}
if|if
condition|(
name|allSatisfyPreCondition
condition|)
block|{
comment|// statistics object that is combination of statistics from all relations involved in JOIN
name|Statistics
name|stats
init|=
operator|new
name|Statistics
argument_list|()
decl_stmt|;
name|long
name|prodRows
init|=
literal|1
decl_stmt|;
name|List
argument_list|<
name|Long
argument_list|>
name|distinctVals
init|=
name|Lists
operator|.
name|newArrayList
argument_list|()
decl_stmt|;
name|boolean
name|multiAttr
init|=
literal|false
decl_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|ColStatistics
argument_list|>
name|joinedColStats
init|=
name|Maps
operator|.
name|newHashMap
argument_list|()
decl_stmt|;
name|Map
argument_list|<
name|Integer
argument_list|,
name|List
argument_list|<
name|String
argument_list|>
argument_list|>
name|joinKeys
init|=
name|Maps
operator|.
name|newHashMap
argument_list|()
decl_stmt|;
comment|// get the join keys from parent ReduceSink operators
for|for
control|(
name|int
name|pos
init|=
literal|0
init|;
name|pos
operator|<
name|parents
operator|.
name|size
argument_list|()
condition|;
name|pos
operator|++
control|)
block|{
name|ReduceSinkOperator
name|parent
init|=
operator|(
name|ReduceSinkOperator
operator|)
name|jop
operator|.
name|getParentOperators
argument_list|()
operator|.
name|get
argument_list|(
name|pos
argument_list|)
decl_stmt|;
name|Statistics
name|parentStats
init|=
name|parent
operator|.
name|getStatistics
argument_list|()
decl_stmt|;
name|prodRows
operator|*=
name|parentStats
operator|.
name|getNumRows
argument_list|()
expr_stmt|;
name|List
argument_list|<
name|ExprNodeDesc
argument_list|>
name|keyExprs
init|=
name|parent
operator|.
name|getConf
argument_list|()
operator|.
name|getKeyCols
argument_list|()
decl_stmt|;
comment|// multi-attribute join key
if|if
condition|(
name|keyExprs
operator|.
name|size
argument_list|()
operator|>
literal|1
condition|)
block|{
name|multiAttr
operator|=
literal|true
expr_stmt|;
block|}
comment|// compute fully qualified join key column names. this name will be used to
comment|// quickly look-up for column statistics of join key.
comment|// TODO: expressions in join condition will be ignored. assign internal name
comment|// for expressions and estimate column statistics for expression.
name|List
argument_list|<
name|String
argument_list|>
name|fqCols
init|=
name|StatsUtils
operator|.
name|getFullQualifedColNameFromExprs
argument_list|(
name|keyExprs
argument_list|,
name|parent
operator|.
name|getColumnExprMap
argument_list|()
argument_list|)
decl_stmt|;
name|joinKeys
operator|.
name|put
argument_list|(
name|pos
argument_list|,
name|fqCols
argument_list|)
expr_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|ExprNodeDesc
argument_list|>
name|colExprMap
init|=
name|parent
operator|.
name|getColumnExprMap
argument_list|()
decl_stmt|;
name|RowSchema
name|rs
init|=
name|parent
operator|.
name|getSchema
argument_list|()
decl_stmt|;
comment|// get column statistics for all output columns
name|List
argument_list|<
name|ColStatistics
argument_list|>
name|cs
init|=
name|StatsUtils
operator|.
name|getColStatisticsFromExprMap
argument_list|(
name|conf
argument_list|,
name|parentStats
argument_list|,
name|colExprMap
argument_list|,
name|rs
argument_list|)
decl_stmt|;
for|for
control|(
name|ColStatistics
name|c
range|:
name|cs
control|)
block|{
if|if
condition|(
name|c
operator|!=
literal|null
condition|)
block|{
name|joinedColStats
operator|.
name|put
argument_list|(
name|c
operator|.
name|getFullyQualifiedColName
argument_list|()
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
block|}
comment|// since new statistics is derived from all relations involved in JOIN,
comment|// we need to update the state information accordingly
name|stats
operator|.
name|updateBasicStatsState
argument_list|(
name|parentStats
operator|.
name|getBasicStatsState
argument_list|()
argument_list|)
expr_stmt|;
name|stats
operator|.
name|updateColumnStatsState
argument_list|(
name|parentStats
operator|.
name|getColumnStatsState
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// compute denominator i.e, max(V(R,Y), V(S,Y)) in case of single attribute join.
comment|// else max(V(R,y1), V(S,y1)) * max(V(R,y2), V(S,y2)) in case of multi-attribute join
name|long
name|denom
init|=
literal|1
decl_stmt|;
if|if
condition|(
name|multiAttr
condition|)
block|{
name|List
argument_list|<
name|Long
argument_list|>
name|perAttrDVs
init|=
name|Lists
operator|.
name|newArrayList
argument_list|()
decl_stmt|;
name|int
name|numAttr
init|=
name|joinKeys
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|size
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|idx
init|=
literal|0
init|;
name|idx
operator|<
name|numAttr
condition|;
name|idx
operator|++
control|)
block|{
for|for
control|(
name|Integer
name|i
range|:
name|joinKeys
operator|.
name|keySet
argument_list|()
control|)
block|{
name|String
name|col
init|=
name|joinKeys
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|get
argument_list|(
name|idx
argument_list|)
decl_stmt|;
name|ColStatistics
name|cs
init|=
name|joinedColStats
operator|.
name|get
argument_list|(
name|col
argument_list|)
decl_stmt|;
if|if
condition|(
name|cs
operator|!=
literal|null
condition|)
block|{
name|perAttrDVs
operator|.
name|add
argument_list|(
name|cs
operator|.
name|getCountDistint
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
name|distinctVals
operator|.
name|add
argument_list|(
name|getDenominator
argument_list|(
name|perAttrDVs
argument_list|)
argument_list|)
expr_stmt|;
name|perAttrDVs
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
for|for
control|(
name|Long
name|l
range|:
name|distinctVals
control|)
block|{
name|denom
operator|*=
name|l
expr_stmt|;
block|}
block|}
else|else
block|{
for|for
control|(
name|List
argument_list|<
name|String
argument_list|>
name|jkeys
range|:
name|joinKeys
operator|.
name|values
argument_list|()
control|)
block|{
for|for
control|(
name|String
name|jk
range|:
name|jkeys
control|)
block|{
name|ColStatistics
name|cs
init|=
name|joinedColStats
operator|.
name|get
argument_list|(
name|jk
argument_list|)
decl_stmt|;
if|if
condition|(
name|cs
operator|!=
literal|null
condition|)
block|{
name|distinctVals
operator|.
name|add
argument_list|(
name|cs
operator|.
name|getCountDistint
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|denom
operator|=
name|getDenominator
argument_list|(
name|distinctVals
argument_list|)
expr_stmt|;
block|}
comment|// column statistics from different sources are put together and rename
comment|// fully qualified column names based on output schema of join operator
name|Map
argument_list|<
name|String
argument_list|,
name|ExprNodeDesc
argument_list|>
name|colExprMap
init|=
name|jop
operator|.
name|getColumnExprMap
argument_list|()
decl_stmt|;
name|RowSchema
name|rs
init|=
name|jop
operator|.
name|getSchema
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|ColStatistics
argument_list|>
name|outColStats
init|=
name|Lists
operator|.
name|newArrayList
argument_list|()
decl_stmt|;
for|for
control|(
name|ColumnInfo
name|ci
range|:
name|rs
operator|.
name|getSignature
argument_list|()
control|)
block|{
name|String
name|key
init|=
name|ci
operator|.
name|getInternalName
argument_list|()
decl_stmt|;
name|ExprNodeDesc
name|end
init|=
name|colExprMap
operator|.
name|get
argument_list|(
name|key
argument_list|)
decl_stmt|;
if|if
condition|(
name|end
operator|instanceof
name|ExprNodeColumnDesc
condition|)
block|{
name|String
name|colName
init|=
operator|(
operator|(
name|ExprNodeColumnDesc
operator|)
name|end
operator|)
operator|.
name|getColumn
argument_list|()
decl_stmt|;
name|colName
operator|=
name|StatsUtils
operator|.
name|stripPrefixFromColumnName
argument_list|(
name|colName
argument_list|)
expr_stmt|;
name|String
name|tabAlias
init|=
operator|(
operator|(
name|ExprNodeColumnDesc
operator|)
name|end
operator|)
operator|.
name|getTabAlias
argument_list|()
decl_stmt|;
name|String
name|fqColName
init|=
name|StatsUtils
operator|.
name|getFullyQualifiedColumnName
argument_list|(
name|tabAlias
argument_list|,
name|colName
argument_list|)
decl_stmt|;
name|ColStatistics
name|cs
init|=
name|joinedColStats
operator|.
name|get
argument_list|(
name|fqColName
argument_list|)
decl_stmt|;
name|String
name|outColName
init|=
name|key
decl_stmt|;
name|String
name|outTabAlias
init|=
name|ci
operator|.
name|getTabAlias
argument_list|()
decl_stmt|;
name|outColName
operator|=
name|StatsUtils
operator|.
name|stripPrefixFromColumnName
argument_list|(
name|outColName
argument_list|)
expr_stmt|;
if|if
condition|(
name|cs
operator|!=
literal|null
condition|)
block|{
name|cs
operator|.
name|setColumnName
argument_list|(
name|outColName
argument_list|)
expr_stmt|;
name|cs
operator|.
name|setTableAlias
argument_list|(
name|outTabAlias
argument_list|)
expr_stmt|;
block|}
name|outColStats
operator|.
name|add
argument_list|(
name|cs
argument_list|)
expr_stmt|;
block|}
block|}
comment|// update join statistics
name|stats
operator|.
name|setColumnStats
argument_list|(
name|outColStats
argument_list|)
expr_stmt|;
name|long
name|newRowCount
init|=
name|prodRows
operator|/
name|denom
decl_stmt|;
name|stats
operator|.
name|setNumRows
argument_list|(
name|newRowCount
argument_list|)
expr_stmt|;
name|stats
operator|.
name|setDataSize
argument_list|(
name|StatsUtils
operator|.
name|getDataSizeFromColumnStats
argument_list|(
name|newRowCount
argument_list|,
name|outColStats
argument_list|)
argument_list|)
expr_stmt|;
name|jop
operator|.
name|setStatistics
argument_list|(
name|stats
argument_list|)
expr_stmt|;
block|}
block|}
return|return
literal|null
return|;
block|}
specifier|private
name|long
name|getDenominator
parameter_list|(
name|List
argument_list|<
name|Long
argument_list|>
name|distinctVals
parameter_list|)
block|{
comment|// simple join from 2 relations
comment|// denom = max(v1, v2)
if|if
condition|(
name|distinctVals
operator|.
name|size
argument_list|()
operator|<=
literal|2
condition|)
block|{
return|return
name|Collections
operator|.
name|max
argument_list|(
name|distinctVals
argument_list|)
return|;
block|}
else|else
block|{
comment|// join from multiple relations
comment|// denom = max(v1, v2) * max(v2, v3) * max(v3, v4)
name|long
name|denom
init|=
literal|1
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|distinctVals
operator|.
name|size
argument_list|()
operator|-
literal|1
condition|;
name|i
operator|++
control|)
block|{
name|long
name|v1
init|=
name|distinctVals
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|long
name|v2
init|=
name|distinctVals
operator|.
name|get
argument_list|(
name|i
operator|+
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|v1
operator|>=
name|v2
condition|)
block|{
name|denom
operator|*=
name|v1
expr_stmt|;
block|}
else|else
block|{
name|denom
operator|*=
name|v2
expr_stmt|;
block|}
block|}
return|return
name|denom
return|;
block|}
block|}
block|}
comment|/**    * LIMIT operator changes the number of rows and thereby the data size.    *    */
specifier|public
specifier|static
class|class
name|LimitStatsRule
extends|extends
name|DefaultStatsRule
implements|implements
name|NodeProcessor
block|{
annotation|@
name|Override
specifier|public
name|Object
name|process
parameter_list|(
name|Node
name|nd
parameter_list|,
name|Stack
argument_list|<
name|Node
argument_list|>
name|stack
parameter_list|,
name|NodeProcessorCtx
name|procCtx
parameter_list|,
name|Object
modifier|...
name|nodeOutputs
parameter_list|)
throws|throws
name|SemanticException
block|{
name|LimitOperator
name|lop
init|=
operator|(
name|LimitOperator
operator|)
name|nd
decl_stmt|;
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
name|parent
init|=
name|lop
operator|.
name|getParentOperators
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|Statistics
name|parentStats
init|=
name|parent
operator|.
name|getStatistics
argument_list|()
decl_stmt|;
try|try
block|{
if|if
condition|(
name|satisfyPrecondition
argument_list|(
name|parentStats
argument_list|)
condition|)
block|{
name|Statistics
name|stats
init|=
name|parentStats
operator|.
name|clone
argument_list|()
decl_stmt|;
name|long
name|limit
init|=
operator|-
literal|1
decl_stmt|;
name|limit
operator|=
name|lop
operator|.
name|getConf
argument_list|()
operator|.
name|getLimit
argument_list|()
expr_stmt|;
if|if
condition|(
name|limit
operator|==
operator|-
literal|1
condition|)
block|{
name|limit
operator|=
name|lop
operator|.
name|getConf
argument_list|()
operator|.
name|getLeastRows
argument_list|()
expr_stmt|;
block|}
comment|// if limit is greate than available rows then do not update statistics
if|if
condition|(
name|limit
operator|<=
name|parentStats
operator|.
name|getNumRows
argument_list|()
condition|)
block|{
name|updateStats
argument_list|(
name|stats
argument_list|,
name|limit
argument_list|)
expr_stmt|;
block|}
name|lop
operator|.
name|setStatistics
argument_list|(
name|stats
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|parentStats
operator|!=
literal|null
condition|)
block|{
name|lop
operator|.
name|setStatistics
argument_list|(
name|parentStats
operator|.
name|clone
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
catch|catch
parameter_list|(
name|CloneNotSupportedException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|STATISTICS_CLONING_FAILED
operator|.
name|getMsg
argument_list|()
argument_list|)
throw|;
block|}
return|return
literal|null
return|;
block|}
block|}
comment|/**    * Default rule is to aggregate the statistics from all its parent operators.    *    */
specifier|public
specifier|static
class|class
name|DefaultStatsRule
implements|implements
name|NodeProcessor
block|{
annotation|@
name|Override
specifier|public
name|Object
name|process
parameter_list|(
name|Node
name|nd
parameter_list|,
name|Stack
argument_list|<
name|Node
argument_list|>
name|stack
parameter_list|,
name|NodeProcessorCtx
name|procCtx
parameter_list|,
name|Object
modifier|...
name|nodeOutputs
parameter_list|)
throws|throws
name|SemanticException
block|{
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
name|op
init|=
operator|(
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
operator|)
name|nd
decl_stmt|;
name|OperatorDesc
name|conf
init|=
name|op
operator|.
name|getConf
argument_list|()
decl_stmt|;
if|if
condition|(
name|conf
operator|!=
literal|null
condition|)
block|{
name|Statistics
name|stats
init|=
name|conf
operator|.
name|getStatistics
argument_list|()
decl_stmt|;
if|if
condition|(
name|stats
operator|==
literal|null
condition|)
block|{
if|if
condition|(
name|op
operator|.
name|getParentOperators
argument_list|()
operator|!=
literal|null
condition|)
block|{
comment|// if parent statistics is null then that branch of the tree is not walked yet.
comment|// don't update the stats until all branches are walked
if|if
condition|(
name|isAllParentsContainStatistics
argument_list|(
name|op
argument_list|)
condition|)
block|{
name|stats
operator|=
operator|new
name|Statistics
argument_list|()
expr_stmt|;
for|for
control|(
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
name|parent
range|:
name|op
operator|.
name|getParentOperators
argument_list|()
control|)
block|{
if|if
condition|(
name|parent
operator|.
name|getStatistics
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|Statistics
name|parentStats
init|=
name|parent
operator|.
name|getStatistics
argument_list|()
decl_stmt|;
name|stats
operator|.
name|addToNumRows
argument_list|(
name|parentStats
operator|.
name|getNumRows
argument_list|()
argument_list|)
expr_stmt|;
name|stats
operator|.
name|addToDataSize
argument_list|(
name|parentStats
operator|.
name|getDataSize
argument_list|()
argument_list|)
expr_stmt|;
name|stats
operator|.
name|updateBasicStatsState
argument_list|(
name|parentStats
operator|.
name|getBasicStatsState
argument_list|()
argument_list|)
expr_stmt|;
name|stats
operator|.
name|updateColumnStatsState
argument_list|(
name|parentStats
operator|.
name|getColumnStatsState
argument_list|()
argument_list|)
expr_stmt|;
name|stats
operator|.
name|addToColumnStats
argument_list|(
name|parentStats
operator|.
name|getColumnStats
argument_list|()
argument_list|)
expr_stmt|;
name|op
operator|.
name|getConf
argument_list|()
operator|.
name|setStatistics
argument_list|(
name|stats
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
block|}
return|return
literal|null
return|;
block|}
comment|// check if all parent statistics are available
specifier|private
name|boolean
name|isAllParentsContainStatistics
parameter_list|(
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
name|op
parameter_list|)
block|{
for|for
control|(
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
name|parent
range|:
name|op
operator|.
name|getParentOperators
argument_list|()
control|)
block|{
if|if
condition|(
name|parent
operator|.
name|getStatistics
argument_list|()
operator|==
literal|null
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
return|return
literal|true
return|;
block|}
block|}
specifier|public
specifier|static
name|NodeProcessor
name|getTableScanRule
parameter_list|()
block|{
return|return
operator|new
name|TableScanStatsRule
argument_list|()
return|;
block|}
specifier|public
specifier|static
name|NodeProcessor
name|getSelectRule
parameter_list|()
block|{
return|return
operator|new
name|SelectStatsRule
argument_list|()
return|;
block|}
specifier|public
specifier|static
name|NodeProcessor
name|getFilterRule
parameter_list|()
block|{
return|return
operator|new
name|FilterStatsRule
argument_list|()
return|;
block|}
specifier|public
specifier|static
name|NodeProcessor
name|getGroupByRule
parameter_list|()
block|{
return|return
operator|new
name|GroupByStatsRule
argument_list|()
return|;
block|}
specifier|public
specifier|static
name|NodeProcessor
name|getJoinRule
parameter_list|()
block|{
return|return
operator|new
name|JoinStatsRule
argument_list|()
return|;
block|}
specifier|public
specifier|static
name|NodeProcessor
name|getLimitRule
parameter_list|()
block|{
return|return
operator|new
name|LimitStatsRule
argument_list|()
return|;
block|}
specifier|public
specifier|static
name|NodeProcessor
name|getDefaultRule
parameter_list|()
block|{
return|return
operator|new
name|DefaultStatsRule
argument_list|()
return|;
block|}
comment|/**    * Update the basic statistics of the statistics object based on the row number    *    * @param stats    *          - statistics to be updated    * @param newNumRows    *          - new number of rows    */
specifier|static
name|void
name|updateStats
parameter_list|(
name|Statistics
name|stats
parameter_list|,
name|long
name|newNumRows
parameter_list|)
block|{
name|long
name|oldRowCount
init|=
name|stats
operator|.
name|getNumRows
argument_list|()
decl_stmt|;
name|double
name|ratio
init|=
operator|(
name|double
operator|)
name|newNumRows
operator|/
operator|(
name|double
operator|)
name|oldRowCount
decl_stmt|;
name|stats
operator|.
name|setNumRows
argument_list|(
name|newNumRows
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|ColStatistics
argument_list|>
name|colStats
init|=
name|stats
operator|.
name|getColumnStats
argument_list|()
decl_stmt|;
for|for
control|(
name|ColStatistics
name|cs
range|:
name|colStats
control|)
block|{
name|long
name|oldNumNulls
init|=
name|cs
operator|.
name|getNumNulls
argument_list|()
decl_stmt|;
name|long
name|oldDV
init|=
name|cs
operator|.
name|getCountDistint
argument_list|()
decl_stmt|;
name|long
name|newNumNulls
init|=
name|Math
operator|.
name|round
argument_list|(
name|ratio
operator|*
name|oldNumNulls
argument_list|)
decl_stmt|;
name|long
name|newDV
init|=
name|oldDV
decl_stmt|;
comment|// if ratio is greater than 1, then number of rows increases. This can happen
comment|// when some operators like GROUPBY duplicates the input rows in which case
comment|// number of distincts should not change. Update the distinct count only when
comment|// the output number of rows is less than input number of rows.
if|if
condition|(
name|ratio
operator|<=
literal|1.0
condition|)
block|{
name|newDV
operator|=
name|Math
operator|.
name|round
argument_list|(
name|ratio
operator|*
name|oldDV
argument_list|)
expr_stmt|;
block|}
name|cs
operator|.
name|setNumNulls
argument_list|(
name|newNumNulls
argument_list|)
expr_stmt|;
name|cs
operator|.
name|setCountDistint
argument_list|(
name|newDV
argument_list|)
expr_stmt|;
block|}
name|stats
operator|.
name|setColumnStats
argument_list|(
name|colStats
argument_list|)
expr_stmt|;
name|long
name|newDataSize
init|=
name|StatsUtils
operator|.
name|getDataSizeFromColumnStats
argument_list|(
name|newNumRows
argument_list|,
name|colStats
argument_list|)
decl_stmt|;
name|stats
operator|.
name|setDataSize
argument_list|(
name|newDataSize
argument_list|)
expr_stmt|;
block|}
specifier|static
name|boolean
name|satisfyPrecondition
parameter_list|(
name|Statistics
name|stats
parameter_list|)
block|{
return|return
name|stats
operator|!=
literal|null
operator|&&
name|stats
operator|.
name|getBasicStatsState
argument_list|()
operator|.
name|equals
argument_list|(
name|Statistics
operator|.
name|State
operator|.
name|COMPLETE
argument_list|)
operator|&&
operator|!
name|stats
operator|.
name|getColumnStatsState
argument_list|()
operator|.
name|equals
argument_list|(
name|Statistics
operator|.
name|State
operator|.
name|NONE
argument_list|)
return|;
block|}
block|}
end_class

end_unit

