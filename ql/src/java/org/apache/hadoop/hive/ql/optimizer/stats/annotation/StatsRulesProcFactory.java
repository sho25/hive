begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|optimizer
operator|.
name|stats
operator|.
name|annotation
package|;
end_package

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|reflect
operator|.
name|Field
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
operator|.
name|Entry
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Stack
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|conf
operator|.
name|HiveConf
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|ErrorMsg
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|AbstractMapJoinOperator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|ColumnInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|CommonJoinOperator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|FilterOperator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|GroupByOperator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|LimitOperator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|Operator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|OperatorUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|ReduceSinkOperator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|RowSchema
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|SelectOperator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|TableScanOperator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|Utilities
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|lib
operator|.
name|Node
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|lib
operator|.
name|NodeProcessor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|lib
operator|.
name|NodeProcessorCtx
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|metadata
operator|.
name|HiveException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|metadata
operator|.
name|Table
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|parse
operator|.
name|PrunedPartitionList
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|parse
operator|.
name|SemanticException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|AggregationDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|ColStatistics
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|ExprNodeColumnDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|ExprNodeColumnListDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|ExprNodeConstantDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|ExprNodeDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|ExprNodeDesc
operator|.
name|ExprNodeDescEqualityWrapper
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|ExprNodeDescUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|ExprNodeDynamicListDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|ExprNodeFieldDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|ExprNodeGenericFuncDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|GroupByDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|JoinDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|MapJoinDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|OperatorDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|Statistics
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|stats
operator|.
name|StatsUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|udf
operator|.
name|generic
operator|.
name|GenericUDAFEvaluator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|udf
operator|.
name|generic
operator|.
name|GenericUDF
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|udf
operator|.
name|generic
operator|.
name|GenericUDFIn
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|udf
operator|.
name|generic
operator|.
name|GenericUDFOPAnd
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|udf
operator|.
name|generic
operator|.
name|GenericUDFOPEqual
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|udf
operator|.
name|generic
operator|.
name|GenericUDFOPEqualNS
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|udf
operator|.
name|generic
operator|.
name|GenericUDFOPEqualOrGreaterThan
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|udf
operator|.
name|generic
operator|.
name|GenericUDFOPEqualOrLessThan
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|udf
operator|.
name|generic
operator|.
name|GenericUDFOPGreaterThan
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|udf
operator|.
name|generic
operator|.
name|GenericUDFOPLessThan
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|udf
operator|.
name|generic
operator|.
name|GenericUDFOPNot
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|udf
operator|.
name|generic
operator|.
name|GenericUDFOPNotEqual
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|udf
operator|.
name|generic
operator|.
name|GenericUDFOPNotNull
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|udf
operator|.
name|generic
operator|.
name|GenericUDFOPNull
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|udf
operator|.
name|generic
operator|.
name|GenericUDFOPOr
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|udf
operator|.
name|generic
operator|.
name|GenericUDFStruct
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde
operator|.
name|serdeConstants
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|objectinspector
operator|.
name|ObjectInspectorUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|typeinfo
operator|.
name|StructTypeInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|typeinfo
operator|.
name|TypeInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Lists
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Maps
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Sets
import|;
end_import

begin_class
specifier|public
class|class
name|StatsRulesProcFactory
block|{
specifier|private
specifier|static
specifier|final
name|Logger
name|LOG
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|StatsRulesProcFactory
operator|.
name|class
operator|.
name|getName
argument_list|()
argument_list|)
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|boolean
name|isDebugEnabled
init|=
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
decl_stmt|;
comment|/**    * Collect basic statistics like number of rows, data size and column level statistics from the    * table. Also sets the state of the available statistics. Basic and column statistics can have    * one of the following states COMPLETE, PARTIAL, NONE. In case of partitioned table, the basic    * and column stats are aggregated together to table level statistics. Column statistics will not    * be collected if hive.stats.fetch.column.stats is set to false. If basic statistics is not    * available then number of rows will be estimated from file size and average row size (computed    * from schema).    */
specifier|public
specifier|static
class|class
name|TableScanStatsRule
extends|extends
name|DefaultStatsRule
implements|implements
name|NodeProcessor
block|{
annotation|@
name|Override
specifier|public
name|Object
name|process
parameter_list|(
name|Node
name|nd
parameter_list|,
name|Stack
argument_list|<
name|Node
argument_list|>
name|stack
parameter_list|,
name|NodeProcessorCtx
name|procCtx
parameter_list|,
name|Object
modifier|...
name|nodeOutputs
parameter_list|)
throws|throws
name|SemanticException
block|{
name|TableScanOperator
name|tsop
init|=
operator|(
name|TableScanOperator
operator|)
name|nd
decl_stmt|;
name|AnnotateStatsProcCtx
name|aspCtx
init|=
operator|(
name|AnnotateStatsProcCtx
operator|)
name|procCtx
decl_stmt|;
name|PrunedPartitionList
name|partList
init|=
name|aspCtx
operator|.
name|getParseContext
argument_list|()
operator|.
name|getPrunedPartitions
argument_list|(
name|tsop
argument_list|)
decl_stmt|;
name|Table
name|table
init|=
name|tsop
operator|.
name|getConf
argument_list|()
operator|.
name|getTableMetadata
argument_list|()
decl_stmt|;
try|try
block|{
comment|// gather statistics for the first time and the attach it to table scan operator
name|Statistics
name|stats
init|=
name|StatsUtils
operator|.
name|collectStatistics
argument_list|(
name|aspCtx
operator|.
name|getConf
argument_list|()
argument_list|,
name|partList
argument_list|,
name|table
argument_list|,
name|tsop
argument_list|)
decl_stmt|;
name|tsop
operator|.
name|setStatistics
argument_list|(
name|stats
operator|.
name|clone
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|isDebugEnabled
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"[0] STATS-"
operator|+
name|tsop
operator|.
name|toString
argument_list|()
operator|+
literal|" ("
operator|+
name|table
operator|.
name|getTableName
argument_list|()
operator|+
literal|"): "
operator|+
name|stats
operator|.
name|extendedToString
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|CloneNotSupportedException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|STATISTICS_CLONING_FAILED
operator|.
name|getMsg
argument_list|()
argument_list|)
throw|;
block|}
catch|catch
parameter_list|(
name|HiveException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Failed to retrieve stats "
argument_list|,
name|e
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|SemanticException
argument_list|(
name|e
argument_list|)
throw|;
block|}
return|return
literal|null
return|;
block|}
block|}
comment|/**    * SELECT operator doesn't change the number of rows emitted from the parent operator. It changes    * the size of each tuple emitted. In a typical case, where only subset of columns are selected    * the average row size will reduce as some of the columns will be pruned. In order to accurately    * compute the average row size, column level statistics is required. Column level statistics    * stores average size of values in column which can be used to more reliably estimate the    * reduction in size of each tuple. In the absence of column level statistics, size of columns    * will be based on data type. For primitive data types size from    * {@link org.apache.hadoop.hive.ql.util.JavaDataModel} will be used and for variable length data    * types worst case will be assumed.    *<p>    *<i>For more information, refer 'Estimating The Cost Of Operations' chapter in    * "Database Systems: The Complete Book" by Garcia-Molina et. al.</i>    *</p>    */
specifier|public
specifier|static
class|class
name|SelectStatsRule
extends|extends
name|DefaultStatsRule
implements|implements
name|NodeProcessor
block|{
annotation|@
name|Override
specifier|public
name|Object
name|process
parameter_list|(
name|Node
name|nd
parameter_list|,
name|Stack
argument_list|<
name|Node
argument_list|>
name|stack
parameter_list|,
name|NodeProcessorCtx
name|procCtx
parameter_list|,
name|Object
modifier|...
name|nodeOutputs
parameter_list|)
throws|throws
name|SemanticException
block|{
name|SelectOperator
name|sop
init|=
operator|(
name|SelectOperator
operator|)
name|nd
decl_stmt|;
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
name|parent
init|=
name|sop
operator|.
name|getParentOperators
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|Statistics
name|parentStats
init|=
name|parent
operator|.
name|getStatistics
argument_list|()
decl_stmt|;
name|AnnotateStatsProcCtx
name|aspCtx
init|=
operator|(
name|AnnotateStatsProcCtx
operator|)
name|procCtx
decl_stmt|;
name|HiveConf
name|conf
init|=
name|aspCtx
operator|.
name|getConf
argument_list|()
decl_stmt|;
name|Statistics
name|stats
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|parentStats
operator|!=
literal|null
condition|)
block|{
try|try
block|{
name|stats
operator|=
name|parentStats
operator|.
name|clone
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|CloneNotSupportedException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|STATISTICS_CLONING_FAILED
operator|.
name|getMsg
argument_list|()
argument_list|)
throw|;
block|}
block|}
try|try
block|{
if|if
condition|(
name|satisfyPrecondition
argument_list|(
name|parentStats
argument_list|)
condition|)
block|{
comment|// this will take care of mapping between input column names and output column names. The
comment|// returned column stats will have the output column names.
name|List
argument_list|<
name|ColStatistics
argument_list|>
name|colStats
init|=
name|StatsUtils
operator|.
name|getColStatisticsFromExprMap
argument_list|(
name|conf
argument_list|,
name|parentStats
argument_list|,
name|sop
operator|.
name|getColumnExprMap
argument_list|()
argument_list|,
name|sop
operator|.
name|getSchema
argument_list|()
argument_list|)
decl_stmt|;
name|stats
operator|.
name|setColumnStats
argument_list|(
name|colStats
argument_list|)
expr_stmt|;
comment|// in case of select(*) the data size does not change
if|if
condition|(
operator|!
name|sop
operator|.
name|getConf
argument_list|()
operator|.
name|isSelectStar
argument_list|()
operator|&&
operator|!
name|sop
operator|.
name|getConf
argument_list|()
operator|.
name|isSelStarNoCompute
argument_list|()
condition|)
block|{
name|long
name|dataSize
init|=
name|StatsUtils
operator|.
name|getDataSizeFromColumnStats
argument_list|(
name|stats
operator|.
name|getNumRows
argument_list|()
argument_list|,
name|colStats
argument_list|)
decl_stmt|;
name|stats
operator|.
name|setDataSize
argument_list|(
name|dataSize
argument_list|)
expr_stmt|;
block|}
name|sop
operator|.
name|setStatistics
argument_list|(
name|stats
argument_list|)
expr_stmt|;
if|if
condition|(
name|isDebugEnabled
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"[0] STATS-"
operator|+
name|sop
operator|.
name|toString
argument_list|()
operator|+
literal|": "
operator|+
name|stats
operator|.
name|extendedToString
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|parentStats
operator|!=
literal|null
condition|)
block|{
name|sop
operator|.
name|setStatistics
argument_list|(
name|parentStats
operator|.
name|clone
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|isDebugEnabled
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"[1] STATS-"
operator|+
name|sop
operator|.
name|toString
argument_list|()
operator|+
literal|": "
operator|+
name|parentStats
operator|.
name|extendedToString
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
catch|catch
parameter_list|(
name|CloneNotSupportedException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|STATISTICS_CLONING_FAILED
operator|.
name|getMsg
argument_list|()
argument_list|)
throw|;
block|}
return|return
literal|null
return|;
block|}
block|}
comment|/**    * FILTER operator does not change the average row size but it does change the number of rows    * emitted. The reduction in the number of rows emitted is dependent on the filter expression.    *<ul>    *<i>Notations:</i>    *<li>T(S) - Number of tuples in relations S</li>    *<li>V(S,A) - Number of distinct values of attribute A in relation S</li>    *</ul>    *<ul>    *<i>Rules:</i><b>    *<li>Column equals a constant</li></b> T(S) = T(R) / V(R,A)    *<p>    *<b>    *<li>Inequality conditions</li></b> T(S) = T(R) / 3    *<p>    *<b>    *<li>Not equals comparison</li></b> - Simple formula T(S) = T(R)    *<p>    * - Alternate formula T(S) = T(R) (V(R,A) - 1) / V(R,A)    *<p>    *<b>    *<li>NOT condition</li></b> T(S) = 1 - T(S'), where T(S') is the satisfying condition    *<p>    *<b>    *<li>Multiple AND conditions</li></b> Cascadingly apply the rules 1 to 3 (order doesn't matter)    *<p>    *<b>    *<li>Multiple OR conditions</li></b> - Simple formula is to evaluate conditions independently    * and sum the results T(S) = m1 + m2    *<p>    * - Alternate formula T(S) = T(R) * ( 1 - ( 1 - m1/T(R) ) * ( 1 - m2/T(R) ))    *<p>    * where, m1 is the number of tuples that satisfy condition1 and m2 is the number of tuples that    * satisfy condition2    *</ul>    *<p>    *<i>Worst case:</i> If no column statistics are available, then evaluation of predicate    * expression will assume worst case (i.e; half the input rows) for each of predicate expression.    *<p>    *<i>For more information, refer 'Estimating The Cost Of Operations' chapter in    * "Database Systems: The Complete Book" by Garcia-Molina et. al.</i>    *</p>    */
specifier|public
specifier|static
class|class
name|FilterStatsRule
extends|extends
name|DefaultStatsRule
implements|implements
name|NodeProcessor
block|{
annotation|@
name|Override
specifier|public
name|Object
name|process
parameter_list|(
name|Node
name|nd
parameter_list|,
name|Stack
argument_list|<
name|Node
argument_list|>
name|stack
parameter_list|,
name|NodeProcessorCtx
name|procCtx
parameter_list|,
name|Object
modifier|...
name|nodeOutputs
parameter_list|)
throws|throws
name|SemanticException
block|{
name|AnnotateStatsProcCtx
name|aspCtx
init|=
operator|(
name|AnnotateStatsProcCtx
operator|)
name|procCtx
decl_stmt|;
name|FilterOperator
name|fop
init|=
operator|(
name|FilterOperator
operator|)
name|nd
decl_stmt|;
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
name|parent
init|=
name|fop
operator|.
name|getParentOperators
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|Statistics
name|parentStats
init|=
name|parent
operator|.
name|getStatistics
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|neededCols
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|parent
operator|instanceof
name|TableScanOperator
condition|)
block|{
name|TableScanOperator
name|tsop
init|=
operator|(
name|TableScanOperator
operator|)
name|parent
decl_stmt|;
name|neededCols
operator|=
name|tsop
operator|.
name|getNeededColumns
argument_list|()
expr_stmt|;
block|}
try|try
block|{
if|if
condition|(
name|parentStats
operator|!=
literal|null
condition|)
block|{
name|ExprNodeDesc
name|pred
init|=
name|fop
operator|.
name|getConf
argument_list|()
operator|.
name|getPredicate
argument_list|()
decl_stmt|;
comment|// evaluate filter expression and update statistics
name|long
name|newNumRows
init|=
name|evaluateExpression
argument_list|(
name|parentStats
argument_list|,
name|pred
argument_list|,
name|aspCtx
argument_list|,
name|neededCols
argument_list|,
name|fop
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|Statistics
name|st
init|=
name|parentStats
operator|.
name|clone
argument_list|()
decl_stmt|;
if|if
condition|(
name|satisfyPrecondition
argument_list|(
name|parentStats
argument_list|)
condition|)
block|{
comment|// update statistics based on column statistics.
comment|// OR conditions keeps adding the stats independently, this may
comment|// result in number of rows getting more than the input rows in
comment|// which case stats need not be updated
if|if
condition|(
name|newNumRows
operator|<=
name|parentStats
operator|.
name|getNumRows
argument_list|()
condition|)
block|{
name|updateStats
argument_list|(
name|st
argument_list|,
name|newNumRows
argument_list|,
literal|true
argument_list|,
name|fop
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|isDebugEnabled
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"[0] STATS-"
operator|+
name|fop
operator|.
name|toString
argument_list|()
operator|+
literal|": "
operator|+
name|st
operator|.
name|extendedToString
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// update only the basic statistics in the absence of column statistics
if|if
condition|(
name|newNumRows
operator|<=
name|parentStats
operator|.
name|getNumRows
argument_list|()
condition|)
block|{
name|updateStats
argument_list|(
name|st
argument_list|,
name|newNumRows
argument_list|,
literal|false
argument_list|,
name|fop
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|isDebugEnabled
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"[1] STATS-"
operator|+
name|fop
operator|.
name|toString
argument_list|()
operator|+
literal|": "
operator|+
name|st
operator|.
name|extendedToString
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
name|fop
operator|.
name|setStatistics
argument_list|(
name|st
argument_list|)
expr_stmt|;
name|aspCtx
operator|.
name|setAndExprStats
argument_list|(
literal|null
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|CloneNotSupportedException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|STATISTICS_CLONING_FAILED
operator|.
name|getMsg
argument_list|()
argument_list|)
throw|;
block|}
return|return
literal|null
return|;
block|}
specifier|private
name|long
name|evaluateExpression
parameter_list|(
name|Statistics
name|stats
parameter_list|,
name|ExprNodeDesc
name|pred
parameter_list|,
name|AnnotateStatsProcCtx
name|aspCtx
parameter_list|,
name|List
argument_list|<
name|String
argument_list|>
name|neededCols
parameter_list|,
name|FilterOperator
name|fop
parameter_list|,
name|long
name|evaluatedRowCount
parameter_list|)
throws|throws
name|CloneNotSupportedException
throws|,
name|SemanticException
block|{
name|long
name|newNumRows
init|=
literal|0
decl_stmt|;
name|Statistics
name|andStats
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|stats
operator|.
name|getNumRows
argument_list|()
operator|<=
literal|1
operator|||
name|stats
operator|.
name|getDataSize
argument_list|()
operator|<=
literal|0
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|pred
operator|instanceof
name|ExprNodeGenericFuncDesc
condition|)
block|{
name|ExprNodeGenericFuncDesc
name|genFunc
init|=
operator|(
name|ExprNodeGenericFuncDesc
operator|)
name|pred
decl_stmt|;
name|GenericUDF
name|udf
init|=
name|genFunc
operator|.
name|getGenericUDF
argument_list|()
decl_stmt|;
comment|// for AND condition cascadingly update stats
if|if
condition|(
name|udf
operator|instanceof
name|GenericUDFOPAnd
condition|)
block|{
name|andStats
operator|=
name|stats
operator|.
name|clone
argument_list|()
expr_stmt|;
name|aspCtx
operator|.
name|setAndExprStats
argument_list|(
name|andStats
argument_list|)
expr_stmt|;
comment|// evaluate children
for|for
control|(
name|ExprNodeDesc
name|child
range|:
name|genFunc
operator|.
name|getChildren
argument_list|()
control|)
block|{
name|newNumRows
operator|=
name|evaluateChildExpr
argument_list|(
name|aspCtx
operator|.
name|getAndExprStats
argument_list|()
argument_list|,
name|child
argument_list|,
name|aspCtx
argument_list|,
name|neededCols
argument_list|,
name|fop
argument_list|,
name|evaluatedRowCount
argument_list|)
expr_stmt|;
if|if
condition|(
name|satisfyPrecondition
argument_list|(
name|aspCtx
operator|.
name|getAndExprStats
argument_list|()
argument_list|)
condition|)
block|{
name|updateStats
argument_list|(
name|aspCtx
operator|.
name|getAndExprStats
argument_list|()
argument_list|,
name|newNumRows
argument_list|,
literal|true
argument_list|,
name|fop
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|updateStats
argument_list|(
name|aspCtx
operator|.
name|getAndExprStats
argument_list|()
argument_list|,
name|newNumRows
argument_list|,
literal|false
argument_list|,
name|fop
argument_list|)
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|udf
operator|instanceof
name|GenericUDFOPOr
condition|)
block|{
comment|// for OR condition independently compute and update stats.
for|for
control|(
name|ExprNodeDesc
name|child
range|:
name|genFunc
operator|.
name|getChildren
argument_list|()
control|)
block|{
comment|// early exit if OR evaluation yields more rows than input rows
if|if
condition|(
name|evaluatedRowCount
operator|>=
name|stats
operator|.
name|getNumRows
argument_list|()
condition|)
block|{
name|evaluatedRowCount
operator|=
name|stats
operator|.
name|getNumRows
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|newNumRows
operator|=
name|StatsUtils
operator|.
name|safeAdd
argument_list|(
name|evaluateChildExpr
argument_list|(
name|stats
argument_list|,
name|child
argument_list|,
name|aspCtx
argument_list|,
name|neededCols
argument_list|,
name|fop
argument_list|,
name|evaluatedRowCount
argument_list|)
argument_list|,
name|newNumRows
argument_list|)
expr_stmt|;
name|evaluatedRowCount
operator|=
name|newNumRows
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|udf
operator|instanceof
name|GenericUDFIn
condition|)
block|{
comment|// for IN clause
name|newNumRows
operator|=
name|evaluateInExpr
argument_list|(
name|stats
argument_list|,
name|pred
argument_list|,
name|aspCtx
argument_list|,
name|neededCols
argument_list|,
name|fop
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|udf
operator|instanceof
name|GenericUDFOPNot
condition|)
block|{
name|newNumRows
operator|=
name|evaluateNotExpr
argument_list|(
name|stats
argument_list|,
name|pred
argument_list|,
name|aspCtx
argument_list|,
name|neededCols
argument_list|,
name|fop
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|udf
operator|instanceof
name|GenericUDFOPNotNull
condition|)
block|{
return|return
name|evaluateNotNullExpr
argument_list|(
name|stats
argument_list|,
name|genFunc
argument_list|)
return|;
block|}
else|else
block|{
comment|// single predicate condition
name|newNumRows
operator|=
name|evaluateChildExpr
argument_list|(
name|stats
argument_list|,
name|pred
argument_list|,
name|aspCtx
argument_list|,
name|neededCols
argument_list|,
name|fop
argument_list|,
name|evaluatedRowCount
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|pred
operator|instanceof
name|ExprNodeColumnDesc
condition|)
block|{
comment|// can be boolean column in which case return true count
name|ExprNodeColumnDesc
name|encd
init|=
operator|(
name|ExprNodeColumnDesc
operator|)
name|pred
decl_stmt|;
name|String
name|colName
init|=
name|encd
operator|.
name|getColumn
argument_list|()
decl_stmt|;
name|String
name|colType
init|=
name|encd
operator|.
name|getTypeString
argument_list|()
decl_stmt|;
if|if
condition|(
name|colType
operator|.
name|equalsIgnoreCase
argument_list|(
name|serdeConstants
operator|.
name|BOOLEAN_TYPE_NAME
argument_list|)
condition|)
block|{
name|ColStatistics
name|cs
init|=
name|stats
operator|.
name|getColumnStatisticsFromColName
argument_list|(
name|colName
argument_list|)
decl_stmt|;
if|if
condition|(
name|cs
operator|!=
literal|null
condition|)
block|{
return|return
name|cs
operator|.
name|getNumTrues
argument_list|()
return|;
block|}
block|}
comment|// if not boolean column return half the number of rows
return|return
name|stats
operator|.
name|getNumRows
argument_list|()
operator|/
literal|2
return|;
block|}
elseif|else
if|if
condition|(
name|pred
operator|instanceof
name|ExprNodeConstantDesc
condition|)
block|{
comment|// special case for handling false constants
name|ExprNodeConstantDesc
name|encd
init|=
operator|(
name|ExprNodeConstantDesc
operator|)
name|pred
decl_stmt|;
if|if
condition|(
name|Boolean
operator|.
name|FALSE
operator|.
name|equals
argument_list|(
name|encd
operator|.
name|getValue
argument_list|()
argument_list|)
condition|)
block|{
return|return
literal|0
return|;
block|}
else|else
block|{
return|return
name|stats
operator|.
name|getNumRows
argument_list|()
return|;
block|}
block|}
return|return
name|newNumRows
return|;
block|}
specifier|private
name|long
name|evaluateInExpr
parameter_list|(
name|Statistics
name|stats
parameter_list|,
name|ExprNodeDesc
name|pred
parameter_list|,
name|AnnotateStatsProcCtx
name|aspCtx
parameter_list|,
name|List
argument_list|<
name|String
argument_list|>
name|neededCols
parameter_list|,
name|FilterOperator
name|fop
parameter_list|)
throws|throws
name|SemanticException
block|{
name|long
name|numRows
init|=
name|stats
operator|.
name|getNumRows
argument_list|()
decl_stmt|;
name|ExprNodeGenericFuncDesc
name|fd
init|=
operator|(
name|ExprNodeGenericFuncDesc
operator|)
name|pred
decl_stmt|;
comment|// 1. It is an IN operator, check if it uses STRUCT
name|List
argument_list|<
name|ExprNodeDesc
argument_list|>
name|children
init|=
name|fd
operator|.
name|getChildren
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|ExprNodeDesc
argument_list|>
name|columns
init|=
name|Lists
operator|.
name|newArrayList
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|ColStatistics
argument_list|>
name|columnStats
init|=
name|Lists
operator|.
name|newArrayList
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|Set
argument_list|<
name|ExprNodeDescEqualityWrapper
argument_list|>
argument_list|>
name|values
init|=
name|Lists
operator|.
name|newArrayList
argument_list|()
decl_stmt|;
name|ExprNodeDesc
name|columnsChild
init|=
name|children
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|boolean
name|multiColumn
decl_stmt|;
if|if
condition|(
name|columnsChild
operator|instanceof
name|ExprNodeGenericFuncDesc
operator|&&
operator|(
operator|(
name|ExprNodeGenericFuncDesc
operator|)
name|columnsChild
operator|)
operator|.
name|getGenericUDF
argument_list|()
operator|instanceof
name|GenericUDFStruct
condition|)
block|{
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|columnsChild
operator|.
name|getChildren
argument_list|()
operator|.
name|size
argument_list|()
condition|;
name|j
operator|++
control|)
block|{
name|ExprNodeDesc
name|columnChild
init|=
name|columnsChild
operator|.
name|getChildren
argument_list|()
operator|.
name|get
argument_list|(
name|j
argument_list|)
decl_stmt|;
comment|// If column is not column reference , we bail out
if|if
condition|(
operator|!
operator|(
name|columnChild
operator|instanceof
name|ExprNodeColumnDesc
operator|)
condition|)
block|{
comment|// Default
return|return
name|numRows
operator|/
literal|2
return|;
block|}
name|columns
operator|.
name|add
argument_list|(
name|columnChild
argument_list|)
expr_stmt|;
specifier|final
name|String
name|columnName
init|=
operator|(
operator|(
name|ExprNodeColumnDesc
operator|)
name|columnChild
operator|)
operator|.
name|getColumn
argument_list|()
decl_stmt|;
comment|// if column name is not contained in needed column list then it
comment|// is a partition column. We do not need to evaluate partition columns
comment|// in filter expression since it will be taken care by partition pruner
if|if
condition|(
name|neededCols
operator|!=
literal|null
operator|&&
operator|!
name|neededCols
operator|.
name|contains
argument_list|(
name|columnName
argument_list|)
condition|)
block|{
comment|// Default
return|return
name|numRows
operator|/
literal|2
return|;
block|}
name|columnStats
operator|.
name|add
argument_list|(
name|stats
operator|.
name|getColumnStatisticsFromColName
argument_list|(
name|columnName
argument_list|)
argument_list|)
expr_stmt|;
name|values
operator|.
name|add
argument_list|(
name|Sets
operator|.
expr|<
name|ExprNodeDescEqualityWrapper
operator|>
name|newHashSet
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|multiColumn
operator|=
literal|true
expr_stmt|;
block|}
else|else
block|{
comment|// If column is not column reference , we bail out
if|if
condition|(
operator|!
operator|(
name|columnsChild
operator|instanceof
name|ExprNodeColumnDesc
operator|)
condition|)
block|{
comment|// Default
return|return
name|numRows
operator|/
literal|2
return|;
block|}
name|columns
operator|.
name|add
argument_list|(
name|columnsChild
argument_list|)
expr_stmt|;
specifier|final
name|String
name|columnName
init|=
operator|(
operator|(
name|ExprNodeColumnDesc
operator|)
name|columnsChild
operator|)
operator|.
name|getColumn
argument_list|()
decl_stmt|;
comment|// if column name is not contained in needed column list then it
comment|// is a partition column. We do not need to evaluate partition columns
comment|// in filter expression since it will be taken care by partition pruner
if|if
condition|(
name|neededCols
operator|!=
literal|null
operator|&&
operator|!
name|neededCols
operator|.
name|contains
argument_list|(
name|columnName
argument_list|)
condition|)
block|{
comment|// Default
return|return
name|numRows
operator|/
literal|2
return|;
block|}
name|columnStats
operator|.
name|add
argument_list|(
name|stats
operator|.
name|getColumnStatisticsFromColName
argument_list|(
name|columnName
argument_list|)
argument_list|)
expr_stmt|;
name|values
operator|.
name|add
argument_list|(
name|Sets
operator|.
expr|<
name|ExprNodeDescEqualityWrapper
operator|>
name|newHashSet
argument_list|()
argument_list|)
expr_stmt|;
name|multiColumn
operator|=
literal|false
expr_stmt|;
block|}
comment|// 2. Extract columns and values
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<
name|children
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|ExprNodeDesc
name|child
init|=
name|children
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
comment|// If value is not a constant, we bail out
if|if
condition|(
operator|!
operator|(
name|child
operator|instanceof
name|ExprNodeConstantDesc
operator|)
condition|)
block|{
comment|// Default
return|return
name|numRows
operator|/
literal|2
return|;
block|}
if|if
condition|(
name|multiColumn
condition|)
block|{
name|ExprNodeConstantDesc
name|constantChild
init|=
operator|(
name|ExprNodeConstantDesc
operator|)
name|child
decl_stmt|;
name|List
argument_list|<
name|?
argument_list|>
name|items
init|=
operator|(
name|List
argument_list|<
name|?
argument_list|>
operator|)
name|constantChild
operator|.
name|getWritableObjectInspector
argument_list|()
operator|.
name|getWritableConstantValue
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|TypeInfo
argument_list|>
name|structTypes
init|=
operator|(
operator|(
name|StructTypeInfo
operator|)
name|constantChild
operator|.
name|getTypeInfo
argument_list|()
operator|)
operator|.
name|getAllStructFieldTypeInfos
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|structTypes
operator|.
name|size
argument_list|()
condition|;
name|j
operator|++
control|)
block|{
name|ExprNodeConstantDesc
name|constant
init|=
operator|new
name|ExprNodeConstantDesc
argument_list|(
name|structTypes
operator|.
name|get
argument_list|(
name|j
argument_list|)
argument_list|,
name|items
operator|.
name|get
argument_list|(
name|j
argument_list|)
argument_list|)
decl_stmt|;
name|values
operator|.
name|get
argument_list|(
name|j
argument_list|)
operator|.
name|add
argument_list|(
operator|new
name|ExprNodeDescEqualityWrapper
argument_list|(
name|constant
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|values
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|add
argument_list|(
operator|new
name|ExprNodeDescEqualityWrapper
argument_list|(
name|child
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|// 3. Calculate IN selectivity
name|float
name|factor
init|=
literal|1
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|columnStats
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|long
name|dvs
init|=
name|columnStats
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|==
literal|null
condition|?
literal|0
else|:
name|columnStats
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|getCountDistint
argument_list|()
decl_stmt|;
comment|// ( num of distinct vals for col / num of rows ) * num of distinct vals for col in IN clause
name|float
name|columnFactor
init|=
name|dvs
operator|==
literal|0
condition|?
literal|0.5f
else|:
operator|(
operator|(
name|float
operator|)
name|dvs
operator|/
name|numRows
operator|)
operator|*
name|values
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|size
argument_list|()
decl_stmt|;
name|factor
operator|*=
name|columnFactor
expr_stmt|;
block|}
return|return
name|Math
operator|.
name|round
argument_list|(
operator|(
name|double
operator|)
name|numRows
operator|*
name|factor
argument_list|)
return|;
block|}
specifier|private
name|long
name|evaluateNotExpr
parameter_list|(
name|Statistics
name|stats
parameter_list|,
name|ExprNodeDesc
name|pred
parameter_list|,
name|AnnotateStatsProcCtx
name|aspCtx
parameter_list|,
name|List
argument_list|<
name|String
argument_list|>
name|neededCols
parameter_list|,
name|FilterOperator
name|fop
parameter_list|)
throws|throws
name|CloneNotSupportedException
throws|,
name|SemanticException
block|{
name|long
name|numRows
init|=
name|stats
operator|.
name|getNumRows
argument_list|()
decl_stmt|;
comment|// if the evaluate yields true then pass all rows else pass 0 rows
if|if
condition|(
name|pred
operator|instanceof
name|ExprNodeGenericFuncDesc
condition|)
block|{
name|ExprNodeGenericFuncDesc
name|genFunc
init|=
operator|(
name|ExprNodeGenericFuncDesc
operator|)
name|pred
decl_stmt|;
for|for
control|(
name|ExprNodeDesc
name|leaf
range|:
name|genFunc
operator|.
name|getChildren
argument_list|()
control|)
block|{
if|if
condition|(
name|leaf
operator|instanceof
name|ExprNodeGenericFuncDesc
condition|)
block|{
comment|// GenericUDF
name|long
name|newNumRows
init|=
literal|0
decl_stmt|;
for|for
control|(
name|ExprNodeDesc
name|child
range|:
name|genFunc
operator|.
name|getChildren
argument_list|()
control|)
block|{
name|newNumRows
operator|=
name|evaluateChildExpr
argument_list|(
name|stats
argument_list|,
name|child
argument_list|,
name|aspCtx
argument_list|,
name|neededCols
argument_list|,
name|fop
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
return|return
name|numRows
operator|-
name|newNumRows
return|;
block|}
elseif|else
if|if
condition|(
name|leaf
operator|instanceof
name|ExprNodeConstantDesc
condition|)
block|{
name|ExprNodeConstantDesc
name|encd
init|=
operator|(
name|ExprNodeConstantDesc
operator|)
name|leaf
decl_stmt|;
if|if
condition|(
name|Boolean
operator|.
name|TRUE
operator|.
name|equals
argument_list|(
name|encd
operator|.
name|getValue
argument_list|()
argument_list|)
condition|)
block|{
return|return
literal|0
return|;
block|}
else|else
block|{
return|return
name|numRows
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|leaf
operator|instanceof
name|ExprNodeColumnDesc
condition|)
block|{
comment|// NOT on boolean columns is possible. in which case return false count.
name|ExprNodeColumnDesc
name|encd
init|=
operator|(
name|ExprNodeColumnDesc
operator|)
name|leaf
decl_stmt|;
name|String
name|colName
init|=
name|encd
operator|.
name|getColumn
argument_list|()
decl_stmt|;
name|String
name|colType
init|=
name|encd
operator|.
name|getTypeString
argument_list|()
decl_stmt|;
if|if
condition|(
name|colType
operator|.
name|equalsIgnoreCase
argument_list|(
name|serdeConstants
operator|.
name|BOOLEAN_TYPE_NAME
argument_list|)
condition|)
block|{
name|ColStatistics
name|cs
init|=
name|stats
operator|.
name|getColumnStatisticsFromColName
argument_list|(
name|colName
argument_list|)
decl_stmt|;
if|if
condition|(
name|cs
operator|!=
literal|null
condition|)
block|{
return|return
name|cs
operator|.
name|getNumFalses
argument_list|()
return|;
block|}
block|}
comment|// if not boolean column return half the number of rows
return|return
name|numRows
operator|/
literal|2
return|;
block|}
block|}
block|}
comment|// worst case
return|return
name|numRows
operator|/
literal|2
return|;
block|}
specifier|private
name|long
name|evaluateColEqualsNullExpr
parameter_list|(
name|Statistics
name|stats
parameter_list|,
name|ExprNodeDesc
name|pred
parameter_list|)
block|{
name|long
name|numRows
init|=
name|stats
operator|.
name|getNumRows
argument_list|()
decl_stmt|;
if|if
condition|(
name|pred
operator|instanceof
name|ExprNodeGenericFuncDesc
condition|)
block|{
name|ExprNodeGenericFuncDesc
name|genFunc
init|=
operator|(
name|ExprNodeGenericFuncDesc
operator|)
name|pred
decl_stmt|;
for|for
control|(
name|ExprNodeDesc
name|leaf
range|:
name|genFunc
operator|.
name|getChildren
argument_list|()
control|)
block|{
if|if
condition|(
name|leaf
operator|instanceof
name|ExprNodeColumnDesc
condition|)
block|{
name|ExprNodeColumnDesc
name|colDesc
init|=
operator|(
name|ExprNodeColumnDesc
operator|)
name|leaf
decl_stmt|;
name|String
name|colName
init|=
name|colDesc
operator|.
name|getColumn
argument_list|()
decl_stmt|;
name|ColStatistics
name|cs
init|=
name|stats
operator|.
name|getColumnStatisticsFromColName
argument_list|(
name|colName
argument_list|)
decl_stmt|;
if|if
condition|(
name|cs
operator|!=
literal|null
condition|)
block|{
return|return
name|cs
operator|.
name|getNumNulls
argument_list|()
return|;
block|}
block|}
block|}
block|}
comment|// worst case
return|return
name|numRows
operator|/
literal|2
return|;
block|}
specifier|private
name|long
name|evaluateNotNullExpr
parameter_list|(
name|Statistics
name|parentStats
parameter_list|,
name|ExprNodeGenericFuncDesc
name|pred
parameter_list|)
block|{
name|long
name|noOfNulls
init|=
name|getMaxNulls
argument_list|(
name|parentStats
argument_list|,
name|pred
argument_list|)
decl_stmt|;
name|long
name|parentCardinality
init|=
name|parentStats
operator|.
name|getNumRows
argument_list|()
decl_stmt|;
name|long
name|newPredCardinality
init|=
name|parentCardinality
decl_stmt|;
if|if
condition|(
name|parentCardinality
operator|>
name|noOfNulls
condition|)
block|{
name|newPredCardinality
operator|=
name|parentCardinality
operator|-
name|noOfNulls
expr_stmt|;
block|}
else|else
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Invalid column stats: No of nulls> cardinality"
argument_list|)
expr_stmt|;
block|}
return|return
name|newPredCardinality
return|;
block|}
specifier|private
name|long
name|getMaxNulls
parameter_list|(
name|Statistics
name|stats
parameter_list|,
name|ExprNodeDesc
name|pred
parameter_list|)
block|{
name|long
name|tmpNoNulls
init|=
literal|0
decl_stmt|;
name|long
name|maxNoNulls
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|pred
operator|instanceof
name|ExprNodeColumnDesc
condition|)
block|{
name|ColStatistics
name|cs
init|=
name|stats
operator|.
name|getColumnStatisticsFromColName
argument_list|(
operator|(
operator|(
name|ExprNodeColumnDesc
operator|)
name|pred
operator|)
operator|.
name|getColumn
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|cs
operator|!=
literal|null
condition|)
block|{
name|tmpNoNulls
operator|=
name|cs
operator|.
name|getNumNulls
argument_list|()
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|pred
operator|instanceof
name|ExprNodeGenericFuncDesc
operator|||
name|pred
operator|instanceof
name|ExprNodeColumnListDesc
condition|)
block|{
name|long
name|noNullsOfChild
init|=
literal|0
decl_stmt|;
for|for
control|(
name|ExprNodeDesc
name|childExpr
range|:
name|pred
operator|.
name|getChildren
argument_list|()
control|)
block|{
name|noNullsOfChild
operator|=
name|getMaxNulls
argument_list|(
name|stats
argument_list|,
name|childExpr
argument_list|)
expr_stmt|;
if|if
condition|(
name|noNullsOfChild
operator|>
name|tmpNoNulls
condition|)
block|{
name|tmpNoNulls
operator|=
name|noNullsOfChild
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|pred
operator|instanceof
name|ExprNodeConstantDesc
condition|)
block|{
if|if
condition|(
name|ExprNodeDescUtils
operator|.
name|isNullConstant
argument_list|(
name|pred
argument_list|)
condition|)
block|{
name|tmpNoNulls
operator|=
name|stats
operator|.
name|getNumRows
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|tmpNoNulls
operator|=
literal|0
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|pred
operator|instanceof
name|ExprNodeDynamicListDesc
condition|)
block|{
name|tmpNoNulls
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|pred
operator|instanceof
name|ExprNodeFieldDesc
condition|)
block|{
comment|// TODO Confirm this is safe
name|tmpNoNulls
operator|=
name|getMaxNulls
argument_list|(
name|stats
argument_list|,
operator|(
operator|(
name|ExprNodeFieldDesc
operator|)
name|pred
operator|)
operator|.
name|getDesc
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|tmpNoNulls
operator|>
name|maxNoNulls
condition|)
block|{
name|maxNoNulls
operator|=
name|tmpNoNulls
expr_stmt|;
block|}
return|return
name|maxNoNulls
return|;
block|}
specifier|private
name|long
name|evaluateComparator
parameter_list|(
name|Statistics
name|stats
parameter_list|,
name|ExprNodeGenericFuncDesc
name|genFunc
parameter_list|)
block|{
name|long
name|numRows
init|=
name|stats
operator|.
name|getNumRows
argument_list|()
decl_stmt|;
name|GenericUDF
name|udf
init|=
name|genFunc
operator|.
name|getGenericUDF
argument_list|()
decl_stmt|;
name|ExprNodeColumnDesc
name|columnDesc
decl_stmt|;
name|ExprNodeConstantDesc
name|constantDesc
decl_stmt|;
name|boolean
name|upperBound
decl_stmt|;
name|String
name|boundValue
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|genFunc
operator|.
name|getChildren
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|instanceof
name|ExprNodeColumnDesc
operator|&&
name|genFunc
operator|.
name|getChildren
argument_list|()
operator|.
name|get
argument_list|(
literal|1
argument_list|)
operator|instanceof
name|ExprNodeConstantDesc
condition|)
block|{
name|columnDesc
operator|=
operator|(
name|ExprNodeColumnDesc
operator|)
name|genFunc
operator|.
name|getChildren
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|constantDesc
operator|=
operator|(
name|ExprNodeConstantDesc
operator|)
name|genFunc
operator|.
name|getChildren
argument_list|()
operator|.
name|get
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|// Comparison to null will always return false
if|if
condition|(
name|constantDesc
operator|.
name|getValue
argument_list|()
operator|==
literal|null
condition|)
block|{
return|return
literal|0
return|;
block|}
if|if
condition|(
name|udf
operator|instanceof
name|GenericUDFOPEqualOrGreaterThan
operator|||
name|udf
operator|instanceof
name|GenericUDFOPGreaterThan
condition|)
block|{
name|boundValue
operator|=
name|constantDesc
operator|.
name|getValue
argument_list|()
operator|.
name|toString
argument_list|()
expr_stmt|;
name|upperBound
operator|=
literal|false
expr_stmt|;
block|}
else|else
block|{
name|boundValue
operator|=
name|constantDesc
operator|.
name|getValue
argument_list|()
operator|.
name|toString
argument_list|()
expr_stmt|;
name|upperBound
operator|=
literal|true
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|genFunc
operator|.
name|getChildren
argument_list|()
operator|.
name|get
argument_list|(
literal|1
argument_list|)
operator|instanceof
name|ExprNodeColumnDesc
operator|&&
name|genFunc
operator|.
name|getChildren
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|instanceof
name|ExprNodeConstantDesc
condition|)
block|{
name|columnDesc
operator|=
operator|(
name|ExprNodeColumnDesc
operator|)
name|genFunc
operator|.
name|getChildren
argument_list|()
operator|.
name|get
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|constantDesc
operator|=
operator|(
name|ExprNodeConstantDesc
operator|)
name|genFunc
operator|.
name|getChildren
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|// Comparison to null will always return false
if|if
condition|(
name|constantDesc
operator|.
name|getValue
argument_list|()
operator|==
literal|null
condition|)
block|{
return|return
literal|0
return|;
block|}
if|if
condition|(
name|udf
operator|instanceof
name|GenericUDFOPEqualOrGreaterThan
operator|||
name|udf
operator|instanceof
name|GenericUDFOPGreaterThan
condition|)
block|{
name|boundValue
operator|=
name|constantDesc
operator|.
name|getValue
argument_list|()
operator|.
name|toString
argument_list|()
expr_stmt|;
name|upperBound
operator|=
literal|true
expr_stmt|;
block|}
else|else
block|{
name|boundValue
operator|=
name|constantDesc
operator|.
name|getValue
argument_list|()
operator|.
name|toString
argument_list|()
expr_stmt|;
name|upperBound
operator|=
literal|false
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// default
return|return
name|numRows
operator|/
literal|3
return|;
block|}
name|ColStatistics
name|cs
init|=
name|stats
operator|.
name|getColumnStatisticsFromColName
argument_list|(
name|columnDesc
operator|.
name|getColumn
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|cs
operator|!=
literal|null
operator|&&
name|cs
operator|.
name|getRange
argument_list|()
operator|!=
literal|null
operator|&&
name|cs
operator|.
name|getRange
argument_list|()
operator|.
name|maxValue
operator|!=
literal|null
operator|&&
name|cs
operator|.
name|getRange
argument_list|()
operator|.
name|minValue
operator|!=
literal|null
condition|)
block|{
name|String
name|colTypeLowerCase
init|=
name|columnDesc
operator|.
name|getTypeString
argument_list|()
operator|.
name|toLowerCase
argument_list|()
decl_stmt|;
try|try
block|{
if|if
condition|(
name|colTypeLowerCase
operator|.
name|equals
argument_list|(
name|serdeConstants
operator|.
name|TINYINT_TYPE_NAME
argument_list|)
condition|)
block|{
name|byte
name|value
init|=
operator|new
name|Byte
argument_list|(
name|boundValue
argument_list|)
decl_stmt|;
name|byte
name|maxValue
init|=
name|cs
operator|.
name|getRange
argument_list|()
operator|.
name|maxValue
operator|.
name|byteValue
argument_list|()
decl_stmt|;
name|byte
name|minValue
init|=
name|cs
operator|.
name|getRange
argument_list|()
operator|.
name|minValue
operator|.
name|byteValue
argument_list|()
decl_stmt|;
if|if
condition|(
name|upperBound
condition|)
block|{
if|if
condition|(
name|maxValue
operator|<
name|value
condition|)
block|{
return|return
name|numRows
return|;
block|}
if|if
condition|(
name|minValue
operator|>
name|value
condition|)
block|{
return|return
literal|0
return|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|minValue
operator|>
name|value
condition|)
block|{
return|return
name|numRows
return|;
block|}
if|if
condition|(
name|maxValue
operator|<
name|value
condition|)
block|{
return|return
literal|0
return|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|colTypeLowerCase
operator|.
name|equals
argument_list|(
name|serdeConstants
operator|.
name|SMALLINT_TYPE_NAME
argument_list|)
condition|)
block|{
name|short
name|value
init|=
operator|new
name|Short
argument_list|(
name|boundValue
argument_list|)
decl_stmt|;
name|short
name|maxValue
init|=
name|cs
operator|.
name|getRange
argument_list|()
operator|.
name|maxValue
operator|.
name|shortValue
argument_list|()
decl_stmt|;
name|short
name|minValue
init|=
name|cs
operator|.
name|getRange
argument_list|()
operator|.
name|minValue
operator|.
name|shortValue
argument_list|()
decl_stmt|;
if|if
condition|(
name|upperBound
condition|)
block|{
if|if
condition|(
name|maxValue
operator|<
name|value
condition|)
block|{
return|return
name|numRows
return|;
block|}
if|if
condition|(
name|minValue
operator|>
name|value
condition|)
block|{
return|return
literal|0
return|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|minValue
operator|>
name|value
condition|)
block|{
return|return
name|numRows
return|;
block|}
if|if
condition|(
name|maxValue
operator|<
name|value
condition|)
block|{
return|return
literal|0
return|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|colTypeLowerCase
operator|.
name|equals
argument_list|(
name|serdeConstants
operator|.
name|INT_TYPE_NAME
argument_list|)
operator|||
name|colTypeLowerCase
operator|.
name|equals
argument_list|(
name|serdeConstants
operator|.
name|DATE_TYPE_NAME
argument_list|)
condition|)
block|{
comment|// Date is an integer internally
name|int
name|value
init|=
operator|new
name|Integer
argument_list|(
name|boundValue
argument_list|)
decl_stmt|;
name|int
name|maxValue
init|=
name|cs
operator|.
name|getRange
argument_list|()
operator|.
name|maxValue
operator|.
name|intValue
argument_list|()
decl_stmt|;
name|int
name|minValue
init|=
name|cs
operator|.
name|getRange
argument_list|()
operator|.
name|minValue
operator|.
name|intValue
argument_list|()
decl_stmt|;
if|if
condition|(
name|upperBound
condition|)
block|{
if|if
condition|(
name|maxValue
operator|<
name|value
condition|)
block|{
return|return
name|numRows
return|;
block|}
if|if
condition|(
name|minValue
operator|>
name|value
condition|)
block|{
return|return
literal|0
return|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|minValue
operator|>
name|value
condition|)
block|{
return|return
name|numRows
return|;
block|}
if|if
condition|(
name|maxValue
operator|<
name|value
condition|)
block|{
return|return
literal|0
return|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|colTypeLowerCase
operator|.
name|equals
argument_list|(
name|serdeConstants
operator|.
name|BIGINT_TYPE_NAME
argument_list|)
condition|)
block|{
name|long
name|value
init|=
operator|new
name|Long
argument_list|(
name|boundValue
argument_list|)
decl_stmt|;
name|long
name|maxValue
init|=
name|cs
operator|.
name|getRange
argument_list|()
operator|.
name|maxValue
operator|.
name|longValue
argument_list|()
decl_stmt|;
name|long
name|minValue
init|=
name|cs
operator|.
name|getRange
argument_list|()
operator|.
name|minValue
operator|.
name|longValue
argument_list|()
decl_stmt|;
if|if
condition|(
name|upperBound
condition|)
block|{
if|if
condition|(
name|maxValue
operator|<
name|value
condition|)
block|{
return|return
name|numRows
return|;
block|}
if|if
condition|(
name|minValue
operator|>
name|value
condition|)
block|{
return|return
literal|0
return|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|minValue
operator|>
name|value
condition|)
block|{
return|return
name|numRows
return|;
block|}
if|if
condition|(
name|maxValue
operator|<
name|value
condition|)
block|{
return|return
literal|0
return|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|colTypeLowerCase
operator|.
name|equals
argument_list|(
name|serdeConstants
operator|.
name|FLOAT_TYPE_NAME
argument_list|)
condition|)
block|{
name|float
name|value
init|=
operator|new
name|Float
argument_list|(
name|boundValue
argument_list|)
decl_stmt|;
name|float
name|maxValue
init|=
name|cs
operator|.
name|getRange
argument_list|()
operator|.
name|maxValue
operator|.
name|floatValue
argument_list|()
decl_stmt|;
name|float
name|minValue
init|=
name|cs
operator|.
name|getRange
argument_list|()
operator|.
name|minValue
operator|.
name|floatValue
argument_list|()
decl_stmt|;
if|if
condition|(
name|upperBound
condition|)
block|{
if|if
condition|(
name|maxValue
operator|<
name|value
condition|)
block|{
return|return
name|numRows
return|;
block|}
if|if
condition|(
name|minValue
operator|>
name|value
condition|)
block|{
return|return
literal|0
return|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|minValue
operator|>
name|value
condition|)
block|{
return|return
name|numRows
return|;
block|}
if|if
condition|(
name|maxValue
operator|<
name|value
condition|)
block|{
return|return
literal|0
return|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|colTypeLowerCase
operator|.
name|equals
argument_list|(
name|serdeConstants
operator|.
name|DOUBLE_TYPE_NAME
argument_list|)
condition|)
block|{
name|double
name|value
init|=
operator|new
name|Double
argument_list|(
name|boundValue
argument_list|)
decl_stmt|;
name|double
name|maxValue
init|=
name|cs
operator|.
name|getRange
argument_list|()
operator|.
name|maxValue
operator|.
name|doubleValue
argument_list|()
decl_stmt|;
name|double
name|minValue
init|=
name|cs
operator|.
name|getRange
argument_list|()
operator|.
name|minValue
operator|.
name|doubleValue
argument_list|()
decl_stmt|;
if|if
condition|(
name|upperBound
condition|)
block|{
if|if
condition|(
name|maxValue
operator|<
name|value
condition|)
block|{
return|return
name|numRows
return|;
block|}
if|if
condition|(
name|minValue
operator|>
name|value
condition|)
block|{
return|return
literal|0
return|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|minValue
operator|>
name|value
condition|)
block|{
return|return
name|numRows
return|;
block|}
if|if
condition|(
name|maxValue
operator|<
name|value
condition|)
block|{
return|return
literal|0
return|;
block|}
block|}
block|}
block|}
catch|catch
parameter_list|(
name|NumberFormatException
name|nfe
parameter_list|)
block|{
return|return
name|numRows
operator|/
literal|3
return|;
block|}
block|}
comment|// default
return|return
name|numRows
operator|/
literal|3
return|;
block|}
specifier|private
name|long
name|evaluateChildExpr
parameter_list|(
name|Statistics
name|stats
parameter_list|,
name|ExprNodeDesc
name|child
parameter_list|,
name|AnnotateStatsProcCtx
name|aspCtx
parameter_list|,
name|List
argument_list|<
name|String
argument_list|>
name|neededCols
parameter_list|,
name|FilterOperator
name|fop
parameter_list|,
name|long
name|evaluatedRowCount
parameter_list|)
throws|throws
name|CloneNotSupportedException
throws|,
name|SemanticException
block|{
name|long
name|numRows
init|=
name|stats
operator|.
name|getNumRows
argument_list|()
decl_stmt|;
if|if
condition|(
name|child
operator|instanceof
name|ExprNodeGenericFuncDesc
condition|)
block|{
name|ExprNodeGenericFuncDesc
name|genFunc
init|=
operator|(
name|ExprNodeGenericFuncDesc
operator|)
name|child
decl_stmt|;
name|GenericUDF
name|udf
init|=
name|genFunc
operator|.
name|getGenericUDF
argument_list|()
decl_stmt|;
if|if
condition|(
name|udf
operator|instanceof
name|GenericUDFOPEqual
operator|||
name|udf
operator|instanceof
name|GenericUDFOPEqualNS
condition|)
block|{
name|String
name|colName
init|=
literal|null
decl_stmt|;
name|boolean
name|isConst
init|=
literal|false
decl_stmt|;
name|Object
name|prevConst
init|=
literal|null
decl_stmt|;
for|for
control|(
name|ExprNodeDesc
name|leaf
range|:
name|genFunc
operator|.
name|getChildren
argument_list|()
control|)
block|{
if|if
condition|(
name|leaf
operator|instanceof
name|ExprNodeConstantDesc
condition|)
block|{
comment|// constant = constant expressions. We shouldn't be getting this
comment|// after constant folding
if|if
condition|(
name|isConst
condition|)
block|{
comment|// special case: if both constants are not equal then return 0
if|if
condition|(
name|prevConst
operator|!=
literal|null
operator|&&
operator|!
name|prevConst
operator|.
name|equals
argument_list|(
operator|(
operator|(
name|ExprNodeConstantDesc
operator|)
name|leaf
operator|)
operator|.
name|getValue
argument_list|()
argument_list|)
condition|)
block|{
return|return
literal|0
return|;
block|}
return|return
name|numRows
return|;
block|}
comment|// if the first argument is const then just set the flag and continue
if|if
condition|(
name|colName
operator|==
literal|null
condition|)
block|{
name|isConst
operator|=
literal|true
expr_stmt|;
name|prevConst
operator|=
operator|(
operator|(
name|ExprNodeConstantDesc
operator|)
name|leaf
operator|)
operator|.
name|getValue
argument_list|()
expr_stmt|;
continue|continue;
block|}
comment|// if column name is not contained in needed column list then it
comment|// is a partition column. We do not need to evaluate partition columns
comment|// in filter expression since it will be taken care by partitio pruner
if|if
condition|(
name|neededCols
operator|!=
literal|null
operator|&&
operator|!
name|neededCols
operator|.
name|contains
argument_list|(
name|colName
argument_list|)
condition|)
block|{
return|return
name|numRows
return|;
block|}
name|ColStatistics
name|cs
init|=
name|stats
operator|.
name|getColumnStatisticsFromColName
argument_list|(
name|colName
argument_list|)
decl_stmt|;
if|if
condition|(
name|cs
operator|!=
literal|null
condition|)
block|{
name|long
name|dvs
init|=
name|cs
operator|.
name|getCountDistint
argument_list|()
decl_stmt|;
name|numRows
operator|=
name|dvs
operator|==
literal|0
condition|?
name|numRows
operator|/
literal|2
else|:
name|Math
operator|.
name|round
argument_list|(
operator|(
name|double
operator|)
name|numRows
operator|/
name|dvs
argument_list|)
expr_stmt|;
return|return
name|numRows
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|leaf
operator|instanceof
name|ExprNodeColumnDesc
condition|)
block|{
name|ExprNodeColumnDesc
name|colDesc
init|=
operator|(
name|ExprNodeColumnDesc
operator|)
name|leaf
decl_stmt|;
name|colName
operator|=
name|colDesc
operator|.
name|getColumn
argument_list|()
expr_stmt|;
comment|// if const is first argument then evaluate the result
if|if
condition|(
name|isConst
condition|)
block|{
comment|// if column name is not contained in needed column list then it
comment|// is a partition column. We do not need to evaluate partition columns
comment|// in filter expression since it will be taken care by partitio pruner
if|if
condition|(
name|neededCols
operator|!=
literal|null
operator|&&
name|neededCols
operator|.
name|indexOf
argument_list|(
name|colName
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
return|return
name|numRows
return|;
block|}
name|ColStatistics
name|cs
init|=
name|stats
operator|.
name|getColumnStatisticsFromColName
argument_list|(
name|colName
argument_list|)
decl_stmt|;
if|if
condition|(
name|cs
operator|!=
literal|null
condition|)
block|{
name|long
name|dvs
init|=
name|cs
operator|.
name|getCountDistint
argument_list|()
decl_stmt|;
name|numRows
operator|=
name|dvs
operator|==
literal|0
condition|?
name|numRows
operator|/
literal|2
else|:
name|Math
operator|.
name|round
argument_list|(
operator|(
name|double
operator|)
name|numRows
operator|/
name|dvs
argument_list|)
expr_stmt|;
return|return
name|numRows
return|;
block|}
block|}
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|udf
operator|instanceof
name|GenericUDFOPNotEqual
condition|)
block|{
return|return
name|numRows
return|;
block|}
elseif|else
if|if
condition|(
name|udf
operator|instanceof
name|GenericUDFOPEqualOrGreaterThan
operator|||
name|udf
operator|instanceof
name|GenericUDFOPEqualOrLessThan
operator|||
name|udf
operator|instanceof
name|GenericUDFOPGreaterThan
operator|||
name|udf
operator|instanceof
name|GenericUDFOPLessThan
condition|)
block|{
return|return
name|evaluateComparator
argument_list|(
name|stats
argument_list|,
name|genFunc
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|udf
operator|instanceof
name|GenericUDFOPNotNull
condition|)
block|{
return|return
name|evaluateNotNullExpr
argument_list|(
name|stats
argument_list|,
name|genFunc
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|udf
operator|instanceof
name|GenericUDFOPNull
condition|)
block|{
return|return
name|evaluateColEqualsNullExpr
argument_list|(
name|stats
argument_list|,
name|genFunc
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|udf
operator|instanceof
name|GenericUDFOPAnd
operator|||
name|udf
operator|instanceof
name|GenericUDFOPOr
operator|||
name|udf
operator|instanceof
name|GenericUDFIn
operator|||
name|udf
operator|instanceof
name|GenericUDFOPNot
condition|)
block|{
return|return
name|evaluateExpression
argument_list|(
name|stats
argument_list|,
name|genFunc
argument_list|,
name|aspCtx
argument_list|,
name|neededCols
argument_list|,
name|fop
argument_list|,
name|evaluatedRowCount
argument_list|)
return|;
block|}
block|}
comment|// worst case
return|return
name|numRows
operator|/
literal|2
return|;
block|}
block|}
comment|/**    * GROUPBY operator changes the number of rows. The number of rows emitted by GBY operator will be    * atleast 1 or utmost T(R) (number of rows in relation T) based on the aggregation. A better    * estimate can be found if we have column statistics on the columns that we are grouping on.    *<p>    * Suppose if we are grouping by attributes A,B,C and if statistics for columns A,B,C are    * available then a better estimate can be found by taking the smaller of product of V(R,[A,B,C])    * (product of distinct cardinalities of A,B,C) and T(R)/2.    *<p>    * T(R) = min (T(R)/2 , V(R,[A,B,C]) ---> [1]    *<p>    * In the presence of grouping sets, map-side GBY will emit more rows depending on the size of    * grouping set (input rows * size of grouping set). These rows will get reduced because of    * map-side hash aggregation. Hash aggregation is an optimization in hive to reduce the number of    * rows shuffled between map and reduce stage. This optimization will be disabled if the memory    * used for hash aggregation exceeds 90% of max available memory for hash aggregation. The number    * of rows emitted from map-side will vary if hash aggregation is enabled throughout execution or    * disabled. In the presence of grouping sets, following rules will be applied    *<p>    * If<b>hash-aggregation is enabled</b>, for query SELECT * FROM table GROUP BY (A,B) WITH CUBE    *<p>    * T(R) = min(T(R)/2, T(R, GBY(A,B)) + T(R, GBY(A)) + T(R, GBY(B)) + 1))    *<p>    * where, GBY(A,B), GBY(B), GBY(B) are the GBY rules mentioned above [1]    *<p>    * If<b>hash-aggregation is disabled</b>, apply the GBY rule [1] and then multiply the result by    * number of elements in grouping set T(R) = T(R) * length_of_grouping_set. Since we do not know    * if hash-aggregation is enabled or disabled during compile time, we will assume worst-case i.e,    * hash-aggregation is disabled    *<p>    * NOTE: The number of rows from map-side GBY operator is dependent on map-side parallelism i.e,    * number of mappers. The map-side parallelism is expected from hive config    * "hive.stats.map.parallelism". If the config is not set then default parallelism of 1 will be    * assumed.    *<p>    *<i>Worst case:</i> If no column statistics are available, then T(R) = T(R)/2 will be used as    * heuristics.    *<p>    *<i>For more information, refer 'Estimating The Cost Of Operations' chapter in    * "Database Systems: The Complete Book" by Garcia-Molina et. al.</i>    *</p>    */
specifier|public
specifier|static
class|class
name|GroupByStatsRule
extends|extends
name|DefaultStatsRule
implements|implements
name|NodeProcessor
block|{
annotation|@
name|Override
specifier|public
name|Object
name|process
parameter_list|(
name|Node
name|nd
parameter_list|,
name|Stack
argument_list|<
name|Node
argument_list|>
name|stack
parameter_list|,
name|NodeProcessorCtx
name|procCtx
parameter_list|,
name|Object
modifier|...
name|nodeOutputs
parameter_list|)
throws|throws
name|SemanticException
block|{
name|GroupByOperator
name|gop
init|=
operator|(
name|GroupByOperator
operator|)
name|nd
decl_stmt|;
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
name|parent
init|=
name|gop
operator|.
name|getParentOperators
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|Statistics
name|parentStats
init|=
name|parent
operator|.
name|getStatistics
argument_list|()
decl_stmt|;
comment|// parent stats are not populated yet
if|if
condition|(
name|parentStats
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
name|AnnotateStatsProcCtx
name|aspCtx
init|=
operator|(
name|AnnotateStatsProcCtx
operator|)
name|procCtx
decl_stmt|;
name|HiveConf
name|conf
init|=
name|aspCtx
operator|.
name|getConf
argument_list|()
decl_stmt|;
name|long
name|maxSplitSize
init|=
name|HiveConf
operator|.
name|getLongVar
argument_list|(
name|conf
argument_list|,
name|HiveConf
operator|.
name|ConfVars
operator|.
name|MAPREDMAXSPLITSIZE
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|AggregationDesc
argument_list|>
name|aggDesc
init|=
name|gop
operator|.
name|getConf
argument_list|()
operator|.
name|getAggregators
argument_list|()
decl_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|ExprNodeDesc
argument_list|>
name|colExprMap
init|=
name|gop
operator|.
name|getColumnExprMap
argument_list|()
decl_stmt|;
name|RowSchema
name|rs
init|=
name|gop
operator|.
name|getSchema
argument_list|()
decl_stmt|;
name|Statistics
name|stats
init|=
literal|null
decl_stmt|;
name|List
argument_list|<
name|ColStatistics
argument_list|>
name|colStats
init|=
name|StatsUtils
operator|.
name|getColStatisticsFromExprMap
argument_list|(
name|conf
argument_list|,
name|parentStats
argument_list|,
name|colExprMap
argument_list|,
name|rs
argument_list|)
decl_stmt|;
name|long
name|cardinality
decl_stmt|;
name|long
name|parallelism
init|=
literal|1L
decl_stmt|;
name|boolean
name|interReduction
init|=
literal|false
decl_stmt|;
name|boolean
name|hashAgg
init|=
literal|false
decl_stmt|;
name|long
name|inputSize
init|=
literal|1L
decl_stmt|;
name|boolean
name|containsGroupingSet
init|=
name|gop
operator|.
name|getConf
argument_list|()
operator|.
name|isGroupingSetsPresent
argument_list|()
decl_stmt|;
name|long
name|sizeOfGroupingSet
init|=
name|containsGroupingSet
condition|?
name|gop
operator|.
name|getConf
argument_list|()
operator|.
name|getListGroupingSets
argument_list|()
operator|.
name|size
argument_list|()
else|:
literal|1L
decl_stmt|;
comment|// There are different cases for Group By depending on map/reduce side, hash aggregation,
comment|// grouping sets and column stats. If we don't have column stats, we just assume hash
comment|// aggregation is disabled. Following are the possible cases and rule for cardinality
comment|// estimation
comment|// INTERMEDIATE REDUCTION:
comment|// Case 1: NO column stats, NO hash aggregation, NO grouping sets  numRows
comment|// Case 2: NO column stats, NO hash aggregation, grouping sets  numRows * sizeOfGroupingSet
comment|// Case 3: column stats, hash aggregation, NO grouping sets  Min(numRows / 2, ndvProduct * parallelism)
comment|// Case 4: column stats, hash aggregation, grouping sets  Min((numRows * sizeOfGroupingSet) / 2, ndvProduct * parallelism * sizeOfGroupingSet)
comment|// Case 5: column stats, NO hash aggregation, NO grouping sets  numRows
comment|// Case 6: column stats, NO hash aggregation, grouping sets  numRows * sizeOfGroupingSet
comment|// FINAL REDUCTION:
comment|// Case 7: NO column stats  numRows / 2
comment|// Case 8: column stats, grouping sets  Min(numRows, ndvProduct * sizeOfGroupingSet)
comment|// Case 9: column stats, NO grouping sets - Min(numRows, ndvProduct)
if|if
condition|(
operator|!
name|gop
operator|.
name|getConf
argument_list|()
operator|.
name|getMode
argument_list|()
operator|.
name|equals
argument_list|(
name|GroupByDesc
operator|.
name|Mode
operator|.
name|MERGEPARTIAL
argument_list|)
operator|&&
operator|!
name|gop
operator|.
name|getConf
argument_list|()
operator|.
name|getMode
argument_list|()
operator|.
name|equals
argument_list|(
name|GroupByDesc
operator|.
name|Mode
operator|.
name|COMPLETE
argument_list|)
operator|&&
operator|!
name|gop
operator|.
name|getConf
argument_list|()
operator|.
name|getMode
argument_list|()
operator|.
name|equals
argument_list|(
name|GroupByDesc
operator|.
name|Mode
operator|.
name|FINAL
argument_list|)
condition|)
block|{
name|interReduction
operator|=
literal|true
expr_stmt|;
comment|// consider approximate map side parallelism to be table data size
comment|// divided by max split size
name|TableScanOperator
name|top
init|=
name|OperatorUtils
operator|.
name|findSingleOperatorUpstream
argument_list|(
name|gop
argument_list|,
name|TableScanOperator
operator|.
name|class
argument_list|)
decl_stmt|;
comment|// if top is null then there are multiple parents (RS as well), hence
comment|// lets use parent statistics to get data size. Also maxSplitSize should
comment|// be updated to bytes per reducer (1GB default)
if|if
condition|(
name|top
operator|==
literal|null
condition|)
block|{
name|inputSize
operator|=
name|parentStats
operator|.
name|getDataSize
argument_list|()
expr_stmt|;
name|maxSplitSize
operator|=
name|HiveConf
operator|.
name|getLongVar
argument_list|(
name|conf
argument_list|,
name|HiveConf
operator|.
name|ConfVars
operator|.
name|BYTESPERREDUCER
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|inputSize
operator|=
name|top
operator|.
name|getConf
argument_list|()
operator|.
name|getStatistics
argument_list|()
operator|.
name|getDataSize
argument_list|()
expr_stmt|;
block|}
name|parallelism
operator|=
operator|(
name|int
operator|)
name|Math
operator|.
name|ceil
argument_list|(
operator|(
name|double
operator|)
name|inputSize
operator|/
name|maxSplitSize
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|isDebugEnabled
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"STATS-"
operator|+
name|gop
operator|.
name|toString
argument_list|()
operator|+
literal|": inputSize: "
operator|+
name|inputSize
operator|+
literal|" maxSplitSize: "
operator|+
name|maxSplitSize
operator|+
literal|" parallelism: "
operator|+
name|parallelism
operator|+
literal|" containsGroupingSet: "
operator|+
name|containsGroupingSet
operator|+
literal|" sizeOfGroupingSet: "
operator|+
name|sizeOfGroupingSet
argument_list|)
expr_stmt|;
block|}
try|try
block|{
comment|// satisfying precondition means column statistics is available
if|if
condition|(
name|satisfyPrecondition
argument_list|(
name|parentStats
argument_list|)
condition|)
block|{
comment|// check if map side aggregation is possible or not based on column stats
name|hashAgg
operator|=
name|checkMapSideAggregation
argument_list|(
name|gop
argument_list|,
name|colStats
argument_list|,
name|conf
argument_list|)
expr_stmt|;
if|if
condition|(
name|isDebugEnabled
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"STATS-"
operator|+
name|gop
operator|.
name|toString
argument_list|()
operator|+
literal|" hashAgg: "
operator|+
name|hashAgg
argument_list|)
expr_stmt|;
block|}
name|stats
operator|=
name|parentStats
operator|.
name|clone
argument_list|()
expr_stmt|;
name|stats
operator|.
name|setColumnStats
argument_list|(
name|colStats
argument_list|)
expr_stmt|;
name|long
name|ndvProduct
init|=
literal|1
decl_stmt|;
specifier|final
name|long
name|parentNumRows
init|=
name|stats
operator|.
name|getNumRows
argument_list|()
decl_stmt|;
comment|// compute product of distinct values of grouping columns
for|for
control|(
name|ColStatistics
name|cs
range|:
name|colStats
control|)
block|{
if|if
condition|(
name|cs
operator|!=
literal|null
condition|)
block|{
name|long
name|ndv
init|=
name|cs
operator|.
name|getCountDistint
argument_list|()
decl_stmt|;
if|if
condition|(
name|cs
operator|.
name|getNumNulls
argument_list|()
operator|>
literal|0
condition|)
block|{
name|ndv
operator|=
name|StatsUtils
operator|.
name|safeAdd
argument_list|(
name|ndv
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|ndvProduct
operator|=
name|StatsUtils
operator|.
name|safeMult
argument_list|(
name|ndvProduct
argument_list|,
name|ndv
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|parentStats
operator|.
name|getColumnStatsState
argument_list|()
operator|.
name|equals
argument_list|(
name|Statistics
operator|.
name|State
operator|.
name|COMPLETE
argument_list|)
condition|)
block|{
comment|// the column must be an aggregate column inserted by GBY. We
comment|// don't have to account for this column when computing product
comment|// of NDVs
continue|continue;
block|}
else|else
block|{
comment|// partial column statistics on grouping attributes case.
comment|// if column statistics on grouping attribute is missing, then
comment|// assume worst case.
comment|// GBY rule will emit half the number of rows if ndvProduct is 0
name|ndvProduct
operator|=
literal|0
expr_stmt|;
block|}
break|break;
block|}
block|}
comment|// if ndvProduct is 0 then column stats state must be partial and we are missing
comment|// column stats for a group by column
if|if
condition|(
name|ndvProduct
operator|==
literal|0
condition|)
block|{
name|ndvProduct
operator|=
name|parentNumRows
operator|/
literal|2
expr_stmt|;
if|if
condition|(
name|isDebugEnabled
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"STATS-"
operator|+
name|gop
operator|.
name|toString
argument_list|()
operator|+
literal|": ndvProduct became 0 as some column does not"
operator|+
literal|" have stats. ndvProduct changed to: "
operator|+
name|ndvProduct
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|interReduction
condition|)
block|{
if|if
condition|(
name|hashAgg
condition|)
block|{
if|if
condition|(
name|containsGroupingSet
condition|)
block|{
comment|// Case 4: column stats, hash aggregation, grouping sets
name|cardinality
operator|=
name|Math
operator|.
name|min
argument_list|(
operator|(
name|StatsUtils
operator|.
name|safeMult
argument_list|(
name|parentNumRows
argument_list|,
name|sizeOfGroupingSet
argument_list|)
operator|)
operator|/
literal|2
argument_list|,
name|StatsUtils
operator|.
name|safeMult
argument_list|(
name|StatsUtils
operator|.
name|safeMult
argument_list|(
name|ndvProduct
argument_list|,
name|parallelism
argument_list|)
argument_list|,
name|sizeOfGroupingSet
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|isDebugEnabled
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"[Case 4] STATS-"
operator|+
name|gop
operator|.
name|toString
argument_list|()
operator|+
literal|": cardinality: "
operator|+
name|cardinality
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// Case 3: column stats, hash aggregation, NO grouping sets
name|cardinality
operator|=
name|Math
operator|.
name|min
argument_list|(
name|parentNumRows
operator|/
literal|2
argument_list|,
name|StatsUtils
operator|.
name|safeMult
argument_list|(
name|ndvProduct
argument_list|,
name|parallelism
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|isDebugEnabled
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"[Case 3] STATS-"
operator|+
name|gop
operator|.
name|toString
argument_list|()
operator|+
literal|": cardinality: "
operator|+
name|cardinality
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
if|if
condition|(
name|containsGroupingSet
condition|)
block|{
comment|// Case 6: column stats, NO hash aggregation, grouping sets
name|cardinality
operator|=
name|StatsUtils
operator|.
name|safeMult
argument_list|(
name|parentNumRows
argument_list|,
name|sizeOfGroupingSet
argument_list|)
expr_stmt|;
if|if
condition|(
name|isDebugEnabled
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"[Case 6] STATS-"
operator|+
name|gop
operator|.
name|toString
argument_list|()
operator|+
literal|": cardinality: "
operator|+
name|cardinality
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// Case 5: column stats, NO hash aggregation, NO grouping sets
name|cardinality
operator|=
name|parentNumRows
expr_stmt|;
if|if
condition|(
name|isDebugEnabled
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"[Case 5] STATS-"
operator|+
name|gop
operator|.
name|toString
argument_list|()
operator|+
literal|": cardinality: "
operator|+
name|cardinality
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
else|else
block|{
comment|// in reduce side GBY, we don't know if the grouping set was present or not. so get it
comment|// from map side GBY
name|GroupByOperator
name|mGop
init|=
name|OperatorUtils
operator|.
name|findSingleOperatorUpstream
argument_list|(
name|parent
argument_list|,
name|GroupByOperator
operator|.
name|class
argument_list|)
decl_stmt|;
if|if
condition|(
name|mGop
operator|!=
literal|null
condition|)
block|{
name|containsGroupingSet
operator|=
name|mGop
operator|.
name|getConf
argument_list|()
operator|.
name|isGroupingSetsPresent
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|containsGroupingSet
condition|)
block|{
comment|// Case 8: column stats, grouping sets
name|sizeOfGroupingSet
operator|=
name|mGop
operator|.
name|getConf
argument_list|()
operator|.
name|getListGroupingSets
argument_list|()
operator|.
name|size
argument_list|()
expr_stmt|;
name|cardinality
operator|=
name|Math
operator|.
name|min
argument_list|(
name|parentNumRows
argument_list|,
name|StatsUtils
operator|.
name|safeMult
argument_list|(
name|ndvProduct
argument_list|,
name|sizeOfGroupingSet
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|isDebugEnabled
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"[Case 8] STATS-"
operator|+
name|gop
operator|.
name|toString
argument_list|()
operator|+
literal|": cardinality: "
operator|+
name|cardinality
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// Case 9: column stats, NO grouping sets
name|cardinality
operator|=
name|Math
operator|.
name|min
argument_list|(
name|parentNumRows
argument_list|,
name|ndvProduct
argument_list|)
expr_stmt|;
if|if
condition|(
name|isDebugEnabled
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"[Case 9] STATS-"
operator|+
name|gop
operator|.
name|toString
argument_list|()
operator|+
literal|": cardinality: "
operator|+
name|cardinality
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|// update stats, but don't update NDV as it will not change
name|updateStats
argument_list|(
name|stats
argument_list|,
name|cardinality
argument_list|,
literal|true
argument_list|,
name|gop
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// NO COLUMN STATS
if|if
condition|(
name|parentStats
operator|!=
literal|null
condition|)
block|{
name|stats
operator|=
name|parentStats
operator|.
name|clone
argument_list|()
expr_stmt|;
specifier|final
name|long
name|parentNumRows
init|=
name|stats
operator|.
name|getNumRows
argument_list|()
decl_stmt|;
comment|// if we don't have column stats, we just assume hash aggregation is disabled
if|if
condition|(
name|interReduction
condition|)
block|{
if|if
condition|(
name|containsGroupingSet
condition|)
block|{
comment|// Case 2: NO column stats, NO hash aggregation, grouping sets
name|cardinality
operator|=
name|StatsUtils
operator|.
name|safeMult
argument_list|(
name|parentNumRows
argument_list|,
name|sizeOfGroupingSet
argument_list|)
expr_stmt|;
if|if
condition|(
name|isDebugEnabled
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"[Case 2] STATS-"
operator|+
name|gop
operator|.
name|toString
argument_list|()
operator|+
literal|": cardinality: "
operator|+
name|cardinality
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// Case 1: NO column stats, NO hash aggregation, NO grouping sets
name|cardinality
operator|=
name|parentNumRows
expr_stmt|;
if|if
condition|(
name|isDebugEnabled
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"[Case 1] STATS-"
operator|+
name|gop
operator|.
name|toString
argument_list|()
operator|+
literal|": cardinality: "
operator|+
name|cardinality
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
comment|// Case 7: NO column stats
name|cardinality
operator|=
name|parentNumRows
operator|/
literal|2
expr_stmt|;
if|if
condition|(
name|isDebugEnabled
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"[Case 7] STATS-"
operator|+
name|gop
operator|.
name|toString
argument_list|()
operator|+
literal|": cardinality: "
operator|+
name|cardinality
argument_list|)
expr_stmt|;
block|}
block|}
name|updateStats
argument_list|(
name|stats
argument_list|,
name|cardinality
argument_list|,
literal|false
argument_list|,
name|gop
argument_list|)
expr_stmt|;
block|}
block|}
comment|// if UDAFs are present, new columns needs to be added
if|if
condition|(
operator|!
name|aggDesc
operator|.
name|isEmpty
argument_list|()
operator|&&
name|stats
operator|!=
literal|null
condition|)
block|{
name|List
argument_list|<
name|ColStatistics
argument_list|>
name|aggColStats
init|=
name|Lists
operator|.
name|newArrayList
argument_list|()
decl_stmt|;
for|for
control|(
name|ColumnInfo
name|ci
range|:
name|rs
operator|.
name|getSignature
argument_list|()
control|)
block|{
comment|// if the columns in row schema is not contained in column
comment|// expression map, then those are the aggregate columns that
comment|// are added GBY operator. we will estimate the column statistics
comment|// for those newly added columns
if|if
condition|(
operator|!
name|colExprMap
operator|.
name|containsKey
argument_list|(
name|ci
operator|.
name|getInternalName
argument_list|()
argument_list|)
condition|)
block|{
name|String
name|colName
init|=
name|ci
operator|.
name|getInternalName
argument_list|()
decl_stmt|;
name|String
name|colType
init|=
name|ci
operator|.
name|getTypeName
argument_list|()
decl_stmt|;
name|ColStatistics
name|cs
init|=
operator|new
name|ColStatistics
argument_list|(
name|colName
argument_list|,
name|colType
argument_list|)
decl_stmt|;
name|cs
operator|.
name|setCountDistint
argument_list|(
name|stats
operator|.
name|getNumRows
argument_list|()
argument_list|)
expr_stmt|;
name|cs
operator|.
name|setNumNulls
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|cs
operator|.
name|setAvgColLen
argument_list|(
name|StatsUtils
operator|.
name|getAvgColLenOfFixedLengthTypes
argument_list|(
name|colType
argument_list|)
argument_list|)
expr_stmt|;
name|aggColStats
operator|.
name|add
argument_list|(
name|cs
argument_list|)
expr_stmt|;
block|}
block|}
comment|// add the new aggregate column and recompute data size
if|if
condition|(
name|aggColStats
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
name|stats
operator|.
name|addToColumnStats
argument_list|(
name|aggColStats
argument_list|)
expr_stmt|;
comment|// only if the column stats is available, update the data size from
comment|// the column stats
if|if
condition|(
operator|!
name|stats
operator|.
name|getColumnStatsState
argument_list|()
operator|.
name|equals
argument_list|(
name|Statistics
operator|.
name|State
operator|.
name|NONE
argument_list|)
condition|)
block|{
name|updateStats
argument_list|(
name|stats
argument_list|,
name|stats
operator|.
name|getNumRows
argument_list|()
argument_list|,
literal|true
argument_list|,
name|gop
argument_list|)
expr_stmt|;
block|}
block|}
comment|// if UDAF present and if column expression map is empty then it must
comment|// be full aggregation query like count(*) in which case number of
comment|// rows will be 1
if|if
condition|(
name|colExprMap
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|stats
operator|.
name|setNumRows
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|updateStats
argument_list|(
name|stats
argument_list|,
literal|1
argument_list|,
literal|true
argument_list|,
name|gop
argument_list|)
expr_stmt|;
block|}
block|}
name|gop
operator|.
name|setStatistics
argument_list|(
name|stats
argument_list|)
expr_stmt|;
if|if
condition|(
name|isDebugEnabled
operator|&&
name|stats
operator|!=
literal|null
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"[0] STATS-"
operator|+
name|gop
operator|.
name|toString
argument_list|()
operator|+
literal|": "
operator|+
name|stats
operator|.
name|extendedToString
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|CloneNotSupportedException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|STATISTICS_CLONING_FAILED
operator|.
name|getMsg
argument_list|()
argument_list|)
throw|;
block|}
return|return
literal|null
return|;
block|}
comment|/**      * This method does not take into account many configs used at runtime to      * disable hash aggregation like HIVEMAPAGGRHASHMINREDUCTION. This method      * roughly estimates the number of rows and size of each row to see if it      * can fit in hashtable for aggregation.      * @param gop - group by operator      * @param colStats - column stats for key columns      * @param conf - hive conf      * @return      */
specifier|private
name|boolean
name|checkMapSideAggregation
parameter_list|(
name|GroupByOperator
name|gop
parameter_list|,
name|List
argument_list|<
name|ColStatistics
argument_list|>
name|colStats
parameter_list|,
name|HiveConf
name|conf
parameter_list|)
block|{
name|List
argument_list|<
name|AggregationDesc
argument_list|>
name|aggDesc
init|=
name|gop
operator|.
name|getConf
argument_list|()
operator|.
name|getAggregators
argument_list|()
decl_stmt|;
name|GroupByDesc
name|desc
init|=
name|gop
operator|.
name|getConf
argument_list|()
decl_stmt|;
name|GroupByDesc
operator|.
name|Mode
name|mode
init|=
name|desc
operator|.
name|getMode
argument_list|()
decl_stmt|;
if|if
condition|(
name|mode
operator|.
name|equals
argument_list|(
name|GroupByDesc
operator|.
name|Mode
operator|.
name|HASH
argument_list|)
condition|)
block|{
name|float
name|hashAggMem
init|=
name|conf
operator|.
name|getFloatVar
argument_list|(
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVEMAPAGGRHASHMEMORY
argument_list|)
decl_stmt|;
name|float
name|hashAggMaxThreshold
init|=
name|conf
operator|.
name|getFloatVar
argument_list|(
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVEMAPAGGRMEMORYTHRESHOLD
argument_list|)
decl_stmt|;
comment|// get available map memory
name|long
name|totalMemory
init|=
name|StatsUtils
operator|.
name|getAvailableMemory
argument_list|(
name|conf
argument_list|)
operator|*
literal|1000L
operator|*
literal|1000L
decl_stmt|;
name|long
name|maxMemHashAgg
init|=
name|Math
operator|.
name|round
argument_list|(
name|totalMemory
operator|*
name|hashAggMem
operator|*
name|hashAggMaxThreshold
argument_list|)
decl_stmt|;
comment|// estimated number of rows will be product of NDVs
name|long
name|numEstimatedRows
init|=
literal|1
decl_stmt|;
comment|// estimate size of key from column statistics
name|long
name|avgKeySize
init|=
literal|0
decl_stmt|;
for|for
control|(
name|ColStatistics
name|cs
range|:
name|colStats
control|)
block|{
if|if
condition|(
name|cs
operator|!=
literal|null
condition|)
block|{
name|numEstimatedRows
operator|=
name|StatsUtils
operator|.
name|safeMult
argument_list|(
name|numEstimatedRows
argument_list|,
name|cs
operator|.
name|getCountDistint
argument_list|()
argument_list|)
expr_stmt|;
name|avgKeySize
operator|+=
name|Math
operator|.
name|ceil
argument_list|(
name|cs
operator|.
name|getAvgColLen
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
comment|// average value size will be sum of all sizes of aggregation buffers
name|long
name|avgValSize
init|=
literal|0
decl_stmt|;
comment|// go over all aggregation buffers and see they implement estimable
comment|// interface if so they aggregate the size of the aggregation buffer
name|GenericUDAFEvaluator
index|[]
name|aggregationEvaluators
decl_stmt|;
name|aggregationEvaluators
operator|=
operator|new
name|GenericUDAFEvaluator
index|[
name|aggDesc
operator|.
name|size
argument_list|()
index|]
expr_stmt|;
comment|// get aggregation evaluators
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|aggregationEvaluators
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|AggregationDesc
name|agg
init|=
name|aggDesc
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|aggregationEvaluators
index|[
name|i
index|]
operator|=
name|agg
operator|.
name|getGenericUDAFEvaluator
argument_list|()
expr_stmt|;
block|}
comment|// estimate size of aggregation buffer
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|aggregationEvaluators
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
comment|// each evaluator has constant java object overhead
name|avgValSize
operator|+=
name|gop
operator|.
name|javaObjectOverHead
expr_stmt|;
name|GenericUDAFEvaluator
operator|.
name|AggregationBuffer
name|agg
init|=
literal|null
decl_stmt|;
try|try
block|{
name|agg
operator|=
name|aggregationEvaluators
index|[
name|i
index|]
operator|.
name|getNewAggregationBuffer
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|HiveException
name|e
parameter_list|)
block|{
comment|// in case of exception assume unknown type (256 bytes)
name|avgValSize
operator|+=
name|gop
operator|.
name|javaSizeUnknownType
expr_stmt|;
block|}
comment|// aggregate size from aggregation buffers
if|if
condition|(
name|agg
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|GenericUDAFEvaluator
operator|.
name|isEstimable
argument_list|(
name|agg
argument_list|)
condition|)
block|{
name|avgValSize
operator|+=
operator|(
operator|(
name|GenericUDAFEvaluator
operator|.
name|AbstractAggregationBuffer
operator|)
name|agg
operator|)
operator|.
name|estimate
argument_list|()
expr_stmt|;
block|}
else|else
block|{
comment|// if the aggregation buffer is not estimable then get all the
comment|// declared fields and compute the sizes from field types
name|Field
index|[]
name|fArr
init|=
name|ObjectInspectorUtils
operator|.
name|getDeclaredNonStaticFields
argument_list|(
name|agg
operator|.
name|getClass
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|Field
name|f
range|:
name|fArr
control|)
block|{
name|long
name|avgSize
init|=
name|StatsUtils
operator|.
name|getAvgColLenOfFixedLengthTypes
argument_list|(
name|f
operator|.
name|getType
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|)
decl_stmt|;
name|avgValSize
operator|+=
name|avgSize
operator|==
literal|0
condition|?
name|gop
operator|.
name|javaSizeUnknownType
else|:
name|avgSize
expr_stmt|;
block|}
block|}
block|}
block|}
comment|// total size of each hash entry
name|long
name|hashEntrySize
init|=
name|gop
operator|.
name|javaHashEntryOverHead
operator|+
name|avgKeySize
operator|+
name|avgValSize
decl_stmt|;
comment|// estimated hash table size
name|long
name|estHashTableSize
init|=
name|StatsUtils
operator|.
name|safeMult
argument_list|(
name|numEstimatedRows
argument_list|,
name|hashEntrySize
argument_list|)
decl_stmt|;
if|if
condition|(
name|estHashTableSize
operator|<
name|maxMemHashAgg
condition|)
block|{
return|return
literal|true
return|;
block|}
block|}
comment|// worst-case, hash aggregation disabled
return|return
literal|false
return|;
block|}
block|}
comment|/**    * JOIN operator can yield any of the following three cases<li>The values of join keys are    * disjoint in both relations in which case T(RXS) = 0 (we need histograms for this)</li><li>Join    * key is primary key on relation R and foreign key on relation S in which case every tuple in S    * will have a tuple in R T(RXS) = T(S) (we need histograms for this)</li><li>Both R& S relation    * have same value for join-key. Ex: bool column with all true values T(RXS) = T(R) * T(S) (we    * need histograms for this. counDistinct = 1 and same value)</li>    *<p>    * In the absence of histograms, we can use the following general case    *<p>    *<b>2 Relations, 1 attribute</b>    *<p>    * T(RXS) = (T(R)*T(S))/max(V(R,Y), V(S,Y)) where Y is the join attribute    *<p>    *<b>2 Relations, 2 attributes</b>    *<p>    * T(RXS) = T(R)*T(S)/max(V(R,y1), V(S,y1)) * max(V(R,y2), V(S,y2)), where y1 and y2 are the join    * attributes    *<p>    *<b>3 Relations, 1 attributes</b>    *<p>    * T(RXSXQ) = T(R)*T(S)*T(Q)/top2largest(V(R,y), V(S,y), V(Q,y)), where y is the join attribute    *<p>    *<b>3 Relations, 2 attributes</b>    *<p>    * T(RXSXQ) = T(R)*T(S)*T(Q)/top2largest(V(R,y1), V(S,y1), V(Q,y1)) * top2largest(V(R,y2), V(S,y2), V(Q,y2)),    * where y1 and y2 are the join attributes    *<p>    *<i>Worst case:</i> If no column statistics are available, then T(RXS) = joinFactor * max(T(R),    * T(S)) * (numParents - 1) will be used as heuristics. joinFactor is from hive.stats.join.factor    * hive config. In the worst case, since we do not know any information about join keys (and hence    * which of the 3 cases to use), we let it to the user to provide the join factor.    *<p>    *<i>For more information, refer 'Estimating The Cost Of Operations' chapter in    * "Database Systems: The Complete Book" by Garcia-Molina et. al.</i>    *</p>    */
specifier|public
specifier|static
class|class
name|JoinStatsRule
extends|extends
name|DefaultStatsRule
implements|implements
name|NodeProcessor
block|{
annotation|@
name|Override
specifier|public
name|Object
name|process
parameter_list|(
name|Node
name|nd
parameter_list|,
name|Stack
argument_list|<
name|Node
argument_list|>
name|stack
parameter_list|,
name|NodeProcessorCtx
name|procCtx
parameter_list|,
name|Object
modifier|...
name|nodeOutputs
parameter_list|)
throws|throws
name|SemanticException
block|{
name|long
name|newNumRows
init|=
literal|0
decl_stmt|;
name|CommonJoinOperator
argument_list|<
name|?
extends|extends
name|JoinDesc
argument_list|>
name|jop
init|=
operator|(
name|CommonJoinOperator
argument_list|<
name|?
extends|extends
name|JoinDesc
argument_list|>
operator|)
name|nd
decl_stmt|;
name|List
argument_list|<
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
argument_list|>
name|parents
init|=
name|jop
operator|.
name|getParentOperators
argument_list|()
decl_stmt|;
name|int
name|numAttr
init|=
literal|1
decl_stmt|;
name|AnnotateStatsProcCtx
name|aspCtx
init|=
operator|(
name|AnnotateStatsProcCtx
operator|)
name|procCtx
decl_stmt|;
name|HiveConf
name|conf
init|=
name|aspCtx
operator|.
name|getConf
argument_list|()
decl_stmt|;
name|boolean
name|allSatisfyPreCondition
init|=
literal|true
decl_stmt|;
for|for
control|(
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
name|op
range|:
name|parents
control|)
block|{
if|if
condition|(
name|op
operator|.
name|getStatistics
argument_list|()
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
block|}
for|for
control|(
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
name|op
range|:
name|parents
control|)
block|{
if|if
condition|(
operator|!
name|satisfyPrecondition
argument_list|(
name|op
operator|.
name|getStatistics
argument_list|()
argument_list|)
condition|)
block|{
name|allSatisfyPreCondition
operator|=
literal|false
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|allSatisfyPreCondition
condition|)
block|{
comment|// statistics object that is combination of statistics from all
comment|// relations involved in JOIN
name|Statistics
name|stats
init|=
operator|new
name|Statistics
argument_list|()
decl_stmt|;
name|int
name|numParent
init|=
name|parents
operator|.
name|size
argument_list|()
decl_stmt|;
name|Map
argument_list|<
name|Integer
argument_list|,
name|Long
argument_list|>
name|rowCountParents
init|=
name|Maps
operator|.
name|newHashMap
argument_list|()
decl_stmt|;
name|Map
argument_list|<
name|Integer
argument_list|,
name|Statistics
argument_list|>
name|joinStats
init|=
name|Maps
operator|.
name|newHashMap
argument_list|()
decl_stmt|;
name|Map
argument_list|<
name|Integer
argument_list|,
name|List
argument_list|<
name|String
argument_list|>
argument_list|>
name|joinKeys
init|=
name|Maps
operator|.
name|newHashMap
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|Long
argument_list|>
name|rowCounts
init|=
name|Lists
operator|.
name|newArrayList
argument_list|()
decl_stmt|;
comment|// detect if there are multiple attributes in join key
name|ReduceSinkOperator
name|rsOp
init|=
operator|(
name|ReduceSinkOperator
operator|)
name|jop
operator|.
name|getParentOperators
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|keyExprs
init|=
name|StatsUtils
operator|.
name|getQualifedReducerKeyNames
argument_list|(
name|rsOp
operator|.
name|getConf
argument_list|()
operator|.
name|getOutputKeyColumnNames
argument_list|()
argument_list|)
decl_stmt|;
name|numAttr
operator|=
name|keyExprs
operator|.
name|size
argument_list|()
expr_stmt|;
comment|// infer PK-FK relationship in single attribute join case
name|long
name|inferredRowCount
init|=
name|inferPKFKRelationship
argument_list|(
name|numAttr
argument_list|,
name|parents
argument_list|,
name|jop
argument_list|)
decl_stmt|;
comment|// get the join keys from parent ReduceSink operators
for|for
control|(
name|int
name|pos
init|=
literal|0
init|;
name|pos
operator|<
name|parents
operator|.
name|size
argument_list|()
condition|;
name|pos
operator|++
control|)
block|{
name|ReduceSinkOperator
name|parent
init|=
operator|(
name|ReduceSinkOperator
operator|)
name|jop
operator|.
name|getParentOperators
argument_list|()
operator|.
name|get
argument_list|(
name|pos
argument_list|)
decl_stmt|;
name|Statistics
name|parentStats
init|=
name|parent
operator|.
name|getStatistics
argument_list|()
decl_stmt|;
name|keyExprs
operator|=
name|StatsUtils
operator|.
name|getQualifedReducerKeyNames
argument_list|(
name|parent
operator|.
name|getConf
argument_list|()
operator|.
name|getOutputKeyColumnNames
argument_list|()
argument_list|)
expr_stmt|;
name|rowCountParents
operator|.
name|put
argument_list|(
name|pos
argument_list|,
name|parentStats
operator|.
name|getNumRows
argument_list|()
argument_list|)
expr_stmt|;
name|rowCounts
operator|.
name|add
argument_list|(
name|parentStats
operator|.
name|getNumRows
argument_list|()
argument_list|)
expr_stmt|;
comment|// internal name for expressions and estimate column statistics for expression.
name|joinKeys
operator|.
name|put
argument_list|(
name|pos
argument_list|,
name|keyExprs
argument_list|)
expr_stmt|;
comment|// get column statistics for all output columns
name|joinStats
operator|.
name|put
argument_list|(
name|pos
argument_list|,
name|parentStats
argument_list|)
expr_stmt|;
comment|// since new statistics is derived from all relations involved in
comment|// JOIN, we need to update the state information accordingly
name|stats
operator|.
name|updateColumnStatsState
argument_list|(
name|parentStats
operator|.
name|getColumnStatsState
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|numAttr
operator|==
literal|0
condition|)
block|{
comment|// It is a cartesian product, row count is easy to infer
name|inferredRowCount
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|int
name|pos
init|=
literal|0
init|;
name|pos
operator|<
name|parents
operator|.
name|size
argument_list|()
condition|;
name|pos
operator|++
control|)
block|{
name|inferredRowCount
operator|=
name|StatsUtils
operator|.
name|safeMult
argument_list|(
name|joinStats
operator|.
name|get
argument_list|(
name|pos
argument_list|)
operator|.
name|getNumRows
argument_list|()
argument_list|,
name|inferredRowCount
argument_list|)
expr_stmt|;
block|}
block|}
name|List
argument_list|<
name|Long
argument_list|>
name|distinctVals
init|=
name|Lists
operator|.
name|newArrayList
argument_list|()
decl_stmt|;
name|long
name|denom
init|=
literal|1
decl_stmt|;
if|if
condition|(
name|inferredRowCount
operator|==
operator|-
literal|1
condition|)
block|{
comment|// failed to infer PK-FK relationship for row count estimation fall-back on default logic
comment|// compute denominator  max(V(R,y1), V(S,y1)) * max(V(R,y2), V(S,y2))
comment|// in case of multi-attribute join
name|List
argument_list|<
name|Long
argument_list|>
name|perAttrDVs
init|=
name|Lists
operator|.
name|newArrayList
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|idx
init|=
literal|0
init|;
name|idx
operator|<
name|numAttr
condition|;
name|idx
operator|++
control|)
block|{
for|for
control|(
name|Integer
name|i
range|:
name|joinKeys
operator|.
name|keySet
argument_list|()
control|)
block|{
name|String
name|col
init|=
name|joinKeys
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|get
argument_list|(
name|idx
argument_list|)
decl_stmt|;
name|ColStatistics
name|cs
init|=
name|joinStats
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|getColumnStatisticsFromColName
argument_list|(
name|col
argument_list|)
decl_stmt|;
if|if
condition|(
name|cs
operator|!=
literal|null
condition|)
block|{
name|perAttrDVs
operator|.
name|add
argument_list|(
name|cs
operator|.
name|getCountDistint
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
name|distinctVals
operator|.
name|add
argument_list|(
name|getDenominator
argument_list|(
name|perAttrDVs
argument_list|)
argument_list|)
expr_stmt|;
name|perAttrDVs
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|numAttr
operator|>
name|numParent
condition|)
block|{
comment|// To avoid denominator getting larger and aggressively reducing
comment|// number of rows, we will ease out denominator.
name|denom
operator|=
name|StatsUtils
operator|.
name|addWithExpDecay
argument_list|(
name|distinctVals
argument_list|)
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|Long
name|l
range|:
name|distinctVals
control|)
block|{
name|denom
operator|=
name|StatsUtils
operator|.
name|safeMult
argument_list|(
name|denom
argument_list|,
name|l
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|// Update NDV of joined columns to be min(V(R,y), V(S,y))
name|updateJoinColumnsNDV
argument_list|(
name|joinKeys
argument_list|,
name|joinStats
argument_list|,
name|numAttr
argument_list|)
expr_stmt|;
comment|// column statistics from different sources are put together and
comment|// rename based on output schema of join operator
name|Map
argument_list|<
name|String
argument_list|,
name|ExprNodeDesc
argument_list|>
name|colExprMap
init|=
name|jop
operator|.
name|getColumnExprMap
argument_list|()
decl_stmt|;
name|RowSchema
name|rs
init|=
name|jop
operator|.
name|getSchema
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|ColStatistics
argument_list|>
name|outColStats
init|=
name|Lists
operator|.
name|newArrayList
argument_list|()
decl_stmt|;
for|for
control|(
name|ColumnInfo
name|ci
range|:
name|rs
operator|.
name|getSignature
argument_list|()
control|)
block|{
name|String
name|key
init|=
name|ci
operator|.
name|getInternalName
argument_list|()
decl_stmt|;
name|ExprNodeDesc
name|end
init|=
name|colExprMap
operator|.
name|get
argument_list|(
name|key
argument_list|)
decl_stmt|;
if|if
condition|(
name|end
operator|instanceof
name|ExprNodeColumnDesc
condition|)
block|{
name|String
name|colName
init|=
operator|(
operator|(
name|ExprNodeColumnDesc
operator|)
name|end
operator|)
operator|.
name|getColumn
argument_list|()
decl_stmt|;
name|int
name|pos
init|=
name|jop
operator|.
name|getConf
argument_list|()
operator|.
name|getReversedExprs
argument_list|()
operator|.
name|get
argument_list|(
name|key
argument_list|)
decl_stmt|;
name|ColStatistics
name|cs
init|=
name|joinStats
operator|.
name|get
argument_list|(
name|pos
argument_list|)
operator|.
name|getColumnStatisticsFromColName
argument_list|(
name|colName
argument_list|)
decl_stmt|;
name|String
name|outColName
init|=
name|key
decl_stmt|;
if|if
condition|(
name|cs
operator|!=
literal|null
condition|)
block|{
name|cs
operator|.
name|setColumnName
argument_list|(
name|outColName
argument_list|)
expr_stmt|;
block|}
name|outColStats
operator|.
name|add
argument_list|(
name|cs
argument_list|)
expr_stmt|;
block|}
block|}
comment|// update join statistics
name|stats
operator|.
name|setColumnStats
argument_list|(
name|outColStats
argument_list|)
expr_stmt|;
name|long
name|newRowCount
init|=
name|inferredRowCount
operator|!=
operator|-
literal|1
condition|?
name|inferredRowCount
else|:
name|computeNewRowCount
argument_list|(
name|rowCounts
argument_list|,
name|denom
argument_list|)
decl_stmt|;
name|updateStatsForJoinType
argument_list|(
name|stats
argument_list|,
name|newRowCount
argument_list|,
name|jop
argument_list|,
name|rowCountParents
argument_list|)
expr_stmt|;
name|jop
operator|.
name|setStatistics
argument_list|(
name|stats
argument_list|)
expr_stmt|;
if|if
condition|(
name|isDebugEnabled
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"[0] STATS-"
operator|+
name|jop
operator|.
name|toString
argument_list|()
operator|+
literal|": "
operator|+
name|stats
operator|.
name|extendedToString
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// worst case when there are no column statistics
name|float
name|joinFactor
init|=
name|HiveConf
operator|.
name|getFloatVar
argument_list|(
name|conf
argument_list|,
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVE_STATS_JOIN_FACTOR
argument_list|)
decl_stmt|;
name|int
name|numParents
init|=
name|parents
operator|.
name|size
argument_list|()
decl_stmt|;
name|long
name|crossRowCount
init|=
literal|1
decl_stmt|;
name|long
name|crossDataSize
init|=
literal|1
decl_stmt|;
name|long
name|maxRowCount
init|=
literal|0
decl_stmt|;
name|long
name|maxDataSize
init|=
literal|0
decl_stmt|;
for|for
control|(
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
name|op
range|:
name|parents
control|)
block|{
name|Statistics
name|ps
init|=
name|op
operator|.
name|getStatistics
argument_list|()
decl_stmt|;
name|long
name|rowCount
init|=
name|ps
operator|.
name|getNumRows
argument_list|()
decl_stmt|;
name|long
name|dataSize
init|=
name|ps
operator|.
name|getDataSize
argument_list|()
decl_stmt|;
comment|// Update cross size
name|long
name|newCrossRowCount
init|=
name|StatsUtils
operator|.
name|safeMult
argument_list|(
name|crossRowCount
argument_list|,
name|rowCount
argument_list|)
decl_stmt|;
name|long
name|newCrossDataSize
init|=
name|StatsUtils
operator|.
name|safeAdd
argument_list|(
name|StatsUtils
operator|.
name|safeMult
argument_list|(
name|crossDataSize
argument_list|,
name|rowCount
argument_list|)
argument_list|,
name|StatsUtils
operator|.
name|safeMult
argument_list|(
name|dataSize
argument_list|,
name|crossRowCount
argument_list|)
argument_list|)
decl_stmt|;
name|crossRowCount
operator|=
name|newCrossRowCount
expr_stmt|;
name|crossDataSize
operator|=
name|newCrossDataSize
expr_stmt|;
comment|// Update largest relation
if|if
condition|(
name|rowCount
operator|>
name|maxRowCount
condition|)
block|{
name|maxRowCount
operator|=
name|rowCount
expr_stmt|;
name|maxDataSize
operator|=
name|dataSize
expr_stmt|;
block|}
block|}
name|long
name|newDataSize
decl_stmt|;
comment|// detect if there are attributes in join key
name|boolean
name|cartesianProduct
init|=
literal|false
decl_stmt|;
if|if
condition|(
name|jop
operator|.
name|getParentOperators
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|instanceof
name|ReduceSinkOperator
condition|)
block|{
name|ReduceSinkOperator
name|rsOp
init|=
operator|(
name|ReduceSinkOperator
operator|)
name|jop
operator|.
name|getParentOperators
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|keyExprs
init|=
name|StatsUtils
operator|.
name|getQualifedReducerKeyNames
argument_list|(
name|rsOp
operator|.
name|getConf
argument_list|()
operator|.
name|getOutputKeyColumnNames
argument_list|()
argument_list|)
decl_stmt|;
name|cartesianProduct
operator|=
name|keyExprs
operator|.
name|size
argument_list|()
operator|==
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|jop
operator|instanceof
name|AbstractMapJoinOperator
condition|)
block|{
name|AbstractMapJoinOperator
argument_list|<
name|?
extends|extends
name|MapJoinDesc
argument_list|>
name|mjop
init|=
operator|(
name|AbstractMapJoinOperator
argument_list|<
name|?
extends|extends
name|MapJoinDesc
argument_list|>
operator|)
name|jop
decl_stmt|;
name|List
argument_list|<
name|ExprNodeDesc
argument_list|>
name|keyExprs
init|=
name|mjop
operator|.
name|getConf
argument_list|()
operator|.
name|getKeys
argument_list|()
operator|.
name|values
argument_list|()
operator|.
name|iterator
argument_list|()
operator|.
name|next
argument_list|()
decl_stmt|;
name|cartesianProduct
operator|=
name|keyExprs
operator|.
name|size
argument_list|()
operator|==
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|cartesianProduct
condition|)
block|{
comment|// Cartesian product
name|newNumRows
operator|=
name|crossRowCount
expr_stmt|;
name|newDataSize
operator|=
name|crossDataSize
expr_stmt|;
block|}
else|else
block|{
name|newNumRows
operator|=
name|StatsUtils
operator|.
name|safeMult
argument_list|(
name|StatsUtils
operator|.
name|safeMult
argument_list|(
name|maxRowCount
argument_list|,
operator|(
name|numParents
operator|-
literal|1
operator|)
argument_list|)
argument_list|,
name|joinFactor
argument_list|)
expr_stmt|;
name|newDataSize
operator|=
name|StatsUtils
operator|.
name|safeMult
argument_list|(
name|StatsUtils
operator|.
name|safeMult
argument_list|(
name|maxDataSize
argument_list|,
operator|(
name|numParents
operator|-
literal|1
operator|)
argument_list|)
argument_list|,
name|joinFactor
argument_list|)
expr_stmt|;
block|}
name|Statistics
name|wcStats
init|=
operator|new
name|Statistics
argument_list|()
decl_stmt|;
name|wcStats
operator|.
name|setNumRows
argument_list|(
name|newNumRows
argument_list|)
expr_stmt|;
name|wcStats
operator|.
name|setDataSize
argument_list|(
name|newDataSize
argument_list|)
expr_stmt|;
name|jop
operator|.
name|setStatistics
argument_list|(
name|wcStats
argument_list|)
expr_stmt|;
if|if
condition|(
name|isDebugEnabled
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"[1] STATS-"
operator|+
name|jop
operator|.
name|toString
argument_list|()
operator|+
literal|": "
operator|+
name|wcStats
operator|.
name|extendedToString
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
return|return
literal|null
return|;
block|}
specifier|private
name|long
name|inferPKFKRelationship
parameter_list|(
name|int
name|numAttr
parameter_list|,
name|List
argument_list|<
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
argument_list|>
name|parents
parameter_list|,
name|CommonJoinOperator
argument_list|<
name|?
extends|extends
name|JoinDesc
argument_list|>
name|jop
parameter_list|)
block|{
name|long
name|newNumRows
init|=
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|numAttr
operator|!=
literal|1
condition|)
block|{
return|return
name|newNumRows
return|;
block|}
comment|// If numAttr is 1, this means we join on one single key column.
name|Map
argument_list|<
name|Integer
argument_list|,
name|ColStatistics
argument_list|>
name|parentsWithPK
init|=
name|getPrimaryKeyCandidates
argument_list|(
name|parents
argument_list|)
decl_stmt|;
comment|// We only allow one single PK.
if|if
condition|(
name|parentsWithPK
operator|.
name|size
argument_list|()
operator|!=
literal|1
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"STATS-"
operator|+
name|jop
operator|.
name|toString
argument_list|()
operator|+
literal|": detects none/multiple PK parents."
argument_list|)
expr_stmt|;
return|return
name|newNumRows
return|;
block|}
name|Integer
name|pkPos
init|=
name|parentsWithPK
operator|.
name|keySet
argument_list|()
operator|.
name|iterator
argument_list|()
operator|.
name|next
argument_list|()
decl_stmt|;
name|ColStatistics
name|csPK
init|=
name|parentsWithPK
operator|.
name|values
argument_list|()
operator|.
name|iterator
argument_list|()
operator|.
name|next
argument_list|()
decl_stmt|;
comment|// infer foreign key candidates positions
name|Map
argument_list|<
name|Integer
argument_list|,
name|ColStatistics
argument_list|>
name|csFKs
init|=
name|getForeignKeyCandidates
argument_list|(
name|parents
argument_list|,
name|csPK
argument_list|)
decl_stmt|;
comment|// we allow multiple foreign keys (snowflake schema)
comment|// csfKs.size() + 1 == parents.size() means we have a single PK and all
comment|// the rest ops are FKs.
if|if
condition|(
name|csFKs
operator|.
name|size
argument_list|()
operator|+
literal|1
operator|==
name|parents
operator|.
name|size
argument_list|()
condition|)
block|{
name|newNumRows
operator|=
name|getCardinality
argument_list|(
name|parents
argument_list|,
name|pkPos
argument_list|,
name|csPK
argument_list|,
name|csFKs
argument_list|,
name|jop
argument_list|)
expr_stmt|;
comment|// some debug information
if|if
condition|(
name|isDebugEnabled
condition|)
block|{
name|List
argument_list|<
name|String
argument_list|>
name|parentIds
init|=
name|Lists
operator|.
name|newArrayList
argument_list|()
decl_stmt|;
comment|// print primary key containing parents
for|for
control|(
name|Integer
name|i
range|:
name|parentsWithPK
operator|.
name|keySet
argument_list|()
control|)
block|{
name|parentIds
operator|.
name|add
argument_list|(
name|parents
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|LOG
operator|.
name|debug
argument_list|(
literal|"STATS-"
operator|+
name|jop
operator|.
name|toString
argument_list|()
operator|+
literal|": PK parent id(s) - "
operator|+
name|parentIds
argument_list|)
expr_stmt|;
name|parentIds
operator|.
name|clear
argument_list|()
expr_stmt|;
comment|// print foreign key containing parents
for|for
control|(
name|Integer
name|i
range|:
name|csFKs
operator|.
name|keySet
argument_list|()
control|)
block|{
name|parentIds
operator|.
name|add
argument_list|(
name|parents
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|LOG
operator|.
name|debug
argument_list|(
literal|"STATS-"
operator|+
name|jop
operator|.
name|toString
argument_list|()
operator|+
literal|": FK parent id(s) - "
operator|+
name|parentIds
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|newNumRows
return|;
block|}
comment|/**      * Get cardinality of reduce sink operators.      * @param csPK - ColStatistics for a single primary key      * @param csFKs - ColStatistics for multiple foreign keys      */
specifier|private
name|long
name|getCardinality
parameter_list|(
name|List
argument_list|<
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
argument_list|>
name|ops
parameter_list|,
name|Integer
name|pkPos
parameter_list|,
name|ColStatistics
name|csPK
parameter_list|,
name|Map
argument_list|<
name|Integer
argument_list|,
name|ColStatistics
argument_list|>
name|csFKs
parameter_list|,
name|CommonJoinOperator
argument_list|<
name|?
extends|extends
name|JoinDesc
argument_list|>
name|jop
parameter_list|)
block|{
name|double
name|pkfkSelectivity
init|=
name|Double
operator|.
name|MAX_VALUE
decl_stmt|;
name|int
name|fkInd
init|=
operator|-
literal|1
decl_stmt|;
comment|// 1. We iterate through all the operators that have candidate FKs and
comment|// choose the FK that has the minimum selectivity. We assume that PK and this FK
comment|// have the PK-FK relationship. This is heuristic and can be
comment|// improved later.
for|for
control|(
name|Entry
argument_list|<
name|Integer
argument_list|,
name|ColStatistics
argument_list|>
name|entry
range|:
name|csFKs
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|int
name|pos
init|=
name|entry
operator|.
name|getKey
argument_list|()
decl_stmt|;
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
name|opWithPK
init|=
name|ops
operator|.
name|get
argument_list|(
name|pkPos
argument_list|)
decl_stmt|;
name|double
name|selectivity
init|=
name|getSelectivitySimpleTree
argument_list|(
name|opWithPK
argument_list|)
decl_stmt|;
name|double
name|selectivityAdjustment
init|=
name|StatsUtils
operator|.
name|getScaledSelectivity
argument_list|(
name|csPK
argument_list|,
name|entry
operator|.
name|getValue
argument_list|()
argument_list|)
decl_stmt|;
name|selectivity
operator|=
name|selectivityAdjustment
operator|*
name|selectivity
operator|>
literal|1
condition|?
name|selectivity
else|:
name|selectivityAdjustment
operator|*
name|selectivity
expr_stmt|;
if|if
condition|(
name|selectivity
operator|<
name|pkfkSelectivity
condition|)
block|{
name|pkfkSelectivity
operator|=
name|selectivity
expr_stmt|;
name|fkInd
operator|=
name|pos
expr_stmt|;
block|}
block|}
name|long
name|newrows
init|=
literal|1
decl_stmt|;
name|List
argument_list|<
name|Long
argument_list|>
name|rowCounts
init|=
name|Lists
operator|.
name|newArrayList
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|Long
argument_list|>
name|distinctVals
init|=
name|Lists
operator|.
name|newArrayList
argument_list|()
decl_stmt|;
comment|// 2. We then iterate through all the operators that have candidate FKs again.
comment|// We assume the PK is first joining with the FK that we just selected.
comment|// And we apply the PK-FK relationship when we compute the newrows and ndv.
comment|// After that, we join the result with all the other FKs.
comment|// We do not assume the PK-FK relationship anymore and just compute the
comment|// row count using the classic formula.
for|for
control|(
name|Entry
argument_list|<
name|Integer
argument_list|,
name|ColStatistics
argument_list|>
name|entry
range|:
name|csFKs
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|int
name|pos
init|=
name|entry
operator|.
name|getKey
argument_list|()
decl_stmt|;
name|ColStatistics
name|csFK
init|=
name|entry
operator|.
name|getValue
argument_list|()
decl_stmt|;
name|ReduceSinkOperator
name|parent
init|=
operator|(
name|ReduceSinkOperator
operator|)
name|jop
operator|.
name|getParentOperators
argument_list|()
operator|.
name|get
argument_list|(
name|pos
argument_list|)
decl_stmt|;
name|Statistics
name|parentStats
init|=
name|parent
operator|.
name|getStatistics
argument_list|()
decl_stmt|;
if|if
condition|(
name|fkInd
operator|==
name|pos
condition|)
block|{
comment|// 2.1 This is the new number of rows after PK is joining with FK
name|newrows
operator|=
operator|(
name|long
operator|)
name|Math
operator|.
name|ceil
argument_list|(
name|parentStats
operator|.
name|getNumRows
argument_list|()
operator|*
name|pkfkSelectivity
argument_list|)
expr_stmt|;
name|rowCounts
operator|.
name|add
argument_list|(
name|newrows
argument_list|)
expr_stmt|;
comment|// 2.1 The ndv is the minimum of the PK and the FK.
name|distinctVals
operator|.
name|add
argument_list|(
name|Math
operator|.
name|min
argument_list|(
name|csFK
operator|.
name|getCountDistint
argument_list|()
argument_list|,
name|csPK
operator|.
name|getCountDistint
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// 2.2 All the other FKs.
name|rowCounts
operator|.
name|add
argument_list|(
name|parentStats
operator|.
name|getNumRows
argument_list|()
argument_list|)
expr_stmt|;
name|distinctVals
operator|.
name|add
argument_list|(
name|csFK
operator|.
name|getCountDistint
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
name|long
name|newNumRows
decl_stmt|;
if|if
condition|(
name|csFKs
operator|.
name|size
argument_list|()
operator|==
literal|1
condition|)
block|{
comment|// there is only one FK
name|newNumRows
operator|=
name|newrows
expr_stmt|;
block|}
else|else
block|{
comment|// there is more than one FK
name|newNumRows
operator|=
name|this
operator|.
name|computeNewRowCount
argument_list|(
name|rowCounts
argument_list|,
name|getDenominator
argument_list|(
name|distinctVals
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|newNumRows
return|;
block|}
specifier|private
name|float
name|getSelectivitySimpleTree
parameter_list|(
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
name|op
parameter_list|)
block|{
name|TableScanOperator
name|tsOp
init|=
name|OperatorUtils
operator|.
name|findSingleOperatorUpstream
argument_list|(
name|op
argument_list|,
name|TableScanOperator
operator|.
name|class
argument_list|)
decl_stmt|;
if|if
condition|(
name|tsOp
operator|==
literal|null
condition|)
block|{
comment|// complex tree with multiple parents
return|return
name|getSelectivityComplexTree
argument_list|(
name|op
argument_list|)
return|;
block|}
else|else
block|{
comment|// simple tree with single parent
name|long
name|inputRow
init|=
name|tsOp
operator|.
name|getStatistics
argument_list|()
operator|.
name|getNumRows
argument_list|()
decl_stmt|;
name|long
name|outputRow
init|=
name|op
operator|.
name|getStatistics
argument_list|()
operator|.
name|getNumRows
argument_list|()
decl_stmt|;
return|return
operator|(
name|float
operator|)
name|outputRow
operator|/
operator|(
name|float
operator|)
name|inputRow
return|;
block|}
block|}
specifier|private
name|float
name|getSelectivityComplexTree
parameter_list|(
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
name|op
parameter_list|)
block|{
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
name|multiParentOp
init|=
literal|null
decl_stmt|;
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
name|currentOp
init|=
name|op
decl_stmt|;
comment|// TS-1      TS-2
comment|//  |          |
comment|// RS-1      RS-2
comment|//    \      /
comment|//      JOIN
comment|//        |
comment|//       FIL
comment|//        |
comment|//       RS-3
comment|//
comment|// For the above complex operator tree,
comment|// selectivity(JOIN) = selectivity(RS-1) * selectivity(RS-2) and
comment|// selectivity(RS-3) = numRows(RS-3)/numRows(JOIN) * selectivity(JOIN)
while|while
condition|(
name|multiParentOp
operator|==
literal|null
condition|)
block|{
if|if
condition|(
name|op
operator|.
name|getParentOperators
argument_list|()
operator|.
name|size
argument_list|()
operator|>
literal|1
condition|)
block|{
name|multiParentOp
operator|=
name|op
expr_stmt|;
block|}
else|else
block|{
name|op
operator|=
name|op
operator|.
name|getParentOperators
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
comment|// No need for overflow checks, assume selectivity is always<= 1.0
name|float
name|selMultiParent
init|=
literal|1.0f
decl_stmt|;
for|for
control|(
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
name|parent
range|:
name|multiParentOp
operator|.
name|getParentOperators
argument_list|()
control|)
block|{
comment|// In the above example, TS-1 -> RS-1 and TS-2 -> RS-2 are simple trees
name|selMultiParent
operator|*=
name|getSelectivitySimpleTree
argument_list|(
name|parent
argument_list|)
expr_stmt|;
block|}
name|float
name|selCurrOp
init|=
operator|(
operator|(
name|float
operator|)
name|currentOp
operator|.
name|getStatistics
argument_list|()
operator|.
name|getNumRows
argument_list|()
operator|/
operator|(
name|float
operator|)
name|multiParentOp
operator|.
name|getStatistics
argument_list|()
operator|.
name|getNumRows
argument_list|()
operator|)
operator|*
name|selMultiParent
decl_stmt|;
return|return
name|selCurrOp
return|;
block|}
comment|/**      * Returns the index of parents whose join key column statistics ranges are within the specified      * primary key range (inferred as foreign keys).      * @param ops - operators      * @param csPK - column statistics of primary key      * @return - a map which contains position ids and the corresponding column statistics      */
specifier|private
name|Map
argument_list|<
name|Integer
argument_list|,
name|ColStatistics
argument_list|>
name|getForeignKeyCandidates
parameter_list|(
name|List
argument_list|<
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
argument_list|>
name|ops
parameter_list|,
name|ColStatistics
name|csPK
parameter_list|)
block|{
name|Map
argument_list|<
name|Integer
argument_list|,
name|ColStatistics
argument_list|>
name|result
init|=
operator|new
name|HashMap
argument_list|<
name|Integer
argument_list|,
name|ColStatistics
argument_list|>
argument_list|()
decl_stmt|;
if|if
condition|(
name|csPK
operator|==
literal|null
operator|||
name|ops
operator|==
literal|null
condition|)
block|{
return|return
name|result
return|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|ops
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
name|op
init|=
name|ops
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|op
operator|!=
literal|null
operator|&&
name|op
operator|instanceof
name|ReduceSinkOperator
condition|)
block|{
name|ReduceSinkOperator
name|rsOp
init|=
operator|(
name|ReduceSinkOperator
operator|)
name|op
decl_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|keys
init|=
name|StatsUtils
operator|.
name|getQualifedReducerKeyNames
argument_list|(
name|rsOp
operator|.
name|getConf
argument_list|()
operator|.
name|getOutputKeyColumnNames
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|keys
operator|.
name|size
argument_list|()
operator|==
literal|1
condition|)
block|{
name|String
name|joinCol
init|=
name|keys
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|rsOp
operator|.
name|getStatistics
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|ColStatistics
name|cs
init|=
name|rsOp
operator|.
name|getStatistics
argument_list|()
operator|.
name|getColumnStatisticsFromColName
argument_list|(
name|joinCol
argument_list|)
decl_stmt|;
if|if
condition|(
name|cs
operator|!=
literal|null
operator|&&
operator|!
name|cs
operator|.
name|isPrimaryKey
argument_list|()
condition|)
block|{
if|if
condition|(
name|StatsUtils
operator|.
name|inferForeignKey
argument_list|(
name|csPK
argument_list|,
name|cs
argument_list|)
condition|)
block|{
name|result
operator|.
name|put
argument_list|(
name|i
argument_list|,
name|cs
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
block|}
return|return
name|result
return|;
block|}
comment|/**      * Returns the index of parents whose join key columns are infer as primary keys      * @param ops - operators      * @return - list of primary key containing parent ids      */
specifier|private
name|Map
argument_list|<
name|Integer
argument_list|,
name|ColStatistics
argument_list|>
name|getPrimaryKeyCandidates
parameter_list|(
name|List
argument_list|<
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
argument_list|>
name|ops
parameter_list|)
block|{
name|Map
argument_list|<
name|Integer
argument_list|,
name|ColStatistics
argument_list|>
name|result
init|=
operator|new
name|HashMap
argument_list|<
name|Integer
argument_list|,
name|ColStatistics
argument_list|>
argument_list|()
decl_stmt|;
if|if
condition|(
name|ops
operator|!=
literal|null
operator|&&
operator|!
name|ops
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|ops
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
name|op
init|=
name|ops
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|op
operator|instanceof
name|ReduceSinkOperator
condition|)
block|{
name|ReduceSinkOperator
name|rsOp
init|=
operator|(
name|ReduceSinkOperator
operator|)
name|op
decl_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|keys
init|=
name|StatsUtils
operator|.
name|getQualifedReducerKeyNames
argument_list|(
name|rsOp
operator|.
name|getConf
argument_list|()
operator|.
name|getOutputKeyColumnNames
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|keys
operator|.
name|size
argument_list|()
operator|==
literal|1
condition|)
block|{
name|String
name|joinCol
init|=
name|keys
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|rsOp
operator|.
name|getStatistics
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|ColStatistics
name|cs
init|=
name|rsOp
operator|.
name|getStatistics
argument_list|()
operator|.
name|getColumnStatisticsFromColName
argument_list|(
name|joinCol
argument_list|)
decl_stmt|;
if|if
condition|(
name|cs
operator|!=
literal|null
operator|&&
name|cs
operator|.
name|isPrimaryKey
argument_list|()
condition|)
block|{
name|result
operator|.
name|put
argument_list|(
name|i
argument_list|,
name|cs
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
block|}
return|return
name|result
return|;
block|}
specifier|private
name|void
name|updateStatsForJoinType
parameter_list|(
name|Statistics
name|stats
parameter_list|,
name|long
name|newNumRows
parameter_list|,
name|CommonJoinOperator
argument_list|<
name|?
extends|extends
name|JoinDesc
argument_list|>
name|jop
parameter_list|,
name|Map
argument_list|<
name|Integer
argument_list|,
name|Long
argument_list|>
name|rowCountParents
parameter_list|)
block|{
if|if
condition|(
name|newNumRows
operator|<
literal|0
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"STATS-"
operator|+
name|jop
operator|.
name|toString
argument_list|()
operator|+
literal|": Overflow in number of rows."
operator|+
name|newNumRows
operator|+
literal|" rows will be set to Long.MAX_VALUE"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|newNumRows
operator|==
literal|0
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"STATS-"
operator|+
name|jop
operator|.
name|toString
argument_list|()
operator|+
literal|": Equals 0 in number of rows."
operator|+
name|newNumRows
operator|+
literal|" rows will be set to 1"
argument_list|)
expr_stmt|;
name|newNumRows
operator|=
literal|1
expr_stmt|;
block|}
name|newNumRows
operator|=
name|StatsUtils
operator|.
name|getMaxIfOverflow
argument_list|(
name|newNumRows
argument_list|)
expr_stmt|;
name|stats
operator|.
name|setNumRows
argument_list|(
name|newNumRows
argument_list|)
expr_stmt|;
comment|// scale down/up the column statistics based on the changes in number of
comment|// rows from each parent. For ex: If there are 2 parents for JOIN operator
comment|// with 1st parent having 200 rows and 2nd parent having 2000 rows. Now if
comment|// the new number of rows after applying join rule is 10, then the column
comment|// stats for columns from 1st parent should be scaled down by 200/10 = 20x
comment|// and stats for columns from 2nd parent should be scaled down by 200x
name|List
argument_list|<
name|ColStatistics
argument_list|>
name|colStats
init|=
name|stats
operator|.
name|getColumnStats
argument_list|()
decl_stmt|;
for|for
control|(
name|ColStatistics
name|cs
range|:
name|colStats
control|)
block|{
name|int
name|pos
init|=
name|jop
operator|.
name|getConf
argument_list|()
operator|.
name|getReversedExprs
argument_list|()
operator|.
name|get
argument_list|(
name|cs
operator|.
name|getColumnName
argument_list|()
argument_list|)
decl_stmt|;
name|long
name|oldRowCount
init|=
name|rowCountParents
operator|.
name|get
argument_list|(
name|pos
argument_list|)
decl_stmt|;
name|double
name|ratio
init|=
operator|(
name|double
operator|)
name|newNumRows
operator|/
operator|(
name|double
operator|)
name|oldRowCount
decl_stmt|;
name|long
name|oldDV
init|=
name|cs
operator|.
name|getCountDistint
argument_list|()
decl_stmt|;
name|long
name|newDV
init|=
name|oldDV
decl_stmt|;
comment|// if ratio is greater than 1, then number of rows increases. This can happen
comment|// when some operators like GROUPBY duplicates the input rows in which case
comment|// number of distincts should not change. Update the distinct count only when
comment|// the output number of rows is less than input number of rows.
if|if
condition|(
name|ratio
operator|<=
literal|1.0
condition|)
block|{
name|newDV
operator|=
operator|(
name|long
operator|)
name|Math
operator|.
name|ceil
argument_list|(
name|ratio
operator|*
name|oldDV
argument_list|)
expr_stmt|;
block|}
comment|// Assumes inner join
comment|// TODO: HIVE-5579 will handle different join types
name|cs
operator|.
name|setNumNulls
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|cs
operator|.
name|setCountDistint
argument_list|(
name|newDV
argument_list|)
expr_stmt|;
block|}
name|stats
operator|.
name|setColumnStats
argument_list|(
name|colStats
argument_list|)
expr_stmt|;
name|long
name|newDataSize
init|=
name|StatsUtils
operator|.
name|getDataSizeFromColumnStats
argument_list|(
name|newNumRows
argument_list|,
name|colStats
argument_list|)
decl_stmt|;
name|stats
operator|.
name|setDataSize
argument_list|(
name|StatsUtils
operator|.
name|getMaxIfOverflow
argument_list|(
name|newDataSize
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|private
name|long
name|computeNewRowCount
parameter_list|(
name|List
argument_list|<
name|Long
argument_list|>
name|rowCountParents
parameter_list|,
name|long
name|denom
parameter_list|)
block|{
name|double
name|factor
init|=
literal|0.0d
decl_stmt|;
name|long
name|result
init|=
literal|1
decl_stmt|;
name|long
name|max
init|=
name|rowCountParents
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|long
name|maxIdx
init|=
literal|0
decl_stmt|;
comment|// To avoid long overflow, we will divide the max row count by denominator
comment|// and use that factor to multiply with other row counts
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<
name|rowCountParents
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|rowCountParents
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|>
name|max
condition|)
block|{
name|max
operator|=
name|rowCountParents
operator|.
name|get
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|maxIdx
operator|=
name|i
expr_stmt|;
block|}
block|}
name|denom
operator|=
name|denom
operator|==
literal|0
condition|?
literal|1
else|:
name|denom
expr_stmt|;
name|factor
operator|=
operator|(
name|double
operator|)
name|max
operator|/
operator|(
name|double
operator|)
name|denom
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|rowCountParents
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|!=
name|maxIdx
condition|)
block|{
name|result
operator|=
name|StatsUtils
operator|.
name|safeMult
argument_list|(
name|result
argument_list|,
name|rowCountParents
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|result
operator|=
call|(
name|long
call|)
argument_list|(
name|result
operator|*
name|factor
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
specifier|private
name|void
name|updateJoinColumnsNDV
parameter_list|(
name|Map
argument_list|<
name|Integer
argument_list|,
name|List
argument_list|<
name|String
argument_list|>
argument_list|>
name|joinKeys
parameter_list|,
name|Map
argument_list|<
name|Integer
argument_list|,
name|Statistics
argument_list|>
name|joinStats
parameter_list|,
name|int
name|numAttr
parameter_list|)
block|{
name|int
name|joinColIdx
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|numAttr
operator|>
literal|0
condition|)
block|{
name|long
name|minNDV
init|=
name|Long
operator|.
name|MAX_VALUE
decl_stmt|;
comment|// find min NDV for joining columns
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|Integer
argument_list|,
name|List
argument_list|<
name|String
argument_list|>
argument_list|>
name|entry
range|:
name|joinKeys
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|int
name|pos
init|=
name|entry
operator|.
name|getKey
argument_list|()
decl_stmt|;
name|String
name|key
init|=
name|entry
operator|.
name|getValue
argument_list|()
operator|.
name|get
argument_list|(
name|joinColIdx
argument_list|)
decl_stmt|;
name|ColStatistics
name|cs
init|=
name|joinStats
operator|.
name|get
argument_list|(
name|pos
argument_list|)
operator|.
name|getColumnStatisticsFromColName
argument_list|(
name|key
argument_list|)
decl_stmt|;
if|if
condition|(
name|cs
operator|!=
literal|null
operator|&&
name|cs
operator|.
name|getCountDistint
argument_list|()
operator|<
name|minNDV
condition|)
block|{
name|minNDV
operator|=
name|cs
operator|.
name|getCountDistint
argument_list|()
expr_stmt|;
block|}
block|}
comment|// set min NDV value to both columns involved in join
if|if
condition|(
name|minNDV
operator|!=
name|Long
operator|.
name|MAX_VALUE
condition|)
block|{
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|Integer
argument_list|,
name|List
argument_list|<
name|String
argument_list|>
argument_list|>
name|entry
range|:
name|joinKeys
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|int
name|pos
init|=
name|entry
operator|.
name|getKey
argument_list|()
decl_stmt|;
name|String
name|key
init|=
name|entry
operator|.
name|getValue
argument_list|()
operator|.
name|get
argument_list|(
name|joinColIdx
argument_list|)
decl_stmt|;
name|ColStatistics
name|cs
init|=
name|joinStats
operator|.
name|get
argument_list|(
name|pos
argument_list|)
operator|.
name|getColumnStatisticsFromColName
argument_list|(
name|key
argument_list|)
decl_stmt|;
if|if
condition|(
name|cs
operator|!=
literal|null
condition|)
block|{
name|cs
operator|.
name|setCountDistint
argument_list|(
name|minNDV
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|joinColIdx
operator|++
expr_stmt|;
name|numAttr
operator|--
expr_stmt|;
block|}
block|}
specifier|private
name|long
name|getDenominator
parameter_list|(
name|List
argument_list|<
name|Long
argument_list|>
name|distinctVals
parameter_list|)
block|{
if|if
condition|(
name|distinctVals
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
comment|// TODO: in union20.q the tab alias is not properly propagated down the
comment|// operator tree. This happens when UNION ALL is used as sub query. Hence, even
comment|// if column statistics are available, the tab alias will be null which will fail
comment|// to get proper column statistics. For now assume, worst case in which
comment|// denominator is 2.
return|return
literal|2
return|;
block|}
comment|// simple join from 2 relations: denom = max(v1, v2)
if|if
condition|(
name|distinctVals
operator|.
name|size
argument_list|()
operator|<=
literal|2
condition|)
block|{
return|return
name|Collections
operator|.
name|max
argument_list|(
name|distinctVals
argument_list|)
return|;
block|}
else|else
block|{
comment|// remember min value and ignore it from the denominator
name|long
name|minNDV
init|=
name|distinctVals
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|int
name|minIdx
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<
name|distinctVals
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|distinctVals
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|<
name|minNDV
condition|)
block|{
name|minNDV
operator|=
name|distinctVals
operator|.
name|get
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|minIdx
operator|=
name|i
expr_stmt|;
block|}
block|}
comment|// join from multiple relations:
comment|// denom = Product of all NDVs except the least of all
name|long
name|denom
init|=
literal|1
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|distinctVals
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|!=
name|minIdx
condition|)
block|{
name|denom
operator|=
name|StatsUtils
operator|.
name|safeMult
argument_list|(
name|denom
argument_list|,
name|distinctVals
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|denom
return|;
block|}
block|}
block|}
comment|/**    * LIMIT operator changes the number of rows and thereby the data size.    */
specifier|public
specifier|static
class|class
name|LimitStatsRule
extends|extends
name|DefaultStatsRule
implements|implements
name|NodeProcessor
block|{
annotation|@
name|Override
specifier|public
name|Object
name|process
parameter_list|(
name|Node
name|nd
parameter_list|,
name|Stack
argument_list|<
name|Node
argument_list|>
name|stack
parameter_list|,
name|NodeProcessorCtx
name|procCtx
parameter_list|,
name|Object
modifier|...
name|nodeOutputs
parameter_list|)
throws|throws
name|SemanticException
block|{
name|LimitOperator
name|lop
init|=
operator|(
name|LimitOperator
operator|)
name|nd
decl_stmt|;
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
name|parent
init|=
name|lop
operator|.
name|getParentOperators
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|Statistics
name|parentStats
init|=
name|parent
operator|.
name|getStatistics
argument_list|()
decl_stmt|;
try|try
block|{
name|long
name|limit
init|=
operator|-
literal|1
decl_stmt|;
name|limit
operator|=
name|lop
operator|.
name|getConf
argument_list|()
operator|.
name|getLimit
argument_list|()
expr_stmt|;
if|if
condition|(
name|satisfyPrecondition
argument_list|(
name|parentStats
argument_list|)
condition|)
block|{
name|Statistics
name|stats
init|=
name|parentStats
operator|.
name|clone
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|ColStatistics
argument_list|>
name|colStats
init|=
name|StatsUtils
operator|.
name|getColStatisticsUpdatingTableAlias
argument_list|(
name|parentStats
argument_list|,
name|lop
operator|.
name|getSchema
argument_list|()
argument_list|)
decl_stmt|;
name|stats
operator|.
name|setColumnStats
argument_list|(
name|colStats
argument_list|)
expr_stmt|;
comment|// if limit is greater than available rows then do not update
comment|// statistics
if|if
condition|(
name|limit
operator|<=
name|parentStats
operator|.
name|getNumRows
argument_list|()
condition|)
block|{
name|updateStats
argument_list|(
name|stats
argument_list|,
name|limit
argument_list|,
literal|true
argument_list|,
name|lop
argument_list|)
expr_stmt|;
block|}
name|lop
operator|.
name|setStatistics
argument_list|(
name|stats
argument_list|)
expr_stmt|;
if|if
condition|(
name|isDebugEnabled
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"[0] STATS-"
operator|+
name|lop
operator|.
name|toString
argument_list|()
operator|+
literal|": "
operator|+
name|stats
operator|.
name|extendedToString
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|parentStats
operator|!=
literal|null
condition|)
block|{
comment|// in the absence of column statistics, compute data size based on
comment|// based on average row size
name|Statistics
name|wcStats
init|=
name|parentStats
operator|.
name|clone
argument_list|()
decl_stmt|;
name|limit
operator|=
name|StatsUtils
operator|.
name|getMaxIfOverflow
argument_list|(
name|limit
argument_list|)
expr_stmt|;
if|if
condition|(
name|limit
operator|<=
name|parentStats
operator|.
name|getNumRows
argument_list|()
condition|)
block|{
name|long
name|numRows
init|=
name|limit
decl_stmt|;
name|long
name|avgRowSize
init|=
name|parentStats
operator|.
name|getAvgRowSize
argument_list|()
decl_stmt|;
name|long
name|dataSize
init|=
name|StatsUtils
operator|.
name|safeMult
argument_list|(
name|avgRowSize
argument_list|,
name|limit
argument_list|)
decl_stmt|;
name|wcStats
operator|.
name|setNumRows
argument_list|(
name|numRows
argument_list|)
expr_stmt|;
name|wcStats
operator|.
name|setDataSize
argument_list|(
name|dataSize
argument_list|)
expr_stmt|;
block|}
name|lop
operator|.
name|setStatistics
argument_list|(
name|wcStats
argument_list|)
expr_stmt|;
if|if
condition|(
name|isDebugEnabled
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"[1] STATS-"
operator|+
name|lop
operator|.
name|toString
argument_list|()
operator|+
literal|": "
operator|+
name|wcStats
operator|.
name|extendedToString
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
catch|catch
parameter_list|(
name|CloneNotSupportedException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|STATISTICS_CLONING_FAILED
operator|.
name|getMsg
argument_list|()
argument_list|)
throw|;
block|}
return|return
literal|null
return|;
block|}
block|}
comment|/**    * ReduceSink operator does not change any of the statistics. But it renames    * the column statistics from its parent based on the output key and value    * column names to make it easy for the downstream operators. This is different    * from the default stats which just aggregates and passes along the statistics    * without actually renaming based on output schema of the operator.    */
specifier|public
specifier|static
class|class
name|ReduceSinkStatsRule
extends|extends
name|DefaultStatsRule
implements|implements
name|NodeProcessor
block|{
annotation|@
name|Override
specifier|public
name|Object
name|process
parameter_list|(
name|Node
name|nd
parameter_list|,
name|Stack
argument_list|<
name|Node
argument_list|>
name|stack
parameter_list|,
name|NodeProcessorCtx
name|procCtx
parameter_list|,
name|Object
modifier|...
name|nodeOutputs
parameter_list|)
throws|throws
name|SemanticException
block|{
name|ReduceSinkOperator
name|rop
init|=
operator|(
name|ReduceSinkOperator
operator|)
name|nd
decl_stmt|;
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
name|parent
init|=
name|rop
operator|.
name|getParentOperators
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|Statistics
name|parentStats
init|=
name|parent
operator|.
name|getStatistics
argument_list|()
decl_stmt|;
if|if
condition|(
name|parentStats
operator|!=
literal|null
condition|)
block|{
name|AnnotateStatsProcCtx
name|aspCtx
init|=
operator|(
name|AnnotateStatsProcCtx
operator|)
name|procCtx
decl_stmt|;
name|HiveConf
name|conf
init|=
name|aspCtx
operator|.
name|getConf
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|outKeyColNames
init|=
name|rop
operator|.
name|getConf
argument_list|()
operator|.
name|getOutputKeyColumnNames
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|outValueColNames
init|=
name|rop
operator|.
name|getConf
argument_list|()
operator|.
name|getOutputValueColumnNames
argument_list|()
decl_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|ExprNodeDesc
argument_list|>
name|colExprMap
init|=
name|rop
operator|.
name|getColumnExprMap
argument_list|()
decl_stmt|;
try|try
block|{
name|Statistics
name|outStats
init|=
name|parentStats
operator|.
name|clone
argument_list|()
decl_stmt|;
if|if
condition|(
name|satisfyPrecondition
argument_list|(
name|parentStats
argument_list|)
condition|)
block|{
name|List
argument_list|<
name|ColStatistics
argument_list|>
name|colStats
init|=
name|Lists
operator|.
name|newArrayList
argument_list|()
decl_stmt|;
for|for
control|(
name|String
name|key
range|:
name|outKeyColNames
control|)
block|{
name|String
name|prefixedKey
init|=
name|Utilities
operator|.
name|ReduceField
operator|.
name|KEY
operator|.
name|toString
argument_list|()
operator|+
literal|"."
operator|+
name|key
decl_stmt|;
name|ExprNodeDesc
name|end
init|=
name|colExprMap
operator|.
name|get
argument_list|(
name|prefixedKey
argument_list|)
decl_stmt|;
if|if
condition|(
name|end
operator|!=
literal|null
condition|)
block|{
name|ColStatistics
name|cs
init|=
name|StatsUtils
operator|.
name|getColStatisticsFromExpression
argument_list|(
name|conf
argument_list|,
name|parentStats
argument_list|,
name|end
argument_list|)
decl_stmt|;
if|if
condition|(
name|cs
operator|!=
literal|null
condition|)
block|{
name|cs
operator|.
name|setColumnName
argument_list|(
name|prefixedKey
argument_list|)
expr_stmt|;
name|colStats
operator|.
name|add
argument_list|(
name|cs
argument_list|)
expr_stmt|;
block|}
block|}
block|}
for|for
control|(
name|String
name|val
range|:
name|outValueColNames
control|)
block|{
name|String
name|prefixedVal
init|=
name|Utilities
operator|.
name|ReduceField
operator|.
name|VALUE
operator|.
name|toString
argument_list|()
operator|+
literal|"."
operator|+
name|val
decl_stmt|;
name|ExprNodeDesc
name|end
init|=
name|colExprMap
operator|.
name|get
argument_list|(
name|prefixedVal
argument_list|)
decl_stmt|;
if|if
condition|(
name|end
operator|!=
literal|null
condition|)
block|{
name|ColStatistics
name|cs
init|=
name|StatsUtils
operator|.
name|getColStatisticsFromExpression
argument_list|(
name|conf
argument_list|,
name|parentStats
argument_list|,
name|end
argument_list|)
decl_stmt|;
if|if
condition|(
name|cs
operator|!=
literal|null
condition|)
block|{
name|cs
operator|.
name|setColumnName
argument_list|(
name|prefixedVal
argument_list|)
expr_stmt|;
name|colStats
operator|.
name|add
argument_list|(
name|cs
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|outStats
operator|.
name|setColumnStats
argument_list|(
name|colStats
argument_list|)
expr_stmt|;
block|}
name|rop
operator|.
name|setStatistics
argument_list|(
name|outStats
argument_list|)
expr_stmt|;
if|if
condition|(
name|isDebugEnabled
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"[0] STATS-"
operator|+
name|rop
operator|.
name|toString
argument_list|()
operator|+
literal|": "
operator|+
name|outStats
operator|.
name|extendedToString
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|CloneNotSupportedException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|STATISTICS_CLONING_FAILED
operator|.
name|getMsg
argument_list|()
argument_list|)
throw|;
block|}
block|}
return|return
literal|null
return|;
block|}
block|}
comment|/**    * Default rule is to aggregate the statistics from all its parent operators.    */
specifier|public
specifier|static
class|class
name|DefaultStatsRule
implements|implements
name|NodeProcessor
block|{
annotation|@
name|Override
specifier|public
name|Object
name|process
parameter_list|(
name|Node
name|nd
parameter_list|,
name|Stack
argument_list|<
name|Node
argument_list|>
name|stack
parameter_list|,
name|NodeProcessorCtx
name|procCtx
parameter_list|,
name|Object
modifier|...
name|nodeOutputs
parameter_list|)
throws|throws
name|SemanticException
block|{
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
name|op
init|=
operator|(
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
operator|)
name|nd
decl_stmt|;
name|OperatorDesc
name|conf
init|=
name|op
operator|.
name|getConf
argument_list|()
decl_stmt|;
name|AnnotateStatsProcCtx
name|aspCtx
init|=
operator|(
name|AnnotateStatsProcCtx
operator|)
name|procCtx
decl_stmt|;
name|HiveConf
name|hconf
init|=
name|aspCtx
operator|.
name|getConf
argument_list|()
decl_stmt|;
if|if
condition|(
name|conf
operator|!=
literal|null
condition|)
block|{
name|Statistics
name|stats
init|=
name|conf
operator|.
name|getStatistics
argument_list|()
decl_stmt|;
if|if
condition|(
name|stats
operator|==
literal|null
condition|)
block|{
if|if
condition|(
name|op
operator|.
name|getParentOperators
argument_list|()
operator|!=
literal|null
condition|)
block|{
comment|// if parent statistics is null then that branch of the tree is not
comment|// walked yet. don't update the stats until all branches are walked
if|if
condition|(
name|isAllParentsContainStatistics
argument_list|(
name|op
argument_list|)
condition|)
block|{
name|stats
operator|=
operator|new
name|Statistics
argument_list|()
expr_stmt|;
for|for
control|(
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
name|parent
range|:
name|op
operator|.
name|getParentOperators
argument_list|()
control|)
block|{
if|if
condition|(
name|parent
operator|.
name|getStatistics
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|Statistics
name|parentStats
init|=
name|parent
operator|.
name|getStatistics
argument_list|()
decl_stmt|;
name|stats
operator|.
name|addToNumRows
argument_list|(
name|parentStats
operator|.
name|getNumRows
argument_list|()
argument_list|)
expr_stmt|;
name|stats
operator|.
name|addToDataSize
argument_list|(
name|parentStats
operator|.
name|getDataSize
argument_list|()
argument_list|)
expr_stmt|;
name|stats
operator|.
name|updateColumnStatsState
argument_list|(
name|parentStats
operator|.
name|getColumnStatsState
argument_list|()
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|ColStatistics
argument_list|>
name|colStats
init|=
name|StatsUtils
operator|.
name|getColStatisticsFromExprMap
argument_list|(
name|hconf
argument_list|,
name|parentStats
argument_list|,
name|op
operator|.
name|getColumnExprMap
argument_list|()
argument_list|,
name|op
operator|.
name|getSchema
argument_list|()
argument_list|)
decl_stmt|;
name|stats
operator|.
name|addToColumnStats
argument_list|(
name|colStats
argument_list|)
expr_stmt|;
name|op
operator|.
name|getConf
argument_list|()
operator|.
name|setStatistics
argument_list|(
name|stats
argument_list|)
expr_stmt|;
if|if
condition|(
name|isDebugEnabled
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"[0] STATS-"
operator|+
name|op
operator|.
name|toString
argument_list|()
operator|+
literal|": "
operator|+
name|stats
operator|.
name|extendedToString
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
block|}
block|}
return|return
literal|null
return|;
block|}
comment|// check if all parent statistics are available
specifier|private
name|boolean
name|isAllParentsContainStatistics
parameter_list|(
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
name|op
parameter_list|)
block|{
for|for
control|(
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
name|parent
range|:
name|op
operator|.
name|getParentOperators
argument_list|()
control|)
block|{
if|if
condition|(
name|parent
operator|.
name|getStatistics
argument_list|()
operator|==
literal|null
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
return|return
literal|true
return|;
block|}
block|}
specifier|public
specifier|static
name|NodeProcessor
name|getTableScanRule
parameter_list|()
block|{
return|return
operator|new
name|TableScanStatsRule
argument_list|()
return|;
block|}
specifier|public
specifier|static
name|NodeProcessor
name|getSelectRule
parameter_list|()
block|{
return|return
operator|new
name|SelectStatsRule
argument_list|()
return|;
block|}
specifier|public
specifier|static
name|NodeProcessor
name|getFilterRule
parameter_list|()
block|{
return|return
operator|new
name|FilterStatsRule
argument_list|()
return|;
block|}
specifier|public
specifier|static
name|NodeProcessor
name|getGroupByRule
parameter_list|()
block|{
return|return
operator|new
name|GroupByStatsRule
argument_list|()
return|;
block|}
specifier|public
specifier|static
name|NodeProcessor
name|getJoinRule
parameter_list|()
block|{
return|return
operator|new
name|JoinStatsRule
argument_list|()
return|;
block|}
specifier|public
specifier|static
name|NodeProcessor
name|getLimitRule
parameter_list|()
block|{
return|return
operator|new
name|LimitStatsRule
argument_list|()
return|;
block|}
specifier|public
specifier|static
name|NodeProcessor
name|getReduceSinkRule
parameter_list|()
block|{
return|return
operator|new
name|ReduceSinkStatsRule
argument_list|()
return|;
block|}
specifier|public
specifier|static
name|NodeProcessor
name|getDefaultRule
parameter_list|()
block|{
return|return
operator|new
name|DefaultStatsRule
argument_list|()
return|;
block|}
comment|/**    * Update the basic statistics of the statistics object based on the row number    * @param stats    *          - statistics to be updated    * @param newNumRows    *          - new number of rows    * @param useColStats    *          - use column statistics to compute data size    */
specifier|static
name|void
name|updateStats
parameter_list|(
name|Statistics
name|stats
parameter_list|,
name|long
name|newNumRows
parameter_list|,
name|boolean
name|useColStats
parameter_list|,
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
name|op
parameter_list|)
block|{
name|updateStats
argument_list|(
name|stats
argument_list|,
name|newNumRows
argument_list|,
name|useColStats
argument_list|,
name|op
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
specifier|static
name|void
name|updateStats
parameter_list|(
name|Statistics
name|stats
parameter_list|,
name|long
name|newNumRows
parameter_list|,
name|boolean
name|useColStats
parameter_list|,
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
name|op
parameter_list|,
name|boolean
name|updateNDV
parameter_list|)
block|{
if|if
condition|(
name|newNumRows
operator|<
literal|0
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"STATS-"
operator|+
name|op
operator|.
name|toString
argument_list|()
operator|+
literal|": Overflow in number of rows."
operator|+
name|newNumRows
operator|+
literal|" rows will be set to Long.MAX_VALUE"
argument_list|)
expr_stmt|;
name|newNumRows
operator|=
name|StatsUtils
operator|.
name|getMaxIfOverflow
argument_list|(
name|newNumRows
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|newNumRows
operator|==
literal|0
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"STATS-"
operator|+
name|op
operator|.
name|toString
argument_list|()
operator|+
literal|": Equals 0 in number of rows."
operator|+
name|newNumRows
operator|+
literal|" rows will be set to 1"
argument_list|)
expr_stmt|;
name|newNumRows
operator|=
literal|1
expr_stmt|;
block|}
name|long
name|oldRowCount
init|=
name|stats
operator|.
name|getNumRows
argument_list|()
decl_stmt|;
name|double
name|ratio
init|=
operator|(
name|double
operator|)
name|newNumRows
operator|/
operator|(
name|double
operator|)
name|oldRowCount
decl_stmt|;
name|stats
operator|.
name|setNumRows
argument_list|(
name|newNumRows
argument_list|)
expr_stmt|;
if|if
condition|(
name|useColStats
condition|)
block|{
name|List
argument_list|<
name|ColStatistics
argument_list|>
name|colStats
init|=
name|stats
operator|.
name|getColumnStats
argument_list|()
decl_stmt|;
for|for
control|(
name|ColStatistics
name|cs
range|:
name|colStats
control|)
block|{
name|long
name|oldNumNulls
init|=
name|cs
operator|.
name|getNumNulls
argument_list|()
decl_stmt|;
name|long
name|oldDV
init|=
name|cs
operator|.
name|getCountDistint
argument_list|()
decl_stmt|;
name|long
name|newNumNulls
init|=
name|Math
operator|.
name|round
argument_list|(
name|ratio
operator|*
name|oldNumNulls
argument_list|)
decl_stmt|;
name|cs
operator|.
name|setNumNulls
argument_list|(
name|newNumNulls
argument_list|)
expr_stmt|;
if|if
condition|(
name|updateNDV
condition|)
block|{
name|long
name|newDV
init|=
name|oldDV
decl_stmt|;
comment|// if ratio is greater than 1, then number of rows increases. This can happen
comment|// when some operators like GROUPBY duplicates the input rows in which case
comment|// number of distincts should not change. Update the distinct count only when
comment|// the output number of rows is less than input number of rows.
if|if
condition|(
name|ratio
operator|<=
literal|1.0
condition|)
block|{
name|newDV
operator|=
operator|(
name|long
operator|)
name|Math
operator|.
name|ceil
argument_list|(
name|ratio
operator|*
name|oldDV
argument_list|)
expr_stmt|;
block|}
name|cs
operator|.
name|setCountDistint
argument_list|(
name|newDV
argument_list|)
expr_stmt|;
block|}
block|}
name|stats
operator|.
name|setColumnStats
argument_list|(
name|colStats
argument_list|)
expr_stmt|;
name|long
name|newDataSize
init|=
name|StatsUtils
operator|.
name|getDataSizeFromColumnStats
argument_list|(
name|newNumRows
argument_list|,
name|colStats
argument_list|)
decl_stmt|;
name|stats
operator|.
name|setDataSize
argument_list|(
name|StatsUtils
operator|.
name|getMaxIfOverflow
argument_list|(
name|newDataSize
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|long
name|newDataSize
init|=
call|(
name|long
call|)
argument_list|(
name|ratio
operator|*
name|stats
operator|.
name|getDataSize
argument_list|()
argument_list|)
decl_stmt|;
name|stats
operator|.
name|setDataSize
argument_list|(
name|StatsUtils
operator|.
name|getMaxIfOverflow
argument_list|(
name|newDataSize
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
specifier|static
name|boolean
name|satisfyPrecondition
parameter_list|(
name|Statistics
name|stats
parameter_list|)
block|{
return|return
name|stats
operator|!=
literal|null
operator|&&
name|stats
operator|.
name|getBasicStatsState
argument_list|()
operator|.
name|equals
argument_list|(
name|Statistics
operator|.
name|State
operator|.
name|COMPLETE
argument_list|)
operator|&&
operator|!
name|stats
operator|.
name|getColumnStatsState
argument_list|()
operator|.
name|equals
argument_list|(
name|Statistics
operator|.
name|State
operator|.
name|NONE
argument_list|)
return|;
block|}
block|}
end_class

end_unit

