begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|optimizer
operator|.
name|stats
operator|.
name|annotation
package|;
end_package

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|reflect
operator|.
name|Field
import|;
end_import

begin_import
import|import
name|java
operator|.
name|math
operator|.
name|BigDecimal
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
operator|.
name|Entry
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Optional
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Stack
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|conf
operator|.
name|HiveConf
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|conf
operator|.
name|HiveConf
operator|.
name|ConfVars
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|Context
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|AbstractMapJoinOperator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|ColumnInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|CommonJoinOperator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|FilterOperator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|FunctionRegistry
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|GroupByOperator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|JoinOperator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|LimitOperator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|Operator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|OperatorUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|ReduceSinkOperator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|RowSchema
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|SelectOperator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|TableScanOperator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|UDTFOperator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|Utilities
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|lib
operator|.
name|Node
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|lib
operator|.
name|NodeProcessor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|lib
operator|.
name|NodeProcessorCtx
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|metadata
operator|.
name|HiveException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|metadata
operator|.
name|Table
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|optimizer
operator|.
name|signature
operator|.
name|OpTreeSignature
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|parse
operator|.
name|ColumnStatsList
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|parse
operator|.
name|PrunedPartitionList
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|parse
operator|.
name|SemanticException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|AggregationDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|ColStatistics
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|ColStatistics
operator|.
name|Range
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|ExprNodeColumnDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|ExprNodeColumnListDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|ExprNodeConstantDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|ExprNodeDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|ExprNodeDesc
operator|.
name|ExprNodeDescEqualityWrapper
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|ExprNodeDescUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|ExprNodeDynamicListDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|ExprNodeDynamicValueDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|ExprNodeFieldDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|ExprNodeGenericFuncDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|GroupByDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|JoinCondDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|JoinDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|MapJoinDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|OperatorDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|Statistics
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|Statistics
operator|.
name|State
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|mapper
operator|.
name|PlanMapper
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|mapper
operator|.
name|StatsSource
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|stats
operator|.
name|OperatorStats
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|stats
operator|.
name|StatsUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|udf
operator|.
name|generic
operator|.
name|GenericUDAFCount
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|udf
operator|.
name|generic
operator|.
name|GenericUDAFEvaluator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|udf
operator|.
name|generic
operator|.
name|GenericUDAFMax
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|udf
operator|.
name|generic
operator|.
name|GenericUDAFMin
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|udf
operator|.
name|generic
operator|.
name|GenericUDAFResolver
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|udf
operator|.
name|generic
operator|.
name|GenericUDAFSum
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|udf
operator|.
name|generic
operator|.
name|GenericUDF
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|udf
operator|.
name|generic
operator|.
name|GenericUDFBetween
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|udf
operator|.
name|generic
operator|.
name|GenericUDFIn
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|udf
operator|.
name|generic
operator|.
name|GenericUDFInBloomFilter
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|udf
operator|.
name|generic
operator|.
name|GenericUDFOPAnd
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|udf
operator|.
name|generic
operator|.
name|GenericUDFOPEqual
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|udf
operator|.
name|generic
operator|.
name|GenericUDFOPEqualOrGreaterThan
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|udf
operator|.
name|generic
operator|.
name|GenericUDFOPEqualOrLessThan
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|udf
operator|.
name|generic
operator|.
name|GenericUDFOPGreaterThan
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|udf
operator|.
name|generic
operator|.
name|GenericUDFOPLessThan
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|udf
operator|.
name|generic
operator|.
name|GenericUDFOPNot
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|udf
operator|.
name|generic
operator|.
name|GenericUDFOPNotEqual
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|udf
operator|.
name|generic
operator|.
name|GenericUDFOPNotNull
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|udf
operator|.
name|generic
operator|.
name|GenericUDFOPNull
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|udf
operator|.
name|generic
operator|.
name|GenericUDFOPOr
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|udf
operator|.
name|generic
operator|.
name|GenericUDFStruct
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde
operator|.
name|serdeConstants
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|io
operator|.
name|DateWritable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|objectinspector
operator|.
name|ObjectInspectorUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|typeinfo
operator|.
name|StructTypeInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|typeinfo
operator|.
name|TypeInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|typeinfo
operator|.
name|TypeInfoFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Lists
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Maps
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Sets
import|;
end_import

begin_class
specifier|public
class|class
name|StatsRulesProcFactory
block|{
specifier|private
specifier|static
specifier|final
name|Logger
name|LOG
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|StatsRulesProcFactory
operator|.
name|class
operator|.
name|getName
argument_list|()
argument_list|)
decl_stmt|;
comment|/**    * Collect basic statistics like number of rows, data size and column level statistics from the    * table. Also sets the state of the available statistics. Basic and column statistics can have    * one of the following states COMPLETE, PARTIAL, NONE. In case of partitioned table, the basic    * and column stats are aggregated together to table level statistics. Column statistics will not    * be collected if hive.stats.fetch.column.stats is set to false. If basic statistics is not    * available then number of rows will be estimated from file size and average row size (computed    * from schema).    */
specifier|public
specifier|static
class|class
name|TableScanStatsRule
extends|extends
name|DefaultStatsRule
implements|implements
name|NodeProcessor
block|{
annotation|@
name|Override
specifier|public
name|Object
name|process
parameter_list|(
name|Node
name|nd
parameter_list|,
name|Stack
argument_list|<
name|Node
argument_list|>
name|stack
parameter_list|,
name|NodeProcessorCtx
name|procCtx
parameter_list|,
name|Object
modifier|...
name|nodeOutputs
parameter_list|)
throws|throws
name|SemanticException
block|{
name|TableScanOperator
name|tsop
init|=
operator|(
name|TableScanOperator
operator|)
name|nd
decl_stmt|;
name|AnnotateStatsProcCtx
name|aspCtx
init|=
operator|(
name|AnnotateStatsProcCtx
operator|)
name|procCtx
decl_stmt|;
name|PrunedPartitionList
name|partList
init|=
name|aspCtx
operator|.
name|getParseContext
argument_list|()
operator|.
name|getPrunedPartitions
argument_list|(
name|tsop
argument_list|)
decl_stmt|;
name|ColumnStatsList
name|colStatsCached
init|=
name|aspCtx
operator|.
name|getParseContext
argument_list|()
operator|.
name|getColStatsCached
argument_list|(
name|partList
argument_list|)
decl_stmt|;
name|Table
name|table
init|=
name|tsop
operator|.
name|getConf
argument_list|()
operator|.
name|getTableMetadata
argument_list|()
decl_stmt|;
try|try
block|{
comment|// gather statistics for the first time and the attach it to table scan operator
name|Statistics
name|stats
init|=
name|StatsUtils
operator|.
name|collectStatistics
argument_list|(
name|aspCtx
operator|.
name|getConf
argument_list|()
argument_list|,
name|partList
argument_list|,
name|colStatsCached
argument_list|,
name|table
argument_list|,
name|tsop
argument_list|)
decl_stmt|;
name|stats
operator|=
name|applyRuntimeStats
argument_list|(
name|aspCtx
operator|.
name|getParseContext
argument_list|()
operator|.
name|getContext
argument_list|()
argument_list|,
name|stats
argument_list|,
name|tsop
argument_list|)
expr_stmt|;
name|tsop
operator|.
name|setStatistics
argument_list|(
name|stats
argument_list|)
expr_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"[0] STATS-"
operator|+
name|tsop
operator|.
name|toString
argument_list|()
operator|+
literal|" ("
operator|+
name|table
operator|.
name|getTableName
argument_list|()
operator|+
literal|"): "
operator|+
name|stats
operator|.
name|extendedToString
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|HiveException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Failed to retrieve stats "
argument_list|,
name|e
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|SemanticException
argument_list|(
name|e
argument_list|)
throw|;
block|}
return|return
literal|null
return|;
block|}
block|}
comment|/**    * SELECT operator doesn't change the number of rows emitted from the parent operator. It changes    * the size of each tuple emitted. In a typical case, where only subset of columns are selected    * the average row size will reduce as some of the columns will be pruned. In order to accurately    * compute the average row size, column level statistics is required. Column level statistics    * stores average size of values in column which can be used to more reliably estimate the    * reduction in size of each tuple. In the absence of column level statistics, size of columns    * will be based on data type. For primitive data types size from    * {@link org.apache.hadoop.hive.ql.util.JavaDataModel} will be used and for variable length data    * types worst case will be assumed.    *<p>    *<i>For more information, refer 'Estimating The Cost Of Operations' chapter in    * "Database Systems: The Complete Book" by Garcia-Molina et. al.</i>    *</p>    */
specifier|public
specifier|static
class|class
name|SelectStatsRule
extends|extends
name|DefaultStatsRule
implements|implements
name|NodeProcessor
block|{
annotation|@
name|Override
specifier|public
name|Object
name|process
parameter_list|(
name|Node
name|nd
parameter_list|,
name|Stack
argument_list|<
name|Node
argument_list|>
name|stack
parameter_list|,
name|NodeProcessorCtx
name|procCtx
parameter_list|,
name|Object
modifier|...
name|nodeOutputs
parameter_list|)
throws|throws
name|SemanticException
block|{
name|SelectOperator
name|sop
init|=
operator|(
name|SelectOperator
operator|)
name|nd
decl_stmt|;
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
name|parent
init|=
name|sop
operator|.
name|getParentOperators
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|Statistics
name|parentStats
init|=
name|parent
operator|.
name|getStatistics
argument_list|()
decl_stmt|;
name|AnnotateStatsProcCtx
name|aspCtx
init|=
operator|(
name|AnnotateStatsProcCtx
operator|)
name|procCtx
decl_stmt|;
name|HiveConf
name|conf
init|=
name|aspCtx
operator|.
name|getConf
argument_list|()
decl_stmt|;
name|Statistics
name|stats
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|parentStats
operator|!=
literal|null
condition|)
block|{
name|stats
operator|=
name|parentStats
operator|.
name|clone
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|satisfyPrecondition
argument_list|(
name|parentStats
argument_list|)
condition|)
block|{
comment|// this will take care of mapping between input column names and output column names. The
comment|// returned column stats will have the output column names.
name|List
argument_list|<
name|ColStatistics
argument_list|>
name|colStats
init|=
name|StatsUtils
operator|.
name|getColStatisticsFromExprMap
argument_list|(
name|conf
argument_list|,
name|parentStats
argument_list|,
name|sop
operator|.
name|getColumnExprMap
argument_list|()
argument_list|,
name|sop
operator|.
name|getSchema
argument_list|()
argument_list|)
decl_stmt|;
name|stats
operator|.
name|setColumnStats
argument_list|(
name|colStats
argument_list|)
expr_stmt|;
comment|// in case of select(*) the data size does not change
if|if
condition|(
operator|!
name|sop
operator|.
name|getConf
argument_list|()
operator|.
name|isSelectStar
argument_list|()
operator|&&
operator|!
name|sop
operator|.
name|getConf
argument_list|()
operator|.
name|isSelStarNoCompute
argument_list|()
condition|)
block|{
name|long
name|dataSize
init|=
name|StatsUtils
operator|.
name|getDataSizeFromColumnStats
argument_list|(
name|stats
operator|.
name|getNumRows
argument_list|()
argument_list|,
name|colStats
argument_list|)
decl_stmt|;
name|stats
operator|.
name|setDataSize
argument_list|(
name|dataSize
argument_list|)
expr_stmt|;
block|}
name|stats
operator|=
name|applyRuntimeStats
argument_list|(
name|aspCtx
operator|.
name|getParseContext
argument_list|()
operator|.
name|getContext
argument_list|()
argument_list|,
name|stats
argument_list|,
name|sop
argument_list|)
expr_stmt|;
name|sop
operator|.
name|setStatistics
argument_list|(
name|stats
argument_list|)
expr_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"[0] STATS-"
operator|+
name|sop
operator|.
name|toString
argument_list|()
operator|+
literal|": "
operator|+
name|stats
operator|.
name|extendedToString
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|parentStats
operator|!=
literal|null
condition|)
block|{
name|stats
operator|=
name|applyRuntimeStats
argument_list|(
name|aspCtx
operator|.
name|getParseContext
argument_list|()
operator|.
name|getContext
argument_list|()
argument_list|,
name|stats
argument_list|,
name|sop
argument_list|)
expr_stmt|;
name|sop
operator|.
name|setStatistics
argument_list|(
name|stats
argument_list|)
expr_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"[1] STATS-"
operator|+
name|sop
operator|.
name|toString
argument_list|()
operator|+
literal|": "
operator|+
name|parentStats
operator|.
name|extendedToString
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
literal|null
return|;
block|}
block|}
comment|/**    * FILTER operator does not change the average row size but it does change the number of rows    * emitted. The reduction in the number of rows emitted is dependent on the filter expression.    *<i>Notations:</i>    *<ul>    *<li>T(S) - Number of tuples in relations S</li>    *<li>V(S,A) - Number of distinct values of attribute A in relation S</li>    *</ul>    *<i>Rules:</i>     *<ul>    *<li><b>Column equals a constant</b> T(S) = T(R) / V(R,A)</li>    *<li><b>Inequality conditions</b> T(S) = T(R) / 3</li>    *<li><b>Not equals comparison</b> - Simple formula T(S) = T(R)</li>    *<li>- Alternate formula T(S) = T(R) (V(R,A) - 1) / V(R,A)</li>    *<li><b>NOT condition</b> T(S) = 1 - T(S'), where T(S') is the satisfying condition</li>    *<li><b>Multiple AND conditions</b> Cascadingly apply the rules 1 to 3 (order doesn't matter)</li>    *<li><b>Multiple OR conditions</b> - Simple formula is to evaluate conditions independently    * and sum the results T(S) = m1 + m2</li>    *<li>- Alternate formula T(S) = T(R) * ( 1 - ( 1 - m1/T(R) ) * ( 1 - m2/T(R) ))    *<br>    * where, m1 is the number of tuples that satisfy condition1 and m2 is the number of tuples that    * satisfy condition2</li>    *</ul>    *<i>Worst case:</i> If no column statistics are available, then evaluation of predicate    * expression will assume worst case (i.e; half the input rows) for each of predicate expression.    *<br>    *<i>For more information, refer 'Estimating The Cost Of Operations' chapter in    * "Database Systems: The Complete Book" by Garcia-Molina et. al.</i>    *<br>    */
specifier|public
specifier|static
class|class
name|FilterStatsRule
extends|extends
name|DefaultStatsRule
implements|implements
name|NodeProcessor
block|{
annotation|@
name|Override
specifier|public
name|Object
name|process
parameter_list|(
name|Node
name|nd
parameter_list|,
name|Stack
argument_list|<
name|Node
argument_list|>
name|stack
parameter_list|,
name|NodeProcessorCtx
name|procCtx
parameter_list|,
name|Object
modifier|...
name|nodeOutputs
parameter_list|)
throws|throws
name|SemanticException
block|{
name|AnnotateStatsProcCtx
name|aspCtx
init|=
operator|(
name|AnnotateStatsProcCtx
operator|)
name|procCtx
decl_stmt|;
name|FilterOperator
name|fop
init|=
operator|(
name|FilterOperator
operator|)
name|nd
decl_stmt|;
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
name|parent
init|=
name|fop
operator|.
name|getParentOperators
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|Statistics
name|parentStats
init|=
name|parent
operator|.
name|getStatistics
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|neededCols
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|parent
operator|instanceof
name|TableScanOperator
condition|)
block|{
name|TableScanOperator
name|tsop
init|=
operator|(
name|TableScanOperator
operator|)
name|parent
decl_stmt|;
name|neededCols
operator|=
name|tsop
operator|.
name|getNeededColumns
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|parentStats
operator|!=
literal|null
condition|)
block|{
name|ExprNodeDesc
name|pred
init|=
name|fop
operator|.
name|getConf
argument_list|()
operator|.
name|getPredicate
argument_list|()
decl_stmt|;
comment|// evaluate filter expression and update statistics
name|aspCtx
operator|.
name|clearAffectedColumns
argument_list|()
expr_stmt|;
name|long
name|newNumRows
init|=
name|evaluateExpression
argument_list|(
name|parentStats
argument_list|,
name|pred
argument_list|,
name|aspCtx
argument_list|,
name|neededCols
argument_list|,
name|fop
argument_list|,
name|parentStats
operator|.
name|getNumRows
argument_list|()
argument_list|)
decl_stmt|;
name|Statistics
name|st
init|=
name|parentStats
operator|.
name|clone
argument_list|()
decl_stmt|;
if|if
condition|(
name|satisfyPrecondition
argument_list|(
name|parentStats
argument_list|)
condition|)
block|{
comment|// update statistics based on column statistics.
comment|// OR conditions keeps adding the stats independently, this may
comment|// result in number of rows getting more than the input rows in
comment|// which case stats need not be updated
if|if
condition|(
name|newNumRows
operator|<=
name|parentStats
operator|.
name|getNumRows
argument_list|()
condition|)
block|{
name|StatsUtils
operator|.
name|updateStats
argument_list|(
name|st
argument_list|,
name|newNumRows
argument_list|,
literal|true
argument_list|,
name|fop
argument_list|,
name|aspCtx
operator|.
name|getAffectedColumns
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"[0] STATS-"
operator|+
name|fop
operator|.
name|toString
argument_list|()
operator|+
literal|": "
operator|+
name|st
operator|.
name|extendedToString
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// update only the basic statistics in the absence of column statistics
if|if
condition|(
name|newNumRows
operator|<=
name|parentStats
operator|.
name|getNumRows
argument_list|()
condition|)
block|{
name|StatsUtils
operator|.
name|updateStats
argument_list|(
name|st
argument_list|,
name|newNumRows
argument_list|,
literal|false
argument_list|,
name|fop
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"[1] STATS-"
operator|+
name|fop
operator|.
name|toString
argument_list|()
operator|+
literal|": "
operator|+
name|st
operator|.
name|extendedToString
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
name|st
operator|=
name|applyRuntimeStats
argument_list|(
name|aspCtx
operator|.
name|getParseContext
argument_list|()
operator|.
name|getContext
argument_list|()
argument_list|,
name|st
argument_list|,
name|fop
argument_list|)
expr_stmt|;
name|fop
operator|.
name|setStatistics
argument_list|(
name|st
argument_list|)
expr_stmt|;
name|aspCtx
operator|.
name|setAndExprStats
argument_list|(
literal|null
argument_list|)
expr_stmt|;
block|}
return|return
literal|null
return|;
block|}
specifier|protected
name|long
name|evaluateExpression
parameter_list|(
name|Statistics
name|stats
parameter_list|,
name|ExprNodeDesc
name|pred
parameter_list|,
name|AnnotateStatsProcCtx
name|aspCtx
parameter_list|,
name|List
argument_list|<
name|String
argument_list|>
name|neededCols
parameter_list|,
name|Operator
argument_list|<
name|?
argument_list|>
name|op
parameter_list|,
name|long
name|currNumRows
parameter_list|)
throws|throws
name|SemanticException
block|{
name|long
name|newNumRows
init|=
literal|0
decl_stmt|;
name|Statistics
name|andStats
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|currNumRows
operator|<=
literal|1
operator|||
name|stats
operator|.
name|getDataSize
argument_list|()
operator|<=
literal|0
condition|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Estimating row count for "
operator|+
name|pred
operator|+
literal|" Original num rows: "
operator|+
name|currNumRows
operator|+
literal|" Original data size: "
operator|+
name|stats
operator|.
name|getDataSize
argument_list|()
operator|+
literal|" New num rows: 1"
argument_list|)
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
if|if
condition|(
name|pred
operator|instanceof
name|ExprNodeGenericFuncDesc
condition|)
block|{
name|ExprNodeGenericFuncDesc
name|genFunc
init|=
operator|(
name|ExprNodeGenericFuncDesc
operator|)
name|pred
decl_stmt|;
name|GenericUDF
name|udf
init|=
name|genFunc
operator|.
name|getGenericUDF
argument_list|()
decl_stmt|;
comment|// for AND condition cascadingly update stats
if|if
condition|(
name|udf
operator|instanceof
name|GenericUDFOPAnd
condition|)
block|{
name|Set
argument_list|<
name|String
argument_list|>
name|affectedColumns
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|()
decl_stmt|;
name|andStats
operator|=
name|stats
operator|.
name|clone
argument_list|()
expr_stmt|;
name|aspCtx
operator|.
name|setAndExprStats
argument_list|(
name|andStats
argument_list|)
expr_stmt|;
name|aspCtx
operator|.
name|clearAffectedColumns
argument_list|()
expr_stmt|;
comment|// evaluate children
name|long
name|evaluatedRowCount
init|=
name|currNumRows
decl_stmt|;
for|for
control|(
name|ExprNodeDesc
name|child
range|:
name|genFunc
operator|.
name|getChildren
argument_list|()
control|)
block|{
name|evaluatedRowCount
operator|=
name|evaluateChildExpr
argument_list|(
name|aspCtx
operator|.
name|getAndExprStats
argument_list|()
argument_list|,
name|child
argument_list|,
name|aspCtx
argument_list|,
name|neededCols
argument_list|,
name|op
argument_list|,
name|evaluatedRowCount
argument_list|)
expr_stmt|;
name|newNumRows
operator|=
name|evaluatedRowCount
expr_stmt|;
if|if
condition|(
name|satisfyPrecondition
argument_list|(
name|aspCtx
operator|.
name|getAndExprStats
argument_list|()
argument_list|)
condition|)
block|{
comment|// Assumption is that columns are uncorrelated.
comment|// Ndv is reduced in a conservative manner - only taking affected columns
comment|// (which might be a subset of the actual *real* affected columns due to current limitation)
comment|// Goal is to not let a situation in which ndv-s asre underestimated happen.
name|StatsUtils
operator|.
name|updateStats
argument_list|(
name|aspCtx
operator|.
name|getAndExprStats
argument_list|()
argument_list|,
name|newNumRows
argument_list|,
literal|true
argument_list|,
name|op
argument_list|,
name|aspCtx
operator|.
name|getAffectedColumns
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|StatsUtils
operator|.
name|updateStats
argument_list|(
name|aspCtx
operator|.
name|getAndExprStats
argument_list|()
argument_list|,
name|newNumRows
argument_list|,
literal|false
argument_list|,
name|op
argument_list|)
expr_stmt|;
block|}
name|affectedColumns
operator|.
name|addAll
argument_list|(
name|aspCtx
operator|.
name|getAffectedColumns
argument_list|()
argument_list|)
expr_stmt|;
name|aspCtx
operator|.
name|clearAffectedColumns
argument_list|()
expr_stmt|;
block|}
name|aspCtx
operator|.
name|addAffectedColumns
argument_list|(
name|affectedColumns
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|udf
operator|instanceof
name|GenericUDFOPOr
condition|)
block|{
comment|// for OR condition independently compute and update stats.
for|for
control|(
name|ExprNodeDesc
name|child
range|:
name|genFunc
operator|.
name|getChildren
argument_list|()
control|)
block|{
name|newNumRows
operator|=
name|StatsUtils
operator|.
name|safeAdd
argument_list|(
name|evaluateChildExpr
argument_list|(
name|stats
argument_list|,
name|child
argument_list|,
name|aspCtx
argument_list|,
name|neededCols
argument_list|,
name|op
argument_list|,
name|currNumRows
argument_list|)
argument_list|,
name|newNumRows
argument_list|)
expr_stmt|;
block|}
comment|// We have to clear the affected columns
comment|// since currently it is not possible to get a real estimate of an or expression.
name|aspCtx
operator|.
name|clearAffectedColumns
argument_list|()
expr_stmt|;
if|if
condition|(
name|newNumRows
operator|>
name|currNumRows
condition|)
block|{
name|newNumRows
operator|=
name|currNumRows
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|udf
operator|instanceof
name|GenericUDFIn
condition|)
block|{
comment|// for IN clause
name|newNumRows
operator|=
name|evaluateInExpr
argument_list|(
name|stats
argument_list|,
name|pred
argument_list|,
name|currNumRows
argument_list|,
name|aspCtx
argument_list|,
name|neededCols
argument_list|,
name|op
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|udf
operator|instanceof
name|GenericUDFBetween
condition|)
block|{
comment|// for BETWEEN clause
name|newNumRows
operator|=
name|evaluateBetweenExpr
argument_list|(
name|stats
argument_list|,
name|pred
argument_list|,
name|currNumRows
argument_list|,
name|aspCtx
argument_list|,
name|neededCols
argument_list|,
name|op
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|udf
operator|instanceof
name|GenericUDFOPNot
condition|)
block|{
name|newNumRows
operator|=
name|evaluateNotExpr
argument_list|(
name|stats
argument_list|,
name|pred
argument_list|,
name|currNumRows
argument_list|,
name|aspCtx
argument_list|,
name|neededCols
argument_list|,
name|op
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|udf
operator|instanceof
name|GenericUDFOPNotNull
condition|)
block|{
return|return
name|evaluateNotNullExpr
argument_list|(
name|stats
argument_list|,
name|aspCtx
argument_list|,
name|genFunc
argument_list|,
name|currNumRows
argument_list|)
return|;
block|}
else|else
block|{
comment|// single predicate condition
name|newNumRows
operator|=
name|evaluateChildExpr
argument_list|(
name|stats
argument_list|,
name|pred
argument_list|,
name|aspCtx
argument_list|,
name|neededCols
argument_list|,
name|op
argument_list|,
name|currNumRows
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|pred
operator|instanceof
name|ExprNodeColumnDesc
condition|)
block|{
comment|// can be boolean column in which case return true count
name|ExprNodeColumnDesc
name|encd
init|=
operator|(
name|ExprNodeColumnDesc
operator|)
name|pred
decl_stmt|;
name|aspCtx
operator|.
name|addAffectedColumn
argument_list|(
name|encd
argument_list|)
expr_stmt|;
name|String
name|colName
init|=
name|encd
operator|.
name|getColumn
argument_list|()
decl_stmt|;
name|String
name|colType
init|=
name|encd
operator|.
name|getTypeString
argument_list|()
decl_stmt|;
if|if
condition|(
name|colType
operator|.
name|equalsIgnoreCase
argument_list|(
name|serdeConstants
operator|.
name|BOOLEAN_TYPE_NAME
argument_list|)
condition|)
block|{
name|ColStatistics
name|cs
init|=
name|stats
operator|.
name|getColumnStatisticsFromColName
argument_list|(
name|colName
argument_list|)
decl_stmt|;
if|if
condition|(
name|cs
operator|!=
literal|null
condition|)
block|{
name|newNumRows
operator|=
name|cs
operator|.
name|getNumTrues
argument_list|()
expr_stmt|;
block|}
else|else
block|{
comment|// default
name|newNumRows
operator|=
name|stats
operator|.
name|getNumRows
argument_list|()
operator|/
literal|2
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// if not boolean column return half the number of rows
name|newNumRows
operator|=
name|stats
operator|.
name|getNumRows
argument_list|()
operator|/
literal|2
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|pred
operator|instanceof
name|ExprNodeConstantDesc
condition|)
block|{
comment|// special case for handling false constants
name|ExprNodeConstantDesc
name|encd
init|=
operator|(
name|ExprNodeConstantDesc
operator|)
name|pred
decl_stmt|;
if|if
condition|(
name|Boolean
operator|.
name|FALSE
operator|.
name|equals
argument_list|(
name|encd
operator|.
name|getValue
argument_list|()
argument_list|)
condition|)
block|{
name|newNumRows
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|newNumRows
operator|=
name|stats
operator|.
name|getNumRows
argument_list|()
expr_stmt|;
block|}
block|}
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Estimating row count for "
operator|+
name|pred
operator|+
literal|" Original num rows: "
operator|+
name|stats
operator|.
name|getNumRows
argument_list|()
operator|+
literal|" New num rows: "
operator|+
name|newNumRows
argument_list|)
expr_stmt|;
block|}
return|return
name|newNumRows
return|;
block|}
specifier|private
name|long
name|evaluateInExpr
parameter_list|(
name|Statistics
name|stats
parameter_list|,
name|ExprNodeDesc
name|pred
parameter_list|,
name|long
name|currNumRows
parameter_list|,
name|AnnotateStatsProcCtx
name|aspCtx
parameter_list|,
name|List
argument_list|<
name|String
argument_list|>
name|neededCols
parameter_list|,
name|Operator
argument_list|<
name|?
argument_list|>
name|op
parameter_list|)
throws|throws
name|SemanticException
block|{
name|long
name|numRows
init|=
name|currNumRows
decl_stmt|;
name|ExprNodeGenericFuncDesc
name|fd
init|=
operator|(
name|ExprNodeGenericFuncDesc
operator|)
name|pred
decl_stmt|;
comment|// 1. It is an IN operator, check if it uses STRUCT
name|List
argument_list|<
name|ExprNodeDesc
argument_list|>
name|children
init|=
name|fd
operator|.
name|getChildren
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|ExprNodeDesc
argument_list|>
name|columns
init|=
name|Lists
operator|.
name|newArrayList
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|ColStatistics
argument_list|>
name|columnStats
init|=
name|Lists
operator|.
name|newArrayList
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|Set
argument_list|<
name|ExprNodeDescEqualityWrapper
argument_list|>
argument_list|>
name|values
init|=
name|Lists
operator|.
name|newArrayList
argument_list|()
decl_stmt|;
name|ExprNodeDesc
name|columnsChild
init|=
name|children
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|boolean
name|multiColumn
decl_stmt|;
if|if
condition|(
name|columnsChild
operator|instanceof
name|ExprNodeGenericFuncDesc
operator|&&
operator|(
operator|(
name|ExprNodeGenericFuncDesc
operator|)
name|columnsChild
operator|)
operator|.
name|getGenericUDF
argument_list|()
operator|instanceof
name|GenericUDFStruct
condition|)
block|{
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|columnsChild
operator|.
name|getChildren
argument_list|()
operator|.
name|size
argument_list|()
condition|;
name|j
operator|++
control|)
block|{
name|ExprNodeDesc
name|columnChild
init|=
name|columnsChild
operator|.
name|getChildren
argument_list|()
operator|.
name|get
argument_list|(
name|j
argument_list|)
decl_stmt|;
comment|// If column is not column reference , we bail out
if|if
condition|(
operator|!
operator|(
name|columnChild
operator|instanceof
name|ExprNodeColumnDesc
operator|)
condition|)
block|{
comment|// Default
return|return
name|numRows
operator|/
literal|2
return|;
block|}
name|columns
operator|.
name|add
argument_list|(
name|columnChild
argument_list|)
expr_stmt|;
comment|// not adding column as affected; since that would rescale ndv based on the other columns
comment|// selectivity as well...which leads to underestimation
comment|// aspCtx.addAffectedColumn((ExprNodeColumnDesc) columnChild);
specifier|final
name|String
name|columnName
init|=
operator|(
operator|(
name|ExprNodeColumnDesc
operator|)
name|columnChild
operator|)
operator|.
name|getColumn
argument_list|()
decl_stmt|;
comment|// if column name is not contained in needed column list then it
comment|// is a partition column. We do not need to evaluate partition columns
comment|// in filter expression since it will be taken care by partition pruner
if|if
condition|(
name|neededCols
operator|!=
literal|null
operator|&&
operator|!
name|neededCols
operator|.
name|contains
argument_list|(
name|columnName
argument_list|)
condition|)
block|{
comment|// Default
return|return
name|numRows
operator|/
literal|2
return|;
block|}
name|columnStats
operator|.
name|add
argument_list|(
name|stats
operator|.
name|getColumnStatisticsFromColName
argument_list|(
name|columnName
argument_list|)
argument_list|)
expr_stmt|;
name|values
operator|.
name|add
argument_list|(
name|Sets
operator|.
expr|<
name|ExprNodeDescEqualityWrapper
operator|>
name|newHashSet
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|multiColumn
operator|=
literal|true
expr_stmt|;
block|}
else|else
block|{
comment|// If column is not column reference , we bail out
if|if
condition|(
operator|!
operator|(
name|columnsChild
operator|instanceof
name|ExprNodeColumnDesc
operator|)
condition|)
block|{
comment|// Default
return|return
name|numRows
operator|/
literal|2
return|;
block|}
name|columns
operator|.
name|add
argument_list|(
name|columnsChild
argument_list|)
expr_stmt|;
name|aspCtx
operator|.
name|addAffectedColumn
argument_list|(
operator|(
name|ExprNodeColumnDesc
operator|)
name|columnsChild
argument_list|)
expr_stmt|;
specifier|final
name|String
name|columnName
init|=
operator|(
operator|(
name|ExprNodeColumnDesc
operator|)
name|columnsChild
operator|)
operator|.
name|getColumn
argument_list|()
decl_stmt|;
comment|// if column name is not contained in needed column list then it
comment|// is a partition column. We do not need to evaluate partition columns
comment|// in filter expression since it will be taken care by partition pruner
if|if
condition|(
name|neededCols
operator|!=
literal|null
operator|&&
operator|!
name|neededCols
operator|.
name|contains
argument_list|(
name|columnName
argument_list|)
condition|)
block|{
comment|// Default
return|return
name|numRows
operator|/
literal|2
return|;
block|}
name|columnStats
operator|.
name|add
argument_list|(
name|stats
operator|.
name|getColumnStatisticsFromColName
argument_list|(
name|columnName
argument_list|)
argument_list|)
expr_stmt|;
name|values
operator|.
name|add
argument_list|(
name|Sets
operator|.
expr|<
name|ExprNodeDescEqualityWrapper
operator|>
name|newHashSet
argument_list|()
argument_list|)
expr_stmt|;
name|multiColumn
operator|=
literal|false
expr_stmt|;
block|}
comment|// 2. Extract columns and values
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<
name|children
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|ExprNodeDesc
name|child
init|=
name|children
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
comment|// If value is not a constant, we bail out
if|if
condition|(
operator|!
operator|(
name|child
operator|instanceof
name|ExprNodeConstantDesc
operator|)
condition|)
block|{
comment|// Default
return|return
name|numRows
operator|/
literal|2
return|;
block|}
if|if
condition|(
name|multiColumn
condition|)
block|{
name|ExprNodeConstantDesc
name|constantChild
init|=
operator|(
name|ExprNodeConstantDesc
operator|)
name|child
decl_stmt|;
name|List
argument_list|<
name|?
argument_list|>
name|items
init|=
operator|(
name|List
argument_list|<
name|?
argument_list|>
operator|)
name|constantChild
operator|.
name|getWritableObjectInspector
argument_list|()
operator|.
name|getWritableConstantValue
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|TypeInfo
argument_list|>
name|structTypes
init|=
operator|(
operator|(
name|StructTypeInfo
operator|)
name|constantChild
operator|.
name|getTypeInfo
argument_list|()
operator|)
operator|.
name|getAllStructFieldTypeInfos
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|structTypes
operator|.
name|size
argument_list|()
condition|;
name|j
operator|++
control|)
block|{
name|ExprNodeConstantDesc
name|constant
init|=
operator|new
name|ExprNodeConstantDesc
argument_list|(
name|structTypes
operator|.
name|get
argument_list|(
name|j
argument_list|)
argument_list|,
name|items
operator|.
name|get
argument_list|(
name|j
argument_list|)
argument_list|)
decl_stmt|;
name|values
operator|.
name|get
argument_list|(
name|j
argument_list|)
operator|.
name|add
argument_list|(
operator|new
name|ExprNodeDescEqualityWrapper
argument_list|(
name|constant
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|values
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|add
argument_list|(
operator|new
name|ExprNodeDescEqualityWrapper
argument_list|(
name|child
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|boolean
name|allColsFilteredByStats
init|=
literal|true
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|columnStats
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|ValuePruner
name|vp
init|=
operator|new
name|ValuePruner
argument_list|(
name|columnStats
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|)
decl_stmt|;
name|allColsFilteredByStats
operator|&=
name|vp
operator|.
name|isValid
argument_list|()
expr_stmt|;
name|Set
argument_list|<
name|ExprNodeDescEqualityWrapper
argument_list|>
name|newValues
init|=
name|Sets
operator|.
name|newHashSet
argument_list|()
decl_stmt|;
for|for
control|(
name|ExprNodeDescEqualityWrapper
name|v
range|:
name|values
operator|.
name|get
argument_list|(
name|i
argument_list|)
control|)
block|{
if|if
condition|(
name|vp
operator|.
name|accept
argument_list|(
name|v
argument_list|)
condition|)
block|{
name|newValues
operator|.
name|add
argument_list|(
name|v
argument_list|)
expr_stmt|;
block|}
block|}
name|values
operator|.
name|set
argument_list|(
name|i
argument_list|,
name|newValues
argument_list|)
expr_stmt|;
block|}
comment|// 3. Calculate IN selectivity
name|double
name|factor
init|=
literal|1d
decl_stmt|;
if|if
condition|(
name|multiColumn
condition|)
block|{
comment|// distinct value array doesn not help that much here; think (1,1),(1,2),(2,1),(2,2) as values
comment|// but that will look like (1,2) as column values...
name|factor
operator|*=
name|children
operator|.
name|size
argument_list|()
operator|-
literal|1
expr_stmt|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|columnStats
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|long
name|dvs
init|=
name|columnStats
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|==
literal|null
condition|?
literal|0
else|:
name|columnStats
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|getCountDistint
argument_list|()
decl_stmt|;
comment|// (num of distinct vals for col in IN clause  / num of distinct vals for col )
name|double
name|columnFactor
init|=
name|dvs
operator|==
literal|0
condition|?
literal|0.5d
else|:
operator|(
literal|1.0d
operator|/
name|dvs
operator|)
decl_stmt|;
if|if
condition|(
operator|!
name|multiColumn
condition|)
block|{
name|columnFactor
operator|*=
name|values
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|size
argument_list|()
expr_stmt|;
block|}
comment|// max can be 1, even when ndv is larger in IN clause than in column stats
name|factor
operator|*=
name|columnFactor
operator|>
literal|1d
condition|?
literal|1d
else|:
name|columnFactor
expr_stmt|;
block|}
comment|// Clamp at 1 to be sure that we don't get out of range.
name|factor
operator|=
name|Double
operator|.
name|min
argument_list|(
name|factor
argument_list|,
literal|1.0d
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|allColsFilteredByStats
condition|)
block|{
name|factor
operator|=
name|Double
operator|.
name|max
argument_list|(
name|factor
argument_list|,
name|HiveConf
operator|.
name|getFloatVar
argument_list|(
name|aspCtx
operator|.
name|getConf
argument_list|()
argument_list|,
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVE_STATS_IN_MIN_RATIO
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|float
name|inFactor
init|=
name|HiveConf
operator|.
name|getFloatVar
argument_list|(
name|aspCtx
operator|.
name|getConf
argument_list|()
argument_list|,
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVE_STATS_IN_CLAUSE_FACTOR
argument_list|)
decl_stmt|;
return|return
name|Math
operator|.
name|round
argument_list|(
name|numRows
operator|*
name|factor
operator|*
name|inFactor
argument_list|)
return|;
block|}
specifier|static
class|class
name|RangeOps
block|{
specifier|private
name|String
name|colType
decl_stmt|;
specifier|private
name|Range
name|range
decl_stmt|;
specifier|public
name|RangeOps
parameter_list|(
name|String
name|colType
parameter_list|,
name|Range
name|range
parameter_list|)
block|{
name|this
operator|.
name|colType
operator|=
name|colType
expr_stmt|;
name|this
operator|.
name|range
operator|=
name|range
expr_stmt|;
block|}
specifier|public
specifier|static
name|RangeOps
name|build
parameter_list|(
name|String
name|colType
parameter_list|,
name|Range
name|range
parameter_list|)
block|{
if|if
condition|(
name|range
operator|==
literal|null
operator|||
name|range
operator|.
name|minValue
operator|==
literal|null
operator|||
name|range
operator|.
name|maxValue
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
return|return
operator|new
name|RangeOps
argument_list|(
name|colType
argument_list|,
name|range
argument_list|)
return|;
block|}
enum|enum
name|RangeResult
block|{
name|BELOW
block|,
name|AT_MIN
block|,
name|BETWEEN
block|,
name|AT_MAX
block|,
name|ABOVE
block|;
specifier|public
specifier|static
name|RangeResult
name|of
parameter_list|(
name|boolean
name|ltMin
parameter_list|,
name|boolean
name|ltMax
parameter_list|,
name|boolean
name|eqMin
parameter_list|,
name|boolean
name|eqMax
parameter_list|)
block|{
if|if
condition|(
name|ltMin
condition|)
block|{
return|return
name|RangeResult
operator|.
name|BELOW
return|;
block|}
if|if
condition|(
name|eqMin
condition|)
block|{
return|return
name|RangeResult
operator|.
name|AT_MIN
return|;
block|}
if|if
condition|(
name|ltMax
condition|)
block|{
return|return
name|RangeResult
operator|.
name|BETWEEN
return|;
block|}
if|if
condition|(
name|eqMax
condition|)
block|{
return|return
name|AT_MAX
return|;
block|}
return|return
name|ABOVE
return|;
block|}
block|}
specifier|public
name|boolean
name|contains
parameter_list|(
name|ExprNodeDesc
name|exprNode
parameter_list|)
block|{
name|RangeResult
name|intersection
init|=
name|intersect
argument_list|(
name|exprNode
argument_list|)
decl_stmt|;
return|return
name|intersection
operator|!=
name|RangeResult
operator|.
name|ABOVE
operator|&&
name|intersection
operator|!=
name|RangeResult
operator|.
name|BELOW
return|;
block|}
specifier|public
name|RangeResult
name|intersect
parameter_list|(
name|ExprNodeDesc
name|exprNode
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|exprNode
operator|instanceof
name|ExprNodeConstantDesc
operator|)
condition|)
block|{
return|return
literal|null
return|;
block|}
try|try
block|{
name|ExprNodeConstantDesc
name|constantDesc
init|=
operator|(
name|ExprNodeConstantDesc
operator|)
name|exprNode
decl_stmt|;
name|String
name|stringVal
init|=
name|constantDesc
operator|.
name|getValue
argument_list|()
operator|.
name|toString
argument_list|()
decl_stmt|;
annotation|@
name|Deprecated
name|String
name|boundValue
init|=
name|stringVal
decl_stmt|;
switch|switch
condition|(
name|colType
condition|)
block|{
case|case
name|serdeConstants
operator|.
name|TINYINT_TYPE_NAME
case|:
block|{
name|byte
name|value
init|=
name|Byte
operator|.
name|parseByte
argument_list|(
name|stringVal
argument_list|)
decl_stmt|;
name|byte
name|maxValue
init|=
name|range
operator|.
name|maxValue
operator|.
name|byteValue
argument_list|()
decl_stmt|;
name|byte
name|minValue
init|=
name|range
operator|.
name|minValue
operator|.
name|byteValue
argument_list|()
decl_stmt|;
return|return
name|RangeResult
operator|.
name|of
argument_list|(
name|value
operator|<
name|minValue
argument_list|,
name|value
operator|<
name|maxValue
argument_list|,
name|value
operator|==
name|minValue
argument_list|,
name|value
operator|==
name|maxValue
argument_list|)
return|;
block|}
case|case
name|serdeConstants
operator|.
name|SMALLINT_TYPE_NAME
case|:
block|{
name|short
name|value
init|=
name|Short
operator|.
name|parseShort
argument_list|(
name|boundValue
argument_list|)
decl_stmt|;
name|short
name|maxValue
init|=
name|range
operator|.
name|maxValue
operator|.
name|shortValue
argument_list|()
decl_stmt|;
name|short
name|minValue
init|=
name|range
operator|.
name|minValue
operator|.
name|shortValue
argument_list|()
decl_stmt|;
return|return
name|RangeResult
operator|.
name|of
argument_list|(
name|value
operator|<
name|minValue
argument_list|,
name|value
operator|<
name|maxValue
argument_list|,
name|value
operator|==
name|minValue
argument_list|,
name|value
operator|==
name|maxValue
argument_list|)
return|;
block|}
case|case
name|serdeConstants
operator|.
name|DATE_TYPE_NAME
case|:
block|{
name|DateWritable
name|dateWriteable
init|=
operator|new
name|DateWritable
argument_list|(
name|java
operator|.
name|sql
operator|.
name|Date
operator|.
name|valueOf
argument_list|(
name|boundValue
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|value
init|=
name|dateWriteable
operator|.
name|getDays
argument_list|()
decl_stmt|;
name|int
name|maxValue
init|=
name|range
operator|.
name|maxValue
operator|.
name|intValue
argument_list|()
decl_stmt|;
name|int
name|minValue
init|=
name|range
operator|.
name|minValue
operator|.
name|intValue
argument_list|()
decl_stmt|;
return|return
name|RangeResult
operator|.
name|of
argument_list|(
name|value
operator|<
name|minValue
argument_list|,
name|value
operator|<
name|maxValue
argument_list|,
name|value
operator|==
name|minValue
argument_list|,
name|value
operator|==
name|maxValue
argument_list|)
return|;
block|}
case|case
name|serdeConstants
operator|.
name|INT_TYPE_NAME
case|:
block|{
name|int
name|value
init|=
name|Integer
operator|.
name|parseInt
argument_list|(
name|boundValue
argument_list|)
decl_stmt|;
name|int
name|maxValue
init|=
name|range
operator|.
name|maxValue
operator|.
name|intValue
argument_list|()
decl_stmt|;
name|int
name|minValue
init|=
name|range
operator|.
name|minValue
operator|.
name|intValue
argument_list|()
decl_stmt|;
return|return
name|RangeResult
operator|.
name|of
argument_list|(
name|value
operator|<
name|minValue
argument_list|,
name|value
operator|<
name|maxValue
argument_list|,
name|value
operator|==
name|minValue
argument_list|,
name|value
operator|==
name|maxValue
argument_list|)
return|;
block|}
case|case
name|serdeConstants
operator|.
name|BIGINT_TYPE_NAME
case|:
block|{
name|long
name|value
init|=
name|Long
operator|.
name|parseLong
argument_list|(
name|boundValue
argument_list|)
decl_stmt|;
name|long
name|maxValue
init|=
name|range
operator|.
name|maxValue
operator|.
name|longValue
argument_list|()
decl_stmt|;
name|long
name|minValue
init|=
name|range
operator|.
name|minValue
operator|.
name|longValue
argument_list|()
decl_stmt|;
return|return
name|RangeResult
operator|.
name|of
argument_list|(
name|value
operator|<
name|minValue
argument_list|,
name|value
operator|<
name|maxValue
argument_list|,
name|value
operator|==
name|minValue
argument_list|,
name|value
operator|==
name|maxValue
argument_list|)
return|;
block|}
case|case
name|serdeConstants
operator|.
name|FLOAT_TYPE_NAME
case|:
block|{
name|float
name|value
init|=
name|Float
operator|.
name|parseFloat
argument_list|(
name|boundValue
argument_list|)
decl_stmt|;
name|float
name|maxValue
init|=
name|range
operator|.
name|maxValue
operator|.
name|floatValue
argument_list|()
decl_stmt|;
name|float
name|minValue
init|=
name|range
operator|.
name|minValue
operator|.
name|floatValue
argument_list|()
decl_stmt|;
return|return
name|RangeResult
operator|.
name|of
argument_list|(
name|value
operator|<
name|minValue
argument_list|,
name|value
operator|<
name|maxValue
argument_list|,
name|value
operator|==
name|minValue
argument_list|,
name|value
operator|==
name|maxValue
argument_list|)
return|;
block|}
case|case
name|serdeConstants
operator|.
name|DOUBLE_TYPE_NAME
case|:
block|{
name|double
name|value
init|=
name|Double
operator|.
name|parseDouble
argument_list|(
name|boundValue
argument_list|)
decl_stmt|;
name|double
name|maxValue
init|=
name|range
operator|.
name|maxValue
operator|.
name|doubleValue
argument_list|()
decl_stmt|;
name|double
name|minValue
init|=
name|range
operator|.
name|minValue
operator|.
name|doubleValue
argument_list|()
decl_stmt|;
return|return
name|RangeResult
operator|.
name|of
argument_list|(
name|value
operator|<
name|minValue
argument_list|,
name|value
operator|<
name|maxValue
argument_list|,
name|value
operator|==
name|minValue
argument_list|,
name|value
operator|==
name|maxValue
argument_list|)
return|;
block|}
default|default:
if|if
condition|(
name|colType
operator|.
name|startsWith
argument_list|(
name|serdeConstants
operator|.
name|DECIMAL_TYPE_NAME
argument_list|)
condition|)
block|{
name|BigDecimal
name|value
init|=
operator|new
name|BigDecimal
argument_list|(
name|boundValue
argument_list|)
decl_stmt|;
name|BigDecimal
name|maxValue
init|=
operator|new
name|BigDecimal
argument_list|(
name|range
operator|.
name|maxValue
operator|.
name|toString
argument_list|()
argument_list|)
decl_stmt|;
name|BigDecimal
name|minValue
init|=
operator|new
name|BigDecimal
argument_list|(
name|range
operator|.
name|minValue
operator|.
name|toString
argument_list|()
argument_list|)
decl_stmt|;
name|int
name|minComparison
init|=
name|value
operator|.
name|compareTo
argument_list|(
name|minValue
argument_list|)
decl_stmt|;
name|int
name|maxComparison
init|=
name|value
operator|.
name|compareTo
argument_list|(
name|maxValue
argument_list|)
decl_stmt|;
return|return
name|RangeResult
operator|.
name|of
argument_list|(
name|minComparison
operator|<
literal|0
argument_list|,
name|maxComparison
operator|<
literal|0
argument_list|,
name|minComparison
operator|==
literal|0
argument_list|,
name|maxComparison
operator|==
literal|0
argument_list|)
return|;
block|}
return|return
literal|null
return|;
block|}
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
comment|// NumberFormatException value out of range
comment|// other unknown cases
return|return
literal|null
return|;
block|}
block|}
block|}
specifier|private
specifier|static
class|class
name|ValuePruner
block|{
specifier|private
name|boolean
name|valid
decl_stmt|;
specifier|private
name|RangeOps
name|colRange
decl_stmt|;
name|ValuePruner
parameter_list|(
name|ColStatistics
name|colStatistics
parameter_list|)
block|{
if|if
condition|(
name|colStatistics
operator|==
literal|null
condition|)
block|{
name|valid
operator|=
literal|false
expr_stmt|;
return|return;
block|}
name|colRange
operator|=
name|RangeOps
operator|.
name|build
argument_list|(
name|colStatistics
operator|.
name|getColumnType
argument_list|()
argument_list|,
name|colStatistics
operator|.
name|getRange
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|colRange
operator|==
literal|null
condition|)
block|{
name|valid
operator|=
literal|false
expr_stmt|;
return|return;
block|}
name|valid
operator|=
literal|true
expr_stmt|;
block|}
specifier|public
name|boolean
name|isValid
parameter_list|()
block|{
return|return
name|valid
return|;
block|}
specifier|public
name|boolean
name|accept
parameter_list|(
name|ExprNodeDescEqualityWrapper
name|e
parameter_list|)
block|{
comment|/** removes all values which are outside of the scope of the column */
return|return
operator|!
name|valid
operator|||
name|colRange
operator|.
name|contains
argument_list|(
name|e
operator|.
name|getExprNodeDesc
argument_list|()
argument_list|)
return|;
block|}
block|}
specifier|private
name|ExprNodeDesc
name|rewriteBetweenToIn
parameter_list|(
specifier|final
name|ExprNodeDesc
name|comparisonExpression
parameter_list|,
specifier|final
name|ExprNodeDesc
name|leftExpression
parameter_list|,
specifier|final
name|ExprNodeDesc
name|rightExpression
parameter_list|,
name|boolean
name|invert
parameter_list|)
block|{
comment|// difference in BETWEEN values could be millions, since for each value a new ExprNodeConstantDesc is created
comment|// we should limit the rewrite to avoid taking too much memory
specifier|final
name|int
name|REWRITE_THRESHOLD
init|=
literal|100
decl_stmt|;
name|boolean
name|shouldRewrite
init|=
literal|false
decl_stmt|;
name|long
name|startVal
init|=
literal|0
decl_stmt|,
name|endVal
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|ExprNodeDescUtils
operator|.
name|isIntegerType
argument_list|(
name|comparisonExpression
argument_list|)
operator|&&
name|leftExpression
operator|instanceof
name|ExprNodeConstantDesc
operator|&&
name|rightExpression
operator|instanceof
name|ExprNodeConstantDesc
condition|)
block|{
name|Object
name|leftValue
init|=
operator|(
operator|(
name|ExprNodeConstantDesc
operator|)
name|leftExpression
operator|)
operator|.
name|getValue
argument_list|()
decl_stmt|;
name|Object
name|rightValue
init|=
operator|(
operator|(
name|ExprNodeConstantDesc
operator|)
name|rightExpression
operator|)
operator|.
name|getValue
argument_list|()
decl_stmt|;
name|startVal
operator|=
operator|(
operator|(
name|Number
operator|)
name|leftValue
operator|)
operator|.
name|longValue
argument_list|()
expr_stmt|;
name|endVal
operator|=
operator|(
operator|(
name|Number
operator|)
name|rightValue
operator|)
operator|.
name|longValue
argument_list|()
expr_stmt|;
comment|// BETWEEN could be (10,0)
if|if
condition|(
name|startVal
operator|>
name|endVal
condition|)
block|{
name|Long
name|tmpVal
init|=
name|startVal
decl_stmt|;
name|startVal
operator|=
name|endVal
expr_stmt|;
name|endVal
operator|=
name|tmpVal
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|endVal
operator|-
name|startVal
operator|)
operator|<=
name|REWRITE_THRESHOLD
condition|)
block|{
name|shouldRewrite
operator|=
literal|true
expr_stmt|;
block|}
block|}
if|if
condition|(
name|shouldRewrite
condition|)
block|{
name|List
argument_list|<
name|ExprNodeDesc
argument_list|>
name|constantExprs
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|constantExprs
operator|.
name|add
argument_list|(
name|comparisonExpression
argument_list|)
expr_stmt|;
comment|//generate list of contiguous integers
for|for
control|(
name|long
name|i
init|=
name|startVal
init|;
name|i
operator|<=
name|endVal
condition|;
name|i
operator|++
control|)
block|{
name|ExprNodeConstantDesc
name|constExpr
init|=
operator|new
name|ExprNodeConstantDesc
argument_list|(
name|comparisonExpression
operator|.
name|getTypeInfo
argument_list|()
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|constantExprs
operator|.
name|add
argument_list|(
name|constExpr
argument_list|)
expr_stmt|;
block|}
name|ExprNodeDesc
name|newExpression
init|=
operator|new
name|ExprNodeGenericFuncDesc
argument_list|(
name|TypeInfoFactory
operator|.
name|booleanTypeInfo
argument_list|,
operator|new
name|GenericUDFIn
argument_list|()
argument_list|,
name|constantExprs
argument_list|)
decl_stmt|;
return|return
name|newExpression
return|;
block|}
else|else
block|{
comment|// We transform the BETWEEN clause to AND clause (with NOT on top in invert is true).
comment|// This is more straightforward, as the evaluateExpression method will deal with
comment|// generating the final row count relying on the basic comparator evaluation methods
specifier|final
name|ExprNodeDesc
name|leftComparator
init|=
operator|new
name|ExprNodeGenericFuncDesc
argument_list|(
name|TypeInfoFactory
operator|.
name|booleanTypeInfo
argument_list|,
operator|new
name|GenericUDFOPEqualOrGreaterThan
argument_list|()
argument_list|,
name|Lists
operator|.
name|newArrayList
argument_list|(
name|comparisonExpression
argument_list|,
name|leftExpression
argument_list|)
argument_list|)
decl_stmt|;
specifier|final
name|ExprNodeDesc
name|rightComparator
init|=
operator|new
name|ExprNodeGenericFuncDesc
argument_list|(
name|TypeInfoFactory
operator|.
name|booleanTypeInfo
argument_list|,
operator|new
name|GenericUDFOPEqualOrLessThan
argument_list|()
argument_list|,
name|Lists
operator|.
name|newArrayList
argument_list|(
name|comparisonExpression
argument_list|,
name|rightExpression
argument_list|)
argument_list|)
decl_stmt|;
name|ExprNodeDesc
name|newExpression
init|=
operator|new
name|ExprNodeGenericFuncDesc
argument_list|(
name|TypeInfoFactory
operator|.
name|booleanTypeInfo
argument_list|,
operator|new
name|GenericUDFOPAnd
argument_list|()
argument_list|,
name|Lists
operator|.
name|newArrayList
argument_list|(
name|leftComparator
argument_list|,
name|rightComparator
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|invert
condition|)
block|{
name|newExpression
operator|=
operator|new
name|ExprNodeGenericFuncDesc
argument_list|(
name|TypeInfoFactory
operator|.
name|booleanTypeInfo
argument_list|,
operator|new
name|GenericUDFOPNot
argument_list|()
argument_list|,
name|Lists
operator|.
name|newArrayList
argument_list|(
name|newExpression
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|newExpression
return|;
block|}
block|}
specifier|private
name|long
name|evaluateBetweenExpr
parameter_list|(
name|Statistics
name|stats
parameter_list|,
name|ExprNodeDesc
name|pred
parameter_list|,
name|long
name|currNumRows
parameter_list|,
name|AnnotateStatsProcCtx
name|aspCtx
parameter_list|,
name|List
argument_list|<
name|String
argument_list|>
name|neededCols
parameter_list|,
name|Operator
argument_list|<
name|?
argument_list|>
name|op
parameter_list|)
throws|throws
name|SemanticException
block|{
specifier|final
name|ExprNodeGenericFuncDesc
name|fd
init|=
operator|(
name|ExprNodeGenericFuncDesc
operator|)
name|pred
decl_stmt|;
specifier|final
name|boolean
name|invert
init|=
name|Boolean
operator|.
name|TRUE
operator|.
name|equals
argument_list|(
operator|(
operator|(
name|ExprNodeConstantDesc
operator|)
name|fd
operator|.
name|getChildren
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|)
operator|.
name|getValue
argument_list|()
argument_list|)
decl_stmt|;
comment|// boolean invert (not)
specifier|final
name|ExprNodeDesc
name|comparisonExpression
init|=
name|fd
operator|.
name|getChildren
argument_list|()
operator|.
name|get
argument_list|(
literal|1
argument_list|)
decl_stmt|;
comment|// expression
specifier|final
name|ExprNodeDesc
name|leftExpression
init|=
name|fd
operator|.
name|getChildren
argument_list|()
operator|.
name|get
argument_list|(
literal|2
argument_list|)
decl_stmt|;
comment|// left expression
specifier|final
name|ExprNodeDesc
name|rightExpression
init|=
name|fd
operator|.
name|getChildren
argument_list|()
operator|.
name|get
argument_list|(
literal|3
argument_list|)
decl_stmt|;
comment|// right expression
comment|// Short circuit and return the current number of rows if this is a
comment|// synthetic predicate with dynamic values
if|if
condition|(
name|leftExpression
operator|instanceof
name|ExprNodeDynamicValueDesc
condition|)
block|{
return|return
name|currNumRows
return|;
block|}
name|ExprNodeDesc
name|newExpression
init|=
name|rewriteBetweenToIn
argument_list|(
name|comparisonExpression
argument_list|,
name|leftExpression
argument_list|,
name|rightExpression
argument_list|,
name|invert
argument_list|)
decl_stmt|;
return|return
name|evaluateExpression
argument_list|(
name|stats
argument_list|,
name|newExpression
argument_list|,
name|aspCtx
argument_list|,
name|neededCols
argument_list|,
name|op
argument_list|,
name|currNumRows
argument_list|)
return|;
block|}
specifier|private
name|long
name|evaluateNotExpr
parameter_list|(
name|Statistics
name|stats
parameter_list|,
name|ExprNodeDesc
name|pred
parameter_list|,
name|long
name|currNumRows
parameter_list|,
name|AnnotateStatsProcCtx
name|aspCtx
parameter_list|,
name|List
argument_list|<
name|String
argument_list|>
name|neededCols
parameter_list|,
name|Operator
argument_list|<
name|?
argument_list|>
name|op
parameter_list|)
throws|throws
name|SemanticException
block|{
name|long
name|numRows
init|=
name|currNumRows
decl_stmt|;
comment|// if the evaluate yields true then pass all rows else pass 0 rows
if|if
condition|(
name|pred
operator|instanceof
name|ExprNodeGenericFuncDesc
condition|)
block|{
name|ExprNodeGenericFuncDesc
name|genFunc
init|=
operator|(
name|ExprNodeGenericFuncDesc
operator|)
name|pred
decl_stmt|;
for|for
control|(
name|ExprNodeDesc
name|leaf
range|:
name|genFunc
operator|.
name|getChildren
argument_list|()
control|)
block|{
if|if
condition|(
name|leaf
operator|instanceof
name|ExprNodeGenericFuncDesc
condition|)
block|{
comment|// GenericUDF
name|long
name|newNumRows
init|=
literal|0
decl_stmt|;
for|for
control|(
name|ExprNodeDesc
name|child
range|:
name|genFunc
operator|.
name|getChildren
argument_list|()
control|)
block|{
name|newNumRows
operator|=
name|evaluateChildExpr
argument_list|(
name|stats
argument_list|,
name|child
argument_list|,
name|aspCtx
argument_list|,
name|neededCols
argument_list|,
name|op
argument_list|,
name|numRows
argument_list|)
expr_stmt|;
block|}
return|return
name|numRows
operator|-
name|newNumRows
return|;
block|}
elseif|else
if|if
condition|(
name|leaf
operator|instanceof
name|ExprNodeConstantDesc
condition|)
block|{
name|ExprNodeConstantDesc
name|encd
init|=
operator|(
name|ExprNodeConstantDesc
operator|)
name|leaf
decl_stmt|;
if|if
condition|(
name|Boolean
operator|.
name|TRUE
operator|.
name|equals
argument_list|(
name|encd
operator|.
name|getValue
argument_list|()
argument_list|)
condition|)
block|{
return|return
literal|0
return|;
block|}
else|else
block|{
return|return
name|numRows
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|leaf
operator|instanceof
name|ExprNodeColumnDesc
condition|)
block|{
comment|// NOT on boolean columns is possible. in which case return false count.
name|ExprNodeColumnDesc
name|encd
init|=
operator|(
name|ExprNodeColumnDesc
operator|)
name|leaf
decl_stmt|;
name|aspCtx
operator|.
name|addAffectedColumn
argument_list|(
name|encd
argument_list|)
expr_stmt|;
name|String
name|colName
init|=
name|encd
operator|.
name|getColumn
argument_list|()
decl_stmt|;
name|String
name|colType
init|=
name|encd
operator|.
name|getTypeString
argument_list|()
decl_stmt|;
if|if
condition|(
name|colType
operator|.
name|equalsIgnoreCase
argument_list|(
name|serdeConstants
operator|.
name|BOOLEAN_TYPE_NAME
argument_list|)
condition|)
block|{
name|ColStatistics
name|cs
init|=
name|stats
operator|.
name|getColumnStatisticsFromColName
argument_list|(
name|colName
argument_list|)
decl_stmt|;
if|if
condition|(
name|cs
operator|!=
literal|null
condition|)
block|{
return|return
name|cs
operator|.
name|getNumFalses
argument_list|()
return|;
block|}
block|}
comment|// if not boolean column return half the number of rows
return|return
name|numRows
operator|/
literal|2
return|;
block|}
block|}
block|}
comment|// worst case
return|return
name|numRows
operator|/
literal|2
return|;
block|}
specifier|private
name|long
name|evaluateColEqualsNullExpr
parameter_list|(
name|Statistics
name|stats
parameter_list|,
name|AnnotateStatsProcCtx
name|aspCtx
parameter_list|,
name|ExprNodeDesc
name|pred
parameter_list|,
name|long
name|currNumRows
parameter_list|)
block|{
name|long
name|numRows
init|=
name|currNumRows
decl_stmt|;
if|if
condition|(
name|pred
operator|instanceof
name|ExprNodeGenericFuncDesc
condition|)
block|{
name|ExprNodeGenericFuncDesc
name|genFunc
init|=
operator|(
name|ExprNodeGenericFuncDesc
operator|)
name|pred
decl_stmt|;
for|for
control|(
name|ExprNodeDesc
name|leaf
range|:
name|genFunc
operator|.
name|getChildren
argument_list|()
control|)
block|{
if|if
condition|(
name|leaf
operator|instanceof
name|ExprNodeColumnDesc
condition|)
block|{
name|ExprNodeColumnDesc
name|colDesc
init|=
operator|(
name|ExprNodeColumnDesc
operator|)
name|leaf
decl_stmt|;
name|aspCtx
operator|.
name|addAffectedColumn
argument_list|(
name|colDesc
argument_list|)
expr_stmt|;
name|String
name|colName
init|=
name|colDesc
operator|.
name|getColumn
argument_list|()
decl_stmt|;
name|ColStatistics
name|cs
init|=
name|stats
operator|.
name|getColumnStatisticsFromColName
argument_list|(
name|colName
argument_list|)
decl_stmt|;
if|if
condition|(
name|cs
operator|!=
literal|null
condition|)
block|{
return|return
name|cs
operator|.
name|getNumNulls
argument_list|()
return|;
block|}
block|}
block|}
block|}
comment|// worst case
return|return
name|numRows
operator|/
literal|2
return|;
block|}
specifier|private
name|long
name|evaluateNotNullExpr
parameter_list|(
name|Statistics
name|parentStats
parameter_list|,
name|AnnotateStatsProcCtx
name|aspCtx
parameter_list|,
name|ExprNodeGenericFuncDesc
name|pred
parameter_list|,
name|long
name|currNumRows
parameter_list|)
block|{
name|long
name|noOfNulls
init|=
name|getMaxNulls
argument_list|(
name|parentStats
argument_list|,
name|aspCtx
argument_list|,
name|pred
argument_list|)
decl_stmt|;
name|long
name|parentCardinality
init|=
name|currNumRows
decl_stmt|;
name|long
name|newPredCardinality
init|=
name|parentCardinality
decl_stmt|;
if|if
condition|(
name|parentCardinality
operator|>
name|noOfNulls
condition|)
block|{
name|newPredCardinality
operator|=
name|parentCardinality
operator|-
name|noOfNulls
expr_stmt|;
block|}
else|else
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Invalid column stats: No of nulls> cardinality"
argument_list|)
expr_stmt|;
block|}
return|return
name|newPredCardinality
return|;
block|}
specifier|private
name|long
name|getMaxNulls
parameter_list|(
name|Statistics
name|stats
parameter_list|,
name|AnnotateStatsProcCtx
name|aspCtx
parameter_list|,
name|ExprNodeDesc
name|pred
parameter_list|)
block|{
name|long
name|tmpNoNulls
init|=
literal|0
decl_stmt|;
name|long
name|maxNoNulls
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|pred
operator|instanceof
name|ExprNodeColumnDesc
condition|)
block|{
name|ExprNodeColumnDesc
name|encd
init|=
operator|(
name|ExprNodeColumnDesc
operator|)
name|pred
decl_stmt|;
name|aspCtx
operator|.
name|addAffectedColumn
argument_list|(
name|encd
argument_list|)
expr_stmt|;
name|ColStatistics
name|cs
init|=
name|stats
operator|.
name|getColumnStatisticsFromColName
argument_list|(
name|encd
operator|.
name|getColumn
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|cs
operator|!=
literal|null
condition|)
block|{
name|tmpNoNulls
operator|=
name|cs
operator|.
name|getNumNulls
argument_list|()
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|pred
operator|instanceof
name|ExprNodeGenericFuncDesc
operator|||
name|pred
operator|instanceof
name|ExprNodeColumnListDesc
condition|)
block|{
name|long
name|noNullsOfChild
init|=
literal|0
decl_stmt|;
for|for
control|(
name|ExprNodeDesc
name|childExpr
range|:
name|pred
operator|.
name|getChildren
argument_list|()
control|)
block|{
name|noNullsOfChild
operator|=
name|getMaxNulls
argument_list|(
name|stats
argument_list|,
name|aspCtx
argument_list|,
name|childExpr
argument_list|)
expr_stmt|;
if|if
condition|(
name|noNullsOfChild
operator|>
name|tmpNoNulls
condition|)
block|{
name|tmpNoNulls
operator|=
name|noNullsOfChild
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|pred
operator|instanceof
name|ExprNodeConstantDesc
condition|)
block|{
if|if
condition|(
name|ExprNodeDescUtils
operator|.
name|isNullConstant
argument_list|(
name|pred
argument_list|)
condition|)
block|{
name|tmpNoNulls
operator|=
name|stats
operator|.
name|getNumRows
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|tmpNoNulls
operator|=
literal|0
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|pred
operator|instanceof
name|ExprNodeDynamicListDesc
condition|)
block|{
name|tmpNoNulls
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|pred
operator|instanceof
name|ExprNodeFieldDesc
condition|)
block|{
comment|// TODO Confirm this is safe
name|tmpNoNulls
operator|=
name|getMaxNulls
argument_list|(
name|stats
argument_list|,
name|aspCtx
argument_list|,
operator|(
operator|(
name|ExprNodeFieldDesc
operator|)
name|pred
operator|)
operator|.
name|getDesc
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|tmpNoNulls
operator|>
name|maxNoNulls
condition|)
block|{
name|maxNoNulls
operator|=
name|tmpNoNulls
expr_stmt|;
block|}
return|return
name|maxNoNulls
return|;
block|}
specifier|private
name|long
name|evaluateComparator
parameter_list|(
name|Statistics
name|stats
parameter_list|,
name|AnnotateStatsProcCtx
name|aspCtx
parameter_list|,
name|ExprNodeGenericFuncDesc
name|genFunc
parameter_list|,
name|long
name|currNumRows
parameter_list|)
block|{
name|long
name|numRows
init|=
name|currNumRows
decl_stmt|;
name|GenericUDF
name|udf
init|=
name|genFunc
operator|.
name|getGenericUDF
argument_list|()
decl_stmt|;
name|ExprNodeColumnDesc
name|columnDesc
decl_stmt|;
name|ExprNodeConstantDesc
name|constantDesc
decl_stmt|;
name|boolean
name|upperBound
decl_stmt|;
name|String
name|boundValue
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|genFunc
operator|.
name|getChildren
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|instanceof
name|ExprNodeColumnDesc
operator|&&
name|genFunc
operator|.
name|getChildren
argument_list|()
operator|.
name|get
argument_list|(
literal|1
argument_list|)
operator|instanceof
name|ExprNodeConstantDesc
condition|)
block|{
name|columnDesc
operator|=
operator|(
name|ExprNodeColumnDesc
operator|)
name|genFunc
operator|.
name|getChildren
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|constantDesc
operator|=
operator|(
name|ExprNodeConstantDesc
operator|)
name|genFunc
operator|.
name|getChildren
argument_list|()
operator|.
name|get
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|aspCtx
operator|.
name|addAffectedColumn
argument_list|(
name|columnDesc
argument_list|)
expr_stmt|;
comment|// Comparison to null will always return false
if|if
condition|(
name|constantDesc
operator|.
name|getValue
argument_list|()
operator|==
literal|null
condition|)
block|{
return|return
literal|0
return|;
block|}
if|if
condition|(
name|udf
operator|instanceof
name|GenericUDFOPEqualOrGreaterThan
operator|||
name|udf
operator|instanceof
name|GenericUDFOPGreaterThan
condition|)
block|{
name|boundValue
operator|=
name|constantDesc
operator|.
name|getValue
argument_list|()
operator|.
name|toString
argument_list|()
expr_stmt|;
name|upperBound
operator|=
literal|false
expr_stmt|;
block|}
else|else
block|{
name|boundValue
operator|=
name|constantDesc
operator|.
name|getValue
argument_list|()
operator|.
name|toString
argument_list|()
expr_stmt|;
name|upperBound
operator|=
literal|true
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|genFunc
operator|.
name|getChildren
argument_list|()
operator|.
name|get
argument_list|(
literal|1
argument_list|)
operator|instanceof
name|ExprNodeColumnDesc
operator|&&
name|genFunc
operator|.
name|getChildren
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|instanceof
name|ExprNodeConstantDesc
condition|)
block|{
name|columnDesc
operator|=
operator|(
name|ExprNodeColumnDesc
operator|)
name|genFunc
operator|.
name|getChildren
argument_list|()
operator|.
name|get
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|constantDesc
operator|=
operator|(
name|ExprNodeConstantDesc
operator|)
name|genFunc
operator|.
name|getChildren
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|aspCtx
operator|.
name|addAffectedColumn
argument_list|(
name|columnDesc
argument_list|)
expr_stmt|;
comment|// Comparison to null will always return false
if|if
condition|(
name|constantDesc
operator|.
name|getValue
argument_list|()
operator|==
literal|null
condition|)
block|{
return|return
literal|0
return|;
block|}
if|if
condition|(
name|udf
operator|instanceof
name|GenericUDFOPEqualOrGreaterThan
operator|||
name|udf
operator|instanceof
name|GenericUDFOPGreaterThan
condition|)
block|{
name|boundValue
operator|=
name|constantDesc
operator|.
name|getValue
argument_list|()
operator|.
name|toString
argument_list|()
expr_stmt|;
name|upperBound
operator|=
literal|true
expr_stmt|;
block|}
else|else
block|{
name|boundValue
operator|=
name|constantDesc
operator|.
name|getValue
argument_list|()
operator|.
name|toString
argument_list|()
expr_stmt|;
name|upperBound
operator|=
literal|false
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// default
return|return
name|numRows
operator|/
literal|3
return|;
block|}
name|ColStatistics
name|cs
init|=
name|stats
operator|.
name|getColumnStatisticsFromColName
argument_list|(
name|columnDesc
operator|.
name|getColumn
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|cs
operator|!=
literal|null
operator|&&
name|cs
operator|.
name|getRange
argument_list|()
operator|!=
literal|null
operator|&&
name|cs
operator|.
name|getRange
argument_list|()
operator|.
name|maxValue
operator|!=
literal|null
operator|&&
name|cs
operator|.
name|getRange
argument_list|()
operator|.
name|minValue
operator|!=
literal|null
condition|)
block|{
name|String
name|colTypeLowerCase
init|=
name|columnDesc
operator|.
name|getTypeString
argument_list|()
operator|.
name|toLowerCase
argument_list|()
decl_stmt|;
try|try
block|{
if|if
condition|(
name|colTypeLowerCase
operator|.
name|equals
argument_list|(
name|serdeConstants
operator|.
name|TINYINT_TYPE_NAME
argument_list|)
condition|)
block|{
name|byte
name|value
init|=
name|Byte
operator|.
name|parseByte
argument_list|(
name|boundValue
argument_list|)
decl_stmt|;
name|byte
name|maxValue
init|=
name|cs
operator|.
name|getRange
argument_list|()
operator|.
name|maxValue
operator|.
name|byteValue
argument_list|()
decl_stmt|;
name|byte
name|minValue
init|=
name|cs
operator|.
name|getRange
argument_list|()
operator|.
name|minValue
operator|.
name|byteValue
argument_list|()
decl_stmt|;
if|if
condition|(
name|upperBound
condition|)
block|{
if|if
condition|(
name|maxValue
operator|<
name|value
condition|)
block|{
return|return
name|numRows
return|;
block|}
if|if
condition|(
name|minValue
operator|>
name|value
condition|)
block|{
return|return
literal|0
return|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|minValue
operator|>=
name|value
condition|)
block|{
return|return
name|numRows
return|;
block|}
if|if
condition|(
name|maxValue
operator|<
name|value
condition|)
block|{
return|return
literal|0
return|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|colTypeLowerCase
operator|.
name|equals
argument_list|(
name|serdeConstants
operator|.
name|SMALLINT_TYPE_NAME
argument_list|)
condition|)
block|{
name|short
name|value
init|=
name|Short
operator|.
name|parseShort
argument_list|(
name|boundValue
argument_list|)
decl_stmt|;
name|short
name|maxValue
init|=
name|cs
operator|.
name|getRange
argument_list|()
operator|.
name|maxValue
operator|.
name|shortValue
argument_list|()
decl_stmt|;
name|short
name|minValue
init|=
name|cs
operator|.
name|getRange
argument_list|()
operator|.
name|minValue
operator|.
name|shortValue
argument_list|()
decl_stmt|;
if|if
condition|(
name|upperBound
condition|)
block|{
if|if
condition|(
name|maxValue
operator|<
name|value
condition|)
block|{
return|return
name|numRows
return|;
block|}
if|if
condition|(
name|minValue
operator|>
name|value
condition|)
block|{
return|return
literal|0
return|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|minValue
operator|>=
name|value
condition|)
block|{
return|return
name|numRows
return|;
block|}
if|if
condition|(
name|maxValue
operator|<
name|value
condition|)
block|{
return|return
literal|0
return|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|colTypeLowerCase
operator|.
name|equals
argument_list|(
name|serdeConstants
operator|.
name|INT_TYPE_NAME
argument_list|)
operator|||
name|colTypeLowerCase
operator|.
name|equals
argument_list|(
name|serdeConstants
operator|.
name|DATE_TYPE_NAME
argument_list|)
condition|)
block|{
name|int
name|value
decl_stmt|;
if|if
condition|(
name|colTypeLowerCase
operator|==
name|serdeConstants
operator|.
name|DATE_TYPE_NAME
condition|)
block|{
name|DateWritable
name|writableVal
init|=
operator|new
name|DateWritable
argument_list|(
name|java
operator|.
name|sql
operator|.
name|Date
operator|.
name|valueOf
argument_list|(
name|boundValue
argument_list|)
argument_list|)
decl_stmt|;
name|value
operator|=
name|writableVal
operator|.
name|getDays
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|value
operator|=
name|Integer
operator|.
name|parseInt
argument_list|(
name|boundValue
argument_list|)
expr_stmt|;
block|}
comment|// Date is an integer internally
name|int
name|maxValue
init|=
name|cs
operator|.
name|getRange
argument_list|()
operator|.
name|maxValue
operator|.
name|intValue
argument_list|()
decl_stmt|;
name|int
name|minValue
init|=
name|cs
operator|.
name|getRange
argument_list|()
operator|.
name|minValue
operator|.
name|intValue
argument_list|()
decl_stmt|;
if|if
condition|(
name|upperBound
condition|)
block|{
if|if
condition|(
name|maxValue
operator|<
name|value
condition|)
block|{
return|return
name|numRows
return|;
block|}
if|if
condition|(
name|minValue
operator|>
name|value
condition|)
block|{
return|return
literal|0
return|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|minValue
operator|>=
name|value
condition|)
block|{
return|return
name|numRows
return|;
block|}
if|if
condition|(
name|maxValue
operator|<
name|value
condition|)
block|{
return|return
literal|0
return|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|colTypeLowerCase
operator|.
name|equals
argument_list|(
name|serdeConstants
operator|.
name|BIGINT_TYPE_NAME
argument_list|)
condition|)
block|{
name|long
name|value
init|=
name|Long
operator|.
name|parseLong
argument_list|(
name|boundValue
argument_list|)
decl_stmt|;
name|long
name|maxValue
init|=
name|cs
operator|.
name|getRange
argument_list|()
operator|.
name|maxValue
operator|.
name|longValue
argument_list|()
decl_stmt|;
name|long
name|minValue
init|=
name|cs
operator|.
name|getRange
argument_list|()
operator|.
name|minValue
operator|.
name|longValue
argument_list|()
decl_stmt|;
if|if
condition|(
name|upperBound
condition|)
block|{
if|if
condition|(
name|maxValue
operator|<
name|value
condition|)
block|{
return|return
name|numRows
return|;
block|}
if|if
condition|(
name|minValue
operator|>
name|value
condition|)
block|{
return|return
literal|0
return|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|minValue
operator|>=
name|value
condition|)
block|{
return|return
name|numRows
return|;
block|}
if|if
condition|(
name|maxValue
operator|<
name|value
condition|)
block|{
return|return
literal|0
return|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|colTypeLowerCase
operator|.
name|equals
argument_list|(
name|serdeConstants
operator|.
name|FLOAT_TYPE_NAME
argument_list|)
condition|)
block|{
name|float
name|value
init|=
name|Float
operator|.
name|parseFloat
argument_list|(
name|boundValue
argument_list|)
decl_stmt|;
name|float
name|maxValue
init|=
name|cs
operator|.
name|getRange
argument_list|()
operator|.
name|maxValue
operator|.
name|floatValue
argument_list|()
decl_stmt|;
name|float
name|minValue
init|=
name|cs
operator|.
name|getRange
argument_list|()
operator|.
name|minValue
operator|.
name|floatValue
argument_list|()
decl_stmt|;
if|if
condition|(
name|upperBound
condition|)
block|{
if|if
condition|(
name|maxValue
operator|<
name|value
condition|)
block|{
return|return
name|numRows
return|;
block|}
if|if
condition|(
name|minValue
operator|>
name|value
condition|)
block|{
return|return
literal|0
return|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|minValue
operator|>=
name|value
condition|)
block|{
return|return
name|numRows
return|;
block|}
if|if
condition|(
name|maxValue
operator|<
name|value
condition|)
block|{
return|return
literal|0
return|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|colTypeLowerCase
operator|.
name|equals
argument_list|(
name|serdeConstants
operator|.
name|DOUBLE_TYPE_NAME
argument_list|)
condition|)
block|{
name|double
name|value
init|=
name|Double
operator|.
name|parseDouble
argument_list|(
name|boundValue
argument_list|)
decl_stmt|;
name|double
name|maxValue
init|=
name|cs
operator|.
name|getRange
argument_list|()
operator|.
name|maxValue
operator|.
name|doubleValue
argument_list|()
decl_stmt|;
name|double
name|minValue
init|=
name|cs
operator|.
name|getRange
argument_list|()
operator|.
name|minValue
operator|.
name|doubleValue
argument_list|()
decl_stmt|;
if|if
condition|(
name|upperBound
condition|)
block|{
if|if
condition|(
name|maxValue
operator|<
name|value
condition|)
block|{
return|return
name|numRows
return|;
block|}
if|if
condition|(
name|minValue
operator|>
name|value
condition|)
block|{
return|return
literal|0
return|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|minValue
operator|>=
name|value
condition|)
block|{
return|return
name|numRows
return|;
block|}
if|if
condition|(
name|maxValue
operator|<
name|value
condition|)
block|{
return|return
literal|0
return|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|colTypeLowerCase
operator|.
name|startsWith
argument_list|(
name|serdeConstants
operator|.
name|DECIMAL_TYPE_NAME
argument_list|)
condition|)
block|{
name|BigDecimal
name|value
init|=
operator|new
name|BigDecimal
argument_list|(
name|boundValue
argument_list|)
decl_stmt|;
name|BigDecimal
name|maxValue
init|=
operator|new
name|BigDecimal
argument_list|(
name|cs
operator|.
name|getRange
argument_list|()
operator|.
name|maxValue
operator|.
name|toString
argument_list|()
argument_list|)
decl_stmt|;
name|BigDecimal
name|minValue
init|=
operator|new
name|BigDecimal
argument_list|(
name|cs
operator|.
name|getRange
argument_list|()
operator|.
name|minValue
operator|.
name|toString
argument_list|()
argument_list|)
decl_stmt|;
name|int
name|minComparison
init|=
name|value
operator|.
name|compareTo
argument_list|(
name|minValue
argument_list|)
decl_stmt|;
name|int
name|maxComparison
init|=
name|value
operator|.
name|compareTo
argument_list|(
name|maxValue
argument_list|)
decl_stmt|;
if|if
condition|(
name|upperBound
condition|)
block|{
if|if
condition|(
name|maxComparison
operator|>
literal|0
condition|)
block|{
return|return
name|numRows
return|;
block|}
if|if
condition|(
name|minComparison
operator|<
literal|0
condition|)
block|{
return|return
literal|0
return|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|minComparison
operator|<=
literal|0
condition|)
block|{
return|return
name|numRows
return|;
block|}
if|if
condition|(
name|maxComparison
operator|>
literal|0
condition|)
block|{
return|return
literal|0
return|;
block|}
block|}
block|}
block|}
catch|catch
parameter_list|(
name|NumberFormatException
name|nfe
parameter_list|)
block|{
return|return
name|numRows
operator|/
literal|3
return|;
block|}
block|}
comment|// default
return|return
name|numRows
operator|/
literal|3
return|;
block|}
specifier|private
name|long
name|evaluateChildExpr
parameter_list|(
name|Statistics
name|stats
parameter_list|,
name|ExprNodeDesc
name|child
parameter_list|,
name|AnnotateStatsProcCtx
name|aspCtx
parameter_list|,
name|List
argument_list|<
name|String
argument_list|>
name|neededCols
parameter_list|,
name|Operator
argument_list|<
name|?
argument_list|>
name|op
parameter_list|,
name|long
name|currNumRows
parameter_list|)
throws|throws
name|SemanticException
block|{
name|long
name|numRows
init|=
name|currNumRows
decl_stmt|;
if|if
condition|(
name|child
operator|instanceof
name|ExprNodeGenericFuncDesc
condition|)
block|{
name|ExprNodeGenericFuncDesc
name|genFunc
init|=
operator|(
name|ExprNodeGenericFuncDesc
operator|)
name|child
decl_stmt|;
name|GenericUDF
name|udf
init|=
name|genFunc
operator|.
name|getGenericUDF
argument_list|()
decl_stmt|;
if|if
condition|(
name|udf
operator|instanceof
name|GenericUDFOPEqual
condition|)
block|{
name|String
name|colName
init|=
literal|null
decl_stmt|;
name|boolean
name|isConst
init|=
literal|false
decl_stmt|;
name|Object
name|prevConst
init|=
literal|null
decl_stmt|;
for|for
control|(
name|ExprNodeDesc
name|leaf
range|:
name|genFunc
operator|.
name|getChildren
argument_list|()
control|)
block|{
if|if
condition|(
name|leaf
operator|instanceof
name|ExprNodeConstantDesc
condition|)
block|{
comment|// constant = constant expressions. We shouldn't be getting this
comment|// after constant folding
if|if
condition|(
name|isConst
condition|)
block|{
comment|// special case: if both constants are not equal then return 0
if|if
condition|(
name|prevConst
operator|!=
literal|null
operator|&&
operator|!
name|prevConst
operator|.
name|equals
argument_list|(
operator|(
operator|(
name|ExprNodeConstantDesc
operator|)
name|leaf
operator|)
operator|.
name|getValue
argument_list|()
argument_list|)
condition|)
block|{
return|return
literal|0
return|;
block|}
return|return
name|numRows
return|;
block|}
comment|// if the first argument is const then just set the flag and continue
if|if
condition|(
name|colName
operator|==
literal|null
condition|)
block|{
name|isConst
operator|=
literal|true
expr_stmt|;
name|prevConst
operator|=
operator|(
operator|(
name|ExprNodeConstantDesc
operator|)
name|leaf
operator|)
operator|.
name|getValue
argument_list|()
expr_stmt|;
continue|continue;
block|}
comment|// if column name is not contained in needed column list then it
comment|// is a partition column. We do not need to evaluate partition columns
comment|// in filter expression since it will be taken care by partitio pruner
if|if
condition|(
name|neededCols
operator|!=
literal|null
operator|&&
operator|!
name|neededCols
operator|.
name|contains
argument_list|(
name|colName
argument_list|)
condition|)
block|{
return|return
name|numRows
return|;
block|}
name|ColStatistics
name|cs
init|=
name|stats
operator|.
name|getColumnStatisticsFromColName
argument_list|(
name|colName
argument_list|)
decl_stmt|;
if|if
condition|(
name|cs
operator|!=
literal|null
condition|)
block|{
name|long
name|dvs
init|=
name|cs
operator|.
name|getCountDistint
argument_list|()
decl_stmt|;
name|numRows
operator|=
name|dvs
operator|==
literal|0
condition|?
name|numRows
operator|/
literal|2
else|:
name|Math
operator|.
name|round
argument_list|(
operator|(
name|double
operator|)
name|numRows
operator|/
name|dvs
argument_list|)
expr_stmt|;
return|return
name|numRows
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|leaf
operator|instanceof
name|ExprNodeColumnDesc
condition|)
block|{
name|ExprNodeColumnDesc
name|colDesc
init|=
operator|(
name|ExprNodeColumnDesc
operator|)
name|leaf
decl_stmt|;
name|aspCtx
operator|.
name|addAffectedColumn
argument_list|(
name|colDesc
argument_list|)
expr_stmt|;
name|colName
operator|=
name|colDesc
operator|.
name|getColumn
argument_list|()
expr_stmt|;
comment|// if const is first argument then evaluate the result
if|if
condition|(
name|isConst
condition|)
block|{
comment|// if column name is not contained in needed column list then it
comment|// is a partition column. We do not need to evaluate partition columns
comment|// in filter expression since it will be taken care by partitio pruner
if|if
condition|(
name|neededCols
operator|!=
literal|null
operator|&&
name|neededCols
operator|.
name|indexOf
argument_list|(
name|colName
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
return|return
name|numRows
return|;
block|}
name|ColStatistics
name|cs
init|=
name|stats
operator|.
name|getColumnStatisticsFromColName
argument_list|(
name|colName
argument_list|)
decl_stmt|;
if|if
condition|(
name|cs
operator|!=
literal|null
condition|)
block|{
name|long
name|dvs
init|=
name|cs
operator|.
name|getCountDistint
argument_list|()
decl_stmt|;
name|numRows
operator|=
name|dvs
operator|==
literal|0
condition|?
name|numRows
operator|/
literal|2
else|:
name|Math
operator|.
name|round
argument_list|(
operator|(
name|double
operator|)
name|numRows
operator|/
name|dvs
argument_list|)
expr_stmt|;
return|return
name|numRows
return|;
block|}
block|}
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|udf
operator|instanceof
name|GenericUDFOPNotEqual
condition|)
block|{
return|return
name|numRows
return|;
block|}
elseif|else
if|if
condition|(
name|udf
operator|instanceof
name|GenericUDFOPEqualOrGreaterThan
operator|||
name|udf
operator|instanceof
name|GenericUDFOPEqualOrLessThan
operator|||
name|udf
operator|instanceof
name|GenericUDFOPGreaterThan
operator|||
name|udf
operator|instanceof
name|GenericUDFOPLessThan
condition|)
block|{
return|return
name|evaluateComparator
argument_list|(
name|stats
argument_list|,
name|aspCtx
argument_list|,
name|genFunc
argument_list|,
name|numRows
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|udf
operator|instanceof
name|GenericUDFOPNotNull
condition|)
block|{
return|return
name|evaluateNotNullExpr
argument_list|(
name|stats
argument_list|,
name|aspCtx
argument_list|,
name|genFunc
argument_list|,
name|numRows
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|udf
operator|instanceof
name|GenericUDFOPNull
condition|)
block|{
return|return
name|evaluateColEqualsNullExpr
argument_list|(
name|stats
argument_list|,
name|aspCtx
argument_list|,
name|genFunc
argument_list|,
name|numRows
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|udf
operator|instanceof
name|GenericUDFOPAnd
operator|||
name|udf
operator|instanceof
name|GenericUDFOPOr
operator|||
name|udf
operator|instanceof
name|GenericUDFIn
operator|||
name|udf
operator|instanceof
name|GenericUDFBetween
operator|||
name|udf
operator|instanceof
name|GenericUDFOPNot
condition|)
block|{
return|return
name|evaluateExpression
argument_list|(
name|stats
argument_list|,
name|genFunc
argument_list|,
name|aspCtx
argument_list|,
name|neededCols
argument_list|,
name|op
argument_list|,
name|numRows
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|udf
operator|instanceof
name|GenericUDFInBloomFilter
condition|)
block|{
if|if
condition|(
name|genFunc
operator|.
name|getChildren
argument_list|()
operator|.
name|get
argument_list|(
literal|1
argument_list|)
operator|instanceof
name|ExprNodeDynamicValueDesc
condition|)
block|{
comment|// Synthetic predicates from semijoin opt should not affect stats.
return|return
name|numRows
return|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|child
operator|instanceof
name|ExprNodeConstantDesc
condition|)
block|{
if|if
condition|(
name|Boolean
operator|.
name|FALSE
operator|.
name|equals
argument_list|(
operator|(
operator|(
name|ExprNodeConstantDesc
operator|)
name|child
operator|)
operator|.
name|getValue
argument_list|()
argument_list|)
condition|)
block|{
return|return
literal|0
return|;
block|}
else|else
block|{
return|return
name|numRows
return|;
block|}
block|}
comment|// worst case
return|return
name|numRows
operator|/
literal|2
return|;
block|}
block|}
comment|/**    * GROUPBY operator changes the number of rows. The number of rows emitted by GBY operator will be    * atleast 1 or utmost T(R) (number of rows in relation T) based on the aggregation. A better    * estimate can be found if we have column statistics on the columns that we are grouping on.    *<p>    * Suppose if we are grouping by attributes A,B,C and if statistics for columns A,B,C are    * available then a better estimate can be found by taking the smaller of product of V(R,[A,B,C])    * (product of distinct cardinalities of A,B,C) and T(R)/2.    *<p>    * T(R) = min (T(R)/2 , V(R,[A,B,C]) ---&gt; [1]    *<p>    * In the presence of grouping sets, map-side GBY will emit more rows depending on the size of    * grouping set (input rows * size of grouping set). These rows will get reduced because of    * map-side hash aggregation. Hash aggregation is an optimization in hive to reduce the number of    * rows shuffled between map and reduce stage. This optimization will be disabled if the memory    * used for hash aggregation exceeds 90% of max available memory for hash aggregation. The number    * of rows emitted from map-side will vary if hash aggregation is enabled throughout execution or    * disabled. In the presence of grouping sets, following rules will be applied    *<p>    * If<b>hash-aggregation is enabled</b>, for query SELECT * FROM table GROUP BY (A,B) WITH CUBE    *<p>    * T(R) = min(T(R)/2, T(R, GBY(A,B)) + T(R, GBY(A)) + T(R, GBY(B)) + 1))    *<p>    * where, GBY(A,B), GBY(B), GBY(B) are the GBY rules mentioned above [1]    *<p>    * If<b>hash-aggregation is disabled</b>, apply the GBY rule [1] and then multiply the result by    * number of elements in grouping set T(R) = T(R) * length_of_grouping_set. Since we do not know    * if hash-aggregation is enabled or disabled during compile time, we will assume worst-case i.e,    * hash-aggregation is disabled    *<p>    * NOTE: The number of rows from map-side GBY operator is dependent on map-side parallelism i.e,    * number of mappers. The map-side parallelism is expected from hive config    * "hive.stats.map.parallelism". If the config is not set then default parallelism of 1 will be    * assumed.    *<p>    *<i>Worst case:</i> If no column statistics are available, then T(R) = T(R)/2 will be used as    * heuristics.    *<p>    *<i>For more information, refer 'Estimating The Cost Of Operations' chapter in    * "Database Systems: The Complete Book" by Garcia-Molina et. al.</i>    *</p>    */
specifier|public
specifier|static
class|class
name|GroupByStatsRule
extends|extends
name|DefaultStatsRule
implements|implements
name|NodeProcessor
block|{
annotation|@
name|Override
specifier|public
name|Object
name|process
parameter_list|(
name|Node
name|nd
parameter_list|,
name|Stack
argument_list|<
name|Node
argument_list|>
name|stack
parameter_list|,
name|NodeProcessorCtx
name|procCtx
parameter_list|,
name|Object
modifier|...
name|nodeOutputs
parameter_list|)
throws|throws
name|SemanticException
block|{
name|GroupByOperator
name|gop
init|=
operator|(
name|GroupByOperator
operator|)
name|nd
decl_stmt|;
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
name|parent
init|=
name|gop
operator|.
name|getParentOperators
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|Statistics
name|parentStats
init|=
name|parent
operator|.
name|getStatistics
argument_list|()
decl_stmt|;
comment|// parent stats are not populated yet
if|if
condition|(
name|parentStats
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
name|AnnotateStatsProcCtx
name|aspCtx
init|=
operator|(
name|AnnotateStatsProcCtx
operator|)
name|procCtx
decl_stmt|;
name|HiveConf
name|conf
init|=
name|aspCtx
operator|.
name|getConf
argument_list|()
decl_stmt|;
name|long
name|maxSplitSize
init|=
name|HiveConf
operator|.
name|getLongVar
argument_list|(
name|conf
argument_list|,
name|HiveConf
operator|.
name|ConfVars
operator|.
name|MAPREDMAXSPLITSIZE
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|AggregationDesc
argument_list|>
name|aggDesc
init|=
name|gop
operator|.
name|getConf
argument_list|()
operator|.
name|getAggregators
argument_list|()
decl_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|ExprNodeDesc
argument_list|>
name|colExprMap
init|=
name|gop
operator|.
name|getColumnExprMap
argument_list|()
decl_stmt|;
name|RowSchema
name|rs
init|=
name|gop
operator|.
name|getSchema
argument_list|()
decl_stmt|;
name|Statistics
name|stats
init|=
literal|null
decl_stmt|;
name|List
argument_list|<
name|ColStatistics
argument_list|>
name|colStats
init|=
name|StatsUtils
operator|.
name|getColStatisticsFromExprMap
argument_list|(
name|conf
argument_list|,
name|parentStats
argument_list|,
name|colExprMap
argument_list|,
name|rs
argument_list|)
decl_stmt|;
name|long
name|cardinality
decl_stmt|;
name|long
name|parallelism
init|=
literal|1L
decl_stmt|;
name|boolean
name|interReduction
init|=
literal|false
decl_stmt|;
name|boolean
name|hashAgg
init|=
literal|false
decl_stmt|;
name|long
name|inputSize
init|=
literal|1L
decl_stmt|;
name|boolean
name|containsGroupingSet
init|=
name|gop
operator|.
name|getConf
argument_list|()
operator|.
name|isGroupingSetsPresent
argument_list|()
decl_stmt|;
name|long
name|sizeOfGroupingSet
init|=
name|containsGroupingSet
condition|?
name|gop
operator|.
name|getConf
argument_list|()
operator|.
name|getListGroupingSets
argument_list|()
operator|.
name|size
argument_list|()
else|:
literal|1L
decl_stmt|;
comment|// There are different cases for Group By depending on map/reduce side, hash aggregation,
comment|// grouping sets and column stats. If we don't have column stats, we just assume hash
comment|// aggregation is disabled. Following are the possible cases and rule for cardinality
comment|// estimation
comment|// INTERMEDIATE REDUCTION:
comment|// Case 1: NO column stats, NO hash aggregation, NO grouping sets — numRows
comment|// Case 2: NO column stats, NO hash aggregation, grouping sets — numRows * sizeOfGroupingSet
comment|// Case 3: column stats, hash aggregation, NO grouping sets — Min(numRows / 2, ndvProduct * parallelism)
comment|// Case 4: column stats, hash aggregation, grouping sets — Min((numRows * sizeOfGroupingSet) / 2, ndvProduct * parallelism * sizeOfGroupingSet)
comment|// Case 5: column stats, NO hash aggregation, NO grouping sets — numRows
comment|// Case 6: column stats, NO hash aggregation, grouping sets — numRows * sizeOfGroupingSet
comment|// FINAL REDUCTION:
comment|// Case 7: NO column stats — numRows / 2
comment|// Case 8: column stats, grouping sets — Min(numRows, ndvProduct * sizeOfGroupingSet)
comment|// Case 9: column stats, NO grouping sets - Min(numRows, ndvProduct)
if|if
condition|(
operator|!
name|gop
operator|.
name|getConf
argument_list|()
operator|.
name|getMode
argument_list|()
operator|.
name|equals
argument_list|(
name|GroupByDesc
operator|.
name|Mode
operator|.
name|MERGEPARTIAL
argument_list|)
operator|&&
operator|!
name|gop
operator|.
name|getConf
argument_list|()
operator|.
name|getMode
argument_list|()
operator|.
name|equals
argument_list|(
name|GroupByDesc
operator|.
name|Mode
operator|.
name|COMPLETE
argument_list|)
operator|&&
operator|!
name|gop
operator|.
name|getConf
argument_list|()
operator|.
name|getMode
argument_list|()
operator|.
name|equals
argument_list|(
name|GroupByDesc
operator|.
name|Mode
operator|.
name|FINAL
argument_list|)
condition|)
block|{
name|interReduction
operator|=
literal|true
expr_stmt|;
comment|// consider approximate map side parallelism to be table data size
comment|// divided by max split size
name|TableScanOperator
name|top
init|=
name|OperatorUtils
operator|.
name|findSingleOperatorUpstream
argument_list|(
name|gop
argument_list|,
name|TableScanOperator
operator|.
name|class
argument_list|)
decl_stmt|;
comment|// if top is null then there are multiple parents (RS as well), hence
comment|// lets use parent statistics to get data size. Also maxSplitSize should
comment|// be updated to bytes per reducer (1GB default)
if|if
condition|(
name|top
operator|==
literal|null
condition|)
block|{
name|inputSize
operator|=
name|parentStats
operator|.
name|getDataSize
argument_list|()
expr_stmt|;
name|maxSplitSize
operator|=
name|HiveConf
operator|.
name|getLongVar
argument_list|(
name|conf
argument_list|,
name|HiveConf
operator|.
name|ConfVars
operator|.
name|BYTESPERREDUCER
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|inputSize
operator|=
name|top
operator|.
name|getConf
argument_list|()
operator|.
name|getStatistics
argument_list|()
operator|.
name|getDataSize
argument_list|()
expr_stmt|;
block|}
name|parallelism
operator|=
operator|(
name|int
operator|)
name|Math
operator|.
name|ceil
argument_list|(
operator|(
name|double
operator|)
name|inputSize
operator|/
name|maxSplitSize
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"STATS-"
operator|+
name|gop
operator|.
name|toString
argument_list|()
operator|+
literal|": inputSize: "
operator|+
name|inputSize
operator|+
literal|" maxSplitSize: "
operator|+
name|maxSplitSize
operator|+
literal|" parallelism: "
operator|+
name|parallelism
operator|+
literal|" containsGroupingSet: "
operator|+
name|containsGroupingSet
operator|+
literal|" sizeOfGroupingSet: "
operator|+
name|sizeOfGroupingSet
argument_list|)
expr_stmt|;
block|}
comment|// satisfying precondition means column statistics is available
if|if
condition|(
name|satisfyPrecondition
argument_list|(
name|parentStats
argument_list|)
condition|)
block|{
comment|// check if map side aggregation is possible or not based on column stats
name|hashAgg
operator|=
name|checkMapSideAggregation
argument_list|(
name|gop
argument_list|,
name|colStats
argument_list|,
name|conf
argument_list|)
expr_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"STATS-"
operator|+
name|gop
operator|.
name|toString
argument_list|()
operator|+
literal|" hashAgg: "
operator|+
name|hashAgg
argument_list|)
expr_stmt|;
block|}
name|stats
operator|=
name|parentStats
operator|.
name|clone
argument_list|()
expr_stmt|;
name|stats
operator|.
name|setColumnStats
argument_list|(
name|colStats
argument_list|)
expr_stmt|;
specifier|final
name|long
name|parentNumRows
init|=
name|stats
operator|.
name|getNumRows
argument_list|()
decl_stmt|;
comment|// compute product of distinct values of grouping columns
name|long
name|ndvProduct
init|=
name|StatsUtils
operator|.
name|computeNDVGroupingColumns
argument_list|(
name|colStats
argument_list|,
name|parentStats
argument_list|,
literal|false
argument_list|)
decl_stmt|;
comment|// if ndvProduct is 0 then column stats state must be partial and we are missing
comment|// column stats for a group by column
if|if
condition|(
name|ndvProduct
operator|==
literal|0
condition|)
block|{
name|ndvProduct
operator|=
name|parentNumRows
operator|/
literal|2
expr_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"STATS-"
operator|+
name|gop
operator|.
name|toString
argument_list|()
operator|+
literal|": ndvProduct became 0 as some column does not"
operator|+
literal|" have stats. ndvProduct changed to: "
operator|+
name|ndvProduct
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|interReduction
condition|)
block|{
if|if
condition|(
name|hashAgg
condition|)
block|{
if|if
condition|(
name|containsGroupingSet
condition|)
block|{
comment|// Case 4: column stats, hash aggregation, grouping sets
name|cardinality
operator|=
name|Math
operator|.
name|min
argument_list|(
operator|(
name|StatsUtils
operator|.
name|safeMult
argument_list|(
name|parentNumRows
argument_list|,
name|sizeOfGroupingSet
argument_list|)
operator|)
operator|/
literal|2
argument_list|,
name|StatsUtils
operator|.
name|safeMult
argument_list|(
name|StatsUtils
operator|.
name|safeMult
argument_list|(
name|ndvProduct
argument_list|,
name|parallelism
argument_list|)
argument_list|,
name|sizeOfGroupingSet
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"[Case 4] STATS-"
operator|+
name|gop
operator|.
name|toString
argument_list|()
operator|+
literal|": cardinality: "
operator|+
name|cardinality
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// Case 3: column stats, hash aggregation, NO grouping sets
name|cardinality
operator|=
name|Math
operator|.
name|min
argument_list|(
name|parentNumRows
operator|/
literal|2
argument_list|,
name|StatsUtils
operator|.
name|safeMult
argument_list|(
name|ndvProduct
argument_list|,
name|parallelism
argument_list|)
argument_list|)
expr_stmt|;
name|long
name|orgParentNumRows
init|=
name|StatsUtils
operator|.
name|safeMult
argument_list|(
name|getParentNumRows
argument_list|(
name|gop
argument_list|,
name|gop
operator|.
name|getConf
argument_list|()
operator|.
name|getKeys
argument_list|()
argument_list|,
name|conf
argument_list|)
argument_list|,
name|parallelism
argument_list|)
decl_stmt|;
name|cardinality
operator|=
name|Math
operator|.
name|min
argument_list|(
name|cardinality
argument_list|,
name|orgParentNumRows
argument_list|)
expr_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"[Case 3] STATS-"
operator|+
name|gop
operator|.
name|toString
argument_list|()
operator|+
literal|": cardinality: "
operator|+
name|cardinality
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
if|if
condition|(
name|containsGroupingSet
condition|)
block|{
comment|// Case 6: column stats, NO hash aggregation, grouping sets
name|cardinality
operator|=
name|StatsUtils
operator|.
name|safeMult
argument_list|(
name|parentNumRows
argument_list|,
name|sizeOfGroupingSet
argument_list|)
expr_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"[Case 6] STATS-"
operator|+
name|gop
operator|.
name|toString
argument_list|()
operator|+
literal|": cardinality: "
operator|+
name|cardinality
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// Case 5: column stats, NO hash aggregation, NO grouping sets
name|cardinality
operator|=
name|Math
operator|.
name|min
argument_list|(
name|parentNumRows
argument_list|,
name|getParentNumRows
argument_list|(
name|gop
argument_list|,
name|gop
operator|.
name|getConf
argument_list|()
operator|.
name|getKeys
argument_list|()
argument_list|,
name|conf
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"[Case 5] STATS-"
operator|+
name|gop
operator|.
name|toString
argument_list|()
operator|+
literal|": cardinality: "
operator|+
name|cardinality
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
else|else
block|{
comment|// in reduce side GBY, we don't know if the grouping set was present or not. so get it
comment|// from map side GBY
name|GroupByOperator
name|mGop
init|=
name|OperatorUtils
operator|.
name|findMapSideGb
argument_list|(
name|gop
argument_list|)
decl_stmt|;
if|if
condition|(
name|mGop
operator|!=
literal|null
condition|)
block|{
name|containsGroupingSet
operator|=
name|mGop
operator|.
name|getConf
argument_list|()
operator|.
name|isGroupingSetsPresent
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|containsGroupingSet
condition|)
block|{
comment|// Case 8: column stats, grouping sets
name|sizeOfGroupingSet
operator|=
name|mGop
operator|.
name|getConf
argument_list|()
operator|.
name|getListGroupingSets
argument_list|()
operator|.
name|size
argument_list|()
expr_stmt|;
name|cardinality
operator|=
name|Math
operator|.
name|min
argument_list|(
name|parentNumRows
argument_list|,
name|StatsUtils
operator|.
name|safeMult
argument_list|(
name|ndvProduct
argument_list|,
name|sizeOfGroupingSet
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"[Case 8] STATS-"
operator|+
name|gop
operator|.
name|toString
argument_list|()
operator|+
literal|": cardinality: "
operator|+
name|cardinality
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// Case 9: column stats, NO grouping sets
name|cardinality
operator|=
name|Math
operator|.
name|min
argument_list|(
name|parentNumRows
argument_list|,
name|ndvProduct
argument_list|)
expr_stmt|;
comment|// to get to the source number of rows we should be using original group by
name|GroupByOperator
name|gOpStats
init|=
name|mGop
decl_stmt|;
if|if
condition|(
name|gOpStats
operator|==
literal|null
condition|)
block|{
comment|// it could be NULL in case the plan has single group by (instead of merge and final)
comment|// e.g. autogather stats
name|gOpStats
operator|=
name|gop
expr_stmt|;
block|}
name|long
name|orgParentNumRows
init|=
name|getParentNumRows
argument_list|(
name|gOpStats
argument_list|,
name|gOpStats
operator|.
name|getConf
argument_list|()
operator|.
name|getKeys
argument_list|()
argument_list|,
name|conf
argument_list|)
decl_stmt|;
name|cardinality
operator|=
name|Math
operator|.
name|min
argument_list|(
name|orgParentNumRows
argument_list|,
name|cardinality
argument_list|)
expr_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"[Case 9] STATS-"
operator|+
name|gop
operator|.
name|toString
argument_list|()
operator|+
literal|": cardinality: "
operator|+
name|cardinality
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|// update stats, but don't update NDV as it will not change
name|StatsUtils
operator|.
name|updateStats
argument_list|(
name|stats
argument_list|,
name|cardinality
argument_list|,
literal|true
argument_list|,
name|gop
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// NO COLUMN STATS
if|if
condition|(
name|parentStats
operator|!=
literal|null
condition|)
block|{
name|stats
operator|=
name|parentStats
operator|.
name|clone
argument_list|()
expr_stmt|;
specifier|final
name|long
name|parentNumRows
init|=
name|stats
operator|.
name|getNumRows
argument_list|()
decl_stmt|;
comment|// if we don't have column stats, we just assume hash aggregation is disabled
if|if
condition|(
name|interReduction
condition|)
block|{
if|if
condition|(
name|containsGroupingSet
condition|)
block|{
comment|// Case 2: NO column stats, NO hash aggregation, grouping sets
name|cardinality
operator|=
name|StatsUtils
operator|.
name|safeMult
argument_list|(
name|parentNumRows
argument_list|,
name|sizeOfGroupingSet
argument_list|)
expr_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"[Case 2] STATS-"
operator|+
name|gop
operator|.
name|toString
argument_list|()
operator|+
literal|": cardinality: "
operator|+
name|cardinality
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// Case 1: NO column stats, NO hash aggregation, NO grouping sets
name|cardinality
operator|=
name|parentNumRows
expr_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"[Case 1] STATS-"
operator|+
name|gop
operator|.
name|toString
argument_list|()
operator|+
literal|": cardinality: "
operator|+
name|cardinality
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
comment|// Case 7: NO column stats
name|cardinality
operator|=
name|parentNumRows
operator|/
literal|2
expr_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"[Case 7] STATS-"
operator|+
name|gop
operator|.
name|toString
argument_list|()
operator|+
literal|": cardinality: "
operator|+
name|cardinality
argument_list|)
expr_stmt|;
block|}
block|}
name|StatsUtils
operator|.
name|updateStats
argument_list|(
name|stats
argument_list|,
name|cardinality
argument_list|,
literal|false
argument_list|,
name|gop
argument_list|)
expr_stmt|;
block|}
block|}
comment|// if UDAFs are present, new columns needs to be added
if|if
condition|(
operator|!
name|aggDesc
operator|.
name|isEmpty
argument_list|()
operator|&&
name|stats
operator|!=
literal|null
condition|)
block|{
name|List
argument_list|<
name|ColStatistics
argument_list|>
name|aggColStats
init|=
name|Lists
operator|.
name|newArrayList
argument_list|()
decl_stmt|;
name|int
name|idx
init|=
literal|0
decl_stmt|;
for|for
control|(
name|ColumnInfo
name|ci
range|:
name|rs
operator|.
name|getSignature
argument_list|()
control|)
block|{
comment|// if the columns in row schema is not contained in column
comment|// expression map, then those are the aggregate columns that
comment|// are added GBY operator. we will estimate the column statistics
comment|// for those newly added columns
if|if
condition|(
operator|!
name|colExprMap
operator|.
name|containsKey
argument_list|(
name|ci
operator|.
name|getInternalName
argument_list|()
argument_list|)
condition|)
block|{
name|String
name|colName
init|=
name|ci
operator|.
name|getInternalName
argument_list|()
decl_stmt|;
name|String
name|colType
init|=
name|ci
operator|.
name|getTypeName
argument_list|()
decl_stmt|;
name|ColStatistics
name|cs
init|=
operator|new
name|ColStatistics
argument_list|(
name|colName
argument_list|,
name|colType
argument_list|)
decl_stmt|;
name|cs
operator|.
name|setCountDistint
argument_list|(
name|stats
operator|.
name|getNumRows
argument_list|()
argument_list|)
expr_stmt|;
name|cs
operator|.
name|setNumNulls
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|cs
operator|.
name|setAvgColLen
argument_list|(
name|StatsUtils
operator|.
name|getAvgColLenOf
argument_list|(
name|conf
argument_list|,
name|ci
operator|.
name|getObjectInspector
argument_list|()
argument_list|,
name|colType
argument_list|)
argument_list|)
expr_stmt|;
name|computeAggregateColumnMinMax
argument_list|(
name|cs
argument_list|,
name|conf
argument_list|,
name|aggDesc
operator|.
name|get
argument_list|(
name|idx
operator|++
argument_list|)
argument_list|,
name|colType
argument_list|,
name|parentStats
argument_list|)
expr_stmt|;
name|aggColStats
operator|.
name|add
argument_list|(
name|cs
argument_list|)
expr_stmt|;
block|}
block|}
comment|// add the new aggregate column and recompute data size
if|if
condition|(
name|aggColStats
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
name|stats
operator|.
name|addToColumnStats
argument_list|(
name|aggColStats
argument_list|)
expr_stmt|;
comment|// only if the column stats is available, update the data size from
comment|// the column stats
if|if
condition|(
operator|!
name|stats
operator|.
name|getColumnStatsState
argument_list|()
operator|.
name|equals
argument_list|(
name|Statistics
operator|.
name|State
operator|.
name|NONE
argument_list|)
condition|)
block|{
name|StatsUtils
operator|.
name|updateStats
argument_list|(
name|stats
argument_list|,
name|stats
operator|.
name|getNumRows
argument_list|()
argument_list|,
literal|true
argument_list|,
name|gop
argument_list|)
expr_stmt|;
block|}
block|}
comment|// if UDAF present and if column expression map is empty then it must
comment|// be full aggregation query like count(*) in which case number of
comment|// rows will be 1
if|if
condition|(
name|colExprMap
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|StatsUtils
operator|.
name|updateStats
argument_list|(
name|stats
argument_list|,
literal|1
argument_list|,
literal|true
argument_list|,
name|gop
argument_list|)
expr_stmt|;
block|}
block|}
name|stats
operator|=
name|applyRuntimeStats
argument_list|(
name|aspCtx
operator|.
name|getParseContext
argument_list|()
operator|.
name|getContext
argument_list|()
argument_list|,
name|stats
argument_list|,
name|gop
argument_list|)
expr_stmt|;
name|gop
operator|.
name|setStatistics
argument_list|(
name|stats
argument_list|)
expr_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
operator|&&
name|stats
operator|!=
literal|null
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"[0] STATS-"
operator|+
name|gop
operator|.
name|toString
argument_list|()
operator|+
literal|": "
operator|+
name|stats
operator|.
name|extendedToString
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
literal|null
return|;
block|}
comment|/**      * If possible, sets the min / max value for the column based on the aggregate function      * being calculated and its input.      */
specifier|private
specifier|static
name|void
name|computeAggregateColumnMinMax
parameter_list|(
name|ColStatistics
name|cs
parameter_list|,
name|HiveConf
name|conf
parameter_list|,
name|AggregationDesc
name|agg
parameter_list|,
name|String
name|aggType
parameter_list|,
name|Statistics
name|parentStats
parameter_list|)
throws|throws
name|SemanticException
block|{
if|if
condition|(
name|agg
operator|.
name|getParameters
argument_list|()
operator|!=
literal|null
operator|&&
name|agg
operator|.
name|getParameters
argument_list|()
operator|.
name|size
argument_list|()
operator|==
literal|1
condition|)
block|{
name|ColStatistics
name|parentCS
init|=
name|StatsUtils
operator|.
name|getColStatisticsFromExpression
argument_list|(
name|conf
argument_list|,
name|parentStats
argument_list|,
name|agg
operator|.
name|getParameters
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|parentCS
operator|!=
literal|null
operator|&&
name|parentCS
operator|.
name|getRange
argument_list|()
operator|!=
literal|null
operator|&&
name|parentCS
operator|.
name|getRange
argument_list|()
operator|.
name|minValue
operator|!=
literal|null
operator|&&
name|parentCS
operator|.
name|getRange
argument_list|()
operator|.
name|maxValue
operator|!=
literal|null
condition|)
block|{
name|long
name|valuesCount
init|=
name|agg
operator|.
name|getDistinct
argument_list|()
condition|?
name|parentCS
operator|.
name|getCountDistint
argument_list|()
else|:
name|parentStats
operator|.
name|getNumRows
argument_list|()
operator|-
name|parentCS
operator|.
name|getNumNulls
argument_list|()
decl_stmt|;
name|Range
name|range
init|=
name|parentCS
operator|.
name|getRange
argument_list|()
decl_stmt|;
comment|// Get the aggregate function matching the name in the query.
name|GenericUDAFResolver
name|udaf
init|=
name|FunctionRegistry
operator|.
name|getGenericUDAFResolver
argument_list|(
name|agg
operator|.
name|getGenericUDAFName
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|udaf
operator|instanceof
name|GenericUDAFCount
condition|)
block|{
name|cs
operator|.
name|setRange
argument_list|(
operator|new
name|Range
argument_list|(
literal|0
argument_list|,
name|valuesCount
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|udaf
operator|instanceof
name|GenericUDAFMax
operator|||
name|udaf
operator|instanceof
name|GenericUDAFMin
condition|)
block|{
name|cs
operator|.
name|setRange
argument_list|(
operator|new
name|Range
argument_list|(
name|range
operator|.
name|minValue
argument_list|,
name|range
operator|.
name|maxValue
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|udaf
operator|instanceof
name|GenericUDAFSum
condition|)
block|{
switch|switch
condition|(
name|aggType
condition|)
block|{
case|case
name|serdeConstants
operator|.
name|TINYINT_TYPE_NAME
case|:
case|case
name|serdeConstants
operator|.
name|SMALLINT_TYPE_NAME
case|:
case|case
name|serdeConstants
operator|.
name|DATE_TYPE_NAME
case|:
case|case
name|serdeConstants
operator|.
name|INT_TYPE_NAME
case|:
case|case
name|serdeConstants
operator|.
name|BIGINT_TYPE_NAME
case|:
name|long
name|maxValueLong
init|=
name|range
operator|.
name|maxValue
operator|.
name|longValue
argument_list|()
decl_stmt|;
name|long
name|minValueLong
init|=
name|range
operator|.
name|minValue
operator|.
name|longValue
argument_list|()
decl_stmt|;
comment|// If min value is less or equal to max value (legal)
if|if
condition|(
name|minValueLong
operator|<=
name|maxValueLong
operator|&&
name|minValueLong
operator|>=
literal|0
condition|)
block|{
comment|// min = minValue, max = (minValue + maxValue) * 0.5 * parentNumRows
name|cs
operator|.
name|setRange
argument_list|(
operator|new
name|Range
argument_list|(
name|minValueLong
argument_list|,
name|StatsUtils
operator|.
name|safeMult
argument_list|(
name|StatsUtils
operator|.
name|safeMult
argument_list|(
name|StatsUtils
operator|.
name|safeAdd
argument_list|(
name|minValueLong
argument_list|,
name|maxValueLong
argument_list|)
argument_list|,
literal|0.5
argument_list|)
argument_list|,
name|valuesCount
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|serdeConstants
operator|.
name|FLOAT_TYPE_NAME
case|:
case|case
name|serdeConstants
operator|.
name|DOUBLE_TYPE_NAME
case|:
name|double
name|maxValueDouble
init|=
name|range
operator|.
name|maxValue
operator|.
name|doubleValue
argument_list|()
decl_stmt|;
name|double
name|minValueDouble
init|=
name|range
operator|.
name|minValue
operator|.
name|doubleValue
argument_list|()
decl_stmt|;
comment|// If min value is less or equal to max value (legal)
if|if
condition|(
name|minValueDouble
operator|<=
name|maxValueDouble
operator|&&
name|minValueDouble
operator|>=
literal|0
condition|)
block|{
comment|// min = minValue, max = (minValue + maxValue) * 0.5 * parentNumRows
name|cs
operator|.
name|setRange
argument_list|(
operator|new
name|Range
argument_list|(
name|minValueDouble
argument_list|,
operator|(
name|minValueDouble
operator|+
name|maxValueDouble
operator|)
operator|*
literal|0.5
operator|*
name|valuesCount
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
if|if
condition|(
name|aggType
operator|.
name|startsWith
argument_list|(
name|serdeConstants
operator|.
name|DECIMAL_TYPE_NAME
argument_list|)
condition|)
block|{
name|BigDecimal
name|maxValueBD
init|=
operator|new
name|BigDecimal
argument_list|(
name|range
operator|.
name|maxValue
operator|.
name|toString
argument_list|()
argument_list|)
decl_stmt|;
name|BigDecimal
name|minValueBD
init|=
operator|new
name|BigDecimal
argument_list|(
name|range
operator|.
name|minValue
operator|.
name|toString
argument_list|()
argument_list|)
decl_stmt|;
comment|// If min value is less or equal to max value (legal)
if|if
condition|(
name|minValueBD
operator|.
name|compareTo
argument_list|(
name|maxValueBD
argument_list|)
operator|<=
literal|0
operator|&&
name|minValueBD
operator|.
name|compareTo
argument_list|(
name|BigDecimal
operator|.
name|ZERO
argument_list|)
operator|>=
literal|0
condition|)
block|{
comment|// min = minValue, max = (minValue + maxValue) * 0.5 * parentNumRows
name|cs
operator|.
name|setRange
argument_list|(
operator|new
name|Range
argument_list|(
name|minValueBD
argument_list|,
name|minValueBD
operator|.
name|add
argument_list|(
name|maxValueBD
argument_list|)
operator|.
name|multiply
argument_list|(
operator|new
name|BigDecimal
argument_list|(
literal|0.5
argument_list|)
argument_list|)
operator|.
name|multiply
argument_list|(
operator|new
name|BigDecimal
argument_list|(
name|valuesCount
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
block|}
block|}
specifier|private
name|long
name|getParentNumRows
parameter_list|(
name|GroupByOperator
name|op
parameter_list|,
name|List
argument_list|<
name|ExprNodeDesc
argument_list|>
name|gbyKeys
parameter_list|,
name|HiveConf
name|conf
parameter_list|)
block|{
if|if
condition|(
name|gbyKeys
operator|==
literal|null
operator|||
name|gbyKeys
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return
name|op
operator|.
name|getParentOperators
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|getStatistics
argument_list|()
operator|.
name|getNumRows
argument_list|()
return|;
block|}
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
name|parent
init|=
name|OperatorUtils
operator|.
name|findSourceRS
argument_list|(
name|op
argument_list|,
name|gbyKeys
argument_list|)
decl_stmt|;
if|if
condition|(
name|parent
operator|!=
literal|null
condition|)
block|{
return|return
name|parent
operator|.
name|getStatistics
argument_list|()
operator|.
name|getNumRows
argument_list|()
return|;
block|}
return|return
name|op
operator|.
name|getParentOperators
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|getStatistics
argument_list|()
operator|.
name|getNumRows
argument_list|()
return|;
block|}
comment|/**      * This method does not take into account many configs used at runtime to      * disable hash aggregation like HIVEMAPAGGRHASHMINREDUCTION. This method      * roughly estimates the number of rows and size of each row to see if it      * can fit in hashtable for aggregation.      * @param gop - group by operator      * @param colStats - column stats for key columns      * @param conf - hive conf      * @return      */
specifier|private
name|boolean
name|checkMapSideAggregation
parameter_list|(
name|GroupByOperator
name|gop
parameter_list|,
name|List
argument_list|<
name|ColStatistics
argument_list|>
name|colStats
parameter_list|,
name|HiveConf
name|conf
parameter_list|)
block|{
name|List
argument_list|<
name|AggregationDesc
argument_list|>
name|aggDesc
init|=
name|gop
operator|.
name|getConf
argument_list|()
operator|.
name|getAggregators
argument_list|()
decl_stmt|;
name|GroupByDesc
name|desc
init|=
name|gop
operator|.
name|getConf
argument_list|()
decl_stmt|;
name|GroupByDesc
operator|.
name|Mode
name|mode
init|=
name|desc
operator|.
name|getMode
argument_list|()
decl_stmt|;
if|if
condition|(
name|mode
operator|.
name|equals
argument_list|(
name|GroupByDesc
operator|.
name|Mode
operator|.
name|HASH
argument_list|)
condition|)
block|{
name|float
name|hashAggMem
init|=
name|conf
operator|.
name|getFloatVar
argument_list|(
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVEMAPAGGRHASHMEMORY
argument_list|)
decl_stmt|;
name|float
name|hashAggMaxThreshold
init|=
name|conf
operator|.
name|getFloatVar
argument_list|(
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVEMAPAGGRMEMORYTHRESHOLD
argument_list|)
decl_stmt|;
comment|// get available map memory
name|long
name|totalMemory
init|=
name|StatsUtils
operator|.
name|getAvailableMemory
argument_list|(
name|conf
argument_list|)
operator|*
literal|1000L
operator|*
literal|1000L
decl_stmt|;
name|long
name|maxMemHashAgg
init|=
name|Math
operator|.
name|round
argument_list|(
name|totalMemory
operator|*
name|hashAggMem
operator|*
name|hashAggMaxThreshold
argument_list|)
decl_stmt|;
comment|// estimated number of rows will be product of NDVs
name|long
name|numEstimatedRows
init|=
literal|1
decl_stmt|;
comment|// estimate size of key from column statistics
name|long
name|avgKeySize
init|=
literal|0
decl_stmt|;
for|for
control|(
name|ColStatistics
name|cs
range|:
name|colStats
control|)
block|{
if|if
condition|(
name|cs
operator|!=
literal|null
condition|)
block|{
name|numEstimatedRows
operator|=
name|StatsUtils
operator|.
name|safeMult
argument_list|(
name|numEstimatedRows
argument_list|,
name|cs
operator|.
name|getCountDistint
argument_list|()
argument_list|)
expr_stmt|;
name|avgKeySize
operator|+=
name|Math
operator|.
name|ceil
argument_list|(
name|cs
operator|.
name|getAvgColLen
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
comment|// average value size will be sum of all sizes of aggregation buffers
name|long
name|avgValSize
init|=
literal|0
decl_stmt|;
comment|// go over all aggregation buffers and see they implement estimable
comment|// interface if so they aggregate the size of the aggregation buffer
name|GenericUDAFEvaluator
index|[]
name|aggregationEvaluators
decl_stmt|;
name|aggregationEvaluators
operator|=
operator|new
name|GenericUDAFEvaluator
index|[
name|aggDesc
operator|.
name|size
argument_list|()
index|]
expr_stmt|;
comment|// get aggregation evaluators
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|aggregationEvaluators
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|AggregationDesc
name|agg
init|=
name|aggDesc
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|aggregationEvaluators
index|[
name|i
index|]
operator|=
name|agg
operator|.
name|getGenericUDAFEvaluator
argument_list|()
expr_stmt|;
block|}
comment|// estimate size of aggregation buffer
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|aggregationEvaluators
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
comment|// each evaluator has constant java object overhead
name|avgValSize
operator|+=
name|gop
operator|.
name|javaObjectOverHead
expr_stmt|;
name|GenericUDAFEvaluator
operator|.
name|AggregationBuffer
name|agg
init|=
literal|null
decl_stmt|;
name|int
name|evaluatorEstimate
init|=
name|aggregationEvaluators
index|[
name|i
index|]
operator|.
name|estimate
argument_list|()
decl_stmt|;
if|if
condition|(
name|evaluatorEstimate
operator|>
literal|0
condition|)
block|{
name|avgValSize
operator|+=
name|evaluatorEstimate
expr_stmt|;
continue|continue;
block|}
try|try
block|{
name|agg
operator|=
name|aggregationEvaluators
index|[
name|i
index|]
operator|.
name|getNewAggregationBuffer
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|HiveException
name|e
parameter_list|)
block|{
comment|// in case of exception assume unknown type (256 bytes)
name|avgValSize
operator|+=
name|gop
operator|.
name|javaSizeUnknownType
expr_stmt|;
block|}
comment|// aggregate size from aggregation buffers
if|if
condition|(
name|agg
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|GenericUDAFEvaluator
operator|.
name|isEstimable
argument_list|(
name|agg
argument_list|)
condition|)
block|{
name|avgValSize
operator|+=
operator|(
operator|(
name|GenericUDAFEvaluator
operator|.
name|AbstractAggregationBuffer
operator|)
name|agg
operator|)
operator|.
name|estimate
argument_list|()
expr_stmt|;
block|}
else|else
block|{
comment|// if the aggregation buffer is not estimable then get all the
comment|// declared fields and compute the sizes from field types
name|Field
index|[]
name|fArr
init|=
name|ObjectInspectorUtils
operator|.
name|getDeclaredNonStaticFields
argument_list|(
name|agg
operator|.
name|getClass
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|Field
name|f
range|:
name|fArr
control|)
block|{
name|long
name|avgSize
init|=
name|StatsUtils
operator|.
name|getAvgColLenOfFixedLengthTypes
argument_list|(
name|f
operator|.
name|getType
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|)
decl_stmt|;
name|avgValSize
operator|+=
name|avgSize
operator|==
literal|0
condition|?
name|gop
operator|.
name|javaSizeUnknownType
else|:
name|avgSize
expr_stmt|;
block|}
block|}
block|}
block|}
comment|// total size of each hash entry
name|long
name|hashEntrySize
init|=
name|gop
operator|.
name|javaHashEntryOverHead
operator|+
name|avgKeySize
operator|+
name|avgValSize
decl_stmt|;
comment|// estimated hash table size
name|long
name|estHashTableSize
init|=
name|StatsUtils
operator|.
name|safeMult
argument_list|(
name|numEstimatedRows
argument_list|,
name|hashEntrySize
argument_list|)
decl_stmt|;
if|if
condition|(
name|estHashTableSize
operator|<
name|maxMemHashAgg
condition|)
block|{
return|return
literal|true
return|;
block|}
block|}
comment|// worst-case, hash aggregation disabled
return|return
literal|false
return|;
block|}
block|}
comment|/**    * JOIN operator can yield any of the following three cases<ul><li>The values of join keys are    * disjoint in both relations in which case T(RXS) = 0 (we need histograms for this)</li><li>Join    * key is primary key on relation R and foreign key on relation S in which case every tuple in S    * will have a tuple in R T(RXS) = T(S) (we need histograms for this)</li><li>Both R&amp; S relation    * have same value for join-key. Ex: bool column with all true values T(RXS) = T(R) * T(S) (we    * need histograms for this. counDistinct = 1 and same value)</li></ul>    *<p>    * In the absence of histograms, we can use the following general case    *<p>    *<b>2 Relations, 1 attribute</b>    *<p>    * T(RXS) = (T(R)*T(S))/max(V(R,Y), V(S,Y)) where Y is the join attribute    *<p>    *<b>2 Relations, 2 attributes</b>    *<p>    * T(RXS) = T(R)*T(S)/max(V(R,y1), V(S,y1)) * max(V(R,y2), V(S,y2)), where y1 and y2 are the join    * attributes    *<p>    *<b>3 Relations, 1 attributes</b>    *<p>    * T(RXSXQ) = T(R)*T(S)*T(Q)/top2largest(V(R,y), V(S,y), V(Q,y)), where y is the join attribute    *<p>    *<b>3 Relations, 2 attributes</b>    *<p>    * T(RXSXQ) = T(R)*T(S)*T(Q)/top2largest(V(R,y1), V(S,y1), V(Q,y1)) * top2largest(V(R,y2), V(S,y2), V(Q,y2)),    * where y1 and y2 are the join attributes    *<p>    *<i>Worst case:</i> If no column statistics are available, then T(RXS) = joinFactor * max(T(R),    * T(S)) * (numParents - 1) will be used as heuristics. joinFactor is from hive.stats.join.factor    * hive config. In the worst case, since we do not know any information about join keys (and hence    * which of the 3 cases to use), we let it to the user to provide the join factor.    *<p>    *<i>For more information, refer 'Estimating The Cost Of Operations' chapter in    * "Database Systems: The Complete Book" by Garcia-Molina et. al.</i>    *</p>    */
specifier|public
specifier|static
class|class
name|JoinStatsRule
extends|extends
name|FilterStatsRule
implements|implements
name|NodeProcessor
block|{
annotation|@
name|Override
specifier|public
name|Object
name|process
parameter_list|(
name|Node
name|nd
parameter_list|,
name|Stack
argument_list|<
name|Node
argument_list|>
name|stack
parameter_list|,
name|NodeProcessorCtx
name|procCtx
parameter_list|,
name|Object
modifier|...
name|nodeOutputs
parameter_list|)
throws|throws
name|SemanticException
block|{
name|long
name|newNumRows
init|=
literal|0
decl_stmt|;
name|CommonJoinOperator
argument_list|<
name|?
extends|extends
name|JoinDesc
argument_list|>
name|jop
init|=
operator|(
name|CommonJoinOperator
argument_list|<
name|?
extends|extends
name|JoinDesc
argument_list|>
operator|)
name|nd
decl_stmt|;
name|List
argument_list|<
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
argument_list|>
name|parents
init|=
name|jop
operator|.
name|getParentOperators
argument_list|()
decl_stmt|;
name|int
name|numAttr
init|=
literal|1
decl_stmt|;
name|AnnotateStatsProcCtx
name|aspCtx
init|=
operator|(
name|AnnotateStatsProcCtx
operator|)
name|procCtx
decl_stmt|;
name|HiveConf
name|conf
init|=
name|aspCtx
operator|.
name|getConf
argument_list|()
decl_stmt|;
name|boolean
name|allSatisfyPreCondition
init|=
literal|true
decl_stmt|;
for|for
control|(
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
name|op
range|:
name|parents
control|)
block|{
if|if
condition|(
name|op
operator|.
name|getStatistics
argument_list|()
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
block|}
for|for
control|(
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
name|op
range|:
name|parents
control|)
block|{
if|if
condition|(
operator|!
name|satisfyPrecondition
argument_list|(
name|op
operator|.
name|getStatistics
argument_list|()
argument_list|)
condition|)
block|{
name|allSatisfyPreCondition
operator|=
literal|false
expr_stmt|;
break|break;
block|}
block|}
comment|// there could be case where join operators input are not RS e.g.
comment|// map join with Spark. Since following estimation of statistics relies on join operators having it inputs as
comment|// reduced sink it will not work for such cases. So we should not try to estimate stats
if|if
condition|(
name|allSatisfyPreCondition
condition|)
block|{
for|for
control|(
name|int
name|pos
init|=
literal|0
init|;
name|pos
operator|<
name|parents
operator|.
name|size
argument_list|()
condition|;
name|pos
operator|++
control|)
block|{
if|if
condition|(
operator|!
operator|(
name|jop
operator|.
name|getParentOperators
argument_list|()
operator|.
name|get
argument_list|(
name|pos
argument_list|)
operator|instanceof
name|ReduceSinkOperator
operator|)
condition|)
block|{
name|allSatisfyPreCondition
operator|=
literal|false
expr_stmt|;
break|break;
block|}
block|}
block|}
if|if
condition|(
name|allSatisfyPreCondition
condition|)
block|{
comment|// statistics object that is combination of statistics from all
comment|// relations involved in JOIN
name|Statistics
name|stats
init|=
operator|new
name|Statistics
argument_list|()
decl_stmt|;
name|int
name|numParent
init|=
name|parents
operator|.
name|size
argument_list|()
decl_stmt|;
name|Map
argument_list|<
name|Integer
argument_list|,
name|Long
argument_list|>
name|rowCountParents
init|=
name|Maps
operator|.
name|newHashMap
argument_list|()
decl_stmt|;
name|Map
argument_list|<
name|Integer
argument_list|,
name|Statistics
argument_list|>
name|joinStats
init|=
name|Maps
operator|.
name|newHashMap
argument_list|()
decl_stmt|;
name|Map
argument_list|<
name|Integer
argument_list|,
name|List
argument_list|<
name|String
argument_list|>
argument_list|>
name|joinKeys
init|=
name|Maps
operator|.
name|newHashMap
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|Long
argument_list|>
name|rowCounts
init|=
name|Lists
operator|.
name|newArrayList
argument_list|()
decl_stmt|;
comment|// detect if there are multiple attributes in join key
name|ReduceSinkOperator
name|rsOp
init|=
operator|(
name|ReduceSinkOperator
operator|)
name|jop
operator|.
name|getParentOperators
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|keyExprs
init|=
name|StatsUtils
operator|.
name|getQualifedReducerKeyNames
argument_list|(
name|rsOp
operator|.
name|getConf
argument_list|()
operator|.
name|getOutputKeyColumnNames
argument_list|()
argument_list|)
decl_stmt|;
name|numAttr
operator|=
name|keyExprs
operator|.
name|size
argument_list|()
expr_stmt|;
comment|// infer PK-FK relationship in single attribute join case
name|long
name|inferredRowCount
init|=
name|inferPKFKRelationship
argument_list|(
name|numAttr
argument_list|,
name|parents
argument_list|,
name|jop
argument_list|)
decl_stmt|;
comment|// get the join keys from parent ReduceSink operators
for|for
control|(
name|int
name|pos
init|=
literal|0
init|;
name|pos
operator|<
name|parents
operator|.
name|size
argument_list|()
condition|;
name|pos
operator|++
control|)
block|{
name|ReduceSinkOperator
name|parent
init|=
operator|(
name|ReduceSinkOperator
operator|)
name|jop
operator|.
name|getParentOperators
argument_list|()
operator|.
name|get
argument_list|(
name|pos
argument_list|)
decl_stmt|;
name|Statistics
name|parentStats
decl_stmt|;
name|parentStats
operator|=
name|parent
operator|.
name|getStatistics
argument_list|()
operator|.
name|clone
argument_list|()
expr_stmt|;
name|keyExprs
operator|=
name|StatsUtils
operator|.
name|getQualifedReducerKeyNames
argument_list|(
name|parent
operator|.
name|getConf
argument_list|()
operator|.
name|getOutputKeyColumnNames
argument_list|()
argument_list|)
expr_stmt|;
name|rowCountParents
operator|.
name|put
argument_list|(
name|pos
argument_list|,
name|parentStats
operator|.
name|getNumRows
argument_list|()
argument_list|)
expr_stmt|;
name|rowCounts
operator|.
name|add
argument_list|(
name|parentStats
operator|.
name|getNumRows
argument_list|()
argument_list|)
expr_stmt|;
comment|// internal name for expressions and estimate column statistics for expression.
name|joinKeys
operator|.
name|put
argument_list|(
name|pos
argument_list|,
name|keyExprs
argument_list|)
expr_stmt|;
comment|// get column statistics for all output columns
name|joinStats
operator|.
name|put
argument_list|(
name|pos
argument_list|,
name|parentStats
argument_list|)
expr_stmt|;
comment|// since new statistics is derived from all relations involved in
comment|// JOIN, we need to update the state information accordingly
name|stats
operator|.
name|updateColumnStatsState
argument_list|(
name|parentStats
operator|.
name|getColumnStatsState
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|numAttr
operator|==
literal|0
condition|)
block|{
comment|// It is a cartesian product, row count is easy to infer
name|inferredRowCount
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|int
name|pos
init|=
literal|0
init|;
name|pos
operator|<
name|parents
operator|.
name|size
argument_list|()
condition|;
name|pos
operator|++
control|)
block|{
name|inferredRowCount
operator|=
name|StatsUtils
operator|.
name|safeMult
argument_list|(
name|joinStats
operator|.
name|get
argument_list|(
name|pos
argument_list|)
operator|.
name|getNumRows
argument_list|()
argument_list|,
name|inferredRowCount
argument_list|)
expr_stmt|;
block|}
block|}
name|List
argument_list|<
name|Long
argument_list|>
name|distinctVals
init|=
name|Lists
operator|.
name|newArrayList
argument_list|()
decl_stmt|;
comment|// these ndvs are later used to compute unmatched rows and num of nulls for outer joins
name|List
argument_list|<
name|Long
argument_list|>
name|ndvsUnmatched
init|=
name|Lists
operator|.
name|newArrayList
argument_list|()
decl_stmt|;
name|long
name|denom
init|=
literal|1
decl_stmt|;
name|long
name|distinctUnmatched
init|=
literal|1
decl_stmt|;
if|if
condition|(
name|inferredRowCount
operator|==
operator|-
literal|1
condition|)
block|{
comment|// failed to infer PK-FK relationship for row count estimation fall-back on default logic
comment|// compute denominator  max(V(R,y1), V(S,y1)) * max(V(R,y2), V(S,y2))
comment|// in case of multi-attribute join
name|List
argument_list|<
name|Long
argument_list|>
name|perAttrDVs
init|=
name|Lists
operator|.
name|newArrayList
argument_list|()
decl_stmt|;
comment|// go over each predicate
for|for
control|(
name|int
name|idx
init|=
literal|0
init|;
name|idx
operator|<
name|numAttr
condition|;
name|idx
operator|++
control|)
block|{
for|for
control|(
name|Integer
name|i
range|:
name|joinKeys
operator|.
name|keySet
argument_list|()
control|)
block|{
name|String
name|col
init|=
name|joinKeys
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|get
argument_list|(
name|idx
argument_list|)
decl_stmt|;
name|ColStatistics
name|cs
init|=
name|joinStats
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|getColumnStatisticsFromColName
argument_list|(
name|col
argument_list|)
decl_stmt|;
if|if
condition|(
name|cs
operator|!=
literal|null
condition|)
block|{
name|perAttrDVs
operator|.
name|add
argument_list|(
name|cs
operator|.
name|getCountDistint
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
name|distinctVals
operator|.
name|add
argument_list|(
name|getDenominator
argument_list|(
name|perAttrDVs
argument_list|)
argument_list|)
expr_stmt|;
name|ndvsUnmatched
operator|.
name|add
argument_list|(
name|getDenominatorForUnmatchedRows
argument_list|(
name|perAttrDVs
argument_list|)
argument_list|)
expr_stmt|;
name|perAttrDVs
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|numAttr
operator|>
literal|1
operator|&&
name|conf
operator|.
name|getBoolVar
argument_list|(
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVE_STATS_CORRELATED_MULTI_KEY_JOINS
argument_list|)
condition|)
block|{
name|denom
operator|=
name|Collections
operator|.
name|max
argument_list|(
name|distinctVals
argument_list|)
expr_stmt|;
name|distinctUnmatched
operator|=
name|denom
operator|-
name|ndvsUnmatched
operator|.
name|get
argument_list|(
name|distinctVals
operator|.
name|indexOf
argument_list|(
name|denom
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// To avoid denominator getting larger and aggressively reducing
comment|// number of rows, we will ease out denominator.
name|denom
operator|=
name|StatsUtils
operator|.
name|addWithExpDecay
argument_list|(
name|distinctVals
argument_list|)
expr_stmt|;
name|distinctUnmatched
operator|=
name|denom
operator|-
name|StatsUtils
operator|.
name|addWithExpDecay
argument_list|(
name|ndvsUnmatched
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Update NDV of joined columns to be min(V(R,y), V(S,y))
name|updateJoinColumnsNDV
argument_list|(
name|joinKeys
argument_list|,
name|joinStats
argument_list|,
name|numAttr
argument_list|)
expr_stmt|;
comment|// column statistics from different sources are put together and
comment|// rename based on output schema of join operator
name|Map
argument_list|<
name|String
argument_list|,
name|ExprNodeDesc
argument_list|>
name|colExprMap
init|=
name|jop
operator|.
name|getColumnExprMap
argument_list|()
decl_stmt|;
name|RowSchema
name|rs
init|=
name|jop
operator|.
name|getSchema
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|ColStatistics
argument_list|>
name|outColStats
init|=
name|Lists
operator|.
name|newArrayList
argument_list|()
decl_stmt|;
for|for
control|(
name|ColumnInfo
name|ci
range|:
name|rs
operator|.
name|getSignature
argument_list|()
control|)
block|{
name|String
name|key
init|=
name|ci
operator|.
name|getInternalName
argument_list|()
decl_stmt|;
name|ExprNodeDesc
name|end
init|=
name|colExprMap
operator|.
name|get
argument_list|(
name|key
argument_list|)
decl_stmt|;
if|if
condition|(
name|end
operator|instanceof
name|ExprNodeColumnDesc
condition|)
block|{
name|aspCtx
operator|.
name|addAffectedColumn
argument_list|(
operator|(
name|ExprNodeColumnDesc
operator|)
name|end
argument_list|)
expr_stmt|;
name|String
name|colName
init|=
operator|(
operator|(
name|ExprNodeColumnDesc
operator|)
name|end
operator|)
operator|.
name|getColumn
argument_list|()
decl_stmt|;
name|int
name|pos
init|=
name|jop
operator|.
name|getConf
argument_list|()
operator|.
name|getReversedExprs
argument_list|()
operator|.
name|get
argument_list|(
name|key
argument_list|)
decl_stmt|;
name|ColStatistics
name|cs
init|=
name|joinStats
operator|.
name|get
argument_list|(
name|pos
argument_list|)
operator|.
name|getColumnStatisticsFromColName
argument_list|(
name|colName
argument_list|)
decl_stmt|;
name|String
name|outColName
init|=
name|key
decl_stmt|;
if|if
condition|(
name|cs
operator|!=
literal|null
condition|)
block|{
name|cs
operator|.
name|setColumnName
argument_list|(
name|outColName
argument_list|)
expr_stmt|;
block|}
name|outColStats
operator|.
name|add
argument_list|(
name|cs
argument_list|)
expr_stmt|;
block|}
block|}
comment|// update join statistics
name|stats
operator|.
name|setColumnStats
argument_list|(
name|outColStats
argument_list|)
expr_stmt|;
name|long
name|joinRowCount
decl_stmt|;
name|long
name|leftUnmatchedRows
init|=
literal|0L
decl_stmt|;
name|long
name|rightUnmatchedRows
init|=
literal|0L
decl_stmt|;
if|if
condition|(
name|inferredRowCount
operator|!=
operator|-
literal|1
condition|)
block|{
name|joinRowCount
operator|=
name|inferredRowCount
expr_stmt|;
block|}
else|else
block|{
name|long
name|innerJoinRowCount
init|=
name|computeRowCountAssumingInnerJoin
argument_list|(
name|rowCounts
argument_list|,
name|denom
argument_list|,
name|jop
argument_list|)
decl_stmt|;
comment|// the idea is to measure unmatched rows in outer joins by figuring out how many rows didn't match
if|if
condition|(
name|jop
operator|.
name|getConf
argument_list|()
operator|.
name|getConds
argument_list|()
operator|.
name|length
operator|==
literal|1
condition|)
block|{
comment|// TODO: Consider more than one condition
name|JoinCondDesc
name|joinCond
init|=
name|jop
operator|.
name|getConf
argument_list|()
operator|.
name|getConds
argument_list|()
index|[
literal|0
index|]
decl_stmt|;
if|if
condition|(
name|joinCond
operator|.
name|getType
argument_list|()
operator|==
name|JoinDesc
operator|.
name|LEFT_OUTER_JOIN
condition|)
block|{
name|leftUnmatchedRows
operator|=
name|calculateUnmatchedRowsForOuter
argument_list|(
name|conf
argument_list|,
name|rowCountParents
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|,
name|joinKeys
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|,
name|joinStats
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|,
name|distinctUnmatched
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|joinCond
operator|.
name|getType
argument_list|()
operator|==
name|JoinDesc
operator|.
name|RIGHT_OUTER_JOIN
condition|)
block|{
name|rightUnmatchedRows
operator|=
name|calculateUnmatchedRowsForOuter
argument_list|(
name|conf
argument_list|,
name|rowCountParents
operator|.
name|get
argument_list|(
literal|1
argument_list|)
argument_list|,
name|joinKeys
operator|.
name|get
argument_list|(
literal|1
argument_list|)
argument_list|,
name|joinStats
operator|.
name|get
argument_list|(
literal|1
argument_list|)
argument_list|,
name|distinctUnmatched
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|joinCond
operator|.
name|getType
argument_list|()
operator|==
name|JoinDesc
operator|.
name|FULL_OUTER_JOIN
condition|)
block|{
name|leftUnmatchedRows
operator|=
name|calculateUnmatchedRowsForOuter
argument_list|(
name|conf
argument_list|,
name|rowCountParents
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|,
name|joinKeys
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|,
name|joinStats
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|,
name|distinctUnmatched
argument_list|)
expr_stmt|;
name|rightUnmatchedRows
operator|=
name|calculateUnmatchedRowsForOuter
argument_list|(
name|conf
argument_list|,
name|rowCountParents
operator|.
name|get
argument_list|(
literal|1
argument_list|)
argument_list|,
name|joinKeys
operator|.
name|get
argument_list|(
literal|1
argument_list|)
argument_list|,
name|joinStats
operator|.
name|get
argument_list|(
literal|1
argument_list|)
argument_list|,
name|distinctUnmatched
argument_list|)
expr_stmt|;
block|}
block|}
comment|// final row computation will consider join type
name|joinRowCount
operator|=
name|computeFinalRowCount
argument_list|(
name|rowCounts
argument_list|,
name|StatsUtils
operator|.
name|safeAdd
argument_list|(
name|innerJoinRowCount
argument_list|,
name|StatsUtils
operator|.
name|safeAdd
argument_list|(
name|leftUnmatchedRows
argument_list|,
name|rightUnmatchedRows
argument_list|)
argument_list|)
argument_list|,
name|jop
argument_list|)
expr_stmt|;
block|}
comment|// update column statistics
name|updateColStats
argument_list|(
name|conf
argument_list|,
name|stats
argument_list|,
name|leftUnmatchedRows
argument_list|,
name|rightUnmatchedRows
argument_list|,
name|joinRowCount
argument_list|,
name|jop
argument_list|,
name|rowCountParents
argument_list|)
expr_stmt|;
comment|// evaluate filter expression and update statistics
if|if
condition|(
name|joinRowCount
operator|!=
operator|-
literal|1
operator|&&
name|jop
operator|.
name|getConf
argument_list|()
operator|.
name|getNoOuterJoin
argument_list|()
operator|&&
name|jop
operator|.
name|getConf
argument_list|()
operator|.
name|getResidualFilterExprs
argument_list|()
operator|!=
literal|null
operator|&&
operator|!
name|jop
operator|.
name|getConf
argument_list|()
operator|.
name|getResidualFilterExprs
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|ExprNodeDesc
name|pred
decl_stmt|;
if|if
condition|(
name|jop
operator|.
name|getConf
argument_list|()
operator|.
name|getResidualFilterExprs
argument_list|()
operator|.
name|size
argument_list|()
operator|>
literal|1
condition|)
block|{
name|pred
operator|=
operator|new
name|ExprNodeGenericFuncDesc
argument_list|(
name|TypeInfoFactory
operator|.
name|booleanTypeInfo
argument_list|,
name|FunctionRegistry
operator|.
name|getGenericUDFForAnd
argument_list|()
argument_list|,
name|jop
operator|.
name|getConf
argument_list|()
operator|.
name|getResidualFilterExprs
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|pred
operator|=
name|jop
operator|.
name|getConf
argument_list|()
operator|.
name|getResidualFilterExprs
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
comment|// evaluate filter expression and update statistics
name|newNumRows
operator|=
name|evaluateExpression
argument_list|(
name|stats
argument_list|,
name|pred
argument_list|,
name|aspCtx
argument_list|,
name|jop
operator|.
name|getSchema
argument_list|()
operator|.
name|getColumnNames
argument_list|()
argument_list|,
name|jop
argument_list|,
name|stats
operator|.
name|getNumRows
argument_list|()
argument_list|)
expr_stmt|;
comment|// update statistics based on column statistics.
comment|// OR conditions keeps adding the stats independently, this may
comment|// result in number of rows getting more than the input rows in
comment|// which case stats need not be updated
if|if
condition|(
name|newNumRows
operator|<=
name|joinRowCount
condition|)
block|{
name|StatsUtils
operator|.
name|updateStats
argument_list|(
name|stats
argument_list|,
name|newNumRows
argument_list|,
literal|true
argument_list|,
name|jop
argument_list|)
expr_stmt|;
block|}
block|}
name|stats
operator|=
name|applyRuntimeStats
argument_list|(
name|aspCtx
operator|.
name|getParseContext
argument_list|()
operator|.
name|getContext
argument_list|()
argument_list|,
name|stats
argument_list|,
name|jop
argument_list|)
expr_stmt|;
name|jop
operator|.
name|setStatistics
argument_list|(
name|stats
argument_list|)
expr_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"[0] STATS-"
operator|+
name|jop
operator|.
name|toString
argument_list|()
operator|+
literal|": "
operator|+
name|stats
operator|.
name|extendedToString
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// worst case when there are no column statistics
name|float
name|joinFactor
init|=
name|HiveConf
operator|.
name|getFloatVar
argument_list|(
name|conf
argument_list|,
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVE_STATS_JOIN_FACTOR
argument_list|)
decl_stmt|;
name|int
name|numParents
init|=
name|parents
operator|.
name|size
argument_list|()
decl_stmt|;
name|long
name|crossRowCount
init|=
literal|1
decl_stmt|;
name|long
name|crossDataSize
init|=
literal|1
decl_stmt|;
name|long
name|maxRowCount
init|=
literal|0
decl_stmt|;
name|long
name|maxDataSize
init|=
literal|0
decl_stmt|;
name|State
name|statsState
init|=
name|State
operator|.
name|NONE
decl_stmt|;
for|for
control|(
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
name|op
range|:
name|parents
control|)
block|{
name|Statistics
name|ps
init|=
name|op
operator|.
name|getStatistics
argument_list|()
decl_stmt|;
name|statsState
operator|=
name|Statistics
operator|.
name|inferColumnStatsState
argument_list|(
name|statsState
argument_list|,
name|ps
operator|.
name|getBasicStatsState
argument_list|()
argument_list|)
expr_stmt|;
name|long
name|rowCount
init|=
name|ps
operator|.
name|getNumRows
argument_list|()
decl_stmt|;
name|long
name|dataSize
init|=
name|ps
operator|.
name|getDataSize
argument_list|()
decl_stmt|;
comment|// Update cross size
name|long
name|newCrossRowCount
init|=
name|StatsUtils
operator|.
name|safeMult
argument_list|(
name|crossRowCount
argument_list|,
name|rowCount
argument_list|)
decl_stmt|;
name|long
name|newCrossDataSize
init|=
name|StatsUtils
operator|.
name|safeAdd
argument_list|(
name|StatsUtils
operator|.
name|safeMult
argument_list|(
name|crossDataSize
argument_list|,
name|rowCount
argument_list|)
argument_list|,
name|StatsUtils
operator|.
name|safeMult
argument_list|(
name|dataSize
argument_list|,
name|crossRowCount
argument_list|)
argument_list|)
decl_stmt|;
name|crossRowCount
operator|=
name|newCrossRowCount
expr_stmt|;
name|crossDataSize
operator|=
name|newCrossDataSize
expr_stmt|;
comment|// Update largest relation
if|if
condition|(
name|rowCount
operator|>
name|maxRowCount
condition|)
block|{
name|maxRowCount
operator|=
name|rowCount
expr_stmt|;
name|maxDataSize
operator|=
name|dataSize
expr_stmt|;
block|}
block|}
name|long
name|newDataSize
decl_stmt|;
comment|// detect if there are attributes in join key
name|boolean
name|cartesianProduct
init|=
literal|false
decl_stmt|;
if|if
condition|(
name|jop
operator|.
name|getParentOperators
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|instanceof
name|ReduceSinkOperator
condition|)
block|{
name|ReduceSinkOperator
name|rsOp
init|=
operator|(
name|ReduceSinkOperator
operator|)
name|jop
operator|.
name|getParentOperators
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|keyExprs
init|=
name|StatsUtils
operator|.
name|getQualifedReducerKeyNames
argument_list|(
name|rsOp
operator|.
name|getConf
argument_list|()
operator|.
name|getOutputKeyColumnNames
argument_list|()
argument_list|)
decl_stmt|;
name|cartesianProduct
operator|=
name|keyExprs
operator|.
name|size
argument_list|()
operator|==
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|jop
operator|instanceof
name|AbstractMapJoinOperator
condition|)
block|{
name|AbstractMapJoinOperator
argument_list|<
name|?
extends|extends
name|MapJoinDesc
argument_list|>
name|mjop
init|=
operator|(
name|AbstractMapJoinOperator
argument_list|<
name|?
extends|extends
name|MapJoinDesc
argument_list|>
operator|)
name|jop
decl_stmt|;
name|List
argument_list|<
name|ExprNodeDesc
argument_list|>
name|keyExprs
init|=
name|mjop
operator|.
name|getConf
argument_list|()
operator|.
name|getKeys
argument_list|()
operator|.
name|values
argument_list|()
operator|.
name|iterator
argument_list|()
operator|.
name|next
argument_list|()
decl_stmt|;
name|cartesianProduct
operator|=
name|keyExprs
operator|.
name|size
argument_list|()
operator|==
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|cartesianProduct
condition|)
block|{
comment|// Cartesian product
name|newNumRows
operator|=
name|crossRowCount
expr_stmt|;
name|newDataSize
operator|=
name|crossDataSize
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|numParents
operator|>
literal|1
condition|)
block|{
name|newNumRows
operator|=
name|StatsUtils
operator|.
name|safeMult
argument_list|(
name|StatsUtils
operator|.
name|safeMult
argument_list|(
name|maxRowCount
argument_list|,
operator|(
name|numParents
operator|-
literal|1
operator|)
argument_list|)
argument_list|,
name|joinFactor
argument_list|)
expr_stmt|;
name|newDataSize
operator|=
name|StatsUtils
operator|.
name|safeMult
argument_list|(
name|StatsUtils
operator|.
name|safeMult
argument_list|(
name|maxDataSize
argument_list|,
operator|(
name|numParents
operator|-
literal|1
operator|)
argument_list|)
argument_list|,
name|joinFactor
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// MUX operator with 1 parent
name|newNumRows
operator|=
name|StatsUtils
operator|.
name|safeMult
argument_list|(
name|maxRowCount
argument_list|,
name|joinFactor
argument_list|)
expr_stmt|;
name|newDataSize
operator|=
name|StatsUtils
operator|.
name|safeMult
argument_list|(
name|maxDataSize
argument_list|,
name|joinFactor
argument_list|)
expr_stmt|;
block|}
block|}
name|Statistics
name|wcStats
init|=
operator|new
name|Statistics
argument_list|(
name|newNumRows
argument_list|,
name|newDataSize
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|wcStats
operator|.
name|setBasicStatsState
argument_list|(
name|statsState
argument_list|)
expr_stmt|;
comment|// evaluate filter expression and update statistics
if|if
condition|(
name|jop
operator|.
name|getConf
argument_list|()
operator|.
name|getNoOuterJoin
argument_list|()
operator|&&
name|jop
operator|.
name|getConf
argument_list|()
operator|.
name|getResidualFilterExprs
argument_list|()
operator|!=
literal|null
operator|&&
operator|!
name|jop
operator|.
name|getConf
argument_list|()
operator|.
name|getResidualFilterExprs
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|long
name|joinRowCount
init|=
name|newNumRows
decl_stmt|;
name|ExprNodeDesc
name|pred
decl_stmt|;
if|if
condition|(
name|jop
operator|.
name|getConf
argument_list|()
operator|.
name|getResidualFilterExprs
argument_list|()
operator|.
name|size
argument_list|()
operator|>
literal|1
condition|)
block|{
name|pred
operator|=
operator|new
name|ExprNodeGenericFuncDesc
argument_list|(
name|TypeInfoFactory
operator|.
name|booleanTypeInfo
argument_list|,
name|FunctionRegistry
operator|.
name|getGenericUDFForAnd
argument_list|()
argument_list|,
name|jop
operator|.
name|getConf
argument_list|()
operator|.
name|getResidualFilterExprs
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|pred
operator|=
name|jop
operator|.
name|getConf
argument_list|()
operator|.
name|getResidualFilterExprs
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
comment|// evaluate filter expression and update statistics
name|newNumRows
operator|=
name|evaluateExpression
argument_list|(
name|wcStats
argument_list|,
name|pred
argument_list|,
name|aspCtx
argument_list|,
name|jop
operator|.
name|getSchema
argument_list|()
operator|.
name|getColumnNames
argument_list|()
argument_list|,
name|jop
argument_list|,
name|wcStats
operator|.
name|getNumRows
argument_list|()
argument_list|)
expr_stmt|;
comment|// update only the basic statistics in the absence of column statistics
if|if
condition|(
name|newNumRows
operator|<=
name|joinRowCount
condition|)
block|{
name|StatsUtils
operator|.
name|updateStats
argument_list|(
name|wcStats
argument_list|,
name|newNumRows
argument_list|,
literal|false
argument_list|,
name|jop
argument_list|)
expr_stmt|;
block|}
block|}
name|wcStats
operator|=
name|applyRuntimeStats
argument_list|(
name|aspCtx
operator|.
name|getParseContext
argument_list|()
operator|.
name|getContext
argument_list|()
argument_list|,
name|wcStats
argument_list|,
name|jop
argument_list|)
expr_stmt|;
name|jop
operator|.
name|setStatistics
argument_list|(
name|wcStats
argument_list|)
expr_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"[1] STATS-"
operator|+
name|jop
operator|.
name|toString
argument_list|()
operator|+
literal|": "
operator|+
name|wcStats
operator|.
name|extendedToString
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
return|return
literal|null
return|;
block|}
specifier|private
name|long
name|calculateUnmatchedRowsForOuter
parameter_list|(
name|HiveConf
name|conf
parameter_list|,
name|long
name|inputRowCount
parameter_list|,
name|List
argument_list|<
name|String
argument_list|>
name|joinKeys
parameter_list|,
name|Statistics
name|statistics
parameter_list|,
name|long
name|distinctUnmatched
parameter_list|)
block|{
comment|// Extract the ndv from each of the columns involved in the join
name|List
argument_list|<
name|Long
argument_list|>
name|distinctVals
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|String
name|col
range|:
name|joinKeys
control|)
block|{
name|ColStatistics
name|cs
init|=
name|statistics
operator|.
name|getColumnStatisticsFromColName
argument_list|(
name|col
argument_list|)
decl_stmt|;
if|if
condition|(
name|cs
operator|!=
literal|null
condition|)
block|{
name|distinctVals
operator|.
name|add
argument_list|(
name|cs
operator|.
name|getCountDistint
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Compute the number of distinct values based on configuration property
name|long
name|distinctVal
decl_stmt|;
if|if
condition|(
name|distinctVals
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|distinctVal
operator|=
literal|2L
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|joinKeys
operator|.
name|size
argument_list|()
operator|>
literal|1
operator|&&
name|conf
operator|.
name|getBoolVar
argument_list|(
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVE_STATS_CORRELATED_MULTI_KEY_JOINS
argument_list|)
condition|)
block|{
name|distinctVal
operator|=
name|Collections
operator|.
name|max
argument_list|(
name|distinctVals
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|distinctVal
operator|=
name|StatsUtils
operator|.
name|addWithExpDecay
argument_list|(
name|distinctVals
argument_list|)
expr_stmt|;
block|}
block|}
comment|// If we have a greater number of unmatched values than number of distinct values,
comment|// we just return the number of rows in the input as we can assume there are no
comment|// matches
if|if
condition|(
name|distinctUnmatched
operator|>=
name|distinctVal
condition|)
block|{
return|return
name|inputRowCount
return|;
block|}
comment|// Otherwise, divide the number of input rows by the number of distinct values
comment|// and divide by the number of distinct values unmatched
return|return
name|StatsUtils
operator|.
name|safeMult
argument_list|(
name|inputRowCount
operator|/
name|distinctVal
argument_list|,
name|distinctUnmatched
argument_list|)
return|;
block|}
specifier|private
name|long
name|inferPKFKRelationship
parameter_list|(
name|int
name|numAttr
parameter_list|,
name|List
argument_list|<
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
argument_list|>
name|parents
parameter_list|,
name|CommonJoinOperator
argument_list|<
name|?
extends|extends
name|JoinDesc
argument_list|>
name|jop
parameter_list|)
block|{
name|long
name|newNumRows
init|=
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|numAttr
operator|!=
literal|1
condition|)
block|{
return|return
name|newNumRows
return|;
block|}
comment|// If numAttr is 1, this means we join on one single key column.
name|Map
argument_list|<
name|Integer
argument_list|,
name|ColStatistics
argument_list|>
name|parentsWithPK
init|=
name|getPrimaryKeyCandidates
argument_list|(
name|parents
argument_list|)
decl_stmt|;
comment|// We only allow one single PK.
if|if
condition|(
name|parentsWithPK
operator|.
name|size
argument_list|()
operator|!=
literal|1
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"STATS-"
operator|+
name|jop
operator|.
name|toString
argument_list|()
operator|+
literal|": detects none/multiple PK parents."
argument_list|)
expr_stmt|;
return|return
name|newNumRows
return|;
block|}
name|Integer
name|pkPos
init|=
name|parentsWithPK
operator|.
name|keySet
argument_list|()
operator|.
name|iterator
argument_list|()
operator|.
name|next
argument_list|()
decl_stmt|;
name|ColStatistics
name|csPK
init|=
name|parentsWithPK
operator|.
name|values
argument_list|()
operator|.
name|iterator
argument_list|()
operator|.
name|next
argument_list|()
decl_stmt|;
comment|// infer foreign key candidates positions
name|Map
argument_list|<
name|Integer
argument_list|,
name|ColStatistics
argument_list|>
name|csFKs
init|=
name|getForeignKeyCandidates
argument_list|(
name|parents
argument_list|,
name|csPK
argument_list|)
decl_stmt|;
comment|// we allow multiple foreign keys (snowflake schema)
comment|// csfKs.size() + 1 == parents.size() means we have a single PK and all
comment|// the rest ops are FKs.
if|if
condition|(
name|csFKs
operator|.
name|size
argument_list|()
operator|+
literal|1
operator|==
name|parents
operator|.
name|size
argument_list|()
condition|)
block|{
name|newNumRows
operator|=
name|getCardinality
argument_list|(
name|parents
argument_list|,
name|pkPos
argument_list|,
name|csPK
argument_list|,
name|csFKs
argument_list|,
name|jop
argument_list|)
expr_stmt|;
comment|// some debug information
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|List
argument_list|<
name|String
argument_list|>
name|parentIds
init|=
name|Lists
operator|.
name|newArrayList
argument_list|()
decl_stmt|;
comment|// print primary key containing parents
for|for
control|(
name|Integer
name|i
range|:
name|parentsWithPK
operator|.
name|keySet
argument_list|()
control|)
block|{
name|parentIds
operator|.
name|add
argument_list|(
name|parents
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|LOG
operator|.
name|debug
argument_list|(
literal|"STATS-"
operator|+
name|jop
operator|.
name|toString
argument_list|()
operator|+
literal|": PK parent id(s) - "
operator|+
name|parentIds
argument_list|)
expr_stmt|;
name|parentIds
operator|.
name|clear
argument_list|()
expr_stmt|;
comment|// print foreign key containing parents
for|for
control|(
name|Integer
name|i
range|:
name|csFKs
operator|.
name|keySet
argument_list|()
control|)
block|{
name|parentIds
operator|.
name|add
argument_list|(
name|parents
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|LOG
operator|.
name|debug
argument_list|(
literal|"STATS-"
operator|+
name|jop
operator|.
name|toString
argument_list|()
operator|+
literal|": FK parent id(s) - "
operator|+
name|parentIds
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|newNumRows
return|;
block|}
comment|/**      * Get cardinality of reduce sink operators.      * @param csPK - ColStatistics for a single primary key      * @param csFKs - ColStatistics for multiple foreign keys      */
specifier|private
name|long
name|getCardinality
parameter_list|(
name|List
argument_list|<
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
argument_list|>
name|ops
parameter_list|,
name|Integer
name|pkPos
parameter_list|,
name|ColStatistics
name|csPK
parameter_list|,
name|Map
argument_list|<
name|Integer
argument_list|,
name|ColStatistics
argument_list|>
name|csFKs
parameter_list|,
name|CommonJoinOperator
argument_list|<
name|?
extends|extends
name|JoinDesc
argument_list|>
name|jop
parameter_list|)
block|{
name|double
name|pkfkSelectivity
init|=
name|Double
operator|.
name|MAX_VALUE
decl_stmt|;
name|int
name|fkInd
init|=
operator|-
literal|1
decl_stmt|;
comment|// 1. We iterate through all the operators that have candidate FKs and
comment|// choose the FK that has the minimum selectivity. We assume that PK and this FK
comment|// have the PK-FK relationship. This is heuristic and can be
comment|// improved later.
for|for
control|(
name|Entry
argument_list|<
name|Integer
argument_list|,
name|ColStatistics
argument_list|>
name|entry
range|:
name|csFKs
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|int
name|pos
init|=
name|entry
operator|.
name|getKey
argument_list|()
decl_stmt|;
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
name|opWithPK
init|=
name|ops
operator|.
name|get
argument_list|(
name|pkPos
argument_list|)
decl_stmt|;
name|double
name|selectivity
init|=
name|getSelectivitySimpleTree
argument_list|(
name|opWithPK
argument_list|)
decl_stmt|;
name|double
name|selectivityAdjustment
init|=
name|StatsUtils
operator|.
name|getScaledSelectivity
argument_list|(
name|csPK
argument_list|,
name|entry
operator|.
name|getValue
argument_list|()
argument_list|)
decl_stmt|;
name|selectivity
operator|=
name|selectivityAdjustment
operator|*
name|selectivity
operator|>
literal|1
condition|?
name|selectivity
else|:
name|selectivityAdjustment
operator|*
name|selectivity
expr_stmt|;
if|if
condition|(
name|selectivity
operator|<
name|pkfkSelectivity
condition|)
block|{
name|pkfkSelectivity
operator|=
name|selectivity
expr_stmt|;
name|fkInd
operator|=
name|pos
expr_stmt|;
block|}
block|}
name|long
name|newrows
init|=
literal|1
decl_stmt|;
name|List
argument_list|<
name|Long
argument_list|>
name|rowCounts
init|=
name|Lists
operator|.
name|newArrayList
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|Long
argument_list|>
name|distinctVals
init|=
name|Lists
operator|.
name|newArrayList
argument_list|()
decl_stmt|;
comment|// 2. We then iterate through all the operators that have candidate FKs again.
comment|// We assume the PK is first joining with the FK that we just selected.
comment|// And we apply the PK-FK relationship when we compute the newrows and ndv.
comment|// After that, we join the result with all the other FKs.
comment|// We do not assume the PK-FK relationship anymore and just compute the
comment|// row count using the classic formula.
for|for
control|(
name|Entry
argument_list|<
name|Integer
argument_list|,
name|ColStatistics
argument_list|>
name|entry
range|:
name|csFKs
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|int
name|pos
init|=
name|entry
operator|.
name|getKey
argument_list|()
decl_stmt|;
name|ColStatistics
name|csFK
init|=
name|entry
operator|.
name|getValue
argument_list|()
decl_stmt|;
name|ReduceSinkOperator
name|parent
init|=
operator|(
name|ReduceSinkOperator
operator|)
name|jop
operator|.
name|getParentOperators
argument_list|()
operator|.
name|get
argument_list|(
name|pos
argument_list|)
decl_stmt|;
name|Statistics
name|parentStats
init|=
name|parent
operator|.
name|getStatistics
argument_list|()
decl_stmt|;
if|if
condition|(
name|fkInd
operator|==
name|pos
condition|)
block|{
comment|// 2.1 This is the new number of rows after PK is joining with FK
name|newrows
operator|=
operator|(
name|long
operator|)
name|Math
operator|.
name|ceil
argument_list|(
name|parentStats
operator|.
name|getNumRows
argument_list|()
operator|*
name|pkfkSelectivity
argument_list|)
expr_stmt|;
name|rowCounts
operator|.
name|add
argument_list|(
name|newrows
argument_list|)
expr_stmt|;
comment|// 2.1 The ndv is the minimum of the PK and the FK.
name|distinctVals
operator|.
name|add
argument_list|(
name|Math
operator|.
name|min
argument_list|(
name|csFK
operator|.
name|getCountDistint
argument_list|()
argument_list|,
name|csPK
operator|.
name|getCountDistint
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// 2.2 All the other FKs.
name|rowCounts
operator|.
name|add
argument_list|(
name|parentStats
operator|.
name|getNumRows
argument_list|()
argument_list|)
expr_stmt|;
name|distinctVals
operator|.
name|add
argument_list|(
name|csFK
operator|.
name|getCountDistint
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
name|long
name|newNumRows
decl_stmt|;
if|if
condition|(
name|csFKs
operator|.
name|size
argument_list|()
operator|==
literal|1
condition|)
block|{
comment|// there is only one FK
name|newNumRows
operator|=
name|newrows
expr_stmt|;
block|}
else|else
block|{
comment|// there is more than one FK
name|newNumRows
operator|=
name|this
operator|.
name|computeRowCountAssumingInnerJoin
argument_list|(
name|rowCounts
argument_list|,
name|getDenominator
argument_list|(
name|distinctVals
argument_list|)
argument_list|,
name|jop
argument_list|)
expr_stmt|;
name|newNumRows
operator|=
name|this
operator|.
name|computeFinalRowCount
argument_list|(
name|rowCounts
argument_list|,
name|newNumRows
argument_list|,
name|jop
argument_list|)
expr_stmt|;
block|}
return|return
name|newNumRows
return|;
block|}
specifier|private
name|float
name|getSelectivitySimpleTree
parameter_list|(
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
name|op
parameter_list|)
block|{
name|TableScanOperator
name|tsOp
init|=
name|OperatorUtils
operator|.
name|findSingleOperatorUpstream
argument_list|(
name|op
argument_list|,
name|TableScanOperator
operator|.
name|class
argument_list|)
decl_stmt|;
if|if
condition|(
name|tsOp
operator|==
literal|null
condition|)
block|{
comment|// complex tree with multiple parents
return|return
name|getSelectivityComplexTree
argument_list|(
name|op
argument_list|)
return|;
block|}
else|else
block|{
comment|// simple tree with single parent
name|long
name|inputRow
init|=
name|tsOp
operator|.
name|getStatistics
argument_list|()
operator|.
name|getNumRows
argument_list|()
decl_stmt|;
name|long
name|outputRow
init|=
name|op
operator|.
name|getStatistics
argument_list|()
operator|.
name|getNumRows
argument_list|()
decl_stmt|;
return|return
operator|(
name|float
operator|)
name|outputRow
operator|/
operator|(
name|float
operator|)
name|inputRow
return|;
block|}
block|}
specifier|private
name|float
name|getSelectivityComplexTree
parameter_list|(
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
name|op
parameter_list|)
block|{
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
name|multiParentOp
init|=
literal|null
decl_stmt|;
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
name|currentOp
init|=
name|op
decl_stmt|;
comment|// TS-1      TS-2
comment|//  |          |
comment|// RS-1      RS-2
comment|//    \      /
comment|//      JOIN
comment|//        |
comment|//       FIL
comment|//        |
comment|//       RS-3
comment|//
comment|// For the above complex operator tree,
comment|// selectivity(JOIN) = selectivity(RS-1) * selectivity(RS-2) and
comment|// selectivity(RS-3) = numRows(RS-3)/numRows(JOIN) * selectivity(JOIN)
while|while
condition|(
name|multiParentOp
operator|==
literal|null
condition|)
block|{
if|if
condition|(
name|op
operator|.
name|getParentOperators
argument_list|()
operator|.
name|size
argument_list|()
operator|>
literal|1
condition|)
block|{
name|multiParentOp
operator|=
name|op
expr_stmt|;
block|}
else|else
block|{
name|op
operator|=
name|op
operator|.
name|getParentOperators
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
comment|// No need for overflow checks, assume selectivity is always<= 1.0
name|float
name|selMultiParent
init|=
literal|1.0f
decl_stmt|;
name|boolean
name|isSelComputed
init|=
literal|false
decl_stmt|;
comment|// if it is two way left outer or right outer join take selectivity only for
comment|// corresponding branch since only that branch will factor is the reduction
if|if
condition|(
name|multiParentOp
operator|instanceof
name|JoinOperator
condition|)
block|{
name|JoinOperator
name|jop
init|=
operator|(
operator|(
name|JoinOperator
operator|)
name|multiParentOp
operator|)
decl_stmt|;
comment|// check for two way join
if|if
condition|(
name|jop
operator|.
name|getConf
argument_list|()
operator|.
name|getConds
argument_list|()
operator|.
name|length
operator|==
literal|1
condition|)
block|{
name|isSelComputed
operator|=
literal|true
expr_stmt|;
name|int
name|type
init|=
name|jop
operator|.
name|getConf
argument_list|()
operator|.
name|getCondsList
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|getType
argument_list|()
decl_stmt|;
if|if
condition|(
name|jop
operator|.
name|getConf
argument_list|()
operator|.
name|getJoinKeys
argument_list|()
index|[
literal|0
index|]
operator|.
name|length
operator|==
literal|0
operator|||
name|type
operator|==
name|JoinDesc
operator|.
name|FULL_OUTER_JOIN
condition|)
block|{
comment|// This is just a cartesian product or a full outer join, we will take the max
name|float
name|selMultiParentLeft
init|=
name|getSelectivitySimpleTree
argument_list|(
name|multiParentOp
operator|.
name|getParentOperators
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|float
name|selMultiParentRight
init|=
name|getSelectivitySimpleTree
argument_list|(
name|multiParentOp
operator|.
name|getParentOperators
argument_list|()
operator|.
name|get
argument_list|(
literal|1
argument_list|)
argument_list|)
decl_stmt|;
name|selMultiParent
operator|=
name|Math
operator|.
name|max
argument_list|(
name|selMultiParentLeft
argument_list|,
name|selMultiParentRight
argument_list|)
expr_stmt|;
block|}
else|else
block|{
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|JoinDesc
operator|.
name|LEFT_OUTER_JOIN
case|:
name|selMultiParent
operator|=
name|getSelectivitySimpleTree
argument_list|(
name|multiParentOp
operator|.
name|getParentOperators
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|JoinDesc
operator|.
name|RIGHT_OUTER_JOIN
case|:
name|selMultiParent
operator|=
name|getSelectivitySimpleTree
argument_list|(
name|multiParentOp
operator|.
name|getParentOperators
argument_list|()
operator|.
name|get
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|// for rest of the join type we will take min of the reduction.
name|float
name|selMultiParentLeft
init|=
name|getSelectivitySimpleTree
argument_list|(
name|multiParentOp
operator|.
name|getParentOperators
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|float
name|selMultiParentRight
init|=
name|getSelectivitySimpleTree
argument_list|(
name|multiParentOp
operator|.
name|getParentOperators
argument_list|()
operator|.
name|get
argument_list|(
literal|1
argument_list|)
argument_list|)
decl_stmt|;
name|selMultiParent
operator|=
name|Math
operator|.
name|min
argument_list|(
name|selMultiParentLeft
argument_list|,
name|selMultiParentRight
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
if|if
condition|(
operator|!
name|isSelComputed
condition|)
block|{
for|for
control|(
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
name|parent
range|:
name|multiParentOp
operator|.
name|getParentOperators
argument_list|()
control|)
block|{
comment|// In the above example, TS-1 -> RS-1 and TS-2 -> RS-2 are simple trees
name|selMultiParent
operator|*=
name|getSelectivitySimpleTree
argument_list|(
name|parent
argument_list|)
expr_stmt|;
block|}
block|}
name|float
name|selCurrOp
init|=
operator|(
operator|(
name|float
operator|)
name|currentOp
operator|.
name|getStatistics
argument_list|()
operator|.
name|getNumRows
argument_list|()
operator|/
operator|(
name|float
operator|)
name|multiParentOp
operator|.
name|getStatistics
argument_list|()
operator|.
name|getNumRows
argument_list|()
operator|)
operator|*
name|selMultiParent
decl_stmt|;
return|return
name|selCurrOp
return|;
block|}
comment|/**      * Returns the index of parents whose join key column statistics ranges are within the specified      * primary key range (inferred as foreign keys).      * @param ops - operators      * @param csPK - column statistics of primary key      * @return - a map which contains position ids and the corresponding column statistics      */
specifier|private
name|Map
argument_list|<
name|Integer
argument_list|,
name|ColStatistics
argument_list|>
name|getForeignKeyCandidates
parameter_list|(
name|List
argument_list|<
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
argument_list|>
name|ops
parameter_list|,
name|ColStatistics
name|csPK
parameter_list|)
block|{
name|Map
argument_list|<
name|Integer
argument_list|,
name|ColStatistics
argument_list|>
name|result
init|=
operator|new
name|HashMap
argument_list|<
name|Integer
argument_list|,
name|ColStatistics
argument_list|>
argument_list|()
decl_stmt|;
if|if
condition|(
name|csPK
operator|==
literal|null
operator|||
name|ops
operator|==
literal|null
condition|)
block|{
return|return
name|result
return|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|ops
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
name|op
init|=
name|ops
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|op
operator|!=
literal|null
operator|&&
name|op
operator|instanceof
name|ReduceSinkOperator
condition|)
block|{
name|ReduceSinkOperator
name|rsOp
init|=
operator|(
name|ReduceSinkOperator
operator|)
name|op
decl_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|keys
init|=
name|StatsUtils
operator|.
name|getQualifedReducerKeyNames
argument_list|(
name|rsOp
operator|.
name|getConf
argument_list|()
operator|.
name|getOutputKeyColumnNames
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|keys
operator|.
name|size
argument_list|()
operator|==
literal|1
condition|)
block|{
name|String
name|joinCol
init|=
name|keys
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|rsOp
operator|.
name|getStatistics
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|ColStatistics
name|cs
init|=
name|rsOp
operator|.
name|getStatistics
argument_list|()
operator|.
name|getColumnStatisticsFromColName
argument_list|(
name|joinCol
argument_list|)
decl_stmt|;
if|if
condition|(
name|cs
operator|!=
literal|null
operator|&&
operator|!
name|cs
operator|.
name|isPrimaryKey
argument_list|()
condition|)
block|{
if|if
condition|(
name|StatsUtils
operator|.
name|inferForeignKey
argument_list|(
name|csPK
argument_list|,
name|cs
argument_list|)
condition|)
block|{
name|result
operator|.
name|put
argument_list|(
name|i
argument_list|,
name|cs
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
block|}
return|return
name|result
return|;
block|}
comment|/**      * Returns the index of parents whose join key columns are infer as primary keys      * @param ops - operators      * @return - list of primary key containing parent ids      */
specifier|private
name|Map
argument_list|<
name|Integer
argument_list|,
name|ColStatistics
argument_list|>
name|getPrimaryKeyCandidates
parameter_list|(
name|List
argument_list|<
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
argument_list|>
name|ops
parameter_list|)
block|{
name|Map
argument_list|<
name|Integer
argument_list|,
name|ColStatistics
argument_list|>
name|result
init|=
operator|new
name|HashMap
argument_list|<
name|Integer
argument_list|,
name|ColStatistics
argument_list|>
argument_list|()
decl_stmt|;
if|if
condition|(
name|ops
operator|!=
literal|null
operator|&&
operator|!
name|ops
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|ops
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
name|op
init|=
name|ops
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|op
operator|instanceof
name|ReduceSinkOperator
condition|)
block|{
name|ReduceSinkOperator
name|rsOp
init|=
operator|(
name|ReduceSinkOperator
operator|)
name|op
decl_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|keys
init|=
name|StatsUtils
operator|.
name|getQualifedReducerKeyNames
argument_list|(
name|rsOp
operator|.
name|getConf
argument_list|()
operator|.
name|getOutputKeyColumnNames
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|keys
operator|.
name|size
argument_list|()
operator|==
literal|1
condition|)
block|{
name|String
name|joinCol
init|=
name|keys
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|rsOp
operator|.
name|getStatistics
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|ColStatistics
name|cs
init|=
name|rsOp
operator|.
name|getStatistics
argument_list|()
operator|.
name|getColumnStatisticsFromColName
argument_list|(
name|joinCol
argument_list|)
decl_stmt|;
if|if
condition|(
name|cs
operator|!=
literal|null
operator|&&
name|cs
operator|.
name|isPrimaryKey
argument_list|()
condition|)
block|{
name|result
operator|.
name|put
argument_list|(
name|i
argument_list|,
name|cs
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
block|}
return|return
name|result
return|;
block|}
specifier|private
name|boolean
name|isJoinKey
parameter_list|(
specifier|final
name|String
name|columnName
parameter_list|,
specifier|final
name|ExprNodeDesc
index|[]
index|[]
name|joinKeys
parameter_list|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|joinKeys
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|ExprNodeDesc
name|expr
range|:
name|Arrays
operator|.
name|asList
argument_list|(
name|joinKeys
index|[
name|i
index|]
argument_list|)
control|)
block|{
if|if
condition|(
name|expr
operator|instanceof
name|ExprNodeColumnDesc
condition|)
block|{
if|if
condition|(
operator|(
operator|(
name|ExprNodeColumnDesc
operator|)
name|expr
operator|)
operator|.
name|getColumn
argument_list|()
operator|.
name|equals
argument_list|(
name|columnName
argument_list|)
condition|)
block|{
return|return
literal|true
return|;
block|}
block|}
block|}
block|}
return|return
literal|false
return|;
block|}
specifier|private
name|void
name|updateNumNulls
parameter_list|(
name|ColStatistics
name|colStats
parameter_list|,
name|long
name|leftUnmatchedRows
parameter_list|,
name|long
name|rightUnmatchedRows
parameter_list|,
name|long
name|newNumRows
parameter_list|,
name|long
name|pos
parameter_list|,
name|CommonJoinOperator
argument_list|<
name|?
extends|extends
name|JoinDesc
argument_list|>
name|jop
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|jop
operator|.
name|getConf
argument_list|()
operator|.
name|getConds
argument_list|()
operator|.
name|length
operator|==
literal|1
operator|)
condition|)
block|{
comment|// TODO: handle multi joins
return|return;
block|}
name|long
name|oldNumNulls
init|=
name|colStats
operator|.
name|getNumNulls
argument_list|()
decl_stmt|;
name|long
name|newNumNulls
init|=
name|Math
operator|.
name|min
argument_list|(
name|newNumRows
argument_list|,
name|oldNumNulls
argument_list|)
decl_stmt|;
name|JoinCondDesc
name|joinCond
init|=
name|jop
operator|.
name|getConf
argument_list|()
operator|.
name|getConds
argument_list|()
index|[
literal|0
index|]
decl_stmt|;
switch|switch
condition|(
name|joinCond
operator|.
name|getType
argument_list|()
condition|)
block|{
case|case
name|JoinDesc
operator|.
name|LEFT_OUTER_JOIN
case|:
if|if
condition|(
name|pos
operator|==
name|joinCond
operator|.
name|getRight
argument_list|()
condition|)
block|{
if|if
condition|(
name|isJoinKey
argument_list|(
name|colStats
operator|.
name|getColumnName
argument_list|()
argument_list|,
name|jop
operator|.
name|getConf
argument_list|()
operator|.
name|getJoinKeys
argument_list|()
argument_list|)
condition|)
block|{
name|newNumNulls
operator|=
name|Math
operator|.
name|min
argument_list|(
name|newNumRows
argument_list|,
name|leftUnmatchedRows
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|newNumNulls
operator|=
name|Math
operator|.
name|min
argument_list|(
name|newNumRows
argument_list|,
name|oldNumNulls
operator|+
name|leftUnmatchedRows
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|JoinDesc
operator|.
name|RIGHT_OUTER_JOIN
case|:
if|if
condition|(
name|pos
operator|==
name|joinCond
operator|.
name|getLeft
argument_list|()
condition|)
block|{
if|if
condition|(
name|isJoinKey
argument_list|(
name|colStats
operator|.
name|getColumnName
argument_list|()
argument_list|,
name|jop
operator|.
name|getConf
argument_list|()
operator|.
name|getJoinKeys
argument_list|()
argument_list|)
condition|)
block|{
name|newNumNulls
operator|=
name|Math
operator|.
name|min
argument_list|(
name|newNumRows
argument_list|,
name|rightUnmatchedRows
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|newNumNulls
operator|=
name|Math
operator|.
name|min
argument_list|(
name|newNumRows
argument_list|,
name|oldNumNulls
operator|+
name|rightUnmatchedRows
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|JoinDesc
operator|.
name|FULL_OUTER_JOIN
case|:
if|if
condition|(
name|isJoinKey
argument_list|(
name|colStats
operator|.
name|getColumnName
argument_list|()
argument_list|,
name|jop
operator|.
name|getConf
argument_list|()
operator|.
name|getJoinKeys
argument_list|()
argument_list|)
condition|)
block|{
name|newNumNulls
operator|=
name|Math
operator|.
name|min
argument_list|(
name|newNumRows
argument_list|,
name|leftUnmatchedRows
operator|+
name|rightUnmatchedRows
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|newNumNulls
operator|=
name|Math
operator|.
name|min
argument_list|(
name|newNumRows
argument_list|,
name|oldNumNulls
operator|+
name|leftUnmatchedRows
operator|+
name|rightUnmatchedRows
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|JoinDesc
operator|.
name|INNER_JOIN
case|:
case|case
name|JoinDesc
operator|.
name|UNIQUE_JOIN
case|:
case|case
name|JoinDesc
operator|.
name|LEFT_SEMI_JOIN
case|:
break|break;
block|}
name|colStats
operator|.
name|setNumNulls
argument_list|(
name|newNumNulls
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|updateColStats
parameter_list|(
name|HiveConf
name|conf
parameter_list|,
name|Statistics
name|stats
parameter_list|,
name|long
name|leftUnmatchedRows
parameter_list|,
name|long
name|rightUnmatchedRows
parameter_list|,
name|long
name|newNumRows
parameter_list|,
name|CommonJoinOperator
argument_list|<
name|?
extends|extends
name|JoinDesc
argument_list|>
name|jop
parameter_list|,
name|Map
argument_list|<
name|Integer
argument_list|,
name|Long
argument_list|>
name|rowCountParents
parameter_list|)
block|{
if|if
condition|(
name|newNumRows
operator|<
literal|0
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"STATS-"
operator|+
name|jop
operator|.
name|toString
argument_list|()
operator|+
literal|": Overflow in number of rows. "
operator|+
name|newNumRows
operator|+
literal|" rows will be set to Long.MAX_VALUE"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|newNumRows
operator|==
literal|0
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"STATS-"
operator|+
name|jop
operator|.
name|toString
argument_list|()
operator|+
literal|": Equals 0 in number of rows. "
operator|+
name|newNumRows
operator|+
literal|" rows will be set to 1"
argument_list|)
expr_stmt|;
name|newNumRows
operator|=
literal|1
expr_stmt|;
block|}
name|newNumRows
operator|=
name|StatsUtils
operator|.
name|getMaxIfOverflow
argument_list|(
name|newNumRows
argument_list|)
expr_stmt|;
name|stats
operator|.
name|setNumRows
argument_list|(
name|newNumRows
argument_list|)
expr_stmt|;
comment|// scale down/up the column statistics based on the changes in number of
comment|// rows from each parent. For ex: If there are 2 parents for JOIN operator
comment|// with 1st parent having 200 rows and 2nd parent having 2000 rows. Now if
comment|// the new number of rows after applying join rule is 10, then the column
comment|// stats for columns from 1st parent should be scaled down by 200/10 = 20x
comment|// and stats for columns from 2nd parent should be scaled down by 200x
name|List
argument_list|<
name|ColStatistics
argument_list|>
name|colStats
init|=
name|stats
operator|.
name|getColumnStats
argument_list|()
decl_stmt|;
name|Set
argument_list|<
name|String
argument_list|>
name|colNameStatsAvailable
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|ColStatistics
name|cs
range|:
name|colStats
control|)
block|{
name|colNameStatsAvailable
operator|.
name|add
argument_list|(
name|cs
operator|.
name|getColumnName
argument_list|()
argument_list|)
expr_stmt|;
name|int
name|pos
init|=
name|jop
operator|.
name|getConf
argument_list|()
operator|.
name|getReversedExprs
argument_list|()
operator|.
name|get
argument_list|(
name|cs
operator|.
name|getColumnName
argument_list|()
argument_list|)
decl_stmt|;
name|long
name|oldRowCount
init|=
name|rowCountParents
operator|.
name|get
argument_list|(
name|pos
argument_list|)
decl_stmt|;
name|double
name|ratio
init|=
operator|(
name|double
operator|)
name|newNumRows
operator|/
operator|(
name|double
operator|)
name|oldRowCount
decl_stmt|;
name|long
name|oldDV
init|=
name|cs
operator|.
name|getCountDistint
argument_list|()
decl_stmt|;
name|long
name|newDV
init|=
name|oldDV
decl_stmt|;
comment|// if ratio is greater than 1, then number of rows increases. This can happen
comment|// when some operators like GROUPBY duplicates the input rows in which case
comment|// number of distincts should not change. Update the distinct count only when
comment|// the output number of rows is less than input number of rows.
if|if
condition|(
name|ratio
operator|<=
literal|1.0
condition|)
block|{
name|newDV
operator|=
operator|(
name|long
operator|)
name|Math
operator|.
name|ceil
argument_list|(
name|ratio
operator|*
name|oldDV
argument_list|)
expr_stmt|;
block|}
name|cs
operator|.
name|setCountDistint
argument_list|(
name|newDV
argument_list|)
expr_stmt|;
name|updateNumNulls
argument_list|(
name|cs
argument_list|,
name|leftUnmatchedRows
argument_list|,
name|rightUnmatchedRows
argument_list|,
name|newNumRows
argument_list|,
name|pos
argument_list|,
name|jop
argument_list|)
expr_stmt|;
block|}
name|stats
operator|.
name|setColumnStats
argument_list|(
name|colStats
argument_list|)
expr_stmt|;
name|long
name|newDataSize
init|=
name|StatsUtils
operator|.
name|getDataSizeFromColumnStats
argument_list|(
name|newNumRows
argument_list|,
name|colStats
argument_list|)
decl_stmt|;
comment|// Add default size for columns for which stats were not available
name|List
argument_list|<
name|String
argument_list|>
name|neededColumns
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|String
name|colName
range|:
name|jop
operator|.
name|getSchema
argument_list|()
operator|.
name|getColumnNames
argument_list|()
control|)
block|{
if|if
condition|(
operator|!
name|colNameStatsAvailable
operator|.
name|contains
argument_list|(
name|colName
argument_list|)
condition|)
block|{
name|neededColumns
operator|.
name|add
argument_list|(
name|colName
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|neededColumns
operator|.
name|size
argument_list|()
operator|!=
literal|0
condition|)
block|{
name|int
name|restColumnsDefaultSize
init|=
name|StatsUtils
operator|.
name|estimateRowSizeFromSchema
argument_list|(
name|conf
argument_list|,
name|jop
operator|.
name|getSchema
argument_list|()
operator|.
name|getSignature
argument_list|()
argument_list|,
name|neededColumns
argument_list|)
decl_stmt|;
name|newDataSize
operator|=
name|StatsUtils
operator|.
name|safeAdd
argument_list|(
name|newDataSize
argument_list|,
name|StatsUtils
operator|.
name|safeMult
argument_list|(
name|restColumnsDefaultSize
argument_list|,
name|newNumRows
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|stats
operator|.
name|setDataSize
argument_list|(
name|StatsUtils
operator|.
name|getMaxIfOverflow
argument_list|(
name|newDataSize
argument_list|)
argument_list|)
expr_stmt|;
name|stats
operator|.
name|setBasicStatsState
argument_list|(
name|State
operator|.
name|COMPLETE
argument_list|)
expr_stmt|;
block|}
specifier|private
name|long
name|computeFinalRowCount
parameter_list|(
name|List
argument_list|<
name|Long
argument_list|>
name|rowCountParents
parameter_list|,
name|long
name|interimRowCount
parameter_list|,
name|CommonJoinOperator
argument_list|<
name|?
extends|extends
name|JoinDesc
argument_list|>
name|join
parameter_list|)
block|{
name|long
name|result
init|=
name|interimRowCount
decl_stmt|;
if|if
condition|(
name|join
operator|.
name|getConf
argument_list|()
operator|.
name|getConds
argument_list|()
operator|.
name|length
operator|==
literal|1
condition|)
block|{
name|JoinCondDesc
name|joinCond
init|=
name|join
operator|.
name|getConf
argument_list|()
operator|.
name|getConds
argument_list|()
index|[
literal|0
index|]
decl_stmt|;
switch|switch
condition|(
name|joinCond
operator|.
name|getType
argument_list|()
condition|)
block|{
case|case
name|JoinDesc
operator|.
name|INNER_JOIN
case|:
comment|// only dealing with special join types here.
break|break;
case|case
name|JoinDesc
operator|.
name|LEFT_OUTER_JOIN
case|:
comment|// all rows from left side will be present in resultset
name|result
operator|=
name|Math
operator|.
name|max
argument_list|(
name|rowCountParents
operator|.
name|get
argument_list|(
name|joinCond
operator|.
name|getLeft
argument_list|()
argument_list|)
argument_list|,
name|result
argument_list|)
expr_stmt|;
break|break;
case|case
name|JoinDesc
operator|.
name|RIGHT_OUTER_JOIN
case|:
comment|// all rows from right side will be present in resultset
name|result
operator|=
name|Math
operator|.
name|max
argument_list|(
name|rowCountParents
operator|.
name|get
argument_list|(
name|joinCond
operator|.
name|getRight
argument_list|()
argument_list|)
argument_list|,
name|result
argument_list|)
expr_stmt|;
break|break;
case|case
name|JoinDesc
operator|.
name|FULL_OUTER_JOIN
case|:
comment|// all rows from both side will be present in resultset
name|result
operator|=
name|Math
operator|.
name|max
argument_list|(
name|StatsUtils
operator|.
name|safeAdd
argument_list|(
name|rowCountParents
operator|.
name|get
argument_list|(
name|joinCond
operator|.
name|getRight
argument_list|()
argument_list|)
argument_list|,
name|rowCountParents
operator|.
name|get
argument_list|(
name|joinCond
operator|.
name|getLeft
argument_list|()
argument_list|)
argument_list|)
argument_list|,
name|result
argument_list|)
expr_stmt|;
break|break;
case|case
name|JoinDesc
operator|.
name|LEFT_SEMI_JOIN
case|:
comment|// max # of rows = rows from left side
name|result
operator|=
name|Math
operator|.
name|min
argument_list|(
name|rowCountParents
operator|.
name|get
argument_list|(
name|joinCond
operator|.
name|getLeft
argument_list|()
argument_list|)
argument_list|,
name|result
argument_list|)
expr_stmt|;
break|break;
default|default:
name|LOG
operator|.
name|debug
argument_list|(
literal|"Unhandled join type in stats estimation: "
operator|+
name|joinCond
operator|.
name|getType
argument_list|()
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
return|return
name|result
return|;
block|}
specifier|private
name|long
name|computeRowCountAssumingInnerJoin
parameter_list|(
name|List
argument_list|<
name|Long
argument_list|>
name|rowCountParents
parameter_list|,
name|long
name|denom
parameter_list|,
name|CommonJoinOperator
argument_list|<
name|?
extends|extends
name|JoinDesc
argument_list|>
name|join
parameter_list|)
block|{
name|double
name|factor
init|=
literal|0.0d
decl_stmt|;
name|long
name|result
init|=
literal|1
decl_stmt|;
name|long
name|max
init|=
name|rowCountParents
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|long
name|maxIdx
init|=
literal|0
decl_stmt|;
comment|// To avoid long overflow, we will divide the max row count by denominator
comment|// and use that factor to multiply with other row counts
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<
name|rowCountParents
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|rowCountParents
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|>
name|max
condition|)
block|{
name|max
operator|=
name|rowCountParents
operator|.
name|get
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|maxIdx
operator|=
name|i
expr_stmt|;
block|}
block|}
name|denom
operator|=
name|denom
operator|==
literal|0
condition|?
literal|1
else|:
name|denom
expr_stmt|;
name|factor
operator|=
operator|(
name|double
operator|)
name|max
operator|/
operator|(
name|double
operator|)
name|denom
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|rowCountParents
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|!=
name|maxIdx
condition|)
block|{
name|result
operator|=
name|StatsUtils
operator|.
name|safeMult
argument_list|(
name|result
argument_list|,
name|rowCountParents
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|result
operator|=
call|(
name|long
call|)
argument_list|(
name|result
operator|*
name|factor
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
specifier|private
name|void
name|updateJoinColumnsNDV
parameter_list|(
name|Map
argument_list|<
name|Integer
argument_list|,
name|List
argument_list|<
name|String
argument_list|>
argument_list|>
name|joinKeys
parameter_list|,
name|Map
argument_list|<
name|Integer
argument_list|,
name|Statistics
argument_list|>
name|joinStats
parameter_list|,
name|int
name|numAttr
parameter_list|)
block|{
name|int
name|joinColIdx
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|numAttr
operator|>
literal|0
condition|)
block|{
name|long
name|minNDV
init|=
name|Long
operator|.
name|MAX_VALUE
decl_stmt|;
comment|// find min NDV for joining columns
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|Integer
argument_list|,
name|List
argument_list|<
name|String
argument_list|>
argument_list|>
name|entry
range|:
name|joinKeys
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|int
name|pos
init|=
name|entry
operator|.
name|getKey
argument_list|()
decl_stmt|;
name|String
name|key
init|=
name|entry
operator|.
name|getValue
argument_list|()
operator|.
name|get
argument_list|(
name|joinColIdx
argument_list|)
decl_stmt|;
name|ColStatistics
name|cs
init|=
name|joinStats
operator|.
name|get
argument_list|(
name|pos
argument_list|)
operator|.
name|getColumnStatisticsFromColName
argument_list|(
name|key
argument_list|)
decl_stmt|;
if|if
condition|(
name|cs
operator|!=
literal|null
operator|&&
name|cs
operator|.
name|getCountDistint
argument_list|()
operator|<
name|minNDV
condition|)
block|{
name|minNDV
operator|=
name|cs
operator|.
name|getCountDistint
argument_list|()
expr_stmt|;
block|}
block|}
comment|// set min NDV value to both columns involved in join
if|if
condition|(
name|minNDV
operator|!=
name|Long
operator|.
name|MAX_VALUE
condition|)
block|{
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|Integer
argument_list|,
name|List
argument_list|<
name|String
argument_list|>
argument_list|>
name|entry
range|:
name|joinKeys
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|int
name|pos
init|=
name|entry
operator|.
name|getKey
argument_list|()
decl_stmt|;
name|String
name|key
init|=
name|entry
operator|.
name|getValue
argument_list|()
operator|.
name|get
argument_list|(
name|joinColIdx
argument_list|)
decl_stmt|;
name|ColStatistics
name|cs
init|=
name|joinStats
operator|.
name|get
argument_list|(
name|pos
argument_list|)
operator|.
name|getColumnStatisticsFromColName
argument_list|(
name|key
argument_list|)
decl_stmt|;
if|if
condition|(
name|cs
operator|!=
literal|null
condition|)
block|{
name|cs
operator|.
name|setCountDistint
argument_list|(
name|minNDV
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|joinColIdx
operator|++
expr_stmt|;
name|numAttr
operator|--
expr_stmt|;
block|}
block|}
specifier|private
name|long
name|getDenominatorForUnmatchedRows
parameter_list|(
name|List
argument_list|<
name|Long
argument_list|>
name|distinctVals
parameter_list|)
block|{
if|if
condition|(
name|distinctVals
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return
literal|2
return|;
block|}
comment|// simple join from 2 relations: denom = min(v1, v2)
if|if
condition|(
name|distinctVals
operator|.
name|size
argument_list|()
operator|<=
literal|2
condition|)
block|{
return|return
name|Collections
operator|.
name|min
argument_list|(
name|distinctVals
argument_list|)
return|;
block|}
else|else
block|{
comment|// remember max value and ignore it from the denominator
name|long
name|maxNDV
init|=
name|distinctVals
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|int
name|maxIdx
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<
name|distinctVals
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|distinctVals
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|>
name|maxNDV
condition|)
block|{
name|maxNDV
operator|=
name|distinctVals
operator|.
name|get
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|maxIdx
operator|=
name|i
expr_stmt|;
block|}
block|}
comment|// join from multiple relations:
comment|// denom = Product of all NDVs except the greatest of all
name|long
name|denom
init|=
literal|1
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|distinctVals
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|!=
name|maxIdx
condition|)
block|{
name|denom
operator|=
name|StatsUtils
operator|.
name|safeMult
argument_list|(
name|denom
argument_list|,
name|distinctVals
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|denom
return|;
block|}
block|}
specifier|private
name|long
name|getDenominator
parameter_list|(
name|List
argument_list|<
name|Long
argument_list|>
name|distinctVals
parameter_list|)
block|{
if|if
condition|(
name|distinctVals
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
comment|// TODO: in union20.q the tab alias is not properly propagated down the
comment|// operator tree. This happens when UNION ALL is used as sub query. Hence, even
comment|// if column statistics are available, the tab alias will be null which will fail
comment|// to get proper column statistics. For now assume, worst case in which
comment|// denominator is 2.
return|return
literal|2
return|;
block|}
comment|// simple join from 2 relations: denom = max(v1, v2)
if|if
condition|(
name|distinctVals
operator|.
name|size
argument_list|()
operator|<=
literal|2
condition|)
block|{
return|return
name|Collections
operator|.
name|max
argument_list|(
name|distinctVals
argument_list|)
return|;
block|}
else|else
block|{
comment|// remember min value and ignore it from the denominator
name|long
name|minNDV
init|=
name|distinctVals
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|int
name|minIdx
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<
name|distinctVals
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|distinctVals
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|<
name|minNDV
condition|)
block|{
name|minNDV
operator|=
name|distinctVals
operator|.
name|get
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|minIdx
operator|=
name|i
expr_stmt|;
block|}
block|}
comment|// join from multiple relations:
comment|// denom = Product of all NDVs except the least of all
name|long
name|denom
init|=
literal|1
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|distinctVals
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|!=
name|minIdx
condition|)
block|{
name|denom
operator|=
name|StatsUtils
operator|.
name|safeMult
argument_list|(
name|denom
argument_list|,
name|distinctVals
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|denom
return|;
block|}
block|}
block|}
comment|/**    * LIMIT operator changes the number of rows and thereby the data size.    */
specifier|public
specifier|static
class|class
name|LimitStatsRule
extends|extends
name|DefaultStatsRule
implements|implements
name|NodeProcessor
block|{
annotation|@
name|Override
specifier|public
name|Object
name|process
parameter_list|(
name|Node
name|nd
parameter_list|,
name|Stack
argument_list|<
name|Node
argument_list|>
name|stack
parameter_list|,
name|NodeProcessorCtx
name|procCtx
parameter_list|,
name|Object
modifier|...
name|nodeOutputs
parameter_list|)
throws|throws
name|SemanticException
block|{
name|AnnotateStatsProcCtx
name|aspCtx
init|=
operator|(
name|AnnotateStatsProcCtx
operator|)
name|procCtx
decl_stmt|;
name|LimitOperator
name|lop
init|=
operator|(
name|LimitOperator
operator|)
name|nd
decl_stmt|;
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
name|parent
init|=
name|lop
operator|.
name|getParentOperators
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|Statistics
name|parentStats
init|=
name|parent
operator|.
name|getStatistics
argument_list|()
decl_stmt|;
name|long
name|limit
init|=
operator|-
literal|1
decl_stmt|;
name|limit
operator|=
name|lop
operator|.
name|getConf
argument_list|()
operator|.
name|getLimit
argument_list|()
expr_stmt|;
if|if
condition|(
name|satisfyPrecondition
argument_list|(
name|parentStats
argument_list|)
condition|)
block|{
name|Statistics
name|stats
init|=
name|parentStats
operator|.
name|clone
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|ColStatistics
argument_list|>
name|colStats
init|=
name|StatsUtils
operator|.
name|getColStatisticsUpdatingTableAlias
argument_list|(
name|parentStats
argument_list|,
name|lop
operator|.
name|getSchema
argument_list|()
argument_list|)
decl_stmt|;
name|stats
operator|.
name|setColumnStats
argument_list|(
name|colStats
argument_list|)
expr_stmt|;
comment|// if limit is greater than available rows then do not update
comment|// statistics
if|if
condition|(
name|limit
operator|<=
name|parentStats
operator|.
name|getNumRows
argument_list|()
condition|)
block|{
name|StatsUtils
operator|.
name|updateStats
argument_list|(
name|stats
argument_list|,
name|limit
argument_list|,
literal|true
argument_list|,
name|lop
argument_list|)
expr_stmt|;
block|}
name|stats
operator|=
name|applyRuntimeStats
argument_list|(
name|aspCtx
operator|.
name|getParseContext
argument_list|()
operator|.
name|getContext
argument_list|()
argument_list|,
name|stats
argument_list|,
name|lop
argument_list|)
expr_stmt|;
name|lop
operator|.
name|setStatistics
argument_list|(
name|stats
argument_list|)
expr_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"[0] STATS-"
operator|+
name|lop
operator|.
name|toString
argument_list|()
operator|+
literal|": "
operator|+
name|stats
operator|.
name|extendedToString
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|parentStats
operator|!=
literal|null
condition|)
block|{
comment|// in the absence of column statistics, compute data size based on
comment|// based on average row size
name|limit
operator|=
name|StatsUtils
operator|.
name|getMaxIfOverflow
argument_list|(
name|limit
argument_list|)
expr_stmt|;
name|Statistics
name|wcStats
init|=
name|parentStats
operator|.
name|scaleToRowCount
argument_list|(
name|limit
argument_list|,
literal|true
argument_list|)
decl_stmt|;
name|wcStats
operator|=
name|applyRuntimeStats
argument_list|(
name|aspCtx
operator|.
name|getParseContext
argument_list|()
operator|.
name|getContext
argument_list|()
argument_list|,
name|wcStats
argument_list|,
name|lop
argument_list|)
expr_stmt|;
name|lop
operator|.
name|setStatistics
argument_list|(
name|wcStats
argument_list|)
expr_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"[1] STATS-"
operator|+
name|lop
operator|.
name|toString
argument_list|()
operator|+
literal|": "
operator|+
name|wcStats
operator|.
name|extendedToString
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
literal|null
return|;
block|}
block|}
comment|/**    * ReduceSink operator does not change any of the statistics. But it renames    * the column statistics from its parent based on the output key and value    * column names to make it easy for the downstream operators. This is different    * from the default stats which just aggregates and passes along the statistics    * without actually renaming based on output schema of the operator.    */
specifier|public
specifier|static
class|class
name|ReduceSinkStatsRule
extends|extends
name|DefaultStatsRule
implements|implements
name|NodeProcessor
block|{
annotation|@
name|Override
specifier|public
name|Object
name|process
parameter_list|(
name|Node
name|nd
parameter_list|,
name|Stack
argument_list|<
name|Node
argument_list|>
name|stack
parameter_list|,
name|NodeProcessorCtx
name|procCtx
parameter_list|,
name|Object
modifier|...
name|nodeOutputs
parameter_list|)
throws|throws
name|SemanticException
block|{
name|ReduceSinkOperator
name|rop
init|=
operator|(
name|ReduceSinkOperator
operator|)
name|nd
decl_stmt|;
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
name|parent
init|=
name|rop
operator|.
name|getParentOperators
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|Statistics
name|parentStats
init|=
name|parent
operator|.
name|getStatistics
argument_list|()
decl_stmt|;
if|if
condition|(
name|parentStats
operator|!=
literal|null
condition|)
block|{
name|AnnotateStatsProcCtx
name|aspCtx
init|=
operator|(
name|AnnotateStatsProcCtx
operator|)
name|procCtx
decl_stmt|;
name|HiveConf
name|conf
init|=
name|aspCtx
operator|.
name|getConf
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|outKeyColNames
init|=
name|rop
operator|.
name|getConf
argument_list|()
operator|.
name|getOutputKeyColumnNames
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|outValueColNames
init|=
name|rop
operator|.
name|getConf
argument_list|()
operator|.
name|getOutputValueColumnNames
argument_list|()
decl_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|ExprNodeDesc
argument_list|>
name|colExprMap
init|=
name|rop
operator|.
name|getColumnExprMap
argument_list|()
decl_stmt|;
name|Statistics
name|outStats
init|=
name|parentStats
operator|.
name|clone
argument_list|()
decl_stmt|;
if|if
condition|(
name|satisfyPrecondition
argument_list|(
name|parentStats
argument_list|)
condition|)
block|{
name|List
argument_list|<
name|ColStatistics
argument_list|>
name|colStats
init|=
name|Lists
operator|.
name|newArrayList
argument_list|()
decl_stmt|;
for|for
control|(
name|String
name|key
range|:
name|outKeyColNames
control|)
block|{
name|String
name|prefixedKey
init|=
name|Utilities
operator|.
name|ReduceField
operator|.
name|KEY
operator|.
name|toString
argument_list|()
operator|+
literal|"."
operator|+
name|key
decl_stmt|;
name|ExprNodeDesc
name|end
init|=
name|colExprMap
operator|.
name|get
argument_list|(
name|prefixedKey
argument_list|)
decl_stmt|;
if|if
condition|(
name|end
operator|!=
literal|null
condition|)
block|{
name|ColStatistics
name|cs
init|=
name|StatsUtils
operator|.
name|getColStatisticsFromExpression
argument_list|(
name|conf
argument_list|,
name|parentStats
argument_list|,
name|end
argument_list|)
decl_stmt|;
if|if
condition|(
name|cs
operator|!=
literal|null
condition|)
block|{
name|cs
operator|.
name|setColumnName
argument_list|(
name|prefixedKey
argument_list|)
expr_stmt|;
name|colStats
operator|.
name|add
argument_list|(
name|cs
argument_list|)
expr_stmt|;
block|}
block|}
block|}
for|for
control|(
name|String
name|val
range|:
name|outValueColNames
control|)
block|{
name|String
name|prefixedVal
init|=
name|Utilities
operator|.
name|ReduceField
operator|.
name|VALUE
operator|.
name|toString
argument_list|()
operator|+
literal|"."
operator|+
name|val
decl_stmt|;
name|ExprNodeDesc
name|end
init|=
name|colExprMap
operator|.
name|get
argument_list|(
name|prefixedVal
argument_list|)
decl_stmt|;
if|if
condition|(
name|end
operator|!=
literal|null
condition|)
block|{
name|ColStatistics
name|cs
init|=
name|StatsUtils
operator|.
name|getColStatisticsFromExpression
argument_list|(
name|conf
argument_list|,
name|parentStats
argument_list|,
name|end
argument_list|)
decl_stmt|;
if|if
condition|(
name|cs
operator|!=
literal|null
condition|)
block|{
name|cs
operator|.
name|setColumnName
argument_list|(
name|prefixedVal
argument_list|)
expr_stmt|;
name|colStats
operator|.
name|add
argument_list|(
name|cs
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|outStats
operator|.
name|setColumnStats
argument_list|(
name|colStats
argument_list|)
expr_stmt|;
block|}
name|outStats
operator|=
name|applyRuntimeStats
argument_list|(
name|aspCtx
operator|.
name|getParseContext
argument_list|()
operator|.
name|getContext
argument_list|()
argument_list|,
name|outStats
argument_list|,
name|rop
argument_list|)
expr_stmt|;
name|rop
operator|.
name|setStatistics
argument_list|(
name|outStats
argument_list|)
expr_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"[0] STATS-"
operator|+
name|rop
operator|.
name|toString
argument_list|()
operator|+
literal|": "
operator|+
name|outStats
operator|.
name|extendedToString
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
return|return
literal|null
return|;
block|}
block|}
comment|/**    * UDTF operator changes the number of rows and thereby the data size.    */
specifier|public
specifier|static
class|class
name|UDTFStatsRule
extends|extends
name|DefaultStatsRule
implements|implements
name|NodeProcessor
block|{
annotation|@
name|Override
specifier|public
name|Object
name|process
parameter_list|(
name|Node
name|nd
parameter_list|,
name|Stack
argument_list|<
name|Node
argument_list|>
name|stack
parameter_list|,
name|NodeProcessorCtx
name|procCtx
parameter_list|,
name|Object
modifier|...
name|nodeOutputs
parameter_list|)
throws|throws
name|SemanticException
block|{
name|AnnotateStatsProcCtx
name|aspCtx
init|=
operator|(
name|AnnotateStatsProcCtx
operator|)
name|procCtx
decl_stmt|;
name|UDTFOperator
name|uop
init|=
operator|(
name|UDTFOperator
operator|)
name|nd
decl_stmt|;
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
name|parent
init|=
name|uop
operator|.
name|getParentOperators
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|Statistics
name|parentStats
init|=
name|parent
operator|.
name|getStatistics
argument_list|()
decl_stmt|;
if|if
condition|(
name|parentStats
operator|!=
literal|null
condition|)
block|{
name|Statistics
name|st
init|=
name|parentStats
operator|.
name|clone
argument_list|()
decl_stmt|;
name|float
name|udtfFactor
init|=
name|HiveConf
operator|.
name|getFloatVar
argument_list|(
name|aspCtx
operator|.
name|getConf
argument_list|()
argument_list|,
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVE_STATS_UDTF_FACTOR
argument_list|)
decl_stmt|;
name|long
name|numRows
init|=
call|(
name|long
call|)
argument_list|(
name|parentStats
operator|.
name|getNumRows
argument_list|()
operator|*
name|udtfFactor
argument_list|)
decl_stmt|;
name|long
name|dataSize
init|=
name|StatsUtils
operator|.
name|safeMult
argument_list|(
name|parentStats
operator|.
name|getDataSize
argument_list|()
argument_list|,
name|udtfFactor
argument_list|)
decl_stmt|;
name|st
operator|.
name|setNumRows
argument_list|(
name|numRows
argument_list|)
expr_stmt|;
name|st
operator|.
name|setDataSize
argument_list|(
name|dataSize
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|ColStatistics
argument_list|>
name|colStatsList
init|=
name|st
operator|.
name|getColumnStats
argument_list|()
decl_stmt|;
if|if
condition|(
name|colStatsList
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|ColStatistics
name|colStats
range|:
name|colStatsList
control|)
block|{
name|colStats
operator|.
name|setNumFalses
argument_list|(
call|(
name|long
call|)
argument_list|(
name|colStats
operator|.
name|getNumFalses
argument_list|()
operator|*
name|udtfFactor
argument_list|)
argument_list|)
expr_stmt|;
name|colStats
operator|.
name|setNumTrues
argument_list|(
call|(
name|long
call|)
argument_list|(
name|colStats
operator|.
name|getNumTrues
argument_list|()
operator|*
name|udtfFactor
argument_list|)
argument_list|)
expr_stmt|;
name|colStats
operator|.
name|setNumNulls
argument_list|(
call|(
name|long
call|)
argument_list|(
name|colStats
operator|.
name|getNumNulls
argument_list|()
operator|*
name|udtfFactor
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|st
operator|.
name|setColumnStats
argument_list|(
name|colStatsList
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"[0] STATS-"
operator|+
name|uop
operator|.
name|toString
argument_list|()
operator|+
literal|": "
operator|+
name|st
operator|.
name|extendedToString
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|uop
operator|.
name|setStatistics
argument_list|(
name|st
argument_list|)
expr_stmt|;
block|}
return|return
literal|null
return|;
block|}
block|}
comment|/**    * Default rule is to aggregate the statistics from all its parent operators.    */
specifier|public
specifier|static
class|class
name|DefaultStatsRule
implements|implements
name|NodeProcessor
block|{
annotation|@
name|Override
specifier|public
name|Object
name|process
parameter_list|(
name|Node
name|nd
parameter_list|,
name|Stack
argument_list|<
name|Node
argument_list|>
name|stack
parameter_list|,
name|NodeProcessorCtx
name|procCtx
parameter_list|,
name|Object
modifier|...
name|nodeOutputs
parameter_list|)
throws|throws
name|SemanticException
block|{
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
name|op
init|=
operator|(
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
operator|)
name|nd
decl_stmt|;
name|OperatorDesc
name|conf
init|=
name|op
operator|.
name|getConf
argument_list|()
decl_stmt|;
name|AnnotateStatsProcCtx
name|aspCtx
init|=
operator|(
name|AnnotateStatsProcCtx
operator|)
name|procCtx
decl_stmt|;
name|HiveConf
name|hconf
init|=
name|aspCtx
operator|.
name|getConf
argument_list|()
decl_stmt|;
if|if
condition|(
name|conf
operator|!=
literal|null
condition|)
block|{
name|Statistics
name|stats
init|=
name|conf
operator|.
name|getStatistics
argument_list|()
decl_stmt|;
if|if
condition|(
name|stats
operator|==
literal|null
operator|&&
name|op
operator|.
name|getParentOperators
argument_list|()
operator|!=
literal|null
condition|)
block|{
comment|// if parent statistics is null then that branch of the tree is not
comment|// walked yet. don't update the stats until all branches are walked
if|if
condition|(
name|isAllParentsContainStatistics
argument_list|(
name|op
argument_list|)
condition|)
block|{
for|for
control|(
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
name|parent
range|:
name|op
operator|.
name|getParentOperators
argument_list|()
control|)
block|{
name|Statistics
name|parentStats
init|=
name|parent
operator|.
name|getStatistics
argument_list|()
decl_stmt|;
if|if
condition|(
name|stats
operator|==
literal|null
condition|)
block|{
name|stats
operator|=
name|parentStats
operator|.
name|clone
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|stats
operator|.
name|addBasicStats
argument_list|(
name|parentStats
argument_list|)
expr_stmt|;
block|}
name|stats
operator|.
name|updateColumnStatsState
argument_list|(
name|parentStats
operator|.
name|getColumnStatsState
argument_list|()
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|ColStatistics
argument_list|>
name|colStats
init|=
name|StatsUtils
operator|.
name|getColStatisticsFromExprMap
argument_list|(
name|hconf
argument_list|,
name|parentStats
argument_list|,
name|op
operator|.
name|getColumnExprMap
argument_list|()
argument_list|,
name|op
operator|.
name|getSchema
argument_list|()
argument_list|)
decl_stmt|;
name|stats
operator|.
name|addToColumnStats
argument_list|(
name|colStats
argument_list|)
expr_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"[0] STATS-"
operator|+
name|op
operator|.
name|toString
argument_list|()
operator|+
literal|": "
operator|+
name|stats
operator|.
name|extendedToString
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
name|stats
operator|=
name|applyRuntimeStats
argument_list|(
name|aspCtx
operator|.
name|getParseContext
argument_list|()
operator|.
name|getContext
argument_list|()
argument_list|,
name|stats
argument_list|,
name|op
argument_list|)
expr_stmt|;
name|op
operator|.
name|getConf
argument_list|()
operator|.
name|setStatistics
argument_list|(
name|stats
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
literal|null
return|;
block|}
comment|// check if all parent statistics are available
specifier|private
name|boolean
name|isAllParentsContainStatistics
parameter_list|(
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
name|op
parameter_list|)
block|{
for|for
control|(
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
name|parent
range|:
name|op
operator|.
name|getParentOperators
argument_list|()
control|)
block|{
if|if
condition|(
name|parent
operator|.
name|getStatistics
argument_list|()
operator|==
literal|null
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
return|return
literal|true
return|;
block|}
block|}
specifier|public
specifier|static
name|NodeProcessor
name|getTableScanRule
parameter_list|()
block|{
return|return
operator|new
name|TableScanStatsRule
argument_list|()
return|;
block|}
specifier|public
specifier|static
name|NodeProcessor
name|getSelectRule
parameter_list|()
block|{
return|return
operator|new
name|SelectStatsRule
argument_list|()
return|;
block|}
specifier|public
specifier|static
name|NodeProcessor
name|getFilterRule
parameter_list|()
block|{
return|return
operator|new
name|FilterStatsRule
argument_list|()
return|;
block|}
specifier|public
specifier|static
name|NodeProcessor
name|getGroupByRule
parameter_list|()
block|{
return|return
operator|new
name|GroupByStatsRule
argument_list|()
return|;
block|}
specifier|public
specifier|static
name|NodeProcessor
name|getJoinRule
parameter_list|()
block|{
return|return
operator|new
name|JoinStatsRule
argument_list|()
return|;
block|}
specifier|public
specifier|static
name|NodeProcessor
name|getLimitRule
parameter_list|()
block|{
return|return
operator|new
name|LimitStatsRule
argument_list|()
return|;
block|}
specifier|public
specifier|static
name|NodeProcessor
name|getReduceSinkRule
parameter_list|()
block|{
return|return
operator|new
name|ReduceSinkStatsRule
argument_list|()
return|;
block|}
specifier|public
specifier|static
name|NodeProcessor
name|getUDTFRule
parameter_list|()
block|{
return|return
operator|new
name|UDTFStatsRule
argument_list|()
return|;
block|}
specifier|public
specifier|static
name|NodeProcessor
name|getDefaultRule
parameter_list|()
block|{
return|return
operator|new
name|DefaultStatsRule
argument_list|()
return|;
block|}
specifier|static
name|boolean
name|satisfyPrecondition
parameter_list|(
name|Statistics
name|stats
parameter_list|)
block|{
return|return
name|stats
operator|!=
literal|null
operator|&&
name|stats
operator|.
name|getBasicStatsState
argument_list|()
operator|.
name|equals
argument_list|(
name|Statistics
operator|.
name|State
operator|.
name|COMPLETE
argument_list|)
operator|&&
operator|!
name|stats
operator|.
name|getColumnStatsState
argument_list|()
operator|.
name|equals
argument_list|(
name|Statistics
operator|.
name|State
operator|.
name|NONE
argument_list|)
return|;
block|}
specifier|private
specifier|static
name|Statistics
name|applyRuntimeStats
parameter_list|(
name|Context
name|context
parameter_list|,
name|Statistics
name|stats
parameter_list|,
name|Operator
argument_list|<
name|?
argument_list|>
name|op
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|HiveConf
operator|)
name|context
operator|.
name|getConf
argument_list|()
operator|)
operator|.
name|getBoolVar
argument_list|(
name|ConfVars
operator|.
name|HIVE_QUERY_REEXECUTION_ENABLED
argument_list|)
condition|)
block|{
return|return
name|stats
return|;
block|}
name|PlanMapper
name|pm
init|=
name|context
operator|.
name|getPlanMapper
argument_list|()
decl_stmt|;
name|OpTreeSignature
name|treeSig
init|=
name|pm
operator|.
name|getSignatureOf
argument_list|(
name|op
argument_list|)
decl_stmt|;
name|pm
operator|.
name|link
argument_list|(
name|op
argument_list|,
name|treeSig
argument_list|)
expr_stmt|;
name|StatsSource
name|statsSource
init|=
name|context
operator|.
name|getStatsSource
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|statsSource
operator|.
name|canProvideStatsFor
argument_list|(
name|op
operator|.
name|getClass
argument_list|()
argument_list|)
condition|)
block|{
return|return
name|stats
return|;
block|}
name|Optional
argument_list|<
name|OperatorStats
argument_list|>
name|os
init|=
name|statsSource
operator|.
name|lookup
argument_list|(
name|treeSig
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|os
operator|.
name|isPresent
argument_list|()
condition|)
block|{
return|return
name|stats
return|;
block|}
name|LOG
operator|.
name|debug
argument_list|(
literal|"using runtime stats for {}; {}"
argument_list|,
name|op
argument_list|,
name|os
operator|.
name|get
argument_list|()
argument_list|)
expr_stmt|;
name|Statistics
name|outStats
init|=
name|stats
operator|.
name|clone
argument_list|()
decl_stmt|;
name|outStats
operator|=
name|outStats
operator|.
name|scaleToRowCount
argument_list|(
name|os
operator|.
name|get
argument_list|()
operator|.
name|getOutputRecords
argument_list|()
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|outStats
operator|.
name|setRuntimeStats
argument_list|(
literal|true
argument_list|)
expr_stmt|;
return|return
name|outStats
return|;
block|}
block|}
end_class

end_unit

