begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|optimizer
operator|.
name|calcite
operator|.
name|translator
operator|.
name|opconventer
package|;
end_package

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexInputRef
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexNode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|Pair
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|conf
operator|.
name|HiveConf
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|ColumnInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|Operator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|OperatorFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|RowSchema
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|SelectOperator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|io
operator|.
name|AcidUtils
operator|.
name|Operation
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|optimizer
operator|.
name|calcite
operator|.
name|reloperators
operator|.
name|HiveProject
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|optimizer
operator|.
name|calcite
operator|.
name|translator
operator|.
name|ExprNodeConverter
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|optimizer
operator|.
name|calcite
operator|.
name|translator
operator|.
name|opconventer
operator|.
name|HiveOpConverter
operator|.
name|OpAttr
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|parse
operator|.
name|PTFInvocationSpec
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|parse
operator|.
name|PTFTranslator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|parse
operator|.
name|RowResolver
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|parse
operator|.
name|SemanticException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|parse
operator|.
name|WindowingComponentizer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|parse
operator|.
name|WindowingSpec
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|parse
operator|.
name|PTFInvocationSpec
operator|.
name|OrderExpression
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|parse
operator|.
name|PTFInvocationSpec
operator|.
name|PartitionExpression
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|parse
operator|.
name|WindowingSpec
operator|.
name|WindowFunctionSpec
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|ExprNodeDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|ExprNodeDescUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|PTFDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|SelectDesc
import|;
end_import

begin_class
class|class
name|HiveProjectVisitor
extends|extends
name|HiveRelNodeVisitor
argument_list|<
name|HiveProject
argument_list|>
block|{
name|HiveProjectVisitor
parameter_list|(
name|HiveOpConverter
name|hiveOpConverter
parameter_list|)
block|{
name|super
argument_list|(
name|hiveOpConverter
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
name|OpAttr
name|visit
parameter_list|(
name|HiveProject
name|projectRel
parameter_list|)
throws|throws
name|SemanticException
block|{
name|OpAttr
name|inputOpAf
init|=
name|hiveOpConverter
operator|.
name|dispatch
argument_list|(
name|projectRel
operator|.
name|getInput
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Translating operator rel#"
operator|+
name|projectRel
operator|.
name|getId
argument_list|()
operator|+
literal|":"
operator|+
name|projectRel
operator|.
name|getRelTypeName
argument_list|()
operator|+
literal|" with row type: ["
operator|+
name|projectRel
operator|.
name|getRowType
argument_list|()
operator|+
literal|"]"
argument_list|)
expr_stmt|;
block|}
name|WindowingSpec
name|windowingSpec
init|=
operator|new
name|WindowingSpec
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|exprNames
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|(
name|projectRel
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldNames
argument_list|()
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|ExprNodeDesc
argument_list|>
name|exprCols
init|=
operator|new
name|ArrayList
argument_list|<
name|ExprNodeDesc
argument_list|>
argument_list|()
decl_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|ExprNodeDesc
argument_list|>
name|colExprMap
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|ExprNodeDesc
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|pos
init|=
literal|0
init|;
name|pos
operator|<
name|projectRel
operator|.
name|getChildExps
argument_list|()
operator|.
name|size
argument_list|()
condition|;
name|pos
operator|++
control|)
block|{
name|ExprNodeConverter
name|converter
init|=
operator|new
name|ExprNodeConverter
argument_list|(
name|inputOpAf
operator|.
name|tabAlias
argument_list|,
name|projectRel
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldNames
argument_list|()
operator|.
name|get
argument_list|(
name|pos
argument_list|)
argument_list|,
name|projectRel
operator|.
name|getInput
argument_list|()
operator|.
name|getRowType
argument_list|()
argument_list|,
name|projectRel
operator|.
name|getRowType
argument_list|()
argument_list|,
name|inputOpAf
operator|.
name|vcolsInCalcite
argument_list|,
name|projectRel
operator|.
name|getCluster
argument_list|()
operator|.
name|getTypeFactory
argument_list|()
argument_list|,
literal|true
argument_list|)
decl_stmt|;
name|ExprNodeDesc
name|exprCol
init|=
name|projectRel
operator|.
name|getChildExps
argument_list|()
operator|.
name|get
argument_list|(
name|pos
argument_list|)
operator|.
name|accept
argument_list|(
name|converter
argument_list|)
decl_stmt|;
name|colExprMap
operator|.
name|put
argument_list|(
name|exprNames
operator|.
name|get
argument_list|(
name|pos
argument_list|)
argument_list|,
name|exprCol
argument_list|)
expr_stmt|;
name|exprCols
operator|.
name|add
argument_list|(
name|exprCol
argument_list|)
expr_stmt|;
comment|//TODO: Cols that come through PTF should it retain (VirtualColumness)?
if|if
condition|(
name|converter
operator|.
name|getWindowFunctionSpec
argument_list|()
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|WindowFunctionSpec
name|wfs
range|:
name|converter
operator|.
name|getWindowFunctionSpec
argument_list|()
control|)
block|{
name|windowingSpec
operator|.
name|addWindowFunction
argument_list|(
name|wfs
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|windowingSpec
operator|.
name|getWindowExpressions
argument_list|()
operator|!=
literal|null
operator|&&
operator|!
name|windowingSpec
operator|.
name|getWindowExpressions
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|inputOpAf
operator|=
name|genPTF
argument_list|(
name|inputOpAf
argument_list|,
name|windowingSpec
argument_list|)
expr_stmt|;
block|}
comment|// TODO: is this a safe assumption (name collision, external names...)
name|SelectDesc
name|sd
init|=
operator|new
name|SelectDesc
argument_list|(
name|exprCols
argument_list|,
name|exprNames
argument_list|)
decl_stmt|;
name|Pair
argument_list|<
name|ArrayList
argument_list|<
name|ColumnInfo
argument_list|>
argument_list|,
name|Set
argument_list|<
name|Integer
argument_list|>
argument_list|>
name|colInfoVColPair
init|=
name|createColInfos
argument_list|(
name|projectRel
operator|.
name|getChildExps
argument_list|()
argument_list|,
name|exprCols
argument_list|,
name|exprNames
argument_list|,
name|inputOpAf
argument_list|)
decl_stmt|;
name|SelectOperator
name|selOp
init|=
operator|(
name|SelectOperator
operator|)
name|OperatorFactory
operator|.
name|getAndMakeChild
argument_list|(
name|sd
argument_list|,
operator|new
name|RowSchema
argument_list|(
name|colInfoVColPair
operator|.
name|getKey
argument_list|()
argument_list|)
argument_list|,
name|inputOpAf
operator|.
name|inputs
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|selOp
operator|.
name|setColumnExprMap
argument_list|(
name|colExprMap
argument_list|)
expr_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Generated "
operator|+
name|selOp
operator|+
literal|" with row schema: ["
operator|+
name|selOp
operator|.
name|getSchema
argument_list|()
operator|+
literal|"]"
argument_list|)
expr_stmt|;
block|}
return|return
operator|new
name|OpAttr
argument_list|(
name|inputOpAf
operator|.
name|tabAlias
argument_list|,
name|colInfoVColPair
operator|.
name|getValue
argument_list|()
argument_list|,
name|selOp
argument_list|)
return|;
block|}
specifier|private
name|OpAttr
name|genPTF
parameter_list|(
name|OpAttr
name|inputOpAf
parameter_list|,
name|WindowingSpec
name|wSpec
parameter_list|)
throws|throws
name|SemanticException
block|{
name|Operator
argument_list|<
name|?
argument_list|>
name|input
init|=
name|inputOpAf
operator|.
name|inputs
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|wSpec
operator|.
name|validateAndMakeEffective
argument_list|()
expr_stmt|;
name|WindowingComponentizer
name|groups
init|=
operator|new
name|WindowingComponentizer
argument_list|(
name|wSpec
argument_list|)
decl_stmt|;
name|RowResolver
name|rr
init|=
operator|new
name|RowResolver
argument_list|()
decl_stmt|;
for|for
control|(
name|ColumnInfo
name|ci
range|:
name|input
operator|.
name|getSchema
argument_list|()
operator|.
name|getSignature
argument_list|()
control|)
block|{
name|rr
operator|.
name|put
argument_list|(
name|inputOpAf
operator|.
name|tabAlias
argument_list|,
name|ci
operator|.
name|getInternalName
argument_list|()
argument_list|,
name|ci
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|groups
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|wSpec
operator|=
name|groups
operator|.
name|next
argument_list|(
name|hiveOpConverter
operator|.
name|getHiveConf
argument_list|()
argument_list|,
name|hiveOpConverter
operator|.
name|getSemanticAnalyzer
argument_list|()
argument_list|,
name|hiveOpConverter
operator|.
name|getUnparseTranslator
argument_list|()
argument_list|,
name|rr
argument_list|)
expr_stmt|;
comment|// 1. Create RS and backtrack Select operator on top
name|ArrayList
argument_list|<
name|ExprNodeDesc
argument_list|>
name|keyCols
init|=
operator|new
name|ArrayList
argument_list|<
name|ExprNodeDesc
argument_list|>
argument_list|()
decl_stmt|;
name|ArrayList
argument_list|<
name|ExprNodeDesc
argument_list|>
name|partCols
init|=
operator|new
name|ArrayList
argument_list|<
name|ExprNodeDesc
argument_list|>
argument_list|()
decl_stmt|;
name|StringBuilder
name|order
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|StringBuilder
name|nullOrder
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
for|for
control|(
name|PartitionExpression
name|partCol
range|:
name|wSpec
operator|.
name|getQueryPartitionSpec
argument_list|()
operator|.
name|getExpressions
argument_list|()
control|)
block|{
name|ExprNodeDesc
name|partExpr
init|=
name|hiveOpConverter
operator|.
name|getSemanticAnalyzer
argument_list|()
operator|.
name|genExprNodeDesc
argument_list|(
name|partCol
operator|.
name|getExpression
argument_list|()
argument_list|,
name|rr
argument_list|)
decl_stmt|;
if|if
condition|(
name|ExprNodeDescUtils
operator|.
name|indexOf
argument_list|(
name|partExpr
argument_list|,
name|partCols
argument_list|)
operator|<
literal|0
condition|)
block|{
name|keyCols
operator|.
name|add
argument_list|(
name|partExpr
argument_list|)
expr_stmt|;
name|partCols
operator|.
name|add
argument_list|(
name|partExpr
argument_list|)
expr_stmt|;
name|order
operator|.
name|append
argument_list|(
literal|'+'
argument_list|)
expr_stmt|;
name|nullOrder
operator|.
name|append
argument_list|(
literal|'a'
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|wSpec
operator|.
name|getQueryOrderSpec
argument_list|()
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|OrderExpression
name|orderCol
range|:
name|wSpec
operator|.
name|getQueryOrderSpec
argument_list|()
operator|.
name|getExpressions
argument_list|()
control|)
block|{
name|ExprNodeDesc
name|orderExpr
init|=
name|hiveOpConverter
operator|.
name|getSemanticAnalyzer
argument_list|()
operator|.
name|genExprNodeDesc
argument_list|(
name|orderCol
operator|.
name|getExpression
argument_list|()
argument_list|,
name|rr
argument_list|)
decl_stmt|;
name|char
name|orderChar
init|=
name|orderCol
operator|.
name|getOrder
argument_list|()
operator|==
name|PTFInvocationSpec
operator|.
name|Order
operator|.
name|ASC
condition|?
literal|'+'
else|:
literal|'-'
decl_stmt|;
name|char
name|nullOrderChar
init|=
name|orderCol
operator|.
name|getNullOrder
argument_list|()
operator|==
name|PTFInvocationSpec
operator|.
name|NullOrder
operator|.
name|NULLS_FIRST
condition|?
literal|'a'
else|:
literal|'z'
decl_stmt|;
name|int
name|index
init|=
name|ExprNodeDescUtils
operator|.
name|indexOf
argument_list|(
name|orderExpr
argument_list|,
name|keyCols
argument_list|)
decl_stmt|;
if|if
condition|(
name|index
operator|>=
literal|0
condition|)
block|{
name|order
operator|.
name|setCharAt
argument_list|(
name|index
argument_list|,
name|orderChar
argument_list|)
expr_stmt|;
name|nullOrder
operator|.
name|setCharAt
argument_list|(
name|index
argument_list|,
name|nullOrderChar
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|keyCols
operator|.
name|add
argument_list|(
name|orderExpr
argument_list|)
expr_stmt|;
name|order
operator|.
name|append
argument_list|(
name|orderChar
argument_list|)
expr_stmt|;
name|nullOrder
operator|.
name|append
argument_list|(
name|nullOrderChar
argument_list|)
expr_stmt|;
block|}
block|}
name|SelectOperator
name|selectOp
init|=
name|genReduceSinkAndBacktrackSelect
argument_list|(
name|input
argument_list|,
name|keyCols
operator|.
name|toArray
argument_list|(
operator|new
name|ExprNodeDesc
index|[
name|keyCols
operator|.
name|size
argument_list|()
index|]
argument_list|)
argument_list|,
literal|0
argument_list|,
name|partCols
argument_list|,
name|order
operator|.
name|toString
argument_list|()
argument_list|,
name|nullOrder
operator|.
name|toString
argument_list|()
argument_list|,
operator|-
literal|1
argument_list|,
name|Operation
operator|.
name|NOT_ACID
argument_list|,
name|hiveOpConverter
operator|.
name|getHiveConf
argument_list|()
argument_list|)
decl_stmt|;
comment|// 2. Finally create PTF
name|PTFTranslator
name|translator
init|=
operator|new
name|PTFTranslator
argument_list|()
decl_stmt|;
name|PTFDesc
name|ptfDesc
init|=
name|translator
operator|.
name|translate
argument_list|(
name|wSpec
argument_list|,
name|hiveOpConverter
operator|.
name|getSemanticAnalyzer
argument_list|()
argument_list|,
name|hiveOpConverter
operator|.
name|getHiveConf
argument_list|()
argument_list|,
name|rr
argument_list|,
name|hiveOpConverter
operator|.
name|getUnparseTranslator
argument_list|()
argument_list|)
decl_stmt|;
name|RowResolver
name|ptfOpRR
init|=
name|ptfDesc
operator|.
name|getFuncDef
argument_list|()
operator|.
name|getOutputShape
argument_list|()
operator|.
name|getRr
argument_list|()
decl_stmt|;
name|Operator
argument_list|<
name|?
argument_list|>
name|ptfOp
init|=
name|OperatorFactory
operator|.
name|getAndMakeChild
argument_list|(
name|ptfDesc
argument_list|,
operator|new
name|RowSchema
argument_list|(
name|ptfOpRR
operator|.
name|getColumnInfos
argument_list|()
argument_list|)
argument_list|,
name|selectOp
argument_list|)
decl_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Generated "
operator|+
name|ptfOp
operator|+
literal|" with row schema: ["
operator|+
name|ptfOp
operator|.
name|getSchema
argument_list|()
operator|+
literal|"]"
argument_list|)
expr_stmt|;
block|}
comment|// 3. Prepare for next iteration (if any)
name|rr
operator|=
name|ptfOpRR
expr_stmt|;
name|input
operator|=
name|ptfOp
expr_stmt|;
block|}
return|return
name|inputOpAf
operator|.
name|clone
argument_list|(
name|input
argument_list|)
return|;
block|}
specifier|private
specifier|static
name|SelectOperator
name|genReduceSinkAndBacktrackSelect
parameter_list|(
name|Operator
argument_list|<
name|?
argument_list|>
name|input
parameter_list|,
name|ExprNodeDesc
index|[]
name|keys
parameter_list|,
name|int
name|tag
parameter_list|,
name|ArrayList
argument_list|<
name|ExprNodeDesc
argument_list|>
name|partitionCols
parameter_list|,
name|String
name|order
parameter_list|,
name|String
name|nullOrder
parameter_list|,
name|int
name|numReducers
parameter_list|,
name|Operation
name|acidOperation
parameter_list|,
name|HiveConf
name|hiveConf
parameter_list|)
throws|throws
name|SemanticException
block|{
return|return
name|HiveOpConverterUtils
operator|.
name|genReduceSinkAndBacktrackSelect
argument_list|(
name|input
argument_list|,
name|keys
argument_list|,
name|tag
argument_list|,
name|partitionCols
argument_list|,
name|order
argument_list|,
name|nullOrder
argument_list|,
name|numReducers
argument_list|,
name|acidOperation
argument_list|,
name|hiveConf
argument_list|,
name|input
operator|.
name|getSchema
argument_list|()
operator|.
name|getColumnNames
argument_list|()
argument_list|)
return|;
block|}
specifier|private
name|Pair
argument_list|<
name|ArrayList
argument_list|<
name|ColumnInfo
argument_list|>
argument_list|,
name|Set
argument_list|<
name|Integer
argument_list|>
argument_list|>
name|createColInfos
parameter_list|(
name|List
argument_list|<
name|RexNode
argument_list|>
name|calciteExprs
parameter_list|,
name|List
argument_list|<
name|ExprNodeDesc
argument_list|>
name|hiveExprs
parameter_list|,
name|List
argument_list|<
name|String
argument_list|>
name|projNames
parameter_list|,
name|OpAttr
name|inpOpAf
parameter_list|)
block|{
if|if
condition|(
name|hiveExprs
operator|.
name|size
argument_list|()
operator|!=
name|projNames
operator|.
name|size
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Column expressions list doesn't match Column Names list"
argument_list|)
throw|;
block|}
name|RexNode
name|rexN
decl_stmt|;
name|ExprNodeDesc
name|pe
decl_stmt|;
name|ArrayList
argument_list|<
name|ColumnInfo
argument_list|>
name|colInfos
init|=
operator|new
name|ArrayList
argument_list|<
name|ColumnInfo
argument_list|>
argument_list|()
decl_stmt|;
name|boolean
name|vc
decl_stmt|;
name|Set
argument_list|<
name|Integer
argument_list|>
name|newVColSet
init|=
operator|new
name|HashSet
argument_list|<
name|Integer
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|hiveExprs
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|pe
operator|=
name|hiveExprs
operator|.
name|get
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|rexN
operator|=
name|calciteExprs
operator|.
name|get
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|vc
operator|=
literal|false
expr_stmt|;
if|if
condition|(
name|rexN
operator|instanceof
name|RexInputRef
condition|)
block|{
if|if
condition|(
name|inpOpAf
operator|.
name|vcolsInCalcite
operator|.
name|contains
argument_list|(
operator|(
operator|(
name|RexInputRef
operator|)
name|rexN
operator|)
operator|.
name|getIndex
argument_list|()
argument_list|)
condition|)
block|{
name|newVColSet
operator|.
name|add
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|vc
operator|=
literal|true
expr_stmt|;
block|}
block|}
name|colInfos
operator|.
name|add
argument_list|(
operator|new
name|ColumnInfo
argument_list|(
name|projNames
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|,
name|pe
operator|.
name|getTypeInfo
argument_list|()
argument_list|,
name|inpOpAf
operator|.
name|tabAlias
argument_list|,
name|vc
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
operator|new
name|Pair
argument_list|<
name|ArrayList
argument_list|<
name|ColumnInfo
argument_list|>
argument_list|,
name|Set
argument_list|<
name|Integer
argument_list|>
argument_list|>
argument_list|(
name|colInfos
argument_list|,
name|newVColSet
argument_list|)
return|;
block|}
block|}
end_class

end_unit

