begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|vector
operator|.
name|mapjoin
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|lang
operator|.
name|ArrayUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|CompilationOpContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|persistence
operator|.
name|HybridHashTableContainer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|persistence
operator|.
name|HybridHashTableContainer
operator|.
name|HashPartition
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|persistence
operator|.
name|MapJoinBytesTableContainer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|persistence
operator|.
name|MapJoinTableContainer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|vector
operator|.
name|ColumnVector
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|vector
operator|.
name|VectorDeserializeRow
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|vector
operator|.
name|VectorSerializeRow
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|vector
operator|.
name|VectorizationContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|vector
operator|.
name|VectorizedBatchUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|vector
operator|.
name|VectorizedRowBatch
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|vector
operator|.
name|expressions
operator|.
name|VectorExpression
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|vector
operator|.
name|mapjoin
operator|.
name|hashtable
operator|.
name|VectorMapJoinHashTableResult
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|vector
operator|.
name|mapjoin
operator|.
name|hashtable
operator|.
name|VectorMapJoinHashMapResult
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|vector
operator|.
name|mapjoin
operator|.
name|optimized
operator|.
name|VectorMapJoinOptimizedCreateHashTable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|metadata
operator|.
name|HiveException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|OperatorDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|SerDeException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|WriteBuffers
operator|.
name|ByteSegmentRef
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|lazybinary
operator|.
name|fast
operator|.
name|LazyBinaryDeserializeRead
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|lazybinary
operator|.
name|fast
operator|.
name|LazyBinarySerializeWrite
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|objectinspector
operator|.
name|ObjectInspector
operator|.
name|Category
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|objectinspector
operator|.
name|StructObjectInspector
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|typeinfo
operator|.
name|PrimitiveTypeInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|typeinfo
operator|.
name|TypeInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|typeinfo
operator|.
name|TypeInfoUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|ByteStream
operator|.
name|Output
import|;
end_import

begin_comment
comment|/**  * This class has methods for generating vectorized join results and forwarding batchs.  *  * In some cases when can forward the big table batch by setting scratch columns  * with small table results and then making use of our output projection to pick out all the  * output result columns.  This can improve performance by avoiding copying big table values.  * So, we will use the big table batch's selected in use to represent those rows.  *  * At the same time, some output results need to be formed in the overflow batch.  * For example, to form N x M cross product output results.  In this case, we will copy big  * table values into the overflow batch and set scratch columns in it for small table results.  * The "schema" of the overflow batch is the same as the big table batch so child operators  * only need one definition of their input batch.  The overflow batch will be typically be  * forwarded when it gets full, which might not be during a process call.  *  * NOTE: Child operators should not remember a received batch.  */
end_comment

begin_class
specifier|public
specifier|abstract
class|class
name|VectorMapJoinGenerateResultOperator
extends|extends
name|VectorMapJoinCommonOperator
block|{
specifier|private
specifier|static
specifier|final
name|long
name|serialVersionUID
init|=
literal|1L
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|Logger
name|LOG
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|VectorMapJoinGenerateResultOperator
operator|.
name|class
operator|.
name|getName
argument_list|()
argument_list|)
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|String
name|CLASS_NAME
init|=
name|VectorMapJoinGenerateResultOperator
operator|.
name|class
operator|.
name|getName
argument_list|()
decl_stmt|;
comment|//------------------------------------------------------------------------------------------------
specifier|private
specifier|transient
name|TypeInfo
index|[]
name|bigTableTypeInfos
decl_stmt|;
specifier|private
specifier|transient
name|VectorSerializeRow
name|bigTableVectorSerializeRow
decl_stmt|;
specifier|private
specifier|transient
name|VectorDeserializeRow
name|bigTableVectorDeserializeRow
decl_stmt|;
comment|// Debug display.
specifier|protected
specifier|transient
name|long
name|batchCounter
decl_stmt|;
comment|/** Kryo ctor. */
specifier|protected
name|VectorMapJoinGenerateResultOperator
parameter_list|()
block|{
name|super
argument_list|()
expr_stmt|;
block|}
specifier|public
name|VectorMapJoinGenerateResultOperator
parameter_list|(
name|CompilationOpContext
name|ctx
parameter_list|)
block|{
name|super
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
block|}
specifier|public
name|VectorMapJoinGenerateResultOperator
parameter_list|(
name|CompilationOpContext
name|ctx
parameter_list|,
name|VectorizationContext
name|vContext
parameter_list|,
name|OperatorDesc
name|conf
parameter_list|)
throws|throws
name|HiveException
block|{
name|super
argument_list|(
name|ctx
argument_list|,
name|vContext
argument_list|,
name|conf
argument_list|)
expr_stmt|;
block|}
specifier|protected
name|void
name|commonSetup
parameter_list|(
name|VectorizedRowBatch
name|batch
parameter_list|)
throws|throws
name|HiveException
block|{
name|super
operator|.
name|commonSetup
argument_list|(
name|batch
argument_list|)
expr_stmt|;
name|batchCounter
operator|=
literal|0
expr_stmt|;
block|}
comment|//------------------------------------------------------------------------------------------------
specifier|protected
name|void
name|performValueExpressions
parameter_list|(
name|VectorizedRowBatch
name|batch
parameter_list|,
name|int
index|[]
name|allMatchs
parameter_list|,
name|int
name|allMatchCount
parameter_list|)
block|{
comment|/*      *  For the moment, pretend all matched are selected so we can evaluate the value      *  expressions.      *      *  Since we may use the overflow batch when generating results, we will assign the      *  selected and real batch size later...      */
name|int
index|[]
name|saveSelected
init|=
name|batch
operator|.
name|selected
decl_stmt|;
name|batch
operator|.
name|selected
operator|=
name|allMatchs
expr_stmt|;
name|boolean
name|saveSelectedInUse
init|=
name|batch
operator|.
name|selectedInUse
decl_stmt|;
name|batch
operator|.
name|selectedInUse
operator|=
literal|true
expr_stmt|;
name|batch
operator|.
name|size
operator|=
name|allMatchCount
expr_stmt|;
comment|// Run our value expressions over whole batch.
for|for
control|(
name|VectorExpression
name|ve
range|:
name|bigTableValueExpressions
control|)
block|{
name|ve
operator|.
name|evaluate
argument_list|(
name|batch
argument_list|)
expr_stmt|;
block|}
name|batch
operator|.
name|selected
operator|=
name|saveSelected
expr_stmt|;
name|batch
operator|.
name|selectedInUse
operator|=
name|saveSelectedInUse
expr_stmt|;
block|}
specifier|protected
name|void
name|doSmallTableDeserializeRow
parameter_list|(
name|VectorizedRowBatch
name|batch
parameter_list|,
name|int
name|batchIndex
parameter_list|,
name|ByteSegmentRef
name|byteSegmentRef
parameter_list|,
name|VectorMapJoinHashMapResult
name|hashMapResult
parameter_list|)
throws|throws
name|HiveException
block|{
name|byte
index|[]
name|bytes
init|=
name|byteSegmentRef
operator|.
name|getBytes
argument_list|()
decl_stmt|;
name|int
name|offset
init|=
operator|(
name|int
operator|)
name|byteSegmentRef
operator|.
name|getOffset
argument_list|()
decl_stmt|;
name|int
name|length
init|=
name|byteSegmentRef
operator|.
name|getLength
argument_list|()
decl_stmt|;
name|smallTableVectorDeserializeRow
operator|.
name|setBytes
argument_list|(
name|bytes
argument_list|,
name|offset
argument_list|,
name|length
argument_list|)
expr_stmt|;
try|try
block|{
comment|// Our hash tables are immutable.  We can safely do by reference STRING, CHAR/VARCHAR, etc.
name|smallTableVectorDeserializeRow
operator|.
name|deserializeByRef
argument_list|(
name|batch
argument_list|,
name|batchIndex
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|HiveException
argument_list|(
literal|"\nHashMapResult detail: "
operator|+
name|hashMapResult
operator|.
name|getDetailedHashMapResultPositionString
argument_list|()
operator|+
literal|"\nDeserializeRead detail: "
operator|+
name|smallTableVectorDeserializeRow
operator|.
name|getDetailedReadPositionString
argument_list|()
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
comment|//------------------------------------------------------------------------------------------------
comment|/*    * Common generate join results from hash maps used by Inner and Outer joins.    */
comment|/**    * Generate join results for a single small table value match.    *    * @param batch    *          The big table batch.    * @param hashMapResult    *          The hash map results for the matching key.    * @param allMatchs    *          The selection array for all matches key.    * @param allMatchesIndex    *          Index into allMatches of the matching key we are generating for.    * @param duplicateCount    *          Number of equal key rows.    * @param numSel    *          Current number of rows that are remaining in the big table for forwarding.    * @return    *          The new count of selected rows.    */
specifier|protected
name|int
name|generateHashMapResultSingleValue
parameter_list|(
name|VectorizedRowBatch
name|batch
parameter_list|,
name|VectorMapJoinHashMapResult
name|hashMapResult
parameter_list|,
name|int
index|[]
name|allMatchs
parameter_list|,
name|int
name|allMatchesIndex
parameter_list|,
name|int
name|duplicateCount
parameter_list|,
name|int
name|numSel
parameter_list|)
throws|throws
name|HiveException
throws|,
name|IOException
block|{
comment|// Read single value.
name|ByteSegmentRef
name|byteSegmentRef
init|=
name|hashMapResult
operator|.
name|first
argument_list|()
decl_stmt|;
comment|// Generate result within big table batch itself.
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|duplicateCount
condition|;
name|i
operator|++
control|)
block|{
name|int
name|batchIndex
init|=
name|allMatchs
index|[
name|allMatchesIndex
operator|+
name|i
index|]
decl_stmt|;
comment|// Outer key copying is only used when we are using the input BigTable batch as the output.
comment|//
if|if
condition|(
name|bigTableVectorCopyOuterKeys
operator|!=
literal|null
condition|)
block|{
comment|// Copy within row.
name|bigTableVectorCopyOuterKeys
operator|.
name|copyByReference
argument_list|(
name|batch
argument_list|,
name|batchIndex
argument_list|,
name|batch
argument_list|,
name|batchIndex
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|smallTableVectorDeserializeRow
operator|!=
literal|null
condition|)
block|{
name|doSmallTableDeserializeRow
argument_list|(
name|batch
argument_list|,
name|batchIndex
argument_list|,
name|byteSegmentRef
argument_list|,
name|hashMapResult
argument_list|)
expr_stmt|;
block|}
comment|// VectorizedBatchUtil.debugDisplayOneRow(batch, batchIndex, "generateHashMapResultSingleValue big table");
comment|// Use the big table row as output.
name|batch
operator|.
name|selected
index|[
name|numSel
operator|++
index|]
operator|=
name|batchIndex
expr_stmt|;
block|}
return|return
name|numSel
return|;
block|}
comment|/**    * Generate results for a N x M cross product.    *    * @param batch    *          The big table batch.    * @param hashMapResult    *          The hash map results for the matching key.    * @param allMatchs    *          The all match selected array that contains (physical) batch indices.    * @param allMatchesIndex    *          The index of the match key.    * @param duplicateCount    *          Number of equal key rows.    */
specifier|protected
name|void
name|generateHashMapResultMultiValue
parameter_list|(
name|VectorizedRowBatch
name|batch
parameter_list|,
name|VectorMapJoinHashMapResult
name|hashMapResult
parameter_list|,
name|int
index|[]
name|allMatchs
parameter_list|,
name|int
name|allMatchesIndex
parameter_list|,
name|int
name|duplicateCount
parameter_list|)
throws|throws
name|HiveException
throws|,
name|IOException
block|{
if|if
condition|(
name|useOverflowRepeatedThreshold
operator|&&
name|hashMapResult
operator|.
name|isCappedCountAvailable
argument_list|()
operator|&&
name|hashMapResult
operator|.
name|cappedCount
argument_list|()
operator|>
name|overflowRepeatedThreshold
condition|)
block|{
comment|// Large cross product: generate the vector optimization using repeating vectorized
comment|// row batch optimization in the overflow batch.
name|generateHashMapResultLargeMultiValue
argument_list|(
name|batch
argument_list|,
name|hashMapResult
argument_list|,
name|allMatchs
argument_list|,
name|allMatchesIndex
argument_list|,
name|duplicateCount
argument_list|)
expr_stmt|;
return|return;
block|}
comment|// We do the cross product of the N big table equal key row's values against the
comment|// small table matching key which has M value rows into overflow batch.
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|duplicateCount
condition|;
name|i
operator|++
control|)
block|{
name|int
name|batchIndex
init|=
name|allMatchs
index|[
name|allMatchesIndex
operator|+
name|i
index|]
decl_stmt|;
name|ByteSegmentRef
name|byteSegmentRef
init|=
name|hashMapResult
operator|.
name|first
argument_list|()
decl_stmt|;
while|while
condition|(
name|byteSegmentRef
operator|!=
literal|null
condition|)
block|{
comment|// Copy the BigTable values into the overflow batch. Since the overflow batch may
comment|// not get flushed here, we must copy by value.
comment|// Note this includes any outer join keys that need to go into the small table "area".
if|if
condition|(
name|bigTableRetainedVectorCopy
operator|!=
literal|null
condition|)
block|{
name|bigTableRetainedVectorCopy
operator|.
name|copyByValue
argument_list|(
name|batch
argument_list|,
name|batchIndex
argument_list|,
name|overflowBatch
argument_list|,
name|overflowBatch
operator|.
name|size
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|smallTableVectorDeserializeRow
operator|!=
literal|null
condition|)
block|{
name|doSmallTableDeserializeRow
argument_list|(
name|overflowBatch
argument_list|,
name|overflowBatch
operator|.
name|size
argument_list|,
name|byteSegmentRef
argument_list|,
name|hashMapResult
argument_list|)
expr_stmt|;
block|}
comment|// VectorizedBatchUtil.debugDisplayOneRow(overflowBatch, overflowBatch.size, "generateHashMapResultMultiValue overflow");
name|overflowBatch
operator|.
name|size
operator|++
expr_stmt|;
if|if
condition|(
name|overflowBatch
operator|.
name|size
operator|==
name|overflowBatch
operator|.
name|DEFAULT_SIZE
condition|)
block|{
name|forwardOverflow
argument_list|()
expr_stmt|;
block|}
name|byteSegmentRef
operator|=
name|hashMapResult
operator|.
name|next
argument_list|()
expr_stmt|;
block|}
block|}
block|}
comment|/**    * Generate optimized results for a large N x M cross product using repeated vectorized row    * batch optimization.    *    * @param batch    *          The big table batch.    * @param hashMapResult    *          The hash map results for the matching key.    * @param allMatchs    *          The all match selected array that contains (physical) batch indices.    * @param allMatchesIndex    *          The index of the match key.    * @param duplicateCount    *          Number of equal key rows.    */
specifier|private
name|void
name|generateHashMapResultLargeMultiValue
parameter_list|(
name|VectorizedRowBatch
name|batch
parameter_list|,
name|VectorMapJoinHashMapResult
name|hashMapResult
parameter_list|,
name|int
index|[]
name|allMatchs
parameter_list|,
name|int
name|allMatchesIndex
parameter_list|,
name|int
name|duplicateCount
parameter_list|)
throws|throws
name|HiveException
throws|,
name|IOException
block|{
comment|// Kick out previous overflow batch results.
if|if
condition|(
name|overflowBatch
operator|.
name|size
operator|>
literal|0
condition|)
block|{
name|forwardOverflow
argument_list|()
expr_stmt|;
block|}
name|ByteSegmentRef
name|byteSegmentRef
init|=
name|hashMapResult
operator|.
name|first
argument_list|()
decl_stmt|;
while|while
condition|(
name|byteSegmentRef
operator|!=
literal|null
condition|)
block|{
comment|// Fill up as much of the overflow batch as possible with small table values.
while|while
condition|(
name|byteSegmentRef
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|smallTableVectorDeserializeRow
operator|!=
literal|null
condition|)
block|{
name|doSmallTableDeserializeRow
argument_list|(
name|overflowBatch
argument_list|,
name|overflowBatch
operator|.
name|size
argument_list|,
name|byteSegmentRef
argument_list|,
name|hashMapResult
argument_list|)
expr_stmt|;
block|}
name|overflowBatch
operator|.
name|size
operator|++
expr_stmt|;
if|if
condition|(
name|overflowBatch
operator|.
name|size
operator|==
name|overflowBatch
operator|.
name|DEFAULT_SIZE
condition|)
block|{
break|break;
block|}
name|byteSegmentRef
operator|=
name|hashMapResult
operator|.
name|next
argument_list|()
expr_stmt|;
block|}
comment|// Forward the overflow batch over and over:
comment|//
comment|//    Reference a new one big table row's values each time
comment|//      cross product
comment|//    Current "batch" of small table values.
comment|//
comment|// TODO: This could be further optimized to copy big table (equal) keys once
comment|//       and only copy big table values each time...
comment|//       And, not set repeating every time...
comment|//
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|duplicateCount
condition|;
name|i
operator|++
control|)
block|{
name|int
name|batchIndex
init|=
name|allMatchs
index|[
name|allMatchesIndex
operator|+
name|i
index|]
decl_stmt|;
if|if
condition|(
name|bigTableRetainedVectorCopy
operator|!=
literal|null
condition|)
block|{
comment|// The one big table row's values repeat.
name|bigTableRetainedVectorCopy
operator|.
name|copyByReference
argument_list|(
name|batch
argument_list|,
name|batchIndex
argument_list|,
name|overflowBatch
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|column
range|:
name|bigTableRetainedMapping
operator|.
name|getOutputColumns
argument_list|()
control|)
block|{
name|overflowBatch
operator|.
name|cols
index|[
name|column
index|]
operator|.
name|isRepeating
operator|=
literal|true
expr_stmt|;
block|}
block|}
comment|// Crucial here that we don't reset the overflow batch, or we will loose the small table
comment|// values we put in above.
name|forwardOverflowNoReset
argument_list|()
expr_stmt|;
comment|// Hand reset the big table columns.
for|for
control|(
name|int
name|column
range|:
name|bigTableRetainedMapping
operator|.
name|getOutputColumns
argument_list|()
control|)
block|{
name|ColumnVector
name|colVector
init|=
name|overflowBatch
operator|.
name|cols
index|[
name|column
index|]
decl_stmt|;
name|colVector
operator|.
name|reset
argument_list|()
expr_stmt|;
block|}
block|}
name|byteSegmentRef
operator|=
name|hashMapResult
operator|.
name|next
argument_list|()
expr_stmt|;
if|if
condition|(
name|byteSegmentRef
operator|==
literal|null
condition|)
block|{
break|break;
block|}
comment|// Get ready for a another round of small table values.
name|overflowBatch
operator|.
name|reset
argument_list|()
expr_stmt|;
block|}
comment|// Clear away any residue from our optimizations.
name|overflowBatch
operator|.
name|reset
argument_list|()
expr_stmt|;
block|}
comment|/**    * Generate optimized results when entire batch key is repeated and it matched the hash map.    *    * @param batch    *          The big table batch.    * @param hashMapResult    *          The hash map results for the repeated key.    */
specifier|protected
name|void
name|generateHashMapResultRepeatedAll
parameter_list|(
name|VectorizedRowBatch
name|batch
parameter_list|,
name|VectorMapJoinHashMapResult
name|hashMapResult
parameter_list|)
throws|throws
name|IOException
throws|,
name|HiveException
block|{
name|int
index|[]
name|selected
init|=
name|batch
operator|.
name|selected
decl_stmt|;
if|if
condition|(
name|batch
operator|.
name|selectedInUse
condition|)
block|{
comment|// The selected array is already filled in as we want it.
block|}
else|else
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|batch
operator|.
name|size
condition|;
name|i
operator|++
control|)
block|{
name|selected
index|[
name|i
index|]
operator|=
name|i
expr_stmt|;
block|}
name|batch
operator|.
name|selectedInUse
operator|=
literal|true
expr_stmt|;
block|}
name|int
name|numSel
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|hashMapResult
operator|.
name|isSingleRow
argument_list|()
condition|)
block|{
name|numSel
operator|=
name|generateHashMapResultSingleValue
argument_list|(
name|batch
argument_list|,
name|hashMapResult
argument_list|,
name|batch
operator|.
name|selected
argument_list|,
literal|0
argument_list|,
name|batch
operator|.
name|size
argument_list|,
name|numSel
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|generateHashMapResultMultiValue
argument_list|(
name|batch
argument_list|,
name|hashMapResult
argument_list|,
name|batch
operator|.
name|selected
argument_list|,
literal|0
argument_list|,
name|batch
operator|.
name|size
argument_list|)
expr_stmt|;
block|}
name|batch
operator|.
name|size
operator|=
name|numSel
expr_stmt|;
block|}
comment|//-----------------------------------------------------------------------------------------------
comment|/*    * Spill.    */
specifier|private
name|void
name|setupSpillSerDe
parameter_list|(
name|VectorizedRowBatch
name|batch
parameter_list|)
throws|throws
name|HiveException
block|{
name|TypeInfo
index|[]
name|inputObjInspectorsTypeInfos
init|=
name|VectorizedBatchUtil
operator|.
name|typeInfosFromStructObjectInspector
argument_list|(
operator|(
name|StructObjectInspector
operator|)
name|inputObjInspectors
index|[
name|posBigTable
index|]
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|Integer
argument_list|>
name|projectedColumns
init|=
name|vContext
operator|.
name|getProjectedColumns
argument_list|()
decl_stmt|;
name|int
name|projectionSize
init|=
name|vContext
operator|.
name|getProjectedColumns
argument_list|()
operator|.
name|size
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|TypeInfo
argument_list|>
name|typeInfoList
init|=
operator|new
name|ArrayList
argument_list|<
name|TypeInfo
argument_list|>
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|Integer
argument_list|>
name|noNullsProjectionList
init|=
operator|new
name|ArrayList
argument_list|<
name|Integer
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|projectionSize
condition|;
name|i
operator|++
control|)
block|{
name|int
name|projectedColumn
init|=
name|projectedColumns
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|batch
operator|.
name|cols
index|[
name|projectedColumn
index|]
operator|!=
literal|null
operator|&&
name|inputObjInspectorsTypeInfos
index|[
name|i
index|]
operator|.
name|getCategory
argument_list|()
operator|==
name|Category
operator|.
name|PRIMITIVE
condition|)
block|{
comment|// Only columns present in the batch and non-complex types.
name|typeInfoList
operator|.
name|add
argument_list|(
name|inputObjInspectorsTypeInfos
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|noNullsProjectionList
operator|.
name|add
argument_list|(
name|projectedColumn
argument_list|)
expr_stmt|;
block|}
block|}
name|int
index|[]
name|noNullsProjection
init|=
name|ArrayUtils
operator|.
name|toPrimitive
argument_list|(
name|noNullsProjectionList
operator|.
name|toArray
argument_list|(
operator|new
name|Integer
index|[
literal|0
index|]
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|noNullsProjectionSize
init|=
name|noNullsProjection
operator|.
name|length
decl_stmt|;
name|bigTableTypeInfos
operator|=
name|typeInfoList
operator|.
name|toArray
argument_list|(
operator|new
name|TypeInfo
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|bigTableVectorSerializeRow
operator|=
operator|new
name|VectorSerializeRow
argument_list|<
name|LazyBinarySerializeWrite
argument_list|>
argument_list|(
operator|new
name|LazyBinarySerializeWrite
argument_list|(
name|noNullsProjectionSize
argument_list|)
argument_list|)
expr_stmt|;
name|bigTableVectorSerializeRow
operator|.
name|init
argument_list|(
name|bigTableTypeInfos
argument_list|,
name|noNullsProjection
argument_list|)
expr_stmt|;
name|bigTableVectorDeserializeRow
operator|=
operator|new
name|VectorDeserializeRow
argument_list|<
name|LazyBinaryDeserializeRead
argument_list|>
argument_list|(
operator|new
name|LazyBinaryDeserializeRead
argument_list|(
name|bigTableTypeInfos
argument_list|,
comment|/* useExternalBuffer */
literal|true
argument_list|)
argument_list|)
expr_stmt|;
name|bigTableVectorDeserializeRow
operator|.
name|init
argument_list|(
name|noNullsProjection
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|spillSerializeRow
parameter_list|(
name|VectorizedRowBatch
name|batch
parameter_list|,
name|int
name|batchIndex
parameter_list|,
name|VectorMapJoinHashTableResult
name|hashTableResult
parameter_list|)
throws|throws
name|IOException
block|{
name|int
name|partitionId
init|=
name|hashTableResult
operator|.
name|spillPartitionId
argument_list|()
decl_stmt|;
name|HybridHashTableContainer
name|ht
init|=
operator|(
name|HybridHashTableContainer
operator|)
name|mapJoinTables
index|[
name|posSingleVectorMapJoinSmallTable
index|]
decl_stmt|;
name|HashPartition
name|hp
init|=
name|ht
operator|.
name|getHashPartitions
argument_list|()
index|[
name|partitionId
index|]
decl_stmt|;
name|VectorMapJoinRowBytesContainer
name|rowBytesContainer
init|=
name|hp
operator|.
name|getMatchfileRowBytesContainer
argument_list|()
decl_stmt|;
name|Output
name|output
init|=
name|rowBytesContainer
operator|.
name|getOuputForRowBytes
argument_list|()
decl_stmt|;
comment|//  int offset = output.getLength();
name|bigTableVectorSerializeRow
operator|.
name|setOutputAppend
argument_list|(
name|output
argument_list|)
expr_stmt|;
name|bigTableVectorSerializeRow
operator|.
name|serializeWrite
argument_list|(
name|batch
argument_list|,
name|batchIndex
argument_list|)
expr_stmt|;
comment|//  int length = output.getLength() - offset;
name|rowBytesContainer
operator|.
name|finishRow
argument_list|()
expr_stmt|;
comment|//  LOG.debug("spillSerializeRow spilled batchIndex " + batchIndex + ", length " + length);
block|}
specifier|protected
name|void
name|spillHashMapBatch
parameter_list|(
name|VectorizedRowBatch
name|batch
parameter_list|,
name|VectorMapJoinHashTableResult
index|[]
name|hashTableResults
parameter_list|,
name|int
index|[]
name|spills
parameter_list|,
name|int
index|[]
name|spillHashTableResultIndices
parameter_list|,
name|int
name|spillCount
parameter_list|)
throws|throws
name|HiveException
throws|,
name|IOException
block|{
if|if
condition|(
name|bigTableVectorSerializeRow
operator|==
literal|null
condition|)
block|{
name|setupSpillSerDe
argument_list|(
name|batch
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|spillCount
condition|;
name|i
operator|++
control|)
block|{
name|int
name|batchIndex
init|=
name|spills
index|[
name|i
index|]
decl_stmt|;
name|int
name|hashTableResultIndex
init|=
name|spillHashTableResultIndices
index|[
name|i
index|]
decl_stmt|;
name|VectorMapJoinHashTableResult
name|hashTableResult
init|=
name|hashTableResults
index|[
name|hashTableResultIndex
index|]
decl_stmt|;
name|spillSerializeRow
argument_list|(
name|batch
argument_list|,
name|batchIndex
argument_list|,
name|hashTableResult
argument_list|)
expr_stmt|;
block|}
block|}
specifier|protected
name|void
name|spillBatchRepeated
parameter_list|(
name|VectorizedRowBatch
name|batch
parameter_list|,
name|VectorMapJoinHashTableResult
name|hashTableResult
parameter_list|)
throws|throws
name|HiveException
throws|,
name|IOException
block|{
if|if
condition|(
name|bigTableVectorSerializeRow
operator|==
literal|null
condition|)
block|{
name|setupSpillSerDe
argument_list|(
name|batch
argument_list|)
expr_stmt|;
block|}
name|int
index|[]
name|selected
init|=
name|batch
operator|.
name|selected
decl_stmt|;
name|boolean
name|selectedInUse
init|=
name|batch
operator|.
name|selectedInUse
decl_stmt|;
for|for
control|(
name|int
name|logical
init|=
literal|0
init|;
name|logical
operator|<
name|batch
operator|.
name|size
condition|;
name|logical
operator|++
control|)
block|{
name|int
name|batchIndex
init|=
operator|(
name|selectedInUse
condition|?
name|selected
index|[
name|logical
index|]
else|:
name|logical
operator|)
decl_stmt|;
name|spillSerializeRow
argument_list|(
name|batch
argument_list|,
name|batchIndex
argument_list|,
name|hashTableResult
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
specifier|protected
name|void
name|reloadHashTable
parameter_list|(
name|byte
name|pos
parameter_list|,
name|int
name|partitionId
parameter_list|)
throws|throws
name|IOException
throws|,
name|HiveException
throws|,
name|SerDeException
throws|,
name|ClassNotFoundException
block|{
comment|// The super method will reload a hash table partition of one of the small tables.
comment|// Currently, for native vector map join it will only be one small table.
name|super
operator|.
name|reloadHashTable
argument_list|(
name|pos
argument_list|,
name|partitionId
argument_list|)
expr_stmt|;
name|MapJoinTableContainer
name|smallTable
init|=
name|spilledMapJoinTables
index|[
name|pos
index|]
decl_stmt|;
name|vectorMapJoinHashTable
operator|=
name|VectorMapJoinOptimizedCreateHashTable
operator|.
name|createHashTable
argument_list|(
name|conf
argument_list|,
name|smallTable
argument_list|)
expr_stmt|;
name|needHashTableSetup
operator|=
literal|true
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Created "
operator|+
name|vectorMapJoinHashTable
operator|.
name|getClass
argument_list|()
operator|.
name|getSimpleName
argument_list|()
operator|+
literal|" from "
operator|+
name|this
operator|.
name|getClass
argument_list|()
operator|.
name|getSimpleName
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|isLogDebugEnabled
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
name|CLASS_NAME
operator|+
literal|" reloadHashTable!"
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
specifier|protected
name|void
name|reProcessBigTable
parameter_list|(
name|int
name|partitionId
parameter_list|)
throws|throws
name|HiveException
block|{
if|if
condition|(
name|isLogDebugEnabled
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
name|CLASS_NAME
operator|+
literal|" reProcessBigTable enter..."
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|spillReplayBatch
operator|==
literal|null
condition|)
block|{
comment|// The process method was not called -- no big table rows.
return|return;
block|}
name|HashPartition
name|partition
init|=
name|firstSmallTable
operator|.
name|getHashPartitions
argument_list|()
index|[
name|partitionId
index|]
decl_stmt|;
name|int
name|rowCount
init|=
literal|0
decl_stmt|;
name|int
name|batchCount
init|=
literal|0
decl_stmt|;
try|try
block|{
name|VectorMapJoinRowBytesContainer
name|bigTable
init|=
name|partition
operator|.
name|getMatchfileRowBytesContainer
argument_list|()
decl_stmt|;
name|bigTable
operator|.
name|prepareForReading
argument_list|()
expr_stmt|;
while|while
condition|(
name|bigTable
operator|.
name|readNext
argument_list|()
condition|)
block|{
name|rowCount
operator|++
expr_stmt|;
name|byte
index|[]
name|bytes
init|=
name|bigTable
operator|.
name|currentBytes
argument_list|()
decl_stmt|;
name|int
name|offset
init|=
name|bigTable
operator|.
name|currentOffset
argument_list|()
decl_stmt|;
name|int
name|length
init|=
name|bigTable
operator|.
name|currentLength
argument_list|()
decl_stmt|;
name|bigTableVectorDeserializeRow
operator|.
name|setBytes
argument_list|(
name|bytes
argument_list|,
name|offset
argument_list|,
name|length
argument_list|)
expr_stmt|;
try|try
block|{
name|bigTableVectorDeserializeRow
operator|.
name|deserialize
argument_list|(
name|spillReplayBatch
argument_list|,
name|spillReplayBatch
operator|.
name|size
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|HiveException
argument_list|(
literal|"\nDeserializeRead detail: "
operator|+
name|bigTableVectorDeserializeRow
operator|.
name|getDetailedReadPositionString
argument_list|()
argument_list|,
name|e
argument_list|)
throw|;
block|}
name|spillReplayBatch
operator|.
name|size
operator|++
expr_stmt|;
if|if
condition|(
name|spillReplayBatch
operator|.
name|size
operator|==
name|VectorizedRowBatch
operator|.
name|DEFAULT_SIZE
condition|)
block|{
name|process
argument_list|(
name|spillReplayBatch
argument_list|,
name|posBigTable
argument_list|)
expr_stmt|;
comment|// call process once we have a full batch
name|spillReplayBatch
operator|.
name|reset
argument_list|()
expr_stmt|;
name|batchCount
operator|++
expr_stmt|;
block|}
block|}
comment|// Process the row batch that has less than DEFAULT_SIZE rows
if|if
condition|(
name|spillReplayBatch
operator|.
name|size
operator|>
literal|0
condition|)
block|{
name|process
argument_list|(
name|spillReplayBatch
argument_list|,
name|posBigTable
argument_list|)
expr_stmt|;
name|spillReplayBatch
operator|.
name|reset
argument_list|()
expr_stmt|;
name|batchCount
operator|++
expr_stmt|;
block|}
name|bigTable
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|info
argument_list|(
name|CLASS_NAME
operator|+
literal|" reProcessBigTable exception! "
operator|+
name|e
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|HiveException
argument_list|(
name|e
argument_list|)
throw|;
block|}
if|if
condition|(
name|isLogDebugEnabled
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
name|CLASS_NAME
operator|+
literal|" reProcessBigTable exit! "
operator|+
name|rowCount
operator|+
literal|" row processed and "
operator|+
name|batchCount
operator|+
literal|" batches processed"
argument_list|)
expr_stmt|;
block|}
block|}
comment|//-----------------------------------------------------------------------------------------------
comment|/*    * Forwarding.    */
comment|/**    * Forward the big table batch to the children.    *    * @param batch    *          The big table batch.    */
specifier|public
name|void
name|forwardBigTableBatch
parameter_list|(
name|VectorizedRowBatch
name|batch
parameter_list|)
throws|throws
name|HiveException
block|{
comment|// Save original projection.
name|int
index|[]
name|originalProjections
init|=
name|batch
operator|.
name|projectedColumns
decl_stmt|;
name|int
name|originalProjectionSize
init|=
name|batch
operator|.
name|projectionSize
decl_stmt|;
comment|// Project with the output of our operator.
name|batch
operator|.
name|projectionSize
operator|=
name|outputProjection
operator|.
name|length
expr_stmt|;
name|batch
operator|.
name|projectedColumns
operator|=
name|outputProjection
expr_stmt|;
name|forward
argument_list|(
name|batch
argument_list|,
literal|null
argument_list|)
expr_stmt|;
comment|// Revert the projected columns back, because batch can be re-used by our parent operators.
name|batch
operator|.
name|projectionSize
operator|=
name|originalProjectionSize
expr_stmt|;
name|batch
operator|.
name|projectedColumns
operator|=
name|originalProjections
expr_stmt|;
block|}
comment|/**    * Forward the overflow batch and reset the batch.    */
specifier|protected
name|void
name|forwardOverflow
parameter_list|()
throws|throws
name|HiveException
block|{
name|forward
argument_list|(
name|overflowBatch
argument_list|,
literal|null
argument_list|)
expr_stmt|;
name|overflowBatch
operator|.
name|reset
argument_list|()
expr_stmt|;
block|}
comment|/**    * Forward the overflow batch, but do not reset the batch.    */
specifier|private
name|void
name|forwardOverflowNoReset
parameter_list|()
throws|throws
name|HiveException
block|{
name|forward
argument_list|(
name|overflowBatch
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
comment|/*    * Close.    */
comment|/**    * On close, make sure a partially filled overflow batch gets forwarded.    */
annotation|@
name|Override
specifier|public
name|void
name|closeOp
parameter_list|(
name|boolean
name|aborted
parameter_list|)
throws|throws
name|HiveException
block|{
name|super
operator|.
name|closeOp
argument_list|(
name|aborted
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|aborted
operator|&&
name|overflowBatch
operator|.
name|size
operator|>
literal|0
condition|)
block|{
name|forwardOverflow
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|isLogDebugEnabled
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"VectorMapJoinInnerLongOperator closeOp "
operator|+
name|batchCounter
operator|+
literal|" batches processed"
argument_list|)
expr_stmt|;
block|}
block|}
comment|//-----------------------------------------------------------------------------------------------
comment|/*    * Debug.    */
specifier|public
name|boolean
name|verifyMonotonicallyIncreasing
parameter_list|(
name|int
index|[]
name|selected
parameter_list|,
name|int
name|size
parameter_list|)
block|{
if|if
condition|(
name|size
operator|==
literal|0
condition|)
block|{
return|return
literal|true
return|;
block|}
name|int
name|prevBatchIndex
init|=
name|selected
index|[
literal|0
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<
name|size
condition|;
name|i
operator|++
control|)
block|{
name|int
name|batchIndex
init|=
name|selected
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|batchIndex
operator|<=
name|prevBatchIndex
condition|)
block|{
return|return
literal|false
return|;
block|}
name|prevBatchIndex
operator|=
name|batchIndex
expr_stmt|;
block|}
return|return
literal|true
return|;
block|}
specifier|public
specifier|static
name|String
name|intArrayToRangesString
parameter_list|(
name|int
name|selection
index|[]
parameter_list|,
name|int
name|size
parameter_list|)
block|{
if|if
condition|(
name|size
operator|==
literal|0
condition|)
block|{
return|return
literal|"[]"
return|;
block|}
name|StringBuilder
name|sb
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
comment|// Use ranges and duplicate multipliers to reduce the size of the display.
name|sb
operator|.
name|append
argument_list|(
literal|"["
argument_list|)
expr_stmt|;
name|int
name|firstIndex
init|=
literal|0
decl_stmt|;
name|int
name|firstValue
init|=
name|selection
index|[
literal|0
index|]
decl_stmt|;
name|boolean
name|duplicates
init|=
literal|false
decl_stmt|;
name|int
name|i
init|=
literal|1
decl_stmt|;
for|for
control|(
init|;
name|i
operator|<
name|size
condition|;
name|i
operator|++
control|)
block|{
name|int
name|newValue
init|=
name|selection
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|newValue
operator|==
name|selection
index|[
name|i
operator|-
literal|1
index|]
condition|)
block|{
comment|// Duplicate.
name|duplicates
operator|=
literal|true
expr_stmt|;
if|if
condition|(
name|newValue
operator|==
name|firstValue
condition|)
block|{
continue|continue;
block|}
else|else
block|{
comment|// Prior none, singleton, or range?
name|int
name|priorRangeLength
init|=
name|i
operator|-
literal|1
operator|-
name|firstIndex
decl_stmt|;
if|if
condition|(
name|priorRangeLength
operator|==
literal|0
condition|)
block|{
continue|continue;
block|}
if|if
condition|(
name|firstIndex
operator|>
literal|0
condition|)
block|{
name|sb
operator|.
name|append
argument_list|(
literal|","
argument_list|)
expr_stmt|;
block|}
name|sb
operator|.
name|append
argument_list|(
name|firstValue
argument_list|)
expr_stmt|;
if|if
condition|(
name|priorRangeLength
operator|>
literal|1
condition|)
block|{
name|sb
operator|.
name|append
argument_list|(
literal|".."
operator|+
name|selection
index|[
name|i
operator|-
literal|2
index|]
argument_list|)
expr_stmt|;
block|}
name|firstIndex
operator|=
name|i
operator|-
literal|1
expr_stmt|;
name|firstValue
operator|=
name|newValue
expr_stmt|;
continue|continue;
block|}
block|}
else|else
block|{
if|if
condition|(
name|duplicates
condition|)
block|{
name|int
name|numDuplicates
init|=
name|i
operator|-
name|firstIndex
decl_stmt|;
if|if
condition|(
name|firstIndex
operator|>
literal|0
condition|)
block|{
name|sb
operator|.
name|append
argument_list|(
literal|","
argument_list|)
expr_stmt|;
block|}
name|sb
operator|.
name|append
argument_list|(
name|numDuplicates
operator|+
literal|"*"
operator|+
name|firstValue
argument_list|)
expr_stmt|;
name|duplicates
operator|=
literal|false
expr_stmt|;
name|firstIndex
operator|=
name|i
expr_stmt|;
name|firstValue
operator|=
name|newValue
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|newValue
operator|==
name|selection
index|[
name|i
operator|-
literal|1
index|]
operator|+
literal|1
condition|)
block|{
comment|// Continue range..
continue|continue;
block|}
else|else
block|{
comment|// Prior singleton or range?
name|int
name|priorRangeLength
init|=
name|i
operator|-
name|firstIndex
decl_stmt|;
if|if
condition|(
name|firstIndex
operator|>
literal|0
condition|)
block|{
name|sb
operator|.
name|append
argument_list|(
literal|","
argument_list|)
expr_stmt|;
block|}
name|sb
operator|.
name|append
argument_list|(
name|firstValue
argument_list|)
expr_stmt|;
if|if
condition|(
name|priorRangeLength
operator|>
literal|1
condition|)
block|{
name|sb
operator|.
name|append
argument_list|(
literal|".."
operator|+
name|selection
index|[
name|i
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
name|firstIndex
operator|=
name|i
expr_stmt|;
name|firstValue
operator|=
name|newValue
expr_stmt|;
continue|continue;
block|}
block|}
block|}
if|if
condition|(
name|duplicates
condition|)
block|{
name|int
name|numDuplicates
init|=
name|i
operator|-
name|firstIndex
decl_stmt|;
if|if
condition|(
name|firstIndex
operator|>
literal|0
condition|)
block|{
name|sb
operator|.
name|append
argument_list|(
literal|","
argument_list|)
expr_stmt|;
block|}
name|sb
operator|.
name|append
argument_list|(
name|numDuplicates
operator|+
literal|"*"
operator|+
name|firstValue
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// Last singleton or range?
name|int
name|priorRangeLength
init|=
name|i
operator|-
name|firstIndex
decl_stmt|;
if|if
condition|(
name|firstIndex
operator|>
literal|0
condition|)
block|{
name|sb
operator|.
name|append
argument_list|(
literal|","
argument_list|)
expr_stmt|;
block|}
name|sb
operator|.
name|append
argument_list|(
name|firstValue
argument_list|)
expr_stmt|;
if|if
condition|(
name|priorRangeLength
operator|>
literal|1
condition|)
block|{
name|sb
operator|.
name|append
argument_list|(
literal|".."
operator|+
name|selection
index|[
name|i
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
block|}
name|sb
operator|.
name|append
argument_list|(
literal|"]"
argument_list|)
expr_stmt|;
return|return
name|sb
operator|.
name|toString
argument_list|()
return|;
block|}
specifier|public
specifier|static
name|String
name|longArrayToRangesString
parameter_list|(
name|long
name|selection
index|[]
parameter_list|,
name|int
name|size
parameter_list|)
block|{
if|if
condition|(
name|size
operator|==
literal|0
condition|)
block|{
return|return
literal|"[]"
return|;
block|}
name|StringBuilder
name|sb
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
comment|// Use ranges and duplicate multipliers to reduce the size of the display.
name|sb
operator|.
name|append
argument_list|(
literal|"["
argument_list|)
expr_stmt|;
name|int
name|firstIndex
init|=
literal|0
decl_stmt|;
name|long
name|firstValue
init|=
name|selection
index|[
literal|0
index|]
decl_stmt|;
name|boolean
name|duplicates
init|=
literal|false
decl_stmt|;
name|int
name|i
init|=
literal|1
decl_stmt|;
for|for
control|(
init|;
name|i
operator|<
name|size
condition|;
name|i
operator|++
control|)
block|{
name|long
name|newValue
init|=
name|selection
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|newValue
operator|==
name|selection
index|[
name|i
operator|-
literal|1
index|]
condition|)
block|{
comment|// Duplicate.
name|duplicates
operator|=
literal|true
expr_stmt|;
if|if
condition|(
name|newValue
operator|==
name|firstValue
condition|)
block|{
continue|continue;
block|}
else|else
block|{
comment|// Prior none, singleton, or range?
name|int
name|priorRangeLength
init|=
name|i
operator|-
literal|1
operator|-
name|firstIndex
decl_stmt|;
if|if
condition|(
name|priorRangeLength
operator|==
literal|0
condition|)
block|{
continue|continue;
block|}
if|if
condition|(
name|firstIndex
operator|>
literal|0
condition|)
block|{
name|sb
operator|.
name|append
argument_list|(
literal|","
argument_list|)
expr_stmt|;
block|}
name|sb
operator|.
name|append
argument_list|(
name|firstValue
argument_list|)
expr_stmt|;
if|if
condition|(
name|priorRangeLength
operator|>
literal|1
condition|)
block|{
name|sb
operator|.
name|append
argument_list|(
literal|".."
operator|+
name|selection
index|[
name|i
operator|-
literal|2
index|]
argument_list|)
expr_stmt|;
block|}
name|firstIndex
operator|=
name|i
operator|-
literal|1
expr_stmt|;
name|firstValue
operator|=
name|newValue
expr_stmt|;
continue|continue;
block|}
block|}
else|else
block|{
if|if
condition|(
name|duplicates
condition|)
block|{
name|int
name|numDuplicates
init|=
name|i
operator|-
name|firstIndex
decl_stmt|;
if|if
condition|(
name|firstIndex
operator|>
literal|0
condition|)
block|{
name|sb
operator|.
name|append
argument_list|(
literal|","
argument_list|)
expr_stmt|;
block|}
name|sb
operator|.
name|append
argument_list|(
name|numDuplicates
operator|+
literal|"*"
operator|+
name|firstValue
argument_list|)
expr_stmt|;
name|duplicates
operator|=
literal|false
expr_stmt|;
name|firstIndex
operator|=
name|i
expr_stmt|;
name|firstValue
operator|=
name|newValue
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|newValue
operator|==
name|selection
index|[
name|i
operator|-
literal|1
index|]
operator|+
literal|1
condition|)
block|{
comment|// Continue range..
continue|continue;
block|}
else|else
block|{
comment|// Prior singleton or range?
name|int
name|priorRangeLength
init|=
name|i
operator|-
name|firstIndex
decl_stmt|;
if|if
condition|(
name|firstIndex
operator|>
literal|0
condition|)
block|{
name|sb
operator|.
name|append
argument_list|(
literal|","
argument_list|)
expr_stmt|;
block|}
name|sb
operator|.
name|append
argument_list|(
name|firstValue
argument_list|)
expr_stmt|;
if|if
condition|(
name|priorRangeLength
operator|>
literal|1
condition|)
block|{
name|sb
operator|.
name|append
argument_list|(
literal|".."
operator|+
name|selection
index|[
name|i
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
name|firstIndex
operator|=
name|i
expr_stmt|;
name|firstValue
operator|=
name|newValue
expr_stmt|;
continue|continue;
block|}
block|}
block|}
if|if
condition|(
name|duplicates
condition|)
block|{
name|int
name|numDuplicates
init|=
name|i
operator|-
name|firstIndex
decl_stmt|;
if|if
condition|(
name|firstIndex
operator|>
literal|0
condition|)
block|{
name|sb
operator|.
name|append
argument_list|(
literal|","
argument_list|)
expr_stmt|;
block|}
name|sb
operator|.
name|append
argument_list|(
name|numDuplicates
operator|+
literal|"*"
operator|+
name|firstValue
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// Last singleton or range?
name|int
name|priorRangeLength
init|=
name|i
operator|-
name|firstIndex
decl_stmt|;
if|if
condition|(
name|firstIndex
operator|>
literal|0
condition|)
block|{
name|sb
operator|.
name|append
argument_list|(
literal|","
argument_list|)
expr_stmt|;
block|}
name|sb
operator|.
name|append
argument_list|(
name|firstValue
argument_list|)
expr_stmt|;
if|if
condition|(
name|priorRangeLength
operator|>
literal|1
condition|)
block|{
name|sb
operator|.
name|append
argument_list|(
literal|".."
operator|+
name|selection
index|[
name|i
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
block|}
name|sb
operator|.
name|append
argument_list|(
literal|"]"
argument_list|)
expr_stmt|;
return|return
name|sb
operator|.
name|toString
argument_list|()
return|;
block|}
block|}
end_class

end_unit

