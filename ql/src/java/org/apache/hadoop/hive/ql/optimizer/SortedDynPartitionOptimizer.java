begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|optimizer
package|;
end_package

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|LinkedHashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Stack
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|metastore
operator|.
name|api
operator|.
name|FieldSchema
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|metastore
operator|.
name|api
operator|.
name|Order
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|ColumnInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|FileSinkOperator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|Operator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|OperatorFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|OperatorUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|ReduceSinkOperator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|RowSchema
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|SelectOperator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|Utilities
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|Utilities
operator|.
name|ReduceField
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|io
operator|.
name|AcidUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|lib
operator|.
name|DefaultGraphWalker
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|lib
operator|.
name|DefaultRuleDispatcher
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|lib
operator|.
name|Dispatcher
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|lib
operator|.
name|GraphWalker
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|lib
operator|.
name|Node
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|lib
operator|.
name|NodeProcessor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|lib
operator|.
name|NodeProcessorCtx
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|lib
operator|.
name|Rule
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|lib
operator|.
name|RuleRegExp
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|metadata
operator|.
name|Table
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|parse
operator|.
name|ParseContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|parse
operator|.
name|SemanticException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|DynamicPartitionCtx
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|ExprNodeColumnDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|ExprNodeConstantDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|ExprNodeDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|ExprNodeGenericFuncDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|FileSinkDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|ListBucketingCtx
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|OperatorDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|PlanUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|ReduceSinkDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|SelectDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|TableDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|typeinfo
operator|.
name|TypeInfoFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Lists
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Maps
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Sets
import|;
end_import

begin_comment
comment|/**  * When dynamic partitioning (with or without bucketing and sorting) is enabled, this optimization  * sorts the records on partition, bucket and sort columns respectively before inserting records  * into the destination table. This enables reducers to keep only one record writer all the time  * thereby reducing the the memory pressure on the reducers.  */
end_comment

begin_class
specifier|public
class|class
name|SortedDynPartitionOptimizer
extends|extends
name|Transform
block|{
specifier|private
specifier|static
specifier|final
name|String
name|BUCKET_NUMBER_COL_NAME
init|=
literal|"_bucket_number"
decl_stmt|;
annotation|@
name|Override
specifier|public
name|ParseContext
name|transform
parameter_list|(
name|ParseContext
name|pCtx
parameter_list|)
throws|throws
name|SemanticException
block|{
comment|// create a walker which walks the tree in a DFS manner while maintaining the
comment|// operator stack. The dispatcher generates the plan from the operator tree
name|Map
argument_list|<
name|Rule
argument_list|,
name|NodeProcessor
argument_list|>
name|opRules
init|=
operator|new
name|LinkedHashMap
argument_list|<
name|Rule
argument_list|,
name|NodeProcessor
argument_list|>
argument_list|()
decl_stmt|;
name|String
name|FS
init|=
name|FileSinkOperator
operator|.
name|getOperatorName
argument_list|()
operator|+
literal|"%"
decl_stmt|;
name|opRules
operator|.
name|put
argument_list|(
operator|new
name|RuleRegExp
argument_list|(
literal|"Sorted Dynamic Partition"
argument_list|,
name|FS
argument_list|)
argument_list|,
name|getSortDynPartProc
argument_list|(
name|pCtx
argument_list|)
argument_list|)
expr_stmt|;
name|Dispatcher
name|disp
init|=
operator|new
name|DefaultRuleDispatcher
argument_list|(
literal|null
argument_list|,
name|opRules
argument_list|,
literal|null
argument_list|)
decl_stmt|;
name|GraphWalker
name|ogw
init|=
operator|new
name|DefaultGraphWalker
argument_list|(
name|disp
argument_list|)
decl_stmt|;
name|ArrayList
argument_list|<
name|Node
argument_list|>
name|topNodes
init|=
operator|new
name|ArrayList
argument_list|<
name|Node
argument_list|>
argument_list|()
decl_stmt|;
name|topNodes
operator|.
name|addAll
argument_list|(
name|pCtx
operator|.
name|getTopOps
argument_list|()
operator|.
name|values
argument_list|()
argument_list|)
expr_stmt|;
name|ogw
operator|.
name|startWalking
argument_list|(
name|topNodes
argument_list|,
literal|null
argument_list|)
expr_stmt|;
return|return
name|pCtx
return|;
block|}
specifier|private
name|NodeProcessor
name|getSortDynPartProc
parameter_list|(
name|ParseContext
name|pCtx
parameter_list|)
block|{
return|return
operator|new
name|SortedDynamicPartitionProc
argument_list|(
name|pCtx
argument_list|)
return|;
block|}
class|class
name|SortedDynamicPartitionProc
implements|implements
name|NodeProcessor
block|{
specifier|private
specifier|final
name|Logger
name|LOG
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|SortedDynPartitionOptimizer
operator|.
name|class
argument_list|)
decl_stmt|;
specifier|protected
name|ParseContext
name|parseCtx
decl_stmt|;
specifier|public
name|SortedDynamicPartitionProc
parameter_list|(
name|ParseContext
name|pCtx
parameter_list|)
block|{
name|this
operator|.
name|parseCtx
operator|=
name|pCtx
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|Object
name|process
parameter_list|(
name|Node
name|nd
parameter_list|,
name|Stack
argument_list|<
name|Node
argument_list|>
name|stack
parameter_list|,
name|NodeProcessorCtx
name|procCtx
parameter_list|,
name|Object
modifier|...
name|nodeOutputs
parameter_list|)
throws|throws
name|SemanticException
block|{
comment|// introduce RS and EX before FS. If the operator tree already contains
comment|// RS then ReduceSinkDeDuplication optimization should merge them
name|FileSinkOperator
name|fsOp
init|=
operator|(
name|FileSinkOperator
operator|)
name|nd
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Sorted dynamic partitioning optimization kicked in.."
argument_list|)
expr_stmt|;
comment|// if not dynamic partitioning then bail out
if|if
condition|(
name|fsOp
operator|.
name|getConf
argument_list|()
operator|.
name|getDynPartCtx
argument_list|()
operator|==
literal|null
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Bailing out of sort dynamic partition optimization as dynamic partitioning context is null"
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
comment|// if list bucketing then bail out
name|ListBucketingCtx
name|lbCtx
init|=
name|fsOp
operator|.
name|getConf
argument_list|()
operator|.
name|getLbCtx
argument_list|()
decl_stmt|;
if|if
condition|(
name|lbCtx
operator|!=
literal|null
operator|&&
operator|!
name|lbCtx
operator|.
name|getSkewedColNames
argument_list|()
operator|.
name|isEmpty
argument_list|()
operator|&&
operator|!
name|lbCtx
operator|.
name|getSkewedColValues
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Bailing out of sort dynamic partition optimization as list bucketing is enabled"
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
name|Table
name|destTable
init|=
name|fsOp
operator|.
name|getConf
argument_list|()
operator|.
name|getTable
argument_list|()
decl_stmt|;
if|if
condition|(
name|destTable
operator|==
literal|null
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Bailing out of sort dynamic partition optimization as destination table is null"
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
comment|// unlink connection between FS and its parent
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
name|fsParent
init|=
name|fsOp
operator|.
name|getParentOperators
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
comment|// if all dp columns got constant folded then disable this optimization
if|if
condition|(
name|allStaticPartitions
argument_list|(
name|fsParent
argument_list|,
name|fsOp
operator|.
name|getConf
argument_list|()
operator|.
name|getDynPartCtx
argument_list|()
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Bailing out of sorted dynamic partition optimizer as all dynamic partition"
operator|+
literal|" columns got constant folded (static partitioning)"
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
comment|// if RS is inserted by enforce bucketing or sorting, we need to remove it
comment|// since ReduceSinkDeDuplication will not merge them to single RS.
comment|// RS inserted by enforce bucketing/sorting will have bucketing column in
comment|// reduce sink key whereas RS inserted by this optimization will have
comment|// partition columns followed by bucket number followed by sort columns in
comment|// the reduce sink key. Since both key columns are not prefix subset
comment|// ReduceSinkDeDuplication will not merge them together resulting in 2 MR jobs.
comment|// To avoid that we will remove the RS (and EX) inserted by enforce bucketing/sorting.
if|if
condition|(
operator|!
name|removeRSInsertedByEnforceBucketing
argument_list|(
name|fsOp
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Bailing out of sort dynamic partition optimization as some partition columns "
operator|+
literal|"got constant folded."
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
comment|// unlink connection between FS and its parent
name|fsParent
operator|=
name|fsOp
operator|.
name|getParentOperators
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|fsParent
operator|.
name|getChildOperators
argument_list|()
operator|.
name|clear
argument_list|()
expr_stmt|;
name|DynamicPartitionCtx
name|dpCtx
init|=
name|fsOp
operator|.
name|getConf
argument_list|()
operator|.
name|getDynPartCtx
argument_list|()
decl_stmt|;
name|int
name|numBuckets
init|=
name|destTable
operator|.
name|getNumBuckets
argument_list|()
decl_stmt|;
comment|// if enforce bucketing/sorting is disabled numBuckets will not be set.
comment|// set the number of buckets here to ensure creation of empty buckets
name|dpCtx
operator|.
name|setNumBuckets
argument_list|(
name|numBuckets
argument_list|)
expr_stmt|;
comment|// Get the positions for partition, bucket and sort columns
name|List
argument_list|<
name|Integer
argument_list|>
name|bucketPositions
init|=
name|getBucketPositions
argument_list|(
name|destTable
operator|.
name|getBucketCols
argument_list|()
argument_list|,
name|destTable
operator|.
name|getCols
argument_list|()
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|Integer
argument_list|>
name|sortPositions
init|=
literal|null
decl_stmt|;
name|List
argument_list|<
name|Integer
argument_list|>
name|sortOrder
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|fsOp
operator|.
name|getConf
argument_list|()
operator|.
name|getWriteType
argument_list|()
operator|==
name|AcidUtils
operator|.
name|Operation
operator|.
name|UPDATE
operator|||
name|fsOp
operator|.
name|getConf
argument_list|()
operator|.
name|getWriteType
argument_list|()
operator|==
name|AcidUtils
operator|.
name|Operation
operator|.
name|DELETE
condition|)
block|{
comment|// When doing updates and deletes we always want to sort on the rowid because the ACID
comment|// reader will expect this sort order when doing reads.  So
comment|// ignore whatever comes from the table and enforce this sort order instead.
name|sortPositions
operator|=
name|Arrays
operator|.
name|asList
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|sortOrder
operator|=
name|Arrays
operator|.
name|asList
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|// 1 means asc, could really use enum here in the thrift if
block|}
else|else
block|{
name|sortPositions
operator|=
name|getSortPositions
argument_list|(
name|destTable
operator|.
name|getSortCols
argument_list|()
argument_list|,
name|destTable
operator|.
name|getCols
argument_list|()
argument_list|)
expr_stmt|;
name|sortOrder
operator|=
name|getSortOrders
argument_list|(
name|destTable
operator|.
name|getSortCols
argument_list|()
argument_list|,
name|destTable
operator|.
name|getCols
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|List
argument_list|<
name|Integer
argument_list|>
name|sortNullOrder
init|=
operator|new
name|ArrayList
argument_list|<
name|Integer
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|order
range|:
name|sortOrder
control|)
block|{
name|sortNullOrder
operator|.
name|add
argument_list|(
name|order
operator|==
literal|1
condition|?
literal|0
else|:
literal|1
argument_list|)
expr_stmt|;
comment|// for asc, nulls first; for desc, nulls last
block|}
name|LOG
operator|.
name|debug
argument_list|(
literal|"Got sort order"
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
range|:
name|sortPositions
control|)
name|LOG
operator|.
name|debug
argument_list|(
literal|"sort position "
operator|+
name|i
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
range|:
name|sortOrder
control|)
name|LOG
operator|.
name|debug
argument_list|(
literal|"sort order "
operator|+
name|i
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
range|:
name|sortNullOrder
control|)
name|LOG
operator|.
name|debug
argument_list|(
literal|"sort null order "
operator|+
name|i
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|Integer
argument_list|>
name|partitionPositions
init|=
name|getPartitionPositions
argument_list|(
name|dpCtx
argument_list|,
name|fsParent
operator|.
name|getSchema
argument_list|()
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|ColumnInfo
argument_list|>
name|colInfos
init|=
name|fsParent
operator|.
name|getSchema
argument_list|()
operator|.
name|getSignature
argument_list|()
decl_stmt|;
name|ArrayList
argument_list|<
name|ExprNodeDesc
argument_list|>
name|bucketColumns
init|=
name|getPositionsToExprNodes
argument_list|(
name|bucketPositions
argument_list|,
name|colInfos
argument_list|)
decl_stmt|;
comment|// update file sink descriptor
name|fsOp
operator|.
name|getConf
argument_list|()
operator|.
name|setMultiFileSpray
argument_list|(
literal|false
argument_list|)
expr_stmt|;
name|fsOp
operator|.
name|getConf
argument_list|()
operator|.
name|setNumFiles
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|fsOp
operator|.
name|getConf
argument_list|()
operator|.
name|setTotalFiles
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|ArrayList
argument_list|<
name|ColumnInfo
argument_list|>
name|parentCols
init|=
name|Lists
operator|.
name|newArrayList
argument_list|(
name|fsParent
operator|.
name|getSchema
argument_list|()
operator|.
name|getSignature
argument_list|()
argument_list|)
decl_stmt|;
name|ArrayList
argument_list|<
name|ExprNodeDesc
argument_list|>
name|allRSCols
init|=
name|Lists
operator|.
name|newArrayList
argument_list|()
decl_stmt|;
for|for
control|(
name|ColumnInfo
name|ci
range|:
name|parentCols
control|)
block|{
name|allRSCols
operator|.
name|add
argument_list|(
operator|new
name|ExprNodeColumnDesc
argument_list|(
name|ci
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// Create ReduceSink operator
name|ReduceSinkOperator
name|rsOp
init|=
name|getReduceSinkOp
argument_list|(
name|partitionPositions
argument_list|,
name|sortPositions
argument_list|,
name|sortOrder
argument_list|,
name|sortNullOrder
argument_list|,
name|allRSCols
argument_list|,
name|bucketColumns
argument_list|,
name|numBuckets
argument_list|,
name|fsParent
argument_list|,
name|fsOp
operator|.
name|getConf
argument_list|()
operator|.
name|getWriteType
argument_list|()
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|ExprNodeDesc
argument_list|>
name|descs
init|=
operator|new
name|ArrayList
argument_list|<
name|ExprNodeDesc
argument_list|>
argument_list|(
name|allRSCols
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|colNames
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
name|String
name|colName
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|allRSCols
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|ExprNodeDesc
name|col
init|=
name|allRSCols
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|colName
operator|=
name|col
operator|.
name|getExprString
argument_list|()
expr_stmt|;
name|colNames
operator|.
name|add
argument_list|(
name|colName
argument_list|)
expr_stmt|;
if|if
condition|(
name|partitionPositions
operator|.
name|contains
argument_list|(
name|i
argument_list|)
operator|||
name|sortPositions
operator|.
name|contains
argument_list|(
name|i
argument_list|)
condition|)
block|{
name|descs
operator|.
name|add
argument_list|(
operator|new
name|ExprNodeColumnDesc
argument_list|(
name|col
operator|.
name|getTypeInfo
argument_list|()
argument_list|,
name|ReduceField
operator|.
name|KEY
operator|.
name|toString
argument_list|()
operator|+
literal|"."
operator|+
name|colName
argument_list|,
literal|null
argument_list|,
literal|false
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|descs
operator|.
name|add
argument_list|(
operator|new
name|ExprNodeColumnDesc
argument_list|(
name|col
operator|.
name|getTypeInfo
argument_list|()
argument_list|,
name|ReduceField
operator|.
name|VALUE
operator|.
name|toString
argument_list|()
operator|+
literal|"."
operator|+
name|colName
argument_list|,
literal|null
argument_list|,
literal|false
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|RowSchema
name|selRS
init|=
operator|new
name|RowSchema
argument_list|(
name|fsParent
operator|.
name|getSchema
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|bucketColumns
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|descs
operator|.
name|add
argument_list|(
operator|new
name|ExprNodeColumnDesc
argument_list|(
name|TypeInfoFactory
operator|.
name|stringTypeInfo
argument_list|,
name|ReduceField
operator|.
name|KEY
operator|.
name|toString
argument_list|()
operator|+
literal|".'"
operator|+
name|BUCKET_NUMBER_COL_NAME
operator|+
literal|"'"
argument_list|,
literal|null
argument_list|,
literal|false
argument_list|)
argument_list|)
expr_stmt|;
name|colNames
operator|.
name|add
argument_list|(
literal|"'"
operator|+
name|BUCKET_NUMBER_COL_NAME
operator|+
literal|"'"
argument_list|)
expr_stmt|;
name|ColumnInfo
name|ci
init|=
operator|new
name|ColumnInfo
argument_list|(
name|BUCKET_NUMBER_COL_NAME
argument_list|,
name|TypeInfoFactory
operator|.
name|stringTypeInfo
argument_list|,
name|selRS
operator|.
name|getSignature
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|getTabAlias
argument_list|()
argument_list|,
literal|true
argument_list|,
literal|true
argument_list|)
decl_stmt|;
name|selRS
operator|.
name|getSignature
argument_list|()
operator|.
name|add
argument_list|(
name|ci
argument_list|)
expr_stmt|;
name|fsParent
operator|.
name|getSchema
argument_list|()
operator|.
name|getSignature
argument_list|()
operator|.
name|add
argument_list|(
name|ci
argument_list|)
expr_stmt|;
block|}
comment|// Create SelectDesc
name|SelectDesc
name|selConf
init|=
operator|new
name|SelectDesc
argument_list|(
name|descs
argument_list|,
name|colNames
argument_list|)
decl_stmt|;
comment|// Create Select Operator
name|SelectOperator
name|selOp
init|=
operator|(
name|SelectOperator
operator|)
name|OperatorFactory
operator|.
name|getAndMakeChild
argument_list|(
name|selConf
argument_list|,
name|selRS
argument_list|,
name|rsOp
argument_list|)
decl_stmt|;
comment|// link SEL to FS
name|fsOp
operator|.
name|getParentOperators
argument_list|()
operator|.
name|clear
argument_list|()
expr_stmt|;
name|fsOp
operator|.
name|getParentOperators
argument_list|()
operator|.
name|add
argument_list|(
name|selOp
argument_list|)
expr_stmt|;
name|selOp
operator|.
name|getChildOperators
argument_list|()
operator|.
name|add
argument_list|(
name|fsOp
argument_list|)
expr_stmt|;
comment|// Set if partition sorted or partition bucket sorted
name|fsOp
operator|.
name|getConf
argument_list|()
operator|.
name|setDpSortState
argument_list|(
name|FileSinkDesc
operator|.
name|DPSortState
operator|.
name|PARTITION_SORTED
argument_list|)
expr_stmt|;
if|if
condition|(
name|bucketColumns
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
name|fsOp
operator|.
name|getConf
argument_list|()
operator|.
name|setDpSortState
argument_list|(
name|FileSinkDesc
operator|.
name|DPSortState
operator|.
name|PARTITION_BUCKET_SORTED
argument_list|)
expr_stmt|;
block|}
comment|// update partition column info in FS descriptor
name|fsOp
operator|.
name|getConf
argument_list|()
operator|.
name|setPartitionCols
argument_list|(
name|rsOp
operator|.
name|getConf
argument_list|()
operator|.
name|getPartitionCols
argument_list|()
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Inserted "
operator|+
name|rsOp
operator|.
name|getOperatorId
argument_list|()
operator|+
literal|" and "
operator|+
name|selOp
operator|.
name|getOperatorId
argument_list|()
operator|+
literal|" as parent of "
operator|+
name|fsOp
operator|.
name|getOperatorId
argument_list|()
operator|+
literal|" and child of "
operator|+
name|fsParent
operator|.
name|getOperatorId
argument_list|()
argument_list|)
expr_stmt|;
name|parseCtx
operator|.
name|setReduceSinkAddedBySortedDynPartition
argument_list|(
literal|true
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
specifier|private
name|boolean
name|allStaticPartitions
parameter_list|(
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
name|op
parameter_list|,
specifier|final
name|DynamicPartitionCtx
name|dynPartCtx
parameter_list|)
block|{
name|int
name|numDpCols
init|=
name|dynPartCtx
operator|.
name|getNumDPCols
argument_list|()
decl_stmt|;
name|int
name|numCols
init|=
name|op
operator|.
name|getSchema
argument_list|()
operator|.
name|getColumnNames
argument_list|()
operator|.
name|size
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|dpCols
init|=
name|op
operator|.
name|getSchema
argument_list|()
operator|.
name|getColumnNames
argument_list|()
operator|.
name|subList
argument_list|(
name|numCols
operator|-
name|numDpCols
argument_list|,
name|numCols
argument_list|)
decl_stmt|;
if|if
condition|(
name|op
operator|.
name|getColumnExprMap
argument_list|()
operator|==
literal|null
condition|)
block|{
comment|// find first operator upstream with valid (non-null) column expression map
for|for
control|(
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
name|parent
range|:
name|op
operator|.
name|getParentOperators
argument_list|()
control|)
block|{
if|if
condition|(
name|parent
operator|.
name|getColumnExprMap
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|op
operator|=
name|parent
expr_stmt|;
break|break;
block|}
block|}
block|}
if|if
condition|(
name|op
operator|.
name|getColumnExprMap
argument_list|()
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|String
name|dpCol
range|:
name|dpCols
control|)
block|{
name|ExprNodeDesc
name|end
init|=
name|findConstantExprOrigin
argument_list|(
name|dpCol
argument_list|,
name|op
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|end
operator|instanceof
name|ExprNodeConstantDesc
operator|)
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
block|}
else|else
block|{
return|return
literal|false
return|;
block|}
return|return
literal|true
return|;
block|}
comment|// Find the constant origin of a certain column if it is originated from a constant
comment|// Otherwise, it returns the expression that originated the column
specifier|private
name|ExprNodeDesc
name|findConstantExprOrigin
parameter_list|(
name|String
name|dpCol
parameter_list|,
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
name|op
parameter_list|)
block|{
name|ExprNodeDesc
name|expr
init|=
name|op
operator|.
name|getColumnExprMap
argument_list|()
operator|.
name|get
argument_list|(
name|dpCol
argument_list|)
decl_stmt|;
name|ExprNodeDesc
name|foldedExpr
decl_stmt|;
comment|// If it is a function, we try to fold it
if|if
condition|(
name|expr
operator|instanceof
name|ExprNodeGenericFuncDesc
condition|)
block|{
name|foldedExpr
operator|=
name|ConstantPropagateProcFactory
operator|.
name|foldExpr
argument_list|(
operator|(
name|ExprNodeGenericFuncDesc
operator|)
name|expr
argument_list|)
expr_stmt|;
if|if
condition|(
name|foldedExpr
operator|==
literal|null
condition|)
block|{
name|foldedExpr
operator|=
name|expr
expr_stmt|;
block|}
block|}
else|else
block|{
name|foldedExpr
operator|=
name|expr
expr_stmt|;
block|}
comment|// If it is a column reference, we will try to resolve it
if|if
condition|(
name|foldedExpr
operator|instanceof
name|ExprNodeColumnDesc
condition|)
block|{
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
name|originOp
init|=
literal|null
decl_stmt|;
for|for
control|(
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
name|parentOp
range|:
name|op
operator|.
name|getParentOperators
argument_list|()
control|)
block|{
if|if
condition|(
name|parentOp
operator|.
name|getColumnExprMap
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|originOp
operator|=
name|parentOp
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|originOp
operator|!=
literal|null
condition|)
block|{
return|return
name|findConstantExprOrigin
argument_list|(
operator|(
operator|(
name|ExprNodeColumnDesc
operator|)
name|foldedExpr
operator|)
operator|.
name|getColumn
argument_list|()
argument_list|,
name|originOp
argument_list|)
return|;
block|}
block|}
comment|// Otherwise, we return the expression
return|return
name|foldedExpr
return|;
block|}
comment|// Remove RS and SEL introduced by enforce bucketing/sorting config
comment|// Convert PARENT -> RS -> SEL -> FS to PARENT -> FS
specifier|private
name|boolean
name|removeRSInsertedByEnforceBucketing
parameter_list|(
name|FileSinkOperator
name|fsOp
parameter_list|)
block|{
name|Set
argument_list|<
name|ReduceSinkOperator
argument_list|>
name|reduceSinks
init|=
name|OperatorUtils
operator|.
name|findOperatorsUpstream
argument_list|(
name|fsOp
argument_list|,
name|ReduceSinkOperator
operator|.
name|class
argument_list|)
decl_stmt|;
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
name|rsToRemove
init|=
literal|null
decl_stmt|;
name|List
argument_list|<
name|ReduceSinkOperator
argument_list|>
name|rsOps
init|=
name|parseCtx
operator|.
name|getReduceSinkOperatorsAddedByEnforceBucketingSorting
argument_list|()
decl_stmt|;
name|boolean
name|found
init|=
literal|false
decl_stmt|;
comment|// iterate through all RS and locate the one introduce by enforce bucketing
for|for
control|(
name|ReduceSinkOperator
name|reduceSink
range|:
name|reduceSinks
control|)
block|{
for|for
control|(
name|ReduceSinkOperator
name|rsOp
range|:
name|rsOps
control|)
block|{
if|if
condition|(
name|reduceSink
operator|.
name|equals
argument_list|(
name|rsOp
argument_list|)
condition|)
block|{
name|rsToRemove
operator|=
name|reduceSink
expr_stmt|;
name|found
operator|=
literal|true
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|found
condition|)
block|{
break|break;
block|}
block|}
comment|// iF RS is found remove it and its child (EX) and connect its parent
comment|// and grand child
if|if
condition|(
name|found
condition|)
block|{
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
name|rsParent
init|=
name|rsToRemove
operator|.
name|getParentOperators
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
name|rsChild
init|=
name|rsToRemove
operator|.
name|getChildOperators
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
name|rsGrandChild
init|=
name|rsChild
operator|.
name|getChildOperators
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|rsChild
operator|instanceof
name|SelectOperator
condition|)
block|{
comment|// if schema size cannot be matched, then it could be because of constant folding
comment|// converting partition column expression to constant expression. The constant
comment|// expression will then get pruned by column pruner since it will not reference to
comment|// any columns.
if|if
condition|(
name|rsParent
operator|.
name|getSchema
argument_list|()
operator|.
name|getSignature
argument_list|()
operator|.
name|size
argument_list|()
operator|!=
name|rsChild
operator|.
name|getSchema
argument_list|()
operator|.
name|getSignature
argument_list|()
operator|.
name|size
argument_list|()
condition|)
block|{
return|return
literal|false
return|;
block|}
name|rsParent
operator|.
name|getChildOperators
argument_list|()
operator|.
name|clear
argument_list|()
expr_stmt|;
name|rsParent
operator|.
name|getChildOperators
argument_list|()
operator|.
name|add
argument_list|(
name|rsGrandChild
argument_list|)
expr_stmt|;
name|rsGrandChild
operator|.
name|getParentOperators
argument_list|()
operator|.
name|clear
argument_list|()
expr_stmt|;
name|rsGrandChild
operator|.
name|getParentOperators
argument_list|()
operator|.
name|add
argument_list|(
name|rsParent
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Removed "
operator|+
name|rsToRemove
operator|.
name|getOperatorId
argument_list|()
operator|+
literal|" and "
operator|+
name|rsChild
operator|.
name|getOperatorId
argument_list|()
operator|+
literal|" as it was introduced by enforce bucketing/sorting."
argument_list|)
expr_stmt|;
block|}
block|}
return|return
literal|true
return|;
block|}
specifier|private
name|List
argument_list|<
name|Integer
argument_list|>
name|getPartitionPositions
parameter_list|(
name|DynamicPartitionCtx
name|dpCtx
parameter_list|,
name|RowSchema
name|schema
parameter_list|)
block|{
name|int
name|numPartCols
init|=
name|dpCtx
operator|.
name|getNumDPCols
argument_list|()
decl_stmt|;
name|int
name|numCols
init|=
name|schema
operator|.
name|getSignature
argument_list|()
operator|.
name|size
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|Integer
argument_list|>
name|partPos
init|=
name|Lists
operator|.
name|newArrayList
argument_list|()
decl_stmt|;
comment|// partition columns will always at the last
for|for
control|(
name|int
name|i
init|=
name|numCols
operator|-
name|numPartCols
init|;
name|i
operator|<
name|numCols
condition|;
name|i
operator|++
control|)
block|{
name|partPos
operator|.
name|add
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
return|return
name|partPos
return|;
block|}
comment|// Get the bucket positions for the table
specifier|private
name|List
argument_list|<
name|Integer
argument_list|>
name|getBucketPositions
parameter_list|(
name|List
argument_list|<
name|String
argument_list|>
name|tabBucketCols
parameter_list|,
name|List
argument_list|<
name|FieldSchema
argument_list|>
name|tabCols
parameter_list|)
block|{
name|List
argument_list|<
name|Integer
argument_list|>
name|posns
init|=
operator|new
name|ArrayList
argument_list|<
name|Integer
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|String
name|bucketCol
range|:
name|tabBucketCols
control|)
block|{
name|int
name|pos
init|=
literal|0
decl_stmt|;
for|for
control|(
name|FieldSchema
name|tabCol
range|:
name|tabCols
control|)
block|{
if|if
condition|(
name|bucketCol
operator|.
name|equals
argument_list|(
name|tabCol
operator|.
name|getName
argument_list|()
argument_list|)
condition|)
block|{
name|posns
operator|.
name|add
argument_list|(
name|pos
argument_list|)
expr_stmt|;
break|break;
block|}
name|pos
operator|++
expr_stmt|;
block|}
block|}
return|return
name|posns
return|;
block|}
specifier|public
name|ReduceSinkOperator
name|getReduceSinkOp
parameter_list|(
name|List
argument_list|<
name|Integer
argument_list|>
name|partitionPositions
parameter_list|,
name|List
argument_list|<
name|Integer
argument_list|>
name|sortPositions
parameter_list|,
name|List
argument_list|<
name|Integer
argument_list|>
name|sortOrder
parameter_list|,
name|List
argument_list|<
name|Integer
argument_list|>
name|sortNullOrder
parameter_list|,
name|ArrayList
argument_list|<
name|ExprNodeDesc
argument_list|>
name|allCols
parameter_list|,
name|ArrayList
argument_list|<
name|ExprNodeDesc
argument_list|>
name|bucketColumns
parameter_list|,
name|int
name|numBuckets
parameter_list|,
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
name|parent
parameter_list|,
name|AcidUtils
operator|.
name|Operation
name|writeType
parameter_list|)
throws|throws
name|SemanticException
block|{
comment|// Order of KEY columns
comment|// 1) Partition columns
comment|// 2) Bucket number column
comment|// 3) Sort columns
comment|// 4) Null sort columns
name|Set
argument_list|<
name|Integer
argument_list|>
name|keyColsPosInVal
init|=
name|Sets
operator|.
name|newLinkedHashSet
argument_list|()
decl_stmt|;
name|ArrayList
argument_list|<
name|ExprNodeDesc
argument_list|>
name|keyCols
init|=
name|Lists
operator|.
name|newArrayList
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|Integer
argument_list|>
name|newSortOrder
init|=
name|Lists
operator|.
name|newArrayList
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|Integer
argument_list|>
name|newSortNullOrder
init|=
name|Lists
operator|.
name|newArrayList
argument_list|()
decl_stmt|;
name|int
name|numPartAndBuck
init|=
name|partitionPositions
operator|.
name|size
argument_list|()
decl_stmt|;
name|keyColsPosInVal
operator|.
name|addAll
argument_list|(
name|partitionPositions
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bucketColumns
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|keyColsPosInVal
operator|.
name|add
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
name|numPartAndBuck
operator|+=
literal|1
expr_stmt|;
block|}
name|keyColsPosInVal
operator|.
name|addAll
argument_list|(
name|sortPositions
argument_list|)
expr_stmt|;
comment|// by default partition and bucket columns are sorted in ascending order
name|Integer
name|order
init|=
literal|1
decl_stmt|;
if|if
condition|(
name|sortOrder
operator|!=
literal|null
operator|&&
operator|!
name|sortOrder
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
if|if
condition|(
name|sortOrder
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|intValue
argument_list|()
operator|==
literal|0
condition|)
block|{
name|order
operator|=
literal|0
expr_stmt|;
block|}
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numPartAndBuck
condition|;
name|i
operator|++
control|)
block|{
name|newSortOrder
operator|.
name|add
argument_list|(
name|order
argument_list|)
expr_stmt|;
block|}
name|newSortOrder
operator|.
name|addAll
argument_list|(
name|sortOrder
argument_list|)
expr_stmt|;
name|String
name|orderStr
init|=
literal|""
decl_stmt|;
for|for
control|(
name|Integer
name|i
range|:
name|newSortOrder
control|)
block|{
if|if
condition|(
name|i
operator|.
name|intValue
argument_list|()
operator|==
literal|1
condition|)
block|{
name|orderStr
operator|+=
literal|"+"
expr_stmt|;
block|}
else|else
block|{
name|orderStr
operator|+=
literal|"-"
expr_stmt|;
block|}
block|}
comment|// if partition and bucket columns are sorted in ascending order, by default
comment|// nulls come first; otherwise nulls come last
name|Integer
name|nullOrder
init|=
name|order
operator|==
literal|1
condition|?
literal|0
else|:
literal|1
decl_stmt|;
if|if
condition|(
name|sortNullOrder
operator|!=
literal|null
operator|&&
operator|!
name|sortNullOrder
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
if|if
condition|(
name|sortNullOrder
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|intValue
argument_list|()
operator|==
literal|0
condition|)
block|{
name|nullOrder
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|nullOrder
operator|=
literal|1
expr_stmt|;
block|}
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numPartAndBuck
condition|;
name|i
operator|++
control|)
block|{
name|newSortNullOrder
operator|.
name|add
argument_list|(
name|nullOrder
argument_list|)
expr_stmt|;
block|}
name|newSortNullOrder
operator|.
name|addAll
argument_list|(
name|sortNullOrder
argument_list|)
expr_stmt|;
name|String
name|nullOrderStr
init|=
literal|""
decl_stmt|;
for|for
control|(
name|Integer
name|i
range|:
name|newSortNullOrder
control|)
block|{
if|if
condition|(
name|i
operator|.
name|intValue
argument_list|()
operator|==
literal|0
condition|)
block|{
name|nullOrderStr
operator|+=
literal|"a"
expr_stmt|;
block|}
else|else
block|{
name|nullOrderStr
operator|+=
literal|"z"
expr_stmt|;
block|}
block|}
name|Map
argument_list|<
name|String
argument_list|,
name|ExprNodeDesc
argument_list|>
name|colExprMap
init|=
name|Maps
operator|.
name|newHashMap
argument_list|()
decl_stmt|;
name|ArrayList
argument_list|<
name|ExprNodeDesc
argument_list|>
name|partCols
init|=
name|Lists
operator|.
name|newArrayList
argument_list|()
decl_stmt|;
comment|// we will clone here as RS will update bucket column key with its
comment|// corresponding with bucket number and hence their OIs
for|for
control|(
name|Integer
name|idx
range|:
name|keyColsPosInVal
control|)
block|{
if|if
condition|(
name|idx
operator|<
literal|0
condition|)
block|{
name|ExprNodeConstantDesc
name|bucketNumCol
init|=
operator|new
name|ExprNodeConstantDesc
argument_list|(
name|TypeInfoFactory
operator|.
name|stringTypeInfo
argument_list|,
name|BUCKET_NUMBER_COL_NAME
argument_list|)
decl_stmt|;
name|keyCols
operator|.
name|add
argument_list|(
name|bucketNumCol
argument_list|)
expr_stmt|;
name|colExprMap
operator|.
name|put
argument_list|(
name|Utilities
operator|.
name|ReduceField
operator|.
name|KEY
operator|+
literal|".'"
operator|+
name|BUCKET_NUMBER_COL_NAME
operator|+
literal|"'"
argument_list|,
name|bucketNumCol
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|keyCols
operator|.
name|add
argument_list|(
name|allCols
operator|.
name|get
argument_list|(
name|idx
argument_list|)
operator|.
name|clone
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
name|ArrayList
argument_list|<
name|ExprNodeDesc
argument_list|>
name|valCols
init|=
name|Lists
operator|.
name|newArrayList
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|allCols
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|keyColsPosInVal
operator|.
name|contains
argument_list|(
name|i
argument_list|)
condition|)
block|{
name|valCols
operator|.
name|add
argument_list|(
name|allCols
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|clone
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
name|Integer
name|idx
range|:
name|partitionPositions
control|)
block|{
name|partCols
operator|.
name|add
argument_list|(
name|allCols
operator|.
name|get
argument_list|(
name|idx
argument_list|)
operator|.
name|clone
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// in the absence of SORTED BY clause, the sorted dynamic partition insert
comment|// should honor the ordering of records provided by ORDER BY in SELECT statement
name|ReduceSinkOperator
name|parentRSOp
init|=
name|OperatorUtils
operator|.
name|findSingleOperatorUpstream
argument_list|(
name|parent
argument_list|,
name|ReduceSinkOperator
operator|.
name|class
argument_list|)
decl_stmt|;
if|if
condition|(
name|parentRSOp
operator|!=
literal|null
operator|&&
name|parseCtx
operator|.
name|getQueryProperties
argument_list|()
operator|.
name|hasOuterOrderBy
argument_list|()
condition|)
block|{
name|String
name|parentRSOpOrder
init|=
name|parentRSOp
operator|.
name|getConf
argument_list|()
operator|.
name|getOrder
argument_list|()
decl_stmt|;
name|String
name|parentRSOpNullOrder
init|=
name|parentRSOp
operator|.
name|getConf
argument_list|()
operator|.
name|getNullOrder
argument_list|()
decl_stmt|;
if|if
condition|(
name|parentRSOpOrder
operator|!=
literal|null
operator|&&
operator|!
name|parentRSOpOrder
operator|.
name|isEmpty
argument_list|()
operator|&&
name|sortPositions
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|keyCols
operator|.
name|addAll
argument_list|(
name|parentRSOp
operator|.
name|getConf
argument_list|()
operator|.
name|getKeyCols
argument_list|()
argument_list|)
expr_stmt|;
name|orderStr
operator|+=
name|parentRSOpOrder
expr_stmt|;
name|nullOrderStr
operator|+=
name|parentRSOpNullOrder
expr_stmt|;
block|}
block|}
comment|// map _col0 to KEY._col0, etc
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|nameMapping
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
name|ArrayList
argument_list|<
name|String
argument_list|>
name|keyColNames
init|=
name|Lists
operator|.
name|newArrayList
argument_list|()
decl_stmt|;
for|for
control|(
name|ExprNodeDesc
name|keyCol
range|:
name|keyCols
control|)
block|{
name|String
name|keyColName
init|=
name|keyCol
operator|.
name|getExprString
argument_list|()
decl_stmt|;
name|keyColNames
operator|.
name|add
argument_list|(
name|keyColName
argument_list|)
expr_stmt|;
name|colExprMap
operator|.
name|put
argument_list|(
name|Utilities
operator|.
name|ReduceField
operator|.
name|KEY
operator|+
literal|"."
operator|+
name|keyColName
argument_list|,
name|keyCol
argument_list|)
expr_stmt|;
name|nameMapping
operator|.
name|put
argument_list|(
name|keyColName
argument_list|,
name|Utilities
operator|.
name|ReduceField
operator|.
name|KEY
operator|+
literal|"."
operator|+
name|keyColName
argument_list|)
expr_stmt|;
block|}
name|ArrayList
argument_list|<
name|String
argument_list|>
name|valColNames
init|=
name|Lists
operator|.
name|newArrayList
argument_list|()
decl_stmt|;
for|for
control|(
name|ExprNodeDesc
name|valCol
range|:
name|valCols
control|)
block|{
name|String
name|colName
init|=
name|valCol
operator|.
name|getExprString
argument_list|()
decl_stmt|;
name|valColNames
operator|.
name|add
argument_list|(
name|colName
argument_list|)
expr_stmt|;
name|colExprMap
operator|.
name|put
argument_list|(
name|Utilities
operator|.
name|ReduceField
operator|.
name|VALUE
operator|+
literal|"."
operator|+
name|colName
argument_list|,
name|valCol
argument_list|)
expr_stmt|;
name|nameMapping
operator|.
name|put
argument_list|(
name|colName
argument_list|,
name|Utilities
operator|.
name|ReduceField
operator|.
name|VALUE
operator|+
literal|"."
operator|+
name|colName
argument_list|)
expr_stmt|;
block|}
comment|// Create Key/Value TableDesc. When the operator plan is split into MR tasks,
comment|// the reduce operator will initialize Extract operator with information
comment|// from Key and Value TableDesc
name|List
argument_list|<
name|FieldSchema
argument_list|>
name|fields
init|=
name|PlanUtils
operator|.
name|getFieldSchemasFromColumnList
argument_list|(
name|keyCols
argument_list|,
name|keyColNames
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
decl_stmt|;
name|TableDesc
name|keyTable
init|=
name|PlanUtils
operator|.
name|getReduceKeyTableDesc
argument_list|(
name|fields
argument_list|,
name|orderStr
argument_list|,
name|nullOrderStr
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|FieldSchema
argument_list|>
name|valFields
init|=
name|PlanUtils
operator|.
name|getFieldSchemasFromColumnList
argument_list|(
name|valCols
argument_list|,
name|valColNames
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
decl_stmt|;
name|TableDesc
name|valueTable
init|=
name|PlanUtils
operator|.
name|getReduceValueTableDesc
argument_list|(
name|valFields
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|List
argument_list|<
name|Integer
argument_list|>
argument_list|>
name|distinctColumnIndices
init|=
name|Lists
operator|.
name|newArrayList
argument_list|()
decl_stmt|;
comment|// Number of reducers is set to default (-1)
name|ReduceSinkDesc
name|rsConf
init|=
operator|new
name|ReduceSinkDesc
argument_list|(
name|keyCols
argument_list|,
name|keyCols
operator|.
name|size
argument_list|()
argument_list|,
name|valCols
argument_list|,
name|keyColNames
argument_list|,
name|distinctColumnIndices
argument_list|,
name|valColNames
argument_list|,
operator|-
literal|1
argument_list|,
name|partCols
argument_list|,
operator|-
literal|1
argument_list|,
name|keyTable
argument_list|,
name|valueTable
argument_list|,
name|writeType
argument_list|)
decl_stmt|;
name|rsConf
operator|.
name|setBucketCols
argument_list|(
name|bucketColumns
argument_list|)
expr_stmt|;
name|rsConf
operator|.
name|setNumBuckets
argument_list|(
name|numBuckets
argument_list|)
expr_stmt|;
name|ArrayList
argument_list|<
name|ColumnInfo
argument_list|>
name|signature
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|index
init|=
literal|0
init|;
name|index
operator|<
name|parent
operator|.
name|getSchema
argument_list|()
operator|.
name|getSignature
argument_list|()
operator|.
name|size
argument_list|()
condition|;
name|index
operator|++
control|)
block|{
name|ColumnInfo
name|colInfo
init|=
operator|new
name|ColumnInfo
argument_list|(
name|parent
operator|.
name|getSchema
argument_list|()
operator|.
name|getSignature
argument_list|()
operator|.
name|get
argument_list|(
name|index
argument_list|)
argument_list|)
decl_stmt|;
name|colInfo
operator|.
name|setInternalName
argument_list|(
name|nameMapping
operator|.
name|get
argument_list|(
name|colInfo
operator|.
name|getInternalName
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|signature
operator|.
name|add
argument_list|(
name|colInfo
argument_list|)
expr_stmt|;
block|}
name|ReduceSinkOperator
name|op
init|=
operator|(
name|ReduceSinkOperator
operator|)
name|OperatorFactory
operator|.
name|getAndMakeChild
argument_list|(
name|rsConf
argument_list|,
operator|new
name|RowSchema
argument_list|(
name|signature
argument_list|)
argument_list|,
name|parent
argument_list|)
decl_stmt|;
name|op
operator|.
name|setColumnExprMap
argument_list|(
name|colExprMap
argument_list|)
expr_stmt|;
return|return
name|op
return|;
block|}
comment|/**      * Get the sort positions for the sort columns      * @param tabSortCols      * @param tabCols      * @return      */
specifier|private
name|List
argument_list|<
name|Integer
argument_list|>
name|getSortPositions
parameter_list|(
name|List
argument_list|<
name|Order
argument_list|>
name|tabSortCols
parameter_list|,
name|List
argument_list|<
name|FieldSchema
argument_list|>
name|tabCols
parameter_list|)
block|{
name|List
argument_list|<
name|Integer
argument_list|>
name|sortPositions
init|=
name|Lists
operator|.
name|newArrayList
argument_list|()
decl_stmt|;
for|for
control|(
name|Order
name|sortCol
range|:
name|tabSortCols
control|)
block|{
name|int
name|pos
init|=
literal|0
decl_stmt|;
for|for
control|(
name|FieldSchema
name|tabCol
range|:
name|tabCols
control|)
block|{
if|if
condition|(
name|sortCol
operator|.
name|getCol
argument_list|()
operator|.
name|equals
argument_list|(
name|tabCol
operator|.
name|getName
argument_list|()
argument_list|)
condition|)
block|{
name|sortPositions
operator|.
name|add
argument_list|(
name|pos
argument_list|)
expr_stmt|;
break|break;
block|}
name|pos
operator|++
expr_stmt|;
block|}
block|}
return|return
name|sortPositions
return|;
block|}
comment|/**      * Get the sort order for the sort columns      * @param tabSortCols      * @param tabCols      * @return      */
specifier|private
name|List
argument_list|<
name|Integer
argument_list|>
name|getSortOrders
parameter_list|(
name|List
argument_list|<
name|Order
argument_list|>
name|tabSortCols
parameter_list|,
name|List
argument_list|<
name|FieldSchema
argument_list|>
name|tabCols
parameter_list|)
block|{
name|List
argument_list|<
name|Integer
argument_list|>
name|sortOrders
init|=
name|Lists
operator|.
name|newArrayList
argument_list|()
decl_stmt|;
for|for
control|(
name|Order
name|sortCol
range|:
name|tabSortCols
control|)
block|{
for|for
control|(
name|FieldSchema
name|tabCol
range|:
name|tabCols
control|)
block|{
if|if
condition|(
name|sortCol
operator|.
name|getCol
argument_list|()
operator|.
name|equals
argument_list|(
name|tabCol
operator|.
name|getName
argument_list|()
argument_list|)
condition|)
block|{
name|sortOrders
operator|.
name|add
argument_list|(
name|sortCol
operator|.
name|getOrder
argument_list|()
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
return|return
name|sortOrders
return|;
block|}
specifier|private
name|ArrayList
argument_list|<
name|ExprNodeDesc
argument_list|>
name|getPositionsToExprNodes
parameter_list|(
name|List
argument_list|<
name|Integer
argument_list|>
name|pos
parameter_list|,
name|List
argument_list|<
name|ColumnInfo
argument_list|>
name|colInfos
parameter_list|)
block|{
name|ArrayList
argument_list|<
name|ExprNodeDesc
argument_list|>
name|cols
init|=
name|Lists
operator|.
name|newArrayList
argument_list|()
decl_stmt|;
for|for
control|(
name|Integer
name|idx
range|:
name|pos
control|)
block|{
name|ColumnInfo
name|ci
init|=
name|colInfos
operator|.
name|get
argument_list|(
name|idx
argument_list|)
decl_stmt|;
name|ExprNodeColumnDesc
name|encd
init|=
operator|new
name|ExprNodeColumnDesc
argument_list|(
name|ci
argument_list|)
decl_stmt|;
name|cols
operator|.
name|add
argument_list|(
name|encd
argument_list|)
expr_stmt|;
block|}
return|return
name|cols
return|;
block|}
block|}
block|}
end_class

end_unit

