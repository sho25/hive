begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|optimizer
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|Serializable
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|LinkedHashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Stack
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|Log
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|LogFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|common
operator|.
name|ObjectPair
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|conf
operator|.
name|HiveConf
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|conf
operator|.
name|HiveConf
operator|.
name|ConfVars
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|metastore
operator|.
name|api
operator|.
name|FieldSchema
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|metastore
operator|.
name|api
operator|.
name|Order
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|ColumnInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|ExtractOperator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|FileSinkOperator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|Operator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|OperatorFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|OperatorUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|ReduceSinkOperator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|RowSchema
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|Utilities
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|io
operator|.
name|AcidUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|lib
operator|.
name|DefaultGraphWalker
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|lib
operator|.
name|DefaultRuleDispatcher
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|lib
operator|.
name|Dispatcher
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|lib
operator|.
name|GraphWalker
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|lib
operator|.
name|Node
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|lib
operator|.
name|NodeProcessor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|lib
operator|.
name|NodeProcessorCtx
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|lib
operator|.
name|Rule
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|lib
operator|.
name|RuleRegExp
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|metadata
operator|.
name|Table
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|parse
operator|.
name|OpParseContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|parse
operator|.
name|ParseContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|parse
operator|.
name|RowResolver
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|parse
operator|.
name|SemanticAnalyzer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|parse
operator|.
name|SemanticException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|DynamicPartitionCtx
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|ExprNodeColumnDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|ExprNodeConstantDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|ExprNodeDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|ExtractDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|FileSinkDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|ListBucketingCtx
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|OperatorDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|PlanUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|ReduceSinkDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|TableDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|typeinfo
operator|.
name|TypeInfoFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|IntWritable
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Lists
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Maps
import|;
end_import

begin_comment
comment|/**  * When dynamic partitioning (with or without bucketing and sorting) is enabled, this optimization  * sorts the records on partition, bucket and sort columns respectively before inserting records  * into the destination table. This enables reducers to keep only one record writer all the time  * thereby reducing the the memory pressure on the reducers. This optimization will force a reducer  * even when hive.enforce.bucketing and hive.enforce.sorting is set to false.  */
end_comment

begin_class
specifier|public
class|class
name|SortedDynPartitionOptimizer
implements|implements
name|Transform
block|{
annotation|@
name|Override
specifier|public
name|ParseContext
name|transform
parameter_list|(
name|ParseContext
name|pCtx
parameter_list|)
throws|throws
name|SemanticException
block|{
comment|// create a walker which walks the tree in a DFS manner while maintaining the
comment|// operator stack. The dispatcher generates the plan from the operator tree
name|Map
argument_list|<
name|Rule
argument_list|,
name|NodeProcessor
argument_list|>
name|opRules
init|=
operator|new
name|LinkedHashMap
argument_list|<
name|Rule
argument_list|,
name|NodeProcessor
argument_list|>
argument_list|()
decl_stmt|;
name|String
name|FS
init|=
name|FileSinkOperator
operator|.
name|getOperatorName
argument_list|()
operator|+
literal|"%"
decl_stmt|;
name|opRules
operator|.
name|put
argument_list|(
operator|new
name|RuleRegExp
argument_list|(
literal|"Sorted Dynamic Partition"
argument_list|,
name|FS
argument_list|)
argument_list|,
name|getSortDynPartProc
argument_list|(
name|pCtx
argument_list|)
argument_list|)
expr_stmt|;
name|Dispatcher
name|disp
init|=
operator|new
name|DefaultRuleDispatcher
argument_list|(
literal|null
argument_list|,
name|opRules
argument_list|,
literal|null
argument_list|)
decl_stmt|;
name|GraphWalker
name|ogw
init|=
operator|new
name|DefaultGraphWalker
argument_list|(
name|disp
argument_list|)
decl_stmt|;
name|ArrayList
argument_list|<
name|Node
argument_list|>
name|topNodes
init|=
operator|new
name|ArrayList
argument_list|<
name|Node
argument_list|>
argument_list|()
decl_stmt|;
name|topNodes
operator|.
name|addAll
argument_list|(
name|pCtx
operator|.
name|getTopOps
argument_list|()
operator|.
name|values
argument_list|()
argument_list|)
expr_stmt|;
name|ogw
operator|.
name|startWalking
argument_list|(
name|topNodes
argument_list|,
literal|null
argument_list|)
expr_stmt|;
return|return
name|pCtx
return|;
block|}
specifier|private
name|NodeProcessor
name|getSortDynPartProc
parameter_list|(
name|ParseContext
name|pCtx
parameter_list|)
block|{
return|return
operator|new
name|SortedDynamicPartitionProc
argument_list|(
name|pCtx
argument_list|)
return|;
block|}
class|class
name|SortedDynamicPartitionProc
implements|implements
name|NodeProcessor
block|{
specifier|private
specifier|final
name|Log
name|LOG
init|=
name|LogFactory
operator|.
name|getLog
argument_list|(
name|SortedDynPartitionOptimizer
operator|.
name|class
argument_list|)
decl_stmt|;
specifier|protected
name|ParseContext
name|parseCtx
decl_stmt|;
specifier|public
name|SortedDynamicPartitionProc
parameter_list|(
name|ParseContext
name|pCtx
parameter_list|)
block|{
name|this
operator|.
name|parseCtx
operator|=
name|pCtx
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|Object
name|process
parameter_list|(
name|Node
name|nd
parameter_list|,
name|Stack
argument_list|<
name|Node
argument_list|>
name|stack
parameter_list|,
name|NodeProcessorCtx
name|procCtx
parameter_list|,
name|Object
modifier|...
name|nodeOutputs
parameter_list|)
throws|throws
name|SemanticException
block|{
comment|// introduce RS and EX before FS. If the operator tree already contains
comment|// RS then ReduceSinkDeDuplication optimization should merge them
name|FileSinkOperator
name|fsOp
init|=
operator|(
name|FileSinkOperator
operator|)
name|nd
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Sorted dynamic partitioning optimization kicked in.."
argument_list|)
expr_stmt|;
comment|// if not dynamic partitioning then bail out
if|if
condition|(
name|fsOp
operator|.
name|getConf
argument_list|()
operator|.
name|getDynPartCtx
argument_list|()
operator|==
literal|null
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Bailing out of sort dynamic partition optimization as dynamic partitioning context is null"
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
comment|// if list bucketing then bail out
name|ListBucketingCtx
name|lbCtx
init|=
name|fsOp
operator|.
name|getConf
argument_list|()
operator|.
name|getLbCtx
argument_list|()
decl_stmt|;
if|if
condition|(
name|lbCtx
operator|!=
literal|null
operator|&&
operator|!
name|lbCtx
operator|.
name|getSkewedColNames
argument_list|()
operator|.
name|isEmpty
argument_list|()
operator|&&
operator|!
name|lbCtx
operator|.
name|getSkewedColValues
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Bailing out of sort dynamic partition optimization as list bucketing is enabled"
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
name|Table
name|destTable
init|=
name|parseCtx
operator|.
name|getFsopToTable
argument_list|()
operator|.
name|get
argument_list|(
name|fsOp
argument_list|)
decl_stmt|;
if|if
condition|(
name|destTable
operator|==
literal|null
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Bailing out of sort dynamic partition optimization as destination table is null"
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
comment|// if RS is inserted by enforce bucketing or sorting, we need to remove it
comment|// since ReduceSinkDeDuplication will not merge them to single RS.
comment|// RS inserted by enforce bucketing/sorting will have bucketing column in
comment|// reduce sink key whereas RS inserted by this optimization will have
comment|// partition columns followed by bucket number followed by sort columns in
comment|// the reduce sink key. Since both key columns are not prefix subset
comment|// ReduceSinkDeDuplication will not merge them together resulting in 2 MR jobs.
comment|// To avoid that we will remove the RS (and EX) inserted by enforce bucketing/sorting.
name|removeRSInsertedByEnforceBucketing
argument_list|(
name|fsOp
argument_list|)
expr_stmt|;
comment|// unlink connection between FS and its parent
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
name|fsParent
init|=
name|fsOp
operator|.
name|getParentOperators
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|fsParent
operator|.
name|getChildOperators
argument_list|()
operator|.
name|clear
argument_list|()
expr_stmt|;
name|DynamicPartitionCtx
name|dpCtx
init|=
name|fsOp
operator|.
name|getConf
argument_list|()
operator|.
name|getDynPartCtx
argument_list|()
decl_stmt|;
name|int
name|numBuckets
init|=
name|destTable
operator|.
name|getNumBuckets
argument_list|()
decl_stmt|;
comment|// if enforce bucketing/sorting is disabled numBuckets will not be set.
comment|// set the number of buckets here to ensure creation of empty buckets
name|dpCtx
operator|.
name|setNumBuckets
argument_list|(
name|numBuckets
argument_list|)
expr_stmt|;
comment|// Get the positions for partition, bucket and sort columns
name|List
argument_list|<
name|Integer
argument_list|>
name|bucketPositions
init|=
name|getBucketPositions
argument_list|(
name|destTable
operator|.
name|getBucketCols
argument_list|()
argument_list|,
name|destTable
operator|.
name|getCols
argument_list|()
argument_list|)
decl_stmt|;
name|ObjectPair
argument_list|<
name|List
argument_list|<
name|Integer
argument_list|>
argument_list|,
name|List
argument_list|<
name|Integer
argument_list|>
argument_list|>
name|sortOrderPositions
init|=
name|getSortPositionsOrder
argument_list|(
name|destTable
operator|.
name|getSortCols
argument_list|()
argument_list|,
name|destTable
operator|.
name|getCols
argument_list|()
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|Integer
argument_list|>
name|sortPositions
init|=
literal|null
decl_stmt|;
name|List
argument_list|<
name|Integer
argument_list|>
name|sortOrder
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|fsOp
operator|.
name|getConf
argument_list|()
operator|.
name|getWriteType
argument_list|()
operator|==
name|AcidUtils
operator|.
name|Operation
operator|.
name|UPDATE
operator|||
name|fsOp
operator|.
name|getConf
argument_list|()
operator|.
name|getWriteType
argument_list|()
operator|==
name|AcidUtils
operator|.
name|Operation
operator|.
name|DELETE
condition|)
block|{
comment|// When doing updates and deletes we always want to sort on the rowid because the ACID
comment|// reader will expect this sort order when doing reads.  So
comment|// ignore whatever comes from the table and enforce this sort order instead.
name|sortPositions
operator|=
name|Arrays
operator|.
name|asList
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|sortOrder
operator|=
name|Arrays
operator|.
name|asList
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|// 1 means asc, could really use enum here in the thrift if
block|}
else|else
block|{
name|sortPositions
operator|=
name|sortOrderPositions
operator|.
name|getFirst
argument_list|()
expr_stmt|;
name|sortOrder
operator|=
name|sortOrderPositions
operator|.
name|getSecond
argument_list|()
expr_stmt|;
block|}
name|LOG
operator|.
name|debug
argument_list|(
literal|"Got sort order"
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
range|:
name|sortPositions
control|)
name|LOG
operator|.
name|debug
argument_list|(
literal|"sort position "
operator|+
name|i
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
range|:
name|sortOrder
control|)
name|LOG
operator|.
name|debug
argument_list|(
literal|"sort order "
operator|+
name|i
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|Integer
argument_list|>
name|partitionPositions
init|=
name|getPartitionPositions
argument_list|(
name|dpCtx
argument_list|,
name|fsParent
operator|.
name|getSchema
argument_list|()
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|ColumnInfo
argument_list|>
name|colInfos
init|=
name|parseCtx
operator|.
name|getOpParseCtx
argument_list|()
operator|.
name|get
argument_list|(
name|fsParent
argument_list|)
operator|.
name|getRowResolver
argument_list|()
operator|.
name|getColumnInfos
argument_list|()
decl_stmt|;
name|ArrayList
argument_list|<
name|ExprNodeDesc
argument_list|>
name|bucketColumns
init|=
name|getPositionsToExprNodes
argument_list|(
name|bucketPositions
argument_list|,
name|colInfos
argument_list|)
decl_stmt|;
comment|// update file sink descriptor
name|fsOp
operator|.
name|getConf
argument_list|()
operator|.
name|setMultiFileSpray
argument_list|(
literal|false
argument_list|)
expr_stmt|;
name|fsOp
operator|.
name|getConf
argument_list|()
operator|.
name|setNumFiles
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|fsOp
operator|.
name|getConf
argument_list|()
operator|.
name|setTotalFiles
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|// Create ReduceSinkDesc
name|RowResolver
name|inputRR
init|=
name|parseCtx
operator|.
name|getOpParseCtx
argument_list|()
operator|.
name|get
argument_list|(
name|fsParent
argument_list|)
operator|.
name|getRowResolver
argument_list|()
decl_stmt|;
name|ObjectPair
argument_list|<
name|String
argument_list|,
name|RowResolver
argument_list|>
name|pair
init|=
name|copyRowResolver
argument_list|(
name|inputRR
argument_list|)
decl_stmt|;
name|RowResolver
name|outRR
init|=
name|pair
operator|.
name|getSecond
argument_list|()
decl_stmt|;
name|ArrayList
argument_list|<
name|ColumnInfo
argument_list|>
name|valColInfo
init|=
name|Lists
operator|.
name|newArrayList
argument_list|(
name|fsParent
operator|.
name|getSchema
argument_list|()
operator|.
name|getSignature
argument_list|()
argument_list|)
decl_stmt|;
name|ArrayList
argument_list|<
name|ExprNodeDesc
argument_list|>
name|newValueCols
init|=
name|Lists
operator|.
name|newArrayList
argument_list|()
decl_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|ExprNodeDesc
argument_list|>
name|colExprMap
init|=
name|Maps
operator|.
name|newHashMap
argument_list|()
decl_stmt|;
for|for
control|(
name|ColumnInfo
name|ci
range|:
name|valColInfo
control|)
block|{
name|newValueCols
operator|.
name|add
argument_list|(
operator|new
name|ExprNodeColumnDesc
argument_list|(
name|ci
operator|.
name|getType
argument_list|()
argument_list|,
name|ci
operator|.
name|getInternalName
argument_list|()
argument_list|,
name|ci
operator|.
name|getTabAlias
argument_list|()
argument_list|,
name|ci
operator|.
name|isHiddenVirtualCol
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|colExprMap
operator|.
name|put
argument_list|(
name|ci
operator|.
name|getInternalName
argument_list|()
argument_list|,
name|newValueCols
operator|.
name|get
argument_list|(
name|newValueCols
operator|.
name|size
argument_list|()
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|ReduceSinkDesc
name|rsConf
init|=
name|getReduceSinkDesc
argument_list|(
name|partitionPositions
argument_list|,
name|sortPositions
argument_list|,
name|sortOrder
argument_list|,
name|newValueCols
argument_list|,
name|bucketColumns
argument_list|,
name|numBuckets
argument_list|,
name|fsParent
argument_list|,
name|fsOp
operator|.
name|getConf
argument_list|()
operator|.
name|getWriteType
argument_list|()
argument_list|)
decl_stmt|;
comment|// Create ReduceSink operator
name|ReduceSinkOperator
name|rsOp
init|=
operator|(
name|ReduceSinkOperator
operator|)
name|putOpInsertMap
argument_list|(
name|OperatorFactory
operator|.
name|getAndMakeChild
argument_list|(
name|rsConf
argument_list|,
operator|new
name|RowSchema
argument_list|(
name|outRR
operator|.
name|getColumnInfos
argument_list|()
argument_list|)
argument_list|,
name|fsParent
argument_list|)
argument_list|,
name|outRR
argument_list|,
name|parseCtx
argument_list|)
decl_stmt|;
name|rsOp
operator|.
name|setColumnExprMap
argument_list|(
name|colExprMap
argument_list|)
expr_stmt|;
comment|// Create ExtractDesc
name|ObjectPair
argument_list|<
name|String
argument_list|,
name|RowResolver
argument_list|>
name|exPair
init|=
name|copyRowResolver
argument_list|(
name|outRR
argument_list|)
decl_stmt|;
name|RowResolver
name|exRR
init|=
name|exPair
operator|.
name|getSecond
argument_list|()
decl_stmt|;
name|ExtractDesc
name|exConf
init|=
operator|new
name|ExtractDesc
argument_list|(
operator|new
name|ExprNodeColumnDesc
argument_list|(
name|TypeInfoFactory
operator|.
name|stringTypeInfo
argument_list|,
name|Utilities
operator|.
name|ReduceField
operator|.
name|VALUE
operator|.
name|toString
argument_list|()
argument_list|,
literal|""
argument_list|,
literal|false
argument_list|)
argument_list|)
decl_stmt|;
comment|// Create Extract Operator
name|ExtractOperator
name|exOp
init|=
operator|(
name|ExtractOperator
operator|)
name|putOpInsertMap
argument_list|(
name|OperatorFactory
operator|.
name|getAndMakeChild
argument_list|(
name|exConf
argument_list|,
operator|new
name|RowSchema
argument_list|(
name|exRR
operator|.
name|getColumnInfos
argument_list|()
argument_list|)
argument_list|,
name|rsOp
argument_list|)
argument_list|,
name|exRR
argument_list|,
name|parseCtx
argument_list|)
decl_stmt|;
comment|// link EX to FS
name|fsOp
operator|.
name|getParentOperators
argument_list|()
operator|.
name|clear
argument_list|()
expr_stmt|;
name|fsOp
operator|.
name|getParentOperators
argument_list|()
operator|.
name|add
argument_list|(
name|exOp
argument_list|)
expr_stmt|;
name|exOp
operator|.
name|getChildOperators
argument_list|()
operator|.
name|add
argument_list|(
name|fsOp
argument_list|)
expr_stmt|;
comment|// Set if partition sorted or partition bucket sorted
name|fsOp
operator|.
name|getConf
argument_list|()
operator|.
name|setDpSortState
argument_list|(
name|FileSinkDesc
operator|.
name|DPSortState
operator|.
name|PARTITION_SORTED
argument_list|)
expr_stmt|;
if|if
condition|(
name|bucketColumns
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
name|fsOp
operator|.
name|getConf
argument_list|()
operator|.
name|setDpSortState
argument_list|(
name|FileSinkDesc
operator|.
name|DPSortState
operator|.
name|PARTITION_BUCKET_SORTED
argument_list|)
expr_stmt|;
block|}
comment|// update partition column info in FS descriptor
name|ArrayList
argument_list|<
name|ExprNodeDesc
argument_list|>
name|partitionColumns
init|=
name|getPositionsToExprNodes
argument_list|(
name|partitionPositions
argument_list|,
name|rsOp
operator|.
name|getSchema
argument_list|()
operator|.
name|getSignature
argument_list|()
argument_list|)
decl_stmt|;
name|fsOp
operator|.
name|getConf
argument_list|()
operator|.
name|setPartitionCols
argument_list|(
name|partitionColumns
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Inserted "
operator|+
name|rsOp
operator|.
name|getOperatorId
argument_list|()
operator|+
literal|" and "
operator|+
name|exOp
operator|.
name|getOperatorId
argument_list|()
operator|+
literal|" as parent of "
operator|+
name|fsOp
operator|.
name|getOperatorId
argument_list|()
operator|+
literal|" and child of "
operator|+
name|fsParent
operator|.
name|getOperatorId
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
comment|// Remove RS and EX introduced by enforce bucketing/sorting config
comment|// Convert PARENT -> RS -> EX -> FS to PARENT -> FS
specifier|private
name|void
name|removeRSInsertedByEnforceBucketing
parameter_list|(
name|FileSinkOperator
name|fsOp
parameter_list|)
block|{
name|HiveConf
name|hconf
init|=
name|parseCtx
operator|.
name|getConf
argument_list|()
decl_stmt|;
name|boolean
name|enforceBucketing
init|=
name|HiveConf
operator|.
name|getBoolVar
argument_list|(
name|hconf
argument_list|,
name|ConfVars
operator|.
name|HIVEENFORCEBUCKETING
argument_list|)
decl_stmt|;
name|boolean
name|enforceSorting
init|=
name|HiveConf
operator|.
name|getBoolVar
argument_list|(
name|hconf
argument_list|,
name|ConfVars
operator|.
name|HIVEENFORCESORTING
argument_list|)
decl_stmt|;
if|if
condition|(
name|enforceBucketing
operator|||
name|enforceSorting
condition|)
block|{
name|Set
argument_list|<
name|ReduceSinkOperator
argument_list|>
name|reduceSinks
init|=
name|OperatorUtils
operator|.
name|findOperatorsUpstream
argument_list|(
name|fsOp
argument_list|,
name|ReduceSinkOperator
operator|.
name|class
argument_list|)
decl_stmt|;
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
name|rsToRemove
init|=
literal|null
decl_stmt|;
name|List
argument_list|<
name|ReduceSinkOperator
argument_list|>
name|rsOps
init|=
name|parseCtx
operator|.
name|getReduceSinkOperatorsAddedByEnforceBucketingSorting
argument_list|()
decl_stmt|;
name|boolean
name|found
init|=
literal|false
decl_stmt|;
comment|// iterate through all RS and locate the one introduce by enforce bucketing
for|for
control|(
name|ReduceSinkOperator
name|reduceSink
range|:
name|reduceSinks
control|)
block|{
for|for
control|(
name|ReduceSinkOperator
name|rsOp
range|:
name|rsOps
control|)
block|{
if|if
condition|(
name|reduceSink
operator|.
name|equals
argument_list|(
name|rsOp
argument_list|)
condition|)
block|{
name|rsToRemove
operator|=
name|reduceSink
expr_stmt|;
name|found
operator|=
literal|true
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|found
condition|)
block|{
break|break;
block|}
block|}
comment|// iF RS is found remove it and its child (EX) and connect its parent
comment|// and grand child
if|if
condition|(
name|found
condition|)
block|{
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
name|rsParent
init|=
name|rsToRemove
operator|.
name|getParentOperators
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
name|rsChild
init|=
name|rsToRemove
operator|.
name|getChildOperators
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
name|rsGrandChild
init|=
name|rsChild
operator|.
name|getChildOperators
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|rsChild
operator|instanceof
name|ExtractOperator
condition|)
block|{
name|rsParent
operator|.
name|getChildOperators
argument_list|()
operator|.
name|clear
argument_list|()
expr_stmt|;
name|rsParent
operator|.
name|getChildOperators
argument_list|()
operator|.
name|add
argument_list|(
name|rsGrandChild
argument_list|)
expr_stmt|;
name|rsGrandChild
operator|.
name|getParentOperators
argument_list|()
operator|.
name|clear
argument_list|()
expr_stmt|;
name|rsGrandChild
operator|.
name|getParentOperators
argument_list|()
operator|.
name|add
argument_list|(
name|rsParent
argument_list|)
expr_stmt|;
name|parseCtx
operator|.
name|removeOpParseCtx
argument_list|(
name|rsToRemove
argument_list|)
expr_stmt|;
name|parseCtx
operator|.
name|removeOpParseCtx
argument_list|(
name|rsChild
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Removed "
operator|+
name|rsParent
operator|.
name|getOperatorId
argument_list|()
operator|+
literal|" and "
operator|+
name|rsChild
operator|.
name|getOperatorId
argument_list|()
operator|+
literal|" as it was introduced by enforce bucketing/sorting."
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
specifier|private
name|List
argument_list|<
name|Integer
argument_list|>
name|getPartitionPositions
parameter_list|(
name|DynamicPartitionCtx
name|dpCtx
parameter_list|,
name|RowSchema
name|schema
parameter_list|)
block|{
name|int
name|numPartCols
init|=
name|dpCtx
operator|.
name|getNumDPCols
argument_list|()
decl_stmt|;
name|int
name|numCols
init|=
name|schema
operator|.
name|getSignature
argument_list|()
operator|.
name|size
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|Integer
argument_list|>
name|partPos
init|=
name|Lists
operator|.
name|newArrayList
argument_list|()
decl_stmt|;
comment|// partition columns will always at the last
for|for
control|(
name|int
name|i
init|=
name|numCols
operator|-
name|numPartCols
init|;
name|i
operator|<
name|numCols
condition|;
name|i
operator|++
control|)
block|{
name|partPos
operator|.
name|add
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
return|return
name|partPos
return|;
block|}
comment|// Get the bucket positions for the table
specifier|private
name|List
argument_list|<
name|Integer
argument_list|>
name|getBucketPositions
parameter_list|(
name|List
argument_list|<
name|String
argument_list|>
name|tabBucketCols
parameter_list|,
name|List
argument_list|<
name|FieldSchema
argument_list|>
name|tabCols
parameter_list|)
block|{
name|List
argument_list|<
name|Integer
argument_list|>
name|posns
init|=
operator|new
name|ArrayList
argument_list|<
name|Integer
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|String
name|bucketCol
range|:
name|tabBucketCols
control|)
block|{
name|int
name|pos
init|=
literal|0
decl_stmt|;
for|for
control|(
name|FieldSchema
name|tabCol
range|:
name|tabCols
control|)
block|{
if|if
condition|(
name|bucketCol
operator|.
name|equals
argument_list|(
name|tabCol
operator|.
name|getName
argument_list|()
argument_list|)
condition|)
block|{
name|posns
operator|.
name|add
argument_list|(
name|pos
argument_list|)
expr_stmt|;
break|break;
block|}
name|pos
operator|++
expr_stmt|;
block|}
block|}
return|return
name|posns
return|;
block|}
specifier|public
name|ReduceSinkDesc
name|getReduceSinkDesc
parameter_list|(
name|List
argument_list|<
name|Integer
argument_list|>
name|partitionPositions
parameter_list|,
name|List
argument_list|<
name|Integer
argument_list|>
name|sortPositions
parameter_list|,
name|List
argument_list|<
name|Integer
argument_list|>
name|sortOrder
parameter_list|,
name|ArrayList
argument_list|<
name|ExprNodeDesc
argument_list|>
name|newValueCols
parameter_list|,
name|ArrayList
argument_list|<
name|ExprNodeDesc
argument_list|>
name|bucketColumns
parameter_list|,
name|int
name|numBuckets
parameter_list|,
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
name|parent
parameter_list|,
name|AcidUtils
operator|.
name|Operation
name|writeType
parameter_list|)
block|{
comment|// Order of KEY columns
comment|// 1) Partition columns
comment|// 2) Bucket number column
comment|// 3) Sort columns
name|List
argument_list|<
name|Integer
argument_list|>
name|keyColsPosInVal
init|=
name|Lists
operator|.
name|newArrayList
argument_list|()
decl_stmt|;
name|ArrayList
argument_list|<
name|ExprNodeDesc
argument_list|>
name|newKeyCols
init|=
name|Lists
operator|.
name|newArrayList
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|Integer
argument_list|>
name|newSortOrder
init|=
name|Lists
operator|.
name|newArrayList
argument_list|()
decl_stmt|;
name|int
name|numPartAndBuck
init|=
name|partitionPositions
operator|.
name|size
argument_list|()
decl_stmt|;
name|keyColsPosInVal
operator|.
name|addAll
argument_list|(
name|partitionPositions
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bucketColumns
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|keyColsPosInVal
operator|.
name|add
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
name|numPartAndBuck
operator|+=
literal|1
expr_stmt|;
block|}
name|keyColsPosInVal
operator|.
name|addAll
argument_list|(
name|sortPositions
argument_list|)
expr_stmt|;
comment|// by default partition and bucket columns are sorted in ascending order
name|Integer
name|order
init|=
literal|1
decl_stmt|;
if|if
condition|(
name|sortOrder
operator|!=
literal|null
operator|&&
operator|!
name|sortOrder
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
if|if
condition|(
name|sortOrder
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|intValue
argument_list|()
operator|==
literal|0
condition|)
block|{
name|order
operator|=
literal|0
expr_stmt|;
block|}
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numPartAndBuck
condition|;
name|i
operator|++
control|)
block|{
name|newSortOrder
operator|.
name|add
argument_list|(
name|order
argument_list|)
expr_stmt|;
block|}
name|newSortOrder
operator|.
name|addAll
argument_list|(
name|sortOrder
argument_list|)
expr_stmt|;
name|String
name|orderStr
init|=
literal|""
decl_stmt|;
for|for
control|(
name|Integer
name|i
range|:
name|newSortOrder
control|)
block|{
if|if
condition|(
name|i
operator|.
name|intValue
argument_list|()
operator|==
literal|1
condition|)
block|{
name|orderStr
operator|+=
literal|"+"
expr_stmt|;
block|}
else|else
block|{
name|orderStr
operator|+=
literal|"-"
expr_stmt|;
block|}
block|}
name|ArrayList
argument_list|<
name|ExprNodeDesc
argument_list|>
name|newPartCols
init|=
name|Lists
operator|.
name|newArrayList
argument_list|()
decl_stmt|;
comment|// we will clone here as RS will update bucket column key with its
comment|// corresponding with bucket number and hence their OIs
for|for
control|(
name|Integer
name|idx
range|:
name|keyColsPosInVal
control|)
block|{
if|if
condition|(
name|idx
operator|<
literal|0
condition|)
block|{
name|newKeyCols
operator|.
name|add
argument_list|(
operator|new
name|ExprNodeConstantDesc
argument_list|(
name|TypeInfoFactory
operator|.
name|getPrimitiveTypeInfoFromPrimitiveWritable
argument_list|(
name|IntWritable
operator|.
name|class
argument_list|)
argument_list|,
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|newKeyCols
operator|.
name|add
argument_list|(
name|newValueCols
operator|.
name|get
argument_list|(
name|idx
argument_list|)
operator|.
name|clone
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
name|Integer
name|idx
range|:
name|partitionPositions
control|)
block|{
name|newPartCols
operator|.
name|add
argument_list|(
name|newValueCols
operator|.
name|get
argument_list|(
name|idx
argument_list|)
operator|.
name|clone
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// in the absence of SORTED BY clause, the sorted dynamic partition insert
comment|// should honor the ordering of records provided by ORDER BY in SELECT statement
name|ReduceSinkOperator
name|parentRSOp
init|=
name|OperatorUtils
operator|.
name|findSingleOperatorUpstream
argument_list|(
name|parent
argument_list|,
name|ReduceSinkOperator
operator|.
name|class
argument_list|)
decl_stmt|;
name|boolean
name|isOrderBy
init|=
name|parseCtx
operator|.
name|getQB
argument_list|()
operator|.
name|getParseInfo
argument_list|()
operator|.
name|getDestToOrderBy
argument_list|()
operator|.
name|size
argument_list|()
operator|>
literal|0
decl_stmt|;
if|if
condition|(
name|parentRSOp
operator|!=
literal|null
operator|&&
name|isOrderBy
condition|)
block|{
name|String
name|parentRSOpOrder
init|=
name|parentRSOp
operator|.
name|getConf
argument_list|()
operator|.
name|getOrder
argument_list|()
decl_stmt|;
if|if
condition|(
name|parentRSOpOrder
operator|!=
literal|null
operator|&&
operator|!
name|parentRSOpOrder
operator|.
name|isEmpty
argument_list|()
operator|&&
name|sortPositions
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|newKeyCols
operator|.
name|addAll
argument_list|(
name|parentRSOp
operator|.
name|getConf
argument_list|()
operator|.
name|getKeyCols
argument_list|()
argument_list|)
expr_stmt|;
name|orderStr
operator|+=
name|parentRSOpOrder
expr_stmt|;
block|}
block|}
comment|// Create Key/Value TableDesc. When the operator plan is split into MR tasks,
comment|// the reduce operator will initialize Extract operator with information
comment|// from Key and Value TableDesc
name|List
argument_list|<
name|FieldSchema
argument_list|>
name|fields
init|=
name|PlanUtils
operator|.
name|getFieldSchemasFromColumnList
argument_list|(
name|newKeyCols
argument_list|,
literal|"reducesinkkey"
argument_list|)
decl_stmt|;
name|TableDesc
name|keyTable
init|=
name|PlanUtils
operator|.
name|getReduceKeyTableDesc
argument_list|(
name|fields
argument_list|,
name|orderStr
argument_list|)
decl_stmt|;
name|ArrayList
argument_list|<
name|String
argument_list|>
name|outputKeyCols
init|=
name|Lists
operator|.
name|newArrayList
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|newKeyCols
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|outputKeyCols
operator|.
name|add
argument_list|(
literal|"reducesinkkey"
operator|+
name|i
argument_list|)
expr_stmt|;
block|}
name|List
argument_list|<
name|String
argument_list|>
name|outCols
init|=
name|Utilities
operator|.
name|getInternalColumnNamesFromSignature
argument_list|(
name|parent
operator|.
name|getSchema
argument_list|()
operator|.
name|getSignature
argument_list|()
argument_list|)
decl_stmt|;
name|ArrayList
argument_list|<
name|String
argument_list|>
name|outValColNames
init|=
name|Lists
operator|.
name|newArrayList
argument_list|(
name|outCols
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|FieldSchema
argument_list|>
name|valFields
init|=
name|PlanUtils
operator|.
name|getFieldSchemasFromColumnList
argument_list|(
name|newValueCols
argument_list|,
name|outValColNames
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
decl_stmt|;
name|TableDesc
name|valueTable
init|=
name|PlanUtils
operator|.
name|getReduceValueTableDesc
argument_list|(
name|valFields
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|List
argument_list|<
name|Integer
argument_list|>
argument_list|>
name|distinctColumnIndices
init|=
name|Lists
operator|.
name|newArrayList
argument_list|()
decl_stmt|;
comment|// Number of reducers is set to default (-1)
name|ReduceSinkDesc
name|rsConf
init|=
operator|new
name|ReduceSinkDesc
argument_list|(
name|newKeyCols
argument_list|,
name|newKeyCols
operator|.
name|size
argument_list|()
argument_list|,
name|newValueCols
argument_list|,
name|outputKeyCols
argument_list|,
name|distinctColumnIndices
argument_list|,
name|outValColNames
argument_list|,
operator|-
literal|1
argument_list|,
name|newPartCols
argument_list|,
operator|-
literal|1
argument_list|,
name|keyTable
argument_list|,
name|valueTable
argument_list|,
name|writeType
argument_list|)
decl_stmt|;
name|rsConf
operator|.
name|setBucketCols
argument_list|(
name|bucketColumns
argument_list|)
expr_stmt|;
name|rsConf
operator|.
name|setNumBuckets
argument_list|(
name|numBuckets
argument_list|)
expr_stmt|;
return|return
name|rsConf
return|;
block|}
comment|/**      * Get the sort positions and sort order for the sort columns      * @param tabSortCols      * @param tabCols      * @return      */
specifier|private
name|ObjectPair
argument_list|<
name|List
argument_list|<
name|Integer
argument_list|>
argument_list|,
name|List
argument_list|<
name|Integer
argument_list|>
argument_list|>
name|getSortPositionsOrder
parameter_list|(
name|List
argument_list|<
name|Order
argument_list|>
name|tabSortCols
parameter_list|,
name|List
argument_list|<
name|FieldSchema
argument_list|>
name|tabCols
parameter_list|)
block|{
name|List
argument_list|<
name|Integer
argument_list|>
name|sortPositions
init|=
name|Lists
operator|.
name|newArrayList
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|Integer
argument_list|>
name|sortOrders
init|=
name|Lists
operator|.
name|newArrayList
argument_list|()
decl_stmt|;
for|for
control|(
name|Order
name|sortCol
range|:
name|tabSortCols
control|)
block|{
name|int
name|pos
init|=
literal|0
decl_stmt|;
for|for
control|(
name|FieldSchema
name|tabCol
range|:
name|tabCols
control|)
block|{
if|if
condition|(
name|sortCol
operator|.
name|getCol
argument_list|()
operator|.
name|equals
argument_list|(
name|tabCol
operator|.
name|getName
argument_list|()
argument_list|)
condition|)
block|{
name|sortPositions
operator|.
name|add
argument_list|(
name|pos
argument_list|)
expr_stmt|;
name|sortOrders
operator|.
name|add
argument_list|(
name|sortCol
operator|.
name|getOrder
argument_list|()
argument_list|)
expr_stmt|;
break|break;
block|}
name|pos
operator|++
expr_stmt|;
block|}
block|}
return|return
operator|new
name|ObjectPair
argument_list|<
name|List
argument_list|<
name|Integer
argument_list|>
argument_list|,
name|List
argument_list|<
name|Integer
argument_list|>
argument_list|>
argument_list|(
name|sortPositions
argument_list|,
name|sortOrders
argument_list|)
return|;
block|}
specifier|private
name|ArrayList
argument_list|<
name|ExprNodeDesc
argument_list|>
name|getPositionsToExprNodes
parameter_list|(
name|List
argument_list|<
name|Integer
argument_list|>
name|pos
parameter_list|,
name|List
argument_list|<
name|ColumnInfo
argument_list|>
name|colInfos
parameter_list|)
block|{
name|ArrayList
argument_list|<
name|ExprNodeDesc
argument_list|>
name|cols
init|=
name|Lists
operator|.
name|newArrayList
argument_list|()
decl_stmt|;
for|for
control|(
name|Integer
name|idx
range|:
name|pos
control|)
block|{
name|ColumnInfo
name|ci
init|=
name|colInfos
operator|.
name|get
argument_list|(
name|idx
argument_list|)
decl_stmt|;
name|ExprNodeColumnDesc
name|encd
init|=
operator|new
name|ExprNodeColumnDesc
argument_list|(
name|ci
operator|.
name|getType
argument_list|()
argument_list|,
name|ci
operator|.
name|getInternalName
argument_list|()
argument_list|,
name|ci
operator|.
name|getTabAlias
argument_list|()
argument_list|,
name|ci
operator|.
name|isHiddenVirtualCol
argument_list|()
argument_list|)
decl_stmt|;
name|cols
operator|.
name|add
argument_list|(
name|encd
argument_list|)
expr_stmt|;
block|}
return|return
name|cols
return|;
block|}
specifier|private
name|Operator
argument_list|<
name|?
extends|extends
name|Serializable
argument_list|>
name|putOpInsertMap
parameter_list|(
name|Operator
argument_list|<
name|?
argument_list|>
name|op
parameter_list|,
name|RowResolver
name|rr
parameter_list|,
name|ParseContext
name|context
parameter_list|)
block|{
name|OpParseContext
name|ctx
init|=
operator|new
name|OpParseContext
argument_list|(
name|rr
argument_list|)
decl_stmt|;
name|context
operator|.
name|getOpParseCtx
argument_list|()
operator|.
name|put
argument_list|(
name|op
argument_list|,
name|ctx
argument_list|)
expr_stmt|;
return|return
name|op
return|;
block|}
specifier|private
name|ObjectPair
argument_list|<
name|String
argument_list|,
name|RowResolver
argument_list|>
name|copyRowResolver
parameter_list|(
name|RowResolver
name|inputRR
parameter_list|)
block|{
name|ObjectPair
argument_list|<
name|String
argument_list|,
name|RowResolver
argument_list|>
name|output
init|=
operator|new
name|ObjectPair
argument_list|<
name|String
argument_list|,
name|RowResolver
argument_list|>
argument_list|()
decl_stmt|;
name|RowResolver
name|outRR
init|=
operator|new
name|RowResolver
argument_list|()
decl_stmt|;
name|int
name|pos
init|=
literal|0
decl_stmt|;
name|String
name|tabAlias
init|=
literal|null
decl_stmt|;
for|for
control|(
name|ColumnInfo
name|colInfo
range|:
name|inputRR
operator|.
name|getColumnInfos
argument_list|()
control|)
block|{
name|String
index|[]
name|info
init|=
name|inputRR
operator|.
name|reverseLookup
argument_list|(
name|colInfo
operator|.
name|getInternalName
argument_list|()
argument_list|)
decl_stmt|;
name|tabAlias
operator|=
name|info
index|[
literal|0
index|]
expr_stmt|;
name|outRR
operator|.
name|put
argument_list|(
name|info
index|[
literal|0
index|]
argument_list|,
name|info
index|[
literal|1
index|]
argument_list|,
operator|new
name|ColumnInfo
argument_list|(
name|SemanticAnalyzer
operator|.
name|getColumnInternalName
argument_list|(
name|pos
argument_list|)
argument_list|,
name|colInfo
operator|.
name|getType
argument_list|()
argument_list|,
name|info
index|[
literal|0
index|]
argument_list|,
name|colInfo
operator|.
name|getIsVirtualCol
argument_list|()
argument_list|,
name|colInfo
operator|.
name|isHiddenVirtualCol
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|pos
operator|++
expr_stmt|;
block|}
name|output
operator|.
name|setFirst
argument_list|(
name|tabAlias
argument_list|)
expr_stmt|;
name|output
operator|.
name|setSecond
argument_list|(
name|outRR
argument_list|)
expr_stmt|;
return|return
name|output
return|;
block|}
block|}
block|}
end_class

end_unit

