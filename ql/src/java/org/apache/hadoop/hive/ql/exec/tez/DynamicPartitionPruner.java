begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|tez
package|;
end_package

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|typeinfo
operator|.
name|PrimitiveTypeInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|ExprNodeColumnDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|ExprNodeGenericFuncDesc
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|DataInputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|InputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|ByteBuffer
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|BlockingQueue
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|LinkedBlockingQueue
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicBoolean
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|VisibleForTesting
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|lang3
operator|.
name|mutable
operator|.
name|MutableInt
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|ExprNodeEvaluator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|ExprNodeEvaluatorFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|metadata
operator|.
name|HiveException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|ExprNodeDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|MapWork
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|PartitionDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|TableDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|Deserializer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|SerDeException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|objectinspector
operator|.
name|ObjectInspector
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|objectinspector
operator|.
name|ObjectInspectorConverters
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|objectinspector
operator|.
name|ObjectInspectorConverters
operator|.
name|Converter
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|objectinspector
operator|.
name|ObjectInspectorFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|objectinspector
operator|.
name|ObjectInspectorUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|objectinspector
operator|.
name|StructField
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|objectinspector
operator|.
name|StructObjectInspector
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|objectinspector
operator|.
name|primitive
operator|.
name|PrimitiveObjectInspectorFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|typeinfo
operator|.
name|TypeInfoFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|BytesWritable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapred
operator|.
name|JobConf
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|ReflectionUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|tez
operator|.
name|dag
operator|.
name|api
operator|.
name|event
operator|.
name|VertexState
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|tez
operator|.
name|runtime
operator|.
name|api
operator|.
name|InputInitializerContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|tez
operator|.
name|runtime
operator|.
name|api
operator|.
name|events
operator|.
name|InputInitializerEvent
import|;
end_import

begin_comment
comment|/**  * DynamicPartitionPruner takes a list of assigned partitions at runtime (split  * generation) and prunes them using events generated during execution of the  * dag.  *  */
end_comment

begin_class
specifier|public
class|class
name|DynamicPartitionPruner
block|{
specifier|private
specifier|static
specifier|final
name|Logger
name|LOG
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|DynamicPartitionPruner
operator|.
name|class
argument_list|)
decl_stmt|;
specifier|private
specifier|final
name|InputInitializerContext
name|context
decl_stmt|;
specifier|private
specifier|final
name|MapWork
name|work
decl_stmt|;
specifier|private
specifier|final
name|JobConf
name|jobConf
decl_stmt|;
specifier|private
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|List
argument_list|<
name|SourceInfo
argument_list|>
argument_list|>
name|sourceInfoMap
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|List
argument_list|<
name|SourceInfo
argument_list|>
argument_list|>
argument_list|()
decl_stmt|;
specifier|private
specifier|final
name|BytesWritable
name|writable
init|=
operator|new
name|BytesWritable
argument_list|()
decl_stmt|;
comment|/* Keeps track of all events that need to be processed - irrespective of the source */
specifier|private
specifier|final
name|BlockingQueue
argument_list|<
name|Object
argument_list|>
name|queue
init|=
operator|new
name|LinkedBlockingQueue
argument_list|<
name|Object
argument_list|>
argument_list|()
decl_stmt|;
comment|/* Keeps track of vertices from which events are expected */
specifier|private
specifier|final
name|Set
argument_list|<
name|String
argument_list|>
name|sourcesWaitingForEvents
init|=
operator|new
name|HashSet
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
comment|// Stores negative values to count columns. Eventually set to #tasks X #columns after the source vertex completes.
specifier|private
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|MutableInt
argument_list|>
name|numExpectedEventsPerSource
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
specifier|private
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|MutableInt
argument_list|>
name|numEventsSeenPerSource
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
specifier|private
name|int
name|sourceInfoCount
init|=
literal|0
decl_stmt|;
specifier|private
specifier|final
name|Object
name|endOfEvents
init|=
operator|new
name|Object
argument_list|()
decl_stmt|;
specifier|private
name|int
name|totalEventCount
init|=
literal|0
decl_stmt|;
specifier|public
name|DynamicPartitionPruner
parameter_list|(
name|InputInitializerContext
name|context
parameter_list|,
name|MapWork
name|work
parameter_list|,
name|JobConf
name|jobConf
parameter_list|)
throws|throws
name|SerDeException
block|{
name|this
operator|.
name|context
operator|=
name|context
expr_stmt|;
name|this
operator|.
name|work
operator|=
name|work
expr_stmt|;
name|this
operator|.
name|jobConf
operator|=
name|jobConf
expr_stmt|;
synchronized|synchronized
init|(
name|this
init|)
block|{
name|initialize
argument_list|()
expr_stmt|;
block|}
block|}
specifier|public
name|void
name|prune
parameter_list|()
throws|throws
name|SerDeException
throws|,
name|IOException
throws|,
name|InterruptedException
throws|,
name|HiveException
block|{
synchronized|synchronized
init|(
name|sourcesWaitingForEvents
init|)
block|{
if|if
condition|(
name|sourcesWaitingForEvents
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return;
block|}
name|Set
argument_list|<
name|VertexState
argument_list|>
name|states
init|=
name|Collections
operator|.
name|singleton
argument_list|(
name|VertexState
operator|.
name|SUCCEEDED
argument_list|)
decl_stmt|;
for|for
control|(
name|String
name|source
range|:
name|sourcesWaitingForEvents
control|)
block|{
comment|// we need to get state transition updates for the vertices that will send
comment|// events to us. once we have received all events and a vertex has succeeded,
comment|// we can move to do the pruning.
name|context
operator|.
name|registerForVertexStateUpdates
argument_list|(
name|source
argument_list|,
name|states
argument_list|)
expr_stmt|;
block|}
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"Waiting for events ("
operator|+
name|sourceInfoCount
operator|+
literal|" sources) ..."
argument_list|)
expr_stmt|;
comment|// synchronous event processing loop. Won't return until all events have
comment|// been processed.
name|this
operator|.
name|processEvents
argument_list|()
expr_stmt|;
name|this
operator|.
name|prunePartitions
argument_list|()
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Ok to proceed."
argument_list|)
expr_stmt|;
block|}
specifier|public
name|BlockingQueue
argument_list|<
name|Object
argument_list|>
name|getQueue
parameter_list|()
block|{
return|return
name|queue
return|;
block|}
specifier|private
name|void
name|clear
parameter_list|()
block|{
name|sourceInfoMap
operator|.
name|clear
argument_list|()
expr_stmt|;
name|sourceInfoCount
operator|=
literal|0
expr_stmt|;
block|}
specifier|private
name|void
name|initialize
parameter_list|()
throws|throws
name|SerDeException
block|{
name|this
operator|.
name|clear
argument_list|()
expr_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|SourceInfo
argument_list|>
name|columnMap
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|SourceInfo
argument_list|>
argument_list|()
decl_stmt|;
comment|// sources represent vertex names
name|Set
argument_list|<
name|String
argument_list|>
name|sources
init|=
name|work
operator|.
name|getEventSourceTableDescMap
argument_list|()
operator|.
name|keySet
argument_list|()
decl_stmt|;
name|sourcesWaitingForEvents
operator|.
name|addAll
argument_list|(
name|sources
argument_list|)
expr_stmt|;
for|for
control|(
name|String
name|s
range|:
name|sources
control|)
block|{
comment|// Set to 0 to start with. This will be decremented for all columns for which events
comment|// are generated by this source - which is eventually used to determine number of expected
comment|// events for the source. #colums X #tasks
name|numExpectedEventsPerSource
operator|.
name|put
argument_list|(
name|s
argument_list|,
operator|new
name|MutableInt
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|numEventsSeenPerSource
operator|.
name|put
argument_list|(
name|s
argument_list|,
operator|new
name|MutableInt
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
comment|// Virtual relation generated by the reduce sync
name|List
argument_list|<
name|TableDesc
argument_list|>
name|tables
init|=
name|work
operator|.
name|getEventSourceTableDescMap
argument_list|()
operator|.
name|get
argument_list|(
name|s
argument_list|)
decl_stmt|;
comment|// Real column name - on which the operation is being performed
name|List
argument_list|<
name|String
argument_list|>
name|columnNames
init|=
name|work
operator|.
name|getEventSourceColumnNameMap
argument_list|()
operator|.
name|get
argument_list|(
name|s
argument_list|)
decl_stmt|;
comment|// Expression for the operation. e.g. N^2> 10
name|List
argument_list|<
name|ExprNodeDesc
argument_list|>
name|partKeyExprs
init|=
name|work
operator|.
name|getEventSourcePartKeyExprMap
argument_list|()
operator|.
name|get
argument_list|(
name|s
argument_list|)
decl_stmt|;
comment|// eventSourceTableDesc, eventSourceColumnName, evenSourcePartKeyExpr move in lock-step.
comment|// One entry is added to each at the same time
name|Iterator
argument_list|<
name|String
argument_list|>
name|cit
init|=
name|columnNames
operator|.
name|iterator
argument_list|()
decl_stmt|;
name|Iterator
argument_list|<
name|ExprNodeDesc
argument_list|>
name|pit
init|=
name|partKeyExprs
operator|.
name|iterator
argument_list|()
decl_stmt|;
comment|// A single source can process multiple columns, and will send an event for each of them.
for|for
control|(
name|TableDesc
name|t
range|:
name|tables
control|)
block|{
name|numExpectedEventsPerSource
operator|.
name|get
argument_list|(
name|s
argument_list|)
operator|.
name|decrement
argument_list|()
expr_stmt|;
operator|++
name|sourceInfoCount
expr_stmt|;
name|String
name|columnName
init|=
name|cit
operator|.
name|next
argument_list|()
decl_stmt|;
name|ExprNodeDesc
name|partKeyExpr
init|=
name|pit
operator|.
name|next
argument_list|()
decl_stmt|;
name|SourceInfo
name|si
init|=
name|createSourceInfo
argument_list|(
name|t
argument_list|,
name|partKeyExpr
argument_list|,
name|columnName
argument_list|,
name|jobConf
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|sourceInfoMap
operator|.
name|containsKey
argument_list|(
name|s
argument_list|)
condition|)
block|{
name|sourceInfoMap
operator|.
name|put
argument_list|(
name|s
argument_list|,
operator|new
name|ArrayList
argument_list|<
name|SourceInfo
argument_list|>
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|List
argument_list|<
name|SourceInfo
argument_list|>
name|sis
init|=
name|sourceInfoMap
operator|.
name|get
argument_list|(
name|s
argument_list|)
decl_stmt|;
name|sis
operator|.
name|add
argument_list|(
name|si
argument_list|)
expr_stmt|;
comment|// We could have multiple sources restrict the same column, need to take
comment|// the union of the values in that case.
if|if
condition|(
name|columnMap
operator|.
name|containsKey
argument_list|(
name|columnName
argument_list|)
condition|)
block|{
comment|// All Sources are initialized up front. Events from different sources will end up getting added to the same list.
comment|// Pruning is disabled if either source sends in an event which causes pruning to be skipped
name|si
operator|.
name|values
operator|=
name|columnMap
operator|.
name|get
argument_list|(
name|columnName
argument_list|)
operator|.
name|values
expr_stmt|;
name|si
operator|.
name|skipPruning
operator|=
name|columnMap
operator|.
name|get
argument_list|(
name|columnName
argument_list|)
operator|.
name|skipPruning
expr_stmt|;
block|}
name|columnMap
operator|.
name|put
argument_list|(
name|columnName
argument_list|,
name|si
argument_list|)
expr_stmt|;
block|}
block|}
block|}
specifier|private
name|void
name|prunePartitions
parameter_list|()
throws|throws
name|HiveException
block|{
name|int
name|expectedEvents
init|=
literal|0
decl_stmt|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|List
argument_list|<
name|SourceInfo
argument_list|>
argument_list|>
name|entry
range|:
name|this
operator|.
name|sourceInfoMap
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|String
name|source
init|=
name|entry
operator|.
name|getKey
argument_list|()
decl_stmt|;
for|for
control|(
name|SourceInfo
name|si
range|:
name|entry
operator|.
name|getValue
argument_list|()
control|)
block|{
name|int
name|taskNum
init|=
name|context
operator|.
name|getVertexNumTasks
argument_list|(
name|source
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Expecting "
operator|+
name|taskNum
operator|+
literal|" events for vertex "
operator|+
name|source
operator|+
literal|", for column "
operator|+
name|si
operator|.
name|columnName
argument_list|)
expr_stmt|;
name|expectedEvents
operator|+=
name|taskNum
expr_stmt|;
name|prunePartitionSingleSource
argument_list|(
name|source
argument_list|,
name|si
argument_list|)
expr_stmt|;
block|}
block|}
comment|// sanity check. all tasks must submit events for us to succeed.
if|if
condition|(
name|expectedEvents
operator|!=
name|totalEventCount
condition|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Expecting: "
operator|+
name|expectedEvents
operator|+
literal|", received: "
operator|+
name|totalEventCount
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|HiveException
argument_list|(
literal|"Incorrect event count in dynamic partition pruning"
argument_list|)
throw|;
block|}
block|}
annotation|@
name|VisibleForTesting
specifier|protected
name|void
name|prunePartitionSingleSource
parameter_list|(
name|String
name|source
parameter_list|,
name|SourceInfo
name|si
parameter_list|)
throws|throws
name|HiveException
block|{
if|if
condition|(
name|si
operator|.
name|skipPruning
operator|.
name|get
argument_list|()
condition|)
block|{
comment|// in this case we've determined that there's too much data
comment|// to prune dynamically.
name|LOG
operator|.
name|info
argument_list|(
literal|"Skip pruning on "
operator|+
name|source
operator|+
literal|", column "
operator|+
name|si
operator|.
name|columnName
argument_list|)
expr_stmt|;
return|return;
block|}
name|Set
argument_list|<
name|Object
argument_list|>
name|values
init|=
name|si
operator|.
name|values
decl_stmt|;
name|String
name|columnName
init|=
name|si
operator|.
name|columnName
decl_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|StringBuilder
name|sb
init|=
operator|new
name|StringBuilder
argument_list|(
literal|"Pruning "
argument_list|)
decl_stmt|;
name|sb
operator|.
name|append
argument_list|(
name|columnName
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|" with "
argument_list|)
expr_stmt|;
for|for
control|(
name|Object
name|value
range|:
name|values
control|)
block|{
name|sb
operator|.
name|append
argument_list|(
name|value
operator|==
literal|null
condition|?
literal|null
else|:
name|value
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|", "
argument_list|)
expr_stmt|;
block|}
name|LOG
operator|.
name|debug
argument_list|(
name|sb
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|ObjectInspector
name|targetOi
init|=
name|findTargetOi
argument_list|(
name|si
operator|.
name|partKey
argument_list|,
name|si
operator|.
name|columnName
argument_list|)
decl_stmt|;
name|Converter
name|converter
init|=
name|ObjectInspectorConverters
operator|.
name|getConverter
argument_list|(
name|PrimitiveObjectInspectorFactory
operator|.
name|javaStringObjectInspector
argument_list|,
name|targetOi
argument_list|)
decl_stmt|;
name|StructObjectInspector
name|soi
init|=
name|ObjectInspectorFactory
operator|.
name|getStandardStructObjectInspector
argument_list|(
name|Collections
operator|.
name|singletonList
argument_list|(
name|columnName
argument_list|)
argument_list|,
name|Collections
operator|.
name|singletonList
argument_list|(
name|targetOi
argument_list|)
argument_list|)
decl_stmt|;
annotation|@
name|SuppressWarnings
argument_list|(
literal|"rawtypes"
argument_list|)
name|ExprNodeEvaluator
name|eval
init|=
name|ExprNodeEvaluatorFactory
operator|.
name|get
argument_list|(
name|si
operator|.
name|partKey
argument_list|)
decl_stmt|;
name|eval
operator|.
name|initialize
argument_list|(
name|soi
argument_list|)
expr_stmt|;
comment|// We expect the row with just the relevant column.
name|applyFilterToPartitions
argument_list|(
name|converter
argument_list|,
name|eval
argument_list|,
name|columnName
argument_list|,
name|values
argument_list|)
expr_stmt|;
block|}
specifier|private
name|ObjectInspector
name|findTargetOi
parameter_list|(
name|ExprNodeDesc
name|expr
parameter_list|,
name|String
name|columnName
parameter_list|)
block|{
if|if
condition|(
name|expr
operator|instanceof
name|ExprNodeColumnDesc
condition|)
block|{
name|ExprNodeColumnDesc
name|colExpr
init|=
operator|(
name|ExprNodeColumnDesc
operator|)
name|expr
decl_stmt|;
comment|// TODO: this is not necessarily going to work for all cases. At least, table name is needed.
comment|//       Also it's not clear if this is going to work with subquery columns and such.
if|if
condition|(
name|columnName
operator|.
name|equals
argument_list|(
name|colExpr
operator|.
name|getColumn
argument_list|()
argument_list|)
condition|)
block|{
return|return
name|PrimitiveObjectInspectorFactory
operator|.
name|getPrimitiveWritableObjectInspector
argument_list|(
operator|(
name|PrimitiveTypeInfo
operator|)
name|colExpr
operator|.
name|getTypeInfo
argument_list|()
argument_list|)
return|;
block|}
block|}
for|for
control|(
name|ExprNodeDesc
name|child
range|:
name|expr
operator|.
name|getChildren
argument_list|()
control|)
block|{
name|ObjectInspector
name|oi
init|=
name|findTargetOi
argument_list|(
name|child
argument_list|,
name|columnName
argument_list|)
decl_stmt|;
if|if
condition|(
name|oi
operator|!=
literal|null
condition|)
return|return
name|oi
return|;
block|}
return|return
literal|null
return|;
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"rawtypes"
argument_list|)
specifier|private
name|void
name|applyFilterToPartitions
parameter_list|(
name|Converter
name|converter
parameter_list|,
name|ExprNodeEvaluator
name|eval
parameter_list|,
name|String
name|columnName
parameter_list|,
name|Set
argument_list|<
name|Object
argument_list|>
name|values
parameter_list|)
throws|throws
name|HiveException
block|{
name|Object
index|[]
name|row
init|=
operator|new
name|Object
index|[
literal|1
index|]
decl_stmt|;
name|Iterator
argument_list|<
name|String
argument_list|>
name|it
init|=
name|work
operator|.
name|getPathToPartitionInfo
argument_list|()
operator|.
name|keySet
argument_list|()
operator|.
name|iterator
argument_list|()
decl_stmt|;
while|while
condition|(
name|it
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|String
name|p
init|=
name|it
operator|.
name|next
argument_list|()
decl_stmt|;
name|PartitionDesc
name|desc
init|=
name|work
operator|.
name|getPathToPartitionInfo
argument_list|()
operator|.
name|get
argument_list|(
name|p
argument_list|)
decl_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|spec
init|=
name|desc
operator|.
name|getPartSpec
argument_list|()
decl_stmt|;
if|if
condition|(
name|spec
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"No partition spec found in dynamic pruning"
argument_list|)
throw|;
block|}
name|String
name|partValueString
init|=
name|spec
operator|.
name|get
argument_list|(
name|columnName
argument_list|)
decl_stmt|;
if|if
condition|(
name|partValueString
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"Could not find partition value for column: "
operator|+
name|columnName
argument_list|)
throw|;
block|}
name|Object
name|partValue
init|=
name|converter
operator|.
name|convert
argument_list|(
name|partValueString
argument_list|)
decl_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Converted partition value: "
operator|+
name|partValue
operator|+
literal|" original ("
operator|+
name|partValueString
operator|+
literal|")"
argument_list|)
expr_stmt|;
block|}
name|row
index|[
literal|0
index|]
operator|=
name|partValue
expr_stmt|;
name|partValue
operator|=
name|eval
operator|.
name|evaluate
argument_list|(
name|row
argument_list|)
expr_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"part key expr applied: "
operator|+
name|partValue
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|values
operator|.
name|contains
argument_list|(
name|partValue
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Pruning path: "
operator|+
name|p
argument_list|)
expr_stmt|;
name|it
operator|.
name|remove
argument_list|()
expr_stmt|;
name|work
operator|.
name|getPathToAliases
argument_list|()
operator|.
name|remove
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|work
operator|.
name|getPaths
argument_list|()
operator|.
name|remove
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|work
operator|.
name|getPartitionDescs
argument_list|()
operator|.
name|remove
argument_list|(
name|desc
argument_list|)
expr_stmt|;
block|}
block|}
block|}
annotation|@
name|VisibleForTesting
specifier|protected
name|SourceInfo
name|createSourceInfo
parameter_list|(
name|TableDesc
name|t
parameter_list|,
name|ExprNodeDesc
name|partKeyExpr
parameter_list|,
name|String
name|columnName
parameter_list|,
name|JobConf
name|jobConf
parameter_list|)
throws|throws
name|SerDeException
block|{
return|return
operator|new
name|SourceInfo
argument_list|(
name|t
argument_list|,
name|partKeyExpr
argument_list|,
name|columnName
argument_list|,
name|jobConf
argument_list|)
return|;
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"deprecation"
argument_list|)
annotation|@
name|VisibleForTesting
specifier|static
class|class
name|SourceInfo
block|{
specifier|public
specifier|final
name|ExprNodeDesc
name|partKey
decl_stmt|;
specifier|public
specifier|final
name|Deserializer
name|deserializer
decl_stmt|;
specifier|public
specifier|final
name|StructObjectInspector
name|soi
decl_stmt|;
specifier|public
specifier|final
name|StructField
name|field
decl_stmt|;
specifier|public
specifier|final
name|ObjectInspector
name|fieldInspector
decl_stmt|;
comment|/* List of partitions that are required - populated from processing each event */
specifier|public
name|Set
argument_list|<
name|Object
argument_list|>
name|values
init|=
operator|new
name|HashSet
argument_list|<
name|Object
argument_list|>
argument_list|()
decl_stmt|;
comment|/* Whether to skipPruning - depends on the payload from an event which may signal skip - if the event payload is too large */
specifier|public
name|AtomicBoolean
name|skipPruning
init|=
operator|new
name|AtomicBoolean
argument_list|()
decl_stmt|;
specifier|public
specifier|final
name|String
name|columnName
decl_stmt|;
annotation|@
name|VisibleForTesting
comment|// Only used for testing.
name|SourceInfo
parameter_list|(
name|TableDesc
name|table
parameter_list|,
name|ExprNodeDesc
name|partKey
parameter_list|,
name|String
name|columnName
parameter_list|,
name|JobConf
name|jobConf
parameter_list|,
name|Object
name|forTesting
parameter_list|)
block|{
name|this
operator|.
name|partKey
operator|=
name|partKey
expr_stmt|;
name|this
operator|.
name|columnName
operator|=
name|columnName
expr_stmt|;
name|this
operator|.
name|deserializer
operator|=
literal|null
expr_stmt|;
name|this
operator|.
name|soi
operator|=
literal|null
expr_stmt|;
name|this
operator|.
name|field
operator|=
literal|null
expr_stmt|;
name|this
operator|.
name|fieldInspector
operator|=
literal|null
expr_stmt|;
block|}
specifier|public
name|SourceInfo
parameter_list|(
name|TableDesc
name|table
parameter_list|,
name|ExprNodeDesc
name|partKey
parameter_list|,
name|String
name|columnName
parameter_list|,
name|JobConf
name|jobConf
parameter_list|)
throws|throws
name|SerDeException
block|{
name|this
operator|.
name|skipPruning
operator|.
name|set
argument_list|(
literal|false
argument_list|)
expr_stmt|;
name|this
operator|.
name|partKey
operator|=
name|partKey
expr_stmt|;
name|this
operator|.
name|columnName
operator|=
name|columnName
expr_stmt|;
name|deserializer
operator|=
name|ReflectionUtils
operator|.
name|newInstance
argument_list|(
name|table
operator|.
name|getDeserializerClass
argument_list|()
argument_list|,
literal|null
argument_list|)
expr_stmt|;
name|deserializer
operator|.
name|initialize
argument_list|(
name|jobConf
argument_list|,
name|table
operator|.
name|getProperties
argument_list|()
argument_list|)
expr_stmt|;
name|ObjectInspector
name|inspector
init|=
name|deserializer
operator|.
name|getObjectInspector
argument_list|()
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Type of obj insp: "
operator|+
name|inspector
operator|.
name|getTypeName
argument_list|()
argument_list|)
expr_stmt|;
name|soi
operator|=
operator|(
name|StructObjectInspector
operator|)
name|inspector
expr_stmt|;
name|List
argument_list|<
name|?
extends|extends
name|StructField
argument_list|>
name|fields
init|=
name|soi
operator|.
name|getAllStructFieldRefs
argument_list|()
decl_stmt|;
if|if
condition|(
name|fields
operator|.
name|size
argument_list|()
operator|>
literal|1
condition|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"expecting single field in input"
argument_list|)
expr_stmt|;
block|}
name|field
operator|=
name|fields
operator|.
name|get
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|fieldInspector
operator|=
name|ObjectInspectorUtils
operator|.
name|getStandardObjectInspector
argument_list|(
name|field
operator|.
name|getFieldObjectInspector
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|processEvents
parameter_list|()
throws|throws
name|SerDeException
throws|,
name|IOException
throws|,
name|InterruptedException
block|{
name|int
name|eventCount
init|=
literal|0
decl_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
name|Object
name|element
init|=
name|queue
operator|.
name|take
argument_list|()
decl_stmt|;
if|if
condition|(
name|element
operator|==
name|endOfEvents
condition|)
block|{
comment|// we're done processing events
break|break;
block|}
name|InputInitializerEvent
name|event
init|=
operator|(
name|InputInitializerEvent
operator|)
name|element
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Input event: "
operator|+
name|event
operator|.
name|getTargetInputName
argument_list|()
operator|+
literal|", "
operator|+
name|event
operator|.
name|getTargetVertexName
argument_list|()
operator|+
literal|", "
operator|+
operator|(
name|event
operator|.
name|getUserPayload
argument_list|()
operator|.
name|limit
argument_list|()
operator|-
name|event
operator|.
name|getUserPayload
argument_list|()
operator|.
name|position
argument_list|()
operator|)
argument_list|)
expr_stmt|;
name|processPayload
argument_list|(
name|event
operator|.
name|getUserPayload
argument_list|()
argument_list|,
name|event
operator|.
name|getSourceVertexName
argument_list|()
argument_list|)
expr_stmt|;
name|eventCount
operator|+=
literal|1
expr_stmt|;
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"Received events: "
operator|+
name|eventCount
argument_list|)
expr_stmt|;
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"deprecation"
argument_list|)
annotation|@
name|VisibleForTesting
specifier|protected
name|String
name|processPayload
parameter_list|(
name|ByteBuffer
name|payload
parameter_list|,
name|String
name|sourceName
parameter_list|)
throws|throws
name|SerDeException
throws|,
name|IOException
block|{
name|DataInputStream
name|in
init|=
operator|new
name|DataInputStream
argument_list|(
operator|new
name|ByteBufferBackedInputStream
argument_list|(
name|payload
argument_list|)
argument_list|)
decl_stmt|;
try|try
block|{
name|String
name|columnName
init|=
name|in
operator|.
name|readUTF
argument_list|()
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Source of event: "
operator|+
name|sourceName
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|SourceInfo
argument_list|>
name|infos
init|=
name|this
operator|.
name|sourceInfoMap
operator|.
name|get
argument_list|(
name|sourceName
argument_list|)
decl_stmt|;
if|if
condition|(
name|infos
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"no source info for event source: "
operator|+
name|sourceName
argument_list|)
throw|;
block|}
name|SourceInfo
name|info
init|=
literal|null
decl_stmt|;
for|for
control|(
name|SourceInfo
name|si
range|:
name|infos
control|)
block|{
if|if
condition|(
name|columnName
operator|.
name|equals
argument_list|(
name|si
operator|.
name|columnName
argument_list|)
condition|)
block|{
name|info
operator|=
name|si
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|info
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"no source info for column: "
operator|+
name|columnName
argument_list|)
throw|;
block|}
if|if
condition|(
name|info
operator|.
name|skipPruning
operator|.
name|get
argument_list|()
condition|)
block|{
comment|// Marked as skipped previously. Don't bother processing the rest of the payload.
block|}
else|else
block|{
name|boolean
name|skip
init|=
name|in
operator|.
name|readBoolean
argument_list|()
decl_stmt|;
if|if
condition|(
name|skip
condition|)
block|{
name|info
operator|.
name|skipPruning
operator|.
name|set
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
else|else
block|{
while|while
condition|(
name|payload
operator|.
name|hasRemaining
argument_list|()
condition|)
block|{
name|writable
operator|.
name|readFields
argument_list|(
name|in
argument_list|)
expr_stmt|;
name|Object
name|row
init|=
name|info
operator|.
name|deserializer
operator|.
name|deserialize
argument_list|(
name|writable
argument_list|)
decl_stmt|;
name|Object
name|value
init|=
name|info
operator|.
name|soi
operator|.
name|getStructFieldData
argument_list|(
name|row
argument_list|,
name|info
operator|.
name|field
argument_list|)
decl_stmt|;
name|value
operator|=
name|ObjectInspectorUtils
operator|.
name|copyToStandardObject
argument_list|(
name|value
argument_list|,
name|info
operator|.
name|fieldInspector
argument_list|)
expr_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Adding: "
operator|+
name|value
operator|+
literal|" to list of required partitions"
argument_list|)
expr_stmt|;
block|}
name|info
operator|.
name|values
operator|.
name|add
argument_list|(
name|value
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
finally|finally
block|{
if|if
condition|(
name|in
operator|!=
literal|null
condition|)
block|{
name|in
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
return|return
name|sourceName
return|;
block|}
specifier|private
specifier|static
class|class
name|ByteBufferBackedInputStream
extends|extends
name|InputStream
block|{
name|ByteBuffer
name|buf
decl_stmt|;
specifier|public
name|ByteBufferBackedInputStream
parameter_list|(
name|ByteBuffer
name|buf
parameter_list|)
block|{
name|this
operator|.
name|buf
operator|=
name|buf
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|int
name|read
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
operator|!
name|buf
operator|.
name|hasRemaining
argument_list|()
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
return|return
name|buf
operator|.
name|get
argument_list|()
operator|&
literal|0xFF
return|;
block|}
annotation|@
name|Override
specifier|public
name|int
name|read
parameter_list|(
name|byte
index|[]
name|bytes
parameter_list|,
name|int
name|off
parameter_list|,
name|int
name|len
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
operator|!
name|buf
operator|.
name|hasRemaining
argument_list|()
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
name|len
operator|=
name|Math
operator|.
name|min
argument_list|(
name|len
argument_list|,
name|buf
operator|.
name|remaining
argument_list|()
argument_list|)
expr_stmt|;
name|buf
operator|.
name|get
argument_list|(
name|bytes
argument_list|,
name|off
argument_list|,
name|len
argument_list|)
expr_stmt|;
return|return
name|len
return|;
block|}
block|}
specifier|public
name|void
name|addEvent
parameter_list|(
name|InputInitializerEvent
name|event
parameter_list|)
block|{
synchronized|synchronized
init|(
name|sourcesWaitingForEvents
init|)
block|{
if|if
condition|(
name|sourcesWaitingForEvents
operator|.
name|contains
argument_list|(
name|event
operator|.
name|getSourceVertexName
argument_list|()
argument_list|)
condition|)
block|{
operator|++
name|totalEventCount
expr_stmt|;
name|numEventsSeenPerSource
operator|.
name|get
argument_list|(
name|event
operator|.
name|getSourceVertexName
argument_list|()
argument_list|)
operator|.
name|increment
argument_list|()
expr_stmt|;
name|queue
operator|.
name|offer
argument_list|(
name|event
argument_list|)
expr_stmt|;
name|checkForSourceCompletion
argument_list|(
name|event
operator|.
name|getSourceVertexName
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
specifier|public
name|void
name|processVertex
parameter_list|(
name|String
name|name
parameter_list|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Vertex succeeded: "
operator|+
name|name
argument_list|)
expr_stmt|;
synchronized|synchronized
init|(
name|sourcesWaitingForEvents
init|)
block|{
comment|// Get a deterministic count of number of tasks for the vertex.
name|MutableInt
name|prevVal
init|=
name|numExpectedEventsPerSource
operator|.
name|get
argument_list|(
name|name
argument_list|)
decl_stmt|;
name|int
name|prevValInt
init|=
name|prevVal
operator|.
name|intValue
argument_list|()
decl_stmt|;
name|Preconditions
operator|.
name|checkState
argument_list|(
name|prevValInt
operator|<
literal|0
argument_list|,
literal|"Invalid value for numExpectedEvents for source: "
operator|+
name|name
operator|+
literal|", oldVal="
operator|+
name|prevValInt
argument_list|)
expr_stmt|;
name|prevVal
operator|.
name|setValue
argument_list|(
operator|(
operator|-
literal|1
operator|)
operator|*
name|prevValInt
operator|*
name|context
operator|.
name|getVertexNumTasks
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|checkForSourceCompletion
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|checkForSourceCompletion
parameter_list|(
name|String
name|name
parameter_list|)
block|{
name|int
name|expectedEvents
init|=
name|numExpectedEventsPerSource
operator|.
name|get
argument_list|(
name|name
argument_list|)
operator|.
name|getValue
argument_list|()
decl_stmt|;
if|if
condition|(
name|expectedEvents
operator|<
literal|0
condition|)
block|{
comment|// Expected events not updated yet - vertex SUCCESS notification not received.
return|return;
block|}
else|else
block|{
name|int
name|processedEvents
init|=
name|numEventsSeenPerSource
operator|.
name|get
argument_list|(
name|name
argument_list|)
operator|.
name|getValue
argument_list|()
decl_stmt|;
if|if
condition|(
name|processedEvents
operator|==
name|expectedEvents
condition|)
block|{
name|sourcesWaitingForEvents
operator|.
name|remove
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|sourcesWaitingForEvents
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
comment|// we've got what we need; mark the queue
name|queue
operator|.
name|offer
argument_list|(
name|endOfEvents
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Waiting for "
operator|+
name|sourcesWaitingForEvents
operator|.
name|size
argument_list|()
operator|+
literal|" sources."
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|processedEvents
operator|>
name|expectedEvents
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"Received too many events for "
operator|+
name|name
operator|+
literal|", Expected="
operator|+
name|expectedEvents
operator|+
literal|", Received="
operator|+
name|processedEvents
argument_list|)
throw|;
block|}
return|return;
block|}
block|}
block|}
end_class

end_unit

