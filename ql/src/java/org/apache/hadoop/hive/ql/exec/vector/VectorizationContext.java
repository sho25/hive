begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|vector
package|;
end_package

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|reflect
operator|.
name|Constructor
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|Log
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|LogFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|ExprNodeEvaluator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|ExprNodeEvaluatorFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|FunctionInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|FunctionRegistry
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|UDF
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|vector
operator|.
name|expressions
operator|.
name|ConstantVectorExpression
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|vector
operator|.
name|expressions
operator|.
name|FilterConstantBooleanVectorExpression
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|vector
operator|.
name|expressions
operator|.
name|FilterExprAndExpr
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|vector
operator|.
name|expressions
operator|.
name|FilterExprOrExpr
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|vector
operator|.
name|expressions
operator|.
name|FilterStringColLikeStringScalar
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|vector
operator|.
name|expressions
operator|.
name|FuncRand
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|vector
operator|.
name|expressions
operator|.
name|ISetDoubleArg
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|vector
operator|.
name|expressions
operator|.
name|ISetLongArg
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|vector
operator|.
name|expressions
operator|.
name|FilterStringColRegExpStringScalar
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|vector
operator|.
name|expressions
operator|.
name|IdentityExpression
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|vector
operator|.
name|expressions
operator|.
name|SelectColumnIsNotNull
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|vector
operator|.
name|expressions
operator|.
name|SelectColumnIsNull
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|vector
operator|.
name|expressions
operator|.
name|SelectColumnIsTrue
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|vector
operator|.
name|expressions
operator|.
name|StringConcatColCol
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|vector
operator|.
name|expressions
operator|.
name|StringConcatColScalar
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|vector
operator|.
name|expressions
operator|.
name|StringConcatScalarCol
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|vector
operator|.
name|expressions
operator|.
name|StringSubstrColStart
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|vector
operator|.
name|expressions
operator|.
name|StringSubstrColStartLen
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|vector
operator|.
name|expressions
operator|.
name|VectorExpression
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|vector
operator|.
name|expressions
operator|.
name|VectorUDFUnixTimeStampLong
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|vector
operator|.
name|expressions
operator|.
name|aggregates
operator|.
name|VectorAggregateExpression
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|vector
operator|.
name|expressions
operator|.
name|aggregates
operator|.
name|VectorUDAFCount
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|vector
operator|.
name|expressions
operator|.
name|aggregates
operator|.
name|VectorUDAFCountStar
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|vector
operator|.
name|expressions
operator|.
name|aggregates
operator|.
name|gen
operator|.
name|VectorUDAFAvgDouble
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|vector
operator|.
name|expressions
operator|.
name|aggregates
operator|.
name|gen
operator|.
name|VectorUDAFAvgLong
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|vector
operator|.
name|expressions
operator|.
name|aggregates
operator|.
name|gen
operator|.
name|VectorUDAFMaxDouble
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|vector
operator|.
name|expressions
operator|.
name|aggregates
operator|.
name|gen
operator|.
name|VectorUDAFMaxLong
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|vector
operator|.
name|expressions
operator|.
name|aggregates
operator|.
name|gen
operator|.
name|VectorUDAFMaxString
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|vector
operator|.
name|expressions
operator|.
name|aggregates
operator|.
name|gen
operator|.
name|VectorUDAFMinDouble
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|vector
operator|.
name|expressions
operator|.
name|aggregates
operator|.
name|gen
operator|.
name|VectorUDAFMinLong
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|vector
operator|.
name|expressions
operator|.
name|aggregates
operator|.
name|gen
operator|.
name|VectorUDAFMinString
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|vector
operator|.
name|expressions
operator|.
name|aggregates
operator|.
name|gen
operator|.
name|VectorUDAFStdPopDouble
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|vector
operator|.
name|expressions
operator|.
name|aggregates
operator|.
name|gen
operator|.
name|VectorUDAFStdPopLong
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|vector
operator|.
name|expressions
operator|.
name|aggregates
operator|.
name|gen
operator|.
name|VectorUDAFStdSampDouble
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|vector
operator|.
name|expressions
operator|.
name|aggregates
operator|.
name|gen
operator|.
name|VectorUDAFStdSampLong
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|vector
operator|.
name|expressions
operator|.
name|aggregates
operator|.
name|gen
operator|.
name|VectorUDAFSumDouble
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|vector
operator|.
name|expressions
operator|.
name|aggregates
operator|.
name|gen
operator|.
name|VectorUDAFSumLong
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|vector
operator|.
name|expressions
operator|.
name|aggregates
operator|.
name|gen
operator|.
name|VectorUDAFVarPopDouble
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|vector
operator|.
name|expressions
operator|.
name|aggregates
operator|.
name|gen
operator|.
name|VectorUDAFVarPopLong
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|vector
operator|.
name|expressions
operator|.
name|aggregates
operator|.
name|gen
operator|.
name|VectorUDAFVarSampDouble
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|vector
operator|.
name|expressions
operator|.
name|aggregates
operator|.
name|gen
operator|.
name|VectorUDAFVarSampLong
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|vector
operator|.
name|expressions
operator|.
name|gen
operator|.
name|CastLongToBooleanViaLongToLong
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|vector
operator|.
name|udf
operator|.
name|VectorUDFAdaptor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|vector
operator|.
name|udf
operator|.
name|VectorUDFArgDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|metadata
operator|.
name|HiveException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|AggregationDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|ExprNodeColumnDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|ExprNodeConstantDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|ExprNodeDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|ExprNodeGenericFuncDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|api
operator|.
name|OperatorType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|udf
operator|.
name|generic
operator|.
name|GenericUDFConcat
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|udf
operator|.
name|UDFAcos
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|udf
operator|.
name|UDFAsin
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|udf
operator|.
name|UDFAtan
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|udf
operator|.
name|UDFBin
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|udf
operator|.
name|UDFCeil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|udf
operator|.
name|UDFConv
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|udf
operator|.
name|UDFCos
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|udf
operator|.
name|UDFDayOfMonth
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|udf
operator|.
name|UDFDegrees
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|udf
operator|.
name|UDFExp
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|udf
operator|.
name|UDFFloor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|udf
operator|.
name|UDFHex
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|udf
operator|.
name|UDFHour
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|udf
operator|.
name|UDFLTrim
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|udf
operator|.
name|UDFLength
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|udf
operator|.
name|UDFLike
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|udf
operator|.
name|UDFLn
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|udf
operator|.
name|UDFLog
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|udf
operator|.
name|UDFLog10
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|udf
operator|.
name|UDFLog2
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|udf
operator|.
name|UDFMinute
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|udf
operator|.
name|UDFMonth
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|udf
operator|.
name|UDFOPDivide
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|udf
operator|.
name|UDFOPMinus
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|udf
operator|.
name|UDFOPMod
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|udf
operator|.
name|UDFOPMultiply
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|udf
operator|.
name|UDFOPNegative
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|udf
operator|.
name|UDFOPPlus
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|udf
operator|.
name|UDFOPPositive
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|udf
operator|.
name|UDFPosMod
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|udf
operator|.
name|UDFPower
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|udf
operator|.
name|UDFRegExp
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|udf
operator|.
name|UDFRTrim
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|udf
operator|.
name|UDFRadians
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|udf
operator|.
name|UDFRand
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|udf
operator|.
name|UDFRound
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|udf
operator|.
name|UDFSecond
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|udf
operator|.
name|UDFSign
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|udf
operator|.
name|UDFSin
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|udf
operator|.
name|UDFSqrt
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|udf
operator|.
name|UDFSubstr
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|udf
operator|.
name|UDFTan
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|udf
operator|.
name|UDFToBoolean
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|udf
operator|.
name|UDFToByte
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|udf
operator|.
name|UDFToInteger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|udf
operator|.
name|UDFToLong
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|udf
operator|.
name|UDFToShort
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|udf
operator|.
name|UDFToFloat
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|udf
operator|.
name|UDFToDouble
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|udf
operator|.
name|UDFToString
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|udf
operator|.
name|UDFTrim
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|udf
operator|.
name|UDFWeekOfYear
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|udf
operator|.
name|UDFYear
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|udf
operator|.
name|generic
operator|.
name|GenericUDF
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|udf
operator|.
name|generic
operator|.
name|GenericUDFAbs
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|udf
operator|.
name|generic
operator|.
name|GenericUDFBridge
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|udf
operator|.
name|generic
operator|.
name|GenericUDFLower
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|udf
operator|.
name|generic
operator|.
name|GenericUDFOPAnd
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|udf
operator|.
name|generic
operator|.
name|GenericUDFOPEqual
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|udf
operator|.
name|generic
operator|.
name|GenericUDFOPEqualOrGreaterThan
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|udf
operator|.
name|generic
operator|.
name|GenericUDFOPEqualOrLessThan
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|udf
operator|.
name|generic
operator|.
name|GenericUDFOPGreaterThan
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|udf
operator|.
name|generic
operator|.
name|GenericUDFOPLessThan
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|udf
operator|.
name|generic
operator|.
name|GenericUDFOPNot
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|udf
operator|.
name|generic
operator|.
name|GenericUDFOPNotEqual
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|udf
operator|.
name|generic
operator|.
name|GenericUDFOPNotNull
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|udf
operator|.
name|generic
operator|.
name|GenericUDFOPNull
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|udf
operator|.
name|generic
operator|.
name|GenericUDFOPOr
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|udf
operator|.
name|generic
operator|.
name|GenericUDFTimestamp
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|udf
operator|.
name|generic
operator|.
name|GenericUDFToUnixTimeStamp
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|udf
operator|.
name|generic
operator|.
name|GenericUDFUpper
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|io
operator|.
name|DoubleWritable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|objectinspector
operator|.
name|ObjectInspector
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|objectinspector
operator|.
name|ObjectInspectorUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|IntWritable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|LongWritable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|Text
import|;
end_import

begin_comment
comment|/**  * Context class for vectorization execution.  * Main role is to map column names to column indices and serves as a  * factory class for building vectorized expressions out of descriptors.  *  */
end_comment

begin_class
specifier|public
class|class
name|VectorizationContext
block|{
specifier|private
specifier|static
specifier|final
name|Log
name|LOG
init|=
name|LogFactory
operator|.
name|getLog
argument_list|(
name|VectorizationContext
operator|.
name|class
operator|.
name|getName
argument_list|()
argument_list|)
decl_stmt|;
comment|//columnName to column position map
specifier|private
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|Integer
argument_list|>
name|columnMap
decl_stmt|;
specifier|private
specifier|final
name|int
name|firstOutputColumnIndex
decl_stmt|;
specifier|private
name|OperatorType
name|opType
decl_stmt|;
comment|//Map column number to type
specifier|private
specifier|final
name|OutputColumnManager
name|ocm
decl_stmt|;
comment|// Package where custom (hand-built) vector expression classes are located.
specifier|private
specifier|static
specifier|final
name|String
name|CUSTOM_EXPR_PACKAGE
init|=
literal|"org.apache.hadoop.hive.ql.exec.vector.expressions"
decl_stmt|;
comment|// Package where vector expression packages generated from templates are located.
specifier|private
specifier|static
specifier|final
name|String
name|GENERATED_EXPR_PACKAGE
init|=
literal|"org.apache.hadoop.hive.ql.exec.vector.expressions.gen"
decl_stmt|;
specifier|public
name|VectorizationContext
parameter_list|(
name|Map
argument_list|<
name|String
argument_list|,
name|Integer
argument_list|>
name|columnMap
parameter_list|,
name|int
name|initialOutputCol
parameter_list|)
block|{
name|this
operator|.
name|columnMap
operator|=
name|columnMap
expr_stmt|;
name|this
operator|.
name|ocm
operator|=
operator|new
name|OutputColumnManager
argument_list|(
name|initialOutputCol
argument_list|)
expr_stmt|;
name|this
operator|.
name|firstOutputColumnIndex
operator|=
name|initialOutputCol
expr_stmt|;
block|}
specifier|private
name|int
name|getInputColumnIndex
parameter_list|(
name|String
name|name
parameter_list|)
block|{
return|return
name|columnMap
operator|.
name|get
argument_list|(
name|name
argument_list|)
return|;
block|}
specifier|private
class|class
name|OutputColumnManager
block|{
specifier|private
specifier|final
name|int
name|initialOutputCol
decl_stmt|;
specifier|private
name|int
name|outputColCount
init|=
literal|0
decl_stmt|;
name|OutputColumnManager
parameter_list|(
name|int
name|initialOutputCol
parameter_list|)
block|{
name|this
operator|.
name|initialOutputCol
operator|=
name|initialOutputCol
expr_stmt|;
block|}
comment|//The complete list of output columns. These should be added to the
comment|//Vectorized row batch for processing. The index in the row batch is
comment|//equal to the index in this array plus initialOutputCol.
comment|//Start with size 100 and double when needed.
specifier|private
name|String
index|[]
name|outputColumnsTypes
init|=
operator|new
name|String
index|[
literal|100
index|]
decl_stmt|;
specifier|private
specifier|final
name|Set
argument_list|<
name|Integer
argument_list|>
name|usedOutputColumns
init|=
operator|new
name|HashSet
argument_list|<
name|Integer
argument_list|>
argument_list|()
decl_stmt|;
name|int
name|allocateOutputColumn
parameter_list|(
name|String
name|columnType
parameter_list|)
block|{
name|int
name|relativeCol
init|=
name|allocateOutputColumnInternal
argument_list|(
name|columnType
argument_list|)
decl_stmt|;
return|return
name|initialOutputCol
operator|+
name|relativeCol
return|;
block|}
specifier|private
name|int
name|allocateOutputColumnInternal
parameter_list|(
name|String
name|columnType
parameter_list|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|outputColCount
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|usedOutputColumns
operator|.
name|contains
argument_list|(
name|i
argument_list|)
operator|||
operator|!
operator|(
name|outputColumnsTypes
operator|)
index|[
name|i
index|]
operator|.
name|equalsIgnoreCase
argument_list|(
name|columnType
argument_list|)
condition|)
block|{
continue|continue;
block|}
comment|//Use i
name|usedOutputColumns
operator|.
name|add
argument_list|(
name|i
argument_list|)
expr_stmt|;
return|return
name|i
return|;
block|}
comment|//Out of allocated columns
if|if
condition|(
name|outputColCount
operator|<
name|outputColumnsTypes
operator|.
name|length
condition|)
block|{
name|int
name|newIndex
init|=
name|outputColCount
decl_stmt|;
name|outputColumnsTypes
index|[
name|outputColCount
operator|++
index|]
operator|=
name|columnType
expr_stmt|;
name|usedOutputColumns
operator|.
name|add
argument_list|(
name|newIndex
argument_list|)
expr_stmt|;
return|return
name|newIndex
return|;
block|}
else|else
block|{
comment|//Expand the array
name|outputColumnsTypes
operator|=
name|Arrays
operator|.
name|copyOf
argument_list|(
name|outputColumnsTypes
argument_list|,
literal|2
operator|*
name|outputColCount
argument_list|)
expr_stmt|;
name|int
name|newIndex
init|=
name|outputColCount
decl_stmt|;
name|outputColumnsTypes
index|[
name|outputColCount
operator|++
index|]
operator|=
name|columnType
expr_stmt|;
name|usedOutputColumns
operator|.
name|add
argument_list|(
name|newIndex
argument_list|)
expr_stmt|;
return|return
name|newIndex
return|;
block|}
block|}
name|void
name|freeOutputColumn
parameter_list|(
name|int
name|index
parameter_list|)
block|{
name|int
name|colIndex
init|=
name|index
operator|-
name|initialOutputCol
decl_stmt|;
if|if
condition|(
name|colIndex
operator|>=
literal|0
condition|)
block|{
name|usedOutputColumns
operator|.
name|remove
argument_list|(
name|index
operator|-
name|initialOutputCol
argument_list|)
expr_stmt|;
block|}
block|}
block|}
specifier|public
name|void
name|setOperatorType
parameter_list|(
name|OperatorType
name|opType
parameter_list|)
block|{
name|this
operator|.
name|opType
operator|=
name|opType
expr_stmt|;
block|}
specifier|private
name|VectorExpression
name|getVectorExpression
parameter_list|(
name|ExprNodeColumnDesc
name|exprDesc
parameter_list|)
block|{
name|int
name|columnNum
init|=
name|getInputColumnIndex
argument_list|(
name|exprDesc
operator|.
name|getColumn
argument_list|()
argument_list|)
decl_stmt|;
name|VectorExpression
name|expr
init|=
literal|null
decl_stmt|;
switch|switch
condition|(
name|opType
condition|)
block|{
case|case
name|FILTER
case|:
comment|//Important: It will come here only if the column is being used as a boolean
name|expr
operator|=
operator|new
name|SelectColumnIsTrue
argument_list|(
name|columnNum
argument_list|)
expr_stmt|;
break|break;
case|case
name|SELECT
case|:
case|case
name|GROUPBY
case|:
case|case
name|REDUCESINK
case|:
name|expr
operator|=
operator|new
name|IdentityExpression
argument_list|(
name|columnNum
argument_list|,
name|exprDesc
operator|.
name|getTypeString
argument_list|()
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
name|expr
return|;
block|}
specifier|public
name|VectorExpression
index|[]
name|getVectorExpressions
parameter_list|(
name|List
argument_list|<
name|ExprNodeDesc
argument_list|>
name|exprNodes
parameter_list|)
throws|throws
name|HiveException
block|{
name|int
name|i
init|=
literal|0
decl_stmt|;
if|if
condition|(
literal|null
operator|==
name|exprNodes
condition|)
block|{
return|return
operator|new
name|VectorExpression
index|[
literal|0
index|]
return|;
block|}
name|VectorExpression
index|[]
name|ret
init|=
operator|new
name|VectorExpression
index|[
name|exprNodes
operator|.
name|size
argument_list|()
index|]
decl_stmt|;
for|for
control|(
name|ExprNodeDesc
name|e
range|:
name|exprNodes
control|)
block|{
name|ret
index|[
name|i
operator|++
index|]
operator|=
name|getVectorExpression
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
comment|/**    * Returns a vector expression for a given expression    * description.    * @param exprDesc, Expression description    * @return {@link VectorExpression}    * @throws HiveException    */
specifier|public
name|VectorExpression
name|getVectorExpression
parameter_list|(
name|ExprNodeDesc
name|exprDesc
parameter_list|)
throws|throws
name|HiveException
block|{
name|VectorExpression
name|ve
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|exprDesc
operator|instanceof
name|ExprNodeColumnDesc
condition|)
block|{
name|ve
operator|=
name|getVectorExpression
argument_list|(
operator|(
name|ExprNodeColumnDesc
operator|)
name|exprDesc
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|exprDesc
operator|instanceof
name|ExprNodeGenericFuncDesc
condition|)
block|{
name|ExprNodeGenericFuncDesc
name|expr
init|=
operator|(
name|ExprNodeGenericFuncDesc
operator|)
name|exprDesc
decl_stmt|;
if|if
condition|(
name|isCustomUDF
argument_list|(
name|expr
argument_list|)
operator|||
name|isLegacyPathUDF
argument_list|(
name|expr
argument_list|)
condition|)
block|{
name|ve
operator|=
name|getCustomUDFExpression
argument_list|(
name|expr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ve
operator|=
name|getVectorExpression
argument_list|(
name|expr
operator|.
name|getGenericUDF
argument_list|()
argument_list|,
name|expr
operator|.
name|getChildExprs
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|exprDesc
operator|instanceof
name|ExprNodeConstantDesc
condition|)
block|{
name|ve
operator|=
name|getConstantVectorExpression
argument_list|(
operator|(
name|ExprNodeConstantDesc
operator|)
name|exprDesc
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ve
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|HiveException
argument_list|(
literal|"Could not vectorize expression: "
operator|+
name|exprDesc
operator|.
name|getName
argument_list|()
argument_list|)
throw|;
block|}
return|return
name|ve
return|;
block|}
comment|/* Return true if this is one of a small set of functions for which    * it is significantly easier to use the old code path in vectorized    * mode instead of implementing a new, optimized VectorExpression.    *    * Depending on performance requirements and frequency of use, these    * may be implemented in the future with an optimized VectorExpression.    */
specifier|public
specifier|static
name|boolean
name|isLegacyPathUDF
parameter_list|(
name|ExprNodeGenericFuncDesc
name|expr
parameter_list|)
block|{
name|GenericUDF
name|gudf
init|=
name|expr
operator|.
name|getGenericUDF
argument_list|()
decl_stmt|;
if|if
condition|(
name|gudf
operator|instanceof
name|GenericUDFBridge
condition|)
block|{
name|GenericUDFBridge
name|bridge
init|=
operator|(
name|GenericUDFBridge
operator|)
name|gudf
decl_stmt|;
name|Class
argument_list|<
name|?
extends|extends
name|UDF
argument_list|>
name|udfClass
init|=
name|bridge
operator|.
name|getUdfClass
argument_list|()
decl_stmt|;
if|if
condition|(
name|udfClass
operator|.
name|equals
argument_list|(
name|UDFHex
operator|.
name|class
argument_list|)
operator|||
name|udfClass
operator|.
name|equals
argument_list|(
name|UDFConv
operator|.
name|class
argument_list|)
operator|||
name|isCastToIntFamily
argument_list|(
name|udfClass
argument_list|)
operator|&&
name|arg0Type
argument_list|(
name|expr
argument_list|)
operator|.
name|equals
argument_list|(
literal|"string"
argument_list|)
operator|||
name|isCastToFloatFamily
argument_list|(
name|udfClass
argument_list|)
operator|&&
name|arg0Type
argument_list|(
name|expr
argument_list|)
operator|.
name|equals
argument_list|(
literal|"string"
argument_list|)
operator|||
name|udfClass
operator|.
name|equals
argument_list|(
name|UDFToString
operator|.
name|class
argument_list|)
operator|&&
operator|(
name|arg0Type
argument_list|(
name|expr
argument_list|)
operator|.
name|equals
argument_list|(
literal|"timestamp"
argument_list|)
operator|||
name|arg0Type
argument_list|(
name|expr
argument_list|)
operator|.
name|equals
argument_list|(
literal|"double"
argument_list|)
operator|||
name|arg0Type
argument_list|(
name|expr
argument_list|)
operator|.
name|equals
argument_list|(
literal|"float"
argument_list|)
operator|)
condition|)
block|{
return|return
literal|true
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|gudf
operator|instanceof
name|GenericUDFTimestamp
operator|&&
name|arg0Type
argument_list|(
name|expr
argument_list|)
operator|.
name|equals
argument_list|(
literal|"string"
argument_list|)
condition|)
block|{
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
specifier|public
specifier|static
name|boolean
name|isCastToIntFamily
parameter_list|(
name|Class
argument_list|<
name|?
extends|extends
name|UDF
argument_list|>
name|udfClass
parameter_list|)
block|{
return|return
name|udfClass
operator|.
name|equals
argument_list|(
name|UDFToByte
operator|.
name|class
argument_list|)
operator|||
name|udfClass
operator|.
name|equals
argument_list|(
name|UDFToShort
operator|.
name|class
argument_list|)
operator|||
name|udfClass
operator|.
name|equals
argument_list|(
name|UDFToInteger
operator|.
name|class
argument_list|)
operator|||
name|udfClass
operator|.
name|equals
argument_list|(
name|UDFToLong
operator|.
name|class
argument_list|)
return|;
comment|// Boolean is purposely excluded.
block|}
specifier|public
specifier|static
name|boolean
name|isCastToFloatFamily
parameter_list|(
name|Class
argument_list|<
name|?
extends|extends
name|UDF
argument_list|>
name|udfClass
parameter_list|)
block|{
return|return
name|udfClass
operator|.
name|equals
argument_list|(
name|UDFToDouble
operator|.
name|class
argument_list|)
operator|||
name|udfClass
operator|.
name|equals
argument_list|(
name|UDFToFloat
operator|.
name|class
argument_list|)
return|;
block|}
comment|// Return the type string of the first argument (argument 0).
specifier|public
specifier|static
name|String
name|arg0Type
parameter_list|(
name|ExprNodeGenericFuncDesc
name|expr
parameter_list|)
block|{
name|String
name|type
init|=
name|expr
operator|.
name|getChildExprs
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|getTypeString
argument_list|()
decl_stmt|;
return|return
name|type
return|;
block|}
comment|// Return true if this is a custom UDF or custom GenericUDF.
comment|// This is for use only in the planner. It will fail in a task.
specifier|public
specifier|static
name|boolean
name|isCustomUDF
parameter_list|(
name|ExprNodeGenericFuncDesc
name|expr
parameter_list|)
block|{
name|String
name|udfName
init|=
name|expr
operator|.
name|getFuncText
argument_list|()
decl_stmt|;
if|if
condition|(
name|udfName
operator|==
literal|null
condition|)
block|{
return|return
literal|false
return|;
block|}
name|FunctionInfo
name|funcInfo
init|=
name|FunctionRegistry
operator|.
name|getFunctionInfo
argument_list|(
name|udfName
argument_list|)
decl_stmt|;
if|if
condition|(
name|funcInfo
operator|==
literal|null
condition|)
block|{
return|return
literal|false
return|;
block|}
name|boolean
name|isNativeFunc
init|=
name|funcInfo
operator|.
name|isNative
argument_list|()
decl_stmt|;
return|return
operator|!
name|isNativeFunc
return|;
block|}
comment|/**    * Handles only the special case of unary operators on a constant.    * @param exprDesc    * @return The same expression if no folding done, else return the constant    *         expression.    * @throws HiveException    */
specifier|private
name|ExprNodeDesc
name|foldConstantsForUnaryExpression
parameter_list|(
name|ExprNodeDesc
name|exprDesc
parameter_list|)
throws|throws
name|HiveException
block|{
if|if
condition|(
operator|!
operator|(
name|exprDesc
operator|instanceof
name|ExprNodeGenericFuncDesc
operator|)
condition|)
block|{
return|return
name|exprDesc
return|;
block|}
if|if
condition|(
name|exprDesc
operator|.
name|getChildren
argument_list|()
operator|==
literal|null
operator|||
operator|(
name|exprDesc
operator|.
name|getChildren
argument_list|()
operator|.
name|size
argument_list|()
operator|!=
literal|1
operator|)
operator|||
operator|(
operator|!
operator|(
name|exprDesc
operator|.
name|getChildren
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|instanceof
name|ExprNodeConstantDesc
operator|)
operator|)
condition|)
block|{
return|return
name|exprDesc
return|;
block|}
name|GenericUDF
name|gudf
init|=
operator|(
operator|(
name|ExprNodeGenericFuncDesc
operator|)
name|exprDesc
operator|)
operator|.
name|getGenericUDF
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|gudf
operator|instanceof
name|GenericUDFBridge
operator|)
condition|)
block|{
return|return
name|exprDesc
return|;
block|}
name|Class
argument_list|<
name|?
extends|extends
name|UDF
argument_list|>
name|cl
init|=
operator|(
operator|(
name|GenericUDFBridge
operator|)
name|gudf
operator|)
operator|.
name|getUdfClass
argument_list|()
decl_stmt|;
name|ExprNodeConstantDesc
name|constExpr
init|=
operator|(
name|ExprNodeConstantDesc
operator|)
name|exprDesc
operator|.
name|getChildren
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|cl
operator|.
name|equals
argument_list|(
name|UDFOPNegative
operator|.
name|class
argument_list|)
operator|||
name|cl
operator|.
name|equals
argument_list|(
name|UDFOPPositive
operator|.
name|class
argument_list|)
condition|)
block|{
name|ExprNodeEvaluator
name|evaluator
init|=
name|ExprNodeEvaluatorFactory
operator|.
name|get
argument_list|(
name|exprDesc
argument_list|)
decl_stmt|;
name|ObjectInspector
name|output
init|=
name|evaluator
operator|.
name|initialize
argument_list|(
literal|null
argument_list|)
decl_stmt|;
name|Object
name|constant
init|=
name|evaluator
operator|.
name|evaluate
argument_list|(
literal|null
argument_list|)
decl_stmt|;
name|Object
name|java
init|=
name|ObjectInspectorUtils
operator|.
name|copyToStandardJavaObject
argument_list|(
name|constant
argument_list|,
name|output
argument_list|)
decl_stmt|;
return|return
operator|new
name|ExprNodeConstantDesc
argument_list|(
name|java
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|exprDesc
return|;
block|}
block|}
specifier|private
name|VectorExpression
name|getConstantVectorExpression
parameter_list|(
name|ExprNodeConstantDesc
name|exprDesc
parameter_list|)
throws|throws
name|HiveException
block|{
name|String
name|type
init|=
name|exprDesc
operator|.
name|getTypeString
argument_list|()
decl_stmt|;
name|String
name|colVectorType
init|=
name|this
operator|.
name|getOutputColType
argument_list|(
name|type
argument_list|,
literal|"constant"
argument_list|)
decl_stmt|;
name|int
name|outCol
init|=
name|ocm
operator|.
name|allocateOutputColumn
argument_list|(
name|colVectorType
argument_list|)
decl_stmt|;
if|if
condition|(
name|type
operator|.
name|equalsIgnoreCase
argument_list|(
literal|"long"
argument_list|)
operator|||
name|type
operator|.
name|equalsIgnoreCase
argument_list|(
literal|"int"
argument_list|)
operator|||
name|type
operator|.
name|equalsIgnoreCase
argument_list|(
literal|"short"
argument_list|)
operator|||
name|type
operator|.
name|equalsIgnoreCase
argument_list|(
literal|"byte"
argument_list|)
condition|)
block|{
return|return
operator|new
name|ConstantVectorExpression
argument_list|(
name|outCol
argument_list|,
operator|(
operator|(
name|Number
operator|)
name|exprDesc
operator|.
name|getValue
argument_list|()
operator|)
operator|.
name|longValue
argument_list|()
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|type
operator|.
name|equalsIgnoreCase
argument_list|(
literal|"double"
argument_list|)
operator|||
name|type
operator|.
name|equalsIgnoreCase
argument_list|(
literal|"float"
argument_list|)
condition|)
block|{
return|return
operator|new
name|ConstantVectorExpression
argument_list|(
name|outCol
argument_list|,
operator|(
operator|(
name|Number
operator|)
name|exprDesc
operator|.
name|getValue
argument_list|()
operator|)
operator|.
name|doubleValue
argument_list|()
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|type
operator|.
name|equalsIgnoreCase
argument_list|(
literal|"string"
argument_list|)
condition|)
block|{
return|return
operator|new
name|ConstantVectorExpression
argument_list|(
name|outCol
argument_list|,
operator|(
operator|(
name|String
operator|)
name|exprDesc
operator|.
name|getValue
argument_list|()
operator|)
operator|.
name|getBytes
argument_list|()
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|type
operator|.
name|equalsIgnoreCase
argument_list|(
literal|"boolean"
argument_list|)
condition|)
block|{
if|if
condition|(
name|this
operator|.
name|opType
operator|==
name|OperatorType
operator|.
name|FILTER
condition|)
block|{
if|if
condition|(
operator|(
operator|(
name|Boolean
operator|)
name|exprDesc
operator|.
name|getValue
argument_list|()
operator|)
operator|.
name|booleanValue
argument_list|()
condition|)
block|{
return|return
operator|new
name|FilterConstantBooleanVectorExpression
argument_list|(
literal|1
argument_list|)
return|;
block|}
else|else
block|{
return|return
operator|new
name|FilterConstantBooleanVectorExpression
argument_list|(
literal|0
argument_list|)
return|;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|(
operator|(
name|Boolean
operator|)
name|exprDesc
operator|.
name|getValue
argument_list|()
operator|)
operator|.
name|booleanValue
argument_list|()
condition|)
block|{
return|return
operator|new
name|ConstantVectorExpression
argument_list|(
name|outCol
argument_list|,
literal|1
argument_list|)
return|;
block|}
else|else
block|{
return|return
operator|new
name|ConstantVectorExpression
argument_list|(
name|outCol
argument_list|,
literal|0
argument_list|)
return|;
block|}
block|}
block|}
else|else
block|{
throw|throw
operator|new
name|HiveException
argument_list|(
literal|"Unsupported constant type: "
operator|+
name|type
operator|.
name|toString
argument_list|()
argument_list|)
throw|;
block|}
block|}
specifier|private
name|VectorExpression
name|getUnaryMinusExpression
parameter_list|(
name|List
argument_list|<
name|ExprNodeDesc
argument_list|>
name|childExprList
parameter_list|)
throws|throws
name|HiveException
block|{
name|ExprNodeDesc
name|childExpr
init|=
name|childExprList
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|int
name|inputCol
decl_stmt|;
name|String
name|colType
decl_stmt|;
name|VectorExpression
name|v1
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|childExpr
operator|instanceof
name|ExprNodeGenericFuncDesc
condition|)
block|{
name|v1
operator|=
name|getVectorExpression
argument_list|(
name|childExpr
argument_list|)
expr_stmt|;
name|inputCol
operator|=
name|v1
operator|.
name|getOutputColumn
argument_list|()
expr_stmt|;
name|colType
operator|=
name|v1
operator|.
name|getOutputType
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|childExpr
operator|instanceof
name|ExprNodeColumnDesc
condition|)
block|{
name|ExprNodeColumnDesc
name|colDesc
init|=
operator|(
name|ExprNodeColumnDesc
operator|)
name|childExpr
decl_stmt|;
name|inputCol
operator|=
name|getInputColumnIndex
argument_list|(
name|colDesc
operator|.
name|getColumn
argument_list|()
argument_list|)
expr_stmt|;
name|colType
operator|=
name|colDesc
operator|.
name|getTypeString
argument_list|()
expr_stmt|;
block|}
else|else
block|{
throw|throw
operator|new
name|HiveException
argument_list|(
literal|"Expression not supported: "
operator|+
name|childExpr
argument_list|)
throw|;
block|}
name|String
name|outputColumnType
init|=
name|getNormalizedTypeName
argument_list|(
name|colType
argument_list|)
decl_stmt|;
name|int
name|outputCol
init|=
name|ocm
operator|.
name|allocateOutputColumn
argument_list|(
name|outputColumnType
argument_list|)
decl_stmt|;
name|String
name|className
init|=
literal|"org.apache.hadoop.hive.ql.exec.vector.expressions.gen."
operator|+
name|outputColumnType
operator|+
literal|"ColUnaryMinus"
decl_stmt|;
name|VectorExpression
name|expr
decl_stmt|;
try|try
block|{
name|expr
operator|=
operator|(
name|VectorExpression
operator|)
name|getConstructor
argument_list|(
name|className
argument_list|)
operator|.
name|newInstance
argument_list|(
name|inputCol
argument_list|,
name|outputCol
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|ex
parameter_list|)
block|{
throw|throw
operator|new
name|HiveException
argument_list|(
name|ex
argument_list|)
throw|;
block|}
if|if
condition|(
name|v1
operator|!=
literal|null
condition|)
block|{
name|expr
operator|.
name|setChildExpressions
argument_list|(
operator|new
name|VectorExpression
index|[]
block|{
name|v1
block|}
argument_list|)
expr_stmt|;
name|ocm
operator|.
name|freeOutputColumn
argument_list|(
name|v1
operator|.
name|getOutputColumn
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|expr
return|;
block|}
comment|/* For functions that take one argument, and can be translated using a vector    * expression class of the form    *<packagePrefix>.<classPrefix><argumentType>To<resultType>    * The argumentType is inferred from the input expression.    */
specifier|private
name|VectorExpression
name|getUnaryFunctionExpression
parameter_list|(
name|String
name|classPrefix
parameter_list|,
name|String
name|resultType
parameter_list|,
name|List
argument_list|<
name|ExprNodeDesc
argument_list|>
name|childExprList
parameter_list|,
name|String
name|packagePrefix
parameter_list|)
throws|throws
name|HiveException
block|{
name|ExprNodeDesc
name|childExpr
init|=
name|childExprList
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|int
name|inputCol
decl_stmt|;
name|String
name|colType
decl_stmt|;
name|VectorExpression
name|v1
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|childExpr
operator|instanceof
name|ExprNodeGenericFuncDesc
condition|)
block|{
name|v1
operator|=
name|getVectorExpression
argument_list|(
name|childExpr
argument_list|)
expr_stmt|;
name|inputCol
operator|=
name|v1
operator|.
name|getOutputColumn
argument_list|()
expr_stmt|;
name|colType
operator|=
name|v1
operator|.
name|getOutputType
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|childExpr
operator|instanceof
name|ExprNodeColumnDesc
condition|)
block|{
name|ExprNodeColumnDesc
name|colDesc
init|=
operator|(
name|ExprNodeColumnDesc
operator|)
name|childExpr
decl_stmt|;
name|inputCol
operator|=
name|getInputColumnIndex
argument_list|(
name|colDesc
operator|.
name|getColumn
argument_list|()
argument_list|)
expr_stmt|;
name|colType
operator|=
name|colDesc
operator|.
name|getTypeString
argument_list|()
expr_stmt|;
block|}
else|else
block|{
throw|throw
operator|new
name|HiveException
argument_list|(
literal|"Expression not supported: "
operator|+
name|childExpr
argument_list|)
throw|;
block|}
name|String
name|funcInputColType
init|=
name|getNormalizedTypeName
argument_list|(
name|colType
argument_list|)
decl_stmt|;
name|int
name|outputCol
init|=
name|ocm
operator|.
name|allocateOutputColumn
argument_list|(
name|resultType
argument_list|)
decl_stmt|;
name|String
name|className
init|=
name|packagePrefix
operator|+
literal|"."
operator|+
name|classPrefix
operator|+
name|funcInputColType
operator|+
literal|"To"
operator|+
name|resultType
decl_stmt|;
name|VectorExpression
name|expr
decl_stmt|;
try|try
block|{
name|expr
operator|=
operator|(
name|VectorExpression
operator|)
name|getConstructor
argument_list|(
name|className
argument_list|)
operator|.
name|newInstance
argument_list|(
name|inputCol
argument_list|,
name|outputCol
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|ex
parameter_list|)
block|{
throw|throw
operator|new
name|HiveException
argument_list|(
name|ex
argument_list|)
throw|;
block|}
if|if
condition|(
name|v1
operator|!=
literal|null
condition|)
block|{
name|expr
operator|.
name|setChildExpressions
argument_list|(
operator|new
name|VectorExpression
index|[]
block|{
name|v1
block|}
argument_list|)
expr_stmt|;
name|ocm
operator|.
name|freeOutputColumn
argument_list|(
name|v1
operator|.
name|getOutputColumn
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|expr
return|;
block|}
comment|// Used as a fast path for operations that don't modify their input, like unary +
comment|// and casting boolean to long.
specifier|private
name|VectorExpression
name|getIdentityExpression
parameter_list|(
name|List
argument_list|<
name|ExprNodeDesc
argument_list|>
name|childExprList
parameter_list|)
throws|throws
name|HiveException
block|{
name|ExprNodeDesc
name|childExpr
init|=
name|childExprList
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|int
name|inputCol
decl_stmt|;
name|String
name|colType
decl_stmt|;
name|VectorExpression
name|v1
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|childExpr
operator|instanceof
name|ExprNodeGenericFuncDesc
condition|)
block|{
name|v1
operator|=
name|getVectorExpression
argument_list|(
name|childExpr
argument_list|)
expr_stmt|;
name|inputCol
operator|=
name|v1
operator|.
name|getOutputColumn
argument_list|()
expr_stmt|;
name|colType
operator|=
name|v1
operator|.
name|getOutputType
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|childExpr
operator|instanceof
name|ExprNodeColumnDesc
condition|)
block|{
name|ExprNodeColumnDesc
name|colDesc
init|=
operator|(
name|ExprNodeColumnDesc
operator|)
name|childExpr
decl_stmt|;
name|inputCol
operator|=
name|getInputColumnIndex
argument_list|(
name|colDesc
operator|.
name|getColumn
argument_list|()
argument_list|)
expr_stmt|;
name|colType
operator|=
name|colDesc
operator|.
name|getTypeString
argument_list|()
expr_stmt|;
block|}
else|else
block|{
throw|throw
operator|new
name|HiveException
argument_list|(
literal|"Expression not supported: "
operator|+
name|childExpr
argument_list|)
throw|;
block|}
name|VectorExpression
name|expr
init|=
operator|new
name|IdentityExpression
argument_list|(
name|inputCol
argument_list|,
name|colType
argument_list|)
decl_stmt|;
if|if
condition|(
name|v1
operator|!=
literal|null
condition|)
block|{
name|expr
operator|.
name|setChildExpressions
argument_list|(
operator|new
name|VectorExpression
index|[]
block|{
name|v1
block|}
argument_list|)
expr_stmt|;
block|}
return|return
name|expr
return|;
block|}
specifier|private
name|VectorExpression
name|getVectorExpression
parameter_list|(
name|GenericUDF
name|udf
parameter_list|,
name|List
argument_list|<
name|ExprNodeDesc
argument_list|>
name|childExpr
parameter_list|)
throws|throws
name|HiveException
block|{
if|if
condition|(
name|udf
operator|instanceof
name|GenericUDFOPLessThan
condition|)
block|{
return|return
name|getVectorBinaryComparisonFilterExpression
argument_list|(
literal|"Less"
argument_list|,
name|childExpr
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|udf
operator|instanceof
name|GenericUDFOPEqualOrLessThan
condition|)
block|{
return|return
name|getVectorBinaryComparisonFilterExpression
argument_list|(
literal|"LessEqual"
argument_list|,
name|childExpr
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|udf
operator|instanceof
name|GenericUDFOPEqual
condition|)
block|{
return|return
name|getVectorBinaryComparisonFilterExpression
argument_list|(
literal|"Equal"
argument_list|,
name|childExpr
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|udf
operator|instanceof
name|GenericUDFOPGreaterThan
condition|)
block|{
return|return
name|getVectorBinaryComparisonFilterExpression
argument_list|(
literal|"Greater"
argument_list|,
name|childExpr
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|udf
operator|instanceof
name|GenericUDFOPEqualOrGreaterThan
condition|)
block|{
return|return
name|getVectorBinaryComparisonFilterExpression
argument_list|(
literal|"GreaterEqual"
argument_list|,
name|childExpr
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|udf
operator|instanceof
name|GenericUDFOPNotEqual
condition|)
block|{
return|return
name|getVectorBinaryComparisonFilterExpression
argument_list|(
literal|"NotEqual"
argument_list|,
name|childExpr
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|udf
operator|instanceof
name|GenericUDFOPNotNull
condition|)
block|{
return|return
name|getVectorExpression
argument_list|(
operator|(
name|GenericUDFOPNotNull
operator|)
name|udf
argument_list|,
name|childExpr
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|udf
operator|instanceof
name|GenericUDFOPNull
condition|)
block|{
return|return
name|getVectorExpression
argument_list|(
operator|(
name|GenericUDFOPNull
operator|)
name|udf
argument_list|,
name|childExpr
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|udf
operator|instanceof
name|GenericUDFOPAnd
condition|)
block|{
return|return
name|getVectorExpression
argument_list|(
operator|(
name|GenericUDFOPAnd
operator|)
name|udf
argument_list|,
name|childExpr
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|udf
operator|instanceof
name|GenericUDFOPNot
condition|)
block|{
return|return
name|getVectorExpression
argument_list|(
operator|(
name|GenericUDFOPNot
operator|)
name|udf
argument_list|,
name|childExpr
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|udf
operator|instanceof
name|GenericUDFOPOr
condition|)
block|{
return|return
name|getVectorExpression
argument_list|(
operator|(
name|GenericUDFOPOr
operator|)
name|udf
argument_list|,
name|childExpr
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|udf
operator|instanceof
name|GenericUDFBridge
condition|)
block|{
return|return
name|getVectorExpression
argument_list|(
operator|(
name|GenericUDFBridge
operator|)
name|udf
argument_list|,
name|childExpr
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|udf
operator|instanceof
name|GenericUDFToUnixTimeStamp
condition|)
block|{
return|return
name|getVectorExpression
argument_list|(
operator|(
name|GenericUDFToUnixTimeStamp
operator|)
name|udf
argument_list|,
name|childExpr
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|udf
operator|instanceof
name|GenericUDFLower
condition|)
block|{
return|return
name|getUnaryStringExpression
argument_list|(
literal|"StringLower"
argument_list|,
literal|"String"
argument_list|,
name|childExpr
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|udf
operator|instanceof
name|GenericUDFUpper
condition|)
block|{
return|return
name|getUnaryStringExpression
argument_list|(
literal|"StringUpper"
argument_list|,
literal|"String"
argument_list|,
name|childExpr
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|udf
operator|instanceof
name|GenericUDFConcat
condition|)
block|{
return|return
name|getConcatExpression
argument_list|(
name|childExpr
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|udf
operator|instanceof
name|GenericUDFAbs
condition|)
block|{
return|return
name|getUnaryAbsExpression
argument_list|(
name|childExpr
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|udf
operator|instanceof
name|GenericUDFTimestamp
condition|)
block|{
return|return
name|getCastToTimestamp
argument_list|(
name|childExpr
argument_list|)
return|;
block|}
throw|throw
operator|new
name|HiveException
argument_list|(
literal|"Udf: "
operator|+
name|udf
operator|.
name|getClass
argument_list|()
operator|.
name|getSimpleName
argument_list|()
operator|+
literal|", is not supported"
argument_list|)
throw|;
block|}
specifier|private
name|VectorExpression
name|getUnaryAbsExpression
parameter_list|(
name|List
argument_list|<
name|ExprNodeDesc
argument_list|>
name|childExpr
parameter_list|)
throws|throws
name|HiveException
block|{
name|String
name|argType
init|=
name|childExpr
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|getTypeString
argument_list|()
decl_stmt|;
if|if
condition|(
name|isIntFamily
argument_list|(
name|argType
argument_list|)
condition|)
block|{
return|return
name|getUnaryFunctionExpression
argument_list|(
literal|"FuncAbs"
argument_list|,
literal|"Long"
argument_list|,
name|childExpr
argument_list|,
name|GENERATED_EXPR_PACKAGE
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|isFloatFamily
argument_list|(
name|argType
argument_list|)
condition|)
block|{
return|return
name|getUnaryFunctionExpression
argument_list|(
literal|"FuncAbs"
argument_list|,
literal|"Double"
argument_list|,
name|childExpr
argument_list|,
name|GENERATED_EXPR_PACKAGE
argument_list|)
return|;
block|}
throw|throw
operator|new
name|HiveException
argument_list|(
literal|"Udf: Abs() not supported for argument type "
operator|+
name|argType
argument_list|)
throw|;
block|}
specifier|private
name|VectorExpression
name|getVectorExpression
parameter_list|(
name|GenericUDFToUnixTimeStamp
name|udf
parameter_list|,
name|List
argument_list|<
name|ExprNodeDesc
argument_list|>
name|childExpr
parameter_list|)
throws|throws
name|HiveException
block|{
name|ExprNodeDesc
name|leftExpr
init|=
name|childExpr
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|leftExpr
operator|=
name|foldConstantsForUnaryExpression
argument_list|(
name|leftExpr
argument_list|)
expr_stmt|;
name|VectorExpression
name|v1
init|=
name|getVectorExpression
argument_list|(
name|leftExpr
argument_list|)
decl_stmt|;
name|String
name|colType
init|=
name|v1
operator|.
name|getOutputType
argument_list|()
decl_stmt|;
name|String
name|outputType
init|=
literal|"long"
decl_stmt|;
if|if
condition|(
name|colType
operator|.
name|equalsIgnoreCase
argument_list|(
literal|"timestamp"
argument_list|)
condition|)
block|{
name|int
name|inputCol
init|=
name|v1
operator|.
name|getOutputColumn
argument_list|()
decl_stmt|;
name|int
name|outputCol
init|=
name|ocm
operator|.
name|allocateOutputColumn
argument_list|(
name|outputType
argument_list|)
decl_stmt|;
try|try
block|{
name|VectorExpression
name|v2
init|=
operator|new
name|VectorUDFUnixTimeStampLong
argument_list|(
name|inputCol
argument_list|,
name|outputCol
argument_list|)
decl_stmt|;
return|return
name|v2
return|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|e
operator|.
name|printStackTrace
argument_list|()
expr_stmt|;
throw|throw
operator|new
name|HiveException
argument_list|(
literal|"Udf: Vector"
operator|+
name|udf
operator|+
literal|", could not be initialized for "
operator|+
name|colType
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
throw|throw
operator|new
name|HiveException
argument_list|(
literal|"Udf: "
operator|+
name|udf
operator|.
name|getClass
argument_list|()
operator|.
name|getSimpleName
argument_list|()
operator|+
literal|", is not supported"
argument_list|)
throw|;
block|}
specifier|private
name|VectorExpression
name|getVectorExpression
parameter_list|(
name|GenericUDFBridge
name|udf
parameter_list|,
name|List
argument_list|<
name|ExprNodeDesc
argument_list|>
name|childExpr
parameter_list|)
throws|throws
name|HiveException
block|{
name|Class
argument_list|<
name|?
extends|extends
name|UDF
argument_list|>
name|cl
init|=
name|udf
operator|.
name|getUdfClass
argument_list|()
decl_stmt|;
comment|// (UDFBaseNumericOp.class.isAssignableFrom(cl)) == true
if|if
condition|(
name|cl
operator|.
name|equals
argument_list|(
name|UDFOPPlus
operator|.
name|class
argument_list|)
condition|)
block|{
return|return
name|getBinaryArithmeticExpression
argument_list|(
literal|"Add"
argument_list|,
name|childExpr
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|cl
operator|.
name|equals
argument_list|(
name|UDFOPMinus
operator|.
name|class
argument_list|)
condition|)
block|{
return|return
name|getBinaryArithmeticExpression
argument_list|(
literal|"Subtract"
argument_list|,
name|childExpr
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|cl
operator|.
name|equals
argument_list|(
name|UDFOPMultiply
operator|.
name|class
argument_list|)
condition|)
block|{
return|return
name|getBinaryArithmeticExpression
argument_list|(
literal|"Multiply"
argument_list|,
name|childExpr
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|cl
operator|.
name|equals
argument_list|(
name|UDFOPDivide
operator|.
name|class
argument_list|)
condition|)
block|{
return|return
name|getBinaryArithmeticExpression
argument_list|(
literal|"Divide"
argument_list|,
name|childExpr
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|cl
operator|.
name|equals
argument_list|(
name|UDFOPMod
operator|.
name|class
argument_list|)
condition|)
block|{
return|return
name|getBinaryArithmeticExpression
argument_list|(
literal|"Modulo"
argument_list|,
name|childExpr
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|cl
operator|.
name|equals
argument_list|(
name|UDFOPNegative
operator|.
name|class
argument_list|)
condition|)
block|{
return|return
name|getUnaryMinusExpression
argument_list|(
name|childExpr
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|cl
operator|.
name|equals
argument_list|(
name|UDFOPPositive
operator|.
name|class
argument_list|)
condition|)
block|{
return|return
name|getIdentityExpression
argument_list|(
name|childExpr
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|cl
operator|.
name|equals
argument_list|(
name|UDFYear
operator|.
name|class
argument_list|)
operator|||
name|cl
operator|.
name|equals
argument_list|(
name|UDFMonth
operator|.
name|class
argument_list|)
operator|||
name|cl
operator|.
name|equals
argument_list|(
name|UDFWeekOfYear
operator|.
name|class
argument_list|)
operator|||
name|cl
operator|.
name|equals
argument_list|(
name|UDFDayOfMonth
operator|.
name|class
argument_list|)
operator|||
name|cl
operator|.
name|equals
argument_list|(
name|UDFHour
operator|.
name|class
argument_list|)
operator|||
name|cl
operator|.
name|equals
argument_list|(
name|UDFMinute
operator|.
name|class
argument_list|)
operator|||
name|cl
operator|.
name|equals
argument_list|(
name|UDFSecond
operator|.
name|class
argument_list|)
condition|)
block|{
return|return
name|getTimestampFieldExpression
argument_list|(
name|cl
operator|.
name|getSimpleName
argument_list|()
argument_list|,
name|childExpr
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|cl
operator|.
name|equals
argument_list|(
name|UDFLike
operator|.
name|class
argument_list|)
condition|)
block|{
return|return
name|getLikeExpression
argument_list|(
name|childExpr
argument_list|,
literal|true
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|cl
operator|.
name|equals
argument_list|(
name|UDFRegExp
operator|.
name|class
argument_list|)
condition|)
block|{
return|return
name|getLikeExpression
argument_list|(
name|childExpr
argument_list|,
literal|false
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|cl
operator|.
name|equals
argument_list|(
name|UDFLength
operator|.
name|class
argument_list|)
condition|)
block|{
return|return
name|getUnaryStringExpression
argument_list|(
literal|"StringLength"
argument_list|,
literal|"Long"
argument_list|,
name|childExpr
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|cl
operator|.
name|equals
argument_list|(
name|UDFSubstr
operator|.
name|class
argument_list|)
condition|)
block|{
return|return
name|getSubstrExpression
argument_list|(
name|childExpr
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|cl
operator|.
name|equals
argument_list|(
name|UDFLTrim
operator|.
name|class
argument_list|)
condition|)
block|{
return|return
name|getUnaryStringExpression
argument_list|(
literal|"StringLTrim"
argument_list|,
literal|"String"
argument_list|,
name|childExpr
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|cl
operator|.
name|equals
argument_list|(
name|UDFRTrim
operator|.
name|class
argument_list|)
condition|)
block|{
return|return
name|getUnaryStringExpression
argument_list|(
literal|"StringRTrim"
argument_list|,
literal|"String"
argument_list|,
name|childExpr
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|cl
operator|.
name|equals
argument_list|(
name|UDFTrim
operator|.
name|class
argument_list|)
condition|)
block|{
return|return
name|getUnaryStringExpression
argument_list|(
literal|"StringTrim"
argument_list|,
literal|"String"
argument_list|,
name|childExpr
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|cl
operator|.
name|equals
argument_list|(
name|UDFSin
operator|.
name|class
argument_list|)
condition|)
block|{
return|return
name|getUnaryFunctionExpression
argument_list|(
literal|"FuncSin"
argument_list|,
literal|"Double"
argument_list|,
name|childExpr
argument_list|,
name|GENERATED_EXPR_PACKAGE
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|cl
operator|.
name|equals
argument_list|(
name|UDFCos
operator|.
name|class
argument_list|)
condition|)
block|{
return|return
name|getUnaryFunctionExpression
argument_list|(
literal|"FuncCos"
argument_list|,
literal|"Double"
argument_list|,
name|childExpr
argument_list|,
name|GENERATED_EXPR_PACKAGE
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|cl
operator|.
name|equals
argument_list|(
name|UDFTan
operator|.
name|class
argument_list|)
condition|)
block|{
return|return
name|getUnaryFunctionExpression
argument_list|(
literal|"FuncTan"
argument_list|,
literal|"Double"
argument_list|,
name|childExpr
argument_list|,
name|GENERATED_EXPR_PACKAGE
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|cl
operator|.
name|equals
argument_list|(
name|UDFAsin
operator|.
name|class
argument_list|)
condition|)
block|{
return|return
name|getUnaryFunctionExpression
argument_list|(
literal|"FuncASin"
argument_list|,
literal|"Double"
argument_list|,
name|childExpr
argument_list|,
name|GENERATED_EXPR_PACKAGE
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|cl
operator|.
name|equals
argument_list|(
name|UDFAcos
operator|.
name|class
argument_list|)
condition|)
block|{
return|return
name|getUnaryFunctionExpression
argument_list|(
literal|"FuncACos"
argument_list|,
literal|"Double"
argument_list|,
name|childExpr
argument_list|,
name|GENERATED_EXPR_PACKAGE
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|cl
operator|.
name|equals
argument_list|(
name|UDFAtan
operator|.
name|class
argument_list|)
condition|)
block|{
return|return
name|getUnaryFunctionExpression
argument_list|(
literal|"FuncATan"
argument_list|,
literal|"Double"
argument_list|,
name|childExpr
argument_list|,
name|GENERATED_EXPR_PACKAGE
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|cl
operator|.
name|equals
argument_list|(
name|UDFFloor
operator|.
name|class
argument_list|)
condition|)
block|{
return|return
name|getUnaryFunctionExpression
argument_list|(
literal|"FuncFloor"
argument_list|,
literal|"Long"
argument_list|,
name|childExpr
argument_list|,
name|GENERATED_EXPR_PACKAGE
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|cl
operator|.
name|equals
argument_list|(
name|UDFCeil
operator|.
name|class
argument_list|)
condition|)
block|{
return|return
name|getUnaryFunctionExpression
argument_list|(
literal|"FuncCeil"
argument_list|,
literal|"Long"
argument_list|,
name|childExpr
argument_list|,
name|GENERATED_EXPR_PACKAGE
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|cl
operator|.
name|equals
argument_list|(
name|UDFDegrees
operator|.
name|class
argument_list|)
condition|)
block|{
return|return
name|getUnaryFunctionExpression
argument_list|(
literal|"FuncDegrees"
argument_list|,
literal|"Double"
argument_list|,
name|childExpr
argument_list|,
name|GENERATED_EXPR_PACKAGE
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|cl
operator|.
name|equals
argument_list|(
name|UDFRadians
operator|.
name|class
argument_list|)
condition|)
block|{
return|return
name|getUnaryFunctionExpression
argument_list|(
literal|"FuncRadians"
argument_list|,
literal|"Double"
argument_list|,
name|childExpr
argument_list|,
name|GENERATED_EXPR_PACKAGE
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|cl
operator|.
name|equals
argument_list|(
name|UDFLn
operator|.
name|class
argument_list|)
condition|)
block|{
return|return
name|getUnaryFunctionExpression
argument_list|(
literal|"FuncLn"
argument_list|,
literal|"Double"
argument_list|,
name|childExpr
argument_list|,
name|GENERATED_EXPR_PACKAGE
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|cl
operator|.
name|equals
argument_list|(
name|UDFLog2
operator|.
name|class
argument_list|)
condition|)
block|{
return|return
name|getUnaryFunctionExpression
argument_list|(
literal|"FuncLog2"
argument_list|,
literal|"Double"
argument_list|,
name|childExpr
argument_list|,
name|GENERATED_EXPR_PACKAGE
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|cl
operator|.
name|equals
argument_list|(
name|UDFLog10
operator|.
name|class
argument_list|)
condition|)
block|{
return|return
name|getUnaryFunctionExpression
argument_list|(
literal|"FuncLog10"
argument_list|,
literal|"Double"
argument_list|,
name|childExpr
argument_list|,
name|GENERATED_EXPR_PACKAGE
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|cl
operator|.
name|equals
argument_list|(
name|UDFSign
operator|.
name|class
argument_list|)
condition|)
block|{
return|return
name|getUnaryFunctionExpression
argument_list|(
literal|"FuncSign"
argument_list|,
literal|"Double"
argument_list|,
name|childExpr
argument_list|,
name|GENERATED_EXPR_PACKAGE
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|cl
operator|.
name|equals
argument_list|(
name|UDFSqrt
operator|.
name|class
argument_list|)
condition|)
block|{
return|return
name|getUnaryFunctionExpression
argument_list|(
literal|"FuncSqrt"
argument_list|,
literal|"Double"
argument_list|,
name|childExpr
argument_list|,
name|GENERATED_EXPR_PACKAGE
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|cl
operator|.
name|equals
argument_list|(
name|UDFExp
operator|.
name|class
argument_list|)
condition|)
block|{
return|return
name|getUnaryFunctionExpression
argument_list|(
literal|"FuncExp"
argument_list|,
literal|"Double"
argument_list|,
name|childExpr
argument_list|,
name|GENERATED_EXPR_PACKAGE
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|cl
operator|.
name|equals
argument_list|(
name|UDFLog
operator|.
name|class
argument_list|)
condition|)
block|{
return|return
name|getLogWithBaseExpression
argument_list|(
name|childExpr
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|cl
operator|.
name|equals
argument_list|(
name|UDFPower
operator|.
name|class
argument_list|)
condition|)
block|{
return|return
name|getPowerExpression
argument_list|(
name|childExpr
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|cl
operator|.
name|equals
argument_list|(
name|UDFRound
operator|.
name|class
argument_list|)
condition|)
block|{
return|return
name|getRoundExpression
argument_list|(
name|childExpr
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|cl
operator|.
name|equals
argument_list|(
name|UDFRand
operator|.
name|class
argument_list|)
condition|)
block|{
return|return
name|getRandExpression
argument_list|(
name|childExpr
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|cl
operator|.
name|equals
argument_list|(
name|UDFBin
operator|.
name|class
argument_list|)
condition|)
block|{
return|return
name|getUnaryStringExpression
argument_list|(
literal|"FuncBin"
argument_list|,
literal|"String"
argument_list|,
name|childExpr
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|isCastToIntFamily
argument_list|(
name|cl
argument_list|)
condition|)
block|{
return|return
name|getCastToLongExpression
argument_list|(
name|childExpr
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|cl
operator|.
name|equals
argument_list|(
name|UDFToBoolean
operator|.
name|class
argument_list|)
condition|)
block|{
return|return
name|getCastToBoolean
argument_list|(
name|childExpr
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|isCastToFloatFamily
argument_list|(
name|cl
argument_list|)
condition|)
block|{
return|return
name|getCastToDoubleExpression
argument_list|(
name|childExpr
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|cl
operator|.
name|equals
argument_list|(
name|UDFToString
operator|.
name|class
argument_list|)
condition|)
block|{
return|return
name|getCastToString
argument_list|(
name|childExpr
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|cl
operator|.
name|equals
argument_list|(
name|UDFPosMod
operator|.
name|class
argument_list|)
condition|)
block|{
return|return
name|getPosModExpression
argument_list|(
name|childExpr
argument_list|)
return|;
block|}
throw|throw
operator|new
name|HiveException
argument_list|(
literal|"Udf: "
operator|+
name|udf
operator|.
name|getClass
argument_list|()
operator|.
name|getSimpleName
argument_list|()
operator|+
literal|", is not supported"
argument_list|)
throw|;
block|}
specifier|private
name|VectorExpression
name|getPosModExpression
parameter_list|(
name|List
argument_list|<
name|ExprNodeDesc
argument_list|>
name|childExpr
parameter_list|)
throws|throws
name|HiveException
block|{
name|String
name|inputType
init|=
name|childExpr
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|getTypeString
argument_list|()
decl_stmt|;
if|if
condition|(
name|isIntFamily
argument_list|(
name|inputType
argument_list|)
condition|)
block|{
comment|// Try to get the second argument (the modulo divisor)
name|long
name|divisor
init|=
name|getLongScalar
argument_list|(
name|childExpr
operator|.
name|get
argument_list|(
literal|1
argument_list|)
argument_list|)
decl_stmt|;
comment|// Use the standard logic for a unary function to handle the first argument.
name|VectorExpression
name|e
init|=
name|getUnaryFunctionExpression
argument_list|(
literal|"PosMod"
argument_list|,
literal|"Long"
argument_list|,
name|childExpr
argument_list|,
name|CUSTOM_EXPR_PACKAGE
argument_list|)
decl_stmt|;
comment|// Set second argument for this special case
operator|(
operator|(
name|ISetLongArg
operator|)
name|e
operator|)
operator|.
name|setArg
argument_list|(
name|divisor
argument_list|)
expr_stmt|;
return|return
name|e
return|;
block|}
elseif|else
if|if
condition|(
name|isFloatFamily
argument_list|(
name|inputType
argument_list|)
condition|)
block|{
comment|// Try to get the second argument (the modulo divisor)
name|double
name|divisor
init|=
name|getDoubleScalar
argument_list|(
name|childExpr
operator|.
name|get
argument_list|(
literal|1
argument_list|)
argument_list|)
decl_stmt|;
comment|// Use the standard logic for a unary function to handle the first argument.
name|VectorExpression
name|e
init|=
name|getUnaryFunctionExpression
argument_list|(
literal|"PosMod"
argument_list|,
literal|"Double"
argument_list|,
name|childExpr
argument_list|,
name|CUSTOM_EXPR_PACKAGE
argument_list|)
decl_stmt|;
comment|// Set second argument for this special case
operator|(
operator|(
name|ISetDoubleArg
operator|)
name|e
operator|)
operator|.
name|setArg
argument_list|(
name|divisor
argument_list|)
expr_stmt|;
return|return
name|e
return|;
block|}
throw|throw
operator|new
name|HiveException
argument_list|(
literal|"Unhandled input type for PMOD():  "
operator|+
name|inputType
argument_list|)
throw|;
block|}
specifier|private
name|VectorExpression
name|getCastToTimestamp
parameter_list|(
name|List
argument_list|<
name|ExprNodeDesc
argument_list|>
name|childExpr
parameter_list|)
throws|throws
name|HiveException
block|{
name|String
name|inputType
init|=
name|childExpr
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|getTypeString
argument_list|()
decl_stmt|;
if|if
condition|(
name|isIntFamily
argument_list|(
name|inputType
argument_list|)
condition|)
block|{
return|return
name|getUnaryFunctionExpression
argument_list|(
literal|"CastLongToTimestampVia"
argument_list|,
literal|"Long"
argument_list|,
name|childExpr
argument_list|,
name|GENERATED_EXPR_PACKAGE
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|isFloatFamily
argument_list|(
name|inputType
argument_list|)
condition|)
block|{
return|return
name|getUnaryFunctionExpression
argument_list|(
literal|"CastDoubleToTimestampVia"
argument_list|,
literal|"Long"
argument_list|,
name|childExpr
argument_list|,
name|GENERATED_EXPR_PACKAGE
argument_list|)
return|;
block|}
comment|// The string type is deliberately omitted -- it's handled elsewhere. See isLegacyPathUDF.
throw|throw
operator|new
name|HiveException
argument_list|(
literal|"Unhandled cast input type: "
operator|+
name|inputType
argument_list|)
throw|;
block|}
specifier|private
name|VectorExpression
name|getCastToString
parameter_list|(
name|List
argument_list|<
name|ExprNodeDesc
argument_list|>
name|childExpr
parameter_list|)
throws|throws
name|HiveException
block|{
name|String
name|inputType
init|=
name|childExpr
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|getTypeString
argument_list|()
decl_stmt|;
if|if
condition|(
name|inputType
operator|.
name|equals
argument_list|(
literal|"boolean"
argument_list|)
condition|)
block|{
comment|// Boolean must come before the integer family. It's a special case.
return|return
name|getUnaryFunctionExpression
argument_list|(
literal|"CastBooleanToStringVia"
argument_list|,
literal|"String"
argument_list|,
name|childExpr
argument_list|,
name|CUSTOM_EXPR_PACKAGE
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|isIntFamily
argument_list|(
name|inputType
argument_list|)
condition|)
block|{
return|return
name|getUnaryFunctionExpression
argument_list|(
literal|"Cast"
argument_list|,
literal|"String"
argument_list|,
name|childExpr
argument_list|,
name|CUSTOM_EXPR_PACKAGE
argument_list|)
return|;
block|}
comment|/* The string type is deliberately omitted -- the planner removes string to string casts.      * Timestamp, float, and double types are handled by the legacy code path. See isLegacyPathUDF.      */
throw|throw
operator|new
name|HiveException
argument_list|(
literal|"Unhandled cast input type: "
operator|+
name|inputType
argument_list|)
throw|;
block|}
specifier|private
name|VectorExpression
name|getCastToDoubleExpression
parameter_list|(
name|List
argument_list|<
name|ExprNodeDesc
argument_list|>
name|childExpr
parameter_list|)
throws|throws
name|HiveException
block|{
name|String
name|inputType
init|=
name|childExpr
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|getTypeString
argument_list|()
decl_stmt|;
if|if
condition|(
name|isIntFamily
argument_list|(
name|inputType
argument_list|)
condition|)
block|{
return|return
name|getUnaryFunctionExpression
argument_list|(
literal|"Cast"
argument_list|,
literal|"Double"
argument_list|,
name|childExpr
argument_list|,
name|GENERATED_EXPR_PACKAGE
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|inputType
operator|.
name|equals
argument_list|(
literal|"timestamp"
argument_list|)
condition|)
block|{
return|return
name|getUnaryFunctionExpression
argument_list|(
literal|"CastTimestampToDoubleVia"
argument_list|,
literal|"Double"
argument_list|,
name|childExpr
argument_list|,
name|GENERATED_EXPR_PACKAGE
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|isFloatFamily
argument_list|(
name|inputType
argument_list|)
condition|)
block|{
comment|// float types require no conversion, so use a no-op
return|return
name|getIdentityExpression
argument_list|(
name|childExpr
argument_list|)
return|;
block|}
comment|// The string type is deliberately omitted -- it's handled elsewhere. See isLegacyPathUDF.
throw|throw
operator|new
name|HiveException
argument_list|(
literal|"Unhandled cast input type: "
operator|+
name|inputType
argument_list|)
throw|;
block|}
specifier|private
name|VectorExpression
name|getCastToBoolean
parameter_list|(
name|List
argument_list|<
name|ExprNodeDesc
argument_list|>
name|childExpr
parameter_list|)
throws|throws
name|HiveException
block|{
name|String
name|inputType
init|=
name|childExpr
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|getTypeString
argument_list|()
decl_stmt|;
if|if
condition|(
name|isFloatFamily
argument_list|(
name|inputType
argument_list|)
condition|)
block|{
return|return
name|getUnaryFunctionExpression
argument_list|(
literal|"CastDoubleToBooleanVia"
argument_list|,
literal|"Long"
argument_list|,
name|childExpr
argument_list|,
name|GENERATED_EXPR_PACKAGE
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|isIntFamily
argument_list|(
name|inputType
argument_list|)
operator|||
name|inputType
operator|.
name|equals
argument_list|(
literal|"timestamp"
argument_list|)
condition|)
block|{
return|return
name|getUnaryFunctionExpression
argument_list|(
literal|"CastLongToBooleanVia"
argument_list|,
literal|"Long"
argument_list|,
name|childExpr
argument_list|,
name|GENERATED_EXPR_PACKAGE
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|inputType
operator|.
name|equals
argument_list|(
literal|"string"
argument_list|)
condition|)
block|{
comment|// string casts to false if it is 0 characters long, otherwise true
name|VectorExpression
name|lenExpr
init|=
name|getUnaryStringExpression
argument_list|(
literal|"StringLength"
argument_list|,
literal|"Long"
argument_list|,
name|childExpr
argument_list|)
decl_stmt|;
name|int
name|outputCol
init|=
name|ocm
operator|.
name|allocateOutputColumn
argument_list|(
literal|"integer"
argument_list|)
decl_stmt|;
name|VectorExpression
name|lenToBoolExpr
init|=
operator|new
name|CastLongToBooleanViaLongToLong
argument_list|(
name|lenExpr
operator|.
name|getOutputColumn
argument_list|()
argument_list|,
name|outputCol
argument_list|)
decl_stmt|;
name|lenToBoolExpr
operator|.
name|setChildExpressions
argument_list|(
operator|new
name|VectorExpression
index|[]
block|{
name|lenExpr
block|}
argument_list|)
expr_stmt|;
name|ocm
operator|.
name|freeOutputColumn
argument_list|(
name|lenExpr
operator|.
name|getOutputColumn
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|lenToBoolExpr
return|;
block|}
comment|// cast(booleanExpr as boolean) case is omitted because planner removes it as a no-op
throw|throw
operator|new
name|HiveException
argument_list|(
literal|"Unhandled cast input type: "
operator|+
name|inputType
argument_list|)
throw|;
block|}
specifier|private
name|VectorExpression
name|getCastToLongExpression
parameter_list|(
name|List
argument_list|<
name|ExprNodeDesc
argument_list|>
name|childExpr
parameter_list|)
throws|throws
name|HiveException
block|{
name|String
name|inputType
init|=
name|childExpr
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|getTypeString
argument_list|()
decl_stmt|;
if|if
condition|(
name|isFloatFamily
argument_list|(
name|inputType
argument_list|)
condition|)
block|{
return|return
name|getUnaryFunctionExpression
argument_list|(
literal|"Cast"
argument_list|,
literal|"Long"
argument_list|,
name|childExpr
argument_list|,
name|GENERATED_EXPR_PACKAGE
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|inputType
operator|.
name|equals
argument_list|(
literal|"timestamp"
argument_list|)
condition|)
block|{
return|return
name|getUnaryFunctionExpression
argument_list|(
literal|"CastTimestampToLongVia"
argument_list|,
literal|"Long"
argument_list|,
name|childExpr
argument_list|,
name|GENERATED_EXPR_PACKAGE
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|isIntFamily
argument_list|(
name|inputType
argument_list|)
condition|)
block|{
comment|// integer and boolean types require no conversion, so use a no-op
return|return
name|getIdentityExpression
argument_list|(
name|childExpr
argument_list|)
return|;
block|}
comment|// string type is deliberately omitted -- it's handled elsewhere. See isLegacyPathUDF.
throw|throw
operator|new
name|HiveException
argument_list|(
literal|"Unhandled cast input type: "
operator|+
name|inputType
argument_list|)
throw|;
block|}
specifier|private
name|VectorExpression
name|getRandExpression
parameter_list|(
name|List
argument_list|<
name|ExprNodeDesc
argument_list|>
name|childExpr
parameter_list|)
throws|throws
name|HiveException
block|{
comment|// prepare one output column
name|int
name|outputCol
init|=
name|ocm
operator|.
name|allocateOutputColumn
argument_list|(
literal|"Double"
argument_list|)
decl_stmt|;
if|if
condition|(
name|childExpr
operator|==
literal|null
operator|||
name|childExpr
operator|.
name|size
argument_list|()
operator|==
literal|0
condition|)
block|{
comment|// make no-argument vectorized Rand expression
return|return
operator|new
name|FuncRand
argument_list|(
name|outputCol
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|childExpr
operator|.
name|size
argument_list|()
operator|==
literal|1
condition|)
block|{
comment|// Make vectorized Rand expression with seed
name|long
name|seed
init|=
name|getLongScalar
argument_list|(
name|childExpr
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|)
decl_stmt|;
return|return
operator|new
name|FuncRand
argument_list|(
name|seed
argument_list|,
name|outputCol
argument_list|)
return|;
block|}
throw|throw
operator|new
name|HiveException
argument_list|(
literal|"Vectorization error. Rand has more than 1 argument."
argument_list|)
throw|;
block|}
specifier|private
name|VectorExpression
name|getRoundExpression
parameter_list|(
name|List
argument_list|<
name|ExprNodeDesc
argument_list|>
name|childExpr
parameter_list|)
throws|throws
name|HiveException
block|{
comment|// Handle one-argument case
if|if
condition|(
name|childExpr
operator|.
name|size
argument_list|()
operator|==
literal|1
condition|)
block|{
return|return
name|getUnaryFunctionExpression
argument_list|(
literal|"FuncRound"
argument_list|,
literal|"Double"
argument_list|,
name|childExpr
argument_list|,
name|GENERATED_EXPR_PACKAGE
argument_list|)
return|;
block|}
comment|// Handle two-argument case
comment|// Try to get the second argument (the number of digits)
name|long
name|numDigits
init|=
name|getLongScalar
argument_list|(
name|childExpr
operator|.
name|get
argument_list|(
literal|1
argument_list|)
argument_list|)
decl_stmt|;
comment|// Use the standard logic for a unary function to handle the first argument.
name|VectorExpression
name|e
init|=
name|getUnaryFunctionExpression
argument_list|(
literal|"RoundWithNumDigits"
argument_list|,
literal|"Double"
argument_list|,
name|childExpr
argument_list|,
name|CUSTOM_EXPR_PACKAGE
argument_list|)
decl_stmt|;
comment|// Set second argument for this special case
operator|(
operator|(
name|ISetLongArg
operator|)
name|e
operator|)
operator|.
name|setArg
argument_list|(
name|numDigits
argument_list|)
expr_stmt|;
return|return
name|e
return|;
block|}
specifier|private
name|VectorExpression
name|getPowerExpression
parameter_list|(
name|List
argument_list|<
name|ExprNodeDesc
argument_list|>
name|childExpr
parameter_list|)
throws|throws
name|HiveException
block|{
name|String
name|argType
init|=
name|childExpr
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|getTypeString
argument_list|()
decl_stmt|;
comment|// Try to get the second argument, typically a constant value (the power).
name|double
name|power
init|=
name|getDoubleScalar
argument_list|(
name|childExpr
operator|.
name|get
argument_list|(
literal|1
argument_list|)
argument_list|)
decl_stmt|;
comment|// Use the standard logic for a unary function to handle the first argument.
name|VectorExpression
name|e
init|=
name|getUnaryFunctionExpression
argument_list|(
literal|"FuncPower"
argument_list|,
literal|"Double"
argument_list|,
name|childExpr
argument_list|,
name|CUSTOM_EXPR_PACKAGE
argument_list|)
decl_stmt|;
comment|// Set the second argument for this special case
operator|(
operator|(
name|ISetDoubleArg
operator|)
name|e
operator|)
operator|.
name|setArg
argument_list|(
name|power
argument_list|)
expr_stmt|;
return|return
name|e
return|;
block|}
specifier|private
name|VectorExpression
name|getLogWithBaseExpression
parameter_list|(
name|List
argument_list|<
name|ExprNodeDesc
argument_list|>
name|childExpr
parameter_list|)
throws|throws
name|HiveException
block|{
if|if
condition|(
name|childExpr
operator|.
name|size
argument_list|()
operator|==
literal|1
condition|)
block|{
comment|// No base provided, so this is equivalent to Ln
return|return
name|getUnaryFunctionExpression
argument_list|(
literal|"FuncLn"
argument_list|,
literal|"Double"
argument_list|,
name|childExpr
argument_list|,
name|GENERATED_EXPR_PACKAGE
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|childExpr
operator|.
name|size
argument_list|()
operator|==
literal|2
condition|)
block|{
comment|// Get the type of the (normally variable) input expression
name|String
name|argType
init|=
name|childExpr
operator|.
name|get
argument_list|(
literal|1
argument_list|)
operator|.
name|getTypeString
argument_list|()
decl_stmt|;
comment|// Try to get the first argument, typically a constant value (the base)
name|double
name|base
init|=
name|getDoubleScalar
argument_list|(
name|childExpr
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|)
decl_stmt|;
comment|// Use the standard logic for a unary function to handle the second argument.
name|VectorExpression
name|e
init|=
name|getUnaryFunctionExpression
argument_list|(
literal|"FuncLogWithBase"
argument_list|,
literal|"Double"
argument_list|,
name|childExpr
operator|.
name|subList
argument_list|(
literal|1
argument_list|,
literal|2
argument_list|)
argument_list|,
comment|// pass the second argument as the first
name|CUSTOM_EXPR_PACKAGE
argument_list|)
decl_stmt|;
comment|// set the first argument (the base) for this special case
operator|(
operator|(
name|ISetDoubleArg
operator|)
name|e
operator|)
operator|.
name|setArg
argument_list|(
name|base
argument_list|)
expr_stmt|;
return|return
name|e
return|;
block|}
throw|throw
operator|new
name|HiveException
argument_list|(
literal|"Udf: Log could not be vectorized"
argument_list|)
throw|;
block|}
specifier|private
name|double
name|getDoubleScalar
parameter_list|(
name|ExprNodeDesc
name|expr
parameter_list|)
throws|throws
name|HiveException
block|{
if|if
condition|(
operator|!
operator|(
name|expr
operator|instanceof
name|ExprNodeConstantDesc
operator|)
condition|)
block|{
throw|throw
operator|new
name|HiveException
argument_list|(
literal|"Constant value expected for UDF argument. "
operator|+
literal|"Non-constant argument not supported for vectorization."
argument_list|)
throw|;
block|}
name|ExprNodeConstantDesc
name|constExpr
init|=
operator|(
name|ExprNodeConstantDesc
operator|)
name|expr
decl_stmt|;
name|Object
name|obj
init|=
name|getScalarValue
argument_list|(
name|constExpr
argument_list|)
decl_stmt|;
if|if
condition|(
name|obj
operator|instanceof
name|Double
condition|)
block|{
return|return
operator|(
operator|(
name|Double
operator|)
name|obj
operator|)
operator|.
name|doubleValue
argument_list|()
return|;
block|}
elseif|else
if|if
condition|(
name|obj
operator|instanceof
name|DoubleWritable
condition|)
block|{
return|return
operator|(
operator|(
name|DoubleWritable
operator|)
name|obj
operator|)
operator|.
name|get
argument_list|()
return|;
block|}
elseif|else
if|if
condition|(
name|obj
operator|instanceof
name|Integer
condition|)
block|{
return|return
call|(
name|double
call|)
argument_list|(
operator|(
name|Integer
operator|)
name|obj
argument_list|)
operator|.
name|longValue
argument_list|()
return|;
block|}
elseif|else
if|if
condition|(
name|obj
operator|instanceof
name|IntWritable
condition|)
block|{
return|return
call|(
name|double
call|)
argument_list|(
operator|(
name|IntWritable
operator|)
name|obj
argument_list|)
operator|.
name|get
argument_list|()
return|;
block|}
throw|throw
operator|new
name|HiveException
argument_list|(
literal|"Udf: unhandled constant type for scalar argument."
operator|+
literal|"Expecting double or integer"
argument_list|)
throw|;
block|}
specifier|private
name|long
name|getLongScalar
parameter_list|(
name|ExprNodeDesc
name|expr
parameter_list|)
throws|throws
name|HiveException
block|{
if|if
condition|(
operator|!
operator|(
name|expr
operator|instanceof
name|ExprNodeConstantDesc
operator|)
condition|)
block|{
throw|throw
operator|new
name|HiveException
argument_list|(
literal|"Constant value expected for UDF argument. "
operator|+
literal|"Non-constant argument not supported for vectorization."
argument_list|)
throw|;
block|}
name|ExprNodeConstantDesc
name|constExpr
init|=
operator|(
name|ExprNodeConstantDesc
operator|)
name|expr
decl_stmt|;
name|Object
name|obj
init|=
name|getScalarValue
argument_list|(
name|constExpr
argument_list|)
decl_stmt|;
if|if
condition|(
name|obj
operator|instanceof
name|Integer
condition|)
block|{
return|return
call|(
name|long
call|)
argument_list|(
operator|(
name|Integer
operator|)
name|obj
argument_list|)
operator|.
name|longValue
argument_list|()
return|;
block|}
elseif|else
if|if
condition|(
name|obj
operator|instanceof
name|IntWritable
condition|)
block|{
return|return
call|(
name|long
call|)
argument_list|(
operator|(
name|IntWritable
operator|)
name|obj
argument_list|)
operator|.
name|get
argument_list|()
return|;
block|}
elseif|else
if|if
condition|(
name|obj
operator|instanceof
name|Long
condition|)
block|{
return|return
operator|(
operator|(
name|Long
operator|)
name|obj
operator|)
operator|.
name|longValue
argument_list|()
return|;
block|}
elseif|else
if|if
condition|(
name|obj
operator|instanceof
name|LongWritable
condition|)
block|{
return|return
operator|(
operator|(
name|LongWritable
operator|)
name|obj
operator|)
operator|.
name|get
argument_list|()
return|;
block|}
throw|throw
operator|new
name|HiveException
argument_list|(
literal|"Udf: unhandled constant type for scalar argument."
operator|+
literal|"Expecting integer or bigint"
argument_list|)
throw|;
block|}
comment|/* Return a vector expression for string concatenation, including the column-scalar,    * scalar-column, and column-column cases.    */
specifier|private
name|VectorExpression
name|getConcatExpression
parameter_list|(
name|List
argument_list|<
name|ExprNodeDesc
argument_list|>
name|childExprList
parameter_list|)
throws|throws
name|HiveException
block|{
name|ExprNodeDesc
name|left
init|=
name|childExprList
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|ExprNodeDesc
name|right
init|=
name|childExprList
operator|.
name|get
argument_list|(
literal|1
argument_list|)
decl_stmt|;
name|int
name|inputColLeft
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|inputColRight
init|=
operator|-
literal|1
decl_stmt|;
name|VectorExpression
name|vLeft
init|=
literal|null
decl_stmt|;
name|VectorExpression
name|vRight
init|=
literal|null
decl_stmt|;
name|VectorExpression
name|expr
init|=
literal|null
decl_stmt|;
comment|// Generate trees to evaluate non-leaf inputs, if there are any.
if|if
condition|(
name|left
operator|instanceof
name|ExprNodeGenericFuncDesc
condition|)
block|{
name|vLeft
operator|=
name|getVectorExpression
argument_list|(
name|left
argument_list|)
expr_stmt|;
name|inputColLeft
operator|=
name|vLeft
operator|.
name|getOutputColumn
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|right
operator|instanceof
name|ExprNodeGenericFuncDesc
condition|)
block|{
name|vRight
operator|=
name|getVectorExpression
argument_list|(
name|right
argument_list|)
expr_stmt|;
name|inputColRight
operator|=
name|vRight
operator|.
name|getOutputColumn
argument_list|()
expr_stmt|;
block|}
comment|// Handle case for left input a column and right input a constant
if|if
condition|(
operator|(
name|left
operator|instanceof
name|ExprNodeColumnDesc
operator|||
name|inputColLeft
operator|!=
operator|-
literal|1
operator|)
operator|&&
name|right
operator|instanceof
name|ExprNodeConstantDesc
condition|)
block|{
if|if
condition|(
name|inputColLeft
operator|==
operator|-
literal|1
condition|)
block|{
name|inputColLeft
operator|=
name|getInputColumnIndex
argument_list|(
operator|(
operator|(
name|ExprNodeColumnDesc
operator|)
name|left
operator|)
operator|.
name|getColumn
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|int
name|outputCol
init|=
name|ocm
operator|.
name|allocateOutputColumn
argument_list|(
literal|"String"
argument_list|)
decl_stmt|;
name|byte
index|[]
name|constant
init|=
operator|(
name|byte
index|[]
operator|)
name|getScalarValue
argument_list|(
operator|(
name|ExprNodeConstantDesc
operator|)
name|right
argument_list|)
decl_stmt|;
name|expr
operator|=
operator|new
name|StringConcatColScalar
argument_list|(
name|inputColLeft
argument_list|,
name|outputCol
argument_list|,
name|constant
argument_list|)
expr_stmt|;
if|if
condition|(
name|vLeft
operator|!=
literal|null
condition|)
block|{
name|expr
operator|.
name|setChildExpressions
argument_list|(
operator|new
name|VectorExpression
index|[]
block|{
name|vLeft
block|}
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Handle case for left input a constant and right input a column
elseif|else
if|if
condition|(
operator|(
name|left
operator|instanceof
name|ExprNodeConstantDesc
operator|)
operator|&&
operator|(
name|right
operator|instanceof
name|ExprNodeColumnDesc
operator|||
name|inputColRight
operator|!=
operator|-
literal|1
operator|)
condition|)
block|{
if|if
condition|(
name|inputColRight
operator|==
operator|-
literal|1
condition|)
block|{
name|inputColRight
operator|=
name|getInputColumnIndex
argument_list|(
operator|(
operator|(
name|ExprNodeColumnDesc
operator|)
name|right
operator|)
operator|.
name|getColumn
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|int
name|outputCol
init|=
name|ocm
operator|.
name|allocateOutputColumn
argument_list|(
literal|"String"
argument_list|)
decl_stmt|;
name|byte
index|[]
name|constant
init|=
operator|(
name|byte
index|[]
operator|)
name|getScalarValue
argument_list|(
operator|(
name|ExprNodeConstantDesc
operator|)
name|left
argument_list|)
decl_stmt|;
name|expr
operator|=
operator|new
name|StringConcatScalarCol
argument_list|(
name|constant
argument_list|,
name|inputColRight
argument_list|,
name|outputCol
argument_list|)
expr_stmt|;
if|if
condition|(
name|vRight
operator|!=
literal|null
condition|)
block|{
name|expr
operator|.
name|setChildExpressions
argument_list|(
operator|new
name|VectorExpression
index|[]
block|{
name|vRight
block|}
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Handle case where both left and right inputs are columns
elseif|else
if|if
condition|(
operator|(
name|left
operator|instanceof
name|ExprNodeColumnDesc
operator|||
name|inputColLeft
operator|!=
operator|-
literal|1
operator|)
operator|&&
operator|(
name|right
operator|instanceof
name|ExprNodeColumnDesc
operator|||
name|inputColRight
operator|!=
operator|-
literal|1
operator|)
condition|)
block|{
if|if
condition|(
name|inputColLeft
operator|==
operator|-
literal|1
condition|)
block|{
name|inputColLeft
operator|=
name|getInputColumnIndex
argument_list|(
operator|(
operator|(
name|ExprNodeColumnDesc
operator|)
name|left
operator|)
operator|.
name|getColumn
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|inputColRight
operator|==
operator|-
literal|1
condition|)
block|{
name|inputColRight
operator|=
name|getInputColumnIndex
argument_list|(
operator|(
operator|(
name|ExprNodeColumnDesc
operator|)
name|right
operator|)
operator|.
name|getColumn
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|int
name|outputCol
init|=
name|ocm
operator|.
name|allocateOutputColumn
argument_list|(
literal|"String"
argument_list|)
decl_stmt|;
name|expr
operator|=
operator|new
name|StringConcatColCol
argument_list|(
name|inputColLeft
argument_list|,
name|inputColRight
argument_list|,
name|outputCol
argument_list|)
expr_stmt|;
if|if
condition|(
name|vLeft
operator|==
literal|null
operator|&&
name|vRight
operator|!=
literal|null
condition|)
block|{
name|expr
operator|.
name|setChildExpressions
argument_list|(
operator|new
name|VectorExpression
index|[]
block|{
name|vRight
block|}
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|vLeft
operator|!=
literal|null
operator|&&
name|vRight
operator|==
literal|null
condition|)
block|{
name|expr
operator|.
name|setChildExpressions
argument_list|(
operator|new
name|VectorExpression
index|[]
block|{
name|vLeft
block|}
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|vLeft
operator|!=
literal|null
operator|&&
name|vRight
operator|!=
literal|null
condition|)
block|{
comment|// Both left and right have child expressions
name|expr
operator|.
name|setChildExpressions
argument_list|(
operator|new
name|VectorExpression
index|[]
block|{
name|vLeft
block|,
name|vRight
block|}
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
throw|throw
operator|new
name|HiveException
argument_list|(
literal|"Failed to vectorize CONCAT()"
argument_list|)
throw|;
block|}
comment|// Free output columns if inputs have non-leaf expression trees.
if|if
condition|(
name|vLeft
operator|!=
literal|null
condition|)
block|{
name|ocm
operator|.
name|freeOutputColumn
argument_list|(
name|vLeft
operator|.
name|getOutputColumn
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|vRight
operator|!=
literal|null
condition|)
block|{
name|ocm
operator|.
name|freeOutputColumn
argument_list|(
name|vRight
operator|.
name|getOutputColumn
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|expr
return|;
block|}
comment|/*    * Return vector expression for a custom (i.e. not built-in) UDF.    */
specifier|private
name|VectorExpression
name|getCustomUDFExpression
parameter_list|(
name|ExprNodeGenericFuncDesc
name|expr
parameter_list|)
throws|throws
name|HiveException
block|{
comment|//GenericUDFBridge udfBridge = (GenericUDFBridge) expr.getGenericUDF();
name|List
argument_list|<
name|ExprNodeDesc
argument_list|>
name|childExprList
init|=
name|expr
operator|.
name|getChildExprs
argument_list|()
decl_stmt|;
comment|// argument descriptors
name|VectorUDFArgDesc
index|[]
name|argDescs
init|=
operator|new
name|VectorUDFArgDesc
index|[
name|expr
operator|.
name|getChildExprs
argument_list|()
operator|.
name|size
argument_list|()
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|argDescs
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|argDescs
index|[
name|i
index|]
operator|=
operator|new
name|VectorUDFArgDesc
argument_list|()
expr_stmt|;
block|}
comment|// positions of variable arguments (columns or non-constant expressions)
name|List
argument_list|<
name|Integer
argument_list|>
name|variableArgPositions
init|=
operator|new
name|ArrayList
argument_list|<
name|Integer
argument_list|>
argument_list|()
decl_stmt|;
comment|// Column numbers of batch corresponding to expression result arguments
name|List
argument_list|<
name|Integer
argument_list|>
name|exprResultColumnNums
init|=
operator|new
name|ArrayList
argument_list|<
name|Integer
argument_list|>
argument_list|()
decl_stmt|;
comment|// Prepare children
name|List
argument_list|<
name|VectorExpression
argument_list|>
name|vectorExprs
init|=
operator|new
name|ArrayList
argument_list|<
name|VectorExpression
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|childExprList
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|ExprNodeDesc
name|child
init|=
name|childExprList
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|child
operator|instanceof
name|ExprNodeGenericFuncDesc
condition|)
block|{
name|VectorExpression
name|e
init|=
name|getVectorExpression
argument_list|(
name|child
argument_list|)
decl_stmt|;
name|vectorExprs
operator|.
name|add
argument_list|(
name|e
argument_list|)
expr_stmt|;
name|variableArgPositions
operator|.
name|add
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|exprResultColumnNums
operator|.
name|add
argument_list|(
name|e
operator|.
name|getOutputColumn
argument_list|()
argument_list|)
expr_stmt|;
name|argDescs
index|[
name|i
index|]
operator|.
name|setVariable
argument_list|(
name|e
operator|.
name|getOutputColumn
argument_list|()
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|child
operator|instanceof
name|ExprNodeColumnDesc
condition|)
block|{
name|variableArgPositions
operator|.
name|add
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|argDescs
index|[
name|i
index|]
operator|.
name|setVariable
argument_list|(
name|getInputColumnIndex
argument_list|(
operator|(
operator|(
name|ExprNodeColumnDesc
operator|)
name|child
operator|)
operator|.
name|getColumn
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|child
operator|instanceof
name|ExprNodeConstantDesc
condition|)
block|{
comment|// this is a constant
name|argDescs
index|[
name|i
index|]
operator|.
name|setConstant
argument_list|(
operator|(
name|ExprNodeConstantDesc
operator|)
name|child
argument_list|)
expr_stmt|;
block|}
else|else
block|{
throw|throw
operator|new
name|HiveException
argument_list|(
literal|"Unable to vectorize Custom UDF"
argument_list|)
throw|;
block|}
block|}
comment|// Allocate output column and get column number;
name|int
name|outputCol
init|=
operator|-
literal|1
decl_stmt|;
name|String
name|resultColVectorType
decl_stmt|;
name|String
name|resultType
init|=
name|expr
operator|.
name|getTypeInfo
argument_list|()
operator|.
name|getTypeName
argument_list|()
decl_stmt|;
if|if
condition|(
name|resultType
operator|.
name|equalsIgnoreCase
argument_list|(
literal|"string"
argument_list|)
condition|)
block|{
name|resultColVectorType
operator|=
literal|"String"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|isIntFamily
argument_list|(
name|resultType
argument_list|)
condition|)
block|{
name|resultColVectorType
operator|=
literal|"Long"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|isFloatFamily
argument_list|(
name|resultType
argument_list|)
condition|)
block|{
name|resultColVectorType
operator|=
literal|"Double"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|resultType
operator|.
name|equalsIgnoreCase
argument_list|(
literal|"timestamp"
argument_list|)
condition|)
block|{
name|resultColVectorType
operator|=
literal|"Long"
expr_stmt|;
block|}
else|else
block|{
throw|throw
operator|new
name|HiveException
argument_list|(
literal|"Unable to vectorize due to unsupported custom UDF return type "
operator|+
name|resultType
argument_list|)
throw|;
block|}
name|outputCol
operator|=
name|ocm
operator|.
name|allocateOutputColumn
argument_list|(
name|resultColVectorType
argument_list|)
expr_stmt|;
comment|// Make vectorized operator
name|VectorExpression
name|ve
decl_stmt|;
name|ve
operator|=
operator|new
name|VectorUDFAdaptor
argument_list|(
name|expr
argument_list|,
name|outputCol
argument_list|,
name|resultColVectorType
argument_list|,
name|argDescs
argument_list|)
expr_stmt|;
comment|// Set child expressions
name|VectorExpression
index|[]
name|childVEs
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|exprResultColumnNums
operator|.
name|size
argument_list|()
operator|!=
literal|0
condition|)
block|{
name|childVEs
operator|=
operator|new
name|VectorExpression
index|[
name|exprResultColumnNums
operator|.
name|size
argument_list|()
index|]
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|childVEs
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|childVEs
index|[
name|i
index|]
operator|=
name|vectorExprs
operator|.
name|get
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
block|}
name|ve
operator|.
name|setChildExpressions
argument_list|(
name|childVEs
argument_list|)
expr_stmt|;
comment|// Free output columns if inputs have non-leaf expression trees.
for|for
control|(
name|Integer
name|i
range|:
name|exprResultColumnNums
control|)
block|{
name|ocm
operator|.
name|freeOutputColumn
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
return|return
name|ve
return|;
block|}
comment|// return true if this is any kind of float
specifier|public
specifier|static
name|boolean
name|isFloatFamily
parameter_list|(
name|String
name|resultType
parameter_list|)
block|{
return|return
name|resultType
operator|.
name|equalsIgnoreCase
argument_list|(
literal|"double"
argument_list|)
operator|||
name|resultType
operator|.
name|equalsIgnoreCase
argument_list|(
literal|"float"
argument_list|)
return|;
block|}
comment|// Return true if this data type is handled in the output vector as an integer.
specifier|public
specifier|static
name|boolean
name|isIntFamily
parameter_list|(
name|String
name|resultType
parameter_list|)
block|{
return|return
name|resultType
operator|.
name|equalsIgnoreCase
argument_list|(
literal|"tinyint"
argument_list|)
operator|||
name|resultType
operator|.
name|equalsIgnoreCase
argument_list|(
literal|"smallint"
argument_list|)
operator|||
name|resultType
operator|.
name|equalsIgnoreCase
argument_list|(
literal|"int"
argument_list|)
operator|||
name|resultType
operator|.
name|equalsIgnoreCase
argument_list|(
literal|"bigint"
argument_list|)
operator|||
name|resultType
operator|.
name|equalsIgnoreCase
argument_list|(
literal|"boolean"
argument_list|)
return|;
block|}
comment|/* Return a unary string vector expression. This is used for functions like    * UPPER() and LOWER().    */
specifier|private
name|VectorExpression
name|getUnaryStringExpression
parameter_list|(
name|String
name|vectorExprClassName
parameter_list|,
name|String
name|resultType
parameter_list|,
comment|// result type name
name|List
argument_list|<
name|ExprNodeDesc
argument_list|>
name|childExprList
parameter_list|)
throws|throws
name|HiveException
block|{
return|return
name|getUnaryExpression
argument_list|(
name|vectorExprClassName
argument_list|,
name|resultType
argument_list|,
name|childExprList
argument_list|,
name|CUSTOM_EXPR_PACKAGE
argument_list|)
return|;
block|}
specifier|private
name|VectorExpression
name|getUnaryExpression
parameter_list|(
name|String
name|vectorExprClassName
parameter_list|,
name|String
name|resultType
parameter_list|,
comment|// result type name
name|List
argument_list|<
name|ExprNodeDesc
argument_list|>
name|childExprList
parameter_list|,
name|String
name|packagePathPrefix
comment|// prefix of package path name
parameter_list|)
throws|throws
name|HiveException
block|{
comment|/* Create an instance of the class vectorExprClassName for the input column or expression result      * and return it.      */
name|ExprNodeDesc
name|childExpr
init|=
name|childExprList
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|int
name|inputCol
decl_stmt|;
name|VectorExpression
name|v1
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|childExpr
operator|instanceof
name|ExprNodeGenericFuncDesc
condition|)
block|{
name|v1
operator|=
name|getVectorExpression
argument_list|(
name|childExpr
argument_list|)
expr_stmt|;
name|inputCol
operator|=
name|v1
operator|.
name|getOutputColumn
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|childExpr
operator|instanceof
name|ExprNodeColumnDesc
condition|)
block|{
name|ExprNodeColumnDesc
name|colDesc
init|=
operator|(
name|ExprNodeColumnDesc
operator|)
name|childExpr
decl_stmt|;
name|inputCol
operator|=
name|getInputColumnIndex
argument_list|(
name|colDesc
operator|.
name|getColumn
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// constant argument case not supported
throw|throw
operator|new
name|HiveException
argument_list|(
literal|"Expression not supported: "
operator|+
name|childExpr
argument_list|)
throw|;
block|}
name|String
name|outputColumnType
init|=
name|getNormalizedTypeName
argument_list|(
name|resultType
argument_list|)
decl_stmt|;
name|int
name|outputCol
init|=
name|ocm
operator|.
name|allocateOutputColumn
argument_list|(
name|outputColumnType
argument_list|)
decl_stmt|;
name|String
name|className
init|=
name|packagePathPrefix
operator|+
literal|"."
operator|+
name|vectorExprClassName
decl_stmt|;
name|VectorExpression
name|expr
decl_stmt|;
try|try
block|{
name|expr
operator|=
operator|(
name|VectorExpression
operator|)
name|getConstructor
argument_list|(
name|className
argument_list|)
operator|.
name|newInstance
argument_list|(
name|inputCol
argument_list|,
name|outputCol
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|ex
parameter_list|)
block|{
throw|throw
operator|new
name|HiveException
argument_list|(
name|ex
argument_list|)
throw|;
block|}
if|if
condition|(
name|v1
operator|!=
literal|null
condition|)
block|{
name|expr
operator|.
name|setChildExpressions
argument_list|(
operator|new
name|VectorExpression
index|[]
block|{
name|v1
block|}
argument_list|)
expr_stmt|;
name|ocm
operator|.
name|freeOutputColumn
argument_list|(
name|v1
operator|.
name|getOutputColumn
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|expr
return|;
block|}
specifier|private
name|VectorExpression
name|getSubstrExpression
parameter_list|(
name|List
argument_list|<
name|ExprNodeDesc
argument_list|>
name|childExprList
parameter_list|)
throws|throws
name|HiveException
block|{
name|ExprNodeDesc
name|childExpr
init|=
name|childExprList
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|ExprNodeDesc
name|startExpr
init|=
name|childExprList
operator|.
name|get
argument_list|(
literal|1
argument_list|)
decl_stmt|;
name|startExpr
operator|=
name|foldConstantsForUnaryExpression
argument_list|(
name|startExpr
argument_list|)
expr_stmt|;
comment|// Get second and optionally third arguments
name|int
name|start
decl_stmt|;
if|if
condition|(
name|startExpr
operator|instanceof
name|ExprNodeConstantDesc
condition|)
block|{
name|ExprNodeConstantDesc
name|constDesc
init|=
operator|(
name|ExprNodeConstantDesc
operator|)
name|startExpr
decl_stmt|;
name|start
operator|=
operator|(
operator|(
name|Integer
operator|)
name|constDesc
operator|.
name|getValue
argument_list|()
operator|)
operator|.
name|intValue
argument_list|()
expr_stmt|;
block|}
else|else
block|{
throw|throw
operator|new
name|HiveException
argument_list|(
literal|"Cannot vectorize non-constant start argument for SUBSTR"
argument_list|)
throw|;
block|}
name|ExprNodeDesc
name|lengthExpr
init|=
literal|null
decl_stmt|;
name|int
name|length
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|childExprList
operator|.
name|size
argument_list|()
operator|==
literal|3
condition|)
block|{
name|lengthExpr
operator|=
name|childExprList
operator|.
name|get
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|lengthExpr
operator|=
name|foldConstantsForUnaryExpression
argument_list|(
name|lengthExpr
argument_list|)
expr_stmt|;
if|if
condition|(
name|lengthExpr
operator|instanceof
name|ExprNodeConstantDesc
condition|)
block|{
name|ExprNodeConstantDesc
name|constDesc
init|=
operator|(
name|ExprNodeConstantDesc
operator|)
name|lengthExpr
decl_stmt|;
name|length
operator|=
operator|(
operator|(
name|Integer
operator|)
name|constDesc
operator|.
name|getValue
argument_list|()
operator|)
operator|.
name|intValue
argument_list|()
expr_stmt|;
block|}
else|else
block|{
throw|throw
operator|new
name|HiveException
argument_list|(
literal|"Cannot vectorize non-constant length argument for SUBSTR"
argument_list|)
throw|;
block|}
block|}
comment|// Prepare first argument (whether it is a column or an expression)
name|int
name|inputCol
decl_stmt|;
name|VectorExpression
name|v1
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|childExpr
operator|instanceof
name|ExprNodeGenericFuncDesc
condition|)
block|{
name|v1
operator|=
name|getVectorExpression
argument_list|(
name|childExpr
argument_list|)
expr_stmt|;
name|inputCol
operator|=
name|v1
operator|.
name|getOutputColumn
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|childExpr
operator|instanceof
name|ExprNodeColumnDesc
condition|)
block|{
name|ExprNodeColumnDesc
name|colDesc
init|=
operator|(
name|ExprNodeColumnDesc
operator|)
name|childExpr
decl_stmt|;
name|inputCol
operator|=
name|getInputColumnIndex
argument_list|(
name|colDesc
operator|.
name|getColumn
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
throw|throw
operator|new
name|HiveException
argument_list|(
literal|"Expression not supported: "
operator|+
name|childExpr
argument_list|)
throw|;
block|}
name|int
name|outputCol
init|=
name|ocm
operator|.
name|allocateOutputColumn
argument_list|(
literal|"String"
argument_list|)
decl_stmt|;
comment|// Create appropriate vector expression for 2 or 3 argument version of SUBSTR()
name|VectorExpression
name|expr
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|childExprList
operator|.
name|size
argument_list|()
operator|==
literal|2
condition|)
block|{
name|expr
operator|=
operator|new
name|StringSubstrColStart
argument_list|(
name|inputCol
argument_list|,
name|start
argument_list|,
name|outputCol
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|childExprList
operator|.
name|size
argument_list|()
operator|==
literal|3
condition|)
block|{
name|expr
operator|=
operator|new
name|StringSubstrColStartLen
argument_list|(
name|inputCol
argument_list|,
name|start
argument_list|,
name|length
argument_list|,
name|outputCol
argument_list|)
expr_stmt|;
block|}
else|else
block|{
throw|throw
operator|new
name|HiveException
argument_list|(
literal|"Invalid number of arguments for SUBSTR()"
argument_list|)
throw|;
block|}
if|if
condition|(
name|v1
operator|!=
literal|null
condition|)
block|{
name|expr
operator|.
name|setChildExpressions
argument_list|(
operator|new
name|VectorExpression
index|[]
block|{
name|v1
block|}
argument_list|)
expr_stmt|;
name|ocm
operator|.
name|freeOutputColumn
argument_list|(
name|v1
operator|.
name|getOutputColumn
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|expr
return|;
block|}
comment|/**    * Returns a vector expression for a LIKE or REGEXP expression    * @param childExpr A list of child expressions    * @param isLike {@code true}: the expression is LIKE.    *               {@code false}: the expression is REGEXP.    * @return A {@link FilterStringColLikeStringScalar} or    *         a {@link FilterStringColRegExpStringScalar}    * @throws HiveException    */
specifier|private
name|VectorExpression
name|getLikeExpression
parameter_list|(
name|List
argument_list|<
name|ExprNodeDesc
argument_list|>
name|childExpr
parameter_list|,
name|boolean
name|isLike
parameter_list|)
throws|throws
name|HiveException
block|{
name|ExprNodeDesc
name|leftExpr
init|=
name|childExpr
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|ExprNodeDesc
name|rightExpr
init|=
name|childExpr
operator|.
name|get
argument_list|(
literal|1
argument_list|)
decl_stmt|;
name|VectorExpression
name|v1
init|=
literal|null
decl_stmt|;
name|VectorExpression
name|expr
init|=
literal|null
decl_stmt|;
name|int
name|inputCol
decl_stmt|;
name|ExprNodeConstantDesc
name|constDesc
decl_stmt|;
if|if
condition|(
operator|(
name|leftExpr
operator|instanceof
name|ExprNodeColumnDesc
operator|)
operator|&&
operator|(
name|rightExpr
operator|instanceof
name|ExprNodeConstantDesc
operator|)
condition|)
block|{
name|ExprNodeColumnDesc
name|leftColDesc
init|=
operator|(
name|ExprNodeColumnDesc
operator|)
name|leftExpr
decl_stmt|;
name|constDesc
operator|=
operator|(
name|ExprNodeConstantDesc
operator|)
name|rightExpr
expr_stmt|;
name|inputCol
operator|=
name|getInputColumnIndex
argument_list|(
name|leftColDesc
operator|.
name|getColumn
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|isLike
condition|)
block|{
name|expr
operator|=
operator|(
name|VectorExpression
operator|)
operator|new
name|FilterStringColLikeStringScalar
argument_list|(
name|inputCol
argument_list|,
operator|new
name|Text
argument_list|(
operator|(
name|byte
index|[]
operator|)
name|getScalarValue
argument_list|(
name|constDesc
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|expr
operator|=
operator|(
name|VectorExpression
operator|)
operator|new
name|FilterStringColRegExpStringScalar
argument_list|(
name|inputCol
argument_list|,
operator|new
name|Text
argument_list|(
operator|(
name|byte
index|[]
operator|)
name|getScalarValue
argument_list|(
name|constDesc
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|leftExpr
operator|instanceof
name|ExprNodeGenericFuncDesc
operator|)
operator|&&
operator|(
name|rightExpr
operator|instanceof
name|ExprNodeConstantDesc
operator|)
condition|)
block|{
name|v1
operator|=
name|getVectorExpression
argument_list|(
name|leftExpr
argument_list|)
expr_stmt|;
name|inputCol
operator|=
name|v1
operator|.
name|getOutputColumn
argument_list|()
expr_stmt|;
name|constDesc
operator|=
operator|(
name|ExprNodeConstantDesc
operator|)
name|rightExpr
expr_stmt|;
if|if
condition|(
name|isLike
condition|)
block|{
name|expr
operator|=
operator|(
name|VectorExpression
operator|)
operator|new
name|FilterStringColLikeStringScalar
argument_list|(
name|inputCol
argument_list|,
operator|new
name|Text
argument_list|(
operator|(
name|byte
index|[]
operator|)
name|getScalarValue
argument_list|(
name|constDesc
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|expr
operator|=
operator|(
name|VectorExpression
operator|)
operator|new
name|FilterStringColRegExpStringScalar
argument_list|(
name|inputCol
argument_list|,
operator|new
name|Text
argument_list|(
operator|(
name|byte
index|[]
operator|)
name|getScalarValue
argument_list|(
name|constDesc
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|// TODO add logic to handle cases where left input is an expression.
if|if
condition|(
name|expr
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|HiveException
argument_list|(
literal|"Vector LIKE filter expression could not be initialized"
argument_list|)
throw|;
block|}
if|if
condition|(
name|v1
operator|!=
literal|null
condition|)
block|{
name|expr
operator|.
name|setChildExpressions
argument_list|(
operator|new
name|VectorExpression
index|[]
block|{
name|v1
block|}
argument_list|)
expr_stmt|;
name|ocm
operator|.
name|freeOutputColumn
argument_list|(
name|v1
operator|.
name|getOutputColumn
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|expr
return|;
block|}
specifier|private
name|VectorExpression
name|getTimestampFieldExpression
parameter_list|(
name|String
name|udf
parameter_list|,
name|List
argument_list|<
name|ExprNodeDesc
argument_list|>
name|childExpr
parameter_list|)
throws|throws
name|HiveException
block|{
name|ExprNodeDesc
name|leftExpr
init|=
name|childExpr
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|leftExpr
operator|=
name|foldConstantsForUnaryExpression
argument_list|(
name|leftExpr
argument_list|)
expr_stmt|;
name|VectorExpression
name|v1
init|=
name|getVectorExpression
argument_list|(
name|leftExpr
argument_list|)
decl_stmt|;
name|String
name|colType
init|=
name|v1
operator|.
name|getOutputType
argument_list|()
decl_stmt|;
name|String
name|outputType
init|=
literal|"long"
decl_stmt|;
if|if
condition|(
name|colType
operator|.
name|equalsIgnoreCase
argument_list|(
literal|"timestamp"
argument_list|)
condition|)
block|{
name|int
name|inputCol
init|=
name|v1
operator|.
name|getOutputColumn
argument_list|()
decl_stmt|;
name|int
name|outputCol
init|=
name|ocm
operator|.
name|allocateOutputColumn
argument_list|(
name|outputType
argument_list|)
decl_stmt|;
name|String
name|pkg
init|=
literal|"org.apache.hadoop.hive.ql.exec.vector.expressions"
decl_stmt|;
comment|// org.apache.hadoop.hive.ql.exec.vector.expressions.VectorUDFYearLong
name|String
name|vectorUDF
init|=
name|pkg
operator|+
literal|".Vector"
operator|+
name|udf
operator|+
literal|"Long"
decl_stmt|;
try|try
block|{
name|VectorExpression
name|v2
init|=
operator|(
name|VectorExpression
operator|)
name|getConstructor
argument_list|(
name|vectorUDF
argument_list|)
operator|.
name|newInstance
argument_list|(
name|inputCol
argument_list|,
name|outputCol
argument_list|)
decl_stmt|;
return|return
name|v2
return|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|e
operator|.
name|printStackTrace
argument_list|()
expr_stmt|;
throw|throw
operator|new
name|HiveException
argument_list|(
literal|"Udf: Vector"
operator|+
name|udf
operator|+
literal|", could not be initialized for "
operator|+
name|colType
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
throw|throw
operator|new
name|HiveException
argument_list|(
literal|"Udf: "
operator|+
name|udf
operator|+
literal|", is not supported for "
operator|+
name|colType
argument_list|)
throw|;
block|}
specifier|private
name|VectorExpression
name|getBinaryArithmeticExpression
parameter_list|(
name|String
name|method
parameter_list|,
name|List
argument_list|<
name|ExprNodeDesc
argument_list|>
name|childExpr
parameter_list|)
throws|throws
name|HiveException
block|{
name|ExprNodeDesc
name|leftExpr
init|=
name|childExpr
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|ExprNodeDesc
name|rightExpr
init|=
name|childExpr
operator|.
name|get
argument_list|(
literal|1
argument_list|)
decl_stmt|;
comment|// TODO: Remove this when constant folding is fixed in the optimizer.
name|leftExpr
operator|=
name|foldConstantsForUnaryExpression
argument_list|(
name|leftExpr
argument_list|)
expr_stmt|;
name|rightExpr
operator|=
name|foldConstantsForUnaryExpression
argument_list|(
name|rightExpr
argument_list|)
expr_stmt|;
name|VectorExpression
name|v1
init|=
literal|null
decl_stmt|;
name|VectorExpression
name|v2
init|=
literal|null
decl_stmt|;
name|VectorExpression
name|expr
init|=
literal|null
decl_stmt|;
if|if
condition|(
operator|(
name|leftExpr
operator|instanceof
name|ExprNodeColumnDesc
operator|)
operator|&&
operator|(
name|rightExpr
operator|instanceof
name|ExprNodeConstantDesc
operator|)
condition|)
block|{
name|ExprNodeColumnDesc
name|leftColDesc
init|=
operator|(
name|ExprNodeColumnDesc
operator|)
name|leftExpr
decl_stmt|;
name|ExprNodeConstantDesc
name|constDesc
init|=
operator|(
name|ExprNodeConstantDesc
operator|)
name|rightExpr
decl_stmt|;
name|int
name|inputCol
init|=
name|getInputColumnIndex
argument_list|(
name|leftColDesc
operator|.
name|getColumn
argument_list|()
argument_list|)
decl_stmt|;
name|String
name|colType
init|=
name|leftColDesc
operator|.
name|getTypeString
argument_list|()
decl_stmt|;
name|String
name|scalarType
init|=
name|constDesc
operator|.
name|getTypeString
argument_list|()
decl_stmt|;
name|String
name|className
init|=
name|getBinaryColumnScalarExpressionClassName
argument_list|(
name|colType
argument_list|,
name|scalarType
argument_list|,
name|method
argument_list|)
decl_stmt|;
name|int
name|outputCol
init|=
name|ocm
operator|.
name|allocateOutputColumn
argument_list|(
name|getOutputColType
argument_list|(
name|colType
argument_list|,
name|scalarType
argument_list|,
name|method
argument_list|)
argument_list|)
decl_stmt|;
try|try
block|{
name|expr
operator|=
operator|(
name|VectorExpression
operator|)
name|getConstructor
argument_list|(
name|className
argument_list|)
operator|.
name|newInstance
argument_list|(
name|inputCol
argument_list|,
name|getScalarValue
argument_list|(
name|constDesc
argument_list|)
argument_list|,
name|outputCol
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|ex
parameter_list|)
block|{
throw|throw
operator|new
name|HiveException
argument_list|(
name|ex
argument_list|)
throw|;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|leftExpr
operator|instanceof
name|ExprNodeConstantDesc
operator|)
operator|&&
operator|(
name|rightExpr
operator|instanceof
name|ExprNodeColumnDesc
operator|)
condition|)
block|{
name|ExprNodeColumnDesc
name|rightColDesc
init|=
operator|(
name|ExprNodeColumnDesc
operator|)
name|rightExpr
decl_stmt|;
name|ExprNodeConstantDesc
name|constDesc
init|=
operator|(
name|ExprNodeConstantDesc
operator|)
name|leftExpr
decl_stmt|;
name|int
name|inputCol
init|=
name|getInputColumnIndex
argument_list|(
name|rightColDesc
operator|.
name|getColumn
argument_list|()
argument_list|)
decl_stmt|;
name|String
name|colType
init|=
name|rightColDesc
operator|.
name|getTypeString
argument_list|()
decl_stmt|;
name|String
name|scalarType
init|=
name|constDesc
operator|.
name|getTypeString
argument_list|()
decl_stmt|;
name|String
name|className
init|=
name|getBinaryScalarColumnExpressionClassName
argument_list|(
name|colType
argument_list|,
name|scalarType
argument_list|,
name|method
argument_list|)
decl_stmt|;
name|String
name|outputColType
init|=
name|getOutputColType
argument_list|(
name|colType
argument_list|,
name|scalarType
argument_list|,
name|method
argument_list|)
decl_stmt|;
name|int
name|outputCol
init|=
name|ocm
operator|.
name|allocateOutputColumn
argument_list|(
name|outputColType
argument_list|)
decl_stmt|;
try|try
block|{
name|expr
operator|=
operator|(
name|VectorExpression
operator|)
name|getConstructor
argument_list|(
name|className
argument_list|)
operator|.
name|newInstance
argument_list|(
name|getScalarValue
argument_list|(
name|constDesc
argument_list|)
argument_list|,
name|inputCol
argument_list|,
name|outputCol
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|ex
parameter_list|)
block|{
throw|throw
operator|new
name|HiveException
argument_list|(
literal|"Could not instantiate: "
operator|+
name|className
argument_list|,
name|ex
argument_list|)
throw|;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|rightExpr
operator|instanceof
name|ExprNodeColumnDesc
operator|)
operator|&&
operator|(
name|leftExpr
operator|instanceof
name|ExprNodeColumnDesc
operator|)
condition|)
block|{
name|ExprNodeColumnDesc
name|leftColDesc
init|=
operator|(
name|ExprNodeColumnDesc
operator|)
name|leftExpr
decl_stmt|;
name|ExprNodeColumnDesc
name|rightColDesc
init|=
operator|(
name|ExprNodeColumnDesc
operator|)
name|rightExpr
decl_stmt|;
name|int
name|inputCol1
init|=
name|getInputColumnIndex
argument_list|(
name|leftColDesc
operator|.
name|getColumn
argument_list|()
argument_list|)
decl_stmt|;
name|int
name|inputCol2
init|=
name|getInputColumnIndex
argument_list|(
name|rightColDesc
operator|.
name|getColumn
argument_list|()
argument_list|)
decl_stmt|;
name|String
name|colType1
init|=
name|leftColDesc
operator|.
name|getTypeString
argument_list|()
decl_stmt|;
name|String
name|colType2
init|=
name|rightColDesc
operator|.
name|getTypeString
argument_list|()
decl_stmt|;
name|String
name|outputColType
init|=
name|getOutputColType
argument_list|(
name|colType1
argument_list|,
name|colType2
argument_list|,
name|method
argument_list|)
decl_stmt|;
name|String
name|className
init|=
name|getBinaryColumnColumnExpressionClassName
argument_list|(
name|colType1
argument_list|,
name|colType2
argument_list|,
name|method
argument_list|)
decl_stmt|;
name|int
name|outputCol
init|=
name|ocm
operator|.
name|allocateOutputColumn
argument_list|(
name|outputColType
argument_list|)
decl_stmt|;
try|try
block|{
name|expr
operator|=
operator|(
name|VectorExpression
operator|)
name|getConstructor
argument_list|(
name|className
argument_list|)
operator|.
name|newInstance
argument_list|(
name|inputCol1
argument_list|,
name|inputCol2
argument_list|,
name|outputCol
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|ex
parameter_list|)
block|{
throw|throw
operator|new
name|HiveException
argument_list|(
name|ex
argument_list|)
throw|;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|leftExpr
operator|instanceof
name|ExprNodeGenericFuncDesc
operator|)
operator|&&
operator|(
name|rightExpr
operator|instanceof
name|ExprNodeColumnDesc
operator|)
condition|)
block|{
name|ExprNodeColumnDesc
name|colDesc
init|=
operator|(
name|ExprNodeColumnDesc
operator|)
name|rightExpr
decl_stmt|;
name|v1
operator|=
name|getVectorExpression
argument_list|(
name|leftExpr
argument_list|)
expr_stmt|;
name|int
name|inputCol1
init|=
name|v1
operator|.
name|getOutputColumn
argument_list|()
decl_stmt|;
name|int
name|inputCol2
init|=
name|getInputColumnIndex
argument_list|(
name|colDesc
operator|.
name|getColumn
argument_list|()
argument_list|)
decl_stmt|;
name|String
name|colType1
init|=
name|v1
operator|.
name|getOutputType
argument_list|()
decl_stmt|;
name|String
name|colType2
init|=
name|colDesc
operator|.
name|getTypeString
argument_list|()
decl_stmt|;
name|String
name|outputColType
init|=
name|getOutputColType
argument_list|(
name|colType1
argument_list|,
name|colType2
argument_list|,
name|method
argument_list|)
decl_stmt|;
name|String
name|className
init|=
name|getBinaryColumnColumnExpressionClassName
argument_list|(
name|colType1
argument_list|,
name|colType2
argument_list|,
name|method
argument_list|)
decl_stmt|;
name|int
name|outputCol
init|=
name|ocm
operator|.
name|allocateOutputColumn
argument_list|(
name|outputColType
argument_list|)
decl_stmt|;
try|try
block|{
name|expr
operator|=
operator|(
name|VectorExpression
operator|)
name|getConstructor
argument_list|(
name|className
argument_list|)
operator|.
name|newInstance
argument_list|(
name|inputCol1
argument_list|,
name|inputCol2
argument_list|,
name|outputCol
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|ex
parameter_list|)
block|{
throw|throw
operator|new
name|HiveException
argument_list|(
operator|(
name|ex
operator|)
argument_list|)
throw|;
block|}
name|expr
operator|.
name|setChildExpressions
argument_list|(
operator|new
name|VectorExpression
index|[]
block|{
name|v1
block|}
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|leftExpr
operator|instanceof
name|ExprNodeGenericFuncDesc
operator|)
operator|&&
operator|(
name|rightExpr
operator|instanceof
name|ExprNodeConstantDesc
operator|)
condition|)
block|{
name|ExprNodeConstantDesc
name|constDesc
init|=
operator|(
name|ExprNodeConstantDesc
operator|)
name|rightExpr
decl_stmt|;
name|v1
operator|=
name|getVectorExpression
argument_list|(
name|leftExpr
argument_list|)
expr_stmt|;
name|int
name|inputCol1
init|=
name|v1
operator|.
name|getOutputColumn
argument_list|()
decl_stmt|;
name|String
name|colType1
init|=
name|v1
operator|.
name|getOutputType
argument_list|()
decl_stmt|;
name|String
name|scalarType
init|=
name|constDesc
operator|.
name|getTypeString
argument_list|()
decl_stmt|;
name|String
name|outputColType
init|=
name|getOutputColType
argument_list|(
name|colType1
argument_list|,
name|scalarType
argument_list|,
name|method
argument_list|)
decl_stmt|;
name|int
name|outputCol
init|=
name|ocm
operator|.
name|allocateOutputColumn
argument_list|(
name|outputColType
argument_list|)
decl_stmt|;
name|String
name|className
init|=
name|getBinaryColumnScalarExpressionClassName
argument_list|(
name|colType1
argument_list|,
name|scalarType
argument_list|,
name|method
argument_list|)
decl_stmt|;
try|try
block|{
name|expr
operator|=
operator|(
name|VectorExpression
operator|)
name|getConstructor
argument_list|(
name|className
argument_list|)
operator|.
name|newInstance
argument_list|(
name|inputCol1
argument_list|,
name|getScalarValue
argument_list|(
name|constDesc
argument_list|)
argument_list|,
name|outputCol
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|ex
parameter_list|)
block|{
throw|throw
operator|new
name|HiveException
argument_list|(
operator|(
name|ex
operator|)
argument_list|)
throw|;
block|}
name|expr
operator|.
name|setChildExpressions
argument_list|(
operator|new
name|VectorExpression
index|[]
block|{
name|v1
block|}
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|leftExpr
operator|instanceof
name|ExprNodeColumnDesc
operator|)
operator|&&
operator|(
name|rightExpr
operator|instanceof
name|ExprNodeGenericFuncDesc
operator|)
condition|)
block|{
name|ExprNodeColumnDesc
name|colDesc
init|=
operator|(
name|ExprNodeColumnDesc
operator|)
name|leftExpr
decl_stmt|;
name|v2
operator|=
name|getVectorExpression
argument_list|(
name|rightExpr
argument_list|)
expr_stmt|;
name|int
name|inputCol1
init|=
name|getInputColumnIndex
argument_list|(
name|colDesc
operator|.
name|getColumn
argument_list|()
argument_list|)
decl_stmt|;
name|int
name|inputCol2
init|=
name|v2
operator|.
name|getOutputColumn
argument_list|()
decl_stmt|;
name|String
name|colType1
init|=
name|colDesc
operator|.
name|getTypeString
argument_list|()
decl_stmt|;
name|String
name|colType2
init|=
name|v2
operator|.
name|getOutputType
argument_list|()
decl_stmt|;
name|String
name|outputColType
init|=
name|getOutputColType
argument_list|(
name|colType1
argument_list|,
name|colType2
argument_list|,
name|method
argument_list|)
decl_stmt|;
name|int
name|outputCol
init|=
name|ocm
operator|.
name|allocateOutputColumn
argument_list|(
name|outputColType
argument_list|)
decl_stmt|;
name|String
name|className
init|=
name|getBinaryColumnColumnExpressionClassName
argument_list|(
name|colType1
argument_list|,
name|colType2
argument_list|,
name|method
argument_list|)
decl_stmt|;
try|try
block|{
name|expr
operator|=
operator|(
name|VectorExpression
operator|)
name|getConstructor
argument_list|(
name|className
argument_list|)
operator|.
name|newInstance
argument_list|(
name|inputCol1
argument_list|,
name|inputCol2
argument_list|,
name|outputCol
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|ex
parameter_list|)
block|{
throw|throw
operator|new
name|HiveException
argument_list|(
name|ex
argument_list|)
throw|;
block|}
name|expr
operator|.
name|setChildExpressions
argument_list|(
operator|new
name|VectorExpression
index|[]
block|{
name|v2
block|}
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|leftExpr
operator|instanceof
name|ExprNodeConstantDesc
operator|)
operator|&&
operator|(
name|rightExpr
operator|instanceof
name|ExprNodeGenericFuncDesc
operator|)
condition|)
block|{
name|ExprNodeConstantDesc
name|constDesc
init|=
operator|(
name|ExprNodeConstantDesc
operator|)
name|leftExpr
decl_stmt|;
name|v2
operator|=
name|getVectorExpression
argument_list|(
name|rightExpr
argument_list|)
expr_stmt|;
name|int
name|inputCol2
init|=
name|v2
operator|.
name|getOutputColumn
argument_list|()
decl_stmt|;
name|String
name|colType2
init|=
name|v2
operator|.
name|getOutputType
argument_list|()
decl_stmt|;
name|String
name|scalarType
init|=
name|constDesc
operator|.
name|getTypeString
argument_list|()
decl_stmt|;
name|String
name|outputColType
init|=
name|getOutputColType
argument_list|(
name|colType2
argument_list|,
name|scalarType
argument_list|,
name|method
argument_list|)
decl_stmt|;
name|int
name|outputCol
init|=
name|ocm
operator|.
name|allocateOutputColumn
argument_list|(
name|outputColType
argument_list|)
decl_stmt|;
name|String
name|className
init|=
name|getBinaryScalarColumnExpressionClassName
argument_list|(
name|colType2
argument_list|,
name|scalarType
argument_list|,
name|method
argument_list|)
decl_stmt|;
try|try
block|{
name|expr
operator|=
operator|(
name|VectorExpression
operator|)
name|getConstructor
argument_list|(
name|className
argument_list|)
operator|.
name|newInstance
argument_list|(
name|getScalarValue
argument_list|(
name|constDesc
argument_list|)
argument_list|,
name|inputCol2
argument_list|,
name|outputCol
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|ex
parameter_list|)
block|{
throw|throw
operator|new
name|HiveException
argument_list|(
name|ex
argument_list|)
throw|;
block|}
name|expr
operator|.
name|setChildExpressions
argument_list|(
operator|new
name|VectorExpression
index|[]
block|{
name|v2
block|}
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|leftExpr
operator|instanceof
name|ExprNodeGenericFuncDesc
operator|)
operator|&&
operator|(
name|rightExpr
operator|instanceof
name|ExprNodeGenericFuncDesc
operator|)
condition|)
block|{
comment|//For arithmetic expression, the child expressions must be materializing
comment|//columns
name|v1
operator|=
name|getVectorExpression
argument_list|(
name|leftExpr
argument_list|)
expr_stmt|;
name|v2
operator|=
name|getVectorExpression
argument_list|(
name|rightExpr
argument_list|)
expr_stmt|;
name|int
name|inputCol1
init|=
name|v1
operator|.
name|getOutputColumn
argument_list|()
decl_stmt|;
name|int
name|inputCol2
init|=
name|v2
operator|.
name|getOutputColumn
argument_list|()
decl_stmt|;
name|String
name|colType1
init|=
name|v1
operator|.
name|getOutputType
argument_list|()
decl_stmt|;
name|String
name|colType2
init|=
name|v2
operator|.
name|getOutputType
argument_list|()
decl_stmt|;
name|String
name|outputColType
init|=
name|getOutputColType
argument_list|(
name|colType1
argument_list|,
name|colType2
argument_list|,
name|method
argument_list|)
decl_stmt|;
name|int
name|outputCol
init|=
name|ocm
operator|.
name|allocateOutputColumn
argument_list|(
name|outputColType
argument_list|)
decl_stmt|;
name|String
name|className
init|=
name|getBinaryColumnColumnExpressionClassName
argument_list|(
name|colType1
argument_list|,
name|colType2
argument_list|,
name|method
argument_list|)
decl_stmt|;
try|try
block|{
name|expr
operator|=
operator|(
name|VectorExpression
operator|)
name|getConstructor
argument_list|(
name|className
argument_list|)
operator|.
name|newInstance
argument_list|(
name|inputCol1
argument_list|,
name|inputCol2
argument_list|,
name|outputCol
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|ex
parameter_list|)
block|{
throw|throw
operator|new
name|HiveException
argument_list|(
name|ex
argument_list|)
throw|;
block|}
name|expr
operator|.
name|setChildExpressions
argument_list|(
operator|new
name|VectorExpression
index|[]
block|{
name|v1
block|,
name|v2
block|}
argument_list|)
expr_stmt|;
block|}
comment|//Reclaim output columns of children to be re-used later
if|if
condition|(
name|v1
operator|!=
literal|null
condition|)
block|{
name|ocm
operator|.
name|freeOutputColumn
argument_list|(
name|v1
operator|.
name|getOutputColumn
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|v2
operator|!=
literal|null
condition|)
block|{
name|ocm
operator|.
name|freeOutputColumn
argument_list|(
name|v2
operator|.
name|getOutputColumn
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|expr
return|;
block|}
specifier|private
name|VectorExpression
name|getVectorExpression
parameter_list|(
name|GenericUDFOPOr
name|udf
parameter_list|,
name|List
argument_list|<
name|ExprNodeDesc
argument_list|>
name|childExpr
parameter_list|)
throws|throws
name|HiveException
block|{
name|ExprNodeDesc
name|leftExpr
init|=
name|childExpr
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|ExprNodeDesc
name|rightExpr
init|=
name|childExpr
operator|.
name|get
argument_list|(
literal|1
argument_list|)
decl_stmt|;
name|VectorExpression
name|ve1
decl_stmt|;
name|VectorExpression
name|ve2
decl_stmt|;
if|if
condition|(
name|leftExpr
operator|instanceof
name|ExprNodeColumnDesc
condition|)
block|{
name|ExprNodeColumnDesc
name|colDesc
init|=
operator|(
name|ExprNodeColumnDesc
operator|)
name|leftExpr
decl_stmt|;
name|int
name|inputCol
init|=
name|getInputColumnIndex
argument_list|(
name|colDesc
operator|.
name|getColumn
argument_list|()
argument_list|)
decl_stmt|;
name|ve1
operator|=
operator|new
name|SelectColumnIsTrue
argument_list|(
name|inputCol
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ve1
operator|=
name|getVectorExpression
argument_list|(
name|leftExpr
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rightExpr
operator|instanceof
name|ExprNodeColumnDesc
condition|)
block|{
name|ExprNodeColumnDesc
name|colDesc
init|=
operator|(
name|ExprNodeColumnDesc
operator|)
name|rightExpr
decl_stmt|;
name|int
name|inputCol
init|=
name|getInputColumnIndex
argument_list|(
name|colDesc
operator|.
name|getColumn
argument_list|()
argument_list|)
decl_stmt|;
name|ve2
operator|=
operator|new
name|SelectColumnIsTrue
argument_list|(
name|inputCol
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ve2
operator|=
name|getVectorExpression
argument_list|(
name|rightExpr
argument_list|)
expr_stmt|;
block|}
return|return
operator|new
name|FilterExprOrExpr
argument_list|(
name|ve1
argument_list|,
name|ve2
argument_list|)
return|;
block|}
specifier|private
name|VectorExpression
name|getVectorExpression
parameter_list|(
name|GenericUDFOPNot
name|udf
parameter_list|,
name|List
argument_list|<
name|ExprNodeDesc
argument_list|>
name|childExpr
parameter_list|)
throws|throws
name|HiveException
block|{
throw|throw
operator|new
name|HiveException
argument_list|(
literal|"Not is not supported"
argument_list|)
throw|;
block|}
specifier|private
name|VectorExpression
name|getVectorExpression
parameter_list|(
name|GenericUDFOPAnd
name|udf
parameter_list|,
name|List
argument_list|<
name|ExprNodeDesc
argument_list|>
name|childExpr
parameter_list|)
throws|throws
name|HiveException
block|{
name|ExprNodeDesc
name|leftExpr
init|=
name|childExpr
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|ExprNodeDesc
name|rightExpr
init|=
name|childExpr
operator|.
name|get
argument_list|(
literal|1
argument_list|)
decl_stmt|;
name|VectorExpression
name|ve1
decl_stmt|;
name|VectorExpression
name|ve2
decl_stmt|;
if|if
condition|(
name|leftExpr
operator|instanceof
name|ExprNodeColumnDesc
condition|)
block|{
name|ExprNodeColumnDesc
name|colDesc
init|=
operator|(
name|ExprNodeColumnDesc
operator|)
name|leftExpr
decl_stmt|;
name|int
name|inputCol
init|=
name|getInputColumnIndex
argument_list|(
name|colDesc
operator|.
name|getColumn
argument_list|()
argument_list|)
decl_stmt|;
name|ve1
operator|=
operator|new
name|SelectColumnIsTrue
argument_list|(
name|inputCol
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ve1
operator|=
name|getVectorExpression
argument_list|(
name|leftExpr
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rightExpr
operator|instanceof
name|ExprNodeColumnDesc
condition|)
block|{
name|ExprNodeColumnDesc
name|colDesc
init|=
operator|(
name|ExprNodeColumnDesc
operator|)
name|rightExpr
decl_stmt|;
name|int
name|inputCol
init|=
name|getInputColumnIndex
argument_list|(
name|colDesc
operator|.
name|getColumn
argument_list|()
argument_list|)
decl_stmt|;
name|ve2
operator|=
operator|new
name|SelectColumnIsTrue
argument_list|(
name|inputCol
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ve2
operator|=
name|getVectorExpression
argument_list|(
name|rightExpr
argument_list|)
expr_stmt|;
block|}
return|return
operator|new
name|FilterExprAndExpr
argument_list|(
name|ve1
argument_list|,
name|ve2
argument_list|)
return|;
block|}
specifier|private
name|VectorExpression
name|getVectorExpression
parameter_list|(
name|GenericUDFOPNull
name|udf
parameter_list|,
name|List
argument_list|<
name|ExprNodeDesc
argument_list|>
name|childExpr
parameter_list|)
throws|throws
name|HiveException
block|{
name|ExprNodeDesc
name|expr
init|=
name|childExpr
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|VectorExpression
name|ve
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|expr
operator|instanceof
name|ExprNodeColumnDesc
condition|)
block|{
name|ExprNodeColumnDesc
name|colDesc
init|=
operator|(
name|ExprNodeColumnDesc
operator|)
name|expr
decl_stmt|;
name|int
name|inputCol
init|=
name|getInputColumnIndex
argument_list|(
name|colDesc
operator|.
name|getColumn
argument_list|()
argument_list|)
decl_stmt|;
name|ve
operator|=
operator|new
name|SelectColumnIsNull
argument_list|(
name|inputCol
argument_list|)
expr_stmt|;
block|}
else|else
block|{
throw|throw
operator|new
name|HiveException
argument_list|(
literal|"Not supported"
argument_list|)
throw|;
block|}
return|return
name|ve
return|;
block|}
specifier|private
name|VectorExpression
name|getVectorExpression
parameter_list|(
name|GenericUDFOPNotNull
name|udf
parameter_list|,
name|List
argument_list|<
name|ExprNodeDesc
argument_list|>
name|childExpr
parameter_list|)
throws|throws
name|HiveException
block|{
name|ExprNodeDesc
name|expr
init|=
name|childExpr
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|expr
operator|instanceof
name|ExprNodeColumnDesc
condition|)
block|{
name|ExprNodeColumnDesc
name|colDesc
init|=
operator|(
name|ExprNodeColumnDesc
operator|)
name|expr
decl_stmt|;
name|int
name|inputCol
init|=
name|getInputColumnIndex
argument_list|(
name|colDesc
operator|.
name|getColumn
argument_list|()
argument_list|)
decl_stmt|;
name|VectorExpression
name|ve
init|=
operator|new
name|SelectColumnIsNotNull
argument_list|(
name|inputCol
argument_list|)
decl_stmt|;
return|return
name|ve
return|;
block|}
else|else
block|{
throw|throw
operator|new
name|HiveException
argument_list|(
literal|"Not supported"
argument_list|)
throw|;
block|}
block|}
specifier|private
name|Object
name|getScalarValue
parameter_list|(
name|ExprNodeConstantDesc
name|constDesc
parameter_list|)
throws|throws
name|HiveException
block|{
if|if
condition|(
name|constDesc
operator|.
name|getTypeString
argument_list|()
operator|.
name|equalsIgnoreCase
argument_list|(
literal|"String"
argument_list|)
condition|)
block|{
try|try
block|{
name|byte
index|[]
name|bytes
init|=
operator|(
operator|(
name|String
operator|)
name|constDesc
operator|.
name|getValue
argument_list|()
operator|)
operator|.
name|getBytes
argument_list|(
literal|"UTF-8"
argument_list|)
decl_stmt|;
return|return
name|bytes
return|;
block|}
catch|catch
parameter_list|(
name|Exception
name|ex
parameter_list|)
block|{
throw|throw
operator|new
name|HiveException
argument_list|(
name|ex
argument_list|)
throw|;
block|}
block|}
elseif|else
if|if
condition|(
name|constDesc
operator|.
name|getTypeString
argument_list|()
operator|.
name|equalsIgnoreCase
argument_list|(
literal|"boolean"
argument_list|)
condition|)
block|{
if|if
condition|(
name|constDesc
operator|.
name|getValue
argument_list|()
operator|.
name|equals
argument_list|(
name|Boolean
operator|.
name|valueOf
argument_list|(
literal|true
argument_list|)
argument_list|)
condition|)
block|{
return|return
literal|1
return|;
block|}
else|else
block|{
return|return
literal|0
return|;
block|}
block|}
else|else
block|{
return|return
name|constDesc
operator|.
name|getValue
argument_list|()
return|;
block|}
block|}
specifier|private
name|VectorExpression
name|getVectorBinaryComparisonFilterExpression
parameter_list|(
name|String
name|opName
parameter_list|,
name|List
argument_list|<
name|ExprNodeDesc
argument_list|>
name|childExpr
parameter_list|)
throws|throws
name|HiveException
block|{
name|ExprNodeDesc
name|leftExpr
init|=
name|childExpr
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|ExprNodeDesc
name|rightExpr
init|=
name|childExpr
operator|.
name|get
argument_list|(
literal|1
argument_list|)
decl_stmt|;
comment|// TODO: Remove this when constant folding is fixed in the optimizer.
name|leftExpr
operator|=
name|foldConstantsForUnaryExpression
argument_list|(
name|leftExpr
argument_list|)
expr_stmt|;
name|rightExpr
operator|=
name|foldConstantsForUnaryExpression
argument_list|(
name|rightExpr
argument_list|)
expr_stmt|;
name|VectorExpression
name|expr
init|=
literal|null
decl_stmt|;
name|VectorExpression
name|v1
init|=
literal|null
decl_stmt|;
name|VectorExpression
name|v2
init|=
literal|null
decl_stmt|;
if|if
condition|(
operator|(
name|leftExpr
operator|instanceof
name|ExprNodeColumnDesc
operator|)
operator|&&
operator|(
name|rightExpr
operator|instanceof
name|ExprNodeConstantDesc
operator|)
condition|)
block|{
name|ExprNodeColumnDesc
name|leftColDesc
init|=
operator|(
name|ExprNodeColumnDesc
operator|)
name|leftExpr
decl_stmt|;
name|ExprNodeConstantDesc
name|constDesc
init|=
operator|(
name|ExprNodeConstantDesc
operator|)
name|rightExpr
decl_stmt|;
name|int
name|inputCol
init|=
name|getInputColumnIndex
argument_list|(
name|leftColDesc
operator|.
name|getColumn
argument_list|()
argument_list|)
decl_stmt|;
name|String
name|colType
init|=
name|leftColDesc
operator|.
name|getTypeString
argument_list|()
decl_stmt|;
name|String
name|scalarType
init|=
name|constDesc
operator|.
name|getTypeString
argument_list|()
decl_stmt|;
name|String
name|className
init|=
name|getFilterColumnScalarExpressionClassName
argument_list|(
name|colType
argument_list|,
name|scalarType
argument_list|,
name|opName
argument_list|)
decl_stmt|;
try|try
block|{
name|Constructor
argument_list|<
name|?
argument_list|>
name|ctor
init|=
name|getConstructor
argument_list|(
name|className
argument_list|)
decl_stmt|;
name|expr
operator|=
operator|(
name|VectorExpression
operator|)
name|ctor
operator|.
name|newInstance
argument_list|(
name|inputCol
argument_list|,
name|getScalarValue
argument_list|(
name|constDesc
argument_list|)
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|ex
parameter_list|)
block|{
throw|throw
operator|new
name|HiveException
argument_list|(
name|ex
argument_list|)
throw|;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|leftExpr
operator|instanceof
name|ExprNodeConstantDesc
operator|)
operator|&&
operator|(
name|rightExpr
operator|instanceof
name|ExprNodeColumnDesc
operator|)
condition|)
block|{
name|ExprNodeConstantDesc
name|constDesc
init|=
operator|(
name|ExprNodeConstantDesc
operator|)
name|leftExpr
decl_stmt|;
name|ExprNodeColumnDesc
name|rightColDesc
init|=
operator|(
name|ExprNodeColumnDesc
operator|)
name|rightExpr
decl_stmt|;
name|int
name|inputCol
init|=
name|getInputColumnIndex
argument_list|(
name|rightColDesc
operator|.
name|getColumn
argument_list|()
argument_list|)
decl_stmt|;
name|String
name|colType
init|=
name|rightColDesc
operator|.
name|getTypeString
argument_list|()
decl_stmt|;
name|String
name|scalarType
init|=
name|constDesc
operator|.
name|getTypeString
argument_list|()
decl_stmt|;
name|String
name|className
init|=
name|getFilterScalarColumnExpressionClassName
argument_list|(
name|colType
argument_list|,
name|scalarType
argument_list|,
name|opName
argument_list|)
decl_stmt|;
try|try
block|{
comment|//Constructor<?>
name|expr
operator|=
operator|(
name|VectorExpression
operator|)
name|getConstructor
argument_list|(
name|className
argument_list|)
operator|.
name|newInstance
argument_list|(
name|inputCol
argument_list|,
name|getScalarValue
argument_list|(
name|constDesc
argument_list|)
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|ex
parameter_list|)
block|{
throw|throw
operator|new
name|HiveException
argument_list|(
name|ex
argument_list|)
throw|;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|rightExpr
operator|instanceof
name|ExprNodeColumnDesc
operator|)
operator|&&
operator|(
name|leftExpr
operator|instanceof
name|ExprNodeColumnDesc
operator|)
condition|)
block|{
name|ExprNodeColumnDesc
name|leftColDesc
init|=
operator|(
name|ExprNodeColumnDesc
operator|)
name|leftExpr
decl_stmt|;
name|ExprNodeColumnDesc
name|rightColDesc
init|=
operator|(
name|ExprNodeColumnDesc
operator|)
name|rightExpr
decl_stmt|;
name|int
name|inputCol1
init|=
name|getInputColumnIndex
argument_list|(
name|leftColDesc
operator|.
name|getColumn
argument_list|()
argument_list|)
decl_stmt|;
name|int
name|inputCol2
init|=
name|getInputColumnIndex
argument_list|(
name|rightColDesc
operator|.
name|getColumn
argument_list|()
argument_list|)
decl_stmt|;
name|String
name|colType1
init|=
name|leftColDesc
operator|.
name|getTypeString
argument_list|()
decl_stmt|;
name|String
name|colType2
init|=
name|rightColDesc
operator|.
name|getTypeString
argument_list|()
decl_stmt|;
name|String
name|className
init|=
name|getFilterColumnColumnExpressionClassName
argument_list|(
name|colType1
argument_list|,
name|colType2
argument_list|,
name|opName
argument_list|)
decl_stmt|;
try|try
block|{
name|expr
operator|=
operator|(
name|VectorExpression
operator|)
name|getConstructor
argument_list|(
name|className
argument_list|)
operator|.
name|newInstance
argument_list|(
name|inputCol1
argument_list|,
name|inputCol2
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|ex
parameter_list|)
block|{
throw|throw
operator|new
name|HiveException
argument_list|(
name|ex
argument_list|)
throw|;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|leftExpr
operator|instanceof
name|ExprNodeGenericFuncDesc
operator|)
operator|&&
operator|(
name|rightExpr
operator|instanceof
name|ExprNodeColumnDesc
operator|)
condition|)
block|{
name|v1
operator|=
name|getVectorExpression
argument_list|(
operator|(
name|ExprNodeGenericFuncDesc
operator|)
name|leftExpr
argument_list|)
expr_stmt|;
name|ExprNodeColumnDesc
name|rightColDesc
init|=
operator|(
name|ExprNodeColumnDesc
operator|)
name|rightExpr
decl_stmt|;
name|int
name|inputCol1
init|=
name|v1
operator|.
name|getOutputColumn
argument_list|()
decl_stmt|;
name|int
name|inputCol2
init|=
name|getInputColumnIndex
argument_list|(
name|rightColDesc
operator|.
name|getColumn
argument_list|()
argument_list|)
decl_stmt|;
name|String
name|colType1
init|=
name|v1
operator|.
name|getOutputType
argument_list|()
decl_stmt|;
name|String
name|colType2
init|=
name|rightColDesc
operator|.
name|getTypeString
argument_list|()
decl_stmt|;
name|String
name|className
init|=
name|getFilterColumnColumnExpressionClassName
argument_list|(
name|colType1
argument_list|,
name|colType2
argument_list|,
name|opName
argument_list|)
decl_stmt|;
try|try
block|{
name|expr
operator|=
operator|(
name|VectorExpression
operator|)
name|getConstructor
argument_list|(
name|className
argument_list|)
operator|.
name|newInstance
argument_list|(
name|inputCol1
argument_list|,
name|inputCol2
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|ex
parameter_list|)
block|{
throw|throw
operator|new
name|HiveException
argument_list|(
name|ex
argument_list|)
throw|;
block|}
name|expr
operator|.
name|setChildExpressions
argument_list|(
operator|new
name|VectorExpression
index|[]
block|{
name|v1
block|}
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|leftExpr
operator|instanceof
name|ExprNodeColumnDesc
operator|)
operator|&&
operator|(
name|rightExpr
operator|instanceof
name|ExprNodeGenericFuncDesc
operator|)
condition|)
block|{
name|ExprNodeColumnDesc
name|rightColDesc
init|=
operator|(
name|ExprNodeColumnDesc
operator|)
name|leftExpr
decl_stmt|;
name|v2
operator|=
name|getVectorExpression
argument_list|(
operator|(
name|ExprNodeGenericFuncDesc
operator|)
name|rightExpr
argument_list|)
expr_stmt|;
name|int
name|inputCol1
init|=
name|getInputColumnIndex
argument_list|(
name|rightColDesc
operator|.
name|getColumn
argument_list|()
argument_list|)
decl_stmt|;
name|int
name|inputCol2
init|=
name|v2
operator|.
name|getOutputColumn
argument_list|()
decl_stmt|;
name|String
name|colType1
init|=
name|rightColDesc
operator|.
name|getTypeString
argument_list|()
decl_stmt|;
name|String
name|colType2
init|=
name|v2
operator|.
name|getOutputType
argument_list|()
decl_stmt|;
name|String
name|className
init|=
name|getFilterColumnColumnExpressionClassName
argument_list|(
name|colType1
argument_list|,
name|colType2
argument_list|,
name|opName
argument_list|)
decl_stmt|;
try|try
block|{
name|expr
operator|=
operator|(
name|VectorExpression
operator|)
name|getConstructor
argument_list|(
name|className
argument_list|)
operator|.
name|newInstance
argument_list|(
name|inputCol1
argument_list|,
name|inputCol2
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|ex
parameter_list|)
block|{
throw|throw
operator|new
name|HiveException
argument_list|(
name|ex
argument_list|)
throw|;
block|}
name|expr
operator|.
name|setChildExpressions
argument_list|(
operator|new
name|VectorExpression
index|[]
block|{
name|v2
block|}
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|leftExpr
operator|instanceof
name|ExprNodeGenericFuncDesc
operator|)
operator|&&
operator|(
name|rightExpr
operator|instanceof
name|ExprNodeConstantDesc
operator|)
condition|)
block|{
name|v1
operator|=
name|getVectorExpression
argument_list|(
operator|(
name|ExprNodeGenericFuncDesc
operator|)
name|leftExpr
argument_list|)
expr_stmt|;
name|ExprNodeConstantDesc
name|constDesc
init|=
operator|(
name|ExprNodeConstantDesc
operator|)
name|rightExpr
decl_stmt|;
name|int
name|inputCol1
init|=
name|v1
operator|.
name|getOutputColumn
argument_list|()
decl_stmt|;
name|String
name|colType1
init|=
name|v1
operator|.
name|getOutputType
argument_list|()
decl_stmt|;
name|String
name|scalarType
init|=
name|constDesc
operator|.
name|getTypeString
argument_list|()
decl_stmt|;
name|String
name|className
init|=
name|getFilterColumnScalarExpressionClassName
argument_list|(
name|colType1
argument_list|,
name|scalarType
argument_list|,
name|opName
argument_list|)
decl_stmt|;
try|try
block|{
name|expr
operator|=
operator|(
name|VectorExpression
operator|)
name|getConstructor
argument_list|(
name|className
argument_list|)
operator|.
name|newInstance
argument_list|(
name|inputCol1
argument_list|,
name|getScalarValue
argument_list|(
name|constDesc
argument_list|)
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|ex
parameter_list|)
block|{
throw|throw
operator|new
name|HiveException
argument_list|(
name|ex
argument_list|)
throw|;
block|}
name|expr
operator|.
name|setChildExpressions
argument_list|(
operator|new
name|VectorExpression
index|[]
block|{
name|v1
block|}
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|leftExpr
operator|instanceof
name|ExprNodeConstantDesc
operator|)
operator|&&
operator|(
name|rightExpr
operator|instanceof
name|ExprNodeGenericFuncDesc
operator|)
condition|)
block|{
name|ExprNodeConstantDesc
name|constDesc
init|=
operator|(
name|ExprNodeConstantDesc
operator|)
name|leftExpr
decl_stmt|;
name|v2
operator|=
name|getVectorExpression
argument_list|(
operator|(
name|ExprNodeGenericFuncDesc
operator|)
name|rightExpr
argument_list|)
expr_stmt|;
name|int
name|inputCol2
init|=
name|v2
operator|.
name|getOutputColumn
argument_list|()
decl_stmt|;
name|String
name|scalarType
init|=
name|constDesc
operator|.
name|getTypeString
argument_list|()
decl_stmt|;
name|String
name|colType
init|=
name|v2
operator|.
name|getOutputType
argument_list|()
decl_stmt|;
name|String
name|className
init|=
name|getFilterScalarColumnExpressionClassName
argument_list|(
name|colType
argument_list|,
name|scalarType
argument_list|,
name|opName
argument_list|)
decl_stmt|;
try|try
block|{
name|expr
operator|=
operator|(
name|VectorExpression
operator|)
name|getConstructor
argument_list|(
name|className
argument_list|)
operator|.
name|newInstance
argument_list|(
name|inputCol2
argument_list|,
name|getScalarValue
argument_list|(
name|constDesc
argument_list|)
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|ex
parameter_list|)
block|{
throw|throw
operator|new
name|HiveException
argument_list|(
name|ex
argument_list|)
throw|;
block|}
name|expr
operator|.
name|setChildExpressions
argument_list|(
operator|new
name|VectorExpression
index|[]
block|{
name|v2
block|}
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|//For comparison expression, the child expressions must be materializing
comment|//columns
name|v1
operator|=
name|getVectorExpression
argument_list|(
name|leftExpr
argument_list|)
expr_stmt|;
name|v2
operator|=
name|getVectorExpression
argument_list|(
name|rightExpr
argument_list|)
expr_stmt|;
name|int
name|inputCol1
init|=
name|v1
operator|.
name|getOutputColumn
argument_list|()
decl_stmt|;
name|int
name|inputCol2
init|=
name|v2
operator|.
name|getOutputColumn
argument_list|()
decl_stmt|;
name|String
name|colType1
init|=
name|v1
operator|.
name|getOutputType
argument_list|()
decl_stmt|;
name|String
name|colType2
init|=
name|v2
operator|.
name|getOutputType
argument_list|()
decl_stmt|;
name|String
name|className
init|=
name|getFilterColumnColumnExpressionClassName
argument_list|(
name|colType1
argument_list|,
name|colType2
argument_list|,
name|opName
argument_list|)
decl_stmt|;
try|try
block|{
name|expr
operator|=
operator|(
name|VectorExpression
operator|)
name|getConstructor
argument_list|(
name|className
argument_list|)
operator|.
name|newInstance
argument_list|(
name|inputCol1
argument_list|,
name|inputCol2
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|ex
parameter_list|)
block|{
throw|throw
operator|new
name|HiveException
argument_list|(
name|ex
argument_list|)
throw|;
block|}
name|expr
operator|.
name|setChildExpressions
argument_list|(
operator|new
name|VectorExpression
index|[]
block|{
name|v1
block|,
name|v2
block|}
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|v1
operator|!=
literal|null
condition|)
block|{
name|ocm
operator|.
name|freeOutputColumn
argument_list|(
name|v1
operator|.
name|getOutputColumn
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|v2
operator|!=
literal|null
condition|)
block|{
name|ocm
operator|.
name|freeOutputColumn
argument_list|(
name|v2
operator|.
name|getOutputColumn
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|expr
return|;
block|}
specifier|private
name|Constructor
argument_list|<
name|?
argument_list|>
name|getConstructor
parameter_list|(
name|String
name|className
parameter_list|)
throws|throws
name|HiveException
block|{
try|try
block|{
name|Class
argument_list|<
name|?
argument_list|>
name|cl
init|=
name|Class
operator|.
name|forName
argument_list|(
name|className
argument_list|)
decl_stmt|;
name|Constructor
argument_list|<
name|?
argument_list|>
index|[]
name|ctors
init|=
name|cl
operator|.
name|getDeclaredConstructors
argument_list|()
decl_stmt|;
name|Constructor
argument_list|<
name|?
argument_list|>
name|defaultCtor
init|=
name|cl
operator|.
name|getConstructor
argument_list|()
decl_stmt|;
for|for
control|(
name|Constructor
argument_list|<
name|?
argument_list|>
name|ctor
range|:
name|ctors
control|)
block|{
if|if
condition|(
operator|!
name|ctor
operator|.
name|equals
argument_list|(
name|defaultCtor
argument_list|)
condition|)
block|{
return|return
name|ctor
return|;
block|}
block|}
throw|throw
operator|new
name|HiveException
argument_list|(
literal|"Only default constructor found"
argument_list|)
throw|;
block|}
catch|catch
parameter_list|(
name|Exception
name|ex
parameter_list|)
block|{
throw|throw
operator|new
name|HiveException
argument_list|(
name|ex
argument_list|)
throw|;
block|}
block|}
specifier|private
name|String
name|getNormalizedTypeName
parameter_list|(
name|String
name|colType
parameter_list|)
throws|throws
name|HiveException
block|{
name|validateInputType
argument_list|(
name|colType
argument_list|)
expr_stmt|;
name|String
name|normalizedType
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|colType
operator|.
name|equalsIgnoreCase
argument_list|(
literal|"Double"
argument_list|)
operator|||
name|colType
operator|.
name|equalsIgnoreCase
argument_list|(
literal|"Float"
argument_list|)
condition|)
block|{
name|normalizedType
operator|=
literal|"Double"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|colType
operator|.
name|equalsIgnoreCase
argument_list|(
literal|"String"
argument_list|)
condition|)
block|{
name|normalizedType
operator|=
literal|"String"
expr_stmt|;
block|}
else|else
block|{
name|normalizedType
operator|=
literal|"Long"
expr_stmt|;
block|}
return|return
name|normalizedType
return|;
block|}
specifier|private
name|String
name|getFilterColumnColumnExpressionClassName
parameter_list|(
name|String
name|colType1
parameter_list|,
name|String
name|colType2
parameter_list|,
name|String
name|opName
parameter_list|)
throws|throws
name|HiveException
block|{
name|StringBuilder
name|b
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|b
operator|.
name|append
argument_list|(
literal|"org.apache.hadoop.hive.ql.exec.vector.expressions.gen."
argument_list|)
expr_stmt|;
if|if
condition|(
name|opType
operator|.
name|equals
argument_list|(
name|OperatorType
operator|.
name|FILTER
argument_list|)
condition|)
block|{
name|b
operator|.
name|append
argument_list|(
literal|"Filter"
argument_list|)
expr_stmt|;
block|}
name|b
operator|.
name|append
argument_list|(
name|getNormalizedTypeName
argument_list|(
name|colType1
argument_list|)
argument_list|)
expr_stmt|;
name|b
operator|.
name|append
argument_list|(
literal|"Col"
argument_list|)
expr_stmt|;
name|b
operator|.
name|append
argument_list|(
name|opName
argument_list|)
expr_stmt|;
name|b
operator|.
name|append
argument_list|(
name|getNormalizedTypeName
argument_list|(
name|colType2
argument_list|)
argument_list|)
expr_stmt|;
name|b
operator|.
name|append
argument_list|(
literal|"Column"
argument_list|)
expr_stmt|;
return|return
name|b
operator|.
name|toString
argument_list|()
return|;
block|}
specifier|private
name|String
name|getFilterColumnScalarExpressionClassName
parameter_list|(
name|String
name|colType
parameter_list|,
name|String
name|scalarType
parameter_list|,
name|String
name|opName
parameter_list|)
throws|throws
name|HiveException
block|{
name|StringBuilder
name|b
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|b
operator|.
name|append
argument_list|(
literal|"org.apache.hadoop.hive.ql.exec.vector.expressions.gen."
argument_list|)
expr_stmt|;
if|if
condition|(
name|opType
operator|.
name|equals
argument_list|(
name|OperatorType
operator|.
name|FILTER
argument_list|)
condition|)
block|{
name|b
operator|.
name|append
argument_list|(
literal|"Filter"
argument_list|)
expr_stmt|;
block|}
name|b
operator|.
name|append
argument_list|(
name|getNormalizedTypeName
argument_list|(
name|colType
argument_list|)
argument_list|)
expr_stmt|;
name|b
operator|.
name|append
argument_list|(
literal|"Col"
argument_list|)
expr_stmt|;
name|b
operator|.
name|append
argument_list|(
name|opName
argument_list|)
expr_stmt|;
name|b
operator|.
name|append
argument_list|(
name|getNormalizedTypeName
argument_list|(
name|scalarType
argument_list|)
argument_list|)
expr_stmt|;
name|b
operator|.
name|append
argument_list|(
literal|"Scalar"
argument_list|)
expr_stmt|;
return|return
name|b
operator|.
name|toString
argument_list|()
return|;
block|}
specifier|private
name|String
name|getFilterScalarColumnExpressionClassName
parameter_list|(
name|String
name|colType
parameter_list|,
name|String
name|scalarType
parameter_list|,
name|String
name|opName
parameter_list|)
throws|throws
name|HiveException
block|{
name|StringBuilder
name|b
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|b
operator|.
name|append
argument_list|(
literal|"org.apache.hadoop.hive.ql.exec.vector.expressions.gen."
argument_list|)
expr_stmt|;
if|if
condition|(
name|opType
operator|.
name|equals
argument_list|(
name|OperatorType
operator|.
name|FILTER
argument_list|)
condition|)
block|{
name|b
operator|.
name|append
argument_list|(
literal|"Filter"
argument_list|)
expr_stmt|;
block|}
name|b
operator|.
name|append
argument_list|(
name|getNormalizedTypeName
argument_list|(
name|scalarType
argument_list|)
argument_list|)
expr_stmt|;
name|b
operator|.
name|append
argument_list|(
literal|"Scalar"
argument_list|)
expr_stmt|;
name|b
operator|.
name|append
argument_list|(
name|opName
argument_list|)
expr_stmt|;
name|b
operator|.
name|append
argument_list|(
name|getNormalizedTypeName
argument_list|(
name|colType
argument_list|)
argument_list|)
expr_stmt|;
name|b
operator|.
name|append
argument_list|(
literal|"Column"
argument_list|)
expr_stmt|;
return|return
name|b
operator|.
name|toString
argument_list|()
return|;
block|}
specifier|private
name|String
name|getBinaryColumnScalarExpressionClassName
parameter_list|(
name|String
name|colType
parameter_list|,
name|String
name|scalarType
parameter_list|,
name|String
name|method
parameter_list|)
throws|throws
name|HiveException
block|{
name|StringBuilder
name|b
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|String
name|normColType
init|=
name|getNormalizedTypeName
argument_list|(
name|colType
argument_list|)
decl_stmt|;
name|String
name|normScalarType
init|=
name|getNormalizedTypeName
argument_list|(
name|scalarType
argument_list|)
decl_stmt|;
if|if
condition|(
name|normColType
operator|.
name|equalsIgnoreCase
argument_list|(
literal|"long"
argument_list|)
operator|&&
name|normScalarType
operator|.
name|equalsIgnoreCase
argument_list|(
literal|"long"
argument_list|)
operator|&&
name|method
operator|.
name|equalsIgnoreCase
argument_list|(
literal|"divide"
argument_list|)
condition|)
block|{
name|b
operator|.
name|append
argument_list|(
literal|"org.apache.hadoop.hive.ql.exec.vector.expressions."
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|b
operator|.
name|append
argument_list|(
literal|"org.apache.hadoop.hive.ql.exec.vector.expressions.gen."
argument_list|)
expr_stmt|;
block|}
name|b
operator|.
name|append
argument_list|(
name|normColType
argument_list|)
expr_stmt|;
name|b
operator|.
name|append
argument_list|(
literal|"Col"
argument_list|)
expr_stmt|;
name|b
operator|.
name|append
argument_list|(
name|method
argument_list|)
expr_stmt|;
name|b
operator|.
name|append
argument_list|(
name|normScalarType
argument_list|)
expr_stmt|;
name|b
operator|.
name|append
argument_list|(
literal|"Scalar"
argument_list|)
expr_stmt|;
return|return
name|b
operator|.
name|toString
argument_list|()
return|;
block|}
specifier|private
name|String
name|getBinaryScalarColumnExpressionClassName
parameter_list|(
name|String
name|colType
parameter_list|,
name|String
name|scalarType
parameter_list|,
name|String
name|method
parameter_list|)
throws|throws
name|HiveException
block|{
name|StringBuilder
name|b
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|String
name|normColType
init|=
name|getNormalizedTypeName
argument_list|(
name|colType
argument_list|)
decl_stmt|;
name|String
name|normScalarType
init|=
name|getNormalizedTypeName
argument_list|(
name|scalarType
argument_list|)
decl_stmt|;
if|if
condition|(
name|normColType
operator|.
name|equalsIgnoreCase
argument_list|(
literal|"long"
argument_list|)
operator|&&
name|normScalarType
operator|.
name|equalsIgnoreCase
argument_list|(
literal|"long"
argument_list|)
operator|&&
name|method
operator|.
name|equalsIgnoreCase
argument_list|(
literal|"divide"
argument_list|)
condition|)
block|{
name|b
operator|.
name|append
argument_list|(
literal|"org.apache.hadoop.hive.ql.exec.vector.expressions."
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|b
operator|.
name|append
argument_list|(
literal|"org.apache.hadoop.hive.ql.exec.vector.expressions.gen."
argument_list|)
expr_stmt|;
block|}
name|b
operator|.
name|append
argument_list|(
name|normScalarType
argument_list|)
expr_stmt|;
name|b
operator|.
name|append
argument_list|(
literal|"Scalar"
argument_list|)
expr_stmt|;
name|b
operator|.
name|append
argument_list|(
name|method
argument_list|)
expr_stmt|;
name|b
operator|.
name|append
argument_list|(
name|normColType
argument_list|)
expr_stmt|;
name|b
operator|.
name|append
argument_list|(
literal|"Column"
argument_list|)
expr_stmt|;
return|return
name|b
operator|.
name|toString
argument_list|()
return|;
block|}
specifier|private
name|String
name|getBinaryColumnColumnExpressionClassName
parameter_list|(
name|String
name|colType1
parameter_list|,
name|String
name|colType2
parameter_list|,
name|String
name|method
parameter_list|)
throws|throws
name|HiveException
block|{
name|StringBuilder
name|b
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|String
name|normColType1
init|=
name|getNormalizedTypeName
argument_list|(
name|colType1
argument_list|)
decl_stmt|;
name|String
name|normColType2
init|=
name|getNormalizedTypeName
argument_list|(
name|colType2
argument_list|)
decl_stmt|;
if|if
condition|(
name|normColType1
operator|.
name|equalsIgnoreCase
argument_list|(
literal|"long"
argument_list|)
operator|&&
name|normColType2
operator|.
name|equalsIgnoreCase
argument_list|(
literal|"long"
argument_list|)
operator|&&
name|method
operator|.
name|equalsIgnoreCase
argument_list|(
literal|"divide"
argument_list|)
condition|)
block|{
name|b
operator|.
name|append
argument_list|(
literal|"org.apache.hadoop.hive.ql.exec.vector.expressions."
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|b
operator|.
name|append
argument_list|(
literal|"org.apache.hadoop.hive.ql.exec.vector.expressions.gen."
argument_list|)
expr_stmt|;
block|}
name|b
operator|.
name|append
argument_list|(
name|normColType1
argument_list|)
expr_stmt|;
name|b
operator|.
name|append
argument_list|(
literal|"Col"
argument_list|)
expr_stmt|;
name|b
operator|.
name|append
argument_list|(
name|method
argument_list|)
expr_stmt|;
name|b
operator|.
name|append
argument_list|(
name|normColType2
argument_list|)
expr_stmt|;
name|b
operator|.
name|append
argument_list|(
literal|"Column"
argument_list|)
expr_stmt|;
return|return
name|b
operator|.
name|toString
argument_list|()
return|;
block|}
specifier|private
name|String
name|getOutputColType
parameter_list|(
name|String
name|inputType1
parameter_list|,
name|String
name|inputType2
parameter_list|,
name|String
name|method
parameter_list|)
throws|throws
name|HiveException
block|{
name|validateInputType
argument_list|(
name|inputType1
argument_list|)
expr_stmt|;
name|validateInputType
argument_list|(
name|inputType2
argument_list|)
expr_stmt|;
if|if
condition|(
name|method
operator|.
name|equalsIgnoreCase
argument_list|(
literal|"divide"
argument_list|)
operator|||
name|inputType1
operator|.
name|equalsIgnoreCase
argument_list|(
literal|"double"
argument_list|)
operator|||
name|inputType2
operator|.
name|equalsIgnoreCase
argument_list|(
literal|"double"
argument_list|)
operator|||
name|inputType1
operator|.
name|equalsIgnoreCase
argument_list|(
literal|"float"
argument_list|)
operator|||
name|inputType2
operator|.
name|equalsIgnoreCase
argument_list|(
literal|"float"
argument_list|)
condition|)
block|{
return|return
literal|"double"
return|;
block|}
else|else
block|{
if|if
condition|(
name|inputType1
operator|.
name|equalsIgnoreCase
argument_list|(
literal|"string"
argument_list|)
operator|||
name|inputType2
operator|.
name|equalsIgnoreCase
argument_list|(
literal|"string"
argument_list|)
condition|)
block|{
return|return
literal|"string"
return|;
block|}
else|else
block|{
return|return
literal|"long"
return|;
block|}
block|}
block|}
specifier|private
name|void
name|validateInputType
parameter_list|(
name|String
name|inputType
parameter_list|)
throws|throws
name|HiveException
block|{
if|if
condition|(
operator|!
operator|(
name|inputType
operator|.
name|equalsIgnoreCase
argument_list|(
literal|"float"
argument_list|)
operator|||
name|inputType
operator|.
name|equalsIgnoreCase
argument_list|(
literal|"double"
argument_list|)
operator|||
name|inputType
operator|.
name|equalsIgnoreCase
argument_list|(
literal|"string"
argument_list|)
operator|||
name|inputType
operator|.
name|equalsIgnoreCase
argument_list|(
literal|"tinyint"
argument_list|)
operator|||
name|inputType
operator|.
name|equalsIgnoreCase
argument_list|(
literal|"smallint"
argument_list|)
operator|||
name|inputType
operator|.
name|equalsIgnoreCase
argument_list|(
literal|"short"
argument_list|)
operator|||
name|inputType
operator|.
name|equalsIgnoreCase
argument_list|(
literal|"byte"
argument_list|)
operator|||
name|inputType
operator|.
name|equalsIgnoreCase
argument_list|(
literal|"int"
argument_list|)
operator|||
name|inputType
operator|.
name|equalsIgnoreCase
argument_list|(
literal|"long"
argument_list|)
operator|||
name|inputType
operator|.
name|equalsIgnoreCase
argument_list|(
literal|"bigint"
argument_list|)
operator|||
name|inputType
operator|.
name|equalsIgnoreCase
argument_list|(
literal|"boolean"
argument_list|)
operator|||
name|inputType
operator|.
name|equalsIgnoreCase
argument_list|(
literal|"timestamp"
argument_list|)
operator|)
condition|)
block|{
throw|throw
operator|new
name|HiveException
argument_list|(
literal|"Unsupported input type: "
operator|+
name|inputType
argument_list|)
throw|;
block|}
block|}
specifier|private
name|String
name|getOutputColType
parameter_list|(
name|String
name|inputType
parameter_list|,
name|String
name|method
parameter_list|)
throws|throws
name|HiveException
block|{
name|validateInputType
argument_list|(
name|inputType
argument_list|)
expr_stmt|;
if|if
condition|(
name|inputType
operator|.
name|equalsIgnoreCase
argument_list|(
literal|"float"
argument_list|)
operator|||
name|inputType
operator|.
name|equalsIgnoreCase
argument_list|(
literal|"double"
argument_list|)
condition|)
block|{
return|return
literal|"double"
return|;
block|}
elseif|else
if|if
condition|(
name|inputType
operator|.
name|equalsIgnoreCase
argument_list|(
literal|"string"
argument_list|)
condition|)
block|{
return|return
literal|"string"
return|;
block|}
else|else
block|{
return|return
literal|"long"
return|;
block|}
block|}
specifier|static
name|Object
index|[]
index|[]
name|aggregatesDefinition
init|=
block|{
block|{
literal|"min"
block|,
literal|"Long"
block|,
name|VectorUDAFMinLong
operator|.
name|class
block|}
block|,
block|{
literal|"min"
block|,
literal|"Double"
block|,
name|VectorUDAFMinDouble
operator|.
name|class
block|}
block|,
block|{
literal|"min"
block|,
literal|"String"
block|,
name|VectorUDAFMinString
operator|.
name|class
block|}
block|,
block|{
literal|"max"
block|,
literal|"Long"
block|,
name|VectorUDAFMaxLong
operator|.
name|class
block|}
block|,
block|{
literal|"max"
block|,
literal|"Double"
block|,
name|VectorUDAFMaxDouble
operator|.
name|class
block|}
block|,
block|{
literal|"max"
block|,
literal|"String"
block|,
name|VectorUDAFMaxString
operator|.
name|class
block|}
block|,
block|{
literal|"count"
block|,
literal|null
block|,
name|VectorUDAFCountStar
operator|.
name|class
block|}
block|,
block|{
literal|"count"
block|,
literal|"Long"
block|,
name|VectorUDAFCount
operator|.
name|class
block|}
block|,
block|{
literal|"count"
block|,
literal|"Double"
block|,
name|VectorUDAFCount
operator|.
name|class
block|}
block|,
block|{
literal|"count"
block|,
literal|"String"
block|,
name|VectorUDAFCount
operator|.
name|class
block|}
block|,
block|{
literal|"sum"
block|,
literal|"Long"
block|,
name|VectorUDAFSumLong
operator|.
name|class
block|}
block|,
block|{
literal|"sum"
block|,
literal|"Double"
block|,
name|VectorUDAFSumDouble
operator|.
name|class
block|}
block|,
block|{
literal|"avg"
block|,
literal|"Long"
block|,
name|VectorUDAFAvgLong
operator|.
name|class
block|}
block|,
block|{
literal|"avg"
block|,
literal|"Double"
block|,
name|VectorUDAFAvgDouble
operator|.
name|class
block|}
block|,
block|{
literal|"variance"
block|,
literal|"Long"
block|,
name|VectorUDAFVarPopLong
operator|.
name|class
block|}
block|,
block|{
literal|"var_pop"
block|,
literal|"Long"
block|,
name|VectorUDAFVarPopLong
operator|.
name|class
block|}
block|,
block|{
literal|"variance"
block|,
literal|"Double"
block|,
name|VectorUDAFVarPopDouble
operator|.
name|class
block|}
block|,
block|{
literal|"var_pop"
block|,
literal|"Double"
block|,
name|VectorUDAFVarPopDouble
operator|.
name|class
block|}
block|,
block|{
literal|"var_samp"
block|,
literal|"Long"
block|,
name|VectorUDAFVarSampLong
operator|.
name|class
block|}
block|,
block|{
literal|"var_samp"
block|,
literal|"Double"
block|,
name|VectorUDAFVarSampDouble
operator|.
name|class
block|}
block|,
block|{
literal|"std"
block|,
literal|"Long"
block|,
name|VectorUDAFStdPopLong
operator|.
name|class
block|}
block|,
block|{
literal|"stddev"
block|,
literal|"Long"
block|,
name|VectorUDAFStdPopLong
operator|.
name|class
block|}
block|,
block|{
literal|"stddev_pop"
block|,
literal|"Long"
block|,
name|VectorUDAFStdPopLong
operator|.
name|class
block|}
block|,
block|{
literal|"std"
block|,
literal|"Double"
block|,
name|VectorUDAFStdPopDouble
operator|.
name|class
block|}
block|,
block|{
literal|"stddev"
block|,
literal|"Double"
block|,
name|VectorUDAFStdPopDouble
operator|.
name|class
block|}
block|,
block|{
literal|"stddev_pop"
block|,
literal|"Double"
block|,
name|VectorUDAFStdPopDouble
operator|.
name|class
block|}
block|,
block|{
literal|"stddev_samp"
block|,
literal|"Long"
block|,
name|VectorUDAFStdSampLong
operator|.
name|class
block|}
block|,
block|{
literal|"stddev_samp"
block|,
literal|"Double"
block|,
name|VectorUDAFStdSampDouble
operator|.
name|class
block|}
block|,   }
decl_stmt|;
specifier|public
name|VectorAggregateExpression
name|getAggregatorExpression
parameter_list|(
name|AggregationDesc
name|desc
parameter_list|)
throws|throws
name|HiveException
block|{
name|ArrayList
argument_list|<
name|ExprNodeDesc
argument_list|>
name|paramDescList
init|=
name|desc
operator|.
name|getParameters
argument_list|()
decl_stmt|;
name|VectorExpression
index|[]
name|vectorParams
init|=
operator|new
name|VectorExpression
index|[
name|paramDescList
operator|.
name|size
argument_list|()
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|paramDescList
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|ExprNodeDesc
name|exprDesc
init|=
name|paramDescList
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|vectorParams
index|[
name|i
index|]
operator|=
name|this
operator|.
name|getVectorExpression
argument_list|(
name|exprDesc
argument_list|)
expr_stmt|;
block|}
name|String
name|aggregateName
init|=
name|desc
operator|.
name|getGenericUDAFName
argument_list|()
decl_stmt|;
name|String
name|inputType
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|paramDescList
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
name|ExprNodeDesc
name|inputExpr
init|=
name|paramDescList
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|inputType
operator|=
name|getNormalizedTypeName
argument_list|(
name|inputExpr
operator|.
name|getTypeString
argument_list|()
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|Object
index|[]
name|aggDef
range|:
name|aggregatesDefinition
control|)
block|{
if|if
condition|(
name|aggregateName
operator|.
name|equalsIgnoreCase
argument_list|(
operator|(
name|String
operator|)
name|aggDef
index|[
literal|0
index|]
argument_list|)
operator|&&
operator|(
operator|(
name|aggDef
index|[
literal|1
index|]
operator|==
literal|null
operator|&&
name|inputType
operator|==
literal|null
operator|)
operator|||
operator|(
name|aggDef
index|[
literal|1
index|]
operator|!=
literal|null
operator|&&
name|aggDef
index|[
literal|1
index|]
operator|.
name|equals
argument_list|(
name|inputType
argument_list|)
operator|)
operator|)
condition|)
block|{
name|Class
argument_list|<
name|?
extends|extends
name|VectorAggregateExpression
argument_list|>
name|aggClass
init|=
call|(
name|Class
argument_list|<
name|?
extends|extends
name|VectorAggregateExpression
argument_list|>
call|)
argument_list|(
name|aggDef
index|[
literal|2
index|]
argument_list|)
decl_stmt|;
try|try
block|{
name|Constructor
argument_list|<
name|?
extends|extends
name|VectorAggregateExpression
argument_list|>
name|ctor
init|=
name|aggClass
operator|.
name|getConstructor
argument_list|(
name|VectorExpression
operator|.
name|class
argument_list|)
decl_stmt|;
name|VectorAggregateExpression
name|aggExpr
init|=
name|ctor
operator|.
name|newInstance
argument_list|(
name|vectorParams
operator|.
name|length
operator|>
literal|0
condition|?
name|vectorParams
index|[
literal|0
index|]
else|:
literal|null
argument_list|)
decl_stmt|;
name|aggExpr
operator|.
name|init
argument_list|(
name|desc
argument_list|)
expr_stmt|;
return|return
name|aggExpr
return|;
block|}
comment|// TODO: change to 1.7 syntax when possible
comment|//catch (InvocationTargetException | IllegalAccessException
comment|// | NoSuchMethodException | InstantiationException)
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|HiveException
argument_list|(
literal|"Internal exception for vector aggregate : \""
operator|+
name|aggregateName
operator|+
literal|"\" for type: \""
operator|+
name|inputType
operator|+
literal|""
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
block|}
throw|throw
operator|new
name|HiveException
argument_list|(
literal|"Vector aggregate not implemented: \""
operator|+
name|aggregateName
operator|+
literal|"\" for type: \""
operator|+
name|inputType
operator|+
literal|""
argument_list|)
throw|;
block|}
specifier|static
name|Object
index|[]
index|[]
name|columnTypes
init|=
block|{
block|{
literal|"Double"
block|,
name|DoubleColumnVector
operator|.
name|class
block|}
block|,
block|{
literal|"Long"
block|,
name|LongColumnVector
operator|.
name|class
block|}
block|,
block|{
literal|"String"
block|,
name|BytesColumnVector
operator|.
name|class
block|}
block|,   }
decl_stmt|;
specifier|public
name|Map
argument_list|<
name|Integer
argument_list|,
name|String
argument_list|>
name|getOutputColumnTypeMap
parameter_list|()
block|{
name|Map
argument_list|<
name|Integer
argument_list|,
name|String
argument_list|>
name|map
init|=
operator|new
name|HashMap
argument_list|<
name|Integer
argument_list|,
name|String
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|ocm
operator|.
name|outputColCount
condition|;
name|i
operator|++
control|)
block|{
name|String
name|type
init|=
name|ocm
operator|.
name|outputColumnsTypes
index|[
name|i
index|]
decl_stmt|;
name|map
operator|.
name|put
argument_list|(
name|i
operator|+
name|this
operator|.
name|firstOutputColumnIndex
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
return|return
name|map
return|;
block|}
specifier|public
name|ColumnVector
name|allocateColumnVector
parameter_list|(
name|String
name|type
parameter_list|,
name|int
name|defaultSize
parameter_list|)
block|{
if|if
condition|(
name|type
operator|.
name|equalsIgnoreCase
argument_list|(
literal|"double"
argument_list|)
condition|)
block|{
return|return
operator|new
name|DoubleColumnVector
argument_list|(
name|defaultSize
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|type
operator|.
name|equalsIgnoreCase
argument_list|(
literal|"string"
argument_list|)
condition|)
block|{
return|return
operator|new
name|BytesColumnVector
argument_list|(
name|defaultSize
argument_list|)
return|;
block|}
else|else
block|{
return|return
operator|new
name|LongColumnVector
argument_list|(
name|defaultSize
argument_list|)
return|;
block|}
block|}
specifier|public
name|void
name|addToColumnMap
parameter_list|(
name|String
name|columnName
parameter_list|,
name|int
name|outputColumn
parameter_list|)
block|{
if|if
condition|(
name|columnMap
operator|!=
literal|null
condition|)
block|{
name|columnMap
operator|.
name|put
argument_list|(
name|columnName
argument_list|,
name|outputColumn
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_class

end_unit

