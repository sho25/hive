begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|vector
package|;
end_package

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|reflect
operator|.
name|Constructor
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|reflect
operator|.
name|InvocationTargetException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|sql
operator|.
name|Timestamp
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|regex
operator|.
name|Pattern
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|Log
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|LogFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|common
operator|.
name|type
operator|.
name|Decimal128
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|common
operator|.
name|type
operator|.
name|HiveDecimal
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|ExprNodeEvaluator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|ExprNodeEvaluatorFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|FunctionInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|FunctionRegistry
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|UDF
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|vector
operator|.
name|TimestampUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|vector
operator|.
name|VectorExpressionDescriptor
operator|.
name|InputExpressionType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|vector
operator|.
name|VectorExpressionDescriptor
operator|.
name|Mode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|vector
operator|.
name|expressions
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|vector
operator|.
name|expressions
operator|.
name|aggregates
operator|.
name|VectorAggregateExpression
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|vector
operator|.
name|expressions
operator|.
name|aggregates
operator|.
name|VectorUDAFCount
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|vector
operator|.
name|expressions
operator|.
name|aggregates
operator|.
name|VectorUDAFCountStar
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|vector
operator|.
name|expressions
operator|.
name|aggregates
operator|.
name|gen
operator|.
name|VectorUDAFAvgDouble
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|vector
operator|.
name|expressions
operator|.
name|aggregates
operator|.
name|gen
operator|.
name|VectorUDAFAvgLong
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|vector
operator|.
name|expressions
operator|.
name|aggregates
operator|.
name|gen
operator|.
name|VectorUDAFMaxDouble
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|vector
operator|.
name|expressions
operator|.
name|aggregates
operator|.
name|gen
operator|.
name|VectorUDAFMaxLong
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|vector
operator|.
name|expressions
operator|.
name|aggregates
operator|.
name|gen
operator|.
name|VectorUDAFMaxString
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|vector
operator|.
name|expressions
operator|.
name|aggregates
operator|.
name|gen
operator|.
name|VectorUDAFMinDouble
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|vector
operator|.
name|expressions
operator|.
name|aggregates
operator|.
name|gen
operator|.
name|VectorUDAFMinLong
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|vector
operator|.
name|expressions
operator|.
name|aggregates
operator|.
name|gen
operator|.
name|VectorUDAFMinString
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|vector
operator|.
name|expressions
operator|.
name|aggregates
operator|.
name|gen
operator|.
name|VectorUDAFStdPopDouble
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|vector
operator|.
name|expressions
operator|.
name|aggregates
operator|.
name|gen
operator|.
name|VectorUDAFStdPopLong
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|vector
operator|.
name|expressions
operator|.
name|aggregates
operator|.
name|gen
operator|.
name|VectorUDAFStdSampDouble
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|vector
operator|.
name|expressions
operator|.
name|aggregates
operator|.
name|gen
operator|.
name|VectorUDAFStdSampLong
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|vector
operator|.
name|expressions
operator|.
name|aggregates
operator|.
name|gen
operator|.
name|VectorUDAFSumDouble
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|vector
operator|.
name|expressions
operator|.
name|aggregates
operator|.
name|gen
operator|.
name|VectorUDAFSumLong
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|vector
operator|.
name|expressions
operator|.
name|aggregates
operator|.
name|gen
operator|.
name|VectorUDAFVarPopDouble
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|vector
operator|.
name|expressions
operator|.
name|aggregates
operator|.
name|gen
operator|.
name|VectorUDAFVarPopLong
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|vector
operator|.
name|expressions
operator|.
name|aggregates
operator|.
name|gen
operator|.
name|VectorUDAFVarSampDouble
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|vector
operator|.
name|expressions
operator|.
name|aggregates
operator|.
name|gen
operator|.
name|VectorUDAFVarSampLong
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|vector
operator|.
name|expressions
operator|.
name|gen
operator|.
name|CastLongToBooleanViaLongToLong
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|vector
operator|.
name|expressions
operator|.
name|gen
operator|.
name|CastLongToDouble
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|vector
operator|.
name|expressions
operator|.
name|gen
operator|.
name|CastTimestampToDoubleViaLongToDouble
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|vector
operator|.
name|expressions
operator|.
name|gen
operator|.
name|FilterDoubleColumnBetween
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|vector
operator|.
name|expressions
operator|.
name|gen
operator|.
name|FilterDoubleColumnNotBetween
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|vector
operator|.
name|expressions
operator|.
name|gen
operator|.
name|FilterLongColumnBetween
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|vector
operator|.
name|expressions
operator|.
name|gen
operator|.
name|FilterLongColumnNotBetween
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|vector
operator|.
name|expressions
operator|.
name|gen
operator|.
name|FilterStringColumnBetween
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|vector
operator|.
name|expressions
operator|.
name|gen
operator|.
name|FilterStringColumnNotBetween
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|vector
operator|.
name|udf
operator|.
name|VectorUDFAdaptor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|vector
operator|.
name|udf
operator|.
name|VectorUDFArgDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|metadata
operator|.
name|HiveException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|AggregationDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|ExprNodeColumnDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|ExprNodeConstantDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|ExprNodeDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|ExprNodeGenericFuncDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|udf
operator|.
name|UDFConv
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|udf
operator|.
name|UDFHex
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|udf
operator|.
name|UDFToBoolean
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|udf
operator|.
name|UDFToByte
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|udf
operator|.
name|UDFToDouble
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|udf
operator|.
name|UDFToFloat
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|udf
operator|.
name|UDFToInteger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|udf
operator|.
name|UDFToLong
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|udf
operator|.
name|UDFToShort
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|udf
operator|.
name|UDFToString
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|udf
operator|.
name|generic
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|objectinspector
operator|.
name|ObjectInspector
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|objectinspector
operator|.
name|ObjectInspectorUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|objectinspector
operator|.
name|PrimitiveObjectInspector
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|typeinfo
operator|.
name|*
import|;
end_import

begin_comment
comment|/**  * Context class for vectorization execution.  * Main role is to map column names to column indices and serves as a  * factory class for building vectorized expressions out of descriptors.  *  */
end_comment

begin_class
specifier|public
class|class
name|VectorizationContext
block|{
specifier|private
specifier|static
specifier|final
name|Log
name|LOG
init|=
name|LogFactory
operator|.
name|getLog
argument_list|(
name|VectorizationContext
operator|.
name|class
operator|.
name|getName
argument_list|()
argument_list|)
decl_stmt|;
name|VectorExpressionDescriptor
name|vMap
decl_stmt|;
comment|//columnName to column position map
specifier|private
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|Integer
argument_list|>
name|columnMap
decl_stmt|;
specifier|private
specifier|final
name|int
name|firstOutputColumnIndex
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|Pattern
name|decimalTypePattern
init|=
name|Pattern
operator|.
name|compile
argument_list|(
literal|"decimal.*"
argument_list|)
decl_stmt|;
comment|//Map column number to type
specifier|private
specifier|final
name|OutputColumnManager
name|ocm
decl_stmt|;
specifier|private
name|String
name|fileKey
init|=
literal|null
decl_stmt|;
comment|// Set of UDF classes for type casting data types in row-mode.
specifier|private
specifier|static
name|Set
argument_list|<
name|Class
argument_list|<
name|?
argument_list|>
argument_list|>
name|castExpressionUdfs
init|=
operator|new
name|HashSet
argument_list|<
name|Class
argument_list|<
name|?
argument_list|>
argument_list|>
argument_list|()
decl_stmt|;
static|static
block|{
name|castExpressionUdfs
operator|.
name|add
argument_list|(
name|GenericUDFToDecimal
operator|.
name|class
argument_list|)
expr_stmt|;
name|castExpressionUdfs
operator|.
name|add
argument_list|(
name|GenericUDFToBinary
operator|.
name|class
argument_list|)
expr_stmt|;
name|castExpressionUdfs
operator|.
name|add
argument_list|(
name|GenericUDFToDate
operator|.
name|class
argument_list|)
expr_stmt|;
name|castExpressionUdfs
operator|.
name|add
argument_list|(
name|GenericUDFToUnixTimeStamp
operator|.
name|class
argument_list|)
expr_stmt|;
name|castExpressionUdfs
operator|.
name|add
argument_list|(
name|GenericUDFToUtcTimestamp
operator|.
name|class
argument_list|)
expr_stmt|;
name|castExpressionUdfs
operator|.
name|add
argument_list|(
name|GenericUDFToChar
operator|.
name|class
argument_list|)
expr_stmt|;
name|castExpressionUdfs
operator|.
name|add
argument_list|(
name|GenericUDFToVarchar
operator|.
name|class
argument_list|)
expr_stmt|;
name|castExpressionUdfs
operator|.
name|add
argument_list|(
name|GenericUDFTimestamp
operator|.
name|class
argument_list|)
expr_stmt|;
name|castExpressionUdfs
operator|.
name|add
argument_list|(
name|UDFToByte
operator|.
name|class
argument_list|)
expr_stmt|;
name|castExpressionUdfs
operator|.
name|add
argument_list|(
name|UDFToBoolean
operator|.
name|class
argument_list|)
expr_stmt|;
name|castExpressionUdfs
operator|.
name|add
argument_list|(
name|UDFToDouble
operator|.
name|class
argument_list|)
expr_stmt|;
name|castExpressionUdfs
operator|.
name|add
argument_list|(
name|UDFToFloat
operator|.
name|class
argument_list|)
expr_stmt|;
name|castExpressionUdfs
operator|.
name|add
argument_list|(
name|UDFToString
operator|.
name|class
argument_list|)
expr_stmt|;
name|castExpressionUdfs
operator|.
name|add
argument_list|(
name|UDFToInteger
operator|.
name|class
argument_list|)
expr_stmt|;
name|castExpressionUdfs
operator|.
name|add
argument_list|(
name|UDFToLong
operator|.
name|class
argument_list|)
expr_stmt|;
name|castExpressionUdfs
operator|.
name|add
argument_list|(
name|UDFToShort
operator|.
name|class
argument_list|)
expr_stmt|;
block|}
specifier|public
name|VectorizationContext
parameter_list|(
name|Map
argument_list|<
name|String
argument_list|,
name|Integer
argument_list|>
name|columnMap
parameter_list|,
name|int
name|initialOutputCol
parameter_list|)
block|{
name|this
operator|.
name|columnMap
operator|=
name|columnMap
expr_stmt|;
name|this
operator|.
name|ocm
operator|=
operator|new
name|OutputColumnManager
argument_list|(
name|initialOutputCol
argument_list|)
expr_stmt|;
name|this
operator|.
name|firstOutputColumnIndex
operator|=
name|initialOutputCol
expr_stmt|;
name|vMap
operator|=
operator|new
name|VectorExpressionDescriptor
argument_list|()
expr_stmt|;
block|}
specifier|public
name|String
name|getFileKey
parameter_list|()
block|{
return|return
name|fileKey
return|;
block|}
specifier|public
name|void
name|setFileKey
parameter_list|(
name|String
name|fileKey
parameter_list|)
block|{
name|this
operator|.
name|fileKey
operator|=
name|fileKey
expr_stmt|;
block|}
specifier|protected
name|int
name|getInputColumnIndex
parameter_list|(
name|String
name|name
parameter_list|)
block|{
if|if
condition|(
operator|!
name|columnMap
operator|.
name|containsKey
argument_list|(
name|name
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|error
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"The column %s is not in the vectorization context column map."
argument_list|,
name|name
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|columnMap
operator|.
name|get
argument_list|(
name|name
argument_list|)
return|;
block|}
specifier|protected
name|int
name|getInputColumnIndex
parameter_list|(
name|ExprNodeColumnDesc
name|colExpr
parameter_list|)
block|{
return|return
name|columnMap
operator|.
name|get
argument_list|(
name|colExpr
operator|.
name|getColumn
argument_list|()
argument_list|)
return|;
block|}
specifier|private
class|class
name|OutputColumnManager
block|{
specifier|private
specifier|final
name|int
name|initialOutputCol
decl_stmt|;
specifier|private
name|int
name|outputColCount
init|=
literal|0
decl_stmt|;
specifier|protected
name|OutputColumnManager
parameter_list|(
name|int
name|initialOutputCol
parameter_list|)
block|{
name|this
operator|.
name|initialOutputCol
operator|=
name|initialOutputCol
expr_stmt|;
block|}
comment|//The complete list of output columns. These should be added to the
comment|//Vectorized row batch for processing. The index in the row batch is
comment|//equal to the index in this array plus initialOutputCol.
comment|//Start with size 100 and double when needed.
specifier|private
name|String
index|[]
name|outputColumnsTypes
init|=
operator|new
name|String
index|[
literal|100
index|]
decl_stmt|;
specifier|private
specifier|final
name|Set
argument_list|<
name|Integer
argument_list|>
name|usedOutputColumns
init|=
operator|new
name|HashSet
argument_list|<
name|Integer
argument_list|>
argument_list|()
decl_stmt|;
name|int
name|allocateOutputColumn
parameter_list|(
name|String
name|columnType
parameter_list|)
block|{
if|if
condition|(
name|initialOutputCol
operator|<
literal|0
condition|)
block|{
comment|// This is a test
return|return
literal|0
return|;
block|}
name|int
name|relativeCol
init|=
name|allocateOutputColumnInternal
argument_list|(
name|columnType
argument_list|)
decl_stmt|;
return|return
name|initialOutputCol
operator|+
name|relativeCol
return|;
block|}
specifier|private
name|int
name|allocateOutputColumnInternal
parameter_list|(
name|String
name|columnType
parameter_list|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|outputColCount
condition|;
name|i
operator|++
control|)
block|{
comment|// Re-use an existing, available column of the same required type.
if|if
condition|(
name|usedOutputColumns
operator|.
name|contains
argument_list|(
name|i
argument_list|)
operator|||
operator|!
operator|(
name|outputColumnsTypes
operator|)
index|[
name|i
index|]
operator|.
name|equalsIgnoreCase
argument_list|(
name|columnType
argument_list|)
condition|)
block|{
continue|continue;
block|}
comment|//Use i
name|usedOutputColumns
operator|.
name|add
argument_list|(
name|i
argument_list|)
expr_stmt|;
return|return
name|i
return|;
block|}
comment|//Out of allocated columns
if|if
condition|(
name|outputColCount
operator|<
name|outputColumnsTypes
operator|.
name|length
condition|)
block|{
name|int
name|newIndex
init|=
name|outputColCount
decl_stmt|;
name|outputColumnsTypes
index|[
name|outputColCount
operator|++
index|]
operator|=
name|columnType
expr_stmt|;
name|usedOutputColumns
operator|.
name|add
argument_list|(
name|newIndex
argument_list|)
expr_stmt|;
return|return
name|newIndex
return|;
block|}
else|else
block|{
comment|//Expand the array
name|outputColumnsTypes
operator|=
name|Arrays
operator|.
name|copyOf
argument_list|(
name|outputColumnsTypes
argument_list|,
literal|2
operator|*
name|outputColCount
argument_list|)
expr_stmt|;
name|int
name|newIndex
init|=
name|outputColCount
decl_stmt|;
name|outputColumnsTypes
index|[
name|outputColCount
operator|++
index|]
operator|=
name|columnType
expr_stmt|;
name|usedOutputColumns
operator|.
name|add
argument_list|(
name|newIndex
argument_list|)
expr_stmt|;
return|return
name|newIndex
return|;
block|}
block|}
name|void
name|freeOutputColumn
parameter_list|(
name|int
name|index
parameter_list|)
block|{
if|if
condition|(
name|initialOutputCol
operator|<
literal|0
condition|)
block|{
comment|// This is a test
return|return;
block|}
name|int
name|colIndex
init|=
name|index
operator|-
name|initialOutputCol
decl_stmt|;
if|if
condition|(
name|colIndex
operator|>=
literal|0
condition|)
block|{
name|usedOutputColumns
operator|.
name|remove
argument_list|(
name|index
operator|-
name|initialOutputCol
argument_list|)
expr_stmt|;
block|}
block|}
block|}
specifier|private
name|VectorExpression
name|getColumnVectorExpression
parameter_list|(
name|ExprNodeColumnDesc
name|exprDesc
parameter_list|,
name|Mode
name|mode
parameter_list|)
block|{
name|int
name|columnNum
init|=
name|getInputColumnIndex
argument_list|(
name|exprDesc
operator|.
name|getColumn
argument_list|()
argument_list|)
decl_stmt|;
name|VectorExpression
name|expr
init|=
literal|null
decl_stmt|;
switch|switch
condition|(
name|mode
condition|)
block|{
case|case
name|FILTER
case|:
comment|//Important: It will come here only if the column is being used as a boolean
name|expr
operator|=
operator|new
name|SelectColumnIsTrue
argument_list|(
name|columnNum
argument_list|)
expr_stmt|;
break|break;
case|case
name|PROJECTION
case|:
name|expr
operator|=
operator|new
name|IdentityExpression
argument_list|(
name|columnNum
argument_list|,
name|exprDesc
operator|.
name|getTypeString
argument_list|()
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
name|expr
return|;
block|}
specifier|public
name|VectorExpression
index|[]
name|getVectorExpressions
parameter_list|(
name|List
argument_list|<
name|ExprNodeDesc
argument_list|>
name|exprNodes
parameter_list|)
throws|throws
name|HiveException
block|{
return|return
name|getVectorExpressions
argument_list|(
name|exprNodes
argument_list|,
name|Mode
operator|.
name|PROJECTION
argument_list|)
return|;
block|}
specifier|public
name|VectorExpression
index|[]
name|getVectorExpressions
parameter_list|(
name|List
argument_list|<
name|ExprNodeDesc
argument_list|>
name|exprNodes
parameter_list|,
name|Mode
name|mode
parameter_list|)
throws|throws
name|HiveException
block|{
name|int
name|i
init|=
literal|0
decl_stmt|;
if|if
condition|(
literal|null
operator|==
name|exprNodes
condition|)
block|{
return|return
operator|new
name|VectorExpression
index|[
literal|0
index|]
return|;
block|}
name|VectorExpression
index|[]
name|ret
init|=
operator|new
name|VectorExpression
index|[
name|exprNodes
operator|.
name|size
argument_list|()
index|]
decl_stmt|;
for|for
control|(
name|ExprNodeDesc
name|e
range|:
name|exprNodes
control|)
block|{
name|ret
index|[
name|i
operator|++
index|]
operator|=
name|getVectorExpression
argument_list|(
name|e
argument_list|,
name|mode
argument_list|)
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
specifier|public
name|VectorExpression
name|getVectorExpression
parameter_list|(
name|ExprNodeDesc
name|exprDesc
parameter_list|)
throws|throws
name|HiveException
block|{
return|return
name|getVectorExpression
argument_list|(
name|exprDesc
argument_list|,
name|Mode
operator|.
name|PROJECTION
argument_list|)
return|;
block|}
comment|/**    * Returns a vector expression for a given expression    * description.    * @param exprDesc, Expression description    * @param mode    * @return {@link VectorExpression}    * @throws HiveException    */
specifier|public
name|VectorExpression
name|getVectorExpression
parameter_list|(
name|ExprNodeDesc
name|exprDesc
parameter_list|,
name|Mode
name|mode
parameter_list|)
throws|throws
name|HiveException
block|{
name|VectorExpression
name|ve
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|exprDesc
operator|instanceof
name|ExprNodeColumnDesc
condition|)
block|{
name|ve
operator|=
name|getColumnVectorExpression
argument_list|(
operator|(
name|ExprNodeColumnDesc
operator|)
name|exprDesc
argument_list|,
name|mode
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|exprDesc
operator|instanceof
name|ExprNodeGenericFuncDesc
condition|)
block|{
name|ExprNodeGenericFuncDesc
name|expr
init|=
operator|(
name|ExprNodeGenericFuncDesc
operator|)
name|exprDesc
decl_stmt|;
if|if
condition|(
name|isCustomUDF
argument_list|(
name|expr
argument_list|)
operator|||
name|isNonVectorizedPathUDF
argument_list|(
name|expr
argument_list|)
condition|)
block|{
name|ve
operator|=
name|getCustomUDFExpression
argument_list|(
name|expr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// Add cast expression if needed. Child expressions of a udf may return different data types
comment|// and that would require converting their data types to evaluate the udf.
comment|// For example decimal column added to an integer column would require integer column to be
comment|// cast to decimal.
name|List
argument_list|<
name|ExprNodeDesc
argument_list|>
name|childExpressions
init|=
name|getChildExpressionsWithImplicitCast
argument_list|(
name|expr
operator|.
name|getGenericUDF
argument_list|()
argument_list|,
name|exprDesc
operator|.
name|getChildren
argument_list|()
argument_list|,
name|exprDesc
operator|.
name|getTypeInfo
argument_list|()
argument_list|)
decl_stmt|;
name|ve
operator|=
name|getGenericUdfVectorExpression
argument_list|(
name|expr
operator|.
name|getGenericUDF
argument_list|()
argument_list|,
name|childExpressions
argument_list|,
name|mode
argument_list|,
name|exprDesc
operator|.
name|getTypeInfo
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|exprDesc
operator|instanceof
name|ExprNodeConstantDesc
condition|)
block|{
name|ve
operator|=
name|getConstantVectorExpression
argument_list|(
operator|(
operator|(
name|ExprNodeConstantDesc
operator|)
name|exprDesc
operator|)
operator|.
name|getValue
argument_list|()
argument_list|,
name|exprDesc
operator|.
name|getTypeInfo
argument_list|()
argument_list|,
name|mode
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ve
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|HiveException
argument_list|(
literal|"Could not vectorize expression: "
operator|+
name|exprDesc
operator|.
name|getName
argument_list|()
argument_list|)
throw|;
block|}
return|return
name|ve
return|;
block|}
specifier|private
name|TypeInfo
name|getCommonTypeForChildExpressions
parameter_list|(
name|GenericUDF
name|genericUdf
parameter_list|,
name|List
argument_list|<
name|ExprNodeDesc
argument_list|>
name|children
parameter_list|,
name|TypeInfo
name|returnType
parameter_list|)
block|{
name|TypeInfo
name|commonType
decl_stmt|;
if|if
condition|(
name|genericUdf
operator|instanceof
name|GenericUDFBaseCompare
condition|)
block|{
comment|// Apply comparison rules
name|TypeInfo
name|tLeft
init|=
name|children
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|getTypeInfo
argument_list|()
decl_stmt|;
name|TypeInfo
name|tRight
init|=
name|children
operator|.
name|get
argument_list|(
literal|1
argument_list|)
operator|.
name|getTypeInfo
argument_list|()
decl_stmt|;
name|commonType
operator|=
name|FunctionRegistry
operator|.
name|getCommonClassForComparison
argument_list|(
name|tLeft
argument_list|,
name|tRight
argument_list|)
expr_stmt|;
if|if
condition|(
name|commonType
operator|==
literal|null
condition|)
block|{
name|commonType
operator|=
name|returnType
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// The children type should be converted to return type
name|commonType
operator|=
name|returnType
expr_stmt|;
block|}
return|return
name|commonType
return|;
block|}
comment|/**    * Add a cast expression to the expression tree if needed. The output of child expressions of a given UDF might    * need a cast if their return type is different from the return type of the UDF.    *    * @param genericUDF The given UDF    * @param children Child expressions of the UDF that might require a cast.    * @param returnType The return type of the UDF.    * @return List of child expressions added with cast.    */
specifier|private
name|List
argument_list|<
name|ExprNodeDesc
argument_list|>
name|getChildExpressionsWithImplicitCast
parameter_list|(
name|GenericUDF
name|genericUDF
parameter_list|,
name|List
argument_list|<
name|ExprNodeDesc
argument_list|>
name|children
parameter_list|,
name|TypeInfo
name|returnType
parameter_list|)
block|{
if|if
condition|(
name|isCastExpression
argument_list|(
name|genericUDF
argument_list|)
condition|)
block|{
comment|// No implicit cast needed
return|return
name|children
return|;
block|}
if|if
condition|(
name|children
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
name|TypeInfo
name|commonType
init|=
name|getCommonTypeForChildExpressions
argument_list|(
name|genericUDF
argument_list|,
name|children
argument_list|,
name|returnType
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|ExprNodeDesc
argument_list|>
name|childrenWithCasts
init|=
operator|new
name|ArrayList
argument_list|<
name|ExprNodeDesc
argument_list|>
argument_list|()
decl_stmt|;
name|boolean
name|atleastOneCastNeeded
init|=
literal|false
decl_stmt|;
for|for
control|(
name|ExprNodeDesc
name|child
range|:
name|children
control|)
block|{
name|ExprNodeDesc
name|castExpression
init|=
name|getImplicitCastExpression
argument_list|(
name|genericUDF
argument_list|,
name|child
argument_list|,
name|commonType
argument_list|)
decl_stmt|;
if|if
condition|(
name|castExpression
operator|!=
literal|null
condition|)
block|{
name|atleastOneCastNeeded
operator|=
literal|true
expr_stmt|;
name|childrenWithCasts
operator|.
name|add
argument_list|(
name|castExpression
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|childrenWithCasts
operator|.
name|add
argument_list|(
name|child
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|atleastOneCastNeeded
condition|)
block|{
return|return
name|childrenWithCasts
return|;
block|}
else|else
block|{
return|return
name|children
return|;
block|}
block|}
specifier|private
name|boolean
name|isCastExpression
parameter_list|(
name|GenericUDF
name|genericUDF
parameter_list|)
block|{
name|boolean
name|ret
init|=
name|castExpressionUdfs
operator|.
name|contains
argument_list|(
name|genericUDF
operator|.
name|getClass
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
return|return
name|ret
return|;
block|}
elseif|else
if|if
condition|(
name|genericUDF
operator|instanceof
name|GenericUDFBridge
condition|)
block|{
return|return
name|castExpressionUdfs
operator|.
name|contains
argument_list|(
operator|(
operator|(
name|GenericUDFBridge
operator|)
name|genericUDF
operator|)
operator|.
name|getUdfClass
argument_list|()
argument_list|)
return|;
block|}
return|return
literal|false
return|;
block|}
comment|/**    * Creates a DecimalTypeInfo object with appropriate precision and scale for the given    * inputTypeInfo.    */
specifier|private
name|TypeInfo
name|updatePrecision
parameter_list|(
name|TypeInfo
name|inputTypeInfo
parameter_list|,
name|DecimalTypeInfo
name|returnType
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|inputTypeInfo
operator|instanceof
name|PrimitiveTypeInfo
operator|)
condition|)
block|{
return|return
name|returnType
return|;
block|}
name|PrimitiveTypeInfo
name|ptinfo
init|=
operator|(
name|PrimitiveTypeInfo
operator|)
name|inputTypeInfo
decl_stmt|;
name|int
name|precision
init|=
name|HiveDecimalUtils
operator|.
name|getPrecisionForType
argument_list|(
name|ptinfo
argument_list|)
decl_stmt|;
name|int
name|scale
init|=
name|HiveDecimalUtils
operator|.
name|getScaleForType
argument_list|(
name|ptinfo
argument_list|)
decl_stmt|;
return|return
operator|new
name|DecimalTypeInfo
argument_list|(
name|precision
argument_list|,
name|scale
argument_list|)
return|;
block|}
comment|/**    * The GenericUDFs might need their children output to be cast to the given castType.    * This method returns a cast expression that would achieve the required casting.    */
specifier|private
name|ExprNodeDesc
name|getImplicitCastExpression
parameter_list|(
name|GenericUDF
name|udf
parameter_list|,
name|ExprNodeDesc
name|child
parameter_list|,
name|TypeInfo
name|castType
parameter_list|)
block|{
name|TypeInfo
name|inputTypeInfo
init|=
name|child
operator|.
name|getTypeInfo
argument_list|()
decl_stmt|;
name|String
name|inputTypeString
init|=
name|inputTypeInfo
operator|.
name|getTypeName
argument_list|()
decl_stmt|;
name|String
name|castTypeString
init|=
name|castType
operator|.
name|getTypeName
argument_list|()
decl_stmt|;
if|if
condition|(
name|inputTypeString
operator|.
name|equals
argument_list|(
name|castTypeString
argument_list|)
condition|)
block|{
comment|// Nothing to be done
return|return
literal|null
return|;
block|}
name|boolean
name|inputTypeDecimal
init|=
literal|false
decl_stmt|;
name|boolean
name|castTypeDecimal
init|=
literal|false
decl_stmt|;
if|if
condition|(
name|decimalTypePattern
operator|.
name|matcher
argument_list|(
name|inputTypeString
argument_list|)
operator|.
name|matches
argument_list|()
condition|)
block|{
name|inputTypeDecimal
operator|=
literal|true
expr_stmt|;
block|}
if|if
condition|(
name|decimalTypePattern
operator|.
name|matcher
argument_list|(
name|castTypeString
argument_list|)
operator|.
name|matches
argument_list|()
condition|)
block|{
name|castTypeDecimal
operator|=
literal|true
expr_stmt|;
block|}
if|if
condition|(
name|castTypeDecimal
operator|&&
operator|!
name|inputTypeDecimal
condition|)
block|{
comment|// Cast the input to decimal
comment|// If castType is decimal, try not to lose precision for numeric types.
name|castType
operator|=
name|updatePrecision
argument_list|(
name|inputTypeInfo
argument_list|,
operator|(
name|DecimalTypeInfo
operator|)
name|castType
argument_list|)
expr_stmt|;
name|GenericUDFToDecimal
name|castToDecimalUDF
init|=
operator|new
name|GenericUDFToDecimal
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|ExprNodeDesc
argument_list|>
name|children
init|=
operator|new
name|ArrayList
argument_list|<
name|ExprNodeDesc
argument_list|>
argument_list|()
decl_stmt|;
name|children
operator|.
name|add
argument_list|(
name|child
argument_list|)
expr_stmt|;
name|ExprNodeDesc
name|desc
init|=
operator|new
name|ExprNodeGenericFuncDesc
argument_list|(
name|castType
argument_list|,
name|castToDecimalUDF
argument_list|,
name|children
argument_list|)
decl_stmt|;
return|return
name|desc
return|;
block|}
elseif|else
if|if
condition|(
operator|!
name|castTypeDecimal
operator|&&
name|inputTypeDecimal
condition|)
block|{
comment|// Cast decimal input to returnType
name|GenericUDF
name|genericUdf
init|=
name|getGenericUDFForCast
argument_list|(
name|castType
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|ExprNodeDesc
argument_list|>
name|children
init|=
operator|new
name|ArrayList
argument_list|<
name|ExprNodeDesc
argument_list|>
argument_list|()
decl_stmt|;
name|children
operator|.
name|add
argument_list|(
name|child
argument_list|)
expr_stmt|;
name|ExprNodeDesc
name|desc
init|=
operator|new
name|ExprNodeGenericFuncDesc
argument_list|(
name|castType
argument_list|,
name|genericUdf
argument_list|,
name|children
argument_list|)
decl_stmt|;
return|return
name|desc
return|;
block|}
else|else
block|{
comment|// Casts to exact types including long to double etc. are needed in some special cases.
if|if
condition|(
name|udf
operator|instanceof
name|GenericUDFCoalesce
condition|)
block|{
name|GenericUDF
name|genericUdf
init|=
name|getGenericUDFForCast
argument_list|(
name|castType
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|ExprNodeDesc
argument_list|>
name|children
init|=
operator|new
name|ArrayList
argument_list|<
name|ExprNodeDesc
argument_list|>
argument_list|()
decl_stmt|;
name|children
operator|.
name|add
argument_list|(
name|child
argument_list|)
expr_stmt|;
name|ExprNodeDesc
name|desc
init|=
operator|new
name|ExprNodeGenericFuncDesc
argument_list|(
name|castType
argument_list|,
name|genericUdf
argument_list|,
name|children
argument_list|)
decl_stmt|;
return|return
name|desc
return|;
block|}
block|}
return|return
literal|null
return|;
block|}
specifier|private
name|GenericUDF
name|getGenericUDFForCast
parameter_list|(
name|TypeInfo
name|castType
parameter_list|)
block|{
name|UDF
name|udfClass
init|=
literal|null
decl_stmt|;
name|GenericUDF
name|genericUdf
init|=
literal|null
decl_stmt|;
switch|switch
condition|(
operator|(
operator|(
name|PrimitiveTypeInfo
operator|)
name|castType
operator|)
operator|.
name|getPrimitiveCategory
argument_list|()
condition|)
block|{
case|case
name|BYTE
case|:
name|udfClass
operator|=
operator|new
name|UDFToByte
argument_list|()
expr_stmt|;
break|break;
case|case
name|SHORT
case|:
name|udfClass
operator|=
operator|new
name|UDFToShort
argument_list|()
expr_stmt|;
break|break;
case|case
name|INT
case|:
name|udfClass
operator|=
operator|new
name|UDFToInteger
argument_list|()
expr_stmt|;
break|break;
case|case
name|LONG
case|:
name|udfClass
operator|=
operator|new
name|UDFToLong
argument_list|()
expr_stmt|;
break|break;
case|case
name|FLOAT
case|:
name|udfClass
operator|=
operator|new
name|UDFToFloat
argument_list|()
expr_stmt|;
break|break;
case|case
name|DOUBLE
case|:
name|udfClass
operator|=
operator|new
name|UDFToDouble
argument_list|()
expr_stmt|;
break|break;
case|case
name|STRING
case|:
name|udfClass
operator|=
operator|new
name|UDFToString
argument_list|()
expr_stmt|;
break|break;
case|case
name|BOOLEAN
case|:
name|udfClass
operator|=
operator|new
name|UDFToBoolean
argument_list|()
expr_stmt|;
break|break;
case|case
name|DATE
case|:
name|genericUdf
operator|=
operator|new
name|GenericUDFToDate
argument_list|()
expr_stmt|;
break|break;
case|case
name|TIMESTAMP
case|:
name|genericUdf
operator|=
operator|new
name|GenericUDFToUnixTimeStamp
argument_list|()
expr_stmt|;
break|break;
case|case
name|BINARY
case|:
name|genericUdf
operator|=
operator|new
name|GenericUDFToBinary
argument_list|()
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|genericUdf
operator|==
literal|null
condition|)
block|{
name|genericUdf
operator|=
operator|new
name|GenericUDFBridge
argument_list|()
expr_stmt|;
operator|(
operator|(
name|GenericUDFBridge
operator|)
name|genericUdf
operator|)
operator|.
name|setUdfClassName
argument_list|(
name|udfClass
operator|.
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|genericUdf
return|;
block|}
comment|/* Return true if this is one of a small set of functions for which    * it is significantly easier to use the old code path in vectorized    * mode instead of implementing a new, optimized VectorExpression.    *    * Depending on performance requirements and frequency of use, these    * may be implemented in the future with an optimized VectorExpression.    */
specifier|public
specifier|static
name|boolean
name|isNonVectorizedPathUDF
parameter_list|(
name|ExprNodeGenericFuncDesc
name|expr
parameter_list|)
block|{
name|GenericUDF
name|gudf
init|=
name|expr
operator|.
name|getGenericUDF
argument_list|()
decl_stmt|;
if|if
condition|(
name|gudf
operator|instanceof
name|GenericUDFBridge
condition|)
block|{
name|GenericUDFBridge
name|bridge
init|=
operator|(
name|GenericUDFBridge
operator|)
name|gudf
decl_stmt|;
name|Class
argument_list|<
name|?
extends|extends
name|UDF
argument_list|>
name|udfClass
init|=
name|bridge
operator|.
name|getUdfClass
argument_list|()
decl_stmt|;
if|if
condition|(
name|udfClass
operator|.
name|equals
argument_list|(
name|UDFHex
operator|.
name|class
argument_list|)
operator|||
name|udfClass
operator|.
name|equals
argument_list|(
name|UDFConv
operator|.
name|class
argument_list|)
operator|||
name|isCastToIntFamily
argument_list|(
name|udfClass
argument_list|)
operator|&&
name|arg0Type
argument_list|(
name|expr
argument_list|)
operator|.
name|equals
argument_list|(
literal|"string"
argument_list|)
operator|||
name|isCastToFloatFamily
argument_list|(
name|udfClass
argument_list|)
operator|&&
name|arg0Type
argument_list|(
name|expr
argument_list|)
operator|.
name|equals
argument_list|(
literal|"string"
argument_list|)
operator|||
name|udfClass
operator|.
name|equals
argument_list|(
name|UDFToString
operator|.
name|class
argument_list|)
operator|&&
operator|(
name|arg0Type
argument_list|(
name|expr
argument_list|)
operator|.
name|equals
argument_list|(
literal|"timestamp"
argument_list|)
operator|||
name|arg0Type
argument_list|(
name|expr
argument_list|)
operator|.
name|equals
argument_list|(
literal|"double"
argument_list|)
operator|||
name|arg0Type
argument_list|(
name|expr
argument_list|)
operator|.
name|equals
argument_list|(
literal|"float"
argument_list|)
operator|)
condition|)
block|{
return|return
literal|true
return|;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|gudf
operator|instanceof
name|GenericUDFTimestamp
operator|&&
name|arg0Type
argument_list|(
name|expr
argument_list|)
operator|.
name|equals
argument_list|(
literal|"string"
argument_list|)
operator|)
comment|/* GenericUDFCase and GenericUDFWhen are implemented with the UDF Adaptor because              * of their complexity and generality. In the future, variations of these              * can be optimized to run faster for the vectorized code path. For example,              * CASE col WHEN 1 then "one" WHEN 2 THEN "two" ELSE "other" END              * is an example of a GenericUDFCase that has all constant arguments              * except for the first argument. This is probably a common case and a              * good candidate for a fast, special-purpose VectorExpression. Then              * the UDF Adaptor code path could be used as a catch-all for              * non-optimized general cases.              */
operator|||
name|gudf
operator|instanceof
name|GenericUDFCase
operator|||
name|gudf
operator|instanceof
name|GenericUDFWhen
condition|)
block|{
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
specifier|public
specifier|static
name|boolean
name|isCastToIntFamily
parameter_list|(
name|Class
argument_list|<
name|?
extends|extends
name|UDF
argument_list|>
name|udfClass
parameter_list|)
block|{
return|return
name|udfClass
operator|.
name|equals
argument_list|(
name|UDFToByte
operator|.
name|class
argument_list|)
operator|||
name|udfClass
operator|.
name|equals
argument_list|(
name|UDFToShort
operator|.
name|class
argument_list|)
operator|||
name|udfClass
operator|.
name|equals
argument_list|(
name|UDFToInteger
operator|.
name|class
argument_list|)
operator|||
name|udfClass
operator|.
name|equals
argument_list|(
name|UDFToLong
operator|.
name|class
argument_list|)
return|;
comment|// Boolean is purposely excluded.
block|}
specifier|public
specifier|static
name|boolean
name|isCastToFloatFamily
parameter_list|(
name|Class
argument_list|<
name|?
extends|extends
name|UDF
argument_list|>
name|udfClass
parameter_list|)
block|{
return|return
name|udfClass
operator|.
name|equals
argument_list|(
name|UDFToDouble
operator|.
name|class
argument_list|)
operator|||
name|udfClass
operator|.
name|equals
argument_list|(
name|UDFToFloat
operator|.
name|class
argument_list|)
return|;
block|}
comment|// Return the type string of the first argument (argument 0).
specifier|public
specifier|static
name|String
name|arg0Type
parameter_list|(
name|ExprNodeGenericFuncDesc
name|expr
parameter_list|)
block|{
name|String
name|type
init|=
name|expr
operator|.
name|getChildren
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|getTypeString
argument_list|()
decl_stmt|;
return|return
name|type
return|;
block|}
comment|// Return true if this is a custom UDF or custom GenericUDF.
comment|// This is for use only in the planner. It will fail in a task.
specifier|public
specifier|static
name|boolean
name|isCustomUDF
parameter_list|(
name|ExprNodeGenericFuncDesc
name|expr
parameter_list|)
block|{
name|String
name|udfName
init|=
name|expr
operator|.
name|getFuncText
argument_list|()
decl_stmt|;
if|if
condition|(
name|udfName
operator|==
literal|null
condition|)
block|{
return|return
literal|false
return|;
block|}
name|FunctionInfo
name|funcInfo
init|=
name|FunctionRegistry
operator|.
name|getFunctionInfo
argument_list|(
name|udfName
argument_list|)
decl_stmt|;
if|if
condition|(
name|funcInfo
operator|==
literal|null
condition|)
block|{
return|return
literal|false
return|;
block|}
name|boolean
name|isNativeFunc
init|=
name|funcInfo
operator|.
name|isNative
argument_list|()
decl_stmt|;
return|return
operator|!
name|isNativeFunc
return|;
block|}
comment|/**    * Handles only the special case of unary operators on a constant.    * @param exprDesc    * @return The same expression if no folding done, else return the constant    *         expression.    * @throws HiveException    */
specifier|private
name|ExprNodeDesc
name|foldConstantsForUnaryExpression
parameter_list|(
name|ExprNodeDesc
name|exprDesc
parameter_list|)
throws|throws
name|HiveException
block|{
if|if
condition|(
operator|!
operator|(
name|exprDesc
operator|instanceof
name|ExprNodeGenericFuncDesc
operator|)
condition|)
block|{
return|return
name|exprDesc
return|;
block|}
if|if
condition|(
name|exprDesc
operator|.
name|getChildren
argument_list|()
operator|==
literal|null
operator|||
operator|(
name|exprDesc
operator|.
name|getChildren
argument_list|()
operator|.
name|size
argument_list|()
operator|!=
literal|1
operator|)
operator|||
operator|(
operator|!
operator|(
name|exprDesc
operator|.
name|getChildren
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|instanceof
name|ExprNodeConstantDesc
operator|)
operator|)
condition|)
block|{
return|return
name|exprDesc
return|;
block|}
name|GenericUDF
name|gudf
init|=
operator|(
operator|(
name|ExprNodeGenericFuncDesc
operator|)
name|exprDesc
operator|)
operator|.
name|getGenericUDF
argument_list|()
decl_stmt|;
if|if
condition|(
name|gudf
operator|instanceof
name|GenericUDFOPNegative
operator|||
name|gudf
operator|instanceof
name|GenericUDFOPPositive
operator|||
name|castExpressionUdfs
operator|.
name|contains
argument_list|(
name|gudf
argument_list|)
operator|||
operator|(
operator|(
name|gudf
operator|instanceof
name|GenericUDFBridge
operator|)
operator|&&
name|castExpressionUdfs
operator|.
name|contains
argument_list|(
operator|(
operator|(
name|GenericUDFBridge
operator|)
name|gudf
operator|)
operator|.
name|getUdfClass
argument_list|()
argument_list|)
operator|)
condition|)
block|{
name|ExprNodeEvaluator
argument_list|<
name|?
argument_list|>
name|evaluator
init|=
name|ExprNodeEvaluatorFactory
operator|.
name|get
argument_list|(
name|exprDesc
argument_list|)
decl_stmt|;
name|ObjectInspector
name|output
init|=
name|evaluator
operator|.
name|initialize
argument_list|(
literal|null
argument_list|)
decl_stmt|;
name|Object
name|constant
init|=
name|evaluator
operator|.
name|evaluate
argument_list|(
literal|null
argument_list|)
decl_stmt|;
name|Object
name|java
init|=
name|ObjectInspectorUtils
operator|.
name|copyToStandardJavaObject
argument_list|(
name|constant
argument_list|,
name|output
argument_list|)
decl_stmt|;
return|return
operator|new
name|ExprNodeConstantDesc
argument_list|(
name|java
argument_list|)
return|;
block|}
return|return
name|exprDesc
return|;
block|}
comment|/* Fold simple unary expressions in all members of the input list and return new list    * containing results.    */
specifier|private
name|List
argument_list|<
name|ExprNodeDesc
argument_list|>
name|foldConstantsForUnaryExprs
parameter_list|(
name|List
argument_list|<
name|ExprNodeDesc
argument_list|>
name|childExpr
parameter_list|)
throws|throws
name|HiveException
block|{
name|List
argument_list|<
name|ExprNodeDesc
argument_list|>
name|constantFoldedChildren
init|=
operator|new
name|ArrayList
argument_list|<
name|ExprNodeDesc
argument_list|>
argument_list|()
decl_stmt|;
if|if
condition|(
name|childExpr
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|ExprNodeDesc
name|expr
range|:
name|childExpr
control|)
block|{
name|expr
operator|=
name|this
operator|.
name|foldConstantsForUnaryExpression
argument_list|(
name|expr
argument_list|)
expr_stmt|;
name|constantFoldedChildren
operator|.
name|add
argument_list|(
name|expr
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|constantFoldedChildren
return|;
block|}
specifier|private
name|VectorExpression
name|getConstantVectorExpression
parameter_list|(
name|Object
name|constantValue
parameter_list|,
name|TypeInfo
name|typeInfo
parameter_list|,
name|Mode
name|mode
parameter_list|)
throws|throws
name|HiveException
block|{
name|String
name|type
init|=
name|typeInfo
operator|.
name|getTypeName
argument_list|()
decl_stmt|;
name|String
name|colVectorType
init|=
name|getNormalizedTypeName
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|int
name|outCol
init|=
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|mode
operator|==
name|Mode
operator|.
name|PROJECTION
condition|)
block|{
name|outCol
operator|=
name|ocm
operator|.
name|allocateOutputColumn
argument_list|(
name|colVectorType
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|decimalTypePattern
operator|.
name|matcher
argument_list|(
name|type
argument_list|)
operator|.
name|matches
argument_list|()
condition|)
block|{
name|VectorExpression
name|ve
init|=
operator|new
name|ConstantVectorExpression
argument_list|(
name|outCol
argument_list|,
operator|(
name|Decimal128
operator|)
name|constantValue
argument_list|)
decl_stmt|;
name|ve
operator|.
name|setOutputType
argument_list|(
name|typeInfo
operator|.
name|getTypeName
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|ve
return|;
block|}
elseif|else
if|if
condition|(
name|type
operator|.
name|equalsIgnoreCase
argument_list|(
literal|"long"
argument_list|)
operator|||
name|type
operator|.
name|equalsIgnoreCase
argument_list|(
literal|"int"
argument_list|)
operator|||
name|type
operator|.
name|equalsIgnoreCase
argument_list|(
literal|"short"
argument_list|)
operator|||
name|type
operator|.
name|equalsIgnoreCase
argument_list|(
literal|"byte"
argument_list|)
condition|)
block|{
return|return
operator|new
name|ConstantVectorExpression
argument_list|(
name|outCol
argument_list|,
operator|(
operator|(
name|Number
operator|)
name|constantValue
operator|)
operator|.
name|longValue
argument_list|()
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|type
operator|.
name|equalsIgnoreCase
argument_list|(
literal|"double"
argument_list|)
operator|||
name|type
operator|.
name|equalsIgnoreCase
argument_list|(
literal|"float"
argument_list|)
condition|)
block|{
return|return
operator|new
name|ConstantVectorExpression
argument_list|(
name|outCol
argument_list|,
operator|(
operator|(
name|Number
operator|)
name|constantValue
operator|)
operator|.
name|doubleValue
argument_list|()
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|type
operator|.
name|equalsIgnoreCase
argument_list|(
literal|"string"
argument_list|)
condition|)
block|{
return|return
operator|new
name|ConstantVectorExpression
argument_list|(
name|outCol
argument_list|,
operator|(
operator|(
name|String
operator|)
name|constantValue
operator|)
operator|.
name|getBytes
argument_list|()
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|type
operator|.
name|equalsIgnoreCase
argument_list|(
literal|"boolean"
argument_list|)
condition|)
block|{
if|if
condition|(
name|mode
operator|==
name|Mode
operator|.
name|FILTER
condition|)
block|{
if|if
condition|(
operator|(
operator|(
name|Boolean
operator|)
name|constantValue
operator|)
operator|.
name|booleanValue
argument_list|()
condition|)
block|{
return|return
operator|new
name|FilterConstantBooleanVectorExpression
argument_list|(
literal|1
argument_list|)
return|;
block|}
else|else
block|{
return|return
operator|new
name|FilterConstantBooleanVectorExpression
argument_list|(
literal|0
argument_list|)
return|;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|(
operator|(
name|Boolean
operator|)
name|constantValue
operator|)
operator|.
name|booleanValue
argument_list|()
condition|)
block|{
return|return
operator|new
name|ConstantVectorExpression
argument_list|(
name|outCol
argument_list|,
literal|1
argument_list|)
return|;
block|}
else|else
block|{
return|return
operator|new
name|ConstantVectorExpression
argument_list|(
name|outCol
argument_list|,
literal|0
argument_list|)
return|;
block|}
block|}
block|}
throw|throw
operator|new
name|HiveException
argument_list|(
literal|"Unsupported constant type: "
operator|+
name|type
operator|.
name|toString
argument_list|()
argument_list|)
throw|;
block|}
comment|/**    * Used as a fast path for operations that don't modify their input, like unary +    * and casting boolean to long. IdentityExpression and its children are always    * projections.    */
specifier|private
name|VectorExpression
name|getIdentityExpression
parameter_list|(
name|List
argument_list|<
name|ExprNodeDesc
argument_list|>
name|childExprList
parameter_list|)
throws|throws
name|HiveException
block|{
name|ExprNodeDesc
name|childExpr
init|=
name|childExprList
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|int
name|inputCol
decl_stmt|;
name|String
name|colType
decl_stmt|;
name|VectorExpression
name|v1
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|childExpr
operator|instanceof
name|ExprNodeGenericFuncDesc
condition|)
block|{
name|v1
operator|=
name|getVectorExpression
argument_list|(
name|childExpr
argument_list|)
expr_stmt|;
name|inputCol
operator|=
name|v1
operator|.
name|getOutputColumn
argument_list|()
expr_stmt|;
name|colType
operator|=
name|v1
operator|.
name|getOutputType
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|childExpr
operator|instanceof
name|ExprNodeColumnDesc
condition|)
block|{
name|ExprNodeColumnDesc
name|colDesc
init|=
operator|(
name|ExprNodeColumnDesc
operator|)
name|childExpr
decl_stmt|;
name|inputCol
operator|=
name|getInputColumnIndex
argument_list|(
name|colDesc
operator|.
name|getColumn
argument_list|()
argument_list|)
expr_stmt|;
name|colType
operator|=
name|colDesc
operator|.
name|getTypeString
argument_list|()
expr_stmt|;
block|}
else|else
block|{
throw|throw
operator|new
name|HiveException
argument_list|(
literal|"Expression not supported: "
operator|+
name|childExpr
argument_list|)
throw|;
block|}
name|VectorExpression
name|expr
init|=
operator|new
name|IdentityExpression
argument_list|(
name|inputCol
argument_list|,
name|colType
argument_list|)
decl_stmt|;
if|if
condition|(
name|v1
operator|!=
literal|null
condition|)
block|{
name|expr
operator|.
name|setChildExpressions
argument_list|(
operator|new
name|VectorExpression
index|[]
block|{
name|v1
block|}
argument_list|)
expr_stmt|;
block|}
return|return
name|expr
return|;
block|}
specifier|private
name|VectorExpression
name|getVectorExpressionForUdf
parameter_list|(
name|Class
argument_list|<
name|?
argument_list|>
name|udf
parameter_list|,
name|List
argument_list|<
name|ExprNodeDesc
argument_list|>
name|childExpr
parameter_list|,
name|Mode
name|mode
parameter_list|,
name|TypeInfo
name|returnType
parameter_list|)
throws|throws
name|HiveException
block|{
name|int
name|numChildren
init|=
operator|(
name|childExpr
operator|==
literal|null
operator|)
condition|?
literal|0
else|:
name|childExpr
operator|.
name|size
argument_list|()
decl_stmt|;
if|if
condition|(
name|numChildren
operator|>
name|VectorExpressionDescriptor
operator|.
name|MAX_NUM_ARGUMENTS
condition|)
block|{
return|return
literal|null
return|;
block|}
name|VectorExpressionDescriptor
operator|.
name|Builder
name|builder
init|=
operator|new
name|VectorExpressionDescriptor
operator|.
name|Builder
argument_list|()
decl_stmt|;
name|builder
operator|.
name|setNumArguments
argument_list|(
name|numChildren
argument_list|)
expr_stmt|;
name|builder
operator|.
name|setMode
argument_list|(
name|mode
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numChildren
condition|;
name|i
operator|++
control|)
block|{
name|ExprNodeDesc
name|child
init|=
name|childExpr
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|builder
operator|.
name|setArgumentType
argument_list|(
name|i
argument_list|,
name|child
operator|.
name|getTypeString
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|child
operator|instanceof
name|ExprNodeGenericFuncDesc
operator|)
operator|||
operator|(
name|child
operator|instanceof
name|ExprNodeColumnDesc
operator|)
condition|)
block|{
name|builder
operator|.
name|setInputExpressionType
argument_list|(
name|i
argument_list|,
name|InputExpressionType
operator|.
name|COLUMN
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|child
operator|instanceof
name|ExprNodeConstantDesc
condition|)
block|{
name|builder
operator|.
name|setInputExpressionType
argument_list|(
name|i
argument_list|,
name|InputExpressionType
operator|.
name|SCALAR
argument_list|)
expr_stmt|;
block|}
else|else
block|{
throw|throw
operator|new
name|HiveException
argument_list|(
literal|"Cannot handle expression type: "
operator|+
name|child
operator|.
name|getClass
argument_list|()
operator|.
name|getSimpleName
argument_list|()
argument_list|)
throw|;
block|}
block|}
name|Class
argument_list|<
name|?
argument_list|>
name|vclass
init|=
name|this
operator|.
name|vMap
operator|.
name|getVectorExpressionClass
argument_list|(
name|udf
argument_list|,
name|builder
operator|.
name|build
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|vclass
operator|==
literal|null
condition|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"No vector udf found for "
operator|+
name|udf
operator|.
name|getSimpleName
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
literal|null
return|;
block|}
name|Mode
name|childrenMode
init|=
name|getChildrenMode
argument_list|(
name|mode
argument_list|,
name|udf
argument_list|)
decl_stmt|;
return|return
name|createVectorExpression
argument_list|(
name|vclass
argument_list|,
name|childExpr
argument_list|,
name|childrenMode
argument_list|,
name|returnType
argument_list|)
return|;
block|}
specifier|private
name|VectorExpression
name|createVectorExpression
parameter_list|(
name|Class
argument_list|<
name|?
argument_list|>
name|vectorClass
parameter_list|,
name|List
argument_list|<
name|ExprNodeDesc
argument_list|>
name|childExpr
parameter_list|,
name|Mode
name|childrenMode
parameter_list|,
name|TypeInfo
name|returnType
parameter_list|)
throws|throws
name|HiveException
block|{
name|int
name|numChildren
init|=
name|childExpr
operator|==
literal|null
condition|?
literal|0
else|:
name|childExpr
operator|.
name|size
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|VectorExpression
argument_list|>
name|children
init|=
operator|new
name|ArrayList
argument_list|<
name|VectorExpression
argument_list|>
argument_list|()
decl_stmt|;
name|Object
index|[]
name|arguments
init|=
operator|new
name|Object
index|[
name|numChildren
index|]
decl_stmt|;
try|try
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numChildren
condition|;
name|i
operator|++
control|)
block|{
name|ExprNodeDesc
name|child
init|=
name|childExpr
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|child
operator|instanceof
name|ExprNodeGenericFuncDesc
condition|)
block|{
name|VectorExpression
name|vChild
init|=
name|getVectorExpression
argument_list|(
name|child
argument_list|,
name|childrenMode
argument_list|)
decl_stmt|;
name|children
operator|.
name|add
argument_list|(
name|vChild
argument_list|)
expr_stmt|;
name|arguments
index|[
name|i
index|]
operator|=
name|vChild
operator|.
name|getOutputColumn
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|child
operator|instanceof
name|ExprNodeColumnDesc
condition|)
block|{
name|int
name|colIndex
init|=
name|getInputColumnIndex
argument_list|(
operator|(
name|ExprNodeColumnDesc
operator|)
name|child
argument_list|)
decl_stmt|;
if|if
condition|(
name|childrenMode
operator|==
name|Mode
operator|.
name|FILTER
condition|)
block|{
comment|// In filter mode, the column must be a boolean
name|children
operator|.
name|add
argument_list|(
operator|new
name|SelectColumnIsTrue
argument_list|(
name|colIndex
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|arguments
index|[
name|i
index|]
operator|=
name|colIndex
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|child
operator|instanceof
name|ExprNodeConstantDesc
condition|)
block|{
name|Object
name|scalarValue
init|=
name|getScalarValue
argument_list|(
operator|(
name|ExprNodeConstantDesc
operator|)
name|child
argument_list|)
decl_stmt|;
name|arguments
index|[
name|i
index|]
operator|=
name|scalarValue
expr_stmt|;
block|}
else|else
block|{
throw|throw
operator|new
name|HiveException
argument_list|(
literal|"Cannot handle expression type: "
operator|+
name|child
operator|.
name|getClass
argument_list|()
operator|.
name|getSimpleName
argument_list|()
argument_list|)
throw|;
block|}
block|}
name|VectorExpression
name|vectorExpression
init|=
name|instantiateExpression
argument_list|(
name|vectorClass
argument_list|,
name|returnType
argument_list|,
name|arguments
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|vectorExpression
operator|!=
literal|null
operator|)
operator|&&
operator|!
name|children
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|vectorExpression
operator|.
name|setChildExpressions
argument_list|(
name|children
operator|.
name|toArray
argument_list|(
operator|new
name|VectorExpression
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|vectorExpression
return|;
block|}
catch|catch
parameter_list|(
name|Exception
name|ex
parameter_list|)
block|{
throw|throw
operator|new
name|HiveException
argument_list|(
name|ex
argument_list|)
throw|;
block|}
finally|finally
block|{
for|for
control|(
name|VectorExpression
name|ve
range|:
name|children
control|)
block|{
name|ocm
operator|.
name|freeOutputColumn
argument_list|(
name|ve
operator|.
name|getOutputColumn
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
specifier|private
name|Mode
name|getChildrenMode
parameter_list|(
name|Mode
name|mode
parameter_list|,
name|Class
argument_list|<
name|?
argument_list|>
name|udf
parameter_list|)
block|{
if|if
condition|(
name|mode
operator|.
name|equals
argument_list|(
name|Mode
operator|.
name|FILTER
argument_list|)
operator|&&
operator|(
name|udf
operator|.
name|equals
argument_list|(
name|GenericUDFOPAnd
operator|.
name|class
argument_list|)
operator|||
name|udf
operator|.
name|equals
argument_list|(
name|GenericUDFOPOr
operator|.
name|class
argument_list|)
operator|)
condition|)
block|{
return|return
name|Mode
operator|.
name|FILTER
return|;
block|}
return|return
name|Mode
operator|.
name|PROJECTION
return|;
block|}
specifier|private
name|VectorExpression
name|instantiateExpression
parameter_list|(
name|Class
argument_list|<
name|?
argument_list|>
name|vclass
parameter_list|,
name|TypeInfo
name|returnType
parameter_list|,
name|Object
modifier|...
name|args
parameter_list|)
throws|throws
name|HiveException
block|{
name|VectorExpression
name|ve
init|=
literal|null
decl_stmt|;
name|Constructor
argument_list|<
name|?
argument_list|>
name|ctor
init|=
name|getConstructor
argument_list|(
name|vclass
argument_list|)
decl_stmt|;
name|int
name|numParams
init|=
name|ctor
operator|.
name|getParameterTypes
argument_list|()
operator|.
name|length
decl_stmt|;
name|int
name|argsLength
init|=
operator|(
name|args
operator|==
literal|null
operator|)
condition|?
literal|0
else|:
name|args
operator|.
name|length
decl_stmt|;
try|try
block|{
if|if
condition|(
name|numParams
operator|==
literal|0
condition|)
block|{
name|ve
operator|=
operator|(
name|VectorExpression
operator|)
name|ctor
operator|.
name|newInstance
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|numParams
operator|==
name|argsLength
condition|)
block|{
name|ve
operator|=
operator|(
name|VectorExpression
operator|)
name|ctor
operator|.
name|newInstance
argument_list|(
name|args
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|numParams
operator|==
name|argsLength
operator|+
literal|1
condition|)
block|{
comment|// Additional argument is needed, which is the outputcolumn.
name|String
name|outType
decl_stmt|;
comment|// Special handling for decimal because decimal types need scale and precision parameter.
comment|// This special handling should be avoided by using returnType uniformly for all cases.
if|if
condition|(
name|returnType
operator|!=
literal|null
condition|)
block|{
name|outType
operator|=
name|getNormalizedTypeName
argument_list|(
name|returnType
operator|.
name|getTypeName
argument_list|()
argument_list|)
operator|.
name|toLowerCase
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|outType
operator|=
operator|(
operator|(
name|VectorExpression
operator|)
name|vclass
operator|.
name|newInstance
argument_list|()
operator|)
operator|.
name|getOutputType
argument_list|()
expr_stmt|;
block|}
name|int
name|outputCol
init|=
name|ocm
operator|.
name|allocateOutputColumn
argument_list|(
name|outType
argument_list|)
decl_stmt|;
name|Object
index|[]
name|newArgs
init|=
name|Arrays
operator|.
name|copyOf
argument_list|(
name|args
argument_list|,
name|numParams
argument_list|)
decl_stmt|;
name|newArgs
index|[
name|numParams
operator|-
literal|1
index|]
operator|=
name|outputCol
expr_stmt|;
name|ve
operator|=
operator|(
name|VectorExpression
operator|)
name|ctor
operator|.
name|newInstance
argument_list|(
name|newArgs
argument_list|)
expr_stmt|;
name|ve
operator|.
name|setOutputType
argument_list|(
name|outType
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|Exception
name|ex
parameter_list|)
block|{
throw|throw
operator|new
name|HiveException
argument_list|(
literal|"Could not instantiate "
operator|+
name|vclass
operator|.
name|getSimpleName
argument_list|()
argument_list|,
name|ex
argument_list|)
throw|;
block|}
return|return
name|ve
return|;
block|}
specifier|private
name|VectorExpression
name|getGenericUdfVectorExpression
parameter_list|(
name|GenericUDF
name|udf
parameter_list|,
name|List
argument_list|<
name|ExprNodeDesc
argument_list|>
name|childExpr
parameter_list|,
name|Mode
name|mode
parameter_list|,
name|TypeInfo
name|returnType
parameter_list|)
throws|throws
name|HiveException
block|{
name|List
argument_list|<
name|ExprNodeDesc
argument_list|>
name|constantFoldedChildren
init|=
name|foldConstantsForUnaryExprs
argument_list|(
name|childExpr
argument_list|)
decl_stmt|;
name|childExpr
operator|=
name|constantFoldedChildren
expr_stmt|;
comment|//First handle special cases
if|if
condition|(
name|udf
operator|instanceof
name|GenericUDFBetween
condition|)
block|{
return|return
name|getBetweenFilterExpression
argument_list|(
name|childExpr
argument_list|,
name|mode
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|udf
operator|instanceof
name|GenericUDFIn
condition|)
block|{
return|return
name|getInExpression
argument_list|(
name|childExpr
argument_list|,
name|mode
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|udf
operator|instanceof
name|GenericUDFOPPositive
condition|)
block|{
return|return
name|getIdentityExpression
argument_list|(
name|childExpr
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|udf
operator|instanceof
name|GenericUDFCoalesce
condition|)
block|{
comment|// Coalesce is a special case because it can take variable number of arguments.
return|return
name|getCoalesceExpression
argument_list|(
name|childExpr
argument_list|,
name|returnType
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|udf
operator|instanceof
name|GenericUDFBridge
condition|)
block|{
name|VectorExpression
name|v
init|=
name|getGenericUDFBridgeVectorExpression
argument_list|(
operator|(
name|GenericUDFBridge
operator|)
name|udf
argument_list|,
name|childExpr
argument_list|,
name|mode
argument_list|,
name|returnType
argument_list|)
decl_stmt|;
if|if
condition|(
name|v
operator|!=
literal|null
condition|)
block|{
return|return
name|v
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|udf
operator|instanceof
name|GenericUDFToDecimal
condition|)
block|{
return|return
name|getCastToDecimal
argument_list|(
name|childExpr
argument_list|,
name|returnType
argument_list|)
return|;
block|}
comment|// Now do a general lookup
name|Class
argument_list|<
name|?
argument_list|>
name|udfClass
init|=
name|udf
operator|.
name|getClass
argument_list|()
decl_stmt|;
if|if
condition|(
name|udf
operator|instanceof
name|GenericUDFBridge
condition|)
block|{
name|udfClass
operator|=
operator|(
operator|(
name|GenericUDFBridge
operator|)
name|udf
operator|)
operator|.
name|getUdfClass
argument_list|()
expr_stmt|;
block|}
name|VectorExpression
name|ve
init|=
name|getVectorExpressionForUdf
argument_list|(
name|udfClass
argument_list|,
name|constantFoldedChildren
argument_list|,
name|mode
argument_list|,
name|returnType
argument_list|)
decl_stmt|;
if|if
condition|(
name|ve
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|HiveException
argument_list|(
literal|"Udf: "
operator|+
name|udf
operator|.
name|getClass
argument_list|()
operator|.
name|getSimpleName
argument_list|()
operator|+
literal|", is not supported"
argument_list|)
throw|;
block|}
return|return
name|ve
return|;
block|}
specifier|private
name|VectorExpression
name|getCoalesceExpression
parameter_list|(
name|List
argument_list|<
name|ExprNodeDesc
argument_list|>
name|childExpr
parameter_list|,
name|TypeInfo
name|returnType
parameter_list|)
throws|throws
name|HiveException
block|{
name|int
index|[]
name|inputColumns
init|=
operator|new
name|int
index|[
name|childExpr
operator|.
name|size
argument_list|()
index|]
decl_stmt|;
name|VectorExpression
index|[]
name|vectorChildren
init|=
literal|null
decl_stmt|;
try|try
block|{
name|vectorChildren
operator|=
name|getVectorExpressions
argument_list|(
name|childExpr
argument_list|,
name|Mode
operator|.
name|PROJECTION
argument_list|)
expr_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
for|for
control|(
name|VectorExpression
name|ve
range|:
name|vectorChildren
control|)
block|{
name|inputColumns
index|[
name|i
operator|++
index|]
operator|=
name|ve
operator|.
name|getOutputColumn
argument_list|()
expr_stmt|;
block|}
name|int
name|outColumn
init|=
name|ocm
operator|.
name|allocateOutputColumn
argument_list|(
name|getNormalizedTypeName
argument_list|(
name|returnType
operator|.
name|getTypeName
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
name|VectorCoalesce
name|vectorCoalesce
init|=
operator|new
name|VectorCoalesce
argument_list|(
name|inputColumns
argument_list|,
name|outColumn
argument_list|)
decl_stmt|;
name|vectorCoalesce
operator|.
name|setOutputType
argument_list|(
name|returnType
operator|.
name|getTypeName
argument_list|()
argument_list|)
expr_stmt|;
name|vectorCoalesce
operator|.
name|setChildExpressions
argument_list|(
name|vectorChildren
argument_list|)
expr_stmt|;
return|return
name|vectorCoalesce
return|;
block|}
finally|finally
block|{
comment|// Free the output columns of the child expressions.
if|if
condition|(
name|vectorChildren
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|VectorExpression
name|v
range|:
name|vectorChildren
control|)
block|{
name|ocm
operator|.
name|freeOutputColumn
argument_list|(
name|v
operator|.
name|getOutputColumn
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/**    * Create a filter or boolean-valued expression for column IN (<list-of-constants> )    */
specifier|private
name|VectorExpression
name|getInExpression
parameter_list|(
name|List
argument_list|<
name|ExprNodeDesc
argument_list|>
name|childExpr
parameter_list|,
name|Mode
name|mode
parameter_list|)
throws|throws
name|HiveException
block|{
name|ExprNodeDesc
name|colExpr
init|=
name|childExpr
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|TypeInfo
name|colTypeInfo
init|=
name|colExpr
operator|.
name|getTypeInfo
argument_list|()
decl_stmt|;
name|String
name|colType
init|=
name|colExpr
operator|.
name|getTypeString
argument_list|()
decl_stmt|;
comment|// prepare arguments for createVectorExpression
name|List
argument_list|<
name|ExprNodeDesc
argument_list|>
name|childrenForInList
init|=
name|foldConstantsForUnaryExprs
argument_list|(
name|childExpr
operator|.
name|subList
argument_list|(
literal|1
argument_list|,
name|childExpr
operator|.
name|size
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
comment|/* This method assumes that the IN list has no NULL entries. That is enforced elsewhere,      * in the Vectorizer class. If NULL is passed in as a list entry, behavior is not defined.      * If in the future, NULL values are allowed in the IN list, be sure to handle 3-valued      * logic correctly. E.g. NOT (col IN (null)) should be considered UNKNOWN, so that would      * become FALSE in the WHERE clause, and cause the row in question to be filtered out.      * See the discussion in Jira HIVE-5583.      */
name|VectorExpression
name|expr
init|=
literal|null
decl_stmt|;
comment|// determine class
name|Class
argument_list|<
name|?
argument_list|>
name|cl
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|isIntFamily
argument_list|(
name|colType
argument_list|)
condition|)
block|{
name|cl
operator|=
operator|(
name|mode
operator|==
name|Mode
operator|.
name|FILTER
condition|?
name|FilterLongColumnInList
operator|.
name|class
else|:
name|LongColumnInList
operator|.
name|class
operator|)
expr_stmt|;
name|long
index|[]
name|inVals
init|=
operator|new
name|long
index|[
name|childrenForInList
operator|.
name|size
argument_list|()
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|!=
name|inVals
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|inVals
index|[
name|i
index|]
operator|=
name|getIntFamilyScalarAsLong
argument_list|(
operator|(
name|ExprNodeConstantDesc
operator|)
name|childrenForInList
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|expr
operator|=
name|createVectorExpression
argument_list|(
name|cl
argument_list|,
name|childExpr
operator|.
name|subList
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|)
argument_list|,
name|Mode
operator|.
name|PROJECTION
argument_list|,
name|colTypeInfo
argument_list|)
expr_stmt|;
operator|(
operator|(
name|ILongInExpr
operator|)
name|expr
operator|)
operator|.
name|setInListValues
argument_list|(
name|inVals
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|colType
operator|.
name|equals
argument_list|(
literal|"timestamp"
argument_list|)
condition|)
block|{
name|cl
operator|=
operator|(
name|mode
operator|==
name|Mode
operator|.
name|FILTER
condition|?
name|FilterLongColumnInList
operator|.
name|class
else|:
name|LongColumnInList
operator|.
name|class
operator|)
expr_stmt|;
name|long
index|[]
name|inVals
init|=
operator|new
name|long
index|[
name|childrenForInList
operator|.
name|size
argument_list|()
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|!=
name|inVals
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|inVals
index|[
name|i
index|]
operator|=
name|getTimestampScalar
argument_list|(
name|childrenForInList
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|expr
operator|=
name|createVectorExpression
argument_list|(
name|cl
argument_list|,
name|childExpr
operator|.
name|subList
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|)
argument_list|,
name|Mode
operator|.
name|PROJECTION
argument_list|,
name|colTypeInfo
argument_list|)
expr_stmt|;
operator|(
operator|(
name|ILongInExpr
operator|)
name|expr
operator|)
operator|.
name|setInListValues
argument_list|(
name|inVals
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|colType
operator|.
name|equals
argument_list|(
literal|"string"
argument_list|)
condition|)
block|{
name|cl
operator|=
operator|(
name|mode
operator|==
name|Mode
operator|.
name|FILTER
condition|?
name|FilterStringColumnInList
operator|.
name|class
else|:
name|StringColumnInList
operator|.
name|class
operator|)
expr_stmt|;
name|byte
index|[]
index|[]
name|inVals
init|=
operator|new
name|byte
index|[
name|childrenForInList
operator|.
name|size
argument_list|()
index|]
index|[]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|!=
name|inVals
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|inVals
index|[
name|i
index|]
operator|=
name|getStringScalarAsByteArray
argument_list|(
operator|(
name|ExprNodeConstantDesc
operator|)
name|childrenForInList
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|expr
operator|=
name|createVectorExpression
argument_list|(
name|cl
argument_list|,
name|childExpr
operator|.
name|subList
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|)
argument_list|,
name|Mode
operator|.
name|PROJECTION
argument_list|,
name|colTypeInfo
argument_list|)
expr_stmt|;
operator|(
operator|(
name|IStringInExpr
operator|)
name|expr
operator|)
operator|.
name|setInListValues
argument_list|(
name|inVals
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|isFloatFamily
argument_list|(
name|colType
argument_list|)
condition|)
block|{
name|cl
operator|=
operator|(
name|mode
operator|==
name|Mode
operator|.
name|FILTER
condition|?
name|FilterDoubleColumnInList
operator|.
name|class
else|:
name|DoubleColumnInList
operator|.
name|class
operator|)
expr_stmt|;
name|double
index|[]
name|inValsD
init|=
operator|new
name|double
index|[
name|childrenForInList
operator|.
name|size
argument_list|()
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|!=
name|inValsD
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|inValsD
index|[
name|i
index|]
operator|=
name|getNumericScalarAsDouble
argument_list|(
name|childrenForInList
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|expr
operator|=
name|createVectorExpression
argument_list|(
name|cl
argument_list|,
name|childExpr
operator|.
name|subList
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|)
argument_list|,
name|Mode
operator|.
name|PROJECTION
argument_list|,
name|colTypeInfo
argument_list|)
expr_stmt|;
operator|(
operator|(
name|IDoubleInExpr
operator|)
name|expr
operator|)
operator|.
name|setInListValues
argument_list|(
name|inValsD
argument_list|)
expr_stmt|;
block|}
comment|// Return the desired VectorExpression if found. Otherwise, return null to cause
comment|// execution to fall back to row mode.
return|return
name|expr
return|;
block|}
specifier|private
name|byte
index|[]
name|getStringScalarAsByteArray
parameter_list|(
name|ExprNodeConstantDesc
name|exprNodeConstantDesc
parameter_list|)
throws|throws
name|HiveException
block|{
name|Object
name|o
init|=
name|getScalarValue
argument_list|(
name|exprNodeConstantDesc
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|o
operator|instanceof
name|byte
index|[]
operator|)
condition|)
block|{
throw|throw
operator|new
name|HiveException
argument_list|(
literal|"Expected constant argument of type string"
argument_list|)
throw|;
block|}
return|return
operator|(
name|byte
index|[]
operator|)
name|o
return|;
block|}
comment|/**    * Invoke special handling for expressions that can't be vectorized by regular    * descriptor based lookup.    */
specifier|private
name|VectorExpression
name|getGenericUDFBridgeVectorExpression
parameter_list|(
name|GenericUDFBridge
name|udf
parameter_list|,
name|List
argument_list|<
name|ExprNodeDesc
argument_list|>
name|childExpr
parameter_list|,
name|Mode
name|mode
parameter_list|,
name|TypeInfo
name|returnType
parameter_list|)
throws|throws
name|HiveException
block|{
name|Class
argument_list|<
name|?
extends|extends
name|UDF
argument_list|>
name|cl
init|=
name|udf
operator|.
name|getUdfClass
argument_list|()
decl_stmt|;
if|if
condition|(
name|isCastToIntFamily
argument_list|(
name|cl
argument_list|)
condition|)
block|{
return|return
name|getCastToLongExpression
argument_list|(
name|childExpr
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|cl
operator|.
name|equals
argument_list|(
name|UDFToBoolean
operator|.
name|class
argument_list|)
condition|)
block|{
return|return
name|getCastToBoolean
argument_list|(
name|childExpr
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|isCastToFloatFamily
argument_list|(
name|cl
argument_list|)
condition|)
block|{
return|return
name|getCastToDoubleExpression
argument_list|(
name|cl
argument_list|,
name|childExpr
argument_list|,
name|returnType
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|cl
operator|.
name|equals
argument_list|(
name|UDFToString
operator|.
name|class
argument_list|)
condition|)
block|{
return|return
name|getCastToString
argument_list|(
name|childExpr
argument_list|)
return|;
block|}
return|return
literal|null
return|;
block|}
specifier|private
name|VectorExpression
name|getCastToDecimal
parameter_list|(
name|List
argument_list|<
name|ExprNodeDesc
argument_list|>
name|childExpr
parameter_list|,
name|TypeInfo
name|returnType
parameter_list|)
throws|throws
name|HiveException
block|{
name|ExprNodeDesc
name|child
init|=
name|childExpr
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|String
name|inputType
init|=
name|childExpr
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|getTypeString
argument_list|()
decl_stmt|;
if|if
condition|(
name|child
operator|instanceof
name|ExprNodeConstantDesc
condition|)
block|{
comment|// Return a constant vector expression
name|Object
name|constantValue
init|=
operator|(
operator|(
name|ExprNodeConstantDesc
operator|)
name|child
operator|)
operator|.
name|getValue
argument_list|()
decl_stmt|;
name|Decimal128
name|decimalValue
init|=
name|castConstantToDecimal
argument_list|(
name|constantValue
argument_list|,
name|child
operator|.
name|getTypeInfo
argument_list|()
argument_list|)
decl_stmt|;
return|return
name|getConstantVectorExpression
argument_list|(
name|decimalValue
argument_list|,
name|returnType
argument_list|,
name|Mode
operator|.
name|PROJECTION
argument_list|)
return|;
block|}
if|if
condition|(
name|isIntFamily
argument_list|(
name|inputType
argument_list|)
condition|)
block|{
return|return
name|createVectorExpression
argument_list|(
name|CastLongToDecimal
operator|.
name|class
argument_list|,
name|childExpr
argument_list|,
name|Mode
operator|.
name|PROJECTION
argument_list|,
name|returnType
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|isFloatFamily
argument_list|(
name|inputType
argument_list|)
condition|)
block|{
return|return
name|createVectorExpression
argument_list|(
name|CastDoubleToDecimal
operator|.
name|class
argument_list|,
name|childExpr
argument_list|,
name|Mode
operator|.
name|PROJECTION
argument_list|,
name|returnType
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|decimalTypePattern
operator|.
name|matcher
argument_list|(
name|inputType
argument_list|)
operator|.
name|matches
argument_list|()
condition|)
block|{
return|return
name|createVectorExpression
argument_list|(
name|CastDecimalToDecimal
operator|.
name|class
argument_list|,
name|childExpr
argument_list|,
name|Mode
operator|.
name|PROJECTION
argument_list|,
name|returnType
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|isStringFamily
argument_list|(
name|inputType
argument_list|)
condition|)
block|{
return|return
name|createVectorExpression
argument_list|(
name|CastStringToDecimal
operator|.
name|class
argument_list|,
name|childExpr
argument_list|,
name|Mode
operator|.
name|PROJECTION
argument_list|,
name|returnType
argument_list|)
return|;
block|}
throw|throw
operator|new
name|HiveException
argument_list|(
literal|"Unhandled cast input type: "
operator|+
name|inputType
argument_list|)
throw|;
block|}
specifier|private
name|Decimal128
name|castConstantToDecimal
parameter_list|(
name|Object
name|scalar
parameter_list|,
name|TypeInfo
name|type
parameter_list|)
throws|throws
name|HiveException
block|{
name|PrimitiveTypeInfo
name|ptinfo
init|=
operator|(
name|PrimitiveTypeInfo
operator|)
name|type
decl_stmt|;
name|String
name|typename
init|=
name|type
operator|.
name|getTypeName
argument_list|()
decl_stmt|;
name|Decimal128
name|d
init|=
operator|new
name|Decimal128
argument_list|()
decl_stmt|;
name|int
name|scale
init|=
name|HiveDecimalUtils
operator|.
name|getScaleForType
argument_list|(
name|ptinfo
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|ptinfo
operator|.
name|getPrimitiveCategory
argument_list|()
condition|)
block|{
case|case
name|FLOAT
case|:
name|float
name|floatVal
init|=
operator|(
operator|(
name|Float
operator|)
name|scalar
operator|)
operator|.
name|floatValue
argument_list|()
decl_stmt|;
name|d
operator|.
name|update
argument_list|(
name|floatVal
argument_list|,
operator|(
name|short
operator|)
name|scale
argument_list|)
expr_stmt|;
break|break;
case|case
name|DOUBLE
case|:
name|double
name|doubleVal
init|=
operator|(
operator|(
name|Double
operator|)
name|scalar
operator|)
operator|.
name|doubleValue
argument_list|()
decl_stmt|;
name|d
operator|.
name|update
argument_list|(
name|doubleVal
argument_list|,
operator|(
name|short
operator|)
name|scale
argument_list|)
expr_stmt|;
break|break;
case|case
name|BYTE
case|:
name|byte
name|byteVal
init|=
operator|(
operator|(
name|Byte
operator|)
name|scalar
operator|)
operator|.
name|byteValue
argument_list|()
decl_stmt|;
name|d
operator|.
name|update
argument_list|(
name|byteVal
argument_list|,
operator|(
name|short
operator|)
name|scale
argument_list|)
expr_stmt|;
break|break;
case|case
name|SHORT
case|:
name|short
name|shortVal
init|=
operator|(
operator|(
name|Short
operator|)
name|scalar
operator|)
operator|.
name|shortValue
argument_list|()
decl_stmt|;
name|d
operator|.
name|update
argument_list|(
name|shortVal
argument_list|,
operator|(
name|short
operator|)
name|scale
argument_list|)
expr_stmt|;
break|break;
case|case
name|INT
case|:
name|int
name|intVal
init|=
operator|(
operator|(
name|Integer
operator|)
name|scalar
operator|)
operator|.
name|intValue
argument_list|()
decl_stmt|;
name|d
operator|.
name|update
argument_list|(
name|intVal
argument_list|,
operator|(
name|short
operator|)
name|scale
argument_list|)
expr_stmt|;
break|break;
case|case
name|LONG
case|:
name|long
name|longVal
init|=
operator|(
operator|(
name|Long
operator|)
name|scalar
operator|)
operator|.
name|longValue
argument_list|()
decl_stmt|;
name|d
operator|.
name|update
argument_list|(
name|longVal
argument_list|,
operator|(
name|short
operator|)
name|scale
argument_list|)
expr_stmt|;
break|break;
case|case
name|DECIMAL
case|:
name|HiveDecimal
name|decimalVal
init|=
operator|(
name|HiveDecimal
operator|)
name|scalar
decl_stmt|;
name|d
operator|.
name|update
argument_list|(
name|decimalVal
operator|.
name|unscaledValue
argument_list|()
argument_list|,
operator|(
name|short
operator|)
name|scale
argument_list|)
expr_stmt|;
break|break;
default|default:
throw|throw
operator|new
name|HiveException
argument_list|(
literal|"Unsupported type "
operator|+
name|typename
operator|+
literal|" for cast to Decimal128"
argument_list|)
throw|;
block|}
return|return
name|d
return|;
block|}
specifier|private
name|VectorExpression
name|getCastToString
parameter_list|(
name|List
argument_list|<
name|ExprNodeDesc
argument_list|>
name|childExpr
parameter_list|)
throws|throws
name|HiveException
block|{
name|String
name|inputType
init|=
name|childExpr
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|getTypeString
argument_list|()
decl_stmt|;
if|if
condition|(
name|inputType
operator|.
name|equals
argument_list|(
literal|"boolean"
argument_list|)
condition|)
block|{
comment|// Boolean must come before the integer family. It's a special case.
return|return
name|createVectorExpression
argument_list|(
name|CastBooleanToStringViaLongToString
operator|.
name|class
argument_list|,
name|childExpr
argument_list|,
name|Mode
operator|.
name|PROJECTION
argument_list|,
literal|null
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|isIntFamily
argument_list|(
name|inputType
argument_list|)
condition|)
block|{
return|return
name|createVectorExpression
argument_list|(
name|CastLongToString
operator|.
name|class
argument_list|,
name|childExpr
argument_list|,
name|Mode
operator|.
name|PROJECTION
argument_list|,
literal|null
argument_list|)
return|;
block|}
comment|/* The string type is deliberately omitted -- the planner removes string to string casts.      * Timestamp, float, and double types are handled by the legacy code path. See isLegacyPathUDF.      */
throw|throw
operator|new
name|HiveException
argument_list|(
literal|"Unhandled cast input type: "
operator|+
name|inputType
argument_list|)
throw|;
block|}
specifier|private
name|VectorExpression
name|getCastToDoubleExpression
parameter_list|(
name|Class
argument_list|<
name|?
argument_list|>
name|udf
parameter_list|,
name|List
argument_list|<
name|ExprNodeDesc
argument_list|>
name|childExpr
parameter_list|,
name|TypeInfo
name|returnType
parameter_list|)
throws|throws
name|HiveException
block|{
name|String
name|inputType
init|=
name|childExpr
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|getTypeString
argument_list|()
decl_stmt|;
if|if
condition|(
name|isIntFamily
argument_list|(
name|inputType
argument_list|)
condition|)
block|{
return|return
name|createVectorExpression
argument_list|(
name|CastLongToDouble
operator|.
name|class
argument_list|,
name|childExpr
argument_list|,
name|Mode
operator|.
name|PROJECTION
argument_list|,
name|returnType
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|inputType
operator|.
name|equals
argument_list|(
literal|"timestamp"
argument_list|)
condition|)
block|{
return|return
name|createVectorExpression
argument_list|(
name|CastTimestampToDoubleViaLongToDouble
operator|.
name|class
argument_list|,
name|childExpr
argument_list|,
name|Mode
operator|.
name|PROJECTION
argument_list|,
name|returnType
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|isFloatFamily
argument_list|(
name|inputType
argument_list|)
condition|)
block|{
comment|// float types require no conversion, so use a no-op
return|return
name|getIdentityExpression
argument_list|(
name|childExpr
argument_list|)
return|;
block|}
comment|// The string type is deliberately omitted -- it's handled elsewhere. See isLegacyPathUDF.
return|return
literal|null
return|;
block|}
specifier|private
name|VectorExpression
name|getCastToBoolean
parameter_list|(
name|List
argument_list|<
name|ExprNodeDesc
argument_list|>
name|childExpr
parameter_list|)
throws|throws
name|HiveException
block|{
name|String
name|inputType
init|=
name|childExpr
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|getTypeString
argument_list|()
decl_stmt|;
comment|// Long and double are handled using descriptors, string needs to be specially handled.
if|if
condition|(
name|inputType
operator|.
name|equals
argument_list|(
literal|"string"
argument_list|)
condition|)
block|{
comment|// string casts to false if it is 0 characters long, otherwise true
name|VectorExpression
name|lenExpr
init|=
name|createVectorExpression
argument_list|(
name|StringLength
operator|.
name|class
argument_list|,
name|childExpr
argument_list|,
name|Mode
operator|.
name|PROJECTION
argument_list|,
literal|null
argument_list|)
decl_stmt|;
name|int
name|outputCol
init|=
name|ocm
operator|.
name|allocateOutputColumn
argument_list|(
literal|"integer"
argument_list|)
decl_stmt|;
name|VectorExpression
name|lenToBoolExpr
init|=
operator|new
name|CastLongToBooleanViaLongToLong
argument_list|(
name|lenExpr
operator|.
name|getOutputColumn
argument_list|()
argument_list|,
name|outputCol
argument_list|)
decl_stmt|;
name|lenToBoolExpr
operator|.
name|setChildExpressions
argument_list|(
operator|new
name|VectorExpression
index|[]
block|{
name|lenExpr
block|}
argument_list|)
expr_stmt|;
name|ocm
operator|.
name|freeOutputColumn
argument_list|(
name|lenExpr
operator|.
name|getOutputColumn
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|lenToBoolExpr
return|;
block|}
comment|// cast(booleanExpr as boolean) case is omitted because planner removes it as a no-op
return|return
literal|null
return|;
block|}
specifier|private
name|VectorExpression
name|getCastToLongExpression
parameter_list|(
name|List
argument_list|<
name|ExprNodeDesc
argument_list|>
name|childExpr
parameter_list|)
throws|throws
name|HiveException
block|{
name|String
name|inputType
init|=
name|childExpr
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|getTypeString
argument_list|()
decl_stmt|;
comment|// Float family, timestamp are handled via descriptor based lookup, int family needs
comment|// special handling.
if|if
condition|(
name|isIntFamily
argument_list|(
name|inputType
argument_list|)
condition|)
block|{
comment|// integer and boolean types require no conversion, so use a no-op
return|return
name|getIdentityExpression
argument_list|(
name|childExpr
argument_list|)
return|;
block|}
comment|// string type is deliberately omitted -- it's handled elsewhere. See isLegacyPathUDF.
return|return
literal|null
return|;
block|}
comment|/* Get a [NOT] BETWEEN filter expression. This is treated as a special case    * because the NOT is actually specified in the expression tree as the first argument,    * and we don't want any runtime cost for that. So creating the VectorExpression    * needs to be done differently than the standard way where all arguments are    * passed to the VectorExpression constructor.    */
specifier|private
name|VectorExpression
name|getBetweenFilterExpression
parameter_list|(
name|List
argument_list|<
name|ExprNodeDesc
argument_list|>
name|childExpr
parameter_list|,
name|Mode
name|mode
parameter_list|)
throws|throws
name|HiveException
block|{
if|if
condition|(
name|mode
operator|==
name|Mode
operator|.
name|PROJECTION
condition|)
block|{
comment|// Projection mode is not yet supported for [NOT] BETWEEN. Return null so Vectorizer
comment|// knows to revert to row-at-a-time execution.
return|return
literal|null
return|;
block|}
name|boolean
name|notKeywordPresent
init|=
call|(
name|Boolean
call|)
argument_list|(
operator|(
name|ExprNodeConstantDesc
operator|)
name|childExpr
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|)
operator|.
name|getValue
argument_list|()
decl_stmt|;
name|ExprNodeDesc
name|colExpr
init|=
name|childExpr
operator|.
name|get
argument_list|(
literal|1
argument_list|)
decl_stmt|;
comment|// To hold left and right boundaries as long value in nanos for timestamp type.
name|long
name|left
decl_stmt|,
name|right
decl_stmt|;
name|List
argument_list|<
name|ExprNodeDesc
argument_list|>
name|newChildren
decl_stmt|;
name|String
name|colType
init|=
name|colExpr
operator|.
name|getTypeString
argument_list|()
decl_stmt|;
comment|// prepare arguments for createVectorExpression
name|List
argument_list|<
name|ExprNodeDesc
argument_list|>
name|childrenAfterNot
init|=
name|foldConstantsForUnaryExprs
argument_list|(
name|childExpr
operator|.
name|subList
argument_list|(
literal|1
argument_list|,
literal|4
argument_list|)
argument_list|)
decl_stmt|;
comment|// determine class
name|Class
argument_list|<
name|?
argument_list|>
name|cl
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|isIntFamily
argument_list|(
name|colType
argument_list|)
operator|&&
operator|!
name|notKeywordPresent
condition|)
block|{
name|cl
operator|=
name|FilterLongColumnBetween
operator|.
name|class
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|isIntFamily
argument_list|(
name|colType
argument_list|)
operator|&&
name|notKeywordPresent
condition|)
block|{
name|cl
operator|=
name|FilterLongColumnNotBetween
operator|.
name|class
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|isFloatFamily
argument_list|(
name|colType
argument_list|)
operator|&&
operator|!
name|notKeywordPresent
condition|)
block|{
name|cl
operator|=
name|FilterDoubleColumnBetween
operator|.
name|class
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|isFloatFamily
argument_list|(
name|colType
argument_list|)
operator|&&
name|notKeywordPresent
condition|)
block|{
name|cl
operator|=
name|FilterDoubleColumnNotBetween
operator|.
name|class
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|colType
operator|.
name|equals
argument_list|(
literal|"string"
argument_list|)
operator|&&
operator|!
name|notKeywordPresent
condition|)
block|{
name|cl
operator|=
name|FilterStringColumnBetween
operator|.
name|class
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|colType
operator|.
name|equals
argument_list|(
literal|"string"
argument_list|)
operator|&&
name|notKeywordPresent
condition|)
block|{
name|cl
operator|=
name|FilterStringColumnNotBetween
operator|.
name|class
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|colType
operator|.
name|equals
argument_list|(
literal|"timestamp"
argument_list|)
condition|)
block|{
comment|// Get timestamp boundary values as longs instead of the expected strings
name|left
operator|=
name|getTimestampScalar
argument_list|(
name|childExpr
operator|.
name|get
argument_list|(
literal|2
argument_list|)
argument_list|)
expr_stmt|;
name|right
operator|=
name|getTimestampScalar
argument_list|(
name|childExpr
operator|.
name|get
argument_list|(
literal|3
argument_list|)
argument_list|)
expr_stmt|;
name|childrenAfterNot
operator|=
operator|new
name|ArrayList
argument_list|<
name|ExprNodeDesc
argument_list|>
argument_list|()
expr_stmt|;
name|childrenAfterNot
operator|.
name|add
argument_list|(
name|colExpr
argument_list|)
expr_stmt|;
name|childrenAfterNot
operator|.
name|add
argument_list|(
operator|new
name|ExprNodeConstantDesc
argument_list|(
name|left
argument_list|)
argument_list|)
expr_stmt|;
name|childrenAfterNot
operator|.
name|add
argument_list|(
operator|new
name|ExprNodeConstantDesc
argument_list|(
name|right
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|notKeywordPresent
condition|)
block|{
name|cl
operator|=
name|FilterLongColumnNotBetween
operator|.
name|class
expr_stmt|;
block|}
else|else
block|{
name|cl
operator|=
name|FilterLongColumnBetween
operator|.
name|class
expr_stmt|;
block|}
block|}
return|return
name|createVectorExpression
argument_list|(
name|cl
argument_list|,
name|childrenAfterNot
argument_list|,
name|Mode
operator|.
name|PROJECTION
argument_list|,
literal|null
argument_list|)
return|;
block|}
comment|/*    * Return vector expression for a custom (i.e. not built-in) UDF.    */
specifier|private
name|VectorExpression
name|getCustomUDFExpression
parameter_list|(
name|ExprNodeGenericFuncDesc
name|expr
parameter_list|)
throws|throws
name|HiveException
block|{
comment|//GenericUDFBridge udfBridge = (GenericUDFBridge) expr.getGenericUDF();
name|List
argument_list|<
name|ExprNodeDesc
argument_list|>
name|childExprList
init|=
name|expr
operator|.
name|getChildren
argument_list|()
decl_stmt|;
comment|// argument descriptors
name|VectorUDFArgDesc
index|[]
name|argDescs
init|=
operator|new
name|VectorUDFArgDesc
index|[
name|expr
operator|.
name|getChildren
argument_list|()
operator|.
name|size
argument_list|()
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|argDescs
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|argDescs
index|[
name|i
index|]
operator|=
operator|new
name|VectorUDFArgDesc
argument_list|()
expr_stmt|;
block|}
comment|// positions of variable arguments (columns or non-constant expressions)
name|List
argument_list|<
name|Integer
argument_list|>
name|variableArgPositions
init|=
operator|new
name|ArrayList
argument_list|<
name|Integer
argument_list|>
argument_list|()
decl_stmt|;
comment|// Column numbers of batch corresponding to expression result arguments
name|List
argument_list|<
name|Integer
argument_list|>
name|exprResultColumnNums
init|=
operator|new
name|ArrayList
argument_list|<
name|Integer
argument_list|>
argument_list|()
decl_stmt|;
comment|// Prepare children
name|List
argument_list|<
name|VectorExpression
argument_list|>
name|vectorExprs
init|=
operator|new
name|ArrayList
argument_list|<
name|VectorExpression
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|childExprList
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|ExprNodeDesc
name|child
init|=
name|childExprList
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|child
operator|instanceof
name|ExprNodeGenericFuncDesc
condition|)
block|{
name|VectorExpression
name|e
init|=
name|getVectorExpression
argument_list|(
name|child
argument_list|,
name|Mode
operator|.
name|PROJECTION
argument_list|)
decl_stmt|;
name|vectorExprs
operator|.
name|add
argument_list|(
name|e
argument_list|)
expr_stmt|;
name|variableArgPositions
operator|.
name|add
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|exprResultColumnNums
operator|.
name|add
argument_list|(
name|e
operator|.
name|getOutputColumn
argument_list|()
argument_list|)
expr_stmt|;
name|argDescs
index|[
name|i
index|]
operator|.
name|setVariable
argument_list|(
name|e
operator|.
name|getOutputColumn
argument_list|()
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|child
operator|instanceof
name|ExprNodeColumnDesc
condition|)
block|{
name|variableArgPositions
operator|.
name|add
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|argDescs
index|[
name|i
index|]
operator|.
name|setVariable
argument_list|(
name|getInputColumnIndex
argument_list|(
operator|(
operator|(
name|ExprNodeColumnDesc
operator|)
name|child
operator|)
operator|.
name|getColumn
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|child
operator|instanceof
name|ExprNodeConstantDesc
condition|)
block|{
comment|// this is a constant
name|argDescs
index|[
name|i
index|]
operator|.
name|setConstant
argument_list|(
operator|(
name|ExprNodeConstantDesc
operator|)
name|child
argument_list|)
expr_stmt|;
block|}
else|else
block|{
throw|throw
operator|new
name|HiveException
argument_list|(
literal|"Unable to vectorize Custom UDF"
argument_list|)
throw|;
block|}
block|}
comment|// Allocate output column and get column number;
name|int
name|outputCol
init|=
operator|-
literal|1
decl_stmt|;
name|String
name|resultType
init|=
name|expr
operator|.
name|getTypeInfo
argument_list|()
operator|.
name|getTypeName
argument_list|()
decl_stmt|;
name|String
name|resultColVectorType
init|=
name|getNormalizedTypeName
argument_list|(
name|resultType
argument_list|)
decl_stmt|;
name|outputCol
operator|=
name|ocm
operator|.
name|allocateOutputColumn
argument_list|(
name|resultColVectorType
argument_list|)
expr_stmt|;
comment|// Make vectorized operator
name|VectorExpression
name|ve
init|=
operator|new
name|VectorUDFAdaptor
argument_list|(
name|expr
argument_list|,
name|outputCol
argument_list|,
name|resultColVectorType
argument_list|,
name|argDescs
argument_list|)
decl_stmt|;
comment|// Set child expressions
name|VectorExpression
index|[]
name|childVEs
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|exprResultColumnNums
operator|.
name|size
argument_list|()
operator|!=
literal|0
condition|)
block|{
name|childVEs
operator|=
operator|new
name|VectorExpression
index|[
name|exprResultColumnNums
operator|.
name|size
argument_list|()
index|]
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|childVEs
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|childVEs
index|[
name|i
index|]
operator|=
name|vectorExprs
operator|.
name|get
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
block|}
name|ve
operator|.
name|setChildExpressions
argument_list|(
name|childVEs
argument_list|)
expr_stmt|;
comment|// Free output columns if inputs have non-leaf expression trees.
for|for
control|(
name|Integer
name|i
range|:
name|exprResultColumnNums
control|)
block|{
name|ocm
operator|.
name|freeOutputColumn
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
return|return
name|ve
return|;
block|}
specifier|public
specifier|static
name|boolean
name|isStringFamily
parameter_list|(
name|String
name|resultType
parameter_list|)
block|{
return|return
name|resultType
operator|.
name|equalsIgnoreCase
argument_list|(
literal|"string"
argument_list|)
return|;
block|}
specifier|public
specifier|static
name|boolean
name|isDatetimeFamily
parameter_list|(
name|String
name|resultType
parameter_list|)
block|{
return|return
name|resultType
operator|.
name|equalsIgnoreCase
argument_list|(
literal|"timestamp"
argument_list|)
return|;
block|}
comment|// return true if this is any kind of float
specifier|public
specifier|static
name|boolean
name|isFloatFamily
parameter_list|(
name|String
name|resultType
parameter_list|)
block|{
return|return
name|resultType
operator|.
name|equalsIgnoreCase
argument_list|(
literal|"double"
argument_list|)
operator|||
name|resultType
operator|.
name|equalsIgnoreCase
argument_list|(
literal|"float"
argument_list|)
return|;
block|}
comment|// Return true if this data type is handled in the output vector as an integer.
specifier|public
specifier|static
name|boolean
name|isIntFamily
parameter_list|(
name|String
name|resultType
parameter_list|)
block|{
return|return
name|resultType
operator|.
name|equalsIgnoreCase
argument_list|(
literal|"tinyint"
argument_list|)
operator|||
name|resultType
operator|.
name|equalsIgnoreCase
argument_list|(
literal|"smallint"
argument_list|)
operator|||
name|resultType
operator|.
name|equalsIgnoreCase
argument_list|(
literal|"int"
argument_list|)
operator|||
name|resultType
operator|.
name|equalsIgnoreCase
argument_list|(
literal|"bigint"
argument_list|)
operator|||
name|resultType
operator|.
name|equalsIgnoreCase
argument_list|(
literal|"boolean"
argument_list|)
operator|||
name|resultType
operator|.
name|equalsIgnoreCase
argument_list|(
literal|"long"
argument_list|)
return|;
block|}
specifier|private
name|Object
name|getScalarValue
parameter_list|(
name|ExprNodeConstantDesc
name|constDesc
parameter_list|)
throws|throws
name|HiveException
block|{
if|if
condition|(
name|constDesc
operator|.
name|getTypeString
argument_list|()
operator|.
name|equalsIgnoreCase
argument_list|(
literal|"String"
argument_list|)
condition|)
block|{
try|try
block|{
name|byte
index|[]
name|bytes
init|=
operator|(
operator|(
name|String
operator|)
name|constDesc
operator|.
name|getValue
argument_list|()
operator|)
operator|.
name|getBytes
argument_list|(
literal|"UTF-8"
argument_list|)
decl_stmt|;
return|return
name|bytes
return|;
block|}
catch|catch
parameter_list|(
name|Exception
name|ex
parameter_list|)
block|{
throw|throw
operator|new
name|HiveException
argument_list|(
name|ex
argument_list|)
throw|;
block|}
block|}
elseif|else
if|if
condition|(
name|constDesc
operator|.
name|getTypeString
argument_list|()
operator|.
name|equalsIgnoreCase
argument_list|(
literal|"boolean"
argument_list|)
condition|)
block|{
if|if
condition|(
name|constDesc
operator|.
name|getValue
argument_list|()
operator|.
name|equals
argument_list|(
name|Boolean
operator|.
name|valueOf
argument_list|(
literal|true
argument_list|)
argument_list|)
condition|)
block|{
return|return
literal|1
return|;
block|}
else|else
block|{
return|return
literal|0
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|decimalTypePattern
operator|.
name|matcher
argument_list|(
name|constDesc
operator|.
name|getTypeString
argument_list|()
argument_list|)
operator|.
name|matches
argument_list|()
condition|)
block|{
name|HiveDecimal
name|hd
init|=
operator|(
name|HiveDecimal
operator|)
name|constDesc
operator|.
name|getValue
argument_list|()
decl_stmt|;
name|Decimal128
name|dvalue
init|=
operator|new
name|Decimal128
argument_list|()
decl_stmt|;
name|dvalue
operator|.
name|update
argument_list|(
name|hd
operator|.
name|unscaledValue
argument_list|()
argument_list|,
operator|(
name|short
operator|)
name|hd
operator|.
name|scale
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|dvalue
return|;
block|}
else|else
block|{
return|return
name|constDesc
operator|.
name|getValue
argument_list|()
return|;
block|}
block|}
specifier|private
name|long
name|getIntFamilyScalarAsLong
parameter_list|(
name|ExprNodeConstantDesc
name|constDesc
parameter_list|)
throws|throws
name|HiveException
block|{
name|Object
name|o
init|=
name|getScalarValue
argument_list|(
name|constDesc
argument_list|)
decl_stmt|;
if|if
condition|(
name|o
operator|instanceof
name|Integer
condition|)
block|{
return|return
operator|(
name|Integer
operator|)
name|o
return|;
block|}
elseif|else
if|if
condition|(
name|o
operator|instanceof
name|Long
condition|)
block|{
return|return
operator|(
name|Long
operator|)
name|o
return|;
block|}
throw|throw
operator|new
name|HiveException
argument_list|(
literal|"Unexpected type when converting to long"
argument_list|)
throw|;
block|}
specifier|private
name|double
name|getNumericScalarAsDouble
parameter_list|(
name|ExprNodeDesc
name|constDesc
parameter_list|)
throws|throws
name|HiveException
block|{
name|Object
name|o
init|=
name|getScalarValue
argument_list|(
operator|(
name|ExprNodeConstantDesc
operator|)
name|constDesc
argument_list|)
decl_stmt|;
if|if
condition|(
name|o
operator|instanceof
name|Double
condition|)
block|{
return|return
operator|(
name|Double
operator|)
name|o
return|;
block|}
elseif|else
if|if
condition|(
name|o
operator|instanceof
name|Float
condition|)
block|{
return|return
operator|(
name|Float
operator|)
name|o
return|;
block|}
elseif|else
if|if
condition|(
name|o
operator|instanceof
name|Integer
condition|)
block|{
return|return
operator|(
name|Integer
operator|)
name|o
return|;
block|}
elseif|else
if|if
condition|(
name|o
operator|instanceof
name|Long
condition|)
block|{
return|return
operator|(
name|Long
operator|)
name|o
return|;
block|}
throw|throw
operator|new
name|HiveException
argument_list|(
literal|"Unexpected type when converting to double"
argument_list|)
throw|;
block|}
comment|// Get a timestamp as a long in number of nanos, from a string constant or cast
specifier|private
name|long
name|getTimestampScalar
parameter_list|(
name|ExprNodeDesc
name|expr
parameter_list|)
throws|throws
name|HiveException
block|{
if|if
condition|(
name|expr
operator|instanceof
name|ExprNodeGenericFuncDesc
operator|&&
operator|(
operator|(
name|ExprNodeGenericFuncDesc
operator|)
name|expr
operator|)
operator|.
name|getGenericUDF
argument_list|()
operator|instanceof
name|GenericUDFTimestamp
condition|)
block|{
return|return
name|evaluateCastToTimestamp
argument_list|(
name|expr
argument_list|)
return|;
block|}
if|if
condition|(
operator|!
operator|(
name|expr
operator|instanceof
name|ExprNodeConstantDesc
operator|)
condition|)
block|{
throw|throw
operator|new
name|HiveException
argument_list|(
literal|"Constant timestamp value expected for expression argument. "
operator|+
literal|"Non-constant argument not supported for vectorization."
argument_list|)
throw|;
block|}
name|ExprNodeConstantDesc
name|constExpr
init|=
operator|(
name|ExprNodeConstantDesc
operator|)
name|expr
decl_stmt|;
if|if
condition|(
name|constExpr
operator|.
name|getTypeString
argument_list|()
operator|.
name|equals
argument_list|(
literal|"string"
argument_list|)
condition|)
block|{
comment|// create expression tree with type cast from string to timestamp
name|ExprNodeGenericFuncDesc
name|expr2
init|=
operator|new
name|ExprNodeGenericFuncDesc
argument_list|()
decl_stmt|;
name|GenericUDFTimestamp
name|f
init|=
operator|new
name|GenericUDFTimestamp
argument_list|()
decl_stmt|;
name|expr2
operator|.
name|setGenericUDF
argument_list|(
name|f
argument_list|)
expr_stmt|;
name|ArrayList
argument_list|<
name|ExprNodeDesc
argument_list|>
name|children
init|=
operator|new
name|ArrayList
argument_list|<
name|ExprNodeDesc
argument_list|>
argument_list|()
decl_stmt|;
name|children
operator|.
name|add
argument_list|(
name|expr
argument_list|)
expr_stmt|;
name|expr2
operator|.
name|setChildren
argument_list|(
name|children
argument_list|)
expr_stmt|;
comment|// initialize and evaluate
return|return
name|evaluateCastToTimestamp
argument_list|(
name|expr2
argument_list|)
return|;
block|}
throw|throw
operator|new
name|HiveException
argument_list|(
literal|"Udf: unhandled constant type for scalar argument. "
operator|+
literal|"Expecting string."
argument_list|)
throw|;
block|}
specifier|private
name|long
name|evaluateCastToTimestamp
parameter_list|(
name|ExprNodeDesc
name|expr
parameter_list|)
throws|throws
name|HiveException
block|{
name|ExprNodeGenericFuncDesc
name|expr2
init|=
operator|(
name|ExprNodeGenericFuncDesc
operator|)
name|expr
decl_stmt|;
name|ExprNodeEvaluator
name|evaluator
init|=
name|ExprNodeEvaluatorFactory
operator|.
name|get
argument_list|(
name|expr2
argument_list|)
decl_stmt|;
name|ObjectInspector
name|output
init|=
name|evaluator
operator|.
name|initialize
argument_list|(
literal|null
argument_list|)
decl_stmt|;
name|Object
name|constant
init|=
name|evaluator
operator|.
name|evaluate
argument_list|(
literal|null
argument_list|)
decl_stmt|;
name|Object
name|java
init|=
name|ObjectInspectorUtils
operator|.
name|copyToStandardJavaObject
argument_list|(
name|constant
argument_list|,
name|output
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|java
operator|instanceof
name|Timestamp
operator|)
condition|)
block|{
throw|throw
operator|new
name|HiveException
argument_list|(
literal|"Udf: failed to convert to timestamp"
argument_list|)
throw|;
block|}
name|Timestamp
name|ts
init|=
operator|(
name|Timestamp
operator|)
name|java
decl_stmt|;
return|return
name|TimestampUtils
operator|.
name|getTimeNanoSec
argument_list|(
name|ts
argument_list|)
return|;
block|}
specifier|private
name|Constructor
argument_list|<
name|?
argument_list|>
name|getConstructor
parameter_list|(
name|Class
argument_list|<
name|?
argument_list|>
name|cl
parameter_list|)
throws|throws
name|HiveException
block|{
try|try
block|{
name|Constructor
argument_list|<
name|?
argument_list|>
index|[]
name|ctors
init|=
name|cl
operator|.
name|getDeclaredConstructors
argument_list|()
decl_stmt|;
if|if
condition|(
name|ctors
operator|.
name|length
operator|==
literal|1
condition|)
block|{
return|return
name|ctors
index|[
literal|0
index|]
return|;
block|}
name|Constructor
argument_list|<
name|?
argument_list|>
name|defaultCtor
init|=
name|cl
operator|.
name|getConstructor
argument_list|()
decl_stmt|;
for|for
control|(
name|Constructor
argument_list|<
name|?
argument_list|>
name|ctor
range|:
name|ctors
control|)
block|{
if|if
condition|(
operator|!
name|ctor
operator|.
name|equals
argument_list|(
name|defaultCtor
argument_list|)
condition|)
block|{
return|return
name|ctor
return|;
block|}
block|}
throw|throw
operator|new
name|HiveException
argument_list|(
literal|"Only default constructor found"
argument_list|)
throw|;
block|}
catch|catch
parameter_list|(
name|Exception
name|ex
parameter_list|)
block|{
throw|throw
operator|new
name|HiveException
argument_list|(
name|ex
argument_list|)
throw|;
block|}
block|}
specifier|static
name|String
name|getNormalizedTypeName
parameter_list|(
name|String
name|colType
parameter_list|)
block|{
name|String
name|normalizedType
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|colType
operator|.
name|equalsIgnoreCase
argument_list|(
literal|"Double"
argument_list|)
operator|||
name|colType
operator|.
name|equalsIgnoreCase
argument_list|(
literal|"Float"
argument_list|)
condition|)
block|{
name|normalizedType
operator|=
literal|"Double"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|colType
operator|.
name|equalsIgnoreCase
argument_list|(
literal|"String"
argument_list|)
condition|)
block|{
name|normalizedType
operator|=
literal|"String"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|decimalTypePattern
operator|.
name|matcher
argument_list|(
name|colType
operator|.
name|toLowerCase
argument_list|()
argument_list|)
operator|.
name|matches
argument_list|()
condition|)
block|{
comment|//Return the decimal type as is, it includes scale and precision.
name|normalizedType
operator|=
name|colType
expr_stmt|;
block|}
else|else
block|{
name|normalizedType
operator|=
literal|"Long"
expr_stmt|;
block|}
return|return
name|normalizedType
return|;
block|}
specifier|static
name|Object
index|[]
index|[]
name|aggregatesDefinition
init|=
block|{
block|{
literal|"min"
block|,
literal|"Long"
block|,
name|VectorUDAFMinLong
operator|.
name|class
block|}
block|,
block|{
literal|"min"
block|,
literal|"Double"
block|,
name|VectorUDAFMinDouble
operator|.
name|class
block|}
block|,
block|{
literal|"min"
block|,
literal|"String"
block|,
name|VectorUDAFMinString
operator|.
name|class
block|}
block|,
block|{
literal|"max"
block|,
literal|"Long"
block|,
name|VectorUDAFMaxLong
operator|.
name|class
block|}
block|,
block|{
literal|"max"
block|,
literal|"Double"
block|,
name|VectorUDAFMaxDouble
operator|.
name|class
block|}
block|,
block|{
literal|"max"
block|,
literal|"String"
block|,
name|VectorUDAFMaxString
operator|.
name|class
block|}
block|,
block|{
literal|"count"
block|,
literal|null
block|,
name|VectorUDAFCountStar
operator|.
name|class
block|}
block|,
block|{
literal|"count"
block|,
literal|"Long"
block|,
name|VectorUDAFCount
operator|.
name|class
block|}
block|,
block|{
literal|"count"
block|,
literal|"Double"
block|,
name|VectorUDAFCount
operator|.
name|class
block|}
block|,
block|{
literal|"count"
block|,
literal|"String"
block|,
name|VectorUDAFCount
operator|.
name|class
block|}
block|,
block|{
literal|"sum"
block|,
literal|"Long"
block|,
name|VectorUDAFSumLong
operator|.
name|class
block|}
block|,
block|{
literal|"sum"
block|,
literal|"Double"
block|,
name|VectorUDAFSumDouble
operator|.
name|class
block|}
block|,
block|{
literal|"avg"
block|,
literal|"Long"
block|,
name|VectorUDAFAvgLong
operator|.
name|class
block|}
block|,
block|{
literal|"avg"
block|,
literal|"Double"
block|,
name|VectorUDAFAvgDouble
operator|.
name|class
block|}
block|,
block|{
literal|"variance"
block|,
literal|"Long"
block|,
name|VectorUDAFVarPopLong
operator|.
name|class
block|}
block|,
block|{
literal|"var_pop"
block|,
literal|"Long"
block|,
name|VectorUDAFVarPopLong
operator|.
name|class
block|}
block|,
block|{
literal|"variance"
block|,
literal|"Double"
block|,
name|VectorUDAFVarPopDouble
operator|.
name|class
block|}
block|,
block|{
literal|"var_pop"
block|,
literal|"Double"
block|,
name|VectorUDAFVarPopDouble
operator|.
name|class
block|}
block|,
block|{
literal|"var_samp"
block|,
literal|"Long"
block|,
name|VectorUDAFVarSampLong
operator|.
name|class
block|}
block|,
block|{
literal|"var_samp"
block|,
literal|"Double"
block|,
name|VectorUDAFVarSampDouble
operator|.
name|class
block|}
block|,
block|{
literal|"std"
block|,
literal|"Long"
block|,
name|VectorUDAFStdPopLong
operator|.
name|class
block|}
block|,
block|{
literal|"stddev"
block|,
literal|"Long"
block|,
name|VectorUDAFStdPopLong
operator|.
name|class
block|}
block|,
block|{
literal|"stddev_pop"
block|,
literal|"Long"
block|,
name|VectorUDAFStdPopLong
operator|.
name|class
block|}
block|,
block|{
literal|"std"
block|,
literal|"Double"
block|,
name|VectorUDAFStdPopDouble
operator|.
name|class
block|}
block|,
block|{
literal|"stddev"
block|,
literal|"Double"
block|,
name|VectorUDAFStdPopDouble
operator|.
name|class
block|}
block|,
block|{
literal|"stddev_pop"
block|,
literal|"Double"
block|,
name|VectorUDAFStdPopDouble
operator|.
name|class
block|}
block|,
block|{
literal|"stddev_samp"
block|,
literal|"Long"
block|,
name|VectorUDAFStdSampLong
operator|.
name|class
block|}
block|,
block|{
literal|"stddev_samp"
block|,
literal|"Double"
block|,
name|VectorUDAFStdSampDouble
operator|.
name|class
block|}
block|,   }
decl_stmt|;
specifier|public
name|VectorAggregateExpression
name|getAggregatorExpression
parameter_list|(
name|AggregationDesc
name|desc
parameter_list|)
throws|throws
name|HiveException
block|{
name|ArrayList
argument_list|<
name|ExprNodeDesc
argument_list|>
name|paramDescList
init|=
name|desc
operator|.
name|getParameters
argument_list|()
decl_stmt|;
name|VectorExpression
index|[]
name|vectorParams
init|=
operator|new
name|VectorExpression
index|[
name|paramDescList
operator|.
name|size
argument_list|()
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|paramDescList
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|ExprNodeDesc
name|exprDesc
init|=
name|paramDescList
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|vectorParams
index|[
name|i
index|]
operator|=
name|this
operator|.
name|getVectorExpression
argument_list|(
name|exprDesc
argument_list|,
name|Mode
operator|.
name|PROJECTION
argument_list|)
expr_stmt|;
block|}
name|String
name|aggregateName
init|=
name|desc
operator|.
name|getGenericUDAFName
argument_list|()
decl_stmt|;
name|String
name|inputType
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|paramDescList
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
name|ExprNodeDesc
name|inputExpr
init|=
name|paramDescList
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|inputType
operator|=
name|getNormalizedTypeName
argument_list|(
name|inputExpr
operator|.
name|getTypeString
argument_list|()
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|Object
index|[]
name|aggDef
range|:
name|aggregatesDefinition
control|)
block|{
if|if
condition|(
name|aggregateName
operator|.
name|equalsIgnoreCase
argument_list|(
operator|(
name|String
operator|)
name|aggDef
index|[
literal|0
index|]
argument_list|)
operator|&&
operator|(
operator|(
name|aggDef
index|[
literal|1
index|]
operator|==
literal|null
operator|&&
name|inputType
operator|==
literal|null
operator|)
operator|||
operator|(
name|aggDef
index|[
literal|1
index|]
operator|!=
literal|null
operator|&&
name|aggDef
index|[
literal|1
index|]
operator|.
name|equals
argument_list|(
name|inputType
argument_list|)
operator|)
operator|)
condition|)
block|{
name|Class
argument_list|<
name|?
extends|extends
name|VectorAggregateExpression
argument_list|>
name|aggClass
init|=
call|(
name|Class
argument_list|<
name|?
extends|extends
name|VectorAggregateExpression
argument_list|>
call|)
argument_list|(
name|aggDef
index|[
literal|2
index|]
argument_list|)
decl_stmt|;
try|try
block|{
name|Constructor
argument_list|<
name|?
extends|extends
name|VectorAggregateExpression
argument_list|>
name|ctor
init|=
name|aggClass
operator|.
name|getConstructor
argument_list|(
name|VectorExpression
operator|.
name|class
argument_list|)
decl_stmt|;
name|VectorAggregateExpression
name|aggExpr
init|=
name|ctor
operator|.
name|newInstance
argument_list|(
name|vectorParams
operator|.
name|length
operator|>
literal|0
condition|?
name|vectorParams
index|[
literal|0
index|]
else|:
literal|null
argument_list|)
decl_stmt|;
name|aggExpr
operator|.
name|init
argument_list|(
name|desc
argument_list|)
expr_stmt|;
return|return
name|aggExpr
return|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|HiveException
argument_list|(
literal|"Internal exception for vector aggregate : \""
operator|+
name|aggregateName
operator|+
literal|"\" for type: \""
operator|+
name|inputType
operator|+
literal|""
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
block|}
throw|throw
operator|new
name|HiveException
argument_list|(
literal|"Vector aggregate not implemented: \""
operator|+
name|aggregateName
operator|+
literal|"\" for type: \""
operator|+
name|inputType
operator|+
literal|""
argument_list|)
throw|;
block|}
specifier|public
name|Map
argument_list|<
name|Integer
argument_list|,
name|String
argument_list|>
name|getOutputColumnTypeMap
parameter_list|()
block|{
name|Map
argument_list|<
name|Integer
argument_list|,
name|String
argument_list|>
name|map
init|=
operator|new
name|HashMap
argument_list|<
name|Integer
argument_list|,
name|String
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|ocm
operator|.
name|outputColCount
condition|;
name|i
operator|++
control|)
block|{
name|String
name|type
init|=
name|ocm
operator|.
name|outputColumnsTypes
index|[
name|i
index|]
decl_stmt|;
name|map
operator|.
name|put
argument_list|(
name|i
operator|+
name|this
operator|.
name|firstOutputColumnIndex
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
return|return
name|map
return|;
block|}
specifier|public
name|Map
argument_list|<
name|String
argument_list|,
name|Integer
argument_list|>
name|getColumnMap
parameter_list|()
block|{
return|return
name|columnMap
return|;
block|}
specifier|public
name|void
name|addToColumnMap
parameter_list|(
name|String
name|columnName
parameter_list|,
name|int
name|outputColumn
parameter_list|)
throws|throws
name|HiveException
block|{
if|if
condition|(
name|columnMap
operator|.
name|containsKey
argument_list|(
name|columnName
argument_list|)
operator|&&
operator|(
name|columnMap
operator|.
name|get
argument_list|(
name|columnName
argument_list|)
operator|!=
name|outputColumn
operator|)
condition|)
block|{
throw|throw
operator|new
name|HiveException
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"Column %s is already mapped to %d. Cannot remap to %d."
argument_list|,
name|columnName
argument_list|,
name|columnMap
operator|.
name|get
argument_list|(
name|columnName
argument_list|)
argument_list|,
name|outputColumn
argument_list|)
argument_list|)
throw|;
block|}
name|columnMap
operator|.
name|put
argument_list|(
name|columnName
argument_list|,
name|outputColumn
argument_list|)
expr_stmt|;
block|}
block|}
end_class

end_unit

