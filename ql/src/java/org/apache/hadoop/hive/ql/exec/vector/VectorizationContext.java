begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|vector
package|;
end_package

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|reflect
operator|.
name|Constructor
import|;
end_import

begin_import
import|import
name|java
operator|.
name|sql
operator|.
name|Date
import|;
end_import

begin_import
import|import
name|java
operator|.
name|sql
operator|.
name|Timestamp
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Comparator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|TreeMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|TreeSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|regex
operator|.
name|Pattern
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|lang
operator|.
name|ArrayUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|common
operator|.
name|type
operator|.
name|DataTypePhysicalVariation
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|common
operator|.
name|type
operator|.
name|HiveChar
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|common
operator|.
name|type
operator|.
name|HiveDecimal
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|common
operator|.
name|type
operator|.
name|HiveIntervalDayTime
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|common
operator|.
name|type
operator|.
name|HiveIntervalYearMonth
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|common
operator|.
name|type
operator|.
name|HiveVarchar
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|conf
operator|.
name|HiveConf
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|conf
operator|.
name|HiveConf
operator|.
name|ConfVars
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|ExprNodeEvaluator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|ExprNodeEvaluatorFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|FunctionInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|FunctionRegistry
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|UDF
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|vector
operator|.
name|ColumnVector
operator|.
name|Type
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|vector
operator|.
name|VectorExpressionDescriptor
operator|.
name|ArgumentType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|vector
operator|.
name|VectorExpressionDescriptor
operator|.
name|InputExpressionType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|vector
operator|.
name|expressions
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|vector
operator|.
name|expressions
operator|.
name|gen
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|vector
operator|.
name|udf
operator|.
name|VectorUDFAdaptor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|vector
operator|.
name|udf
operator|.
name|VectorUDFArgDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|metadata
operator|.
name|HiveException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|parse
operator|.
name|SemanticException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|ExprNodeColumnDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|ExprNodeConstantDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|ExprNodeDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|ExprNodeDynamicValueDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|ExprNodeGenericFuncDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|ExprNodeFieldDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|udf
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|udf
operator|.
name|generic
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|ByteStream
operator|.
name|Output
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|binarysortable
operator|.
name|fast
operator|.
name|BinarySortableSerializeWrite
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|io
operator|.
name|DateWritable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|io
operator|.
name|DoubleWritable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|io
operator|.
name|HiveDecimalWritable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|objectinspector
operator|.
name|ConstantObjectInspector
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|objectinspector
operator|.
name|ObjectInspector
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|objectinspector
operator|.
name|ObjectInspector
operator|.
name|Category
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|objectinspector
operator|.
name|ObjectInspectorUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|objectinspector
operator|.
name|PrimitiveObjectInspector
operator|.
name|PrimitiveCategory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|typeinfo
operator|.
name|BaseCharTypeInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|typeinfo
operator|.
name|DecimalTypeInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|typeinfo
operator|.
name|HiveDecimalUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|typeinfo
operator|.
name|PrimitiveTypeInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|typeinfo
operator|.
name|StructTypeInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|typeinfo
operator|.
name|TypeInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|typeinfo
operator|.
name|TypeInfoFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|typeinfo
operator|.
name|TypeInfoUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|IntWritable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|LongWritable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|Text
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hive
operator|.
name|common
operator|.
name|util
operator|.
name|AnnotationUtils
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|VisibleForTesting
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
import|;
end_import

begin_comment
comment|/**  * Context class for vectorization execution.  * Main role is to map column names to column indices and serves as a  * factory class for building vectorized expressions out of descriptors.  *  */
end_comment

begin_class
specifier|public
class|class
name|VectorizationContext
block|{
specifier|private
specifier|static
specifier|final
name|Logger
name|LOG
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|VectorizationContext
operator|.
name|class
operator|.
name|getName
argument_list|()
argument_list|)
decl_stmt|;
specifier|private
specifier|final
name|String
name|contextName
decl_stmt|;
specifier|private
specifier|final
name|int
name|level
decl_stmt|;
name|VectorExpressionDescriptor
name|vMap
decl_stmt|;
specifier|private
specifier|final
name|List
argument_list|<
name|String
argument_list|>
name|initialColumnNames
decl_stmt|;
specifier|private
name|List
argument_list|<
name|TypeInfo
argument_list|>
name|initialTypeInfos
decl_stmt|;
specifier|private
name|List
argument_list|<
name|DataTypePhysicalVariation
argument_list|>
name|initialDataTypePhysicalVariations
decl_stmt|;
specifier|private
name|List
argument_list|<
name|Integer
argument_list|>
name|projectedColumns
decl_stmt|;
specifier|private
name|List
argument_list|<
name|String
argument_list|>
name|projectionColumnNames
decl_stmt|;
specifier|private
name|Map
argument_list|<
name|String
argument_list|,
name|Integer
argument_list|>
name|projectionColumnMap
decl_stmt|;
comment|//columnName to column position map
comment|// private final Map<String, Integer> columnMap;
specifier|private
name|int
name|firstOutputColumnIndex
decl_stmt|;
specifier|public
enum|enum
name|HiveVectorAdaptorUsageMode
block|{
name|NONE
block|,
name|CHOSEN
block|,
name|ALL
block|;
specifier|public
specifier|static
name|HiveVectorAdaptorUsageMode
name|getHiveConfValue
parameter_list|(
name|HiveConf
name|hiveConf
parameter_list|)
block|{
name|String
name|string
init|=
name|HiveConf
operator|.
name|getVar
argument_list|(
name|hiveConf
argument_list|,
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVE_VECTOR_ADAPTOR_USAGE_MODE
argument_list|)
decl_stmt|;
return|return
name|valueOf
argument_list|(
name|string
operator|.
name|toUpperCase
argument_list|()
argument_list|)
return|;
block|}
block|}
specifier|private
name|HiveVectorAdaptorUsageMode
name|hiveVectorAdaptorUsageMode
decl_stmt|;
specifier|private
name|boolean
name|reuseScratchColumns
init|=
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVE_VECTORIZATION_TESTING_REUSE_SCRATCH_COLUMNS
operator|.
name|defaultBoolVal
decl_stmt|;
specifier|private
name|void
name|setHiveConfVars
parameter_list|(
name|HiveConf
name|hiveConf
parameter_list|)
block|{
name|hiveVectorAdaptorUsageMode
operator|=
name|HiveVectorAdaptorUsageMode
operator|.
name|getHiveConfValue
argument_list|(
name|hiveConf
argument_list|)
expr_stmt|;
name|this
operator|.
name|reuseScratchColumns
operator|=
name|HiveConf
operator|.
name|getBoolVar
argument_list|(
name|hiveConf
argument_list|,
name|ConfVars
operator|.
name|HIVE_VECTORIZATION_TESTING_REUSE_SCRATCH_COLUMNS
argument_list|)
expr_stmt|;
name|this
operator|.
name|ocm
operator|.
name|setReuseColumns
argument_list|(
name|reuseScratchColumns
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|copyHiveConfVars
parameter_list|(
name|VectorizationContext
name|vContextEnvironment
parameter_list|)
block|{
name|hiveVectorAdaptorUsageMode
operator|=
name|vContextEnvironment
operator|.
name|hiveVectorAdaptorUsageMode
expr_stmt|;
name|this
operator|.
name|reuseScratchColumns
operator|=
name|vContextEnvironment
operator|.
name|reuseScratchColumns
expr_stmt|;
name|this
operator|.
name|ocm
operator|.
name|setReuseColumns
argument_list|(
name|reuseScratchColumns
argument_list|)
expr_stmt|;
block|}
comment|// Convenient constructor for initial batch creation takes
comment|// a list of columns names and maps them to 0..n-1 indices.
specifier|public
name|VectorizationContext
parameter_list|(
name|String
name|contextName
parameter_list|,
name|List
argument_list|<
name|String
argument_list|>
name|initialColumnNames
parameter_list|,
name|List
argument_list|<
name|TypeInfo
argument_list|>
name|initialTypeInfos
parameter_list|,
name|List
argument_list|<
name|DataTypePhysicalVariation
argument_list|>
name|initialDataTypePhysicalVariations
parameter_list|,
name|HiveConf
name|hiveConf
parameter_list|)
block|{
name|this
operator|.
name|contextName
operator|=
name|contextName
expr_stmt|;
name|level
operator|=
literal|0
expr_stmt|;
name|this
operator|.
name|initialColumnNames
operator|=
name|initialColumnNames
expr_stmt|;
name|this
operator|.
name|initialTypeInfos
operator|=
name|initialTypeInfos
expr_stmt|;
name|this
operator|.
name|initialDataTypePhysicalVariations
operator|=
name|initialDataTypePhysicalVariations
expr_stmt|;
name|this
operator|.
name|projectionColumnNames
operator|=
name|initialColumnNames
expr_stmt|;
name|projectedColumns
operator|=
operator|new
name|ArrayList
argument_list|<
name|Integer
argument_list|>
argument_list|()
expr_stmt|;
name|projectionColumnMap
operator|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|Integer
argument_list|>
argument_list|()
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|this
operator|.
name|projectionColumnNames
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|projectedColumns
operator|.
name|add
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|projectionColumnMap
operator|.
name|put
argument_list|(
name|projectionColumnNames
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
name|int
name|firstOutputColumnIndex
init|=
name|projectedColumns
operator|.
name|size
argument_list|()
decl_stmt|;
name|this
operator|.
name|ocm
operator|=
operator|new
name|OutputColumnManager
argument_list|(
name|firstOutputColumnIndex
argument_list|)
expr_stmt|;
name|this
operator|.
name|firstOutputColumnIndex
operator|=
name|firstOutputColumnIndex
expr_stmt|;
name|vMap
operator|=
operator|new
name|VectorExpressionDescriptor
argument_list|()
expr_stmt|;
if|if
condition|(
name|hiveConf
operator|!=
literal|null
condition|)
block|{
name|setHiveConfVars
argument_list|(
name|hiveConf
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Convenient constructor for initial batch creation takes
comment|// a list of columns names and maps them to 0..n-1 indices.
specifier|public
name|VectorizationContext
parameter_list|(
name|String
name|contextName
parameter_list|,
name|List
argument_list|<
name|String
argument_list|>
name|initialColumnNames
parameter_list|,
name|HiveConf
name|hiveConf
parameter_list|)
block|{
name|this
operator|.
name|contextName
operator|=
name|contextName
expr_stmt|;
name|level
operator|=
literal|0
expr_stmt|;
name|this
operator|.
name|initialColumnNames
operator|=
name|initialColumnNames
expr_stmt|;
name|this
operator|.
name|projectionColumnNames
operator|=
name|initialColumnNames
expr_stmt|;
name|projectedColumns
operator|=
operator|new
name|ArrayList
argument_list|<
name|Integer
argument_list|>
argument_list|()
expr_stmt|;
name|projectionColumnMap
operator|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|Integer
argument_list|>
argument_list|()
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|this
operator|.
name|projectionColumnNames
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|projectedColumns
operator|.
name|add
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|projectionColumnMap
operator|.
name|put
argument_list|(
name|projectionColumnNames
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
name|int
name|firstOutputColumnIndex
init|=
name|projectedColumns
operator|.
name|size
argument_list|()
decl_stmt|;
name|this
operator|.
name|ocm
operator|=
operator|new
name|OutputColumnManager
argument_list|(
name|firstOutputColumnIndex
argument_list|)
expr_stmt|;
name|this
operator|.
name|firstOutputColumnIndex
operator|=
name|firstOutputColumnIndex
expr_stmt|;
name|vMap
operator|=
operator|new
name|VectorExpressionDescriptor
argument_list|()
expr_stmt|;
if|if
condition|(
name|hiveConf
operator|!=
literal|null
condition|)
block|{
name|setHiveConfVars
argument_list|(
name|hiveConf
argument_list|)
expr_stmt|;
block|}
block|}
specifier|public
name|VectorizationContext
parameter_list|(
name|String
name|contextName
parameter_list|,
name|List
argument_list|<
name|String
argument_list|>
name|initialColumnNames
parameter_list|,
name|VectorizationContext
name|vContextEnvironment
parameter_list|)
block|{
name|this
argument_list|(
name|contextName
argument_list|,
name|initialColumnNames
argument_list|,
operator|(
name|HiveConf
operator|)
literal|null
argument_list|)
expr_stmt|;
name|copyHiveConfVars
argument_list|(
name|vContextEnvironment
argument_list|)
expr_stmt|;
block|}
annotation|@
name|VisibleForTesting
specifier|public
name|VectorizationContext
parameter_list|(
name|String
name|contextName
parameter_list|,
name|List
argument_list|<
name|String
argument_list|>
name|initialColumnNames
parameter_list|)
block|{
name|this
argument_list|(
name|contextName
argument_list|,
name|initialColumnNames
argument_list|,
operator|(
name|HiveConf
operator|)
literal|null
argument_list|)
expr_stmt|;
block|}
comment|// Constructor to with the individual addInitialColumn method
comment|// followed by a call to finishedAddingInitialColumns.
specifier|public
name|VectorizationContext
parameter_list|(
name|String
name|contextName
parameter_list|,
name|HiveConf
name|hiveConf
parameter_list|)
block|{
name|this
operator|.
name|contextName
operator|=
name|contextName
expr_stmt|;
name|level
operator|=
literal|0
expr_stmt|;
name|initialColumnNames
operator|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
expr_stmt|;
name|projectedColumns
operator|=
operator|new
name|ArrayList
argument_list|<
name|Integer
argument_list|>
argument_list|()
expr_stmt|;
name|projectionColumnNames
operator|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
expr_stmt|;
name|projectionColumnMap
operator|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|Integer
argument_list|>
argument_list|()
expr_stmt|;
name|this
operator|.
name|ocm
operator|=
operator|new
name|OutputColumnManager
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|this
operator|.
name|firstOutputColumnIndex
operator|=
literal|0
expr_stmt|;
name|vMap
operator|=
operator|new
name|VectorExpressionDescriptor
argument_list|()
expr_stmt|;
if|if
condition|(
name|hiveConf
operator|!=
literal|null
condition|)
block|{
name|setHiveConfVars
argument_list|(
name|hiveConf
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|VisibleForTesting
specifier|public
name|VectorizationContext
parameter_list|(
name|String
name|contextName
parameter_list|)
block|{
name|this
argument_list|(
name|contextName
argument_list|,
operator|(
name|HiveConf
operator|)
literal|null
argument_list|)
expr_stmt|;
block|}
comment|// Constructor useful making a projection vectorization context.  E.g. VectorSelectOperator.
comment|// Use with resetProjectionColumns and addProjectionColumn.
comment|// Keeps existing output column map, etc.
specifier|public
name|VectorizationContext
parameter_list|(
name|String
name|contextName
parameter_list|,
name|VectorizationContext
name|vContext
parameter_list|)
block|{
name|this
operator|.
name|contextName
operator|=
name|contextName
expr_stmt|;
name|level
operator|=
name|vContext
operator|.
name|level
operator|+
literal|1
expr_stmt|;
name|this
operator|.
name|initialColumnNames
operator|=
name|vContext
operator|.
name|initialColumnNames
expr_stmt|;
name|this
operator|.
name|initialTypeInfos
operator|=
name|vContext
operator|.
name|initialTypeInfos
expr_stmt|;
name|this
operator|.
name|initialDataTypePhysicalVariations
operator|=
name|vContext
operator|.
name|initialDataTypePhysicalVariations
expr_stmt|;
name|this
operator|.
name|projectedColumns
operator|=
operator|new
name|ArrayList
argument_list|<
name|Integer
argument_list|>
argument_list|()
expr_stmt|;
name|this
operator|.
name|projectionColumnNames
operator|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
expr_stmt|;
name|this
operator|.
name|projectionColumnMap
operator|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|Integer
argument_list|>
argument_list|()
expr_stmt|;
name|this
operator|.
name|ocm
operator|=
name|vContext
operator|.
name|ocm
expr_stmt|;
name|this
operator|.
name|firstOutputColumnIndex
operator|=
name|vContext
operator|.
name|firstOutputColumnIndex
expr_stmt|;
name|vMap
operator|=
operator|new
name|VectorExpressionDescriptor
argument_list|()
expr_stmt|;
name|copyHiveConfVars
argument_list|(
name|vContext
argument_list|)
expr_stmt|;
block|}
comment|// Add an initial column to a vectorization context when
comment|// a vectorized row batch is being created.
specifier|public
name|void
name|addInitialColumn
parameter_list|(
name|String
name|columnName
parameter_list|)
block|{
name|initialColumnNames
operator|.
name|add
argument_list|(
name|columnName
argument_list|)
expr_stmt|;
name|int
name|index
init|=
name|projectedColumns
operator|.
name|size
argument_list|()
decl_stmt|;
name|projectedColumns
operator|.
name|add
argument_list|(
name|index
argument_list|)
expr_stmt|;
name|projectionColumnNames
operator|.
name|add
argument_list|(
name|columnName
argument_list|)
expr_stmt|;
name|projectionColumnMap
operator|.
name|put
argument_list|(
name|columnName
argument_list|,
name|index
argument_list|)
expr_stmt|;
block|}
comment|// Finishes the vectorization context after all the initial
comment|// columns have been added.
annotation|@
name|VisibleForTesting
specifier|public
name|void
name|finishedAddingInitialColumns
parameter_list|()
block|{
name|int
name|firstOutputColumnIndex
init|=
name|projectedColumns
operator|.
name|size
argument_list|()
decl_stmt|;
name|this
operator|.
name|ocm
operator|=
operator|new
name|OutputColumnManager
argument_list|(
name|firstOutputColumnIndex
argument_list|)
expr_stmt|;
name|this
operator|.
name|ocm
operator|.
name|setReuseColumns
argument_list|(
name|this
operator|.
name|reuseScratchColumns
argument_list|)
expr_stmt|;
name|this
operator|.
name|firstOutputColumnIndex
operator|=
name|firstOutputColumnIndex
expr_stmt|;
block|}
comment|// Empties the projection columns.
specifier|public
name|void
name|resetProjectionColumns
parameter_list|()
block|{
name|projectedColumns
operator|=
operator|new
name|ArrayList
argument_list|<
name|Integer
argument_list|>
argument_list|()
expr_stmt|;
name|projectionColumnNames
operator|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
expr_stmt|;
name|projectionColumnMap
operator|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|Integer
argument_list|>
argument_list|()
expr_stmt|;
block|}
comment|// Add a projection column to a projection vectorization context.
specifier|public
name|void
name|addProjectionColumn
parameter_list|(
name|String
name|columnName
parameter_list|,
name|int
name|vectorBatchColIndex
parameter_list|)
block|{
if|if
condition|(
name|vectorBatchColIndex
operator|<
literal|0
condition|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Negative projected column number"
argument_list|)
throw|;
block|}
name|projectedColumns
operator|.
name|add
argument_list|(
name|vectorBatchColIndex
argument_list|)
expr_stmt|;
name|projectionColumnNames
operator|.
name|add
argument_list|(
name|columnName
argument_list|)
expr_stmt|;
name|projectionColumnMap
operator|.
name|put
argument_list|(
name|columnName
argument_list|,
name|vectorBatchColIndex
argument_list|)
expr_stmt|;
block|}
specifier|public
name|void
name|setInitialTypeInfos
parameter_list|(
name|List
argument_list|<
name|TypeInfo
argument_list|>
name|initialTypeInfos
parameter_list|)
block|{
name|this
operator|.
name|initialTypeInfos
operator|=
name|initialTypeInfos
expr_stmt|;
specifier|final
name|int
name|size
init|=
name|initialTypeInfos
operator|.
name|size
argument_list|()
decl_stmt|;
name|initialDataTypePhysicalVariations
operator|=
operator|new
name|ArrayList
argument_list|<
name|DataTypePhysicalVariation
argument_list|>
argument_list|(
name|size
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|size
condition|;
name|i
operator|++
control|)
block|{
name|initialDataTypePhysicalVariations
operator|.
name|add
argument_list|(
name|DataTypePhysicalVariation
operator|.
name|NONE
argument_list|)
expr_stmt|;
block|}
block|}
specifier|public
name|void
name|setInitialDataTypePhysicalVariations
parameter_list|(
name|List
argument_list|<
name|DataTypePhysicalVariation
argument_list|>
name|initialDataTypePhysicalVariations
parameter_list|)
block|{
name|this
operator|.
name|initialDataTypePhysicalVariations
operator|=
name|initialDataTypePhysicalVariations
expr_stmt|;
block|}
specifier|public
name|List
argument_list|<
name|String
argument_list|>
name|getInitialColumnNames
parameter_list|()
block|{
return|return
name|initialColumnNames
return|;
block|}
specifier|public
name|List
argument_list|<
name|Integer
argument_list|>
name|getProjectedColumns
parameter_list|()
block|{
return|return
name|projectedColumns
return|;
block|}
specifier|public
name|List
argument_list|<
name|String
argument_list|>
name|getProjectionColumnNames
parameter_list|()
block|{
return|return
name|projectionColumnNames
return|;
block|}
specifier|public
name|Map
argument_list|<
name|String
argument_list|,
name|Integer
argument_list|>
name|getProjectionColumnMap
parameter_list|()
block|{
return|return
name|projectionColumnMap
return|;
block|}
specifier|public
name|TypeInfo
index|[]
name|getInitialTypeInfos
parameter_list|()
block|{
return|return
name|initialTypeInfos
operator|.
name|toArray
argument_list|(
operator|new
name|TypeInfo
index|[
literal|0
index|]
argument_list|)
return|;
block|}
specifier|public
name|TypeInfo
name|getTypeInfo
parameter_list|(
name|int
name|columnNum
parameter_list|)
throws|throws
name|HiveException
block|{
if|if
condition|(
name|initialTypeInfos
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|HiveException
argument_list|(
literal|"initialTypeInfos array is null in contextName "
operator|+
name|contextName
argument_list|)
throw|;
block|}
specifier|final
name|int
name|initialSize
init|=
name|initialTypeInfos
operator|.
name|size
argument_list|()
decl_stmt|;
if|if
condition|(
name|columnNum
operator|<
name|initialSize
condition|)
block|{
return|return
name|initialTypeInfos
operator|.
name|get
argument_list|(
name|columnNum
argument_list|)
return|;
block|}
else|else
block|{
name|String
name|typeName
init|=
name|ocm
operator|.
name|getScratchTypeName
argument_list|(
name|columnNum
argument_list|)
decl_stmt|;
comment|// Replace unparsable synonyms.
name|typeName
operator|=
name|VectorizationContext
operator|.
name|mapTypeNameSynonyms
argument_list|(
name|typeName
argument_list|)
expr_stmt|;
comment|// Make CHAR and VARCHAR type info parsable.
if|if
condition|(
name|typeName
operator|.
name|equals
argument_list|(
literal|"char"
argument_list|)
condition|)
block|{
name|typeName
operator|=
literal|"char("
operator|+
name|HiveChar
operator|.
name|MAX_CHAR_LENGTH
operator|+
literal|")"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|typeName
operator|.
name|equals
argument_list|(
literal|"varchar"
argument_list|)
condition|)
block|{
name|typeName
operator|=
literal|"varchar("
operator|+
name|HiveVarchar
operator|.
name|MAX_VARCHAR_LENGTH
operator|+
literal|")"
expr_stmt|;
block|}
name|TypeInfo
name|typeInfo
init|=
name|TypeInfoUtils
operator|.
name|getTypeInfoFromTypeString
argument_list|(
name|typeName
argument_list|)
decl_stmt|;
return|return
name|typeInfo
return|;
block|}
block|}
specifier|public
name|DataTypePhysicalVariation
name|getDataTypePhysicalVariation
parameter_list|(
name|int
name|columnNum
parameter_list|)
throws|throws
name|HiveException
block|{
if|if
condition|(
name|initialDataTypePhysicalVariations
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
if|if
condition|(
name|columnNum
operator|<
literal|0
condition|)
block|{
name|fake
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|columnNum
operator|<
name|initialDataTypePhysicalVariations
operator|.
name|size
argument_list|()
condition|)
block|{
return|return
name|initialDataTypePhysicalVariations
operator|.
name|get
argument_list|(
name|columnNum
argument_list|)
return|;
block|}
return|return
name|ocm
operator|.
name|getDataTypePhysicalVariation
argument_list|(
name|columnNum
argument_list|)
return|;
block|}
specifier|public
name|TypeInfo
index|[]
name|getAllTypeInfos
parameter_list|()
throws|throws
name|HiveException
block|{
specifier|final
name|int
name|size
init|=
name|initialTypeInfos
operator|.
name|size
argument_list|()
operator|+
name|ocm
operator|.
name|outputColCount
decl_stmt|;
name|TypeInfo
index|[]
name|result
init|=
operator|new
name|TypeInfo
index|[
name|size
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|size
condition|;
name|i
operator|++
control|)
block|{
name|result
index|[
name|i
index|]
operator|=
name|getTypeInfo
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
specifier|public
specifier|static
specifier|final
name|Pattern
name|decimalTypePattern
init|=
name|Pattern
operator|.
name|compile
argument_list|(
literal|"decimal.*"
argument_list|,
name|Pattern
operator|.
name|CASE_INSENSITIVE
argument_list|)
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|Pattern
name|charTypePattern
init|=
name|Pattern
operator|.
name|compile
argument_list|(
literal|"char.*"
argument_list|,
name|Pattern
operator|.
name|CASE_INSENSITIVE
argument_list|)
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|Pattern
name|varcharTypePattern
init|=
name|Pattern
operator|.
name|compile
argument_list|(
literal|"varchar.*"
argument_list|,
name|Pattern
operator|.
name|CASE_INSENSITIVE
argument_list|)
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|Pattern
name|charVarcharTypePattern
init|=
name|Pattern
operator|.
name|compile
argument_list|(
literal|"char.*|varchar.*"
argument_list|,
name|Pattern
operator|.
name|CASE_INSENSITIVE
argument_list|)
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|Pattern
name|structTypePattern
init|=
name|Pattern
operator|.
name|compile
argument_list|(
literal|"struct.*"
argument_list|,
name|Pattern
operator|.
name|CASE_INSENSITIVE
argument_list|)
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|Pattern
name|listTypePattern
init|=
name|Pattern
operator|.
name|compile
argument_list|(
literal|"array.*"
argument_list|,
name|Pattern
operator|.
name|CASE_INSENSITIVE
argument_list|)
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|Pattern
name|mapTypePattern
init|=
name|Pattern
operator|.
name|compile
argument_list|(
literal|"map.*"
argument_list|,
name|Pattern
operator|.
name|CASE_INSENSITIVE
argument_list|)
decl_stmt|;
comment|//Map column number to type (this is always non-null for a useful vec context)
specifier|private
name|OutputColumnManager
name|ocm
decl_stmt|;
comment|// Set of UDF classes for type casting data types in row-mode.
specifier|private
specifier|static
name|Set
argument_list|<
name|Class
argument_list|<
name|?
argument_list|>
argument_list|>
name|castExpressionUdfs
init|=
operator|new
name|HashSet
argument_list|<
name|Class
argument_list|<
name|?
argument_list|>
argument_list|>
argument_list|()
decl_stmt|;
static|static
block|{
name|castExpressionUdfs
operator|.
name|add
argument_list|(
name|GenericUDFToDecimal
operator|.
name|class
argument_list|)
expr_stmt|;
name|castExpressionUdfs
operator|.
name|add
argument_list|(
name|GenericUDFToBinary
operator|.
name|class
argument_list|)
expr_stmt|;
name|castExpressionUdfs
operator|.
name|add
argument_list|(
name|GenericUDFToDate
operator|.
name|class
argument_list|)
expr_stmt|;
name|castExpressionUdfs
operator|.
name|add
argument_list|(
name|GenericUDFToUnixTimeStamp
operator|.
name|class
argument_list|)
expr_stmt|;
name|castExpressionUdfs
operator|.
name|add
argument_list|(
name|GenericUDFToUtcTimestamp
operator|.
name|class
argument_list|)
expr_stmt|;
name|castExpressionUdfs
operator|.
name|add
argument_list|(
name|GenericUDFToChar
operator|.
name|class
argument_list|)
expr_stmt|;
name|castExpressionUdfs
operator|.
name|add
argument_list|(
name|GenericUDFToVarchar
operator|.
name|class
argument_list|)
expr_stmt|;
name|castExpressionUdfs
operator|.
name|add
argument_list|(
name|GenericUDFTimestamp
operator|.
name|class
argument_list|)
expr_stmt|;
name|castExpressionUdfs
operator|.
name|add
argument_list|(
name|GenericUDFToIntervalYearMonth
operator|.
name|class
argument_list|)
expr_stmt|;
name|castExpressionUdfs
operator|.
name|add
argument_list|(
name|GenericUDFToIntervalDayTime
operator|.
name|class
argument_list|)
expr_stmt|;
name|castExpressionUdfs
operator|.
name|add
argument_list|(
name|UDFToByte
operator|.
name|class
argument_list|)
expr_stmt|;
name|castExpressionUdfs
operator|.
name|add
argument_list|(
name|UDFToBoolean
operator|.
name|class
argument_list|)
expr_stmt|;
name|castExpressionUdfs
operator|.
name|add
argument_list|(
name|UDFToDouble
operator|.
name|class
argument_list|)
expr_stmt|;
name|castExpressionUdfs
operator|.
name|add
argument_list|(
name|UDFToFloat
operator|.
name|class
argument_list|)
expr_stmt|;
name|castExpressionUdfs
operator|.
name|add
argument_list|(
name|UDFToString
operator|.
name|class
argument_list|)
expr_stmt|;
name|castExpressionUdfs
operator|.
name|add
argument_list|(
name|UDFToInteger
operator|.
name|class
argument_list|)
expr_stmt|;
name|castExpressionUdfs
operator|.
name|add
argument_list|(
name|UDFToLong
operator|.
name|class
argument_list|)
expr_stmt|;
name|castExpressionUdfs
operator|.
name|add
argument_list|(
name|UDFToShort
operator|.
name|class
argument_list|)
expr_stmt|;
block|}
comment|// Set of GenericUDFs which require need implicit type casting of decimal parameters.
comment|// Vectorization for mathmatical functions currently depends on decimal params automatically
comment|// being converted to the return type (see getImplicitCastExpression()), which is not correct
comment|// in the general case. This set restricts automatic type conversion to just these functions.
specifier|private
specifier|static
name|Set
argument_list|<
name|Class
argument_list|<
name|?
argument_list|>
argument_list|>
name|udfsNeedingImplicitDecimalCast
init|=
operator|new
name|HashSet
argument_list|<
name|Class
argument_list|<
name|?
argument_list|>
argument_list|>
argument_list|()
decl_stmt|;
static|static
block|{
name|udfsNeedingImplicitDecimalCast
operator|.
name|add
argument_list|(
name|GenericUDFOPPlus
operator|.
name|class
argument_list|)
expr_stmt|;
name|udfsNeedingImplicitDecimalCast
operator|.
name|add
argument_list|(
name|GenericUDFOPMinus
operator|.
name|class
argument_list|)
expr_stmt|;
name|udfsNeedingImplicitDecimalCast
operator|.
name|add
argument_list|(
name|GenericUDFOPMultiply
operator|.
name|class
argument_list|)
expr_stmt|;
name|udfsNeedingImplicitDecimalCast
operator|.
name|add
argument_list|(
name|GenericUDFOPDivide
operator|.
name|class
argument_list|)
expr_stmt|;
name|udfsNeedingImplicitDecimalCast
operator|.
name|add
argument_list|(
name|GenericUDFOPMod
operator|.
name|class
argument_list|)
expr_stmt|;
name|udfsNeedingImplicitDecimalCast
operator|.
name|add
argument_list|(
name|GenericUDFRound
operator|.
name|class
argument_list|)
expr_stmt|;
name|udfsNeedingImplicitDecimalCast
operator|.
name|add
argument_list|(
name|GenericUDFBRound
operator|.
name|class
argument_list|)
expr_stmt|;
name|udfsNeedingImplicitDecimalCast
operator|.
name|add
argument_list|(
name|GenericUDFFloor
operator|.
name|class
argument_list|)
expr_stmt|;
name|udfsNeedingImplicitDecimalCast
operator|.
name|add
argument_list|(
name|GenericUDFCbrt
operator|.
name|class
argument_list|)
expr_stmt|;
name|udfsNeedingImplicitDecimalCast
operator|.
name|add
argument_list|(
name|GenericUDFCeil
operator|.
name|class
argument_list|)
expr_stmt|;
name|udfsNeedingImplicitDecimalCast
operator|.
name|add
argument_list|(
name|GenericUDFAbs
operator|.
name|class
argument_list|)
expr_stmt|;
name|udfsNeedingImplicitDecimalCast
operator|.
name|add
argument_list|(
name|GenericUDFPosMod
operator|.
name|class
argument_list|)
expr_stmt|;
name|udfsNeedingImplicitDecimalCast
operator|.
name|add
argument_list|(
name|GenericUDFPower
operator|.
name|class
argument_list|)
expr_stmt|;
name|udfsNeedingImplicitDecimalCast
operator|.
name|add
argument_list|(
name|GenericUDFFactorial
operator|.
name|class
argument_list|)
expr_stmt|;
name|udfsNeedingImplicitDecimalCast
operator|.
name|add
argument_list|(
name|GenericUDFOPPositive
operator|.
name|class
argument_list|)
expr_stmt|;
name|udfsNeedingImplicitDecimalCast
operator|.
name|add
argument_list|(
name|GenericUDFOPNegative
operator|.
name|class
argument_list|)
expr_stmt|;
name|udfsNeedingImplicitDecimalCast
operator|.
name|add
argument_list|(
name|GenericUDFCoalesce
operator|.
name|class
argument_list|)
expr_stmt|;
name|udfsNeedingImplicitDecimalCast
operator|.
name|add
argument_list|(
name|GenericUDFElt
operator|.
name|class
argument_list|)
expr_stmt|;
name|udfsNeedingImplicitDecimalCast
operator|.
name|add
argument_list|(
name|GenericUDFGreatest
operator|.
name|class
argument_list|)
expr_stmt|;
name|udfsNeedingImplicitDecimalCast
operator|.
name|add
argument_list|(
name|GenericUDFLeast
operator|.
name|class
argument_list|)
expr_stmt|;
name|udfsNeedingImplicitDecimalCast
operator|.
name|add
argument_list|(
name|GenericUDFIn
operator|.
name|class
argument_list|)
expr_stmt|;
name|udfsNeedingImplicitDecimalCast
operator|.
name|add
argument_list|(
name|GenericUDFOPEqual
operator|.
name|class
argument_list|)
expr_stmt|;
name|udfsNeedingImplicitDecimalCast
operator|.
name|add
argument_list|(
name|GenericUDFOPEqualNS
operator|.
name|class
argument_list|)
expr_stmt|;
name|udfsNeedingImplicitDecimalCast
operator|.
name|add
argument_list|(
name|GenericUDFOPNotEqual
operator|.
name|class
argument_list|)
expr_stmt|;
name|udfsNeedingImplicitDecimalCast
operator|.
name|add
argument_list|(
name|GenericUDFOPLessThan
operator|.
name|class
argument_list|)
expr_stmt|;
name|udfsNeedingImplicitDecimalCast
operator|.
name|add
argument_list|(
name|GenericUDFOPEqualOrLessThan
operator|.
name|class
argument_list|)
expr_stmt|;
name|udfsNeedingImplicitDecimalCast
operator|.
name|add
argument_list|(
name|GenericUDFOPGreaterThan
operator|.
name|class
argument_list|)
expr_stmt|;
name|udfsNeedingImplicitDecimalCast
operator|.
name|add
argument_list|(
name|GenericUDFOPEqualOrGreaterThan
operator|.
name|class
argument_list|)
expr_stmt|;
name|udfsNeedingImplicitDecimalCast
operator|.
name|add
argument_list|(
name|GenericUDFBetween
operator|.
name|class
argument_list|)
expr_stmt|;
name|udfsNeedingImplicitDecimalCast
operator|.
name|add
argument_list|(
name|UDFSqrt
operator|.
name|class
argument_list|)
expr_stmt|;
name|udfsNeedingImplicitDecimalCast
operator|.
name|add
argument_list|(
name|UDFRand
operator|.
name|class
argument_list|)
expr_stmt|;
name|udfsNeedingImplicitDecimalCast
operator|.
name|add
argument_list|(
name|UDFLn
operator|.
name|class
argument_list|)
expr_stmt|;
name|udfsNeedingImplicitDecimalCast
operator|.
name|add
argument_list|(
name|UDFLog2
operator|.
name|class
argument_list|)
expr_stmt|;
name|udfsNeedingImplicitDecimalCast
operator|.
name|add
argument_list|(
name|UDFSin
operator|.
name|class
argument_list|)
expr_stmt|;
name|udfsNeedingImplicitDecimalCast
operator|.
name|add
argument_list|(
name|UDFAsin
operator|.
name|class
argument_list|)
expr_stmt|;
name|udfsNeedingImplicitDecimalCast
operator|.
name|add
argument_list|(
name|UDFCos
operator|.
name|class
argument_list|)
expr_stmt|;
name|udfsNeedingImplicitDecimalCast
operator|.
name|add
argument_list|(
name|UDFAcos
operator|.
name|class
argument_list|)
expr_stmt|;
name|udfsNeedingImplicitDecimalCast
operator|.
name|add
argument_list|(
name|UDFLog10
operator|.
name|class
argument_list|)
expr_stmt|;
name|udfsNeedingImplicitDecimalCast
operator|.
name|add
argument_list|(
name|UDFLog
operator|.
name|class
argument_list|)
expr_stmt|;
name|udfsNeedingImplicitDecimalCast
operator|.
name|add
argument_list|(
name|UDFExp
operator|.
name|class
argument_list|)
expr_stmt|;
name|udfsNeedingImplicitDecimalCast
operator|.
name|add
argument_list|(
name|UDFDegrees
operator|.
name|class
argument_list|)
expr_stmt|;
name|udfsNeedingImplicitDecimalCast
operator|.
name|add
argument_list|(
name|UDFRadians
operator|.
name|class
argument_list|)
expr_stmt|;
name|udfsNeedingImplicitDecimalCast
operator|.
name|add
argument_list|(
name|UDFAtan
operator|.
name|class
argument_list|)
expr_stmt|;
name|udfsNeedingImplicitDecimalCast
operator|.
name|add
argument_list|(
name|UDFTan
operator|.
name|class
argument_list|)
expr_stmt|;
name|udfsNeedingImplicitDecimalCast
operator|.
name|add
argument_list|(
name|UDFOPLongDivide
operator|.
name|class
argument_list|)
expr_stmt|;
block|}
specifier|protected
name|boolean
name|needsImplicitCastForDecimal
parameter_list|(
name|GenericUDF
name|udf
parameter_list|)
block|{
name|Class
argument_list|<
name|?
argument_list|>
name|udfClass
init|=
name|udf
operator|.
name|getClass
argument_list|()
decl_stmt|;
if|if
condition|(
name|udf
operator|instanceof
name|GenericUDFBridge
condition|)
block|{
name|udfClass
operator|=
operator|(
operator|(
name|GenericUDFBridge
operator|)
name|udf
operator|)
operator|.
name|getUdfClass
argument_list|()
expr_stmt|;
block|}
return|return
name|udfsNeedingImplicitDecimalCast
operator|.
name|contains
argument_list|(
name|udfClass
argument_list|)
return|;
block|}
specifier|public
name|int
name|getInputColumnIndex
parameter_list|(
name|String
name|name
parameter_list|)
throws|throws
name|HiveException
block|{
if|if
condition|(
name|name
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|HiveException
argument_list|(
literal|"Null column name"
argument_list|)
throw|;
block|}
if|if
condition|(
operator|!
name|projectionColumnMap
operator|.
name|containsKey
argument_list|(
name|name
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|HiveException
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"The column %s is not in the vectorization context column map %s."
argument_list|,
name|name
argument_list|,
name|projectionColumnMap
operator|.
name|toString
argument_list|()
argument_list|)
argument_list|)
throw|;
block|}
specifier|final
name|int
name|projectedColumnNum
init|=
name|projectionColumnMap
operator|.
name|get
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|projectedColumnNum
operator|<
literal|0
condition|)
block|{
throw|throw
operator|new
name|HiveException
argument_list|(
literal|"Negative projected column number"
argument_list|)
throw|;
block|}
return|return
name|projectedColumnNum
return|;
block|}
specifier|protected
name|int
name|getInputColumnIndex
parameter_list|(
name|ExprNodeColumnDesc
name|colExpr
parameter_list|)
throws|throws
name|HiveException
block|{
comment|// Call the regular method since it does error checking.
return|return
name|getInputColumnIndex
argument_list|(
name|colExpr
operator|.
name|getColumn
argument_list|()
argument_list|)
return|;
block|}
specifier|private
specifier|static
class|class
name|OutputColumnManager
block|{
specifier|private
specifier|final
name|int
name|initialOutputCol
decl_stmt|;
specifier|private
name|int
name|outputColCount
init|=
literal|0
decl_stmt|;
specifier|private
name|boolean
name|reuseScratchColumns
init|=
literal|true
decl_stmt|;
specifier|protected
name|OutputColumnManager
parameter_list|(
name|int
name|initialOutputCol
parameter_list|)
block|{
name|this
operator|.
name|initialOutputCol
operator|=
name|initialOutputCol
expr_stmt|;
block|}
comment|//The complete list of output columns. These should be added to the
comment|//Vectorized row batch for processing. The index in the row batch is
comment|//equal to the index in this array plus initialOutputCol.
comment|//Start with size 100 and double when needed.
specifier|private
name|String
index|[]
name|scratchVectorTypeNames
init|=
operator|new
name|String
index|[
literal|100
index|]
decl_stmt|;
specifier|private
name|DataTypePhysicalVariation
index|[]
name|scratchDataTypePhysicalVariations
init|=
operator|new
name|DataTypePhysicalVariation
index|[
literal|100
index|]
decl_stmt|;
specifier|private
specifier|final
name|Set
argument_list|<
name|Integer
argument_list|>
name|usedOutputColumns
init|=
operator|new
name|HashSet
argument_list|<
name|Integer
argument_list|>
argument_list|()
decl_stmt|;
name|int
name|allocateOutputColumn
parameter_list|(
name|TypeInfo
name|typeInfo
parameter_list|)
throws|throws
name|HiveException
block|{
return|return
name|allocateOutputColumn
argument_list|(
name|typeInfo
argument_list|,
name|DataTypePhysicalVariation
operator|.
name|NONE
argument_list|)
return|;
block|}
name|int
name|allocateOutputColumn
parameter_list|(
name|TypeInfo
name|typeInfo
parameter_list|,
name|DataTypePhysicalVariation
name|dataTypePhysicalVariation
parameter_list|)
throws|throws
name|HiveException
block|{
if|if
condition|(
name|initialOutputCol
operator|<
literal|0
condition|)
block|{
comment|// This is a test calling.
return|return
literal|0
return|;
block|}
comment|// CONCERN: We currently differentiate DECIMAL columns by their precision and scale...,
comment|// which could lead to a lot of extra unnecessary scratch columns.
name|String
name|vectorTypeName
init|=
name|getScratchName
argument_list|(
name|typeInfo
argument_list|)
decl_stmt|;
name|int
name|relativeCol
init|=
name|allocateOutputColumnInternal
argument_list|(
name|vectorTypeName
argument_list|,
name|dataTypePhysicalVariation
argument_list|)
decl_stmt|;
return|return
name|initialOutputCol
operator|+
name|relativeCol
return|;
block|}
specifier|private
name|int
name|allocateOutputColumnInternal
parameter_list|(
name|String
name|columnType
parameter_list|,
name|DataTypePhysicalVariation
name|dataTypePhysicalVariation
parameter_list|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|outputColCount
condition|;
name|i
operator|++
control|)
block|{
comment|// Re-use an existing, available column of the same required type.
if|if
condition|(
name|usedOutputColumns
operator|.
name|contains
argument_list|(
name|i
argument_list|)
operator|||
operator|!
operator|(
name|scratchVectorTypeNames
operator|)
index|[
name|i
index|]
operator|.
name|equalsIgnoreCase
argument_list|(
name|columnType
argument_list|)
operator|&&
name|scratchDataTypePhysicalVariations
index|[
name|i
index|]
operator|==
name|dataTypePhysicalVariation
condition|)
block|{
continue|continue;
block|}
comment|//Use i
name|usedOutputColumns
operator|.
name|add
argument_list|(
name|i
argument_list|)
expr_stmt|;
return|return
name|i
return|;
block|}
comment|//Out of allocated columns
if|if
condition|(
name|outputColCount
operator|<
name|scratchVectorTypeNames
operator|.
name|length
condition|)
block|{
name|int
name|newIndex
init|=
name|outputColCount
decl_stmt|;
name|scratchVectorTypeNames
index|[
name|outputColCount
index|]
operator|=
name|columnType
expr_stmt|;
name|scratchDataTypePhysicalVariations
index|[
name|outputColCount
operator|++
index|]
operator|=
name|dataTypePhysicalVariation
expr_stmt|;
name|usedOutputColumns
operator|.
name|add
argument_list|(
name|newIndex
argument_list|)
expr_stmt|;
return|return
name|newIndex
return|;
block|}
else|else
block|{
comment|//Expand the array
name|scratchVectorTypeNames
operator|=
name|Arrays
operator|.
name|copyOf
argument_list|(
name|scratchVectorTypeNames
argument_list|,
literal|2
operator|*
name|outputColCount
argument_list|)
expr_stmt|;
name|scratchDataTypePhysicalVariations
operator|=
name|Arrays
operator|.
name|copyOf
argument_list|(
name|scratchDataTypePhysicalVariations
argument_list|,
literal|2
operator|*
name|outputColCount
argument_list|)
expr_stmt|;
name|int
name|newIndex
init|=
name|outputColCount
decl_stmt|;
name|scratchVectorTypeNames
index|[
name|outputColCount
index|]
operator|=
name|columnType
expr_stmt|;
name|scratchDataTypePhysicalVariations
index|[
name|outputColCount
operator|++
index|]
operator|=
name|dataTypePhysicalVariation
expr_stmt|;
name|usedOutputColumns
operator|.
name|add
argument_list|(
name|newIndex
argument_list|)
expr_stmt|;
return|return
name|newIndex
return|;
block|}
block|}
name|void
name|freeOutputColumn
parameter_list|(
name|int
name|index
parameter_list|)
block|{
if|if
condition|(
name|initialOutputCol
operator|<
literal|0
operator|||
name|reuseScratchColumns
operator|==
literal|false
condition|)
block|{
comment|// This is a test
return|return;
block|}
name|int
name|colIndex
init|=
name|index
operator|-
name|initialOutputCol
decl_stmt|;
if|if
condition|(
name|colIndex
operator|>=
literal|0
condition|)
block|{
name|usedOutputColumns
operator|.
name|remove
argument_list|(
name|index
operator|-
name|initialOutputCol
argument_list|)
expr_stmt|;
block|}
block|}
specifier|public
name|int
index|[]
name|currentScratchColumns
parameter_list|()
block|{
name|TreeSet
argument_list|<
name|Integer
argument_list|>
name|treeSet
init|=
operator|new
name|TreeSet
argument_list|<
name|Integer
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|Integer
name|col
range|:
name|usedOutputColumns
control|)
block|{
name|treeSet
operator|.
name|add
argument_list|(
name|initialOutputCol
operator|+
name|col
argument_list|)
expr_stmt|;
block|}
return|return
name|ArrayUtils
operator|.
name|toPrimitive
argument_list|(
name|treeSet
operator|.
name|toArray
argument_list|(
operator|new
name|Integer
index|[
literal|0
index|]
argument_list|)
argument_list|)
return|;
block|}
specifier|public
name|String
name|getScratchTypeName
parameter_list|(
name|int
name|columnNum
parameter_list|)
block|{
return|return
name|scratchVectorTypeNames
index|[
name|columnNum
operator|-
name|initialOutputCol
index|]
return|;
block|}
specifier|public
name|DataTypePhysicalVariation
name|getDataTypePhysicalVariation
parameter_list|(
name|int
name|columnNum
parameter_list|)
block|{
if|if
condition|(
name|scratchDataTypePhysicalVariations
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
return|return
name|scratchDataTypePhysicalVariations
index|[
name|columnNum
operator|-
name|initialOutputCol
index|]
return|;
block|}
comment|// Allow debugging by disabling column reuse (input cols are never reused by design, only
comment|// scratch cols are)
specifier|public
name|void
name|setReuseColumns
parameter_list|(
name|boolean
name|reuseColumns
parameter_list|)
block|{
name|this
operator|.
name|reuseScratchColumns
operator|=
name|reuseColumns
expr_stmt|;
block|}
block|}
specifier|public
name|int
name|allocateScratchColumn
parameter_list|(
name|TypeInfo
name|typeInfo
parameter_list|)
throws|throws
name|HiveException
block|{
return|return
name|ocm
operator|.
name|allocateOutputColumn
argument_list|(
name|typeInfo
argument_list|)
return|;
block|}
specifier|public
name|int
index|[]
name|currentScratchColumns
parameter_list|()
block|{
return|return
name|ocm
operator|.
name|currentScratchColumns
argument_list|()
return|;
block|}
specifier|private
name|VectorExpression
name|getColumnVectorExpression
parameter_list|(
name|ExprNodeColumnDesc
name|exprDesc
parameter_list|,
name|VectorExpressionDescriptor
operator|.
name|Mode
name|mode
parameter_list|)
throws|throws
name|HiveException
block|{
name|int
name|columnNum
init|=
name|getInputColumnIndex
argument_list|(
name|exprDesc
operator|.
name|getColumn
argument_list|()
argument_list|)
decl_stmt|;
name|VectorExpression
name|expr
init|=
literal|null
decl_stmt|;
switch|switch
condition|(
name|mode
condition|)
block|{
case|case
name|FILTER
case|:
comment|// Evaluate the column as a boolean, converting if necessary.
name|TypeInfo
name|typeInfo
init|=
name|exprDesc
operator|.
name|getTypeInfo
argument_list|()
decl_stmt|;
if|if
condition|(
name|typeInfo
operator|.
name|getCategory
argument_list|()
operator|==
name|Category
operator|.
name|PRIMITIVE
operator|&&
operator|(
operator|(
name|PrimitiveTypeInfo
operator|)
name|typeInfo
operator|)
operator|.
name|getPrimitiveCategory
argument_list|()
operator|==
name|PrimitiveCategory
operator|.
name|BOOLEAN
condition|)
block|{
name|expr
operator|=
operator|new
name|SelectColumnIsTrue
argument_list|(
name|columnNum
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// Ok, we need to convert.
name|ArrayList
argument_list|<
name|ExprNodeDesc
argument_list|>
name|exprAsList
init|=
operator|new
name|ArrayList
argument_list|<
name|ExprNodeDesc
argument_list|>
argument_list|(
literal|1
argument_list|)
decl_stmt|;
name|exprAsList
operator|.
name|add
argument_list|(
name|exprDesc
argument_list|)
expr_stmt|;
comment|// First try our cast method that will handle a few special cases.
name|VectorExpression
name|castToBooleanExpr
init|=
name|getCastToBoolean
argument_list|(
name|exprAsList
argument_list|)
decl_stmt|;
if|if
condition|(
name|castToBooleanExpr
operator|==
literal|null
condition|)
block|{
comment|// Ok, try the UDF.
name|castToBooleanExpr
operator|=
name|getVectorExpressionForUdf
argument_list|(
literal|null
argument_list|,
name|UDFToBoolean
operator|.
name|class
argument_list|,
name|exprAsList
argument_list|,
name|VectorExpressionDescriptor
operator|.
name|Mode
operator|.
name|PROJECTION
argument_list|,
name|TypeInfoFactory
operator|.
name|booleanTypeInfo
argument_list|)
expr_stmt|;
if|if
condition|(
name|castToBooleanExpr
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|HiveException
argument_list|(
literal|"Cannot vectorize converting expression "
operator|+
name|exprDesc
operator|.
name|getExprString
argument_list|()
operator|+
literal|" to boolean"
argument_list|)
throw|;
block|}
block|}
specifier|final
name|int
name|outputColumnNum
init|=
name|castToBooleanExpr
operator|.
name|getOutputColumnNum
argument_list|()
decl_stmt|;
name|expr
operator|=
operator|new
name|SelectColumnIsTrue
argument_list|(
name|outputColumnNum
argument_list|)
expr_stmt|;
name|expr
operator|.
name|setChildExpressions
argument_list|(
operator|new
name|VectorExpression
index|[]
block|{
name|castToBooleanExpr
block|}
argument_list|)
expr_stmt|;
name|expr
operator|.
name|setInputTypeInfos
argument_list|(
name|castToBooleanExpr
operator|.
name|getOutputTypeInfo
argument_list|()
argument_list|)
expr_stmt|;
name|expr
operator|.
name|setInputDataTypePhysicalVariations
argument_list|(
name|DataTypePhysicalVariation
operator|.
name|NONE
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|PROJECTION
case|:
block|{
name|expr
operator|=
operator|new
name|IdentityExpression
argument_list|(
name|columnNum
argument_list|)
expr_stmt|;
name|TypeInfo
name|identityTypeInfo
init|=
name|exprDesc
operator|.
name|getTypeInfo
argument_list|()
decl_stmt|;
name|DataTypePhysicalVariation
name|identityDataTypePhysicalVariation
init|=
name|getDataTypePhysicalVariation
argument_list|(
name|columnNum
argument_list|)
decl_stmt|;
name|expr
operator|.
name|setInputTypeInfos
argument_list|(
name|identityTypeInfo
argument_list|)
expr_stmt|;
name|expr
operator|.
name|setInputDataTypePhysicalVariations
argument_list|(
name|identityDataTypePhysicalVariation
argument_list|)
expr_stmt|;
name|expr
operator|.
name|setOutputTypeInfo
argument_list|(
name|identityTypeInfo
argument_list|)
expr_stmt|;
name|expr
operator|.
name|setOutputDataTypePhysicalVariation
argument_list|(
name|identityDataTypePhysicalVariation
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
return|return
name|expr
return|;
block|}
specifier|public
name|VectorExpression
index|[]
name|getVectorExpressionsUpConvertDecimal64
parameter_list|(
name|List
argument_list|<
name|ExprNodeDesc
argument_list|>
name|exprNodes
parameter_list|)
throws|throws
name|HiveException
block|{
name|VectorExpression
index|[]
name|vecExprs
init|=
name|getVectorExpressions
argument_list|(
name|exprNodes
argument_list|,
name|VectorExpressionDescriptor
operator|.
name|Mode
operator|.
name|PROJECTION
argument_list|)
decl_stmt|;
specifier|final
name|int
name|size
init|=
name|vecExprs
operator|.
name|length
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|size
condition|;
name|i
operator|++
control|)
block|{
name|VectorExpression
name|vecExpr
init|=
name|vecExprs
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|vecExpr
operator|.
name|getOutputColumnVectorType
argument_list|()
operator|==
name|ColumnVector
operator|.
name|Type
operator|.
name|DECIMAL_64
condition|)
block|{
name|vecExprs
index|[
name|i
index|]
operator|=
name|wrapWithDecimal64ToDecimalConversion
argument_list|(
name|vecExpr
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|vecExprs
return|;
block|}
specifier|public
name|VectorExpression
index|[]
name|getVectorExpressions
parameter_list|(
name|List
argument_list|<
name|ExprNodeDesc
argument_list|>
name|exprNodes
parameter_list|)
throws|throws
name|HiveException
block|{
return|return
name|getVectorExpressions
argument_list|(
name|exprNodes
argument_list|,
name|VectorExpressionDescriptor
operator|.
name|Mode
operator|.
name|PROJECTION
argument_list|)
return|;
block|}
specifier|public
name|VectorExpression
index|[]
name|getVectorExpressions
parameter_list|(
name|List
argument_list|<
name|ExprNodeDesc
argument_list|>
name|exprNodes
parameter_list|,
name|VectorExpressionDescriptor
operator|.
name|Mode
name|mode
parameter_list|)
throws|throws
name|HiveException
block|{
name|int
name|i
init|=
literal|0
decl_stmt|;
if|if
condition|(
literal|null
operator|==
name|exprNodes
condition|)
block|{
return|return
operator|new
name|VectorExpression
index|[
literal|0
index|]
return|;
block|}
name|VectorExpression
index|[]
name|ret
init|=
operator|new
name|VectorExpression
index|[
name|exprNodes
operator|.
name|size
argument_list|()
index|]
decl_stmt|;
for|for
control|(
name|ExprNodeDesc
name|e
range|:
name|exprNodes
control|)
block|{
name|ret
index|[
name|i
operator|++
index|]
operator|=
name|getVectorExpression
argument_list|(
name|e
argument_list|,
name|mode
argument_list|)
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
specifier|public
name|VectorExpression
name|getVectorExpression
parameter_list|(
name|ExprNodeDesc
name|exprDesc
parameter_list|)
throws|throws
name|HiveException
block|{
return|return
name|getVectorExpression
argument_list|(
name|exprDesc
argument_list|,
name|VectorExpressionDescriptor
operator|.
name|Mode
operator|.
name|PROJECTION
argument_list|)
return|;
block|}
comment|/**    * Returns a vector expression for a given expression    * description.    * @param exprDesc, Expression description    * @param mode    * @return {@link VectorExpression}    * @throws HiveException    */
specifier|public
name|VectorExpression
name|getVectorExpression
parameter_list|(
name|ExprNodeDesc
name|exprDesc
parameter_list|,
name|VectorExpressionDescriptor
operator|.
name|Mode
name|mode
parameter_list|)
throws|throws
name|HiveException
block|{
name|VectorExpression
name|ve
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|exprDesc
operator|instanceof
name|ExprNodeColumnDesc
condition|)
block|{
name|ve
operator|=
name|getColumnVectorExpression
argument_list|(
operator|(
name|ExprNodeColumnDesc
operator|)
name|exprDesc
argument_list|,
name|mode
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|exprDesc
operator|instanceof
name|ExprNodeGenericFuncDesc
condition|)
block|{
name|ExprNodeGenericFuncDesc
name|expr
init|=
operator|(
name|ExprNodeGenericFuncDesc
operator|)
name|exprDesc
decl_stmt|;
comment|// push not through between...
if|if
condition|(
literal|"not"
operator|.
name|equals
argument_list|(
name|expr
operator|.
name|getFuncText
argument_list|()
argument_list|)
condition|)
block|{
if|if
condition|(
name|expr
operator|.
name|getChildren
argument_list|()
operator|!=
literal|null
operator|&&
name|expr
operator|.
name|getChildren
argument_list|()
operator|.
name|size
argument_list|()
operator|==
literal|1
condition|)
block|{
name|ExprNodeDesc
name|child
init|=
name|expr
operator|.
name|getChildren
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|child
operator|instanceof
name|ExprNodeGenericFuncDesc
condition|)
block|{
name|ExprNodeGenericFuncDesc
name|childExpr
init|=
operator|(
name|ExprNodeGenericFuncDesc
operator|)
name|child
decl_stmt|;
if|if
condition|(
literal|"between"
operator|.
name|equals
argument_list|(
name|childExpr
operator|.
name|getFuncText
argument_list|()
argument_list|)
condition|)
block|{
name|ExprNodeConstantDesc
name|flag
init|=
operator|(
name|ExprNodeConstantDesc
operator|)
name|childExpr
operator|.
name|getChildren
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|ExprNodeDesc
argument_list|>
name|newChildren
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
if|if
condition|(
name|Boolean
operator|.
name|TRUE
operator|.
name|equals
argument_list|(
name|flag
operator|.
name|getValue
argument_list|()
argument_list|)
condition|)
block|{
name|newChildren
operator|.
name|add
argument_list|(
operator|new
name|ExprNodeConstantDesc
argument_list|(
name|Boolean
operator|.
name|FALSE
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|newChildren
operator|.
name|add
argument_list|(
operator|new
name|ExprNodeConstantDesc
argument_list|(
name|Boolean
operator|.
name|TRUE
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|newChildren
operator|.
name|addAll
argument_list|(
name|childExpr
operator|.
name|getChildren
argument_list|()
operator|.
name|subList
argument_list|(
literal|1
argument_list|,
name|childExpr
operator|.
name|getChildren
argument_list|()
operator|.
name|size
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|expr
operator|.
name|setTypeInfo
argument_list|(
name|childExpr
operator|.
name|getTypeInfo
argument_list|()
argument_list|)
expr_stmt|;
name|expr
operator|.
name|setGenericUDF
argument_list|(
name|childExpr
operator|.
name|getGenericUDF
argument_list|()
argument_list|)
expr_stmt|;
name|expr
operator|.
name|setChildren
argument_list|(
name|newChildren
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
comment|// Add cast expression if needed. Child expressions of a udf may return different data types
comment|// and that would require converting their data types to evaluate the udf.
comment|// For example decimal column added to an integer column would require integer column to be
comment|// cast to decimal.
comment|// Note: this is a no-op for custom UDFs
name|List
argument_list|<
name|ExprNodeDesc
argument_list|>
name|childExpressions
init|=
name|getChildExpressionsWithImplicitCast
argument_list|(
name|expr
operator|.
name|getGenericUDF
argument_list|()
argument_list|,
name|exprDesc
operator|.
name|getChildren
argument_list|()
argument_list|,
name|exprDesc
operator|.
name|getTypeInfo
argument_list|()
argument_list|)
decl_stmt|;
name|ve
operator|=
name|getGenericUdfVectorExpression
argument_list|(
name|expr
operator|.
name|getGenericUDF
argument_list|()
argument_list|,
name|childExpressions
argument_list|,
name|mode
argument_list|,
name|exprDesc
operator|.
name|getTypeInfo
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|ve
operator|==
literal|null
condition|)
block|{
comment|// Ok, no vectorized class available.  No problem -- try to use the VectorUDFAdaptor
comment|// when configured.
comment|//
comment|// NOTE: We assume if hiveVectorAdaptorUsageMode has not been set it because we are
comment|// executing a test that didn't create a HiveConf, etc.  No usage of VectorUDFAdaptor in
comment|// that case.
if|if
condition|(
name|hiveVectorAdaptorUsageMode
operator|!=
literal|null
condition|)
block|{
switch|switch
condition|(
name|hiveVectorAdaptorUsageMode
condition|)
block|{
case|case
name|NONE
case|:
comment|// No VectorUDFAdaptor usage.
throw|throw
operator|new
name|HiveException
argument_list|(
literal|"Could not vectorize expression (mode = "
operator|+
name|mode
operator|.
name|name
argument_list|()
operator|+
literal|"): "
operator|+
name|exprDesc
operator|.
name|toString
argument_list|()
operator|+
literal|" because hive.vectorized.adaptor.usage.mode=none"
argument_list|)
throw|;
case|case
name|CHOSEN
case|:
if|if
condition|(
name|isNonVectorizedPathUDF
argument_list|(
name|expr
argument_list|,
name|mode
argument_list|)
condition|)
block|{
name|ve
operator|=
name|getCustomUDFExpression
argument_list|(
name|expr
argument_list|,
name|mode
argument_list|)
expr_stmt|;
block|}
else|else
block|{
throw|throw
operator|new
name|HiveException
argument_list|(
literal|"Could not vectorize expression (mode = "
operator|+
name|mode
operator|.
name|name
argument_list|()
operator|+
literal|"): "
operator|+
name|exprDesc
operator|.
name|toString
argument_list|()
operator|+
literal|" because hive.vectorized.adaptor.usage.mode=chosen"
operator|+
literal|" and the UDF wasn't one of the chosen ones"
argument_list|)
throw|;
block|}
break|break;
case|case
name|ALL
case|:
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"We will try to use the VectorUDFAdaptor for "
operator|+
name|exprDesc
operator|.
name|toString
argument_list|()
operator|+
literal|" because hive.vectorized.adaptor.usage.mode=all"
argument_list|)
expr_stmt|;
block|}
name|ve
operator|=
name|getCustomUDFExpression
argument_list|(
name|expr
argument_list|,
name|mode
argument_list|)
expr_stmt|;
break|break;
default|default:
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Unknown hive vector adaptor usage mode "
operator|+
name|hiveVectorAdaptorUsageMode
operator|.
name|name
argument_list|()
argument_list|)
throw|;
block|}
if|if
condition|(
name|ve
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|HiveException
argument_list|(
literal|"Unable vectorize expression (mode = "
operator|+
name|mode
operator|.
name|name
argument_list|()
operator|+
literal|"): "
operator|+
name|exprDesc
operator|.
name|toString
argument_list|()
operator|+
literal|" even for the VectorUDFAdaptor"
argument_list|)
throw|;
block|}
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|exprDesc
operator|instanceof
name|ExprNodeConstantDesc
condition|)
block|{
name|ve
operator|=
name|getConstantVectorExpression
argument_list|(
operator|(
operator|(
name|ExprNodeConstantDesc
operator|)
name|exprDesc
operator|)
operator|.
name|getValue
argument_list|()
argument_list|,
name|exprDesc
operator|.
name|getTypeInfo
argument_list|()
argument_list|,
name|mode
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|exprDesc
operator|instanceof
name|ExprNodeDynamicValueDesc
condition|)
block|{
name|ve
operator|=
name|getDynamicValueVectorExpression
argument_list|(
operator|(
name|ExprNodeDynamicValueDesc
operator|)
name|exprDesc
argument_list|,
name|mode
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|exprDesc
operator|instanceof
name|ExprNodeFieldDesc
condition|)
block|{
comment|// Get the GenericUDFStructField to process the field of Struct type
name|ve
operator|=
name|getGenericUDFStructField
argument_list|(
operator|(
name|ExprNodeFieldDesc
operator|)
name|exprDesc
argument_list|,
name|mode
argument_list|,
name|exprDesc
operator|.
name|getTypeInfo
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ve
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|HiveException
argument_list|(
literal|"Could not vectorize expression (mode = "
operator|+
name|mode
operator|.
name|name
argument_list|()
operator|+
literal|"): "
operator|+
name|exprDesc
operator|.
name|toString
argument_list|()
argument_list|)
throw|;
block|}
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Input Expression = "
operator|+
name|exprDesc
operator|.
name|toString
argument_list|()
operator|+
literal|", Vectorized Expression = "
operator|+
name|ve
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|ve
return|;
block|}
specifier|private
name|VectorExpression
name|getGenericUDFStructField
parameter_list|(
name|ExprNodeFieldDesc
name|exprNodeFieldDesc
parameter_list|,
name|VectorExpressionDescriptor
operator|.
name|Mode
name|mode
parameter_list|,
name|TypeInfo
name|returnType
parameter_list|)
throws|throws
name|HiveException
block|{
comment|// set the arguments for GenericUDFStructField
name|List
argument_list|<
name|ExprNodeDesc
argument_list|>
name|children
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
literal|2
argument_list|)
decl_stmt|;
name|children
operator|.
name|add
argument_list|(
name|exprNodeFieldDesc
operator|.
name|getDesc
argument_list|()
argument_list|)
expr_stmt|;
name|children
operator|.
name|add
argument_list|(
operator|new
name|ExprNodeConstantDesc
argument_list|(
name|getStructFieldIndex
argument_list|(
name|exprNodeFieldDesc
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|getVectorExpressionForUdf
argument_list|(
literal|null
argument_list|,
name|GenericUDFStructField
operator|.
name|class
argument_list|,
name|children
argument_list|,
name|mode
argument_list|,
name|returnType
argument_list|)
return|;
block|}
comment|/**    * The field of Struct is stored in StructColumnVector.fields[index].    * Check the StructTypeInfo.getAllStructFieldNames() and compare to the field name, get the index.    */
specifier|private
name|int
name|getStructFieldIndex
parameter_list|(
name|ExprNodeFieldDesc
name|exprNodeFieldDesc
parameter_list|)
throws|throws
name|HiveException
block|{
name|ExprNodeDesc
name|structNodeDesc
init|=
name|exprNodeFieldDesc
operator|.
name|getDesc
argument_list|()
decl_stmt|;
name|String
name|fieldName
init|=
name|exprNodeFieldDesc
operator|.
name|getFieldName
argument_list|()
decl_stmt|;
name|StructTypeInfo
name|structTypeInfo
init|=
operator|(
name|StructTypeInfo
operator|)
name|structNodeDesc
operator|.
name|getTypeInfo
argument_list|()
decl_stmt|;
name|int
name|index
init|=
literal|0
decl_stmt|;
name|boolean
name|isFieldExist
init|=
literal|false
decl_stmt|;
for|for
control|(
name|String
name|fn
range|:
name|structTypeInfo
operator|.
name|getAllStructFieldNames
argument_list|()
control|)
block|{
if|if
condition|(
name|fieldName
operator|.
name|equals
argument_list|(
name|fn
argument_list|)
condition|)
block|{
name|isFieldExist
operator|=
literal|true
expr_stmt|;
break|break;
block|}
name|index
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|isFieldExist
condition|)
block|{
return|return
name|index
return|;
block|}
else|else
block|{
throw|throw
operator|new
name|HiveException
argument_list|(
literal|"Could not vectorize expression:"
operator|+
name|exprNodeFieldDesc
operator|.
name|toString
argument_list|()
operator|+
literal|", the field "
operator|+
name|fieldName
operator|+
literal|" doesn't exist."
argument_list|)
throw|;
block|}
block|}
comment|/**    * Given a udf and its children, return the common type to which the children's type should be    * cast.    */
specifier|private
name|TypeInfo
name|getCommonTypeForChildExpressions
parameter_list|(
name|GenericUDF
name|genericUdf
parameter_list|,
name|List
argument_list|<
name|ExprNodeDesc
argument_list|>
name|children
parameter_list|,
name|TypeInfo
name|returnType
parameter_list|)
throws|throws
name|HiveException
block|{
name|TypeInfo
name|commonType
decl_stmt|;
if|if
condition|(
name|genericUdf
operator|instanceof
name|GenericUDFBaseCompare
condition|)
block|{
comment|// Apply comparison rules
name|TypeInfo
name|tLeft
init|=
name|children
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|getTypeInfo
argument_list|()
decl_stmt|;
name|TypeInfo
name|tRight
init|=
name|children
operator|.
name|get
argument_list|(
literal|1
argument_list|)
operator|.
name|getTypeInfo
argument_list|()
decl_stmt|;
name|commonType
operator|=
name|FunctionRegistry
operator|.
name|getCommonClassForComparison
argument_list|(
name|tLeft
argument_list|,
name|tRight
argument_list|)
expr_stmt|;
if|if
condition|(
name|commonType
operator|==
literal|null
condition|)
block|{
name|commonType
operator|=
name|returnType
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|genericUdf
operator|instanceof
name|GenericUDFIn
condition|)
block|{
name|TypeInfo
name|colTi
init|=
name|children
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|getTypeInfo
argument_list|()
decl_stmt|;
if|if
condition|(
name|colTi
operator|.
name|getCategory
argument_list|()
operator|!=
name|Category
operator|.
name|PRIMITIVE
condition|)
block|{
return|return
name|colTi
return|;
comment|// Handled later, only struct will be supported.
block|}
name|TypeInfo
name|opTi
init|=
name|GenericUDFUtils
operator|.
name|deriveInType
argument_list|(
name|children
argument_list|)
decl_stmt|;
if|if
condition|(
name|opTi
operator|==
literal|null
operator|||
name|opTi
operator|.
name|getCategory
argument_list|()
operator|!=
name|Category
operator|.
name|PRIMITIVE
condition|)
block|{
throw|throw
operator|new
name|HiveException
argument_list|(
literal|"Cannot vectorize IN() - common type is "
operator|+
name|opTi
argument_list|)
throw|;
block|}
if|if
condition|(
operator|(
operator|(
name|PrimitiveTypeInfo
operator|)
name|colTi
operator|)
operator|.
name|getPrimitiveCategory
argument_list|()
operator|!=
operator|(
operator|(
name|PrimitiveTypeInfo
operator|)
name|opTi
operator|)
operator|.
name|getPrimitiveCategory
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|HiveException
argument_list|(
literal|"Cannot vectorize IN() - casting a column is not supported. "
operator|+
literal|"Column type is "
operator|+
name|colTi
operator|+
literal|" but the common type is "
operator|+
name|opTi
argument_list|)
throw|;
block|}
return|return
name|colTi
return|;
block|}
else|else
block|{
comment|// The children type should be converted to return type
name|commonType
operator|=
name|returnType
expr_stmt|;
block|}
return|return
name|commonType
return|;
block|}
comment|/**    * Add a cast expression to the expression tree if needed. The output of child expressions of a given UDF might    * need a cast if their return type is different from the return type of the UDF.    *    * @param genericUDF The given UDF    * @param children Child expressions of the UDF that might require a cast.    * @param returnType The return type of the UDF.    * @return List of child expressions added with cast.    */
specifier|private
name|List
argument_list|<
name|ExprNodeDesc
argument_list|>
name|getChildExpressionsWithImplicitCast
parameter_list|(
name|GenericUDF
name|genericUDF
parameter_list|,
name|List
argument_list|<
name|ExprNodeDesc
argument_list|>
name|children
parameter_list|,
name|TypeInfo
name|returnType
parameter_list|)
throws|throws
name|HiveException
block|{
if|if
condition|(
name|isCustomUDF
argument_list|(
name|genericUDF
operator|.
name|getUdfName
argument_list|()
argument_list|)
condition|)
block|{
comment|// no implicit casts possible
return|return
name|children
return|;
block|}
if|if
condition|(
name|isExcludedFromCast
argument_list|(
name|genericUDF
argument_list|)
condition|)
block|{
comment|// No implicit cast needed
return|return
name|children
return|;
block|}
if|if
condition|(
name|children
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
name|TypeInfo
name|commonType
init|=
name|getCommonTypeForChildExpressions
argument_list|(
name|genericUDF
argument_list|,
name|children
argument_list|,
name|returnType
argument_list|)
decl_stmt|;
if|if
condition|(
name|commonType
operator|==
literal|null
condition|)
block|{
comment|// Couldn't determine common type, don't cast
return|return
name|children
return|;
block|}
name|List
argument_list|<
name|ExprNodeDesc
argument_list|>
name|childrenWithCasts
init|=
operator|new
name|ArrayList
argument_list|<
name|ExprNodeDesc
argument_list|>
argument_list|()
decl_stmt|;
name|boolean
name|atleastOneCastNeeded
init|=
literal|false
decl_stmt|;
if|if
condition|(
name|genericUDF
operator|instanceof
name|GenericUDFElt
condition|)
block|{
name|int
name|i
init|=
literal|0
decl_stmt|;
for|for
control|(
name|ExprNodeDesc
name|child
range|:
name|children
control|)
block|{
name|TypeInfo
name|castType
init|=
name|commonType
decl_stmt|;
if|if
condition|(
name|i
operator|++
operator|==
literal|0
condition|)
block|{
name|castType
operator|=
name|isIntFamily
argument_list|(
name|child
operator|.
name|getTypeString
argument_list|()
argument_list|)
condition|?
name|child
operator|.
name|getTypeInfo
argument_list|()
else|:
name|TypeInfoFactory
operator|.
name|intTypeInfo
expr_stmt|;
block|}
name|ExprNodeDesc
name|castExpression
init|=
name|getImplicitCastExpression
argument_list|(
name|genericUDF
argument_list|,
name|child
argument_list|,
name|castType
argument_list|)
decl_stmt|;
if|if
condition|(
name|castExpression
operator|!=
literal|null
condition|)
block|{
name|atleastOneCastNeeded
operator|=
literal|true
expr_stmt|;
name|childrenWithCasts
operator|.
name|add
argument_list|(
name|castExpression
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|childrenWithCasts
operator|.
name|add
argument_list|(
name|child
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
for|for
control|(
name|ExprNodeDesc
name|child
range|:
name|children
control|)
block|{
name|ExprNodeDesc
name|castExpression
init|=
name|getImplicitCastExpression
argument_list|(
name|genericUDF
argument_list|,
name|child
argument_list|,
name|commonType
argument_list|)
decl_stmt|;
if|if
condition|(
name|castExpression
operator|!=
literal|null
condition|)
block|{
name|atleastOneCastNeeded
operator|=
literal|true
expr_stmt|;
name|childrenWithCasts
operator|.
name|add
argument_list|(
name|castExpression
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|childrenWithCasts
operator|.
name|add
argument_list|(
name|child
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|atleastOneCastNeeded
condition|)
block|{
return|return
name|childrenWithCasts
return|;
block|}
else|else
block|{
return|return
name|children
return|;
block|}
block|}
specifier|private
name|boolean
name|isExcludedFromCast
parameter_list|(
name|GenericUDF
name|genericUDF
parameter_list|)
block|{
name|boolean
name|ret
init|=
name|castExpressionUdfs
operator|.
name|contains
argument_list|(
name|genericUDF
operator|.
name|getClass
argument_list|()
argument_list|)
operator|||
operator|(
name|genericUDF
operator|instanceof
name|GenericUDFRound
operator|)
operator|||
operator|(
name|genericUDF
operator|instanceof
name|GenericUDFBetween
operator|)
decl_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
return|return
name|ret
return|;
block|}
if|if
condition|(
name|genericUDF
operator|instanceof
name|GenericUDFBridge
condition|)
block|{
name|Class
argument_list|<
name|?
argument_list|>
name|udfClass
init|=
operator|(
operator|(
name|GenericUDFBridge
operator|)
name|genericUDF
operator|)
operator|.
name|getUdfClass
argument_list|()
decl_stmt|;
return|return
name|castExpressionUdfs
operator|.
name|contains
argument_list|(
name|udfClass
argument_list|)
operator|||
name|UDFSign
operator|.
name|class
operator|.
name|isAssignableFrom
argument_list|(
name|udfClass
argument_list|)
return|;
block|}
return|return
literal|false
return|;
block|}
comment|/**    * Creates a DecimalTypeInfo object with appropriate precision and scale for the given    * inputTypeInfo.    */
specifier|private
name|TypeInfo
name|updatePrecision
parameter_list|(
name|TypeInfo
name|inputTypeInfo
parameter_list|,
name|DecimalTypeInfo
name|returnType
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|inputTypeInfo
operator|instanceof
name|PrimitiveTypeInfo
operator|)
condition|)
block|{
return|return
name|returnType
return|;
block|}
name|PrimitiveTypeInfo
name|ptinfo
init|=
operator|(
name|PrimitiveTypeInfo
operator|)
name|inputTypeInfo
decl_stmt|;
name|int
name|precision
init|=
name|getPrecisionForType
argument_list|(
name|ptinfo
argument_list|)
decl_stmt|;
comment|// TODO: precision and scale would be practically invalid for string conversion (38,38)
name|int
name|scale
init|=
name|HiveDecimalUtils
operator|.
name|getScaleForType
argument_list|(
name|ptinfo
argument_list|)
decl_stmt|;
return|return
operator|new
name|DecimalTypeInfo
argument_list|(
name|precision
argument_list|,
name|scale
argument_list|)
return|;
block|}
comment|/**    * The GenericUDFs might need their children output to be cast to the given castType.    * This method returns a cast expression that would achieve the required casting.    */
specifier|private
name|ExprNodeDesc
name|getImplicitCastExpression
parameter_list|(
name|GenericUDF
name|udf
parameter_list|,
name|ExprNodeDesc
name|child
parameter_list|,
name|TypeInfo
name|castType
parameter_list|)
throws|throws
name|HiveException
block|{
name|TypeInfo
name|inputTypeInfo
init|=
name|child
operator|.
name|getTypeInfo
argument_list|()
decl_stmt|;
name|String
name|inputTypeString
init|=
name|inputTypeInfo
operator|.
name|getTypeName
argument_list|()
decl_stmt|;
name|String
name|castTypeString
init|=
name|castType
operator|.
name|getTypeName
argument_list|()
decl_stmt|;
if|if
condition|(
name|inputTypeString
operator|.
name|equals
argument_list|(
name|castTypeString
argument_list|)
condition|)
block|{
comment|// Nothing to be done
return|return
literal|null
return|;
block|}
name|boolean
name|inputTypeDecimal
init|=
literal|false
decl_stmt|;
name|boolean
name|castTypeDecimal
init|=
literal|false
decl_stmt|;
if|if
condition|(
name|decimalTypePattern
operator|.
name|matcher
argument_list|(
name|inputTypeString
argument_list|)
operator|.
name|matches
argument_list|()
condition|)
block|{
name|inputTypeDecimal
operator|=
literal|true
expr_stmt|;
block|}
if|if
condition|(
name|decimalTypePattern
operator|.
name|matcher
argument_list|(
name|castTypeString
argument_list|)
operator|.
name|matches
argument_list|()
condition|)
block|{
name|castTypeDecimal
operator|=
literal|true
expr_stmt|;
block|}
if|if
condition|(
name|castTypeDecimal
operator|&&
operator|!
name|inputTypeDecimal
condition|)
block|{
if|if
condition|(
name|needsImplicitCastForDecimal
argument_list|(
name|udf
argument_list|)
condition|)
block|{
comment|// Cast the input to decimal
comment|// If castType is decimal, try not to lose precision for numeric types.
name|castType
operator|=
name|updatePrecision
argument_list|(
name|inputTypeInfo
argument_list|,
operator|(
name|DecimalTypeInfo
operator|)
name|castType
argument_list|)
expr_stmt|;
name|GenericUDFToDecimal
name|castToDecimalUDF
init|=
operator|new
name|GenericUDFToDecimal
argument_list|()
decl_stmt|;
name|castToDecimalUDF
operator|.
name|setTypeInfo
argument_list|(
name|castType
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|ExprNodeDesc
argument_list|>
name|children
init|=
operator|new
name|ArrayList
argument_list|<
name|ExprNodeDesc
argument_list|>
argument_list|()
decl_stmt|;
name|children
operator|.
name|add
argument_list|(
name|child
argument_list|)
expr_stmt|;
name|ExprNodeDesc
name|desc
init|=
operator|new
name|ExprNodeGenericFuncDesc
argument_list|(
name|castType
argument_list|,
name|castToDecimalUDF
argument_list|,
name|children
argument_list|)
decl_stmt|;
return|return
name|desc
return|;
block|}
block|}
elseif|else
if|if
condition|(
operator|!
name|castTypeDecimal
operator|&&
name|inputTypeDecimal
condition|)
block|{
if|if
condition|(
name|needsImplicitCastForDecimal
argument_list|(
name|udf
argument_list|)
condition|)
block|{
comment|// Cast decimal input to returnType
name|GenericUDF
name|genericUdf
init|=
name|getGenericUDFForCast
argument_list|(
name|castType
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|ExprNodeDesc
argument_list|>
name|children
init|=
operator|new
name|ArrayList
argument_list|<
name|ExprNodeDesc
argument_list|>
argument_list|()
decl_stmt|;
name|children
operator|.
name|add
argument_list|(
name|child
argument_list|)
expr_stmt|;
name|ExprNodeDesc
name|desc
init|=
operator|new
name|ExprNodeGenericFuncDesc
argument_list|(
name|castType
argument_list|,
name|genericUdf
argument_list|,
name|children
argument_list|)
decl_stmt|;
return|return
name|desc
return|;
block|}
block|}
else|else
block|{
comment|// Casts to exact types including long to double etc. are needed in some special cases.
if|if
condition|(
name|udf
operator|instanceof
name|GenericUDFCoalesce
operator|||
name|udf
operator|instanceof
name|GenericUDFNvl
operator|||
name|udf
operator|instanceof
name|GenericUDFElt
condition|)
block|{
name|GenericUDF
name|genericUdf
init|=
name|getGenericUDFForCast
argument_list|(
name|castType
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|ExprNodeDesc
argument_list|>
name|children
init|=
operator|new
name|ArrayList
argument_list|<
name|ExprNodeDesc
argument_list|>
argument_list|()
decl_stmt|;
name|children
operator|.
name|add
argument_list|(
name|child
argument_list|)
expr_stmt|;
name|ExprNodeDesc
name|desc
init|=
operator|new
name|ExprNodeGenericFuncDesc
argument_list|(
name|castType
argument_list|,
name|genericUdf
argument_list|,
name|children
argument_list|)
decl_stmt|;
return|return
name|desc
return|;
block|}
block|}
return|return
literal|null
return|;
block|}
specifier|private
name|int
name|getPrecisionForType
parameter_list|(
name|PrimitiveTypeInfo
name|typeInfo
parameter_list|)
block|{
if|if
condition|(
name|isFloatFamily
argument_list|(
name|typeInfo
operator|.
name|getTypeName
argument_list|()
argument_list|)
condition|)
block|{
return|return
name|HiveDecimal
operator|.
name|MAX_PRECISION
return|;
block|}
return|return
name|HiveDecimalUtils
operator|.
name|getPrecisionForType
argument_list|(
name|typeInfo
argument_list|)
return|;
block|}
specifier|private
name|GenericUDF
name|getGenericUDFForCast
parameter_list|(
name|TypeInfo
name|castType
parameter_list|)
throws|throws
name|HiveException
block|{
name|UDF
name|udfClass
init|=
literal|null
decl_stmt|;
name|GenericUDF
name|genericUdf
init|=
literal|null
decl_stmt|;
switch|switch
condition|(
operator|(
operator|(
name|PrimitiveTypeInfo
operator|)
name|castType
operator|)
operator|.
name|getPrimitiveCategory
argument_list|()
condition|)
block|{
case|case
name|BYTE
case|:
name|udfClass
operator|=
operator|new
name|UDFToByte
argument_list|()
expr_stmt|;
break|break;
case|case
name|SHORT
case|:
name|udfClass
operator|=
operator|new
name|UDFToShort
argument_list|()
expr_stmt|;
break|break;
case|case
name|INT
case|:
name|udfClass
operator|=
operator|new
name|UDFToInteger
argument_list|()
expr_stmt|;
break|break;
case|case
name|LONG
case|:
name|udfClass
operator|=
operator|new
name|UDFToLong
argument_list|()
expr_stmt|;
break|break;
case|case
name|FLOAT
case|:
name|udfClass
operator|=
operator|new
name|UDFToFloat
argument_list|()
expr_stmt|;
break|break;
case|case
name|DOUBLE
case|:
name|udfClass
operator|=
operator|new
name|UDFToDouble
argument_list|()
expr_stmt|;
break|break;
case|case
name|STRING
case|:
name|udfClass
operator|=
operator|new
name|UDFToString
argument_list|()
expr_stmt|;
break|break;
case|case
name|CHAR
case|:
name|genericUdf
operator|=
operator|new
name|GenericUDFToChar
argument_list|()
expr_stmt|;
break|break;
case|case
name|VARCHAR
case|:
name|genericUdf
operator|=
operator|new
name|GenericUDFToVarchar
argument_list|()
expr_stmt|;
break|break;
case|case
name|BOOLEAN
case|:
name|udfClass
operator|=
operator|new
name|UDFToBoolean
argument_list|()
expr_stmt|;
break|break;
case|case
name|DATE
case|:
name|genericUdf
operator|=
operator|new
name|GenericUDFToDate
argument_list|()
expr_stmt|;
break|break;
case|case
name|TIMESTAMP
case|:
name|genericUdf
operator|=
operator|new
name|GenericUDFTimestamp
argument_list|()
expr_stmt|;
break|break;
case|case
name|INTERVAL_YEAR_MONTH
case|:
name|genericUdf
operator|=
operator|new
name|GenericUDFToIntervalYearMonth
argument_list|()
expr_stmt|;
break|break;
case|case
name|INTERVAL_DAY_TIME
case|:
name|genericUdf
operator|=
operator|new
name|GenericUDFToIntervalDayTime
argument_list|()
expr_stmt|;
break|break;
case|case
name|BINARY
case|:
name|genericUdf
operator|=
operator|new
name|GenericUDFToBinary
argument_list|()
expr_stmt|;
break|break;
case|case
name|DECIMAL
case|:
name|genericUdf
operator|=
operator|new
name|GenericUDFToDecimal
argument_list|()
expr_stmt|;
break|break;
case|case
name|VOID
case|:
case|case
name|UNKNOWN
case|:
comment|// fall-through to throw exception, its not expected for execution to reach here.
break|break;
block|}
if|if
condition|(
name|genericUdf
operator|==
literal|null
condition|)
block|{
if|if
condition|(
name|udfClass
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|HiveException
argument_list|(
literal|"Could not add implicit cast for type "
operator|+
name|castType
operator|.
name|getTypeName
argument_list|()
argument_list|)
throw|;
block|}
name|genericUdf
operator|=
operator|new
name|GenericUDFBridge
argument_list|()
expr_stmt|;
operator|(
operator|(
name|GenericUDFBridge
operator|)
name|genericUdf
operator|)
operator|.
name|setUdfClassName
argument_list|(
name|udfClass
operator|.
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|genericUdf
operator|instanceof
name|SettableUDF
condition|)
block|{
operator|(
operator|(
name|SettableUDF
operator|)
name|genericUdf
operator|)
operator|.
name|setTypeInfo
argument_list|(
name|castType
argument_list|)
expr_stmt|;
block|}
return|return
name|genericUdf
return|;
block|}
comment|/* Return true if this is one of a small set of functions for which    * it is significantly easier to use the old code path in vectorized    * mode instead of implementing a new, optimized VectorExpression.    *    * Depending on performance requirements and frequency of use, these    * may be implemented in the future with an optimized VectorExpression.    */
specifier|public
specifier|static
name|boolean
name|isNonVectorizedPathUDF
parameter_list|(
name|ExprNodeGenericFuncDesc
name|expr
parameter_list|,
name|VectorExpressionDescriptor
operator|.
name|Mode
name|mode
parameter_list|)
block|{
name|GenericUDF
name|gudf
init|=
name|expr
operator|.
name|getGenericUDF
argument_list|()
decl_stmt|;
if|if
condition|(
name|gudf
operator|instanceof
name|GenericUDFBridge
condition|)
block|{
name|GenericUDFBridge
name|bridge
init|=
operator|(
name|GenericUDFBridge
operator|)
name|gudf
decl_stmt|;
name|Class
argument_list|<
name|?
extends|extends
name|UDF
argument_list|>
name|udfClass
init|=
name|bridge
operator|.
name|getUdfClass
argument_list|()
decl_stmt|;
if|if
condition|(
name|udfClass
operator|.
name|equals
argument_list|(
name|UDFHex
operator|.
name|class
argument_list|)
operator|||
name|udfClass
operator|.
name|equals
argument_list|(
name|UDFRegExpExtract
operator|.
name|class
argument_list|)
operator|||
name|udfClass
operator|.
name|equals
argument_list|(
name|UDFRegExpReplace
operator|.
name|class
argument_list|)
operator|||
name|udfClass
operator|.
name|equals
argument_list|(
name|UDFConv
operator|.
name|class
argument_list|)
operator|||
name|udfClass
operator|.
name|equals
argument_list|(
name|UDFFromUnixTime
operator|.
name|class
argument_list|)
operator|&&
name|isIntFamily
argument_list|(
name|arg0Type
argument_list|(
name|expr
argument_list|)
argument_list|)
operator|||
name|isCastToIntFamily
argument_list|(
name|udfClass
argument_list|)
operator|&&
name|isStringFamily
argument_list|(
name|arg0Type
argument_list|(
name|expr
argument_list|)
argument_list|)
operator|||
name|isCastToFloatFamily
argument_list|(
name|udfClass
argument_list|)
operator|&&
name|isStringFamily
argument_list|(
name|arg0Type
argument_list|(
name|expr
argument_list|)
argument_list|)
operator|||
name|udfClass
operator|.
name|equals
argument_list|(
name|UDFToString
operator|.
name|class
argument_list|)
operator|&&
operator|(
name|arg0Type
argument_list|(
name|expr
argument_list|)
operator|.
name|equals
argument_list|(
literal|"timestamp"
argument_list|)
operator|||
name|arg0Type
argument_list|(
name|expr
argument_list|)
operator|.
name|equals
argument_list|(
literal|"double"
argument_list|)
operator|||
name|arg0Type
argument_list|(
name|expr
argument_list|)
operator|.
name|equals
argument_list|(
literal|"float"
argument_list|)
operator|)
condition|)
block|{
return|return
literal|true
return|;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|gudf
operator|instanceof
name|GenericUDFTimestamp
operator|&&
name|isStringFamily
argument_list|(
name|arg0Type
argument_list|(
name|expr
argument_list|)
argument_list|)
operator|)
comment|/* GenericUDFCase and GenericUDFWhen are implemented with the UDF Adaptor because              * of their complexity and generality. In the future, variations of these              * can be optimized to run faster for the vectorized code path. For example,              * CASE col WHEN 1 then "one" WHEN 2 THEN "two" ELSE "other" END              * is an example of a GenericUDFCase that has all constant arguments              * except for the first argument. This is probably a common case and a              * good candidate for a fast, special-purpose VectorExpression. Then              * the UDF Adaptor code path could be used as a catch-all for              * non-optimized general cases.              */
operator|||
name|gudf
operator|instanceof
name|GenericUDFCase
operator|||
name|gudf
operator|instanceof
name|GenericUDFWhen
condition|)
block|{
return|return
literal|true
return|;
block|}
elseif|else
if|if
condition|(
name|gudf
operator|instanceof
name|GenericUDFToChar
operator|&&
operator|(
name|arg0Type
argument_list|(
name|expr
argument_list|)
operator|.
name|equals
argument_list|(
literal|"timestamp"
argument_list|)
operator|||
name|arg0Type
argument_list|(
name|expr
argument_list|)
operator|.
name|equals
argument_list|(
literal|"double"
argument_list|)
operator|||
name|arg0Type
argument_list|(
name|expr
argument_list|)
operator|.
name|equals
argument_list|(
literal|"float"
argument_list|)
operator|)
condition|)
block|{
return|return
literal|true
return|;
block|}
elseif|else
if|if
condition|(
name|gudf
operator|instanceof
name|GenericUDFToVarchar
operator|&&
operator|(
name|arg0Type
argument_list|(
name|expr
argument_list|)
operator|.
name|equals
argument_list|(
literal|"timestamp"
argument_list|)
operator|||
name|arg0Type
argument_list|(
name|expr
argument_list|)
operator|.
name|equals
argument_list|(
literal|"double"
argument_list|)
operator|||
name|arg0Type
argument_list|(
name|expr
argument_list|)
operator|.
name|equals
argument_list|(
literal|"float"
argument_list|)
operator|)
condition|)
block|{
return|return
literal|true
return|;
block|}
elseif|else
if|if
condition|(
name|gudf
operator|instanceof
name|GenericUDFBetween
operator|&&
operator|(
name|mode
operator|==
name|VectorExpressionDescriptor
operator|.
name|Mode
operator|.
name|PROJECTION
operator|)
condition|)
block|{
comment|// between has 4 args here, but can be vectorized like this
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
specifier|public
specifier|static
name|boolean
name|isCastToIntFamily
parameter_list|(
name|Class
argument_list|<
name|?
extends|extends
name|UDF
argument_list|>
name|udfClass
parameter_list|)
block|{
return|return
name|udfClass
operator|.
name|equals
argument_list|(
name|UDFToByte
operator|.
name|class
argument_list|)
operator|||
name|udfClass
operator|.
name|equals
argument_list|(
name|UDFToShort
operator|.
name|class
argument_list|)
operator|||
name|udfClass
operator|.
name|equals
argument_list|(
name|UDFToInteger
operator|.
name|class
argument_list|)
operator|||
name|udfClass
operator|.
name|equals
argument_list|(
name|UDFToLong
operator|.
name|class
argument_list|)
return|;
comment|// Boolean is purposely excluded.
block|}
specifier|public
specifier|static
name|boolean
name|isCastToFloatFamily
parameter_list|(
name|Class
argument_list|<
name|?
extends|extends
name|UDF
argument_list|>
name|udfClass
parameter_list|)
block|{
return|return
name|udfClass
operator|.
name|equals
argument_list|(
name|UDFToDouble
operator|.
name|class
argument_list|)
operator|||
name|udfClass
operator|.
name|equals
argument_list|(
name|UDFToFloat
operator|.
name|class
argument_list|)
return|;
block|}
comment|// Return the type string of the first argument (argument 0).
specifier|public
specifier|static
name|String
name|arg0Type
parameter_list|(
name|ExprNodeGenericFuncDesc
name|expr
parameter_list|)
block|{
name|String
name|type
init|=
name|expr
operator|.
name|getChildren
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|getTypeString
argument_list|()
decl_stmt|;
return|return
name|type
return|;
block|}
comment|// Return true if this is a custom UDF or custom GenericUDF.
comment|// This two functions are for use only in the planner. It will fail in a task.
specifier|public
specifier|static
name|boolean
name|isCustomUDF
parameter_list|(
name|ExprNodeGenericFuncDesc
name|expr
parameter_list|)
block|{
return|return
name|isCustomUDF
argument_list|(
name|expr
operator|.
name|getFuncText
argument_list|()
argument_list|)
return|;
block|}
specifier|private
specifier|static
name|boolean
name|isCustomUDF
parameter_list|(
name|String
name|udfName
parameter_list|)
block|{
if|if
condition|(
name|udfName
operator|==
literal|null
condition|)
block|{
return|return
literal|false
return|;
block|}
name|FunctionInfo
name|funcInfo
decl_stmt|;
try|try
block|{
name|funcInfo
operator|=
name|FunctionRegistry
operator|.
name|getFunctionInfo
argument_list|(
name|udfName
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|SemanticException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Failed to load "
operator|+
name|udfName
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|funcInfo
operator|=
literal|null
expr_stmt|;
block|}
if|if
condition|(
name|funcInfo
operator|==
literal|null
condition|)
block|{
return|return
literal|false
return|;
block|}
name|boolean
name|isNativeFunc
init|=
name|funcInfo
operator|.
name|isNative
argument_list|()
decl_stmt|;
return|return
operator|!
name|isNativeFunc
return|;
block|}
comment|/**    * Handles only the special cases of cast/+ve/-ve operator on a constant.    * @param exprDesc    * @return The same expression if no evaluation done, else return the constant    *         expression.    * @throws HiveException    */
name|ExprNodeDesc
name|evaluateCastOnConstants
parameter_list|(
name|ExprNodeDesc
name|exprDesc
parameter_list|)
throws|throws
name|HiveException
block|{
if|if
condition|(
operator|!
operator|(
name|exprDesc
operator|instanceof
name|ExprNodeGenericFuncDesc
operator|)
condition|)
block|{
return|return
name|exprDesc
return|;
block|}
if|if
condition|(
name|exprDesc
operator|.
name|getChildren
argument_list|()
operator|==
literal|null
operator|||
operator|(
name|exprDesc
operator|.
name|getChildren
argument_list|()
operator|.
name|size
argument_list|()
operator|!=
literal|1
operator|)
condition|)
block|{
return|return
name|exprDesc
return|;
block|}
name|ExprNodeConstantDesc
name|foldedChild
init|=
literal|null
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|exprDesc
operator|.
name|getChildren
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|instanceof
name|ExprNodeConstantDesc
operator|)
condition|)
block|{
comment|// try recursive folding
name|ExprNodeDesc
name|expr
init|=
name|evaluateCastOnConstants
argument_list|(
name|exprDesc
operator|.
name|getChildren
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|expr
operator|instanceof
name|ExprNodeConstantDesc
condition|)
block|{
name|foldedChild
operator|=
operator|(
name|ExprNodeConstantDesc
operator|)
name|expr
expr_stmt|;
block|}
block|}
else|else
block|{
name|foldedChild
operator|=
operator|(
name|ExprNodeConstantDesc
operator|)
name|exprDesc
operator|.
name|getChildren
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|foldedChild
operator|==
literal|null
condition|)
block|{
return|return
name|exprDesc
return|;
block|}
name|ObjectInspector
name|childoi
init|=
name|foldedChild
operator|.
name|getWritableObjectInspector
argument_list|()
decl_stmt|;
name|GenericUDF
name|gudf
init|=
operator|(
operator|(
name|ExprNodeGenericFuncDesc
operator|)
name|exprDesc
operator|)
operator|.
name|getGenericUDF
argument_list|()
decl_stmt|;
comment|// Only evaluate +ve/-ve or cast on constant or recursive casting.
if|if
condition|(
name|gudf
operator|instanceof
name|GenericUDFOPNegative
operator|||
name|gudf
operator|instanceof
name|GenericUDFOPPositive
operator|||
name|castExpressionUdfs
operator|.
name|contains
argument_list|(
name|gudf
operator|.
name|getClass
argument_list|()
argument_list|)
operator|||
operator|(
operator|(
name|gudf
operator|instanceof
name|GenericUDFBridge
operator|)
operator|&&
name|castExpressionUdfs
operator|.
name|contains
argument_list|(
operator|(
operator|(
name|GenericUDFBridge
operator|)
name|gudf
operator|)
operator|.
name|getUdfClass
argument_list|()
argument_list|)
operator|)
condition|)
block|{
name|ExprNodeEvaluator
argument_list|<
name|?
argument_list|>
name|evaluator
init|=
name|ExprNodeEvaluatorFactory
operator|.
name|get
argument_list|(
name|exprDesc
argument_list|)
decl_stmt|;
name|ObjectInspector
name|output
init|=
name|evaluator
operator|.
name|initialize
argument_list|(
name|childoi
argument_list|)
decl_stmt|;
name|Object
name|constant
init|=
name|evaluator
operator|.
name|evaluate
argument_list|(
literal|null
argument_list|)
decl_stmt|;
name|Object
name|java
init|=
name|ObjectInspectorUtils
operator|.
name|copyToStandardJavaObject
argument_list|(
name|constant
argument_list|,
name|output
argument_list|)
decl_stmt|;
return|return
operator|new
name|ExprNodeConstantDesc
argument_list|(
name|exprDesc
operator|.
name|getTypeInfo
argument_list|()
argument_list|,
name|java
argument_list|)
return|;
block|}
return|return
name|exprDesc
return|;
block|}
comment|/* For cast on constant operator in all members of the input list and return new list    * containing results.    */
specifier|private
name|List
argument_list|<
name|ExprNodeDesc
argument_list|>
name|evaluateCastOnConstants
parameter_list|(
name|List
argument_list|<
name|ExprNodeDesc
argument_list|>
name|childExpr
parameter_list|)
throws|throws
name|HiveException
block|{
name|List
argument_list|<
name|ExprNodeDesc
argument_list|>
name|evaluatedChildren
init|=
operator|new
name|ArrayList
argument_list|<
name|ExprNodeDesc
argument_list|>
argument_list|()
decl_stmt|;
if|if
condition|(
name|childExpr
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|ExprNodeDesc
name|expr
range|:
name|childExpr
control|)
block|{
name|expr
operator|=
name|this
operator|.
name|evaluateCastOnConstants
argument_list|(
name|expr
argument_list|)
expr_stmt|;
name|evaluatedChildren
operator|.
name|add
argument_list|(
name|expr
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|evaluatedChildren
return|;
block|}
specifier|private
name|VectorExpression
name|getConstantVectorExpression
parameter_list|(
name|Object
name|constantValue
parameter_list|,
name|TypeInfo
name|typeInfo
parameter_list|,
name|VectorExpressionDescriptor
operator|.
name|Mode
name|mode
parameter_list|)
throws|throws
name|HiveException
block|{
name|String
name|typeName
init|=
name|typeInfo
operator|.
name|getTypeName
argument_list|()
decl_stmt|;
name|VectorExpressionDescriptor
operator|.
name|ArgumentType
name|vectorArgType
init|=
name|VectorExpressionDescriptor
operator|.
name|ArgumentType
operator|.
name|fromHiveTypeName
argument_list|(
name|typeName
argument_list|)
decl_stmt|;
if|if
condition|(
name|vectorArgType
operator|==
name|VectorExpressionDescriptor
operator|.
name|ArgumentType
operator|.
name|NONE
condition|)
block|{
throw|throw
operator|new
name|HiveException
argument_list|(
literal|"No vector argument type for type name "
operator|+
name|typeName
argument_list|)
throw|;
block|}
name|int
name|outCol
init|=
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|mode
operator|==
name|VectorExpressionDescriptor
operator|.
name|Mode
operator|.
name|PROJECTION
condition|)
block|{
name|outCol
operator|=
name|ocm
operator|.
name|allocateOutputColumn
argument_list|(
name|typeInfo
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|constantValue
operator|==
literal|null
condition|)
block|{
return|return
operator|new
name|ConstantVectorExpression
argument_list|(
name|outCol
argument_list|,
name|typeInfo
argument_list|,
literal|true
argument_list|)
return|;
block|}
comment|// Boolean is special case.
if|if
condition|(
name|typeName
operator|.
name|equalsIgnoreCase
argument_list|(
literal|"boolean"
argument_list|)
condition|)
block|{
if|if
condition|(
name|mode
operator|==
name|VectorExpressionDescriptor
operator|.
name|Mode
operator|.
name|FILTER
condition|)
block|{
if|if
condition|(
operator|(
operator|(
name|Boolean
operator|)
name|constantValue
operator|)
operator|.
name|booleanValue
argument_list|()
condition|)
block|{
return|return
operator|new
name|FilterConstantBooleanVectorExpression
argument_list|(
literal|1
argument_list|)
return|;
block|}
else|else
block|{
return|return
operator|new
name|FilterConstantBooleanVectorExpression
argument_list|(
literal|0
argument_list|)
return|;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|(
operator|(
name|Boolean
operator|)
name|constantValue
operator|)
operator|.
name|booleanValue
argument_list|()
condition|)
block|{
return|return
operator|new
name|ConstantVectorExpression
argument_list|(
name|outCol
argument_list|,
literal|1
argument_list|,
name|typeInfo
argument_list|)
return|;
block|}
else|else
block|{
return|return
operator|new
name|ConstantVectorExpression
argument_list|(
name|outCol
argument_list|,
literal|0
argument_list|,
name|typeInfo
argument_list|)
return|;
block|}
block|}
block|}
switch|switch
condition|(
name|vectorArgType
condition|)
block|{
case|case
name|INT_FAMILY
case|:
return|return
operator|new
name|ConstantVectorExpression
argument_list|(
name|outCol
argument_list|,
operator|(
operator|(
name|Number
operator|)
name|constantValue
operator|)
operator|.
name|longValue
argument_list|()
argument_list|,
name|typeInfo
argument_list|)
return|;
case|case
name|DATE
case|:
return|return
operator|new
name|ConstantVectorExpression
argument_list|(
name|outCol
argument_list|,
name|DateWritable
operator|.
name|dateToDays
argument_list|(
operator|(
name|Date
operator|)
name|constantValue
argument_list|)
argument_list|,
name|typeInfo
argument_list|)
return|;
case|case
name|TIMESTAMP
case|:
return|return
operator|new
name|ConstantVectorExpression
argument_list|(
name|outCol
argument_list|,
operator|(
name|Timestamp
operator|)
name|constantValue
argument_list|,
name|typeInfo
argument_list|)
return|;
case|case
name|INTERVAL_YEAR_MONTH
case|:
return|return
operator|new
name|ConstantVectorExpression
argument_list|(
name|outCol
argument_list|,
operator|(
operator|(
name|HiveIntervalYearMonth
operator|)
name|constantValue
operator|)
operator|.
name|getTotalMonths
argument_list|()
argument_list|,
name|typeInfo
argument_list|)
return|;
case|case
name|INTERVAL_DAY_TIME
case|:
return|return
operator|new
name|ConstantVectorExpression
argument_list|(
name|outCol
argument_list|,
operator|(
name|HiveIntervalDayTime
operator|)
name|constantValue
argument_list|,
name|typeInfo
argument_list|)
return|;
case|case
name|FLOAT_FAMILY
case|:
return|return
operator|new
name|ConstantVectorExpression
argument_list|(
name|outCol
argument_list|,
operator|(
operator|(
name|Number
operator|)
name|constantValue
operator|)
operator|.
name|doubleValue
argument_list|()
argument_list|,
name|typeInfo
argument_list|)
return|;
case|case
name|DECIMAL
case|:
return|return
operator|new
name|ConstantVectorExpression
argument_list|(
name|outCol
argument_list|,
operator|(
name|HiveDecimal
operator|)
name|constantValue
argument_list|,
name|typeInfo
argument_list|)
return|;
case|case
name|STRING
case|:
return|return
operator|new
name|ConstantVectorExpression
argument_list|(
name|outCol
argument_list|,
operator|(
operator|(
name|String
operator|)
name|constantValue
operator|)
operator|.
name|getBytes
argument_list|()
argument_list|,
name|typeInfo
argument_list|)
return|;
case|case
name|CHAR
case|:
return|return
operator|new
name|ConstantVectorExpression
argument_list|(
name|outCol
argument_list|,
operator|(
operator|(
name|HiveChar
operator|)
name|constantValue
operator|)
argument_list|,
name|typeInfo
argument_list|)
return|;
case|case
name|VARCHAR
case|:
return|return
operator|new
name|ConstantVectorExpression
argument_list|(
name|outCol
argument_list|,
operator|(
operator|(
name|HiveVarchar
operator|)
name|constantValue
operator|)
argument_list|,
name|typeInfo
argument_list|)
return|;
default|default:
throw|throw
operator|new
name|HiveException
argument_list|(
literal|"Unsupported constant type: "
operator|+
name|typeName
operator|+
literal|", object class "
operator|+
name|constantValue
operator|.
name|getClass
argument_list|()
operator|.
name|getSimpleName
argument_list|()
argument_list|)
throw|;
block|}
block|}
specifier|private
name|VectorExpression
name|getDynamicValueVectorExpression
parameter_list|(
name|ExprNodeDynamicValueDesc
name|dynamicValueExpr
parameter_list|,
name|VectorExpressionDescriptor
operator|.
name|Mode
name|mode
parameter_list|)
throws|throws
name|HiveException
block|{
name|String
name|typeName
init|=
name|dynamicValueExpr
operator|.
name|getTypeInfo
argument_list|()
operator|.
name|getTypeName
argument_list|()
decl_stmt|;
name|VectorExpressionDescriptor
operator|.
name|ArgumentType
name|vectorArgType
init|=
name|VectorExpressionDescriptor
operator|.
name|ArgumentType
operator|.
name|fromHiveTypeName
argument_list|(
name|typeName
argument_list|)
decl_stmt|;
if|if
condition|(
name|vectorArgType
operator|==
name|VectorExpressionDescriptor
operator|.
name|ArgumentType
operator|.
name|NONE
condition|)
block|{
throw|throw
operator|new
name|HiveException
argument_list|(
literal|"No vector argument type for type name "
operator|+
name|typeName
argument_list|)
throw|;
block|}
name|int
name|outCol
init|=
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|mode
operator|==
name|VectorExpressionDescriptor
operator|.
name|Mode
operator|.
name|PROJECTION
condition|)
block|{
name|outCol
operator|=
name|ocm
operator|.
name|allocateOutputColumn
argument_list|(
name|dynamicValueExpr
operator|.
name|getTypeInfo
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
operator|new
name|DynamicValueVectorExpression
argument_list|(
name|outCol
argument_list|,
name|dynamicValueExpr
operator|.
name|getTypeInfo
argument_list|()
argument_list|,
name|dynamicValueExpr
operator|.
name|getDynamicValue
argument_list|()
argument_list|)
return|;
block|}
comment|/**    * Used as a fast path for operations that don't modify their input, like unary +    * and casting boolean to long. IdentityExpression and its children are always    * projections.    */
specifier|private
name|VectorExpression
name|getIdentityExpression
parameter_list|(
name|List
argument_list|<
name|ExprNodeDesc
argument_list|>
name|childExprList
parameter_list|)
throws|throws
name|HiveException
block|{
name|ExprNodeDesc
name|childExpr
init|=
name|childExprList
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|int
name|identityCol
decl_stmt|;
name|TypeInfo
name|identityTypeInfo
decl_stmt|;
name|DataTypePhysicalVariation
name|identityDataTypePhysicalVariation
decl_stmt|;
name|VectorExpression
name|v1
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|childExpr
operator|instanceof
name|ExprNodeGenericFuncDesc
condition|)
block|{
name|v1
operator|=
name|getVectorExpression
argument_list|(
name|childExpr
argument_list|)
expr_stmt|;
name|identityCol
operator|=
name|v1
operator|.
name|getOutputColumnNum
argument_list|()
expr_stmt|;
name|identityTypeInfo
operator|=
name|v1
operator|.
name|getOutputTypeInfo
argument_list|()
expr_stmt|;
name|identityDataTypePhysicalVariation
operator|=
name|v1
operator|.
name|getOutputDataTypePhysicalVariation
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|childExpr
operator|instanceof
name|ExprNodeColumnDesc
condition|)
block|{
name|ExprNodeColumnDesc
name|colDesc
init|=
operator|(
name|ExprNodeColumnDesc
operator|)
name|childExpr
decl_stmt|;
name|identityCol
operator|=
name|getInputColumnIndex
argument_list|(
name|colDesc
operator|.
name|getColumn
argument_list|()
argument_list|)
expr_stmt|;
name|identityTypeInfo
operator|=
name|colDesc
operator|.
name|getTypeInfo
argument_list|()
expr_stmt|;
comment|// CONSIDER: Validation of type information
name|identityDataTypePhysicalVariation
operator|=
name|getDataTypePhysicalVariation
argument_list|(
name|identityCol
argument_list|)
expr_stmt|;
block|}
else|else
block|{
throw|throw
operator|new
name|HiveException
argument_list|(
literal|"Expression not supported: "
operator|+
name|childExpr
argument_list|)
throw|;
block|}
name|VectorExpression
name|ve
init|=
operator|new
name|IdentityExpression
argument_list|(
name|identityCol
argument_list|)
decl_stmt|;
if|if
condition|(
name|v1
operator|!=
literal|null
condition|)
block|{
name|ve
operator|.
name|setChildExpressions
argument_list|(
operator|new
name|VectorExpression
index|[]
block|{
name|v1
block|}
argument_list|)
expr_stmt|;
block|}
name|ve
operator|.
name|setInputTypeInfos
argument_list|(
name|identityTypeInfo
argument_list|)
expr_stmt|;
name|ve
operator|.
name|setInputDataTypePhysicalVariations
argument_list|(
name|identityDataTypePhysicalVariation
argument_list|)
expr_stmt|;
name|ve
operator|.
name|setOutputTypeInfo
argument_list|(
name|identityTypeInfo
argument_list|)
expr_stmt|;
name|ve
operator|.
name|setOutputDataTypePhysicalVariation
argument_list|(
name|identityDataTypePhysicalVariation
argument_list|)
expr_stmt|;
return|return
name|ve
return|;
block|}
specifier|private
name|boolean
name|checkExprNodeDescForDecimal64
parameter_list|(
name|ExprNodeDesc
name|exprNodeDesc
parameter_list|)
throws|throws
name|HiveException
block|{
if|if
condition|(
name|exprNodeDesc
operator|instanceof
name|ExprNodeColumnDesc
condition|)
block|{
name|int
name|colIndex
init|=
name|getInputColumnIndex
argument_list|(
operator|(
name|ExprNodeColumnDesc
operator|)
name|exprNodeDesc
argument_list|)
decl_stmt|;
name|DataTypePhysicalVariation
name|dataTypePhysicalVariation
init|=
name|getDataTypePhysicalVariation
argument_list|(
name|colIndex
argument_list|)
decl_stmt|;
return|return
operator|(
name|dataTypePhysicalVariation
operator|==
name|DataTypePhysicalVariation
operator|.
name|DECIMAL_64
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|exprNodeDesc
operator|instanceof
name|ExprNodeGenericFuncDesc
condition|)
block|{
comment|// Is the result Decimal64 precision?
name|TypeInfo
name|returnType
init|=
name|exprNodeDesc
operator|.
name|getTypeInfo
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|checkTypeInfoForDecimal64
argument_list|(
name|returnType
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
name|DecimalTypeInfo
name|returnDecimalType
init|=
operator|(
name|DecimalTypeInfo
operator|)
name|returnType
decl_stmt|;
name|GenericUDF
name|udf
init|=
operator|(
operator|(
name|ExprNodeGenericFuncDesc
operator|)
name|exprNodeDesc
operator|)
operator|.
name|getGenericUDF
argument_list|()
decl_stmt|;
name|Class
argument_list|<
name|?
argument_list|>
name|udfClass
init|=
name|udf
operator|.
name|getClass
argument_list|()
decl_stmt|;
comment|// We have a class-level annotation that says whether the UDF's vectorization expressions
comment|// support Decimal64.
name|VectorizedExpressionsSupportDecimal64
name|annotation
init|=
name|AnnotationUtils
operator|.
name|getAnnotation
argument_list|(
name|udfClass
argument_list|,
name|VectorizedExpressionsSupportDecimal64
operator|.
name|class
argument_list|)
decl_stmt|;
if|if
condition|(
name|annotation
operator|==
literal|null
condition|)
block|{
return|return
literal|false
return|;
block|}
comment|// Carefully check the children to make sure they are Decimal64.
name|List
argument_list|<
name|ExprNodeDesc
argument_list|>
name|children
init|=
name|exprNodeDesc
operator|.
name|getChildren
argument_list|()
decl_stmt|;
for|for
control|(
name|ExprNodeDesc
name|childExprNodeDesc
range|:
name|children
control|)
block|{
comment|// Some cases were converted before calling getVectorExpressionForUdf.
comment|// So, emulate those cases first.
if|if
condition|(
name|childExprNodeDesc
operator|instanceof
name|ExprNodeConstantDesc
condition|)
block|{
name|DecimalTypeInfo
name|childDecimalTypeInfo
init|=
name|decimalTypeFromCastToDecimal
argument_list|(
name|childExprNodeDesc
argument_list|,
name|returnDecimalType
argument_list|)
decl_stmt|;
if|if
condition|(
name|childDecimalTypeInfo
operator|==
literal|null
condition|)
block|{
return|return
literal|false
return|;
block|}
if|if
condition|(
operator|!
name|checkTypeInfoForDecimal64
argument_list|(
name|childDecimalTypeInfo
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
continue|continue;
block|}
comment|// Otherwise, recurse.
if|if
condition|(
operator|!
name|checkExprNodeDescForDecimal64
argument_list|(
name|childExprNodeDesc
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
return|return
literal|true
return|;
block|}
elseif|else
if|if
condition|(
name|exprNodeDesc
operator|instanceof
name|ExprNodeConstantDesc
condition|)
block|{
return|return
name|checkTypeInfoForDecimal64
argument_list|(
name|exprNodeDesc
operator|.
name|getTypeInfo
argument_list|()
argument_list|)
return|;
block|}
return|return
literal|false
return|;
block|}
specifier|private
name|boolean
name|checkTypeInfoForDecimal64
parameter_list|(
name|TypeInfo
name|typeInfo
parameter_list|)
block|{
if|if
condition|(
name|typeInfo
operator|instanceof
name|DecimalTypeInfo
condition|)
block|{
name|DecimalTypeInfo
name|decimalTypeInfo
init|=
operator|(
name|DecimalTypeInfo
operator|)
name|typeInfo
decl_stmt|;
return|return
name|HiveDecimalWritable
operator|.
name|isPrecisionDecimal64
argument_list|(
name|decimalTypeInfo
operator|.
name|precision
argument_list|()
argument_list|)
return|;
block|}
return|return
literal|false
return|;
block|}
specifier|public
name|boolean
name|haveCandidateForDecimal64VectorExpression
parameter_list|(
name|int
name|numChildren
parameter_list|,
name|List
argument_list|<
name|ExprNodeDesc
argument_list|>
name|childExpr
parameter_list|,
name|TypeInfo
name|returnType
parameter_list|)
throws|throws
name|HiveException
block|{
comment|// For now, just 2 Decimal64 inputs and a Decimal64 or boolean output.
return|return
operator|(
name|numChildren
operator|==
literal|2
operator|&&
name|checkExprNodeDescForDecimal64
argument_list|(
name|childExpr
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|)
operator|&&
name|checkExprNodeDescForDecimal64
argument_list|(
name|childExpr
operator|.
name|get
argument_list|(
literal|1
argument_list|)
argument_list|)
operator|&&
operator|(
name|checkTypeInfoForDecimal64
argument_list|(
name|returnType
argument_list|)
operator|||
name|returnType
operator|.
name|equals
argument_list|(
name|TypeInfoFactory
operator|.
name|booleanTypeInfo
argument_list|)
operator|)
operator|)
return|;
block|}
specifier|private
name|VectorExpression
name|getDecimal64VectorExpressionForUdf
parameter_list|(
name|GenericUDF
name|genericUdf
parameter_list|,
name|Class
argument_list|<
name|?
argument_list|>
name|udfClass
parameter_list|,
name|List
argument_list|<
name|ExprNodeDesc
argument_list|>
name|childExpr
parameter_list|,
name|int
name|numChildren
parameter_list|,
name|VectorExpressionDescriptor
operator|.
name|Mode
name|mode
parameter_list|,
name|TypeInfo
name|returnType
parameter_list|)
throws|throws
name|HiveException
block|{
name|ExprNodeDesc
name|child1
init|=
name|childExpr
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|ExprNodeDesc
name|child2
init|=
name|childExpr
operator|.
name|get
argument_list|(
literal|1
argument_list|)
decl_stmt|;
name|DecimalTypeInfo
name|decimalTypeInfo1
init|=
operator|(
name|DecimalTypeInfo
operator|)
name|child1
operator|.
name|getTypeInfo
argument_list|()
decl_stmt|;
name|DecimalTypeInfo
name|decimalTypeInfo2
init|=
operator|(
name|DecimalTypeInfo
operator|)
name|child2
operator|.
name|getTypeInfo
argument_list|()
decl_stmt|;
name|DataTypePhysicalVariation
name|dataTypePhysicalVariation1
init|=
name|DataTypePhysicalVariation
operator|.
name|DECIMAL_64
decl_stmt|;
name|DataTypePhysicalVariation
name|dataTypePhysicalVariation2
init|=
name|DataTypePhysicalVariation
operator|.
name|DECIMAL_64
decl_stmt|;
specifier|final
name|int
name|scale1
init|=
name|decimalTypeInfo1
operator|.
name|scale
argument_list|()
decl_stmt|;
specifier|final
name|int
name|scale2
init|=
name|decimalTypeInfo2
operator|.
name|scale
argument_list|()
decl_stmt|;
name|VectorExpressionDescriptor
operator|.
name|Builder
name|builder
init|=
operator|new
name|VectorExpressionDescriptor
operator|.
name|Builder
argument_list|()
decl_stmt|;
name|builder
operator|.
name|setNumArguments
argument_list|(
name|numChildren
argument_list|)
expr_stmt|;
name|builder
operator|.
name|setMode
argument_list|(
name|mode
argument_list|)
expr_stmt|;
name|boolean
name|isColumnScaleEstablished
init|=
literal|false
decl_stmt|;
name|int
name|columnScale
init|=
literal|0
decl_stmt|;
name|boolean
name|hasScalar
init|=
literal|false
decl_stmt|;
name|builder
operator|.
name|setArgumentType
argument_list|(
literal|0
argument_list|,
name|ArgumentType
operator|.
name|DECIMAL_64
argument_list|)
expr_stmt|;
if|if
condition|(
name|child1
operator|instanceof
name|ExprNodeGenericFuncDesc
operator|||
name|child1
operator|instanceof
name|ExprNodeColumnDesc
condition|)
block|{
name|builder
operator|.
name|setInputExpressionType
argument_list|(
literal|0
argument_list|,
name|InputExpressionType
operator|.
name|COLUMN
argument_list|)
expr_stmt|;
name|isColumnScaleEstablished
operator|=
literal|true
expr_stmt|;
name|columnScale
operator|=
name|scale1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|child1
operator|instanceof
name|ExprNodeConstantDesc
condition|)
block|{
name|hasScalar
operator|=
literal|true
expr_stmt|;
name|builder
operator|.
name|setInputExpressionType
argument_list|(
literal|0
argument_list|,
name|InputExpressionType
operator|.
name|SCALAR
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// Currently, only functions, columns, and scalars supported.
return|return
literal|null
return|;
block|}
name|builder
operator|.
name|setArgumentType
argument_list|(
literal|1
argument_list|,
name|ArgumentType
operator|.
name|DECIMAL_64
argument_list|)
expr_stmt|;
if|if
condition|(
name|child2
operator|instanceof
name|ExprNodeGenericFuncDesc
operator|||
name|child2
operator|instanceof
name|ExprNodeColumnDesc
condition|)
block|{
name|builder
operator|.
name|setInputExpressionType
argument_list|(
literal|1
argument_list|,
name|InputExpressionType
operator|.
name|COLUMN
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|isColumnScaleEstablished
condition|)
block|{
name|isColumnScaleEstablished
operator|=
literal|true
expr_stmt|;
name|columnScale
operator|=
name|scale2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|columnScale
operator|!=
name|scale2
condition|)
block|{
comment|// We only support Decimal64 on 2 columns when the have the same scale.
return|return
literal|null
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|child2
operator|instanceof
name|ExprNodeConstantDesc
condition|)
block|{
comment|// Cannot have SCALAR, SCALAR.
if|if
condition|(
operator|!
name|isColumnScaleEstablished
condition|)
block|{
return|return
literal|null
return|;
block|}
name|hasScalar
operator|=
literal|true
expr_stmt|;
name|builder
operator|.
name|setInputExpressionType
argument_list|(
literal|1
argument_list|,
name|InputExpressionType
operator|.
name|SCALAR
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// Currently, only functions, columns, and scalars supported.
return|return
literal|null
return|;
block|}
name|VectorExpressionDescriptor
operator|.
name|Descriptor
name|descriptor
init|=
name|builder
operator|.
name|build
argument_list|()
decl_stmt|;
name|Class
argument_list|<
name|?
argument_list|>
name|vectorClass
init|=
name|this
operator|.
name|vMap
operator|.
name|getVectorExpressionClass
argument_list|(
name|udfClass
argument_list|,
name|descriptor
argument_list|)
decl_stmt|;
if|if
condition|(
name|vectorClass
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
name|VectorExpressionDescriptor
operator|.
name|Mode
name|childrenMode
init|=
name|getChildrenMode
argument_list|(
name|mode
argument_list|,
name|udfClass
argument_list|)
decl_stmt|;
comment|/*      * Custom build arguments.      */
name|List
argument_list|<
name|VectorExpression
argument_list|>
name|children
init|=
operator|new
name|ArrayList
argument_list|<
name|VectorExpression
argument_list|>
argument_list|()
decl_stmt|;
name|Object
index|[]
name|arguments
init|=
operator|new
name|Object
index|[
name|numChildren
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numChildren
condition|;
name|i
operator|++
control|)
block|{
name|ExprNodeDesc
name|child
init|=
name|childExpr
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|child
operator|instanceof
name|ExprNodeGenericFuncDesc
condition|)
block|{
name|VectorExpression
name|vChild
init|=
name|getVectorExpression
argument_list|(
name|child
argument_list|,
name|childrenMode
argument_list|)
decl_stmt|;
name|children
operator|.
name|add
argument_list|(
name|vChild
argument_list|)
expr_stmt|;
name|arguments
index|[
name|i
index|]
operator|=
name|vChild
operator|.
name|getOutputColumnNum
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|child
operator|instanceof
name|ExprNodeColumnDesc
condition|)
block|{
name|int
name|colIndex
init|=
name|getInputColumnIndex
argument_list|(
operator|(
name|ExprNodeColumnDesc
operator|)
name|child
argument_list|)
decl_stmt|;
if|if
condition|(
name|childrenMode
operator|==
name|VectorExpressionDescriptor
operator|.
name|Mode
operator|.
name|FILTER
condition|)
block|{
comment|// In filter mode, the column must be a boolean
name|children
operator|.
name|add
argument_list|(
operator|new
name|SelectColumnIsTrue
argument_list|(
name|colIndex
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|arguments
index|[
name|i
index|]
operator|=
name|colIndex
expr_stmt|;
block|}
else|else
block|{
name|Preconditions
operator|.
name|checkState
argument_list|(
name|child
operator|instanceof
name|ExprNodeConstantDesc
argument_list|)
expr_stmt|;
name|ExprNodeConstantDesc
name|constDesc
init|=
operator|(
name|ExprNodeConstantDesc
operator|)
name|child
decl_stmt|;
name|HiveDecimal
name|hiveDecimal
init|=
operator|(
name|HiveDecimal
operator|)
name|constDesc
operator|.
name|getValue
argument_list|()
decl_stmt|;
if|if
condition|(
name|hiveDecimal
operator|.
name|scale
argument_list|()
operator|>
name|columnScale
condition|)
block|{
comment|// For now, bail out on decimal constants with larger scale than column scale.
return|return
literal|null
return|;
block|}
specifier|final
name|long
name|decimal64Scalar
init|=
operator|new
name|HiveDecimalWritable
argument_list|(
name|hiveDecimal
argument_list|)
operator|.
name|serialize64
argument_list|(
name|columnScale
argument_list|)
decl_stmt|;
name|arguments
index|[
name|i
index|]
operator|=
name|decimal64Scalar
expr_stmt|;
block|}
block|}
comment|/*      * Instantiate Decimal64 vector expression.      *      * The instantiateExpression method sets the output column and type information.      */
name|VectorExpression
name|vectorExpression
init|=
name|instantiateExpression
argument_list|(
name|vectorClass
argument_list|,
name|returnType
argument_list|,
name|DataTypePhysicalVariation
operator|.
name|DECIMAL_64
argument_list|,
name|arguments
argument_list|)
decl_stmt|;
if|if
condition|(
name|vectorExpression
operator|==
literal|null
condition|)
block|{
name|handleCouldNotInstantiateVectorExpression
argument_list|(
name|vectorClass
argument_list|,
name|returnType
argument_list|,
name|DataTypePhysicalVariation
operator|.
name|DECIMAL_64
argument_list|,
name|arguments
argument_list|)
expr_stmt|;
block|}
name|vectorExpression
operator|.
name|setInputTypeInfos
argument_list|(
name|decimalTypeInfo1
argument_list|,
name|decimalTypeInfo2
argument_list|)
expr_stmt|;
name|vectorExpression
operator|.
name|setInputDataTypePhysicalVariations
argument_list|(
name|dataTypePhysicalVariation1
argument_list|,
name|dataTypePhysicalVariation2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|vectorExpression
operator|!=
literal|null
operator|)
operator|&&
operator|!
name|children
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|vectorExpression
operator|.
name|setChildExpressions
argument_list|(
name|children
operator|.
name|toArray
argument_list|(
operator|new
name|VectorExpression
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|vectorExpression
return|;
block|}
specifier|static
name|int
name|fake
init|=
literal|0
decl_stmt|;
specifier|private
name|VectorExpression
name|getVectorExpressionForUdf
parameter_list|(
name|GenericUDF
name|genericUdf
parameter_list|,
name|Class
argument_list|<
name|?
argument_list|>
name|udfClass
parameter_list|,
name|List
argument_list|<
name|ExprNodeDesc
argument_list|>
name|childExpr
parameter_list|,
name|VectorExpressionDescriptor
operator|.
name|Mode
name|mode
parameter_list|,
name|TypeInfo
name|returnType
parameter_list|)
throws|throws
name|HiveException
block|{
name|int
name|numChildren
init|=
operator|(
name|childExpr
operator|==
literal|null
operator|)
condition|?
literal|0
else|:
name|childExpr
operator|.
name|size
argument_list|()
decl_stmt|;
if|if
condition|(
name|numChildren
operator|>
literal|2
operator|&&
name|genericUdf
operator|!=
literal|null
operator|&&
name|mode
operator|==
name|VectorExpressionDescriptor
operator|.
name|Mode
operator|.
name|FILTER
operator|&&
operator|(
operator|(
name|genericUdf
operator|instanceof
name|GenericUDFOPOr
operator|)
operator|||
operator|(
name|genericUdf
operator|instanceof
name|GenericUDFOPAnd
operator|)
operator|)
condition|)
block|{
comment|// Special case handling for Multi-OR and Multi-AND.
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numChildren
condition|;
name|i
operator|++
control|)
block|{
name|ExprNodeDesc
name|child
init|=
name|childExpr
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|String
name|childTypeString
init|=
name|child
operator|.
name|getTypeString
argument_list|()
decl_stmt|;
if|if
condition|(
name|childTypeString
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|HiveException
argument_list|(
literal|"Null child type name string"
argument_list|)
throw|;
block|}
name|TypeInfo
name|typeInfo
init|=
name|TypeInfoUtils
operator|.
name|getTypeInfoFromTypeString
argument_list|(
name|childTypeString
argument_list|)
decl_stmt|;
name|Type
name|columnVectorType
init|=
name|VectorizationContext
operator|.
name|getColumnVectorTypeFromTypeInfo
argument_list|(
name|typeInfo
argument_list|)
decl_stmt|;
if|if
condition|(
name|columnVectorType
operator|!=
name|ColumnVector
operator|.
name|Type
operator|.
name|LONG
condition|)
block|{
return|return
literal|null
return|;
block|}
if|if
condition|(
operator|!
operator|(
name|child
operator|instanceof
name|ExprNodeGenericFuncDesc
operator|)
operator|&&
operator|!
operator|(
name|child
operator|instanceof
name|ExprNodeColumnDesc
operator|)
condition|)
block|{
return|return
literal|null
return|;
block|}
block|}
name|Class
argument_list|<
name|?
argument_list|>
name|vclass
decl_stmt|;
if|if
condition|(
name|genericUdf
operator|instanceof
name|GenericUDFOPOr
condition|)
block|{
name|vclass
operator|=
name|FilterExprOrExpr
operator|.
name|class
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|genericUdf
operator|instanceof
name|GenericUDFOPAnd
condition|)
block|{
name|vclass
operator|=
name|FilterExprAndExpr
operator|.
name|class
expr_stmt|;
block|}
else|else
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Unexpected multi-child UDF"
argument_list|)
throw|;
block|}
name|VectorExpressionDescriptor
operator|.
name|Mode
name|childrenMode
init|=
name|getChildrenMode
argument_list|(
name|mode
argument_list|,
name|udfClass
argument_list|)
decl_stmt|;
return|return
name|createVectorExpression
argument_list|(
name|vclass
argument_list|,
name|childExpr
argument_list|,
name|childrenMode
argument_list|,
name|returnType
argument_list|)
return|;
block|}
if|if
condition|(
name|numChildren
operator|>
name|VectorExpressionDescriptor
operator|.
name|MAX_NUM_ARGUMENTS
condition|)
block|{
return|return
literal|null
return|;
block|}
comment|// Should we intercept here for a possible Decimal64 vector expression class?
if|if
condition|(
name|haveCandidateForDecimal64VectorExpression
argument_list|(
name|numChildren
argument_list|,
name|childExpr
argument_list|,
name|returnType
argument_list|)
condition|)
block|{
name|VectorExpression
name|result
init|=
name|getDecimal64VectorExpressionForUdf
argument_list|(
name|genericUdf
argument_list|,
name|udfClass
argument_list|,
name|childExpr
argument_list|,
name|numChildren
argument_list|,
name|mode
argument_list|,
name|returnType
argument_list|)
decl_stmt|;
if|if
condition|(
name|result
operator|!=
literal|null
condition|)
block|{
return|return
name|result
return|;
block|}
comment|// Otherwise, fall through and proceed with non-Decimal64 vector expression classes...
block|}
name|VectorExpressionDescriptor
operator|.
name|Builder
name|builder
init|=
operator|new
name|VectorExpressionDescriptor
operator|.
name|Builder
argument_list|()
decl_stmt|;
name|builder
operator|.
name|setNumArguments
argument_list|(
name|numChildren
argument_list|)
expr_stmt|;
name|builder
operator|.
name|setMode
argument_list|(
name|mode
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numChildren
condition|;
name|i
operator|++
control|)
block|{
name|ExprNodeDesc
name|child
init|=
name|childExpr
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|TypeInfo
name|childTypeInfo
init|=
name|child
operator|.
name|getTypeInfo
argument_list|()
decl_stmt|;
name|String
name|childTypeString
init|=
name|childTypeInfo
operator|.
name|toString
argument_list|()
decl_stmt|;
if|if
condition|(
name|childTypeString
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|HiveException
argument_list|(
literal|"Null child type name string"
argument_list|)
throw|;
block|}
name|String
name|undecoratedTypeName
init|=
name|getUndecoratedName
argument_list|(
name|childTypeString
argument_list|)
decl_stmt|;
if|if
condition|(
name|undecoratedTypeName
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|HiveException
argument_list|(
literal|"No match for type string "
operator|+
name|childTypeString
operator|+
literal|" from undecorated type name method"
argument_list|)
throw|;
block|}
name|builder
operator|.
name|setArgumentType
argument_list|(
name|i
argument_list|,
name|undecoratedTypeName
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|child
operator|instanceof
name|ExprNodeGenericFuncDesc
operator|)
operator|||
operator|(
name|child
operator|instanceof
name|ExprNodeColumnDesc
operator|)
operator|||
operator|(
name|child
operator|instanceof
name|ExprNodeFieldDesc
operator|)
condition|)
block|{
name|builder
operator|.
name|setInputExpressionType
argument_list|(
name|i
argument_list|,
name|InputExpressionType
operator|.
name|COLUMN
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|child
operator|instanceof
name|ExprNodeConstantDesc
condition|)
block|{
name|builder
operator|.
name|setInputExpressionType
argument_list|(
name|i
argument_list|,
name|InputExpressionType
operator|.
name|SCALAR
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|child
operator|instanceof
name|ExprNodeDynamicValueDesc
condition|)
block|{
name|builder
operator|.
name|setInputExpressionType
argument_list|(
name|i
argument_list|,
name|InputExpressionType
operator|.
name|DYNAMICVALUE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
throw|throw
operator|new
name|HiveException
argument_list|(
literal|"Cannot handle expression type: "
operator|+
name|child
operator|.
name|getClass
argument_list|()
operator|.
name|getSimpleName
argument_list|()
argument_list|)
throw|;
block|}
block|}
name|VectorExpressionDescriptor
operator|.
name|Descriptor
name|descriptor
init|=
name|builder
operator|.
name|build
argument_list|()
decl_stmt|;
name|Class
argument_list|<
name|?
argument_list|>
name|vclass
init|=
name|this
operator|.
name|vMap
operator|.
name|getVectorExpressionClass
argument_list|(
name|udfClass
argument_list|,
name|descriptor
argument_list|)
decl_stmt|;
if|if
condition|(
name|vclass
operator|==
literal|null
condition|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"No vector udf found for "
operator|+
name|udfClass
operator|.
name|getSimpleName
argument_list|()
operator|+
literal|", descriptor: "
operator|+
name|descriptor
argument_list|)
expr_stmt|;
block|}
return|return
literal|null
return|;
block|}
name|VectorExpressionDescriptor
operator|.
name|Mode
name|childrenMode
init|=
name|getChildrenMode
argument_list|(
name|mode
argument_list|,
name|udfClass
argument_list|)
decl_stmt|;
return|return
name|createVectorExpression
argument_list|(
name|vclass
argument_list|,
name|childExpr
argument_list|,
name|childrenMode
argument_list|,
name|returnType
argument_list|)
return|;
block|}
specifier|private
name|VectorExpression
name|createDecimal64ToDecimalConversion
parameter_list|(
name|int
name|colIndex
parameter_list|,
name|TypeInfo
name|resultTypeInfo
parameter_list|)
throws|throws
name|HiveException
block|{
name|Object
index|[]
name|conversionArgs
init|=
operator|new
name|Object
index|[
literal|1
index|]
decl_stmt|;
name|conversionArgs
index|[
literal|0
index|]
operator|=
name|colIndex
expr_stmt|;
name|VectorExpression
name|vectorExpression
init|=
name|instantiateExpression
argument_list|(
name|ConvertDecimal64ToDecimal
operator|.
name|class
argument_list|,
name|resultTypeInfo
argument_list|,
name|DataTypePhysicalVariation
operator|.
name|NONE
argument_list|,
name|conversionArgs
argument_list|)
decl_stmt|;
if|if
condition|(
name|vectorExpression
operator|==
literal|null
condition|)
block|{
name|handleCouldNotInstantiateVectorExpression
argument_list|(
name|ConvertDecimal64ToDecimal
operator|.
name|class
argument_list|,
name|resultTypeInfo
argument_list|,
name|DataTypePhysicalVariation
operator|.
name|NONE
argument_list|,
name|conversionArgs
argument_list|)
expr_stmt|;
block|}
name|vectorExpression
operator|.
name|setInputTypeInfos
argument_list|(
name|resultTypeInfo
argument_list|)
expr_stmt|;
name|vectorExpression
operator|.
name|setInputDataTypePhysicalVariations
argument_list|(
name|DataTypePhysicalVariation
operator|.
name|DECIMAL_64
argument_list|)
expr_stmt|;
return|return
name|vectorExpression
return|;
block|}
specifier|public
name|VectorExpression
name|wrapWithDecimal64ToDecimalConversion
parameter_list|(
name|VectorExpression
name|inputExpression
parameter_list|)
throws|throws
name|HiveException
block|{
name|VectorExpression
name|wrapExpression
init|=
name|createDecimal64ToDecimalConversion
argument_list|(
name|inputExpression
operator|.
name|getOutputColumnNum
argument_list|()
argument_list|,
name|inputExpression
operator|.
name|getOutputTypeInfo
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|inputExpression
operator|instanceof
name|IdentityExpression
condition|)
block|{
return|return
name|wrapExpression
return|;
block|}
comment|// CONCERN: Leaking scratch column?
name|VectorExpression
index|[]
name|child
init|=
operator|new
name|VectorExpression
index|[
literal|1
index|]
decl_stmt|;
name|child
index|[
literal|0
index|]
operator|=
name|inputExpression
expr_stmt|;
name|wrapExpression
operator|.
name|setChildExpressions
argument_list|(
name|child
argument_list|)
expr_stmt|;
return|return
name|wrapExpression
return|;
block|}
specifier|private
name|VectorExpression
name|createVectorExpression
parameter_list|(
name|Class
argument_list|<
name|?
argument_list|>
name|vectorClass
parameter_list|,
name|List
argument_list|<
name|ExprNodeDesc
argument_list|>
name|childExpr
parameter_list|,
name|VectorExpressionDescriptor
operator|.
name|Mode
name|childrenMode
parameter_list|,
name|TypeInfo
name|returnType
parameter_list|)
throws|throws
name|HiveException
block|{
name|int
name|numChildren
init|=
name|childExpr
operator|==
literal|null
condition|?
literal|0
else|:
name|childExpr
operator|.
name|size
argument_list|()
decl_stmt|;
name|TypeInfo
index|[]
name|inputTypeInfos
init|=
operator|new
name|TypeInfo
index|[
name|numChildren
index|]
decl_stmt|;
name|DataTypePhysicalVariation
index|[]
name|inputDataTypePhysicalVariations
init|=
operator|new
name|DataTypePhysicalVariation
index|[
name|numChildren
index|]
decl_stmt|;
name|List
argument_list|<
name|VectorExpression
argument_list|>
name|children
init|=
operator|new
name|ArrayList
argument_list|<
name|VectorExpression
argument_list|>
argument_list|()
decl_stmt|;
name|Object
index|[]
name|arguments
init|=
operator|new
name|Object
index|[
name|numChildren
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numChildren
condition|;
name|i
operator|++
control|)
block|{
name|ExprNodeDesc
name|child
init|=
name|childExpr
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|TypeInfo
name|childTypeInfo
init|=
name|child
operator|.
name|getTypeInfo
argument_list|()
decl_stmt|;
name|inputTypeInfos
index|[
name|i
index|]
operator|=
name|childTypeInfo
expr_stmt|;
name|inputDataTypePhysicalVariations
index|[
name|i
index|]
operator|=
name|DataTypePhysicalVariation
operator|.
name|NONE
expr_stmt|;
comment|// Assume.
if|if
condition|(
operator|(
name|child
operator|instanceof
name|ExprNodeGenericFuncDesc
operator|)
operator|||
operator|(
name|child
operator|instanceof
name|ExprNodeFieldDesc
operator|)
condition|)
block|{
name|VectorExpression
name|vChild
init|=
name|getVectorExpression
argument_list|(
name|child
argument_list|,
name|childrenMode
argument_list|)
decl_stmt|;
name|children
operator|.
name|add
argument_list|(
name|vChild
argument_list|)
expr_stmt|;
name|arguments
index|[
name|i
index|]
operator|=
name|vChild
operator|.
name|getOutputColumnNum
argument_list|()
expr_stmt|;
comment|// Update.
name|inputDataTypePhysicalVariations
index|[
name|i
index|]
operator|=
name|vChild
operator|.
name|getOutputDataTypePhysicalVariation
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|child
operator|instanceof
name|ExprNodeColumnDesc
condition|)
block|{
name|int
name|colIndex
init|=
name|getInputColumnIndex
argument_list|(
operator|(
name|ExprNodeColumnDesc
operator|)
name|child
argument_list|)
decl_stmt|;
comment|// CONSIDER: Validate type information
if|if
condition|(
name|childTypeInfo
operator|instanceof
name|DecimalTypeInfo
condition|)
block|{
comment|// In this method, we must only process non-Decimal64 column vectors.
comment|// Convert Decimal64 columns to regular decimal.
name|DataTypePhysicalVariation
name|dataTypePhysicalVariation
init|=
name|getDataTypePhysicalVariation
argument_list|(
name|colIndex
argument_list|)
decl_stmt|;
if|if
condition|(
name|dataTypePhysicalVariation
operator|!=
literal|null
operator|&&
name|dataTypePhysicalVariation
operator|==
name|DataTypePhysicalVariation
operator|.
name|DECIMAL_64
condition|)
block|{
comment|// FUTURE: Can we reuse this conversion?
name|VectorExpression
name|vChild
init|=
name|createDecimal64ToDecimalConversion
argument_list|(
name|colIndex
argument_list|,
name|childTypeInfo
argument_list|)
decl_stmt|;
name|children
operator|.
name|add
argument_list|(
name|vChild
argument_list|)
expr_stmt|;
name|arguments
index|[
name|i
index|]
operator|=
name|vChild
operator|.
name|getOutputColumnNum
argument_list|()
expr_stmt|;
comment|// Update.
name|inputDataTypePhysicalVariations
index|[
name|i
index|]
operator|=
name|vChild
operator|.
name|getOutputDataTypePhysicalVariation
argument_list|()
expr_stmt|;
continue|continue;
block|}
block|}
if|if
condition|(
name|childrenMode
operator|==
name|VectorExpressionDescriptor
operator|.
name|Mode
operator|.
name|FILTER
condition|)
block|{
comment|// In filter mode, the column must be a boolean
name|SelectColumnIsTrue
name|selectColumnIsTrue
init|=
operator|new
name|SelectColumnIsTrue
argument_list|(
name|colIndex
argument_list|)
decl_stmt|;
name|selectColumnIsTrue
operator|.
name|setInputTypeInfos
argument_list|(
name|childTypeInfo
argument_list|)
expr_stmt|;
name|selectColumnIsTrue
operator|.
name|setInputDataTypePhysicalVariations
argument_list|(
name|DataTypePhysicalVariation
operator|.
name|NONE
argument_list|)
expr_stmt|;
name|children
operator|.
name|add
argument_list|(
name|selectColumnIsTrue
argument_list|)
expr_stmt|;
block|}
name|arguments
index|[
name|i
index|]
operator|=
name|colIndex
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|child
operator|instanceof
name|ExprNodeConstantDesc
condition|)
block|{
name|Object
name|scalarValue
init|=
name|getVectorTypeScalarValue
argument_list|(
operator|(
name|ExprNodeConstantDesc
operator|)
name|child
argument_list|)
decl_stmt|;
name|arguments
index|[
name|i
index|]
operator|=
operator|(
literal|null
operator|==
name|scalarValue
operator|)
condition|?
name|getConstantVectorExpression
argument_list|(
literal|null
argument_list|,
name|child
operator|.
name|getTypeInfo
argument_list|()
argument_list|,
name|childrenMode
argument_list|)
else|:
name|scalarValue
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|child
operator|instanceof
name|ExprNodeDynamicValueDesc
condition|)
block|{
name|arguments
index|[
name|i
index|]
operator|=
operator|(
operator|(
name|ExprNodeDynamicValueDesc
operator|)
name|child
operator|)
operator|.
name|getDynamicValue
argument_list|()
expr_stmt|;
block|}
else|else
block|{
throw|throw
operator|new
name|HiveException
argument_list|(
literal|"Cannot handle expression type: "
operator|+
name|child
operator|.
name|getClass
argument_list|()
operator|.
name|getSimpleName
argument_list|()
argument_list|)
throw|;
block|}
block|}
name|VectorExpression
name|vectorExpression
init|=
name|instantiateExpression
argument_list|(
name|vectorClass
argument_list|,
name|returnType
argument_list|,
name|DataTypePhysicalVariation
operator|.
name|NONE
argument_list|,
name|arguments
argument_list|)
decl_stmt|;
if|if
condition|(
name|vectorExpression
operator|==
literal|null
condition|)
block|{
name|handleCouldNotInstantiateVectorExpression
argument_list|(
name|vectorClass
argument_list|,
name|returnType
argument_list|,
name|DataTypePhysicalVariation
operator|.
name|NONE
argument_list|,
name|arguments
argument_list|)
expr_stmt|;
block|}
name|vectorExpression
operator|.
name|setInputTypeInfos
argument_list|(
name|inputTypeInfos
argument_list|)
expr_stmt|;
name|vectorExpression
operator|.
name|setInputDataTypePhysicalVariations
argument_list|(
name|inputDataTypePhysicalVariations
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|vectorExpression
operator|!=
literal|null
operator|)
operator|&&
operator|!
name|children
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|vectorExpression
operator|.
name|setChildExpressions
argument_list|(
name|children
operator|.
name|toArray
argument_list|(
operator|new
name|VectorExpression
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|VectorExpression
name|ve
range|:
name|children
control|)
block|{
name|ocm
operator|.
name|freeOutputColumn
argument_list|(
name|ve
operator|.
name|getOutputColumnNum
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|vectorExpression
return|;
block|}
specifier|private
name|void
name|handleCouldNotInstantiateVectorExpression
parameter_list|(
name|Class
argument_list|<
name|?
argument_list|>
name|vectorClass
parameter_list|,
name|TypeInfo
name|returnType
parameter_list|,
name|DataTypePhysicalVariation
name|dataTypePhysicalVariation
parameter_list|,
name|Object
index|[]
name|arguments
parameter_list|)
throws|throws
name|HiveException
block|{
name|String
name|displayString
init|=
literal|"Could not instantiate vector expression class "
operator|+
name|vectorClass
operator|.
name|getName
argument_list|()
operator|+
literal|" for arguments "
operator|+
name|Arrays
operator|.
name|toString
argument_list|(
name|arguments
argument_list|)
operator|+
literal|" return type "
operator|+
name|VectorExpression
operator|.
name|getTypeName
argument_list|(
name|returnType
argument_list|,
name|dataTypePhysicalVariation
argument_list|)
decl_stmt|;
throw|throw
operator|new
name|HiveException
argument_list|(
name|displayString
argument_list|)
throw|;
block|}
specifier|private
name|VectorExpressionDescriptor
operator|.
name|Mode
name|getChildrenMode
parameter_list|(
name|VectorExpressionDescriptor
operator|.
name|Mode
name|mode
parameter_list|,
name|Class
argument_list|<
name|?
argument_list|>
name|udf
parameter_list|)
block|{
if|if
condition|(
name|mode
operator|.
name|equals
argument_list|(
name|VectorExpressionDescriptor
operator|.
name|Mode
operator|.
name|FILTER
argument_list|)
operator|&&
operator|(
name|udf
operator|.
name|equals
argument_list|(
name|GenericUDFOPAnd
operator|.
name|class
argument_list|)
operator|||
name|udf
operator|.
name|equals
argument_list|(
name|GenericUDFOPOr
operator|.
name|class
argument_list|)
operator|)
condition|)
block|{
return|return
name|VectorExpressionDescriptor
operator|.
name|Mode
operator|.
name|FILTER
return|;
block|}
return|return
name|VectorExpressionDescriptor
operator|.
name|Mode
operator|.
name|PROJECTION
return|;
block|}
specifier|private
name|String
name|getNewInstanceArgumentString
parameter_list|(
name|Object
index|[]
name|args
parameter_list|)
block|{
if|if
condition|(
name|args
operator|==
literal|null
condition|)
block|{
return|return
literal|"arguments: NULL"
return|;
block|}
name|ArrayList
argument_list|<
name|String
argument_list|>
name|argClasses
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|Object
name|obj
range|:
name|args
control|)
block|{
name|argClasses
operator|.
name|add
argument_list|(
name|obj
operator|.
name|getClass
argument_list|()
operator|.
name|getSimpleName
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
literal|"arguments: "
operator|+
name|Arrays
operator|.
name|toString
argument_list|(
name|args
argument_list|)
operator|+
literal|", argument classes: "
operator|+
name|argClasses
operator|.
name|toString
argument_list|()
return|;
block|}
specifier|private
specifier|static
specifier|final
name|int
name|STACK_LENGTH_LIMIT
init|=
literal|15
decl_stmt|;
specifier|public
specifier|static
name|String
name|getStackTraceAsSingleLine
parameter_list|(
name|Throwable
name|e
parameter_list|)
block|{
name|StringBuilder
name|sb
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|sb
operator|.
name|append
argument_list|(
name|e
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|" stack trace: "
argument_list|)
expr_stmt|;
name|StackTraceElement
index|[]
name|stackTrace
init|=
name|e
operator|.
name|getStackTrace
argument_list|()
decl_stmt|;
name|int
name|length
init|=
name|stackTrace
operator|.
name|length
decl_stmt|;
name|boolean
name|isTruncated
init|=
literal|false
decl_stmt|;
if|if
condition|(
name|length
operator|>
name|STACK_LENGTH_LIMIT
condition|)
block|{
name|length
operator|=
name|STACK_LENGTH_LIMIT
expr_stmt|;
name|isTruncated
operator|=
literal|true
expr_stmt|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|length
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|>
literal|0
condition|)
block|{
name|sb
operator|.
name|append
argument_list|(
literal|", "
argument_list|)
expr_stmt|;
block|}
name|sb
operator|.
name|append
argument_list|(
name|stackTrace
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|isTruncated
condition|)
block|{
name|sb
operator|.
name|append
argument_list|(
literal|", ..."
argument_list|)
expr_stmt|;
block|}
comment|// Attempt to cleanup stack trace elements that vary by VM.
name|String
name|cleaned
init|=
name|sb
operator|.
name|toString
argument_list|()
operator|.
name|replaceAll
argument_list|(
literal|"GeneratedConstructorAccessor[0-9]*"
argument_list|,
literal|"GeneratedConstructorAccessor<omitted>"
argument_list|)
decl_stmt|;
return|return
name|cleaned
return|;
block|}
specifier|private
name|VectorExpression
name|instantiateExpression
parameter_list|(
name|Class
argument_list|<
name|?
argument_list|>
name|vclass
parameter_list|,
name|TypeInfo
name|returnTypeInfo
parameter_list|,
name|DataTypePhysicalVariation
name|returnDataTypePhysicalVariation
parameter_list|,
name|Object
modifier|...
name|args
parameter_list|)
throws|throws
name|HiveException
block|{
name|VectorExpression
name|ve
init|=
literal|null
decl_stmt|;
name|Constructor
argument_list|<
name|?
argument_list|>
name|ctor
init|=
name|getConstructor
argument_list|(
name|vclass
argument_list|)
decl_stmt|;
name|int
name|numParams
init|=
name|ctor
operator|.
name|getParameterTypes
argument_list|()
operator|.
name|length
decl_stmt|;
name|int
name|argsLength
init|=
operator|(
name|args
operator|==
literal|null
operator|)
condition|?
literal|0
else|:
name|args
operator|.
name|length
decl_stmt|;
if|if
condition|(
name|numParams
operator|==
literal|0
condition|)
block|{
try|try
block|{
name|ve
operator|=
operator|(
name|VectorExpression
operator|)
name|ctor
operator|.
name|newInstance
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|ex
parameter_list|)
block|{
throw|throw
operator|new
name|HiveException
argument_list|(
literal|"Could not instantiate "
operator|+
name|vclass
operator|.
name|getSimpleName
argument_list|()
operator|+
literal|" with 0 arguments, exception: "
operator|+
name|getStackTraceAsSingleLine
argument_list|(
name|ex
argument_list|)
argument_list|)
throw|;
block|}
block|}
elseif|else
if|if
condition|(
name|numParams
operator|==
name|argsLength
condition|)
block|{
try|try
block|{
name|ve
operator|=
operator|(
name|VectorExpression
operator|)
name|ctor
operator|.
name|newInstance
argument_list|(
name|args
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|ex
parameter_list|)
block|{
throw|throw
operator|new
name|HiveException
argument_list|(
literal|"Could not instantiate "
operator|+
name|vclass
operator|.
name|getSimpleName
argument_list|()
operator|+
literal|" with "
operator|+
name|getNewInstanceArgumentString
argument_list|(
name|args
argument_list|)
operator|+
literal|", exception: "
operator|+
name|getStackTraceAsSingleLine
argument_list|(
name|ex
argument_list|)
argument_list|)
throw|;
block|}
block|}
elseif|else
if|if
condition|(
name|numParams
operator|==
name|argsLength
operator|+
literal|1
condition|)
block|{
comment|// Additional argument is needed, which is the outputcolumn.
name|Object
index|[]
name|newArgs
init|=
literal|null
decl_stmt|;
try|try
block|{
if|if
condition|(
name|returnTypeInfo
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|HiveException
argument_list|(
literal|"Missing output type information"
argument_list|)
throw|;
block|}
name|String
name|returnTypeName
init|=
name|returnTypeInfo
operator|.
name|getTypeName
argument_list|()
decl_stmt|;
name|returnTypeName
operator|=
name|VectorizationContext
operator|.
name|mapTypeNameSynonyms
argument_list|(
name|returnTypeName
argument_list|)
expr_stmt|;
comment|// Special handling for decimal because decimal types need scale and precision parameter.
comment|// This special handling should be avoided by using returnType uniformly for all cases.
specifier|final
name|int
name|outputColumnNum
init|=
name|ocm
operator|.
name|allocateOutputColumn
argument_list|(
name|returnTypeInfo
argument_list|,
name|returnDataTypePhysicalVariation
argument_list|)
decl_stmt|;
name|newArgs
operator|=
name|Arrays
operator|.
name|copyOf
argument_list|(
name|args
argument_list|,
name|numParams
argument_list|)
expr_stmt|;
name|newArgs
index|[
name|numParams
operator|-
literal|1
index|]
operator|=
name|outputColumnNum
expr_stmt|;
name|ve
operator|=
operator|(
name|VectorExpression
operator|)
name|ctor
operator|.
name|newInstance
argument_list|(
name|newArgs
argument_list|)
expr_stmt|;
comment|/*          * Caller is responsible for setting children and input type information.          */
name|ve
operator|.
name|setOutputTypeInfo
argument_list|(
name|returnTypeInfo
argument_list|)
expr_stmt|;
name|ve
operator|.
name|setOutputDataTypePhysicalVariation
argument_list|(
name|returnDataTypePhysicalVariation
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|ex
parameter_list|)
block|{
throw|throw
operator|new
name|HiveException
argument_list|(
literal|"Could not instantiate "
operator|+
name|vclass
operator|.
name|getSimpleName
argument_list|()
operator|+
literal|" with arguments "
operator|+
name|getNewInstanceArgumentString
argument_list|(
name|newArgs
argument_list|)
operator|+
literal|", exception: "
operator|+
name|getStackTraceAsSingleLine
argument_list|(
name|ex
argument_list|)
argument_list|)
throw|;
block|}
block|}
comment|// Add maxLength parameter to UDFs that have CHAR or VARCHAR output.
if|if
condition|(
name|ve
operator|instanceof
name|TruncStringOutput
condition|)
block|{
name|TruncStringOutput
name|truncStringOutput
init|=
operator|(
name|TruncStringOutput
operator|)
name|ve
decl_stmt|;
if|if
condition|(
name|returnTypeInfo
operator|instanceof
name|BaseCharTypeInfo
condition|)
block|{
name|BaseCharTypeInfo
name|baseCharTypeInfo
init|=
operator|(
name|BaseCharTypeInfo
operator|)
name|returnTypeInfo
decl_stmt|;
name|truncStringOutput
operator|.
name|setMaxLength
argument_list|(
name|baseCharTypeInfo
operator|.
name|getLength
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|ve
return|;
block|}
specifier|private
name|VectorExpression
name|getGenericUdfVectorExpression
parameter_list|(
name|GenericUDF
name|udf
parameter_list|,
name|List
argument_list|<
name|ExprNodeDesc
argument_list|>
name|childExpr
parameter_list|,
name|VectorExpressionDescriptor
operator|.
name|Mode
name|mode
parameter_list|,
name|TypeInfo
name|returnType
parameter_list|)
throws|throws
name|HiveException
block|{
name|List
argument_list|<
name|ExprNodeDesc
argument_list|>
name|castedChildren
init|=
name|evaluateCastOnConstants
argument_list|(
name|childExpr
argument_list|)
decl_stmt|;
name|childExpr
operator|=
name|castedChildren
expr_stmt|;
comment|//First handle special cases.  If one of the special case methods cannot handle it,
comment|// it returns null.
name|VectorExpression
name|ve
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|udf
operator|instanceof
name|GenericUDFBetween
operator|&&
name|mode
operator|==
name|VectorExpressionDescriptor
operator|.
name|Mode
operator|.
name|FILTER
condition|)
block|{
name|ve
operator|=
name|getBetweenFilterExpression
argument_list|(
name|childExpr
argument_list|,
name|mode
argument_list|,
name|returnType
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|udf
operator|instanceof
name|GenericUDFIn
condition|)
block|{
name|ve
operator|=
name|getInExpression
argument_list|(
name|childExpr
argument_list|,
name|mode
argument_list|,
name|returnType
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|udf
operator|instanceof
name|GenericUDFWhen
condition|)
block|{
name|ve
operator|=
name|getWhenExpression
argument_list|(
name|childExpr
argument_list|,
name|mode
argument_list|,
name|returnType
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|udf
operator|instanceof
name|GenericUDFOPPositive
condition|)
block|{
name|ve
operator|=
name|getIdentityExpression
argument_list|(
name|childExpr
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|udf
operator|instanceof
name|GenericUDFCoalesce
operator|||
name|udf
operator|instanceof
name|GenericUDFNvl
condition|)
block|{
comment|// Coalesce is a special case because it can take variable number of arguments.
comment|// Nvl is a specialization of the Coalesce.
name|ve
operator|=
name|getCoalesceExpression
argument_list|(
name|childExpr
argument_list|,
name|returnType
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|udf
operator|instanceof
name|GenericUDFElt
condition|)
block|{
comment|// Elt is a special case because it can take variable number of arguments.
name|ve
operator|=
name|getEltExpression
argument_list|(
name|childExpr
argument_list|,
name|returnType
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|udf
operator|instanceof
name|GenericUDFBridge
condition|)
block|{
name|ve
operator|=
name|getGenericUDFBridgeVectorExpression
argument_list|(
operator|(
name|GenericUDFBridge
operator|)
name|udf
argument_list|,
name|childExpr
argument_list|,
name|mode
argument_list|,
name|returnType
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|udf
operator|instanceof
name|GenericUDFToDecimal
condition|)
block|{
name|ve
operator|=
name|getCastToDecimal
argument_list|(
name|childExpr
argument_list|,
name|returnType
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|udf
operator|instanceof
name|GenericUDFToChar
condition|)
block|{
name|ve
operator|=
name|getCastToChar
argument_list|(
name|childExpr
argument_list|,
name|returnType
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|udf
operator|instanceof
name|GenericUDFToVarchar
condition|)
block|{
name|ve
operator|=
name|getCastToVarChar
argument_list|(
name|childExpr
argument_list|,
name|returnType
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|udf
operator|instanceof
name|GenericUDFTimestamp
condition|)
block|{
name|ve
operator|=
name|getCastToTimestamp
argument_list|(
operator|(
name|GenericUDFTimestamp
operator|)
name|udf
argument_list|,
name|childExpr
argument_list|,
name|mode
argument_list|,
name|returnType
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ve
operator|!=
literal|null
condition|)
block|{
return|return
name|ve
return|;
block|}
comment|// Now do a general lookup
name|Class
argument_list|<
name|?
argument_list|>
name|udfClass
init|=
name|udf
operator|.
name|getClass
argument_list|()
decl_stmt|;
name|boolean
name|isSubstituted
init|=
literal|false
decl_stmt|;
if|if
condition|(
name|udf
operator|instanceof
name|GenericUDFBridge
condition|)
block|{
name|udfClass
operator|=
operator|(
operator|(
name|GenericUDFBridge
operator|)
name|udf
operator|)
operator|.
name|getUdfClass
argument_list|()
expr_stmt|;
name|isSubstituted
operator|=
literal|true
expr_stmt|;
block|}
name|ve
operator|=
name|getVectorExpressionForUdf
argument_list|(
operator|(
operator|!
name|isSubstituted
condition|?
name|udf
else|:
literal|null
operator|)
argument_list|,
name|udfClass
argument_list|,
name|castedChildren
argument_list|,
name|mode
argument_list|,
name|returnType
argument_list|)
expr_stmt|;
return|return
name|ve
return|;
block|}
specifier|private
name|VectorExpression
name|getCastToTimestamp
parameter_list|(
name|GenericUDFTimestamp
name|udf
parameter_list|,
name|List
argument_list|<
name|ExprNodeDesc
argument_list|>
name|childExpr
parameter_list|,
name|VectorExpressionDescriptor
operator|.
name|Mode
name|mode
parameter_list|,
name|TypeInfo
name|returnType
parameter_list|)
throws|throws
name|HiveException
block|{
name|VectorExpression
name|ve
init|=
name|getVectorExpressionForUdf
argument_list|(
name|udf
argument_list|,
name|udf
operator|.
name|getClass
argument_list|()
argument_list|,
name|childExpr
argument_list|,
name|mode
argument_list|,
name|returnType
argument_list|)
decl_stmt|;
comment|// Replace with the milliseconds conversion
if|if
condition|(
operator|!
name|udf
operator|.
name|isIntToTimestampInSeconds
argument_list|()
operator|&&
name|ve
operator|instanceof
name|CastLongToTimestamp
condition|)
block|{
name|ve
operator|=
name|createVectorExpression
argument_list|(
name|CastMillisecondsLongToTimestamp
operator|.
name|class
argument_list|,
name|childExpr
argument_list|,
name|VectorExpressionDescriptor
operator|.
name|Mode
operator|.
name|PROJECTION
argument_list|,
name|returnType
argument_list|)
expr_stmt|;
block|}
return|return
name|ve
return|;
block|}
specifier|private
name|void
name|freeNonColumns
parameter_list|(
name|VectorExpression
index|[]
name|vectorChildren
parameter_list|)
block|{
if|if
condition|(
name|vectorChildren
operator|==
literal|null
condition|)
block|{
return|return;
block|}
for|for
control|(
name|VectorExpression
name|v
range|:
name|vectorChildren
control|)
block|{
if|if
condition|(
operator|!
operator|(
name|v
operator|instanceof
name|IdentityExpression
operator|)
condition|)
block|{
name|ocm
operator|.
name|freeOutputColumn
argument_list|(
name|v
operator|.
name|getOutputColumnNum
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
specifier|private
name|VectorExpression
name|getCoalesceExpression
parameter_list|(
name|List
argument_list|<
name|ExprNodeDesc
argument_list|>
name|childExpr
parameter_list|,
name|TypeInfo
name|returnType
parameter_list|)
throws|throws
name|HiveException
block|{
name|int
index|[]
name|inputColumns
init|=
operator|new
name|int
index|[
name|childExpr
operator|.
name|size
argument_list|()
index|]
decl_stmt|;
name|VectorExpression
index|[]
name|vectorChildren
init|=
name|getVectorExpressions
argument_list|(
name|childExpr
argument_list|,
name|VectorExpressionDescriptor
operator|.
name|Mode
operator|.
name|PROJECTION
argument_list|)
decl_stmt|;
specifier|final
name|int
name|size
init|=
name|vectorChildren
operator|.
name|length
decl_stmt|;
name|TypeInfo
index|[]
name|inputTypeInfos
init|=
operator|new
name|TypeInfo
index|[
name|size
index|]
decl_stmt|;
name|DataTypePhysicalVariation
index|[]
name|inputDataTypePhysicalVariations
init|=
operator|new
name|DataTypePhysicalVariation
index|[
name|size
index|]
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
for|for
control|(
name|VectorExpression
name|ve
range|:
name|vectorChildren
control|)
block|{
name|inputColumns
index|[
name|i
index|]
operator|=
name|ve
operator|.
name|getOutputColumnNum
argument_list|()
expr_stmt|;
name|inputTypeInfos
index|[
name|i
index|]
operator|=
name|ve
operator|.
name|getOutputTypeInfo
argument_list|()
expr_stmt|;
name|inputDataTypePhysicalVariations
index|[
name|i
operator|++
index|]
operator|=
name|ve
operator|.
name|getOutputDataTypePhysicalVariation
argument_list|()
expr_stmt|;
block|}
specifier|final
name|int
name|outputColumnNum
init|=
name|ocm
operator|.
name|allocateOutputColumn
argument_list|(
name|returnType
argument_list|)
decl_stmt|;
name|VectorCoalesce
name|vectorCoalesce
init|=
operator|new
name|VectorCoalesce
argument_list|(
name|inputColumns
argument_list|,
name|outputColumnNum
argument_list|)
decl_stmt|;
name|vectorCoalesce
operator|.
name|setChildExpressions
argument_list|(
name|vectorChildren
argument_list|)
expr_stmt|;
name|vectorCoalesce
operator|.
name|setInputTypeInfos
argument_list|(
name|inputTypeInfos
argument_list|)
expr_stmt|;
name|vectorCoalesce
operator|.
name|setInputDataTypePhysicalVariations
argument_list|(
name|inputDataTypePhysicalVariations
argument_list|)
expr_stmt|;
name|vectorCoalesce
operator|.
name|setOutputTypeInfo
argument_list|(
name|returnType
argument_list|)
expr_stmt|;
name|vectorCoalesce
operator|.
name|setOutputDataTypePhysicalVariation
argument_list|(
name|DataTypePhysicalVariation
operator|.
name|NONE
argument_list|)
expr_stmt|;
name|freeNonColumns
argument_list|(
name|vectorChildren
argument_list|)
expr_stmt|;
return|return
name|vectorCoalesce
return|;
block|}
specifier|private
name|VectorExpression
name|getEltExpression
parameter_list|(
name|List
argument_list|<
name|ExprNodeDesc
argument_list|>
name|childExpr
parameter_list|,
name|TypeInfo
name|returnType
parameter_list|)
throws|throws
name|HiveException
block|{
name|int
index|[]
name|inputColumns
init|=
operator|new
name|int
index|[
name|childExpr
operator|.
name|size
argument_list|()
index|]
decl_stmt|;
name|VectorExpression
index|[]
name|vectorChildren
init|=
name|getVectorExpressions
argument_list|(
name|childExpr
argument_list|,
name|VectorExpressionDescriptor
operator|.
name|Mode
operator|.
name|PROJECTION
argument_list|)
decl_stmt|;
specifier|final
name|int
name|size
init|=
name|vectorChildren
operator|.
name|length
decl_stmt|;
name|TypeInfo
index|[]
name|inputTypeInfos
init|=
operator|new
name|TypeInfo
index|[
name|size
index|]
decl_stmt|;
name|DataTypePhysicalVariation
index|[]
name|inputDataTypePhysicalVariations
init|=
operator|new
name|DataTypePhysicalVariation
index|[
name|size
index|]
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
for|for
control|(
name|VectorExpression
name|ve
range|:
name|vectorChildren
control|)
block|{
name|inputColumns
index|[
name|i
index|]
operator|=
name|ve
operator|.
name|getOutputColumnNum
argument_list|()
expr_stmt|;
name|inputTypeInfos
index|[
name|i
index|]
operator|=
name|ve
operator|.
name|getOutputTypeInfo
argument_list|()
expr_stmt|;
name|inputDataTypePhysicalVariations
index|[
name|i
operator|++
index|]
operator|=
name|ve
operator|.
name|getOutputDataTypePhysicalVariation
argument_list|()
expr_stmt|;
block|}
specifier|final
name|int
name|outputColumnNum
init|=
name|ocm
operator|.
name|allocateOutputColumn
argument_list|(
name|returnType
argument_list|)
decl_stmt|;
name|VectorElt
name|vectorElt
init|=
operator|new
name|VectorElt
argument_list|(
name|inputColumns
argument_list|,
name|outputColumnNum
argument_list|)
decl_stmt|;
name|vectorElt
operator|.
name|setChildExpressions
argument_list|(
name|vectorChildren
argument_list|)
expr_stmt|;
name|vectorElt
operator|.
name|setInputTypeInfos
argument_list|(
name|inputTypeInfos
argument_list|)
expr_stmt|;
name|vectorElt
operator|.
name|setInputDataTypePhysicalVariations
argument_list|(
name|inputDataTypePhysicalVariations
argument_list|)
expr_stmt|;
name|vectorElt
operator|.
name|setOutputTypeInfo
argument_list|(
name|returnType
argument_list|)
expr_stmt|;
name|vectorElt
operator|.
name|setOutputDataTypePhysicalVariation
argument_list|(
name|DataTypePhysicalVariation
operator|.
name|NONE
argument_list|)
expr_stmt|;
name|freeNonColumns
argument_list|(
name|vectorChildren
argument_list|)
expr_stmt|;
return|return
name|vectorElt
return|;
block|}
specifier|public
enum|enum
name|InConstantType
block|{
name|INT_FAMILY
block|,
name|TIMESTAMP
block|,
name|DATE
block|,
name|FLOAT_FAMILY
block|,
name|STRING_FAMILY
block|,
name|DECIMAL
block|}
specifier|public
specifier|static
name|InConstantType
name|getInConstantTypeFromPrimitiveCategory
parameter_list|(
name|PrimitiveCategory
name|primitiveCategory
parameter_list|)
block|{
switch|switch
condition|(
name|primitiveCategory
condition|)
block|{
case|case
name|BOOLEAN
case|:
case|case
name|BYTE
case|:
case|case
name|SHORT
case|:
case|case
name|INT
case|:
case|case
name|LONG
case|:
return|return
name|InConstantType
operator|.
name|INT_FAMILY
return|;
case|case
name|DATE
case|:
return|return
name|InConstantType
operator|.
name|TIMESTAMP
return|;
case|case
name|TIMESTAMP
case|:
return|return
name|InConstantType
operator|.
name|DATE
return|;
case|case
name|FLOAT
case|:
case|case
name|DOUBLE
case|:
return|return
name|InConstantType
operator|.
name|FLOAT_FAMILY
return|;
case|case
name|STRING
case|:
case|case
name|CHAR
case|:
case|case
name|VARCHAR
case|:
case|case
name|BINARY
case|:
return|return
name|InConstantType
operator|.
name|STRING_FAMILY
return|;
case|case
name|DECIMAL
case|:
return|return
name|InConstantType
operator|.
name|DECIMAL
return|;
case|case
name|INTERVAL_YEAR_MONTH
case|:
case|case
name|INTERVAL_DAY_TIME
case|:
comment|// UNDONE: Fall through for these... they don't appear to be supported yet.
default|default:
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Unexpected primitive type category "
operator|+
name|primitiveCategory
argument_list|)
throw|;
block|}
block|}
specifier|private
name|VectorExpression
name|getStructInExpression
parameter_list|(
name|List
argument_list|<
name|ExprNodeDesc
argument_list|>
name|childExpr
parameter_list|,
name|ExprNodeDesc
name|colExpr
parameter_list|,
name|TypeInfo
name|colTypeInfo
parameter_list|,
name|List
argument_list|<
name|ExprNodeDesc
argument_list|>
name|inChildren
parameter_list|,
name|VectorExpressionDescriptor
operator|.
name|Mode
name|mode
parameter_list|,
name|TypeInfo
name|returnType
parameter_list|)
throws|throws
name|HiveException
block|{
name|VectorExpression
name|expr
init|=
literal|null
decl_stmt|;
name|StructTypeInfo
name|structTypeInfo
init|=
operator|(
name|StructTypeInfo
operator|)
name|colTypeInfo
decl_stmt|;
name|ArrayList
argument_list|<
name|TypeInfo
argument_list|>
name|fieldTypeInfos
init|=
name|structTypeInfo
operator|.
name|getAllStructFieldTypeInfos
argument_list|()
decl_stmt|;
specifier|final
name|int
name|fieldCount
init|=
name|fieldTypeInfos
operator|.
name|size
argument_list|()
decl_stmt|;
name|ColumnVector
operator|.
name|Type
index|[]
name|fieldVectorColumnTypes
init|=
operator|new
name|ColumnVector
operator|.
name|Type
index|[
name|fieldCount
index|]
decl_stmt|;
name|InConstantType
index|[]
name|fieldInConstantTypes
init|=
operator|new
name|InConstantType
index|[
name|fieldCount
index|]
decl_stmt|;
for|for
control|(
name|int
name|f
init|=
literal|0
init|;
name|f
operator|<
name|fieldCount
condition|;
name|f
operator|++
control|)
block|{
name|TypeInfo
name|fieldTypeInfo
init|=
name|fieldTypeInfos
operator|.
name|get
argument_list|(
name|f
argument_list|)
decl_stmt|;
comment|// Only primitive fields supports for now.
if|if
condition|(
name|fieldTypeInfo
operator|.
name|getCategory
argument_list|()
operator|!=
name|Category
operator|.
name|PRIMITIVE
condition|)
block|{
return|return
literal|null
return|;
block|}
comment|// We are going to serialize using the 4 basic types.
name|ColumnVector
operator|.
name|Type
name|fieldVectorColumnType
init|=
name|getColumnVectorTypeFromTypeInfo
argument_list|(
name|fieldTypeInfo
argument_list|)
decl_stmt|;
name|fieldVectorColumnTypes
index|[
name|f
index|]
operator|=
name|fieldVectorColumnType
expr_stmt|;
comment|// We currently evaluate the IN (..) constants in special ways.
name|PrimitiveCategory
name|fieldPrimitiveCategory
init|=
operator|(
operator|(
name|PrimitiveTypeInfo
operator|)
name|fieldTypeInfo
operator|)
operator|.
name|getPrimitiveCategory
argument_list|()
decl_stmt|;
name|InConstantType
name|inConstantType
init|=
name|getInConstantTypeFromPrimitiveCategory
argument_list|(
name|fieldPrimitiveCategory
argument_list|)
decl_stmt|;
name|fieldInConstantTypes
index|[
name|f
index|]
operator|=
name|inConstantType
expr_stmt|;
block|}
name|Output
name|buffer
init|=
operator|new
name|Output
argument_list|()
decl_stmt|;
name|BinarySortableSerializeWrite
name|binarySortableSerializeWrite
init|=
operator|new
name|BinarySortableSerializeWrite
argument_list|(
name|fieldCount
argument_list|)
decl_stmt|;
specifier|final
name|int
name|inChildrenCount
init|=
name|inChildren
operator|.
name|size
argument_list|()
decl_stmt|;
name|byte
index|[]
index|[]
name|serializedInChildren
init|=
operator|new
name|byte
index|[
name|inChildrenCount
index|]
index|[]
decl_stmt|;
try|try
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|inChildrenCount
condition|;
name|i
operator|++
control|)
block|{
specifier|final
name|ExprNodeDesc
name|node
init|=
name|inChildren
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
specifier|final
name|Object
index|[]
name|constants
decl_stmt|;
if|if
condition|(
name|node
operator|instanceof
name|ExprNodeConstantDesc
condition|)
block|{
name|ExprNodeConstantDesc
name|constNode
init|=
operator|(
name|ExprNodeConstantDesc
operator|)
name|node
decl_stmt|;
name|ConstantObjectInspector
name|output
init|=
name|constNode
operator|.
name|getWritableObjectInspector
argument_list|()
decl_stmt|;
name|constants
operator|=
operator|(
operator|(
name|List
argument_list|<
name|?
argument_list|>
operator|)
name|output
operator|.
name|getWritableConstantValue
argument_list|()
operator|)
operator|.
name|toArray
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|ExprNodeGenericFuncDesc
name|exprNode
init|=
operator|(
name|ExprNodeGenericFuncDesc
operator|)
name|node
decl_stmt|;
name|ExprNodeEvaluator
argument_list|<
name|?
argument_list|>
name|evaluator
init|=
name|ExprNodeEvaluatorFactory
operator|.
name|get
argument_list|(
name|exprNode
argument_list|)
decl_stmt|;
name|ObjectInspector
name|output
init|=
name|evaluator
operator|.
name|initialize
argument_list|(
name|exprNode
operator|.
name|getWritableObjectInspector
argument_list|()
argument_list|)
decl_stmt|;
name|constants
operator|=
operator|(
name|Object
index|[]
operator|)
name|evaluator
operator|.
name|evaluate
argument_list|(
literal|null
argument_list|)
expr_stmt|;
block|}
name|binarySortableSerializeWrite
operator|.
name|set
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|f
init|=
literal|0
init|;
name|f
operator|<
name|fieldCount
condition|;
name|f
operator|++
control|)
block|{
name|Object
name|constant
init|=
name|constants
index|[
name|f
index|]
decl_stmt|;
if|if
condition|(
name|constant
operator|==
literal|null
condition|)
block|{
name|binarySortableSerializeWrite
operator|.
name|writeNull
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|InConstantType
name|inConstantType
init|=
name|fieldInConstantTypes
index|[
name|f
index|]
decl_stmt|;
switch|switch
condition|(
name|inConstantType
condition|)
block|{
case|case
name|STRING_FAMILY
case|:
block|{
name|byte
index|[]
name|bytes
decl_stmt|;
if|if
condition|(
name|constant
operator|instanceof
name|Text
condition|)
block|{
name|Text
name|text
init|=
operator|(
name|Text
operator|)
name|constant
decl_stmt|;
name|bytes
operator|=
name|text
operator|.
name|getBytes
argument_list|()
expr_stmt|;
name|binarySortableSerializeWrite
operator|.
name|writeString
argument_list|(
name|bytes
argument_list|,
literal|0
argument_list|,
name|text
operator|.
name|getLength
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
throw|throw
operator|new
name|HiveException
argument_list|(
literal|"Unexpected constant String type "
operator|+
name|constant
operator|.
name|getClass
argument_list|()
operator|.
name|getSimpleName
argument_list|()
argument_list|)
throw|;
block|}
block|}
break|break;
case|case
name|INT_FAMILY
case|:
block|{
name|long
name|value
decl_stmt|;
if|if
condition|(
name|constant
operator|instanceof
name|IntWritable
condition|)
block|{
name|value
operator|=
operator|(
operator|(
name|IntWritable
operator|)
name|constant
operator|)
operator|.
name|get
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|constant
operator|instanceof
name|LongWritable
condition|)
block|{
name|value
operator|=
operator|(
operator|(
name|LongWritable
operator|)
name|constant
operator|)
operator|.
name|get
argument_list|()
expr_stmt|;
block|}
else|else
block|{
throw|throw
operator|new
name|HiveException
argument_list|(
literal|"Unexpected constant Long type "
operator|+
name|constant
operator|.
name|getClass
argument_list|()
operator|.
name|getSimpleName
argument_list|()
argument_list|)
throw|;
block|}
name|binarySortableSerializeWrite
operator|.
name|writeLong
argument_list|(
name|value
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|FLOAT_FAMILY
case|:
block|{
name|double
name|value
decl_stmt|;
if|if
condition|(
name|constant
operator|instanceof
name|DoubleWritable
condition|)
block|{
name|value
operator|=
operator|(
operator|(
name|DoubleWritable
operator|)
name|constant
operator|)
operator|.
name|get
argument_list|()
expr_stmt|;
block|}
else|else
block|{
throw|throw
operator|new
name|HiveException
argument_list|(
literal|"Unexpected constant Double type "
operator|+
name|constant
operator|.
name|getClass
argument_list|()
operator|.
name|getSimpleName
argument_list|()
argument_list|)
throw|;
block|}
name|binarySortableSerializeWrite
operator|.
name|writeDouble
argument_list|(
name|value
argument_list|)
expr_stmt|;
block|}
break|break;
comment|// UNDONE...
case|case
name|DATE
case|:
case|case
name|TIMESTAMP
case|:
case|case
name|DECIMAL
case|:
default|default:
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Unexpected IN constant type "
operator|+
name|inConstantType
operator|.
name|name
argument_list|()
argument_list|)
throw|;
block|}
block|}
block|}
name|serializedInChildren
index|[
name|i
index|]
operator|=
name|Arrays
operator|.
name|copyOfRange
argument_list|(
name|buffer
operator|.
name|getData
argument_list|()
argument_list|,
literal|0
argument_list|,
name|buffer
operator|.
name|getLength
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|HiveException
argument_list|(
name|e
argument_list|)
throw|;
block|}
comment|// Create a single child representing the scratch column where we will
comment|// generate the serialized keys of the batch.
name|int
name|scratchBytesCol
init|=
name|ocm
operator|.
name|allocateOutputColumn
argument_list|(
name|TypeInfoFactory
operator|.
name|stringTypeInfo
argument_list|)
decl_stmt|;
name|Class
argument_list|<
name|?
argument_list|>
name|cl
init|=
operator|(
name|mode
operator|==
name|VectorExpressionDescriptor
operator|.
name|Mode
operator|.
name|FILTER
condition|?
name|FilterStructColumnInList
operator|.
name|class
else|:
name|StructColumnInList
operator|.
name|class
operator|)
decl_stmt|;
name|expr
operator|=
name|createVectorExpression
argument_list|(
name|cl
argument_list|,
literal|null
argument_list|,
name|VectorExpressionDescriptor
operator|.
name|Mode
operator|.
name|PROJECTION
argument_list|,
name|returnType
argument_list|)
expr_stmt|;
operator|(
operator|(
name|IStringInExpr
operator|)
name|expr
operator|)
operator|.
name|setInListValues
argument_list|(
name|serializedInChildren
argument_list|)
expr_stmt|;
operator|(
operator|(
name|IStructInExpr
operator|)
name|expr
operator|)
operator|.
name|setScratchBytesColumn
argument_list|(
name|scratchBytesCol
argument_list|)
expr_stmt|;
operator|(
operator|(
name|IStructInExpr
operator|)
name|expr
operator|)
operator|.
name|setStructColumnExprs
argument_list|(
name|this
argument_list|,
name|colExpr
operator|.
name|getChildren
argument_list|()
argument_list|,
name|fieldVectorColumnTypes
argument_list|)
expr_stmt|;
return|return
name|expr
return|;
block|}
comment|/**    * Create a filter or boolean-valued expression for column IN (<list-of-constants> )    */
specifier|private
name|VectorExpression
name|getInExpression
parameter_list|(
name|List
argument_list|<
name|ExprNodeDesc
argument_list|>
name|childExpr
parameter_list|,
name|VectorExpressionDescriptor
operator|.
name|Mode
name|mode
parameter_list|,
name|TypeInfo
name|returnType
parameter_list|)
throws|throws
name|HiveException
block|{
name|ExprNodeDesc
name|colExpr
init|=
name|childExpr
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|ExprNodeDesc
argument_list|>
name|inChildren
init|=
name|childExpr
operator|.
name|subList
argument_list|(
literal|1
argument_list|,
name|childExpr
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
name|String
name|colType
init|=
name|colExpr
operator|.
name|getTypeString
argument_list|()
decl_stmt|;
name|colType
operator|=
name|VectorizationContext
operator|.
name|mapTypeNameSynonyms
argument_list|(
name|colType
argument_list|)
expr_stmt|;
name|TypeInfo
name|colTypeInfo
init|=
name|TypeInfoUtils
operator|.
name|getTypeInfoFromTypeString
argument_list|(
name|colType
argument_list|)
decl_stmt|;
name|Category
name|category
init|=
name|colTypeInfo
operator|.
name|getCategory
argument_list|()
decl_stmt|;
if|if
condition|(
name|category
operator|==
name|Category
operator|.
name|STRUCT
condition|)
block|{
return|return
name|getStructInExpression
argument_list|(
name|childExpr
argument_list|,
name|colExpr
argument_list|,
name|colTypeInfo
argument_list|,
name|inChildren
argument_list|,
name|mode
argument_list|,
name|returnType
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|category
operator|!=
name|Category
operator|.
name|PRIMITIVE
condition|)
block|{
return|return
literal|null
return|;
block|}
comment|// prepare arguments for createVectorExpression
name|List
argument_list|<
name|ExprNodeDesc
argument_list|>
name|childrenForInList
init|=
name|evaluateCastOnConstants
argument_list|(
name|inChildren
argument_list|)
decl_stmt|;
comment|/* This method assumes that the IN list has no NULL entries. That is enforced elsewhere,      * in the Vectorizer class. If NULL is passed in as a list entry, behavior is not defined.      * If in the future, NULL values are allowed in the IN list, be sure to handle 3-valued      * logic correctly. E.g. NOT (col IN (null)) should be considered UNKNOWN, so that would      * become FALSE in the WHERE clause, and cause the row in question to be filtered out.      * See the discussion in Jira HIVE-5583.      */
name|VectorExpression
name|expr
init|=
literal|null
decl_stmt|;
comment|// Validate the IN items are only constants.
for|for
control|(
name|ExprNodeDesc
name|inListChild
range|:
name|childrenForInList
control|)
block|{
if|if
condition|(
operator|!
operator|(
name|inListChild
operator|instanceof
name|ExprNodeConstantDesc
operator|)
condition|)
block|{
throw|throw
operator|new
name|HiveException
argument_list|(
literal|"Vectorizing IN expression only supported for constant values"
argument_list|)
throw|;
block|}
block|}
comment|// determine class
name|Class
argument_list|<
name|?
argument_list|>
name|cl
init|=
literal|null
decl_stmt|;
comment|// TODO: the below assumes that all the arguments to IN are of the same type;
comment|//       non-vectorized validates that explicitly during UDF init.
if|if
condition|(
name|isIntFamily
argument_list|(
name|colType
argument_list|)
condition|)
block|{
name|cl
operator|=
operator|(
name|mode
operator|==
name|VectorExpressionDescriptor
operator|.
name|Mode
operator|.
name|FILTER
condition|?
name|FilterLongColumnInList
operator|.
name|class
else|:
name|LongColumnInList
operator|.
name|class
operator|)
expr_stmt|;
name|long
index|[]
name|inVals
init|=
operator|new
name|long
index|[
name|childrenForInList
operator|.
name|size
argument_list|()
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|!=
name|inVals
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|inVals
index|[
name|i
index|]
operator|=
name|getIntFamilyScalarAsLong
argument_list|(
operator|(
name|ExprNodeConstantDesc
operator|)
name|childrenForInList
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|expr
operator|=
name|createVectorExpression
argument_list|(
name|cl
argument_list|,
name|childExpr
operator|.
name|subList
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|)
argument_list|,
name|VectorExpressionDescriptor
operator|.
name|Mode
operator|.
name|PROJECTION
argument_list|,
name|returnType
argument_list|)
expr_stmt|;
operator|(
operator|(
name|ILongInExpr
operator|)
name|expr
operator|)
operator|.
name|setInListValues
argument_list|(
name|inVals
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|isTimestampFamily
argument_list|(
name|colType
argument_list|)
condition|)
block|{
name|cl
operator|=
operator|(
name|mode
operator|==
name|VectorExpressionDescriptor
operator|.
name|Mode
operator|.
name|FILTER
condition|?
name|FilterTimestampColumnInList
operator|.
name|class
else|:
name|TimestampColumnInList
operator|.
name|class
operator|)
expr_stmt|;
name|Timestamp
index|[]
name|inVals
init|=
operator|new
name|Timestamp
index|[
name|childrenForInList
operator|.
name|size
argument_list|()
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|!=
name|inVals
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|inVals
index|[
name|i
index|]
operator|=
name|getTimestampScalar
argument_list|(
name|childrenForInList
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|expr
operator|=
name|createVectorExpression
argument_list|(
name|cl
argument_list|,
name|childExpr
operator|.
name|subList
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|)
argument_list|,
name|VectorExpressionDescriptor
operator|.
name|Mode
operator|.
name|PROJECTION
argument_list|,
name|returnType
argument_list|)
expr_stmt|;
operator|(
operator|(
name|ITimestampInExpr
operator|)
name|expr
operator|)
operator|.
name|setInListValues
argument_list|(
name|inVals
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|isStringFamily
argument_list|(
name|colType
argument_list|)
condition|)
block|{
name|cl
operator|=
operator|(
name|mode
operator|==
name|VectorExpressionDescriptor
operator|.
name|Mode
operator|.
name|FILTER
condition|?
name|FilterStringColumnInList
operator|.
name|class
else|:
name|StringColumnInList
operator|.
name|class
operator|)
expr_stmt|;
name|byte
index|[]
index|[]
name|inVals
init|=
operator|new
name|byte
index|[
name|childrenForInList
operator|.
name|size
argument_list|()
index|]
index|[]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|!=
name|inVals
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|inVals
index|[
name|i
index|]
operator|=
name|getStringScalarAsByteArray
argument_list|(
operator|(
name|ExprNodeConstantDesc
operator|)
name|childrenForInList
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|expr
operator|=
name|createVectorExpression
argument_list|(
name|cl
argument_list|,
name|childExpr
operator|.
name|subList
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|)
argument_list|,
name|VectorExpressionDescriptor
operator|.
name|Mode
operator|.
name|PROJECTION
argument_list|,
name|returnType
argument_list|)
expr_stmt|;
operator|(
operator|(
name|IStringInExpr
operator|)
name|expr
operator|)
operator|.
name|setInListValues
argument_list|(
name|inVals
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|isFloatFamily
argument_list|(
name|colType
argument_list|)
condition|)
block|{
name|cl
operator|=
operator|(
name|mode
operator|==
name|VectorExpressionDescriptor
operator|.
name|Mode
operator|.
name|FILTER
condition|?
name|FilterDoubleColumnInList
operator|.
name|class
else|:
name|DoubleColumnInList
operator|.
name|class
operator|)
expr_stmt|;
name|double
index|[]
name|inValsD
init|=
operator|new
name|double
index|[
name|childrenForInList
operator|.
name|size
argument_list|()
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|!=
name|inValsD
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|inValsD
index|[
name|i
index|]
operator|=
name|getNumericScalarAsDouble
argument_list|(
name|childrenForInList
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|expr
operator|=
name|createVectorExpression
argument_list|(
name|cl
argument_list|,
name|childExpr
operator|.
name|subList
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|)
argument_list|,
name|VectorExpressionDescriptor
operator|.
name|Mode
operator|.
name|PROJECTION
argument_list|,
name|returnType
argument_list|)
expr_stmt|;
operator|(
operator|(
name|IDoubleInExpr
operator|)
name|expr
operator|)
operator|.
name|setInListValues
argument_list|(
name|inValsD
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|isDecimalFamily
argument_list|(
name|colType
argument_list|)
condition|)
block|{
name|cl
operator|=
operator|(
name|mode
operator|==
name|VectorExpressionDescriptor
operator|.
name|Mode
operator|.
name|FILTER
condition|?
name|FilterDecimalColumnInList
operator|.
name|class
else|:
name|DecimalColumnInList
operator|.
name|class
operator|)
expr_stmt|;
name|HiveDecimal
index|[]
name|inValsD
init|=
operator|new
name|HiveDecimal
index|[
name|childrenForInList
operator|.
name|size
argument_list|()
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|!=
name|inValsD
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|inValsD
index|[
name|i
index|]
operator|=
operator|(
name|HiveDecimal
operator|)
name|getVectorTypeScalarValue
argument_list|(
operator|(
name|ExprNodeConstantDesc
operator|)
name|childrenForInList
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|expr
operator|=
name|createVectorExpression
argument_list|(
name|cl
argument_list|,
name|childExpr
operator|.
name|subList
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|)
argument_list|,
name|VectorExpressionDescriptor
operator|.
name|Mode
operator|.
name|PROJECTION
argument_list|,
name|returnType
argument_list|)
expr_stmt|;
operator|(
operator|(
name|IDecimalInExpr
operator|)
name|expr
operator|)
operator|.
name|setInListValues
argument_list|(
name|inValsD
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|isDateFamily
argument_list|(
name|colType
argument_list|)
condition|)
block|{
name|cl
operator|=
operator|(
name|mode
operator|==
name|VectorExpressionDescriptor
operator|.
name|Mode
operator|.
name|FILTER
condition|?
name|FilterLongColumnInList
operator|.
name|class
else|:
name|LongColumnInList
operator|.
name|class
operator|)
expr_stmt|;
name|long
index|[]
name|inVals
init|=
operator|new
name|long
index|[
name|childrenForInList
operator|.
name|size
argument_list|()
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|!=
name|inVals
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|inVals
index|[
name|i
index|]
operator|=
operator|(
name|Long
operator|)
name|getVectorTypeScalarValue
argument_list|(
operator|(
name|ExprNodeConstantDesc
operator|)
name|childrenForInList
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|expr
operator|=
name|createVectorExpression
argument_list|(
name|cl
argument_list|,
name|childExpr
operator|.
name|subList
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|)
argument_list|,
name|VectorExpressionDescriptor
operator|.
name|Mode
operator|.
name|PROJECTION
argument_list|,
name|returnType
argument_list|)
expr_stmt|;
operator|(
operator|(
name|ILongInExpr
operator|)
name|expr
operator|)
operator|.
name|setInListValues
argument_list|(
name|inVals
argument_list|)
expr_stmt|;
block|}
comment|// Return the desired VectorExpression if found. Otherwise, return null to cause
comment|// execution to fall back to row mode.
return|return
name|expr
return|;
block|}
specifier|private
name|byte
index|[]
name|getStringScalarAsByteArray
parameter_list|(
name|ExprNodeConstantDesc
name|exprNodeConstantDesc
parameter_list|)
throws|throws
name|HiveException
block|{
name|Object
name|o
init|=
name|getScalarValue
argument_list|(
name|exprNodeConstantDesc
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|o
operator|instanceof
name|byte
index|[]
operator|)
condition|)
block|{
throw|throw
operator|new
name|HiveException
argument_list|(
literal|"Expected constant argument of type string"
argument_list|)
throw|;
block|}
return|return
operator|(
name|byte
index|[]
operator|)
name|o
return|;
block|}
specifier|private
name|PrimitiveCategory
name|getAnyIntegerPrimitiveCategoryFromUdfClass
parameter_list|(
name|Class
argument_list|<
name|?
extends|extends
name|UDF
argument_list|>
name|udfClass
parameter_list|)
block|{
if|if
condition|(
name|udfClass
operator|.
name|equals
argument_list|(
name|UDFToByte
operator|.
name|class
argument_list|)
condition|)
block|{
return|return
name|PrimitiveCategory
operator|.
name|BYTE
return|;
block|}
elseif|else
if|if
condition|(
name|udfClass
operator|.
name|equals
argument_list|(
name|UDFToShort
operator|.
name|class
argument_list|)
condition|)
block|{
return|return
name|PrimitiveCategory
operator|.
name|SHORT
return|;
block|}
elseif|else
if|if
condition|(
name|udfClass
operator|.
name|equals
argument_list|(
name|UDFToInteger
operator|.
name|class
argument_list|)
condition|)
block|{
return|return
name|PrimitiveCategory
operator|.
name|INT
return|;
block|}
elseif|else
if|if
condition|(
name|udfClass
operator|.
name|equals
argument_list|(
name|UDFToLong
operator|.
name|class
argument_list|)
condition|)
block|{
return|return
name|PrimitiveCategory
operator|.
name|LONG
return|;
block|}
else|else
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Unexpected any integery UDF class "
operator|+
name|udfClass
operator|.
name|getName
argument_list|()
argument_list|)
throw|;
block|}
block|}
comment|/**    * Invoke special handling for expressions that can't be vectorized by regular    * descriptor based lookup.    */
specifier|private
name|VectorExpression
name|getGenericUDFBridgeVectorExpression
parameter_list|(
name|GenericUDFBridge
name|udf
parameter_list|,
name|List
argument_list|<
name|ExprNodeDesc
argument_list|>
name|childExpr
parameter_list|,
name|VectorExpressionDescriptor
operator|.
name|Mode
name|mode
parameter_list|,
name|TypeInfo
name|returnType
parameter_list|)
throws|throws
name|HiveException
block|{
name|Class
argument_list|<
name|?
extends|extends
name|UDF
argument_list|>
name|cl
init|=
name|udf
operator|.
name|getUdfClass
argument_list|()
decl_stmt|;
name|VectorExpression
name|ve
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|isCastToIntFamily
argument_list|(
name|cl
argument_list|)
condition|)
block|{
name|PrimitiveCategory
name|integerPrimitiveCategory
init|=
name|getAnyIntegerPrimitiveCategoryFromUdfClass
argument_list|(
name|cl
argument_list|)
decl_stmt|;
name|ve
operator|=
name|getCastToLongExpression
argument_list|(
name|childExpr
argument_list|,
name|integerPrimitiveCategory
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cl
operator|.
name|equals
argument_list|(
name|UDFToBoolean
operator|.
name|class
argument_list|)
condition|)
block|{
name|ve
operator|=
name|getCastToBoolean
argument_list|(
name|childExpr
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|isCastToFloatFamily
argument_list|(
name|cl
argument_list|)
condition|)
block|{
name|ve
operator|=
name|getCastToDoubleExpression
argument_list|(
name|cl
argument_list|,
name|childExpr
argument_list|,
name|returnType
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cl
operator|.
name|equals
argument_list|(
name|UDFToString
operator|.
name|class
argument_list|)
condition|)
block|{
name|ve
operator|=
name|getCastToString
argument_list|(
name|childExpr
argument_list|,
name|returnType
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ve
operator|==
literal|null
operator|&&
name|childExpr
operator|instanceof
name|ExprNodeGenericFuncDesc
condition|)
block|{
name|ve
operator|=
name|getCustomUDFExpression
argument_list|(
operator|(
name|ExprNodeGenericFuncDesc
operator|)
name|childExpr
argument_list|,
name|mode
argument_list|)
expr_stmt|;
block|}
return|return
name|ve
return|;
block|}
specifier|private
name|HiveDecimal
name|castConstantToDecimal
parameter_list|(
name|Object
name|scalar
parameter_list|,
name|TypeInfo
name|type
parameter_list|)
throws|throws
name|HiveException
block|{
if|if
condition|(
literal|null
operator|==
name|scalar
condition|)
block|{
return|return
literal|null
return|;
block|}
name|PrimitiveTypeInfo
name|ptinfo
init|=
operator|(
name|PrimitiveTypeInfo
operator|)
name|type
decl_stmt|;
name|String
name|typename
init|=
name|type
operator|.
name|getTypeName
argument_list|()
decl_stmt|;
name|HiveDecimal
name|rawDecimal
decl_stmt|;
switch|switch
condition|(
name|ptinfo
operator|.
name|getPrimitiveCategory
argument_list|()
condition|)
block|{
case|case
name|FLOAT
case|:
name|rawDecimal
operator|=
name|HiveDecimal
operator|.
name|create
argument_list|(
name|String
operator|.
name|valueOf
argument_list|(
name|scalar
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|DOUBLE
case|:
name|rawDecimal
operator|=
name|HiveDecimal
operator|.
name|create
argument_list|(
name|String
operator|.
name|valueOf
argument_list|(
name|scalar
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|BYTE
case|:
name|rawDecimal
operator|=
name|HiveDecimal
operator|.
name|create
argument_list|(
operator|(
name|Byte
operator|)
name|scalar
argument_list|)
expr_stmt|;
break|break;
case|case
name|SHORT
case|:
name|rawDecimal
operator|=
name|HiveDecimal
operator|.
name|create
argument_list|(
operator|(
name|Short
operator|)
name|scalar
argument_list|)
expr_stmt|;
break|break;
case|case
name|INT
case|:
name|rawDecimal
operator|=
name|HiveDecimal
operator|.
name|create
argument_list|(
operator|(
name|Integer
operator|)
name|scalar
argument_list|)
expr_stmt|;
break|break;
case|case
name|LONG
case|:
name|rawDecimal
operator|=
name|HiveDecimal
operator|.
name|create
argument_list|(
operator|(
name|Long
operator|)
name|scalar
argument_list|)
expr_stmt|;
break|break;
case|case
name|DECIMAL
case|:
name|rawDecimal
operator|=
operator|(
name|HiveDecimal
operator|)
name|scalar
expr_stmt|;
break|break;
default|default:
throw|throw
operator|new
name|HiveException
argument_list|(
literal|"Unsupported type "
operator|+
name|typename
operator|+
literal|" for cast to HiveDecimal"
argument_list|)
throw|;
block|}
if|if
condition|(
name|rawDecimal
operator|==
literal|null
condition|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Casting constant scalar "
operator|+
name|scalar
operator|+
literal|" to HiveDecimal resulted in null"
argument_list|)
expr_stmt|;
block|}
return|return
literal|null
return|;
block|}
return|return
name|rawDecimal
return|;
block|}
specifier|private
name|String
name|castConstantToString
parameter_list|(
name|Object
name|scalar
parameter_list|,
name|TypeInfo
name|type
parameter_list|)
throws|throws
name|HiveException
block|{
if|if
condition|(
literal|null
operator|==
name|scalar
condition|)
block|{
return|return
literal|null
return|;
block|}
name|PrimitiveTypeInfo
name|ptinfo
init|=
operator|(
name|PrimitiveTypeInfo
operator|)
name|type
decl_stmt|;
name|String
name|typename
init|=
name|type
operator|.
name|getTypeName
argument_list|()
decl_stmt|;
switch|switch
condition|(
name|ptinfo
operator|.
name|getPrimitiveCategory
argument_list|()
condition|)
block|{
case|case
name|FLOAT
case|:
case|case
name|DOUBLE
case|:
case|case
name|BYTE
case|:
case|case
name|SHORT
case|:
case|case
name|INT
case|:
case|case
name|LONG
case|:
return|return
operator|(
operator|(
name|Number
operator|)
name|scalar
operator|)
operator|.
name|toString
argument_list|()
return|;
case|case
name|DECIMAL
case|:
name|HiveDecimal
name|decimalVal
init|=
operator|(
name|HiveDecimal
operator|)
name|scalar
decl_stmt|;
return|return
name|decimalVal
operator|.
name|toString
argument_list|()
return|;
default|default:
throw|throw
operator|new
name|HiveException
argument_list|(
literal|"Unsupported type "
operator|+
name|typename
operator|+
literal|" for cast to String"
argument_list|)
throw|;
block|}
block|}
specifier|private
name|Double
name|castConstantToDouble
parameter_list|(
name|Object
name|scalar
parameter_list|,
name|TypeInfo
name|type
parameter_list|)
throws|throws
name|HiveException
block|{
if|if
condition|(
literal|null
operator|==
name|scalar
condition|)
block|{
return|return
literal|null
return|;
block|}
name|PrimitiveTypeInfo
name|ptinfo
init|=
operator|(
name|PrimitiveTypeInfo
operator|)
name|type
decl_stmt|;
name|String
name|typename
init|=
name|type
operator|.
name|getTypeName
argument_list|()
decl_stmt|;
switch|switch
condition|(
name|ptinfo
operator|.
name|getPrimitiveCategory
argument_list|()
condition|)
block|{
case|case
name|FLOAT
case|:
case|case
name|DOUBLE
case|:
case|case
name|BYTE
case|:
case|case
name|SHORT
case|:
case|case
name|INT
case|:
case|case
name|LONG
case|:
return|return
operator|(
operator|(
name|Number
operator|)
name|scalar
operator|)
operator|.
name|doubleValue
argument_list|()
return|;
case|case
name|DECIMAL
case|:
name|HiveDecimal
name|decimalVal
init|=
operator|(
name|HiveDecimal
operator|)
name|scalar
decl_stmt|;
return|return
name|decimalVal
operator|.
name|doubleValue
argument_list|()
return|;
default|default:
throw|throw
operator|new
name|HiveException
argument_list|(
literal|"Unsupported type "
operator|+
name|typename
operator|+
literal|" for cast to Double"
argument_list|)
throw|;
block|}
block|}
specifier|private
name|Long
name|castConstantToLong
parameter_list|(
name|Object
name|scalar
parameter_list|,
name|TypeInfo
name|type
parameter_list|,
name|PrimitiveCategory
name|integerPrimitiveCategory
parameter_list|)
throws|throws
name|HiveException
block|{
if|if
condition|(
literal|null
operator|==
name|scalar
condition|)
block|{
return|return
literal|null
return|;
block|}
name|PrimitiveTypeInfo
name|ptinfo
init|=
operator|(
name|PrimitiveTypeInfo
operator|)
name|type
decl_stmt|;
name|String
name|typename
init|=
name|type
operator|.
name|getTypeName
argument_list|()
decl_stmt|;
switch|switch
condition|(
name|ptinfo
operator|.
name|getPrimitiveCategory
argument_list|()
condition|)
block|{
case|case
name|FLOAT
case|:
case|case
name|DOUBLE
case|:
case|case
name|BYTE
case|:
case|case
name|SHORT
case|:
case|case
name|INT
case|:
case|case
name|LONG
case|:
return|return
operator|(
operator|(
name|Number
operator|)
name|scalar
operator|)
operator|.
name|longValue
argument_list|()
return|;
case|case
name|DECIMAL
case|:
name|HiveDecimal
name|decimalVal
init|=
operator|(
name|HiveDecimal
operator|)
name|scalar
decl_stmt|;
switch|switch
condition|(
name|integerPrimitiveCategory
condition|)
block|{
case|case
name|BYTE
case|:
if|if
condition|(
operator|!
name|decimalVal
operator|.
name|isByte
argument_list|()
condition|)
block|{
comment|// Accurate byte value cannot be obtained.
return|return
literal|null
return|;
block|}
break|break;
case|case
name|SHORT
case|:
if|if
condition|(
operator|!
name|decimalVal
operator|.
name|isShort
argument_list|()
condition|)
block|{
comment|// Accurate short value cannot be obtained.
return|return
literal|null
return|;
block|}
break|break;
case|case
name|INT
case|:
if|if
condition|(
operator|!
name|decimalVal
operator|.
name|isInt
argument_list|()
condition|)
block|{
comment|// Accurate int value cannot be obtained.
return|return
literal|null
return|;
block|}
break|break;
case|case
name|LONG
case|:
if|if
condition|(
operator|!
name|decimalVal
operator|.
name|isLong
argument_list|()
condition|)
block|{
comment|// Accurate long value cannot be obtained.
return|return
literal|null
return|;
block|}
break|break;
default|default:
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Unexpected integer primitive type "
operator|+
name|integerPrimitiveCategory
argument_list|)
throw|;
block|}
comment|// We only store longs in our LongColumnVector.
return|return
name|decimalVal
operator|.
name|longValue
argument_list|()
return|;
default|default:
throw|throw
operator|new
name|HiveException
argument_list|(
literal|"Unsupported type "
operator|+
name|typename
operator|+
literal|" for cast to Long"
argument_list|)
throw|;
block|}
block|}
comment|/*    * This method must return the decimal TypeInfo for what getCastToDecimal will produce.    */
specifier|private
name|DecimalTypeInfo
name|decimalTypeFromCastToDecimal
parameter_list|(
name|ExprNodeDesc
name|exprNodeDesc
parameter_list|,
name|DecimalTypeInfo
name|returnDecimalType
parameter_list|)
throws|throws
name|HiveException
block|{
if|if
condition|(
name|exprNodeDesc
operator|instanceof
name|ExprNodeConstantDesc
condition|)
block|{
comment|// Return a constant vector expression
name|Object
name|constantValue
init|=
operator|(
operator|(
name|ExprNodeConstantDesc
operator|)
name|exprNodeDesc
operator|)
operator|.
name|getValue
argument_list|()
decl_stmt|;
name|HiveDecimal
name|decimalValue
init|=
name|castConstantToDecimal
argument_list|(
name|constantValue
argument_list|,
name|exprNodeDesc
operator|.
name|getTypeInfo
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|decimalValue
operator|==
literal|null
condition|)
block|{
comment|// Return something.
return|return
name|returnDecimalType
return|;
block|}
return|return
operator|new
name|DecimalTypeInfo
argument_list|(
name|decimalValue
operator|.
name|precision
argument_list|()
argument_list|,
name|decimalValue
operator|.
name|scale
argument_list|()
argument_list|)
return|;
block|}
name|String
name|inputType
init|=
name|exprNodeDesc
operator|.
name|getTypeString
argument_list|()
decl_stmt|;
if|if
condition|(
name|isIntFamily
argument_list|(
name|inputType
argument_list|)
operator|||
name|isFloatFamily
argument_list|(
name|inputType
argument_list|)
operator|||
name|decimalTypePattern
operator|.
name|matcher
argument_list|(
name|inputType
argument_list|)
operator|.
name|matches
argument_list|()
operator|||
name|isStringFamily
argument_list|(
name|inputType
argument_list|)
operator|||
name|inputType
operator|.
name|equals
argument_list|(
literal|"timestamp"
argument_list|)
condition|)
block|{
return|return
name|returnDecimalType
return|;
block|}
return|return
literal|null
return|;
block|}
specifier|private
name|VectorExpression
name|getCastToDecimal
parameter_list|(
name|List
argument_list|<
name|ExprNodeDesc
argument_list|>
name|childExpr
parameter_list|,
name|TypeInfo
name|returnType
parameter_list|)
throws|throws
name|HiveException
block|{
name|ExprNodeDesc
name|child
init|=
name|childExpr
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|String
name|inputType
init|=
name|childExpr
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|getTypeString
argument_list|()
decl_stmt|;
if|if
condition|(
name|child
operator|instanceof
name|ExprNodeConstantDesc
condition|)
block|{
comment|// Return a constant vector expression
name|Object
name|constantValue
init|=
operator|(
operator|(
name|ExprNodeConstantDesc
operator|)
name|child
operator|)
operator|.
name|getValue
argument_list|()
decl_stmt|;
name|HiveDecimal
name|decimalValue
init|=
name|castConstantToDecimal
argument_list|(
name|constantValue
argument_list|,
name|child
operator|.
name|getTypeInfo
argument_list|()
argument_list|)
decl_stmt|;
return|return
name|getConstantVectorExpression
argument_list|(
name|decimalValue
argument_list|,
name|returnType
argument_list|,
name|VectorExpressionDescriptor
operator|.
name|Mode
operator|.
name|PROJECTION
argument_list|)
return|;
block|}
if|if
condition|(
name|isIntFamily
argument_list|(
name|inputType
argument_list|)
condition|)
block|{
return|return
name|createVectorExpression
argument_list|(
name|CastLongToDecimal
operator|.
name|class
argument_list|,
name|childExpr
argument_list|,
name|VectorExpressionDescriptor
operator|.
name|Mode
operator|.
name|PROJECTION
argument_list|,
name|returnType
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|isFloatFamily
argument_list|(
name|inputType
argument_list|)
condition|)
block|{
return|return
name|createVectorExpression
argument_list|(
name|CastDoubleToDecimal
operator|.
name|class
argument_list|,
name|childExpr
argument_list|,
name|VectorExpressionDescriptor
operator|.
name|Mode
operator|.
name|PROJECTION
argument_list|,
name|returnType
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|decimalTypePattern
operator|.
name|matcher
argument_list|(
name|inputType
argument_list|)
operator|.
name|matches
argument_list|()
condition|)
block|{
if|if
condition|(
name|child
operator|instanceof
name|ExprNodeColumnDesc
condition|)
block|{
name|int
name|colIndex
init|=
name|getInputColumnIndex
argument_list|(
operator|(
name|ExprNodeColumnDesc
operator|)
name|child
argument_list|)
decl_stmt|;
name|DataTypePhysicalVariation
name|dataTypePhysicalVariation
init|=
name|getDataTypePhysicalVariation
argument_list|(
name|colIndex
argument_list|)
decl_stmt|;
if|if
condition|(
name|dataTypePhysicalVariation
operator|==
name|DataTypePhysicalVariation
operator|.
name|DECIMAL_64
condition|)
block|{
comment|// Do Decimal64 conversion instead.
return|return
name|createDecimal64ToDecimalConversion
argument_list|(
name|colIndex
argument_list|,
name|returnType
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|createVectorExpression
argument_list|(
name|CastDecimalToDecimal
operator|.
name|class
argument_list|,
name|childExpr
argument_list|,
name|VectorExpressionDescriptor
operator|.
name|Mode
operator|.
name|PROJECTION
argument_list|,
name|returnType
argument_list|)
return|;
block|}
block|}
else|else
block|{
return|return
name|createVectorExpression
argument_list|(
name|CastDecimalToDecimal
operator|.
name|class
argument_list|,
name|childExpr
argument_list|,
name|VectorExpressionDescriptor
operator|.
name|Mode
operator|.
name|PROJECTION
argument_list|,
name|returnType
argument_list|)
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|isStringFamily
argument_list|(
name|inputType
argument_list|)
condition|)
block|{
return|return
name|createVectorExpression
argument_list|(
name|CastStringToDecimal
operator|.
name|class
argument_list|,
name|childExpr
argument_list|,
name|VectorExpressionDescriptor
operator|.
name|Mode
operator|.
name|PROJECTION
argument_list|,
name|returnType
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|inputType
operator|.
name|equals
argument_list|(
literal|"timestamp"
argument_list|)
condition|)
block|{
return|return
name|createVectorExpression
argument_list|(
name|CastTimestampToDecimal
operator|.
name|class
argument_list|,
name|childExpr
argument_list|,
name|VectorExpressionDescriptor
operator|.
name|Mode
operator|.
name|PROJECTION
argument_list|,
name|returnType
argument_list|)
return|;
block|}
return|return
literal|null
return|;
block|}
specifier|private
name|VectorExpression
name|getCastToString
parameter_list|(
name|List
argument_list|<
name|ExprNodeDesc
argument_list|>
name|childExpr
parameter_list|,
name|TypeInfo
name|returnType
parameter_list|)
throws|throws
name|HiveException
block|{
name|ExprNodeDesc
name|child
init|=
name|childExpr
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|String
name|inputType
init|=
name|childExpr
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|getTypeString
argument_list|()
decl_stmt|;
if|if
condition|(
name|child
operator|instanceof
name|ExprNodeConstantDesc
condition|)
block|{
comment|// Return a constant vector expression
name|Object
name|constantValue
init|=
operator|(
operator|(
name|ExprNodeConstantDesc
operator|)
name|child
operator|)
operator|.
name|getValue
argument_list|()
decl_stmt|;
name|String
name|strValue
init|=
name|castConstantToString
argument_list|(
name|constantValue
argument_list|,
name|child
operator|.
name|getTypeInfo
argument_list|()
argument_list|)
decl_stmt|;
return|return
name|getConstantVectorExpression
argument_list|(
name|strValue
argument_list|,
name|returnType
argument_list|,
name|VectorExpressionDescriptor
operator|.
name|Mode
operator|.
name|PROJECTION
argument_list|)
return|;
block|}
if|if
condition|(
name|inputType
operator|.
name|equals
argument_list|(
literal|"boolean"
argument_list|)
condition|)
block|{
comment|// Boolean must come before the integer family. It's a special case.
return|return
name|createVectorExpression
argument_list|(
name|CastBooleanToStringViaLongToString
operator|.
name|class
argument_list|,
name|childExpr
argument_list|,
name|VectorExpressionDescriptor
operator|.
name|Mode
operator|.
name|PROJECTION
argument_list|,
name|returnType
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|isIntFamily
argument_list|(
name|inputType
argument_list|)
condition|)
block|{
return|return
name|createVectorExpression
argument_list|(
name|CastLongToString
operator|.
name|class
argument_list|,
name|childExpr
argument_list|,
name|VectorExpressionDescriptor
operator|.
name|Mode
operator|.
name|PROJECTION
argument_list|,
name|returnType
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|inputType
operator|.
name|equals
argument_list|(
literal|"float"
argument_list|)
condition|)
block|{
return|return
name|createVectorExpression
argument_list|(
name|CastFloatToString
operator|.
name|class
argument_list|,
name|childExpr
argument_list|,
name|VectorExpressionDescriptor
operator|.
name|Mode
operator|.
name|PROJECTION
argument_list|,
name|returnType
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|inputType
operator|.
name|equals
argument_list|(
literal|"double"
argument_list|)
condition|)
block|{
return|return
name|createVectorExpression
argument_list|(
name|CastDoubleToString
operator|.
name|class
argument_list|,
name|childExpr
argument_list|,
name|VectorExpressionDescriptor
operator|.
name|Mode
operator|.
name|PROJECTION
argument_list|,
name|returnType
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|isDecimalFamily
argument_list|(
name|inputType
argument_list|)
condition|)
block|{
return|return
name|createVectorExpression
argument_list|(
name|CastDecimalToString
operator|.
name|class
argument_list|,
name|childExpr
argument_list|,
name|VectorExpressionDescriptor
operator|.
name|Mode
operator|.
name|PROJECTION
argument_list|,
name|returnType
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|isDateFamily
argument_list|(
name|inputType
argument_list|)
condition|)
block|{
return|return
name|createVectorExpression
argument_list|(
name|CastDateToString
operator|.
name|class
argument_list|,
name|childExpr
argument_list|,
name|VectorExpressionDescriptor
operator|.
name|Mode
operator|.
name|PROJECTION
argument_list|,
name|returnType
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|isStringFamily
argument_list|(
name|inputType
argument_list|)
condition|)
block|{
return|return
name|createVectorExpression
argument_list|(
name|CastStringGroupToString
operator|.
name|class
argument_list|,
name|childExpr
argument_list|,
name|VectorExpressionDescriptor
operator|.
name|Mode
operator|.
name|PROJECTION
argument_list|,
name|returnType
argument_list|)
return|;
block|}
return|return
literal|null
return|;
block|}
specifier|private
name|VectorExpression
name|getCastToChar
parameter_list|(
name|List
argument_list|<
name|ExprNodeDesc
argument_list|>
name|childExpr
parameter_list|,
name|TypeInfo
name|returnType
parameter_list|)
throws|throws
name|HiveException
block|{
name|ExprNodeDesc
name|child
init|=
name|childExpr
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|String
name|inputType
init|=
name|childExpr
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|getTypeString
argument_list|()
decl_stmt|;
if|if
condition|(
name|child
operator|instanceof
name|ExprNodeConstantDesc
condition|)
block|{
comment|// Don't do constant folding here.  Wait until the optimizer is changed to do it.
comment|// Family of related JIRAs: HIVE-7421, HIVE-7422, and HIVE-7424.
return|return
literal|null
return|;
block|}
if|if
condition|(
name|inputType
operator|.
name|equals
argument_list|(
literal|"boolean"
argument_list|)
condition|)
block|{
comment|// Boolean must come before the integer family. It's a special case.
return|return
name|createVectorExpression
argument_list|(
name|CastBooleanToCharViaLongToChar
operator|.
name|class
argument_list|,
name|childExpr
argument_list|,
name|VectorExpressionDescriptor
operator|.
name|Mode
operator|.
name|PROJECTION
argument_list|,
name|returnType
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|isIntFamily
argument_list|(
name|inputType
argument_list|)
condition|)
block|{
return|return
name|createVectorExpression
argument_list|(
name|CastLongToChar
operator|.
name|class
argument_list|,
name|childExpr
argument_list|,
name|VectorExpressionDescriptor
operator|.
name|Mode
operator|.
name|PROJECTION
argument_list|,
name|returnType
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|inputType
operator|.
name|equals
argument_list|(
literal|"float"
argument_list|)
condition|)
block|{
return|return
name|createVectorExpression
argument_list|(
name|CastFloatToChar
operator|.
name|class
argument_list|,
name|childExpr
argument_list|,
name|VectorExpressionDescriptor
operator|.
name|Mode
operator|.
name|PROJECTION
argument_list|,
name|returnType
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|inputType
operator|.
name|equals
argument_list|(
literal|"double"
argument_list|)
condition|)
block|{
return|return
name|createVectorExpression
argument_list|(
name|CastDoubleToChar
operator|.
name|class
argument_list|,
name|childExpr
argument_list|,
name|VectorExpressionDescriptor
operator|.
name|Mode
operator|.
name|PROJECTION
argument_list|,
name|returnType
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|isDecimalFamily
argument_list|(
name|inputType
argument_list|)
condition|)
block|{
return|return
name|createVectorExpression
argument_list|(
name|CastDecimalToChar
operator|.
name|class
argument_list|,
name|childExpr
argument_list|,
name|VectorExpressionDescriptor
operator|.
name|Mode
operator|.
name|PROJECTION
argument_list|,
name|returnType
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|isDateFamily
argument_list|(
name|inputType
argument_list|)
condition|)
block|{
return|return
name|createVectorExpression
argument_list|(
name|CastDateToChar
operator|.
name|class
argument_list|,
name|childExpr
argument_list|,
name|VectorExpressionDescriptor
operator|.
name|Mode
operator|.
name|PROJECTION
argument_list|,
name|returnType
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|isStringFamily
argument_list|(
name|inputType
argument_list|)
condition|)
block|{
return|return
name|createVectorExpression
argument_list|(
name|CastStringGroupToChar
operator|.
name|class
argument_list|,
name|childExpr
argument_list|,
name|VectorExpressionDescriptor
operator|.
name|Mode
operator|.
name|PROJECTION
argument_list|,
name|returnType
argument_list|)
return|;
block|}
return|return
literal|null
return|;
block|}
specifier|private
name|VectorExpression
name|getCastToVarChar
parameter_list|(
name|List
argument_list|<
name|ExprNodeDesc
argument_list|>
name|childExpr
parameter_list|,
name|TypeInfo
name|returnType
parameter_list|)
throws|throws
name|HiveException
block|{
name|ExprNodeDesc
name|child
init|=
name|childExpr
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|String
name|inputType
init|=
name|childExpr
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|getTypeString
argument_list|()
decl_stmt|;
if|if
condition|(
name|child
operator|instanceof
name|ExprNodeConstantDesc
condition|)
block|{
comment|// Don't do constant folding here.  Wait until the optimizer is changed to do it.
comment|// Family of related JIRAs: HIVE-7421, HIVE-7422, and HIVE-7424.
return|return
literal|null
return|;
block|}
if|if
condition|(
name|inputType
operator|.
name|equals
argument_list|(
literal|"boolean"
argument_list|)
condition|)
block|{
comment|// Boolean must come before the integer family. It's a special case.
return|return
name|createVectorExpression
argument_list|(
name|CastBooleanToVarCharViaLongToVarChar
operator|.
name|class
argument_list|,
name|childExpr
argument_list|,
name|VectorExpressionDescriptor
operator|.
name|Mode
operator|.
name|PROJECTION
argument_list|,
name|returnType
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|isIntFamily
argument_list|(
name|inputType
argument_list|)
condition|)
block|{
return|return
name|createVectorExpression
argument_list|(
name|CastLongToVarChar
operator|.
name|class
argument_list|,
name|childExpr
argument_list|,
name|VectorExpressionDescriptor
operator|.
name|Mode
operator|.
name|PROJECTION
argument_list|,
name|returnType
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|inputType
operator|.
name|equals
argument_list|(
literal|"float"
argument_list|)
condition|)
block|{
return|return
name|createVectorExpression
argument_list|(
name|CastFloatToVarChar
operator|.
name|class
argument_list|,
name|childExpr
argument_list|,
name|VectorExpressionDescriptor
operator|.
name|Mode
operator|.
name|PROJECTION
argument_list|,
name|returnType
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|inputType
operator|.
name|equals
argument_list|(
literal|"double"
argument_list|)
condition|)
block|{
return|return
name|createVectorExpression
argument_list|(
name|CastDoubleToVarChar
operator|.
name|class
argument_list|,
name|childExpr
argument_list|,
name|VectorExpressionDescriptor
operator|.
name|Mode
operator|.
name|PROJECTION
argument_list|,
name|returnType
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|isDecimalFamily
argument_list|(
name|inputType
argument_list|)
condition|)
block|{
return|return
name|createVectorExpression
argument_list|(
name|CastDecimalToVarChar
operator|.
name|class
argument_list|,
name|childExpr
argument_list|,
name|VectorExpressionDescriptor
operator|.
name|Mode
operator|.
name|PROJECTION
argument_list|,
name|returnType
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|isDateFamily
argument_list|(
name|inputType
argument_list|)
condition|)
block|{
return|return
name|createVectorExpression
argument_list|(
name|CastDateToVarChar
operator|.
name|class
argument_list|,
name|childExpr
argument_list|,
name|VectorExpressionDescriptor
operator|.
name|Mode
operator|.
name|PROJECTION
argument_list|,
name|returnType
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|isStringFamily
argument_list|(
name|inputType
argument_list|)
condition|)
block|{
return|return
name|createVectorExpression
argument_list|(
name|CastStringGroupToVarChar
operator|.
name|class
argument_list|,
name|childExpr
argument_list|,
name|VectorExpressionDescriptor
operator|.
name|Mode
operator|.
name|PROJECTION
argument_list|,
name|returnType
argument_list|)
return|;
block|}
return|return
literal|null
return|;
block|}
specifier|private
name|VectorExpression
name|getCastToDoubleExpression
parameter_list|(
name|Class
argument_list|<
name|?
argument_list|>
name|udf
parameter_list|,
name|List
argument_list|<
name|ExprNodeDesc
argument_list|>
name|childExpr
parameter_list|,
name|TypeInfo
name|returnType
parameter_list|)
throws|throws
name|HiveException
block|{
name|ExprNodeDesc
name|child
init|=
name|childExpr
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|String
name|inputType
init|=
name|childExpr
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|getTypeString
argument_list|()
decl_stmt|;
if|if
condition|(
name|child
operator|instanceof
name|ExprNodeConstantDesc
condition|)
block|{
comment|// Return a constant vector expression
name|Object
name|constantValue
init|=
operator|(
operator|(
name|ExprNodeConstantDesc
operator|)
name|child
operator|)
operator|.
name|getValue
argument_list|()
decl_stmt|;
name|Double
name|doubleValue
init|=
name|castConstantToDouble
argument_list|(
name|constantValue
argument_list|,
name|child
operator|.
name|getTypeInfo
argument_list|()
argument_list|)
decl_stmt|;
return|return
name|getConstantVectorExpression
argument_list|(
name|doubleValue
argument_list|,
name|returnType
argument_list|,
name|VectorExpressionDescriptor
operator|.
name|Mode
operator|.
name|PROJECTION
argument_list|)
return|;
block|}
if|if
condition|(
name|isIntFamily
argument_list|(
name|inputType
argument_list|)
condition|)
block|{
if|if
condition|(
name|udf
operator|.
name|equals
argument_list|(
name|UDFToFloat
operator|.
name|class
argument_list|)
condition|)
block|{
comment|// In order to convert from integer to float correctly, we need to apply the float cast not the double cast (HIVE-13338).
return|return
name|createVectorExpression
argument_list|(
name|CastLongToFloatViaLongToDouble
operator|.
name|class
argument_list|,
name|childExpr
argument_list|,
name|VectorExpressionDescriptor
operator|.
name|Mode
operator|.
name|PROJECTION
argument_list|,
name|returnType
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|createVectorExpression
argument_list|(
name|CastLongToDouble
operator|.
name|class
argument_list|,
name|childExpr
argument_list|,
name|VectorExpressionDescriptor
operator|.
name|Mode
operator|.
name|PROJECTION
argument_list|,
name|returnType
argument_list|)
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|inputType
operator|.
name|equals
argument_list|(
literal|"timestamp"
argument_list|)
condition|)
block|{
return|return
name|createVectorExpression
argument_list|(
name|CastTimestampToDouble
operator|.
name|class
argument_list|,
name|childExpr
argument_list|,
name|VectorExpressionDescriptor
operator|.
name|Mode
operator|.
name|PROJECTION
argument_list|,
name|returnType
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|isFloatFamily
argument_list|(
name|inputType
argument_list|)
condition|)
block|{
comment|// float types require no conversion, so use a no-op
return|return
name|getIdentityExpression
argument_list|(
name|childExpr
argument_list|)
return|;
block|}
return|return
literal|null
return|;
block|}
specifier|private
name|VectorExpression
name|getCastToBoolean
parameter_list|(
name|List
argument_list|<
name|ExprNodeDesc
argument_list|>
name|childExpr
parameter_list|)
throws|throws
name|HiveException
block|{
name|ExprNodeDesc
name|child
init|=
name|childExpr
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|TypeInfo
name|inputTypeInfo
init|=
name|child
operator|.
name|getTypeInfo
argument_list|()
decl_stmt|;
name|String
name|inputType
init|=
name|inputTypeInfo
operator|.
name|toString
argument_list|()
decl_stmt|;
if|if
condition|(
name|child
operator|instanceof
name|ExprNodeConstantDesc
condition|)
block|{
if|if
condition|(
literal|null
operator|==
operator|(
operator|(
name|ExprNodeConstantDesc
operator|)
name|child
operator|)
operator|.
name|getValue
argument_list|()
condition|)
block|{
return|return
name|getConstantVectorExpression
argument_list|(
literal|null
argument_list|,
name|TypeInfoFactory
operator|.
name|booleanTypeInfo
argument_list|,
name|VectorExpressionDescriptor
operator|.
name|Mode
operator|.
name|PROJECTION
argument_list|)
return|;
block|}
comment|// Don't do constant folding here.  Wait until the optimizer is changed to do it.
comment|// Family of related JIRAs: HIVE-7421, HIVE-7422, and HIVE-7424.
return|return
literal|null
return|;
block|}
comment|// Long and double are handled using descriptors, string needs to be specially handled.
if|if
condition|(
name|isStringFamily
argument_list|(
name|inputType
argument_list|)
condition|)
block|{
name|VectorExpression
name|lenExpr
init|=
name|createVectorExpression
argument_list|(
name|CastStringToBoolean
operator|.
name|class
argument_list|,
name|childExpr
argument_list|,
name|VectorExpressionDescriptor
operator|.
name|Mode
operator|.
name|PROJECTION
argument_list|,
name|TypeInfoFactory
operator|.
name|booleanTypeInfo
argument_list|)
decl_stmt|;
return|return
name|lenExpr
return|;
block|}
return|return
literal|null
return|;
block|}
specifier|private
name|VectorExpression
name|getCastToLongExpression
parameter_list|(
name|List
argument_list|<
name|ExprNodeDesc
argument_list|>
name|childExpr
parameter_list|,
name|PrimitiveCategory
name|integerPrimitiveCategory
parameter_list|)
throws|throws
name|HiveException
block|{
name|ExprNodeDesc
name|child
init|=
name|childExpr
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|String
name|inputType
init|=
name|childExpr
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|getTypeString
argument_list|()
decl_stmt|;
if|if
condition|(
name|child
operator|instanceof
name|ExprNodeConstantDesc
condition|)
block|{
comment|// Return a constant vector expression
name|Object
name|constantValue
init|=
operator|(
operator|(
name|ExprNodeConstantDesc
operator|)
name|child
operator|)
operator|.
name|getValue
argument_list|()
decl_stmt|;
name|Long
name|longValue
init|=
name|castConstantToLong
argument_list|(
name|constantValue
argument_list|,
name|child
operator|.
name|getTypeInfo
argument_list|()
argument_list|,
name|integerPrimitiveCategory
argument_list|)
decl_stmt|;
return|return
name|getConstantVectorExpression
argument_list|(
name|longValue
argument_list|,
name|TypeInfoFactory
operator|.
name|longTypeInfo
argument_list|,
name|VectorExpressionDescriptor
operator|.
name|Mode
operator|.
name|PROJECTION
argument_list|)
return|;
block|}
comment|// Float family, timestamp are handled via descriptor based lookup, int family needs
comment|// special handling.
if|if
condition|(
name|isIntFamily
argument_list|(
name|inputType
argument_list|)
condition|)
block|{
comment|// integer and boolean types require no conversion, so use a no-op
return|return
name|getIdentityExpression
argument_list|(
name|childExpr
argument_list|)
return|;
block|}
return|return
literal|null
return|;
block|}
comment|/* Get a [NOT] BETWEEN filter expression. This is treated as a special case    * because the NOT is actually specified in the expression tree as the first argument,    * and we don't want any runtime cost for that. So creating the VectorExpression    * needs to be done differently than the standard way where all arguments are    * passed to the VectorExpression constructor.    */
specifier|private
name|VectorExpression
name|getBetweenFilterExpression
parameter_list|(
name|List
argument_list|<
name|ExprNodeDesc
argument_list|>
name|childExpr
parameter_list|,
name|VectorExpressionDescriptor
operator|.
name|Mode
name|mode
parameter_list|,
name|TypeInfo
name|returnType
parameter_list|)
throws|throws
name|HiveException
block|{
if|if
condition|(
name|mode
operator|==
name|VectorExpressionDescriptor
operator|.
name|Mode
operator|.
name|PROJECTION
condition|)
block|{
comment|// Projection mode is not yet supported for [NOT] BETWEEN. Return null so Vectorizer
comment|// knows to revert to row-at-a-time execution.
return|return
literal|null
return|;
block|}
name|boolean
name|hasDynamicValues
init|=
literal|false
decl_stmt|;
comment|// We don't currently support the BETWEEN ends being columns.  They must be scalars.
if|if
condition|(
operator|(
name|childExpr
operator|.
name|get
argument_list|(
literal|2
argument_list|)
operator|instanceof
name|ExprNodeDynamicValueDesc
operator|)
operator|&&
operator|(
name|childExpr
operator|.
name|get
argument_list|(
literal|3
argument_list|)
operator|instanceof
name|ExprNodeDynamicValueDesc
operator|)
condition|)
block|{
name|hasDynamicValues
operator|=
literal|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
operator|(
name|childExpr
operator|.
name|get
argument_list|(
literal|2
argument_list|)
operator|instanceof
name|ExprNodeConstantDesc
operator|)
operator|||
operator|!
operator|(
name|childExpr
operator|.
name|get
argument_list|(
literal|3
argument_list|)
operator|instanceof
name|ExprNodeConstantDesc
operator|)
condition|)
block|{
return|return
literal|null
return|;
block|}
name|boolean
name|notKeywordPresent
init|=
call|(
name|Boolean
call|)
argument_list|(
operator|(
name|ExprNodeConstantDesc
operator|)
name|childExpr
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|)
operator|.
name|getValue
argument_list|()
decl_stmt|;
name|ExprNodeDesc
name|colExpr
init|=
name|childExpr
operator|.
name|get
argument_list|(
literal|1
argument_list|)
decl_stmt|;
comment|// The children after not, might need a cast. Get common types for the two comparisons.
comment|// Casting for 'between' is handled here as a special case, because the first child is for NOT and doesn't need
comment|// cast
name|TypeInfo
name|commonType
init|=
name|FunctionRegistry
operator|.
name|getCommonClassForComparison
argument_list|(
name|childExpr
operator|.
name|get
argument_list|(
literal|1
argument_list|)
operator|.
name|getTypeInfo
argument_list|()
argument_list|,
name|childExpr
operator|.
name|get
argument_list|(
literal|2
argument_list|)
operator|.
name|getTypeInfo
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|commonType
operator|==
literal|null
condition|)
block|{
comment|// Can't vectorize
return|return
literal|null
return|;
block|}
name|commonType
operator|=
name|FunctionRegistry
operator|.
name|getCommonClassForComparison
argument_list|(
name|commonType
argument_list|,
name|childExpr
operator|.
name|get
argument_list|(
literal|3
argument_list|)
operator|.
name|getTypeInfo
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|commonType
operator|==
literal|null
condition|)
block|{
comment|// Can't vectorize
return|return
literal|null
return|;
block|}
name|List
argument_list|<
name|ExprNodeDesc
argument_list|>
name|castChildren
init|=
operator|new
name|ArrayList
argument_list|<
name|ExprNodeDesc
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|ExprNodeDesc
name|desc
range|:
name|childExpr
operator|.
name|subList
argument_list|(
literal|1
argument_list|,
literal|4
argument_list|)
control|)
block|{
if|if
condition|(
name|commonType
operator|.
name|equals
argument_list|(
name|desc
operator|.
name|getTypeInfo
argument_list|()
argument_list|)
condition|)
block|{
name|castChildren
operator|.
name|add
argument_list|(
name|desc
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|GenericUDF
name|castUdf
init|=
name|getGenericUDFForCast
argument_list|(
name|commonType
argument_list|)
decl_stmt|;
name|ExprNodeGenericFuncDesc
name|engfd
init|=
operator|new
name|ExprNodeGenericFuncDesc
argument_list|(
name|commonType
argument_list|,
name|castUdf
argument_list|,
name|Arrays
operator|.
name|asList
argument_list|(
operator|new
name|ExprNodeDesc
index|[]
block|{
name|desc
block|}
argument_list|)
argument_list|)
decl_stmt|;
name|castChildren
operator|.
name|add
argument_list|(
name|engfd
argument_list|)
expr_stmt|;
block|}
block|}
name|String
name|colType
init|=
name|commonType
operator|.
name|getTypeName
argument_list|()
decl_stmt|;
comment|// prepare arguments for createVectorExpression
name|List
argument_list|<
name|ExprNodeDesc
argument_list|>
name|childrenAfterNot
init|=
name|evaluateCastOnConstants
argument_list|(
name|castChildren
argument_list|)
decl_stmt|;
comment|// determine class
name|Class
argument_list|<
name|?
argument_list|>
name|cl
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|isIntFamily
argument_list|(
name|colType
argument_list|)
operator|&&
operator|!
name|notKeywordPresent
condition|)
block|{
name|cl
operator|=
operator|(
name|hasDynamicValues
condition|?
name|FilterLongColumnBetweenDynamicValue
operator|.
name|class
else|:
name|FilterLongColumnBetween
operator|.
name|class
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|isIntFamily
argument_list|(
name|colType
argument_list|)
operator|&&
name|notKeywordPresent
condition|)
block|{
name|cl
operator|=
name|FilterLongColumnNotBetween
operator|.
name|class
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|isFloatFamily
argument_list|(
name|colType
argument_list|)
operator|&&
operator|!
name|notKeywordPresent
condition|)
block|{
name|cl
operator|=
operator|(
name|hasDynamicValues
condition|?
name|FilterDoubleColumnBetweenDynamicValue
operator|.
name|class
else|:
name|FilterDoubleColumnBetween
operator|.
name|class
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|isFloatFamily
argument_list|(
name|colType
argument_list|)
operator|&&
name|notKeywordPresent
condition|)
block|{
name|cl
operator|=
name|FilterDoubleColumnNotBetween
operator|.
name|class
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|colType
operator|.
name|equals
argument_list|(
literal|"string"
argument_list|)
operator|&&
operator|!
name|notKeywordPresent
condition|)
block|{
name|cl
operator|=
operator|(
name|hasDynamicValues
condition|?
name|FilterStringColumnBetweenDynamicValue
operator|.
name|class
else|:
name|FilterStringColumnBetween
operator|.
name|class
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|colType
operator|.
name|equals
argument_list|(
literal|"string"
argument_list|)
operator|&&
name|notKeywordPresent
condition|)
block|{
name|cl
operator|=
name|FilterStringColumnNotBetween
operator|.
name|class
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|varcharTypePattern
operator|.
name|matcher
argument_list|(
name|colType
argument_list|)
operator|.
name|matches
argument_list|()
operator|&&
operator|!
name|notKeywordPresent
condition|)
block|{
name|cl
operator|=
operator|(
name|hasDynamicValues
condition|?
name|FilterVarCharColumnBetweenDynamicValue
operator|.
name|class
else|:
name|FilterVarCharColumnBetween
operator|.
name|class
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|varcharTypePattern
operator|.
name|matcher
argument_list|(
name|colType
argument_list|)
operator|.
name|matches
argument_list|()
operator|&&
name|notKeywordPresent
condition|)
block|{
name|cl
operator|=
name|FilterVarCharColumnNotBetween
operator|.
name|class
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|charTypePattern
operator|.
name|matcher
argument_list|(
name|colType
argument_list|)
operator|.
name|matches
argument_list|()
operator|&&
operator|!
name|notKeywordPresent
condition|)
block|{
name|cl
operator|=
operator|(
name|hasDynamicValues
condition|?
name|FilterCharColumnBetweenDynamicValue
operator|.
name|class
else|:
name|FilterCharColumnBetween
operator|.
name|class
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|charTypePattern
operator|.
name|matcher
argument_list|(
name|colType
argument_list|)
operator|.
name|matches
argument_list|()
operator|&&
name|notKeywordPresent
condition|)
block|{
name|cl
operator|=
name|FilterCharColumnNotBetween
operator|.
name|class
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|colType
operator|.
name|equals
argument_list|(
literal|"timestamp"
argument_list|)
operator|&&
operator|!
name|notKeywordPresent
condition|)
block|{
name|cl
operator|=
operator|(
name|hasDynamicValues
condition|?
name|FilterTimestampColumnBetweenDynamicValue
operator|.
name|class
else|:
name|FilterTimestampColumnBetween
operator|.
name|class
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|colType
operator|.
name|equals
argument_list|(
literal|"timestamp"
argument_list|)
operator|&&
name|notKeywordPresent
condition|)
block|{
name|cl
operator|=
name|FilterTimestampColumnNotBetween
operator|.
name|class
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|isDecimalFamily
argument_list|(
name|colType
argument_list|)
operator|&&
operator|!
name|notKeywordPresent
condition|)
block|{
name|cl
operator|=
operator|(
name|hasDynamicValues
condition|?
name|FilterDecimalColumnBetweenDynamicValue
operator|.
name|class
else|:
name|FilterDecimalColumnBetween
operator|.
name|class
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|isDecimalFamily
argument_list|(
name|colType
argument_list|)
operator|&&
name|notKeywordPresent
condition|)
block|{
name|cl
operator|=
name|FilterDecimalColumnNotBetween
operator|.
name|class
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|isDateFamily
argument_list|(
name|colType
argument_list|)
operator|&&
operator|!
name|notKeywordPresent
condition|)
block|{
name|cl
operator|=
operator|(
name|hasDynamicValues
condition|?
name|FilterDateColumnBetweenDynamicValue
operator|.
name|class
else|:
name|FilterLongColumnBetween
operator|.
name|class
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|isDateFamily
argument_list|(
name|colType
argument_list|)
operator|&&
name|notKeywordPresent
condition|)
block|{
name|cl
operator|=
name|FilterLongColumnNotBetween
operator|.
name|class
expr_stmt|;
block|}
return|return
name|createVectorExpression
argument_list|(
name|cl
argument_list|,
name|childrenAfterNot
argument_list|,
name|VectorExpressionDescriptor
operator|.
name|Mode
operator|.
name|PROJECTION
argument_list|,
name|returnType
argument_list|)
return|;
block|}
specifier|private
name|boolean
name|isNullConst
parameter_list|(
name|ExprNodeDesc
name|exprNodeDesc
parameter_list|)
block|{
comment|//null constant could be typed so we need to check the value
if|if
condition|(
name|exprNodeDesc
operator|instanceof
name|ExprNodeConstantDesc
operator|&&
operator|(
operator|(
name|ExprNodeConstantDesc
operator|)
name|exprNodeDesc
operator|)
operator|.
name|getValue
argument_list|()
operator|==
literal|null
condition|)
block|{
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
specifier|private
name|VectorExpression
name|getWhenExpression
parameter_list|(
name|List
argument_list|<
name|ExprNodeDesc
argument_list|>
name|childExpr
parameter_list|,
name|VectorExpressionDescriptor
operator|.
name|Mode
name|mode
parameter_list|,
name|TypeInfo
name|returnType
parameter_list|)
throws|throws
name|HiveException
block|{
if|if
condition|(
name|mode
operator|!=
name|VectorExpressionDescriptor
operator|.
name|Mode
operator|.
name|PROJECTION
condition|)
block|{
return|return
literal|null
return|;
block|}
specifier|final
name|int
name|size
init|=
name|childExpr
operator|.
name|size
argument_list|()
decl_stmt|;
specifier|final
name|ExprNodeDesc
name|whenDesc
init|=
name|childExpr
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
specifier|final
name|ExprNodeDesc
name|thenDesc
init|=
name|childExpr
operator|.
name|get
argument_list|(
literal|1
argument_list|)
decl_stmt|;
specifier|final
name|ExprNodeDesc
name|elseDesc
decl_stmt|;
if|if
condition|(
name|size
operator|==
literal|2
condition|)
block|{
name|elseDesc
operator|=
operator|new
name|ExprNodeConstantDesc
argument_list|(
name|returnType
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|size
operator|==
literal|3
condition|)
block|{
name|elseDesc
operator|=
name|childExpr
operator|.
name|get
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
else|else
block|{
specifier|final
name|GenericUDFWhen
name|udfWhen
init|=
operator|new
name|GenericUDFWhen
argument_list|()
decl_stmt|;
name|elseDesc
operator|=
operator|new
name|ExprNodeGenericFuncDesc
argument_list|(
name|returnType
argument_list|,
name|udfWhen
argument_list|,
name|udfWhen
operator|.
name|getUdfName
argument_list|()
argument_list|,
name|childExpr
operator|.
name|subList
argument_list|(
literal|2
argument_list|,
name|childExpr
operator|.
name|size
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|isNullConst
argument_list|(
name|thenDesc
argument_list|)
condition|)
block|{
specifier|final
name|VectorExpression
name|whenExpr
init|=
name|getVectorExpression
argument_list|(
name|whenDesc
argument_list|,
name|mode
argument_list|)
decl_stmt|;
specifier|final
name|VectorExpression
name|elseExpr
init|=
name|getVectorExpression
argument_list|(
name|elseDesc
argument_list|,
name|mode
argument_list|)
decl_stmt|;
specifier|final
name|int
name|outputColumnNum
init|=
name|ocm
operator|.
name|allocateOutputColumn
argument_list|(
name|returnType
argument_list|)
decl_stmt|;
specifier|final
name|VectorExpression
name|resultExpr
init|=
operator|new
name|IfExprNullColumn
argument_list|(
name|whenExpr
operator|.
name|getOutputColumnNum
argument_list|()
argument_list|,
name|elseExpr
operator|.
name|getOutputColumnNum
argument_list|()
argument_list|,
name|outputColumnNum
argument_list|)
decl_stmt|;
name|resultExpr
operator|.
name|setChildExpressions
argument_list|(
operator|new
name|VectorExpression
index|[]
block|{
name|whenExpr
block|,
name|elseExpr
block|}
argument_list|)
expr_stmt|;
name|resultExpr
operator|.
name|setInputTypeInfos
argument_list|(
name|whenExpr
operator|.
name|getOutputTypeInfo
argument_list|()
argument_list|,
name|TypeInfoFactory
operator|.
name|voidTypeInfo
argument_list|,
name|elseExpr
operator|.
name|getOutputTypeInfo
argument_list|()
argument_list|)
expr_stmt|;
name|resultExpr
operator|.
name|setInputDataTypePhysicalVariations
argument_list|(
name|whenExpr
operator|.
name|getOutputDataTypePhysicalVariation
argument_list|()
argument_list|,
name|DataTypePhysicalVariation
operator|.
name|NONE
argument_list|,
name|elseExpr
operator|.
name|getOutputDataTypePhysicalVariation
argument_list|()
argument_list|)
expr_stmt|;
name|resultExpr
operator|.
name|setOutputTypeInfo
argument_list|(
name|returnType
argument_list|)
expr_stmt|;
name|resultExpr
operator|.
name|setOutputDataTypePhysicalVariation
argument_list|(
name|DataTypePhysicalVariation
operator|.
name|NONE
argument_list|)
expr_stmt|;
return|return
name|resultExpr
return|;
block|}
if|if
condition|(
name|isNullConst
argument_list|(
name|elseDesc
argument_list|)
condition|)
block|{
specifier|final
name|VectorExpression
name|whenExpr
init|=
name|getVectorExpression
argument_list|(
name|whenDesc
argument_list|,
name|mode
argument_list|)
decl_stmt|;
specifier|final
name|VectorExpression
name|thenExpr
init|=
name|getVectorExpression
argument_list|(
name|thenDesc
argument_list|,
name|mode
argument_list|)
decl_stmt|;
specifier|final
name|int
name|outputColumnNum
init|=
name|ocm
operator|.
name|allocateOutputColumn
argument_list|(
name|returnType
argument_list|)
decl_stmt|;
specifier|final
name|VectorExpression
name|resultExpr
init|=
operator|new
name|IfExprColumnNull
argument_list|(
name|whenExpr
operator|.
name|getOutputColumnNum
argument_list|()
argument_list|,
name|thenExpr
operator|.
name|getOutputColumnNum
argument_list|()
argument_list|,
name|outputColumnNum
argument_list|)
decl_stmt|;
name|resultExpr
operator|.
name|setChildExpressions
argument_list|(
operator|new
name|VectorExpression
index|[]
block|{
name|whenExpr
block|,
name|thenExpr
block|}
argument_list|)
expr_stmt|;
name|resultExpr
operator|.
name|setInputTypeInfos
argument_list|(
name|whenExpr
operator|.
name|getOutputTypeInfo
argument_list|()
argument_list|,
name|thenExpr
operator|.
name|getOutputTypeInfo
argument_list|()
argument_list|,
name|TypeInfoFactory
operator|.
name|voidTypeInfo
argument_list|)
expr_stmt|;
name|resultExpr
operator|.
name|setInputDataTypePhysicalVariations
argument_list|(
name|whenExpr
operator|.
name|getOutputDataTypePhysicalVariation
argument_list|()
argument_list|,
name|thenExpr
operator|.
name|getOutputDataTypePhysicalVariation
argument_list|()
argument_list|,
name|DataTypePhysicalVariation
operator|.
name|NONE
argument_list|)
expr_stmt|;
name|resultExpr
operator|.
name|setOutputTypeInfo
argument_list|(
name|returnType
argument_list|)
expr_stmt|;
name|resultExpr
operator|.
name|setOutputDataTypePhysicalVariation
argument_list|(
name|DataTypePhysicalVariation
operator|.
name|NONE
argument_list|)
expr_stmt|;
return|return
name|resultExpr
return|;
block|}
specifier|final
name|GenericUDFIf
name|genericUDFIf
init|=
operator|new
name|GenericUDFIf
argument_list|()
decl_stmt|;
specifier|final
name|List
argument_list|<
name|ExprNodeDesc
argument_list|>
name|ifChildExpr
init|=
name|Arrays
operator|.
expr|<
name|ExprNodeDesc
operator|>
name|asList
argument_list|(
name|whenDesc
argument_list|,
name|thenDesc
argument_list|,
name|elseDesc
argument_list|)
decl_stmt|;
specifier|final
name|ExprNodeGenericFuncDesc
name|exprNodeDesc
init|=
operator|new
name|ExprNodeGenericFuncDesc
argument_list|(
name|returnType
argument_list|,
name|genericUDFIf
argument_list|,
literal|"if"
argument_list|,
name|ifChildExpr
argument_list|)
decl_stmt|;
return|return
name|getVectorExpression
argument_list|(
name|exprNodeDesc
argument_list|,
name|mode
argument_list|)
return|;
block|}
comment|/*    * Return vector expression for a custom (i.e. not built-in) UDF.    */
specifier|private
name|VectorExpression
name|getCustomUDFExpression
parameter_list|(
name|ExprNodeGenericFuncDesc
name|expr
parameter_list|,
name|VectorExpressionDescriptor
operator|.
name|Mode
name|mode
parameter_list|)
throws|throws
name|HiveException
block|{
name|boolean
name|isFilter
init|=
literal|false
decl_stmt|;
comment|// Assume.
if|if
condition|(
name|mode
operator|==
name|VectorExpressionDescriptor
operator|.
name|Mode
operator|.
name|FILTER
condition|)
block|{
comment|// Is output type a BOOLEAN?
name|TypeInfo
name|resultTypeInfo
init|=
name|expr
operator|.
name|getTypeInfo
argument_list|()
decl_stmt|;
if|if
condition|(
name|resultTypeInfo
operator|.
name|getCategory
argument_list|()
operator|==
name|Category
operator|.
name|PRIMITIVE
operator|&&
operator|(
operator|(
name|PrimitiveTypeInfo
operator|)
name|resultTypeInfo
operator|)
operator|.
name|getPrimitiveCategory
argument_list|()
operator|==
name|PrimitiveCategory
operator|.
name|BOOLEAN
condition|)
block|{
name|isFilter
operator|=
literal|true
expr_stmt|;
block|}
else|else
block|{
return|return
literal|null
return|;
block|}
block|}
comment|//GenericUDFBridge udfBridge = (GenericUDFBridge) expr.getGenericUDF();
name|List
argument_list|<
name|ExprNodeDesc
argument_list|>
name|childExprList
init|=
name|expr
operator|.
name|getChildren
argument_list|()
decl_stmt|;
specifier|final
name|int
name|childrenCount
init|=
name|childExprList
operator|.
name|size
argument_list|()
decl_stmt|;
comment|// argument descriptors
name|VectorUDFArgDesc
index|[]
name|argDescs
init|=
operator|new
name|VectorUDFArgDesc
index|[
name|childrenCount
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|argDescs
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|argDescs
index|[
name|i
index|]
operator|=
operator|new
name|VectorUDFArgDesc
argument_list|()
expr_stmt|;
block|}
comment|// positions of variable arguments (columns or non-constant expressions)
name|List
argument_list|<
name|Integer
argument_list|>
name|variableArgPositions
init|=
operator|new
name|ArrayList
argument_list|<
name|Integer
argument_list|>
argument_list|()
decl_stmt|;
comment|// Column numbers of batch corresponding to expression result arguments
name|List
argument_list|<
name|Integer
argument_list|>
name|exprResultColumnNums
init|=
operator|new
name|ArrayList
argument_list|<
name|Integer
argument_list|>
argument_list|()
decl_stmt|;
comment|// Prepare children
name|List
argument_list|<
name|VectorExpression
argument_list|>
name|vectorExprs
init|=
operator|new
name|ArrayList
argument_list|<
name|VectorExpression
argument_list|>
argument_list|()
decl_stmt|;
name|TypeInfo
index|[]
name|inputTypeInfos
init|=
operator|new
name|TypeInfo
index|[
name|childrenCount
index|]
decl_stmt|;
name|DataTypePhysicalVariation
index|[]
name|inputDataTypePhysicalVariations
init|=
operator|new
name|DataTypePhysicalVariation
index|[
name|childrenCount
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|childrenCount
condition|;
name|i
operator|++
control|)
block|{
name|ExprNodeDesc
name|child
init|=
name|childExprList
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|inputTypeInfos
index|[
name|i
index|]
operator|=
name|child
operator|.
name|getTypeInfo
argument_list|()
expr_stmt|;
name|inputDataTypePhysicalVariations
index|[
name|i
index|]
operator|=
name|DataTypePhysicalVariation
operator|.
name|NONE
expr_stmt|;
if|if
condition|(
name|child
operator|instanceof
name|ExprNodeGenericFuncDesc
condition|)
block|{
name|VectorExpression
name|e
init|=
name|getVectorExpression
argument_list|(
name|child
argument_list|,
name|VectorExpressionDescriptor
operator|.
name|Mode
operator|.
name|PROJECTION
argument_list|)
decl_stmt|;
name|vectorExprs
operator|.
name|add
argument_list|(
name|e
argument_list|)
expr_stmt|;
name|variableArgPositions
operator|.
name|add
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|exprResultColumnNums
operator|.
name|add
argument_list|(
name|e
operator|.
name|getOutputColumnNum
argument_list|()
argument_list|)
expr_stmt|;
name|argDescs
index|[
name|i
index|]
operator|.
name|setVariable
argument_list|(
name|e
operator|.
name|getOutputColumnNum
argument_list|()
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|child
operator|instanceof
name|ExprNodeColumnDesc
condition|)
block|{
name|variableArgPositions
operator|.
name|add
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|argDescs
index|[
name|i
index|]
operator|.
name|setVariable
argument_list|(
name|getInputColumnIndex
argument_list|(
operator|(
operator|(
name|ExprNodeColumnDesc
operator|)
name|child
operator|)
operator|.
name|getColumn
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|child
operator|instanceof
name|ExprNodeConstantDesc
condition|)
block|{
comment|// this is a constant (or null)
name|argDescs
index|[
name|i
index|]
operator|.
name|setConstant
argument_list|(
operator|(
name|ExprNodeConstantDesc
operator|)
name|child
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|child
operator|instanceof
name|ExprNodeDynamicValueDesc
condition|)
block|{
name|VectorExpression
name|e
init|=
name|getVectorExpression
argument_list|(
name|child
argument_list|,
name|VectorExpressionDescriptor
operator|.
name|Mode
operator|.
name|PROJECTION
argument_list|)
decl_stmt|;
name|vectorExprs
operator|.
name|add
argument_list|(
name|e
argument_list|)
expr_stmt|;
name|variableArgPositions
operator|.
name|add
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|exprResultColumnNums
operator|.
name|add
argument_list|(
name|e
operator|.
name|getOutputColumnNum
argument_list|()
argument_list|)
expr_stmt|;
name|argDescs
index|[
name|i
index|]
operator|.
name|setVariable
argument_list|(
name|e
operator|.
name|getOutputColumnNum
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
throw|throw
operator|new
name|HiveException
argument_list|(
literal|"Unable to vectorize custom UDF. Encountered unsupported expr desc : "
operator|+
name|child
argument_list|)
throw|;
block|}
block|}
comment|// Allocate output column and get column number;
name|TypeInfo
name|resultTypeInfo
init|=
name|expr
operator|.
name|getTypeInfo
argument_list|()
decl_stmt|;
name|String
name|resultTypeName
init|=
name|resultTypeInfo
operator|.
name|getTypeName
argument_list|()
decl_stmt|;
specifier|final
name|int
name|outputColumnNum
init|=
name|ocm
operator|.
name|allocateOutputColumn
argument_list|(
name|expr
operator|.
name|getTypeInfo
argument_list|()
argument_list|)
decl_stmt|;
comment|// Make vectorized operator
name|VectorExpression
name|ve
init|=
operator|new
name|VectorUDFAdaptor
argument_list|(
name|expr
argument_list|,
name|outputColumnNum
argument_list|,
name|resultTypeName
argument_list|,
name|argDescs
argument_list|)
decl_stmt|;
comment|// Set child expressions
name|VectorExpression
index|[]
name|childVEs
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|exprResultColumnNums
operator|.
name|size
argument_list|()
operator|!=
literal|0
condition|)
block|{
name|childVEs
operator|=
operator|new
name|VectorExpression
index|[
name|exprResultColumnNums
operator|.
name|size
argument_list|()
index|]
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|childVEs
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|childVEs
index|[
name|i
index|]
operator|=
name|vectorExprs
operator|.
name|get
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
block|}
name|ve
operator|.
name|setChildExpressions
argument_list|(
name|childVEs
argument_list|)
expr_stmt|;
name|ve
operator|.
name|setInputTypeInfos
argument_list|(
name|inputTypeInfos
argument_list|)
expr_stmt|;
name|ve
operator|.
name|setInputDataTypePhysicalVariations
argument_list|(
name|inputDataTypePhysicalVariations
argument_list|)
expr_stmt|;
name|ve
operator|.
name|setOutputTypeInfo
argument_list|(
name|resultTypeInfo
argument_list|)
expr_stmt|;
name|ve
operator|.
name|setOutputDataTypePhysicalVariation
argument_list|(
name|DataTypePhysicalVariation
operator|.
name|NONE
argument_list|)
expr_stmt|;
comment|// Free output columns if inputs have non-leaf expression trees.
for|for
control|(
name|Integer
name|i
range|:
name|exprResultColumnNums
control|)
block|{
name|ocm
operator|.
name|freeOutputColumn
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|isFilter
condition|)
block|{
name|SelectColumnIsTrue
name|filterVectorExpr
init|=
operator|new
name|SelectColumnIsTrue
argument_list|(
name|outputColumnNum
argument_list|)
decl_stmt|;
name|filterVectorExpr
operator|.
name|setChildExpressions
argument_list|(
operator|new
name|VectorExpression
index|[]
block|{
name|ve
block|}
argument_list|)
expr_stmt|;
name|filterVectorExpr
operator|.
name|setInputTypeInfos
argument_list|(
name|ve
operator|.
name|getOutputTypeInfo
argument_list|()
argument_list|)
expr_stmt|;
name|filterVectorExpr
operator|.
name|setInputDataTypePhysicalVariations
argument_list|(
name|ve
operator|.
name|getOutputDataTypePhysicalVariation
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|filterVectorExpr
return|;
block|}
else|else
block|{
return|return
name|ve
return|;
block|}
block|}
specifier|public
specifier|static
name|boolean
name|isStringFamily
parameter_list|(
name|String
name|resultType
parameter_list|)
block|{
return|return
name|resultType
operator|.
name|equalsIgnoreCase
argument_list|(
literal|"string"
argument_list|)
operator|||
name|charVarcharTypePattern
operator|.
name|matcher
argument_list|(
name|resultType
argument_list|)
operator|.
name|matches
argument_list|()
operator|||
name|resultType
operator|.
name|equalsIgnoreCase
argument_list|(
literal|"string_family"
argument_list|)
return|;
block|}
specifier|public
specifier|static
name|boolean
name|isDatetimeFamily
parameter_list|(
name|String
name|resultType
parameter_list|)
block|{
return|return
name|resultType
operator|.
name|equalsIgnoreCase
argument_list|(
literal|"timestamp"
argument_list|)
operator|||
name|resultType
operator|.
name|equalsIgnoreCase
argument_list|(
literal|"date"
argument_list|)
return|;
block|}
specifier|public
specifier|static
name|boolean
name|isTimestampFamily
parameter_list|(
name|String
name|resultType
parameter_list|)
block|{
return|return
name|resultType
operator|.
name|equalsIgnoreCase
argument_list|(
literal|"timestamp"
argument_list|)
return|;
block|}
specifier|public
specifier|static
name|boolean
name|isDateFamily
parameter_list|(
name|String
name|resultType
parameter_list|)
block|{
return|return
name|resultType
operator|.
name|equalsIgnoreCase
argument_list|(
literal|"date"
argument_list|)
return|;
block|}
specifier|public
specifier|static
name|boolean
name|isIntervalYearMonthFamily
parameter_list|(
name|String
name|resultType
parameter_list|)
block|{
return|return
name|resultType
operator|.
name|equalsIgnoreCase
argument_list|(
literal|"interval_year_month"
argument_list|)
return|;
block|}
specifier|public
specifier|static
name|boolean
name|isIntervalDayTimeFamily
parameter_list|(
name|String
name|resultType
parameter_list|)
block|{
return|return
name|resultType
operator|.
name|equalsIgnoreCase
argument_list|(
literal|"interval_day_time"
argument_list|)
return|;
block|}
comment|// return true if this is any kind of float
specifier|public
specifier|static
name|boolean
name|isFloatFamily
parameter_list|(
name|String
name|resultType
parameter_list|)
block|{
return|return
name|resultType
operator|.
name|equalsIgnoreCase
argument_list|(
literal|"double"
argument_list|)
operator|||
name|resultType
operator|.
name|equalsIgnoreCase
argument_list|(
literal|"float"
argument_list|)
return|;
block|}
comment|// Return true if this data type is handled in the output vector as an integer.
specifier|public
specifier|static
name|boolean
name|isIntFamily
parameter_list|(
name|String
name|resultType
parameter_list|)
block|{
return|return
name|resultType
operator|.
name|equalsIgnoreCase
argument_list|(
literal|"tinyint"
argument_list|)
operator|||
name|resultType
operator|.
name|equalsIgnoreCase
argument_list|(
literal|"smallint"
argument_list|)
operator|||
name|resultType
operator|.
name|equalsIgnoreCase
argument_list|(
literal|"int"
argument_list|)
operator|||
name|resultType
operator|.
name|equalsIgnoreCase
argument_list|(
literal|"bigint"
argument_list|)
operator|||
name|resultType
operator|.
name|equalsIgnoreCase
argument_list|(
literal|"boolean"
argument_list|)
operator|||
name|resultType
operator|.
name|equalsIgnoreCase
argument_list|(
literal|"long"
argument_list|)
return|;
block|}
specifier|public
specifier|static
name|boolean
name|isDecimalFamily
parameter_list|(
name|String
name|colType
parameter_list|)
block|{
return|return
name|decimalTypePattern
operator|.
name|matcher
argument_list|(
name|colType
argument_list|)
operator|.
name|matches
argument_list|()
return|;
block|}
specifier|private
name|Object
name|getScalarValue
parameter_list|(
name|ExprNodeConstantDesc
name|constDesc
parameter_list|)
throws|throws
name|HiveException
block|{
if|if
condition|(
name|constDesc
operator|.
name|getTypeString
argument_list|()
operator|.
name|equalsIgnoreCase
argument_list|(
literal|"String"
argument_list|)
condition|)
block|{
try|try
block|{
name|byte
index|[]
name|bytes
init|=
operator|(
operator|(
name|String
operator|)
name|constDesc
operator|.
name|getValue
argument_list|()
operator|)
operator|.
name|getBytes
argument_list|(
literal|"UTF-8"
argument_list|)
decl_stmt|;
return|return
name|bytes
return|;
block|}
catch|catch
parameter_list|(
name|Exception
name|ex
parameter_list|)
block|{
throw|throw
operator|new
name|HiveException
argument_list|(
name|ex
argument_list|)
throw|;
block|}
block|}
elseif|else
if|if
condition|(
name|constDesc
operator|.
name|getTypeString
argument_list|()
operator|.
name|equalsIgnoreCase
argument_list|(
literal|"boolean"
argument_list|)
condition|)
block|{
if|if
condition|(
name|constDesc
operator|.
name|getValue
argument_list|()
operator|.
name|equals
argument_list|(
name|Boolean
operator|.
name|valueOf
argument_list|(
literal|true
argument_list|)
argument_list|)
condition|)
block|{
return|return
literal|1
return|;
block|}
else|else
block|{
return|return
literal|0
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|decimalTypePattern
operator|.
name|matcher
argument_list|(
name|constDesc
operator|.
name|getTypeString
argument_list|()
argument_list|)
operator|.
name|matches
argument_list|()
condition|)
block|{
return|return
name|constDesc
operator|.
name|getValue
argument_list|()
return|;
block|}
else|else
block|{
return|return
name|constDesc
operator|.
name|getValue
argument_list|()
return|;
block|}
block|}
specifier|private
name|long
name|getIntFamilyScalarAsLong
parameter_list|(
name|ExprNodeConstantDesc
name|constDesc
parameter_list|)
throws|throws
name|HiveException
block|{
name|Object
name|o
init|=
name|getScalarValue
argument_list|(
name|constDesc
argument_list|)
decl_stmt|;
if|if
condition|(
name|o
operator|instanceof
name|Integer
condition|)
block|{
return|return
operator|(
name|Integer
operator|)
name|o
return|;
block|}
elseif|else
if|if
condition|(
name|o
operator|instanceof
name|Long
condition|)
block|{
return|return
operator|(
name|Long
operator|)
name|o
return|;
block|}
throw|throw
operator|new
name|HiveException
argument_list|(
literal|"Unexpected type when converting to long : "
operator|+
name|o
operator|.
name|getClass
argument_list|()
operator|.
name|getSimpleName
argument_list|()
argument_list|)
throw|;
block|}
specifier|private
name|double
name|getNumericScalarAsDouble
parameter_list|(
name|ExprNodeDesc
name|constDesc
parameter_list|)
throws|throws
name|HiveException
block|{
name|Object
name|o
init|=
name|getScalarValue
argument_list|(
operator|(
name|ExprNodeConstantDesc
operator|)
name|constDesc
argument_list|)
decl_stmt|;
if|if
condition|(
name|o
operator|instanceof
name|Double
condition|)
block|{
return|return
operator|(
name|Double
operator|)
name|o
return|;
block|}
elseif|else
if|if
condition|(
name|o
operator|instanceof
name|Float
condition|)
block|{
return|return
operator|(
name|Float
operator|)
name|o
return|;
block|}
elseif|else
if|if
condition|(
name|o
operator|instanceof
name|Integer
condition|)
block|{
return|return
operator|(
name|Integer
operator|)
name|o
return|;
block|}
elseif|else
if|if
condition|(
name|o
operator|instanceof
name|Long
condition|)
block|{
return|return
operator|(
name|Long
operator|)
name|o
return|;
block|}
throw|throw
operator|new
name|HiveException
argument_list|(
literal|"Unexpected type when converting to double"
argument_list|)
throw|;
block|}
specifier|private
name|Object
name|getVectorTypeScalarValue
parameter_list|(
name|ExprNodeConstantDesc
name|constDesc
parameter_list|)
throws|throws
name|HiveException
block|{
name|TypeInfo
name|typeInfo
init|=
name|constDesc
operator|.
name|getTypeInfo
argument_list|()
decl_stmt|;
name|PrimitiveCategory
name|primitiveCategory
init|=
operator|(
operator|(
name|PrimitiveTypeInfo
operator|)
name|typeInfo
operator|)
operator|.
name|getPrimitiveCategory
argument_list|()
decl_stmt|;
name|Object
name|scalarValue
init|=
name|getScalarValue
argument_list|(
name|constDesc
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|primitiveCategory
condition|)
block|{
case|case
name|DATE
case|:
return|return
operator|new
name|Long
argument_list|(
name|DateWritable
operator|.
name|dateToDays
argument_list|(
operator|(
name|Date
operator|)
name|scalarValue
argument_list|)
argument_list|)
return|;
case|case
name|INTERVAL_YEAR_MONTH
case|:
return|return
operator|(
operator|(
name|HiveIntervalYearMonth
operator|)
name|scalarValue
operator|)
operator|.
name|getTotalMonths
argument_list|()
return|;
default|default:
return|return
name|scalarValue
return|;
block|}
block|}
comment|// Get a timestamp from a string constant or cast
specifier|private
name|Timestamp
name|getTimestampScalar
parameter_list|(
name|ExprNodeDesc
name|expr
parameter_list|)
throws|throws
name|HiveException
block|{
if|if
condition|(
name|expr
operator|instanceof
name|ExprNodeGenericFuncDesc
operator|&&
operator|(
operator|(
name|ExprNodeGenericFuncDesc
operator|)
name|expr
operator|)
operator|.
name|getGenericUDF
argument_list|()
operator|instanceof
name|GenericUDFTimestamp
condition|)
block|{
return|return
name|evaluateCastToTimestamp
argument_list|(
name|expr
argument_list|)
return|;
block|}
if|if
condition|(
operator|!
operator|(
name|expr
operator|instanceof
name|ExprNodeConstantDesc
operator|)
condition|)
block|{
throw|throw
operator|new
name|HiveException
argument_list|(
literal|"Constant timestamp value expected for expression argument. "
operator|+
literal|"Non-constant argument not supported for vectorization."
argument_list|)
throw|;
block|}
name|ExprNodeConstantDesc
name|constExpr
init|=
operator|(
name|ExprNodeConstantDesc
operator|)
name|expr
decl_stmt|;
name|String
name|constTypeString
init|=
name|constExpr
operator|.
name|getTypeString
argument_list|()
decl_stmt|;
if|if
condition|(
name|isStringFamily
argument_list|(
name|constTypeString
argument_list|)
operator|||
name|isDatetimeFamily
argument_list|(
name|constTypeString
argument_list|)
condition|)
block|{
comment|// create expression tree with type cast from string to timestamp
name|ExprNodeGenericFuncDesc
name|expr2
init|=
operator|new
name|ExprNodeGenericFuncDesc
argument_list|()
decl_stmt|;
name|GenericUDFTimestamp
name|f
init|=
operator|new
name|GenericUDFTimestamp
argument_list|()
decl_stmt|;
name|expr2
operator|.
name|setGenericUDF
argument_list|(
name|f
argument_list|)
expr_stmt|;
name|ArrayList
argument_list|<
name|ExprNodeDesc
argument_list|>
name|children
init|=
operator|new
name|ArrayList
argument_list|<
name|ExprNodeDesc
argument_list|>
argument_list|()
decl_stmt|;
name|children
operator|.
name|add
argument_list|(
name|expr
argument_list|)
expr_stmt|;
name|expr2
operator|.
name|setChildren
argument_list|(
name|children
argument_list|)
expr_stmt|;
comment|// initialize and evaluate
return|return
name|evaluateCastToTimestamp
argument_list|(
name|expr2
argument_list|)
return|;
block|}
throw|throw
operator|new
name|HiveException
argument_list|(
literal|"Udf: unhandled constant type for scalar argument. "
operator|+
literal|"Expecting string/date/timestamp."
argument_list|)
throw|;
block|}
specifier|private
name|Timestamp
name|evaluateCastToTimestamp
parameter_list|(
name|ExprNodeDesc
name|expr
parameter_list|)
throws|throws
name|HiveException
block|{
name|ExprNodeGenericFuncDesc
name|expr2
init|=
operator|(
name|ExprNodeGenericFuncDesc
operator|)
name|expr
decl_stmt|;
name|ExprNodeEvaluator
name|evaluator
init|=
name|ExprNodeEvaluatorFactory
operator|.
name|get
argument_list|(
name|expr2
argument_list|)
decl_stmt|;
name|ObjectInspector
name|output
init|=
name|evaluator
operator|.
name|initialize
argument_list|(
literal|null
argument_list|)
decl_stmt|;
name|Object
name|constant
init|=
name|evaluator
operator|.
name|evaluate
argument_list|(
literal|null
argument_list|)
decl_stmt|;
name|Object
name|java
init|=
name|ObjectInspectorUtils
operator|.
name|copyToStandardJavaObject
argument_list|(
name|constant
argument_list|,
name|output
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|java
operator|instanceof
name|Timestamp
operator|)
condition|)
block|{
throw|throw
operator|new
name|HiveException
argument_list|(
literal|"Udf: failed to convert to timestamp"
argument_list|)
throw|;
block|}
name|Timestamp
name|ts
init|=
operator|(
name|Timestamp
operator|)
name|java
decl_stmt|;
return|return
name|ts
return|;
block|}
specifier|private
name|Constructor
argument_list|<
name|?
argument_list|>
name|getConstructor
parameter_list|(
name|Class
argument_list|<
name|?
argument_list|>
name|cl
parameter_list|)
throws|throws
name|HiveException
block|{
try|try
block|{
name|Constructor
argument_list|<
name|?
argument_list|>
index|[]
name|ctors
init|=
name|cl
operator|.
name|getDeclaredConstructors
argument_list|()
decl_stmt|;
if|if
condition|(
name|ctors
operator|.
name|length
operator|==
literal|1
condition|)
block|{
return|return
name|ctors
index|[
literal|0
index|]
return|;
block|}
name|Constructor
argument_list|<
name|?
argument_list|>
name|defaultCtor
init|=
name|cl
operator|.
name|getConstructor
argument_list|()
decl_stmt|;
for|for
control|(
name|Constructor
argument_list|<
name|?
argument_list|>
name|ctor
range|:
name|ctors
control|)
block|{
if|if
condition|(
operator|!
name|ctor
operator|.
name|equals
argument_list|(
name|defaultCtor
argument_list|)
condition|)
block|{
return|return
name|ctor
return|;
block|}
block|}
throw|throw
operator|new
name|HiveException
argument_list|(
literal|"Only default constructor found"
argument_list|)
throw|;
block|}
catch|catch
parameter_list|(
name|Exception
name|ex
parameter_list|)
block|{
throw|throw
operator|new
name|HiveException
argument_list|(
name|ex
argument_list|)
throw|;
block|}
block|}
specifier|static
name|String
name|getScratchName
parameter_list|(
name|TypeInfo
name|typeInfo
parameter_list|)
throws|throws
name|HiveException
block|{
comment|// For now, leave DECIMAL precision/scale in the name so DecimalColumnVector scratch columns
comment|// don't need their precision/scale adjusted...
if|if
condition|(
name|typeInfo
operator|.
name|getCategory
argument_list|()
operator|==
name|Category
operator|.
name|PRIMITIVE
operator|&&
operator|(
operator|(
name|PrimitiveTypeInfo
operator|)
name|typeInfo
operator|)
operator|.
name|getPrimitiveCategory
argument_list|()
operator|==
name|PrimitiveCategory
operator|.
name|DECIMAL
condition|)
block|{
return|return
name|typeInfo
operator|.
name|getTypeName
argument_list|()
return|;
block|}
comment|// And, for Complex Types, also leave the children types in place...
if|if
condition|(
name|typeInfo
operator|.
name|getCategory
argument_list|()
operator|!=
name|Category
operator|.
name|PRIMITIVE
condition|)
block|{
return|return
name|typeInfo
operator|.
name|getTypeName
argument_list|()
return|;
block|}
name|Type
name|columnVectorType
init|=
name|VectorizationContext
operator|.
name|getColumnVectorTypeFromTypeInfo
argument_list|(
name|typeInfo
argument_list|)
decl_stmt|;
return|return
name|columnVectorType
operator|.
name|name
argument_list|()
operator|.
name|toLowerCase
argument_list|()
return|;
block|}
specifier|static
name|String
name|getUndecoratedName
parameter_list|(
name|String
name|hiveTypeName
parameter_list|)
throws|throws
name|HiveException
block|{
name|VectorExpressionDescriptor
operator|.
name|ArgumentType
name|argType
init|=
name|VectorExpressionDescriptor
operator|.
name|ArgumentType
operator|.
name|fromHiveTypeName
argument_list|(
name|hiveTypeName
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|argType
condition|)
block|{
case|case
name|INT_FAMILY
case|:
return|return
literal|"Long"
return|;
case|case
name|FLOAT_FAMILY
case|:
return|return
literal|"Double"
return|;
case|case
name|DECIMAL
case|:
return|return
literal|"Decimal"
return|;
case|case
name|STRING
case|:
return|return
literal|"String"
return|;
case|case
name|CHAR
case|:
return|return
literal|"Char"
return|;
case|case
name|VARCHAR
case|:
return|return
literal|"VarChar"
return|;
case|case
name|BINARY
case|:
return|return
literal|"Binary"
return|;
case|case
name|DATE
case|:
return|return
literal|"Date"
return|;
case|case
name|TIMESTAMP
case|:
return|return
literal|"Timestamp"
return|;
case|case
name|INTERVAL_YEAR_MONTH
case|:
case|case
name|INTERVAL_DAY_TIME
case|:
return|return
name|hiveTypeName
return|;
case|case
name|STRUCT
case|:
return|return
literal|"Struct"
return|;
case|case
name|LIST
case|:
return|return
literal|"List"
return|;
case|case
name|MAP
case|:
return|return
literal|"Map"
return|;
default|default:
throw|throw
operator|new
name|HiveException
argument_list|(
literal|"Unexpected hive type name "
operator|+
name|hiveTypeName
argument_list|)
throw|;
block|}
block|}
specifier|public
specifier|static
name|String
name|mapTypeNameSynonyms
parameter_list|(
name|String
name|typeName
parameter_list|)
block|{
name|typeName
operator|=
name|typeName
operator|.
name|toLowerCase
argument_list|()
expr_stmt|;
if|if
condition|(
name|typeName
operator|.
name|equals
argument_list|(
literal|"long"
argument_list|)
condition|)
block|{
return|return
literal|"bigint"
return|;
block|}
elseif|else
if|if
condition|(
name|typeName
operator|.
name|equals
argument_list|(
literal|"string_family"
argument_list|)
condition|)
block|{
return|return
literal|"string"
return|;
block|}
else|else
block|{
return|return
name|typeName
return|;
block|}
block|}
specifier|public
specifier|static
name|ColumnVector
operator|.
name|Type
name|getColumnVectorTypeFromTypeInfo
parameter_list|(
name|TypeInfo
name|typeInfo
parameter_list|)
throws|throws
name|HiveException
block|{
return|return
name|getColumnVectorTypeFromTypeInfo
argument_list|(
name|typeInfo
argument_list|,
name|DataTypePhysicalVariation
operator|.
name|NONE
argument_list|)
return|;
block|}
specifier|public
specifier|static
name|ColumnVector
operator|.
name|Type
name|getColumnVectorTypeFromTypeInfo
parameter_list|(
name|TypeInfo
name|typeInfo
parameter_list|,
name|DataTypePhysicalVariation
name|dataTypePhysicalVariation
parameter_list|)
throws|throws
name|HiveException
block|{
switch|switch
condition|(
name|typeInfo
operator|.
name|getCategory
argument_list|()
condition|)
block|{
case|case
name|STRUCT
case|:
return|return
name|Type
operator|.
name|STRUCT
return|;
case|case
name|UNION
case|:
return|return
name|Type
operator|.
name|UNION
return|;
case|case
name|LIST
case|:
return|return
name|Type
operator|.
name|LIST
return|;
case|case
name|MAP
case|:
return|return
name|Type
operator|.
name|MAP
return|;
case|case
name|PRIMITIVE
case|:
block|{
name|PrimitiveTypeInfo
name|primitiveTypeInfo
init|=
operator|(
name|PrimitiveTypeInfo
operator|)
name|typeInfo
decl_stmt|;
name|PrimitiveCategory
name|primitiveCategory
init|=
name|primitiveTypeInfo
operator|.
name|getPrimitiveCategory
argument_list|()
decl_stmt|;
switch|switch
condition|(
name|primitiveCategory
condition|)
block|{
case|case
name|BOOLEAN
case|:
case|case
name|BYTE
case|:
case|case
name|SHORT
case|:
case|case
name|INT
case|:
case|case
name|LONG
case|:
case|case
name|DATE
case|:
case|case
name|INTERVAL_YEAR_MONTH
case|:
return|return
name|ColumnVector
operator|.
name|Type
operator|.
name|LONG
return|;
case|case
name|TIMESTAMP
case|:
return|return
name|ColumnVector
operator|.
name|Type
operator|.
name|TIMESTAMP
return|;
case|case
name|INTERVAL_DAY_TIME
case|:
return|return
name|ColumnVector
operator|.
name|Type
operator|.
name|INTERVAL_DAY_TIME
return|;
case|case
name|FLOAT
case|:
case|case
name|DOUBLE
case|:
return|return
name|ColumnVector
operator|.
name|Type
operator|.
name|DOUBLE
return|;
case|case
name|STRING
case|:
case|case
name|CHAR
case|:
case|case
name|VARCHAR
case|:
case|case
name|BINARY
case|:
return|return
name|ColumnVector
operator|.
name|Type
operator|.
name|BYTES
return|;
case|case
name|DECIMAL
case|:
if|if
condition|(
name|dataTypePhysicalVariation
operator|!=
literal|null
operator|&&
name|dataTypePhysicalVariation
operator|==
name|DataTypePhysicalVariation
operator|.
name|DECIMAL_64
condition|)
block|{
return|return
name|ColumnVector
operator|.
name|Type
operator|.
name|DECIMAL_64
return|;
block|}
else|else
block|{
return|return
name|ColumnVector
operator|.
name|Type
operator|.
name|DECIMAL
return|;
block|}
default|default:
throw|throw
operator|new
name|HiveException
argument_list|(
literal|"Unexpected primitive type category "
operator|+
name|primitiveCategory
argument_list|)
throw|;
block|}
block|}
default|default:
throw|throw
operator|new
name|HiveException
argument_list|(
literal|"Unexpected type category "
operator|+
name|typeInfo
operator|.
name|getCategory
argument_list|()
argument_list|)
throw|;
block|}
block|}
specifier|public
name|int
name|firstOutputColumnIndex
parameter_list|()
block|{
return|return
name|firstOutputColumnIndex
return|;
block|}
specifier|public
name|String
index|[]
name|getScratchColumnTypeNames
parameter_list|()
block|{
name|String
index|[]
name|result
init|=
operator|new
name|String
index|[
name|ocm
operator|.
name|outputColCount
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|ocm
operator|.
name|outputColCount
condition|;
name|i
operator|++
control|)
block|{
name|String
name|vectorTypeName
init|=
name|ocm
operator|.
name|scratchVectorTypeNames
index|[
name|i
index|]
decl_stmt|;
name|String
name|typeName
decl_stmt|;
if|if
condition|(
name|vectorTypeName
operator|.
name|equalsIgnoreCase
argument_list|(
literal|"bytes"
argument_list|)
condition|)
block|{
comment|// Use hive type name.
name|typeName
operator|=
literal|"string"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|vectorTypeName
operator|.
name|equalsIgnoreCase
argument_list|(
literal|"long"
argument_list|)
condition|)
block|{
comment|// Use hive type name.
name|typeName
operator|=
literal|"bigint"
expr_stmt|;
block|}
else|else
block|{
name|typeName
operator|=
name|vectorTypeName
expr_stmt|;
block|}
name|result
index|[
name|i
index|]
operator|=
name|typeName
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
specifier|public
name|DataTypePhysicalVariation
index|[]
name|getScratchDataTypePhysicalVariations
parameter_list|()
block|{
return|return
name|Arrays
operator|.
name|copyOf
argument_list|(
name|ocm
operator|.
name|scratchDataTypePhysicalVariations
argument_list|,
name|ocm
operator|.
name|outputColCount
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|toString
parameter_list|()
block|{
name|StringBuilder
name|sb
init|=
operator|new
name|StringBuilder
argument_list|(
literal|32
argument_list|)
decl_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|"Context name "
argument_list|)
operator|.
name|append
argument_list|(
name|contextName
argument_list|)
operator|.
name|append
argument_list|(
literal|", level "
operator|+
name|level
operator|+
literal|", "
argument_list|)
expr_stmt|;
name|Comparator
argument_list|<
name|Integer
argument_list|>
name|comparerInteger
init|=
operator|new
name|Comparator
argument_list|<
name|Integer
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|int
name|compare
parameter_list|(
name|Integer
name|o1
parameter_list|,
name|Integer
name|o2
parameter_list|)
block|{
return|return
name|o1
operator|.
name|compareTo
argument_list|(
name|o2
argument_list|)
return|;
block|}
block|}
decl_stmt|;
name|Map
argument_list|<
name|Integer
argument_list|,
name|String
argument_list|>
name|sortedColumnMap
init|=
operator|new
name|TreeMap
argument_list|<
name|Integer
argument_list|,
name|String
argument_list|>
argument_list|(
name|comparerInteger
argument_list|)
decl_stmt|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|Integer
argument_list|>
name|entry
range|:
name|projectionColumnMap
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|sortedColumnMap
operator|.
name|put
argument_list|(
name|entry
operator|.
name|getValue
argument_list|()
argument_list|,
name|entry
operator|.
name|getKey
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|sb
operator|.
name|append
argument_list|(
literal|"sorted projectionColumnMap "
argument_list|)
operator|.
name|append
argument_list|(
name|sortedColumnMap
argument_list|)
operator|.
name|append
argument_list|(
literal|", "
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|"initial column names "
argument_list|)
operator|.
name|append
argument_list|(
name|initialColumnNames
operator|.
name|toString
argument_list|()
argument_list|)
operator|.
name|append
argument_list|(
literal|","
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|"initial type infos "
argument_list|)
operator|.
name|append
argument_list|(
name|initialTypeInfos
operator|.
name|toString
argument_list|()
argument_list|)
operator|.
name|append
argument_list|(
literal|", "
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|"scratchColumnTypeNames "
argument_list|)
operator|.
name|append
argument_list|(
name|Arrays
operator|.
name|toString
argument_list|(
name|getScratchColumnTypeNames
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|sb
operator|.
name|toString
argument_list|()
return|;
block|}
block|}
end_class

end_unit

