begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one or more contributor license  * agreements. See the NOTICE file distributed with this work for additional information regarding  * copyright ownership. The ASF licenses this file to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance with the License. You may obtain a  * copy of the License at  *   * http://www.apache.org/licenses/LICENSE-2.0  *   * Unless required by applicable law or agreed to in writing, software distributed under the License  * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express  * or implied. See the License for the specific language governing permissions and limitations under  * the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|optimizer
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|Serializable
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
operator|.
name|Entry
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Stack
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|lang
operator|.
name|StringUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|Log
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|LogFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|common
operator|.
name|JavaUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|ColumnInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|FileSinkOperator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|FilterOperator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|GroupByOperator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|JoinOperator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|Operator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|ReduceSinkOperator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|RowSchema
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|SelectOperator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|TableScanOperator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|UDF
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|lib
operator|.
name|Node
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|lib
operator|.
name|NodeProcessor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|lib
operator|.
name|NodeProcessorCtx
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|metadata
operator|.
name|HiveException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|parse
operator|.
name|RowResolver
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|parse
operator|.
name|SemanticException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|DynamicPartitionCtx
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|ExprNodeColumnDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|ExprNodeConstantDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|ExprNodeDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|ExprNodeGenericFuncDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|ExprNodeNullDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|FileSinkDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|GroupByDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|JoinCondDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|JoinDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|PlanUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|ReduceSinkDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|TableScanDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|udf
operator|.
name|UDFType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|udf
operator|.
name|generic
operator|.
name|GenericUDF
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|udf
operator|.
name|generic
operator|.
name|GenericUDF
operator|.
name|DeferredJavaObject
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|udf
operator|.
name|generic
operator|.
name|GenericUDFBridge
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|udf
operator|.
name|generic
operator|.
name|GenericUDFOPAnd
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|udf
operator|.
name|generic
operator|.
name|GenericUDFOPEqual
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|udf
operator|.
name|generic
operator|.
name|GenericUDFOPNull
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|udf
operator|.
name|generic
operator|.
name|GenericUDFOPOr
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde
operator|.
name|serdeConstants
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|objectinspector
operator|.
name|ObjectInspector
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|objectinspector
operator|.
name|ObjectInspectorConverters
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|objectinspector
operator|.
name|ObjectInspectorConverters
operator|.
name|Converter
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|objectinspector
operator|.
name|ObjectInspectorUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|objectinspector
operator|.
name|PrimitiveObjectInspector
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|objectinspector
operator|.
name|PrimitiveObjectInspector
operator|.
name|PrimitiveCategory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|objectinspector
operator|.
name|primitive
operator|.
name|PrimitiveObjectInspectorFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|objectinspector
operator|.
name|primitive
operator|.
name|PrimitiveObjectInspectorUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|typeinfo
operator|.
name|PrimitiveTypeInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|typeinfo
operator|.
name|TypeInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|typeinfo
operator|.
name|TypeInfoUtils
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|ImmutableSet
import|;
end_import

begin_comment
comment|/**  * Factory for generating the different node processors used by ConstantPropagate.  */
end_comment

begin_class
specifier|public
specifier|final
class|class
name|ConstantPropagateProcFactory
block|{
specifier|protected
specifier|static
specifier|final
name|Log
name|LOG
init|=
name|LogFactory
operator|.
name|getLog
argument_list|(
name|ConstantPropagateProcFactory
operator|.
name|class
operator|.
name|getName
argument_list|()
argument_list|)
decl_stmt|;
specifier|protected
specifier|static
name|Set
argument_list|<
name|Class
argument_list|<
name|?
argument_list|>
argument_list|>
name|propagatableUdfs
init|=
operator|new
name|HashSet
argument_list|<
name|Class
argument_list|<
name|?
argument_list|>
argument_list|>
argument_list|()
decl_stmt|;
static|static
block|{
name|propagatableUdfs
operator|.
name|add
argument_list|(
name|GenericUDFOPAnd
operator|.
name|class
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
specifier|private
name|ConstantPropagateProcFactory
parameter_list|()
block|{
comment|// prevent instantiation
block|}
comment|/**    * Get ColumnInfo from column expression.    *     * @param rr    * @param desc    * @return    */
specifier|public
specifier|static
name|ColumnInfo
name|resolveColumn
parameter_list|(
name|RowResolver
name|rr
parameter_list|,
name|ExprNodeColumnDesc
name|desc
parameter_list|)
block|{
try|try
block|{
name|ColumnInfo
name|ci
init|=
name|rr
operator|.
name|get
argument_list|(
name|desc
operator|.
name|getTabAlias
argument_list|()
argument_list|,
name|desc
operator|.
name|getColumn
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|ci
operator|==
literal|null
condition|)
block|{
name|String
index|[]
name|tmp
init|=
name|rr
operator|.
name|reverseLookup
argument_list|(
name|desc
operator|.
name|getColumn
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|tmp
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
name|ci
operator|=
name|rr
operator|.
name|get
argument_list|(
name|tmp
index|[
literal|0
index|]
argument_list|,
name|tmp
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|ci
operator|.
name|setTabAlias
argument_list|(
name|tmp
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|ci
operator|.
name|setAlias
argument_list|(
name|tmp
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|String
index|[]
name|tmp
init|=
name|rr
operator|.
name|reverseLookup
argument_list|(
name|ci
operator|.
name|getInternalName
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|tmp
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
name|ci
operator|.
name|setTabAlias
argument_list|(
name|tmp
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|ci
operator|.
name|setAlias
argument_list|(
name|tmp
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
return|return
name|ci
return|;
block|}
catch|catch
parameter_list|(
name|SemanticException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
specifier|private
specifier|static
specifier|final
name|Set
argument_list|<
name|PrimitiveCategory
argument_list|>
name|unSupportedTypes
init|=
name|ImmutableSet
operator|.
expr|<
name|PrimitiveCategory
operator|>
name|builder
argument_list|()
operator|.
name|add
argument_list|(
name|PrimitiveCategory
operator|.
name|DECIMAL
argument_list|)
operator|.
name|add
argument_list|(
name|PrimitiveCategory
operator|.
name|VARCHAR
argument_list|)
operator|.
name|add
argument_list|(
name|PrimitiveCategory
operator|.
name|CHAR
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
comment|/**    * Cast type from expression type to expected type ti.    *     * @param desc constant expression    * @param ti expected type info    * @return cast constant, or null if the type cast failed.    */
specifier|private
specifier|static
name|ExprNodeConstantDesc
name|typeCast
parameter_list|(
name|ExprNodeDesc
name|desc
parameter_list|,
name|TypeInfo
name|ti
parameter_list|)
block|{
if|if
condition|(
name|desc
operator|instanceof
name|ExprNodeNullDesc
condition|)
block|{
return|return
literal|null
return|;
block|}
if|if
condition|(
operator|!
operator|(
name|ti
operator|instanceof
name|PrimitiveTypeInfo
operator|)
operator|||
operator|!
operator|(
name|desc
operator|.
name|getTypeInfo
argument_list|()
operator|instanceof
name|PrimitiveTypeInfo
operator|)
condition|)
block|{
return|return
literal|null
return|;
block|}
name|PrimitiveTypeInfo
name|priti
init|=
operator|(
name|PrimitiveTypeInfo
operator|)
name|ti
decl_stmt|;
name|PrimitiveTypeInfo
name|descti
init|=
operator|(
name|PrimitiveTypeInfo
operator|)
name|desc
operator|.
name|getTypeInfo
argument_list|()
decl_stmt|;
if|if
condition|(
name|unSupportedTypes
operator|.
name|contains
argument_list|(
name|priti
operator|.
name|getPrimitiveCategory
argument_list|()
argument_list|)
operator|||
name|unSupportedTypes
operator|.
name|contains
argument_list|(
name|descti
operator|.
name|getPrimitiveCategory
argument_list|()
argument_list|)
condition|)
block|{
comment|// FIXME: support template types. It currently has conflict with
comment|// ExprNodeConstantDesc
return|return
literal|null
return|;
block|}
name|LOG
operator|.
name|debug
argument_list|(
literal|"Casting "
operator|+
name|desc
operator|+
literal|" to type "
operator|+
name|ti
argument_list|)
expr_stmt|;
name|ExprNodeConstantDesc
name|c
init|=
operator|(
name|ExprNodeConstantDesc
operator|)
name|desc
decl_stmt|;
name|ObjectInspector
name|origOI
init|=
name|TypeInfoUtils
operator|.
name|getStandardJavaObjectInspectorFromTypeInfo
argument_list|(
name|desc
operator|.
name|getTypeInfo
argument_list|()
argument_list|)
decl_stmt|;
name|ObjectInspector
name|oi
init|=
name|TypeInfoUtils
operator|.
name|getStandardJavaObjectInspectorFromTypeInfo
argument_list|(
name|ti
argument_list|)
decl_stmt|;
name|Converter
name|converter
init|=
name|ObjectInspectorConverters
operator|.
name|getConverter
argument_list|(
name|origOI
argument_list|,
name|oi
argument_list|)
decl_stmt|;
name|Object
name|convObj
init|=
name|converter
operator|.
name|convert
argument_list|(
name|c
operator|.
name|getValue
argument_list|()
argument_list|)
decl_stmt|;
comment|// Convert integer related types because converters are not sufficient
if|if
condition|(
name|convObj
operator|instanceof
name|Integer
condition|)
block|{
switch|switch
condition|(
name|priti
operator|.
name|getPrimitiveCategory
argument_list|()
condition|)
block|{
case|case
name|BYTE
case|:
name|convObj
operator|=
operator|new
name|Byte
argument_list|(
call|(
name|byte
call|)
argument_list|(
operator|(
operator|(
name|Integer
operator|)
name|convObj
operator|)
operator|.
name|intValue
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|SHORT
case|:
name|convObj
operator|=
operator|new
name|Short
argument_list|(
call|(
name|short
call|)
argument_list|(
operator|(
name|Integer
operator|)
name|convObj
argument_list|)
operator|.
name|intValue
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|LONG
case|:
name|convObj
operator|=
operator|new
name|Long
argument_list|(
operator|(
operator|(
name|Integer
operator|)
name|convObj
operator|)
operator|.
name|intValue
argument_list|()
argument_list|)
expr_stmt|;
default|default:
block|}
block|}
return|return
operator|new
name|ExprNodeConstantDesc
argument_list|(
name|ti
argument_list|,
name|convObj
argument_list|)
return|;
block|}
comment|/**    * Fold input expression desc.    *     * If desc is a UDF and all parameters are constants, evaluate it. If desc is a column expression,    * find it from propagated constants, and if there is, replace it with constant.    *     * @param desc folding expression    * @param constants current propagated constant map    * @param cppCtx    * @param op processing operator    * @param propagate if true, assignment expressions will be added to constants.    * @return fold expression    */
specifier|private
specifier|static
name|ExprNodeDesc
name|foldExpr
parameter_list|(
name|ExprNodeDesc
name|desc
parameter_list|,
name|Map
argument_list|<
name|ColumnInfo
argument_list|,
name|ExprNodeDesc
argument_list|>
name|constants
parameter_list|,
name|ConstantPropagateProcCtx
name|cppCtx
parameter_list|,
name|Operator
argument_list|<
name|?
extends|extends
name|Serializable
argument_list|>
name|op
parameter_list|,
name|int
name|tag
parameter_list|,
name|boolean
name|propagate
parameter_list|)
block|{
if|if
condition|(
name|desc
operator|instanceof
name|ExprNodeGenericFuncDesc
condition|)
block|{
name|ExprNodeGenericFuncDesc
name|funcDesc
init|=
operator|(
name|ExprNodeGenericFuncDesc
operator|)
name|desc
decl_stmt|;
comment|// The function must be deterministic, or we can't fold it.
name|GenericUDF
name|udf
init|=
name|funcDesc
operator|.
name|getGenericUDF
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|isDeterministicUdf
argument_list|(
name|udf
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Function "
operator|+
name|udf
operator|.
name|getClass
argument_list|()
operator|+
literal|" undeterministic, quit folding."
argument_list|)
expr_stmt|;
return|return
name|desc
return|;
block|}
name|boolean
name|propagateNext
init|=
name|propagate
operator|&&
name|propagatableUdfs
operator|.
name|contains
argument_list|(
name|udf
operator|.
name|getClass
argument_list|()
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|ExprNodeDesc
argument_list|>
name|newExprs
init|=
operator|new
name|ArrayList
argument_list|<
name|ExprNodeDesc
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|ExprNodeDesc
name|childExpr
range|:
name|desc
operator|.
name|getChildren
argument_list|()
control|)
block|{
name|newExprs
operator|.
name|add
argument_list|(
name|foldExpr
argument_list|(
name|childExpr
argument_list|,
name|constants
argument_list|,
name|cppCtx
argument_list|,
name|op
argument_list|,
name|tag
argument_list|,
name|propagateNext
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// If all child expressions are constants, evaluate UDF immediately
name|ExprNodeDesc
name|constant
init|=
name|evaluateFunction
argument_list|(
name|udf
argument_list|,
name|newExprs
argument_list|,
name|desc
operator|.
name|getChildren
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|constant
operator|!=
literal|null
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Folding expression:"
operator|+
name|desc
operator|+
literal|" -> "
operator|+
name|constant
argument_list|)
expr_stmt|;
return|return
name|constant
return|;
block|}
else|else
block|{
comment|// Check if the function can be short cut.
name|ExprNodeDesc
name|shortcut
init|=
name|shortcutFunction
argument_list|(
name|udf
argument_list|,
name|newExprs
argument_list|)
decl_stmt|;
if|if
condition|(
name|shortcut
operator|!=
literal|null
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Folding expression:"
operator|+
name|desc
operator|+
literal|" -> "
operator|+
name|shortcut
argument_list|)
expr_stmt|;
return|return
name|shortcut
return|;
block|}
operator|(
operator|(
name|ExprNodeGenericFuncDesc
operator|)
name|desc
operator|)
operator|.
name|setChildren
argument_list|(
name|newExprs
argument_list|)
expr_stmt|;
block|}
comment|// If in some selected binary operators (=, is null, etc), one of the
comment|// expressions are
comment|// constant, add them to colToConstatns as half-deterministic columns.
if|if
condition|(
name|propagate
condition|)
block|{
name|propagate
argument_list|(
name|udf
argument_list|,
name|newExprs
argument_list|,
name|cppCtx
operator|.
name|getRowResolver
argument_list|(
name|op
argument_list|)
argument_list|,
name|constants
argument_list|)
expr_stmt|;
block|}
return|return
name|desc
return|;
block|}
elseif|else
if|if
condition|(
name|desc
operator|instanceof
name|ExprNodeColumnDesc
condition|)
block|{
if|if
condition|(
name|op
operator|.
name|getParentOperators
argument_list|()
operator|==
literal|null
operator|||
name|op
operator|.
name|getParentOperators
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return
name|desc
return|;
block|}
name|Operator
argument_list|<
name|?
extends|extends
name|Serializable
argument_list|>
name|parent
init|=
name|op
operator|.
name|getParentOperators
argument_list|()
operator|.
name|get
argument_list|(
name|tag
argument_list|)
decl_stmt|;
name|ExprNodeDesc
name|col
init|=
name|evaluateColumn
argument_list|(
operator|(
name|ExprNodeColumnDesc
operator|)
name|desc
argument_list|,
name|cppCtx
argument_list|,
name|parent
argument_list|)
decl_stmt|;
if|if
condition|(
name|col
operator|!=
literal|null
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Folding expression:"
operator|+
name|desc
operator|+
literal|" -> "
operator|+
name|col
argument_list|)
expr_stmt|;
return|return
name|col
return|;
block|}
block|}
return|return
name|desc
return|;
block|}
specifier|private
specifier|static
name|boolean
name|isDeterministicUdf
parameter_list|(
name|GenericUDF
name|udf
parameter_list|)
block|{
name|UDFType
name|udfType
init|=
name|udf
operator|.
name|getClass
argument_list|()
operator|.
name|getAnnotation
argument_list|(
name|UDFType
operator|.
name|class
argument_list|)
decl_stmt|;
if|if
condition|(
name|udf
operator|instanceof
name|GenericUDFBridge
condition|)
block|{
name|udfType
operator|=
operator|(
operator|(
name|GenericUDFBridge
operator|)
name|udf
operator|)
operator|.
name|getUdfClass
argument_list|()
operator|.
name|getAnnotation
argument_list|(
name|UDFType
operator|.
name|class
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|udfType
operator|.
name|deterministic
argument_list|()
operator|==
literal|false
condition|)
block|{
return|return
literal|false
return|;
block|}
comment|// If udf is requiring additional jars, we can't determine the result in
comment|// compile time.
name|String
index|[]
name|files
decl_stmt|;
name|String
index|[]
name|jars
decl_stmt|;
if|if
condition|(
name|udf
operator|instanceof
name|GenericUDFBridge
condition|)
block|{
name|GenericUDFBridge
name|bridge
init|=
operator|(
name|GenericUDFBridge
operator|)
name|udf
decl_stmt|;
name|String
name|udfClassName
init|=
name|bridge
operator|.
name|getUdfClassName
argument_list|()
decl_stmt|;
try|try
block|{
name|UDF
name|udfInternal
init|=
operator|(
name|UDF
operator|)
name|Class
operator|.
name|forName
argument_list|(
name|bridge
operator|.
name|getUdfClassName
argument_list|()
argument_list|,
literal|true
argument_list|,
name|JavaUtils
operator|.
name|getClassLoader
argument_list|()
argument_list|)
operator|.
name|newInstance
argument_list|()
decl_stmt|;
name|files
operator|=
name|udfInternal
operator|.
name|getRequiredFiles
argument_list|()
expr_stmt|;
name|jars
operator|=
name|udf
operator|.
name|getRequiredJars
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"The UDF implementation class '"
operator|+
name|udfClassName
operator|+
literal|"' is not present in the class path"
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
else|else
block|{
name|files
operator|=
name|udf
operator|.
name|getRequiredFiles
argument_list|()
expr_stmt|;
name|jars
operator|=
name|udf
operator|.
name|getRequiredJars
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|files
operator|!=
literal|null
operator|||
name|jars
operator|!=
literal|null
condition|)
block|{
return|return
literal|false
return|;
block|}
return|return
literal|true
return|;
block|}
comment|/**    * Propagate assignment expression, adding an entry into constant map constants.    *     * @param udf expression UDF, currently only 2 UDFs are supported: '=' and 'is null'.    * @param newExprs child expressions (parameters).    * @param cppCtx    * @param op    * @param constants    */
specifier|private
specifier|static
name|void
name|propagate
parameter_list|(
name|GenericUDF
name|udf
parameter_list|,
name|List
argument_list|<
name|ExprNodeDesc
argument_list|>
name|newExprs
parameter_list|,
name|RowResolver
name|rr
parameter_list|,
name|Map
argument_list|<
name|ColumnInfo
argument_list|,
name|ExprNodeDesc
argument_list|>
name|constants
parameter_list|)
block|{
if|if
condition|(
name|udf
operator|instanceof
name|GenericUDFOPEqual
condition|)
block|{
name|ExprNodeDesc
name|lOperand
init|=
name|newExprs
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|ExprNodeDesc
name|rOperand
init|=
name|newExprs
operator|.
name|get
argument_list|(
literal|1
argument_list|)
decl_stmt|;
name|ExprNodeColumnDesc
name|c
decl_stmt|;
name|ExprNodeConstantDesc
name|v
decl_stmt|;
if|if
condition|(
name|lOperand
operator|instanceof
name|ExprNodeColumnDesc
operator|&&
name|rOperand
operator|instanceof
name|ExprNodeConstantDesc
condition|)
block|{
name|c
operator|=
operator|(
name|ExprNodeColumnDesc
operator|)
name|lOperand
expr_stmt|;
name|v
operator|=
operator|(
name|ExprNodeConstantDesc
operator|)
name|rOperand
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|rOperand
operator|instanceof
name|ExprNodeColumnDesc
operator|&&
name|lOperand
operator|instanceof
name|ExprNodeConstantDesc
condition|)
block|{
name|c
operator|=
operator|(
name|ExprNodeColumnDesc
operator|)
name|rOperand
expr_stmt|;
name|v
operator|=
operator|(
name|ExprNodeConstantDesc
operator|)
name|lOperand
expr_stmt|;
block|}
else|else
block|{
return|return;
block|}
name|ColumnInfo
name|ci
init|=
name|resolveColumn
argument_list|(
name|rr
argument_list|,
name|c
argument_list|)
decl_stmt|;
if|if
condition|(
name|ci
operator|!=
literal|null
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Filter "
operator|+
name|udf
operator|+
literal|" is identified as a value assignment, propagate it."
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|v
operator|.
name|getTypeInfo
argument_list|()
operator|.
name|equals
argument_list|(
name|ci
operator|.
name|getType
argument_list|()
argument_list|)
condition|)
block|{
name|v
operator|=
name|typeCast
argument_list|(
name|v
argument_list|,
name|ci
operator|.
name|getType
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|v
operator|!=
literal|null
condition|)
block|{
name|constants
operator|.
name|put
argument_list|(
name|ci
argument_list|,
name|v
argument_list|)
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|udf
operator|instanceof
name|GenericUDFOPNull
condition|)
block|{
name|ExprNodeDesc
name|operand
init|=
name|newExprs
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|operand
operator|instanceof
name|ExprNodeColumnDesc
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Filter "
operator|+
name|udf
operator|+
literal|" is identified as a value assignment, propagate it."
argument_list|)
expr_stmt|;
name|ExprNodeColumnDesc
name|c
init|=
operator|(
name|ExprNodeColumnDesc
operator|)
name|operand
decl_stmt|;
name|ColumnInfo
name|ci
init|=
name|resolveColumn
argument_list|(
name|rr
argument_list|,
name|c
argument_list|)
decl_stmt|;
if|if
condition|(
name|ci
operator|!=
literal|null
condition|)
block|{
name|constants
operator|.
name|put
argument_list|(
name|ci
argument_list|,
operator|new
name|ExprNodeNullDesc
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
specifier|private
specifier|static
name|ExprNodeDesc
name|shortcutFunction
parameter_list|(
name|GenericUDF
name|udf
parameter_list|,
name|List
argument_list|<
name|ExprNodeDesc
argument_list|>
name|newExprs
parameter_list|)
block|{
if|if
condition|(
name|udf
operator|instanceof
name|GenericUDFOPAnd
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
literal|2
condition|;
name|i
operator|++
control|)
block|{
name|ExprNodeDesc
name|childExpr
init|=
name|newExprs
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|childExpr
operator|instanceof
name|ExprNodeConstantDesc
condition|)
block|{
name|ExprNodeConstantDesc
name|c
init|=
operator|(
name|ExprNodeConstantDesc
operator|)
name|childExpr
decl_stmt|;
if|if
condition|(
name|c
operator|.
name|getValue
argument_list|()
operator|==
name|Boolean
operator|.
name|TRUE
condition|)
block|{
comment|// if true, prune it
return|return
name|newExprs
operator|.
name|get
argument_list|(
name|Math
operator|.
name|abs
argument_list|(
name|i
operator|-
literal|1
argument_list|)
argument_list|)
return|;
block|}
else|else
block|{
comment|// if false return false
return|return
name|childExpr
return|;
block|}
block|}
block|}
block|}
if|if
condition|(
name|udf
operator|instanceof
name|GenericUDFOPOr
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
literal|2
condition|;
name|i
operator|++
control|)
block|{
name|ExprNodeDesc
name|childExpr
init|=
name|newExprs
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|childExpr
operator|instanceof
name|ExprNodeConstantDesc
condition|)
block|{
name|ExprNodeConstantDesc
name|c
init|=
operator|(
name|ExprNodeConstantDesc
operator|)
name|childExpr
decl_stmt|;
if|if
condition|(
name|c
operator|.
name|getValue
argument_list|()
operator|==
name|Boolean
operator|.
name|FALSE
condition|)
block|{
comment|// if false, prune it
return|return
name|newExprs
operator|.
name|get
argument_list|(
name|Math
operator|.
name|abs
argument_list|(
name|i
operator|-
literal|1
argument_list|)
argument_list|)
return|;
block|}
else|else
block|{
comment|// if true return true
return|return
name|childExpr
return|;
block|}
block|}
block|}
block|}
return|return
literal|null
return|;
block|}
comment|/**    * Evaluate column, replace the deterministic columns with constants if possible    *     * @param desc    * @param ctx    * @param op    * @param colToConstants    * @return    */
specifier|private
specifier|static
name|ExprNodeDesc
name|evaluateColumn
parameter_list|(
name|ExprNodeColumnDesc
name|desc
parameter_list|,
name|ConstantPropagateProcCtx
name|cppCtx
parameter_list|,
name|Operator
argument_list|<
name|?
extends|extends
name|Serializable
argument_list|>
name|parent
parameter_list|)
block|{
try|try
block|{
name|ColumnInfo
name|ci
init|=
literal|null
decl_stmt|;
name|RowResolver
name|rr
init|=
name|cppCtx
operator|.
name|getOpToParseCtxMap
argument_list|()
operator|.
name|get
argument_list|(
name|parent
argument_list|)
operator|.
name|getRowResolver
argument_list|()
decl_stmt|;
name|String
index|[]
name|tmp
init|=
name|rr
operator|.
name|reverseLookup
argument_list|(
name|desc
operator|.
name|getColumn
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|tmp
operator|==
literal|null
condition|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Reverse look up of column "
operator|+
name|desc
operator|+
literal|" error!"
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
name|ci
operator|=
name|rr
operator|.
name|get
argument_list|(
name|tmp
index|[
literal|0
index|]
argument_list|,
name|tmp
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|ci
operator|!=
literal|null
condition|)
block|{
name|ExprNodeDesc
name|constant
init|=
literal|null
decl_stmt|;
comment|// Additional work for union operator, see union27.q
if|if
condition|(
name|ci
operator|.
name|getAlias
argument_list|()
operator|==
literal|null
condition|)
block|{
for|for
control|(
name|Entry
argument_list|<
name|ColumnInfo
argument_list|,
name|ExprNodeDesc
argument_list|>
name|e
range|:
name|cppCtx
operator|.
name|getOpToConstantExprs
argument_list|()
operator|.
name|get
argument_list|(
name|parent
argument_list|)
operator|.
name|entrySet
argument_list|()
control|)
block|{
if|if
condition|(
name|e
operator|.
name|getKey
argument_list|()
operator|.
name|getInternalName
argument_list|()
operator|.
name|equals
argument_list|(
name|ci
operator|.
name|getInternalName
argument_list|()
argument_list|)
condition|)
block|{
name|constant
operator|=
name|e
operator|.
name|getValue
argument_list|()
expr_stmt|;
break|break;
block|}
block|}
block|}
else|else
block|{
name|constant
operator|=
name|cppCtx
operator|.
name|getOpToConstantExprs
argument_list|()
operator|.
name|get
argument_list|(
name|parent
argument_list|)
operator|.
name|get
argument_list|(
name|ci
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|constant
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|constant
operator|instanceof
name|ExprNodeConstantDesc
operator|&&
operator|!
name|constant
operator|.
name|getTypeInfo
argument_list|()
operator|.
name|equals
argument_list|(
name|desc
operator|.
name|getTypeInfo
argument_list|()
argument_list|)
condition|)
block|{
return|return
name|typeCast
argument_list|(
name|constant
argument_list|,
name|desc
operator|.
name|getTypeInfo
argument_list|()
argument_list|)
return|;
block|}
return|return
name|constant
return|;
block|}
else|else
block|{
return|return
literal|null
return|;
block|}
block|}
name|LOG
operator|.
name|error
argument_list|(
literal|"Can't resolve "
operator|+
name|desc
operator|.
name|getTabAlias
argument_list|()
operator|+
literal|"."
operator|+
name|desc
operator|.
name|getColumn
argument_list|()
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Can't resolve "
operator|+
name|desc
operator|.
name|getTabAlias
argument_list|()
operator|+
literal|"."
operator|+
name|desc
operator|.
name|getColumn
argument_list|()
argument_list|)
throw|;
block|}
catch|catch
parameter_list|(
name|SemanticException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
comment|/**    * Evaluate UDF    *     * @param udf UDF object    * @param exprs    * @param oldExprs    * @return null if expression cannot be evaluated (not all parameters are constants). Or evaluated    *         ExprNodeConstantDesc if possible.    * @throws HiveException    */
specifier|private
specifier|static
name|ExprNodeDesc
name|evaluateFunction
parameter_list|(
name|GenericUDF
name|udf
parameter_list|,
name|List
argument_list|<
name|ExprNodeDesc
argument_list|>
name|exprs
parameter_list|,
name|List
argument_list|<
name|ExprNodeDesc
argument_list|>
name|oldExprs
parameter_list|)
block|{
name|DeferredJavaObject
index|[]
name|arguments
init|=
operator|new
name|DeferredJavaObject
index|[
name|exprs
operator|.
name|size
argument_list|()
index|]
decl_stmt|;
name|ObjectInspector
index|[]
name|argois
init|=
operator|new
name|ObjectInspector
index|[
name|exprs
operator|.
name|size
argument_list|()
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|exprs
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|ExprNodeDesc
name|desc
init|=
name|exprs
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|desc
operator|instanceof
name|ExprNodeConstantDesc
condition|)
block|{
name|ExprNodeConstantDesc
name|constant
init|=
operator|(
name|ExprNodeConstantDesc
operator|)
name|exprs
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|constant
operator|.
name|getTypeInfo
argument_list|()
operator|.
name|equals
argument_list|(
name|oldExprs
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|getTypeInfo
argument_list|()
argument_list|)
condition|)
block|{
name|constant
operator|=
name|typeCast
argument_list|(
name|constant
argument_list|,
name|oldExprs
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|getTypeInfo
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|constant
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
block|}
name|Object
name|value
init|=
name|constant
operator|.
name|getValue
argument_list|()
decl_stmt|;
name|PrimitiveTypeInfo
name|pti
init|=
operator|(
name|PrimitiveTypeInfo
operator|)
name|constant
operator|.
name|getTypeInfo
argument_list|()
decl_stmt|;
name|Object
name|writableValue
init|=
name|PrimitiveObjectInspectorFactory
operator|.
name|getPrimitiveJavaObjectInspector
argument_list|(
name|pti
argument_list|)
operator|.
name|getPrimitiveWritableObject
argument_list|(
name|value
argument_list|)
decl_stmt|;
name|arguments
index|[
name|i
index|]
operator|=
operator|new
name|DeferredJavaObject
argument_list|(
name|writableValue
argument_list|)
expr_stmt|;
name|argois
index|[
name|i
index|]
operator|=
name|ObjectInspectorUtils
operator|.
name|getConstantObjectInspector
argument_list|(
name|constant
operator|.
name|getWritableObjectInspector
argument_list|()
argument_list|,
name|writableValue
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|desc
operator|instanceof
name|ExprNodeNullDesc
condition|)
block|{
comment|// FIXME: add null support.
return|return
literal|null
return|;
block|}
else|else
block|{
return|return
literal|null
return|;
block|}
block|}
try|try
block|{
name|ObjectInspector
name|oi
init|=
name|udf
operator|.
name|initialize
argument_list|(
name|argois
argument_list|)
decl_stmt|;
name|Object
name|o
init|=
name|udf
operator|.
name|evaluate
argument_list|(
name|arguments
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
name|udf
operator|.
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
operator|+
literal|"("
operator|+
name|exprs
operator|+
literal|")="
operator|+
name|o
argument_list|)
expr_stmt|;
if|if
condition|(
name|o
operator|==
literal|null
condition|)
block|{
return|return
operator|new
name|ExprNodeNullDesc
argument_list|()
return|;
block|}
name|Class
argument_list|<
name|?
argument_list|>
name|clz
init|=
name|o
operator|.
name|getClass
argument_list|()
decl_stmt|;
if|if
condition|(
name|PrimitiveObjectInspectorUtils
operator|.
name|isPrimitiveWritableClass
argument_list|(
name|clz
argument_list|)
condition|)
block|{
name|PrimitiveObjectInspector
name|poi
init|=
operator|(
name|PrimitiveObjectInspector
operator|)
name|oi
decl_stmt|;
name|TypeInfo
name|typeInfo
init|=
name|poi
operator|.
name|getTypeInfo
argument_list|()
decl_stmt|;
comment|// Handling parameterized types (varchar, decimal, etc).
if|if
condition|(
name|typeInfo
operator|.
name|getTypeName
argument_list|()
operator|.
name|contains
argument_list|(
name|serdeConstants
operator|.
name|DECIMAL_TYPE_NAME
argument_list|)
operator|||
name|typeInfo
operator|.
name|getTypeName
argument_list|()
operator|.
name|contains
argument_list|(
name|serdeConstants
operator|.
name|VARCHAR_TYPE_NAME
argument_list|)
operator|||
name|typeInfo
operator|.
name|getTypeName
argument_list|()
operator|.
name|contains
argument_list|(
name|serdeConstants
operator|.
name|CHAR_TYPE_NAME
argument_list|)
condition|)
block|{
comment|// Do not support parameterized types.
return|return
literal|null
return|;
block|}
name|o
operator|=
name|poi
operator|.
name|getPrimitiveJavaObject
argument_list|(
name|o
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|PrimitiveObjectInspectorUtils
operator|.
name|isPrimitiveJavaClass
argument_list|(
name|clz
argument_list|)
condition|)
block|{        }
else|else
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Unable to evaluate "
operator|+
name|udf
operator|+
literal|". Return value unrecoginizable."
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
return|return
operator|new
name|ExprNodeConstantDesc
argument_list|(
name|o
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|HiveException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Evaluation function "
operator|+
name|udf
operator|.
name|getClass
argument_list|()
operator|+
literal|" failed in Constant Propagatation Optimizer."
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|RuntimeException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
comment|/**    * Change operator row schema, replace column with constant if it is.    *     * @param op    * @param constants    * @throws SemanticException    */
specifier|private
specifier|static
name|void
name|foldOperator
parameter_list|(
name|Operator
argument_list|<
name|?
extends|extends
name|Serializable
argument_list|>
name|op
parameter_list|,
name|ConstantPropagateProcCtx
name|cppCtx
parameter_list|)
throws|throws
name|SemanticException
block|{
name|RowSchema
name|schema
init|=
name|op
operator|.
name|getSchema
argument_list|()
decl_stmt|;
name|Map
argument_list|<
name|ColumnInfo
argument_list|,
name|ExprNodeDesc
argument_list|>
name|constants
init|=
name|cppCtx
operator|.
name|getOpToConstantExprs
argument_list|()
operator|.
name|get
argument_list|(
name|op
argument_list|)
decl_stmt|;
if|if
condition|(
name|schema
operator|!=
literal|null
operator|&&
name|schema
operator|.
name|getSignature
argument_list|()
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|ColumnInfo
name|col
range|:
name|schema
operator|.
name|getSignature
argument_list|()
control|)
block|{
name|ExprNodeDesc
name|constant
init|=
name|constants
operator|.
name|get
argument_list|(
name|col
argument_list|)
decl_stmt|;
if|if
condition|(
name|constant
operator|!=
literal|null
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Replacing column "
operator|+
name|col
operator|+
literal|" with constant "
operator|+
name|constant
operator|+
literal|" in "
operator|+
name|op
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|col
operator|.
name|getType
argument_list|()
operator|.
name|equals
argument_list|(
name|constant
operator|.
name|getTypeInfo
argument_list|()
argument_list|)
condition|)
block|{
name|constant
operator|=
name|typeCast
argument_list|(
name|constant
argument_list|,
name|col
operator|.
name|getType
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|constant
operator|!=
literal|null
condition|)
block|{
name|col
operator|.
name|setObjectinspector
argument_list|(
name|constant
operator|.
name|getWritableObjectInspector
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
name|Map
argument_list|<
name|String
argument_list|,
name|ExprNodeDesc
argument_list|>
name|colExprMap
init|=
name|op
operator|.
name|getColumnExprMap
argument_list|()
decl_stmt|;
if|if
condition|(
name|colExprMap
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|Entry
argument_list|<
name|ColumnInfo
argument_list|,
name|ExprNodeDesc
argument_list|>
name|e
range|:
name|constants
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|String
name|internalName
init|=
name|e
operator|.
name|getKey
argument_list|()
operator|.
name|getInternalName
argument_list|()
decl_stmt|;
if|if
condition|(
name|colExprMap
operator|.
name|containsKey
argument_list|(
name|internalName
argument_list|)
condition|)
block|{
name|colExprMap
operator|.
name|put
argument_list|(
name|internalName
argument_list|,
name|e
operator|.
name|getValue
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/**    * Node Processor for Constant Propagation on Filter Operators. The processor is to fold    * conditional expressions and extract assignment expressions and propagate them.    */
specifier|public
specifier|static
class|class
name|ConstantPropagateFilterProc
implements|implements
name|NodeProcessor
block|{
specifier|public
name|Object
name|process
parameter_list|(
name|Node
name|nd
parameter_list|,
name|Stack
argument_list|<
name|Node
argument_list|>
name|stack
parameter_list|,
name|NodeProcessorCtx
name|ctx
parameter_list|,
name|Object
modifier|...
name|nodeOutputs
parameter_list|)
throws|throws
name|SemanticException
block|{
name|FilterOperator
name|op
init|=
operator|(
name|FilterOperator
operator|)
name|nd
decl_stmt|;
name|ConstantPropagateProcCtx
name|cppCtx
init|=
operator|(
name|ConstantPropagateProcCtx
operator|)
name|ctx
decl_stmt|;
name|Map
argument_list|<
name|ColumnInfo
argument_list|,
name|ExprNodeDesc
argument_list|>
name|constants
init|=
name|cppCtx
operator|.
name|getPropagatedConstants
argument_list|(
name|op
argument_list|)
decl_stmt|;
name|cppCtx
operator|.
name|getOpToConstantExprs
argument_list|()
operator|.
name|put
argument_list|(
name|op
argument_list|,
name|constants
argument_list|)
expr_stmt|;
name|ExprNodeDesc
name|condn
init|=
name|op
operator|.
name|getConf
argument_list|()
operator|.
name|getPredicate
argument_list|()
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Old filter FIL["
operator|+
name|op
operator|.
name|getIdentifier
argument_list|()
operator|+
literal|"] conditions:"
operator|+
name|condn
operator|.
name|getExprString
argument_list|()
argument_list|)
expr_stmt|;
name|ExprNodeDesc
name|newCondn
init|=
name|foldExpr
argument_list|(
name|condn
argument_list|,
name|constants
argument_list|,
name|cppCtx
argument_list|,
name|op
argument_list|,
literal|0
argument_list|,
literal|true
argument_list|)
decl_stmt|;
if|if
condition|(
name|newCondn
operator|instanceof
name|ExprNodeConstantDesc
condition|)
block|{
name|ExprNodeConstantDesc
name|c
init|=
operator|(
name|ExprNodeConstantDesc
operator|)
name|newCondn
decl_stmt|;
if|if
condition|(
name|c
operator|.
name|getValue
argument_list|()
operator|==
name|Boolean
operator|.
name|TRUE
condition|)
block|{
name|cppCtx
operator|.
name|addOpToDelete
argument_list|(
name|op
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Filter expression "
operator|+
name|condn
operator|+
literal|" holds true. Will delete it."
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|.
name|getValue
argument_list|()
operator|==
name|Boolean
operator|.
name|FALSE
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Filter expression "
operator|+
name|condn
operator|+
literal|" holds false!"
argument_list|)
expr_stmt|;
block|}
block|}
name|LOG
operator|.
name|debug
argument_list|(
literal|"New filter FIL["
operator|+
name|op
operator|.
name|getIdentifier
argument_list|()
operator|+
literal|"] conditions:"
operator|+
name|newCondn
operator|.
name|getExprString
argument_list|()
argument_list|)
expr_stmt|;
comment|// merge it with the downstream col list
name|op
operator|.
name|getConf
argument_list|()
operator|.
name|setPredicate
argument_list|(
name|newCondn
argument_list|)
expr_stmt|;
name|foldOperator
argument_list|(
name|op
argument_list|,
name|cppCtx
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
block|}
comment|/**    * Factory method to get the ConstantPropagateFilterProc class.    *     * @return ConstantPropagateFilterProc    */
specifier|public
specifier|static
name|ConstantPropagateFilterProc
name|getFilterProc
parameter_list|()
block|{
return|return
operator|new
name|ConstantPropagateFilterProc
argument_list|()
return|;
block|}
comment|/**    * Node Processor for Constant Propagate for Group By Operators.    */
specifier|public
specifier|static
class|class
name|ConstantPropagateGroupByProc
implements|implements
name|NodeProcessor
block|{
specifier|public
name|Object
name|process
parameter_list|(
name|Node
name|nd
parameter_list|,
name|Stack
argument_list|<
name|Node
argument_list|>
name|stack
parameter_list|,
name|NodeProcessorCtx
name|ctx
parameter_list|,
name|Object
modifier|...
name|nodeOutputs
parameter_list|)
throws|throws
name|SemanticException
block|{
name|GroupByOperator
name|op
init|=
operator|(
name|GroupByOperator
operator|)
name|nd
decl_stmt|;
name|ConstantPropagateProcCtx
name|cppCtx
init|=
operator|(
name|ConstantPropagateProcCtx
operator|)
name|ctx
decl_stmt|;
name|Map
argument_list|<
name|ColumnInfo
argument_list|,
name|ExprNodeDesc
argument_list|>
name|colToConstants
init|=
name|cppCtx
operator|.
name|getPropagatedConstants
argument_list|(
name|op
argument_list|)
decl_stmt|;
name|cppCtx
operator|.
name|getOpToConstantExprs
argument_list|()
operator|.
name|put
argument_list|(
name|op
argument_list|,
name|colToConstants
argument_list|)
expr_stmt|;
if|if
condition|(
name|colToConstants
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return
literal|null
return|;
block|}
name|GroupByDesc
name|conf
init|=
name|op
operator|.
name|getConf
argument_list|()
decl_stmt|;
name|ArrayList
argument_list|<
name|ExprNodeDesc
argument_list|>
name|keys
init|=
name|conf
operator|.
name|getKeys
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|keys
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|ExprNodeDesc
name|key
init|=
name|keys
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|ExprNodeDesc
name|newkey
init|=
name|foldExpr
argument_list|(
name|key
argument_list|,
name|colToConstants
argument_list|,
name|cppCtx
argument_list|,
name|op
argument_list|,
literal|0
argument_list|,
literal|false
argument_list|)
decl_stmt|;
name|keys
operator|.
name|set
argument_list|(
name|i
argument_list|,
name|newkey
argument_list|)
expr_stmt|;
block|}
name|foldOperator
argument_list|(
name|op
argument_list|,
name|cppCtx
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
block|}
comment|/**    * Factory method to get the ConstantPropagateGroupByProc class.    *     * @return ConstantPropagateGroupByProc    */
specifier|public
specifier|static
name|ConstantPropagateGroupByProc
name|getGroupByProc
parameter_list|()
block|{
return|return
operator|new
name|ConstantPropagateGroupByProc
argument_list|()
return|;
block|}
comment|/**    * The Default Node Processor for Constant Propagation.    */
specifier|public
specifier|static
class|class
name|ConstantPropagateDefaultProc
implements|implements
name|NodeProcessor
block|{
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
specifier|public
name|Object
name|process
parameter_list|(
name|Node
name|nd
parameter_list|,
name|Stack
argument_list|<
name|Node
argument_list|>
name|stack
parameter_list|,
name|NodeProcessorCtx
name|ctx
parameter_list|,
name|Object
modifier|...
name|nodeOutputs
parameter_list|)
throws|throws
name|SemanticException
block|{
name|ConstantPropagateProcCtx
name|cppCtx
init|=
operator|(
name|ConstantPropagateProcCtx
operator|)
name|ctx
decl_stmt|;
name|Operator
argument_list|<
name|?
extends|extends
name|Serializable
argument_list|>
name|op
init|=
operator|(
name|Operator
argument_list|<
name|?
extends|extends
name|Serializable
argument_list|>
operator|)
name|nd
decl_stmt|;
name|Map
argument_list|<
name|ColumnInfo
argument_list|,
name|ExprNodeDesc
argument_list|>
name|constants
init|=
name|cppCtx
operator|.
name|getPropagatedConstants
argument_list|(
name|op
argument_list|)
decl_stmt|;
name|cppCtx
operator|.
name|getOpToConstantExprs
argument_list|()
operator|.
name|put
argument_list|(
name|op
argument_list|,
name|constants
argument_list|)
expr_stmt|;
if|if
condition|(
name|constants
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return
literal|null
return|;
block|}
name|foldOperator
argument_list|(
name|op
argument_list|,
name|cppCtx
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
block|}
comment|/**    * Factory method to get the ConstantPropagateDefaultProc class.    *     * @return ConstantPropagateDefaultProc    */
specifier|public
specifier|static
name|ConstantPropagateDefaultProc
name|getDefaultProc
parameter_list|()
block|{
return|return
operator|new
name|ConstantPropagateDefaultProc
argument_list|()
return|;
block|}
comment|/**    * The Node Processor for Constant Propagation for Select Operators.    */
specifier|public
specifier|static
class|class
name|ConstantPropagateSelectProc
implements|implements
name|NodeProcessor
block|{
specifier|public
name|Object
name|process
parameter_list|(
name|Node
name|nd
parameter_list|,
name|Stack
argument_list|<
name|Node
argument_list|>
name|stack
parameter_list|,
name|NodeProcessorCtx
name|ctx
parameter_list|,
name|Object
modifier|...
name|nodeOutputs
parameter_list|)
throws|throws
name|SemanticException
block|{
name|SelectOperator
name|op
init|=
operator|(
name|SelectOperator
operator|)
name|nd
decl_stmt|;
name|ConstantPropagateProcCtx
name|cppCtx
init|=
operator|(
name|ConstantPropagateProcCtx
operator|)
name|ctx
decl_stmt|;
name|Map
argument_list|<
name|ColumnInfo
argument_list|,
name|ExprNodeDesc
argument_list|>
name|constants
init|=
name|cppCtx
operator|.
name|getPropagatedConstants
argument_list|(
name|op
argument_list|)
decl_stmt|;
name|cppCtx
operator|.
name|getOpToConstantExprs
argument_list|()
operator|.
name|put
argument_list|(
name|op
argument_list|,
name|constants
argument_list|)
expr_stmt|;
name|foldOperator
argument_list|(
name|op
argument_list|,
name|cppCtx
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|ExprNodeDesc
argument_list|>
name|colList
init|=
name|op
operator|.
name|getConf
argument_list|()
operator|.
name|getColList
argument_list|()
decl_stmt|;
if|if
condition|(
name|colList
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|colList
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|ExprNodeDesc
name|newCol
init|=
name|foldExpr
argument_list|(
name|colList
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|,
name|constants
argument_list|,
name|cppCtx
argument_list|,
name|op
argument_list|,
literal|0
argument_list|,
literal|false
argument_list|)
decl_stmt|;
name|colList
operator|.
name|set
argument_list|(
name|i
argument_list|,
name|newCol
argument_list|)
expr_stmt|;
block|}
name|LOG
operator|.
name|debug
argument_list|(
literal|"New column list:("
operator|+
name|StringUtils
operator|.
name|join
argument_list|(
name|colList
argument_list|,
literal|" "
argument_list|)
operator|+
literal|")"
argument_list|)
expr_stmt|;
block|}
return|return
literal|null
return|;
block|}
block|}
comment|/**    * The Factory method to get the ConstantPropagateSelectProc class.    *     * @return ConstantPropagateSelectProc    */
specifier|public
specifier|static
name|ConstantPropagateSelectProc
name|getSelectProc
parameter_list|()
block|{
return|return
operator|new
name|ConstantPropagateSelectProc
argument_list|()
return|;
block|}
comment|/**    * The Node Processor for constant propagation for FileSink Operators. In addition to constant    * propagation, this processor also prunes dynamic partitions to static partitions if possible.    */
specifier|public
specifier|static
class|class
name|ConstantPropagateFileSinkProc
implements|implements
name|NodeProcessor
block|{
specifier|public
name|Object
name|process
parameter_list|(
name|Node
name|nd
parameter_list|,
name|Stack
argument_list|<
name|Node
argument_list|>
name|stack
parameter_list|,
name|NodeProcessorCtx
name|ctx
parameter_list|,
name|Object
modifier|...
name|nodeOutputs
parameter_list|)
throws|throws
name|SemanticException
block|{
name|FileSinkOperator
name|op
init|=
operator|(
name|FileSinkOperator
operator|)
name|nd
decl_stmt|;
name|ConstantPropagateProcCtx
name|cppCtx
init|=
operator|(
name|ConstantPropagateProcCtx
operator|)
name|ctx
decl_stmt|;
name|Map
argument_list|<
name|ColumnInfo
argument_list|,
name|ExprNodeDesc
argument_list|>
name|constants
init|=
name|cppCtx
operator|.
name|getPropagatedConstants
argument_list|(
name|op
argument_list|)
decl_stmt|;
name|cppCtx
operator|.
name|getOpToConstantExprs
argument_list|()
operator|.
name|put
argument_list|(
name|op
argument_list|,
name|constants
argument_list|)
expr_stmt|;
if|if
condition|(
name|constants
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return
literal|null
return|;
block|}
name|FileSinkDesc
name|fsdesc
init|=
name|op
operator|.
name|getConf
argument_list|()
decl_stmt|;
name|DynamicPartitionCtx
name|dpCtx
init|=
name|fsdesc
operator|.
name|getDynPartCtx
argument_list|()
decl_stmt|;
if|if
condition|(
name|dpCtx
operator|!=
literal|null
condition|)
block|{
comment|// If all dynamic partitions are propagated as constant, remove DP.
name|Set
argument_list|<
name|String
argument_list|>
name|inputs
init|=
name|dpCtx
operator|.
name|getInputToDPCols
argument_list|()
operator|.
name|keySet
argument_list|()
decl_stmt|;
comment|// Assume only 1 parent for FS operator
name|Operator
argument_list|<
name|?
extends|extends
name|Serializable
argument_list|>
name|parent
init|=
name|op
operator|.
name|getParentOperators
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|Map
argument_list|<
name|ColumnInfo
argument_list|,
name|ExprNodeDesc
argument_list|>
name|parentConstants
init|=
name|cppCtx
operator|.
name|getPropagatedConstants
argument_list|(
name|parent
argument_list|)
decl_stmt|;
name|RowResolver
name|rr
init|=
name|cppCtx
operator|.
name|getOpToParseCtxMap
argument_list|()
operator|.
name|get
argument_list|(
name|parent
argument_list|)
operator|.
name|getRowResolver
argument_list|()
decl_stmt|;
name|boolean
name|allConstant
init|=
literal|true
decl_stmt|;
for|for
control|(
name|String
name|input
range|:
name|inputs
control|)
block|{
name|String
name|tmp
index|[]
init|=
name|rr
operator|.
name|reverseLookup
argument_list|(
name|input
argument_list|)
decl_stmt|;
name|ColumnInfo
name|ci
init|=
name|rr
operator|.
name|get
argument_list|(
name|tmp
index|[
literal|0
index|]
argument_list|,
name|tmp
index|[
literal|1
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
name|parentConstants
operator|.
name|get
argument_list|(
name|ci
argument_list|)
operator|==
literal|null
condition|)
block|{
name|allConstant
operator|=
literal|false
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|allConstant
condition|)
block|{
name|pruneDP
argument_list|(
name|fsdesc
argument_list|)
expr_stmt|;
block|}
block|}
name|foldOperator
argument_list|(
name|op
argument_list|,
name|cppCtx
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
specifier|private
name|void
name|pruneDP
parameter_list|(
name|FileSinkDesc
name|fsdesc
parameter_list|)
block|{
comment|// FIXME: Support pruning dynamic partitioning.
name|LOG
operator|.
name|info
argument_list|(
literal|"DP can be rewritten to SP!"
argument_list|)
expr_stmt|;
block|}
block|}
specifier|public
specifier|static
name|NodeProcessor
name|getFileSinkProc
parameter_list|()
block|{
return|return
operator|new
name|ConstantPropagateFileSinkProc
argument_list|()
return|;
block|}
comment|/**    * The Node Processor for Constant Propagation for Operators which is designed to stop propagate.    * Currently these kinds of Operators include UnionOperator and ScriptOperator.    */
specifier|public
specifier|static
class|class
name|ConstantPropagateStopProc
implements|implements
name|NodeProcessor
block|{
specifier|public
name|Object
name|process
parameter_list|(
name|Node
name|nd
parameter_list|,
name|Stack
argument_list|<
name|Node
argument_list|>
name|stack
parameter_list|,
name|NodeProcessorCtx
name|ctx
parameter_list|,
name|Object
modifier|...
name|nodeOutputs
parameter_list|)
throws|throws
name|SemanticException
block|{
name|Operator
argument_list|<
name|?
argument_list|>
name|op
init|=
operator|(
name|Operator
argument_list|<
name|?
argument_list|>
operator|)
name|nd
decl_stmt|;
name|ConstantPropagateProcCtx
name|cppCtx
init|=
operator|(
name|ConstantPropagateProcCtx
operator|)
name|ctx
decl_stmt|;
name|cppCtx
operator|.
name|getOpToConstantExprs
argument_list|()
operator|.
name|put
argument_list|(
name|op
argument_list|,
operator|new
name|HashMap
argument_list|<
name|ColumnInfo
argument_list|,
name|ExprNodeDesc
argument_list|>
argument_list|()
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Stop propagate constants on op "
operator|+
name|op
operator|.
name|getOperatorId
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
block|}
specifier|public
specifier|static
name|NodeProcessor
name|getStopProc
parameter_list|()
block|{
return|return
operator|new
name|ConstantPropagateStopProc
argument_list|()
return|;
block|}
comment|/**    * The Node Processor for Constant Propagation for ReduceSink Operators. If the RS Operator is for    * a join, then only those constants from inner join tables, or from the 'inner side' of a outer    * join (left table for left outer join and vice versa) can be propagated.    */
specifier|public
specifier|static
class|class
name|ConstantPropagateReduceSinkProc
implements|implements
name|NodeProcessor
block|{
specifier|public
name|Object
name|process
parameter_list|(
name|Node
name|nd
parameter_list|,
name|Stack
argument_list|<
name|Node
argument_list|>
name|stack
parameter_list|,
name|NodeProcessorCtx
name|ctx
parameter_list|,
name|Object
modifier|...
name|nodeOutputs
parameter_list|)
throws|throws
name|SemanticException
block|{
name|ReduceSinkOperator
name|op
init|=
operator|(
name|ReduceSinkOperator
operator|)
name|nd
decl_stmt|;
name|ReduceSinkDesc
name|rsDesc
init|=
name|op
operator|.
name|getConf
argument_list|()
decl_stmt|;
name|ConstantPropagateProcCtx
name|cppCtx
init|=
operator|(
name|ConstantPropagateProcCtx
operator|)
name|ctx
decl_stmt|;
name|Map
argument_list|<
name|ColumnInfo
argument_list|,
name|ExprNodeDesc
argument_list|>
name|constants
init|=
name|cppCtx
operator|.
name|getPropagatedConstants
argument_list|(
name|op
argument_list|)
decl_stmt|;
name|cppCtx
operator|.
name|getOpToConstantExprs
argument_list|()
operator|.
name|put
argument_list|(
name|op
argument_list|,
name|constants
argument_list|)
expr_stmt|;
if|if
condition|(
name|constants
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return
literal|null
return|;
block|}
if|if
condition|(
name|op
operator|.
name|getChildOperators
argument_list|()
operator|.
name|size
argument_list|()
operator|==
literal|1
operator|&&
name|op
operator|.
name|getChildOperators
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|instanceof
name|JoinOperator
condition|)
block|{
name|JoinOperator
name|joinOp
init|=
operator|(
name|JoinOperator
operator|)
name|op
operator|.
name|getChildOperators
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|skipFolding
argument_list|(
name|joinOp
operator|.
name|getConf
argument_list|()
argument_list|,
name|rsDesc
operator|.
name|getTag
argument_list|()
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Skip folding in outer join "
operator|+
name|op
argument_list|)
expr_stmt|;
name|cppCtx
operator|.
name|getOpToConstantExprs
argument_list|()
operator|.
name|put
argument_list|(
name|op
argument_list|,
operator|new
name|HashMap
argument_list|<
name|ColumnInfo
argument_list|,
name|ExprNodeDesc
argument_list|>
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
block|}
if|if
condition|(
name|rsDesc
operator|.
name|getDistinctColumnIndices
argument_list|()
operator|!=
literal|null
operator|&&
operator|!
name|rsDesc
operator|.
name|getDistinctColumnIndices
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Skip folding in distinct subqueries "
operator|+
name|op
argument_list|)
expr_stmt|;
name|cppCtx
operator|.
name|getOpToConstantExprs
argument_list|()
operator|.
name|put
argument_list|(
name|op
argument_list|,
operator|new
name|HashMap
argument_list|<
name|ColumnInfo
argument_list|,
name|ExprNodeDesc
argument_list|>
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
comment|// key columns
name|ArrayList
argument_list|<
name|ExprNodeDesc
argument_list|>
name|newKeyEpxrs
init|=
operator|new
name|ArrayList
argument_list|<
name|ExprNodeDesc
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|ExprNodeDesc
name|desc
range|:
name|rsDesc
operator|.
name|getKeyCols
argument_list|()
control|)
block|{
name|newKeyEpxrs
operator|.
name|add
argument_list|(
name|foldExpr
argument_list|(
name|desc
argument_list|,
name|constants
argument_list|,
name|cppCtx
argument_list|,
name|op
argument_list|,
literal|0
argument_list|,
literal|false
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|rsDesc
operator|.
name|setKeyCols
argument_list|(
name|newKeyEpxrs
argument_list|)
expr_stmt|;
comment|// partition columns
name|ArrayList
argument_list|<
name|ExprNodeDesc
argument_list|>
name|newPartExprs
init|=
operator|new
name|ArrayList
argument_list|<
name|ExprNodeDesc
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|ExprNodeDesc
name|desc
range|:
name|rsDesc
operator|.
name|getPartitionCols
argument_list|()
control|)
block|{
name|ExprNodeDesc
name|expr
init|=
name|foldExpr
argument_list|(
name|desc
argument_list|,
name|constants
argument_list|,
name|cppCtx
argument_list|,
name|op
argument_list|,
literal|0
argument_list|,
literal|false
argument_list|)
decl_stmt|;
if|if
condition|(
name|expr
operator|instanceof
name|ExprNodeConstantDesc
operator|||
name|expr
operator|instanceof
name|ExprNodeNullDesc
condition|)
block|{
continue|continue;
block|}
name|newPartExprs
operator|.
name|add
argument_list|(
name|expr
argument_list|)
expr_stmt|;
block|}
name|rsDesc
operator|.
name|setPartitionCols
argument_list|(
name|newPartExprs
argument_list|)
expr_stmt|;
comment|// value columns
name|ArrayList
argument_list|<
name|ExprNodeDesc
argument_list|>
name|newValExprs
init|=
operator|new
name|ArrayList
argument_list|<
name|ExprNodeDesc
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|ExprNodeDesc
name|desc
range|:
name|rsDesc
operator|.
name|getValueCols
argument_list|()
control|)
block|{
name|newValExprs
operator|.
name|add
argument_list|(
name|foldExpr
argument_list|(
name|desc
argument_list|,
name|constants
argument_list|,
name|cppCtx
argument_list|,
name|op
argument_list|,
literal|0
argument_list|,
literal|false
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|rsDesc
operator|.
name|setValueCols
argument_list|(
name|newValExprs
argument_list|)
expr_stmt|;
name|foldOperator
argument_list|(
name|op
argument_list|,
name|cppCtx
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
specifier|private
name|boolean
name|skipFolding
parameter_list|(
name|JoinDesc
name|joinDesc
parameter_list|,
name|int
name|tag
parameter_list|)
block|{
name|JoinCondDesc
index|[]
name|conds
init|=
name|joinDesc
operator|.
name|getConds
argument_list|()
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|conds
operator|.
name|length
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|conds
index|[
name|i
index|]
operator|.
name|getType
argument_list|()
operator|==
name|JoinDesc
operator|.
name|INNER_JOIN
condition|)
block|{
if|if
condition|(
name|tag
operator|==
name|i
operator|+
literal|1
condition|)
return|return
literal|false
return|;
block|}
elseif|else
if|if
condition|(
name|conds
index|[
name|i
index|]
operator|.
name|getType
argument_list|()
operator|==
name|JoinDesc
operator|.
name|FULL_OUTER_JOIN
condition|)
block|{
return|return
literal|true
return|;
block|}
elseif|else
if|if
condition|(
name|conds
index|[
name|i
index|]
operator|.
name|getType
argument_list|()
operator|==
name|JoinDesc
operator|.
name|RIGHT_OUTER_JOIN
condition|)
block|{
if|if
condition|(
name|tag
operator|==
name|i
operator|+
literal|1
condition|)
return|return
literal|false
return|;
return|return
literal|true
return|;
block|}
elseif|else
if|if
condition|(
name|conds
index|[
name|i
index|]
operator|.
name|getType
argument_list|()
operator|==
name|JoinDesc
operator|.
name|LEFT_OUTER_JOIN
condition|)
block|{
if|if
condition|(
name|tag
operator|==
name|i
operator|+
literal|1
condition|)
return|return
literal|true
return|;
block|}
block|}
if|if
condition|(
name|tag
operator|==
literal|0
condition|)
block|{
return|return
literal|false
return|;
block|}
return|return
literal|true
return|;
block|}
block|}
specifier|public
specifier|static
name|NodeProcessor
name|getReduceSinkProc
parameter_list|()
block|{
return|return
operator|new
name|ConstantPropagateReduceSinkProc
argument_list|()
return|;
block|}
comment|/**    * The Node Processor for Constant Propagation for Join Operators.    */
specifier|public
specifier|static
class|class
name|ConstantPropagateJoinProc
implements|implements
name|NodeProcessor
block|{
specifier|public
name|Object
name|process
parameter_list|(
name|Node
name|nd
parameter_list|,
name|Stack
argument_list|<
name|Node
argument_list|>
name|stack
parameter_list|,
name|NodeProcessorCtx
name|ctx
parameter_list|,
name|Object
modifier|...
name|nodeOutputs
parameter_list|)
throws|throws
name|SemanticException
block|{
name|JoinOperator
name|op
init|=
operator|(
name|JoinOperator
operator|)
name|nd
decl_stmt|;
name|JoinDesc
name|conf
init|=
name|op
operator|.
name|getConf
argument_list|()
decl_stmt|;
name|ConstantPropagateProcCtx
name|cppCtx
init|=
operator|(
name|ConstantPropagateProcCtx
operator|)
name|ctx
decl_stmt|;
name|Map
argument_list|<
name|ColumnInfo
argument_list|,
name|ExprNodeDesc
argument_list|>
name|constants
init|=
name|cppCtx
operator|.
name|getPropagatedConstants
argument_list|(
name|op
argument_list|)
decl_stmt|;
name|cppCtx
operator|.
name|getOpToConstantExprs
argument_list|()
operator|.
name|put
argument_list|(
name|op
argument_list|,
name|constants
argument_list|)
expr_stmt|;
if|if
condition|(
name|constants
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return
literal|null
return|;
block|}
comment|// Note: the following code (removing folded constants in exprs) is deeply coupled with
comment|//    ColumnPruner optimizer.
comment|// Assuming ColumnPrunner will remove constant columns so we don't deal with output columns.
comment|//    Except one case that the join operator is followed by a redistribution (RS operator).
if|if
condition|(
name|op
operator|.
name|getChildOperators
argument_list|()
operator|.
name|size
argument_list|()
operator|==
literal|1
operator|&&
name|op
operator|.
name|getChildOperators
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|instanceof
name|ReduceSinkOperator
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Skip JOIN-RS structure."
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"Old exprs "
operator|+
name|conf
operator|.
name|getExprs
argument_list|()
argument_list|)
expr_stmt|;
name|Iterator
argument_list|<
name|Entry
argument_list|<
name|Byte
argument_list|,
name|List
argument_list|<
name|ExprNodeDesc
argument_list|>
argument_list|>
argument_list|>
name|itr
init|=
name|conf
operator|.
name|getExprs
argument_list|()
operator|.
name|entrySet
argument_list|()
operator|.
name|iterator
argument_list|()
decl_stmt|;
while|while
condition|(
name|itr
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|Entry
argument_list|<
name|Byte
argument_list|,
name|List
argument_list|<
name|ExprNodeDesc
argument_list|>
argument_list|>
name|e
init|=
name|itr
operator|.
name|next
argument_list|()
decl_stmt|;
name|int
name|tag
init|=
name|e
operator|.
name|getKey
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|ExprNodeDesc
argument_list|>
name|exprs
init|=
name|e
operator|.
name|getValue
argument_list|()
decl_stmt|;
if|if
condition|(
name|exprs
operator|==
literal|null
condition|)
block|{
continue|continue;
block|}
name|List
argument_list|<
name|ExprNodeDesc
argument_list|>
name|newExprs
init|=
operator|new
name|ArrayList
argument_list|<
name|ExprNodeDesc
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|ExprNodeDesc
name|expr
range|:
name|exprs
control|)
block|{
name|ExprNodeDesc
name|newExpr
init|=
name|foldExpr
argument_list|(
name|expr
argument_list|,
name|constants
argument_list|,
name|cppCtx
argument_list|,
name|op
argument_list|,
name|tag
argument_list|,
literal|false
argument_list|)
decl_stmt|;
if|if
condition|(
name|newExpr
operator|instanceof
name|ExprNodeConstantDesc
operator|||
name|newExpr
operator|instanceof
name|ExprNodeNullDesc
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"expr "
operator|+
name|newExpr
operator|+
literal|" fold from "
operator|+
name|expr
operator|+
literal|" is removed."
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|newExprs
operator|.
name|add
argument_list|(
name|newExpr
argument_list|)
expr_stmt|;
block|}
name|e
operator|.
name|setValue
argument_list|(
name|newExprs
argument_list|)
expr_stmt|;
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"New exprs "
operator|+
name|conf
operator|.
name|getExprs
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|List
argument_list|<
name|ExprNodeDesc
argument_list|>
name|v
range|:
name|conf
operator|.
name|getFilters
argument_list|()
operator|.
name|values
argument_list|()
control|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|v
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|ExprNodeDesc
name|expr
init|=
name|foldExpr
argument_list|(
name|v
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|,
name|constants
argument_list|,
name|cppCtx
argument_list|,
name|op
argument_list|,
literal|0
argument_list|,
literal|false
argument_list|)
decl_stmt|;
name|v
operator|.
name|set
argument_list|(
name|i
argument_list|,
name|expr
argument_list|)
expr_stmt|;
block|}
block|}
name|foldOperator
argument_list|(
name|op
argument_list|,
name|cppCtx
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
block|}
specifier|public
specifier|static
name|NodeProcessor
name|getJoinProc
parameter_list|()
block|{
return|return
operator|new
name|ConstantPropagateJoinProc
argument_list|()
return|;
block|}
comment|/**    * The Node Processor for Constant Propagation for Table Scan Operators.    */
specifier|public
specifier|static
class|class
name|ConstantPropagateTableScanProc
implements|implements
name|NodeProcessor
block|{
specifier|public
name|Object
name|process
parameter_list|(
name|Node
name|nd
parameter_list|,
name|Stack
argument_list|<
name|Node
argument_list|>
name|stack
parameter_list|,
name|NodeProcessorCtx
name|ctx
parameter_list|,
name|Object
modifier|...
name|nodeOutputs
parameter_list|)
throws|throws
name|SemanticException
block|{
name|TableScanOperator
name|op
init|=
operator|(
name|TableScanOperator
operator|)
name|nd
decl_stmt|;
name|TableScanDesc
name|conf
init|=
name|op
operator|.
name|getConf
argument_list|()
decl_stmt|;
name|ConstantPropagateProcCtx
name|cppCtx
init|=
operator|(
name|ConstantPropagateProcCtx
operator|)
name|ctx
decl_stmt|;
name|Map
argument_list|<
name|ColumnInfo
argument_list|,
name|ExprNodeDesc
argument_list|>
name|constants
init|=
name|cppCtx
operator|.
name|getPropagatedConstants
argument_list|(
name|op
argument_list|)
decl_stmt|;
name|cppCtx
operator|.
name|getOpToConstantExprs
argument_list|()
operator|.
name|put
argument_list|(
name|op
argument_list|,
name|constants
argument_list|)
expr_stmt|;
name|ExprNodeGenericFuncDesc
name|pred
init|=
name|conf
operator|.
name|getFilterExpr
argument_list|()
decl_stmt|;
if|if
condition|(
name|pred
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
name|List
argument_list|<
name|ExprNodeDesc
argument_list|>
name|newChildren
init|=
operator|new
name|ArrayList
argument_list|<
name|ExprNodeDesc
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|ExprNodeDesc
name|expr
range|:
name|pred
operator|.
name|getChildren
argument_list|()
control|)
block|{
name|ExprNodeDesc
name|constant
init|=
name|foldExpr
argument_list|(
name|expr
argument_list|,
name|constants
argument_list|,
name|cppCtx
argument_list|,
name|op
argument_list|,
literal|0
argument_list|,
literal|false
argument_list|)
decl_stmt|;
name|newChildren
operator|.
name|add
argument_list|(
name|constant
argument_list|)
expr_stmt|;
block|}
name|pred
operator|.
name|setChildren
argument_list|(
name|newChildren
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
block|}
specifier|public
specifier|static
name|NodeProcessor
name|getTableScanProc
parameter_list|()
block|{
return|return
operator|new
name|ConstantPropagateTableScanProc
argument_list|()
return|;
block|}
block|}
end_class

end_unit

