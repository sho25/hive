begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|optimizer
operator|.
name|physical
package|;
end_package

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Stack
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|ColumnInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|ExtractOperator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|FileSinkOperator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|ForwardOperator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|GroupByOperator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|JoinOperator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|Operator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|ReduceSinkOperator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|SelectOperator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|lib
operator|.
name|Node
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|lib
operator|.
name|NodeProcessor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|lib
operator|.
name|NodeProcessorCtx
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|lib
operator|.
name|Utils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|optimizer
operator|.
name|physical
operator|.
name|BucketingSortingCtx
operator|.
name|BucketCol
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|optimizer
operator|.
name|physical
operator|.
name|BucketingSortingCtx
operator|.
name|BucketSortCol
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|optimizer
operator|.
name|physical
operator|.
name|BucketingSortingCtx
operator|.
name|SortCol
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|parse
operator|.
name|SemanticException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|ExprNodeColumnDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|ExprNodeDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|ExprNodeDesc
operator|.
name|ExprNodeDescEqualityWrapper
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|OperatorDesc
import|;
end_import

begin_comment
comment|/**  * Operator factory for the rule processors for inferring bucketing/sorting columns.  */
end_comment

begin_class
specifier|public
class|class
name|BucketingSortingOpProcFactory
block|{
specifier|public
specifier|static
class|class
name|DefaultInferrer
implements|implements
name|NodeProcessor
block|{
annotation|@
name|Override
specifier|public
name|Object
name|process
parameter_list|(
name|Node
name|nd
parameter_list|,
name|Stack
argument_list|<
name|Node
argument_list|>
name|stack
parameter_list|,
name|NodeProcessorCtx
name|procCtx
parameter_list|,
name|Object
modifier|...
name|nodeOutputs
parameter_list|)
throws|throws
name|SemanticException
block|{
return|return
literal|null
return|;
block|}
block|}
comment|/**    * Infers bucket/sort columns for operators which simply forward rows from the parent    * E.g. Forward operators and SELECT *    * @param op    * @param bctx    * @param parent    * @throws SemanticException    */
specifier|private
specifier|static
name|void
name|processForward
parameter_list|(
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
name|op
parameter_list|,
name|BucketingSortingCtx
name|bctx
parameter_list|,
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
name|parent
parameter_list|)
throws|throws
name|SemanticException
block|{
name|List
argument_list|<
name|BucketCol
argument_list|>
name|bucketCols
init|=
name|bctx
operator|.
name|getBucketedCols
argument_list|(
name|parent
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|SortCol
argument_list|>
name|sortCols
init|=
name|bctx
operator|.
name|getSortedCols
argument_list|(
name|parent
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|ColumnInfo
argument_list|>
name|colInfos
init|=
name|op
operator|.
name|getSchema
argument_list|()
operator|.
name|getSignature
argument_list|()
decl_stmt|;
if|if
condition|(
name|bucketCols
operator|==
literal|null
operator|&&
name|sortCols
operator|==
literal|null
condition|)
block|{
return|return;
block|}
name|List
argument_list|<
name|BucketCol
argument_list|>
name|newBucketCols
decl_stmt|;
name|List
argument_list|<
name|SortCol
argument_list|>
name|newSortCols
decl_stmt|;
if|if
condition|(
name|bucketCols
operator|==
literal|null
condition|)
block|{
name|newBucketCols
operator|=
literal|null
expr_stmt|;
block|}
else|else
block|{
name|newBucketCols
operator|=
name|getNewBucketCols
argument_list|(
name|bucketCols
argument_list|,
name|colInfos
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sortCols
operator|==
literal|null
condition|)
block|{
name|newSortCols
operator|=
literal|null
expr_stmt|;
block|}
else|else
block|{
name|newSortCols
operator|=
name|getNewSortCols
argument_list|(
name|sortCols
argument_list|,
name|colInfos
argument_list|)
expr_stmt|;
block|}
name|bctx
operator|.
name|setBucketedCols
argument_list|(
name|op
argument_list|,
name|newBucketCols
argument_list|)
expr_stmt|;
name|bctx
operator|.
name|setSortedCols
argument_list|(
name|op
argument_list|,
name|newSortCols
argument_list|)
expr_stmt|;
block|}
comment|/**    * Returns the parent operator in the walk path to the current operator.    *    * @param stack The stack encoding the path.    *    * @return Operator The parent operator in the current path.    */
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
specifier|protected
specifier|static
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
name|getParent
parameter_list|(
name|Stack
argument_list|<
name|Node
argument_list|>
name|stack
parameter_list|)
block|{
return|return
operator|(
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
operator|)
name|Utils
operator|.
name|getNthAncestor
argument_list|(
name|stack
argument_list|,
literal|1
argument_list|)
return|;
block|}
comment|/**    * Processor for Join Operator.    *    * This handles common joins, the tree should look like    * ReducSinkOperator    *                      \    *     ....           ---  JoinOperator    *                      /    * ReduceSink Operator    *    */
specifier|public
specifier|static
class|class
name|JoinInferrer
extends|extends
name|DefaultInferrer
implements|implements
name|NodeProcessor
block|{
annotation|@
name|Override
specifier|public
name|Object
name|process
parameter_list|(
name|Node
name|nd
parameter_list|,
name|Stack
argument_list|<
name|Node
argument_list|>
name|stack
parameter_list|,
name|NodeProcessorCtx
name|procCtx
parameter_list|,
name|Object
modifier|...
name|nodeOutputs
parameter_list|)
throws|throws
name|SemanticException
block|{
name|BucketingSortingCtx
name|bctx
init|=
operator|(
name|BucketingSortingCtx
operator|)
name|procCtx
decl_stmt|;
name|JoinOperator
name|jop
init|=
operator|(
name|JoinOperator
operator|)
name|nd
decl_stmt|;
name|List
argument_list|<
name|ColumnInfo
argument_list|>
name|colInfos
init|=
name|jop
operator|.
name|getSchema
argument_list|()
operator|.
name|getSignature
argument_list|()
decl_stmt|;
name|Byte
index|[]
name|order
init|=
name|jop
operator|.
name|getConf
argument_list|()
operator|.
name|getTagOrder
argument_list|()
decl_stmt|;
name|BucketCol
index|[]
name|newBucketCols
init|=
literal|null
decl_stmt|;
name|SortCol
index|[]
name|newSortCols
init|=
literal|null
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|jop
operator|.
name|getParentOperators
argument_list|()
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
name|parent
init|=
name|jop
operator|.
name|getParentOperators
argument_list|()
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
comment|// The caller of this method should guarantee this
assert|assert
operator|(
name|parent
operator|instanceof
name|ReduceSinkOperator
operator|)
assert|;
name|ReduceSinkOperator
name|rop
init|=
operator|(
name|ReduceSinkOperator
operator|)
name|jop
operator|.
name|getParentOperators
argument_list|()
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|String
name|sortOrder
init|=
name|rop
operator|.
name|getConf
argument_list|()
operator|.
name|getOrder
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|BucketCol
argument_list|>
name|bucketCols
init|=
operator|new
name|ArrayList
argument_list|<
name|BucketCol
argument_list|>
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|SortCol
argument_list|>
name|sortCols
init|=
operator|new
name|ArrayList
argument_list|<
name|SortCol
argument_list|>
argument_list|()
decl_stmt|;
comment|// Go through the Reduce keys and find the matching column(s) in the reduce values
for|for
control|(
name|int
name|keyIndex
init|=
literal|0
init|;
name|keyIndex
operator|<
name|rop
operator|.
name|getConf
argument_list|()
operator|.
name|getKeyCols
argument_list|()
operator|.
name|size
argument_list|()
condition|;
name|keyIndex
operator|++
control|)
block|{
for|for
control|(
name|int
name|valueIndex
init|=
literal|0
init|;
name|valueIndex
operator|<
name|rop
operator|.
name|getConf
argument_list|()
operator|.
name|getValueCols
argument_list|()
operator|.
name|size
argument_list|()
condition|;
name|valueIndex
operator|++
control|)
block|{
if|if
condition|(
operator|new
name|ExprNodeDescEqualityWrapper
argument_list|(
name|rop
operator|.
name|getConf
argument_list|()
operator|.
name|getValueCols
argument_list|()
operator|.
name|get
argument_list|(
name|valueIndex
argument_list|)
argument_list|)
operator|.
name|equals
argument_list|(
operator|new
name|ExprNodeDescEqualityWrapper
argument_list|(
name|rop
operator|.
name|getConf
argument_list|()
operator|.
name|getKeyCols
argument_list|()
operator|.
name|get
argument_list|(
name|keyIndex
argument_list|)
argument_list|)
argument_list|)
condition|)
block|{
name|String
name|colName
init|=
name|rop
operator|.
name|getSchema
argument_list|()
operator|.
name|getSignature
argument_list|()
operator|.
name|get
argument_list|(
name|valueIndex
argument_list|)
operator|.
name|getInternalName
argument_list|()
decl_stmt|;
name|bucketCols
operator|.
name|add
argument_list|(
operator|new
name|BucketCol
argument_list|(
name|colName
argument_list|,
name|keyIndex
argument_list|)
argument_list|)
expr_stmt|;
name|sortCols
operator|.
name|add
argument_list|(
operator|new
name|SortCol
argument_list|(
name|colName
argument_list|,
name|keyIndex
argument_list|,
name|sortOrder
operator|.
name|charAt
argument_list|(
name|keyIndex
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
if|if
condition|(
name|bucketCols
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
assert|assert
operator|(
name|sortCols
operator|.
name|isEmpty
argument_list|()
operator|)
assert|;
continue|continue;
block|}
if|if
condition|(
name|newBucketCols
operator|==
literal|null
condition|)
block|{
assert|assert
operator|(
name|newSortCols
operator|==
literal|null
operator|)
assert|;
comment|// The number of join keys is equal to the number of keys in every reducer, although
comment|// not every key may map to a value in the reducer
name|newBucketCols
operator|=
operator|new
name|BucketCol
index|[
name|rop
operator|.
name|getConf
argument_list|()
operator|.
name|getKeyCols
argument_list|()
operator|.
name|size
argument_list|()
index|]
expr_stmt|;
name|newSortCols
operator|=
operator|new
name|SortCol
index|[
name|rop
operator|.
name|getConf
argument_list|()
operator|.
name|getKeyCols
argument_list|()
operator|.
name|size
argument_list|()
index|]
expr_stmt|;
block|}
else|else
block|{
assert|assert
operator|(
name|newSortCols
operator|!=
literal|null
operator|)
assert|;
block|}
name|byte
name|tag
init|=
operator|(
name|byte
operator|)
name|rop
operator|.
name|getConf
argument_list|()
operator|.
name|getTag
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|ExprNodeDesc
argument_list|>
name|exprs
init|=
name|jop
operator|.
name|getConf
argument_list|()
operator|.
name|getExprs
argument_list|()
operator|.
name|get
argument_list|(
name|tag
argument_list|)
decl_stmt|;
name|int
name|colInfosOffset
init|=
literal|0
decl_stmt|;
name|int
name|orderValue
init|=
name|order
index|[
name|tag
index|]
decl_stmt|;
comment|// Columns are output from the join from the different reduce sinks in the order of their
comment|// offsets
for|for
control|(
name|byte
name|orderIndex
init|=
literal|0
init|;
name|orderIndex
operator|<
name|order
operator|.
name|length
condition|;
name|orderIndex
operator|++
control|)
block|{
if|if
condition|(
name|order
index|[
name|orderIndex
index|]
operator|<
name|orderValue
condition|)
block|{
name|colInfosOffset
operator|+=
name|jop
operator|.
name|getConf
argument_list|()
operator|.
name|getExprs
argument_list|()
operator|.
name|get
argument_list|(
name|orderIndex
argument_list|)
operator|.
name|size
argument_list|()
expr_stmt|;
block|}
block|}
name|findBucketingSortingColumns
argument_list|(
name|exprs
argument_list|,
name|colInfos
argument_list|,
name|bucketCols
argument_list|,
name|sortCols
argument_list|,
name|newBucketCols
argument_list|,
name|newSortCols
argument_list|,
name|colInfosOffset
argument_list|)
expr_stmt|;
block|}
name|setBucketingColsIfComplete
argument_list|(
name|bctx
argument_list|,
name|jop
argument_list|,
name|newBucketCols
argument_list|)
expr_stmt|;
name|setSortingColsIfComplete
argument_list|(
name|bctx
argument_list|,
name|jop
argument_list|,
name|newSortCols
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
block|}
comment|/**    * If the list of output bucket columns has been populated and every column has at least    * one representative in the output they can be inferred    *    * @param bctx - BucketingSortingCtx containing inferred columns    * @param op - The operator we are inferring information about the output of    * @param newBucketCols - An array of columns on which the output is bucketed, e.g. as output by    *                        the method findBucketingSortingColumns    */
specifier|private
specifier|static
name|void
name|setBucketingColsIfComplete
parameter_list|(
name|BucketingSortingCtx
name|bctx
parameter_list|,
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
name|op
parameter_list|,
name|BucketCol
index|[]
name|newBucketCols
parameter_list|)
block|{
if|if
condition|(
name|newBucketCols
operator|!=
literal|null
condition|)
block|{
name|List
argument_list|<
name|BucketCol
argument_list|>
name|newBucketColList
init|=
name|Arrays
operator|.
name|asList
argument_list|(
name|newBucketCols
argument_list|)
decl_stmt|;
comment|// If newBucketColList had a null value it means that at least one of the input bucket
comment|// columns did not have a representative found in the output columns, so assume the data
comment|// is no longer bucketed
if|if
condition|(
operator|!
name|newBucketColList
operator|.
name|contains
argument_list|(
literal|null
argument_list|)
condition|)
block|{
name|bctx
operator|.
name|setBucketedCols
argument_list|(
name|op
argument_list|,
name|newBucketColList
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**    * If the list of output sort columns has been populated and every column has at least    * one representative in the output they can be inferred    *    * @param bctx - BucketingSortingCtx containing inferred columns    * @param op - The operator we are inferring information about the output of    * @param newSortCols - An array of columns on which the output is sorted, e.g. as output by    *                        the method findBucketingSortingColumns    */
specifier|private
specifier|static
name|void
name|setSortingColsIfComplete
parameter_list|(
name|BucketingSortingCtx
name|bctx
parameter_list|,
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
name|op
parameter_list|,
name|SortCol
index|[]
name|newSortCols
parameter_list|)
block|{
if|if
condition|(
name|newSortCols
operator|!=
literal|null
condition|)
block|{
name|List
argument_list|<
name|SortCol
argument_list|>
name|newSortColList
init|=
name|Arrays
operator|.
name|asList
argument_list|(
name|newSortCols
argument_list|)
decl_stmt|;
comment|// If newSortColList had a null value it means that at least one of the input sort
comment|// columns did not have a representative found in the output columns, so assume the data
comment|// is no longer sorted
if|if
condition|(
operator|!
name|newSortColList
operator|.
name|contains
argument_list|(
literal|null
argument_list|)
condition|)
block|{
name|bctx
operator|.
name|setSortedCols
argument_list|(
name|op
argument_list|,
name|newSortColList
argument_list|)
expr_stmt|;
block|}
block|}
block|}
specifier|private
specifier|static
name|void
name|findBucketingSortingColumns
parameter_list|(
name|List
argument_list|<
name|ExprNodeDesc
argument_list|>
name|exprs
parameter_list|,
name|List
argument_list|<
name|ColumnInfo
argument_list|>
name|colInfos
parameter_list|,
name|List
argument_list|<
name|BucketCol
argument_list|>
name|bucketCols
parameter_list|,
name|List
argument_list|<
name|SortCol
argument_list|>
name|sortCols
parameter_list|,
name|BucketCol
index|[]
name|newBucketCols
parameter_list|,
name|SortCol
index|[]
name|newSortCols
parameter_list|)
block|{
name|findBucketingSortingColumns
argument_list|(
name|exprs
argument_list|,
name|colInfos
argument_list|,
name|bucketCols
argument_list|,
name|sortCols
argument_list|,
name|newBucketCols
argument_list|,
name|newSortCols
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/**    * For each expression, check if it represents a column known to be bucketed/sorted.    *    * The methods setBucketingColsIfComplete and setSortingColsIfComplete should be used to assign    * the values of newBucketCols and newSortCols as the bucketing/sorting columns of this operator    * because these arrays may contain nulls indicating that the output of this operator is not    * bucketed/sorted.    *    * @param exprs - list of expression    * @param colInfos - list of column infos    * @param bucketCols - list of bucketed columns from the input    * @param sortCols - list of sorted columns from the input    * @param newBucketCols - an array of bucket columns which should be the same length as    *    bucketCols, updated such that the bucketed column(s) at index i in bucketCols became    *    the bucketed column(s) at index i of newBucketCols in the output    * @param newSortCols - an array of sort columns which should be the same length as    *    sortCols, updated such that the sorted column(s) at index i in sortCols became    *    the sorted column(s) at index i of sortCols in the output    * @param colInfosOffset - the expressions are known to be represented by column infos    *    beginning at this index    */
specifier|private
specifier|static
name|void
name|findBucketingSortingColumns
parameter_list|(
name|List
argument_list|<
name|ExprNodeDesc
argument_list|>
name|exprs
parameter_list|,
name|List
argument_list|<
name|ColumnInfo
argument_list|>
name|colInfos
parameter_list|,
name|List
argument_list|<
name|BucketCol
argument_list|>
name|bucketCols
parameter_list|,
name|List
argument_list|<
name|SortCol
argument_list|>
name|sortCols
parameter_list|,
name|BucketCol
index|[]
name|newBucketCols
parameter_list|,
name|SortCol
index|[]
name|newSortCols
parameter_list|,
name|int
name|colInfosOffset
parameter_list|)
block|{
for|for
control|(
name|int
name|cnt
init|=
literal|0
init|;
name|cnt
operator|<
name|exprs
operator|.
name|size
argument_list|()
condition|;
name|cnt
operator|++
control|)
block|{
name|ExprNodeDesc
name|expr
init|=
name|exprs
operator|.
name|get
argument_list|(
name|cnt
argument_list|)
decl_stmt|;
comment|// Only columns can be sorted/bucketed, in particular applying a function to a column
comment|// voids any assumptions
if|if
condition|(
operator|!
operator|(
name|expr
operator|instanceof
name|ExprNodeColumnDesc
operator|)
condition|)
block|{
continue|continue;
block|}
name|ExprNodeColumnDesc
name|columnExpr
init|=
operator|(
name|ExprNodeColumnDesc
operator|)
name|expr
decl_stmt|;
name|int
name|colInfosIndex
init|=
name|cnt
operator|+
name|colInfosOffset
decl_stmt|;
if|if
condition|(
name|newBucketCols
operator|!=
literal|null
condition|)
block|{
name|int
name|bucketIndex
init|=
name|indexOfColName
argument_list|(
name|bucketCols
argument_list|,
name|columnExpr
operator|.
name|getColumn
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|bucketIndex
operator|!=
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|newBucketCols
index|[
name|bucketIndex
index|]
operator|==
literal|null
condition|)
block|{
name|newBucketCols
index|[
name|bucketIndex
index|]
operator|=
operator|new
name|BucketCol
argument_list|()
expr_stmt|;
block|}
name|newBucketCols
index|[
name|bucketIndex
index|]
operator|.
name|addAlias
argument_list|(
name|colInfos
operator|.
name|get
argument_list|(
name|colInfosIndex
argument_list|)
operator|.
name|getInternalName
argument_list|()
argument_list|,
name|colInfosIndex
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|newSortCols
operator|!=
literal|null
condition|)
block|{
name|int
name|sortIndex
init|=
name|indexOfColName
argument_list|(
name|sortCols
argument_list|,
name|columnExpr
operator|.
name|getColumn
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|sortIndex
operator|!=
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|newSortCols
index|[
name|sortIndex
index|]
operator|==
literal|null
condition|)
block|{
name|newSortCols
index|[
name|sortIndex
index|]
operator|=
operator|new
name|SortCol
argument_list|(
name|sortCols
operator|.
name|get
argument_list|(
name|sortIndex
argument_list|)
operator|.
name|getSortOrder
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|newSortCols
index|[
name|sortIndex
index|]
operator|.
name|addAlias
argument_list|(
name|colInfos
operator|.
name|get
argument_list|(
name|colInfosIndex
argument_list|)
operator|.
name|getInternalName
argument_list|()
argument_list|,
name|colInfosIndex
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/**    * Processor for Select operator.    */
specifier|public
specifier|static
class|class
name|SelectInferrer
extends|extends
name|DefaultInferrer
implements|implements
name|NodeProcessor
block|{
annotation|@
name|Override
specifier|public
name|Object
name|process
parameter_list|(
name|Node
name|nd
parameter_list|,
name|Stack
argument_list|<
name|Node
argument_list|>
name|stack
parameter_list|,
name|NodeProcessorCtx
name|procCtx
parameter_list|,
name|Object
modifier|...
name|nodeOutputs
parameter_list|)
throws|throws
name|SemanticException
block|{
name|BucketingSortingCtx
name|bctx
init|=
operator|(
name|BucketingSortingCtx
operator|)
name|procCtx
decl_stmt|;
name|SelectOperator
name|sop
init|=
operator|(
name|SelectOperator
operator|)
name|nd
decl_stmt|;
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
name|parent
init|=
name|getParent
argument_list|(
name|stack
argument_list|)
decl_stmt|;
comment|// if this is a selStarNoCompute then this select operator
comment|// is treated like a default operator, so just call the super classes
comment|// process method.
if|if
condition|(
name|sop
operator|.
name|getConf
argument_list|()
operator|.
name|isSelStarNoCompute
argument_list|()
condition|)
block|{
name|processForward
argument_list|(
name|sop
argument_list|,
name|bctx
argument_list|,
name|parent
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
name|List
argument_list|<
name|BucketCol
argument_list|>
name|bucketCols
init|=
name|bctx
operator|.
name|getBucketedCols
argument_list|(
name|parent
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|SortCol
argument_list|>
name|sortCols
init|=
name|bctx
operator|.
name|getSortedCols
argument_list|(
name|parent
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|ColumnInfo
argument_list|>
name|colInfos
init|=
name|sop
operator|.
name|getSchema
argument_list|()
operator|.
name|getSignature
argument_list|()
decl_stmt|;
if|if
condition|(
name|bucketCols
operator|==
literal|null
operator|&&
name|sortCols
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
name|BucketCol
index|[]
name|newBucketCols
init|=
literal|null
decl_stmt|;
name|SortCol
index|[]
name|newSortCols
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|bucketCols
operator|!=
literal|null
condition|)
block|{
name|newBucketCols
operator|=
operator|new
name|BucketCol
index|[
name|bucketCols
operator|.
name|size
argument_list|()
index|]
expr_stmt|;
block|}
if|if
condition|(
name|sortCols
operator|!=
literal|null
condition|)
block|{
name|newSortCols
operator|=
operator|new
name|SortCol
index|[
name|sortCols
operator|.
name|size
argument_list|()
index|]
expr_stmt|;
block|}
name|findBucketingSortingColumns
argument_list|(
name|sop
operator|.
name|getConf
argument_list|()
operator|.
name|getColList
argument_list|()
argument_list|,
name|colInfos
argument_list|,
name|bucketCols
argument_list|,
name|sortCols
argument_list|,
name|newBucketCols
argument_list|,
name|newSortCols
argument_list|)
expr_stmt|;
name|setBucketingColsIfComplete
argument_list|(
name|bctx
argument_list|,
name|sop
argument_list|,
name|newBucketCols
argument_list|)
expr_stmt|;
name|setSortingColsIfComplete
argument_list|(
name|bctx
argument_list|,
name|sop
argument_list|,
name|newSortCols
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
block|}
comment|/**    * Find the BucketSortCol which has colName as one of its aliases.  Returns the index of that    * BucketSortCol, or -1 if none exist    * @param bucketSortCols    * @param colName    * @return    */
specifier|private
specifier|static
name|int
name|indexOfColName
parameter_list|(
name|List
argument_list|<
name|?
extends|extends
name|BucketSortCol
argument_list|>
name|bucketSortCols
parameter_list|,
name|String
name|colName
parameter_list|)
block|{
for|for
control|(
name|int
name|index
init|=
literal|0
init|;
name|index
operator|<
name|bucketSortCols
operator|.
name|size
argument_list|()
condition|;
name|index
operator|++
control|)
block|{
name|BucketSortCol
name|bucketSortCol
init|=
name|bucketSortCols
operator|.
name|get
argument_list|(
name|index
argument_list|)
decl_stmt|;
if|if
condition|(
name|bucketSortCol
operator|.
name|getNames
argument_list|()
operator|.
name|indexOf
argument_list|(
name|colName
argument_list|)
operator|!=
operator|-
literal|1
condition|)
block|{
return|return
name|index
return|;
block|}
block|}
return|return
operator|-
literal|1
return|;
block|}
comment|/**    * This is used to construct new lists of bucketed columns where the order of the columns    * hasn't changed, only possibly the name    * @param bucketCols - input bucketed columns    * @param colInfos - List of column infos    * @return output bucketed columns    */
specifier|private
specifier|static
name|List
argument_list|<
name|BucketCol
argument_list|>
name|getNewBucketCols
parameter_list|(
name|List
argument_list|<
name|BucketCol
argument_list|>
name|bucketCols
parameter_list|,
name|List
argument_list|<
name|ColumnInfo
argument_list|>
name|colInfos
parameter_list|)
block|{
name|List
argument_list|<
name|BucketCol
argument_list|>
name|newBucketCols
init|=
operator|new
name|ArrayList
argument_list|<
name|BucketCol
argument_list|>
argument_list|(
name|bucketCols
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|bucketCols
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|BucketCol
name|bucketCol
init|=
operator|new
name|BucketCol
argument_list|()
decl_stmt|;
for|for
control|(
name|Integer
name|index
range|:
name|bucketCols
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|getIndexes
argument_list|()
control|)
block|{
comment|// The only time this condition should be false is in the case of dynamic partitioning
comment|// where the data is bucketed on a dynamic partitioning column and the FileSinkOperator is
comment|// being processed.  In this case, the dynamic partition column will not appear in
comment|// colInfos, and due to the limitations of dynamic partitioning, they will appear at the
comment|// end of the input schema.  Since the order of the columns hasn't changed, and no new
comment|// columns have been added/removed, it is safe to assume that these will have indexes
comment|// greater than or equal to colInfos.size().
if|if
condition|(
name|index
operator|<
name|colInfos
operator|.
name|size
argument_list|()
condition|)
block|{
name|bucketCol
operator|.
name|addAlias
argument_list|(
name|colInfos
operator|.
name|get
argument_list|(
name|index
argument_list|)
operator|.
name|getInternalName
argument_list|()
argument_list|,
name|index
argument_list|)
expr_stmt|;
block|}
else|else
block|{
return|return
literal|null
return|;
block|}
block|}
name|newBucketCols
operator|.
name|add
argument_list|(
name|bucketCol
argument_list|)
expr_stmt|;
block|}
return|return
name|newBucketCols
return|;
block|}
comment|/**    * This is used to construct new lists of sorted columns where the order of the columns    * hasn't changed, only possibly the name    * @param bucketCols - input sorted columns    * @param colInfos - List of column infos    * @return output sorted columns    */
specifier|private
specifier|static
name|List
argument_list|<
name|SortCol
argument_list|>
name|getNewSortCols
parameter_list|(
name|List
argument_list|<
name|SortCol
argument_list|>
name|sortCols
parameter_list|,
name|List
argument_list|<
name|ColumnInfo
argument_list|>
name|colInfos
parameter_list|)
block|{
name|List
argument_list|<
name|SortCol
argument_list|>
name|newSortCols
init|=
operator|new
name|ArrayList
argument_list|<
name|SortCol
argument_list|>
argument_list|(
name|sortCols
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|sortCols
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|SortCol
name|sortCol
init|=
operator|new
name|SortCol
argument_list|(
name|sortCols
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|getSortOrder
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|Integer
name|index
range|:
name|sortCols
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|getIndexes
argument_list|()
control|)
block|{
comment|// The only time this condition should be false is in the case of dynamic partitioning
if|if
condition|(
name|index
operator|<
name|colInfos
operator|.
name|size
argument_list|()
condition|)
block|{
name|sortCol
operator|.
name|addAlias
argument_list|(
name|colInfos
operator|.
name|get
argument_list|(
name|index
argument_list|)
operator|.
name|getInternalName
argument_list|()
argument_list|,
name|index
argument_list|)
expr_stmt|;
block|}
else|else
block|{
return|return
literal|null
return|;
block|}
block|}
name|newSortCols
operator|.
name|add
argument_list|(
name|sortCol
argument_list|)
expr_stmt|;
block|}
return|return
name|newSortCols
return|;
block|}
comment|/**    * Processor for FileSink operator.    */
specifier|public
specifier|static
class|class
name|FileSinkInferrer
extends|extends
name|DefaultInferrer
implements|implements
name|NodeProcessor
block|{
annotation|@
name|Override
specifier|public
name|Object
name|process
parameter_list|(
name|Node
name|nd
parameter_list|,
name|Stack
argument_list|<
name|Node
argument_list|>
name|stack
parameter_list|,
name|NodeProcessorCtx
name|procCtx
parameter_list|,
name|Object
modifier|...
name|nodeOutputs
parameter_list|)
throws|throws
name|SemanticException
block|{
name|BucketingSortingCtx
name|bctx
init|=
operator|(
name|BucketingSortingCtx
operator|)
name|procCtx
decl_stmt|;
name|FileSinkOperator
name|fop
init|=
operator|(
name|FileSinkOperator
operator|)
name|nd
decl_stmt|;
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
name|parent
init|=
name|getParent
argument_list|(
name|stack
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|BucketCol
argument_list|>
name|bucketCols
init|=
name|bctx
operator|.
name|getBucketedCols
argument_list|(
name|parent
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|ColumnInfo
argument_list|>
name|colInfos
init|=
name|fop
operator|.
name|getSchema
argument_list|()
operator|.
name|getSignature
argument_list|()
decl_stmt|;
comment|// Set the inferred bucket columns for the file this FileSink produces
if|if
condition|(
name|bucketCols
operator|!=
literal|null
condition|)
block|{
name|List
argument_list|<
name|BucketCol
argument_list|>
name|newBucketCols
init|=
name|getNewBucketCols
argument_list|(
name|bucketCols
argument_list|,
name|colInfos
argument_list|)
decl_stmt|;
name|bctx
operator|.
name|getBucketedColsByDirectory
argument_list|()
operator|.
name|put
argument_list|(
name|fop
operator|.
name|getConf
argument_list|()
operator|.
name|getDirName
argument_list|()
argument_list|,
name|newBucketCols
argument_list|)
expr_stmt|;
name|bctx
operator|.
name|setBucketedCols
argument_list|(
name|fop
argument_list|,
name|newBucketCols
argument_list|)
expr_stmt|;
block|}
name|List
argument_list|<
name|SortCol
argument_list|>
name|sortCols
init|=
name|bctx
operator|.
name|getSortedCols
argument_list|(
name|parent
argument_list|)
decl_stmt|;
comment|// Set the inferred sort columns for the file this FileSink produces
if|if
condition|(
name|sortCols
operator|!=
literal|null
condition|)
block|{
name|List
argument_list|<
name|SortCol
argument_list|>
name|newSortCols
init|=
name|getNewSortCols
argument_list|(
name|sortCols
argument_list|,
name|colInfos
argument_list|)
decl_stmt|;
name|bctx
operator|.
name|getSortedColsByDirectory
argument_list|()
operator|.
name|put
argument_list|(
name|fop
operator|.
name|getConf
argument_list|()
operator|.
name|getDirName
argument_list|()
argument_list|,
name|newSortCols
argument_list|)
expr_stmt|;
name|bctx
operator|.
name|setSortedCols
argument_list|(
name|fop
argument_list|,
name|newSortCols
argument_list|)
expr_stmt|;
block|}
return|return
literal|null
return|;
block|}
block|}
comment|/**    * Processor for Extract operator.    *    * Only handles the case where the tree looks like    *    * ReduceSinkOperator --- ExtractOperator    *    * This is the case for distribute by, sort by, order by, cluster by operators.    */
specifier|public
specifier|static
class|class
name|ExtractInferrer
extends|extends
name|DefaultInferrer
implements|implements
name|NodeProcessor
block|{
annotation|@
name|Override
specifier|public
name|Object
name|process
parameter_list|(
name|Node
name|nd
parameter_list|,
name|Stack
argument_list|<
name|Node
argument_list|>
name|stack
parameter_list|,
name|NodeProcessorCtx
name|procCtx
parameter_list|,
name|Object
modifier|...
name|nodeOutputs
parameter_list|)
throws|throws
name|SemanticException
block|{
name|BucketingSortingCtx
name|bctx
init|=
operator|(
name|BucketingSortingCtx
operator|)
name|procCtx
decl_stmt|;
name|ExtractOperator
name|exop
init|=
operator|(
name|ExtractOperator
operator|)
name|nd
decl_stmt|;
comment|// As of writing this, there is no case where this could be false, this is just protection
comment|// from possible future changes
if|if
condition|(
name|exop
operator|.
name|getParentOperators
argument_list|()
operator|.
name|size
argument_list|()
operator|!=
literal|1
condition|)
block|{
return|return
literal|null
return|;
block|}
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
name|parent
init|=
name|exop
operator|.
name|getParentOperators
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
comment|// The caller of this method should guarantee this
assert|assert
operator|(
name|parent
operator|instanceof
name|ReduceSinkOperator
operator|)
assert|;
name|ReduceSinkOperator
name|rop
init|=
operator|(
name|ReduceSinkOperator
operator|)
name|parent
decl_stmt|;
comment|// Go through the set of partition columns, and find their representatives in the values
comment|// These represent the bucketed columns
name|List
argument_list|<
name|BucketCol
argument_list|>
name|bucketCols
init|=
operator|new
name|ArrayList
argument_list|<
name|BucketCol
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|rop
operator|.
name|getConf
argument_list|()
operator|.
name|getPartitionCols
argument_list|()
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|boolean
name|valueColFound
init|=
literal|false
decl_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|rop
operator|.
name|getConf
argument_list|()
operator|.
name|getValueCols
argument_list|()
operator|.
name|size
argument_list|()
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
operator|new
name|ExprNodeDescEqualityWrapper
argument_list|(
name|rop
operator|.
name|getConf
argument_list|()
operator|.
name|getValueCols
argument_list|()
operator|.
name|get
argument_list|(
name|j
argument_list|)
argument_list|)
operator|.
name|equals
argument_list|(
operator|new
name|ExprNodeDescEqualityWrapper
argument_list|(
name|rop
operator|.
name|getConf
argument_list|()
operator|.
name|getPartitionCols
argument_list|()
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|)
argument_list|)
condition|)
block|{
name|bucketCols
operator|.
name|add
argument_list|(
operator|new
name|BucketCol
argument_list|(
name|rop
operator|.
name|getSchema
argument_list|()
operator|.
name|getSignature
argument_list|()
operator|.
name|get
argument_list|(
name|j
argument_list|)
operator|.
name|getInternalName
argument_list|()
argument_list|,
name|j
argument_list|)
argument_list|)
expr_stmt|;
name|valueColFound
operator|=
literal|true
expr_stmt|;
break|break;
block|}
block|}
comment|// If the partition columns can't all be found in the values then the data is not bucketed
if|if
condition|(
operator|!
name|valueColFound
condition|)
block|{
name|bucketCols
operator|.
name|clear
argument_list|()
expr_stmt|;
break|break;
block|}
block|}
comment|// Go through the set of key columns, and find their representatives in the values
comment|// These represent the sorted columns
name|String
name|sortOrder
init|=
name|rop
operator|.
name|getConf
argument_list|()
operator|.
name|getOrder
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|SortCol
argument_list|>
name|sortCols
init|=
operator|new
name|ArrayList
argument_list|<
name|SortCol
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|rop
operator|.
name|getConf
argument_list|()
operator|.
name|getKeyCols
argument_list|()
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|boolean
name|valueColFound
init|=
literal|false
decl_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|rop
operator|.
name|getConf
argument_list|()
operator|.
name|getValueCols
argument_list|()
operator|.
name|size
argument_list|()
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
operator|new
name|ExprNodeDescEqualityWrapper
argument_list|(
name|rop
operator|.
name|getConf
argument_list|()
operator|.
name|getValueCols
argument_list|()
operator|.
name|get
argument_list|(
name|j
argument_list|)
argument_list|)
operator|.
name|equals
argument_list|(
operator|new
name|ExprNodeDescEqualityWrapper
argument_list|(
name|rop
operator|.
name|getConf
argument_list|()
operator|.
name|getKeyCols
argument_list|()
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|)
argument_list|)
condition|)
block|{
name|sortCols
operator|.
name|add
argument_list|(
operator|new
name|SortCol
argument_list|(
name|rop
operator|.
name|getSchema
argument_list|()
operator|.
name|getSignature
argument_list|()
operator|.
name|get
argument_list|(
name|j
argument_list|)
operator|.
name|getInternalName
argument_list|()
argument_list|,
name|j
argument_list|,
name|sortOrder
operator|.
name|charAt
argument_list|(
name|i
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|valueColFound
operator|=
literal|true
expr_stmt|;
break|break;
block|}
block|}
comment|// If the sorted columns can't all be found in the values then the data is only sorted on
comment|// the columns seen up until now
if|if
condition|(
operator|!
name|valueColFound
condition|)
block|{
break|break;
block|}
block|}
name|List
argument_list|<
name|ColumnInfo
argument_list|>
name|colInfos
init|=
name|exop
operator|.
name|getSchema
argument_list|()
operator|.
name|getSignature
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|bucketCols
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|List
argument_list|<
name|BucketCol
argument_list|>
name|newBucketCols
init|=
name|getNewBucketCols
argument_list|(
name|bucketCols
argument_list|,
name|colInfos
argument_list|)
decl_stmt|;
name|bctx
operator|.
name|setBucketedCols
argument_list|(
name|exop
argument_list|,
name|newBucketCols
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|sortCols
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|List
argument_list|<
name|SortCol
argument_list|>
name|newSortCols
init|=
name|getNewSortCols
argument_list|(
name|sortCols
argument_list|,
name|colInfos
argument_list|)
decl_stmt|;
name|bctx
operator|.
name|setSortedCols
argument_list|(
name|exop
argument_list|,
name|newSortCols
argument_list|)
expr_stmt|;
block|}
return|return
literal|null
return|;
block|}
block|}
comment|/**    * Processor for GroupByOperator, the special case where it follows a ForwardOperator    *    * There is a multi group by optimization which puts multiple group by operators in a    * reducer when they share the same keys and are part of a multi insert query.    *    * In this case the tree should look like    *                                           Group By Operator    *                                         /    *    ReduceSinkOperator - ForwardOperator ---     ...    *                                         \    *                                           GroupByOperator    *    */
specifier|public
specifier|static
class|class
name|MultiGroupByInferrer
extends|extends
name|GroupByInferrer
implements|implements
name|NodeProcessor
block|{
annotation|@
name|Override
specifier|public
name|Object
name|process
parameter_list|(
name|Node
name|nd
parameter_list|,
name|Stack
argument_list|<
name|Node
argument_list|>
name|stack
parameter_list|,
name|NodeProcessorCtx
name|procCtx
parameter_list|,
name|Object
modifier|...
name|nodeOutputs
parameter_list|)
throws|throws
name|SemanticException
block|{
name|BucketingSortingCtx
name|bctx
init|=
operator|(
name|BucketingSortingCtx
operator|)
name|procCtx
decl_stmt|;
name|GroupByOperator
name|gop
init|=
operator|(
name|GroupByOperator
operator|)
name|nd
decl_stmt|;
if|if
condition|(
name|gop
operator|.
name|getParentOperators
argument_list|()
operator|.
name|size
argument_list|()
operator|!=
literal|1
condition|)
block|{
return|return
literal|null
return|;
block|}
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
name|fop
init|=
name|gop
operator|.
name|getParentOperators
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
comment|// The caller of this method should guarantee this
assert|assert
operator|(
name|fop
operator|instanceof
name|ForwardOperator
operator|)
assert|;
if|if
condition|(
name|fop
operator|.
name|getParentOperators
argument_list|()
operator|.
name|size
argument_list|()
operator|!=
literal|1
condition|)
block|{
return|return
literal|null
return|;
block|}
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
name|rop
init|=
name|fop
operator|.
name|getParentOperators
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
comment|// The caller of this method should guarantee this
assert|assert
operator|(
name|rop
operator|instanceof
name|ReduceSinkOperator
operator|)
assert|;
name|processGroupByReduceSink
argument_list|(
operator|(
name|ReduceSinkOperator
operator|)
name|rop
argument_list|,
name|gop
argument_list|,
name|bctx
argument_list|)
expr_stmt|;
name|processForward
argument_list|(
name|fop
argument_list|,
name|bctx
argument_list|,
name|rop
argument_list|)
expr_stmt|;
return|return
name|processGroupBy
argument_list|(
name|fop
argument_list|,
name|gop
argument_list|,
name|bctx
argument_list|)
return|;
block|}
block|}
comment|/**    * Processor for GroupBy operator.    *    * This handles the standard use of a group by operator, the tree should look like    *    *    ReduceSinkOperator --- GroupByOperator    *    * It is up to the caller to guarantee the tree matches this pattern.    */
specifier|public
specifier|static
class|class
name|GroupByInferrer
extends|extends
name|DefaultInferrer
implements|implements
name|NodeProcessor
block|{
annotation|@
name|Override
specifier|public
name|Object
name|process
parameter_list|(
name|Node
name|nd
parameter_list|,
name|Stack
argument_list|<
name|Node
argument_list|>
name|stack
parameter_list|,
name|NodeProcessorCtx
name|procCtx
parameter_list|,
name|Object
modifier|...
name|nodeOutputs
parameter_list|)
throws|throws
name|SemanticException
block|{
name|BucketingSortingCtx
name|bctx
init|=
operator|(
name|BucketingSortingCtx
operator|)
name|procCtx
decl_stmt|;
name|GroupByOperator
name|gop
init|=
operator|(
name|GroupByOperator
operator|)
name|nd
decl_stmt|;
comment|// As of writing this, there is no case where this could be false, this is just protection
comment|// from possible future changes
if|if
condition|(
name|gop
operator|.
name|getParentOperators
argument_list|()
operator|.
name|size
argument_list|()
operator|!=
literal|1
condition|)
block|{
return|return
literal|null
return|;
block|}
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
name|rop
init|=
name|gop
operator|.
name|getParentOperators
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
comment|// The caller of this method should guarantee this
assert|assert
operator|(
name|rop
operator|instanceof
name|ReduceSinkOperator
operator|)
assert|;
name|processGroupByReduceSink
argument_list|(
operator|(
name|ReduceSinkOperator
operator|)
name|rop
argument_list|,
name|gop
argument_list|,
name|bctx
argument_list|)
expr_stmt|;
return|return
name|processGroupBy
argument_list|(
operator|(
name|ReduceSinkOperator
operator|)
name|rop
argument_list|,
name|gop
argument_list|,
name|bctx
argument_list|)
return|;
block|}
comment|/**      * Process the ReduceSinkOperator preceding a GroupByOperator to determine which columns      * are bucketed and sorted.      *      * @param rop      * @param gop      * @param bctx      */
specifier|protected
name|void
name|processGroupByReduceSink
parameter_list|(
name|ReduceSinkOperator
name|rop
parameter_list|,
name|GroupByOperator
name|gop
parameter_list|,
name|BucketingSortingCtx
name|bctx
parameter_list|)
block|{
name|String
name|sortOrder
init|=
name|rop
operator|.
name|getConf
argument_list|()
operator|.
name|getOrder
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|BucketCol
argument_list|>
name|bucketCols
init|=
operator|new
name|ArrayList
argument_list|<
name|BucketCol
argument_list|>
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|SortCol
argument_list|>
name|sortCols
init|=
operator|new
name|ArrayList
argument_list|<
name|SortCol
argument_list|>
argument_list|()
decl_stmt|;
assert|assert
name|rop
operator|.
name|getConf
argument_list|()
operator|.
name|getKeyCols
argument_list|()
operator|.
name|size
argument_list|()
operator|<=
name|rop
operator|.
name|getSchema
argument_list|()
operator|.
name|getSignature
argument_list|()
operator|.
name|size
argument_list|()
assert|;
comment|// Group by operators select the key cols, so no need to find them in the values
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|rop
operator|.
name|getConf
argument_list|()
operator|.
name|getKeyCols
argument_list|()
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|String
name|colName
init|=
name|rop
operator|.
name|getSchema
argument_list|()
operator|.
name|getSignature
argument_list|()
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|getInternalName
argument_list|()
decl_stmt|;
name|bucketCols
operator|.
name|add
argument_list|(
operator|new
name|BucketCol
argument_list|(
name|colName
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|sortCols
operator|.
name|add
argument_list|(
operator|new
name|SortCol
argument_list|(
name|colName
argument_list|,
name|i
argument_list|,
name|sortOrder
operator|.
name|charAt
argument_list|(
name|i
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|bctx
operator|.
name|setBucketedCols
argument_list|(
name|rop
argument_list|,
name|bucketCols
argument_list|)
expr_stmt|;
name|bctx
operator|.
name|setSortedCols
argument_list|(
name|rop
argument_list|,
name|sortCols
argument_list|)
expr_stmt|;
block|}
comment|/**      * Process a GroupByOperator to determine which if any columns the output is bucketed and      * sorted by, assumes the columns output by the parent which are bucketed and sorted have      * already been determined.      *      * @param parent      * @param gop      * @param bctx      * @return      */
specifier|protected
name|Object
name|processGroupBy
parameter_list|(
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
name|parent
parameter_list|,
name|GroupByOperator
name|gop
parameter_list|,
name|BucketingSortingCtx
name|bctx
parameter_list|)
block|{
name|List
argument_list|<
name|BucketCol
argument_list|>
name|bucketCols
init|=
name|bctx
operator|.
name|getBucketedCols
argument_list|(
name|parent
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|SortCol
argument_list|>
name|sortCols
init|=
name|bctx
operator|.
name|getSortedCols
argument_list|(
name|parent
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|ColumnInfo
argument_list|>
name|colInfos
init|=
name|gop
operator|.
name|getSchema
argument_list|()
operator|.
name|getSignature
argument_list|()
decl_stmt|;
if|if
condition|(
name|bucketCols
operator|==
literal|null
condition|)
block|{
assert|assert
name|sortCols
operator|==
literal|null
assert|;
return|return
literal|null
return|;
block|}
if|if
condition|(
name|bucketCols
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
assert|assert
name|sortCols
operator|.
name|isEmpty
argument_list|()
assert|;
return|return
literal|null
return|;
block|}
name|BucketCol
index|[]
name|newBucketCols
init|=
operator|new
name|BucketCol
index|[
name|bucketCols
operator|.
name|size
argument_list|()
index|]
decl_stmt|;
name|SortCol
index|[]
name|newSortCols
init|=
operator|new
name|SortCol
index|[
name|sortCols
operator|.
name|size
argument_list|()
index|]
decl_stmt|;
name|findBucketingSortingColumns
argument_list|(
name|gop
operator|.
name|getConf
argument_list|()
operator|.
name|getKeys
argument_list|()
argument_list|,
name|colInfos
argument_list|,
name|bucketCols
argument_list|,
name|sortCols
argument_list|,
name|newBucketCols
argument_list|,
name|newSortCols
argument_list|)
expr_stmt|;
name|setBucketingColsIfComplete
argument_list|(
name|bctx
argument_list|,
name|gop
argument_list|,
name|newBucketCols
argument_list|)
expr_stmt|;
name|setSortingColsIfComplete
argument_list|(
name|bctx
argument_list|,
name|gop
argument_list|,
name|newSortCols
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
block|}
comment|/**    * Filter processor    */
specifier|public
specifier|static
class|class
name|ForwardingInferrer
extends|extends
name|DefaultInferrer
implements|implements
name|NodeProcessor
block|{
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
annotation|@
name|Override
specifier|public
name|Object
name|process
parameter_list|(
name|Node
name|nd
parameter_list|,
name|Stack
argument_list|<
name|Node
argument_list|>
name|stack
parameter_list|,
name|NodeProcessorCtx
name|procCtx
parameter_list|,
name|Object
modifier|...
name|nodeOutputs
parameter_list|)
throws|throws
name|SemanticException
block|{
name|processForward
argument_list|(
operator|(
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
operator|)
name|nd
argument_list|,
operator|(
name|BucketingSortingCtx
operator|)
name|procCtx
argument_list|,
name|getParent
argument_list|(
name|stack
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
block|}
specifier|public
specifier|static
name|NodeProcessor
name|getDefaultProc
parameter_list|()
block|{
return|return
operator|new
name|DefaultInferrer
argument_list|()
return|;
block|}
specifier|public
specifier|static
name|NodeProcessor
name|getJoinProc
parameter_list|()
block|{
return|return
operator|new
name|JoinInferrer
argument_list|()
return|;
block|}
specifier|public
specifier|static
name|NodeProcessor
name|getSelProc
parameter_list|()
block|{
return|return
operator|new
name|SelectInferrer
argument_list|()
return|;
block|}
specifier|public
specifier|static
name|NodeProcessor
name|getGroupByProc
parameter_list|()
block|{
return|return
operator|new
name|GroupByInferrer
argument_list|()
return|;
block|}
specifier|public
specifier|static
name|NodeProcessor
name|getFileSinkProc
parameter_list|()
block|{
return|return
operator|new
name|FileSinkInferrer
argument_list|()
return|;
block|}
specifier|public
specifier|static
name|NodeProcessor
name|getExtractProc
parameter_list|()
block|{
return|return
operator|new
name|ExtractInferrer
argument_list|()
return|;
block|}
specifier|public
specifier|static
name|NodeProcessor
name|getFilterProc
parameter_list|()
block|{
return|return
operator|new
name|ForwardingInferrer
argument_list|()
return|;
block|}
specifier|public
specifier|static
name|NodeProcessor
name|getLimitProc
parameter_list|()
block|{
return|return
operator|new
name|ForwardingInferrer
argument_list|()
return|;
block|}
specifier|public
specifier|static
name|NodeProcessor
name|getLateralViewForwardProc
parameter_list|()
block|{
return|return
operator|new
name|ForwardingInferrer
argument_list|()
return|;
block|}
specifier|public
specifier|static
name|NodeProcessor
name|getLateralViewJoinProc
parameter_list|()
block|{
return|return
operator|new
name|ForwardingInferrer
argument_list|()
return|;
block|}
specifier|public
specifier|static
name|NodeProcessor
name|getForwardProc
parameter_list|()
block|{
return|return
operator|new
name|ForwardingInferrer
argument_list|()
return|;
block|}
specifier|public
specifier|static
name|NodeProcessor
name|getMultiGroupByProc
parameter_list|()
block|{
return|return
operator|new
name|MultiGroupByInferrer
argument_list|()
return|;
block|}
block|}
end_class

end_unit

