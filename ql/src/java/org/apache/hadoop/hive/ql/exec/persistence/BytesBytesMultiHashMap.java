begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|persistence
package|;
end_package

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|TreeMap
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|lang
operator|.
name|StringUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|Log
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|LogFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|debug
operator|.
name|Utils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|ByteStream
operator|.
name|RandomAccessOutput
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|SerDeException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|WriteBuffers
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|VisibleForTesting
import|;
end_import

begin_comment
comment|/**  * HashMap that maps byte arrays to byte arrays with limited functionality necessary for  * MapJoin hash tables, with small memory overhead. Supports multiple values for single key.  * Values can be added for key (but cannot be removed); values can be gotten for the key.  * Some things (like entrySet) are easy to add; some e.g. deletion are pretty hard to do well.  * Additionally, for each key it contains a magic "state byte" which is not part of the key and  * can be updated on every put for that key. That is really silly, we use it to store aliasFilter.  * Magic byte could be removed for generality.  * Initially inspired by HPPC LongLongOpenHashMap; however, the code is almost completely reworked  * and there's very little in common left save for quadratic probing (and that with some changes).  */
end_comment

begin_class
specifier|public
specifier|final
class|class
name|BytesBytesMultiHashMap
block|{
specifier|public
specifier|static
specifier|final
name|Log
name|LOG
init|=
name|LogFactory
operator|.
name|getLog
argument_list|(
name|BytesBytesMultiHashMap
operator|.
name|class
argument_list|)
decl_stmt|;
comment|/*    * This hashtable stores "references" in an array of longs;  index in the array is hash of    * the key; these references point into infinite byte buffer (see below). This buffer contains    * records written one after another. There are several simple record formats.    * - single record for the key    *    [key bytes][value bytes][vlong value length][vlong key length][padding]    *    We leave padding to ensure we have at least 5 bytes after key and value.    * - first of multiple records for the key (updated from "single value for the key")    *    [key bytes][value bytes][5-byte long offset to a list start record]    *  - list start record    *    [vlong value length][vlong key length][5-byte long offset to the 2nd list record]    *    Lengths are preserved from the first record. Offset is discussed above.    *  - subsequent values in the list    *    [value bytes][value length][vlong relative offset to next record].    *    * In summary, because we have separate list record, we have very little list overhead for    * the typical case of primary key join, where there's no list for any key; large lists also    * don't have a lot of relative overhead (also see the todo below).    *    * So the record looks as follows for one value per key (hash is fixed, 4 bytes, and is    * stored to expand w/o rehashing, and to more efficiently deal with collision    *    *             i = key hash    *           ._______.    * REFS: ... |offset | ....    *           `--\----'    *               `-------------.    *                            \|/    *          .______._____._____'__.__._.    * WBS: ... | hash | key | val |vl|kl| | ....    *          `------'-----'-----'--'--'-'    *    * After that refs don't change so they are not pictured.    * When we add the 2nd value, we rewrite lengths with relative offset to the list start record.    * That way, the first record points to the "list record".    *                         ref .---------.    *                         \|/ |        \|/    *       .______._____._____'__|___.     '__.__.______.    * WBS:  | hash | key | val |offset| ... |vl|kl|      |    *       `------'-----'-----'------'     '--'--'------'    * After that refs don't change so they are not pictured. List record points to the 2nd value.    *                         ref .---------.        .---------------.    *                         \|/ |        \|/       |              \|/    *       .______._____._____'__|___.     '__.__.__|___.     ._____'__._.    * WBS:  | hash | key | val |offset| ... |vl|kl|offset| ... | val |vl|0|    *       `------'-----'-----'------'     '--'--'------'     '-----'--'-'    * If we add another value, we overwrite the list record.    * We don't need to overwrite any vlongs and suffer because of that.    *                         ref .---------.         .-------------------------------.    *                         \|/ |        \|/        |                              \|/    *       .______._____._____'__|___.     '__.__.___|__.     ._____.__._.     ._____'__.______.    * WBS:  | hash | key | val |offset| ... |vl|kl|offset| ... | val |vl|0| ... | val |vl|offset|    *       `------'-----'-----'------'     '--'--'------'     '-----:--'-'     '-----'--'--|---'    *                                                               /|\                     |    *                                                                `----------------------'    * And another value (for example)    * ... ---.         .-----------------------------------------------------.    *       \|/        |                                                    \|/    *        '__.__.___|__.     ._____.__._.     ._____.__.______.     ._____'__.______.    * ...    |vl|kl|offset| ... | val |vl|0| ... | val |vl|offset| ... | val |vl|offset|    *        '--'--'------'     '-----:--'-'     '-----'--:--|---'     '-----'--'--|---'    *                                /|\                 /|\ |                     |    *                                 `-------------------+--'                     |    *                                                     `------------------------'    */
comment|/**    * Write buffers for keys and values. For the description of the structure above, think    * of this as one infinite byte buffer.    */
specifier|private
name|WriteBuffers
name|writeBuffers
decl_stmt|;
specifier|private
specifier|final
name|float
name|loadFactor
decl_stmt|;
specifier|private
name|int
name|resizeThreshold
decl_stmt|;
specifier|private
name|int
name|keysAssigned
decl_stmt|;
specifier|private
name|int
name|numValues
decl_stmt|;
comment|/**    * Largest number of probe steps ever taken to find location for a key. When getting, we can    * conclude that they key is not in hashtable when we make this many steps and don't find it.    */
specifier|private
name|int
name|largestNumberOfSteps
init|=
literal|0
decl_stmt|;
comment|/**    * References to keys of the hashtable. The index is hash of the key; collisions are    * resolved using open addressing with quadratic probing. Reference format    * [40: offset into writeBuffers][8: state byte][1: has list flag]    * [15: part of hash used to optimize probing]    * Offset is tail offset of the first record for the key (the one containing the key).    * It is not necessary to store 15 bits in particular to optimize probing; in fact when    * we always store the hash it is not necessary. But we have nothing else to do with them.    * TODO: actually we could also use few bits to store largestNumberOfSteps for each,    *      so we'd stop earlier on read collision. Need to profile on real queries.    */
specifier|private
name|long
index|[]
name|refs
decl_stmt|;
specifier|private
name|int
name|startingHashBitCount
decl_stmt|,
name|hashBitCount
decl_stmt|;
specifier|private
name|int
name|metricPutConflict
init|=
literal|0
decl_stmt|,
name|metricGetConflict
init|=
literal|0
decl_stmt|,
name|metricExpands
init|=
literal|0
decl_stmt|,
name|metricExpandsMs
init|=
literal|0
decl_stmt|;
comment|/** We have 39 bits to store list pointer from the first record; this is size limit */
specifier|final
specifier|static
name|long
name|MAX_WB_SIZE
init|=
operator|(
operator|(
name|long
operator|)
literal|1
operator|)
operator|<<
literal|38
decl_stmt|;
comment|/** 8 Gb of refs is the max capacity if memory limit is not specified. If someone has 100s of    * Gbs of memory (this might happen pretty soon) we'd need to string together arrays anyway. */
specifier|private
specifier|final
specifier|static
name|int
name|DEFAULT_MAX_CAPACITY
init|=
literal|1024
operator|*
literal|1024
operator|*
literal|1024
decl_stmt|;
specifier|public
name|BytesBytesMultiHashMap
parameter_list|(
name|int
name|initialCapacity
parameter_list|,
name|float
name|loadFactor
parameter_list|,
name|int
name|wbSize
parameter_list|,
name|long
name|memUsage
parameter_list|)
block|{
if|if
condition|(
name|loadFactor
argument_list|<
literal|0
operator|||
name|loadFactor
argument_list|>
literal|1
condition|)
block|{
throw|throw
operator|new
name|AssertionError
argument_list|(
literal|"Load factor must be between (0, 1]."
argument_list|)
throw|;
block|}
assert|assert
name|initialCapacity
operator|>
literal|0
assert|;
name|initialCapacity
operator|=
operator|(
name|Long
operator|.
name|bitCount
argument_list|(
name|initialCapacity
argument_list|)
operator|==
literal|1
operator|)
condition|?
name|initialCapacity
else|:
name|nextHighestPowerOfTwo
argument_list|(
name|initialCapacity
argument_list|)
expr_stmt|;
comment|// 8 bytes per long in the refs, assume data will be empty. This is just a sanity check.
name|int
name|maxCapacity
init|=
operator|(
name|memUsage
operator|<=
literal|0
operator|)
condition|?
name|DEFAULT_MAX_CAPACITY
else|:
operator|(
name|int
operator|)
name|Math
operator|.
name|min
argument_list|(
operator|(
name|long
operator|)
name|DEFAULT_MAX_CAPACITY
argument_list|,
name|memUsage
operator|/
literal|8
argument_list|)
decl_stmt|;
if|if
condition|(
name|maxCapacity
operator|<
name|initialCapacity
operator|||
name|initialCapacity
operator|<=
literal|0
condition|)
block|{
comment|// Either initialCapacity is too large, or nextHighestPowerOfTwo overflows
name|initialCapacity
operator|=
operator|(
name|Long
operator|.
name|bitCount
argument_list|(
name|maxCapacity
argument_list|)
operator|==
literal|1
operator|)
condition|?
name|maxCapacity
else|:
name|nextLowestPowerOfTwo
argument_list|(
name|maxCapacity
argument_list|)
expr_stmt|;
block|}
name|validateCapacity
argument_list|(
name|initialCapacity
argument_list|)
expr_stmt|;
name|startingHashBitCount
operator|=
literal|63
operator|-
name|Long
operator|.
name|numberOfLeadingZeros
argument_list|(
name|initialCapacity
argument_list|)
expr_stmt|;
name|this
operator|.
name|loadFactor
operator|=
name|loadFactor
expr_stmt|;
name|refs
operator|=
operator|new
name|long
index|[
name|initialCapacity
index|]
expr_stmt|;
name|writeBuffers
operator|=
operator|new
name|WriteBuffers
argument_list|(
name|wbSize
argument_list|,
name|MAX_WB_SIZE
argument_list|)
expr_stmt|;
name|resizeThreshold
operator|=
call|(
name|int
call|)
argument_list|(
name|initialCapacity
operator|*
name|this
operator|.
name|loadFactor
argument_list|)
expr_stmt|;
block|}
annotation|@
name|VisibleForTesting
name|BytesBytesMultiHashMap
parameter_list|(
name|int
name|initialCapacity
parameter_list|,
name|float
name|loadFactor
parameter_list|,
name|int
name|wbSize
parameter_list|)
block|{
name|this
argument_list|(
name|initialCapacity
argument_list|,
name|loadFactor
argument_list|,
name|wbSize
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
specifier|public
class|class
name|ThreadSafeGetter
block|{
specifier|private
name|WriteBuffers
operator|.
name|Position
name|position
init|=
operator|new
name|WriteBuffers
operator|.
name|Position
argument_list|()
decl_stmt|;
specifier|public
name|byte
name|getValueResult
parameter_list|(
name|byte
index|[]
name|key
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|length
parameter_list|,
name|BytesBytesMultiHashMap
operator|.
name|Result
name|hashMapResult
parameter_list|)
block|{
return|return
name|BytesBytesMultiHashMap
operator|.
name|this
operator|.
name|getValueResult
argument_list|(
name|key
argument_list|,
name|offset
argument_list|,
name|length
argument_list|,
name|hashMapResult
argument_list|,
name|position
argument_list|)
return|;
block|}
specifier|public
name|void
name|populateValue
parameter_list|(
name|WriteBuffers
operator|.
name|ByteSegmentRef
name|valueRef
parameter_list|)
block|{
comment|// Convenience method, populateValue is thread-safe.
name|BytesBytesMultiHashMap
operator|.
name|this
operator|.
name|populateValue
argument_list|(
name|valueRef
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * The result of looking up a key in the multi-hash map.    *    * This object can read through the 0, 1, or more values found for the key.    */
specifier|public
specifier|static
class|class
name|Result
block|{
comment|// Whether there are more than 0 rows.
specifier|private
name|boolean
name|hasRows
decl_stmt|;
comment|// We need a pointer to the hash map since this class must be static to support having
comment|// multiple hash tables with Hybrid Grace partitioning.
specifier|private
name|BytesBytesMultiHashMap
name|hashMap
decl_stmt|;
comment|// And, a mutable read position for thread safety when sharing a hash map.
specifier|private
name|WriteBuffers
operator|.
name|Position
name|readPos
decl_stmt|;
comment|// These values come from setValueResult when it finds a key.  These values allow this
comment|// class to read (and re-read) the values.
specifier|private
name|long
name|firstOffset
decl_stmt|;
specifier|private
name|boolean
name|hasList
decl_stmt|;
specifier|private
name|long
name|offsetAfterListRecordKeyLen
decl_stmt|;
comment|// When we have multiple values, we save the next value record's offset here.
specifier|private
name|long
name|nextTailOffset
decl_stmt|;
comment|// 0-based index of which row we are on.
specifier|private
name|long
name|readIndex
decl_stmt|;
comment|// A reference to the current row.
specifier|private
name|WriteBuffers
operator|.
name|ByteSegmentRef
name|byteSegmentRef
decl_stmt|;
specifier|public
name|Result
parameter_list|()
block|{
name|hasRows
operator|=
literal|false
expr_stmt|;
name|byteSegmentRef
operator|=
operator|new
name|WriteBuffers
operator|.
name|ByteSegmentRef
argument_list|()
expr_stmt|;
block|}
comment|/**      * @return Whether there are 1 or more values.      */
specifier|public
name|boolean
name|hasRows
parameter_list|()
block|{
comment|// NOTE: Originally we named this isEmpty, but that name conflicted with another interface.
return|return
name|hasRows
return|;
block|}
comment|/**      * @return Whether there is just 1 value row.      */
specifier|public
name|boolean
name|isSingleRow
parameter_list|()
block|{
return|return
operator|!
name|hasList
return|;
block|}
comment|/**      * Set internal values for reading the values after finding a key.      *      * @param hashMap      *          The hash map we found the key in.      * @param firstOffset      *          The absolute offset of the first record in the write buffers.      * @param hasList      *          Whether there are multiple values (true) or just a single value (false).      * @param offsetAfterListRecordKeyLen      *          The offset of just after the key length in the list record.  Or, 0 when single row.      * @param readPos      *          Holds mutable read position for thread safety.      */
specifier|public
name|void
name|set
parameter_list|(
name|BytesBytesMultiHashMap
name|hashMap
parameter_list|,
name|long
name|firstOffset
parameter_list|,
name|boolean
name|hasList
parameter_list|,
name|long
name|offsetAfterListRecordKeyLen
parameter_list|,
name|WriteBuffers
operator|.
name|Position
name|readPos
parameter_list|)
block|{
name|this
operator|.
name|hashMap
operator|=
name|hashMap
expr_stmt|;
name|this
operator|.
name|readPos
operator|=
name|readPos
expr_stmt|;
name|this
operator|.
name|firstOffset
operator|=
name|firstOffset
expr_stmt|;
name|this
operator|.
name|hasList
operator|=
name|hasList
expr_stmt|;
name|this
operator|.
name|offsetAfterListRecordKeyLen
operator|=
name|offsetAfterListRecordKeyLen
expr_stmt|;
comment|// Position at first row.
name|readIndex
operator|=
literal|0
expr_stmt|;
name|nextTailOffset
operator|=
operator|-
literal|1
expr_stmt|;
name|hasRows
operator|=
literal|true
expr_stmt|;
block|}
specifier|public
name|WriteBuffers
operator|.
name|ByteSegmentRef
name|first
parameter_list|()
block|{
if|if
condition|(
operator|!
name|hasRows
condition|)
block|{
return|return
literal|null
return|;
block|}
comment|// Position at first row.
name|readIndex
operator|=
literal|0
expr_stmt|;
name|nextTailOffset
operator|=
operator|-
literal|1
expr_stmt|;
return|return
name|internalRead
argument_list|()
return|;
block|}
specifier|public
name|WriteBuffers
operator|.
name|ByteSegmentRef
name|next
parameter_list|()
block|{
if|if
condition|(
operator|!
name|hasRows
condition|)
block|{
return|return
literal|null
return|;
block|}
return|return
name|internalRead
argument_list|()
return|;
block|}
comment|/**      * Read the current value.        *       * @return      *           The ByteSegmentRef to the current value read.      */
specifier|private
name|WriteBuffers
operator|.
name|ByteSegmentRef
name|internalRead
parameter_list|()
block|{
if|if
condition|(
operator|!
name|hasList
condition|)
block|{
comment|/*          * Single value.          */
if|if
condition|(
name|readIndex
operator|>
literal|0
condition|)
block|{
return|return
literal|null
return|;
block|}
comment|// For a non-list (i.e. single value), the offset is for the variable length long (VLong)
comment|// holding the value length (followed by the key length).
name|hashMap
operator|.
name|writeBuffers
operator|.
name|setReadPoint
argument_list|(
name|firstOffset
argument_list|,
name|readPos
argument_list|)
expr_stmt|;
name|int
name|valueLength
init|=
operator|(
name|int
operator|)
name|hashMap
operator|.
name|writeBuffers
operator|.
name|readVLong
argument_list|(
name|readPos
argument_list|)
decl_stmt|;
comment|// The value is before the offset.  Make byte segment reference absolute.
name|byteSegmentRef
operator|.
name|reset
argument_list|(
name|firstOffset
operator|-
name|valueLength
argument_list|,
name|valueLength
argument_list|)
expr_stmt|;
name|hashMap
operator|.
name|writeBuffers
operator|.
name|populateValue
argument_list|(
name|byteSegmentRef
argument_list|)
expr_stmt|;
name|readIndex
operator|++
expr_stmt|;
return|return
name|byteSegmentRef
return|;
block|}
comment|/*        * Multiple values.        */
if|if
condition|(
name|readIndex
operator|==
literal|0
condition|)
block|{
comment|// For a list, the value and key lengths of 1st record were overwritten with the
comment|// relative offset to a new list record.
name|long
name|relativeOffset
init|=
name|hashMap
operator|.
name|writeBuffers
operator|.
name|readNByteLong
argument_list|(
name|firstOffset
argument_list|,
literal|5
argument_list|,
name|readPos
argument_list|)
decl_stmt|;
comment|// At the beginning of the list record will be the value length.
name|hashMap
operator|.
name|writeBuffers
operator|.
name|setReadPoint
argument_list|(
name|firstOffset
operator|+
name|relativeOffset
argument_list|,
name|readPos
argument_list|)
expr_stmt|;
name|int
name|valueLength
init|=
operator|(
name|int
operator|)
name|hashMap
operator|.
name|writeBuffers
operator|.
name|readVLong
argument_list|(
name|readPos
argument_list|)
decl_stmt|;
comment|// The value is before the list record offset.  Make byte segment reference absolute.
name|byteSegmentRef
operator|.
name|reset
argument_list|(
name|firstOffset
operator|-
name|valueLength
argument_list|,
name|valueLength
argument_list|)
expr_stmt|;
name|hashMap
operator|.
name|writeBuffers
operator|.
name|populateValue
argument_list|(
name|byteSegmentRef
argument_list|)
expr_stmt|;
name|readIndex
operator|++
expr_stmt|;
return|return
name|byteSegmentRef
return|;
block|}
if|if
condition|(
name|readIndex
operator|==
literal|1
condition|)
block|{
comment|// We remembered the offset of just after the key length in the list record.
comment|// Read the absolute offset to the 2nd value.
name|nextTailOffset
operator|=
name|hashMap
operator|.
name|writeBuffers
operator|.
name|readNByteLong
argument_list|(
name|offsetAfterListRecordKeyLen
argument_list|,
literal|5
argument_list|,
name|readPos
argument_list|)
expr_stmt|;
if|if
condition|(
name|nextTailOffset
operator|<=
literal|0
condition|)
block|{
throw|throw
operator|new
name|Error
argument_list|(
literal|"Expecting a second value"
argument_list|)
throw|;
block|}
block|}
elseif|else
if|if
condition|(
name|nextTailOffset
operator|<=
literal|0
condition|)
block|{
return|return
literal|null
return|;
block|}
name|hashMap
operator|.
name|writeBuffers
operator|.
name|setReadPoint
argument_list|(
name|nextTailOffset
argument_list|,
name|readPos
argument_list|)
expr_stmt|;
comment|// Get the value length.
name|int
name|valueLength
init|=
operator|(
name|int
operator|)
name|hashMap
operator|.
name|writeBuffers
operator|.
name|readVLong
argument_list|(
name|readPos
argument_list|)
decl_stmt|;
comment|// Now read the relative offset to next record. Next record is always before the
comment|// previous record in the write buffers (see writeBuffers javadoc).
name|long
name|delta
init|=
name|hashMap
operator|.
name|writeBuffers
operator|.
name|readVLong
argument_list|(
name|readPos
argument_list|)
decl_stmt|;
name|long
name|newTailOffset
init|=
name|delta
operator|==
literal|0
condition|?
literal|0
else|:
operator|(
name|nextTailOffset
operator|-
name|delta
operator|)
decl_stmt|;
comment|// The value is before the value record offset.  Make byte segment reference absolute.
name|byteSegmentRef
operator|.
name|reset
argument_list|(
name|nextTailOffset
operator|-
name|valueLength
argument_list|,
name|valueLength
argument_list|)
expr_stmt|;
name|hashMap
operator|.
name|writeBuffers
operator|.
name|populateValue
argument_list|(
name|byteSegmentRef
argument_list|)
expr_stmt|;
name|nextTailOffset
operator|=
name|newTailOffset
expr_stmt|;
name|readIndex
operator|++
expr_stmt|;
return|return
name|byteSegmentRef
return|;
block|}
comment|/**      * @return Whether we have read all the values or not.      */
specifier|public
name|boolean
name|isEof
parameter_list|()
block|{
comment|// LOG.info("BytesBytesMultiHashMap isEof hasRows " + hasRows + " hasList " + hasList + " readIndex " + readIndex + " nextTailOffset " + nextTailOffset);
if|if
condition|(
operator|!
name|hasRows
condition|)
block|{
return|return
literal|true
return|;
block|}
if|if
condition|(
operator|!
name|hasList
condition|)
block|{
return|return
operator|(
name|readIndex
operator|>
literal|0
operator|)
return|;
block|}
else|else
block|{
comment|// Multiple values.
if|if
condition|(
name|readIndex
operator|<=
literal|1
condition|)
block|{
comment|// Careful: We have not read the list record and 2nd value yet, so nextTailOffset
comment|// is not valid yet.
return|return
literal|false
return|;
block|}
else|else
block|{
return|return
operator|(
name|nextTailOffset
operator|<=
literal|0
operator|)
return|;
block|}
block|}
block|}
comment|/**      * Lets go of any references to a hash map.      */
specifier|public
name|void
name|forget
parameter_list|()
block|{
name|hashMap
operator|=
literal|null
expr_stmt|;
name|readPos
operator|=
literal|null
expr_stmt|;
name|byteSegmentRef
operator|.
name|reset
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|hasRows
operator|=
literal|false
expr_stmt|;
name|readIndex
operator|=
literal|0
expr_stmt|;
name|nextTailOffset
operator|=
operator|-
literal|1
expr_stmt|;
block|}
block|}
comment|/** The source of keys and values to put into hashtable; avoids byte copying. */
specifier|public
specifier|static
interface|interface
name|KvSource
block|{
comment|/** Write key into output. */
specifier|public
name|void
name|writeKey
parameter_list|(
name|RandomAccessOutput
name|dest
parameter_list|)
throws|throws
name|SerDeException
function_decl|;
comment|/** Write value into output. */
specifier|public
name|void
name|writeValue
parameter_list|(
name|RandomAccessOutput
name|dest
parameter_list|)
throws|throws
name|SerDeException
function_decl|;
comment|/**      * Provide updated value for state byte for a key.      * @param previousValue Previous value; null if this is the first call per key.      * @return The updated value.      */
specifier|public
name|byte
name|updateStateByte
parameter_list|(
name|Byte
name|previousValue
parameter_list|)
function_decl|;
block|}
comment|/**    * Adds new value to new or existing key in hashmap. Not thread-safe.    * @param kv Keyvalue writer. Each method will be called at most once.    */
specifier|private
specifier|static
specifier|final
name|byte
index|[]
name|FOUR_ZEROES
init|=
operator|new
name|byte
index|[]
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
specifier|public
name|void
name|put
parameter_list|(
name|KvSource
name|kv
parameter_list|,
name|int
name|keyHashCode
parameter_list|)
throws|throws
name|SerDeException
block|{
if|if
condition|(
name|resizeThreshold
operator|<=
name|keysAssigned
condition|)
block|{
name|expandAndRehash
argument_list|()
expr_stmt|;
block|}
comment|// Reserve 4 bytes for the hash (don't just reserve, there may be junk there)
name|writeBuffers
operator|.
name|write
argument_list|(
name|FOUR_ZEROES
argument_list|)
expr_stmt|;
comment|// Write key to buffer to compute hashcode and compare; if it's a new key, it will
comment|// become part of the record; otherwise, we will just write over it later.
name|long
name|keyOffset
init|=
name|writeBuffers
operator|.
name|getWritePoint
argument_list|()
decl_stmt|;
name|kv
operator|.
name|writeKey
argument_list|(
name|writeBuffers
argument_list|)
expr_stmt|;
name|int
name|keyLength
init|=
call|(
name|int
call|)
argument_list|(
name|writeBuffers
operator|.
name|getWritePoint
argument_list|()
operator|-
name|keyOffset
argument_list|)
decl_stmt|;
name|int
name|hashCode
init|=
operator|(
name|keyHashCode
operator|==
operator|-
literal|1
operator|)
condition|?
name|writeBuffers
operator|.
name|hashCode
argument_list|(
name|keyOffset
argument_list|,
name|keyLength
argument_list|)
else|:
name|keyHashCode
decl_stmt|;
name|int
name|slot
init|=
name|findKeySlotToWrite
argument_list|(
name|keyOffset
argument_list|,
name|keyLength
argument_list|,
name|hashCode
argument_list|)
decl_stmt|;
comment|// LOG.info("Write hash code is " + Integer.toBinaryString(hashCode) + " - " + slot);
name|long
name|ref
init|=
name|refs
index|[
name|slot
index|]
decl_stmt|;
if|if
condition|(
name|ref
operator|==
literal|0
condition|)
block|{
comment|// This is a new key, keep writing the first record.
name|long
name|tailOffset
init|=
name|writeFirstValueRecord
argument_list|(
name|kv
argument_list|,
name|keyOffset
argument_list|,
name|keyLength
argument_list|,
name|hashCode
argument_list|)
decl_stmt|;
name|byte
name|stateByte
init|=
name|kv
operator|.
name|updateStateByte
argument_list|(
literal|null
argument_list|)
decl_stmt|;
name|refs
index|[
name|slot
index|]
operator|=
name|Ref
operator|.
name|makeFirstRef
argument_list|(
name|tailOffset
argument_list|,
name|stateByte
argument_list|,
name|hashCode
argument_list|,
name|startingHashBitCount
argument_list|)
expr_stmt|;
operator|++
name|keysAssigned
expr_stmt|;
block|}
else|else
block|{
comment|// This is not a new key; we'll overwrite the key and hash bytes - not needed anymore.
name|writeBuffers
operator|.
name|setWritePoint
argument_list|(
name|keyOffset
operator|-
literal|4
argument_list|)
expr_stmt|;
name|long
name|lrPtrOffset
init|=
name|createOrGetListRecord
argument_list|(
name|ref
argument_list|)
decl_stmt|;
name|long
name|tailOffset
init|=
name|writeValueAndLength
argument_list|(
name|kv
argument_list|)
decl_stmt|;
name|addRecordToList
argument_list|(
name|lrPtrOffset
argument_list|,
name|tailOffset
argument_list|)
expr_stmt|;
name|byte
name|oldStateByte
init|=
name|Ref
operator|.
name|getStateByte
argument_list|(
name|ref
argument_list|)
decl_stmt|;
name|byte
name|stateByte
init|=
name|kv
operator|.
name|updateStateByte
argument_list|(
name|oldStateByte
argument_list|)
decl_stmt|;
if|if
condition|(
name|oldStateByte
operator|!=
name|stateByte
condition|)
block|{
name|ref
operator|=
name|Ref
operator|.
name|setStateByte
argument_list|(
name|ref
argument_list|,
name|stateByte
argument_list|)
expr_stmt|;
block|}
name|refs
index|[
name|slot
index|]
operator|=
name|Ref
operator|.
name|setListFlag
argument_list|(
name|ref
argument_list|)
expr_stmt|;
block|}
operator|++
name|numValues
expr_stmt|;
block|}
specifier|public
name|ThreadSafeGetter
name|createGetterForThread
parameter_list|()
block|{
return|return
operator|new
name|ThreadSafeGetter
argument_list|()
return|;
block|}
comment|/** Not thread-safe! Use createGetterForThread. */
specifier|public
name|byte
name|getValueResult
parameter_list|(
name|byte
index|[]
name|key
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|length
parameter_list|,
name|Result
name|hashMapResult
parameter_list|)
block|{
return|return
name|getValueResult
argument_list|(
name|key
argument_list|,
name|offset
argument_list|,
name|length
argument_list|,
name|hashMapResult
argument_list|,
name|writeBuffers
operator|.
name|getReadPosition
argument_list|()
argument_list|)
return|;
block|}
comment|/**    * Finds a key.  Values can be read with the supplied result object.    *    * @param key Key buffer.    * @param offset the offset to the key in the buffer    * @param hashMapResult The object to fill in that can read the values.    * @param readPos Holds mutable read position for thread safety.    * @return The state byte.    */
specifier|private
name|byte
name|getValueResult
parameter_list|(
name|byte
index|[]
name|key
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|length
parameter_list|,
name|Result
name|hashMapResult
parameter_list|,
name|WriteBuffers
operator|.
name|Position
name|readPos
parameter_list|)
block|{
name|hashMapResult
operator|.
name|forget
argument_list|()
expr_stmt|;
comment|// First, find first record for the key.
name|long
name|ref
init|=
name|findKeyRefToRead
argument_list|(
name|key
argument_list|,
name|offset
argument_list|,
name|length
argument_list|,
name|readPos
argument_list|)
decl_stmt|;
if|if
condition|(
name|ref
operator|==
literal|0
condition|)
block|{
return|return
literal|0
return|;
block|}
name|boolean
name|hasList
init|=
name|Ref
operator|.
name|hasList
argument_list|(
name|ref
argument_list|)
decl_stmt|;
comment|// This relies on findKeyRefToRead doing key equality check and leaving read ptr where needed.
name|long
name|offsetAfterListRecordKeyLen
init|=
name|hasList
condition|?
name|writeBuffers
operator|.
name|getReadPoint
argument_list|(
name|readPos
argument_list|)
else|:
literal|0
decl_stmt|;
name|hashMapResult
operator|.
name|set
argument_list|(
name|this
argument_list|,
name|Ref
operator|.
name|getOffset
argument_list|(
name|ref
argument_list|)
argument_list|,
name|hasList
argument_list|,
name|offsetAfterListRecordKeyLen
argument_list|,
name|readPos
argument_list|)
expr_stmt|;
return|return
name|Ref
operator|.
name|getStateByte
argument_list|(
name|ref
argument_list|)
return|;
block|}
comment|/**    * Take the segment reference from {@link #getValueRefs(byte[], int, List)}    * result and makes it self-contained - adds byte array where the value is stored, and    * updates the offset from "global" write buffers offset to offset within that array.    */
specifier|public
name|void
name|populateValue
parameter_list|(
name|WriteBuffers
operator|.
name|ByteSegmentRef
name|valueRef
parameter_list|)
block|{
name|writeBuffers
operator|.
name|populateValue
argument_list|(
name|valueRef
argument_list|)
expr_stmt|;
block|}
comment|/**    * Number of keys in the hashmap    * @return number of keys    */
specifier|public
name|int
name|size
parameter_list|()
block|{
return|return
name|keysAssigned
return|;
block|}
comment|/**    * Number of values in the hashmap    * This is equal to or bigger than number of keys, since some values may share the same key    * @return number of values    */
specifier|public
name|int
name|getNumValues
parameter_list|()
block|{
return|return
name|numValues
return|;
block|}
comment|/**    * Number of bytes used by the hashmap    * There are two main components that take most memory: writeBuffers and refs    * Others include instance fields: 100    * @return number of bytes    */
specifier|public
name|long
name|memorySize
parameter_list|()
block|{
return|return
name|writeBuffers
operator|.
name|size
argument_list|()
operator|+
name|refs
operator|.
name|length
operator|*
literal|8
operator|+
literal|100
return|;
block|}
specifier|public
name|void
name|seal
parameter_list|()
block|{
name|writeBuffers
operator|.
name|seal
argument_list|()
expr_stmt|;
block|}
specifier|public
name|void
name|clear
parameter_list|()
block|{
comment|// This will make the object completely unusable. Semantics of clear are not defined...
name|this
operator|.
name|writeBuffers
operator|.
name|clear
argument_list|()
expr_stmt|;
name|this
operator|.
name|refs
operator|=
operator|new
name|long
index|[
literal|1
index|]
expr_stmt|;
name|this
operator|.
name|keysAssigned
operator|=
literal|0
expr_stmt|;
name|this
operator|.
name|numValues
operator|=
literal|0
expr_stmt|;
block|}
specifier|public
name|void
name|expandAndRehashToTarget
parameter_list|(
name|int
name|estimateNewRowCount
parameter_list|)
block|{
name|int
name|oldRefsCount
init|=
name|refs
operator|.
name|length
decl_stmt|;
name|int
name|newRefsCount
init|=
name|oldRefsCount
operator|+
name|estimateNewRowCount
decl_stmt|;
if|if
condition|(
name|resizeThreshold
operator|<=
name|newRefsCount
condition|)
block|{
name|newRefsCount
operator|=
operator|(
name|Long
operator|.
name|bitCount
argument_list|(
name|newRefsCount
argument_list|)
operator|==
literal|1
operator|)
condition|?
name|estimateNewRowCount
else|:
name|nextHighestPowerOfTwo
argument_list|(
name|newRefsCount
argument_list|)
expr_stmt|;
name|expandAndRehashImpl
argument_list|(
name|newRefsCount
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Expand and rehash to "
operator|+
name|newRefsCount
operator|+
literal|" from "
operator|+
name|oldRefsCount
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
specifier|static
name|void
name|validateCapacity
parameter_list|(
name|long
name|capacity
parameter_list|)
block|{
if|if
condition|(
name|Long
operator|.
name|bitCount
argument_list|(
name|capacity
argument_list|)
operator|!=
literal|1
condition|)
block|{
throw|throw
operator|new
name|AssertionError
argument_list|(
literal|"Capacity must be a power of two"
argument_list|)
throw|;
block|}
if|if
condition|(
name|capacity
operator|<=
literal|0
condition|)
block|{
throw|throw
operator|new
name|AssertionError
argument_list|(
literal|"Invalid capacity "
operator|+
name|capacity
argument_list|)
throw|;
block|}
block|}
comment|/**    * Finds the slot to use for writing, based on the key bytes already written to buffers.    * @param keyOffset Offset to the key.    * @param keyLength Length of the key.    * @param hashCode Hash code of the key (passed in because java doesn't have ref/pointers).    * @return The slot to use for writing; can be new, or matching existing key.    */
specifier|private
name|int
name|findKeySlotToWrite
parameter_list|(
name|long
name|keyOffset
parameter_list|,
name|int
name|keyLength
parameter_list|,
name|int
name|hashCode
parameter_list|)
block|{
specifier|final
name|int
name|bucketMask
init|=
operator|(
name|refs
operator|.
name|length
operator|-
literal|1
operator|)
decl_stmt|;
name|int
name|slot
init|=
name|hashCode
operator|&
name|bucketMask
decl_stmt|;
name|long
name|probeSlot
init|=
name|slot
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
name|long
name|ref
init|=
name|refs
index|[
name|slot
index|]
decl_stmt|;
if|if
condition|(
name|ref
operator|==
literal|0
operator|||
name|isSameKey
argument_list|(
name|keyOffset
argument_list|,
name|keyLength
argument_list|,
name|ref
argument_list|,
name|hashCode
argument_list|)
condition|)
block|{
break|break;
block|}
operator|++
name|metricPutConflict
expr_stmt|;
comment|// Some other key (collision) - keep probing.
name|probeSlot
operator|+=
operator|(
operator|++
name|i
operator|)
expr_stmt|;
name|slot
operator|=
call|(
name|int
call|)
argument_list|(
name|probeSlot
operator|&
name|bucketMask
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|largestNumberOfSteps
operator|<
name|i
condition|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Probed "
operator|+
name|i
operator|+
literal|" slots (the longest so far) to find space"
argument_list|)
expr_stmt|;
block|}
name|largestNumberOfSteps
operator|=
name|i
expr_stmt|;
comment|// debugDumpKeyProbe(keyOffset, keyLength, hashCode, slot);
block|}
return|return
name|slot
return|;
block|}
comment|/**    * Finds the slot to use for reading.    * @param key Read key array.    * @param length Read key length.    * @return The ref to use for reading.    */
specifier|private
name|long
name|findKeyRefToRead
parameter_list|(
name|byte
index|[]
name|key
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|length
parameter_list|,
name|WriteBuffers
operator|.
name|Position
name|readPos
parameter_list|)
block|{
specifier|final
name|int
name|bucketMask
init|=
operator|(
name|refs
operator|.
name|length
operator|-
literal|1
operator|)
decl_stmt|;
name|int
name|hashCode
init|=
name|writeBuffers
operator|.
name|hashCode
argument_list|(
name|key
argument_list|,
name|offset
argument_list|,
name|length
argument_list|)
decl_stmt|;
name|int
name|slot
init|=
name|hashCode
operator|&
name|bucketMask
decl_stmt|;
comment|// LOG.info("Read hash code for " + Utils.toStringBinary(key, 0, length)
comment|//   + " is " + Integer.toBinaryString(hashCode) + " - " + slot);
name|long
name|probeSlot
init|=
name|slot
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
name|long
name|ref
init|=
name|refs
index|[
name|slot
index|]
decl_stmt|;
comment|// When we were inserting the key, we would have inserted here; so, there's no key.
if|if
condition|(
name|ref
operator|==
literal|0
condition|)
block|{
return|return
literal|0
return|;
block|}
if|if
condition|(
name|isSameKey
argument_list|(
name|key
argument_list|,
name|offset
argument_list|,
name|length
argument_list|,
name|ref
argument_list|,
name|hashCode
argument_list|,
name|readPos
argument_list|)
condition|)
block|{
return|return
name|ref
return|;
block|}
operator|++
name|metricGetConflict
expr_stmt|;
name|probeSlot
operator|+=
operator|(
operator|++
name|i
operator|)
expr_stmt|;
if|if
condition|(
name|i
operator|>
name|largestNumberOfSteps
condition|)
block|{
comment|// We know we never went that far when we were inserting.
return|return
literal|0
return|;
block|}
name|slot
operator|=
call|(
name|int
call|)
argument_list|(
name|probeSlot
operator|&
name|bucketMask
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Puts ref into new refs array.    * @param newRefs New refs array.    * @param newRef New ref value.    * @param hashCode Hash code to use.    * @return The number of probe steps taken to find key position.    */
specifier|private
name|int
name|relocateKeyRef
parameter_list|(
name|long
index|[]
name|newRefs
parameter_list|,
name|long
name|newRef
parameter_list|,
name|int
name|hashCode
parameter_list|)
block|{
specifier|final
name|int
name|bucketMask
init|=
name|newRefs
operator|.
name|length
operator|-
literal|1
decl_stmt|;
name|int
name|newSlot
init|=
name|hashCode
operator|&
name|bucketMask
decl_stmt|;
name|long
name|probeSlot
init|=
name|newSlot
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
name|long
name|current
init|=
name|newRefs
index|[
name|newSlot
index|]
decl_stmt|;
if|if
condition|(
name|current
operator|==
literal|0
condition|)
block|{
name|newRefs
index|[
name|newSlot
index|]
operator|=
name|newRef
expr_stmt|;
break|break;
block|}
comment|// New array cannot contain the records w/the same key, so just advance, don't check.
name|probeSlot
operator|+=
operator|(
operator|++
name|i
operator|)
expr_stmt|;
name|newSlot
operator|=
call|(
name|int
call|)
argument_list|(
name|probeSlot
operator|&
name|bucketMask
argument_list|)
expr_stmt|;
block|}
return|return
name|i
return|;
block|}
comment|/**    * Verifies that the key matches a requisite key.    * @param cmpOffset The offset to the key to compare with.    * @param cmpLength The length of the key to compare with.    * @param ref The ref that can be used to retrieve the candidate key.    * @param hashCode    * @return -1 if the key referenced by ref is different than the one referenced by cmp...    *         0 if the keys match, and there's only one value for this key (no list).    *         Offset if the keys match, and there are multiple values for this key (a list).    */
specifier|private
name|boolean
name|isSameKey
parameter_list|(
name|long
name|cmpOffset
parameter_list|,
name|int
name|cmpLength
parameter_list|,
name|long
name|ref
parameter_list|,
name|int
name|hashCode
parameter_list|)
block|{
if|if
condition|(
operator|!
name|compareHashBits
argument_list|(
name|ref
argument_list|,
name|hashCode
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
comment|// Hash bits in ref don't match.
block|}
name|writeBuffers
operator|.
name|setReadPoint
argument_list|(
name|getFirstRecordLengthsOffset
argument_list|(
name|ref
argument_list|,
literal|null
argument_list|)
argument_list|)
expr_stmt|;
name|int
name|valueLength
init|=
operator|(
name|int
operator|)
name|writeBuffers
operator|.
name|readVLong
argument_list|()
decl_stmt|,
name|keyLength
init|=
operator|(
name|int
operator|)
name|writeBuffers
operator|.
name|readVLong
argument_list|()
decl_stmt|;
if|if
condition|(
name|keyLength
operator|!=
name|cmpLength
condition|)
block|{
return|return
literal|false
return|;
block|}
name|long
name|keyOffset
init|=
name|Ref
operator|.
name|getOffset
argument_list|(
name|ref
argument_list|)
operator|-
operator|(
name|valueLength
operator|+
name|keyLength
operator|)
decl_stmt|;
comment|// There's full hash code stored in front of the key. We could check that first. If keyLength
comment|// is<= 4 it obviously doesn't make sense, less bytes to check in a key. Then, if there's a
comment|// match, we check it in vain. But what is the proportion of matches? For writes it could be 0
comment|// if all keys are unique, for reads we hope it's really high. Then if there's a mismatch what
comment|// probability is there that key mismatches in<4 bytes (so just checking the key is faster)?
comment|// We assume the latter is pretty high, so we don't check for now.
return|return
name|writeBuffers
operator|.
name|isEqual
argument_list|(
name|cmpOffset
argument_list|,
name|cmpLength
argument_list|,
name|keyOffset
argument_list|,
name|keyLength
argument_list|)
return|;
block|}
comment|/**    * Same as {@link #isSameKey(long, int, long, int)} but for externally stored key.    */
specifier|private
name|boolean
name|isSameKey
parameter_list|(
name|byte
index|[]
name|key
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|length
parameter_list|,
name|long
name|ref
parameter_list|,
name|int
name|hashCode
parameter_list|,
name|WriteBuffers
operator|.
name|Position
name|readPos
parameter_list|)
block|{
if|if
condition|(
operator|!
name|compareHashBits
argument_list|(
name|ref
argument_list|,
name|hashCode
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
comment|// Hash bits don't match.
block|}
name|writeBuffers
operator|.
name|setReadPoint
argument_list|(
name|getFirstRecordLengthsOffset
argument_list|(
name|ref
argument_list|,
name|readPos
argument_list|)
argument_list|,
name|readPos
argument_list|)
expr_stmt|;
name|int
name|valueLength
init|=
operator|(
name|int
operator|)
name|writeBuffers
operator|.
name|readVLong
argument_list|(
name|readPos
argument_list|)
decl_stmt|,
name|keyLength
init|=
operator|(
name|int
operator|)
name|writeBuffers
operator|.
name|readVLong
argument_list|(
name|readPos
argument_list|)
decl_stmt|;
name|long
name|keyOffset
init|=
name|Ref
operator|.
name|getOffset
argument_list|(
name|ref
argument_list|)
operator|-
operator|(
name|valueLength
operator|+
name|keyLength
operator|)
decl_stmt|;
comment|// See the comment in the other isSameKey
if|if
condition|(
name|offset
operator|==
literal|0
condition|)
block|{
return|return
name|writeBuffers
operator|.
name|isEqual
argument_list|(
name|key
argument_list|,
name|length
argument_list|,
name|keyOffset
argument_list|,
name|keyLength
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|writeBuffers
operator|.
name|isEqual
argument_list|(
name|key
argument_list|,
name|offset
argument_list|,
name|length
argument_list|,
name|keyOffset
argument_list|,
name|keyLength
argument_list|)
return|;
block|}
block|}
specifier|private
name|boolean
name|compareHashBits
parameter_list|(
name|long
name|ref
parameter_list|,
name|int
name|hashCode
parameter_list|)
block|{
name|long
name|fakeRef
init|=
name|Ref
operator|.
name|makeFirstRef
argument_list|(
literal|0
argument_list|,
operator|(
name|byte
operator|)
literal|0
argument_list|,
name|hashCode
argument_list|,
name|startingHashBitCount
argument_list|)
decl_stmt|;
return|return
operator|(
name|Ref
operator|.
name|getHashBits
argument_list|(
name|fakeRef
argument_list|)
operator|==
name|Ref
operator|.
name|getHashBits
argument_list|(
name|ref
argument_list|)
operator|)
return|;
block|}
comment|/**    * @param ref Reference.    * @return The offset to value and key length vlongs of the first record referenced by ref.    */
specifier|private
name|long
name|getFirstRecordLengthsOffset
parameter_list|(
name|long
name|ref
parameter_list|,
name|WriteBuffers
operator|.
name|Position
name|readPos
parameter_list|)
block|{
name|long
name|tailOffset
init|=
name|Ref
operator|.
name|getOffset
argument_list|(
name|ref
argument_list|)
decl_stmt|;
if|if
condition|(
name|Ref
operator|.
name|hasList
argument_list|(
name|ref
argument_list|)
condition|)
block|{
name|long
name|relativeOffset
init|=
operator|(
name|readPos
operator|==
literal|null
operator|)
condition|?
name|writeBuffers
operator|.
name|readNByteLong
argument_list|(
name|tailOffset
argument_list|,
literal|5
argument_list|)
else|:
name|writeBuffers
operator|.
name|readNByteLong
argument_list|(
name|tailOffset
argument_list|,
literal|5
argument_list|,
name|readPos
argument_list|)
decl_stmt|;
name|tailOffset
operator|+=
name|relativeOffset
expr_stmt|;
block|}
return|return
name|tailOffset
return|;
block|}
specifier|private
name|void
name|expandAndRehash
parameter_list|()
block|{
name|long
name|capacity
init|=
name|refs
operator|.
name|length
operator|<<
literal|1
decl_stmt|;
name|expandAndRehashImpl
argument_list|(
name|capacity
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|expandAndRehashImpl
parameter_list|(
name|long
name|capacity
parameter_list|)
block|{
name|long
name|expandTime
init|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
decl_stmt|;
specifier|final
name|long
index|[]
name|oldRefs
init|=
name|refs
decl_stmt|;
name|validateCapacity
argument_list|(
name|capacity
argument_list|)
expr_stmt|;
name|long
index|[]
name|newRefs
init|=
operator|new
name|long
index|[
operator|(
name|int
operator|)
name|capacity
index|]
decl_stmt|;
comment|// We store some hash bits in ref; for every expansion, we need to add one bit to hash.
comment|// If we have enough bits, we'll do that; if we don't, we'll rehash.
comment|// LOG.info("Expanding the hashtable to " + capacity + " capacity");
name|int
name|newHashBitCount
init|=
name|hashBitCount
operator|+
literal|1
decl_stmt|;
comment|// Relocate all assigned slots from the old hash table.
name|int
name|maxSteps
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|oldSlot
init|=
literal|0
init|;
name|oldSlot
operator|<
name|oldRefs
operator|.
name|length
condition|;
operator|++
name|oldSlot
control|)
block|{
name|long
name|oldRef
init|=
name|oldRefs
index|[
name|oldSlot
index|]
decl_stmt|;
if|if
condition|(
name|oldRef
operator|==
literal|0
condition|)
block|{
continue|continue;
block|}
comment|// TODO: we could actually store a bit flag in ref indicating whether this is a hash
comment|//       match or a probe, and in the former case use hash bits (for a first few resizes).
comment|// int hashCodeOrPart = oldSlot | Ref.getNthHashBit(oldRef, startingHashBitCount, newHashBitCount);
name|writeBuffers
operator|.
name|setReadPoint
argument_list|(
name|getFirstRecordLengthsOffset
argument_list|(
name|oldRef
argument_list|,
literal|null
argument_list|)
argument_list|)
expr_stmt|;
comment|// Read the value and key length for the first record.
name|int
name|hashCode
init|=
operator|(
name|int
operator|)
name|writeBuffers
operator|.
name|readNByteLong
argument_list|(
name|Ref
operator|.
name|getOffset
argument_list|(
name|oldRef
argument_list|)
operator|-
name|writeBuffers
operator|.
name|readVLong
argument_list|()
operator|-
name|writeBuffers
operator|.
name|readVLong
argument_list|()
operator|-
literal|4
argument_list|,
literal|4
argument_list|)
decl_stmt|;
name|int
name|probeSteps
init|=
name|relocateKeyRef
argument_list|(
name|newRefs
argument_list|,
name|oldRef
argument_list|,
name|hashCode
argument_list|)
decl_stmt|;
name|maxSteps
operator|=
name|Math
operator|.
name|max
argument_list|(
name|probeSteps
argument_list|,
name|maxSteps
argument_list|)
expr_stmt|;
block|}
name|this
operator|.
name|refs
operator|=
name|newRefs
expr_stmt|;
name|this
operator|.
name|largestNumberOfSteps
operator|=
name|maxSteps
expr_stmt|;
name|this
operator|.
name|hashBitCount
operator|=
name|newHashBitCount
expr_stmt|;
name|this
operator|.
name|resizeThreshold
operator|=
call|(
name|int
call|)
argument_list|(
name|capacity
operator|*
name|loadFactor
argument_list|)
expr_stmt|;
name|metricExpandsMs
operator|+=
operator|(
name|System
operator|.
name|currentTimeMillis
argument_list|()
operator|-
name|expandTime
operator|)
expr_stmt|;
operator|++
name|metricExpands
expr_stmt|;
block|}
comment|/**    * @param ref The ref.    * @return The offset to list record pointer; list record is created if it doesn't exist.    */
specifier|private
name|long
name|createOrGetListRecord
parameter_list|(
name|long
name|ref
parameter_list|)
block|{
if|if
condition|(
name|Ref
operator|.
name|hasList
argument_list|(
name|ref
argument_list|)
condition|)
block|{
comment|// LOG.info("Found list record at " + writeBuffers.getReadPoint());
return|return
name|writeBuffers
operator|.
name|getReadPoint
argument_list|()
return|;
comment|// Assumes we are here after key compare.
block|}
name|long
name|firstTailOffset
init|=
name|Ref
operator|.
name|getOffset
argument_list|(
name|ref
argument_list|)
decl_stmt|;
comment|// LOG.info("First tail offset to create list record is " + firstTailOffset);
comment|// Determine the length of storage for value and key lengths of the first record.
name|writeBuffers
operator|.
name|setReadPoint
argument_list|(
name|firstTailOffset
argument_list|)
expr_stmt|;
name|writeBuffers
operator|.
name|skipVLong
argument_list|()
expr_stmt|;
name|writeBuffers
operator|.
name|skipVLong
argument_list|()
expr_stmt|;
name|int
name|lengthsLength
init|=
call|(
name|int
call|)
argument_list|(
name|writeBuffers
operator|.
name|getReadPoint
argument_list|()
operator|-
name|firstTailOffset
argument_list|)
decl_stmt|;
comment|// Create the list record, copy first record value/key lengths there.
name|writeBuffers
operator|.
name|writeBytes
argument_list|(
name|firstTailOffset
argument_list|,
name|lengthsLength
argument_list|)
expr_stmt|;
name|long
name|lrPtrOffset
init|=
name|writeBuffers
operator|.
name|getWritePoint
argument_list|()
decl_stmt|;
comment|// LOG.info("Creating list record: copying " + lengthsLength + ", lrPtrOffset " + lrPtrOffset);
comment|// Reserve 5 bytes for writeValueRecord to fill. There might be junk there so null them.
name|writeBuffers
operator|.
name|write
argument_list|(
name|FIVE_ZEROES
argument_list|)
expr_stmt|;
comment|// Link the list record to the first element.
name|writeBuffers
operator|.
name|writeFiveByteULong
argument_list|(
name|firstTailOffset
argument_list|,
name|lrPtrOffset
operator|-
name|lengthsLength
operator|-
name|firstTailOffset
argument_list|)
expr_stmt|;
return|return
name|lrPtrOffset
return|;
block|}
comment|/**    * Adds a newly-written record to existing list.    * @param lrPtrOffset List record pointer offset.    * @param tailOffset New record offset.    */
specifier|private
name|void
name|addRecordToList
parameter_list|(
name|long
name|lrPtrOffset
parameter_list|,
name|long
name|tailOffset
parameter_list|)
block|{
comment|// Now, insert this record into the list.
name|long
name|prevHeadOffset
init|=
name|writeBuffers
operator|.
name|readNByteLong
argument_list|(
name|lrPtrOffset
argument_list|,
literal|5
argument_list|)
decl_stmt|;
comment|// LOG.info("Reading offset " + prevHeadOffset + " at " + lrPtrOffset);
assert|assert
name|prevHeadOffset
operator|<
name|tailOffset
assert|;
comment|// We replace an earlier element, must have lower offset.
name|writeBuffers
operator|.
name|writeFiveByteULong
argument_list|(
name|lrPtrOffset
argument_list|,
name|tailOffset
argument_list|)
expr_stmt|;
comment|// LOG.info("Writing offset " + tailOffset + " at " + lrPtrOffset);
name|writeBuffers
operator|.
name|writeVLong
argument_list|(
name|prevHeadOffset
operator|==
literal|0
condition|?
literal|0
else|:
operator|(
name|tailOffset
operator|-
name|prevHeadOffset
operator|)
argument_list|)
expr_stmt|;
block|}
comment|/**    * Writes first value and lengths to finish the first record after the key has been written.    * @param kv Key-value writer.    * @param keyOffset    * @param keyLength Key length (already written).    * @param hashCode    * @return The offset of the new record.    */
specifier|private
name|long
name|writeFirstValueRecord
parameter_list|(
name|KvSource
name|kv
parameter_list|,
name|long
name|keyOffset
parameter_list|,
name|int
name|keyLength
parameter_list|,
name|int
name|hashCode
parameter_list|)
throws|throws
name|SerDeException
block|{
name|long
name|valueOffset
init|=
name|writeBuffers
operator|.
name|getWritePoint
argument_list|()
decl_stmt|;
name|kv
operator|.
name|writeValue
argument_list|(
name|writeBuffers
argument_list|)
expr_stmt|;
name|long
name|tailOffset
init|=
name|writeBuffers
operator|.
name|getWritePoint
argument_list|()
decl_stmt|;
name|int
name|valueLength
init|=
call|(
name|int
call|)
argument_list|(
name|tailOffset
operator|-
name|valueOffset
argument_list|)
decl_stmt|;
comment|// LOG.info("Writing value at " + valueOffset + " length " + valueLength);
comment|// In an unlikely case of 0-length key and value for the very first entry, we want to tell
comment|// this apart from an empty value. We'll just advance one byte; this byte will be lost.
if|if
condition|(
name|tailOffset
operator|==
literal|0
condition|)
block|{
name|writeBuffers
operator|.
name|reserve
argument_list|(
literal|1
argument_list|)
expr_stmt|;
operator|++
name|tailOffset
expr_stmt|;
block|}
comment|// LOG.info("First tail offset " + writeBuffers.getWritePoint());
name|writeBuffers
operator|.
name|writeVLong
argument_list|(
name|valueLength
argument_list|)
expr_stmt|;
name|writeBuffers
operator|.
name|writeVLong
argument_list|(
name|keyLength
argument_list|)
expr_stmt|;
name|long
name|lengthsLength
init|=
name|writeBuffers
operator|.
name|getWritePoint
argument_list|()
operator|-
name|tailOffset
decl_stmt|;
if|if
condition|(
name|lengthsLength
operator|<
literal|5
condition|)
block|{
comment|// Reserve space for potential future list
name|writeBuffers
operator|.
name|reserve
argument_list|(
literal|5
operator|-
operator|(
name|int
operator|)
name|lengthsLength
argument_list|)
expr_stmt|;
block|}
comment|// Finally write the hash code.
name|writeBuffers
operator|.
name|writeInt
argument_list|(
name|keyOffset
operator|-
literal|4
argument_list|,
name|hashCode
argument_list|)
expr_stmt|;
return|return
name|tailOffset
return|;
block|}
comment|/**    * Writes the value and value length for non-first record.    * @param kv Key-value writer.    * @return The offset of the new record.    */
specifier|private
name|long
name|writeValueAndLength
parameter_list|(
name|KvSource
name|kv
parameter_list|)
throws|throws
name|SerDeException
block|{
name|long
name|valueOffset
init|=
name|writeBuffers
operator|.
name|getWritePoint
argument_list|()
decl_stmt|;
name|kv
operator|.
name|writeValue
argument_list|(
name|writeBuffers
argument_list|)
expr_stmt|;
name|long
name|tailOffset
init|=
name|writeBuffers
operator|.
name|getWritePoint
argument_list|()
decl_stmt|;
name|writeBuffers
operator|.
name|writeVLong
argument_list|(
name|tailOffset
operator|-
name|valueOffset
argument_list|)
expr_stmt|;
comment|// LOG.info("Writing value at " + valueOffset + " length " + (tailOffset - valueOffset));
return|return
name|tailOffset
return|;
block|}
comment|/** Writes the debug dump of the table into logs. Not thread-safe. */
specifier|public
name|void
name|debugDumpTable
parameter_list|()
block|{
name|StringBuilder
name|dump
init|=
operator|new
name|StringBuilder
argument_list|(
name|keysAssigned
operator|+
literal|" keys\n"
argument_list|)
decl_stmt|;
name|TreeMap
argument_list|<
name|Long
argument_list|,
name|Integer
argument_list|>
name|byteIntervals
init|=
operator|new
name|TreeMap
argument_list|<
name|Long
argument_list|,
name|Integer
argument_list|>
argument_list|()
decl_stmt|;
name|int
name|examined
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|slot
init|=
literal|0
init|;
name|slot
operator|<
name|refs
operator|.
name|length
condition|;
operator|++
name|slot
control|)
block|{
name|long
name|ref
init|=
name|refs
index|[
name|slot
index|]
decl_stmt|;
if|if
condition|(
name|ref
operator|==
literal|0
condition|)
block|{
continue|continue;
block|}
operator|++
name|examined
expr_stmt|;
name|long
name|recOffset
init|=
name|getFirstRecordLengthsOffset
argument_list|(
name|ref
argument_list|,
literal|null
argument_list|)
decl_stmt|;
name|long
name|tailOffset
init|=
name|Ref
operator|.
name|getOffset
argument_list|(
name|ref
argument_list|)
decl_stmt|;
name|writeBuffers
operator|.
name|setReadPoint
argument_list|(
name|recOffset
argument_list|)
expr_stmt|;
name|int
name|valueLength
init|=
operator|(
name|int
operator|)
name|writeBuffers
operator|.
name|readVLong
argument_list|()
decl_stmt|,
name|keyLength
init|=
operator|(
name|int
operator|)
name|writeBuffers
operator|.
name|readVLong
argument_list|()
decl_stmt|;
name|long
name|ptrOffset
init|=
name|writeBuffers
operator|.
name|getReadPoint
argument_list|()
decl_stmt|;
if|if
condition|(
name|Ref
operator|.
name|hasList
argument_list|(
name|ref
argument_list|)
condition|)
block|{
name|byteIntervals
operator|.
name|put
argument_list|(
name|recOffset
argument_list|,
call|(
name|int
call|)
argument_list|(
name|ptrOffset
operator|+
literal|5
operator|-
name|recOffset
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|long
name|keyOffset
init|=
name|tailOffset
operator|-
name|valueLength
operator|-
name|keyLength
decl_stmt|;
name|byte
index|[]
name|key
init|=
operator|new
name|byte
index|[
name|keyLength
index|]
decl_stmt|;
name|WriteBuffers
operator|.
name|ByteSegmentRef
name|fakeRef
init|=
operator|new
name|WriteBuffers
operator|.
name|ByteSegmentRef
argument_list|(
name|keyOffset
argument_list|,
name|keyLength
argument_list|)
decl_stmt|;
name|byteIntervals
operator|.
name|put
argument_list|(
name|keyOffset
operator|-
literal|4
argument_list|,
name|keyLength
operator|+
literal|4
argument_list|)
expr_stmt|;
name|writeBuffers
operator|.
name|populateValue
argument_list|(
name|fakeRef
argument_list|)
expr_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|fakeRef
operator|.
name|getBytes
argument_list|()
argument_list|,
operator|(
name|int
operator|)
name|fakeRef
operator|.
name|getOffset
argument_list|()
argument_list|,
name|key
argument_list|,
literal|0
argument_list|,
name|keyLength
argument_list|)
expr_stmt|;
name|dump
operator|.
name|append
argument_list|(
name|Utils
operator|.
name|toStringBinary
argument_list|(
name|key
argument_list|,
literal|0
argument_list|,
name|key
operator|.
name|length
argument_list|)
argument_list|)
operator|.
name|append
argument_list|(
literal|" ref ["
argument_list|)
operator|.
name|append
argument_list|(
name|dumpRef
argument_list|(
name|ref
argument_list|)
argument_list|)
operator|.
name|append
argument_list|(
literal|"]: "
argument_list|)
expr_stmt|;
name|Result
name|hashMapResult
init|=
operator|new
name|Result
argument_list|()
decl_stmt|;
name|getValueResult
argument_list|(
name|key
argument_list|,
literal|0
argument_list|,
name|key
operator|.
name|length
argument_list|,
name|hashMapResult
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|WriteBuffers
operator|.
name|ByteSegmentRef
argument_list|>
name|results
init|=
operator|new
name|ArrayList
argument_list|<
name|WriteBuffers
operator|.
name|ByteSegmentRef
argument_list|>
argument_list|()
decl_stmt|;
name|WriteBuffers
operator|.
name|ByteSegmentRef
name|byteSegmentRef
init|=
name|hashMapResult
operator|.
name|first
argument_list|()
decl_stmt|;
while|while
condition|(
name|byteSegmentRef
operator|!=
literal|null
condition|)
block|{
name|results
operator|.
name|add
argument_list|(
name|hashMapResult
operator|.
name|byteSegmentRef
argument_list|)
expr_stmt|;
name|byteSegmentRef
operator|=
name|hashMapResult
operator|.
name|next
argument_list|()
expr_stmt|;
block|}
name|dump
operator|.
name|append
argument_list|(
name|results
operator|.
name|size
argument_list|()
argument_list|)
operator|.
name|append
argument_list|(
literal|" rows\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|results
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|WriteBuffers
operator|.
name|ByteSegmentRef
name|segment
init|=
name|results
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|byteIntervals
operator|.
name|put
argument_list|(
name|segment
operator|.
name|getOffset
argument_list|()
argument_list|,
name|segment
operator|.
name|getLength
argument_list|()
operator|+
operator|(
operator|(
name|i
operator|==
literal|0
operator|)
condition|?
literal|1
else|:
literal|0
operator|)
argument_list|)
expr_stmt|;
comment|// state byte in the first record
block|}
block|}
if|if
condition|(
name|examined
operator|!=
name|keysAssigned
condition|)
block|{
name|dump
operator|.
name|append
argument_list|(
literal|"Found "
operator|+
name|examined
operator|+
literal|" keys!\n"
argument_list|)
expr_stmt|;
block|}
comment|// Report suspicious gaps in writeBuffers
name|long
name|currentOffset
init|=
literal|0
decl_stmt|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|Long
argument_list|,
name|Integer
argument_list|>
name|e
range|:
name|byteIntervals
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|long
name|start
init|=
name|e
operator|.
name|getKey
argument_list|()
decl_stmt|,
name|len
init|=
name|e
operator|.
name|getValue
argument_list|()
decl_stmt|;
if|if
condition|(
name|start
operator|-
name|currentOffset
operator|>
literal|4
condition|)
block|{
name|dump
operator|.
name|append
argument_list|(
literal|"Gap! ["
operator|+
name|currentOffset
operator|+
literal|", "
operator|+
name|start
operator|+
literal|")\n"
argument_list|)
expr_stmt|;
block|}
name|currentOffset
operator|=
name|start
operator|+
name|len
expr_stmt|;
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"Hashtable dump:\n "
operator|+
name|dump
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
specifier|private
specifier|final
specifier|static
name|byte
index|[]
name|FIVE_ZEROES
init|=
operator|new
name|byte
index|[]
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
specifier|private
specifier|static
name|int
name|nextHighestPowerOfTwo
parameter_list|(
name|int
name|v
parameter_list|)
block|{
return|return
name|Integer
operator|.
name|highestOneBit
argument_list|(
name|v
argument_list|)
operator|<<
literal|1
return|;
block|}
specifier|private
specifier|static
name|int
name|nextLowestPowerOfTwo
parameter_list|(
name|int
name|v
parameter_list|)
block|{
return|return
name|Integer
operator|.
name|highestOneBit
argument_list|(
name|v
argument_list|)
return|;
block|}
annotation|@
name|VisibleForTesting
name|int
name|getCapacity
parameter_list|()
block|{
return|return
name|refs
operator|.
name|length
return|;
block|}
comment|/** Static helper for manipulating refs */
specifier|private
specifier|final
specifier|static
class|class
name|Ref
block|{
specifier|private
specifier|final
specifier|static
name|int
name|OFFSET_SHIFT
init|=
literal|24
decl_stmt|;
specifier|private
specifier|final
specifier|static
name|int
name|STATE_BYTE_SHIFT
init|=
literal|16
decl_stmt|;
specifier|private
specifier|final
specifier|static
name|long
name|STATE_BYTE_MASK
init|=
operator|(
operator|(
name|long
operator|)
literal|1
operator|<<
operator|(
name|OFFSET_SHIFT
operator|-
name|STATE_BYTE_SHIFT
operator|)
operator|)
operator|-
literal|1
decl_stmt|;
specifier|public
specifier|final
specifier|static
name|long
name|HASH_BITS_COUNT
init|=
name|STATE_BYTE_SHIFT
operator|-
literal|1
decl_stmt|;
specifier|private
specifier|final
specifier|static
name|long
name|HAS_LIST_MASK
init|=
operator|(
name|long
operator|)
literal|1
operator|<<
name|HASH_BITS_COUNT
decl_stmt|;
specifier|private
specifier|final
specifier|static
name|long
name|HASH_BITS_MASK
init|=
name|HAS_LIST_MASK
operator|-
literal|1
decl_stmt|;
specifier|private
specifier|final
specifier|static
name|long
name|REMOVE_STATE_BYTE
init|=
operator|~
operator|(
name|STATE_BYTE_MASK
operator|<<
name|STATE_BYTE_SHIFT
operator|)
decl_stmt|;
specifier|public
specifier|static
name|long
name|getOffset
parameter_list|(
name|long
name|ref
parameter_list|)
block|{
return|return
name|ref
operator|>>>
name|OFFSET_SHIFT
return|;
block|}
specifier|public
specifier|static
name|byte
name|getStateByte
parameter_list|(
name|long
name|ref
parameter_list|)
block|{
return|return
call|(
name|byte
call|)
argument_list|(
operator|(
name|ref
operator|>>>
name|STATE_BYTE_SHIFT
operator|)
operator|&
name|STATE_BYTE_MASK
argument_list|)
return|;
block|}
specifier|public
specifier|static
name|boolean
name|hasList
parameter_list|(
name|long
name|ref
parameter_list|)
block|{
return|return
operator|(
name|ref
operator|&
name|HAS_LIST_MASK
operator|)
operator|==
name|HAS_LIST_MASK
return|;
block|}
specifier|public
specifier|static
name|long
name|getHashBits
parameter_list|(
name|long
name|ref
parameter_list|)
block|{
return|return
name|ref
operator|&
name|HASH_BITS_MASK
return|;
block|}
specifier|public
specifier|static
name|long
name|makeFirstRef
parameter_list|(
name|long
name|offset
parameter_list|,
name|byte
name|stateByte
parameter_list|,
name|int
name|hashCode
parameter_list|,
name|int
name|skipHashBits
parameter_list|)
block|{
name|long
name|hashPart
init|=
operator|(
name|hashCode
operator|>>>
name|skipHashBits
operator|)
operator|&
name|HASH_BITS_MASK
decl_stmt|;
return|return
name|offset
operator|<<
name|OFFSET_SHIFT
operator||
name|hashPart
operator||
operator|(
operator|(
name|stateByte
operator|&
literal|0xffl
operator|)
operator|<<
name|STATE_BYTE_SHIFT
operator|)
return|;
block|}
specifier|public
specifier|static
name|int
name|getNthHashBit
parameter_list|(
name|long
name|ref
parameter_list|,
name|int
name|skippedBits
parameter_list|,
name|int
name|position
parameter_list|)
block|{
name|long
name|hashPart
init|=
name|getHashBits
argument_list|(
name|ref
argument_list|)
operator|<<
name|skippedBits
decl_stmt|;
comment|// Original hashcode, with 0-d low bits.
return|return
call|(
name|int
call|)
argument_list|(
name|hashPart
operator|&
operator|(
literal|1
operator|<<
operator|(
name|position
operator|-
literal|1
operator|)
operator|)
argument_list|)
return|;
block|}
specifier|public
specifier|static
name|long
name|setStateByte
parameter_list|(
name|long
name|ref
parameter_list|,
name|byte
name|stateByte
parameter_list|)
block|{
return|return
operator|(
name|ref
operator|&
name|REMOVE_STATE_BYTE
operator|)
operator||
operator|(
operator|(
name|stateByte
operator|&
literal|0xffl
operator|)
operator|<<
name|STATE_BYTE_SHIFT
operator|)
return|;
block|}
specifier|public
specifier|static
name|long
name|setListFlag
parameter_list|(
name|long
name|ref
parameter_list|)
block|{
return|return
name|ref
operator||
name|HAS_LIST_MASK
return|;
block|}
block|}
specifier|private
specifier|static
name|String
name|dumpRef
parameter_list|(
name|long
name|ref
parameter_list|)
block|{
return|return
name|StringUtils
operator|.
name|leftPad
argument_list|(
name|Long
operator|.
name|toBinaryString
argument_list|(
name|ref
argument_list|)
argument_list|,
literal|64
argument_list|,
literal|"0"
argument_list|)
operator|+
literal|" o="
operator|+
name|Ref
operator|.
name|getOffset
argument_list|(
name|ref
argument_list|)
operator|+
literal|" s="
operator|+
name|Ref
operator|.
name|getStateByte
argument_list|(
name|ref
argument_list|)
operator|+
literal|" l="
operator|+
name|Ref
operator|.
name|hasList
argument_list|(
name|ref
argument_list|)
operator|+
literal|" h="
operator|+
name|Long
operator|.
name|toBinaryString
argument_list|(
name|Ref
operator|.
name|getHashBits
argument_list|(
name|ref
argument_list|)
argument_list|)
return|;
block|}
specifier|public
name|void
name|debugDumpMetrics
parameter_list|()
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Map metrics: keys allocated "
operator|+
name|this
operator|.
name|refs
operator|.
name|length
operator|+
literal|", keys assigned "
operator|+
name|keysAssigned
operator|+
literal|", write conflict "
operator|+
name|metricPutConflict
operator|+
literal|", write max dist "
operator|+
name|largestNumberOfSteps
operator|+
literal|", read conflict "
operator|+
name|metricGetConflict
operator|+
literal|", expanded "
operator|+
name|metricExpands
operator|+
literal|" times in "
operator|+
name|metricExpandsMs
operator|+
literal|"ms"
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|debugDumpKeyProbe
parameter_list|(
name|long
name|keyOffset
parameter_list|,
name|int
name|keyLength
parameter_list|,
name|int
name|hashCode
parameter_list|,
name|int
name|finalSlot
parameter_list|)
block|{
specifier|final
name|int
name|bucketMask
init|=
name|refs
operator|.
name|length
operator|-
literal|1
decl_stmt|;
name|WriteBuffers
operator|.
name|ByteSegmentRef
name|fakeRef
init|=
operator|new
name|WriteBuffers
operator|.
name|ByteSegmentRef
argument_list|(
name|keyOffset
argument_list|,
name|keyLength
argument_list|)
decl_stmt|;
name|writeBuffers
operator|.
name|populateValue
argument_list|(
name|fakeRef
argument_list|)
expr_stmt|;
name|int
name|slot
init|=
name|hashCode
operator|&
name|bucketMask
decl_stmt|;
name|long
name|probeSlot
init|=
name|slot
decl_stmt|;
name|StringBuilder
name|sb
init|=
operator|new
name|StringBuilder
argument_list|(
literal|"Probe path debug for ["
argument_list|)
decl_stmt|;
name|sb
operator|.
name|append
argument_list|(
name|Utils
operator|.
name|toStringBinary
argument_list|(
name|fakeRef
operator|.
name|getBytes
argument_list|()
argument_list|,
operator|(
name|int
operator|)
name|fakeRef
operator|.
name|getOffset
argument_list|()
argument_list|,
name|fakeRef
operator|.
name|getLength
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|"] hashCode "
argument_list|)
operator|.
name|append
argument_list|(
name|Integer
operator|.
name|toBinaryString
argument_list|(
name|hashCode
argument_list|)
argument_list|)
operator|.
name|append
argument_list|(
literal|" is: "
argument_list|)
expr_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|slot
operator|!=
name|finalSlot
condition|)
block|{
name|probeSlot
operator|+=
operator|(
operator|++
name|i
operator|)
expr_stmt|;
name|slot
operator|=
call|(
name|int
call|)
argument_list|(
name|probeSlot
operator|&
name|bucketMask
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
name|slot
argument_list|)
operator|.
name|append
argument_list|(
literal|" - "
argument_list|)
operator|.
name|append
argument_list|(
name|probeSlot
argument_list|)
operator|.
name|append
argument_list|(
literal|" - "
argument_list|)
operator|.
name|append
argument_list|(
name|Long
operator|.
name|toBinaryString
argument_list|(
name|refs
index|[
name|slot
index|]
argument_list|)
argument_list|)
operator|.
name|append
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
name|LOG
operator|.
name|info
argument_list|(
name|sb
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
end_class

end_unit

