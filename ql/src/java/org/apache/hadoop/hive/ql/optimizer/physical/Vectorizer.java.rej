***************
*** 1255,1272 ****
        LOG.info("Cannot vectorize " + desc.toString() + " of type " + typeName);
        return false;
      }
      if (desc instanceof ExprNodeGenericFuncDesc) {
        ExprNodeGenericFuncDesc d = (ExprNodeGenericFuncDesc) desc;
        boolean r = validateGenericUdf(d);
        if (!r) {
          return false;
        }
      }
      if (desc.getChildren() != null) {
-       for (ExprNodeDesc d: desc.getChildren()) {
-         // Don't restrict child expressions for projection.  Always use looser FILTER mode.
-         boolean r = validateExprNodeDescRecursive(d, VectorExpressionDescriptor.Mode.FILTER);
-         if (!r) {
            return false;
          }
        }
--- 1265,1329 ----
        LOG.info("Cannot vectorize " + desc.toString() + " of type " + typeName);
        return false;
      }
+     boolean isInExpression = false;
      if (desc instanceof ExprNodeGenericFuncDesc) {
        ExprNodeGenericFuncDesc d = (ExprNodeGenericFuncDesc) desc;
        boolean r = validateGenericUdf(d);
        if (!r) {
          return false;
        }
+       GenericUDF genericUDF = d.getGenericUDF();
+       isInExpression = (genericUDF instanceof GenericUDFIn);
      }
      if (desc.getChildren() != null) {
+       if (isInExpression &&
+           desc.getChildren().get(0).getTypeInfo().getCategory() == Category.STRUCT) {
+         boolean r = validateStructInExpression(desc, VectorExpressionDescriptor.Mode.FILTER);
+       } else {
+         for (ExprNodeDesc d: desc.getChildren()) {
+           // Don't restrict child expressions for projection.  Always use looser FILTER mode.
+           boolean r = validateExprNodeDescRecursive(d, VectorExpressionDescriptor.Mode.FILTER);
+           if (!r) {
+             return false;
+           }
+         }
+       }
+     }
+     return true;
+   }
+ 
+   private boolean validateStructInExpression(ExprNodeDesc desc,
+       VectorExpressionDescriptor.Mode mode) {
+ 
+     for (ExprNodeDesc d: desc.getChildren()) {
+       TypeInfo typeInfo = d.getTypeInfo();
+       if (typeInfo.getCategory() != Category.STRUCT){
+         return false;
+       }
+       StructTypeInfo structTypeInfo = (StructTypeInfo) typeInfo;
+ 
+       ArrayList<TypeInfo> fieldTypeInfos = structTypeInfo.getAllStructFieldTypeInfos();
+       ArrayList<String> fieldNames = structTypeInfo.getAllStructFieldNames();
+       final int fieldCount = fieldTypeInfos.size();
+       for (int f = 0; f < fieldCount; f++) {
+         TypeInfo fieldTypeInfo = fieldTypeInfos.get(f);
+         Category category = fieldTypeInfo.getCategory();
+         if (category != Category.PRIMITIVE){
+           LOG.info("Cannot vectorize struct field " + fieldNames.get(f) +
+               " of type " + fieldTypeInfo.getTypeName());
+           return false;
+         }
+         PrimitiveTypeInfo fieldPrimitiveTypeInfo = (PrimitiveTypeInfo) fieldTypeInfo;
+         InConstantType inConstantType =
+             VectorizationContext.getInConstantTypeFromPrimitiveCategory(
+                 fieldPrimitiveTypeInfo.getPrimitiveCategory());
+ 
+         // For now, limit the data types we support for Vectorized Struct IN().
+         if (inConstantType != InConstantType.INT_FAMILY &&
+             inConstantType != InConstantType.FLOAT_FAMILY &&
+             inConstantType != InConstantType.STRING_FAMILY) {
+           LOG.info("Cannot vectorize struct field " + fieldNames.get(f) +
+               " of type " + fieldTypeInfo.getTypeName());
            return false;
          }
        }
