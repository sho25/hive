begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|optimizer
operator|.
name|calcite
operator|.
name|translator
package|;
end_package

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|RelNode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|core
operator|.
name|AggregateCall
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|type
operator|.
name|RelDataType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexInputRef
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|ImmutableBitSet
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|conf
operator|.
name|HiveConf
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|ErrorMsg
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|ColumnInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|GroupByOperator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|Operator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|OperatorFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|ReduceSinkOperator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|RowSchema
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|Utilities
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|io
operator|.
name|AcidUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|metadata
operator|.
name|VirtualColumn
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|optimizer
operator|.
name|calcite
operator|.
name|CalciteSemanticException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|optimizer
operator|.
name|calcite
operator|.
name|HiveCalciteUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|optimizer
operator|.
name|calcite
operator|.
name|reloperators
operator|.
name|HiveAggregate
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|optimizer
operator|.
name|calcite
operator|.
name|reloperators
operator|.
name|HiveGroupingID
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|optimizer
operator|.
name|calcite
operator|.
name|translator
operator|.
name|HiveOpConverter
operator|.
name|OpAttr
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|parse
operator|.
name|ASTNode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|parse
operator|.
name|SemanticAnalyzer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|parse
operator|.
name|SemanticException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|parse
operator|.
name|SemanticAnalyzer
operator|.
name|GenericUDAFInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|AggregationDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|ExprNodeColumnDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|ExprNodeConstantDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|ExprNodeDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|ExprNodeDescUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|GroupByDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|PlanUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|udf
operator|.
name|generic
operator|.
name|GenericUDAFEvaluator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|udf
operator|.
name|generic
operator|.
name|GenericUDAFEvaluator
operator|.
name|Mode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|typeinfo
operator|.
name|TypeInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|typeinfo
operator|.
name|TypeInfoFactory
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|ImmutableList
import|;
end_import

begin_comment
comment|/**  * TODO:<br>  * 1. Change the output col/ExprNodeColumn names to external names.<br>  * 2. Verify if we need to use the "KEY."/"VALUE." in RS cols; switch to  * external names if possible.<br>  * 3. In ExprNode& in ColumnInfo the tableAlias/VirtualColumn is specified  * differently for different GB/RS in pipeline. Remove the different treatments.  * 3. VirtualColMap needs to be maintained  *  */
end_comment

begin_class
specifier|public
class|class
name|HiveGBOpConvUtil
block|{
specifier|private
specifier|static
enum|enum
name|HIVEGBPHYSICALMODE
block|{
name|MAP_SIDE_GB_NO_SKEW_NO_ADD_MR_JOB
block|,
name|MAP_SIDE_GB_NO_SKEW_ADD_MR_JOB
block|,
name|MAP_SIDE_GB_SKEW_GBKEYS_OR_DIST_UDAF_PRESENT
block|,
name|MAP_SIDE_GB_SKEW_GBKEYS_AND_DIST_UDAF_NOT_PRESENT
block|,
name|NO_MAP_SIDE_GB_NO_SKEW
block|,
name|NO_MAP_SIDE_GB_SKEW
block|}
empty_stmt|;
specifier|private
specifier|static
class|class
name|UDAFAttrs
block|{
specifier|private
name|boolean
name|isDistinctUDAF
decl_stmt|;
specifier|private
name|String
name|udafName
decl_stmt|;
specifier|private
name|GenericUDAFEvaluator
name|udafEvaluator
decl_stmt|;
specifier|private
specifier|final
name|ArrayList
argument_list|<
name|ExprNodeDesc
argument_list|>
name|udafParams
init|=
operator|new
name|ArrayList
argument_list|<
name|ExprNodeDesc
argument_list|>
argument_list|()
decl_stmt|;
specifier|private
name|List
argument_list|<
name|Integer
argument_list|>
name|udafParamsIndxInGBInfoDistExprs
init|=
operator|new
name|ArrayList
argument_list|<
name|Integer
argument_list|>
argument_list|()
decl_stmt|;
block|}
empty_stmt|;
specifier|private
specifier|static
class|class
name|GBInfo
block|{
specifier|private
specifier|final
name|List
argument_list|<
name|String
argument_list|>
name|outputColNames
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
specifier|private
specifier|final
name|List
argument_list|<
name|String
argument_list|>
name|gbKeyColNamesInInput
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
specifier|private
specifier|final
name|List
argument_list|<
name|TypeInfo
argument_list|>
name|gbKeyTypes
init|=
operator|new
name|ArrayList
argument_list|<
name|TypeInfo
argument_list|>
argument_list|()
decl_stmt|;
specifier|private
specifier|final
name|List
argument_list|<
name|ExprNodeDesc
argument_list|>
name|gbKeys
init|=
operator|new
name|ArrayList
argument_list|<
name|ExprNodeDesc
argument_list|>
argument_list|()
decl_stmt|;
specifier|private
specifier|final
name|List
argument_list|<
name|Integer
argument_list|>
name|grpSets
init|=
operator|new
name|ArrayList
argument_list|<
name|Integer
argument_list|>
argument_list|()
decl_stmt|;
specifier|private
name|boolean
name|grpSetRqrAdditionalMRJob
decl_stmt|;
specifier|private
name|boolean
name|grpIdFunctionNeeded
decl_stmt|;
specifier|private
specifier|final
name|List
argument_list|<
name|String
argument_list|>
name|distExprNames
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
specifier|private
specifier|final
name|List
argument_list|<
name|TypeInfo
argument_list|>
name|distExprTypes
init|=
operator|new
name|ArrayList
argument_list|<
name|TypeInfo
argument_list|>
argument_list|()
decl_stmt|;
specifier|private
specifier|final
name|List
argument_list|<
name|ExprNodeDesc
argument_list|>
name|distExprNodes
init|=
operator|new
name|ArrayList
argument_list|<
name|ExprNodeDesc
argument_list|>
argument_list|()
decl_stmt|;
specifier|private
specifier|final
name|List
argument_list|<
name|List
argument_list|<
name|Integer
argument_list|>
argument_list|>
name|distColIndices
init|=
operator|new
name|ArrayList
argument_list|<
name|List
argument_list|<
name|Integer
argument_list|>
argument_list|>
argument_list|()
decl_stmt|;
specifier|private
specifier|final
name|List
argument_list|<
name|ExprNodeDesc
argument_list|>
name|deDupedNonDistIrefs
init|=
operator|new
name|ArrayList
argument_list|<
name|ExprNodeDesc
argument_list|>
argument_list|()
decl_stmt|;
specifier|private
specifier|final
name|List
argument_list|<
name|UDAFAttrs
argument_list|>
name|udafAttrs
init|=
operator|new
name|ArrayList
argument_list|<
name|UDAFAttrs
argument_list|>
argument_list|()
decl_stmt|;
specifier|private
name|boolean
name|containsDistinctAggr
init|=
literal|false
decl_stmt|;
name|float
name|groupByMemoryUsage
decl_stmt|;
name|float
name|memoryThreshold
decl_stmt|;
specifier|private
name|HIVEGBPHYSICALMODE
name|gbPhysicalPipelineMode
decl_stmt|;
block|}
empty_stmt|;
specifier|private
specifier|static
name|HIVEGBPHYSICALMODE
name|getAggOPMode
parameter_list|(
name|HiveConf
name|hc
parameter_list|,
name|GBInfo
name|gbInfo
parameter_list|)
block|{
name|HIVEGBPHYSICALMODE
name|gbPhysicalPipelineMode
init|=
name|HIVEGBPHYSICALMODE
operator|.
name|MAP_SIDE_GB_NO_SKEW_NO_ADD_MR_JOB
decl_stmt|;
if|if
condition|(
name|hc
operator|.
name|getBoolVar
argument_list|(
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVEMAPSIDEAGGREGATE
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|hc
operator|.
name|getBoolVar
argument_list|(
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVEGROUPBYSKEW
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|gbInfo
operator|.
name|grpSetRqrAdditionalMRJob
condition|)
block|{
name|gbPhysicalPipelineMode
operator|=
name|HIVEGBPHYSICALMODE
operator|.
name|MAP_SIDE_GB_NO_SKEW_NO_ADD_MR_JOB
expr_stmt|;
block|}
else|else
block|{
name|gbPhysicalPipelineMode
operator|=
name|HIVEGBPHYSICALMODE
operator|.
name|MAP_SIDE_GB_NO_SKEW_ADD_MR_JOB
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|gbInfo
operator|.
name|containsDistinctAggr
operator|||
operator|!
name|gbInfo
operator|.
name|gbKeys
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|gbPhysicalPipelineMode
operator|=
name|HIVEGBPHYSICALMODE
operator|.
name|MAP_SIDE_GB_SKEW_GBKEYS_OR_DIST_UDAF_PRESENT
expr_stmt|;
block|}
else|else
block|{
name|gbPhysicalPipelineMode
operator|=
name|HIVEGBPHYSICALMODE
operator|.
name|MAP_SIDE_GB_SKEW_GBKEYS_AND_DIST_UDAF_NOT_PRESENT
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
if|if
condition|(
operator|!
name|hc
operator|.
name|getBoolVar
argument_list|(
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVEGROUPBYSKEW
argument_list|)
condition|)
block|{
name|gbPhysicalPipelineMode
operator|=
name|HIVEGBPHYSICALMODE
operator|.
name|NO_MAP_SIDE_GB_NO_SKEW
expr_stmt|;
block|}
else|else
block|{
name|gbPhysicalPipelineMode
operator|=
name|HIVEGBPHYSICALMODE
operator|.
name|NO_MAP_SIDE_GB_SKEW
expr_stmt|;
block|}
block|}
return|return
name|gbPhysicalPipelineMode
return|;
block|}
comment|// For each of the GB op in the logical GB this should be called seperately;
comment|// otherwise GBevaluator and expr nodes may get shared among multiple GB ops
specifier|private
specifier|static
name|GBInfo
name|getGBInfo
parameter_list|(
name|HiveAggregate
name|aggRel
parameter_list|,
name|OpAttr
name|inputOpAf
parameter_list|,
name|HiveConf
name|hc
parameter_list|)
throws|throws
name|SemanticException
block|{
name|GBInfo
name|gbInfo
init|=
operator|new
name|GBInfo
argument_list|()
decl_stmt|;
comment|// 0. Collect AggRel output col Names
name|gbInfo
operator|.
name|outputColNames
operator|.
name|addAll
argument_list|(
name|aggRel
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldNames
argument_list|()
argument_list|)
expr_stmt|;
comment|// 1. Collect GB Keys
name|RelNode
name|aggInputRel
init|=
name|aggRel
operator|.
name|getInput
argument_list|()
decl_stmt|;
name|ExprNodeConverter
name|exprConv
init|=
operator|new
name|ExprNodeConverter
argument_list|(
name|inputOpAf
operator|.
name|tabAlias
argument_list|,
name|aggInputRel
operator|.
name|getRowType
argument_list|()
argument_list|,
operator|new
name|HashSet
argument_list|<
name|Integer
argument_list|>
argument_list|()
argument_list|,
name|aggRel
operator|.
name|getCluster
argument_list|()
operator|.
name|getTypeFactory
argument_list|()
argument_list|)
decl_stmt|;
name|ExprNodeDesc
name|tmpExprNodeDesc
decl_stmt|;
for|for
control|(
name|int
name|i
range|:
name|aggRel
operator|.
name|getGroupSet
argument_list|()
control|)
block|{
name|RexInputRef
name|iRef
init|=
operator|new
name|RexInputRef
argument_list|(
name|i
argument_list|,
name|aggInputRel
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldList
argument_list|()
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|getType
argument_list|()
argument_list|)
decl_stmt|;
name|tmpExprNodeDesc
operator|=
name|iRef
operator|.
name|accept
argument_list|(
name|exprConv
argument_list|)
expr_stmt|;
name|gbInfo
operator|.
name|gbKeys
operator|.
name|add
argument_list|(
name|tmpExprNodeDesc
argument_list|)
expr_stmt|;
name|gbInfo
operator|.
name|gbKeyColNamesInInput
operator|.
name|add
argument_list|(
name|aggInputRel
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldNames
argument_list|()
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|gbInfo
operator|.
name|gbKeyTypes
operator|.
name|add
argument_list|(
name|tmpExprNodeDesc
operator|.
name|getTypeInfo
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// 2. Collect Grouping Set info
if|if
condition|(
name|aggRel
operator|.
name|indicator
condition|)
block|{
comment|// 2.1 Translate Grouping set col bitset
name|ImmutableList
argument_list|<
name|ImmutableBitSet
argument_list|>
name|lstGrpSet
init|=
name|aggRel
operator|.
name|getGroupSets
argument_list|()
decl_stmt|;
name|int
name|bitmap
init|=
literal|0
decl_stmt|;
for|for
control|(
name|ImmutableBitSet
name|grpSet
range|:
name|lstGrpSet
control|)
block|{
name|bitmap
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|Integer
name|bitIdx
range|:
name|grpSet
operator|.
name|asList
argument_list|()
control|)
block|{
name|bitmap
operator|=
name|SemanticAnalyzer
operator|.
name|setBit
argument_list|(
name|bitmap
argument_list|,
name|bitIdx
argument_list|)
expr_stmt|;
block|}
name|gbInfo
operator|.
name|grpSets
operator|.
name|add
argument_list|(
name|bitmap
argument_list|)
expr_stmt|;
block|}
name|Collections
operator|.
name|sort
argument_list|(
name|gbInfo
operator|.
name|grpSets
argument_list|)
expr_stmt|;
comment|// 2.2 Check if GRpSet require additional MR Job
name|gbInfo
operator|.
name|grpSetRqrAdditionalMRJob
operator|=
name|gbInfo
operator|.
name|grpSets
operator|.
name|size
argument_list|()
operator|>
name|hc
operator|.
name|getIntVar
argument_list|(
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVE_NEW_JOB_GROUPING_SET_CARDINALITY
argument_list|)
expr_stmt|;
comment|// 2.3 Check if GROUPING_ID needs to be projected out
if|if
condition|(
operator|!
name|aggRel
operator|.
name|getAggCallList
argument_list|()
operator|.
name|isEmpty
argument_list|()
operator|&&
operator|(
name|aggRel
operator|.
name|getAggCallList
argument_list|()
operator|.
name|get
argument_list|(
name|aggRel
operator|.
name|getAggCallList
argument_list|()
operator|.
name|size
argument_list|()
operator|-
literal|1
argument_list|)
operator|.
name|getAggregation
argument_list|()
operator|==
name|HiveGroupingID
operator|.
name|INSTANCE
operator|)
condition|)
block|{
name|gbInfo
operator|.
name|grpIdFunctionNeeded
operator|=
literal|true
expr_stmt|;
block|}
block|}
comment|// 3. Walk through UDAF& Collect Distinct Info
name|Set
argument_list|<
name|Integer
argument_list|>
name|distinctRefs
init|=
operator|new
name|HashSet
argument_list|<
name|Integer
argument_list|>
argument_list|()
decl_stmt|;
name|Map
argument_list|<
name|Integer
argument_list|,
name|Integer
argument_list|>
name|distParamInRefsToOutputPos
init|=
operator|new
name|HashMap
argument_list|<
name|Integer
argument_list|,
name|Integer
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|AggregateCall
name|aggCall
range|:
name|aggRel
operator|.
name|getAggCallList
argument_list|()
control|)
block|{
if|if
condition|(
operator|(
name|aggCall
operator|.
name|getAggregation
argument_list|()
operator|==
name|HiveGroupingID
operator|.
name|INSTANCE
operator|)
operator|||
operator|!
name|aggCall
operator|.
name|isDistinct
argument_list|()
condition|)
block|{
continue|continue;
block|}
name|List
argument_list|<
name|Integer
argument_list|>
name|argLst
init|=
operator|new
name|ArrayList
argument_list|<
name|Integer
argument_list|>
argument_list|(
name|aggCall
operator|.
name|getArgList
argument_list|()
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|argNames
init|=
name|HiveCalciteUtil
operator|.
name|getFieldNames
argument_list|(
name|argLst
argument_list|,
name|aggInputRel
argument_list|)
decl_stmt|;
name|ExprNodeDesc
name|distinctExpr
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|argLst
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|distinctRefs
operator|.
name|contains
argument_list|(
name|argLst
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|)
condition|)
block|{
name|distinctRefs
operator|.
name|add
argument_list|(
name|argLst
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|distParamInRefsToOutputPos
operator|.
name|put
argument_list|(
name|argLst
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|,
name|gbInfo
operator|.
name|distExprNodes
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|distinctExpr
operator|=
name|HiveCalciteUtil
operator|.
name|getExprNode
argument_list|(
name|argLst
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|,
name|aggInputRel
argument_list|,
name|exprConv
argument_list|)
expr_stmt|;
name|gbInfo
operator|.
name|distExprNodes
operator|.
name|add
argument_list|(
name|distinctExpr
argument_list|)
expr_stmt|;
name|gbInfo
operator|.
name|distExprNames
operator|.
name|add
argument_list|(
name|argNames
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|gbInfo
operator|.
name|distExprTypes
operator|.
name|add
argument_list|(
name|distinctExpr
operator|.
name|getTypeInfo
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|// 4. Walk through UDAF& Collect UDAF Info
name|Set
argument_list|<
name|Integer
argument_list|>
name|deDupedNonDistIrefsSet
init|=
operator|new
name|HashSet
argument_list|<
name|Integer
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|AggregateCall
name|aggCall
range|:
name|aggRel
operator|.
name|getAggCallList
argument_list|()
control|)
block|{
if|if
condition|(
name|aggCall
operator|.
name|getAggregation
argument_list|()
operator|==
name|HiveGroupingID
operator|.
name|INSTANCE
condition|)
block|{
continue|continue;
block|}
name|UDAFAttrs
name|udafAttrs
init|=
operator|new
name|UDAFAttrs
argument_list|()
decl_stmt|;
name|udafAttrs
operator|.
name|udafParams
operator|.
name|addAll
argument_list|(
name|HiveCalciteUtil
operator|.
name|getExprNodes
argument_list|(
name|aggCall
operator|.
name|getArgList
argument_list|()
argument_list|,
name|aggInputRel
argument_list|,
name|inputOpAf
operator|.
name|tabAlias
argument_list|)
argument_list|)
expr_stmt|;
name|udafAttrs
operator|.
name|udafName
operator|=
name|aggCall
operator|.
name|getAggregation
argument_list|()
operator|.
name|getName
argument_list|()
expr_stmt|;
name|udafAttrs
operator|.
name|isDistinctUDAF
operator|=
name|aggCall
operator|.
name|isDistinct
argument_list|()
expr_stmt|;
name|List
argument_list|<
name|Integer
argument_list|>
name|argLst
init|=
operator|new
name|ArrayList
argument_list|<
name|Integer
argument_list|>
argument_list|(
name|aggCall
operator|.
name|getArgList
argument_list|()
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|Integer
argument_list|>
name|distColIndicesOfUDAF
init|=
operator|new
name|ArrayList
argument_list|<
name|Integer
argument_list|>
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|Integer
argument_list|>
name|distUDAFParamsIndxInDistExprs
init|=
operator|new
name|ArrayList
argument_list|<
name|Integer
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|argLst
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
comment|// NOTE: distinct expr can not be part of of GB key (we assume plan
comment|// gen would have prevented it)
if|if
condition|(
name|udafAttrs
operator|.
name|isDistinctUDAF
condition|)
block|{
name|distColIndicesOfUDAF
operator|.
name|add
argument_list|(
name|distParamInRefsToOutputPos
operator|.
name|get
argument_list|(
name|argLst
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|distUDAFParamsIndxInDistExprs
operator|.
name|add
argument_list|(
name|distParamInRefsToOutputPos
operator|.
name|get
argument_list|(
name|argLst
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// TODO: this seems wrong (following what Hive Regular does)
if|if
condition|(
operator|!
name|distParamInRefsToOutputPos
operator|.
name|containsKey
argument_list|(
name|argLst
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|)
operator|&&
operator|!
name|deDupedNonDistIrefsSet
operator|.
name|contains
argument_list|(
name|argLst
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|)
condition|)
block|{
name|deDupedNonDistIrefsSet
operator|.
name|add
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|gbInfo
operator|.
name|deDupedNonDistIrefs
operator|.
name|add
argument_list|(
name|udafAttrs
operator|.
name|udafParams
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|udafAttrs
operator|.
name|isDistinctUDAF
condition|)
block|{
name|gbInfo
operator|.
name|containsDistinctAggr
operator|=
literal|true
expr_stmt|;
name|udafAttrs
operator|.
name|udafParamsIndxInGBInfoDistExprs
operator|=
name|distUDAFParamsIndxInDistExprs
expr_stmt|;
name|gbInfo
operator|.
name|distColIndices
operator|.
name|add
argument_list|(
name|distColIndicesOfUDAF
argument_list|)
expr_stmt|;
block|}
comment|// special handling for count, similar to PlanModifierForASTConv::replaceEmptyGroupAggr()
name|udafAttrs
operator|.
name|udafEvaluator
operator|=
name|SemanticAnalyzer
operator|.
name|getGenericUDAFEvaluator
argument_list|(
name|udafAttrs
operator|.
name|udafName
argument_list|,
operator|new
name|ArrayList
argument_list|<
name|ExprNodeDesc
argument_list|>
argument_list|(
name|udafAttrs
operator|.
name|udafParams
argument_list|)
argument_list|,
operator|new
name|ASTNode
argument_list|()
argument_list|,
name|udafAttrs
operator|.
name|isDistinctUDAF
argument_list|,
name|udafAttrs
operator|.
name|udafParams
operator|.
name|size
argument_list|()
operator|==
literal|0
operator|&&
literal|"count"
operator|.
name|equalsIgnoreCase
argument_list|(
name|udafAttrs
operator|.
name|udafName
argument_list|)
condition|?
literal|true
else|:
literal|false
argument_list|)
expr_stmt|;
name|gbInfo
operator|.
name|udafAttrs
operator|.
name|add
argument_list|(
name|udafAttrs
argument_list|)
expr_stmt|;
block|}
comment|// 4. Gather GB Memory threshold
name|gbInfo
operator|.
name|groupByMemoryUsage
operator|=
name|HiveConf
operator|.
name|getFloatVar
argument_list|(
name|hc
argument_list|,
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVEMAPAGGRHASHMEMORY
argument_list|)
expr_stmt|;
name|gbInfo
operator|.
name|memoryThreshold
operator|=
name|HiveConf
operator|.
name|getFloatVar
argument_list|(
name|hc
argument_list|,
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVEMAPAGGRMEMORYTHRESHOLD
argument_list|)
expr_stmt|;
comment|// 5. Gather GB Physical pipeline (based on user config& Grping Sets size)
name|gbInfo
operator|.
name|gbPhysicalPipelineMode
operator|=
name|getAggOPMode
argument_list|(
name|hc
argument_list|,
name|gbInfo
argument_list|)
expr_stmt|;
return|return
name|gbInfo
return|;
block|}
specifier|static
name|OpAttr
name|translateGB
parameter_list|(
name|OpAttr
name|inputOpAf
parameter_list|,
name|HiveAggregate
name|aggRel
parameter_list|,
name|HiveConf
name|hc
parameter_list|)
throws|throws
name|SemanticException
block|{
name|OpAttr
name|translatedGBOpAttr
init|=
literal|null
decl_stmt|;
name|GBInfo
name|gbInfo
init|=
name|getGBInfo
argument_list|(
name|aggRel
argument_list|,
name|inputOpAf
argument_list|,
name|hc
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|gbInfo
operator|.
name|gbPhysicalPipelineMode
condition|)
block|{
case|case
name|MAP_SIDE_GB_NO_SKEW_NO_ADD_MR_JOB
case|:
name|translatedGBOpAttr
operator|=
name|genMapSideGBNoSkewNoAddMRJob
argument_list|(
name|inputOpAf
argument_list|,
name|aggRel
argument_list|,
name|gbInfo
argument_list|)
expr_stmt|;
break|break;
case|case
name|MAP_SIDE_GB_NO_SKEW_ADD_MR_JOB
case|:
name|translatedGBOpAttr
operator|=
name|genMapSideGBNoSkewAddMRJob
argument_list|(
name|inputOpAf
argument_list|,
name|aggRel
argument_list|,
name|gbInfo
argument_list|)
expr_stmt|;
break|break;
case|case
name|MAP_SIDE_GB_SKEW_GBKEYS_OR_DIST_UDAF_PRESENT
case|:
name|translatedGBOpAttr
operator|=
name|genMapSideGBSkewGBKeysOrDistUDAFPresent
argument_list|(
name|inputOpAf
argument_list|,
name|aggRel
argument_list|,
name|gbInfo
argument_list|)
expr_stmt|;
break|break;
case|case
name|MAP_SIDE_GB_SKEW_GBKEYS_AND_DIST_UDAF_NOT_PRESENT
case|:
name|translatedGBOpAttr
operator|=
name|genMapSideGBSkewGBKeysAndDistUDAFNotPresent
argument_list|(
name|inputOpAf
argument_list|,
name|aggRel
argument_list|,
name|gbInfo
argument_list|)
expr_stmt|;
break|break;
case|case
name|NO_MAP_SIDE_GB_NO_SKEW
case|:
name|translatedGBOpAttr
operator|=
name|genNoMapSideGBNoSkew
argument_list|(
name|inputOpAf
argument_list|,
name|aggRel
argument_list|,
name|gbInfo
argument_list|)
expr_stmt|;
break|break;
case|case
name|NO_MAP_SIDE_GB_SKEW
case|:
name|translatedGBOpAttr
operator|=
name|genNoMapSideGBSkew
argument_list|(
name|inputOpAf
argument_list|,
name|aggRel
argument_list|,
name|gbInfo
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
name|translatedGBOpAttr
return|;
block|}
comment|/**    * GB-RS-GB1    *    * Construct GB-RS-GB Pipe line. User has enabled Map Side GB, specified no    * skew and Grp Set is below the threshold.    *    * @param inputOpAf    * @param aggRel    * @param gbInfo    * @return    * @throws SemanticException    */
specifier|private
specifier|static
name|OpAttr
name|genMapSideGBNoSkewNoAddMRJob
parameter_list|(
name|OpAttr
name|inputOpAf
parameter_list|,
name|HiveAggregate
name|aggRel
parameter_list|,
name|GBInfo
name|gbInfo
parameter_list|)
throws|throws
name|SemanticException
block|{
name|OpAttr
name|mapSideGB
init|=
literal|null
decl_stmt|;
name|OpAttr
name|mapSideRS
init|=
literal|null
decl_stmt|;
name|OpAttr
name|reduceSideGB
init|=
literal|null
decl_stmt|;
comment|// 1. Insert MapSide GB
name|mapSideGB
operator|=
name|genMapSideGB
argument_list|(
name|inputOpAf
argument_list|,
name|gbInfo
argument_list|)
expr_stmt|;
comment|// 2. Insert MapSide RS
name|mapSideRS
operator|=
name|genMapSideGBRS
argument_list|(
name|mapSideGB
argument_list|,
name|gbInfo
argument_list|)
expr_stmt|;
comment|// 3. Insert ReduceSide GB
name|reduceSideGB
operator|=
name|genReduceSideGB1
argument_list|(
name|mapSideRS
argument_list|,
name|gbInfo
argument_list|,
literal|false
argument_list|,
literal|false
argument_list|,
name|GroupByDesc
operator|.
name|Mode
operator|.
name|MERGEPARTIAL
argument_list|)
expr_stmt|;
return|return
name|reduceSideGB
return|;
block|}
comment|/**    * GB-RS-GB1-RS-GB2    */
specifier|private
specifier|static
name|OpAttr
name|genGBRSGBRSGBOpPipeLine
parameter_list|(
name|OpAttr
name|inputOpAf
parameter_list|,
name|HiveAggregate
name|aggRel
parameter_list|,
name|GBInfo
name|gbInfo
parameter_list|)
throws|throws
name|SemanticException
block|{
name|OpAttr
name|mapSideGB
init|=
literal|null
decl_stmt|;
name|OpAttr
name|mapSideRS
init|=
literal|null
decl_stmt|;
name|OpAttr
name|reduceSideGB1
init|=
literal|null
decl_stmt|;
name|OpAttr
name|reduceSideRS
init|=
literal|null
decl_stmt|;
name|OpAttr
name|reduceSideGB2
init|=
literal|null
decl_stmt|;
comment|// 1. Insert MapSide GB
name|mapSideGB
operator|=
name|genMapSideGB
argument_list|(
name|inputOpAf
argument_list|,
name|gbInfo
argument_list|)
expr_stmt|;
comment|// 2. Insert MapSide RS
name|mapSideRS
operator|=
name|genMapSideGBRS
argument_list|(
name|mapSideGB
argument_list|,
name|gbInfo
argument_list|)
expr_stmt|;
comment|// 3. Insert ReduceSide GB1
name|boolean
name|computeGrpSet
init|=
operator|(
name|gbInfo
operator|.
name|gbPhysicalPipelineMode
operator|==
name|HIVEGBPHYSICALMODE
operator|.
name|MAP_SIDE_GB_SKEW_GBKEYS_OR_DIST_UDAF_PRESENT
operator|)
condition|?
literal|false
else|:
literal|true
decl_stmt|;
name|reduceSideGB1
operator|=
name|genReduceSideGB1
argument_list|(
name|mapSideRS
argument_list|,
name|gbInfo
argument_list|,
name|computeGrpSet
argument_list|,
literal|false
argument_list|,
name|GroupByDesc
operator|.
name|Mode
operator|.
name|PARTIALS
argument_list|)
expr_stmt|;
comment|// 4. Insert RS on reduce side with Reduce side GB as input
name|reduceSideRS
operator|=
name|genReduceGBRS
argument_list|(
name|reduceSideGB1
argument_list|,
name|gbInfo
argument_list|)
expr_stmt|;
comment|// 5. Insert ReduceSide GB2
name|reduceSideGB2
operator|=
name|genReduceSideGB2
argument_list|(
name|reduceSideRS
argument_list|,
name|gbInfo
argument_list|)
expr_stmt|;
return|return
name|reduceSideGB2
return|;
block|}
comment|/**    * GB-RS-GB1-RS-GB2    *    * @param inputOpAf    * @param aggRel    * @param gbInfo    * @return    * @throws SemanticException    */
specifier|private
specifier|static
name|OpAttr
name|genMapSideGBNoSkewAddMRJob
parameter_list|(
name|OpAttr
name|inputOpAf
parameter_list|,
name|HiveAggregate
name|aggRel
parameter_list|,
name|GBInfo
name|gbInfo
parameter_list|)
throws|throws
name|SemanticException
block|{
comment|// 1. Sanity check
if|if
condition|(
name|gbInfo
operator|.
name|containsDistinctAggr
condition|)
block|{
name|String
name|errorMsg
init|=
literal|"The number of rows per input row due to grouping sets is "
operator|+
name|gbInfo
operator|.
name|grpSets
operator|.
name|size
argument_list|()
decl_stmt|;
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|HIVE_GROUPING_SETS_THRESHOLD_NOT_ALLOWED_WITH_DISTINCTS
operator|.
name|getMsg
argument_list|(
name|errorMsg
argument_list|)
argument_list|)
throw|;
block|}
comment|// 2. Gen GB-RS-GB-RS-GB pipeline
return|return
name|genGBRSGBRSGBOpPipeLine
argument_list|(
name|inputOpAf
argument_list|,
name|aggRel
argument_list|,
name|gbInfo
argument_list|)
return|;
block|}
comment|/**    * GB-RS-GB1-RS-GB2    *    * @param inputOpAf    * @param aggRel    * @param gbInfo    * @return    * @throws SemanticException    */
specifier|private
specifier|static
name|OpAttr
name|genMapSideGBSkewGBKeysOrDistUDAFPresent
parameter_list|(
name|OpAttr
name|inputOpAf
parameter_list|,
name|HiveAggregate
name|aggRel
parameter_list|,
name|GBInfo
name|gbInfo
parameter_list|)
throws|throws
name|SemanticException
block|{
comment|// 1. Sanity check
if|if
condition|(
name|gbInfo
operator|.
name|grpSetRqrAdditionalMRJob
condition|)
block|{
name|String
name|errorMsg
init|=
literal|"The number of rows per input row due to grouping sets is "
operator|+
name|gbInfo
operator|.
name|grpSets
operator|.
name|size
argument_list|()
decl_stmt|;
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|HIVE_GROUPING_SETS_THRESHOLD_NOT_ALLOWED_WITH_SKEW
operator|.
name|getMsg
argument_list|(
name|errorMsg
argument_list|)
argument_list|)
throw|;
block|}
comment|// 2. Gen GB-RS-GB-RS-GB pipeline
return|return
name|genGBRSGBRSGBOpPipeLine
argument_list|(
name|inputOpAf
argument_list|,
name|aggRel
argument_list|,
name|gbInfo
argument_list|)
return|;
block|}
comment|/**    * GB-RS-GB2    *    * @param inputOpAf    * @param aggRel    * @param gbInfo    * @return    * @throws SemanticException    */
specifier|private
specifier|static
name|OpAttr
name|genMapSideGBSkewGBKeysAndDistUDAFNotPresent
parameter_list|(
name|OpAttr
name|inputOpAf
parameter_list|,
name|HiveAggregate
name|aggRel
parameter_list|,
name|GBInfo
name|gbInfo
parameter_list|)
throws|throws
name|SemanticException
block|{
name|OpAttr
name|mapSideGB
init|=
literal|null
decl_stmt|;
name|OpAttr
name|mapSideRS
init|=
literal|null
decl_stmt|;
name|OpAttr
name|reduceSideGB2
init|=
literal|null
decl_stmt|;
comment|// 1. Sanity check
if|if
condition|(
name|gbInfo
operator|.
name|grpSetRqrAdditionalMRJob
condition|)
block|{
name|String
name|errorMsg
init|=
literal|"The number of rows per input row due to grouping sets is "
operator|+
name|gbInfo
operator|.
name|grpSets
operator|.
name|size
argument_list|()
decl_stmt|;
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|HIVE_GROUPING_SETS_THRESHOLD_NOT_ALLOWED_WITH_SKEW
operator|.
name|getMsg
argument_list|(
name|errorMsg
argument_list|)
argument_list|)
throw|;
block|}
comment|// 1. Insert MapSide GB
name|mapSideGB
operator|=
name|genMapSideGB
argument_list|(
name|inputOpAf
argument_list|,
name|gbInfo
argument_list|)
expr_stmt|;
comment|// 2. Insert MapSide RS
name|mapSideRS
operator|=
name|genMapSideGBRS
argument_list|(
name|mapSideGB
argument_list|,
name|gbInfo
argument_list|)
expr_stmt|;
comment|// 3. Insert ReduceSide GB2
name|reduceSideGB2
operator|=
name|genReduceSideGB2
argument_list|(
name|mapSideRS
argument_list|,
name|gbInfo
argument_list|)
expr_stmt|;
return|return
name|reduceSideGB2
return|;
block|}
comment|/**    * RS-Gb1    *    * @param inputOpAf    * @param aggRel    * @param gbInfo    * @return    * @throws SemanticException    */
specifier|private
specifier|static
name|OpAttr
name|genNoMapSideGBNoSkew
parameter_list|(
name|OpAttr
name|inputOpAf
parameter_list|,
name|HiveAggregate
name|aggRel
parameter_list|,
name|GBInfo
name|gbInfo
parameter_list|)
throws|throws
name|SemanticException
block|{
name|OpAttr
name|mapSideRS
init|=
literal|null
decl_stmt|;
name|OpAttr
name|reduceSideGB1NoMapGB
init|=
literal|null
decl_stmt|;
comment|// 1. Insert MapSide RS
name|mapSideRS
operator|=
name|genMapSideRS
argument_list|(
name|inputOpAf
argument_list|,
name|gbInfo
argument_list|)
expr_stmt|;
comment|// 2. Insert ReduceSide GB
name|reduceSideGB1NoMapGB
operator|=
name|genReduceSideGB1NoMapGB
argument_list|(
name|mapSideRS
argument_list|,
name|gbInfo
argument_list|,
name|GroupByDesc
operator|.
name|Mode
operator|.
name|COMPLETE
argument_list|)
expr_stmt|;
return|return
name|reduceSideGB1NoMapGB
return|;
block|}
comment|/**    * RS-GB1-RS-GB2    *    * @param inputOpAf    * @param aggRel    * @param gbInfo    * @return    * @throws SemanticException    */
specifier|private
specifier|static
name|OpAttr
name|genNoMapSideGBSkew
parameter_list|(
name|OpAttr
name|inputOpAf
parameter_list|,
name|HiveAggregate
name|aggRel
parameter_list|,
name|GBInfo
name|gbInfo
parameter_list|)
throws|throws
name|SemanticException
block|{
name|OpAttr
name|mapSideRS
init|=
literal|null
decl_stmt|;
name|OpAttr
name|reduceSideGB1NoMapGB
init|=
literal|null
decl_stmt|;
name|OpAttr
name|reduceSideRS
init|=
literal|null
decl_stmt|;
name|OpAttr
name|reduceSideGB2
init|=
literal|null
decl_stmt|;
comment|// 1. Insert MapSide RS
name|mapSideRS
operator|=
name|genMapSideRS
argument_list|(
name|inputOpAf
argument_list|,
name|gbInfo
argument_list|)
expr_stmt|;
comment|// 2. Insert ReduceSide GB
name|reduceSideGB1NoMapGB
operator|=
name|genReduceSideGB1NoMapGB
argument_list|(
name|mapSideRS
argument_list|,
name|gbInfo
argument_list|,
name|GroupByDesc
operator|.
name|Mode
operator|.
name|PARTIAL1
argument_list|)
expr_stmt|;
comment|// 3. Insert RS on reduce side with Reduce side GB as input
name|reduceSideRS
operator|=
name|genReduceGBRS
argument_list|(
name|reduceSideGB1NoMapGB
argument_list|,
name|gbInfo
argument_list|)
expr_stmt|;
comment|// 4. Insert ReduceSide GB2
name|reduceSideGB2
operator|=
name|genReduceSideGB2
argument_list|(
name|reduceSideRS
argument_list|,
name|gbInfo
argument_list|)
expr_stmt|;
return|return
name|reduceSideGB2
return|;
block|}
specifier|private
specifier|static
name|int
name|getParallelismForReduceSideRS
parameter_list|(
name|GBInfo
name|gbInfo
parameter_list|)
block|{
name|int
name|degreeOfParallelism
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|gbInfo
operator|.
name|gbPhysicalPipelineMode
condition|)
block|{
case|case
name|MAP_SIDE_GB_NO_SKEW_ADD_MR_JOB
case|:
case|case
name|MAP_SIDE_GB_SKEW_GBKEYS_OR_DIST_UDAF_PRESENT
case|:
case|case
name|NO_MAP_SIDE_GB_SKEW
case|:
if|if
condition|(
name|gbInfo
operator|.
name|gbKeys
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|degreeOfParallelism
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|degreeOfParallelism
operator|=
operator|-
literal|1
expr_stmt|;
block|}
break|break;
default|default:
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Unable to determine Reducer Parallelism - Invalid Physical Mode: "
operator|+
name|gbInfo
operator|.
name|gbPhysicalPipelineMode
argument_list|)
throw|;
block|}
return|return
name|degreeOfParallelism
return|;
block|}
specifier|private
specifier|static
name|int
name|getParallelismForMapSideRS
parameter_list|(
name|GBInfo
name|gbInfo
parameter_list|)
block|{
name|int
name|degreeOfParallelism
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|gbInfo
operator|.
name|gbPhysicalPipelineMode
condition|)
block|{
case|case
name|MAP_SIDE_GB_NO_SKEW_NO_ADD_MR_JOB
case|:
case|case
name|MAP_SIDE_GB_NO_SKEW_ADD_MR_JOB
case|:
case|case
name|NO_MAP_SIDE_GB_NO_SKEW
case|:
if|if
condition|(
name|gbInfo
operator|.
name|gbKeys
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|degreeOfParallelism
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|degreeOfParallelism
operator|=
operator|-
literal|1
expr_stmt|;
block|}
break|break;
case|case
name|NO_MAP_SIDE_GB_SKEW
case|:
case|case
name|MAP_SIDE_GB_SKEW_GBKEYS_OR_DIST_UDAF_PRESENT
case|:
name|degreeOfParallelism
operator|=
operator|-
literal|1
expr_stmt|;
break|break;
case|case
name|MAP_SIDE_GB_SKEW_GBKEYS_AND_DIST_UDAF_NOT_PRESENT
case|:
name|degreeOfParallelism
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Unable to determine Reducer Parallelism - Invalid Physical Mode: "
operator|+
name|gbInfo
operator|.
name|gbPhysicalPipelineMode
argument_list|)
throw|;
block|}
return|return
name|degreeOfParallelism
return|;
block|}
specifier|private
specifier|static
name|int
name|getNumPartFieldsForReduceSideRS
parameter_list|(
name|GBInfo
name|gbInfo
parameter_list|)
block|{
name|int
name|numPartFields
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|gbInfo
operator|.
name|gbPhysicalPipelineMode
condition|)
block|{
case|case
name|MAP_SIDE_GB_NO_SKEW_ADD_MR_JOB
case|:
name|numPartFields
operator|=
name|gbInfo
operator|.
name|gbKeys
operator|.
name|size
argument_list|()
operator|+
literal|1
expr_stmt|;
break|break;
case|case
name|MAP_SIDE_GB_SKEW_GBKEYS_OR_DIST_UDAF_PRESENT
case|:
case|case
name|NO_MAP_SIDE_GB_SKEW
case|:
name|numPartFields
operator|=
name|gbInfo
operator|.
name|gbKeys
operator|.
name|size
argument_list|()
expr_stmt|;
break|break;
default|default:
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Unable to determine Number of Partition Fields - Invalid Physical Mode: "
operator|+
name|gbInfo
operator|.
name|gbPhysicalPipelineMode
argument_list|)
throw|;
block|}
return|return
name|numPartFields
return|;
block|}
specifier|private
specifier|static
name|int
name|getNumPartFieldsForMapSideRS
parameter_list|(
name|GBInfo
name|gbInfo
parameter_list|)
block|{
name|int
name|numPartFields
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|gbInfo
operator|.
name|gbPhysicalPipelineMode
condition|)
block|{
case|case
name|MAP_SIDE_GB_NO_SKEW_NO_ADD_MR_JOB
case|:
case|case
name|MAP_SIDE_GB_NO_SKEW_ADD_MR_JOB
case|:
case|case
name|MAP_SIDE_GB_SKEW_GBKEYS_AND_DIST_UDAF_NOT_PRESENT
case|:
case|case
name|NO_MAP_SIDE_GB_NO_SKEW
case|:
name|numPartFields
operator|+=
name|gbInfo
operator|.
name|gbKeys
operator|.
name|size
argument_list|()
expr_stmt|;
break|break;
case|case
name|NO_MAP_SIDE_GB_SKEW
case|:
case|case
name|MAP_SIDE_GB_SKEW_GBKEYS_OR_DIST_UDAF_PRESENT
case|:
if|if
condition|(
name|gbInfo
operator|.
name|containsDistinctAggr
condition|)
block|{
name|numPartFields
operator|=
name|Integer
operator|.
name|MAX_VALUE
expr_stmt|;
block|}
else|else
block|{
name|numPartFields
operator|=
operator|-
literal|1
expr_stmt|;
block|}
break|break;
default|default:
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Unable to determine Number of Partition Fields - Invalid Physical Mode: "
operator|+
name|gbInfo
operator|.
name|gbPhysicalPipelineMode
argument_list|)
throw|;
block|}
return|return
name|numPartFields
return|;
block|}
specifier|private
specifier|static
name|boolean
name|inclGrpSetInReduceSide
parameter_list|(
name|GBInfo
name|gbInfo
parameter_list|)
block|{
name|boolean
name|inclGrpSet
init|=
literal|false
decl_stmt|;
if|if
condition|(
name|gbInfo
operator|.
name|grpSets
operator|.
name|size
argument_list|()
operator|>
literal|0
operator|&&
operator|(
name|gbInfo
operator|.
name|gbPhysicalPipelineMode
operator|==
name|HIVEGBPHYSICALMODE
operator|.
name|MAP_SIDE_GB_NO_SKEW_ADD_MR_JOB
operator|||
name|gbInfo
operator|.
name|gbPhysicalPipelineMode
operator|==
name|HIVEGBPHYSICALMODE
operator|.
name|MAP_SIDE_GB_SKEW_GBKEYS_OR_DIST_UDAF_PRESENT
operator|)
condition|)
block|{
name|inclGrpSet
operator|=
literal|true
expr_stmt|;
block|}
return|return
name|inclGrpSet
return|;
block|}
specifier|private
specifier|static
name|boolean
name|inclGrpSetInMapSide
parameter_list|(
name|GBInfo
name|gbInfo
parameter_list|)
block|{
name|boolean
name|inclGrpSet
init|=
literal|false
decl_stmt|;
if|if
condition|(
name|gbInfo
operator|.
name|grpSets
operator|.
name|size
argument_list|()
operator|>
literal|0
operator|&&
operator|(
operator|(
name|gbInfo
operator|.
name|gbPhysicalPipelineMode
operator|==
name|HIVEGBPHYSICALMODE
operator|.
name|MAP_SIDE_GB_NO_SKEW_NO_ADD_MR_JOB
operator|)
operator|||
name|gbInfo
operator|.
name|gbPhysicalPipelineMode
operator|==
name|HIVEGBPHYSICALMODE
operator|.
name|MAP_SIDE_GB_SKEW_GBKEYS_OR_DIST_UDAF_PRESENT
operator|)
condition|)
block|{
name|inclGrpSet
operator|=
literal|true
expr_stmt|;
block|}
return|return
name|inclGrpSet
return|;
block|}
specifier|private
specifier|static
name|OpAttr
name|genReduceGBRS
parameter_list|(
name|OpAttr
name|inputOpAf
parameter_list|,
name|GBInfo
name|gbInfo
parameter_list|)
throws|throws
name|SemanticException
block|{
name|Map
argument_list|<
name|String
argument_list|,
name|ExprNodeDesc
argument_list|>
name|colExprMap
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|ExprNodeDesc
argument_list|>
argument_list|()
decl_stmt|;
name|ArrayList
argument_list|<
name|String
argument_list|>
name|outputColumnNames
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
name|ArrayList
argument_list|<
name|ColumnInfo
argument_list|>
name|colInfoLst
init|=
operator|new
name|ArrayList
argument_list|<
name|ColumnInfo
argument_list|>
argument_list|()
decl_stmt|;
name|GroupByOperator
name|reduceSideGB1
init|=
operator|(
name|GroupByOperator
operator|)
name|inputOpAf
operator|.
name|inputs
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|ColumnInfo
argument_list|>
name|gb1ColInfoLst
init|=
name|reduceSideGB1
operator|.
name|getSchema
argument_list|()
operator|.
name|getSignature
argument_list|()
decl_stmt|;
name|ArrayList
argument_list|<
name|ExprNodeDesc
argument_list|>
name|reduceKeys
init|=
name|getReduceKeysForRS
argument_list|(
name|reduceSideGB1
argument_list|,
literal|0
argument_list|,
name|gbInfo
operator|.
name|gbKeys
operator|.
name|size
argument_list|()
operator|-
literal|1
argument_list|,
name|outputColumnNames
argument_list|,
literal|false
argument_list|,
name|colInfoLst
argument_list|,
name|colExprMap
argument_list|,
literal|true
argument_list|,
literal|true
argument_list|)
decl_stmt|;
if|if
condition|(
name|inclGrpSetInReduceSide
argument_list|(
name|gbInfo
argument_list|)
condition|)
block|{
name|addGrpSetCol
argument_list|(
literal|false
argument_list|,
name|gb1ColInfoLst
operator|.
name|get
argument_list|(
name|reduceKeys
operator|.
name|size
argument_list|()
argument_list|)
operator|.
name|getInternalName
argument_list|()
argument_list|,
literal|true
argument_list|,
name|reduceKeys
argument_list|,
name|outputColumnNames
argument_list|,
name|colInfoLst
argument_list|,
name|colExprMap
argument_list|)
expr_stmt|;
block|}
name|ArrayList
argument_list|<
name|ExprNodeDesc
argument_list|>
name|reduceValues
init|=
name|getValueKeysForRS
argument_list|(
name|reduceSideGB1
argument_list|,
name|reduceSideGB1
operator|.
name|getConf
argument_list|()
operator|.
name|getKeys
argument_list|()
operator|.
name|size
argument_list|()
argument_list|,
name|outputColumnNames
argument_list|,
name|colInfoLst
argument_list|,
name|colExprMap
argument_list|,
literal|true
argument_list|,
literal|true
argument_list|)
decl_stmt|;
name|ReduceSinkOperator
name|rsOp
init|=
operator|(
name|ReduceSinkOperator
operator|)
name|OperatorFactory
operator|.
name|getAndMakeChild
argument_list|(
name|PlanUtils
operator|.
name|getReduceSinkDesc
argument_list|(
name|reduceKeys
argument_list|,
name|reduceValues
argument_list|,
name|outputColumnNames
argument_list|,
literal|true
argument_list|,
operator|-
literal|1
argument_list|,
name|getNumPartFieldsForReduceSideRS
argument_list|(
name|gbInfo
argument_list|)
argument_list|,
name|getParallelismForReduceSideRS
argument_list|(
name|gbInfo
argument_list|)
argument_list|,
name|AcidUtils
operator|.
name|Operation
operator|.
name|NOT_ACID
argument_list|)
argument_list|,
operator|new
name|RowSchema
argument_list|(
name|colInfoLst
argument_list|)
argument_list|,
name|reduceSideGB1
argument_list|)
decl_stmt|;
name|rsOp
operator|.
name|setColumnExprMap
argument_list|(
name|colExprMap
argument_list|)
expr_stmt|;
return|return
operator|new
name|OpAttr
argument_list|(
literal|""
argument_list|,
operator|new
name|HashSet
argument_list|<
name|Integer
argument_list|>
argument_list|()
argument_list|,
name|rsOp
argument_list|)
return|;
block|}
specifier|private
specifier|static
name|OpAttr
name|genMapSideGBRS
parameter_list|(
name|OpAttr
name|inputOpAf
parameter_list|,
name|GBInfo
name|gbInfo
parameter_list|)
throws|throws
name|SemanticException
block|{
name|Map
argument_list|<
name|String
argument_list|,
name|ExprNodeDesc
argument_list|>
name|colExprMap
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|ExprNodeDesc
argument_list|>
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|outputKeyColumnNames
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|outputValueColumnNames
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
name|ArrayList
argument_list|<
name|ColumnInfo
argument_list|>
name|colInfoLst
init|=
operator|new
name|ArrayList
argument_list|<
name|ColumnInfo
argument_list|>
argument_list|()
decl_stmt|;
name|GroupByOperator
name|mapGB
init|=
operator|(
name|GroupByOperator
operator|)
name|inputOpAf
operator|.
name|inputs
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|int
name|distColStartIndx
init|=
name|gbInfo
operator|.
name|gbKeys
operator|.
name|size
argument_list|()
operator|+
operator|(
name|gbInfo
operator|.
name|grpSets
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|?
literal|1
else|:
literal|0
operator|)
decl_stmt|;
name|ArrayList
argument_list|<
name|ExprNodeDesc
argument_list|>
name|reduceKeys
init|=
name|getReduceKeysForRS
argument_list|(
name|mapGB
argument_list|,
literal|0
argument_list|,
name|gbInfo
operator|.
name|gbKeys
operator|.
name|size
argument_list|()
operator|-
literal|1
argument_list|,
name|outputKeyColumnNames
argument_list|,
literal|false
argument_list|,
name|colInfoLst
argument_list|,
name|colExprMap
argument_list|,
literal|false
argument_list|,
literal|false
argument_list|)
decl_stmt|;
name|int
name|keyLength
init|=
name|reduceKeys
operator|.
name|size
argument_list|()
decl_stmt|;
if|if
condition|(
name|inclGrpSetInMapSide
argument_list|(
name|gbInfo
argument_list|)
condition|)
block|{
name|addGrpSetCol
argument_list|(
literal|false
argument_list|,
name|SemanticAnalyzer
operator|.
name|getColumnInternalName
argument_list|(
name|reduceKeys
operator|.
name|size
argument_list|()
argument_list|)
argument_list|,
literal|true
argument_list|,
name|reduceKeys
argument_list|,
name|outputKeyColumnNames
argument_list|,
name|colInfoLst
argument_list|,
name|colExprMap
argument_list|)
expr_stmt|;
name|keyLength
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|mapGB
operator|.
name|getConf
argument_list|()
operator|.
name|getKeys
argument_list|()
operator|.
name|size
argument_list|()
operator|>
name|reduceKeys
operator|.
name|size
argument_list|()
condition|)
block|{
comment|// NOTE: All dist cols have single output col name;
name|reduceKeys
operator|.
name|addAll
argument_list|(
name|getReduceKeysForRS
argument_list|(
name|mapGB
argument_list|,
name|reduceKeys
operator|.
name|size
argument_list|()
argument_list|,
name|mapGB
operator|.
name|getConf
argument_list|()
operator|.
name|getKeys
argument_list|()
operator|.
name|size
argument_list|()
operator|-
literal|1
argument_list|,
name|outputKeyColumnNames
argument_list|,
literal|true
argument_list|,
name|colInfoLst
argument_list|,
name|colExprMap
argument_list|,
literal|false
argument_list|,
literal|false
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|ArrayList
argument_list|<
name|ExprNodeDesc
argument_list|>
name|reduceValues
init|=
name|getValueKeysForRS
argument_list|(
name|mapGB
argument_list|,
name|mapGB
operator|.
name|getConf
argument_list|()
operator|.
name|getKeys
argument_list|()
operator|.
name|size
argument_list|()
argument_list|,
name|outputValueColumnNames
argument_list|,
name|colInfoLst
argument_list|,
name|colExprMap
argument_list|,
literal|false
argument_list|,
literal|false
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|List
argument_list|<
name|Integer
argument_list|>
argument_list|>
name|distinctColIndices
init|=
name|getDistColIndices
argument_list|(
name|gbInfo
argument_list|,
name|distColStartIndx
argument_list|)
decl_stmt|;
name|ReduceSinkOperator
name|rsOp
init|=
operator|(
name|ReduceSinkOperator
operator|)
name|OperatorFactory
operator|.
name|getAndMakeChild
argument_list|(
name|PlanUtils
operator|.
name|getReduceSinkDesc
argument_list|(
name|reduceKeys
argument_list|,
name|keyLength
argument_list|,
name|reduceValues
argument_list|,
name|distinctColIndices
argument_list|,
name|outputKeyColumnNames
argument_list|,
name|outputValueColumnNames
argument_list|,
literal|true
argument_list|,
operator|-
literal|1
argument_list|,
name|getNumPartFieldsForMapSideRS
argument_list|(
name|gbInfo
argument_list|)
argument_list|,
name|getParallelismForMapSideRS
argument_list|(
name|gbInfo
argument_list|)
argument_list|,
name|AcidUtils
operator|.
name|Operation
operator|.
name|NOT_ACID
argument_list|)
argument_list|,
operator|new
name|RowSchema
argument_list|(
name|colInfoLst
argument_list|)
argument_list|,
name|mapGB
argument_list|)
decl_stmt|;
name|rsOp
operator|.
name|setColumnExprMap
argument_list|(
name|colExprMap
argument_list|)
expr_stmt|;
return|return
operator|new
name|OpAttr
argument_list|(
literal|""
argument_list|,
operator|new
name|HashSet
argument_list|<
name|Integer
argument_list|>
argument_list|()
argument_list|,
name|rsOp
argument_list|)
return|;
block|}
specifier|private
specifier|static
name|OpAttr
name|genMapSideRS
parameter_list|(
name|OpAttr
name|inputOpAf
parameter_list|,
name|GBInfo
name|gbInfo
parameter_list|)
throws|throws
name|SemanticException
block|{
name|Map
argument_list|<
name|String
argument_list|,
name|ExprNodeDesc
argument_list|>
name|colExprMap
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|ExprNodeDesc
argument_list|>
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|outputKeyColumnNames
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|outputValueColumnNames
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
name|ArrayList
argument_list|<
name|ColumnInfo
argument_list|>
name|colInfoLst
init|=
operator|new
name|ArrayList
argument_list|<
name|ColumnInfo
argument_list|>
argument_list|()
decl_stmt|;
name|int
name|distColStartIndx
init|=
name|gbInfo
operator|.
name|gbKeys
operator|.
name|size
argument_list|()
operator|+
operator|(
name|gbInfo
operator|.
name|grpSets
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|?
literal|1
else|:
literal|0
operator|)
decl_stmt|;
name|String
name|outputColName
decl_stmt|;
comment|// 1. Add GB Keys to reduce keys
name|ArrayList
argument_list|<
name|ExprNodeDesc
argument_list|>
name|reduceKeys
init|=
name|getReduceKeysForRS
argument_list|(
name|inputOpAf
operator|.
name|inputs
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|,
name|gbInfo
operator|.
name|gbKeys
operator|.
name|size
argument_list|()
operator|-
literal|1
argument_list|,
name|outputKeyColumnNames
argument_list|,
literal|false
argument_list|,
name|colInfoLst
argument_list|,
name|colExprMap
argument_list|,
literal|false
argument_list|,
literal|false
argument_list|)
decl_stmt|;
name|int
name|keyLength
init|=
name|reduceKeys
operator|.
name|size
argument_list|()
decl_stmt|;
comment|// 2. Add Dist UDAF args to reduce keys
if|if
condition|(
name|gbInfo
operator|.
name|containsDistinctAggr
condition|)
block|{
comment|// TODO: Why is this needed (doesn't represent any cols)
name|String
name|udafName
init|=
name|SemanticAnalyzer
operator|.
name|getColumnInternalName
argument_list|(
name|reduceKeys
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
name|outputKeyColumnNames
operator|.
name|add
argument_list|(
name|udafName
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|gbInfo
operator|.
name|distExprNodes
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|reduceKeys
operator|.
name|add
argument_list|(
name|gbInfo
operator|.
name|distExprNodes
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|outputColName
operator|=
name|SemanticAnalyzer
operator|.
name|getColumnInternalName
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|String
name|field
init|=
name|Utilities
operator|.
name|ReduceField
operator|.
name|KEY
operator|.
name|toString
argument_list|()
operator|+
literal|"."
operator|+
name|udafName
operator|+
literal|":"
operator|+
name|i
operator|+
literal|"."
operator|+
name|outputColName
decl_stmt|;
name|ColumnInfo
name|colInfo
init|=
operator|new
name|ColumnInfo
argument_list|(
name|field
argument_list|,
name|gbInfo
operator|.
name|distExprNodes
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|getTypeInfo
argument_list|()
argument_list|,
literal|null
argument_list|,
literal|false
argument_list|)
decl_stmt|;
name|colInfoLst
operator|.
name|add
argument_list|(
name|colInfo
argument_list|)
expr_stmt|;
name|colExprMap
operator|.
name|put
argument_list|(
name|field
argument_list|,
name|gbInfo
operator|.
name|distExprNodes
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|// 3. Add UDAF args deduped to reduce values
name|ArrayList
argument_list|<
name|ExprNodeDesc
argument_list|>
name|reduceValues
init|=
operator|new
name|ArrayList
argument_list|<
name|ExprNodeDesc
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|gbInfo
operator|.
name|deDupedNonDistIrefs
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|reduceValues
operator|.
name|add
argument_list|(
name|gbInfo
operator|.
name|deDupedNonDistIrefs
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|outputColName
operator|=
name|SemanticAnalyzer
operator|.
name|getColumnInternalName
argument_list|(
name|reduceValues
operator|.
name|size
argument_list|()
operator|-
literal|1
argument_list|)
expr_stmt|;
name|outputValueColumnNames
operator|.
name|add
argument_list|(
name|outputColName
argument_list|)
expr_stmt|;
name|String
name|field
init|=
name|Utilities
operator|.
name|ReduceField
operator|.
name|VALUE
operator|.
name|toString
argument_list|()
operator|+
literal|"."
operator|+
name|outputColName
decl_stmt|;
name|colInfoLst
operator|.
name|add
argument_list|(
operator|new
name|ColumnInfo
argument_list|(
name|field
argument_list|,
name|reduceValues
operator|.
name|get
argument_list|(
name|reduceValues
operator|.
name|size
argument_list|()
operator|-
literal|1
argument_list|)
operator|.
name|getTypeInfo
argument_list|()
argument_list|,
literal|null
argument_list|,
literal|false
argument_list|)
argument_list|)
expr_stmt|;
name|colExprMap
operator|.
name|put
argument_list|(
name|field
argument_list|,
name|reduceValues
operator|.
name|get
argument_list|(
name|reduceValues
operator|.
name|size
argument_list|()
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// 4. Gen RS
name|ReduceSinkOperator
name|rsOp
init|=
operator|(
name|ReduceSinkOperator
operator|)
name|OperatorFactory
operator|.
name|getAndMakeChild
argument_list|(
name|PlanUtils
operator|.
name|getReduceSinkDesc
argument_list|(
name|reduceKeys
argument_list|,
name|keyLength
argument_list|,
name|reduceValues
argument_list|,
name|getDistColIndices
argument_list|(
name|gbInfo
argument_list|,
name|distColStartIndx
argument_list|)
argument_list|,
name|outputKeyColumnNames
argument_list|,
name|outputValueColumnNames
argument_list|,
literal|true
argument_list|,
operator|-
literal|1
argument_list|,
name|getNumPartFieldsForMapSideRS
argument_list|(
name|gbInfo
argument_list|)
argument_list|,
name|getParallelismForMapSideRS
argument_list|(
name|gbInfo
argument_list|)
argument_list|,
name|AcidUtils
operator|.
name|Operation
operator|.
name|NOT_ACID
argument_list|)
argument_list|,
operator|new
name|RowSchema
argument_list|(
name|colInfoLst
argument_list|)
argument_list|,
name|inputOpAf
operator|.
name|inputs
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|rsOp
operator|.
name|setColumnExprMap
argument_list|(
name|colExprMap
argument_list|)
expr_stmt|;
return|return
operator|new
name|OpAttr
argument_list|(
literal|""
argument_list|,
operator|new
name|HashSet
argument_list|<
name|Integer
argument_list|>
argument_list|()
argument_list|,
name|rsOp
argument_list|)
return|;
block|}
specifier|private
specifier|static
name|OpAttr
name|genReduceSideGB2
parameter_list|(
name|OpAttr
name|inputOpAf
parameter_list|,
name|GBInfo
name|gbInfo
parameter_list|)
throws|throws
name|SemanticException
block|{
name|ArrayList
argument_list|<
name|String
argument_list|>
name|outputColNames
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
name|ArrayList
argument_list|<
name|ColumnInfo
argument_list|>
name|colInfoLst
init|=
operator|new
name|ArrayList
argument_list|<
name|ColumnInfo
argument_list|>
argument_list|()
decl_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|ExprNodeDesc
argument_list|>
name|colExprMap
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|ExprNodeDesc
argument_list|>
argument_list|()
decl_stmt|;
name|String
name|colOutputName
init|=
literal|null
decl_stmt|;
name|ReduceSinkOperator
name|rs
init|=
operator|(
name|ReduceSinkOperator
operator|)
name|inputOpAf
operator|.
name|inputs
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|ColumnInfo
argument_list|>
name|rsColInfoLst
init|=
name|rs
operator|.
name|getSchema
argument_list|()
operator|.
name|getSignature
argument_list|()
decl_stmt|;
name|ColumnInfo
name|ci
decl_stmt|;
comment|// 1. Build GB Keys, grouping set starting position
comment|// 1.1 First Add original GB Keys
name|ArrayList
argument_list|<
name|ExprNodeDesc
argument_list|>
name|gbKeys
init|=
name|ExprNodeDescUtils
operator|.
name|genExprNodeDesc
argument_list|(
name|rs
argument_list|,
literal|0
argument_list|,
name|gbInfo
operator|.
name|gbKeys
operator|.
name|size
argument_list|()
operator|-
literal|1
argument_list|,
literal|false
argument_list|,
literal|false
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|gbInfo
operator|.
name|gbKeys
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|ci
operator|=
name|rsColInfoLst
operator|.
name|get
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|colOutputName
operator|=
name|gbInfo
operator|.
name|outputColNames
operator|.
name|get
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|outputColNames
operator|.
name|add
argument_list|(
name|colOutputName
argument_list|)
expr_stmt|;
name|colInfoLst
operator|.
name|add
argument_list|(
operator|new
name|ColumnInfo
argument_list|(
name|colOutputName
argument_list|,
name|ci
operator|.
name|getType
argument_list|()
argument_list|,
literal|""
argument_list|,
literal|false
argument_list|)
argument_list|)
expr_stmt|;
name|colExprMap
operator|.
name|put
argument_list|(
name|colOutputName
argument_list|,
name|gbKeys
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// 1.2 Add GrpSet Col
name|int
name|groupingSetsPosition
init|=
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|inclGrpSetInReduceSide
argument_list|(
name|gbInfo
argument_list|)
operator|&&
name|gbInfo
operator|.
name|grpIdFunctionNeeded
condition|)
block|{
name|groupingSetsPosition
operator|=
name|gbKeys
operator|.
name|size
argument_list|()
expr_stmt|;
name|ExprNodeDesc
name|grpSetColExpr
init|=
operator|new
name|ExprNodeColumnDesc
argument_list|(
name|TypeInfoFactory
operator|.
name|stringTypeInfo
argument_list|,
name|rsColInfoLst
operator|.
name|get
argument_list|(
name|groupingSetsPosition
argument_list|)
operator|.
name|getInternalName
argument_list|()
argument_list|,
literal|null
argument_list|,
literal|false
argument_list|)
decl_stmt|;
name|gbKeys
operator|.
name|add
argument_list|(
name|grpSetColExpr
argument_list|)
expr_stmt|;
name|colOutputName
operator|=
name|gbInfo
operator|.
name|outputColNames
operator|.
name|get
argument_list|(
name|gbInfo
operator|.
name|outputColNames
operator|.
name|size
argument_list|()
operator|-
literal|1
argument_list|)
expr_stmt|;
empty_stmt|;
name|outputColNames
operator|.
name|add
argument_list|(
name|colOutputName
argument_list|)
expr_stmt|;
name|colInfoLst
operator|.
name|add
argument_list|(
operator|new
name|ColumnInfo
argument_list|(
name|colOutputName
argument_list|,
name|TypeInfoFactory
operator|.
name|stringTypeInfo
argument_list|,
literal|null
argument_list|,
literal|true
argument_list|)
argument_list|)
expr_stmt|;
name|colExprMap
operator|.
name|put
argument_list|(
name|colOutputName
argument_list|,
name|grpSetColExpr
argument_list|)
expr_stmt|;
block|}
comment|// 2. Add UDAF
name|UDAFAttrs
name|udafAttr
decl_stmt|;
name|ArrayList
argument_list|<
name|AggregationDesc
argument_list|>
name|aggregations
init|=
operator|new
name|ArrayList
argument_list|<
name|AggregationDesc
argument_list|>
argument_list|()
decl_stmt|;
name|int
name|udafStartPosInGBInfOutputColNames
init|=
name|gbInfo
operator|.
name|grpSets
operator|.
name|isEmpty
argument_list|()
condition|?
name|gbInfo
operator|.
name|gbKeys
operator|.
name|size
argument_list|()
else|:
name|gbInfo
operator|.
name|gbKeys
operator|.
name|size
argument_list|()
operator|*
literal|2
decl_stmt|;
name|int
name|udafStartPosInInputRS
init|=
name|gbInfo
operator|.
name|grpSets
operator|.
name|isEmpty
argument_list|()
condition|?
name|gbInfo
operator|.
name|gbKeys
operator|.
name|size
argument_list|()
else|:
name|gbInfo
operator|.
name|gbKeys
operator|.
name|size
argument_list|()
operator|+
literal|1
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|gbInfo
operator|.
name|udafAttrs
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|udafAttr
operator|=
name|gbInfo
operator|.
name|udafAttrs
operator|.
name|get
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|ArrayList
argument_list|<
name|ExprNodeDesc
argument_list|>
name|aggParameters
init|=
operator|new
name|ArrayList
argument_list|<
name|ExprNodeDesc
argument_list|>
argument_list|()
decl_stmt|;
name|aggParameters
operator|.
name|add
argument_list|(
operator|new
name|ExprNodeColumnDesc
argument_list|(
name|rsColInfoLst
operator|.
name|get
argument_list|(
name|udafStartPosInInputRS
operator|+
name|i
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|colOutputName
operator|=
name|gbInfo
operator|.
name|outputColNames
operator|.
name|get
argument_list|(
name|udafStartPosInGBInfOutputColNames
operator|+
name|i
argument_list|)
expr_stmt|;
name|outputColNames
operator|.
name|add
argument_list|(
name|colOutputName
argument_list|)
expr_stmt|;
name|Mode
name|udafMode
init|=
name|SemanticAnalyzer
operator|.
name|groupByDescModeToUDAFMode
argument_list|(
name|GroupByDesc
operator|.
name|Mode
operator|.
name|FINAL
argument_list|,
name|udafAttr
operator|.
name|isDistinctUDAF
argument_list|)
decl_stmt|;
name|GenericUDAFInfo
name|udaf
init|=
name|SemanticAnalyzer
operator|.
name|getGenericUDAFInfo
argument_list|(
name|udafAttr
operator|.
name|udafEvaluator
argument_list|,
name|udafMode
argument_list|,
name|aggParameters
argument_list|)
decl_stmt|;
name|aggregations
operator|.
name|add
argument_list|(
operator|new
name|AggregationDesc
argument_list|(
name|udafAttr
operator|.
name|udafName
operator|.
name|toLowerCase
argument_list|()
argument_list|,
name|udaf
operator|.
name|genericUDAFEvaluator
argument_list|,
name|udaf
operator|.
name|convertedParameters
argument_list|,
literal|false
argument_list|,
name|udafMode
argument_list|)
argument_list|)
expr_stmt|;
name|colInfoLst
operator|.
name|add
argument_list|(
operator|new
name|ColumnInfo
argument_list|(
name|colOutputName
argument_list|,
name|udaf
operator|.
name|returnType
argument_list|,
literal|""
argument_list|,
literal|false
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|Operator
name|rsGBOp2
init|=
name|OperatorFactory
operator|.
name|getAndMakeChild
argument_list|(
operator|new
name|GroupByDesc
argument_list|(
name|GroupByDesc
operator|.
name|Mode
operator|.
name|FINAL
argument_list|,
name|outputColNames
argument_list|,
name|gbKeys
argument_list|,
name|aggregations
argument_list|,
literal|false
argument_list|,
name|gbInfo
operator|.
name|groupByMemoryUsage
argument_list|,
name|gbInfo
operator|.
name|memoryThreshold
argument_list|,
literal|null
argument_list|,
literal|false
argument_list|,
name|groupingSetsPosition
argument_list|,
name|gbInfo
operator|.
name|containsDistinctAggr
argument_list|)
argument_list|,
operator|new
name|RowSchema
argument_list|(
name|colInfoLst
argument_list|)
argument_list|,
name|rs
argument_list|)
decl_stmt|;
name|rsGBOp2
operator|.
name|setColumnExprMap
argument_list|(
name|colExprMap
argument_list|)
expr_stmt|;
comment|// TODO: Shouldn't we propgate vc? is it vc col from tab or all vc
return|return
operator|new
name|OpAttr
argument_list|(
literal|""
argument_list|,
operator|new
name|HashSet
argument_list|<
name|Integer
argument_list|>
argument_list|()
argument_list|,
name|rsGBOp2
argument_list|)
return|;
block|}
specifier|private
specifier|static
name|OpAttr
name|genReduceSideGB1
parameter_list|(
name|OpAttr
name|inputOpAf
parameter_list|,
name|GBInfo
name|gbInfo
parameter_list|,
name|boolean
name|computeGrpSet
parameter_list|,
name|boolean
name|propagateConstInDistinctUDAF
parameter_list|,
name|GroupByDesc
operator|.
name|Mode
name|gbMode
parameter_list|)
throws|throws
name|SemanticException
block|{
name|ArrayList
argument_list|<
name|String
argument_list|>
name|outputColNames
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
name|ArrayList
argument_list|<
name|ColumnInfo
argument_list|>
name|colInfoLst
init|=
operator|new
name|ArrayList
argument_list|<
name|ColumnInfo
argument_list|>
argument_list|()
decl_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|ExprNodeDesc
argument_list|>
name|colExprMap
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|ExprNodeDesc
argument_list|>
argument_list|()
decl_stmt|;
name|String
name|colOutputName
init|=
literal|null
decl_stmt|;
name|ReduceSinkOperator
name|rs
init|=
operator|(
name|ReduceSinkOperator
operator|)
name|inputOpAf
operator|.
name|inputs
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|ColumnInfo
argument_list|>
name|rsColInfoLst
init|=
name|rs
operator|.
name|getSchema
argument_list|()
operator|.
name|getSignature
argument_list|()
decl_stmt|;
name|ColumnInfo
name|ci
decl_stmt|;
name|boolean
name|finalGB
init|=
operator|(
name|gbInfo
operator|.
name|gbPhysicalPipelineMode
operator|==
name|HIVEGBPHYSICALMODE
operator|.
name|MAP_SIDE_GB_NO_SKEW_NO_ADD_MR_JOB
operator|)
decl_stmt|;
comment|// 1. Build GB Keys, grouping set starting position
comment|// 1.1 First Add original GB Keys
name|ArrayList
argument_list|<
name|ExprNodeDesc
argument_list|>
name|gbKeys
init|=
name|ExprNodeDescUtils
operator|.
name|genExprNodeDesc
argument_list|(
name|rs
argument_list|,
literal|0
argument_list|,
name|gbInfo
operator|.
name|gbKeys
operator|.
name|size
argument_list|()
operator|-
literal|1
argument_list|,
literal|false
argument_list|,
literal|false
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|gbInfo
operator|.
name|gbKeys
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|ci
operator|=
name|rsColInfoLst
operator|.
name|get
argument_list|(
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|finalGB
condition|)
block|{
name|colOutputName
operator|=
name|gbInfo
operator|.
name|outputColNames
operator|.
name|get
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|colOutputName
operator|=
name|SemanticAnalyzer
operator|.
name|getColumnInternalName
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
name|outputColNames
operator|.
name|add
argument_list|(
name|colOutputName
argument_list|)
expr_stmt|;
name|colInfoLst
operator|.
name|add
argument_list|(
operator|new
name|ColumnInfo
argument_list|(
name|colOutputName
argument_list|,
name|ci
operator|.
name|getType
argument_list|()
argument_list|,
literal|""
argument_list|,
literal|false
argument_list|)
argument_list|)
expr_stmt|;
name|colExprMap
operator|.
name|put
argument_list|(
name|colOutputName
argument_list|,
name|gbKeys
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// 1.2 Add GrpSet Col
name|int
name|groupingSetsColPosition
init|=
operator|-
literal|1
decl_stmt|;
if|if
condition|(
operator|(
operator|!
name|finalGB
operator|&&
name|gbInfo
operator|.
name|grpSets
operator|.
name|size
argument_list|()
operator|>
literal|0
operator|)
operator|||
operator|(
name|finalGB
operator|&&
name|gbInfo
operator|.
name|grpIdFunctionNeeded
operator|)
condition|)
block|{
name|groupingSetsColPosition
operator|=
name|gbInfo
operator|.
name|gbKeys
operator|.
name|size
argument_list|()
expr_stmt|;
if|if
condition|(
name|computeGrpSet
condition|)
block|{
comment|// GrpSet Col needs to be constructed
name|gbKeys
operator|.
name|add
argument_list|(
operator|new
name|ExprNodeConstantDesc
argument_list|(
literal|"0"
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// GrpSet Col already part of input RS
comment|// TODO: Can't we just copy the ExprNodeDEsc from input (Do we need to
comment|// explicitly set table alias to null& VC to false
name|gbKeys
operator|.
name|addAll
argument_list|(
name|ExprNodeDescUtils
operator|.
name|genExprNodeDesc
argument_list|(
name|rs
argument_list|,
name|groupingSetsColPosition
argument_list|,
name|groupingSetsColPosition
argument_list|,
literal|false
argument_list|,
literal|true
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|colOutputName
operator|=
name|SemanticAnalyzer
operator|.
name|getColumnInternalName
argument_list|(
name|groupingSetsColPosition
argument_list|)
expr_stmt|;
if|if
condition|(
name|finalGB
condition|)
block|{
name|colOutputName
operator|=
name|gbInfo
operator|.
name|outputColNames
operator|.
name|get
argument_list|(
name|gbInfo
operator|.
name|outputColNames
operator|.
name|size
argument_list|()
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
name|outputColNames
operator|.
name|add
argument_list|(
name|colOutputName
argument_list|)
expr_stmt|;
name|colInfoLst
operator|.
name|add
argument_list|(
operator|new
name|ColumnInfo
argument_list|(
name|colOutputName
argument_list|,
name|TypeInfoFactory
operator|.
name|stringTypeInfo
argument_list|,
literal|null
argument_list|,
literal|true
argument_list|)
argument_list|)
expr_stmt|;
name|colExprMap
operator|.
name|put
argument_list|(
name|colOutputName
argument_list|,
name|gbKeys
operator|.
name|get
argument_list|(
name|groupingSetsColPosition
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// 2. Walk through UDAF and add them to GB
name|String
name|lastReduceKeyColName
init|=
literal|null
decl_stmt|;
if|if
condition|(
operator|!
name|rs
operator|.
name|getConf
argument_list|()
operator|.
name|getOutputKeyColumnNames
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|lastReduceKeyColName
operator|=
name|rs
operator|.
name|getConf
argument_list|()
operator|.
name|getOutputKeyColumnNames
argument_list|()
operator|.
name|get
argument_list|(
name|rs
operator|.
name|getConf
argument_list|()
operator|.
name|getOutputKeyColumnNames
argument_list|()
operator|.
name|size
argument_list|()
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
name|int
name|numDistinctUDFs
init|=
literal|0
decl_stmt|;
name|int
name|distinctStartPosInReduceKeys
init|=
name|gbKeys
operator|.
name|size
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|ExprNodeDesc
argument_list|>
name|reduceValues
init|=
name|rs
operator|.
name|getConf
argument_list|()
operator|.
name|getValueCols
argument_list|()
decl_stmt|;
name|ArrayList
argument_list|<
name|AggregationDesc
argument_list|>
name|aggregations
init|=
operator|new
name|ArrayList
argument_list|<
name|AggregationDesc
argument_list|>
argument_list|()
decl_stmt|;
name|int
name|udafColStartPosInOriginalGB
init|=
operator|(
name|gbInfo
operator|.
name|grpSets
operator|.
name|size
argument_list|()
operator|>
literal|0
operator|)
condition|?
name|gbInfo
operator|.
name|gbKeys
operator|.
name|size
argument_list|()
operator|*
literal|2
else|:
name|gbInfo
operator|.
name|gbKeys
operator|.
name|size
argument_list|()
decl_stmt|;
name|int
name|udafColStartPosInRS
init|=
name|rs
operator|.
name|getConf
argument_list|()
operator|.
name|getKeyCols
argument_list|()
operator|.
name|size
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|gbInfo
operator|.
name|udafAttrs
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|UDAFAttrs
name|udafAttr
init|=
name|gbInfo
operator|.
name|udafAttrs
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|ArrayList
argument_list|<
name|ExprNodeDesc
argument_list|>
name|aggParameters
init|=
operator|new
name|ArrayList
argument_list|<
name|ExprNodeDesc
argument_list|>
argument_list|()
decl_stmt|;
if|if
condition|(
name|udafAttr
operator|.
name|isDistinctUDAF
condition|)
block|{
name|ColumnInfo
name|rsDistUDAFParamColInfo
decl_stmt|;
name|ExprNodeDesc
name|distinctUDAFParam
decl_stmt|;
name|ExprNodeDesc
name|constantPropDistinctUDAFParam
decl_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|udafAttr
operator|.
name|udafParamsIndxInGBInfoDistExprs
operator|.
name|size
argument_list|()
condition|;
name|j
operator|++
control|)
block|{
name|rsDistUDAFParamColInfo
operator|=
name|rsColInfoLst
operator|.
name|get
argument_list|(
name|distinctStartPosInReduceKeys
operator|+
name|j
argument_list|)
expr_stmt|;
name|String
name|rsDistUDAFParamName
init|=
name|rsDistUDAFParamColInfo
operator|.
name|getInternalName
argument_list|()
decl_stmt|;
comment|// TODO: verify if this is needed
if|if
condition|(
name|lastReduceKeyColName
operator|!=
literal|null
condition|)
block|{
name|rsDistUDAFParamName
operator|=
name|Utilities
operator|.
name|ReduceField
operator|.
name|KEY
operator|.
name|name
argument_list|()
operator|+
literal|"."
operator|+
name|lastReduceKeyColName
operator|+
literal|":"
operator|+
name|numDistinctUDFs
operator|+
literal|"."
operator|+
name|SemanticAnalyzer
operator|.
name|getColumnInternalName
argument_list|(
name|j
argument_list|)
expr_stmt|;
block|}
name|distinctUDAFParam
operator|=
operator|new
name|ExprNodeColumnDesc
argument_list|(
name|rsDistUDAFParamColInfo
operator|.
name|getType
argument_list|()
argument_list|,
name|rsDistUDAFParamName
argument_list|,
name|rsDistUDAFParamColInfo
operator|.
name|getTabAlias
argument_list|()
argument_list|,
name|rsDistUDAFParamColInfo
operator|.
name|getIsVirtualCol
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|propagateConstInDistinctUDAF
condition|)
block|{
comment|// TODO: Implement propConstDistUDAFParams
name|constantPropDistinctUDAFParam
operator|=
name|SemanticAnalyzer
operator|.
name|isConstantParameterInAggregationParameters
argument_list|(
name|rsDistUDAFParamColInfo
operator|.
name|getInternalName
argument_list|()
argument_list|,
name|reduceValues
argument_list|)
expr_stmt|;
if|if
condition|(
name|constantPropDistinctUDAFParam
operator|!=
literal|null
condition|)
block|{
name|distinctUDAFParam
operator|=
name|constantPropDistinctUDAFParam
expr_stmt|;
block|}
block|}
name|aggParameters
operator|.
name|add
argument_list|(
name|distinctUDAFParam
argument_list|)
expr_stmt|;
block|}
name|numDistinctUDFs
operator|++
expr_stmt|;
block|}
else|else
block|{
name|aggParameters
operator|.
name|add
argument_list|(
operator|new
name|ExprNodeColumnDesc
argument_list|(
name|rsColInfoLst
operator|.
name|get
argument_list|(
name|udafColStartPosInRS
operator|+
name|i
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|Mode
name|udafMode
init|=
name|SemanticAnalyzer
operator|.
name|groupByDescModeToUDAFMode
argument_list|(
name|gbMode
argument_list|,
name|udafAttr
operator|.
name|isDistinctUDAF
argument_list|)
decl_stmt|;
name|GenericUDAFInfo
name|udaf
init|=
name|SemanticAnalyzer
operator|.
name|getGenericUDAFInfo
argument_list|(
name|udafAttr
operator|.
name|udafEvaluator
argument_list|,
name|udafMode
argument_list|,
name|aggParameters
argument_list|)
decl_stmt|;
name|aggregations
operator|.
name|add
argument_list|(
operator|new
name|AggregationDesc
argument_list|(
name|udafAttr
operator|.
name|udafName
operator|.
name|toLowerCase
argument_list|()
argument_list|,
name|udaf
operator|.
name|genericUDAFEvaluator
argument_list|,
name|udaf
operator|.
name|convertedParameters
argument_list|,
operator|(
name|gbMode
operator|!=
name|GroupByDesc
operator|.
name|Mode
operator|.
name|FINAL
operator|&&
name|udafAttr
operator|.
name|isDistinctUDAF
operator|)
argument_list|,
name|udafMode
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|finalGB
condition|)
block|{
name|colOutputName
operator|=
name|gbInfo
operator|.
name|outputColNames
operator|.
name|get
argument_list|(
name|udafColStartPosInOriginalGB
operator|+
name|i
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|colOutputName
operator|=
name|SemanticAnalyzer
operator|.
name|getColumnInternalName
argument_list|(
name|gbKeys
operator|.
name|size
argument_list|()
operator|+
name|aggregations
operator|.
name|size
argument_list|()
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
name|colInfoLst
operator|.
name|add
argument_list|(
operator|new
name|ColumnInfo
argument_list|(
name|colOutputName
argument_list|,
name|udaf
operator|.
name|returnType
argument_list|,
literal|""
argument_list|,
literal|false
argument_list|)
argument_list|)
expr_stmt|;
name|outputColNames
operator|.
name|add
argument_list|(
name|colOutputName
argument_list|)
expr_stmt|;
block|}
comment|// Nothing special needs to be done for grouping sets if
comment|// this is the final group by operator, and multiple rows corresponding to
comment|// the
comment|// grouping sets have been generated upstream.
comment|// However, if an addition MR job has been created to handle grouping sets,
comment|// additional rows corresponding to grouping sets need to be created here.
comment|//TODO: Clean up/refactor assumptions
name|boolean
name|includeGrpSetInGBDesc
init|=
operator|(
name|gbInfo
operator|.
name|grpSets
operator|.
name|size
argument_list|()
operator|>
literal|0
operator|)
operator|&&
operator|!
name|finalGB
operator|&&
operator|!
operator|(
name|gbInfo
operator|.
name|gbPhysicalPipelineMode
operator|==
name|HIVEGBPHYSICALMODE
operator|.
name|MAP_SIDE_GB_SKEW_GBKEYS_OR_DIST_UDAF_PRESENT
operator|)
decl_stmt|;
name|Operator
name|rsGBOp
init|=
name|OperatorFactory
operator|.
name|getAndMakeChild
argument_list|(
operator|new
name|GroupByDesc
argument_list|(
name|gbMode
argument_list|,
name|outputColNames
argument_list|,
name|gbKeys
argument_list|,
name|aggregations
argument_list|,
name|gbInfo
operator|.
name|groupByMemoryUsage
argument_list|,
name|gbInfo
operator|.
name|memoryThreshold
argument_list|,
name|gbInfo
operator|.
name|grpSets
argument_list|,
name|includeGrpSetInGBDesc
argument_list|,
name|groupingSetsColPosition
argument_list|,
name|gbInfo
operator|.
name|containsDistinctAggr
argument_list|)
argument_list|,
operator|new
name|RowSchema
argument_list|(
name|colInfoLst
argument_list|)
argument_list|,
name|rs
argument_list|)
decl_stmt|;
name|rsGBOp
operator|.
name|setColumnExprMap
argument_list|(
name|colExprMap
argument_list|)
expr_stmt|;
return|return
operator|new
name|OpAttr
argument_list|(
literal|""
argument_list|,
operator|new
name|HashSet
argument_list|<
name|Integer
argument_list|>
argument_list|()
argument_list|,
name|rsGBOp
argument_list|)
return|;
block|}
comment|/**    * RS-GB0    *    * @param inputOpAf    * @param gbInfo    * @param gbMode    * @return    * @throws SemanticException    */
specifier|private
specifier|static
name|OpAttr
name|genReduceSideGB1NoMapGB
parameter_list|(
name|OpAttr
name|inputOpAf
parameter_list|,
name|GBInfo
name|gbInfo
parameter_list|,
name|GroupByDesc
operator|.
name|Mode
name|gbMode
parameter_list|)
throws|throws
name|SemanticException
block|{
name|ArrayList
argument_list|<
name|String
argument_list|>
name|outputColNames
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
name|ArrayList
argument_list|<
name|ColumnInfo
argument_list|>
name|colInfoLst
init|=
operator|new
name|ArrayList
argument_list|<
name|ColumnInfo
argument_list|>
argument_list|()
decl_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|ExprNodeDesc
argument_list|>
name|colExprMap
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|ExprNodeDesc
argument_list|>
argument_list|()
decl_stmt|;
name|String
name|colOutputName
init|=
literal|null
decl_stmt|;
name|ReduceSinkOperator
name|rs
init|=
operator|(
name|ReduceSinkOperator
operator|)
name|inputOpAf
operator|.
name|inputs
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|ColumnInfo
argument_list|>
name|rsColInfoLst
init|=
name|rs
operator|.
name|getSchema
argument_list|()
operator|.
name|getSignature
argument_list|()
decl_stmt|;
name|ColumnInfo
name|ci
decl_stmt|;
name|boolean
name|useOriginalGBNames
init|=
operator|(
name|gbInfo
operator|.
name|gbPhysicalPipelineMode
operator|==
name|HIVEGBPHYSICALMODE
operator|.
name|NO_MAP_SIDE_GB_NO_SKEW
operator|)
decl_stmt|;
comment|// 1. Build GB Keys, grouping set starting position
comment|// 1.1 First Add original GB Keys
name|ArrayList
argument_list|<
name|ExprNodeDesc
argument_list|>
name|gbKeys
init|=
name|ExprNodeDescUtils
operator|.
name|genExprNodeDesc
argument_list|(
name|rs
argument_list|,
literal|0
argument_list|,
name|gbInfo
operator|.
name|gbKeys
operator|.
name|size
argument_list|()
operator|-
literal|1
argument_list|,
literal|true
argument_list|,
literal|false
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|gbInfo
operator|.
name|gbKeys
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|ci
operator|=
name|rsColInfoLst
operator|.
name|get
argument_list|(
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|useOriginalGBNames
condition|)
block|{
name|colOutputName
operator|=
name|gbInfo
operator|.
name|outputColNames
operator|.
name|get
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|colOutputName
operator|=
name|SemanticAnalyzer
operator|.
name|getColumnInternalName
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
name|outputColNames
operator|.
name|add
argument_list|(
name|colOutputName
argument_list|)
expr_stmt|;
name|colInfoLst
operator|.
name|add
argument_list|(
operator|new
name|ColumnInfo
argument_list|(
name|colOutputName
argument_list|,
name|ci
operator|.
name|getType
argument_list|()
argument_list|,
literal|null
argument_list|,
literal|false
argument_list|)
argument_list|)
expr_stmt|;
name|colExprMap
operator|.
name|put
argument_list|(
name|colOutputName
argument_list|,
name|gbKeys
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// 2. Walk through UDAF and add them to GB
name|String
name|lastReduceKeyColName
init|=
literal|null
decl_stmt|;
if|if
condition|(
operator|!
name|rs
operator|.
name|getConf
argument_list|()
operator|.
name|getOutputKeyColumnNames
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|lastReduceKeyColName
operator|=
name|rs
operator|.
name|getConf
argument_list|()
operator|.
name|getOutputKeyColumnNames
argument_list|()
operator|.
name|get
argument_list|(
name|rs
operator|.
name|getConf
argument_list|()
operator|.
name|getOutputKeyColumnNames
argument_list|()
operator|.
name|size
argument_list|()
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
name|int
name|numDistinctUDFs
init|=
literal|0
decl_stmt|;
name|int
name|distinctStartPosInReduceKeys
init|=
name|gbKeys
operator|.
name|size
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|ExprNodeDesc
argument_list|>
name|reduceValues
init|=
name|rs
operator|.
name|getConf
argument_list|()
operator|.
name|getValueCols
argument_list|()
decl_stmt|;
name|ArrayList
argument_list|<
name|AggregationDesc
argument_list|>
name|aggregations
init|=
operator|new
name|ArrayList
argument_list|<
name|AggregationDesc
argument_list|>
argument_list|()
decl_stmt|;
name|int
name|udafColStartPosInOriginalGB
init|=
name|gbInfo
operator|.
name|gbKeys
operator|.
name|size
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|gbInfo
operator|.
name|udafAttrs
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|UDAFAttrs
name|udafAttr
init|=
name|gbInfo
operator|.
name|udafAttrs
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|ArrayList
argument_list|<
name|ExprNodeDesc
argument_list|>
name|aggParameters
init|=
operator|new
name|ArrayList
argument_list|<
name|ExprNodeDesc
argument_list|>
argument_list|()
decl_stmt|;
name|ColumnInfo
name|rsUDAFParamColInfo
decl_stmt|;
name|ExprNodeDesc
name|udafParam
decl_stmt|;
name|ExprNodeDesc
name|constantPropDistinctUDAFParam
decl_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|udafAttr
operator|.
name|udafParams
operator|.
name|size
argument_list|()
condition|;
name|j
operator|++
control|)
block|{
name|rsUDAFParamColInfo
operator|=
name|rsColInfoLst
operator|.
name|get
argument_list|(
name|distinctStartPosInReduceKeys
operator|+
name|j
argument_list|)
expr_stmt|;
name|String
name|rsUDAFParamName
init|=
name|rsUDAFParamColInfo
operator|.
name|getInternalName
argument_list|()
decl_stmt|;
comment|// TODO: verify if this is needed
if|if
condition|(
name|udafAttr
operator|.
name|isDistinctUDAF
operator|&&
name|lastReduceKeyColName
operator|!=
literal|null
condition|)
block|{
name|rsUDAFParamName
operator|=
name|Utilities
operator|.
name|ReduceField
operator|.
name|KEY
operator|.
name|name
argument_list|()
operator|+
literal|"."
operator|+
name|lastReduceKeyColName
operator|+
literal|":"
operator|+
name|numDistinctUDFs
operator|+
literal|"."
operator|+
name|SemanticAnalyzer
operator|.
name|getColumnInternalName
argument_list|(
name|j
argument_list|)
expr_stmt|;
block|}
name|udafParam
operator|=
operator|new
name|ExprNodeColumnDesc
argument_list|(
name|rsUDAFParamColInfo
operator|.
name|getType
argument_list|()
argument_list|,
name|rsUDAFParamName
argument_list|,
name|rsUDAFParamColInfo
operator|.
name|getTabAlias
argument_list|()
argument_list|,
name|rsUDAFParamColInfo
operator|.
name|getIsVirtualCol
argument_list|()
argument_list|)
expr_stmt|;
name|constantPropDistinctUDAFParam
operator|=
name|SemanticAnalyzer
operator|.
name|isConstantParameterInAggregationParameters
argument_list|(
name|rsUDAFParamColInfo
operator|.
name|getInternalName
argument_list|()
argument_list|,
name|reduceValues
argument_list|)
expr_stmt|;
if|if
condition|(
name|constantPropDistinctUDAFParam
operator|!=
literal|null
condition|)
block|{
name|udafParam
operator|=
name|constantPropDistinctUDAFParam
expr_stmt|;
block|}
name|aggParameters
operator|.
name|add
argument_list|(
name|udafParam
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|udafAttr
operator|.
name|isDistinctUDAF
condition|)
block|{
name|numDistinctUDFs
operator|++
expr_stmt|;
block|}
name|Mode
name|udafMode
init|=
name|SemanticAnalyzer
operator|.
name|groupByDescModeToUDAFMode
argument_list|(
name|gbMode
argument_list|,
name|udafAttr
operator|.
name|isDistinctUDAF
argument_list|)
decl_stmt|;
name|GenericUDAFInfo
name|udaf
init|=
name|SemanticAnalyzer
operator|.
name|getGenericUDAFInfo
argument_list|(
name|udafAttr
operator|.
name|udafEvaluator
argument_list|,
name|udafMode
argument_list|,
name|aggParameters
argument_list|)
decl_stmt|;
name|aggregations
operator|.
name|add
argument_list|(
operator|new
name|AggregationDesc
argument_list|(
name|udafAttr
operator|.
name|udafName
operator|.
name|toLowerCase
argument_list|()
argument_list|,
name|udaf
operator|.
name|genericUDAFEvaluator
argument_list|,
name|udaf
operator|.
name|convertedParameters
argument_list|,
name|udafAttr
operator|.
name|isDistinctUDAF
argument_list|,
name|udafMode
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|useOriginalGBNames
condition|)
block|{
name|colOutputName
operator|=
name|gbInfo
operator|.
name|outputColNames
operator|.
name|get
argument_list|(
name|udafColStartPosInOriginalGB
operator|+
name|i
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|colOutputName
operator|=
name|SemanticAnalyzer
operator|.
name|getColumnInternalName
argument_list|(
name|gbKeys
operator|.
name|size
argument_list|()
operator|+
name|aggregations
operator|.
name|size
argument_list|()
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
name|colInfoLst
operator|.
name|add
argument_list|(
operator|new
name|ColumnInfo
argument_list|(
name|colOutputName
argument_list|,
name|udaf
operator|.
name|returnType
argument_list|,
literal|""
argument_list|,
literal|false
argument_list|)
argument_list|)
expr_stmt|;
name|outputColNames
operator|.
name|add
argument_list|(
name|colOutputName
argument_list|)
expr_stmt|;
block|}
name|Operator
name|rsGB1
init|=
name|OperatorFactory
operator|.
name|getAndMakeChild
argument_list|(
operator|new
name|GroupByDesc
argument_list|(
name|gbMode
argument_list|,
name|outputColNames
argument_list|,
name|gbKeys
argument_list|,
name|aggregations
argument_list|,
literal|false
argument_list|,
name|gbInfo
operator|.
name|groupByMemoryUsage
argument_list|,
name|gbInfo
operator|.
name|memoryThreshold
argument_list|,
literal|null
argument_list|,
literal|false
argument_list|,
operator|-
literal|1
argument_list|,
name|numDistinctUDFs
operator|>
literal|0
argument_list|)
argument_list|,
operator|new
name|RowSchema
argument_list|(
name|colInfoLst
argument_list|)
argument_list|,
name|rs
argument_list|)
decl_stmt|;
name|rsGB1
operator|.
name|setColumnExprMap
argument_list|(
name|colExprMap
argument_list|)
expr_stmt|;
return|return
operator|new
name|OpAttr
argument_list|(
literal|""
argument_list|,
operator|new
name|HashSet
argument_list|<
name|Integer
argument_list|>
argument_list|()
argument_list|,
name|rsGB1
argument_list|)
return|;
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
specifier|private
specifier|static
name|OpAttr
name|genMapSideGB
parameter_list|(
name|OpAttr
name|inputOpAf
parameter_list|,
name|GBInfo
name|gbAttrs
parameter_list|)
throws|throws
name|SemanticException
block|{
name|ArrayList
argument_list|<
name|String
argument_list|>
name|outputColNames
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
name|ArrayList
argument_list|<
name|ColumnInfo
argument_list|>
name|colInfoLst
init|=
operator|new
name|ArrayList
argument_list|<
name|ColumnInfo
argument_list|>
argument_list|()
decl_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|ExprNodeDesc
argument_list|>
name|colExprMap
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|ExprNodeDesc
argument_list|>
argument_list|()
decl_stmt|;
name|Set
argument_list|<
name|String
argument_list|>
name|gbKeyColsAsNamesFrmIn
init|=
operator|new
name|HashSet
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
name|String
name|colOutputName
init|=
literal|null
decl_stmt|;
comment|// 1. Build GB Keys, grouping set starting position
comment|// 1.1 First Add original GB Keys
name|ArrayList
argument_list|<
name|ExprNodeDesc
argument_list|>
name|gbKeys
init|=
operator|new
name|ArrayList
argument_list|<
name|ExprNodeDesc
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|gbAttrs
operator|.
name|gbKeys
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|gbKeys
operator|.
name|add
argument_list|(
name|gbAttrs
operator|.
name|gbKeys
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|colOutputName
operator|=
name|SemanticAnalyzer
operator|.
name|getColumnInternalName
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|colInfoLst
operator|.
name|add
argument_list|(
operator|new
name|ColumnInfo
argument_list|(
name|colOutputName
argument_list|,
name|gbAttrs
operator|.
name|gbKeyTypes
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|,
literal|""
argument_list|,
literal|false
argument_list|)
argument_list|)
expr_stmt|;
name|outputColNames
operator|.
name|add
argument_list|(
name|colOutputName
argument_list|)
expr_stmt|;
name|gbKeyColsAsNamesFrmIn
operator|.
name|add
argument_list|(
name|gbAttrs
operator|.
name|gbKeyColNamesInInput
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|colExprMap
operator|.
name|put
argument_list|(
name|colOutputName
argument_list|,
name|gbKeys
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// 1.2. Adjust GroupingSet Position, GBKeys for GroupingSet Position if
comment|// needed. NOTE: GroupingID is added to map side GB only if we don't GrpSet
comment|// doesn't require additional MR Jobs
name|int
name|groupingSetsPosition
init|=
operator|-
literal|1
decl_stmt|;
name|boolean
name|inclGrpID
init|=
name|inclGrpSetInMapSide
argument_list|(
name|gbAttrs
argument_list|)
decl_stmt|;
if|if
condition|(
name|inclGrpID
condition|)
block|{
name|groupingSetsPosition
operator|=
name|gbKeys
operator|.
name|size
argument_list|()
expr_stmt|;
name|addGrpSetCol
argument_list|(
literal|true
argument_list|,
literal|null
argument_list|,
literal|false
argument_list|,
name|gbKeys
argument_list|,
name|outputColNames
argument_list|,
name|colInfoLst
argument_list|,
name|colExprMap
argument_list|)
expr_stmt|;
block|}
comment|// 1.3. Add all distinct params
comment|// NOTE: distinct expr can not be part of of GB key (we assume plan
comment|// gen would have prevented it)
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|gbAttrs
operator|.
name|distExprNodes
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|gbKeyColsAsNamesFrmIn
operator|.
name|contains
argument_list|(
name|gbAttrs
operator|.
name|distExprNames
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|)
condition|)
block|{
name|gbKeys
operator|.
name|add
argument_list|(
name|gbAttrs
operator|.
name|distExprNodes
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|colOutputName
operator|=
name|SemanticAnalyzer
operator|.
name|getColumnInternalName
argument_list|(
name|gbKeys
operator|.
name|size
argument_list|()
operator|-
literal|1
argument_list|)
expr_stmt|;
name|colInfoLst
operator|.
name|add
argument_list|(
operator|new
name|ColumnInfo
argument_list|(
name|colOutputName
argument_list|,
name|gbAttrs
operator|.
name|distExprTypes
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|,
literal|""
argument_list|,
literal|false
argument_list|)
argument_list|)
expr_stmt|;
name|outputColNames
operator|.
name|add
argument_list|(
name|colOutputName
argument_list|)
expr_stmt|;
name|gbKeyColsAsNamesFrmIn
operator|.
name|add
argument_list|(
name|gbAttrs
operator|.
name|distExprNames
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|colExprMap
operator|.
name|put
argument_list|(
name|colOutputName
argument_list|,
name|gbKeys
operator|.
name|get
argument_list|(
name|gbKeys
operator|.
name|size
argument_list|()
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|// 2. Build Aggregations
name|ArrayList
argument_list|<
name|AggregationDesc
argument_list|>
name|aggregations
init|=
operator|new
name|ArrayList
argument_list|<
name|AggregationDesc
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|UDAFAttrs
name|udafAttr
range|:
name|gbAttrs
operator|.
name|udafAttrs
control|)
block|{
name|Mode
name|amode
init|=
name|SemanticAnalyzer
operator|.
name|groupByDescModeToUDAFMode
argument_list|(
name|GroupByDesc
operator|.
name|Mode
operator|.
name|HASH
argument_list|,
name|udafAttr
operator|.
name|isDistinctUDAF
argument_list|)
decl_stmt|;
name|aggregations
operator|.
name|add
argument_list|(
operator|new
name|AggregationDesc
argument_list|(
name|udafAttr
operator|.
name|udafName
operator|.
name|toLowerCase
argument_list|()
argument_list|,
name|udafAttr
operator|.
name|udafEvaluator
argument_list|,
name|udafAttr
operator|.
name|udafParams
argument_list|,
name|udafAttr
operator|.
name|isDistinctUDAF
argument_list|,
name|amode
argument_list|)
argument_list|)
expr_stmt|;
name|GenericUDAFInfo
name|udafInfo
decl_stmt|;
try|try
block|{
name|udafInfo
operator|=
name|SemanticAnalyzer
operator|.
name|getGenericUDAFInfo
argument_list|(
name|udafAttr
operator|.
name|udafEvaluator
argument_list|,
name|amode
argument_list|,
name|udafAttr
operator|.
name|udafParams
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|SemanticException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
name|e
argument_list|)
throw|;
block|}
name|colOutputName
operator|=
name|SemanticAnalyzer
operator|.
name|getColumnInternalName
argument_list|(
name|gbKeys
operator|.
name|size
argument_list|()
operator|+
name|aggregations
operator|.
name|size
argument_list|()
operator|-
literal|1
argument_list|)
expr_stmt|;
name|colInfoLst
operator|.
name|add
argument_list|(
operator|new
name|ColumnInfo
argument_list|(
name|colOutputName
argument_list|,
name|udafInfo
operator|.
name|returnType
argument_list|,
literal|""
argument_list|,
literal|false
argument_list|)
argument_list|)
expr_stmt|;
name|outputColNames
operator|.
name|add
argument_list|(
name|colOutputName
argument_list|)
expr_stmt|;
block|}
comment|// 3. Create GB
annotation|@
name|SuppressWarnings
argument_list|(
literal|"rawtypes"
argument_list|)
name|Operator
name|gbOp
init|=
name|OperatorFactory
operator|.
name|getAndMakeChild
argument_list|(
operator|new
name|GroupByDesc
argument_list|(
name|GroupByDesc
operator|.
name|Mode
operator|.
name|HASH
argument_list|,
name|outputColNames
argument_list|,
name|gbKeys
argument_list|,
name|aggregations
argument_list|,
literal|false
argument_list|,
name|gbAttrs
operator|.
name|groupByMemoryUsage
argument_list|,
name|gbAttrs
operator|.
name|memoryThreshold
argument_list|,
name|gbAttrs
operator|.
name|grpSets
argument_list|,
name|inclGrpID
argument_list|,
name|groupingSetsPosition
argument_list|,
name|gbAttrs
operator|.
name|containsDistinctAggr
argument_list|)
argument_list|,
operator|new
name|RowSchema
argument_list|(
name|colInfoLst
argument_list|)
argument_list|,
name|inputOpAf
operator|.
name|inputs
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|)
decl_stmt|;
comment|// 5. Setup Expr Col Map
comment|// NOTE: UDAF is not included in ExprColMap
name|gbOp
operator|.
name|setColumnExprMap
argument_list|(
name|colExprMap
argument_list|)
expr_stmt|;
return|return
operator|new
name|OpAttr
argument_list|(
literal|""
argument_list|,
operator|new
name|HashSet
argument_list|<
name|Integer
argument_list|>
argument_list|()
argument_list|,
name|gbOp
argument_list|)
return|;
block|}
specifier|private
specifier|static
name|void
name|addGrpSetCol
parameter_list|(
name|boolean
name|createConstantExpr
parameter_list|,
name|String
name|grpSetIDExprName
parameter_list|,
name|boolean
name|addReducePrefixToColInfoName
parameter_list|,
name|List
argument_list|<
name|ExprNodeDesc
argument_list|>
name|exprLst
parameter_list|,
name|List
argument_list|<
name|String
argument_list|>
name|outputColumnNames
parameter_list|,
name|List
argument_list|<
name|ColumnInfo
argument_list|>
name|colInfoLst
parameter_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|ExprNodeDesc
argument_list|>
name|colExprMap
parameter_list|)
throws|throws
name|SemanticException
block|{
name|String
name|outputColName
init|=
literal|null
decl_stmt|;
name|ExprNodeDesc
name|grpSetColExpr
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|createConstantExpr
condition|)
block|{
name|grpSetColExpr
operator|=
operator|new
name|ExprNodeConstantDesc
argument_list|(
literal|"0"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|grpSetColExpr
operator|=
operator|new
name|ExprNodeColumnDesc
argument_list|(
name|TypeInfoFactory
operator|.
name|stringTypeInfo
argument_list|,
name|grpSetIDExprName
argument_list|,
literal|null
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
name|exprLst
operator|.
name|add
argument_list|(
name|grpSetColExpr
argument_list|)
expr_stmt|;
name|outputColName
operator|=
name|SemanticAnalyzer
operator|.
name|getColumnInternalName
argument_list|(
name|exprLst
operator|.
name|size
argument_list|()
operator|-
literal|1
argument_list|)
expr_stmt|;
name|outputColumnNames
operator|.
name|add
argument_list|(
name|outputColName
argument_list|)
expr_stmt|;
name|String
name|internalColName
init|=
name|outputColName
decl_stmt|;
if|if
condition|(
name|addReducePrefixToColInfoName
condition|)
block|{
name|internalColName
operator|=
name|Utilities
operator|.
name|ReduceField
operator|.
name|KEY
operator|.
name|toString
argument_list|()
operator|+
literal|"."
operator|+
name|outputColName
expr_stmt|;
block|}
name|colInfoLst
operator|.
name|add
argument_list|(
operator|new
name|ColumnInfo
argument_list|(
name|internalColName
argument_list|,
name|grpSetColExpr
operator|.
name|getTypeInfo
argument_list|()
argument_list|,
literal|null
argument_list|,
literal|true
argument_list|)
argument_list|)
expr_stmt|;
name|colExprMap
operator|.
name|put
argument_list|(
name|internalColName
argument_list|,
name|grpSetColExpr
argument_list|)
expr_stmt|;
block|}
comment|/**    * Get Reduce Keys for RS following MapSide GB    *    * @param reduceKeys    *          assumed to be deduped list of exprs    * @param outputKeyColumnNames    * @param colExprMap    * @return List of ExprNodeDesc of ReduceKeys    * @throws SemanticException    */
specifier|private
specifier|static
name|ArrayList
argument_list|<
name|ExprNodeDesc
argument_list|>
name|getReduceKeysForRS
parameter_list|(
name|Operator
name|inOp
parameter_list|,
name|int
name|startPos
parameter_list|,
name|int
name|endPos
parameter_list|,
name|List
argument_list|<
name|String
argument_list|>
name|outputKeyColumnNames
parameter_list|,
name|boolean
name|addOnlyOneKeyColName
parameter_list|,
name|ArrayList
argument_list|<
name|ColumnInfo
argument_list|>
name|colInfoLst
parameter_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|ExprNodeDesc
argument_list|>
name|colExprMap
parameter_list|,
name|boolean
name|addEmptyTabAlias
parameter_list|,
name|boolean
name|setColToNonVirtual
parameter_list|)
throws|throws
name|SemanticException
block|{
name|ArrayList
argument_list|<
name|ExprNodeDesc
argument_list|>
name|reduceKeys
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|endPos
operator|<
literal|0
condition|)
block|{
name|reduceKeys
operator|=
operator|new
name|ArrayList
argument_list|<
name|ExprNodeDesc
argument_list|>
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|reduceKeys
operator|=
name|ExprNodeDescUtils
operator|.
name|genExprNodeDesc
argument_list|(
name|inOp
argument_list|,
name|startPos
argument_list|,
name|endPos
argument_list|,
name|addEmptyTabAlias
argument_list|,
name|setColToNonVirtual
argument_list|)
expr_stmt|;
name|int
name|outColNameIndx
init|=
name|startPos
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|reduceKeys
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|String
name|outputColName
init|=
name|SemanticAnalyzer
operator|.
name|getColumnInternalName
argument_list|(
name|outColNameIndx
argument_list|)
decl_stmt|;
name|outColNameIndx
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|addOnlyOneKeyColName
operator|||
name|i
operator|==
literal|0
condition|)
block|{
name|outputKeyColumnNames
operator|.
name|add
argument_list|(
name|outputColName
argument_list|)
expr_stmt|;
block|}
comment|// TODO: Verify if this is needed (Why can't it be always null/empty
name|String
name|tabAlias
init|=
name|addEmptyTabAlias
condition|?
literal|""
else|:
literal|null
decl_stmt|;
name|ColumnInfo
name|colInfo
init|=
operator|new
name|ColumnInfo
argument_list|(
name|Utilities
operator|.
name|ReduceField
operator|.
name|KEY
operator|.
name|toString
argument_list|()
operator|+
literal|"."
operator|+
name|outputColName
argument_list|,
name|reduceKeys
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|getTypeInfo
argument_list|()
argument_list|,
name|tabAlias
argument_list|,
literal|false
argument_list|)
decl_stmt|;
name|colInfoLst
operator|.
name|add
argument_list|(
name|colInfo
argument_list|)
expr_stmt|;
name|colExprMap
operator|.
name|put
argument_list|(
name|colInfo
operator|.
name|getInternalName
argument_list|()
argument_list|,
name|reduceKeys
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|reduceKeys
return|;
block|}
comment|/**    * Get Value Keys for RS following MapSide GB    *    * @param GroupByOperator    *          MapSide GB    * @param outputKeyColumnNames    * @param colExprMap    * @return List of ExprNodeDesc of Values    * @throws SemanticException    */
specifier|private
specifier|static
name|ArrayList
argument_list|<
name|ExprNodeDesc
argument_list|>
name|getValueKeysForRS
parameter_list|(
name|Operator
name|inOp
parameter_list|,
name|int
name|aggStartPos
parameter_list|,
name|List
argument_list|<
name|String
argument_list|>
name|outputKeyColumnNames
parameter_list|,
name|ArrayList
argument_list|<
name|ColumnInfo
argument_list|>
name|colInfoLst
parameter_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|ExprNodeDesc
argument_list|>
name|colExprMap
parameter_list|,
name|boolean
name|addEmptyTabAlias
parameter_list|,
name|boolean
name|setColToNonVirtual
parameter_list|)
throws|throws
name|SemanticException
block|{
name|List
argument_list|<
name|ColumnInfo
argument_list|>
name|mapGBColInfoLst
init|=
name|inOp
operator|.
name|getSchema
argument_list|()
operator|.
name|getSignature
argument_list|()
decl_stmt|;
name|ArrayList
argument_list|<
name|ExprNodeDesc
argument_list|>
name|valueKeys
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|aggStartPos
operator|>=
name|mapGBColInfoLst
operator|.
name|size
argument_list|()
condition|)
block|{
name|valueKeys
operator|=
operator|new
name|ArrayList
argument_list|<
name|ExprNodeDesc
argument_list|>
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|valueKeys
operator|=
name|ExprNodeDescUtils
operator|.
name|genExprNodeDesc
argument_list|(
name|inOp
argument_list|,
name|aggStartPos
argument_list|,
name|mapGBColInfoLst
operator|.
name|size
argument_list|()
operator|-
literal|1
argument_list|,
literal|true
argument_list|,
name|setColToNonVirtual
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|valueKeys
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|String
name|outputColName
init|=
name|SemanticAnalyzer
operator|.
name|getColumnInternalName
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|outputKeyColumnNames
operator|.
name|add
argument_list|(
name|outputColName
argument_list|)
expr_stmt|;
comment|// TODO: Verify if this is needed (Why can't it be always null/empty
name|String
name|tabAlias
init|=
name|addEmptyTabAlias
condition|?
literal|""
else|:
literal|null
decl_stmt|;
name|ColumnInfo
name|colInfo
init|=
operator|new
name|ColumnInfo
argument_list|(
name|Utilities
operator|.
name|ReduceField
operator|.
name|VALUE
operator|.
name|toString
argument_list|()
operator|+
literal|"."
operator|+
name|outputColName
argument_list|,
name|valueKeys
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|getTypeInfo
argument_list|()
argument_list|,
name|tabAlias
argument_list|,
literal|false
argument_list|)
decl_stmt|;
name|colInfoLst
operator|.
name|add
argument_list|(
name|colInfo
argument_list|)
expr_stmt|;
name|colExprMap
operator|.
name|put
argument_list|(
name|colInfo
operator|.
name|getInternalName
argument_list|()
argument_list|,
name|valueKeys
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|valueKeys
return|;
block|}
specifier|private
specifier|static
name|List
argument_list|<
name|List
argument_list|<
name|Integer
argument_list|>
argument_list|>
name|getDistColIndices
parameter_list|(
name|GBInfo
name|gbAttrs
parameter_list|,
name|int
name|distOffSet
parameter_list|)
throws|throws
name|SemanticException
block|{
name|List
argument_list|<
name|List
argument_list|<
name|Integer
argument_list|>
argument_list|>
name|distColIndices
init|=
operator|new
name|ArrayList
argument_list|<
name|List
argument_list|<
name|Integer
argument_list|>
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|List
argument_list|<
name|Integer
argument_list|>
name|udafDistCols
range|:
name|gbAttrs
operator|.
name|distColIndices
control|)
block|{
name|List
argument_list|<
name|Integer
argument_list|>
name|udfAdjustedDistColIndx
init|=
operator|new
name|ArrayList
argument_list|<
name|Integer
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|Integer
name|distIndx
range|:
name|udafDistCols
control|)
block|{
name|udfAdjustedDistColIndx
operator|.
name|add
argument_list|(
name|distIndx
operator|+
name|distOffSet
argument_list|)
expr_stmt|;
block|}
name|distColIndices
operator|.
name|add
argument_list|(
name|udfAdjustedDistColIndx
argument_list|)
expr_stmt|;
block|}
return|return
name|distColIndices
return|;
block|}
comment|// TODO: Implement this
specifier|private
specifier|static
name|ExprNodeDesc
name|propConstDistUDAFParams
parameter_list|()
block|{
return|return
literal|null
return|;
block|}
block|}
end_class

end_unit

