begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|io
operator|.
name|orc
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|ByteBuffer
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|charset
operator|.
name|CharacterCodingException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|charset
operator|.
name|Charset
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|charset
operator|.
name|CharsetDecoder
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|Log
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|LogFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FSDataOutputStream
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FileSystem
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|Path
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|io
operator|.
name|AcidOutputFormat
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|io
operator|.
name|AcidUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|io
operator|.
name|RecordIdentifier
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|io
operator|.
name|RecordUpdater
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|SerDeStats
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|objectinspector
operator|.
name|ObjectInspector
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|objectinspector
operator|.
name|StructField
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|objectinspector
operator|.
name|StructObjectInspector
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|objectinspector
operator|.
name|primitive
operator|.
name|LongObjectInspector
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|objectinspector
operator|.
name|primitive
operator|.
name|PrimitiveObjectInspectorFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|IntWritable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|LongWritable
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|VisibleForTesting
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Lists
import|;
end_import

begin_comment
comment|/**  * A RecordUpdater where the files are stored as ORC.  */
end_comment

begin_class
specifier|public
class|class
name|OrcRecordUpdater
implements|implements
name|RecordUpdater
block|{
specifier|private
specifier|static
specifier|final
name|Log
name|LOG
init|=
name|LogFactory
operator|.
name|getLog
argument_list|(
name|OrcRecordUpdater
operator|.
name|class
argument_list|)
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|String
name|ACID_KEY_INDEX_NAME
init|=
literal|"hive.acid.key.index"
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|String
name|ACID_FORMAT
init|=
literal|"_orc_acid_version"
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|String
name|ACID_STATS
init|=
literal|"hive.acid.stats"
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|int
name|ORC_ACID_VERSION
init|=
literal|0
decl_stmt|;
specifier|final
specifier|static
name|int
name|INSERT_OPERATION
init|=
literal|0
decl_stmt|;
specifier|final
specifier|static
name|int
name|UPDATE_OPERATION
init|=
literal|1
decl_stmt|;
specifier|final
specifier|static
name|int
name|DELETE_OPERATION
init|=
literal|2
decl_stmt|;
specifier|final
specifier|static
name|int
name|OPERATION
init|=
literal|0
decl_stmt|;
specifier|final
specifier|static
name|int
name|ORIGINAL_TRANSACTION
init|=
literal|1
decl_stmt|;
specifier|final
specifier|static
name|int
name|BUCKET
init|=
literal|2
decl_stmt|;
specifier|final
specifier|static
name|int
name|ROW_ID
init|=
literal|3
decl_stmt|;
specifier|final
specifier|static
name|int
name|CURRENT_TRANSACTION
init|=
literal|4
decl_stmt|;
specifier|final
specifier|static
name|int
name|ROW
init|=
literal|5
decl_stmt|;
specifier|final
specifier|static
name|int
name|FIELDS
init|=
literal|6
decl_stmt|;
specifier|final
specifier|static
name|int
name|DELTA_BUFFER_SIZE
init|=
literal|16
operator|*
literal|1024
decl_stmt|;
specifier|final
specifier|static
name|long
name|DELTA_STRIPE_SIZE
init|=
literal|16
operator|*
literal|1024
operator|*
literal|1024
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|Charset
name|UTF8
init|=
name|Charset
operator|.
name|forName
argument_list|(
literal|"UTF-8"
argument_list|)
decl_stmt|;
specifier|private
specifier|final
name|AcidOutputFormat
operator|.
name|Options
name|options
decl_stmt|;
specifier|private
specifier|final
name|Path
name|path
decl_stmt|;
specifier|private
specifier|final
name|FileSystem
name|fs
decl_stmt|;
specifier|private
name|Writer
name|writer
decl_stmt|;
specifier|private
specifier|final
name|FSDataOutputStream
name|flushLengths
decl_stmt|;
specifier|private
specifier|final
name|OrcStruct
name|item
decl_stmt|;
specifier|private
specifier|final
name|IntWritable
name|operation
init|=
operator|new
name|IntWritable
argument_list|()
decl_stmt|;
specifier|private
specifier|final
name|LongWritable
name|currentTransaction
init|=
operator|new
name|LongWritable
argument_list|(
operator|-
literal|1
argument_list|)
decl_stmt|;
specifier|private
specifier|final
name|LongWritable
name|originalTransaction
init|=
operator|new
name|LongWritable
argument_list|(
operator|-
literal|1
argument_list|)
decl_stmt|;
specifier|private
specifier|final
name|IntWritable
name|bucket
init|=
operator|new
name|IntWritable
argument_list|()
decl_stmt|;
specifier|private
specifier|final
name|LongWritable
name|rowId
init|=
operator|new
name|LongWritable
argument_list|()
decl_stmt|;
specifier|private
name|long
name|insertedRows
init|=
literal|0
decl_stmt|;
specifier|private
name|long
name|rowIdOffset
init|=
literal|0
decl_stmt|;
comment|// This records how many rows have been inserted or deleted.  It is separate from insertedRows
comment|// because that is monotonically increasing to give new unique row ids.
specifier|private
name|long
name|rowCountDelta
init|=
literal|0
decl_stmt|;
specifier|private
specifier|final
name|KeyIndexBuilder
name|indexBuilder
init|=
operator|new
name|KeyIndexBuilder
argument_list|()
decl_stmt|;
specifier|private
name|StructField
name|recIdField
init|=
literal|null
decl_stmt|;
comment|// field to look for the record identifier in
specifier|private
name|StructField
name|rowIdField
init|=
literal|null
decl_stmt|;
comment|// field inside recId to look for row id in
specifier|private
name|StructField
name|originalTxnField
init|=
literal|null
decl_stmt|;
comment|// field inside recId to look for original txn in
specifier|private
name|StructObjectInspector
name|rowInspector
decl_stmt|;
comment|// OI for the original row
specifier|private
name|StructObjectInspector
name|recIdInspector
decl_stmt|;
comment|// OI for the record identifier struct
specifier|private
name|LongObjectInspector
name|rowIdInspector
decl_stmt|;
comment|// OI for the long row id inside the recordIdentifier
specifier|private
name|LongObjectInspector
name|origTxnInspector
decl_stmt|;
comment|// OI for the original txn inside the record
comment|// identifer
specifier|static
class|class
name|AcidStats
block|{
name|long
name|inserts
decl_stmt|;
name|long
name|updates
decl_stmt|;
name|long
name|deletes
decl_stmt|;
name|AcidStats
parameter_list|()
block|{
comment|// nothing
block|}
name|AcidStats
parameter_list|(
name|String
name|serialized
parameter_list|)
block|{
name|String
index|[]
name|parts
init|=
name|serialized
operator|.
name|split
argument_list|(
literal|","
argument_list|)
decl_stmt|;
name|inserts
operator|=
name|Long
operator|.
name|parseLong
argument_list|(
name|parts
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|updates
operator|=
name|Long
operator|.
name|parseLong
argument_list|(
name|parts
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|deletes
operator|=
name|Long
operator|.
name|parseLong
argument_list|(
name|parts
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
block|}
name|String
name|serialize
parameter_list|()
block|{
name|StringBuilder
name|builder
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|builder
operator|.
name|append
argument_list|(
name|inserts
argument_list|)
expr_stmt|;
name|builder
operator|.
name|append
argument_list|(
literal|","
argument_list|)
expr_stmt|;
name|builder
operator|.
name|append
argument_list|(
name|updates
argument_list|)
expr_stmt|;
name|builder
operator|.
name|append
argument_list|(
literal|","
argument_list|)
expr_stmt|;
name|builder
operator|.
name|append
argument_list|(
name|deletes
argument_list|)
expr_stmt|;
return|return
name|builder
operator|.
name|toString
argument_list|()
return|;
block|}
block|}
specifier|static
name|Path
name|getSideFile
parameter_list|(
name|Path
name|main
parameter_list|)
block|{
return|return
operator|new
name|Path
argument_list|(
name|main
operator|+
name|AcidUtils
operator|.
name|DELTA_SIDE_FILE_SUFFIX
argument_list|)
return|;
block|}
specifier|static
name|int
name|getOperation
parameter_list|(
name|OrcStruct
name|struct
parameter_list|)
block|{
return|return
operator|(
operator|(
name|IntWritable
operator|)
name|struct
operator|.
name|getFieldValue
argument_list|(
name|OPERATION
argument_list|)
operator|)
operator|.
name|get
argument_list|()
return|;
block|}
specifier|static
name|long
name|getCurrentTransaction
parameter_list|(
name|OrcStruct
name|struct
parameter_list|)
block|{
return|return
operator|(
operator|(
name|LongWritable
operator|)
name|struct
operator|.
name|getFieldValue
argument_list|(
name|CURRENT_TRANSACTION
argument_list|)
operator|)
operator|.
name|get
argument_list|()
return|;
block|}
specifier|static
name|long
name|getOriginalTransaction
parameter_list|(
name|OrcStruct
name|struct
parameter_list|)
block|{
return|return
operator|(
operator|(
name|LongWritable
operator|)
name|struct
operator|.
name|getFieldValue
argument_list|(
name|ORIGINAL_TRANSACTION
argument_list|)
operator|)
operator|.
name|get
argument_list|()
return|;
block|}
specifier|static
name|int
name|getBucket
parameter_list|(
name|OrcStruct
name|struct
parameter_list|)
block|{
return|return
operator|(
operator|(
name|IntWritable
operator|)
name|struct
operator|.
name|getFieldValue
argument_list|(
name|BUCKET
argument_list|)
operator|)
operator|.
name|get
argument_list|()
return|;
block|}
specifier|static
name|long
name|getRowId
parameter_list|(
name|OrcStruct
name|struct
parameter_list|)
block|{
return|return
operator|(
operator|(
name|LongWritable
operator|)
name|struct
operator|.
name|getFieldValue
argument_list|(
name|ROW_ID
argument_list|)
operator|)
operator|.
name|get
argument_list|()
return|;
block|}
specifier|static
name|OrcStruct
name|getRow
parameter_list|(
name|OrcStruct
name|struct
parameter_list|)
block|{
if|if
condition|(
name|struct
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
else|else
block|{
return|return
operator|(
name|OrcStruct
operator|)
name|struct
operator|.
name|getFieldValue
argument_list|(
name|ROW
argument_list|)
return|;
block|}
block|}
comment|/**    * An extension to AcidOutputFormat that allows users to add additional    * options.    */
specifier|public
specifier|static
class|class
name|OrcOptions
extends|extends
name|AcidOutputFormat
operator|.
name|Options
block|{
name|OrcFile
operator|.
name|WriterOptions
name|orcOptions
init|=
literal|null
decl_stmt|;
specifier|public
name|OrcOptions
parameter_list|(
name|Configuration
name|conf
parameter_list|)
block|{
name|super
argument_list|(
name|conf
argument_list|)
expr_stmt|;
block|}
specifier|public
name|OrcOptions
name|orcOptions
parameter_list|(
name|OrcFile
operator|.
name|WriterOptions
name|opts
parameter_list|)
block|{
name|this
operator|.
name|orcOptions
operator|=
name|opts
expr_stmt|;
return|return
name|this
return|;
block|}
specifier|public
name|OrcFile
operator|.
name|WriterOptions
name|getOrcOptions
parameter_list|()
block|{
return|return
name|orcOptions
return|;
block|}
block|}
comment|/**    * Create an object inspector for the ACID event based on the object inspector    * for the underlying row.    * @param rowInspector the row's object inspector    * @return an object inspector for the event stream    */
specifier|static
name|StructObjectInspector
name|createEventSchema
parameter_list|(
name|ObjectInspector
name|rowInspector
parameter_list|)
block|{
name|List
argument_list|<
name|StructField
argument_list|>
name|fields
init|=
operator|new
name|ArrayList
argument_list|<
name|StructField
argument_list|>
argument_list|()
decl_stmt|;
name|fields
operator|.
name|add
argument_list|(
operator|new
name|OrcStruct
operator|.
name|Field
argument_list|(
literal|"operation"
argument_list|,
name|PrimitiveObjectInspectorFactory
operator|.
name|writableIntObjectInspector
argument_list|,
name|OPERATION
argument_list|)
argument_list|)
expr_stmt|;
name|fields
operator|.
name|add
argument_list|(
operator|new
name|OrcStruct
operator|.
name|Field
argument_list|(
literal|"originalTransaction"
argument_list|,
name|PrimitiveObjectInspectorFactory
operator|.
name|writableLongObjectInspector
argument_list|,
name|ORIGINAL_TRANSACTION
argument_list|)
argument_list|)
expr_stmt|;
name|fields
operator|.
name|add
argument_list|(
operator|new
name|OrcStruct
operator|.
name|Field
argument_list|(
literal|"bucket"
argument_list|,
name|PrimitiveObjectInspectorFactory
operator|.
name|writableIntObjectInspector
argument_list|,
name|BUCKET
argument_list|)
argument_list|)
expr_stmt|;
name|fields
operator|.
name|add
argument_list|(
operator|new
name|OrcStruct
operator|.
name|Field
argument_list|(
literal|"rowId"
argument_list|,
name|PrimitiveObjectInspectorFactory
operator|.
name|writableLongObjectInspector
argument_list|,
name|ROW_ID
argument_list|)
argument_list|)
expr_stmt|;
name|fields
operator|.
name|add
argument_list|(
operator|new
name|OrcStruct
operator|.
name|Field
argument_list|(
literal|"currentTransaction"
argument_list|,
name|PrimitiveObjectInspectorFactory
operator|.
name|writableLongObjectInspector
argument_list|,
name|CURRENT_TRANSACTION
argument_list|)
argument_list|)
expr_stmt|;
name|fields
operator|.
name|add
argument_list|(
operator|new
name|OrcStruct
operator|.
name|Field
argument_list|(
literal|"row"
argument_list|,
name|rowInspector
argument_list|,
name|ROW
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|new
name|OrcStruct
operator|.
name|OrcStructInspector
argument_list|(
name|fields
argument_list|)
return|;
block|}
specifier|public
specifier|static
name|List
argument_list|<
name|String
argument_list|>
name|getAcidEventFields
parameter_list|()
block|{
return|return
name|Lists
operator|.
name|newArrayList
argument_list|(
literal|"operation"
argument_list|,
literal|"originalTransaction"
argument_list|,
literal|"bucket"
argument_list|,
literal|"rowId"
argument_list|,
literal|"currentTransaction"
argument_list|,
literal|"row"
argument_list|)
return|;
block|}
name|OrcRecordUpdater
parameter_list|(
name|Path
name|path
parameter_list|,
name|AcidOutputFormat
operator|.
name|Options
name|options
parameter_list|)
throws|throws
name|IOException
block|{
name|this
operator|.
name|options
operator|=
name|options
expr_stmt|;
name|this
operator|.
name|bucket
operator|.
name|set
argument_list|(
name|options
operator|.
name|getBucket
argument_list|()
argument_list|)
expr_stmt|;
name|this
operator|.
name|path
operator|=
name|AcidUtils
operator|.
name|createFilename
argument_list|(
name|path
argument_list|,
name|options
argument_list|)
expr_stmt|;
name|FileSystem
name|fs
init|=
name|options
operator|.
name|getFilesystem
argument_list|()
decl_stmt|;
if|if
condition|(
name|fs
operator|==
literal|null
condition|)
block|{
name|fs
operator|=
name|path
operator|.
name|getFileSystem
argument_list|(
name|options
operator|.
name|getConfiguration
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|this
operator|.
name|fs
operator|=
name|fs
expr_stmt|;
try|try
block|{
name|FSDataOutputStream
name|strm
init|=
name|fs
operator|.
name|create
argument_list|(
operator|new
name|Path
argument_list|(
name|path
argument_list|,
name|ACID_FORMAT
argument_list|)
argument_list|,
literal|false
argument_list|)
decl_stmt|;
name|strm
operator|.
name|writeInt
argument_list|(
name|ORC_ACID_VERSION
argument_list|)
expr_stmt|;
name|strm
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ioe
parameter_list|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Failed to create "
operator|+
name|path
operator|+
literal|"/"
operator|+
name|ACID_FORMAT
operator|+
literal|" with "
operator|+
name|ioe
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|options
operator|.
name|getMinimumTransactionId
argument_list|()
operator|!=
name|options
operator|.
name|getMaximumTransactionId
argument_list|()
operator|&&
operator|!
name|options
operator|.
name|isWritingBase
argument_list|()
condition|)
block|{
name|flushLengths
operator|=
name|fs
operator|.
name|create
argument_list|(
name|getSideFile
argument_list|(
name|this
operator|.
name|path
argument_list|)
argument_list|,
literal|true
argument_list|,
literal|8
argument_list|,
name|options
operator|.
name|getReporter
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|flushLengths
operator|=
literal|null
expr_stmt|;
block|}
name|OrcFile
operator|.
name|WriterOptions
name|writerOptions
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|options
operator|instanceof
name|OrcOptions
condition|)
block|{
name|writerOptions
operator|=
operator|(
operator|(
name|OrcOptions
operator|)
name|options
operator|)
operator|.
name|getOrcOptions
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|writerOptions
operator|==
literal|null
condition|)
block|{
name|writerOptions
operator|=
name|OrcFile
operator|.
name|writerOptions
argument_list|(
name|options
operator|.
name|getConfiguration
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|writerOptions
operator|.
name|fileSystem
argument_list|(
name|fs
argument_list|)
operator|.
name|callback
argument_list|(
name|indexBuilder
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|options
operator|.
name|isWritingBase
argument_list|()
condition|)
block|{
name|writerOptions
operator|.
name|blockPadding
argument_list|(
literal|false
argument_list|)
expr_stmt|;
name|writerOptions
operator|.
name|bufferSize
argument_list|(
name|DELTA_BUFFER_SIZE
argument_list|)
expr_stmt|;
name|writerOptions
operator|.
name|stripeSize
argument_list|(
name|DELTA_STRIPE_SIZE
argument_list|)
expr_stmt|;
block|}
name|rowInspector
operator|=
operator|(
name|StructObjectInspector
operator|)
name|options
operator|.
name|getInspector
argument_list|()
expr_stmt|;
name|writerOptions
operator|.
name|inspector
argument_list|(
name|createEventSchema
argument_list|(
name|findRecId
argument_list|(
name|options
operator|.
name|getInspector
argument_list|()
argument_list|,
name|options
operator|.
name|getRecordIdColumn
argument_list|()
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|this
operator|.
name|writer
operator|=
name|OrcFile
operator|.
name|createWriter
argument_list|(
name|this
operator|.
name|path
argument_list|,
name|writerOptions
argument_list|)
expr_stmt|;
name|item
operator|=
operator|new
name|OrcStruct
argument_list|(
name|FIELDS
argument_list|)
expr_stmt|;
name|item
operator|.
name|setFieldValue
argument_list|(
name|OPERATION
argument_list|,
name|operation
argument_list|)
expr_stmt|;
name|item
operator|.
name|setFieldValue
argument_list|(
name|CURRENT_TRANSACTION
argument_list|,
name|currentTransaction
argument_list|)
expr_stmt|;
name|item
operator|.
name|setFieldValue
argument_list|(
name|ORIGINAL_TRANSACTION
argument_list|,
name|originalTransaction
argument_list|)
expr_stmt|;
name|item
operator|.
name|setFieldValue
argument_list|(
name|BUCKET
argument_list|,
name|bucket
argument_list|)
expr_stmt|;
name|item
operator|.
name|setFieldValue
argument_list|(
name|ROW_ID
argument_list|,
name|rowId
argument_list|)
expr_stmt|;
block|}
comment|/**    * To handle multiple INSERT... statements in a single transaction, we want to make sure    * to generate unique {@code rowId} for all inserted rows of the transaction.    * @return largest rowId created by previous statements (maybe 0)    * @throws IOException    */
specifier|private
name|long
name|findRowIdOffsetForInsert
parameter_list|()
throws|throws
name|IOException
block|{
comment|/*     * 1. need to know bucket we are writing to     * 2. need to know which delta dir it's in     * Then,     * 1. find the same bucket file in previous delta dir for this txn     * 2. read the footer and get AcidStats which has insert count      * 2.1 if AcidStats.inserts>0 done      *  else go to previous delta file      *  For example, consider insert/update/insert case...*/
if|if
condition|(
name|options
operator|.
name|getStatementId
argument_list|()
operator|<=
literal|0
condition|)
block|{
return|return
literal|0
return|;
comment|//there is only 1 statement in this transaction (so far)
block|}
for|for
control|(
name|int
name|pastStmt
init|=
name|options
operator|.
name|getStatementId
argument_list|()
operator|-
literal|1
init|;
name|pastStmt
operator|>=
literal|0
condition|;
name|pastStmt
operator|--
control|)
block|{
name|Path
name|matchingBucket
init|=
name|AcidUtils
operator|.
name|createFilename
argument_list|(
name|options
operator|.
name|getFinalDestination
argument_list|()
argument_list|,
name|options
operator|.
name|clone
argument_list|()
operator|.
name|statementId
argument_list|(
name|pastStmt
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|fs
operator|.
name|exists
argument_list|(
name|matchingBucket
argument_list|)
condition|)
block|{
continue|continue;
block|}
name|Reader
name|reader
init|=
name|OrcFile
operator|.
name|createReader
argument_list|(
name|matchingBucket
argument_list|,
name|OrcFile
operator|.
name|readerOptions
argument_list|(
name|options
operator|.
name|getConfiguration
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
comment|//no close() on Reader?!
name|AcidStats
name|acidStats
init|=
name|parseAcidStats
argument_list|(
name|reader
argument_list|)
decl_stmt|;
if|if
condition|(
name|acidStats
operator|.
name|inserts
operator|>
literal|0
condition|)
block|{
return|return
name|acidStats
operator|.
name|inserts
return|;
block|}
block|}
comment|//if we got here, we looked at all delta files in this txn, prior to current statement and didn't
comment|//find any inserts...
return|return
literal|0
return|;
block|}
comment|// Find the record identifier column (if there) and return a possibly new ObjectInspector that
comment|// will strain out the record id for the underlying writer.
specifier|private
name|ObjectInspector
name|findRecId
parameter_list|(
name|ObjectInspector
name|inspector
parameter_list|,
name|int
name|rowIdColNum
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|inspector
operator|instanceof
name|StructObjectInspector
operator|)
condition|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Serious problem, expected a StructObjectInspector, but got a "
operator|+
name|inspector
operator|.
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|)
throw|;
block|}
if|if
condition|(
name|rowIdColNum
operator|<
literal|0
condition|)
block|{
return|return
name|inspector
return|;
block|}
else|else
block|{
name|RecIdStrippingObjectInspector
name|newInspector
init|=
operator|new
name|RecIdStrippingObjectInspector
argument_list|(
name|inspector
argument_list|,
name|rowIdColNum
argument_list|)
decl_stmt|;
name|recIdField
operator|=
name|newInspector
operator|.
name|getRecId
argument_list|()
expr_stmt|;
name|List
argument_list|<
name|?
extends|extends
name|StructField
argument_list|>
name|fields
init|=
operator|(
operator|(
name|StructObjectInspector
operator|)
name|recIdField
operator|.
name|getFieldObjectInspector
argument_list|()
operator|)
operator|.
name|getAllStructFieldRefs
argument_list|()
decl_stmt|;
comment|// Go by position, not field name, as field names aren't guaranteed.  The order of fields
comment|// in RecordIdentifier is transactionId, bucketId, rowId
name|originalTxnField
operator|=
name|fields
operator|.
name|get
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|origTxnInspector
operator|=
operator|(
name|LongObjectInspector
operator|)
name|originalTxnField
operator|.
name|getFieldObjectInspector
argument_list|()
expr_stmt|;
name|rowIdField
operator|=
name|fields
operator|.
name|get
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|rowIdInspector
operator|=
operator|(
name|LongObjectInspector
operator|)
name|rowIdField
operator|.
name|getFieldObjectInspector
argument_list|()
expr_stmt|;
name|recIdInspector
operator|=
operator|(
name|StructObjectInspector
operator|)
name|recIdField
operator|.
name|getFieldObjectInspector
argument_list|()
expr_stmt|;
return|return
name|newInspector
return|;
block|}
block|}
specifier|private
name|void
name|addEvent
parameter_list|(
name|int
name|operation
parameter_list|,
name|long
name|currentTransaction
parameter_list|,
name|long
name|rowId
parameter_list|,
name|Object
name|row
parameter_list|)
throws|throws
name|IOException
block|{
name|this
operator|.
name|operation
operator|.
name|set
argument_list|(
name|operation
argument_list|)
expr_stmt|;
name|this
operator|.
name|currentTransaction
operator|.
name|set
argument_list|(
name|currentTransaction
argument_list|)
expr_stmt|;
comment|// If this is an insert, originalTransaction should be set to this transaction.  If not,
comment|// it will be reset by the following if anyway.
name|long
name|originalTransaction
init|=
name|currentTransaction
decl_stmt|;
if|if
condition|(
name|operation
operator|==
name|DELETE_OPERATION
operator|||
name|operation
operator|==
name|UPDATE_OPERATION
condition|)
block|{
name|Object
name|rowIdValue
init|=
name|rowInspector
operator|.
name|getStructFieldData
argument_list|(
name|row
argument_list|,
name|recIdField
argument_list|)
decl_stmt|;
name|originalTransaction
operator|=
name|origTxnInspector
operator|.
name|get
argument_list|(
name|recIdInspector
operator|.
name|getStructFieldData
argument_list|(
name|rowIdValue
argument_list|,
name|originalTxnField
argument_list|)
argument_list|)
expr_stmt|;
name|rowId
operator|=
name|rowIdInspector
operator|.
name|get
argument_list|(
name|recIdInspector
operator|.
name|getStructFieldData
argument_list|(
name|rowIdValue
argument_list|,
name|rowIdField
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|operation
operator|==
name|INSERT_OPERATION
condition|)
block|{
name|rowId
operator|+=
name|rowIdOffset
expr_stmt|;
block|}
name|this
operator|.
name|rowId
operator|.
name|set
argument_list|(
name|rowId
argument_list|)
expr_stmt|;
name|this
operator|.
name|originalTransaction
operator|.
name|set
argument_list|(
name|originalTransaction
argument_list|)
expr_stmt|;
name|item
operator|.
name|setFieldValue
argument_list|(
name|OrcRecordUpdater
operator|.
name|ROW
argument_list|,
operator|(
name|operation
operator|==
name|DELETE_OPERATION
condition|?
literal|null
else|:
name|row
operator|)
argument_list|)
expr_stmt|;
name|indexBuilder
operator|.
name|addKey
argument_list|(
name|operation
argument_list|,
name|originalTransaction
argument_list|,
name|bucket
operator|.
name|get
argument_list|()
argument_list|,
name|rowId
argument_list|)
expr_stmt|;
name|writer
operator|.
name|addRow
argument_list|(
name|item
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|insert
parameter_list|(
name|long
name|currentTransaction
parameter_list|,
name|Object
name|row
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|this
operator|.
name|currentTransaction
operator|.
name|get
argument_list|()
operator|!=
name|currentTransaction
condition|)
block|{
name|insertedRows
operator|=
literal|0
expr_stmt|;
comment|//this method is almost no-op in hcatalog.streaming case since statementId == 0 is
comment|//always true in that case
name|rowIdOffset
operator|=
name|findRowIdOffsetForInsert
argument_list|()
expr_stmt|;
block|}
name|addEvent
argument_list|(
name|INSERT_OPERATION
argument_list|,
name|currentTransaction
argument_list|,
name|insertedRows
operator|++
argument_list|,
name|row
argument_list|)
expr_stmt|;
name|rowCountDelta
operator|++
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|update
parameter_list|(
name|long
name|currentTransaction
parameter_list|,
name|Object
name|row
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|this
operator|.
name|currentTransaction
operator|.
name|get
argument_list|()
operator|!=
name|currentTransaction
condition|)
block|{
name|insertedRows
operator|=
literal|0
expr_stmt|;
block|}
name|addEvent
argument_list|(
name|UPDATE_OPERATION
argument_list|,
name|currentTransaction
argument_list|,
operator|-
literal|1L
argument_list|,
name|row
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|delete
parameter_list|(
name|long
name|currentTransaction
parameter_list|,
name|Object
name|row
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|this
operator|.
name|currentTransaction
operator|.
name|get
argument_list|()
operator|!=
name|currentTransaction
condition|)
block|{
name|insertedRows
operator|=
literal|0
expr_stmt|;
block|}
name|addEvent
argument_list|(
name|DELETE_OPERATION
argument_list|,
name|currentTransaction
argument_list|,
operator|-
literal|1
argument_list|,
name|row
argument_list|)
expr_stmt|;
name|rowCountDelta
operator|--
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|flush
parameter_list|()
throws|throws
name|IOException
block|{
comment|// We only support flushes on files with multiple transactions, because
comment|// flushes create significant overhead in HDFS. Record updaters with a
comment|// single transaction should be closed rather than flushed.
if|if
condition|(
name|flushLengths
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"Attempting to flush a RecordUpdater on "
operator|+
name|path
operator|+
literal|" with a single transaction."
argument_list|)
throw|;
block|}
name|long
name|len
init|=
name|writer
operator|.
name|writeIntermediateFooter
argument_list|()
decl_stmt|;
name|flushLengths
operator|.
name|writeLong
argument_list|(
name|len
argument_list|)
expr_stmt|;
name|OrcInputFormat
operator|.
name|SHIMS
operator|.
name|hflush
argument_list|(
name|flushLengths
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|close
parameter_list|(
name|boolean
name|abort
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|abort
condition|)
block|{
if|if
condition|(
name|flushLengths
operator|==
literal|null
condition|)
block|{
name|fs
operator|.
name|delete
argument_list|(
name|path
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|writer
operator|!=
literal|null
condition|)
name|writer
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|flushLengths
operator|!=
literal|null
condition|)
block|{
name|flushLengths
operator|.
name|close
argument_list|()
expr_stmt|;
name|fs
operator|.
name|delete
argument_list|(
name|getSideFile
argument_list|(
name|path
argument_list|)
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
name|writer
operator|=
literal|null
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|SerDeStats
name|getStats
parameter_list|()
block|{
name|SerDeStats
name|stats
init|=
operator|new
name|SerDeStats
argument_list|()
decl_stmt|;
name|stats
operator|.
name|setRowCount
argument_list|(
name|rowCountDelta
argument_list|)
expr_stmt|;
comment|// Don't worry about setting raw data size diff.  I have no idea how to calculate that
comment|// without finding the row we are updating or deleting, which would be a mess.
return|return
name|stats
return|;
block|}
annotation|@
name|VisibleForTesting
name|Writer
name|getWriter
parameter_list|()
block|{
return|return
name|writer
return|;
block|}
specifier|private
specifier|static
specifier|final
name|Charset
name|utf8
init|=
name|Charset
operator|.
name|forName
argument_list|(
literal|"UTF-8"
argument_list|)
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|CharsetDecoder
name|utf8Decoder
init|=
name|utf8
operator|.
name|newDecoder
argument_list|()
decl_stmt|;
specifier|static
name|RecordIdentifier
index|[]
name|parseKeyIndex
parameter_list|(
name|Reader
name|reader
parameter_list|)
block|{
name|String
index|[]
name|stripes
decl_stmt|;
try|try
block|{
name|ByteBuffer
name|val
init|=
name|reader
operator|.
name|getMetadataValue
argument_list|(
name|OrcRecordUpdater
operator|.
name|ACID_KEY_INDEX_NAME
argument_list|)
operator|.
name|duplicate
argument_list|()
decl_stmt|;
name|stripes
operator|=
name|utf8Decoder
operator|.
name|decode
argument_list|(
name|val
argument_list|)
operator|.
name|toString
argument_list|()
operator|.
name|split
argument_list|(
literal|";"
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|CharacterCodingException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Bad string encoding for "
operator|+
name|OrcRecordUpdater
operator|.
name|ACID_KEY_INDEX_NAME
argument_list|,
name|e
argument_list|)
throw|;
block|}
name|RecordIdentifier
index|[]
name|result
init|=
operator|new
name|RecordIdentifier
index|[
name|stripes
operator|.
name|length
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|stripes
operator|.
name|length
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|stripes
index|[
name|i
index|]
operator|.
name|length
argument_list|()
operator|!=
literal|0
condition|)
block|{
name|String
index|[]
name|parts
init|=
name|stripes
index|[
name|i
index|]
operator|.
name|split
argument_list|(
literal|","
argument_list|)
decl_stmt|;
name|result
index|[
name|i
index|]
operator|=
operator|new
name|RecordIdentifier
argument_list|()
expr_stmt|;
name|result
index|[
name|i
index|]
operator|.
name|setValues
argument_list|(
name|Long
operator|.
name|parseLong
argument_list|(
name|parts
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|Integer
operator|.
name|parseInt
argument_list|(
name|parts
index|[
literal|1
index|]
argument_list|)
argument_list|,
name|Long
operator|.
name|parseLong
argument_list|(
name|parts
index|[
literal|2
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|result
return|;
block|}
comment|/**    * {@link KeyIndexBuilder} creates these    */
specifier|static
name|AcidStats
name|parseAcidStats
parameter_list|(
name|Reader
name|reader
parameter_list|)
block|{
name|String
name|statsSerialized
decl_stmt|;
try|try
block|{
name|ByteBuffer
name|val
init|=
name|reader
operator|.
name|getMetadataValue
argument_list|(
name|OrcRecordUpdater
operator|.
name|ACID_STATS
argument_list|)
operator|.
name|duplicate
argument_list|()
decl_stmt|;
name|statsSerialized
operator|=
name|utf8Decoder
operator|.
name|decode
argument_list|(
name|val
argument_list|)
operator|.
name|toString
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|CharacterCodingException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Bad string encoding for "
operator|+
name|OrcRecordUpdater
operator|.
name|ACID_STATS
argument_list|,
name|e
argument_list|)
throw|;
block|}
return|return
operator|new
name|AcidStats
argument_list|(
name|statsSerialized
argument_list|)
return|;
block|}
specifier|static
class|class
name|KeyIndexBuilder
implements|implements
name|OrcFile
operator|.
name|WriterCallback
block|{
name|StringBuilder
name|lastKey
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|long
name|lastTransaction
decl_stmt|;
name|int
name|lastBucket
decl_stmt|;
name|long
name|lastRowId
decl_stmt|;
name|AcidStats
name|acidStats
init|=
operator|new
name|AcidStats
argument_list|()
decl_stmt|;
annotation|@
name|Override
specifier|public
name|void
name|preStripeWrite
parameter_list|(
name|OrcFile
operator|.
name|WriterContext
name|context
parameter_list|)
throws|throws
name|IOException
block|{
name|lastKey
operator|.
name|append
argument_list|(
name|lastTransaction
argument_list|)
expr_stmt|;
name|lastKey
operator|.
name|append
argument_list|(
literal|','
argument_list|)
expr_stmt|;
name|lastKey
operator|.
name|append
argument_list|(
name|lastBucket
argument_list|)
expr_stmt|;
name|lastKey
operator|.
name|append
argument_list|(
literal|','
argument_list|)
expr_stmt|;
name|lastKey
operator|.
name|append
argument_list|(
name|lastRowId
argument_list|)
expr_stmt|;
name|lastKey
operator|.
name|append
argument_list|(
literal|';'
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|preFooterWrite
parameter_list|(
name|OrcFile
operator|.
name|WriterContext
name|context
parameter_list|)
throws|throws
name|IOException
block|{
name|context
operator|.
name|getWriter
argument_list|()
operator|.
name|addUserMetadata
argument_list|(
name|ACID_KEY_INDEX_NAME
argument_list|,
name|UTF8
operator|.
name|encode
argument_list|(
name|lastKey
operator|.
name|toString
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|context
operator|.
name|getWriter
argument_list|()
operator|.
name|addUserMetadata
argument_list|(
name|ACID_STATS
argument_list|,
name|UTF8
operator|.
name|encode
argument_list|(
name|acidStats
operator|.
name|serialize
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|void
name|addKey
parameter_list|(
name|int
name|op
parameter_list|,
name|long
name|transaction
parameter_list|,
name|int
name|bucket
parameter_list|,
name|long
name|rowId
parameter_list|)
block|{
switch|switch
condition|(
name|op
condition|)
block|{
case|case
name|INSERT_OPERATION
case|:
name|acidStats
operator|.
name|inserts
operator|+=
literal|1
expr_stmt|;
break|break;
case|case
name|UPDATE_OPERATION
case|:
name|acidStats
operator|.
name|updates
operator|+=
literal|1
expr_stmt|;
break|break;
case|case
name|DELETE_OPERATION
case|:
name|acidStats
operator|.
name|deletes
operator|+=
literal|1
expr_stmt|;
break|break;
default|default:
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Unknown operation "
operator|+
name|op
argument_list|)
throw|;
block|}
name|lastTransaction
operator|=
name|transaction
expr_stmt|;
name|lastBucket
operator|=
name|bucket
expr_stmt|;
name|lastRowId
operator|=
name|rowId
expr_stmt|;
block|}
block|}
comment|/**    * An ObjectInspector that will strip out the record identifier so that the underlying writer    * doesn't see it.    */
specifier|private
specifier|static
class|class
name|RecIdStrippingObjectInspector
extends|extends
name|StructObjectInspector
block|{
specifier|private
name|StructObjectInspector
name|wrapped
decl_stmt|;
name|List
argument_list|<
name|StructField
argument_list|>
name|fields
decl_stmt|;
name|StructField
name|recId
decl_stmt|;
name|RecIdStrippingObjectInspector
parameter_list|(
name|ObjectInspector
name|oi
parameter_list|,
name|int
name|rowIdColNum
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|oi
operator|instanceof
name|StructObjectInspector
operator|)
condition|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Serious problem, expected a StructObjectInspector, "
operator|+
literal|"but got a "
operator|+
name|oi
operator|.
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|)
throw|;
block|}
name|wrapped
operator|=
operator|(
name|StructObjectInspector
operator|)
name|oi
expr_stmt|;
name|List
argument_list|<
name|?
extends|extends
name|StructField
argument_list|>
name|wrappedFields
init|=
name|wrapped
operator|.
name|getAllStructFieldRefs
argument_list|()
decl_stmt|;
name|fields
operator|=
operator|new
name|ArrayList
argument_list|<
name|StructField
argument_list|>
argument_list|(
name|wrapped
operator|.
name|getAllStructFieldRefs
argument_list|()
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|wrappedFields
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|==
name|rowIdColNum
condition|)
block|{
name|recId
operator|=
name|wrappedFields
operator|.
name|get
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fields
operator|.
name|add
argument_list|(
name|wrappedFields
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
annotation|@
name|Override
specifier|public
name|List
argument_list|<
name|?
extends|extends
name|StructField
argument_list|>
name|getAllStructFieldRefs
parameter_list|()
block|{
return|return
name|fields
return|;
block|}
annotation|@
name|Override
specifier|public
name|StructField
name|getStructFieldRef
parameter_list|(
name|String
name|fieldName
parameter_list|)
block|{
return|return
name|wrapped
operator|.
name|getStructFieldRef
argument_list|(
name|fieldName
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|Object
name|getStructFieldData
parameter_list|(
name|Object
name|data
parameter_list|,
name|StructField
name|fieldRef
parameter_list|)
block|{
comment|// For performance don't check that that the fieldRef isn't recId everytime,
comment|// just assume that the caller used getAllStructFieldRefs and thus doesn't have that fieldRef
return|return
name|wrapped
operator|.
name|getStructFieldData
argument_list|(
name|data
argument_list|,
name|fieldRef
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|List
argument_list|<
name|Object
argument_list|>
name|getStructFieldsDataAsList
parameter_list|(
name|Object
name|data
parameter_list|)
block|{
return|return
name|wrapped
operator|.
name|getStructFieldsDataAsList
argument_list|(
name|data
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|getTypeName
parameter_list|()
block|{
return|return
name|wrapped
operator|.
name|getTypeName
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|Category
name|getCategory
parameter_list|()
block|{
return|return
name|wrapped
operator|.
name|getCategory
argument_list|()
return|;
block|}
name|StructField
name|getRecId
parameter_list|()
block|{
return|return
name|recId
return|;
block|}
block|}
block|}
end_class

end_unit

