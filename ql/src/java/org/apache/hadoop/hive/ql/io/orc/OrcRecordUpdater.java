begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|io
operator|.
name|orc
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|ByteBuffer
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|charset
operator|.
name|CharacterCodingException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|charset
operator|.
name|Charset
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|charset
operator|.
name|CharsetDecoder
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FSDataOutputStream
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FileSystem
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|Path
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|conf
operator|.
name|HiveConf
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|io
operator|.
name|AcidOutputFormat
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|io
operator|.
name|AcidUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|io
operator|.
name|BucketCodec
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|io
operator|.
name|RecordIdentifier
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|io
operator|.
name|RecordUpdater
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|metadata
operator|.
name|Hive
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|SerDeStats
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|objectinspector
operator|.
name|ObjectInspector
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|objectinspector
operator|.
name|StructField
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|objectinspector
operator|.
name|StructObjectInspector
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|objectinspector
operator|.
name|primitive
operator|.
name|IntObjectInspector
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|objectinspector
operator|.
name|primitive
operator|.
name|LongObjectInspector
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|objectinspector
operator|.
name|primitive
operator|.
name|PrimitiveObjectInspectorFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|IntWritable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|LongWritable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|orc
operator|.
name|OrcConf
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|orc
operator|.
name|impl
operator|.
name|AcidStats
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|orc
operator|.
name|impl
operator|.
name|OrcAcidUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_comment
comment|/**  * A RecordUpdater where the files are stored as ORC.  * A note on various record structures: the {@code row} coming in (as in {@link #insert(long, Object)}  * for example), is a struct like<RecordIdentifier, f1, ... fn> but what is written to the file  * * is<op, otid, writerId, rowid, ctid,<f1, ... fn>> (see {@link #createEventSchema(ObjectInspector)})  * So there are OIs here to make the translation.  */
end_comment

begin_class
specifier|public
class|class
name|OrcRecordUpdater
implements|implements
name|RecordUpdater
block|{
specifier|private
specifier|static
specifier|final
name|Logger
name|LOG
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|OrcRecordUpdater
operator|.
name|class
argument_list|)
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|String
name|ACID_KEY_INDEX_NAME
init|=
literal|"hive.acid.key.index"
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|String
name|ACID_FORMAT
init|=
literal|"_orc_acid_version"
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|int
name|ORC_ACID_VERSION
init|=
literal|0
decl_stmt|;
specifier|final
specifier|static
name|int
name|INSERT_OPERATION
init|=
literal|0
decl_stmt|;
specifier|final
specifier|static
name|int
name|UPDATE_OPERATION
init|=
literal|1
decl_stmt|;
specifier|final
specifier|static
name|int
name|DELETE_OPERATION
init|=
literal|2
decl_stmt|;
specifier|final
specifier|static
name|int
name|OPERATION
init|=
literal|0
decl_stmt|;
specifier|final
specifier|static
name|int
name|ORIGINAL_TRANSACTION
init|=
literal|1
decl_stmt|;
specifier|final
specifier|static
name|int
name|BUCKET
init|=
literal|2
decl_stmt|;
specifier|final
specifier|static
name|int
name|ROW_ID
init|=
literal|3
decl_stmt|;
specifier|final
specifier|static
name|int
name|CURRENT_TRANSACTION
init|=
literal|4
decl_stmt|;
specifier|final
specifier|static
name|int
name|ROW
init|=
literal|5
decl_stmt|;
specifier|final
specifier|static
name|int
name|FIELDS
init|=
literal|6
decl_stmt|;
specifier|final
specifier|static
name|int
name|DELTA_BUFFER_SIZE
init|=
literal|16
operator|*
literal|1024
decl_stmt|;
specifier|final
specifier|static
name|long
name|DELTA_STRIPE_SIZE
init|=
literal|16
operator|*
literal|1024
operator|*
literal|1024
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|Charset
name|UTF8
init|=
name|Charset
operator|.
name|forName
argument_list|(
literal|"UTF-8"
argument_list|)
decl_stmt|;
specifier|private
specifier|final
name|AcidOutputFormat
operator|.
name|Options
name|options
decl_stmt|;
specifier|private
specifier|final
name|AcidUtils
operator|.
name|AcidOperationalProperties
name|acidOperationalProperties
decl_stmt|;
specifier|private
specifier|final
name|Path
name|path
decl_stmt|;
specifier|private
name|Path
name|deleteEventPath
decl_stmt|;
specifier|private
specifier|final
name|FileSystem
name|fs
decl_stmt|;
specifier|private
name|OrcFile
operator|.
name|WriterOptions
name|writerOptions
decl_stmt|;
specifier|private
name|OrcFile
operator|.
name|WriterOptions
name|deleteWriterOptions
decl_stmt|;
specifier|private
name|Writer
name|writer
init|=
literal|null
decl_stmt|;
specifier|private
name|boolean
name|writerClosed
init|=
literal|false
decl_stmt|;
specifier|private
name|Writer
name|deleteEventWriter
init|=
literal|null
decl_stmt|;
specifier|private
specifier|final
name|FSDataOutputStream
name|flushLengths
decl_stmt|;
specifier|private
specifier|final
name|OrcStruct
name|item
decl_stmt|;
specifier|private
specifier|final
name|IntWritable
name|operation
init|=
operator|new
name|IntWritable
argument_list|()
decl_stmt|;
specifier|private
specifier|final
name|LongWritable
name|currentTransaction
init|=
operator|new
name|LongWritable
argument_list|(
operator|-
literal|1
argument_list|)
decl_stmt|;
specifier|private
specifier|final
name|LongWritable
name|originalTransaction
init|=
operator|new
name|LongWritable
argument_list|(
operator|-
literal|1
argument_list|)
decl_stmt|;
specifier|private
specifier|final
name|IntWritable
name|bucket
init|=
operator|new
name|IntWritable
argument_list|()
decl_stmt|;
specifier|private
specifier|final
name|LongWritable
name|rowId
init|=
operator|new
name|LongWritable
argument_list|()
decl_stmt|;
specifier|private
name|long
name|insertedRows
init|=
literal|0
decl_stmt|;
comment|// This records how many rows have been inserted or deleted.  It is separate from insertedRows
comment|// because that is monotonically increasing to give new unique row ids.
specifier|private
name|long
name|rowCountDelta
init|=
literal|0
decl_stmt|;
specifier|private
specifier|final
name|KeyIndexBuilder
name|indexBuilder
init|=
operator|new
name|KeyIndexBuilder
argument_list|(
literal|"insert"
argument_list|)
decl_stmt|;
specifier|private
name|KeyIndexBuilder
name|deleteEventIndexBuilder
decl_stmt|;
specifier|private
name|StructField
name|recIdField
init|=
literal|null
decl_stmt|;
comment|// field to look for the record identifier in
specifier|private
name|StructField
name|rowIdField
init|=
literal|null
decl_stmt|;
comment|// field inside recId to look for row id in
specifier|private
name|StructField
name|originalTxnField
init|=
literal|null
decl_stmt|;
comment|// field inside recId to look for original txn in
specifier|private
name|StructField
name|bucketField
init|=
literal|null
decl_stmt|;
comment|// field inside recId to look for bucket in
specifier|private
name|StructObjectInspector
name|rowInspector
decl_stmt|;
comment|// OI for the original row
specifier|private
name|StructObjectInspector
name|recIdInspector
decl_stmt|;
comment|// OI for the record identifier struct
specifier|private
name|LongObjectInspector
name|rowIdInspector
decl_stmt|;
comment|// OI for the long row id inside the recordIdentifier
specifier|private
name|LongObjectInspector
name|origTxnInspector
decl_stmt|;
comment|// OI for the original txn inside the record
comment|// identifer
specifier|private
name|IntObjectInspector
name|bucketInspector
decl_stmt|;
specifier|static
name|int
name|getOperation
parameter_list|(
name|OrcStruct
name|struct
parameter_list|)
block|{
return|return
operator|(
operator|(
name|IntWritable
operator|)
name|struct
operator|.
name|getFieldValue
argument_list|(
name|OPERATION
argument_list|)
operator|)
operator|.
name|get
argument_list|()
return|;
block|}
specifier|static
name|long
name|getCurrentTransaction
parameter_list|(
name|OrcStruct
name|struct
parameter_list|)
block|{
return|return
operator|(
operator|(
name|LongWritable
operator|)
name|struct
operator|.
name|getFieldValue
argument_list|(
name|CURRENT_TRANSACTION
argument_list|)
operator|)
operator|.
name|get
argument_list|()
return|;
block|}
specifier|static
name|long
name|getOriginalTransaction
parameter_list|(
name|OrcStruct
name|struct
parameter_list|)
block|{
return|return
operator|(
operator|(
name|LongWritable
operator|)
name|struct
operator|.
name|getFieldValue
argument_list|(
name|ORIGINAL_TRANSACTION
argument_list|)
operator|)
operator|.
name|get
argument_list|()
return|;
block|}
specifier|static
name|int
name|getBucket
parameter_list|(
name|OrcStruct
name|struct
parameter_list|)
block|{
return|return
operator|(
operator|(
name|IntWritable
operator|)
name|struct
operator|.
name|getFieldValue
argument_list|(
name|BUCKET
argument_list|)
operator|)
operator|.
name|get
argument_list|()
return|;
block|}
specifier|static
name|long
name|getRowId
parameter_list|(
name|OrcStruct
name|struct
parameter_list|)
block|{
return|return
operator|(
operator|(
name|LongWritable
operator|)
name|struct
operator|.
name|getFieldValue
argument_list|(
name|ROW_ID
argument_list|)
operator|)
operator|.
name|get
argument_list|()
return|;
block|}
specifier|static
name|OrcStruct
name|getRow
parameter_list|(
name|OrcStruct
name|struct
parameter_list|)
block|{
if|if
condition|(
name|struct
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
else|else
block|{
return|return
operator|(
name|OrcStruct
operator|)
name|struct
operator|.
name|getFieldValue
argument_list|(
name|ROW
argument_list|)
return|;
block|}
block|}
comment|/**    * An extension to AcidOutputFormat that allows users to add additional    * options.    *    * todo: since this is only used for testing could we not control the writer some other way?    * to simplify {@link #OrcRecordUpdater(Path, AcidOutputFormat.Options)}    */
specifier|final
specifier|static
class|class
name|OrcOptions
extends|extends
name|AcidOutputFormat
operator|.
name|Options
block|{
name|OrcFile
operator|.
name|WriterOptions
name|orcOptions
init|=
literal|null
decl_stmt|;
name|OrcOptions
parameter_list|(
name|Configuration
name|conf
parameter_list|)
block|{
name|super
argument_list|(
name|conf
argument_list|)
expr_stmt|;
block|}
name|OrcOptions
name|orcOptions
parameter_list|(
name|OrcFile
operator|.
name|WriterOptions
name|opts
parameter_list|)
block|{
name|this
operator|.
name|orcOptions
operator|=
name|opts
expr_stmt|;
return|return
name|this
return|;
block|}
name|OrcFile
operator|.
name|WriterOptions
name|getOrcOptions
parameter_list|()
block|{
return|return
name|orcOptions
return|;
block|}
block|}
comment|/**    * Create an object inspector for the ACID event based on the object inspector    * for the underlying row.    * @param rowInspector the row's object inspector    * @return an object inspector for the event stream    */
specifier|static
name|StructObjectInspector
name|createEventSchema
parameter_list|(
name|ObjectInspector
name|rowInspector
parameter_list|)
block|{
name|List
argument_list|<
name|StructField
argument_list|>
name|fields
init|=
operator|new
name|ArrayList
argument_list|<
name|StructField
argument_list|>
argument_list|()
decl_stmt|;
name|fields
operator|.
name|add
argument_list|(
operator|new
name|OrcStruct
operator|.
name|Field
argument_list|(
literal|"operation"
argument_list|,
name|PrimitiveObjectInspectorFactory
operator|.
name|writableIntObjectInspector
argument_list|,
name|OPERATION
argument_list|)
argument_list|)
expr_stmt|;
name|fields
operator|.
name|add
argument_list|(
operator|new
name|OrcStruct
operator|.
name|Field
argument_list|(
literal|"originalTransaction"
argument_list|,
name|PrimitiveObjectInspectorFactory
operator|.
name|writableLongObjectInspector
argument_list|,
name|ORIGINAL_TRANSACTION
argument_list|)
argument_list|)
expr_stmt|;
name|fields
operator|.
name|add
argument_list|(
operator|new
name|OrcStruct
operator|.
name|Field
argument_list|(
literal|"bucket"
argument_list|,
name|PrimitiveObjectInspectorFactory
operator|.
name|writableIntObjectInspector
argument_list|,
name|BUCKET
argument_list|)
argument_list|)
expr_stmt|;
name|fields
operator|.
name|add
argument_list|(
operator|new
name|OrcStruct
operator|.
name|Field
argument_list|(
literal|"rowId"
argument_list|,
name|PrimitiveObjectInspectorFactory
operator|.
name|writableLongObjectInspector
argument_list|,
name|ROW_ID
argument_list|)
argument_list|)
expr_stmt|;
name|fields
operator|.
name|add
argument_list|(
operator|new
name|OrcStruct
operator|.
name|Field
argument_list|(
literal|"currentTransaction"
argument_list|,
name|PrimitiveObjectInspectorFactory
operator|.
name|writableLongObjectInspector
argument_list|,
name|CURRENT_TRANSACTION
argument_list|)
argument_list|)
expr_stmt|;
name|fields
operator|.
name|add
argument_list|(
operator|new
name|OrcStruct
operator|.
name|Field
argument_list|(
literal|"row"
argument_list|,
name|rowInspector
argument_list|,
name|ROW
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|new
name|OrcStruct
operator|.
name|OrcStructInspector
argument_list|(
name|fields
argument_list|)
return|;
block|}
name|OrcRecordUpdater
parameter_list|(
name|Path
name|path
parameter_list|,
name|AcidOutputFormat
operator|.
name|Options
name|options
parameter_list|)
throws|throws
name|IOException
block|{
name|this
operator|.
name|options
operator|=
name|options
expr_stmt|;
comment|// Initialize acidOperationalProperties based on table properties, and
comment|// if they are not available, see if we can find it in the job configuration.
comment|// We have to look at these two places instead of just the conf, because Streaming Ingest
comment|// uses table properties, while normal Hive SQL inserts/updates/deletes will place this
comment|// value in the configuration object.
if|if
condition|(
name|options
operator|.
name|getTableProperties
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|this
operator|.
name|acidOperationalProperties
operator|=
name|AcidUtils
operator|.
name|getAcidOperationalProperties
argument_list|(
name|options
operator|.
name|getTableProperties
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|this
operator|.
name|acidOperationalProperties
operator|=
name|AcidUtils
operator|.
name|getAcidOperationalProperties
argument_list|(
name|options
operator|.
name|getConfiguration
argument_list|()
argument_list|)
expr_stmt|;
block|}
assert|assert
name|this
operator|.
name|acidOperationalProperties
operator|.
name|isSplitUpdate
argument_list|()
operator|:
literal|"HIVE-17089?!"
assert|;
name|BucketCodec
name|bucketCodec
init|=
name|BucketCodec
operator|.
name|V1
decl_stmt|;
if|if
condition|(
name|options
operator|.
name|getConfiguration
argument_list|()
operator|!=
literal|null
condition|)
block|{
comment|//so that we can test "old" files
name|Configuration
name|hc
init|=
name|options
operator|.
name|getConfiguration
argument_list|()
decl_stmt|;
if|if
condition|(
name|hc
operator|.
name|getBoolean
argument_list|(
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVE_IN_TEST
operator|.
name|name
argument_list|()
argument_list|,
literal|false
argument_list|)
operator|||
name|hc
operator|.
name|getBoolean
argument_list|(
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVE_IN_TEZ_TEST
operator|.
name|name
argument_list|()
argument_list|,
literal|false
argument_list|)
condition|)
block|{
name|bucketCodec
operator|=
name|BucketCodec
operator|.
name|getCodec
argument_list|(
name|hc
operator|.
name|getInt
argument_list|(
name|HiveConf
operator|.
name|ConfVars
operator|.
name|TESTMODE_BUCKET_CODEC_VERSION
operator|.
name|name
argument_list|()
argument_list|,
name|BucketCodec
operator|.
name|V1
operator|.
name|getVersion
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|this
operator|.
name|bucket
operator|.
name|set
argument_list|(
name|bucketCodec
operator|.
name|encode
argument_list|(
name|options
argument_list|)
argument_list|)
expr_stmt|;
name|this
operator|.
name|path
operator|=
name|AcidUtils
operator|.
name|createFilename
argument_list|(
name|path
argument_list|,
name|options
argument_list|)
expr_stmt|;
name|this
operator|.
name|deleteEventWriter
operator|=
literal|null
expr_stmt|;
name|this
operator|.
name|deleteEventPath
operator|=
literal|null
expr_stmt|;
name|FileSystem
name|fs
init|=
name|options
operator|.
name|getFilesystem
argument_list|()
decl_stmt|;
if|if
condition|(
name|fs
operator|==
literal|null
condition|)
block|{
name|fs
operator|=
name|path
operator|.
name|getFileSystem
argument_list|(
name|options
operator|.
name|getConfiguration
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|this
operator|.
name|fs
operator|=
name|fs
expr_stmt|;
name|Path
name|formatFile
init|=
operator|new
name|Path
argument_list|(
name|path
argument_list|,
name|ACID_FORMAT
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|fs
operator|.
name|exists
argument_list|(
name|formatFile
argument_list|)
condition|)
block|{
try|try
init|(
name|FSDataOutputStream
name|strm
init|=
name|fs
operator|.
name|create
argument_list|(
name|formatFile
argument_list|,
literal|false
argument_list|)
init|)
block|{
name|strm
operator|.
name|writeInt
argument_list|(
name|ORC_ACID_VERSION
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ioe
parameter_list|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Failed to create "
operator|+
name|path
operator|+
literal|"/"
operator|+
name|ACID_FORMAT
operator|+
literal|" with "
operator|+
name|ioe
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|options
operator|.
name|getMinimumTransactionId
argument_list|()
operator|!=
name|options
operator|.
name|getMaximumTransactionId
argument_list|()
operator|&&
operator|!
name|options
operator|.
name|isWritingBase
argument_list|()
condition|)
block|{
comment|//throw if file already exists as that should never happen
name|flushLengths
operator|=
name|fs
operator|.
name|create
argument_list|(
name|OrcAcidUtils
operator|.
name|getSideFile
argument_list|(
name|this
operator|.
name|path
argument_list|)
argument_list|,
literal|false
argument_list|,
literal|8
argument_list|,
name|options
operator|.
name|getReporter
argument_list|()
argument_list|)
expr_stmt|;
name|flushLengths
operator|.
name|writeLong
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|OrcInputFormat
operator|.
name|SHIMS
operator|.
name|hflush
argument_list|(
name|flushLengths
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|flushLengths
operator|=
literal|null
expr_stmt|;
block|}
name|this
operator|.
name|writerOptions
operator|=
literal|null
expr_stmt|;
comment|// If writing delta dirs, we need to make a clone of original options, to avoid polluting it for
comment|// the base writer
if|if
condition|(
name|options
operator|.
name|isWritingBase
argument_list|()
condition|)
block|{
if|if
condition|(
name|options
operator|instanceof
name|OrcOptions
condition|)
block|{
name|writerOptions
operator|=
operator|(
operator|(
name|OrcOptions
operator|)
name|options
operator|)
operator|.
name|getOrcOptions
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|writerOptions
operator|==
literal|null
condition|)
block|{
name|writerOptions
operator|=
name|OrcFile
operator|.
name|writerOptions
argument_list|(
name|options
operator|.
name|getTableProperties
argument_list|()
argument_list|,
name|options
operator|.
name|getConfiguration
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// delta writer
name|AcidOutputFormat
operator|.
name|Options
name|optionsCloneForDelta
init|=
name|options
operator|.
name|clone
argument_list|()
decl_stmt|;
if|if
condition|(
name|optionsCloneForDelta
operator|instanceof
name|OrcOptions
condition|)
block|{
name|writerOptions
operator|=
operator|(
operator|(
name|OrcOptions
operator|)
name|optionsCloneForDelta
operator|)
operator|.
name|getOrcOptions
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|writerOptions
operator|==
literal|null
condition|)
block|{
name|writerOptions
operator|=
name|OrcFile
operator|.
name|writerOptions
argument_list|(
name|optionsCloneForDelta
operator|.
name|getTableProperties
argument_list|()
argument_list|,
name|optionsCloneForDelta
operator|.
name|getConfiguration
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|this
operator|.
name|acidOperationalProperties
operator|.
name|isSplitUpdate
argument_list|()
condition|)
block|{
name|AcidOutputFormat
operator|.
name|Options
name|deleteOptions
init|=
name|options
operator|.
name|clone
argument_list|()
operator|.
name|writingDeleteDelta
argument_list|(
literal|true
argument_list|)
decl_stmt|;
comment|// If this is a split-update, we initialize a delete delta file path in anticipation that
comment|// they would write update/delete events to that separate file.
comment|// This writes to a file in directory which starts with "delete_delta_..."
comment|// The actual initialization of a writer only happens if any delete events are written
comment|//to avoid empty files.
name|this
operator|.
name|deleteEventPath
operator|=
name|AcidUtils
operator|.
name|createFilename
argument_list|(
name|path
argument_list|,
name|deleteOptions
argument_list|)
expr_stmt|;
comment|/**          * HIVE-14514 is not done so we can't clone writerOptions().  So here we create a new          * options object to make sure insert and delete writers don't share them (like the          * callback object, for example)          * In any case insert writer and delete writer would most likely have very different          * characteristics - delete writer only writes a tiny amount of data.  Once we do early          * update split, each {@link OrcRecordUpdater} will have only 1 writer. (except for Mutate API)          * Then it would perhaps make sense to take writerOptions as input - how?.          */
name|this
operator|.
name|deleteWriterOptions
operator|=
name|OrcFile
operator|.
name|writerOptions
argument_list|(
name|optionsCloneForDelta
operator|.
name|getTableProperties
argument_list|()
argument_list|,
name|optionsCloneForDelta
operator|.
name|getConfiguration
argument_list|()
argument_list|)
expr_stmt|;
name|this
operator|.
name|deleteWriterOptions
operator|.
name|inspector
argument_list|(
name|createEventSchema
argument_list|(
name|findRecId
argument_list|(
name|options
operator|.
name|getInspector
argument_list|()
argument_list|,
name|options
operator|.
name|getRecordIdColumn
argument_list|()
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// get buffer size and stripe size for base writer
name|int
name|baseBufferSizeValue
init|=
name|writerOptions
operator|.
name|getBufferSize
argument_list|()
decl_stmt|;
name|long
name|baseStripeSizeValue
init|=
name|writerOptions
operator|.
name|getStripeSize
argument_list|()
decl_stmt|;
comment|// overwrite buffer size and stripe size for delta writer, based on BASE_DELTA_RATIO
name|int
name|ratio
init|=
operator|(
name|int
operator|)
name|OrcConf
operator|.
name|BASE_DELTA_RATIO
operator|.
name|getLong
argument_list|(
name|options
operator|.
name|getConfiguration
argument_list|()
argument_list|)
decl_stmt|;
name|writerOptions
operator|.
name|bufferSize
argument_list|(
name|baseBufferSizeValue
operator|/
name|ratio
argument_list|)
expr_stmt|;
name|writerOptions
operator|.
name|stripeSize
argument_list|(
name|baseStripeSizeValue
operator|/
name|ratio
argument_list|)
expr_stmt|;
name|writerOptions
operator|.
name|blockPadding
argument_list|(
literal|false
argument_list|)
expr_stmt|;
block|}
name|writerOptions
operator|.
name|fileSystem
argument_list|(
name|fs
argument_list|)
operator|.
name|callback
argument_list|(
name|indexBuilder
argument_list|)
expr_stmt|;
name|rowInspector
operator|=
operator|(
name|StructObjectInspector
operator|)
name|options
operator|.
name|getInspector
argument_list|()
expr_stmt|;
name|writerOptions
operator|.
name|inspector
argument_list|(
name|createEventSchema
argument_list|(
name|findRecId
argument_list|(
name|options
operator|.
name|getInspector
argument_list|()
argument_list|,
name|options
operator|.
name|getRecordIdColumn
argument_list|()
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|item
operator|=
operator|new
name|OrcStruct
argument_list|(
name|FIELDS
argument_list|)
expr_stmt|;
name|item
operator|.
name|setFieldValue
argument_list|(
name|OPERATION
argument_list|,
name|operation
argument_list|)
expr_stmt|;
name|item
operator|.
name|setFieldValue
argument_list|(
name|CURRENT_TRANSACTION
argument_list|,
name|currentTransaction
argument_list|)
expr_stmt|;
name|item
operator|.
name|setFieldValue
argument_list|(
name|ORIGINAL_TRANSACTION
argument_list|,
name|originalTransaction
argument_list|)
expr_stmt|;
name|item
operator|.
name|setFieldValue
argument_list|(
name|BUCKET
argument_list|,
name|bucket
argument_list|)
expr_stmt|;
name|item
operator|.
name|setFieldValue
argument_list|(
name|ROW_ID
argument_list|,
name|rowId
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
operator|+
literal|"["
operator|+
name|path
operator|+
literal|"]"
return|;
block|}
comment|// Find the record identifier column (if there) and return a possibly new ObjectInspector that
comment|// will strain out the record id for the underlying writer.
specifier|private
name|ObjectInspector
name|findRecId
parameter_list|(
name|ObjectInspector
name|inspector
parameter_list|,
name|int
name|rowIdColNum
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|inspector
operator|instanceof
name|StructObjectInspector
operator|)
condition|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Serious problem, expected a StructObjectInspector, but got a "
operator|+
name|inspector
operator|.
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|)
throw|;
block|}
if|if
condition|(
name|rowIdColNum
operator|<
literal|0
condition|)
block|{
return|return
name|inspector
return|;
block|}
else|else
block|{
name|RecIdStrippingObjectInspector
name|newInspector
init|=
operator|new
name|RecIdStrippingObjectInspector
argument_list|(
name|inspector
argument_list|,
name|rowIdColNum
argument_list|)
decl_stmt|;
name|recIdField
operator|=
name|newInspector
operator|.
name|getRecId
argument_list|()
expr_stmt|;
name|List
argument_list|<
name|?
extends|extends
name|StructField
argument_list|>
name|fields
init|=
operator|(
operator|(
name|StructObjectInspector
operator|)
name|recIdField
operator|.
name|getFieldObjectInspector
argument_list|()
operator|)
operator|.
name|getAllStructFieldRefs
argument_list|()
decl_stmt|;
comment|// Go by position, not field name, as field names aren't guaranteed.  The order of fields
comment|// in RecordIdentifier is transactionId, bucketId, rowId
name|originalTxnField
operator|=
name|fields
operator|.
name|get
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|origTxnInspector
operator|=
operator|(
name|LongObjectInspector
operator|)
name|originalTxnField
operator|.
name|getFieldObjectInspector
argument_list|()
expr_stmt|;
name|bucketField
operator|=
name|fields
operator|.
name|get
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|bucketInspector
operator|=
operator|(
name|IntObjectInspector
operator|)
name|bucketField
operator|.
name|getFieldObjectInspector
argument_list|()
expr_stmt|;
name|rowIdField
operator|=
name|fields
operator|.
name|get
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|rowIdInspector
operator|=
operator|(
name|LongObjectInspector
operator|)
name|rowIdField
operator|.
name|getFieldObjectInspector
argument_list|()
expr_stmt|;
name|recIdInspector
operator|=
operator|(
name|StructObjectInspector
operator|)
name|recIdField
operator|.
name|getFieldObjectInspector
argument_list|()
expr_stmt|;
return|return
name|newInspector
return|;
block|}
block|}
comment|/**    * The INSERT event always uses {@link #bucket} that this {@link RecordUpdater} was created with    * thus even for unbucketed tables, the N in bucket_N file name matches writerId/bucketId even for    * late split    */
specifier|private
name|void
name|addSimpleEvent
parameter_list|(
name|int
name|operation
parameter_list|,
name|long
name|currentTransaction
parameter_list|,
name|long
name|rowId
parameter_list|,
name|Object
name|row
parameter_list|)
throws|throws
name|IOException
block|{
name|this
operator|.
name|operation
operator|.
name|set
argument_list|(
name|operation
argument_list|)
expr_stmt|;
name|this
operator|.
name|currentTransaction
operator|.
name|set
argument_list|(
name|currentTransaction
argument_list|)
expr_stmt|;
name|Integer
name|currentBucket
init|=
literal|null
decl_stmt|;
comment|// If this is an insert, originalTransaction should be set to this transaction.  If not,
comment|// it will be reset by the following if anyway.
name|long
name|originalTransaction
init|=
name|currentTransaction
decl_stmt|;
if|if
condition|(
name|operation
operator|==
name|DELETE_OPERATION
operator|||
name|operation
operator|==
name|UPDATE_OPERATION
condition|)
block|{
name|Object
name|rowIdValue
init|=
name|rowInspector
operator|.
name|getStructFieldData
argument_list|(
name|row
argument_list|,
name|recIdField
argument_list|)
decl_stmt|;
name|originalTransaction
operator|=
name|origTxnInspector
operator|.
name|get
argument_list|(
name|recIdInspector
operator|.
name|getStructFieldData
argument_list|(
name|rowIdValue
argument_list|,
name|originalTxnField
argument_list|)
argument_list|)
expr_stmt|;
name|rowId
operator|=
name|rowIdInspector
operator|.
name|get
argument_list|(
name|recIdInspector
operator|.
name|getStructFieldData
argument_list|(
name|rowIdValue
argument_list|,
name|rowIdField
argument_list|)
argument_list|)
expr_stmt|;
name|currentBucket
operator|=
name|setBucket
argument_list|(
name|bucketInspector
operator|.
name|get
argument_list|(
name|recIdInspector
operator|.
name|getStructFieldData
argument_list|(
name|rowIdValue
argument_list|,
name|bucketField
argument_list|)
argument_list|)
argument_list|,
name|operation
argument_list|)
expr_stmt|;
block|}
name|this
operator|.
name|rowId
operator|.
name|set
argument_list|(
name|rowId
argument_list|)
expr_stmt|;
name|this
operator|.
name|originalTransaction
operator|.
name|set
argument_list|(
name|originalTransaction
argument_list|)
expr_stmt|;
name|item
operator|.
name|setFieldValue
argument_list|(
name|OrcRecordUpdater
operator|.
name|OPERATION
argument_list|,
operator|new
name|IntWritable
argument_list|(
name|operation
argument_list|)
argument_list|)
expr_stmt|;
name|item
operator|.
name|setFieldValue
argument_list|(
name|OrcRecordUpdater
operator|.
name|ROW
argument_list|,
operator|(
name|operation
operator|==
name|DELETE_OPERATION
condition|?
literal|null
else|:
name|row
operator|)
argument_list|)
expr_stmt|;
name|indexBuilder
operator|.
name|addKey
argument_list|(
name|operation
argument_list|,
name|originalTransaction
argument_list|,
name|bucket
operator|.
name|get
argument_list|()
argument_list|,
name|rowId
argument_list|)
expr_stmt|;
if|if
condition|(
name|writer
operator|==
literal|null
condition|)
block|{
name|writer
operator|=
name|OrcFile
operator|.
name|createWriter
argument_list|(
name|path
argument_list|,
name|writerOptions
argument_list|)
expr_stmt|;
block|}
name|writer
operator|.
name|addRow
argument_list|(
name|item
argument_list|)
expr_stmt|;
name|restoreBucket
argument_list|(
name|currentBucket
argument_list|,
name|operation
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|addSplitUpdateEvent
parameter_list|(
name|int
name|operation
parameter_list|,
name|long
name|currentTransaction
parameter_list|,
name|long
name|rowId
parameter_list|,
name|Object
name|row
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|operation
operator|==
name|INSERT_OPERATION
condition|)
block|{
comment|// Just insert the record in the usual way, i.e., default to the simple behavior.
name|addSimpleEvent
argument_list|(
name|operation
argument_list|,
name|currentTransaction
argument_list|,
name|rowId
argument_list|,
name|row
argument_list|)
expr_stmt|;
return|return;
block|}
name|this
operator|.
name|operation
operator|.
name|set
argument_list|(
name|operation
argument_list|)
expr_stmt|;
name|this
operator|.
name|currentTransaction
operator|.
name|set
argument_list|(
name|currentTransaction
argument_list|)
expr_stmt|;
name|Object
name|rowValue
init|=
name|rowInspector
operator|.
name|getStructFieldData
argument_list|(
name|row
argument_list|,
name|recIdField
argument_list|)
decl_stmt|;
name|long
name|originalTransaction
init|=
name|origTxnInspector
operator|.
name|get
argument_list|(
name|recIdInspector
operator|.
name|getStructFieldData
argument_list|(
name|rowValue
argument_list|,
name|originalTxnField
argument_list|)
argument_list|)
decl_stmt|;
name|rowId
operator|=
name|rowIdInspector
operator|.
name|get
argument_list|(
name|recIdInspector
operator|.
name|getStructFieldData
argument_list|(
name|rowValue
argument_list|,
name|rowIdField
argument_list|)
argument_list|)
expr_stmt|;
name|Integer
name|currentBucket
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|operation
operator|==
name|DELETE_OPERATION
operator|||
name|operation
operator|==
name|UPDATE_OPERATION
condition|)
block|{
comment|/**        * make sure bucketProperty in the delete event is from the {@link row} rather than whatever        * {@link this#bucket} is.  For bucketed tables, the 2 must agree on bucketId encoded in it        * not for necessarily the whole value.  For unbucketed tables there is no relationship.        */
name|currentBucket
operator|=
name|setBucket
argument_list|(
name|bucketInspector
operator|.
name|get
argument_list|(
name|recIdInspector
operator|.
name|getStructFieldData
argument_list|(
name|rowValue
argument_list|,
name|bucketField
argument_list|)
argument_list|)
argument_list|,
name|operation
argument_list|)
expr_stmt|;
comment|// Initialize a deleteEventWriter if not yet done. (Lazy initialization)
if|if
condition|(
name|deleteEventWriter
operator|==
literal|null
condition|)
block|{
comment|// Initialize an indexBuilder for deleteEvents. (HIVE-17284)
name|deleteEventIndexBuilder
operator|=
operator|new
name|KeyIndexBuilder
argument_list|(
literal|"delete"
argument_list|)
expr_stmt|;
name|this
operator|.
name|deleteEventWriter
operator|=
name|OrcFile
operator|.
name|createWriter
argument_list|(
name|deleteEventPath
argument_list|,
name|deleteWriterOptions
operator|.
name|callback
argument_list|(
name|deleteEventIndexBuilder
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// A delete/update generates a delete event for the original row.
name|this
operator|.
name|rowId
operator|.
name|set
argument_list|(
name|rowId
argument_list|)
expr_stmt|;
name|this
operator|.
name|originalTransaction
operator|.
name|set
argument_list|(
name|originalTransaction
argument_list|)
expr_stmt|;
name|item
operator|.
name|setFieldValue
argument_list|(
name|OrcRecordUpdater
operator|.
name|OPERATION
argument_list|,
operator|new
name|IntWritable
argument_list|(
name|DELETE_OPERATION
argument_list|)
argument_list|)
expr_stmt|;
name|item
operator|.
name|setFieldValue
argument_list|(
name|OrcRecordUpdater
operator|.
name|ROW
argument_list|,
literal|null
argument_list|)
expr_stmt|;
comment|// ROW is null for delete events.
name|deleteEventIndexBuilder
operator|.
name|addKey
argument_list|(
name|DELETE_OPERATION
argument_list|,
name|originalTransaction
argument_list|,
name|bucket
operator|.
name|get
argument_list|()
argument_list|,
name|rowId
argument_list|)
expr_stmt|;
name|deleteEventWriter
operator|.
name|addRow
argument_list|(
name|item
argument_list|)
expr_stmt|;
name|restoreBucket
argument_list|(
name|currentBucket
argument_list|,
name|operation
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|operation
operator|==
name|UPDATE_OPERATION
condition|)
block|{
comment|// A new row is also inserted in the usual delta file for an update event.
name|addSimpleEvent
argument_list|(
name|INSERT_OPERATION
argument_list|,
name|currentTransaction
argument_list|,
name|insertedRows
operator|++
argument_list|,
name|row
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|void
name|insert
parameter_list|(
name|long
name|currentTransaction
parameter_list|,
name|Object
name|row
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|this
operator|.
name|currentTransaction
operator|.
name|get
argument_list|()
operator|!=
name|currentTransaction
condition|)
block|{
name|insertedRows
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|acidOperationalProperties
operator|.
name|isSplitUpdate
argument_list|()
condition|)
block|{
name|addSplitUpdateEvent
argument_list|(
name|INSERT_OPERATION
argument_list|,
name|currentTransaction
argument_list|,
name|insertedRows
operator|++
argument_list|,
name|row
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|addSimpleEvent
argument_list|(
name|INSERT_OPERATION
argument_list|,
name|currentTransaction
argument_list|,
name|insertedRows
operator|++
argument_list|,
name|row
argument_list|)
expr_stmt|;
block|}
name|rowCountDelta
operator|++
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|update
parameter_list|(
name|long
name|currentTransaction
parameter_list|,
name|Object
name|row
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|this
operator|.
name|currentTransaction
operator|.
name|get
argument_list|()
operator|!=
name|currentTransaction
condition|)
block|{
name|insertedRows
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|acidOperationalProperties
operator|.
name|isSplitUpdate
argument_list|()
condition|)
block|{
name|addSplitUpdateEvent
argument_list|(
name|UPDATE_OPERATION
argument_list|,
name|currentTransaction
argument_list|,
operator|-
literal|1L
argument_list|,
name|row
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|addSimpleEvent
argument_list|(
name|UPDATE_OPERATION
argument_list|,
name|currentTransaction
argument_list|,
operator|-
literal|1L
argument_list|,
name|row
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|void
name|delete
parameter_list|(
name|long
name|currentTransaction
parameter_list|,
name|Object
name|row
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|this
operator|.
name|currentTransaction
operator|.
name|get
argument_list|()
operator|!=
name|currentTransaction
condition|)
block|{
name|insertedRows
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|acidOperationalProperties
operator|.
name|isSplitUpdate
argument_list|()
condition|)
block|{
name|addSplitUpdateEvent
argument_list|(
name|DELETE_OPERATION
argument_list|,
name|currentTransaction
argument_list|,
operator|-
literal|1L
argument_list|,
name|row
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|addSimpleEvent
argument_list|(
name|DELETE_OPERATION
argument_list|,
name|currentTransaction
argument_list|,
operator|-
literal|1L
argument_list|,
name|row
argument_list|)
expr_stmt|;
block|}
name|rowCountDelta
operator|--
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|flush
parameter_list|()
throws|throws
name|IOException
block|{
comment|// We only support flushes on files with multiple transactions, because
comment|// flushes create significant overhead in HDFS. Record updaters with a
comment|// single transaction should be closed rather than flushed.
if|if
condition|(
name|flushLengths
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"Attempting to flush a RecordUpdater on "
operator|+
name|path
operator|+
literal|" with a single transaction."
argument_list|)
throw|;
block|}
if|if
condition|(
name|writer
operator|==
literal|null
condition|)
block|{
name|writer
operator|=
name|OrcFile
operator|.
name|createWriter
argument_list|(
name|path
argument_list|,
name|writerOptions
argument_list|)
expr_stmt|;
block|}
name|long
name|len
init|=
name|writer
operator|.
name|writeIntermediateFooter
argument_list|()
decl_stmt|;
name|flushLengths
operator|.
name|writeLong
argument_list|(
name|len
argument_list|)
expr_stmt|;
name|OrcInputFormat
operator|.
name|SHIMS
operator|.
name|hflush
argument_list|(
name|flushLengths
argument_list|)
expr_stmt|;
comment|//multiple transactions only happen for streaming ingest which only allows inserts
assert|assert
name|deleteEventWriter
operator|==
literal|null
operator|:
literal|"unexpected delete writer for "
operator|+
name|path
assert|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|close
parameter_list|(
name|boolean
name|abort
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|abort
condition|)
block|{
if|if
condition|(
name|flushLengths
operator|==
literal|null
condition|)
block|{
name|fs
operator|.
name|delete
argument_list|(
name|path
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|!
name|writerClosed
condition|)
block|{
if|if
condition|(
name|acidOperationalProperties
operator|.
name|isSplitUpdate
argument_list|()
condition|)
block|{
comment|// When split-update is enabled, we can choose not to write
comment|// any delta files when there are no inserts. In such cases only the delete_deltas
comment|// would be written& they are closed separately below.
if|if
condition|(
name|writer
operator|!=
literal|null
operator|&&
name|indexBuilder
operator|.
name|acidStats
operator|.
name|inserts
operator|>
literal|0
condition|)
block|{
name|writer
operator|.
name|close
argument_list|()
expr_stmt|;
comment|// normal close, when there are inserts.
block|}
block|}
else|else
block|{
if|if
condition|(
name|writer
operator|==
literal|null
condition|)
block|{
comment|//so that we create empty bucket files when needed (but see HIVE-17138)
name|writer
operator|=
name|OrcFile
operator|.
name|createWriter
argument_list|(
name|path
argument_list|,
name|writerOptions
argument_list|)
expr_stmt|;
block|}
name|writer
operator|.
name|close
argument_list|()
expr_stmt|;
comment|// normal close.
block|}
if|if
condition|(
name|deleteEventWriter
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|deleteEventIndexBuilder
operator|.
name|acidStats
operator|.
name|deletes
operator|>
literal|0
condition|)
block|{
comment|// Only need to write out& close the delete_delta if there have been any.
name|deleteEventWriter
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
else|else
block|{
comment|// Just remove delete_delta, if there have been no delete events.
name|fs
operator|.
name|delete
argument_list|(
name|deleteEventPath
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|flushLengths
operator|!=
literal|null
condition|)
block|{
name|flushLengths
operator|.
name|close
argument_list|()
expr_stmt|;
name|fs
operator|.
name|delete
argument_list|(
name|OrcAcidUtils
operator|.
name|getSideFile
argument_list|(
name|path
argument_list|)
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
name|writer
operator|=
literal|null
expr_stmt|;
name|deleteEventWriter
operator|=
literal|null
expr_stmt|;
name|writerClosed
operator|=
literal|true
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|SerDeStats
name|getStats
parameter_list|()
block|{
name|SerDeStats
name|stats
init|=
operator|new
name|SerDeStats
argument_list|()
decl_stmt|;
name|stats
operator|.
name|setRowCount
argument_list|(
name|rowCountDelta
argument_list|)
expr_stmt|;
comment|// Don't worry about setting raw data size diff.  I have no idea how to calculate that
comment|// without finding the row we are updating or deleting, which would be a mess.
return|return
name|stats
return|;
block|}
specifier|private
specifier|static
specifier|final
name|Charset
name|utf8
init|=
name|Charset
operator|.
name|forName
argument_list|(
literal|"UTF-8"
argument_list|)
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|CharsetDecoder
name|utf8Decoder
init|=
name|utf8
operator|.
name|newDecoder
argument_list|()
decl_stmt|;
specifier|static
name|RecordIdentifier
index|[]
name|parseKeyIndex
parameter_list|(
name|Reader
name|reader
parameter_list|)
block|{
name|String
index|[]
name|stripes
decl_stmt|;
try|try
block|{
name|ByteBuffer
name|val
init|=
name|reader
operator|.
name|getMetadataValue
argument_list|(
name|OrcRecordUpdater
operator|.
name|ACID_KEY_INDEX_NAME
argument_list|)
operator|.
name|duplicate
argument_list|()
decl_stmt|;
name|stripes
operator|=
name|utf8Decoder
operator|.
name|decode
argument_list|(
name|val
argument_list|)
operator|.
name|toString
argument_list|()
operator|.
name|split
argument_list|(
literal|";"
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|CharacterCodingException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Bad string encoding for "
operator|+
name|OrcRecordUpdater
operator|.
name|ACID_KEY_INDEX_NAME
argument_list|,
name|e
argument_list|)
throw|;
block|}
name|RecordIdentifier
index|[]
name|result
init|=
operator|new
name|RecordIdentifier
index|[
name|stripes
operator|.
name|length
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|stripes
operator|.
name|length
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|stripes
index|[
name|i
index|]
operator|.
name|length
argument_list|()
operator|!=
literal|0
condition|)
block|{
name|String
index|[]
name|parts
init|=
name|stripes
index|[
name|i
index|]
operator|.
name|split
argument_list|(
literal|","
argument_list|)
decl_stmt|;
name|result
index|[
name|i
index|]
operator|=
operator|new
name|RecordIdentifier
argument_list|()
expr_stmt|;
name|result
index|[
name|i
index|]
operator|.
name|setValues
argument_list|(
name|Long
operator|.
name|parseLong
argument_list|(
name|parts
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|Integer
operator|.
name|parseInt
argument_list|(
name|parts
index|[
literal|1
index|]
argument_list|)
argument_list|,
name|Long
operator|.
name|parseLong
argument_list|(
name|parts
index|[
literal|2
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|result
return|;
block|}
specifier|static
class|class
name|KeyIndexBuilder
implements|implements
name|OrcFile
operator|.
name|WriterCallback
block|{
specifier|private
specifier|final
name|String
name|builderName
decl_stmt|;
name|StringBuilder
name|lastKey
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
comment|//list of last keys for each stripe
name|long
name|lastTransaction
decl_stmt|;
name|int
name|lastBucket
decl_stmt|;
name|long
name|lastRowId
decl_stmt|;
name|AcidStats
name|acidStats
init|=
operator|new
name|AcidStats
argument_list|()
decl_stmt|;
name|KeyIndexBuilder
parameter_list|(
name|String
name|name
parameter_list|)
block|{
name|this
operator|.
name|builderName
operator|=
name|name
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|preStripeWrite
parameter_list|(
name|OrcFile
operator|.
name|WriterContext
name|context
parameter_list|)
throws|throws
name|IOException
block|{
name|lastKey
operator|.
name|append
argument_list|(
name|lastTransaction
argument_list|)
expr_stmt|;
name|lastKey
operator|.
name|append
argument_list|(
literal|','
argument_list|)
expr_stmt|;
name|lastKey
operator|.
name|append
argument_list|(
name|lastBucket
argument_list|)
expr_stmt|;
name|lastKey
operator|.
name|append
argument_list|(
literal|','
argument_list|)
expr_stmt|;
name|lastKey
operator|.
name|append
argument_list|(
name|lastRowId
argument_list|)
expr_stmt|;
name|lastKey
operator|.
name|append
argument_list|(
literal|';'
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|preFooterWrite
parameter_list|(
name|OrcFile
operator|.
name|WriterContext
name|context
parameter_list|)
throws|throws
name|IOException
block|{
name|context
operator|.
name|getWriter
argument_list|()
operator|.
name|addUserMetadata
argument_list|(
name|ACID_KEY_INDEX_NAME
argument_list|,
name|UTF8
operator|.
name|encode
argument_list|(
name|lastKey
operator|.
name|toString
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|context
operator|.
name|getWriter
argument_list|()
operator|.
name|addUserMetadata
argument_list|(
name|OrcAcidUtils
operator|.
name|ACID_STATS
argument_list|,
name|UTF8
operator|.
name|encode
argument_list|(
name|acidStats
operator|.
name|serialize
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|void
name|addKey
parameter_list|(
name|int
name|op
parameter_list|,
name|long
name|transaction
parameter_list|,
name|int
name|bucket
parameter_list|,
name|long
name|rowId
parameter_list|)
block|{
switch|switch
condition|(
name|op
condition|)
block|{
case|case
name|INSERT_OPERATION
case|:
name|acidStats
operator|.
name|inserts
operator|+=
literal|1
expr_stmt|;
break|break;
case|case
name|UPDATE_OPERATION
case|:
name|acidStats
operator|.
name|updates
operator|+=
literal|1
expr_stmt|;
break|break;
case|case
name|DELETE_OPERATION
case|:
name|acidStats
operator|.
name|deletes
operator|+=
literal|1
expr_stmt|;
break|break;
default|default:
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Unknown operation "
operator|+
name|op
argument_list|)
throw|;
block|}
name|lastTransaction
operator|=
name|transaction
expr_stmt|;
name|lastBucket
operator|=
name|bucket
expr_stmt|;
name|lastRowId
operator|=
name|rowId
expr_stmt|;
block|}
block|}
comment|/**    * An ObjectInspector that will strip out the record identifier so that the underlying writer    * doesn't see it.    */
specifier|private
specifier|static
class|class
name|RecIdStrippingObjectInspector
extends|extends
name|StructObjectInspector
block|{
specifier|private
name|StructObjectInspector
name|wrapped
decl_stmt|;
name|List
argument_list|<
name|StructField
argument_list|>
name|fields
decl_stmt|;
name|StructField
name|recId
decl_stmt|;
name|RecIdStrippingObjectInspector
parameter_list|(
name|ObjectInspector
name|oi
parameter_list|,
name|int
name|rowIdColNum
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|oi
operator|instanceof
name|StructObjectInspector
operator|)
condition|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Serious problem, expected a StructObjectInspector, "
operator|+
literal|"but got a "
operator|+
name|oi
operator|.
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|)
throw|;
block|}
name|wrapped
operator|=
operator|(
name|StructObjectInspector
operator|)
name|oi
expr_stmt|;
name|List
argument_list|<
name|?
extends|extends
name|StructField
argument_list|>
name|wrappedFields
init|=
name|wrapped
operator|.
name|getAllStructFieldRefs
argument_list|()
decl_stmt|;
name|fields
operator|=
operator|new
name|ArrayList
argument_list|<
name|StructField
argument_list|>
argument_list|(
name|wrapped
operator|.
name|getAllStructFieldRefs
argument_list|()
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|wrappedFields
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|==
name|rowIdColNum
condition|)
block|{
name|recId
operator|=
name|wrappedFields
operator|.
name|get
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fields
operator|.
name|add
argument_list|(
name|wrappedFields
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
annotation|@
name|Override
specifier|public
name|List
argument_list|<
name|?
extends|extends
name|StructField
argument_list|>
name|getAllStructFieldRefs
parameter_list|()
block|{
return|return
name|fields
return|;
block|}
annotation|@
name|Override
specifier|public
name|StructField
name|getStructFieldRef
parameter_list|(
name|String
name|fieldName
parameter_list|)
block|{
return|return
name|wrapped
operator|.
name|getStructFieldRef
argument_list|(
name|fieldName
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|Object
name|getStructFieldData
parameter_list|(
name|Object
name|data
parameter_list|,
name|StructField
name|fieldRef
parameter_list|)
block|{
comment|// For performance don't check that that the fieldRef isn't recId everytime,
comment|// just assume that the caller used getAllStructFieldRefs and thus doesn't have that fieldRef
return|return
name|wrapped
operator|.
name|getStructFieldData
argument_list|(
name|data
argument_list|,
name|fieldRef
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|List
argument_list|<
name|Object
argument_list|>
name|getStructFieldsDataAsList
parameter_list|(
name|Object
name|data
parameter_list|)
block|{
return|return
name|wrapped
operator|.
name|getStructFieldsDataAsList
argument_list|(
name|data
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|getTypeName
parameter_list|()
block|{
return|return
name|wrapped
operator|.
name|getTypeName
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|Category
name|getCategory
parameter_list|()
block|{
return|return
name|wrapped
operator|.
name|getCategory
argument_list|()
return|;
block|}
name|StructField
name|getRecId
parameter_list|()
block|{
return|return
name|recId
return|;
block|}
block|}
specifier|private
name|void
name|restoreBucket
parameter_list|(
name|Integer
name|currentBucket
parameter_list|,
name|int
name|operation
parameter_list|)
block|{
if|if
condition|(
name|currentBucket
operator|!=
literal|null
condition|)
block|{
name|setBucket
argument_list|(
name|currentBucket
argument_list|,
name|operation
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
name|int
name|setBucket
parameter_list|(
name|int
name|bucketProperty
parameter_list|,
name|int
name|operation
parameter_list|)
block|{
assert|assert
name|operation
operator|==
name|UPDATE_OPERATION
operator|||
name|operation
operator|==
name|DELETE_OPERATION
assert|;
name|int
name|currentBucketProperty
init|=
name|bucket
operator|.
name|get
argument_list|()
decl_stmt|;
name|bucket
operator|.
name|set
argument_list|(
name|bucketProperty
argument_list|)
expr_stmt|;
return|return
name|currentBucketProperty
return|;
block|}
block|}
end_class

end_unit

