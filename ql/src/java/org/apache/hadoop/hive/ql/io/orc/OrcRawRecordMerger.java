begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|io
operator|.
name|orc
package|;
end_package

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|VisibleForTesting
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|Log
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|LogFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FSDataInputStream
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FileSystem
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|Path
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|common
operator|.
name|ValidTxnList
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|io
operator|.
name|AcidInputFormat
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|io
operator|.
name|AcidUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|io
operator|.
name|RecordIdentifier
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|metadata
operator|.
name|VirtualColumn
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde
operator|.
name|serdeConstants
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|objectinspector
operator|.
name|ObjectInspector
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|typeinfo
operator|.
name|StructTypeInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|typeinfo
operator|.
name|TypeInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|typeinfo
operator|.
name|TypeInfoUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|IntWritable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|LongWritable
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayDeque
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Deque
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|TreeMap
import|;
end_import

begin_comment
comment|/**  * Merges a base and a list of delta files together into a single stream of  * events.  */
end_comment

begin_class
specifier|public
class|class
name|OrcRawRecordMerger
implements|implements
name|AcidInputFormat
operator|.
name|RawReader
argument_list|<
name|OrcStruct
argument_list|>
block|{
specifier|private
specifier|static
specifier|final
name|Log
name|LOG
init|=
name|LogFactory
operator|.
name|getLog
argument_list|(
name|OrcRawRecordMerger
operator|.
name|class
argument_list|)
decl_stmt|;
specifier|private
specifier|final
name|Configuration
name|conf
decl_stmt|;
specifier|private
specifier|final
name|boolean
name|collapse
decl_stmt|;
specifier|private
specifier|final
name|RecordReader
name|baseReader
decl_stmt|;
specifier|private
specifier|final
name|long
name|offset
decl_stmt|;
specifier|private
specifier|final
name|long
name|length
decl_stmt|;
specifier|private
specifier|final
name|ValidTxnList
name|validTxnList
decl_stmt|;
specifier|private
specifier|final
name|int
name|columns
decl_stmt|;
specifier|private
name|ReaderKey
name|prevKey
init|=
operator|new
name|ReaderKey
argument_list|()
decl_stmt|;
comment|// this is the key less than the lowest key we need to process
specifier|private
name|RecordIdentifier
name|minKey
decl_stmt|;
comment|// this is the last key we need to process
specifier|private
name|RecordIdentifier
name|maxKey
decl_stmt|;
comment|// an extra value so that we can return it while reading ahead
specifier|private
name|OrcStruct
name|extraValue
decl_stmt|;
comment|/**    * A RecordIdentifier extended with the current transaction id. This is the    * key of our merge sort with the originalTransaction, bucket, and rowId    * ascending and the currentTransaction descending. This means that if the    * reader is collapsing events to just the last update, just the first    * instance of each record is required.    */
specifier|final
specifier|static
class|class
name|ReaderKey
extends|extends
name|RecordIdentifier
block|{
specifier|private
name|long
name|currentTransactionId
decl_stmt|;
specifier|public
name|ReaderKey
parameter_list|()
block|{
name|this
argument_list|(
operator|-
literal|1
argument_list|,
operator|-
literal|1
argument_list|,
operator|-
literal|1
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
specifier|public
name|ReaderKey
parameter_list|(
name|long
name|originalTransaction
parameter_list|,
name|int
name|bucket
parameter_list|,
name|long
name|rowId
parameter_list|,
name|long
name|currentTransactionId
parameter_list|)
block|{
name|super
argument_list|(
name|originalTransaction
argument_list|,
name|bucket
argument_list|,
name|rowId
argument_list|)
expr_stmt|;
name|this
operator|.
name|currentTransactionId
operator|=
name|currentTransactionId
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|set
parameter_list|(
name|RecordIdentifier
name|other
parameter_list|)
block|{
name|super
operator|.
name|set
argument_list|(
name|other
argument_list|)
expr_stmt|;
name|currentTransactionId
operator|=
operator|(
operator|(
name|ReaderKey
operator|)
name|other
operator|)
operator|.
name|currentTransactionId
expr_stmt|;
block|}
specifier|public
name|void
name|setValues
parameter_list|(
name|long
name|originalTransactionId
parameter_list|,
name|int
name|bucket
parameter_list|,
name|long
name|rowId
parameter_list|,
name|long
name|currentTransactionId
parameter_list|)
block|{
name|setValues
argument_list|(
name|originalTransactionId
argument_list|,
name|bucket
argument_list|,
name|rowId
argument_list|)
expr_stmt|;
name|this
operator|.
name|currentTransactionId
operator|=
name|currentTransactionId
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|equals
parameter_list|(
name|Object
name|other
parameter_list|)
block|{
return|return
name|super
operator|.
name|equals
argument_list|(
name|other
argument_list|)
operator|&&
name|currentTransactionId
operator|==
operator|(
operator|(
name|ReaderKey
operator|)
name|other
operator|)
operator|.
name|currentTransactionId
return|;
block|}
annotation|@
name|Override
specifier|public
name|int
name|compareTo
parameter_list|(
name|RecordIdentifier
name|other
parameter_list|)
block|{
name|int
name|sup
init|=
name|compareToInternal
argument_list|(
name|other
argument_list|)
decl_stmt|;
if|if
condition|(
name|sup
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|other
operator|.
name|getClass
argument_list|()
operator|==
name|ReaderKey
operator|.
name|class
condition|)
block|{
name|ReaderKey
name|oth
init|=
operator|(
name|ReaderKey
operator|)
name|other
decl_stmt|;
if|if
condition|(
name|currentTransactionId
operator|!=
name|oth
operator|.
name|currentTransactionId
condition|)
block|{
return|return
name|currentTransactionId
operator|<
name|oth
operator|.
name|currentTransactionId
condition|?
operator|+
literal|1
else|:
operator|-
literal|1
return|;
block|}
block|}
else|else
block|{
return|return
operator|-
literal|1
return|;
block|}
block|}
return|return
name|sup
return|;
block|}
specifier|public
name|long
name|getCurrentTransactionId
parameter_list|()
block|{
return|return
name|currentTransactionId
return|;
block|}
comment|/**      * Compare rows without considering the currentTransactionId.      * @param other the value to compare to      * @return -1, 0, +1      */
specifier|public
name|int
name|compareRow
parameter_list|(
name|RecordIdentifier
name|other
parameter_list|)
block|{
return|return
name|compareToInternal
argument_list|(
name|other
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
literal|"{originalTxn: "
operator|+
name|getTransactionId
argument_list|()
operator|+
literal|", bucket: "
operator|+
name|getBucketId
argument_list|()
operator|+
literal|", row: "
operator|+
name|getRowId
argument_list|()
operator|+
literal|", currentTxn: "
operator|+
name|currentTransactionId
operator|+
literal|"}"
return|;
block|}
block|}
comment|/**    * A reader and the next record from that reader. The code reads ahead so that    * we can return the lowest ReaderKey from each of the readers. Thus, the    * next available row is nextRecord and only following records are still in    * the reader.    */
specifier|static
class|class
name|ReaderPair
block|{
name|OrcStruct
name|nextRecord
decl_stmt|;
specifier|final
name|Reader
name|reader
decl_stmt|;
specifier|final
name|RecordReader
name|recordReader
decl_stmt|;
specifier|final
name|ReaderKey
name|key
decl_stmt|;
specifier|final
name|RecordIdentifier
name|maxKey
decl_stmt|;
specifier|final
name|int
name|bucket
decl_stmt|;
comment|/**      * Create a reader that reads from the first key larger than minKey to any      * keys equal to maxKey.      * @param key the key to read into      * @param reader the ORC file reader      * @param bucket the bucket number for the file      * @param minKey only return keys larger than minKey if it is non-null      * @param maxKey only return keys less than or equal to maxKey if it is      *               non-null      * @param options options to provide to read the rows.      * @throws IOException      */
name|ReaderPair
parameter_list|(
name|ReaderKey
name|key
parameter_list|,
name|Reader
name|reader
parameter_list|,
name|int
name|bucket
parameter_list|,
name|RecordIdentifier
name|minKey
parameter_list|,
name|RecordIdentifier
name|maxKey
parameter_list|,
name|ReaderImpl
operator|.
name|Options
name|options
parameter_list|)
throws|throws
name|IOException
block|{
name|this
operator|.
name|reader
operator|=
name|reader
expr_stmt|;
name|this
operator|.
name|key
operator|=
name|key
expr_stmt|;
name|this
operator|.
name|maxKey
operator|=
name|maxKey
expr_stmt|;
name|this
operator|.
name|bucket
operator|=
name|bucket
expr_stmt|;
comment|// TODO use stripe statistics to jump over stripes
name|recordReader
operator|=
name|reader
operator|.
name|rowsOptions
argument_list|(
name|options
argument_list|)
expr_stmt|;
comment|// advance the reader until we reach the minimum key
do|do
block|{
name|next
argument_list|(
name|nextRecord
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|nextRecord
operator|!=
literal|null
operator|&&
operator|(
name|minKey
operator|!=
literal|null
operator|&&
name|key
operator|.
name|compareRow
argument_list|(
name|minKey
argument_list|)
operator|<=
literal|0
operator|)
condition|)
do|;
block|}
name|void
name|next
parameter_list|(
name|OrcStruct
name|next
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|recordReader
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|nextRecord
operator|=
operator|(
name|OrcStruct
operator|)
name|recordReader
operator|.
name|next
argument_list|(
name|next
argument_list|)
expr_stmt|;
comment|// set the key
name|key
operator|.
name|setValues
argument_list|(
name|OrcRecordUpdater
operator|.
name|getOriginalTransaction
argument_list|(
name|nextRecord
argument_list|)
argument_list|,
name|OrcRecordUpdater
operator|.
name|getBucket
argument_list|(
name|nextRecord
argument_list|)
argument_list|,
name|OrcRecordUpdater
operator|.
name|getRowId
argument_list|(
name|nextRecord
argument_list|)
argument_list|,
name|OrcRecordUpdater
operator|.
name|getCurrentTransaction
argument_list|(
name|nextRecord
argument_list|)
argument_list|)
expr_stmt|;
comment|// if this record is larger than maxKey, we need to stop
if|if
condition|(
name|maxKey
operator|!=
literal|null
operator|&&
name|key
operator|.
name|compareRow
argument_list|(
name|maxKey
argument_list|)
operator|>
literal|0
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"key "
operator|+
name|key
operator|+
literal|"> maxkey "
operator|+
name|maxKey
argument_list|)
expr_stmt|;
name|nextRecord
operator|=
literal|null
expr_stmt|;
name|recordReader
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
else|else
block|{
name|nextRecord
operator|=
literal|null
expr_stmt|;
name|recordReader
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
name|int
name|getColumns
parameter_list|()
block|{
return|return
name|reader
operator|.
name|getTypes
argument_list|()
operator|.
name|get
argument_list|(
name|OrcRecordUpdater
operator|.
name|ROW
operator|+
literal|1
argument_list|)
operator|.
name|getSubtypesCount
argument_list|()
return|;
block|}
block|}
comment|/**    * A reader that pretends an original base file is a new version base file.    * It wraps the underlying reader's row with an ACID event object and    * makes the relevant translations.    */
specifier|static
specifier|final
class|class
name|OriginalReaderPair
extends|extends
name|ReaderPair
block|{
name|OriginalReaderPair
parameter_list|(
name|ReaderKey
name|key
parameter_list|,
name|Reader
name|reader
parameter_list|,
name|int
name|bucket
parameter_list|,
name|RecordIdentifier
name|minKey
parameter_list|,
name|RecordIdentifier
name|maxKey
parameter_list|,
name|Reader
operator|.
name|Options
name|options
parameter_list|)
throws|throws
name|IOException
block|{
name|super
argument_list|(
name|key
argument_list|,
name|reader
argument_list|,
name|bucket
argument_list|,
name|minKey
argument_list|,
name|maxKey
argument_list|,
name|options
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
name|void
name|next
parameter_list|(
name|OrcStruct
name|next
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|recordReader
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|long
name|nextRowId
init|=
name|recordReader
operator|.
name|getRowNumber
argument_list|()
decl_stmt|;
comment|// have to do initialization here, because the super's constructor
comment|// calls next and thus we need to initialize before our constructor
comment|// runs
if|if
condition|(
name|next
operator|==
literal|null
condition|)
block|{
name|nextRecord
operator|=
operator|new
name|OrcStruct
argument_list|(
name|OrcRecordUpdater
operator|.
name|FIELDS
argument_list|)
expr_stmt|;
name|IntWritable
name|operation
init|=
operator|new
name|IntWritable
argument_list|(
name|OrcRecordUpdater
operator|.
name|INSERT_OPERATION
argument_list|)
decl_stmt|;
name|nextRecord
operator|.
name|setFieldValue
argument_list|(
name|OrcRecordUpdater
operator|.
name|OPERATION
argument_list|,
name|operation
argument_list|)
expr_stmt|;
name|nextRecord
operator|.
name|setFieldValue
argument_list|(
name|OrcRecordUpdater
operator|.
name|CURRENT_TRANSACTION
argument_list|,
operator|new
name|LongWritable
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|nextRecord
operator|.
name|setFieldValue
argument_list|(
name|OrcRecordUpdater
operator|.
name|ORIGINAL_TRANSACTION
argument_list|,
operator|new
name|LongWritable
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|nextRecord
operator|.
name|setFieldValue
argument_list|(
name|OrcRecordUpdater
operator|.
name|BUCKET
argument_list|,
operator|new
name|IntWritable
argument_list|(
name|bucket
argument_list|)
argument_list|)
expr_stmt|;
name|nextRecord
operator|.
name|setFieldValue
argument_list|(
name|OrcRecordUpdater
operator|.
name|ROW_ID
argument_list|,
operator|new
name|LongWritable
argument_list|(
name|nextRowId
argument_list|)
argument_list|)
expr_stmt|;
name|nextRecord
operator|.
name|setFieldValue
argument_list|(
name|OrcRecordUpdater
operator|.
name|ROW
argument_list|,
name|recordReader
operator|.
name|next
argument_list|(
literal|null
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|nextRecord
operator|=
name|next
expr_stmt|;
operator|(
operator|(
name|IntWritable
operator|)
name|next
operator|.
name|getFieldValue
argument_list|(
name|OrcRecordUpdater
operator|.
name|OPERATION
argument_list|)
operator|)
operator|.
name|set
argument_list|(
name|OrcRecordUpdater
operator|.
name|INSERT_OPERATION
argument_list|)
expr_stmt|;
operator|(
operator|(
name|LongWritable
operator|)
name|next
operator|.
name|getFieldValue
argument_list|(
name|OrcRecordUpdater
operator|.
name|ORIGINAL_TRANSACTION
argument_list|)
operator|)
operator|.
name|set
argument_list|(
literal|0
argument_list|)
expr_stmt|;
operator|(
operator|(
name|IntWritable
operator|)
name|next
operator|.
name|getFieldValue
argument_list|(
name|OrcRecordUpdater
operator|.
name|BUCKET
argument_list|)
operator|)
operator|.
name|set
argument_list|(
name|bucket
argument_list|)
expr_stmt|;
operator|(
operator|(
name|LongWritable
operator|)
name|next
operator|.
name|getFieldValue
argument_list|(
name|OrcRecordUpdater
operator|.
name|CURRENT_TRANSACTION
argument_list|)
operator|)
operator|.
name|set
argument_list|(
literal|0
argument_list|)
expr_stmt|;
operator|(
operator|(
name|LongWritable
operator|)
name|next
operator|.
name|getFieldValue
argument_list|(
name|OrcRecordUpdater
operator|.
name|ROW_ID
argument_list|)
operator|)
operator|.
name|set
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|nextRecord
operator|.
name|setFieldValue
argument_list|(
name|OrcRecordUpdater
operator|.
name|ROW
argument_list|,
name|recordReader
operator|.
name|next
argument_list|(
name|OrcRecordUpdater
operator|.
name|getRow
argument_list|(
name|next
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|key
operator|.
name|setValues
argument_list|(
literal|0L
argument_list|,
name|bucket
argument_list|,
name|nextRowId
argument_list|,
literal|0L
argument_list|)
expr_stmt|;
if|if
condition|(
name|maxKey
operator|!=
literal|null
operator|&&
name|key
operator|.
name|compareRow
argument_list|(
name|maxKey
argument_list|)
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"key "
operator|+
name|key
operator|+
literal|"> maxkey "
operator|+
name|maxKey
argument_list|)
expr_stmt|;
block|}
name|nextRecord
operator|=
literal|null
expr_stmt|;
name|recordReader
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
else|else
block|{
name|nextRecord
operator|=
literal|null
expr_stmt|;
name|recordReader
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
annotation|@
name|Override
name|int
name|getColumns
parameter_list|()
block|{
return|return
name|reader
operator|.
name|getTypes
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|getSubtypesCount
argument_list|()
return|;
block|}
block|}
specifier|private
specifier|final
name|TreeMap
argument_list|<
name|ReaderKey
argument_list|,
name|ReaderPair
argument_list|>
name|readers
init|=
operator|new
name|TreeMap
argument_list|<
name|ReaderKey
argument_list|,
name|ReaderPair
argument_list|>
argument_list|()
decl_stmt|;
comment|// The reader that currently has the lowest key.
specifier|private
name|ReaderPair
name|primary
decl_stmt|;
comment|// The key of the next lowest reader.
specifier|private
name|ReaderKey
name|secondaryKey
init|=
literal|null
decl_stmt|;
comment|/**    * Find the key range for original bucket files.    * @param reader the reader    * @param bucket the bucket number we are reading    * @param options the options for reading with    * @throws IOException    */
specifier|private
name|void
name|discoverOriginalKeyBounds
parameter_list|(
name|Reader
name|reader
parameter_list|,
name|int
name|bucket
parameter_list|,
name|Reader
operator|.
name|Options
name|options
parameter_list|)
throws|throws
name|IOException
block|{
name|long
name|rowLength
init|=
literal|0
decl_stmt|;
name|long
name|rowOffset
init|=
literal|0
decl_stmt|;
name|long
name|offset
init|=
name|options
operator|.
name|getOffset
argument_list|()
decl_stmt|;
name|long
name|maxOffset
init|=
name|options
operator|.
name|getMaxOffset
argument_list|()
decl_stmt|;
name|boolean
name|isTail
init|=
literal|true
decl_stmt|;
for|for
control|(
name|StripeInformation
name|stripe
range|:
name|reader
operator|.
name|getStripes
argument_list|()
control|)
block|{
if|if
condition|(
name|offset
operator|>
name|stripe
operator|.
name|getOffset
argument_list|()
condition|)
block|{
name|rowOffset
operator|+=
name|stripe
operator|.
name|getNumberOfRows
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|maxOffset
operator|>
name|stripe
operator|.
name|getOffset
argument_list|()
condition|)
block|{
name|rowLength
operator|+=
name|stripe
operator|.
name|getNumberOfRows
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|isTail
operator|=
literal|false
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|rowOffset
operator|>
literal|0
condition|)
block|{
name|minKey
operator|=
operator|new
name|RecordIdentifier
argument_list|(
literal|0
argument_list|,
name|bucket
argument_list|,
name|rowOffset
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|isTail
condition|)
block|{
name|maxKey
operator|=
operator|new
name|RecordIdentifier
argument_list|(
literal|0
argument_list|,
name|bucket
argument_list|,
name|rowOffset
operator|+
name|rowLength
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Find the key range for bucket files.    * @param reader the reader    * @param options the options for reading with    * @throws IOException    */
specifier|private
name|void
name|discoverKeyBounds
parameter_list|(
name|Reader
name|reader
parameter_list|,
name|Reader
operator|.
name|Options
name|options
parameter_list|)
throws|throws
name|IOException
block|{
name|RecordIdentifier
index|[]
name|keyIndex
init|=
name|OrcRecordUpdater
operator|.
name|parseKeyIndex
argument_list|(
name|reader
argument_list|)
decl_stmt|;
name|long
name|offset
init|=
name|options
operator|.
name|getOffset
argument_list|()
decl_stmt|;
name|long
name|maxOffset
init|=
name|options
operator|.
name|getMaxOffset
argument_list|()
decl_stmt|;
name|int
name|firstStripe
init|=
literal|0
decl_stmt|;
name|int
name|stripeCount
init|=
literal|0
decl_stmt|;
name|boolean
name|isTail
init|=
literal|true
decl_stmt|;
name|List
argument_list|<
name|StripeInformation
argument_list|>
name|stripes
init|=
name|reader
operator|.
name|getStripes
argument_list|()
decl_stmt|;
for|for
control|(
name|StripeInformation
name|stripe
range|:
name|stripes
control|)
block|{
if|if
condition|(
name|offset
operator|>
name|stripe
operator|.
name|getOffset
argument_list|()
condition|)
block|{
name|firstStripe
operator|+=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|maxOffset
operator|>
name|stripe
operator|.
name|getOffset
argument_list|()
condition|)
block|{
name|stripeCount
operator|+=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|isTail
operator|=
literal|false
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|firstStripe
operator|!=
literal|0
condition|)
block|{
name|minKey
operator|=
name|keyIndex
index|[
name|firstStripe
operator|-
literal|1
index|]
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|isTail
condition|)
block|{
name|maxKey
operator|=
name|keyIndex
index|[
name|firstStripe
operator|+
name|stripeCount
operator|-
literal|1
index|]
expr_stmt|;
block|}
block|}
comment|/**    * Convert from the row include/sarg/columnNames to the event equivalent    * for the underlying file.    * @param options options for the row reader    * @return a cloned options object that is modified for the event reader    */
specifier|static
name|Reader
operator|.
name|Options
name|createEventOptions
parameter_list|(
name|Reader
operator|.
name|Options
name|options
parameter_list|)
block|{
name|Reader
operator|.
name|Options
name|result
init|=
name|options
operator|.
name|clone
argument_list|()
decl_stmt|;
name|result
operator|.
name|range
argument_list|(
name|options
operator|.
name|getOffset
argument_list|()
argument_list|,
name|Long
operator|.
name|MAX_VALUE
argument_list|)
expr_stmt|;
comment|// slide the columns down by 6 for the include array
if|if
condition|(
name|options
operator|.
name|getInclude
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|boolean
index|[]
name|orig
init|=
name|options
operator|.
name|getInclude
argument_list|()
decl_stmt|;
comment|// we always need the base row
name|orig
index|[
literal|0
index|]
operator|=
literal|true
expr_stmt|;
name|boolean
index|[]
name|include
init|=
operator|new
name|boolean
index|[
name|orig
operator|.
name|length
operator|+
name|OrcRecordUpdater
operator|.
name|FIELDS
index|]
decl_stmt|;
name|Arrays
operator|.
name|fill
argument_list|(
name|include
argument_list|,
literal|0
argument_list|,
name|OrcRecordUpdater
operator|.
name|FIELDS
argument_list|,
literal|true
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|orig
operator|.
name|length
condition|;
operator|++
name|i
control|)
block|{
name|include
index|[
name|i
operator|+
name|OrcRecordUpdater
operator|.
name|FIELDS
index|]
operator|=
name|orig
index|[
name|i
index|]
expr_stmt|;
block|}
name|result
operator|.
name|include
argument_list|(
name|include
argument_list|)
expr_stmt|;
block|}
comment|// slide the column names down by 6 for the name array
if|if
condition|(
name|options
operator|.
name|getColumnNames
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|String
index|[]
name|orig
init|=
name|options
operator|.
name|getColumnNames
argument_list|()
decl_stmt|;
name|String
index|[]
name|cols
init|=
operator|new
name|String
index|[
name|orig
operator|.
name|length
operator|+
name|OrcRecordUpdater
operator|.
name|FIELDS
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|orig
operator|.
name|length
condition|;
operator|++
name|i
control|)
block|{
name|cols
index|[
name|i
operator|+
name|OrcRecordUpdater
operator|.
name|FIELDS
index|]
operator|=
name|orig
index|[
name|i
index|]
expr_stmt|;
block|}
name|result
operator|.
name|searchArgument
argument_list|(
name|options
operator|.
name|getSearchArgument
argument_list|()
argument_list|,
name|cols
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
comment|/**    * Create a reader that merge sorts the ACID events together.    * @param conf the configuration    * @param collapseEvents should the events on the same row be collapsed    * @param isOriginal is the base file a pre-acid file    * @param bucket the bucket we are reading    * @param options the options to read with    * @param deltaDirectory the list of delta directories to include    * @throws IOException    */
name|OrcRawRecordMerger
parameter_list|(
name|Configuration
name|conf
parameter_list|,
name|boolean
name|collapseEvents
parameter_list|,
name|Reader
name|reader
parameter_list|,
name|boolean
name|isOriginal
parameter_list|,
name|int
name|bucket
parameter_list|,
name|ValidTxnList
name|validTxnList
parameter_list|,
name|Reader
operator|.
name|Options
name|options
parameter_list|,
name|Path
index|[]
name|deltaDirectory
parameter_list|)
throws|throws
name|IOException
block|{
name|this
operator|.
name|conf
operator|=
name|conf
expr_stmt|;
name|this
operator|.
name|collapse
operator|=
name|collapseEvents
expr_stmt|;
name|this
operator|.
name|offset
operator|=
name|options
operator|.
name|getOffset
argument_list|()
expr_stmt|;
name|this
operator|.
name|length
operator|=
name|options
operator|.
name|getLength
argument_list|()
expr_stmt|;
name|this
operator|.
name|validTxnList
operator|=
name|validTxnList
expr_stmt|;
comment|// modify the optins to reflect the event instead of the base row
name|Reader
operator|.
name|Options
name|eventOptions
init|=
name|createEventOptions
argument_list|(
name|options
argument_list|)
decl_stmt|;
if|if
condition|(
name|reader
operator|==
literal|null
condition|)
block|{
name|baseReader
operator|=
literal|null
expr_stmt|;
block|}
else|else
block|{
comment|// find the min/max based on the offset and length
if|if
condition|(
name|isOriginal
condition|)
block|{
name|discoverOriginalKeyBounds
argument_list|(
name|reader
argument_list|,
name|bucket
argument_list|,
name|options
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|discoverKeyBounds
argument_list|(
name|reader
argument_list|,
name|options
argument_list|)
expr_stmt|;
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"min key = "
operator|+
name|minKey
operator|+
literal|", max key = "
operator|+
name|maxKey
argument_list|)
expr_stmt|;
comment|// use the min/max instead of the byte range
name|ReaderPair
name|pair
decl_stmt|;
name|ReaderKey
name|key
init|=
operator|new
name|ReaderKey
argument_list|()
decl_stmt|;
if|if
condition|(
name|isOriginal
condition|)
block|{
name|options
operator|=
name|options
operator|.
name|clone
argument_list|()
expr_stmt|;
name|options
operator|.
name|range
argument_list|(
name|options
operator|.
name|getOffset
argument_list|()
argument_list|,
name|Long
operator|.
name|MAX_VALUE
argument_list|)
expr_stmt|;
name|pair
operator|=
operator|new
name|OriginalReaderPair
argument_list|(
name|key
argument_list|,
name|reader
argument_list|,
name|bucket
argument_list|,
name|minKey
argument_list|,
name|maxKey
argument_list|,
name|options
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|pair
operator|=
operator|new
name|ReaderPair
argument_list|(
name|key
argument_list|,
name|reader
argument_list|,
name|bucket
argument_list|,
name|minKey
argument_list|,
name|maxKey
argument_list|,
name|eventOptions
argument_list|)
expr_stmt|;
block|}
comment|// if there is at least one record, put it in the map
if|if
condition|(
name|pair
operator|.
name|nextRecord
operator|!=
literal|null
condition|)
block|{
name|readers
operator|.
name|put
argument_list|(
name|key
argument_list|,
name|pair
argument_list|)
expr_stmt|;
block|}
name|baseReader
operator|=
name|pair
operator|.
name|recordReader
expr_stmt|;
block|}
comment|// we always want to read all of the deltas
name|eventOptions
operator|.
name|range
argument_list|(
literal|0
argument_list|,
name|Long
operator|.
name|MAX_VALUE
argument_list|)
expr_stmt|;
comment|// Turn off the sarg before pushing it to delta.  We never want to push a sarg to a delta as
comment|// it can produce wrong results (if the latest valid version of the record is filtered out by
comment|// the sarg) or ArrayOutOfBounds errors (when the sarg is applied to a delete record)
name|eventOptions
operator|.
name|searchArgument
argument_list|(
literal|null
argument_list|,
literal|null
argument_list|)
expr_stmt|;
if|if
condition|(
name|deltaDirectory
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|Path
name|delta
range|:
name|deltaDirectory
control|)
block|{
name|ReaderKey
name|key
init|=
operator|new
name|ReaderKey
argument_list|()
decl_stmt|;
name|Path
name|deltaFile
init|=
name|AcidUtils
operator|.
name|createBucketFile
argument_list|(
name|delta
argument_list|,
name|bucket
argument_list|)
decl_stmt|;
name|FileSystem
name|fs
init|=
name|deltaFile
operator|.
name|getFileSystem
argument_list|(
name|conf
argument_list|)
decl_stmt|;
name|long
name|length
init|=
name|getLastFlushLength
argument_list|(
name|fs
argument_list|,
name|deltaFile
argument_list|)
decl_stmt|;
if|if
condition|(
name|fs
operator|.
name|exists
argument_list|(
name|deltaFile
argument_list|)
operator|&&
name|length
operator|!=
operator|-
literal|1
condition|)
block|{
name|Reader
name|deltaReader
init|=
name|OrcFile
operator|.
name|createReader
argument_list|(
name|deltaFile
argument_list|,
name|OrcFile
operator|.
name|readerOptions
argument_list|(
name|conf
argument_list|)
operator|.
name|maxLength
argument_list|(
name|length
argument_list|)
argument_list|)
decl_stmt|;
name|ReaderPair
name|deltaPair
init|=
operator|new
name|ReaderPair
argument_list|(
name|key
argument_list|,
name|deltaReader
argument_list|,
name|bucket
argument_list|,
name|minKey
argument_list|,
name|maxKey
argument_list|,
name|eventOptions
argument_list|)
decl_stmt|;
if|if
condition|(
name|deltaPair
operator|.
name|nextRecord
operator|!=
literal|null
condition|)
block|{
name|readers
operator|.
name|put
argument_list|(
name|key
argument_list|,
name|deltaPair
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
comment|// get the first record
name|Map
operator|.
name|Entry
argument_list|<
name|ReaderKey
argument_list|,
name|ReaderPair
argument_list|>
name|entry
init|=
name|readers
operator|.
name|pollFirstEntry
argument_list|()
decl_stmt|;
if|if
condition|(
name|entry
operator|==
literal|null
condition|)
block|{
name|columns
operator|=
literal|0
expr_stmt|;
name|primary
operator|=
literal|null
expr_stmt|;
block|}
else|else
block|{
name|primary
operator|=
name|entry
operator|.
name|getValue
argument_list|()
expr_stmt|;
if|if
condition|(
name|readers
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|secondaryKey
operator|=
literal|null
expr_stmt|;
block|}
else|else
block|{
name|secondaryKey
operator|=
name|readers
operator|.
name|firstKey
argument_list|()
expr_stmt|;
block|}
comment|// get the number of columns in the user's rows
name|columns
operator|=
name|primary
operator|.
name|getColumns
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Read the side file to get the last flush length.    * @param fs the file system to use    * @param deltaFile the path of the delta file    * @return the maximum size of the file to use    * @throws IOException    */
specifier|private
specifier|static
name|long
name|getLastFlushLength
parameter_list|(
name|FileSystem
name|fs
parameter_list|,
name|Path
name|deltaFile
parameter_list|)
throws|throws
name|IOException
block|{
name|Path
name|lengths
init|=
name|OrcRecordUpdater
operator|.
name|getSideFile
argument_list|(
name|deltaFile
argument_list|)
decl_stmt|;
name|long
name|result
init|=
name|Long
operator|.
name|MAX_VALUE
decl_stmt|;
try|try
block|{
name|FSDataInputStream
name|stream
init|=
name|fs
operator|.
name|open
argument_list|(
name|lengths
argument_list|)
decl_stmt|;
name|result
operator|=
operator|-
literal|1
expr_stmt|;
while|while
condition|(
name|stream
operator|.
name|available
argument_list|()
operator|>
literal|0
condition|)
block|{
name|result
operator|=
name|stream
operator|.
name|readLong
argument_list|()
expr_stmt|;
block|}
name|stream
operator|.
name|close
argument_list|()
expr_stmt|;
return|return
name|result
return|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ioe
parameter_list|)
block|{
return|return
name|result
return|;
block|}
block|}
annotation|@
name|VisibleForTesting
name|RecordIdentifier
name|getMinKey
parameter_list|()
block|{
return|return
name|minKey
return|;
block|}
annotation|@
name|VisibleForTesting
name|RecordIdentifier
name|getMaxKey
parameter_list|()
block|{
return|return
name|maxKey
return|;
block|}
annotation|@
name|VisibleForTesting
name|ReaderPair
name|getCurrentReader
parameter_list|()
block|{
return|return
name|primary
return|;
block|}
annotation|@
name|VisibleForTesting
name|Map
argument_list|<
name|ReaderKey
argument_list|,
name|ReaderPair
argument_list|>
name|getOtherReaders
parameter_list|()
block|{
return|return
name|readers
return|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|next
parameter_list|(
name|RecordIdentifier
name|recordIdentifier
parameter_list|,
name|OrcStruct
name|prev
parameter_list|)
throws|throws
name|IOException
block|{
name|boolean
name|keysSame
init|=
literal|true
decl_stmt|;
while|while
condition|(
name|keysSame
operator|&&
name|primary
operator|!=
literal|null
condition|)
block|{
comment|// The primary's nextRecord is the next value to return
name|OrcStruct
name|current
init|=
name|primary
operator|.
name|nextRecord
decl_stmt|;
name|recordIdentifier
operator|.
name|set
argument_list|(
name|primary
operator|.
name|key
argument_list|)
expr_stmt|;
comment|// Advance the primary reader to the next record
name|primary
operator|.
name|next
argument_list|(
name|extraValue
argument_list|)
expr_stmt|;
comment|// Save the current record as the new extraValue for next time so that
comment|// we minimize allocations
name|extraValue
operator|=
name|current
expr_stmt|;
comment|// now that the primary reader has advanced, we need to see if we
comment|// continue to read it or move to the secondary.
if|if
condition|(
name|primary
operator|.
name|nextRecord
operator|==
literal|null
operator|||
name|primary
operator|.
name|key
operator|.
name|compareTo
argument_list|(
name|secondaryKey
argument_list|)
operator|>
literal|0
condition|)
block|{
comment|// if the primary isn't done, push it back into the readers
if|if
condition|(
name|primary
operator|.
name|nextRecord
operator|!=
literal|null
condition|)
block|{
name|readers
operator|.
name|put
argument_list|(
name|primary
operator|.
name|key
argument_list|,
name|primary
argument_list|)
expr_stmt|;
block|}
comment|// update primary and secondaryKey
name|Map
operator|.
name|Entry
argument_list|<
name|ReaderKey
argument_list|,
name|ReaderPair
argument_list|>
name|entry
init|=
name|readers
operator|.
name|pollFirstEntry
argument_list|()
decl_stmt|;
if|if
condition|(
name|entry
operator|!=
literal|null
condition|)
block|{
name|primary
operator|=
name|entry
operator|.
name|getValue
argument_list|()
expr_stmt|;
if|if
condition|(
name|readers
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|secondaryKey
operator|=
literal|null
expr_stmt|;
block|}
else|else
block|{
name|secondaryKey
operator|=
name|readers
operator|.
name|firstKey
argument_list|()
expr_stmt|;
block|}
block|}
else|else
block|{
name|primary
operator|=
literal|null
expr_stmt|;
block|}
block|}
comment|// if this transaction isn't ok, skip over it
if|if
condition|(
operator|!
name|validTxnList
operator|.
name|isTxnCommitted
argument_list|(
operator|(
operator|(
name|ReaderKey
operator|)
name|recordIdentifier
operator|)
operator|.
name|getCurrentTransactionId
argument_list|()
argument_list|)
condition|)
block|{
continue|continue;
block|}
comment|// if we are collapsing, figure out if this is a new row
if|if
condition|(
name|collapse
condition|)
block|{
name|keysSame
operator|=
name|prevKey
operator|.
name|compareRow
argument_list|(
name|recordIdentifier
argument_list|)
operator|==
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|keysSame
condition|)
block|{
name|prevKey
operator|.
name|set
argument_list|(
name|recordIdentifier
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|keysSame
operator|=
literal|false
expr_stmt|;
block|}
comment|// set the output record by fiddling with the pointers so that we can
comment|// avoid a copy.
name|prev
operator|.
name|linkFields
argument_list|(
name|current
argument_list|)
expr_stmt|;
block|}
return|return
operator|!
name|keysSame
return|;
block|}
annotation|@
name|Override
specifier|public
name|RecordIdentifier
name|createKey
parameter_list|()
block|{
return|return
operator|new
name|ReaderKey
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|OrcStruct
name|createValue
parameter_list|()
block|{
return|return
operator|new
name|OrcStruct
argument_list|(
name|OrcRecordUpdater
operator|.
name|FIELDS
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|long
name|getPos
parameter_list|()
throws|throws
name|IOException
block|{
return|return
name|offset
operator|+
call|(
name|long
call|)
argument_list|(
name|getProgress
argument_list|()
operator|*
name|length
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|close
parameter_list|()
throws|throws
name|IOException
block|{
for|for
control|(
name|ReaderPair
name|pair
range|:
name|readers
operator|.
name|values
argument_list|()
control|)
block|{
name|pair
operator|.
name|recordReader
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|float
name|getProgress
parameter_list|()
throws|throws
name|IOException
block|{
return|return
name|baseReader
operator|==
literal|null
condition|?
literal|1
else|:
name|baseReader
operator|.
name|getProgress
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|ObjectInspector
name|getObjectInspector
parameter_list|()
block|{
comment|// Read the configuration parameters
name|String
name|columnNameProperty
init|=
name|conf
operator|.
name|get
argument_list|(
name|serdeConstants
operator|.
name|LIST_COLUMNS
argument_list|)
decl_stmt|;
comment|// NOTE: if "columns.types" is missing, all columns will be of String type
name|String
name|columnTypeProperty
init|=
name|conf
operator|.
name|get
argument_list|(
name|serdeConstants
operator|.
name|LIST_COLUMN_TYPES
argument_list|)
decl_stmt|;
comment|// Parse the configuration parameters
name|ArrayList
argument_list|<
name|String
argument_list|>
name|columnNames
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
name|Deque
argument_list|<
name|Integer
argument_list|>
name|virtualColumns
init|=
operator|new
name|ArrayDeque
argument_list|<
name|Integer
argument_list|>
argument_list|()
decl_stmt|;
if|if
condition|(
name|columnNameProperty
operator|!=
literal|null
operator|&&
name|columnNameProperty
operator|.
name|length
argument_list|()
operator|>
literal|0
condition|)
block|{
name|String
index|[]
name|colNames
init|=
name|columnNameProperty
operator|.
name|split
argument_list|(
literal|","
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|colNames
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|VirtualColumn
operator|.
name|VIRTUAL_COLUMN_NAMES
operator|.
name|contains
argument_list|(
name|colNames
index|[
name|i
index|]
argument_list|)
condition|)
block|{
name|virtualColumns
operator|.
name|addLast
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|columnNames
operator|.
name|add
argument_list|(
name|colNames
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|columnTypeProperty
operator|==
literal|null
condition|)
block|{
comment|// Default type: all string
name|StringBuilder
name|sb
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|columnNames
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|>
literal|0
condition|)
block|{
name|sb
operator|.
name|append
argument_list|(
literal|":"
argument_list|)
expr_stmt|;
block|}
name|sb
operator|.
name|append
argument_list|(
literal|"string"
argument_list|)
expr_stmt|;
block|}
name|columnTypeProperty
operator|=
name|sb
operator|.
name|toString
argument_list|()
expr_stmt|;
block|}
name|ArrayList
argument_list|<
name|TypeInfo
argument_list|>
name|fieldTypes
init|=
name|TypeInfoUtils
operator|.
name|getTypeInfosFromTypeString
argument_list|(
name|columnTypeProperty
argument_list|)
decl_stmt|;
while|while
condition|(
name|virtualColumns
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
name|fieldTypes
operator|.
name|remove
argument_list|(
name|virtualColumns
operator|.
name|removeLast
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|StructTypeInfo
name|rowType
init|=
operator|new
name|StructTypeInfo
argument_list|()
decl_stmt|;
name|rowType
operator|.
name|setAllStructFieldNames
argument_list|(
name|columnNames
argument_list|)
expr_stmt|;
name|rowType
operator|.
name|setAllStructFieldTypeInfos
argument_list|(
name|fieldTypes
argument_list|)
expr_stmt|;
return|return
name|OrcRecordUpdater
operator|.
name|createEventSchema
argument_list|(
name|OrcStruct
operator|.
name|createObjectInspector
argument_list|(
name|rowType
argument_list|)
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|isDelete
parameter_list|(
name|OrcStruct
name|value
parameter_list|)
block|{
return|return
name|OrcRecordUpdater
operator|.
name|getOperation
argument_list|(
name|value
argument_list|)
operator|==
name|OrcRecordUpdater
operator|.
name|DELETE_OPERATION
return|;
block|}
comment|/**    * Get the number of columns in the underlying rows.    * @return 0 if there are no base and no deltas.    */
specifier|public
name|int
name|getColumns
parameter_list|()
block|{
return|return
name|columns
return|;
block|}
block|}
end_class

end_unit

