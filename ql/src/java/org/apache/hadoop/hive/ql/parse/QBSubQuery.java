begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|parse
package|;
end_package

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Stack
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|common
operator|.
name|ObjectPair
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|Context
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|ErrorMsg
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|ColumnInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|lib
operator|.
name|Node
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|lib
operator|.
name|NodeProcessor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|parse
operator|.
name|SubQueryUtils
operator|.
name|ISubQueryJoinInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|parse
operator|.
name|TypeCheckProcFactory
operator|.
name|DefaultExprProcessor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|ExprNodeColumnDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|ExprNodeConstantDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|ExprNodeDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|typeinfo
operator|.
name|TypeInfoFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|parse
operator|.
name|SubQueryDiagnostic
operator|.
name|QBSubQueryRewrite
import|;
end_import

begin_class
specifier|public
class|class
name|QBSubQuery
implements|implements
name|ISubQueryJoinInfo
block|{
specifier|public
specifier|static
enum|enum
name|SubQueryType
block|{
name|EXISTS
block|,
name|NOT_EXISTS
block|,
name|IN
block|,
name|NOT_IN
block|;
specifier|public
specifier|static
name|SubQueryType
name|get
parameter_list|(
name|ASTNode
name|opNode
parameter_list|)
throws|throws
name|SemanticException
block|{
switch|switch
condition|(
name|opNode
operator|.
name|getType
argument_list|()
condition|)
block|{
case|case
name|HiveParser
operator|.
name|KW_EXISTS
case|:
return|return
name|EXISTS
return|;
case|case
name|HiveParser
operator|.
name|TOK_SUBQUERY_OP_NOTEXISTS
case|:
return|return
name|NOT_EXISTS
return|;
case|case
name|HiveParser
operator|.
name|KW_IN
case|:
return|return
name|IN
return|;
case|case
name|HiveParser
operator|.
name|TOK_SUBQUERY_OP_NOTIN
case|:
return|return
name|NOT_IN
return|;
default|default:
throw|throw
operator|new
name|SemanticException
argument_list|(
name|SemanticAnalyzer
operator|.
name|generateErrorMessage
argument_list|(
name|opNode
argument_list|,
literal|"Operator not supported in SubQuery use."
argument_list|)
argument_list|)
throw|;
block|}
block|}
block|}
specifier|public
specifier|static
class|class
name|SubQueryTypeDef
block|{
specifier|private
specifier|final
name|ASTNode
name|ast
decl_stmt|;
specifier|private
specifier|final
name|SubQueryType
name|type
decl_stmt|;
specifier|public
name|SubQueryTypeDef
parameter_list|(
name|ASTNode
name|ast
parameter_list|,
name|SubQueryType
name|type
parameter_list|)
block|{
name|super
argument_list|()
expr_stmt|;
name|this
operator|.
name|ast
operator|=
name|ast
expr_stmt|;
name|this
operator|.
name|type
operator|=
name|type
expr_stmt|;
block|}
specifier|public
name|ASTNode
name|getAst
parameter_list|()
block|{
return|return
name|ast
return|;
block|}
specifier|public
name|SubQueryType
name|getType
parameter_list|()
block|{
return|return
name|type
return|;
block|}
block|}
comment|/*    * An expression is either the left/right side of an Equality predicate in the SubQuery where    * clause; or it is the entire conjunct. For e.g. if the Where Clause for a SubQuery is:    * where R1.X = R2.Y and R2.Z> 7    * Then the expressions analyzed are R1.X, R2.X ( the left and right sides of the Equality    * predicate); and R2.Z> 7.    *    * The ExprType tracks whether the expr:    * - has a reference to a SubQuery table source    * - has a reference to Outer(parent) Query table source    */
specifier|static
enum|enum
name|ExprType
block|{
name|REFERS_NONE
argument_list|(
literal|false
argument_list|,
literal|false
argument_list|)
block|{
annotation|@
name|Override
specifier|public
name|ExprType
name|combine
parameter_list|(
name|ExprType
name|other
parameter_list|)
block|{
return|return
name|other
return|;
block|}
block|}
block|,
name|REFERS_PARENT
argument_list|(
literal|true
argument_list|,
literal|false
argument_list|)
block|{
annotation|@
name|Override
specifier|public
name|ExprType
name|combine
parameter_list|(
name|ExprType
name|other
parameter_list|)
block|{
switch|switch
condition|(
name|other
condition|)
block|{
case|case
name|REFERS_SUBQUERY
case|:
case|case
name|REFERS_BOTH
case|:
return|return
name|REFERS_BOTH
return|;
default|default:
return|return
name|this
return|;
block|}
block|}
block|}
block|,
name|REFERS_SUBQUERY
argument_list|(
literal|false
argument_list|,
literal|true
argument_list|)
block|{
annotation|@
name|Override
specifier|public
name|ExprType
name|combine
parameter_list|(
name|ExprType
name|other
parameter_list|)
block|{
switch|switch
condition|(
name|other
condition|)
block|{
case|case
name|REFERS_PARENT
case|:
case|case
name|REFERS_BOTH
case|:
return|return
name|REFERS_BOTH
return|;
default|default:
return|return
name|this
return|;
block|}
block|}
block|}
block|,
name|REFERS_BOTH
argument_list|(
literal|true
argument_list|,
literal|true
argument_list|)
block|{
annotation|@
name|Override
specifier|public
name|ExprType
name|combine
parameter_list|(
name|ExprType
name|other
parameter_list|)
block|{
return|return
name|this
return|;
block|}
block|}
block|;
specifier|final
name|boolean
name|refersParent
decl_stmt|;
specifier|final
name|boolean
name|refersSubQuery
decl_stmt|;
name|ExprType
parameter_list|(
name|boolean
name|refersParent
parameter_list|,
name|boolean
name|refersSubQuery
parameter_list|)
block|{
name|this
operator|.
name|refersParent
operator|=
name|refersParent
expr_stmt|;
name|this
operator|.
name|refersSubQuery
operator|=
name|refersSubQuery
expr_stmt|;
block|}
specifier|public
name|boolean
name|refersParent
parameter_list|()
block|{
return|return
name|refersParent
return|;
block|}
specifier|public
name|boolean
name|refersSubQuery
parameter_list|()
block|{
return|return
name|refersSubQuery
return|;
block|}
specifier|public
specifier|abstract
name|ExprType
name|combine
parameter_list|(
name|ExprType
name|other
parameter_list|)
function_decl|;
block|}
comment|/*    * This class captures the information about a    * conjunct in the where clause of the SubQuery.    * For a equality predicate it capture for each side:    * - the AST    * - the type of Expression (basically what columns are referenced)    * - for Expressions that refer the parent it captures the    *   parent's ColumnInfo. In case of outer Aggregation expressions    *   we need this to introduce a new mapping in the OuterQuery    *   RowResolver. A join condition must use qualified column references,    *   so we generate a new name for the aggr expression and use it in the    *   joining condition.    *   For e.g.    *   having exists ( select x from R2 where y = min(R1.z) )    *   where the expression 'min(R1.z)' is from the outer Query.    *   We give this expression a new name like 'R1._gby_sq_col_1'    *   and use the join condition: R1._gby_sq_col_1 = R2.y    */
specifier|static
class|class
name|Conjunct
block|{
specifier|private
specifier|final
name|ASTNode
name|leftExpr
decl_stmt|;
specifier|private
specifier|final
name|ASTNode
name|rightExpr
decl_stmt|;
specifier|private
specifier|final
name|ExprType
name|leftExprType
decl_stmt|;
specifier|private
specifier|final
name|ExprType
name|rightExprType
decl_stmt|;
specifier|private
specifier|final
name|ColumnInfo
name|leftOuterColInfo
decl_stmt|;
specifier|private
specifier|final
name|ColumnInfo
name|rightOuterColInfo
decl_stmt|;
name|Conjunct
parameter_list|(
name|ASTNode
name|leftExpr
parameter_list|,
name|ASTNode
name|rightExpr
parameter_list|,
name|ExprType
name|leftExprType
parameter_list|,
name|ExprType
name|rightExprType
parameter_list|,
name|ColumnInfo
name|leftOuterColInfo
parameter_list|,
name|ColumnInfo
name|rightOuterColInfo
parameter_list|)
block|{
name|super
argument_list|()
expr_stmt|;
name|this
operator|.
name|leftExpr
operator|=
name|leftExpr
expr_stmt|;
name|this
operator|.
name|rightExpr
operator|=
name|rightExpr
expr_stmt|;
name|this
operator|.
name|leftExprType
operator|=
name|leftExprType
expr_stmt|;
name|this
operator|.
name|rightExprType
operator|=
name|rightExprType
expr_stmt|;
name|this
operator|.
name|leftOuterColInfo
operator|=
name|leftOuterColInfo
expr_stmt|;
name|this
operator|.
name|rightOuterColInfo
operator|=
name|rightOuterColInfo
expr_stmt|;
block|}
name|ASTNode
name|getLeftExpr
parameter_list|()
block|{
return|return
name|leftExpr
return|;
block|}
name|ASTNode
name|getRightExpr
parameter_list|()
block|{
return|return
name|rightExpr
return|;
block|}
name|ExprType
name|getLeftExprType
parameter_list|()
block|{
return|return
name|leftExprType
return|;
block|}
name|ExprType
name|getRightExprType
parameter_list|()
block|{
return|return
name|rightExprType
return|;
block|}
name|boolean
name|eitherSideRefersBoth
parameter_list|()
block|{
if|if
condition|(
name|leftExprType
operator|==
name|ExprType
operator|.
name|REFERS_BOTH
condition|)
block|{
return|return
literal|true
return|;
block|}
elseif|else
if|if
condition|(
name|rightExpr
operator|!=
literal|null
condition|)
block|{
return|return
name|rightExprType
operator|==
name|ExprType
operator|.
name|REFERS_BOTH
return|;
block|}
return|return
literal|false
return|;
block|}
name|boolean
name|isCorrelated
parameter_list|()
block|{
if|if
condition|(
name|rightExpr
operator|!=
literal|null
condition|)
block|{
return|return
name|leftExprType
operator|.
name|combine
argument_list|(
name|rightExprType
argument_list|)
operator|==
name|ExprType
operator|.
name|REFERS_BOTH
return|;
block|}
return|return
literal|false
return|;
block|}
name|boolean
name|refersOuterOnly
parameter_list|()
block|{
if|if
condition|(
name|rightExpr
operator|==
literal|null
condition|)
block|{
return|return
name|leftExprType
operator|==
name|ExprType
operator|.
name|REFERS_PARENT
return|;
block|}
return|return
name|leftExprType
operator|.
name|combine
argument_list|(
name|rightExprType
argument_list|)
operator|==
name|ExprType
operator|.
name|REFERS_PARENT
return|;
block|}
name|ColumnInfo
name|getLeftOuterColInfo
parameter_list|()
block|{
return|return
name|leftOuterColInfo
return|;
block|}
name|ColumnInfo
name|getRightOuterColInfo
parameter_list|()
block|{
return|return
name|rightOuterColInfo
return|;
block|}
block|}
class|class
name|ConjunctAnalyzer
block|{
name|RowResolver
name|parentQueryRR
decl_stmt|;
name|boolean
name|forHavingClause
decl_stmt|;
name|String
name|parentQueryNewAlias
decl_stmt|;
name|NodeProcessor
name|defaultExprProcessor
decl_stmt|;
name|Stack
argument_list|<
name|Node
argument_list|>
name|stack
decl_stmt|;
name|ConjunctAnalyzer
parameter_list|(
name|RowResolver
name|parentQueryRR
parameter_list|,
name|boolean
name|forHavingClause
parameter_list|,
name|String
name|parentQueryNewAlias
parameter_list|)
block|{
name|this
operator|.
name|parentQueryRR
operator|=
name|parentQueryRR
expr_stmt|;
name|defaultExprProcessor
operator|=
operator|new
name|DefaultExprProcessor
argument_list|()
expr_stmt|;
name|this
operator|.
name|forHavingClause
operator|=
name|forHavingClause
expr_stmt|;
name|this
operator|.
name|parentQueryNewAlias
operator|=
name|parentQueryNewAlias
expr_stmt|;
name|stack
operator|=
operator|new
name|Stack
argument_list|<
name|Node
argument_list|>
argument_list|()
expr_stmt|;
block|}
comment|/*      * 1. On encountering a DOT, we attempt to resolve the leftmost name      *    to the Parent Query.      * 2. An unqualified name is assumed to be a SubQuery reference.      *    We don't attempt to resolve this to the Parent; because      *    we require all Parent column references to be qualified.      * 3. All other expressions have a Type based on their children.      *    An Expr w/o children is assumed to refer to neither.      */
specifier|private
name|ObjectPair
argument_list|<
name|ExprType
argument_list|,
name|ColumnInfo
argument_list|>
name|analyzeExpr
parameter_list|(
name|ASTNode
name|expr
parameter_list|)
block|{
name|ColumnInfo
name|cInfo
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|forHavingClause
condition|)
block|{
try|try
block|{
name|cInfo
operator|=
name|parentQueryRR
operator|.
name|getExpression
argument_list|(
name|expr
argument_list|)
expr_stmt|;
if|if
condition|(
name|cInfo
operator|!=
literal|null
condition|)
block|{
return|return
name|ObjectPair
operator|.
name|create
argument_list|(
name|ExprType
operator|.
name|REFERS_PARENT
argument_list|,
name|cInfo
argument_list|)
return|;
block|}
block|}
catch|catch
parameter_list|(
name|SemanticException
name|se
parameter_list|)
block|{         }
block|}
if|if
condition|(
name|expr
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|DOT
condition|)
block|{
name|ASTNode
name|dot
init|=
name|firstDot
argument_list|(
name|expr
argument_list|)
decl_stmt|;
name|cInfo
operator|=
name|resolveDot
argument_list|(
name|dot
argument_list|)
expr_stmt|;
if|if
condition|(
name|cInfo
operator|!=
literal|null
condition|)
block|{
return|return
name|ObjectPair
operator|.
name|create
argument_list|(
name|ExprType
operator|.
name|REFERS_PARENT
argument_list|,
name|cInfo
argument_list|)
return|;
block|}
return|return
name|ObjectPair
operator|.
name|create
argument_list|(
name|ExprType
operator|.
name|REFERS_SUBQUERY
argument_list|,
literal|null
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|expr
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_TABLE_OR_COL
condition|)
block|{
return|return
name|ObjectPair
operator|.
name|create
argument_list|(
name|ExprType
operator|.
name|REFERS_SUBQUERY
argument_list|,
literal|null
argument_list|)
return|;
block|}
else|else
block|{
name|ExprType
name|exprType
init|=
name|ExprType
operator|.
name|REFERS_NONE
decl_stmt|;
name|int
name|cnt
init|=
name|expr
operator|.
name|getChildCount
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|cnt
condition|;
name|i
operator|++
control|)
block|{
name|ASTNode
name|child
init|=
operator|(
name|ASTNode
operator|)
name|expr
operator|.
name|getChild
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|exprType
operator|=
name|exprType
operator|.
name|combine
argument_list|(
name|analyzeExpr
argument_list|(
name|child
argument_list|)
operator|.
name|getFirst
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|ObjectPair
operator|.
name|create
argument_list|(
name|exprType
argument_list|,
literal|null
argument_list|)
return|;
block|}
block|}
comment|/*      * 1. The only correlation operator we check for is EQUAL; because that is      *    the one for which we can do a Algebraic transformation.      * 2. For expressions that are not an EQUAL predicate, we treat them as conjuncts      *    having only 1 side. These should only contain references to the SubQuery      *    table sources.      * 3. For expressions that are an EQUAL predicate; we analyze each side and let the      *    left and right exprs in the Conjunct object.      *      * @return Conjunct  contains details on the left and right side of the conjunct expression.      */
name|Conjunct
name|analyzeConjunct
parameter_list|(
name|ASTNode
name|conjunct
parameter_list|)
throws|throws
name|SemanticException
block|{
name|int
name|type
init|=
name|conjunct
operator|.
name|getType
argument_list|()
decl_stmt|;
if|if
condition|(
name|type
operator|==
name|HiveParser
operator|.
name|EQUAL
condition|)
block|{
name|ASTNode
name|left
init|=
operator|(
name|ASTNode
operator|)
name|conjunct
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|ASTNode
name|right
init|=
operator|(
name|ASTNode
operator|)
name|conjunct
operator|.
name|getChild
argument_list|(
literal|1
argument_list|)
decl_stmt|;
name|ObjectPair
argument_list|<
name|ExprType
argument_list|,
name|ColumnInfo
argument_list|>
name|leftInfo
init|=
name|analyzeExpr
argument_list|(
name|left
argument_list|)
decl_stmt|;
name|ObjectPair
argument_list|<
name|ExprType
argument_list|,
name|ColumnInfo
argument_list|>
name|rightInfo
init|=
name|analyzeExpr
argument_list|(
name|right
argument_list|)
decl_stmt|;
return|return
operator|new
name|Conjunct
argument_list|(
name|left
argument_list|,
name|right
argument_list|,
name|leftInfo
operator|.
name|getFirst
argument_list|()
argument_list|,
name|rightInfo
operator|.
name|getFirst
argument_list|()
argument_list|,
name|leftInfo
operator|.
name|getSecond
argument_list|()
argument_list|,
name|rightInfo
operator|.
name|getSecond
argument_list|()
argument_list|)
return|;
block|}
else|else
block|{
name|ObjectPair
argument_list|<
name|ExprType
argument_list|,
name|ColumnInfo
argument_list|>
name|sqExprInfo
init|=
name|analyzeExpr
argument_list|(
name|conjunct
argument_list|)
decl_stmt|;
return|return
operator|new
name|Conjunct
argument_list|(
name|conjunct
argument_list|,
literal|null
argument_list|,
name|sqExprInfo
operator|.
name|getFirst
argument_list|()
argument_list|,
literal|null
argument_list|,
name|sqExprInfo
operator|.
name|getSecond
argument_list|()
argument_list|,
name|sqExprInfo
operator|.
name|getSecond
argument_list|()
argument_list|)
return|;
block|}
block|}
comment|/*      * Try to resolve a qualified name as a column reference on the Parent Query's RowResolver.      * Apply this logic on the leftmost(first) dot in an AST tree.      */
specifier|protected
name|ColumnInfo
name|resolveDot
parameter_list|(
name|ASTNode
name|node
parameter_list|)
block|{
try|try
block|{
name|TypeCheckCtx
name|tcCtx
init|=
operator|new
name|TypeCheckCtx
argument_list|(
name|parentQueryRR
argument_list|)
decl_stmt|;
name|String
name|str
init|=
name|BaseSemanticAnalyzer
operator|.
name|unescapeIdentifier
argument_list|(
name|node
operator|.
name|getChild
argument_list|(
literal|1
argument_list|)
operator|.
name|getText
argument_list|()
argument_list|)
decl_stmt|;
name|ExprNodeDesc
name|idDesc
init|=
operator|new
name|ExprNodeConstantDesc
argument_list|(
name|TypeInfoFactory
operator|.
name|stringTypeInfo
argument_list|,
name|str
argument_list|)
decl_stmt|;
name|ExprNodeColumnDesc
name|colDesc
init|=
operator|(
name|ExprNodeColumnDesc
operator|)
name|defaultExprProcessor
operator|.
name|process
argument_list|(
name|node
argument_list|,
name|stack
argument_list|,
name|tcCtx
argument_list|,
operator|(
name|Object
operator|)
literal|null
argument_list|,
name|idDesc
argument_list|)
decl_stmt|;
if|if
condition|(
name|colDesc
operator|!=
literal|null
condition|)
block|{
name|String
index|[]
name|qualName
init|=
name|parentQueryRR
operator|.
name|reverseLookup
argument_list|(
name|colDesc
operator|.
name|getColumn
argument_list|()
argument_list|)
decl_stmt|;
return|return
name|parentQueryRR
operator|.
name|get
argument_list|(
name|qualName
index|[
literal|0
index|]
argument_list|,
name|qualName
index|[
literal|1
index|]
argument_list|)
return|;
block|}
block|}
catch|catch
parameter_list|(
name|SemanticException
name|se
parameter_list|)
block|{       }
return|return
literal|null
return|;
block|}
comment|/*      * We want to resolve the leftmost name to the Parent Query's RR.      * Hence we do a left walk down the AST, until we reach the bottom most DOT.      */
specifier|protected
name|ASTNode
name|firstDot
parameter_list|(
name|ASTNode
name|dot
parameter_list|)
block|{
name|ASTNode
name|firstChild
init|=
operator|(
name|ASTNode
operator|)
name|dot
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|firstChild
operator|!=
literal|null
operator|&&
name|firstChild
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|DOT
condition|)
block|{
return|return
name|firstDot
argument_list|(
name|firstChild
argument_list|)
return|;
block|}
return|return
name|dot
return|;
block|}
block|}
comment|/*    * When transforming a Not In SubQuery we need to check for nulls in the    * Joining expressions of the SubQuery. If there are nulls then the SubQuery always    * return false. For more details see    * https://issues.apache.org/jira/secure/attachment/12614003/SubQuerySpec.pdf    *    * Basically, SQL semantics say that:    * - R1.A not in (null, 1, 2, ...)    *   is always false.    *   A 'not in' operator is equivalent to a '<> all'. Since a not equal check with null    *   returns false, a not in predicate against aset with a 'null' value always returns false.    *    * So for not in SubQuery predicates:    * - we join in a null count predicate.    * - And the joining condition is that the 'Null Count' query has a count of 0.    *    */
class|class
name|NotInCheck
implements|implements
name|ISubQueryJoinInfo
block|{
specifier|private
specifier|static
specifier|final
name|String
name|CNT_ALIAS
init|=
literal|"c1"
decl_stmt|;
comment|/*      * expressions in SubQ that are joined to the Outer Query.      */
name|List
argument_list|<
name|ASTNode
argument_list|>
name|subQryCorrExprs
decl_stmt|;
comment|/*      * row resolver of the SubQuery.      * Set by the SemanticAnalyzer after the Plan for the SubQuery is genned.      * This is neede in case the SubQuery select list contains a TOK_ALLCOLREF      */
name|RowResolver
name|sqRR
decl_stmt|;
name|NotInCheck
parameter_list|()
block|{
name|subQryCorrExprs
operator|=
operator|new
name|ArrayList
argument_list|<
name|ASTNode
argument_list|>
argument_list|()
expr_stmt|;
block|}
name|void
name|addCorrExpr
parameter_list|(
name|ASTNode
name|corrExpr
parameter_list|)
block|{
name|subQryCorrExprs
operator|.
name|add
argument_list|(
name|corrExpr
argument_list|)
expr_stmt|;
block|}
specifier|public
name|ASTNode
name|getSubQueryAST
parameter_list|()
block|{
name|ASTNode
name|ast
init|=
name|SubQueryUtils
operator|.
name|buildNotInNullCheckQuery
argument_list|(
name|QBSubQuery
operator|.
name|this
operator|.
name|getSubQueryAST
argument_list|()
argument_list|,
name|QBSubQuery
operator|.
name|this
operator|.
name|getAlias
argument_list|()
argument_list|,
name|CNT_ALIAS
argument_list|,
name|subQryCorrExprs
argument_list|,
name|sqRR
argument_list|)
decl_stmt|;
name|SubQueryUtils
operator|.
name|setOriginDeep
argument_list|(
name|ast
argument_list|,
name|QBSubQuery
operator|.
name|this
operator|.
name|originalSQASTOrigin
argument_list|)
expr_stmt|;
return|return
name|ast
return|;
block|}
specifier|public
name|String
name|getAlias
parameter_list|()
block|{
return|return
name|QBSubQuery
operator|.
name|this
operator|.
name|getAlias
argument_list|()
operator|+
literal|"_notin_nullcheck"
return|;
block|}
specifier|public
name|JoinType
name|getJoinType
parameter_list|()
block|{
return|return
name|JoinType
operator|.
name|LEFTSEMI
return|;
block|}
specifier|public
name|ASTNode
name|getJoinConditionAST
parameter_list|()
block|{
name|ASTNode
name|ast
init|=
name|SubQueryUtils
operator|.
name|buildNotInNullJoinCond
argument_list|(
name|getAlias
argument_list|()
argument_list|,
name|CNT_ALIAS
argument_list|)
decl_stmt|;
name|SubQueryUtils
operator|.
name|setOriginDeep
argument_list|(
name|ast
argument_list|,
name|QBSubQuery
operator|.
name|this
operator|.
name|originalSQASTOrigin
argument_list|)
expr_stmt|;
return|return
name|ast
return|;
block|}
specifier|public
name|QBSubQuery
name|getSubQuery
parameter_list|()
block|{
return|return
name|QBSubQuery
operator|.
name|this
return|;
block|}
specifier|public
name|String
name|getOuterQueryId
parameter_list|()
block|{
return|return
name|QBSubQuery
operator|.
name|this
operator|.
name|getOuterQueryId
argument_list|()
return|;
block|}
name|void
name|setSQRR
parameter_list|(
name|RowResolver
name|sqRR
parameter_list|)
block|{
name|this
operator|.
name|sqRR
operator|=
name|sqRR
expr_stmt|;
block|}
block|}
specifier|private
specifier|final
name|String
name|outerQueryId
decl_stmt|;
specifier|private
specifier|final
name|int
name|sqIdx
decl_stmt|;
specifier|private
specifier|final
name|String
name|alias
decl_stmt|;
specifier|private
specifier|final
name|ASTNode
name|subQueryAST
decl_stmt|;
specifier|private
specifier|final
name|ASTNode
name|parentQueryExpression
decl_stmt|;
specifier|private
specifier|final
name|SubQueryTypeDef
name|operator
decl_stmt|;
specifier|private
name|boolean
name|containsAggregationExprs
decl_stmt|;
specifier|private
name|boolean
name|hasCorrelation
decl_stmt|;
specifier|private
name|ASTNode
name|joinConditionAST
decl_stmt|;
specifier|private
name|JoinType
name|joinType
decl_stmt|;
specifier|private
name|ASTNode
name|postJoinConditionAST
decl_stmt|;
specifier|private
name|int
name|numCorrExprsinSQ
decl_stmt|;
specifier|private
name|List
argument_list|<
name|ASTNode
argument_list|>
name|subQueryJoinAliasExprs
decl_stmt|;
specifier|private
specifier|transient
specifier|final
name|ASTNodeOrigin
name|originalSQASTOrigin
decl_stmt|;
comment|/*    * tracks number of exprs from correlated predicates added to SQ select list.    */
specifier|private
name|int
name|numOfCorrelationExprsAddedToSQSelect
decl_stmt|;
specifier|private
name|boolean
name|groupbyAddedToSQ
decl_stmt|;
specifier|private
name|int
name|numOuterCorrExprsForHaving
decl_stmt|;
specifier|private
name|NotInCheck
name|notInCheck
decl_stmt|;
specifier|private
name|QBSubQueryRewrite
name|subQueryDiagnostic
decl_stmt|;
specifier|public
name|QBSubQuery
parameter_list|(
name|String
name|outerQueryId
parameter_list|,
name|int
name|sqIdx
parameter_list|,
name|ASTNode
name|subQueryAST
parameter_list|,
name|ASTNode
name|parentQueryExpression
parameter_list|,
name|SubQueryTypeDef
name|operator
parameter_list|,
name|ASTNode
name|originalSQAST
parameter_list|,
name|Context
name|ctx
parameter_list|)
block|{
name|super
argument_list|()
expr_stmt|;
name|this
operator|.
name|subQueryAST
operator|=
name|subQueryAST
expr_stmt|;
name|this
operator|.
name|parentQueryExpression
operator|=
name|parentQueryExpression
expr_stmt|;
name|this
operator|.
name|operator
operator|=
name|operator
expr_stmt|;
name|this
operator|.
name|outerQueryId
operator|=
name|outerQueryId
expr_stmt|;
name|this
operator|.
name|sqIdx
operator|=
name|sqIdx
expr_stmt|;
name|this
operator|.
name|alias
operator|=
literal|"sq_"
operator|+
name|this
operator|.
name|sqIdx
expr_stmt|;
name|this
operator|.
name|numCorrExprsinSQ
operator|=
literal|0
expr_stmt|;
name|this
operator|.
name|numOuterCorrExprsForHaving
operator|=
literal|0
expr_stmt|;
name|String
name|s
init|=
name|ctx
operator|.
name|getTokenRewriteStream
argument_list|()
operator|.
name|toString
argument_list|(
name|originalSQAST
operator|.
name|getTokenStartIndex
argument_list|()
argument_list|,
name|originalSQAST
operator|.
name|getTokenStopIndex
argument_list|()
argument_list|)
decl_stmt|;
name|originalSQASTOrigin
operator|=
operator|new
name|ASTNodeOrigin
argument_list|(
literal|"SubQuery"
argument_list|,
name|alias
argument_list|,
name|s
argument_list|,
name|alias
argument_list|,
name|originalSQAST
argument_list|)
expr_stmt|;
name|numOfCorrelationExprsAddedToSQSelect
operator|=
literal|0
expr_stmt|;
name|groupbyAddedToSQ
operator|=
literal|false
expr_stmt|;
if|if
condition|(
name|operator
operator|.
name|getType
argument_list|()
operator|==
name|SubQueryType
operator|.
name|NOT_IN
condition|)
block|{
name|notInCheck
operator|=
operator|new
name|NotInCheck
argument_list|()
expr_stmt|;
block|}
name|subQueryDiagnostic
operator|=
name|SubQueryDiagnostic
operator|.
name|getRewrite
argument_list|(
name|this
argument_list|,
name|ctx
operator|.
name|getTokenRewriteStream
argument_list|()
argument_list|,
name|ctx
argument_list|)
expr_stmt|;
block|}
specifier|public
name|ASTNode
name|getSubQueryAST
parameter_list|()
block|{
return|return
name|subQueryAST
return|;
block|}
specifier|public
name|ASTNode
name|getOuterQueryExpression
parameter_list|()
block|{
return|return
name|parentQueryExpression
return|;
block|}
specifier|public
name|SubQueryTypeDef
name|getOperator
parameter_list|()
block|{
return|return
name|operator
return|;
block|}
specifier|public
name|ASTNode
name|getOriginalSubQueryASTForRewrite
parameter_list|()
block|{
return|return
operator|(
name|operator
operator|.
name|getType
argument_list|()
operator|==
name|SubQueryType
operator|.
name|NOT_EXISTS
operator|||
name|operator
operator|.
name|getType
argument_list|()
operator|==
name|SubQueryType
operator|.
name|NOT_IN
condition|?
operator|(
name|ASTNode
operator|)
name|originalSQASTOrigin
operator|.
name|getUsageNode
argument_list|()
operator|.
name|getParent
argument_list|()
else|:
name|originalSQASTOrigin
operator|.
name|getUsageNode
argument_list|()
operator|)
return|;
block|}
name|void
name|validateAndRewriteAST
parameter_list|(
name|RowResolver
name|outerQueryRR
parameter_list|,
name|boolean
name|forHavingClause
parameter_list|,
name|String
name|outerQueryAlias
parameter_list|,
name|Set
argument_list|<
name|String
argument_list|>
name|outerQryAliases
parameter_list|)
throws|throws
name|SemanticException
block|{
name|ASTNode
name|selectClause
init|=
operator|(
name|ASTNode
operator|)
name|subQueryAST
operator|.
name|getChild
argument_list|(
literal|1
argument_list|)
operator|.
name|getChild
argument_list|(
literal|1
argument_list|)
decl_stmt|;
name|int
name|selectExprStart
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|selectClause
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_HINTLIST
condition|)
block|{
name|selectExprStart
operator|=
literal|1
expr_stmt|;
block|}
comment|/*      * Restriction.16.s :: Correlated Expression in Outer Query must not contain      * unqualified column references.      */
if|if
condition|(
name|parentQueryExpression
operator|!=
literal|null
operator|&&
operator|!
name|forHavingClause
condition|)
block|{
name|ASTNode
name|u
init|=
name|SubQueryUtils
operator|.
name|hasUnQualifiedColumnReferences
argument_list|(
name|parentQueryExpression
argument_list|)
decl_stmt|;
if|if
condition|(
name|u
operator|!=
literal|null
condition|)
block|{
name|subQueryAST
operator|.
name|setOrigin
argument_list|(
name|originalSQASTOrigin
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|UNSUPPORTED_SUBQUERY_EXPRESSION
operator|.
name|getMsg
argument_list|(
name|u
argument_list|,
literal|"Correlating expression cannot contain unqualified column references."
argument_list|)
argument_list|)
throw|;
block|}
block|}
comment|/*      * Restriction 17.s :: SubQuery cannot use the same table alias as one used in      * the Outer Query.      */
name|List
argument_list|<
name|String
argument_list|>
name|sqAliases
init|=
name|SubQueryUtils
operator|.
name|getTableAliasesInSubQuery
argument_list|(
name|this
argument_list|)
decl_stmt|;
name|String
name|sharedAlias
init|=
literal|null
decl_stmt|;
for|for
control|(
name|String
name|s
range|:
name|sqAliases
control|)
block|{
if|if
condition|(
name|outerQryAliases
operator|.
name|contains
argument_list|(
name|s
argument_list|)
condition|)
block|{
name|sharedAlias
operator|=
name|s
expr_stmt|;
block|}
block|}
if|if
condition|(
name|sharedAlias
operator|!=
literal|null
condition|)
block|{
name|ASTNode
name|whereClause
init|=
name|SubQueryUtils
operator|.
name|subQueryWhere
argument_list|(
name|subQueryAST
argument_list|)
decl_stmt|;
if|if
condition|(
name|whereClause
operator|!=
literal|null
condition|)
block|{
name|ASTNode
name|u
init|=
name|SubQueryUtils
operator|.
name|hasUnQualifiedColumnReferences
argument_list|(
name|whereClause
argument_list|)
decl_stmt|;
if|if
condition|(
name|u
operator|!=
literal|null
condition|)
block|{
name|subQueryAST
operator|.
name|setOrigin
argument_list|(
name|originalSQASTOrigin
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|UNSUPPORTED_SUBQUERY_EXPRESSION
operator|.
name|getMsg
argument_list|(
name|u
argument_list|,
literal|"SubQuery cannot use the table alias: "
operator|+
name|sharedAlias
operator|+
literal|"; "
operator|+
literal|"this is also an alias in the Outer Query and SubQuery contains a unqualified column reference"
argument_list|)
argument_list|)
throw|;
block|}
block|}
block|}
comment|/*      * Check.5.h :: For In and Not In the SubQuery must implicitly or      * explicitly only contain one select item.      */
if|if
condition|(
name|operator
operator|.
name|getType
argument_list|()
operator|!=
name|SubQueryType
operator|.
name|EXISTS
operator|&&
name|operator
operator|.
name|getType
argument_list|()
operator|!=
name|SubQueryType
operator|.
name|NOT_EXISTS
operator|&&
name|selectClause
operator|.
name|getChildCount
argument_list|()
operator|-
name|selectExprStart
operator|>
literal|1
condition|)
block|{
name|subQueryAST
operator|.
name|setOrigin
argument_list|(
name|originalSQASTOrigin
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|INVALID_SUBQUERY_EXPRESSION
operator|.
name|getMsg
argument_list|(
name|subQueryAST
argument_list|,
literal|"SubQuery can contain only 1 item in Select List."
argument_list|)
argument_list|)
throw|;
block|}
name|containsAggregationExprs
operator|=
literal|false
expr_stmt|;
name|boolean
name|containsWindowing
init|=
literal|false
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
name|selectExprStart
init|;
name|i
operator|<
name|selectClause
operator|.
name|getChildCount
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|ASTNode
name|selectItem
init|=
operator|(
name|ASTNode
operator|)
name|selectClause
operator|.
name|getChild
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|int
name|r
init|=
name|SubQueryUtils
operator|.
name|checkAggOrWindowing
argument_list|(
name|selectItem
argument_list|)
decl_stmt|;
name|containsWindowing
operator|=
name|containsWindowing
operator||
operator|(
name|r
operator|==
literal|2
operator|)
expr_stmt|;
name|containsAggregationExprs
operator|=
name|containsAggregationExprs
operator||
operator|(
name|r
operator|==
literal|1
operator|)
expr_stmt|;
block|}
name|rewrite
argument_list|(
name|outerQueryRR
argument_list|,
name|forHavingClause
argument_list|,
name|outerQueryAlias
argument_list|)
expr_stmt|;
name|SubQueryUtils
operator|.
name|setOriginDeep
argument_list|(
name|subQueryAST
argument_list|,
name|originalSQASTOrigin
argument_list|)
expr_stmt|;
comment|/*      * Restriction.13.m :: In the case of an implied Group By on a      * correlated SubQuery, the SubQuery always returns 1 row.      * An exists on a SubQuery with an implied GBy will always return true.      * Whereas Algebraically transforming to a Join may not return true. See      * Specification doc for details.      * Similarly a not exists on a SubQuery with a implied GBY will always return false.      */
if|if
condition|(
name|operator
operator|.
name|getType
argument_list|()
operator|==
name|SubQueryType
operator|.
name|EXISTS
operator|&&
name|containsAggregationExprs
operator|&&
name|groupbyAddedToSQ
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|INVALID_SUBQUERY_EXPRESSION
operator|.
name|getMsg
argument_list|(
name|subQueryAST
argument_list|,
literal|"An Exists predicate on SubQuery with implicit Aggregation(no Group By clause) "
operator|+
literal|"cannot be rewritten. (predicate will always return true)."
argument_list|)
argument_list|)
throw|;
block|}
if|if
condition|(
name|operator
operator|.
name|getType
argument_list|()
operator|==
name|SubQueryType
operator|.
name|NOT_EXISTS
operator|&&
name|containsAggregationExprs
operator|&&
name|groupbyAddedToSQ
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|INVALID_SUBQUERY_EXPRESSION
operator|.
name|getMsg
argument_list|(
name|subQueryAST
argument_list|,
literal|"A Not Exists predicate on SubQuery with implicit Aggregation(no Group By clause) "
operator|+
literal|"cannot be rewritten. (predicate will always return false)."
argument_list|)
argument_list|)
throw|;
block|}
comment|/*      * Restriction.14.h :: Correlated Sub Queries cannot contain Windowing clauses.      */
if|if
condition|(
name|containsWindowing
operator|&&
name|hasCorrelation
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|UNSUPPORTED_SUBQUERY_EXPRESSION
operator|.
name|getMsg
argument_list|(
name|subQueryAST
argument_list|,
literal|"Correlated Sub Queries cannot contain Windowing clauses."
argument_list|)
argument_list|)
throw|;
block|}
comment|/*      * Check.4.h :: For Exists and Not Exists, the Sub Query must      * have 1 or more correlated predicates.      */
if|if
condition|(
operator|(
name|operator
operator|.
name|getType
argument_list|()
operator|==
name|SubQueryType
operator|.
name|EXISTS
operator|||
name|operator
operator|.
name|getType
argument_list|()
operator|==
name|SubQueryType
operator|.
name|NOT_EXISTS
operator|)
operator|&&
operator|!
name|hasCorrelation
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|INVALID_SUBQUERY_EXPRESSION
operator|.
name|getMsg
argument_list|(
name|subQueryAST
argument_list|,
literal|"For Exists/Not Exists operator SubQuery must be Correlated."
argument_list|)
argument_list|)
throw|;
block|}
block|}
specifier|private
name|void
name|setJoinType
parameter_list|()
block|{
if|if
condition|(
name|operator
operator|.
name|getType
argument_list|()
operator|==
name|SubQueryType
operator|.
name|NOT_IN
operator|||
name|operator
operator|.
name|getType
argument_list|()
operator|==
name|SubQueryType
operator|.
name|NOT_EXISTS
condition|)
block|{
name|joinType
operator|=
name|JoinType
operator|.
name|LEFTOUTER
expr_stmt|;
block|}
else|else
block|{
name|joinType
operator|=
name|JoinType
operator|.
name|LEFTSEMI
expr_stmt|;
block|}
block|}
name|void
name|buildJoinCondition
parameter_list|(
name|RowResolver
name|outerQueryRR
parameter_list|,
name|RowResolver
name|sqRR
parameter_list|,
name|boolean
name|forHavingClause
parameter_list|,
name|String
name|outerQueryAlias
parameter_list|)
throws|throws
name|SemanticException
block|{
name|ASTNode
name|parentQueryJoinCond
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|parentQueryExpression
operator|!=
literal|null
condition|)
block|{
name|ColumnInfo
name|outerQueryCol
init|=
literal|null
decl_stmt|;
try|try
block|{
name|outerQueryCol
operator|=
name|outerQueryRR
operator|.
name|getExpression
argument_list|(
name|parentQueryExpression
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|SemanticException
name|se
parameter_list|)
block|{       }
name|parentQueryJoinCond
operator|=
name|SubQueryUtils
operator|.
name|buildOuterQryToSQJoinCond
argument_list|(
name|getOuterQueryExpression
argument_list|()
argument_list|,
name|alias
argument_list|,
name|sqRR
argument_list|)
expr_stmt|;
if|if
condition|(
name|outerQueryCol
operator|!=
literal|null
condition|)
block|{
name|rewriteCorrConjunctForHaving
argument_list|(
name|parentQueryJoinCond
argument_list|,
literal|true
argument_list|,
name|outerQueryAlias
argument_list|,
name|outerQueryRR
argument_list|,
name|outerQueryCol
argument_list|)
expr_stmt|;
block|}
name|subQueryDiagnostic
operator|.
name|addJoinCondition
argument_list|(
name|parentQueryJoinCond
argument_list|,
name|outerQueryCol
operator|!=
literal|null
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
name|joinConditionAST
operator|=
name|SubQueryUtils
operator|.
name|andAST
argument_list|(
name|parentQueryJoinCond
argument_list|,
name|joinConditionAST
argument_list|)
expr_stmt|;
name|setJoinType
argument_list|()
expr_stmt|;
if|if
condition|(
name|joinType
operator|==
name|JoinType
operator|.
name|LEFTOUTER
condition|)
block|{
if|if
condition|(
name|operator
operator|.
name|getType
argument_list|()
operator|==
name|SubQueryType
operator|.
name|NOT_EXISTS
operator|&&
name|hasCorrelation
condition|)
block|{
name|postJoinConditionAST
operator|=
name|SubQueryUtils
operator|.
name|buildPostJoinNullCheck
argument_list|(
name|subQueryJoinAliasExprs
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|operator
operator|.
name|getType
argument_list|()
operator|==
name|SubQueryType
operator|.
name|NOT_IN
condition|)
block|{
name|postJoinConditionAST
operator|=
name|SubQueryUtils
operator|.
name|buildOuterJoinPostCond
argument_list|(
name|alias
argument_list|,
name|sqRR
argument_list|)
expr_stmt|;
block|}
block|}
name|SubQueryUtils
operator|.
name|setOriginDeep
argument_list|(
name|joinConditionAST
argument_list|,
name|originalSQASTOrigin
argument_list|)
expr_stmt|;
name|SubQueryUtils
operator|.
name|setOriginDeep
argument_list|(
name|postJoinConditionAST
argument_list|,
name|originalSQASTOrigin
argument_list|)
expr_stmt|;
block|}
name|ASTNode
name|updateOuterQueryFilter
parameter_list|(
name|ASTNode
name|outerQryFilter
parameter_list|)
block|{
if|if
condition|(
name|postJoinConditionAST
operator|==
literal|null
condition|)
block|{
return|return
name|outerQryFilter
return|;
block|}
name|subQueryDiagnostic
operator|.
name|addPostJoinCondition
argument_list|(
name|postJoinConditionAST
argument_list|)
expr_stmt|;
if|if
condition|(
name|outerQryFilter
operator|==
literal|null
condition|)
block|{
return|return
name|postJoinConditionAST
return|;
block|}
name|ASTNode
name|node
init|=
name|SubQueryUtils
operator|.
name|andAST
argument_list|(
name|outerQryFilter
argument_list|,
name|postJoinConditionAST
argument_list|)
decl_stmt|;
name|node
operator|.
name|setOrigin
argument_list|(
name|originalSQASTOrigin
argument_list|)
expr_stmt|;
return|return
name|node
return|;
block|}
name|String
name|getNextCorrExprAlias
parameter_list|()
block|{
return|return
literal|"sq_corr_"
operator|+
name|numCorrExprsinSQ
operator|++
return|;
block|}
comment|/*    * - If the SubQuery has no where clause, there is nothing to rewrite.    * - Decompose SubQuery where clause into list of Top level conjuncts.    * - For each conjunct    *   - Break down the conjunct into (LeftExpr, LeftExprType, RightExpr,    *     RightExprType)    *   - If the top level operator is an Equality Operator we will break    *     it down into left and right; in all other case there is only a    *     lhs.    *   - The ExprType is based on whether the Expr. refers to the Parent    *     Query table sources, refers to the SubQuery sources or both.    *   - We assume an unqualified Column refers to a SubQuery table source.    *     This is because we require Parent Column references to be qualified    *     within the SubQuery.    *   - If the lhs or rhs expr refers to both Parent and SubQuery sources,    *     we flag this as Unsupported.    *   - If the conjunct as a whole, only refers to the Parent Query sources,    *     we flag this as an Error.    *   - A conjunct is Correlated if the lhs refers to SubQuery sources and rhs    *     refers to Parent Query sources or the reverse.    *   - Say the lhs refers to SubQuery and rhs refers to Parent Query sources; the    *     other case is handled analogously.    *     - remove this conjunct from the SubQuery where clause.    *     - for the SubQuery expression(lhs) construct a new alias    *     - in the correlated predicate, replace the SubQuery    *       expression(lhs) with the alias AST.    *     - add this altered predicate to the Join predicate tracked by the    *       QBSubQuery object.    *     - add the alias AST to a list of subQueryJoinAliasExprs. This    *       list is used in the case of Outer Joins to add null check    *       predicates to the Outer Query's where clause.    *     - Add the SubQuery expression with the alias as a SelectItem to    *       the SubQuery's SelectList.    *     - In case this SubQuery contains aggregation expressions add this SubQuery    *       expression to its GroupBy; add it to the front of the GroupBy.    *   - If predicate is not correlated, let it remain in the SubQuery    *     where clause.    * Additional things for Having clause:    * - A correlation predicate may refer to an aggregation expression.    * - This introduces 2 twists to the rewrite:    *   a. When analyzing equality predicates we need to analyze each side    *      to see if it is an aggregation expression from the Outer Query.    *      So for e.g. this is a valid correlation predicate:    *         R2.x = min(R1.y)    *      Where R1 is an outer table reference, and R2 is a SubQuery table reference.    *   b. When hoisting the correlation predicate to a join predicate, we need to    *      rewrite it to be in the form the Join code allows: so the predicte needs    *      to contain a qualified column references.    *      We handle this by generating a new name for the aggregation expression,    *      like R1._gby_sq_col_1 and adding this mapping to the Outer Query's    *      Row Resolver. Then we construct a joining predicate using this new    *      name; so in our e.g. the condition would be: R2.x = R1._gby_sq_col_1    */
specifier|private
name|void
name|rewrite
parameter_list|(
name|RowResolver
name|parentQueryRR
parameter_list|,
name|boolean
name|forHavingClause
parameter_list|,
name|String
name|outerQueryAlias
parameter_list|)
throws|throws
name|SemanticException
block|{
name|ASTNode
name|selectClause
init|=
operator|(
name|ASTNode
operator|)
name|subQueryAST
operator|.
name|getChild
argument_list|(
literal|1
argument_list|)
operator|.
name|getChild
argument_list|(
literal|1
argument_list|)
decl_stmt|;
name|ASTNode
name|whereClause
init|=
name|SubQueryUtils
operator|.
name|subQueryWhere
argument_list|(
name|subQueryAST
argument_list|)
decl_stmt|;
if|if
condition|(
name|whereClause
operator|==
literal|null
condition|)
block|{
return|return;
block|}
name|ASTNode
name|searchCond
init|=
operator|(
name|ASTNode
operator|)
name|whereClause
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|ASTNode
argument_list|>
name|conjuncts
init|=
operator|new
name|ArrayList
argument_list|<
name|ASTNode
argument_list|>
argument_list|()
decl_stmt|;
name|SubQueryUtils
operator|.
name|extractConjuncts
argument_list|(
name|searchCond
argument_list|,
name|conjuncts
argument_list|)
expr_stmt|;
name|ConjunctAnalyzer
name|conjunctAnalyzer
init|=
operator|new
name|ConjunctAnalyzer
argument_list|(
name|parentQueryRR
argument_list|,
name|forHavingClause
argument_list|,
name|outerQueryAlias
argument_list|)
decl_stmt|;
name|ASTNode
name|sqNewSearchCond
init|=
literal|null
decl_stmt|;
for|for
control|(
name|ASTNode
name|conjunctAST
range|:
name|conjuncts
control|)
block|{
name|Conjunct
name|conjunct
init|=
name|conjunctAnalyzer
operator|.
name|analyzeConjunct
argument_list|(
name|conjunctAST
argument_list|)
decl_stmt|;
comment|/*        *  Restriction.11.m :: A SubQuery predicate that refers to an Outer        *  Query column must be a valid Join predicate.        */
if|if
condition|(
name|conjunct
operator|.
name|eitherSideRefersBoth
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|UNSUPPORTED_SUBQUERY_EXPRESSION
operator|.
name|getMsg
argument_list|(
name|conjunctAST
argument_list|,
literal|"SubQuery expression refers to both Parent and SubQuery expressions and "
operator|+
literal|"is not a valid join condition."
argument_list|)
argument_list|)
throw|;
block|}
comment|/*        * Check.12.h :: SubQuery predicates cannot only refer to Outer Query columns.        */
if|if
condition|(
name|conjunct
operator|.
name|refersOuterOnly
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|UNSUPPORTED_SUBQUERY_EXPRESSION
operator|.
name|getMsg
argument_list|(
name|conjunctAST
argument_list|,
literal|"SubQuery expression refers to Outer query expressions only."
argument_list|)
argument_list|)
throw|;
block|}
if|if
condition|(
name|conjunct
operator|.
name|isCorrelated
argument_list|()
condition|)
block|{
name|hasCorrelation
operator|=
literal|true
expr_stmt|;
name|subQueryJoinAliasExprs
operator|=
operator|new
name|ArrayList
argument_list|<
name|ASTNode
argument_list|>
argument_list|()
expr_stmt|;
name|String
name|exprAlias
init|=
name|getNextCorrExprAlias
argument_list|()
decl_stmt|;
name|ASTNode
name|sqExprAlias
init|=
name|SubQueryUtils
operator|.
name|createAliasAST
argument_list|(
name|exprAlias
argument_list|)
decl_stmt|;
name|ASTNode
name|sqExprForCorr
init|=
name|SubQueryUtils
operator|.
name|createColRefAST
argument_list|(
name|alias
argument_list|,
name|exprAlias
argument_list|)
decl_stmt|;
name|boolean
name|corrCondLeftIsRewritten
init|=
literal|false
decl_stmt|;
name|boolean
name|corrCondRightIsRewritten
init|=
literal|false
decl_stmt|;
if|if
condition|(
name|conjunct
operator|.
name|getLeftExprType
argument_list|()
operator|.
name|refersSubQuery
argument_list|()
condition|)
block|{
name|corrCondLeftIsRewritten
operator|=
literal|true
expr_stmt|;
if|if
condition|(
name|forHavingClause
operator|&&
name|conjunct
operator|.
name|getRightOuterColInfo
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|corrCondRightIsRewritten
operator|=
literal|true
expr_stmt|;
name|rewriteCorrConjunctForHaving
argument_list|(
name|conjunctAST
argument_list|,
literal|false
argument_list|,
name|outerQueryAlias
argument_list|,
name|parentQueryRR
argument_list|,
name|conjunct
operator|.
name|getRightOuterColInfo
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|ASTNode
name|joinPredciate
init|=
name|SubQueryUtils
operator|.
name|alterCorrelatedPredicate
argument_list|(
name|conjunctAST
argument_list|,
name|sqExprForCorr
argument_list|,
literal|true
argument_list|)
decl_stmt|;
name|joinConditionAST
operator|=
name|SubQueryUtils
operator|.
name|andAST
argument_list|(
name|joinConditionAST
argument_list|,
name|joinPredciate
argument_list|)
expr_stmt|;
name|subQueryJoinAliasExprs
operator|.
name|add
argument_list|(
name|sqExprForCorr
argument_list|)
expr_stmt|;
name|ASTNode
name|selExpr
init|=
name|SubQueryUtils
operator|.
name|createSelectItem
argument_list|(
name|conjunct
operator|.
name|getLeftExpr
argument_list|()
argument_list|,
name|sqExprAlias
argument_list|)
decl_stmt|;
name|selectClause
operator|.
name|addChild
argument_list|(
name|selExpr
argument_list|)
expr_stmt|;
name|subQueryDiagnostic
operator|.
name|addSelectClauseRewrite
argument_list|(
name|conjunct
operator|.
name|getLeftExpr
argument_list|()
argument_list|,
name|exprAlias
argument_list|)
expr_stmt|;
name|numOfCorrelationExprsAddedToSQSelect
operator|++
expr_stmt|;
if|if
condition|(
name|containsAggregationExprs
condition|)
block|{
name|ASTNode
name|gBy
init|=
name|getSubQueryGroupByAST
argument_list|()
decl_stmt|;
name|SubQueryUtils
operator|.
name|addGroupExpressionToFront
argument_list|(
name|gBy
argument_list|,
name|conjunct
operator|.
name|getLeftExpr
argument_list|()
argument_list|)
expr_stmt|;
name|subQueryDiagnostic
operator|.
name|addGByClauseRewrite
argument_list|(
name|conjunct
operator|.
name|getLeftExpr
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|notInCheck
operator|!=
literal|null
condition|)
block|{
name|notInCheck
operator|.
name|addCorrExpr
argument_list|(
operator|(
name|ASTNode
operator|)
name|conjunctAST
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|subQueryDiagnostic
operator|.
name|addJoinCondition
argument_list|(
name|conjunctAST
argument_list|,
name|corrCondLeftIsRewritten
argument_list|,
name|corrCondRightIsRewritten
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|corrCondRightIsRewritten
operator|=
literal|true
expr_stmt|;
if|if
condition|(
name|forHavingClause
operator|&&
name|conjunct
operator|.
name|getLeftOuterColInfo
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|corrCondLeftIsRewritten
operator|=
literal|true
expr_stmt|;
name|rewriteCorrConjunctForHaving
argument_list|(
name|conjunctAST
argument_list|,
literal|true
argument_list|,
name|outerQueryAlias
argument_list|,
name|parentQueryRR
argument_list|,
name|conjunct
operator|.
name|getLeftOuterColInfo
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|ASTNode
name|joinPredciate
init|=
name|SubQueryUtils
operator|.
name|alterCorrelatedPredicate
argument_list|(
name|conjunctAST
argument_list|,
name|sqExprForCorr
argument_list|,
literal|false
argument_list|)
decl_stmt|;
name|joinConditionAST
operator|=
name|SubQueryUtils
operator|.
name|andAST
argument_list|(
name|joinConditionAST
argument_list|,
name|joinPredciate
argument_list|)
expr_stmt|;
name|subQueryJoinAliasExprs
operator|.
name|add
argument_list|(
name|sqExprForCorr
argument_list|)
expr_stmt|;
name|ASTNode
name|selExpr
init|=
name|SubQueryUtils
operator|.
name|createSelectItem
argument_list|(
name|conjunct
operator|.
name|getRightExpr
argument_list|()
argument_list|,
name|sqExprAlias
argument_list|)
decl_stmt|;
name|selectClause
operator|.
name|addChild
argument_list|(
name|selExpr
argument_list|)
expr_stmt|;
name|subQueryDiagnostic
operator|.
name|addSelectClauseRewrite
argument_list|(
name|conjunct
operator|.
name|getRightExpr
argument_list|()
argument_list|,
name|exprAlias
argument_list|)
expr_stmt|;
name|numOfCorrelationExprsAddedToSQSelect
operator|++
expr_stmt|;
if|if
condition|(
name|containsAggregationExprs
condition|)
block|{
name|ASTNode
name|gBy
init|=
name|getSubQueryGroupByAST
argument_list|()
decl_stmt|;
name|SubQueryUtils
operator|.
name|addGroupExpressionToFront
argument_list|(
name|gBy
argument_list|,
name|conjunct
operator|.
name|getRightExpr
argument_list|()
argument_list|)
expr_stmt|;
name|subQueryDiagnostic
operator|.
name|addGByClauseRewrite
argument_list|(
name|conjunct
operator|.
name|getRightExpr
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|notInCheck
operator|!=
literal|null
condition|)
block|{
name|notInCheck
operator|.
name|addCorrExpr
argument_list|(
operator|(
name|ASTNode
operator|)
name|conjunctAST
operator|.
name|getChild
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|subQueryDiagnostic
operator|.
name|addJoinCondition
argument_list|(
name|conjunctAST
argument_list|,
name|corrCondLeftIsRewritten
argument_list|,
name|corrCondRightIsRewritten
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|sqNewSearchCond
operator|=
name|SubQueryUtils
operator|.
name|andAST
argument_list|(
name|sqNewSearchCond
argument_list|,
name|conjunctAST
argument_list|)
expr_stmt|;
name|subQueryDiagnostic
operator|.
name|addWhereClauseRewrite
argument_list|(
name|conjunctAST
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|sqNewSearchCond
operator|!=
name|searchCond
condition|)
block|{
if|if
condition|(
name|sqNewSearchCond
operator|==
literal|null
condition|)
block|{
comment|/*          * for now just adding a true condition(1=1) to where clause.          * Can remove the where clause from the AST; requires moving all subsequent children          * left.          */
name|sqNewSearchCond
operator|=
name|SubQueryUtils
operator|.
name|constructTrueCond
argument_list|()
expr_stmt|;
name|subQueryDiagnostic
operator|.
name|addWhereClauseRewrite
argument_list|(
literal|"1 = 1"
argument_list|)
expr_stmt|;
block|}
name|whereClause
operator|.
name|setChild
argument_list|(
literal|0
argument_list|,
name|sqNewSearchCond
argument_list|)
expr_stmt|;
block|}
block|}
comment|/*    * called if the SubQuery is Agg and Correlated.    * if SQ doesn't have a GroupBy, it is added to the SQ AST.    */
specifier|private
name|ASTNode
name|getSubQueryGroupByAST
parameter_list|()
block|{
name|ASTNode
name|groupBy
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|subQueryAST
operator|.
name|getChild
argument_list|(
literal|1
argument_list|)
operator|.
name|getChildCount
argument_list|()
operator|>
literal|3
operator|&&
name|subQueryAST
operator|.
name|getChild
argument_list|(
literal|1
argument_list|)
operator|.
name|getChild
argument_list|(
literal|3
argument_list|)
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_GROUPBY
condition|)
block|{
name|groupBy
operator|=
operator|(
name|ASTNode
operator|)
name|subQueryAST
operator|.
name|getChild
argument_list|(
literal|1
argument_list|)
operator|.
name|getChild
argument_list|(
literal|3
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|groupBy
operator|!=
literal|null
condition|)
block|{
return|return
name|groupBy
return|;
block|}
name|groupBy
operator|=
name|SubQueryUtils
operator|.
name|buildGroupBy
argument_list|()
expr_stmt|;
name|groupbyAddedToSQ
operator|=
literal|true
expr_stmt|;
name|List
argument_list|<
name|ASTNode
argument_list|>
name|newChildren
init|=
operator|new
name|ArrayList
argument_list|<
name|ASTNode
argument_list|>
argument_list|()
decl_stmt|;
name|newChildren
operator|.
name|add
argument_list|(
name|groupBy
argument_list|)
expr_stmt|;
if|if
condition|(
name|subQueryAST
operator|.
name|getChildCount
argument_list|()
operator|>
literal|3
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
name|subQueryAST
operator|.
name|getChildCount
argument_list|()
operator|-
literal|1
init|;
name|i
operator|>=
literal|3
condition|;
name|i
operator|--
control|)
block|{
name|ASTNode
name|child
init|=
operator|(
name|ASTNode
operator|)
name|subQueryAST
operator|.
name|getChild
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|newChildren
operator|.
name|add
argument_list|(
name|child
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
name|ASTNode
name|child
range|:
name|newChildren
control|)
block|{
name|subQueryAST
operator|.
name|addChild
argument_list|(
name|child
argument_list|)
expr_stmt|;
block|}
name|subQueryDiagnostic
operator|.
name|setAddGroupByClause
argument_list|()
expr_stmt|;
return|return
name|groupBy
return|;
block|}
specifier|public
name|String
name|getOuterQueryId
parameter_list|()
block|{
return|return
name|outerQueryId
return|;
block|}
specifier|public
name|JoinType
name|getJoinType
parameter_list|()
block|{
return|return
name|joinType
return|;
block|}
specifier|public
name|String
name|getAlias
parameter_list|()
block|{
return|return
name|alias
return|;
block|}
specifier|public
name|ASTNode
name|getJoinConditionAST
parameter_list|()
block|{
return|return
name|joinConditionAST
return|;
block|}
specifier|public
name|int
name|getNumOfCorrelationExprsAddedToSQSelect
parameter_list|()
block|{
return|return
name|numOfCorrelationExprsAddedToSQSelect
return|;
block|}
specifier|public
name|QBSubQueryRewrite
name|getDiagnostic
parameter_list|()
block|{
return|return
name|subQueryDiagnostic
return|;
block|}
specifier|public
name|QBSubQuery
name|getSubQuery
parameter_list|()
block|{
return|return
name|this
return|;
block|}
name|NotInCheck
name|getNotInCheck
parameter_list|()
block|{
return|return
name|notInCheck
return|;
block|}
specifier|private
name|void
name|rewriteCorrConjunctForHaving
parameter_list|(
name|ASTNode
name|conjunctASTNode
parameter_list|,
name|boolean
name|refersLeft
parameter_list|,
name|String
name|outerQueryAlias
parameter_list|,
name|RowResolver
name|outerQueryRR
parameter_list|,
name|ColumnInfo
name|outerQueryCol
parameter_list|)
block|{
name|String
name|newColAlias
init|=
literal|"_gby_sq_col_"
operator|+
name|numOuterCorrExprsForHaving
operator|++
decl_stmt|;
name|ASTNode
name|outerExprForCorr
init|=
name|SubQueryUtils
operator|.
name|createColRefAST
argument_list|(
name|outerQueryAlias
argument_list|,
name|newColAlias
argument_list|)
decl_stmt|;
if|if
condition|(
name|refersLeft
condition|)
block|{
name|conjunctASTNode
operator|.
name|setChild
argument_list|(
literal|0
argument_list|,
name|outerExprForCorr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|conjunctASTNode
operator|.
name|setChild
argument_list|(
literal|1
argument_list|,
name|outerExprForCorr
argument_list|)
expr_stmt|;
block|}
name|outerQueryRR
operator|.
name|put
argument_list|(
name|outerQueryAlias
argument_list|,
name|newColAlias
argument_list|,
name|outerQueryCol
argument_list|)
expr_stmt|;
block|}
block|}
end_class

end_unit

