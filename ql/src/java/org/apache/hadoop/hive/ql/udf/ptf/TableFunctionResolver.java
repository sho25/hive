begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|udf
operator|.
name|ptf
package|;
end_package

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|conf
operator|.
name|HiveConf
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|ExprNodeEvaluator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|FunctionRegistry
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|metadata
operator|.
name|HiveException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|parse
operator|.
name|SemanticException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|ExprNodeDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|PTFDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|PTFDesc
operator|.
name|PartitionedTableFunctionDef
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|udf
operator|.
name|generic
operator|.
name|GenericUDAFResolver
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|objectinspector
operator|.
name|StructObjectInspector
import|;
end_import

begin_comment
comment|/**  * Based on Hive {@link GenericUDAFResolver}. Break up the responsibility of the  * old AbstractTableFunction class into a Resolver and Evaluator.  * The Resolver is responsible for:  *<ol>  *<li> setting up the {@link tableFunctionEvaluator}  *<li> Setting up the The raw and output ObjectInspectors of the Evaluator.  *<li> The Evaluator also holds onto the {@link TableFunctionDef}. This provides information  * about the arguments to the function, the shape of the Input partition and the Partitioning details.  *</ol>  * The Resolver for a function is obtained from the {@link FunctionRegistry}. The Resolver is initialized  * by the following 4 step process:  *<ol>  *<li> The initialize method is called; which is passed the {@link PTFDesc} and the {@link TableFunctionDef}.  *<li> The resolver is then asked to setup the Raw ObjectInspector. This is only required if the Function reshapes  * the raw input.  *<li> Once the Resolver has had a chance to compute the shape of the Raw Input that is fed to the partitioning  * machinery; the translator sets up the partitioning details on the tableFuncDef.  *<li> finally the resolver is asked to setup the output ObjectInspector.  *</ol>  */
end_comment

begin_class
annotation|@
name|SuppressWarnings
argument_list|(
literal|"deprecation"
argument_list|)
specifier|public
specifier|abstract
class|class
name|TableFunctionResolver
block|{
name|TableFunctionEvaluator
name|evaluator
decl_stmt|;
name|PTFDesc
name|ptfDesc
decl_stmt|;
comment|/*    * - called during translation.    * - invokes createEvaluator which must be implemented by a subclass    * - sets up the evaluator with references to the TableDef, PartitionClass, PartitonMemsize and    *   the transformsRawInput boolean.    */
specifier|public
name|void
name|initialize
parameter_list|(
name|HiveConf
name|cfg
parameter_list|,
name|PTFDesc
name|ptfDesc
parameter_list|,
name|PartitionedTableFunctionDef
name|tDef
parameter_list|)
throws|throws
name|SemanticException
block|{
name|this
operator|.
name|ptfDesc
operator|=
name|ptfDesc
expr_stmt|;
name|evaluator
operator|=
name|createEvaluator
argument_list|(
name|ptfDesc
argument_list|,
name|tDef
argument_list|)
expr_stmt|;
name|evaluator
operator|.
name|setTransformsRawInput
argument_list|(
name|transformsRawInput
argument_list|()
argument_list|)
expr_stmt|;
name|evaluator
operator|.
name|setTableDef
argument_list|(
name|tDef
argument_list|)
expr_stmt|;
name|evaluator
operator|.
name|setQueryDef
argument_list|(
name|ptfDesc
argument_list|)
expr_stmt|;
block|}
comment|/*    * called during deserialization of a QueryDef during runtime.    */
specifier|public
name|void
name|initialize
parameter_list|(
name|PTFDesc
name|ptfDesc
parameter_list|,
name|PartitionedTableFunctionDef
name|tDef
parameter_list|,
name|TableFunctionEvaluator
name|evaluator
parameter_list|)
throws|throws
name|HiveException
block|{
name|this
operator|.
name|evaluator
operator|=
name|evaluator
expr_stmt|;
name|this
operator|.
name|ptfDesc
operator|=
name|ptfDesc
expr_stmt|;
name|evaluator
operator|.
name|setTableDef
argument_list|(
name|tDef
argument_list|)
expr_stmt|;
name|evaluator
operator|.
name|setQueryDef
argument_list|(
name|ptfDesc
argument_list|)
expr_stmt|;
block|}
specifier|public
name|TableFunctionEvaluator
name|getEvaluator
parameter_list|()
block|{
return|return
name|evaluator
return|;
block|}
comment|/*    * - a subclass must provide this method.    * - this method is invoked during translation and also when the Operator is initialized during runtime.    * - a subclass must use this call to setup the shape of its output.    * - subsequent to this call, a call to getOutputOI call on the {@link TableFunctionEvaluator} must return the OI    * of the output of this function.    */
specifier|public
specifier|abstract
name|void
name|setupOutputOI
parameter_list|()
throws|throws
name|SemanticException
function_decl|;
comment|/*    * A PTF Function must provide the 'external' names of the columns in its Output.    *    */
specifier|public
specifier|abstract
name|ArrayList
argument_list|<
name|String
argument_list|>
name|getOutputColumnNames
parameter_list|()
throws|throws
name|SemanticException
function_decl|;
comment|/**    * This method is invoked during runtime(during deserialization of theQueryDef).    * At this point the TableFunction can assume that the {@link ExprNodeDesc Expression Nodes}    * exist for all the Def (ArgDef, ColumnDef, WindowDef..). It is the responsibility of    * the TableFunction to construct the {@link ExprNodeEvaluator evaluators} and setup the OI.    *    * @param tblFuncDef    * @param ptfDesc    * @throws HiveException    */
specifier|public
specifier|abstract
name|void
name|initializeOutputOI
parameter_list|()
throws|throws
name|HiveException
function_decl|;
comment|/*    * - Called on functions that transform the raw input.    * - this method is invoked during translation and also when the Operator is initialized during runtime.    * - a subclass must use this call to setup the shape of the raw input, that is fed to the partitioning mechanics.    * - subsequent to this call, a call to getRawInputOI call on the {@link TableFunctionEvaluator} must return the OI    *   of the output of this function.    */
specifier|public
name|void
name|setupRawInputOI
parameter_list|()
throws|throws
name|SemanticException
block|{
if|if
condition|(
operator|!
name|transformsRawInput
argument_list|()
condition|)
block|{
return|return;
block|}
throw|throw
operator|new
name|SemanticException
argument_list|(
literal|"Function has map phase, must extend setupMapOI"
argument_list|)
throw|;
block|}
comment|/*    * A PTF Function must provide the 'external' names of the columns in the transformed Raw Input.    *    */
specifier|public
name|ArrayList
argument_list|<
name|String
argument_list|>
name|getRawInputColumnNames
parameter_list|()
throws|throws
name|SemanticException
block|{
if|if
condition|(
operator|!
name|transformsRawInput
argument_list|()
condition|)
block|{
return|return
literal|null
return|;
block|}
throw|throw
operator|new
name|SemanticException
argument_list|(
literal|"Function transforms Raw Input; must extend getRawColumnInputNames"
argument_list|)
throw|;
block|}
comment|/*    * Same responsibility as initializeOI, but for the RawInput.    */
specifier|public
name|void
name|initializeRawInputOI
parameter_list|()
throws|throws
name|HiveException
block|{
if|if
condition|(
operator|!
name|transformsRawInput
argument_list|()
condition|)
block|{
return|return;
block|}
throw|throw
operator|new
name|HiveException
argument_list|(
literal|"Function has map phase, must extend initializeRawInputOI"
argument_list|)
throw|;
block|}
comment|/*    * callback method used by subclasses to set the RawInputOI on the Evaluator.    */
specifier|protected
name|void
name|setRawInputOI
parameter_list|(
name|StructObjectInspector
name|rawInputOI
parameter_list|)
block|{
name|evaluator
operator|.
name|setRawInputOI
argument_list|(
name|rawInputOI
argument_list|)
expr_stmt|;
block|}
comment|/*    * callback method used by subclasses to set the OutputOI on the Evaluator.    */
specifier|protected
name|void
name|setOutputOI
parameter_list|(
name|StructObjectInspector
name|outputOI
parameter_list|)
block|{
name|evaluator
operator|.
name|setOutputOI
argument_list|(
name|outputOI
argument_list|)
expr_stmt|;
block|}
specifier|public
name|PTFDesc
name|getPtfDesc
parameter_list|()
block|{
return|return
name|ptfDesc
return|;
block|}
comment|/*    * This is used during translation to decide if the internalName -> alias mapping from the Input to the PTF is carried    * forward when building the Output RR for this PTF.    * This is used by internal PTFs: NOOP, WindowingTableFunction to make names in its input available in the Output.    * In general this should be false; and the names used for the Output Columns must be provided by the PTF Writer in the    * function getOutputNames.    */
specifier|public
name|boolean
name|carryForwardNames
parameter_list|()
block|{
return|return
literal|false
return|;
block|}
comment|/*    * a subclass must indicate whether it will transform the raw input before it is fed through the    * partitioning mechanics.    */
specifier|public
specifier|abstract
name|boolean
name|transformsRawInput
parameter_list|()
function_decl|;
comment|/*    * a subclass must provide the {@link TableFunctionEvaluator} instance.    */
specifier|protected
specifier|abstract
name|TableFunctionEvaluator
name|createEvaluator
parameter_list|(
name|PTFDesc
name|ptfDesc
parameter_list|,
name|PartitionedTableFunctionDef
name|tDef
parameter_list|)
function_decl|;
block|}
end_class

end_unit

