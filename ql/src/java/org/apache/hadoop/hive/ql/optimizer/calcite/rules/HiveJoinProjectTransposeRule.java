begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|optimizer
operator|.
name|calcite
operator|.
name|rules
package|;
end_package

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|plan
operator|.
name|RelOptRuleCall
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|plan
operator|.
name|RelOptRuleOperand
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|plan
operator|.
name|RelOptUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|RelNode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|core
operator|.
name|Join
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|core
operator|.
name|JoinRelType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|core
operator|.
name|Project
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|core
operator|.
name|RelFactories
operator|.
name|ProjectFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|rules
operator|.
name|JoinProjectTransposeRule
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|type
operator|.
name|RelDataType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rel
operator|.
name|type
operator|.
name|RelDataTypeField
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexBuilder
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexLocalRef
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexNode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexProgram
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|rex
operator|.
name|RexProgramBuilder
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|calcite
operator|.
name|util
operator|.
name|Pair
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|optimizer
operator|.
name|calcite
operator|.
name|reloperators
operator|.
name|HiveJoin
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|optimizer
operator|.
name|calcite
operator|.
name|reloperators
operator|.
name|HiveProject
import|;
end_import

begin_class
specifier|public
class|class
name|HiveJoinProjectTransposeRule
extends|extends
name|JoinProjectTransposeRule
block|{
specifier|public
specifier|static
specifier|final
name|HiveJoinProjectTransposeRule
name|BOTH_PROJECT
init|=
operator|new
name|HiveJoinProjectTransposeRule
argument_list|(
name|operand
argument_list|(
name|HiveJoin
operator|.
name|class
argument_list|,
name|operand
argument_list|(
name|HiveProject
operator|.
name|class
argument_list|,
name|any
argument_list|()
argument_list|)
argument_list|,
name|operand
argument_list|(
name|HiveProject
operator|.
name|class
argument_list|,
name|any
argument_list|()
argument_list|)
argument_list|)
argument_list|,
literal|"JoinProjectTransposeRule(Project-Project)"
argument_list|,
name|HiveProject
operator|.
name|DEFAULT_PROJECT_FACTORY
argument_list|)
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|HiveJoinProjectTransposeRule
name|LEFT_PROJECT
init|=
operator|new
name|HiveJoinProjectTransposeRule
argument_list|(
name|operand
argument_list|(
name|HiveJoin
operator|.
name|class
argument_list|,
name|some
argument_list|(
name|operand
argument_list|(
name|HiveProject
operator|.
name|class
argument_list|,
name|any
argument_list|()
argument_list|)
argument_list|)
argument_list|)
argument_list|,
literal|"JoinProjectTransposeRule(Project-Other)"
argument_list|,
name|HiveProject
operator|.
name|DEFAULT_PROJECT_FACTORY
argument_list|)
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|HiveJoinProjectTransposeRule
name|RIGHT_PROJECT
init|=
operator|new
name|HiveJoinProjectTransposeRule
argument_list|(
name|operand
argument_list|(
name|HiveJoin
operator|.
name|class
argument_list|,
name|operand
argument_list|(
name|RelNode
operator|.
name|class
argument_list|,
name|any
argument_list|()
argument_list|)
argument_list|,
name|operand
argument_list|(
name|HiveProject
operator|.
name|class
argument_list|,
name|any
argument_list|()
argument_list|)
argument_list|)
argument_list|,
literal|"JoinProjectTransposeRule(Other-Project)"
argument_list|,
name|HiveProject
operator|.
name|DEFAULT_PROJECT_FACTORY
argument_list|)
decl_stmt|;
specifier|private
specifier|final
name|ProjectFactory
name|projectFactory
decl_stmt|;
specifier|private
name|HiveJoinProjectTransposeRule
parameter_list|(
name|RelOptRuleOperand
name|operand
parameter_list|,
name|String
name|description
parameter_list|,
name|ProjectFactory
name|pFactory
parameter_list|)
block|{
name|super
argument_list|(
name|operand
argument_list|,
name|description
argument_list|,
name|pFactory
argument_list|)
expr_stmt|;
name|this
operator|.
name|projectFactory
operator|=
name|pFactory
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|onMatch
parameter_list|(
name|RelOptRuleCall
name|call
parameter_list|)
block|{
name|Join
name|joinRel
init|=
name|call
operator|.
name|rel
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|JoinRelType
name|joinType
init|=
name|joinRel
operator|.
name|getJoinType
argument_list|()
decl_stmt|;
name|Project
name|leftProj
decl_stmt|;
name|Project
name|rightProj
decl_stmt|;
name|RelNode
name|leftJoinChild
decl_stmt|;
name|RelNode
name|rightJoinChild
decl_stmt|;
comment|// see if at least one input's projection doesn't generate nulls
if|if
condition|(
name|hasLeftChild
argument_list|(
name|call
argument_list|)
condition|)
block|{
name|leftProj
operator|=
name|call
operator|.
name|rel
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|leftJoinChild
operator|=
name|getProjectChild
argument_list|(
name|call
argument_list|,
name|leftProj
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|leftProj
operator|=
literal|null
expr_stmt|;
name|leftJoinChild
operator|=
name|call
operator|.
name|rel
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|hasRightChild
argument_list|(
name|call
argument_list|)
condition|)
block|{
name|rightProj
operator|=
name|getRightChild
argument_list|(
name|call
argument_list|)
expr_stmt|;
name|rightJoinChild
operator|=
name|getProjectChild
argument_list|(
name|call
argument_list|,
name|rightProj
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|rightProj
operator|=
literal|null
expr_stmt|;
name|rightJoinChild
operator|=
name|joinRel
operator|.
name|getRight
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|leftProj
operator|==
literal|null
operator|)
operator|&&
operator|(
name|rightProj
operator|==
literal|null
operator|)
condition|)
block|{
return|return;
block|}
comment|// Construct two RexPrograms and combine them.  The bottom program
comment|// is a join of the projection expressions from the left and/or
comment|// right projects that feed into the join.  The top program contains
comment|// the join condition.
comment|// Create a row type representing a concatenation of the inputs
comment|// underneath the projects that feed into the join.  This is the input
comment|// into the bottom RexProgram.  Note that the join type is an inner
comment|// join because the inputs haven't actually been joined yet.
name|RelDataType
name|joinChildrenRowType
init|=
name|Join
operator|.
name|deriveJoinRowType
argument_list|(
name|leftJoinChild
operator|.
name|getRowType
argument_list|()
argument_list|,
name|rightJoinChild
operator|.
name|getRowType
argument_list|()
argument_list|,
name|JoinRelType
operator|.
name|INNER
argument_list|,
name|joinRel
operator|.
name|getCluster
argument_list|()
operator|.
name|getTypeFactory
argument_list|()
argument_list|,
literal|null
argument_list|,
name|Collections
operator|.
expr|<
name|RelDataTypeField
operator|>
name|emptyList
argument_list|()
argument_list|)
decl_stmt|;
comment|// Create projection expressions, combining the projection expressions
comment|// from the projects that feed into the join.  For the RHS projection
comment|// expressions, shift them to the right by the number of fields on
comment|// the LHS.  If the join input was not a projection, simply create
comment|// references to the inputs.
name|int
name|nProjExprs
init|=
name|joinRel
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldCount
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|Pair
argument_list|<
name|RexNode
argument_list|,
name|String
argument_list|>
argument_list|>
name|projects
init|=
operator|new
name|ArrayList
argument_list|<
name|Pair
argument_list|<
name|RexNode
argument_list|,
name|String
argument_list|>
argument_list|>
argument_list|()
decl_stmt|;
name|RexBuilder
name|rexBuilder
init|=
name|joinRel
operator|.
name|getCluster
argument_list|()
operator|.
name|getRexBuilder
argument_list|()
decl_stmt|;
name|createProjectExprs
argument_list|(
name|leftProj
argument_list|,
name|leftJoinChild
argument_list|,
literal|0
argument_list|,
name|rexBuilder
argument_list|,
name|joinChildrenRowType
operator|.
name|getFieldList
argument_list|()
argument_list|,
name|projects
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|RelDataTypeField
argument_list|>
name|leftFields
init|=
name|leftJoinChild
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldList
argument_list|()
decl_stmt|;
name|int
name|nFieldsLeft
init|=
name|leftFields
operator|.
name|size
argument_list|()
decl_stmt|;
name|createProjectExprs
argument_list|(
name|rightProj
argument_list|,
name|rightJoinChild
argument_list|,
name|nFieldsLeft
argument_list|,
name|rexBuilder
argument_list|,
name|joinChildrenRowType
operator|.
name|getFieldList
argument_list|()
argument_list|,
name|projects
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|RelDataType
argument_list|>
name|projTypes
init|=
operator|new
name|ArrayList
argument_list|<
name|RelDataType
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|nProjExprs
condition|;
name|i
operator|++
control|)
block|{
name|projTypes
operator|.
name|add
argument_list|(
name|projects
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|left
operator|.
name|getType
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|RelDataType
name|projRowType
init|=
name|rexBuilder
operator|.
name|getTypeFactory
argument_list|()
operator|.
name|createStructType
argument_list|(
name|projTypes
argument_list|,
name|Pair
operator|.
name|right
argument_list|(
name|projects
argument_list|)
argument_list|)
decl_stmt|;
comment|// create the RexPrograms and merge them
name|RexProgram
name|bottomProgram
init|=
name|RexProgram
operator|.
name|create
argument_list|(
name|joinChildrenRowType
argument_list|,
name|Pair
operator|.
name|left
argument_list|(
name|projects
argument_list|)
argument_list|,
literal|null
argument_list|,
name|projRowType
argument_list|,
name|rexBuilder
argument_list|)
decl_stmt|;
name|RexProgramBuilder
name|topProgramBuilder
init|=
operator|new
name|RexProgramBuilder
argument_list|(
name|projRowType
argument_list|,
name|rexBuilder
argument_list|)
decl_stmt|;
name|topProgramBuilder
operator|.
name|addIdentity
argument_list|()
expr_stmt|;
name|topProgramBuilder
operator|.
name|addCondition
argument_list|(
name|joinRel
operator|.
name|getCondition
argument_list|()
argument_list|)
expr_stmt|;
name|RexProgram
name|topProgram
init|=
name|topProgramBuilder
operator|.
name|getProgram
argument_list|()
decl_stmt|;
name|RexProgram
name|mergedProgram
init|=
name|RexProgramBuilder
operator|.
name|mergePrograms
argument_list|(
name|topProgram
argument_list|,
name|bottomProgram
argument_list|,
name|rexBuilder
argument_list|)
decl_stmt|;
comment|// expand out the join condition and construct a new LogicalJoin that
comment|// directly references the join children without the intervening
comment|// ProjectRels
name|RexNode
name|newCondition
init|=
name|mergedProgram
operator|.
name|expandLocalRef
argument_list|(
name|mergedProgram
operator|.
name|getCondition
argument_list|()
argument_list|)
decl_stmt|;
name|Join
name|newJoinRel
init|=
name|joinRel
operator|.
name|copy
argument_list|(
name|joinRel
operator|.
name|getTraitSet
argument_list|()
argument_list|,
name|newCondition
argument_list|,
name|leftJoinChild
argument_list|,
name|rightJoinChild
argument_list|,
name|joinRel
operator|.
name|getJoinType
argument_list|()
argument_list|,
name|joinRel
operator|.
name|isSemiJoinDone
argument_list|()
argument_list|)
decl_stmt|;
comment|// expand out the new projection expressions; if the join is an
comment|// outer join, modify the expressions to reference the join output
name|List
argument_list|<
name|RexNode
argument_list|>
name|newProjExprs
init|=
operator|new
name|ArrayList
argument_list|<
name|RexNode
argument_list|>
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|RexLocalRef
argument_list|>
name|projList
init|=
name|mergedProgram
operator|.
name|getProjectList
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|RelDataTypeField
argument_list|>
name|newJoinFields
init|=
name|newJoinRel
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldList
argument_list|()
decl_stmt|;
name|int
name|nJoinFields
init|=
name|newJoinFields
operator|.
name|size
argument_list|()
decl_stmt|;
name|int
index|[]
name|adjustments
init|=
operator|new
name|int
index|[
name|nJoinFields
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|nProjExprs
condition|;
name|i
operator|++
control|)
block|{
name|RexNode
name|newExpr
init|=
name|mergedProgram
operator|.
name|expandLocalRef
argument_list|(
name|projList
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|joinType
operator|!=
name|JoinRelType
operator|.
name|INNER
condition|)
block|{
name|newExpr
operator|=
name|newExpr
operator|.
name|accept
argument_list|(
operator|new
name|RelOptUtil
operator|.
name|RexInputConverter
argument_list|(
name|rexBuilder
argument_list|,
name|joinChildrenRowType
operator|.
name|getFieldList
argument_list|()
argument_list|,
name|newJoinFields
argument_list|,
name|adjustments
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|newProjExprs
operator|.
name|add
argument_list|(
name|newExpr
argument_list|)
expr_stmt|;
block|}
comment|// finally, create the projection on top of the join
name|RelNode
name|newProjRel
init|=
name|projectFactory
operator|.
name|createProject
argument_list|(
name|newJoinRel
argument_list|,
name|newProjExprs
argument_list|,
name|joinRel
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldNames
argument_list|()
argument_list|)
decl_stmt|;
name|call
operator|.
name|transformTo
argument_list|(
name|newProjRel
argument_list|)
expr_stmt|;
block|}
comment|/**    * Creates projection expressions corresponding to one of the inputs into    * the join    *    * @param projRel            the projection input into the join (if it exists)    * @param joinChild          the child of the projection input (if there is a    *                           projection); otherwise, this is the join input    * @param adjustmentAmount   the amount the expressions need to be shifted by    * @param rexBuilder         rex builder    * @param joinChildrenFields concatenation of the fields from the left and    *                           right join inputs (once the projections have been    *                           removed)    * @param projects           Projection expressions&amp; names to be created    */
specifier|private
name|void
name|createProjectExprs
parameter_list|(
name|Project
name|projRel
parameter_list|,
name|RelNode
name|joinChild
parameter_list|,
name|int
name|adjustmentAmount
parameter_list|,
name|RexBuilder
name|rexBuilder
parameter_list|,
name|List
argument_list|<
name|RelDataTypeField
argument_list|>
name|joinChildrenFields
parameter_list|,
name|List
argument_list|<
name|Pair
argument_list|<
name|RexNode
argument_list|,
name|String
argument_list|>
argument_list|>
name|projects
parameter_list|)
block|{
name|List
argument_list|<
name|RelDataTypeField
argument_list|>
name|childFields
init|=
name|joinChild
operator|.
name|getRowType
argument_list|()
operator|.
name|getFieldList
argument_list|()
decl_stmt|;
if|if
condition|(
name|projRel
operator|!=
literal|null
condition|)
block|{
name|List
argument_list|<
name|Pair
argument_list|<
name|RexNode
argument_list|,
name|String
argument_list|>
argument_list|>
name|namedProjects
init|=
name|projRel
operator|.
name|getNamedProjects
argument_list|()
decl_stmt|;
name|int
name|nChildFields
init|=
name|childFields
operator|.
name|size
argument_list|()
decl_stmt|;
name|int
index|[]
name|adjustments
init|=
operator|new
name|int
index|[
name|nChildFields
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|nChildFields
condition|;
name|i
operator|++
control|)
block|{
name|adjustments
index|[
name|i
index|]
operator|=
name|adjustmentAmount
expr_stmt|;
block|}
for|for
control|(
name|Pair
argument_list|<
name|RexNode
argument_list|,
name|String
argument_list|>
name|pair
range|:
name|namedProjects
control|)
block|{
name|RexNode
name|e
init|=
name|pair
operator|.
name|left
decl_stmt|;
if|if
condition|(
name|adjustmentAmount
operator|!=
literal|0
condition|)
block|{
comment|// shift the references by the adjustment amount
name|e
operator|=
name|e
operator|.
name|accept
argument_list|(
operator|new
name|RelOptUtil
operator|.
name|RexInputConverter
argument_list|(
name|rexBuilder
argument_list|,
name|childFields
argument_list|,
name|joinChildrenFields
argument_list|,
name|adjustments
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|projects
operator|.
name|add
argument_list|(
name|Pair
operator|.
name|of
argument_list|(
name|e
argument_list|,
name|pair
operator|.
name|right
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// no projection; just create references to the inputs
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|childFields
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
specifier|final
name|RelDataTypeField
name|field
init|=
name|childFields
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|projects
operator|.
name|add
argument_list|(
name|Pair
operator|.
name|of
argument_list|(
operator|(
name|RexNode
operator|)
name|rexBuilder
operator|.
name|makeInputRef
argument_list|(
name|field
operator|.
name|getType
argument_list|()
argument_list|,
name|i
operator|+
name|adjustmentAmount
argument_list|)
argument_list|,
name|field
operator|.
name|getName
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_class

end_unit

