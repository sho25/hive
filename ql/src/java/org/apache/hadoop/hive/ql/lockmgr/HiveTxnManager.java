begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|lockmgr
package|;
end_package

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|common
operator|.
name|ValidTxnList
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|common
operator|.
name|ValidTxnWriteIdList
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|common
operator|.
name|ValidWriteIdList
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|metastore
operator|.
name|api
operator|.
name|CommitTxnRequest
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|metastore
operator|.
name|api
operator|.
name|LockResponse
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|metastore
operator|.
name|api
operator|.
name|TxnToWriteId
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|Context
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|Driver
operator|.
name|LockedDriverState
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|QueryPlan
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|metadata
operator|.
name|Hive
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|metadata
operator|.
name|HiveException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|LockDatabaseDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|LockTableDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|UnlockDatabaseDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|UnlockTableDesc
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_comment
comment|/**  * An interface that allows Hive to manage transactions.  All classes  * implementing this should extend {@link HiveTxnManagerImpl} rather than  * implementing this directly.  */
end_comment

begin_interface
specifier|public
interface|interface
name|HiveTxnManager
block|{
comment|/**    * Open a new transaction.    * @param ctx Context for this query    * @param user Hive user who is opening this transaction.    * @return The new transaction id    * @throws LockException if a transaction is already open.    */
name|long
name|openTxn
parameter_list|(
name|Context
name|ctx
parameter_list|,
name|String
name|user
parameter_list|)
throws|throws
name|LockException
function_decl|;
comment|/**    * Open a new transaction in target cluster.    * @param replPolicy Replication policy to uniquely identify the source cluster.    * @param srcTxnIds The ids of the transaction at the source cluster    * @param user The user who has fired the repl load command    * @return The new transaction id.    * @throws LockException in case of failure to start the transaction.    */
name|List
argument_list|<
name|Long
argument_list|>
name|replOpenTxn
parameter_list|(
name|String
name|replPolicy
parameter_list|,
name|List
argument_list|<
name|Long
argument_list|>
name|srcTxnIds
parameter_list|,
name|String
name|user
parameter_list|)
throws|throws
name|LockException
function_decl|;
comment|/**    * Commit the transaction in target cluster.    *    * @param rqst Commit transaction request having information related to commit txn and write events.    * @throws LockException in case of failure to commit the transaction.    */
name|void
name|replCommitTxn
parameter_list|(
name|CommitTxnRequest
name|rqst
parameter_list|)
throws|throws
name|LockException
function_decl|;
comment|/**    * Abort the transaction in target cluster.    * @param replPolicy Replication policy to uniquely identify the source cluster.    * @param srcTxnId The id of the transaction at the source cluster    * @throws LockException in case of failure to abort the transaction.    */
name|void
name|replRollbackTxn
parameter_list|(
name|String
name|replPolicy
parameter_list|,
name|long
name|srcTxnId
parameter_list|)
throws|throws
name|LockException
function_decl|;
comment|/**   * Replicate Table Write Ids state to mark aborted write ids and writeid high water mark.   * @param validWriteIdList Snapshot of writeid list when the table/partition is dumped.   * @param dbName Database name   * @param tableName Table which is written.   * @param partNames List of partitions being written.   * @throws LockException in case of failure.   */
name|void
name|replTableWriteIdState
parameter_list|(
name|String
name|validWriteIdList
parameter_list|,
name|String
name|dbName
parameter_list|,
name|String
name|tableName
parameter_list|,
name|List
argument_list|<
name|String
argument_list|>
name|partNames
parameter_list|)
throws|throws
name|LockException
function_decl|;
comment|/**    * Get the lock manager.  This must be used rather than instantiating an    * instance of the lock manager directly as the transaction manager will    * choose which lock manager to instantiate.    * @return the instance of the lock manager    * @throws LockException if there is an issue obtaining the lock manager.    */
name|HiveLockManager
name|getLockManager
parameter_list|()
throws|throws
name|LockException
function_decl|;
comment|/**    * Acquire all of the locks needed by a query.  If used with a query that    * requires transactions, this should be called after {@link #openTxn(Context, String)}.    * A list of acquired locks will be stored in the    * {@link org.apache.hadoop.hive.ql.Context} object and can be retrieved    * via {@link org.apache.hadoop.hive.ql.Context#getHiveLocks}.    *    * @param plan query plan    * @param ctx Context for this query    * @param username name of the user for this query    * @throws LockException if there is an error getting the locks.  Use {@link LockException#getCanonicalErrorMsg()}    * to get more info on how to handle the exception.    */
name|void
name|acquireLocks
parameter_list|(
name|QueryPlan
name|plan
parameter_list|,
name|Context
name|ctx
parameter_list|,
name|String
name|username
parameter_list|)
throws|throws
name|LockException
function_decl|;
comment|/**    * Acquire all of the locks needed by a query.  If used with a query that    * requires transactions, this should be called after {@link #openTxn(Context, String)}.    * A list of acquired locks will be stored in the    * {@link org.apache.hadoop.hive.ql.Context} object and can be retrieved    * via {@link org.apache.hadoop.hive.ql.Context#getHiveLocks}.    * @param plan query plan    * @param ctx Context for this query    * @param username name of the user for this query    * @param lDrvState the state to inform if the query cancelled or not    * @throws LockException if there is an error getting the locks    */
name|void
name|acquireLocks
parameter_list|(
name|QueryPlan
name|plan
parameter_list|,
name|Context
name|ctx
parameter_list|,
name|String
name|username
parameter_list|,
name|LockedDriverState
name|lDrvState
parameter_list|)
throws|throws
name|LockException
function_decl|;
comment|/**    * Release specified locks.    * Transaction aware TxnManagers, which has {@code supportsAcid() == true},    * will track locks internally and ignore this parameter    * @param hiveLocks The list of locks to be released.    */
name|void
name|releaseLocks
parameter_list|(
name|List
argument_list|<
name|HiveLock
argument_list|>
name|hiveLocks
parameter_list|)
throws|throws
name|LockException
function_decl|;
comment|/**    * Commit the current transaction.  This will release all locks obtained in    * {@link #acquireLocks(org.apache.hadoop.hive.ql.QueryPlan,    * org.apache.hadoop.hive.ql.Context, java.lang.String)}.    * @throws LockException if there is no current transaction or the    * transaction has already been committed or aborted.    */
name|void
name|commitTxn
parameter_list|()
throws|throws
name|LockException
function_decl|;
comment|/**    * Abort the current transaction.  This will release all locks obtained in    * {@link #acquireLocks(org.apache.hadoop.hive.ql.QueryPlan,    * org.apache.hadoop.hive.ql.Context, java.lang.String)}.    * @throws LockException if there is no current transaction or the    * transaction has already been committed or aborted.    */
name|void
name|rollbackTxn
parameter_list|()
throws|throws
name|LockException
function_decl|;
comment|/**    * Send a heartbeat to the transaction management storage so other Hive    * clients know that the transaction and locks held by this client are    * still valid.  For implementations that do not require heartbeats this    * can be a no-op.    * @throws LockException If current transaction exists or the transaction    * has already been committed or aborted.    */
name|void
name|heartbeat
parameter_list|()
throws|throws
name|LockException
function_decl|;
comment|/**    * Get the transactions that are currently valid.  The resulting    * {@link ValidTxnList} object can be passed as string to the processing    * tasks for use in the reading the data.  This call should be made once up    * front by the planner and should never be called on the backend,    * as this will violate the isolation level semantics.    * @return list of valid transactions.    * @throws LockException    */
name|ValidTxnList
name|getValidTxns
parameter_list|()
throws|throws
name|LockException
function_decl|;
comment|/**    * Get the table write Ids that are valid for the current transaction.  The resulting    * {@link ValidTxnWriteIdList} object can be passed as string to the processing    * tasks for use in the reading the data.  This call will return same results as long as validTxnString    * passed is same.    * @param tableList list of tables (<db_name>.<table_name>) read/written by current transaction.    * @param validTxnList snapshot of valid txns for the current txn    * @return list of valid table write Ids.    * @throws LockException    */
name|ValidTxnWriteIdList
name|getValidWriteIds
parameter_list|(
name|List
argument_list|<
name|String
argument_list|>
name|tableList
parameter_list|,
name|String
name|validTxnList
parameter_list|)
throws|throws
name|LockException
function_decl|;
comment|/**    * Get the name for currently installed transaction manager.    * @return transaction manager name    */
name|String
name|getTxnManagerName
parameter_list|()
function_decl|;
comment|/**    * This call closes down the transaction manager.  All open transactions    * are aborted.  If no transactions are open but locks are held those locks    * are released.  This method should be called if processing of a session    * is being halted in an abnormal way.  It avoids locks and transactions    * timing out.    */
name|void
name|closeTxnManager
parameter_list|()
function_decl|;
comment|/**    * Indicate whether this lock manager supports the use of<code>lock    *<i>database</i></code> or<code>lock<i>table</i></code>.    * @return    */
name|boolean
name|supportsExplicitLock
parameter_list|()
function_decl|;
comment|/**    * This function is called to lock the table when explicit lock command is    * issued on a table.    * @param hiveDB    an object to communicate with the metastore    * @param lockTbl   table locking info, such as table name, locking mode    * @return 0 if the locking succeeds, 1 otherwise.    * @throws HiveException    */
name|int
name|lockTable
parameter_list|(
name|Hive
name|hiveDB
parameter_list|,
name|LockTableDesc
name|lockTbl
parameter_list|)
throws|throws
name|HiveException
function_decl|;
comment|/**    * This function is called to unlock the table when explicit unlock command is    * issued on a table.    * @param hiveDB    an object to communicate with the metastore    * @param unlockTbl table unlocking info, such as table name    * @return 0 if the locking succeeds, 1 otherwise.    * @throws HiveException    */
name|int
name|unlockTable
parameter_list|(
name|Hive
name|hiveDB
parameter_list|,
name|UnlockTableDesc
name|unlockTbl
parameter_list|)
throws|throws
name|HiveException
function_decl|;
comment|/**    * This function is called to lock the database when explicit lock command is    * issued on a database.    * @param hiveDB    an object to communicate with the metastore    * @param lockDb    database locking info, such as database name, locking mode    * @return 0 if the locking succeeds, 1 otherwise.    * @throws HiveException    */
name|int
name|lockDatabase
parameter_list|(
name|Hive
name|hiveDB
parameter_list|,
name|LockDatabaseDesc
name|lockDb
parameter_list|)
throws|throws
name|HiveException
function_decl|;
comment|/**    * This function is called to unlock the database when explicit unlock command    * is issued on a database.    * @param hiveDB    an object to communicate with the metastore    * @param unlockDb  database unlocking info, such as database name    * @return 0 if the locking succeeds, 1 otherwise.    * @throws HiveException    */
name|int
name|unlockDatabase
parameter_list|(
name|Hive
name|hiveDB
parameter_list|,
name|UnlockDatabaseDesc
name|unlockDb
parameter_list|)
throws|throws
name|HiveException
function_decl|;
comment|/**    * Indicate whether this transaction manager returns information about locks in the new format    * for show locks or the old one.    * @return true if the new format should be used.    */
name|boolean
name|useNewShowLocksFormat
parameter_list|()
function_decl|;
comment|/**    * Indicate whether this transaction manager supports ACID operations.    * @return true if this transaction manager does ACID    */
name|boolean
name|supportsAcid
parameter_list|()
function_decl|;
comment|/**    * For resources that support MVCC, the state of the DB must be recorded for the duration of the    * operation/transaction.  Returns {@code true} if current statement needs to do this.    */
name|boolean
name|recordSnapshot
parameter_list|(
name|QueryPlan
name|queryPlan
parameter_list|)
function_decl|;
name|boolean
name|isImplicitTransactionOpen
parameter_list|()
function_decl|;
name|boolean
name|isTxnOpen
parameter_list|()
function_decl|;
comment|/**    * if {@code isTxnOpen()}, returns the currently active transaction ID.    */
name|long
name|getCurrentTxnId
parameter_list|()
function_decl|;
comment|/**    * if {@code isTxnOpen()}, returns the table write ID associated with current active transaction.    */
name|long
name|getTableWriteId
parameter_list|(
name|String
name|dbName
parameter_list|,
name|String
name|tableName
parameter_list|)
throws|throws
name|LockException
function_decl|;
comment|/**   * if {@code isTxnOpen()}, returns the already allocated table write ID of the table with   * the given "dbName.tableName" for the current active transaction.   * If not allocated, then returns 0.   * @param dbName   * @param tableName   * @return 0 if not yet allocated   * @throws LockException   */
specifier|public
name|long
name|getAllocatedTableWriteId
parameter_list|(
name|String
name|dbName
parameter_list|,
name|String
name|tableName
parameter_list|)
throws|throws
name|LockException
function_decl|;
comment|/**    * Allocates write id for each transaction in the list.    * @param dbName database name    * @param tableName the name of the table to allocate the write id    * @param replPolicy used by replication task to identify the source cluster    * @param srcTxnToWriteIdList List of txn id to write id Map    * @throws LockException    */
name|void
name|replAllocateTableWriteIdsBatch
parameter_list|(
name|String
name|dbName
parameter_list|,
name|String
name|tableName
parameter_list|,
name|String
name|replPolicy
parameter_list|,
name|List
argument_list|<
name|TxnToWriteId
argument_list|>
name|srcTxnToWriteIdList
parameter_list|)
throws|throws
name|LockException
function_decl|;
comment|/**    * Should be though of more as a unique write operation ID in a given txn (at QueryPlan level).    * Each statement writing data within a multi statement txn should have a unique WriteId.    * Even a single statement, (e.g. Merge, multi-insert may generates several writes).    */
name|int
name|getStmtIdAndIncrement
parameter_list|()
function_decl|;
comment|// Can be used by operation to set the stmt id when allocation is done somewhere else.
name|int
name|getCurrentStmtId
parameter_list|()
function_decl|;
comment|/**    * Acquire the materialization rebuild lock for a given view. We need to specify the fully    * qualified name of the materialized view and the open transaction ID so we can identify    * uniquely the lock.    * @return the response from the metastore, where the lock id is equal to the txn id and    * the status can be either ACQUIRED or NOT ACQUIRED    */
name|LockResponse
name|acquireMaterializationRebuildLock
parameter_list|(
name|String
name|dbName
parameter_list|,
name|String
name|tableName
parameter_list|,
name|long
name|txnId
parameter_list|)
throws|throws
name|LockException
function_decl|;
block|}
end_interface

end_unit

