begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|parse
package|;
end_package

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|reflect
operator|.
name|Method
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Stack
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|ColumnInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|FunctionRegistry
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|UDF
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|lib
operator|.
name|Node
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|lib
operator|.
name|NodeProcessor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|lib
operator|.
name|NodeProcessorCtx
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|exprNodeColumnDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|exprNodeConstantDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|exprNodeDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|exprNodeFieldDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|exprNodeFuncDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|exprNodeIndexDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|exprNodeNullDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|typeinfo
operator|.
name|TypeInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|typeinfo
operator|.
name|TypeInfoFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|udf
operator|.
name|UDFOPPositive
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|objectinspector
operator|.
name|ObjectInspector
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|objectinspector
operator|.
name|ObjectInspectorUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|objectinspector
operator|.
name|ObjectInspector
operator|.
name|Category
import|;
end_import

begin_comment
comment|/**  * The Factory for creating typecheck processors. The typecheck processors are used to  * processes the syntax trees for expressions and convert them into expression Node  * Descriptor trees. They also introduce the correct conversion functions to do proper  * implicit conversion.  */
end_comment

begin_class
specifier|public
class|class
name|TypeCheckProcFactory
block|{
comment|/**    * Function to do groupby subexpression elimination. This is called by all the processors initially.    * As an example, consider the query    *   select a+b, count(1) from T group by a+b;    * Then a+b is already precomputed in the group by operators key, so we substitute a+b in the select    * list with the internal column name of the a+b expression that appears in the in input row resolver.    *     * @param nd The node that is being inspected.    * @param procCtx The processor context.    *     * @return exprNodeColumnDesc.    */
specifier|public
specifier|static
name|exprNodeDesc
name|processGByExpr
parameter_list|(
name|Node
name|nd
parameter_list|,
name|Object
name|procCtx
parameter_list|)
throws|throws
name|SemanticException
block|{
comment|//  We recursively create the exprNodeDesc.  Base cases:  when we encounter
comment|//  a column ref, we convert that into an exprNodeColumnDesc;  when we encounter
comment|//  a constant, we convert that into an exprNodeConstantDesc.  For others we just
comment|//  build the exprNodeFuncDesc with recursively built children.
name|ASTNode
name|expr
init|=
operator|(
name|ASTNode
operator|)
name|nd
decl_stmt|;
name|TypeCheckCtx
name|ctx
init|=
operator|(
name|TypeCheckCtx
operator|)
name|procCtx
decl_stmt|;
name|RowResolver
name|input
init|=
name|ctx
operator|.
name|getInputRR
argument_list|()
decl_stmt|;
name|exprNodeDesc
name|desc
init|=
literal|null
decl_stmt|;
comment|//  If the current subExpression is pre-calculated, as in Group-By etc.
name|ColumnInfo
name|colInfo
init|=
name|input
operator|.
name|get
argument_list|(
literal|""
argument_list|,
name|expr
operator|.
name|toStringTree
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|colInfo
operator|!=
literal|null
condition|)
block|{
name|desc
operator|=
operator|new
name|exprNodeColumnDesc
argument_list|(
name|colInfo
operator|.
name|getType
argument_list|()
argument_list|,
name|colInfo
operator|.
name|getInternalName
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|desc
return|;
block|}
return|return
name|desc
return|;
block|}
comment|/**    * Processor for processing NULL expression.    */
specifier|public
specifier|static
class|class
name|NullExprProcessor
implements|implements
name|NodeProcessor
block|{
annotation|@
name|Override
specifier|public
name|Object
name|process
parameter_list|(
name|Node
name|nd
parameter_list|,
name|Stack
argument_list|<
name|Node
argument_list|>
name|stack
parameter_list|,
name|NodeProcessorCtx
name|procCtx
parameter_list|,
name|Object
modifier|...
name|nodeOutputs
parameter_list|)
throws|throws
name|SemanticException
block|{
name|exprNodeDesc
name|desc
init|=
name|TypeCheckProcFactory
operator|.
name|processGByExpr
argument_list|(
name|nd
argument_list|,
name|procCtx
argument_list|)
decl_stmt|;
if|if
condition|(
name|desc
operator|!=
literal|null
condition|)
block|{
return|return
name|desc
return|;
block|}
return|return
operator|new
name|exprNodeNullDesc
argument_list|()
return|;
block|}
block|}
comment|/**    * Factory method to get NullExprProcessor.    * @return NullExprProcessor.    */
specifier|public
specifier|static
name|NullExprProcessor
name|getNullExprProcessor
parameter_list|()
block|{
return|return
operator|new
name|NullExprProcessor
argument_list|()
return|;
block|}
comment|/**    * Processor for processing numeric constants.    */
specifier|public
specifier|static
class|class
name|NumExprProcessor
implements|implements
name|NodeProcessor
block|{
annotation|@
name|Override
specifier|public
name|Object
name|process
parameter_list|(
name|Node
name|nd
parameter_list|,
name|Stack
argument_list|<
name|Node
argument_list|>
name|stack
parameter_list|,
name|NodeProcessorCtx
name|procCtx
parameter_list|,
name|Object
modifier|...
name|nodeOutputs
parameter_list|)
throws|throws
name|SemanticException
block|{
name|exprNodeDesc
name|desc
init|=
name|TypeCheckProcFactory
operator|.
name|processGByExpr
argument_list|(
name|nd
argument_list|,
name|procCtx
argument_list|)
decl_stmt|;
if|if
condition|(
name|desc
operator|!=
literal|null
condition|)
block|{
return|return
name|desc
return|;
block|}
name|Number
name|v
init|=
literal|null
decl_stmt|;
name|ASTNode
name|expr
init|=
operator|(
name|ASTNode
operator|)
name|nd
decl_stmt|;
comment|// The expression can be any one of Double, Long and Integer. We
comment|// try to parse the expression in that order to ensure that the
comment|// most specific type is used for conversion.
try|try
block|{
name|v
operator|=
name|Double
operator|.
name|valueOf
argument_list|(
name|expr
operator|.
name|getText
argument_list|()
argument_list|)
expr_stmt|;
name|v
operator|=
name|Long
operator|.
name|valueOf
argument_list|(
name|expr
operator|.
name|getText
argument_list|()
argument_list|)
expr_stmt|;
name|v
operator|=
name|Integer
operator|.
name|valueOf
argument_list|(
name|expr
operator|.
name|getText
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|NumberFormatException
name|e
parameter_list|)
block|{
comment|// do nothing here, we will throw an exception in the following block
block|}
if|if
condition|(
name|v
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|INVALID_NUMERICAL_CONSTANT
operator|.
name|getMsg
argument_list|(
name|expr
argument_list|)
argument_list|)
throw|;
block|}
return|return
operator|new
name|exprNodeConstantDesc
argument_list|(
name|v
argument_list|)
return|;
block|}
block|}
comment|/**    * Factory method to get NumExprProcessor.    * @return NumExprProcessor.    */
specifier|public
specifier|static
name|NumExprProcessor
name|getNumExprProcessor
parameter_list|()
block|{
return|return
operator|new
name|NumExprProcessor
argument_list|()
return|;
block|}
comment|/**    * Processor for processing string constants.    */
specifier|public
specifier|static
class|class
name|StrExprProcessor
implements|implements
name|NodeProcessor
block|{
annotation|@
name|Override
specifier|public
name|Object
name|process
parameter_list|(
name|Node
name|nd
parameter_list|,
name|Stack
argument_list|<
name|Node
argument_list|>
name|stack
parameter_list|,
name|NodeProcessorCtx
name|procCtx
parameter_list|,
name|Object
modifier|...
name|nodeOutputs
parameter_list|)
throws|throws
name|SemanticException
block|{
name|exprNodeDesc
name|desc
init|=
name|TypeCheckProcFactory
operator|.
name|processGByExpr
argument_list|(
name|nd
argument_list|,
name|procCtx
argument_list|)
decl_stmt|;
if|if
condition|(
name|desc
operator|!=
literal|null
condition|)
block|{
return|return
name|desc
return|;
block|}
name|ASTNode
name|expr
init|=
operator|(
name|ASTNode
operator|)
name|nd
decl_stmt|;
name|String
name|str
init|=
literal|null
decl_stmt|;
switch|switch
condition|(
name|expr
operator|.
name|getToken
argument_list|()
operator|.
name|getType
argument_list|()
condition|)
block|{
case|case
name|HiveParser
operator|.
name|StringLiteral
case|:
name|str
operator|=
name|BaseSemanticAnalyzer
operator|.
name|unescapeSQLString
argument_list|(
name|expr
operator|.
name|getText
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|HiveParser
operator|.
name|TOK_CHARSETLITERAL
case|:
name|str
operator|=
name|BaseSemanticAnalyzer
operator|.
name|charSetString
argument_list|(
name|expr
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getText
argument_list|()
argument_list|,
name|expr
operator|.
name|getChild
argument_list|(
literal|1
argument_list|)
operator|.
name|getText
argument_list|()
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|// HiveParser.identifier | HiveParse.KW_IF | HiveParse.KW_LEFT | HiveParse.KW_RIGHT
name|str
operator|=
name|BaseSemanticAnalyzer
operator|.
name|unescapeIdentifier
argument_list|(
name|expr
operator|.
name|getText
argument_list|()
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
operator|new
name|exprNodeConstantDesc
argument_list|(
name|String
operator|.
name|class
argument_list|,
name|str
argument_list|)
return|;
block|}
block|}
comment|/**    * Factory method to get StrExprProcessor.    * @return StrExprProcessor.    */
specifier|public
specifier|static
name|StrExprProcessor
name|getStrExprProcessor
parameter_list|()
block|{
return|return
operator|new
name|StrExprProcessor
argument_list|()
return|;
block|}
comment|/**    * Processor for boolean constants.    */
specifier|public
specifier|static
class|class
name|BoolExprProcessor
implements|implements
name|NodeProcessor
block|{
annotation|@
name|Override
specifier|public
name|Object
name|process
parameter_list|(
name|Node
name|nd
parameter_list|,
name|Stack
argument_list|<
name|Node
argument_list|>
name|stack
parameter_list|,
name|NodeProcessorCtx
name|procCtx
parameter_list|,
name|Object
modifier|...
name|nodeOutputs
parameter_list|)
throws|throws
name|SemanticException
block|{
name|exprNodeDesc
name|desc
init|=
name|TypeCheckProcFactory
operator|.
name|processGByExpr
argument_list|(
name|nd
argument_list|,
name|procCtx
argument_list|)
decl_stmt|;
if|if
condition|(
name|desc
operator|!=
literal|null
condition|)
block|{
return|return
name|desc
return|;
block|}
name|ASTNode
name|expr
init|=
operator|(
name|ASTNode
operator|)
name|nd
decl_stmt|;
name|Boolean
name|bool
init|=
literal|null
decl_stmt|;
switch|switch
condition|(
name|expr
operator|.
name|getToken
argument_list|()
operator|.
name|getType
argument_list|()
condition|)
block|{
case|case
name|HiveParser
operator|.
name|KW_TRUE
case|:
name|bool
operator|=
name|Boolean
operator|.
name|TRUE
expr_stmt|;
break|break;
case|case
name|HiveParser
operator|.
name|KW_FALSE
case|:
name|bool
operator|=
name|Boolean
operator|.
name|FALSE
expr_stmt|;
break|break;
default|default:
assert|assert
literal|false
assert|;
block|}
return|return
operator|new
name|exprNodeConstantDesc
argument_list|(
name|Boolean
operator|.
name|class
argument_list|,
name|bool
argument_list|)
return|;
block|}
block|}
comment|/**    * Factory method to get BoolExprProcessor.    * @return BoolExprProcessor.    */
specifier|public
specifier|static
name|BoolExprProcessor
name|getBoolExprProcessor
parameter_list|()
block|{
return|return
operator|new
name|BoolExprProcessor
argument_list|()
return|;
block|}
comment|/**    * Processor for table columns    */
specifier|public
specifier|static
class|class
name|ColumnExprProcessor
implements|implements
name|NodeProcessor
block|{
annotation|@
name|Override
specifier|public
name|Object
name|process
parameter_list|(
name|Node
name|nd
parameter_list|,
name|Stack
argument_list|<
name|Node
argument_list|>
name|stack
parameter_list|,
name|NodeProcessorCtx
name|procCtx
parameter_list|,
name|Object
modifier|...
name|nodeOutputs
parameter_list|)
throws|throws
name|SemanticException
block|{
name|exprNodeDesc
name|desc
init|=
name|TypeCheckProcFactory
operator|.
name|processGByExpr
argument_list|(
name|nd
argument_list|,
name|procCtx
argument_list|)
decl_stmt|;
if|if
condition|(
name|desc
operator|!=
literal|null
condition|)
block|{
return|return
name|desc
return|;
block|}
name|ASTNode
name|expr
init|=
operator|(
name|ASTNode
operator|)
name|nd
decl_stmt|;
name|TypeCheckCtx
name|ctx
init|=
operator|(
name|TypeCheckCtx
operator|)
name|procCtx
decl_stmt|;
name|RowResolver
name|input
init|=
name|ctx
operator|.
name|getInputRR
argument_list|()
decl_stmt|;
if|if
condition|(
name|expr
operator|.
name|getType
argument_list|()
operator|!=
name|HiveParser
operator|.
name|TOK_COLREF
condition|)
block|{
name|ctx
operator|.
name|setError
argument_list|(
name|ErrorMsg
operator|.
name|INVALID_COLUMN
operator|.
name|getMsg
argument_list|(
name|expr
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
name|String
name|tabAlias
init|=
literal|null
decl_stmt|;
name|String
name|colName
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|expr
operator|.
name|getChildCount
argument_list|()
operator|!=
literal|1
condition|)
block|{
name|tabAlias
operator|=
name|BaseSemanticAnalyzer
operator|.
name|unescapeIdentifier
argument_list|(
name|expr
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getText
argument_list|()
argument_list|)
expr_stmt|;
name|colName
operator|=
name|BaseSemanticAnalyzer
operator|.
name|unescapeIdentifier
argument_list|(
name|expr
operator|.
name|getChild
argument_list|(
literal|1
argument_list|)
operator|.
name|getText
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|colName
operator|=
name|BaseSemanticAnalyzer
operator|.
name|unescapeIdentifier
argument_list|(
name|expr
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getText
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|colName
operator|==
literal|null
condition|)
block|{
name|ctx
operator|.
name|setError
argument_list|(
name|ErrorMsg
operator|.
name|INVALID_XPATH
operator|.
name|getMsg
argument_list|(
name|expr
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
name|ColumnInfo
name|colInfo
init|=
name|input
operator|.
name|get
argument_list|(
name|tabAlias
argument_list|,
name|colName
argument_list|)
decl_stmt|;
if|if
condition|(
name|colInfo
operator|==
literal|null
operator|&&
name|input
operator|.
name|getIsExprResolver
argument_list|()
condition|)
block|{
name|ctx
operator|.
name|setError
argument_list|(
name|ErrorMsg
operator|.
name|NON_KEY_EXPR_IN_GROUPBY
operator|.
name|getMsg
argument_list|(
name|expr
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
elseif|else
if|if
condition|(
name|tabAlias
operator|!=
literal|null
operator|&&
operator|!
name|input
operator|.
name|hasTableAlias
argument_list|(
name|tabAlias
argument_list|)
condition|)
block|{
name|ctx
operator|.
name|setError
argument_list|(
name|ErrorMsg
operator|.
name|INVALID_TABLE_ALIAS
operator|.
name|getMsg
argument_list|(
name|expr
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
elseif|else
if|if
condition|(
name|colInfo
operator|==
literal|null
condition|)
block|{
name|ctx
operator|.
name|setError
argument_list|(
name|ErrorMsg
operator|.
name|INVALID_COLUMN
operator|.
name|getMsg
argument_list|(
name|tabAlias
operator|==
literal|null
condition|?
name|expr
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
else|:
name|expr
operator|.
name|getChild
argument_list|(
literal|1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
return|return
operator|new
name|exprNodeColumnDesc
argument_list|(
name|colInfo
operator|.
name|getType
argument_list|()
argument_list|,
name|colInfo
operator|.
name|getInternalName
argument_list|()
argument_list|)
return|;
block|}
block|}
comment|/**    * Factory method to get ColumnExprProcessor.    * @return ColumnExprProcessor.    */
specifier|public
specifier|static
name|ColumnExprProcessor
name|getColumnExprProcessor
parameter_list|()
block|{
return|return
operator|new
name|ColumnExprProcessor
argument_list|()
return|;
block|}
comment|/**    * The default processor for typechecking.    */
specifier|public
specifier|static
class|class
name|DefaultExprProcessor
implements|implements
name|NodeProcessor
block|{
specifier|static
name|HashMap
argument_list|<
name|Integer
argument_list|,
name|String
argument_list|>
name|specialUnaryOperatorTextHashMap
decl_stmt|;
specifier|static
name|HashMap
argument_list|<
name|Integer
argument_list|,
name|String
argument_list|>
name|specialFunctionTextHashMap
decl_stmt|;
specifier|static
name|HashMap
argument_list|<
name|Integer
argument_list|,
name|String
argument_list|>
name|conversionFunctionTextHashMap
decl_stmt|;
static|static
block|{
name|specialUnaryOperatorTextHashMap
operator|=
operator|new
name|HashMap
argument_list|<
name|Integer
argument_list|,
name|String
argument_list|>
argument_list|()
expr_stmt|;
name|specialUnaryOperatorTextHashMap
operator|.
name|put
argument_list|(
name|HiveParser
operator|.
name|PLUS
argument_list|,
literal|"positive"
argument_list|)
expr_stmt|;
name|specialUnaryOperatorTextHashMap
operator|.
name|put
argument_list|(
name|HiveParser
operator|.
name|MINUS
argument_list|,
literal|"negative"
argument_list|)
expr_stmt|;
name|specialFunctionTextHashMap
operator|=
operator|new
name|HashMap
argument_list|<
name|Integer
argument_list|,
name|String
argument_list|>
argument_list|()
expr_stmt|;
name|specialFunctionTextHashMap
operator|.
name|put
argument_list|(
name|HiveParser
operator|.
name|TOK_ISNULL
argument_list|,
literal|"isnull"
argument_list|)
expr_stmt|;
name|specialFunctionTextHashMap
operator|.
name|put
argument_list|(
name|HiveParser
operator|.
name|TOK_ISNOTNULL
argument_list|,
literal|"isnotnull"
argument_list|)
expr_stmt|;
name|conversionFunctionTextHashMap
operator|=
operator|new
name|HashMap
argument_list|<
name|Integer
argument_list|,
name|String
argument_list|>
argument_list|()
expr_stmt|;
name|conversionFunctionTextHashMap
operator|.
name|put
argument_list|(
name|HiveParser
operator|.
name|TOK_BOOLEAN
argument_list|,
name|Boolean
operator|.
name|class
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
name|conversionFunctionTextHashMap
operator|.
name|put
argument_list|(
name|HiveParser
operator|.
name|TOK_TINYINT
argument_list|,
name|Byte
operator|.
name|class
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
name|conversionFunctionTextHashMap
operator|.
name|put
argument_list|(
name|HiveParser
operator|.
name|TOK_SMALLINT
argument_list|,
name|Short
operator|.
name|class
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
name|conversionFunctionTextHashMap
operator|.
name|put
argument_list|(
name|HiveParser
operator|.
name|TOK_INT
argument_list|,
name|Integer
operator|.
name|class
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
name|conversionFunctionTextHashMap
operator|.
name|put
argument_list|(
name|HiveParser
operator|.
name|TOK_BIGINT
argument_list|,
name|Long
operator|.
name|class
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
name|conversionFunctionTextHashMap
operator|.
name|put
argument_list|(
name|HiveParser
operator|.
name|TOK_FLOAT
argument_list|,
name|Float
operator|.
name|class
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
name|conversionFunctionTextHashMap
operator|.
name|put
argument_list|(
name|HiveParser
operator|.
name|TOK_DOUBLE
argument_list|,
name|Double
operator|.
name|class
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
name|conversionFunctionTextHashMap
operator|.
name|put
argument_list|(
name|HiveParser
operator|.
name|TOK_STRING
argument_list|,
name|String
operator|.
name|class
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
name|conversionFunctionTextHashMap
operator|.
name|put
argument_list|(
name|HiveParser
operator|.
name|TOK_DATE
argument_list|,
name|java
operator|.
name|sql
operator|.
name|Date
operator|.
name|class
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
block|}
specifier|public
specifier|static
name|boolean
name|isRedundantConversionFunction
parameter_list|(
name|ASTNode
name|expr
parameter_list|,
name|boolean
name|isFunction
parameter_list|,
name|ArrayList
argument_list|<
name|exprNodeDesc
argument_list|>
name|children
parameter_list|)
block|{
if|if
condition|(
operator|!
name|isFunction
condition|)
return|return
literal|false
return|;
comment|// children is always one less than the expr.getChildCount(), since the latter contains function name.
assert|assert
operator|(
name|children
operator|.
name|size
argument_list|()
operator|==
name|expr
operator|.
name|getChildCount
argument_list|()
operator|-
literal|1
operator|)
assert|;
comment|// conversion functions take a single parameter
if|if
condition|(
name|children
operator|.
name|size
argument_list|()
operator|!=
literal|1
condition|)
return|return
literal|false
return|;
name|String
name|funcText
init|=
name|conversionFunctionTextHashMap
operator|.
name|get
argument_list|(
operator|(
operator|(
name|ASTNode
operator|)
name|expr
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|)
operator|.
name|getType
argument_list|()
argument_list|)
decl_stmt|;
comment|// not a conversion function
if|if
condition|(
name|funcText
operator|==
literal|null
condition|)
return|return
literal|false
return|;
comment|// return true when the child type and the conversion target type is the same
return|return
name|children
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|getTypeInfo
argument_list|()
operator|.
name|getPrimitiveClass
argument_list|()
operator|.
name|getName
argument_list|()
operator|.
name|equals
argument_list|(
name|funcText
argument_list|)
return|;
block|}
specifier|public
specifier|static
name|String
name|getFunctionText
parameter_list|(
name|ASTNode
name|expr
parameter_list|,
name|boolean
name|isFunction
parameter_list|)
block|{
name|String
name|funcText
init|=
literal|null
decl_stmt|;
if|if
condition|(
operator|!
name|isFunction
condition|)
block|{
comment|// For operator, the function name is the operator text, unless it's in our special dictionary
if|if
condition|(
name|expr
operator|.
name|getChildCount
argument_list|()
operator|==
literal|1
condition|)
block|{
name|funcText
operator|=
name|specialUnaryOperatorTextHashMap
operator|.
name|get
argument_list|(
name|expr
operator|.
name|getType
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|funcText
operator|==
literal|null
condition|)
block|{
name|funcText
operator|=
name|expr
operator|.
name|getText
argument_list|()
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// For TOK_FUNCTION, the function name is stored in the first child, unless it's in our
comment|// special dictionary.
assert|assert
operator|(
name|expr
operator|.
name|getChildCount
argument_list|()
operator|>=
literal|1
operator|)
assert|;
name|int
name|funcType
init|=
operator|(
operator|(
name|ASTNode
operator|)
name|expr
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|)
operator|.
name|getType
argument_list|()
decl_stmt|;
name|funcText
operator|=
name|specialFunctionTextHashMap
operator|.
name|get
argument_list|(
name|funcType
argument_list|)
expr_stmt|;
if|if
condition|(
name|funcText
operator|==
literal|null
condition|)
block|{
name|funcText
operator|=
name|conversionFunctionTextHashMap
operator|.
name|get
argument_list|(
name|funcType
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|funcText
operator|==
literal|null
condition|)
block|{
name|funcText
operator|=
operator|(
operator|(
name|ASTNode
operator|)
name|expr
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|)
operator|.
name|getText
argument_list|()
expr_stmt|;
block|}
block|}
return|return
name|funcText
return|;
block|}
comment|/**      * Get the exprNodeDesc      * @param name      * @param children      * @return      */
specifier|public
specifier|static
name|exprNodeDesc
name|getFuncExprNodeDesc
parameter_list|(
name|String
name|name
parameter_list|,
name|exprNodeDesc
modifier|...
name|children
parameter_list|)
block|{
return|return
name|getFuncExprNodeDesc
argument_list|(
name|name
argument_list|,
name|Arrays
operator|.
name|asList
argument_list|(
name|children
argument_list|)
argument_list|)
return|;
block|}
comment|/**      * This function create an ExprNodeDesc for a UDF function given the children (arguments).      * It will insert implicit type conversion functions if necessary.       * @throws SemanticException       */
specifier|public
specifier|static
name|exprNodeDesc
name|getFuncExprNodeDesc
parameter_list|(
name|String
name|udfName
parameter_list|,
name|List
argument_list|<
name|exprNodeDesc
argument_list|>
name|children
parameter_list|)
block|{
comment|// Find the corresponding method
name|ArrayList
argument_list|<
name|Class
argument_list|<
name|?
argument_list|>
argument_list|>
name|argumentClasses
init|=
operator|new
name|ArrayList
argument_list|<
name|Class
argument_list|<
name|?
argument_list|>
argument_list|>
argument_list|(
name|children
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|children
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|exprNodeDesc
name|child
init|=
name|children
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
assert|assert
operator|(
name|child
operator|!=
literal|null
operator|)
assert|;
name|TypeInfo
name|childTypeInfo
init|=
name|child
operator|.
name|getTypeInfo
argument_list|()
decl_stmt|;
assert|assert
operator|(
name|childTypeInfo
operator|!=
literal|null
operator|)
assert|;
comment|// Note: we don't pass the element types of MAP/LIST to UDF.
comment|// That will work for null test and size but not other more complex functionalities like list slice etc.
comment|// For those more complex functionalities, we plan to have a ComplexUDF interface which has an evaluate
comment|// method that accepts a list of objects and a list of objectinspectors.
switch|switch
condition|(
name|childTypeInfo
operator|.
name|getCategory
argument_list|()
condition|)
block|{
case|case
name|PRIMITIVE
case|:
block|{
name|argumentClasses
operator|.
name|add
argument_list|(
name|childTypeInfo
operator|.
name|getPrimitiveClass
argument_list|()
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|MAP
case|:
block|{
name|argumentClasses
operator|.
name|add
argument_list|(
name|Map
operator|.
name|class
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|LIST
case|:
block|{
name|argumentClasses
operator|.
name|add
argument_list|(
name|List
operator|.
name|class
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|STRUCT
case|:
block|{
name|argumentClasses
operator|.
name|add
argument_list|(
name|Object
operator|.
name|class
argument_list|)
expr_stmt|;
break|break;
block|}
default|default:
block|{
comment|// should never happen
assert|assert
operator|(
literal|false
operator|)
assert|;
block|}
block|}
block|}
name|Method
name|udfMethod
init|=
name|FunctionRegistry
operator|.
name|getUDFMethod
argument_list|(
name|udfName
argument_list|,
name|argumentClasses
argument_list|)
decl_stmt|;
if|if
condition|(
name|udfMethod
operator|==
literal|null
condition|)
return|return
literal|null
return|;
name|ArrayList
argument_list|<
name|exprNodeDesc
argument_list|>
name|ch
init|=
operator|new
name|ArrayList
argument_list|<
name|exprNodeDesc
argument_list|>
argument_list|()
decl_stmt|;
name|Class
argument_list|<
name|?
argument_list|>
index|[]
name|pTypes
init|=
name|udfMethod
operator|.
name|getParameterTypes
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|children
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|exprNodeDesc
name|desc
init|=
name|children
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|Class
argument_list|<
name|?
argument_list|>
name|pType
init|=
name|ObjectInspectorUtils
operator|.
name|generalizePrimitive
argument_list|(
name|pTypes
index|[
name|i
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
name|desc
operator|instanceof
name|exprNodeNullDesc
condition|)
block|{
name|exprNodeConstantDesc
name|newCh
init|=
operator|new
name|exprNodeConstantDesc
argument_list|(
name|TypeInfoFactory
operator|.
name|getPrimitiveTypeInfo
argument_list|(
name|pType
argument_list|)
argument_list|,
literal|null
argument_list|)
decl_stmt|;
name|ch
operator|.
name|add
argument_list|(
name|newCh
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|pType
operator|.
name|isAssignableFrom
argument_list|(
name|argumentClasses
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|)
condition|)
block|{
comment|// no type conversion needed
name|ch
operator|.
name|add
argument_list|(
name|desc
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// must be implicit type conversion
name|Class
argument_list|<
name|?
argument_list|>
name|from
init|=
name|argumentClasses
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|Class
argument_list|<
name|?
argument_list|>
name|to
init|=
name|pType
decl_stmt|;
if|if
condition|(
operator|!
name|FunctionRegistry
operator|.
name|implicitConvertable
argument_list|(
name|from
argument_list|,
name|to
argument_list|)
condition|)
block|{
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"cannot implicitly convert from "
operator|+
name|from
operator|+
literal|" to "
operator|+
name|to
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"cannot implicitly convert from "
operator|+
name|from
operator|+
literal|" to "
operator|+
name|to
argument_list|)
throw|;
block|}
name|Method
name|m
init|=
name|FunctionRegistry
operator|.
name|getUDFMethod
argument_list|(
name|to
operator|.
name|getName
argument_list|()
argument_list|,
name|from
argument_list|)
decl_stmt|;
assert|assert
operator|(
name|m
operator|!=
literal|null
operator|)
assert|;
name|Class
argument_list|<
name|?
extends|extends
name|UDF
argument_list|>
name|c
init|=
name|FunctionRegistry
operator|.
name|getUDFClass
argument_list|(
name|to
operator|.
name|getName
argument_list|()
argument_list|)
decl_stmt|;
assert|assert
operator|(
name|c
operator|!=
literal|null
operator|)
assert|;
comment|// get the conversion method
name|ArrayList
argument_list|<
name|exprNodeDesc
argument_list|>
name|conversionArg
init|=
operator|new
name|ArrayList
argument_list|<
name|exprNodeDesc
argument_list|>
argument_list|(
literal|1
argument_list|)
decl_stmt|;
name|conversionArg
operator|.
name|add
argument_list|(
name|desc
argument_list|)
expr_stmt|;
name|ch
operator|.
name|add
argument_list|(
operator|new
name|exprNodeFuncDesc
argument_list|(
name|TypeInfoFactory
operator|.
name|getPrimitiveTypeInfo
argument_list|(
name|pType
argument_list|)
argument_list|,
name|c
argument_list|,
name|m
argument_list|,
name|conversionArg
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|exprNodeFuncDesc
name|desc
init|=
operator|new
name|exprNodeFuncDesc
argument_list|(
name|TypeInfoFactory
operator|.
name|getPrimitiveTypeInfo
argument_list|(
name|udfMethod
operator|.
name|getReturnType
argument_list|()
argument_list|)
argument_list|,
name|FunctionRegistry
operator|.
name|getUDFClass
argument_list|(
name|udfName
argument_list|)
argument_list|,
name|udfMethod
argument_list|,
name|ch
argument_list|)
decl_stmt|;
return|return
name|desc
return|;
block|}
specifier|static
name|exprNodeDesc
name|getXpathOrFuncExprNodeDesc
parameter_list|(
name|ASTNode
name|expr
parameter_list|,
name|boolean
name|isFunction
parameter_list|,
name|ArrayList
argument_list|<
name|exprNodeDesc
argument_list|>
name|children
parameter_list|)
throws|throws
name|SemanticException
block|{
comment|// return the child directly if the conversion is redundant.
if|if
condition|(
name|isRedundantConversionFunction
argument_list|(
name|expr
argument_list|,
name|isFunction
argument_list|,
name|children
argument_list|)
condition|)
block|{
assert|assert
operator|(
name|children
operator|.
name|size
argument_list|()
operator|==
literal|1
operator|)
assert|;
assert|assert
operator|(
name|children
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|!=
literal|null
operator|)
assert|;
return|return
name|children
operator|.
name|get
argument_list|(
literal|0
argument_list|)
return|;
block|}
name|String
name|funcText
init|=
name|getFunctionText
argument_list|(
name|expr
argument_list|,
name|isFunction
argument_list|)
decl_stmt|;
name|exprNodeDesc
name|desc
decl_stmt|;
if|if
condition|(
name|funcText
operator|.
name|equals
argument_list|(
literal|"."
argument_list|)
condition|)
block|{
comment|// "." :  FIELD Expression
assert|assert
operator|(
name|children
operator|.
name|size
argument_list|()
operator|==
literal|2
operator|)
assert|;
comment|// Only allow constant field name for now
assert|assert
operator|(
name|children
operator|.
name|get
argument_list|(
literal|1
argument_list|)
operator|instanceof
name|exprNodeConstantDesc
operator|)
assert|;
name|exprNodeDesc
name|object
init|=
name|children
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|exprNodeConstantDesc
name|fieldName
init|=
operator|(
name|exprNodeConstantDesc
operator|)
name|children
operator|.
name|get
argument_list|(
literal|1
argument_list|)
decl_stmt|;
assert|assert
operator|(
name|fieldName
operator|.
name|getValue
argument_list|()
operator|instanceof
name|String
operator|)
assert|;
comment|// Calculate result TypeInfo
name|String
name|fieldNameString
init|=
operator|(
name|String
operator|)
name|fieldName
operator|.
name|getValue
argument_list|()
decl_stmt|;
name|TypeInfo
name|objectTypeInfo
init|=
name|object
operator|.
name|getTypeInfo
argument_list|()
decl_stmt|;
comment|// Allow accessing a field of list element structs directly from a list
name|boolean
name|isList
init|=
operator|(
name|object
operator|.
name|getTypeInfo
argument_list|()
operator|.
name|getCategory
argument_list|()
operator|==
name|ObjectInspector
operator|.
name|Category
operator|.
name|LIST
operator|)
decl_stmt|;
if|if
condition|(
name|isList
condition|)
block|{
name|objectTypeInfo
operator|=
name|objectTypeInfo
operator|.
name|getListElementTypeInfo
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|objectTypeInfo
operator|.
name|getCategory
argument_list|()
operator|!=
name|Category
operator|.
name|STRUCT
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|INVALID_DOT
operator|.
name|getMsg
argument_list|(
name|expr
argument_list|)
argument_list|)
throw|;
block|}
name|TypeInfo
name|t
init|=
name|objectTypeInfo
operator|.
name|getStructFieldTypeInfo
argument_list|(
name|fieldNameString
argument_list|)
decl_stmt|;
if|if
condition|(
name|isList
condition|)
block|{
name|t
operator|=
name|TypeInfoFactory
operator|.
name|getListTypeInfo
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
name|desc
operator|=
operator|new
name|exprNodeFieldDesc
argument_list|(
name|t
argument_list|,
name|children
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|,
name|fieldNameString
argument_list|,
name|isList
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|funcText
operator|.
name|equals
argument_list|(
literal|"["
argument_list|)
condition|)
block|{
comment|// "[]" : LSQUARE/INDEX Expression
assert|assert
operator|(
name|children
operator|.
name|size
argument_list|()
operator|==
literal|2
operator|)
assert|;
comment|// Check whether this is a list or a map
name|TypeInfo
name|myt
init|=
name|children
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|getTypeInfo
argument_list|()
decl_stmt|;
if|if
condition|(
name|myt
operator|.
name|getCategory
argument_list|()
operator|==
name|Category
operator|.
name|LIST
condition|)
block|{
comment|// Only allow constant integer index for now
if|if
condition|(
operator|!
operator|(
name|children
operator|.
name|get
argument_list|(
literal|1
argument_list|)
operator|instanceof
name|exprNodeConstantDesc
operator|)
operator|||
operator|!
operator|(
operator|(
operator|(
name|exprNodeConstantDesc
operator|)
name|children
operator|.
name|get
argument_list|(
literal|1
argument_list|)
operator|)
operator|.
name|getValue
argument_list|()
operator|instanceof
name|Integer
operator|)
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|INVALID_ARRAYINDEX_CONSTANT
operator|.
name|getMsg
argument_list|(
name|expr
argument_list|)
argument_list|)
throw|;
block|}
comment|// Calculate TypeInfo
name|TypeInfo
name|t
init|=
name|myt
operator|.
name|getListElementTypeInfo
argument_list|()
decl_stmt|;
name|desc
operator|=
operator|new
name|exprNodeIndexDesc
argument_list|(
name|t
argument_list|,
name|children
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|,
name|children
operator|.
name|get
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|myt
operator|.
name|getCategory
argument_list|()
operator|==
name|Category
operator|.
name|MAP
condition|)
block|{
comment|// Only allow only constant indexes for now
if|if
condition|(
operator|!
operator|(
name|children
operator|.
name|get
argument_list|(
literal|1
argument_list|)
operator|instanceof
name|exprNodeConstantDesc
operator|)
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|INVALID_MAPINDEX_CONSTANT
operator|.
name|getMsg
argument_list|(
name|expr
argument_list|)
argument_list|)
throw|;
block|}
if|if
condition|(
operator|!
operator|(
operator|(
operator|(
name|exprNodeConstantDesc
operator|)
name|children
operator|.
name|get
argument_list|(
literal|1
argument_list|)
operator|)
operator|.
name|getValue
argument_list|()
operator|.
name|getClass
argument_list|()
operator|==
name|myt
operator|.
name|getMapKeyTypeInfo
argument_list|()
operator|.
name|getPrimitiveClass
argument_list|()
operator|)
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|INVALID_MAPINDEX_TYPE
operator|.
name|getMsg
argument_list|(
name|expr
argument_list|)
argument_list|)
throw|;
block|}
comment|// Calculate TypeInfo
name|TypeInfo
name|t
init|=
name|myt
operator|.
name|getMapValueTypeInfo
argument_list|()
decl_stmt|;
name|desc
operator|=
operator|new
name|exprNodeIndexDesc
argument_list|(
name|t
argument_list|,
name|children
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|,
name|children
operator|.
name|get
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|NON_COLLECTION_TYPE
operator|.
name|getMsg
argument_list|(
name|expr
argument_list|,
name|myt
operator|.
name|getTypeName
argument_list|()
argument_list|)
argument_list|)
throw|;
block|}
block|}
else|else
block|{
comment|// other operators or functions
name|Class
argument_list|<
name|?
extends|extends
name|UDF
argument_list|>
name|udf
init|=
name|FunctionRegistry
operator|.
name|getUDFClass
argument_list|(
name|funcText
argument_list|)
decl_stmt|;
if|if
condition|(
name|udf
operator|==
literal|null
condition|)
block|{
if|if
condition|(
name|isFunction
condition|)
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|INVALID_FUNCTION
operator|.
name|getMsg
argument_list|(
operator|(
name|ASTNode
operator|)
name|expr
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
argument_list|)
argument_list|)
throw|;
else|else
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|INVALID_FUNCTION
operator|.
name|getMsg
argument_list|(
operator|(
name|ASTNode
operator|)
name|expr
argument_list|)
argument_list|)
throw|;
block|}
name|desc
operator|=
name|getFuncExprNodeDesc
argument_list|(
name|funcText
argument_list|,
name|children
argument_list|)
expr_stmt|;
if|if
condition|(
name|desc
operator|==
literal|null
condition|)
block|{
name|ArrayList
argument_list|<
name|Class
argument_list|<
name|?
argument_list|>
argument_list|>
name|argumentClasses
init|=
operator|new
name|ArrayList
argument_list|<
name|Class
argument_list|<
name|?
argument_list|>
argument_list|>
argument_list|(
name|children
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|children
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|argumentClasses
operator|.
name|add
argument_list|(
name|children
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|getTypeInfo
argument_list|()
operator|.
name|getPrimitiveClass
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|isFunction
condition|)
block|{
name|String
name|reason
init|=
literal|"Looking for UDF \""
operator|+
name|expr
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getText
argument_list|()
operator|+
literal|"\" with parameters "
operator|+
name|argumentClasses
decl_stmt|;
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|INVALID_FUNCTION_SIGNATURE
operator|.
name|getMsg
argument_list|(
operator|(
name|ASTNode
operator|)
name|expr
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
argument_list|,
name|reason
argument_list|)
argument_list|)
throw|;
block|}
else|else
block|{
name|String
name|reason
init|=
literal|"Looking for Operator \""
operator|+
name|expr
operator|.
name|getText
argument_list|()
operator|+
literal|"\" with parameters "
operator|+
name|argumentClasses
decl_stmt|;
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|INVALID_OPERATOR_SIGNATURE
operator|.
name|getMsg
argument_list|(
name|expr
argument_list|,
name|reason
argument_list|)
argument_list|)
throw|;
block|}
block|}
block|}
comment|// UDFOPPositive is a no-op.
comment|// However, we still create it, and then remove it here, to make sure we only allow
comment|// "+" for numeric types.
if|if
condition|(
name|desc
operator|instanceof
name|exprNodeFuncDesc
condition|)
block|{
name|exprNodeFuncDesc
name|funcDesc
init|=
operator|(
name|exprNodeFuncDesc
operator|)
name|desc
decl_stmt|;
if|if
condition|(
name|funcDesc
operator|.
name|getUDFClass
argument_list|()
operator|.
name|equals
argument_list|(
name|UDFOPPositive
operator|.
name|class
argument_list|)
condition|)
block|{
assert|assert
operator|(
name|funcDesc
operator|.
name|getChildren
argument_list|()
operator|.
name|size
argument_list|()
operator|==
literal|1
operator|)
assert|;
name|desc
operator|=
name|funcDesc
operator|.
name|getChildren
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
assert|assert
operator|(
name|desc
operator|!=
literal|null
operator|)
assert|;
return|return
name|desc
return|;
block|}
annotation|@
name|Override
specifier|public
name|Object
name|process
parameter_list|(
name|Node
name|nd
parameter_list|,
name|Stack
argument_list|<
name|Node
argument_list|>
name|stack
parameter_list|,
name|NodeProcessorCtx
name|procCtx
parameter_list|,
name|Object
modifier|...
name|nodeOutputs
parameter_list|)
throws|throws
name|SemanticException
block|{
name|ASTNode
name|expr
init|=
operator|(
name|ASTNode
operator|)
name|nd
decl_stmt|;
comment|// Return nulls for conversion operators
if|if
condition|(
name|conversionFunctionTextHashMap
operator|.
name|keySet
argument_list|()
operator|.
name|contains
argument_list|(
name|expr
operator|.
name|getType
argument_list|()
argument_list|)
operator|||
name|specialFunctionTextHashMap
operator|.
name|keySet
argument_list|()
operator|.
name|contains
argument_list|(
name|expr
operator|.
name|getType
argument_list|()
argument_list|)
operator|||
name|expr
operator|.
name|getToken
argument_list|()
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|CharSetName
operator|||
name|expr
operator|.
name|getToken
argument_list|()
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|CharSetLiteral
condition|)
block|{
return|return
literal|null
return|;
block|}
name|exprNodeDesc
name|desc
init|=
name|TypeCheckProcFactory
operator|.
name|processGByExpr
argument_list|(
name|nd
argument_list|,
name|procCtx
argument_list|)
decl_stmt|;
if|if
condition|(
name|desc
operator|!=
literal|null
condition|)
block|{
return|return
name|desc
return|;
block|}
name|boolean
name|isFunction
init|=
operator|(
name|expr
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_FUNCTION
operator|)
decl_stmt|;
comment|// Create all children
name|int
name|childrenBegin
init|=
operator|(
name|isFunction
condition|?
literal|1
else|:
literal|0
operator|)
decl_stmt|;
name|ArrayList
argument_list|<
name|exprNodeDesc
argument_list|>
name|children
init|=
operator|new
name|ArrayList
argument_list|<
name|exprNodeDesc
argument_list|>
argument_list|(
name|expr
operator|.
name|getChildCount
argument_list|()
operator|-
name|childrenBegin
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|ci
init|=
name|childrenBegin
init|;
name|ci
operator|<
name|expr
operator|.
name|getChildCount
argument_list|()
condition|;
name|ci
operator|++
control|)
block|{
name|children
operator|.
name|add
argument_list|(
operator|(
name|exprNodeDesc
operator|)
name|nodeOutputs
index|[
name|ci
index|]
argument_list|)
expr_stmt|;
block|}
comment|// If any of the children contains null, then return a null
comment|// this is a hack for now to handle the group by case
if|if
condition|(
name|children
operator|.
name|contains
argument_list|(
literal|null
argument_list|)
condition|)
block|{
return|return
literal|null
return|;
block|}
comment|// Create function desc
return|return
name|getXpathOrFuncExprNodeDesc
argument_list|(
name|expr
argument_list|,
name|isFunction
argument_list|,
name|children
argument_list|)
return|;
block|}
block|}
comment|/**    * Factory method to get DefaultExprProcessor.    * @return DefaultExprProcessor.    */
specifier|public
specifier|static
name|DefaultExprProcessor
name|getDefaultExprProcessor
parameter_list|()
block|{
return|return
operator|new
name|DefaultExprProcessor
argument_list|()
return|;
block|}
block|}
end_class

end_unit

