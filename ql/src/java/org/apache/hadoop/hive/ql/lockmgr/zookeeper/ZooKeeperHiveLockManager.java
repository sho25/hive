begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|lockmgr
operator|.
name|zookeeper
package|;
end_package

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|VisibleForTesting
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|common
operator|.
name|metrics
operator|.
name|common
operator|.
name|Metrics
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|common
operator|.
name|metrics
operator|.
name|common
operator|.
name|MetricsConstant
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|common
operator|.
name|metrics
operator|.
name|common
operator|.
name|MetricsFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|conf
operator|.
name|HiveConf
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|Driver
operator|.
name|DriverState
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|Driver
operator|.
name|LockedDriverState
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|ErrorMsg
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|lockmgr
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|lockmgr
operator|.
name|HiveLockObject
operator|.
name|HiveLockObjectData
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|metadata
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|session
operator|.
name|SessionState
operator|.
name|LogHelper
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|zookeeper
operator|.
name|CreateMode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|zookeeper
operator|.
name|KeeperException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|curator
operator|.
name|framework
operator|.
name|CuratorFramework
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|InetAddress
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|*
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|TimeUnit
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|regex
operator|.
name|Matcher
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|regex
operator|.
name|Pattern
import|;
end_import

begin_class
specifier|public
class|class
name|ZooKeeperHiveLockManager
implements|implements
name|HiveLockManager
block|{
name|HiveLockManagerCtx
name|ctx
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|Logger
name|LOG
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
literal|"ZooKeeperHiveLockManager"
argument_list|)
decl_stmt|;
specifier|static
specifier|final
specifier|private
name|LogHelper
name|console
init|=
operator|new
name|LogHelper
argument_list|(
name|LOG
argument_list|)
decl_stmt|;
specifier|private
specifier|static
name|CuratorFramework
name|curatorFramework
decl_stmt|;
comment|// All the locks are created under this parent
specifier|private
name|String
name|parent
decl_stmt|;
specifier|private
name|long
name|sleepTime
decl_stmt|;
specifier|private
name|int
name|numRetriesForLock
decl_stmt|;
specifier|private
name|int
name|numRetriesForUnLock
decl_stmt|;
specifier|private
specifier|static
name|String
name|clientIp
decl_stmt|;
static|static
block|{
name|clientIp
operator|=
literal|"UNKNOWN"
expr_stmt|;
try|try
block|{
name|InetAddress
name|clientAddr
init|=
name|InetAddress
operator|.
name|getLocalHost
argument_list|()
decl_stmt|;
name|clientIp
operator|=
name|clientAddr
operator|.
name|getHostAddress
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e1
parameter_list|)
block|{     }
block|}
specifier|public
name|ZooKeeperHiveLockManager
parameter_list|()
block|{   }
comment|/**    * @param ctx  The lock manager context (containing the Hive configuration file)    * Start the ZooKeeper client based on the zookeeper cluster specified in the conf.    **/
annotation|@
name|Override
specifier|public
name|void
name|setContext
parameter_list|(
name|HiveLockManagerCtx
name|ctx
parameter_list|)
throws|throws
name|LockException
block|{
name|this
operator|.
name|ctx
operator|=
name|ctx
expr_stmt|;
name|HiveConf
name|conf
init|=
name|ctx
operator|.
name|getConf
argument_list|()
decl_stmt|;
name|sleepTime
operator|=
name|conf
operator|.
name|getTimeVar
argument_list|(
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVE_LOCK_SLEEP_BETWEEN_RETRIES
argument_list|,
name|TimeUnit
operator|.
name|MILLISECONDS
argument_list|)
expr_stmt|;
name|numRetriesForLock
operator|=
name|conf
operator|.
name|getIntVar
argument_list|(
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVE_LOCK_NUMRETRIES
argument_list|)
expr_stmt|;
name|numRetriesForUnLock
operator|=
name|conf
operator|.
name|getIntVar
argument_list|(
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVE_UNLOCK_NUMRETRIES
argument_list|)
expr_stmt|;
try|try
block|{
name|curatorFramework
operator|=
name|CuratorFrameworkSingleton
operator|.
name|getInstance
argument_list|(
name|conf
argument_list|)
expr_stmt|;
name|parent
operator|=
name|conf
operator|.
name|getVar
argument_list|(
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVE_ZOOKEEPER_NAMESPACE
argument_list|)
expr_stmt|;
try|try
block|{
name|curatorFramework
operator|.
name|create
argument_list|()
operator|.
name|withMode
argument_list|(
name|CreateMode
operator|.
name|PERSISTENT
argument_list|)
operator|.
name|forPath
argument_list|(
literal|"/"
operator|+
name|parent
argument_list|,
operator|new
name|byte
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
comment|// ignore if the parent already exists
if|if
condition|(
operator|!
operator|(
name|e
operator|instanceof
name|KeeperException
operator|)
operator|||
operator|(
operator|(
name|KeeperException
operator|)
name|e
operator|)
operator|.
name|code
argument_list|()
operator|!=
name|KeeperException
operator|.
name|Code
operator|.
name|NODEEXISTS
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Unexpected ZK exception when creating parent node /"
operator|+
name|parent
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Failed to create curatorFramework object: "
argument_list|,
name|e
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|LockException
argument_list|(
name|ErrorMsg
operator|.
name|ZOOKEEPER_CLIENT_COULD_NOT_BE_INITIALIZED
operator|.
name|getMsg
argument_list|()
argument_list|)
throw|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|void
name|refresh
parameter_list|()
block|{
name|HiveConf
name|conf
init|=
name|ctx
operator|.
name|getConf
argument_list|()
decl_stmt|;
name|sleepTime
operator|=
name|conf
operator|.
name|getTimeVar
argument_list|(
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVE_LOCK_SLEEP_BETWEEN_RETRIES
argument_list|,
name|TimeUnit
operator|.
name|MILLISECONDS
argument_list|)
expr_stmt|;
name|numRetriesForLock
operator|=
name|conf
operator|.
name|getIntVar
argument_list|(
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVE_LOCK_NUMRETRIES
argument_list|)
expr_stmt|;
name|numRetriesForUnLock
operator|=
name|conf
operator|.
name|getIntVar
argument_list|(
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVE_UNLOCK_NUMRETRIES
argument_list|)
expr_stmt|;
block|}
comment|/**    * @param key    object to be locked    * Get the name of the last string. For eg. if you need to lock db/T/ds=1=/hr=1,    * the last name would be db/T/ds=1/hr=1    **/
specifier|private
specifier|static
name|String
name|getLastObjectName
parameter_list|(
name|String
name|parent
parameter_list|,
name|HiveLockObject
name|key
parameter_list|)
block|{
return|return
literal|"/"
operator|+
name|parent
operator|+
literal|"/"
operator|+
name|key
operator|.
name|getName
argument_list|()
return|;
block|}
comment|/**    * @param key    object to be locked    * Get the list of names for all the parents.    * For eg: if you need to lock db/T/ds=1/hr=1, the following list will be returned:    * {db, db/T, db/T/ds=1, db/T/ds=1/hr=1}    **/
specifier|private
name|List
argument_list|<
name|String
argument_list|>
name|getObjectNames
parameter_list|(
name|HiveLockObject
name|key
parameter_list|)
block|{
name|List
argument_list|<
name|String
argument_list|>
name|parents
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
name|String
name|curParent
init|=
literal|"/"
operator|+
name|parent
operator|+
literal|"/"
decl_stmt|;
name|String
index|[]
name|names
init|=
name|key
operator|.
name|getName
argument_list|()
operator|.
name|split
argument_list|(
literal|"/"
argument_list|)
decl_stmt|;
for|for
control|(
name|String
name|name
range|:
name|names
control|)
block|{
name|curParent
operator|=
name|curParent
operator|+
name|name
expr_stmt|;
name|parents
operator|.
name|add
argument_list|(
name|curParent
argument_list|)
expr_stmt|;
name|curParent
operator|=
name|curParent
operator|+
literal|"/"
expr_stmt|;
block|}
return|return
name|parents
return|;
block|}
comment|/**    * @param  lockObjects  List of objects and the modes of the locks requested    * @param  keepAlive    Whether the lock is to be persisted after the statement    *    * Acuire all the locks. Release all the locks and return null if any lock    * could not be acquired.    **/
annotation|@
name|Override
specifier|public
name|List
argument_list|<
name|HiveLock
argument_list|>
name|lock
parameter_list|(
name|List
argument_list|<
name|HiveLockObj
argument_list|>
name|lockObjects
parameter_list|,
name|boolean
name|keepAlive
parameter_list|,
name|LockedDriverState
name|lDrvState
parameter_list|)
throws|throws
name|LockException
block|{
comment|// Sort the objects first. You are guaranteed that if a partition is being locked,
comment|// the table has already been locked
name|Collections
operator|.
name|sort
argument_list|(
name|lockObjects
argument_list|,
operator|new
name|Comparator
argument_list|<
name|HiveLockObj
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|int
name|compare
parameter_list|(
name|HiveLockObj
name|o1
parameter_list|,
name|HiveLockObj
name|o2
parameter_list|)
block|{
name|int
name|cmp
init|=
name|o1
operator|.
name|getName
argument_list|()
operator|.
name|compareTo
argument_list|(
name|o2
operator|.
name|getName
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|cmp
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|o1
operator|.
name|getMode
argument_list|()
operator|==
name|o2
operator|.
name|getMode
argument_list|()
condition|)
block|{
return|return
name|cmp
return|;
block|}
comment|// EXCLUSIVE locks occur before SHARED locks
if|if
condition|(
name|o1
operator|.
name|getMode
argument_list|()
operator|==
name|HiveLockMode
operator|.
name|EXCLUSIVE
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
return|return
operator|+
literal|1
return|;
block|}
return|return
name|cmp
return|;
block|}
block|}
argument_list|)
expr_stmt|;
comment|// walk the list and acquire the locks - if any lock cant be acquired, release all locks, sleep
comment|// and retry
name|HiveLockObj
name|prevLockObj
init|=
literal|null
decl_stmt|;
name|List
argument_list|<
name|HiveLock
argument_list|>
name|hiveLocks
init|=
operator|new
name|ArrayList
argument_list|<
name|HiveLock
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|HiveLockObj
name|lockObject
range|:
name|lockObjects
control|)
block|{
comment|// No need to acquire a lock twice on the same object
comment|// It is ensured that EXCLUSIVE locks occur before SHARED locks on the same object
if|if
condition|(
operator|(
name|prevLockObj
operator|!=
literal|null
operator|)
operator|&&
operator|(
name|prevLockObj
operator|.
name|getName
argument_list|()
operator|.
name|equals
argument_list|(
name|lockObject
operator|.
name|getName
argument_list|()
argument_list|)
operator|)
condition|)
block|{
name|prevLockObj
operator|=
name|lockObject
expr_stmt|;
continue|continue;
block|}
name|HiveLock
name|lock
init|=
literal|null
decl_stmt|;
name|boolean
name|isInterrupted
init|=
literal|false
decl_stmt|;
if|if
condition|(
name|lDrvState
operator|!=
literal|null
condition|)
block|{
name|lDrvState
operator|.
name|stateLock
operator|.
name|lock
argument_list|()
expr_stmt|;
if|if
condition|(
name|lDrvState
operator|.
name|driverState
operator|==
name|DriverState
operator|.
name|INTERRUPT
condition|)
block|{
name|isInterrupted
operator|=
literal|true
expr_stmt|;
block|}
name|lDrvState
operator|.
name|stateLock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|isInterrupted
condition|)
block|{
try|try
block|{
name|lock
operator|=
name|lock
argument_list|(
name|lockObject
operator|.
name|getObj
argument_list|()
argument_list|,
name|lockObject
operator|.
name|getMode
argument_list|()
argument_list|,
name|keepAlive
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|LockException
name|e
parameter_list|)
block|{
name|console
operator|.
name|printError
argument_list|(
literal|"Error in acquireLocks..."
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|error
argument_list|(
literal|"Error in acquireLocks..."
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|lock
operator|=
literal|null
expr_stmt|;
block|}
block|}
if|if
condition|(
name|lock
operator|==
literal|null
condition|)
block|{
name|releaseLocks
argument_list|(
name|hiveLocks
argument_list|)
expr_stmt|;
if|if
condition|(
name|isInterrupted
condition|)
block|{
throw|throw
operator|new
name|LockException
argument_list|(
name|ErrorMsg
operator|.
name|LOCK_ACQUIRE_CANCELLED
operator|.
name|getMsg
argument_list|()
argument_list|)
throw|;
block|}
return|return
literal|null
return|;
block|}
name|hiveLocks
operator|.
name|add
argument_list|(
name|lock
argument_list|)
expr_stmt|;
name|prevLockObj
operator|=
name|lockObject
expr_stmt|;
block|}
return|return
name|hiveLocks
return|;
block|}
comment|/**    * @param hiveLocks    *          list of hive locks to be released Release all the locks specified. If some of the    *          locks have already been released, ignore them    **/
annotation|@
name|Override
specifier|public
name|void
name|releaseLocks
parameter_list|(
name|List
argument_list|<
name|HiveLock
argument_list|>
name|hiveLocks
parameter_list|)
block|{
if|if
condition|(
name|hiveLocks
operator|!=
literal|null
condition|)
block|{
name|int
name|len
init|=
name|hiveLocks
operator|.
name|size
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|pos
init|=
name|len
operator|-
literal|1
init|;
name|pos
operator|>=
literal|0
condition|;
name|pos
operator|--
control|)
block|{
name|HiveLock
name|hiveLock
init|=
name|hiveLocks
operator|.
name|get
argument_list|(
name|pos
argument_list|)
decl_stmt|;
try|try
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"About to release lock for {}"
argument_list|,
name|hiveLock
operator|.
name|getHiveLockObject
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
name|unlock
argument_list|(
name|hiveLock
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|LockException
name|e
parameter_list|)
block|{
comment|// The lock may have been released. Ignore and continue
name|LOG
operator|.
name|warn
argument_list|(
literal|"Error when releasing lock"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/**    * @param key    *          The object to be locked    * @param mode    *          The mode of the lock    * @param keepAlive    *          Whether the lock is to be persisted after the statement Acquire the    *          lock. Return null if a conflicting lock is present.    **/
annotation|@
name|Override
specifier|public
name|ZooKeeperHiveLock
name|lock
parameter_list|(
name|HiveLockObject
name|key
parameter_list|,
name|HiveLockMode
name|mode
parameter_list|,
name|boolean
name|keepAlive
parameter_list|)
throws|throws
name|LockException
block|{
return|return
name|lock
argument_list|(
name|key
argument_list|,
name|mode
argument_list|,
name|keepAlive
argument_list|,
literal|false
argument_list|)
return|;
block|}
comment|/**    * @param name    *          The name of the zookeeper child    * @param data    *          The data for the zookeeper child    * @param mode    *          The mode in which the child needs to be created    * @throws KeeperException    * @throws InterruptedException    **/
specifier|private
name|String
name|createChild
parameter_list|(
name|String
name|name
parameter_list|,
name|byte
index|[]
name|data
parameter_list|,
name|CreateMode
name|mode
parameter_list|)
throws|throws
name|Exception
block|{
return|return
name|curatorFramework
operator|.
name|create
argument_list|()
operator|.
name|withMode
argument_list|(
name|mode
argument_list|)
operator|.
name|forPath
argument_list|(
name|name
argument_list|,
name|data
argument_list|)
return|;
block|}
specifier|private
name|String
name|getLockName
parameter_list|(
name|String
name|parent
parameter_list|,
name|HiveLockMode
name|mode
parameter_list|)
block|{
return|return
name|parent
operator|+
literal|"/"
operator|+
literal|"LOCK-"
operator|+
name|mode
operator|+
literal|"-"
return|;
block|}
specifier|private
name|ZooKeeperHiveLock
name|lock
parameter_list|(
name|HiveLockObject
name|key
parameter_list|,
name|HiveLockMode
name|mode
parameter_list|,
name|boolean
name|keepAlive
parameter_list|,
name|boolean
name|parentCreated
parameter_list|)
throws|throws
name|LockException
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Acquiring lock for {} with mode {}"
argument_list|,
name|key
operator|.
name|getName
argument_list|()
argument_list|,
name|key
operator|.
name|getData
argument_list|()
operator|.
name|getLockMode
argument_list|()
argument_list|)
expr_stmt|;
name|int
name|tryNum
init|=
literal|0
decl_stmt|;
name|ZooKeeperHiveLock
name|ret
init|=
literal|null
decl_stmt|;
name|Set
argument_list|<
name|String
argument_list|>
name|conflictingLocks
init|=
operator|new
name|HashSet
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
name|Exception
name|lastException
init|=
literal|null
decl_stmt|;
do|do
block|{
name|lastException
operator|=
literal|null
expr_stmt|;
name|tryNum
operator|++
expr_stmt|;
try|try
block|{
if|if
condition|(
name|tryNum
operator|>
literal|1
condition|)
block|{
name|Thread
operator|.
name|sleep
argument_list|(
name|sleepTime
argument_list|)
expr_stmt|;
name|prepareRetry
argument_list|()
expr_stmt|;
block|}
name|ret
operator|=
name|lockPrimitive
argument_list|(
name|key
argument_list|,
name|mode
argument_list|,
name|keepAlive
argument_list|,
name|parentCreated
argument_list|,
name|conflictingLocks
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|null
condition|)
block|{
break|break;
block|}
block|}
catch|catch
parameter_list|(
name|Exception
name|e1
parameter_list|)
block|{
name|lastException
operator|=
name|e1
expr_stmt|;
if|if
condition|(
name|e1
operator|instanceof
name|KeeperException
condition|)
block|{
name|KeeperException
name|e
init|=
operator|(
name|KeeperException
operator|)
name|e1
decl_stmt|;
switch|switch
condition|(
name|e
operator|.
name|code
argument_list|()
condition|)
block|{
case|case
name|CONNECTIONLOSS
case|:
case|case
name|OPERATIONTIMEOUT
case|:
case|case
name|NONODE
case|:
case|case
name|NODEEXISTS
case|:
name|LOG
operator|.
name|debug
argument_list|(
literal|"Possibly transient ZooKeeper exception: "
argument_list|,
name|e
argument_list|)
expr_stmt|;
break|break;
default|default:
name|LOG
operator|.
name|error
argument_list|(
literal|"Serious Zookeeper exception: "
argument_list|,
name|e
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
else|else
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Other unexpected exception: "
argument_list|,
name|e1
argument_list|)
expr_stmt|;
block|}
block|}
block|}
do|while
condition|(
name|tryNum
operator|<
name|numRetriesForLock
condition|)
do|;
if|if
condition|(
name|ret
operator|==
literal|null
condition|)
block|{
name|console
operator|.
name|printError
argument_list|(
literal|"Unable to acquire "
operator|+
name|key
operator|.
name|getData
argument_list|()
operator|.
name|getLockMode
argument_list|()
operator|+
literal|", "
operator|+
name|mode
operator|+
literal|" lock "
operator|+
name|key
operator|.
name|getDisplayName
argument_list|()
operator|+
literal|" after "
operator|+
name|tryNum
operator|+
literal|" attempts."
argument_list|)
expr_stmt|;
name|printConflictingLocks
argument_list|(
name|key
argument_list|,
name|mode
argument_list|,
name|conflictingLocks
argument_list|)
expr_stmt|;
if|if
condition|(
name|lastException
operator|!=
literal|null
condition|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Exceeds maximum retries with errors: "
argument_list|,
name|lastException
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|LockException
argument_list|(
name|lastException
argument_list|)
throw|;
block|}
block|}
return|return
name|ret
return|;
block|}
specifier|private
name|void
name|printConflictingLocks
parameter_list|(
name|HiveLockObject
name|key
parameter_list|,
name|HiveLockMode
name|mode
parameter_list|,
name|Set
argument_list|<
name|String
argument_list|>
name|conflictingLocks
parameter_list|)
block|{
if|if
condition|(
operator|!
name|conflictingLocks
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|HiveLockObjectData
name|requestedLock
init|=
operator|new
name|HiveLockObjectData
argument_list|(
name|key
operator|.
name|getData
argument_list|()
operator|.
name|toString
argument_list|()
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Requested lock "
operator|+
name|key
operator|.
name|getDisplayName
argument_list|()
operator|+
literal|":: mode:"
operator|+
name|requestedLock
operator|.
name|getLockMode
argument_list|()
operator|+
literal|","
operator|+
name|mode
operator|+
literal|"; query:"
operator|+
name|requestedLock
operator|.
name|getQueryStr
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|String
name|conflictingLock
range|:
name|conflictingLocks
control|)
block|{
name|HiveLockObjectData
name|conflictingLockData
init|=
operator|new
name|HiveLockObjectData
argument_list|(
name|conflictingLock
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Conflicting lock to "
operator|+
name|key
operator|.
name|getDisplayName
argument_list|()
operator|+
literal|":: mode:"
operator|+
name|conflictingLockData
operator|.
name|getLockMode
argument_list|()
operator|+
literal|";query:"
operator|+
name|conflictingLockData
operator|.
name|getQueryStr
argument_list|()
operator|+
literal|";queryId:"
operator|+
name|conflictingLockData
operator|.
name|getQueryId
argument_list|()
operator|+
literal|";clientIp:"
operator|+
name|conflictingLockData
operator|.
name|getClientIp
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**    * Creates a primitive lock object on ZooKeeper.    * @param key The lock data    * @param mode The lock mode (HiveLockMode - EXCLUSIVE/SHARED/SEMI_SHARED)    * @param keepAlive If true creating PERSISTENT ZooKeeper locks, otherwise EPHEMERAL ZooKeeper    *                  locks    * @param parentCreated If we expect, that the parent is already created then true, otherwise    *                      we will try to create the parents as well    * @param conflictingLocks The set where we should collect the conflicting locks when    *                         the logging level is set to DEBUG    * @return The created ZooKeeperHiveLock object, null if there was a conflicting lock    * @throws Exception If there was an unexpected Exception    */
specifier|private
name|ZooKeeperHiveLock
name|lockPrimitive
parameter_list|(
name|HiveLockObject
name|key
parameter_list|,
name|HiveLockMode
name|mode
parameter_list|,
name|boolean
name|keepAlive
parameter_list|,
name|boolean
name|parentCreated
parameter_list|,
name|Set
argument_list|<
name|String
argument_list|>
name|conflictingLocks
parameter_list|)
throws|throws
name|Exception
block|{
name|String
name|res
decl_stmt|;
comment|// If the parents have already been created, create the last child only
name|List
argument_list|<
name|String
argument_list|>
name|names
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
name|String
name|lastName
decl_stmt|;
name|HiveLockObjectData
name|lockData
init|=
name|key
operator|.
name|getData
argument_list|()
decl_stmt|;
name|lockData
operator|.
name|setClientIp
argument_list|(
name|clientIp
argument_list|)
expr_stmt|;
if|if
condition|(
name|parentCreated
condition|)
block|{
name|lastName
operator|=
name|getLastObjectName
argument_list|(
name|parent
argument_list|,
name|key
argument_list|)
expr_stmt|;
name|names
operator|.
name|add
argument_list|(
name|lastName
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|names
operator|=
name|getObjectNames
argument_list|(
name|key
argument_list|)
expr_stmt|;
name|lastName
operator|=
name|names
operator|.
name|get
argument_list|(
name|names
operator|.
name|size
argument_list|()
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
comment|// Create the parents first
for|for
control|(
name|String
name|name
range|:
name|names
control|)
block|{
try|try
block|{
name|res
operator|=
name|createChild
argument_list|(
name|name
argument_list|,
operator|new
name|byte
index|[
literal|0
index|]
argument_list|,
name|CreateMode
operator|.
name|PERSISTENT
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|e
operator|instanceof
name|KeeperException
operator|)
operator|||
operator|(
operator|(
name|KeeperException
operator|)
name|e
operator|)
operator|.
name|code
argument_list|()
operator|!=
name|KeeperException
operator|.
name|Code
operator|.
name|NODEEXISTS
condition|)
block|{
comment|//if the exception is not 'NODEEXISTS', re-throw it
throw|throw
name|e
throw|;
block|}
block|}
block|}
name|res
operator|=
name|createChild
argument_list|(
name|getLockName
argument_list|(
name|lastName
argument_list|,
name|mode
argument_list|)
argument_list|,
name|key
operator|.
name|getData
argument_list|()
operator|.
name|toString
argument_list|()
operator|.
name|getBytes
argument_list|()
argument_list|,
name|keepAlive
condition|?
name|CreateMode
operator|.
name|PERSISTENT_SEQUENTIAL
else|:
name|CreateMode
operator|.
name|EPHEMERAL_SEQUENTIAL
argument_list|)
expr_stmt|;
name|int
name|seqNo
init|=
name|getSequenceNumber
argument_list|(
name|res
argument_list|,
name|getLockName
argument_list|(
name|lastName
argument_list|,
name|mode
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|seqNo
operator|==
operator|-
literal|1
condition|)
block|{
name|curatorFramework
operator|.
name|delete
argument_list|()
operator|.
name|forPath
argument_list|(
name|res
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|LockException
argument_list|(
literal|"The created node does not contain a sequence number: "
operator|+
name|res
argument_list|)
throw|;
block|}
name|List
argument_list|<
name|String
argument_list|>
name|children
init|=
name|curatorFramework
operator|.
name|getChildren
argument_list|()
operator|.
name|forPath
argument_list|(
name|lastName
argument_list|)
decl_stmt|;
name|String
name|exLock
init|=
name|getLockName
argument_list|(
name|lastName
argument_list|,
name|HiveLockMode
operator|.
name|EXCLUSIVE
argument_list|)
decl_stmt|;
name|String
name|shLock
init|=
name|getLockName
argument_list|(
name|lastName
argument_list|,
name|HiveLockMode
operator|.
name|SHARED
argument_list|)
decl_stmt|;
for|for
control|(
name|String
name|child
range|:
name|children
control|)
block|{
name|child
operator|=
name|lastName
operator|+
literal|"/"
operator|+
name|child
expr_stmt|;
comment|// Is there a conflicting lock on the same object with a lower sequence
comment|// number
name|int
name|childSeq
init|=
name|seqNo
decl_stmt|;
if|if
condition|(
name|child
operator|.
name|startsWith
argument_list|(
name|exLock
argument_list|)
condition|)
block|{
name|childSeq
operator|=
name|getSequenceNumber
argument_list|(
name|child
argument_list|,
name|exLock
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|mode
operator|==
name|HiveLockMode
operator|.
name|EXCLUSIVE
operator|)
operator|&&
name|child
operator|.
name|startsWith
argument_list|(
name|shLock
argument_list|)
condition|)
block|{
name|childSeq
operator|=
name|getSequenceNumber
argument_list|(
name|child
argument_list|,
name|shLock
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|childSeq
operator|>=
literal|0
operator|)
operator|&&
operator|(
name|childSeq
operator|<
name|seqNo
operator|)
condition|)
block|{
try|try
block|{
name|curatorFramework
operator|.
name|delete
argument_list|()
operator|.
name|forPath
argument_list|(
name|res
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
try|try
block|{
name|String
name|data
init|=
operator|new
name|String
argument_list|(
name|curatorFramework
operator|.
name|getData
argument_list|()
operator|.
name|forPath
argument_list|(
name|child
argument_list|)
argument_list|)
decl_stmt|;
name|conflictingLocks
operator|.
name|add
argument_list|(
name|data
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
comment|//ignored
block|}
block|}
block|}
return|return
literal|null
return|;
block|}
block|}
name|Metrics
name|metrics
init|=
name|MetricsFactory
operator|.
name|getInstance
argument_list|()
decl_stmt|;
if|if
condition|(
name|metrics
operator|!=
literal|null
condition|)
block|{
try|try
block|{
switch|switch
condition|(
name|mode
condition|)
block|{
case|case
name|EXCLUSIVE
case|:
name|metrics
operator|.
name|incrementCounter
argument_list|(
name|MetricsConstant
operator|.
name|ZOOKEEPER_HIVE_EXCLUSIVELOCKS
argument_list|)
expr_stmt|;
break|break;
case|case
name|SEMI_SHARED
case|:
name|metrics
operator|.
name|incrementCounter
argument_list|(
name|MetricsConstant
operator|.
name|ZOOKEEPER_HIVE_SEMISHAREDLOCKS
argument_list|)
expr_stmt|;
break|break;
default|default:
name|metrics
operator|.
name|incrementCounter
argument_list|(
name|MetricsConstant
operator|.
name|ZOOKEEPER_HIVE_SHAREDLOCKS
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Error Reporting hive client zookeeper lock operation to Metrics system"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|new
name|ZooKeeperHiveLock
argument_list|(
name|res
argument_list|,
name|key
argument_list|,
name|mode
argument_list|)
return|;
block|}
comment|/* Remove the lock specified */
annotation|@
name|Override
specifier|public
name|void
name|unlock
parameter_list|(
name|HiveLock
name|hiveLock
parameter_list|)
throws|throws
name|LockException
block|{
name|unlockWithRetry
argument_list|(
name|hiveLock
argument_list|,
name|parent
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|unlockWithRetry
parameter_list|(
name|HiveLock
name|hiveLock
parameter_list|,
name|String
name|parent
parameter_list|)
throws|throws
name|LockException
block|{
name|int
name|tryNum
init|=
literal|0
decl_stmt|;
do|do
block|{
try|try
block|{
name|tryNum
operator|++
expr_stmt|;
if|if
condition|(
name|tryNum
operator|>
literal|1
condition|)
block|{
name|Thread
operator|.
name|sleep
argument_list|(
name|sleepTime
argument_list|)
expr_stmt|;
block|}
name|unlockPrimitive
argument_list|(
name|hiveLock
argument_list|,
name|parent
argument_list|,
name|curatorFramework
argument_list|)
expr_stmt|;
break|break;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
if|if
condition|(
name|tryNum
operator|>=
name|numRetriesForUnLock
condition|)
block|{
name|String
name|name
init|=
operator|(
operator|(
name|ZooKeeperHiveLock
operator|)
name|hiveLock
operator|)
operator|.
name|getPath
argument_list|()
decl_stmt|;
name|LOG
operator|.
name|error
argument_list|(
literal|"Node "
operator|+
name|name
operator|+
literal|" can not be deleted after "
operator|+
name|numRetriesForUnLock
operator|+
literal|" attempts."
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|LockException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
block|}
do|while
condition|(
name|tryNum
operator|<
name|numRetriesForUnLock
condition|)
do|;
return|return;
block|}
comment|/* Remove the lock specified */
annotation|@
name|VisibleForTesting
specifier|static
name|void
name|unlockPrimitive
parameter_list|(
name|HiveLock
name|hiveLock
parameter_list|,
name|String
name|parent
parameter_list|,
name|CuratorFramework
name|curatorFramework
parameter_list|)
throws|throws
name|LockException
block|{
name|ZooKeeperHiveLock
name|zLock
init|=
operator|(
name|ZooKeeperHiveLock
operator|)
name|hiveLock
decl_stmt|;
name|HiveLockMode
name|lMode
init|=
name|hiveLock
operator|.
name|getHiveLockMode
argument_list|()
decl_stmt|;
name|HiveLockObject
name|obj
init|=
name|zLock
operator|.
name|getHiveLockObject
argument_list|()
decl_stmt|;
name|String
name|name
init|=
name|getLastObjectName
argument_list|(
name|parent
argument_list|,
name|obj
argument_list|)
decl_stmt|;
try|try
block|{
comment|//catch InterruptedException to make sure locks can be released when the query is cancelled.
try|try
block|{
name|curatorFramework
operator|.
name|delete
argument_list|()
operator|.
name|forPath
argument_list|(
name|zLock
operator|.
name|getPath
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|ie
parameter_list|)
block|{
name|curatorFramework
operator|.
name|delete
argument_list|()
operator|.
name|forPath
argument_list|(
name|zLock
operator|.
name|getPath
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// Delete the parent node if all the children have been deleted
name|List
argument_list|<
name|String
argument_list|>
name|children
init|=
literal|null
decl_stmt|;
try|try
block|{
name|children
operator|=
name|curatorFramework
operator|.
name|getChildren
argument_list|()
operator|.
name|forPath
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|ie
parameter_list|)
block|{
name|children
operator|=
name|curatorFramework
operator|.
name|getChildren
argument_list|()
operator|.
name|forPath
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|children
operator|==
literal|null
operator|||
name|children
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
try|try
block|{
name|curatorFramework
operator|.
name|delete
argument_list|()
operator|.
name|forPath
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|ie
parameter_list|)
block|{
name|curatorFramework
operator|.
name|delete
argument_list|()
operator|.
name|forPath
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
block|}
name|Metrics
name|metrics
init|=
name|MetricsFactory
operator|.
name|getInstance
argument_list|()
decl_stmt|;
if|if
condition|(
name|metrics
operator|!=
literal|null
condition|)
block|{
try|try
block|{
switch|switch
condition|(
name|lMode
condition|)
block|{
case|case
name|EXCLUSIVE
case|:
name|metrics
operator|.
name|decrementCounter
argument_list|(
name|MetricsConstant
operator|.
name|ZOOKEEPER_HIVE_EXCLUSIVELOCKS
argument_list|)
expr_stmt|;
break|break;
case|case
name|SEMI_SHARED
case|:
name|metrics
operator|.
name|decrementCounter
argument_list|(
name|MetricsConstant
operator|.
name|ZOOKEEPER_HIVE_SEMISHAREDLOCKS
argument_list|)
expr_stmt|;
break|break;
default|default:
name|metrics
operator|.
name|decrementCounter
argument_list|(
name|MetricsConstant
operator|.
name|ZOOKEEPER_HIVE_SHAREDLOCKS
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Error Reporting hive client zookeeper unlock operation to Metrics system"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
block|}
catch|catch
parameter_list|(
name|KeeperException
operator|.
name|NoNodeException
name|nne
parameter_list|)
block|{
comment|//can happen in retrying deleting the zLock after exceptions like InterruptedException
comment|//or in a race condition where parent has already been deleted by other process when it
comment|//is to be deleted. Both cases should not raise error
name|LOG
operator|.
name|debug
argument_list|(
literal|"Node "
operator|+
name|zLock
operator|.
name|getPath
argument_list|()
operator|+
literal|" or its parent has already been deleted."
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|KeeperException
operator|.
name|NotEmptyException
name|nee
parameter_list|)
block|{
comment|//can happen in a race condition where another process adds a zLock under this parent
comment|//just before it is about to be deleted. It should not be a problem since this parent
comment|//can eventually be deleted by the process which hold its last child zLock
name|LOG
operator|.
name|debug
argument_list|(
literal|"Node "
operator|+
name|name
operator|+
literal|" to be deleted is not empty."
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
comment|//exceptions including InterruptException and other KeeperException
name|LOG
operator|.
name|error
argument_list|(
literal|"Failed to release ZooKeeper lock: "
argument_list|,
name|e
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|LockException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
comment|/* Release all locks - including PERSISTENT locks */
specifier|public
specifier|static
name|void
name|releaseAllLocks
parameter_list|(
name|HiveConf
name|conf
parameter_list|)
throws|throws
name|Exception
block|{
try|try
block|{
name|String
name|parent
init|=
name|conf
operator|.
name|getVar
argument_list|(
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVE_ZOOKEEPER_NAMESPACE
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|HiveLock
argument_list|>
name|locks
init|=
name|getLocks
argument_list|(
name|conf
argument_list|,
literal|null
argument_list|,
name|parent
argument_list|,
literal|false
argument_list|,
literal|false
argument_list|)
decl_stmt|;
name|Exception
name|lastExceptionGot
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|locks
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|HiveLock
name|lock
range|:
name|locks
control|)
block|{
try|try
block|{
name|unlockPrimitive
argument_list|(
name|lock
argument_list|,
name|parent
argument_list|,
name|curatorFramework
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|lastExceptionGot
operator|=
name|e
expr_stmt|;
block|}
block|}
block|}
comment|// if we got exception during doing the unlock, rethrow it here
if|if
condition|(
name|lastExceptionGot
operator|!=
literal|null
condition|)
block|{
throw|throw
name|lastExceptionGot
throw|;
block|}
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Failed to release all locks: "
argument_list|,
name|e
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|Exception
argument_list|(
name|ErrorMsg
operator|.
name|ZOOKEEPER_CLIENT_COULD_NOT_BE_INITIALIZED
operator|.
name|getMsg
argument_list|()
argument_list|)
throw|;
block|}
block|}
comment|/* Get all locks */
annotation|@
name|Override
specifier|public
name|List
argument_list|<
name|HiveLock
argument_list|>
name|getLocks
parameter_list|(
name|boolean
name|verifyTablePartition
parameter_list|,
name|boolean
name|fetchData
parameter_list|)
throws|throws
name|LockException
block|{
return|return
name|getLocks
argument_list|(
name|ctx
operator|.
name|getConf
argument_list|()
argument_list|,
literal|null
argument_list|,
name|parent
argument_list|,
name|verifyTablePartition
argument_list|,
name|fetchData
argument_list|)
return|;
block|}
comment|/* Get all locks for a particular object */
annotation|@
name|Override
specifier|public
name|List
argument_list|<
name|HiveLock
argument_list|>
name|getLocks
parameter_list|(
name|HiveLockObject
name|key
parameter_list|,
name|boolean
name|verifyTablePartitions
parameter_list|,
name|boolean
name|fetchData
parameter_list|)
throws|throws
name|LockException
block|{
return|return
name|getLocks
argument_list|(
name|ctx
operator|.
name|getConf
argument_list|()
argument_list|,
name|key
argument_list|,
name|parent
argument_list|,
name|verifyTablePartitions
argument_list|,
name|fetchData
argument_list|)
return|;
block|}
comment|/**    * @param conf        Hive configuration    * @param key         The object to be compared against - if key is null, then get all locks    **/
specifier|private
specifier|static
name|List
argument_list|<
name|HiveLock
argument_list|>
name|getLocks
parameter_list|(
name|HiveConf
name|conf
parameter_list|,
name|HiveLockObject
name|key
parameter_list|,
name|String
name|parent
parameter_list|,
name|boolean
name|verifyTablePartition
parameter_list|,
name|boolean
name|fetchData
parameter_list|)
throws|throws
name|LockException
block|{
name|List
argument_list|<
name|HiveLock
argument_list|>
name|locks
init|=
operator|new
name|ArrayList
argument_list|<
name|HiveLock
argument_list|>
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|children
decl_stmt|;
name|boolean
name|recurse
init|=
literal|true
decl_stmt|;
name|String
name|commonParent
decl_stmt|;
try|try
block|{
if|if
condition|(
name|key
operator|!=
literal|null
condition|)
block|{
name|commonParent
operator|=
literal|"/"
operator|+
name|parent
operator|+
literal|"/"
operator|+
name|key
operator|.
name|getName
argument_list|()
expr_stmt|;
name|children
operator|=
name|curatorFramework
operator|.
name|getChildren
argument_list|()
operator|.
name|forPath
argument_list|(
name|commonParent
argument_list|)
expr_stmt|;
name|recurse
operator|=
literal|false
expr_stmt|;
block|}
else|else
block|{
name|commonParent
operator|=
literal|"/"
operator|+
name|parent
expr_stmt|;
name|children
operator|=
name|curatorFramework
operator|.
name|getChildren
argument_list|()
operator|.
name|forPath
argument_list|(
name|commonParent
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
comment|// no locks present
return|return
name|locks
return|;
block|}
name|Queue
argument_list|<
name|String
argument_list|>
name|childn
init|=
operator|new
name|LinkedList
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
if|if
condition|(
name|children
operator|!=
literal|null
operator|&&
operator|!
name|children
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
for|for
control|(
name|String
name|child
range|:
name|children
control|)
block|{
name|childn
operator|.
name|add
argument_list|(
name|commonParent
operator|+
literal|"/"
operator|+
name|child
argument_list|)
expr_stmt|;
block|}
block|}
while|while
condition|(
literal|true
condition|)
block|{
name|String
name|curChild
init|=
name|childn
operator|.
name|poll
argument_list|()
decl_stmt|;
if|if
condition|(
name|curChild
operator|==
literal|null
condition|)
block|{
return|return
name|locks
return|;
block|}
if|if
condition|(
name|recurse
condition|)
block|{
try|try
block|{
name|children
operator|=
name|curatorFramework
operator|.
name|getChildren
argument_list|()
operator|.
name|forPath
argument_list|(
name|curChild
argument_list|)
expr_stmt|;
for|for
control|(
name|String
name|child
range|:
name|children
control|)
block|{
name|childn
operator|.
name|add
argument_list|(
name|curChild
operator|+
literal|"/"
operator|+
name|child
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
comment|// nothing to do
block|}
block|}
name|HiveLockMode
name|mode
init|=
name|getLockMode
argument_list|(
name|curChild
argument_list|)
decl_stmt|;
if|if
condition|(
name|mode
operator|==
literal|null
condition|)
block|{
continue|continue;
block|}
name|HiveLockObjectData
name|data
init|=
literal|null
decl_stmt|;
comment|// set the lock object with a dummy data, and then do a set if needed.
name|HiveLockObject
name|obj
init|=
name|getLockObject
argument_list|(
name|conf
argument_list|,
name|curChild
argument_list|,
name|mode
argument_list|,
name|data
argument_list|,
name|parent
argument_list|,
name|verifyTablePartition
argument_list|)
decl_stmt|;
if|if
condition|(
name|obj
operator|==
literal|null
condition|)
block|{
continue|continue;
block|}
if|if
condition|(
operator|(
name|key
operator|==
literal|null
operator|)
operator|||
operator|(
name|obj
operator|.
name|getName
argument_list|()
operator|.
name|equals
argument_list|(
name|key
operator|.
name|getName
argument_list|()
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|fetchData
condition|)
block|{
try|try
block|{
name|data
operator|=
operator|new
name|HiveLockObjectData
argument_list|(
operator|new
name|String
argument_list|(
name|curatorFramework
operator|.
name|getData
argument_list|()
operator|.
name|watched
argument_list|()
operator|.
name|forPath
argument_list|(
name|curChild
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|data
operator|.
name|setClientIp
argument_list|(
name|clientIp
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Error in getting data for "
operator|+
name|curChild
argument_list|,
name|e
argument_list|)
expr_stmt|;
comment|// ignore error
block|}
block|}
name|obj
operator|.
name|setData
argument_list|(
name|data
argument_list|)
expr_stmt|;
name|HiveLock
name|lck
init|=
operator|(
operator|new
name|ZooKeeperHiveLock
argument_list|(
name|curChild
argument_list|,
name|obj
argument_list|,
name|mode
argument_list|)
operator|)
decl_stmt|;
name|locks
operator|.
name|add
argument_list|(
name|lck
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/** Remove all redundant nodes **/
specifier|private
name|void
name|removeAllRedundantNodes
parameter_list|()
block|{
try|try
block|{
name|checkRedundantNode
argument_list|(
literal|"/"
operator|+
name|parent
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Exception while removing all redundant nodes"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|checkRedundantNode
parameter_list|(
name|String
name|node
parameter_list|)
block|{
try|try
block|{
comment|// Nothing to do if it is a lock mode
if|if
condition|(
name|getLockMode
argument_list|(
name|node
argument_list|)
operator|!=
literal|null
condition|)
block|{
return|return;
block|}
name|List
argument_list|<
name|String
argument_list|>
name|children
init|=
name|curatorFramework
operator|.
name|getChildren
argument_list|()
operator|.
name|forPath
argument_list|(
name|node
argument_list|)
decl_stmt|;
for|for
control|(
name|String
name|child
range|:
name|children
control|)
block|{
name|checkRedundantNode
argument_list|(
name|node
operator|+
literal|"/"
operator|+
name|child
argument_list|)
expr_stmt|;
block|}
name|children
operator|=
name|curatorFramework
operator|.
name|getChildren
argument_list|()
operator|.
name|forPath
argument_list|(
name|node
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|children
operator|==
literal|null
operator|)
operator|||
operator|(
name|children
operator|.
name|isEmpty
argument_list|()
operator|)
condition|)
block|{
name|curatorFramework
operator|.
name|delete
argument_list|()
operator|.
name|forPath
argument_list|(
name|node
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Error in checkRedundantNode for node "
operator|+
name|node
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Release all transient locks, by simply closing the client */
annotation|@
name|Override
specifier|public
name|void
name|close
parameter_list|()
throws|throws
name|LockException
block|{
try|try
block|{
if|if
condition|(
name|HiveConf
operator|.
name|getBoolVar
argument_list|(
name|ctx
operator|.
name|getConf
argument_list|()
argument_list|,
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVE_ZOOKEEPER_CLEAN_EXTRA_NODES
argument_list|)
condition|)
block|{
name|removeAllRedundantNodes
argument_list|()
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Failed to close zooKeeper client: "
operator|+
name|e
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|LockException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
comment|/**    * Get the sequence number from the path. The sequence number is always at the end of the path.    **/
specifier|private
name|int
name|getSequenceNumber
parameter_list|(
name|String
name|resPath
parameter_list|,
name|String
name|path
parameter_list|)
block|{
name|String
name|tst
init|=
name|resPath
operator|.
name|substring
argument_list|(
name|path
operator|.
name|length
argument_list|()
argument_list|)
decl_stmt|;
try|try
block|{
return|return
operator|(
operator|new
name|Integer
argument_list|(
name|tst
argument_list|)
operator|)
operator|.
name|intValue
argument_list|()
return|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
return|return
operator|-
literal|1
return|;
comment|// invalid number
block|}
block|}
comment|/**    * Get the object from the path of the lock.    * The object may correspond to a table, a partition or a parent to a partition.    * For eg: if Table T is partitioned by ds, hr and ds=1/hr=1 is a valid partition,    * the lock may also correspond to T@ds=1, which is not a valid object    * @param verifyTablePartition    **/
specifier|private
specifier|static
name|HiveLockObject
name|getLockObject
parameter_list|(
name|HiveConf
name|conf
parameter_list|,
name|String
name|path
parameter_list|,
name|HiveLockMode
name|mode
parameter_list|,
name|HiveLockObjectData
name|data
parameter_list|,
name|String
name|parent
parameter_list|,
name|boolean
name|verifyTablePartition
parameter_list|)
throws|throws
name|LockException
block|{
try|try
block|{
name|Hive
name|db
init|=
name|Hive
operator|.
name|get
argument_list|(
name|conf
argument_list|)
decl_stmt|;
name|int
name|indx
init|=
name|path
operator|.
name|lastIndexOf
argument_list|(
literal|"LOCK-"
operator|+
name|mode
operator|.
name|toString
argument_list|()
argument_list|)
decl_stmt|;
name|String
name|objName
init|=
name|path
operator|.
name|substring
argument_list|(
operator|(
literal|"/"
operator|+
name|parent
operator|+
literal|"/"
operator|)
operator|.
name|length
argument_list|()
argument_list|,
name|indx
operator|-
literal|1
argument_list|)
decl_stmt|;
name|String
index|[]
name|names
init|=
name|objName
operator|.
name|split
argument_list|(
literal|"/"
argument_list|)
decl_stmt|;
if|if
condition|(
name|names
operator|.
name|length
operator|<
literal|2
condition|)
block|{
return|return
literal|null
return|;
block|}
if|if
condition|(
operator|!
name|verifyTablePartition
condition|)
block|{
return|return
operator|new
name|HiveLockObject
argument_list|(
name|names
argument_list|,
name|data
argument_list|)
return|;
block|}
comment|// do not throw exception if table does not exist
name|Table
name|tab
init|=
name|db
operator|.
name|getTable
argument_list|(
name|names
index|[
literal|0
index|]
argument_list|,
name|names
index|[
literal|1
index|]
argument_list|,
literal|false
argument_list|)
decl_stmt|;
if|if
condition|(
name|tab
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
if|if
condition|(
name|names
operator|.
name|length
operator|==
literal|2
condition|)
block|{
return|return
operator|new
name|HiveLockObject
argument_list|(
name|tab
argument_list|,
name|data
argument_list|)
return|;
block|}
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|partSpec
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|indx
operator|=
literal|2
init|;
name|indx
operator|<
name|names
operator|.
name|length
condition|;
name|indx
operator|++
control|)
block|{
name|String
index|[]
name|partVals
init|=
name|names
index|[
name|indx
index|]
operator|.
name|split
argument_list|(
literal|"="
argument_list|)
decl_stmt|;
name|partSpec
operator|.
name|put
argument_list|(
name|partVals
index|[
literal|0
index|]
argument_list|,
name|partVals
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
name|Partition
name|partn
decl_stmt|;
try|try
block|{
name|partn
operator|=
name|db
operator|.
name|getPartition
argument_list|(
name|tab
argument_list|,
name|partSpec
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|HiveException
name|e
parameter_list|)
block|{
name|partn
operator|=
literal|null
expr_stmt|;
block|}
if|if
condition|(
name|partn
operator|==
literal|null
condition|)
block|{
return|return
operator|new
name|HiveLockObject
argument_list|(
operator|new
name|DummyPartition
argument_list|(
name|tab
argument_list|,
name|path
argument_list|,
name|partSpec
argument_list|)
argument_list|,
name|data
argument_list|)
return|;
block|}
return|return
operator|new
name|HiveLockObject
argument_list|(
name|partn
argument_list|,
name|data
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Failed to create ZooKeeper object: "
operator|+
name|e
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|LockException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
specifier|private
specifier|static
name|Pattern
name|shMode
init|=
name|Pattern
operator|.
name|compile
argument_list|(
literal|"^.*-(SHARED)-([0-9]+)$"
argument_list|)
decl_stmt|;
specifier|private
specifier|static
name|Pattern
name|exMode
init|=
name|Pattern
operator|.
name|compile
argument_list|(
literal|"^.*-(EXCLUSIVE)-([0-9]+)$"
argument_list|)
decl_stmt|;
comment|/* Get the mode of the lock encoded in the path */
specifier|private
specifier|static
name|HiveLockMode
name|getLockMode
parameter_list|(
name|String
name|path
parameter_list|)
block|{
name|Matcher
name|shMatcher
init|=
name|shMode
operator|.
name|matcher
argument_list|(
name|path
argument_list|)
decl_stmt|;
name|Matcher
name|exMatcher
init|=
name|exMode
operator|.
name|matcher
argument_list|(
name|path
argument_list|)
decl_stmt|;
if|if
condition|(
name|shMatcher
operator|.
name|matches
argument_list|()
condition|)
block|{
return|return
name|HiveLockMode
operator|.
name|SHARED
return|;
block|}
if|if
condition|(
name|exMatcher
operator|.
name|matches
argument_list|()
condition|)
block|{
return|return
name|HiveLockMode
operator|.
name|EXCLUSIVE
return|;
block|}
return|return
literal|null
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|prepareRetry
parameter_list|()
throws|throws
name|LockException
block|{   }
block|}
end_class

end_unit

