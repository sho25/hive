begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|parse
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|Serializable
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|UnsupportedEncodingException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|sql
operator|.
name|Date
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|LinkedHashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|LinkedHashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
operator|.
name|Entry
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Properties
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|org
operator|.
name|antlr
operator|.
name|runtime
operator|.
name|tree
operator|.
name|Tree
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|lang3
operator|.
name|StringUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|lang3
operator|.
name|tuple
operator|.
name|Pair
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|Path
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|common
operator|.
name|FileUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|conf
operator|.
name|HiveConf
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|metastore
operator|.
name|HiveMetaStore
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|metastore
operator|.
name|api
operator|.
name|Database
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|metastore
operator|.
name|api
operator|.
name|FieldSchema
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|metastore
operator|.
name|api
operator|.
name|Order
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|metastore
operator|.
name|api
operator|.
name|SQLForeignKey
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|metastore
operator|.
name|api
operator|.
name|SQLNotNullConstraint
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|metastore
operator|.
name|api
operator|.
name|SQLPrimaryKey
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|metastore
operator|.
name|api
operator|.
name|SQLUniqueConstraint
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|CompilationOpContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|Context
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|ErrorMsg
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|QueryProperties
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|QueryState
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|FetchTask
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|Task
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|TaskFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|Utilities
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|hooks
operator|.
name|LineageInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|hooks
operator|.
name|ReadEntity
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|hooks
operator|.
name|WriteEntity
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|io
operator|.
name|IgnoreKeyTextOutputFormat
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|lib
operator|.
name|Node
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|metadata
operator|.
name|Hive
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|metadata
operator|.
name|HiveException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|metadata
operator|.
name|InvalidTableException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|metadata
operator|.
name|Partition
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|metadata
operator|.
name|Table
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|metadata
operator|.
name|VirtualColumn
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|optimizer
operator|.
name|listbucketingpruner
operator|.
name|ListBucketingPrunerUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|ExprNodeConstantDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|ExprNodeDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|FetchWork
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|FileSinkDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|ListBucketingCtx
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|PlanUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|TableDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|session
operator|.
name|SessionState
operator|.
name|LogHelper
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde
operator|.
name|serdeConstants
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|io
operator|.
name|DateWritable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|lazy
operator|.
name|LazySimpleSerDe
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|objectinspector
operator|.
name|ObjectInspector
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|objectinspector
operator|.
name|ObjectInspectorConverters
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|typeinfo
operator|.
name|TypeInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|typeinfo
operator|.
name|TypeInfoUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapred
operator|.
name|TextInputFormat
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|VisibleForTesting
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|ImmutableList
import|;
end_import

begin_comment
comment|/**  * BaseSemanticAnalyzer.  *  */
end_comment

begin_class
specifier|public
specifier|abstract
class|class
name|BaseSemanticAnalyzer
block|{
specifier|protected
specifier|static
specifier|final
name|Logger
name|STATIC_LOG
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|BaseSemanticAnalyzer
operator|.
name|class
operator|.
name|getName
argument_list|()
argument_list|)
decl_stmt|;
comment|// Assumes one instance of this + single-threaded compilation for each query.
specifier|protected
specifier|final
name|Hive
name|db
decl_stmt|;
specifier|protected
specifier|final
name|HiveConf
name|conf
decl_stmt|;
specifier|protected
specifier|final
name|QueryState
name|queryState
decl_stmt|;
specifier|protected
name|List
argument_list|<
name|Task
argument_list|<
name|?
extends|extends
name|Serializable
argument_list|>
argument_list|>
name|rootTasks
decl_stmt|;
specifier|protected
name|FetchTask
name|fetchTask
decl_stmt|;
specifier|protected
specifier|final
name|Logger
name|LOG
decl_stmt|;
specifier|protected
specifier|final
name|LogHelper
name|console
decl_stmt|;
specifier|protected
name|CompilationOpContext
name|cContext
decl_stmt|;
specifier|protected
name|Context
name|ctx
decl_stmt|;
specifier|protected
name|HashMap
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|idToTableNameMap
decl_stmt|;
specifier|protected
name|QueryProperties
name|queryProperties
decl_stmt|;
comment|/**    * A set of FileSinkOperators being written to in an ACID compliant way.  We need to remember    * them here because when we build them we don't yet know the transaction id.  We need to go    * back and set it once we actually start running the query.    */
specifier|protected
name|Set
argument_list|<
name|FileSinkDesc
argument_list|>
name|acidFileSinks
init|=
operator|new
name|HashSet
argument_list|<
name|FileSinkDesc
argument_list|>
argument_list|()
decl_stmt|;
comment|// whether any ACID table is involved in a query
specifier|protected
name|boolean
name|acidInQuery
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|int
name|HIVE_COLUMN_ORDER_ASC
init|=
literal|1
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|int
name|HIVE_COLUMN_ORDER_DESC
init|=
literal|0
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|int
name|HIVE_COLUMN_NULLS_FIRST
init|=
literal|0
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|int
name|HIVE_COLUMN_NULLS_LAST
init|=
literal|1
decl_stmt|;
comment|/**    * ReadEntities that are passed to the hooks.    */
specifier|protected
name|HashSet
argument_list|<
name|ReadEntity
argument_list|>
name|inputs
decl_stmt|;
comment|/**    * List of WriteEntities that are passed to the hooks.    */
specifier|protected
name|HashSet
argument_list|<
name|WriteEntity
argument_list|>
name|outputs
decl_stmt|;
comment|/**    * Lineage information for the query.    */
specifier|protected
name|LineageInfo
name|linfo
decl_stmt|;
specifier|protected
name|TableAccessInfo
name|tableAccessInfo
decl_stmt|;
specifier|protected
name|ColumnAccessInfo
name|columnAccessInfo
decl_stmt|;
comment|/**    * Columns accessed by updates    */
specifier|protected
name|ColumnAccessInfo
name|updateColumnAccessInfo
decl_stmt|;
comment|/**    * the value of set autocommit true|false    * It's an object to make sure it's {@code null} if the parsed statement is    * not 'set autocommit...'    */
specifier|private
name|Boolean
name|autoCommitValue
decl_stmt|;
specifier|public
name|Boolean
name|getAutoCommitValue
parameter_list|()
block|{
return|return
name|autoCommitValue
return|;
block|}
name|void
name|setAutoCommitValue
parameter_list|(
name|Boolean
name|autoCommit
parameter_list|)
block|{
name|autoCommitValue
operator|=
name|autoCommit
expr_stmt|;
block|}
specifier|public
name|boolean
name|skipAuthorization
parameter_list|()
block|{
return|return
literal|false
return|;
block|}
class|class
name|RowFormatParams
block|{
name|String
name|fieldDelim
init|=
literal|null
decl_stmt|;
name|String
name|fieldEscape
init|=
literal|null
decl_stmt|;
name|String
name|collItemDelim
init|=
literal|null
decl_stmt|;
name|String
name|mapKeyDelim
init|=
literal|null
decl_stmt|;
name|String
name|lineDelim
init|=
literal|null
decl_stmt|;
name|String
name|nullFormat
init|=
literal|null
decl_stmt|;
specifier|protected
name|void
name|analyzeRowFormat
parameter_list|(
name|ASTNode
name|child
parameter_list|)
throws|throws
name|SemanticException
block|{
name|child
operator|=
operator|(
name|ASTNode
operator|)
name|child
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|int
name|numChildRowFormat
init|=
name|child
operator|.
name|getChildCount
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|numC
init|=
literal|0
init|;
name|numC
operator|<
name|numChildRowFormat
condition|;
name|numC
operator|++
control|)
block|{
name|ASTNode
name|rowChild
init|=
operator|(
name|ASTNode
operator|)
name|child
operator|.
name|getChild
argument_list|(
name|numC
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|rowChild
operator|.
name|getToken
argument_list|()
operator|.
name|getType
argument_list|()
condition|)
block|{
case|case
name|HiveParser
operator|.
name|TOK_TABLEROWFORMATFIELD
case|:
name|fieldDelim
operator|=
name|unescapeSQLString
argument_list|(
name|rowChild
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getText
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|rowChild
operator|.
name|getChildCount
argument_list|()
operator|>=
literal|2
condition|)
block|{
name|fieldEscape
operator|=
name|unescapeSQLString
argument_list|(
name|rowChild
operator|.
name|getChild
argument_list|(
literal|1
argument_list|)
operator|.
name|getText
argument_list|()
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|HiveParser
operator|.
name|TOK_TABLEROWFORMATCOLLITEMS
case|:
name|collItemDelim
operator|=
name|unescapeSQLString
argument_list|(
name|rowChild
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getText
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|HiveParser
operator|.
name|TOK_TABLEROWFORMATMAPKEYS
case|:
name|mapKeyDelim
operator|=
name|unescapeSQLString
argument_list|(
name|rowChild
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getText
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|HiveParser
operator|.
name|TOK_TABLEROWFORMATLINES
case|:
name|lineDelim
operator|=
name|unescapeSQLString
argument_list|(
name|rowChild
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getText
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|lineDelim
operator|.
name|equals
argument_list|(
literal|"\n"
argument_list|)
operator|&&
operator|!
name|lineDelim
operator|.
name|equals
argument_list|(
literal|"10"
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|SemanticAnalyzer
operator|.
name|generateErrorMessage
argument_list|(
name|rowChild
argument_list|,
name|ErrorMsg
operator|.
name|LINES_TERMINATED_BY_NON_NEWLINE
operator|.
name|getMsg
argument_list|()
argument_list|)
argument_list|)
throw|;
block|}
break|break;
case|case
name|HiveParser
operator|.
name|TOK_TABLEROWFORMATNULL
case|:
name|nullFormat
operator|=
name|unescapeSQLString
argument_list|(
name|rowChild
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getText
argument_list|()
argument_list|)
expr_stmt|;
break|break;
default|default:
throw|throw
operator|new
name|AssertionError
argument_list|(
literal|"Unkown Token: "
operator|+
name|rowChild
argument_list|)
throw|;
block|}
block|}
block|}
block|}
specifier|public
name|BaseSemanticAnalyzer
parameter_list|(
name|QueryState
name|queryState
parameter_list|)
throws|throws
name|SemanticException
block|{
name|this
argument_list|(
name|queryState
argument_list|,
name|createHiveDB
argument_list|(
name|queryState
operator|.
name|getConf
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|public
name|BaseSemanticAnalyzer
parameter_list|(
name|QueryState
name|queryState
parameter_list|,
name|Hive
name|db
parameter_list|)
throws|throws
name|SemanticException
block|{
try|try
block|{
name|this
operator|.
name|queryState
operator|=
name|queryState
expr_stmt|;
name|this
operator|.
name|conf
operator|=
name|queryState
operator|.
name|getConf
argument_list|()
expr_stmt|;
name|this
operator|.
name|db
operator|=
name|db
expr_stmt|;
name|rootTasks
operator|=
operator|new
name|ArrayList
argument_list|<
name|Task
argument_list|<
name|?
extends|extends
name|Serializable
argument_list|>
argument_list|>
argument_list|()
expr_stmt|;
name|LOG
operator|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|this
operator|.
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
name|console
operator|=
operator|new
name|LogHelper
argument_list|(
name|LOG
argument_list|)
expr_stmt|;
name|idToTableNameMap
operator|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
argument_list|()
expr_stmt|;
name|inputs
operator|=
operator|new
name|LinkedHashSet
argument_list|<
name|ReadEntity
argument_list|>
argument_list|()
expr_stmt|;
name|outputs
operator|=
operator|new
name|LinkedHashSet
argument_list|<
name|WriteEntity
argument_list|>
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
specifier|protected
specifier|static
name|Hive
name|createHiveDB
parameter_list|(
name|HiveConf
name|conf
parameter_list|)
throws|throws
name|SemanticException
block|{
try|try
block|{
return|return
name|Hive
operator|.
name|get
argument_list|(
name|conf
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|HiveException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
specifier|public
name|HashMap
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|getIdToTableNameMap
parameter_list|()
block|{
return|return
name|idToTableNameMap
return|;
block|}
specifier|public
specifier|abstract
name|void
name|analyzeInternal
parameter_list|(
name|ASTNode
name|ast
parameter_list|)
throws|throws
name|SemanticException
function_decl|;
specifier|public
name|void
name|init
parameter_list|(
name|boolean
name|clearPartsCache
parameter_list|)
block|{
comment|//no-op
block|}
specifier|public
name|void
name|initCtx
parameter_list|(
name|Context
name|ctx
parameter_list|)
block|{
name|this
operator|.
name|ctx
operator|=
name|ctx
expr_stmt|;
block|}
specifier|public
name|void
name|analyze
parameter_list|(
name|ASTNode
name|ast
parameter_list|,
name|Context
name|ctx
parameter_list|)
throws|throws
name|SemanticException
block|{
name|initCtx
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
name|init
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|analyzeInternal
argument_list|(
name|ast
argument_list|)
expr_stmt|;
block|}
specifier|public
name|void
name|validate
parameter_list|()
throws|throws
name|SemanticException
block|{
comment|// Implementations may choose to override this
block|}
specifier|public
name|List
argument_list|<
name|Task
argument_list|<
name|?
extends|extends
name|Serializable
argument_list|>
argument_list|>
name|getRootTasks
parameter_list|()
block|{
return|return
name|rootTasks
return|;
block|}
comment|/**    * @return the fetchTask    */
specifier|public
name|FetchTask
name|getFetchTask
parameter_list|()
block|{
return|return
name|fetchTask
return|;
block|}
comment|/**    * @param fetchTask    *          the fetchTask to set    */
specifier|public
name|void
name|setFetchTask
parameter_list|(
name|FetchTask
name|fetchTask
parameter_list|)
block|{
name|this
operator|.
name|fetchTask
operator|=
name|fetchTask
expr_stmt|;
block|}
specifier|protected
name|void
name|reset
parameter_list|(
name|boolean
name|clearPartsCache
parameter_list|)
block|{
name|rootTasks
operator|=
operator|new
name|ArrayList
argument_list|<
name|Task
argument_list|<
name|?
extends|extends
name|Serializable
argument_list|>
argument_list|>
argument_list|()
expr_stmt|;
block|}
specifier|public
specifier|static
name|String
name|stripIdentifierQuotes
parameter_list|(
name|String
name|val
parameter_list|)
block|{
if|if
condition|(
operator|(
name|val
operator|.
name|charAt
argument_list|(
literal|0
argument_list|)
operator|==
literal|'`'
operator|&&
name|val
operator|.
name|charAt
argument_list|(
name|val
operator|.
name|length
argument_list|()
operator|-
literal|1
argument_list|)
operator|==
literal|'`'
operator|)
condition|)
block|{
name|val
operator|=
name|val
operator|.
name|substring
argument_list|(
literal|1
argument_list|,
name|val
operator|.
name|length
argument_list|()
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
name|val
return|;
block|}
specifier|public
specifier|static
name|String
name|stripQuotes
parameter_list|(
name|String
name|val
parameter_list|)
block|{
return|return
name|PlanUtils
operator|.
name|stripQuotes
argument_list|(
name|val
argument_list|)
return|;
block|}
specifier|public
specifier|static
name|String
name|charSetString
parameter_list|(
name|String
name|charSetName
parameter_list|,
name|String
name|charSetString
parameter_list|)
throws|throws
name|SemanticException
block|{
try|try
block|{
comment|// The character set name starts with a _, so strip that
name|charSetName
operator|=
name|charSetName
operator|.
name|substring
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|charSetString
operator|.
name|charAt
argument_list|(
literal|0
argument_list|)
operator|==
literal|'\''
condition|)
block|{
return|return
operator|new
name|String
argument_list|(
name|unescapeSQLString
argument_list|(
name|charSetString
argument_list|)
operator|.
name|getBytes
argument_list|()
argument_list|,
name|charSetName
argument_list|)
return|;
block|}
else|else
comment|// hex input is also supported
block|{
assert|assert
name|charSetString
operator|.
name|charAt
argument_list|(
literal|0
argument_list|)
operator|==
literal|'0'
assert|;
assert|assert
name|charSetString
operator|.
name|charAt
argument_list|(
literal|1
argument_list|)
operator|==
literal|'x'
assert|;
name|charSetString
operator|=
name|charSetString
operator|.
name|substring
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|byte
index|[]
name|bArray
init|=
operator|new
name|byte
index|[
name|charSetString
operator|.
name|length
argument_list|()
operator|/
literal|2
index|]
decl_stmt|;
name|int
name|j
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|charSetString
operator|.
name|length
argument_list|()
condition|;
name|i
operator|+=
literal|2
control|)
block|{
name|int
name|val
init|=
name|Character
operator|.
name|digit
argument_list|(
name|charSetString
operator|.
name|charAt
argument_list|(
name|i
argument_list|)
argument_list|,
literal|16
argument_list|)
operator|*
literal|16
operator|+
name|Character
operator|.
name|digit
argument_list|(
name|charSetString
operator|.
name|charAt
argument_list|(
name|i
operator|+
literal|1
argument_list|)
argument_list|,
literal|16
argument_list|)
decl_stmt|;
if|if
condition|(
name|val
operator|>
literal|127
condition|)
block|{
name|val
operator|=
name|val
operator|-
literal|256
expr_stmt|;
block|}
name|bArray
index|[
name|j
operator|++
index|]
operator|=
operator|(
name|byte
operator|)
name|val
expr_stmt|;
block|}
name|String
name|res
init|=
operator|new
name|String
argument_list|(
name|bArray
argument_list|,
name|charSetName
argument_list|)
decl_stmt|;
return|return
name|res
return|;
block|}
block|}
catch|catch
parameter_list|(
name|UnsupportedEncodingException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
comment|/**    * Get dequoted name from a table/column node.    * @param tableOrColumnNode the table or column node    * @return for table node, db.tab or tab. for column node column.    */
specifier|public
specifier|static
name|String
name|getUnescapedName
parameter_list|(
name|ASTNode
name|tableOrColumnNode
parameter_list|)
block|{
return|return
name|getUnescapedName
argument_list|(
name|tableOrColumnNode
argument_list|,
literal|null
argument_list|)
return|;
block|}
specifier|public
specifier|static
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|getDbTableNamePair
parameter_list|(
name|ASTNode
name|tableNameNode
parameter_list|)
block|{
assert|assert
operator|(
name|tableNameNode
operator|.
name|getToken
argument_list|()
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_TABNAME
operator|)
assert|;
if|if
condition|(
name|tableNameNode
operator|.
name|getChildCount
argument_list|()
operator|==
literal|2
condition|)
block|{
name|String
name|dbName
init|=
name|unescapeIdentifier
argument_list|(
name|tableNameNode
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getText
argument_list|()
argument_list|)
decl_stmt|;
name|String
name|tableName
init|=
name|unescapeIdentifier
argument_list|(
name|tableNameNode
operator|.
name|getChild
argument_list|(
literal|1
argument_list|)
operator|.
name|getText
argument_list|()
argument_list|)
decl_stmt|;
return|return
name|Pair
operator|.
name|of
argument_list|(
name|dbName
argument_list|,
name|tableName
argument_list|)
return|;
block|}
else|else
block|{
name|String
name|tableName
init|=
name|unescapeIdentifier
argument_list|(
name|tableNameNode
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getText
argument_list|()
argument_list|)
decl_stmt|;
return|return
name|Pair
operator|.
name|of
argument_list|(
literal|null
argument_list|,
name|tableName
argument_list|)
return|;
block|}
block|}
specifier|public
specifier|static
name|String
name|getUnescapedName
parameter_list|(
name|ASTNode
name|tableOrColumnNode
parameter_list|,
name|String
name|currentDatabase
parameter_list|)
block|{
name|int
name|tokenType
init|=
name|tableOrColumnNode
operator|.
name|getToken
argument_list|()
operator|.
name|getType
argument_list|()
decl_stmt|;
if|if
condition|(
name|tokenType
operator|==
name|HiveParser
operator|.
name|TOK_TABNAME
condition|)
block|{
comment|// table node
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|dbTablePair
init|=
name|getDbTableNamePair
argument_list|(
name|tableOrColumnNode
argument_list|)
decl_stmt|;
name|String
name|dbName
init|=
name|dbTablePair
operator|.
name|getKey
argument_list|()
decl_stmt|;
name|String
name|tableName
init|=
name|dbTablePair
operator|.
name|getValue
argument_list|()
decl_stmt|;
if|if
condition|(
name|dbName
operator|!=
literal|null
condition|)
block|{
return|return
name|dbName
operator|+
literal|"."
operator|+
name|tableName
return|;
block|}
if|if
condition|(
name|currentDatabase
operator|!=
literal|null
condition|)
block|{
return|return
name|currentDatabase
operator|+
literal|"."
operator|+
name|tableName
return|;
block|}
return|return
name|tableName
return|;
block|}
elseif|else
if|if
condition|(
name|tokenType
operator|==
name|HiveParser
operator|.
name|StringLiteral
condition|)
block|{
return|return
name|unescapeSQLString
argument_list|(
name|tableOrColumnNode
operator|.
name|getText
argument_list|()
argument_list|)
return|;
block|}
comment|// column node
return|return
name|unescapeIdentifier
argument_list|(
name|tableOrColumnNode
operator|.
name|getText
argument_list|()
argument_list|)
return|;
block|}
specifier|public
specifier|static
name|String
index|[]
name|getQualifiedTableName
parameter_list|(
name|ASTNode
name|tabNameNode
parameter_list|)
throws|throws
name|SemanticException
block|{
if|if
condition|(
name|tabNameNode
operator|.
name|getType
argument_list|()
operator|!=
name|HiveParser
operator|.
name|TOK_TABNAME
operator|||
operator|(
name|tabNameNode
operator|.
name|getChildCount
argument_list|()
operator|!=
literal|1
operator|&&
name|tabNameNode
operator|.
name|getChildCount
argument_list|()
operator|!=
literal|2
operator|)
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|INVALID_TABLE_NAME
operator|.
name|getMsg
argument_list|(
name|tabNameNode
argument_list|)
argument_list|)
throw|;
block|}
if|if
condition|(
name|tabNameNode
operator|.
name|getChildCount
argument_list|()
operator|==
literal|2
condition|)
block|{
name|String
name|dbName
init|=
name|unescapeIdentifier
argument_list|(
name|tabNameNode
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getText
argument_list|()
argument_list|)
decl_stmt|;
name|String
name|tableName
init|=
name|unescapeIdentifier
argument_list|(
name|tabNameNode
operator|.
name|getChild
argument_list|(
literal|1
argument_list|)
operator|.
name|getText
argument_list|()
argument_list|)
decl_stmt|;
return|return
operator|new
name|String
index|[]
block|{
name|dbName
block|,
name|tableName
block|}
return|;
block|}
name|String
name|tableName
init|=
name|unescapeIdentifier
argument_list|(
name|tabNameNode
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getText
argument_list|()
argument_list|)
decl_stmt|;
return|return
name|Utilities
operator|.
name|getDbTableName
argument_list|(
name|tableName
argument_list|)
return|;
block|}
specifier|public
specifier|static
name|String
name|getDotName
parameter_list|(
name|String
index|[]
name|qname
parameter_list|)
throws|throws
name|SemanticException
block|{
name|String
name|genericName
init|=
name|StringUtils
operator|.
name|join
argument_list|(
name|qname
argument_list|,
literal|"."
argument_list|)
decl_stmt|;
if|if
condition|(
name|qname
operator|.
name|length
operator|!=
literal|2
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|INVALID_TABLE_NAME
argument_list|,
name|genericName
argument_list|)
throw|;
block|}
return|return
name|genericName
return|;
block|}
comment|/**    * Get the unqualified name from a table node.    *    * This method works for table names qualified with their schema (e.g., "db.table")    * and table names without schema qualification. In both cases, it returns    * the table name without the schema.    *    * @param node the table node    * @return the table name without schema qualification    *         (i.e., if name is "db.table" or "table", returns "table")    */
specifier|public
specifier|static
name|String
name|getUnescapedUnqualifiedTableName
parameter_list|(
name|ASTNode
name|node
parameter_list|)
block|{
assert|assert
name|node
operator|.
name|getChildCount
argument_list|()
operator|<=
literal|2
assert|;
if|if
condition|(
name|node
operator|.
name|getChildCount
argument_list|()
operator|==
literal|2
condition|)
block|{
name|node
operator|=
operator|(
name|ASTNode
operator|)
name|node
operator|.
name|getChild
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
name|getUnescapedName
argument_list|(
name|node
argument_list|)
return|;
block|}
comment|/**    * Remove the encapsulating "`" pair from the identifier. We allow users to    * use "`" to escape identifier for table names, column names and aliases, in    * case that coincide with Hive language keywords.    */
specifier|public
specifier|static
name|String
name|unescapeIdentifier
parameter_list|(
name|String
name|val
parameter_list|)
block|{
if|if
condition|(
name|val
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
if|if
condition|(
name|val
operator|.
name|charAt
argument_list|(
literal|0
argument_list|)
operator|==
literal|'`'
operator|&&
name|val
operator|.
name|charAt
argument_list|(
name|val
operator|.
name|length
argument_list|()
operator|-
literal|1
argument_list|)
operator|==
literal|'`'
condition|)
block|{
name|val
operator|=
name|val
operator|.
name|substring
argument_list|(
literal|1
argument_list|,
name|val
operator|.
name|length
argument_list|()
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
name|val
return|;
block|}
comment|/**    * Converts parsed key/value properties pairs into a map.    *    * @param prop ASTNode parent of the key/value pairs    *    * @param mapProp property map which receives the mappings    */
specifier|public
specifier|static
name|void
name|readProps
parameter_list|(
name|ASTNode
name|prop
parameter_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|mapProp
parameter_list|)
block|{
for|for
control|(
name|int
name|propChild
init|=
literal|0
init|;
name|propChild
operator|<
name|prop
operator|.
name|getChildCount
argument_list|()
condition|;
name|propChild
operator|++
control|)
block|{
name|String
name|key
init|=
name|unescapeSQLString
argument_list|(
name|prop
operator|.
name|getChild
argument_list|(
name|propChild
argument_list|)
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getText
argument_list|()
argument_list|)
decl_stmt|;
name|String
name|value
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|prop
operator|.
name|getChild
argument_list|(
name|propChild
argument_list|)
operator|.
name|getChild
argument_list|(
literal|1
argument_list|)
operator|!=
literal|null
condition|)
block|{
name|value
operator|=
name|unescapeSQLString
argument_list|(
name|prop
operator|.
name|getChild
argument_list|(
name|propChild
argument_list|)
operator|.
name|getChild
argument_list|(
literal|1
argument_list|)
operator|.
name|getText
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|mapProp
operator|.
name|put
argument_list|(
name|key
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"nls"
argument_list|)
specifier|public
specifier|static
name|String
name|unescapeSQLString
parameter_list|(
name|String
name|b
parameter_list|)
block|{
name|Character
name|enclosure
init|=
literal|null
decl_stmt|;
comment|// Some of the strings can be passed in as unicode. For example, the
comment|// delimiter can be passed in as \002 - So, we first check if the
comment|// string is a unicode number, else go back to the old behavior
name|StringBuilder
name|sb
init|=
operator|new
name|StringBuilder
argument_list|(
name|b
operator|.
name|length
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|b
operator|.
name|length
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|char
name|currentChar
init|=
name|b
operator|.
name|charAt
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|enclosure
operator|==
literal|null
condition|)
block|{
if|if
condition|(
name|currentChar
operator|==
literal|'\''
operator|||
name|b
operator|.
name|charAt
argument_list|(
name|i
argument_list|)
operator|==
literal|'\"'
condition|)
block|{
name|enclosure
operator|=
name|currentChar
expr_stmt|;
block|}
comment|// ignore all other chars outside the enclosure
continue|continue;
block|}
if|if
condition|(
name|enclosure
operator|.
name|equals
argument_list|(
name|currentChar
argument_list|)
condition|)
block|{
name|enclosure
operator|=
literal|null
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|currentChar
operator|==
literal|'\\'
operator|&&
operator|(
name|i
operator|+
literal|6
operator|<
name|b
operator|.
name|length
argument_list|()
operator|)
operator|&&
name|b
operator|.
name|charAt
argument_list|(
name|i
operator|+
literal|1
argument_list|)
operator|==
literal|'u'
condition|)
block|{
name|int
name|code
init|=
literal|0
decl_stmt|;
name|int
name|base
init|=
name|i
operator|+
literal|2
decl_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
literal|4
condition|;
name|j
operator|++
control|)
block|{
name|int
name|digit
init|=
name|Character
operator|.
name|digit
argument_list|(
name|b
operator|.
name|charAt
argument_list|(
name|j
operator|+
name|base
argument_list|)
argument_list|,
literal|16
argument_list|)
decl_stmt|;
name|code
operator|=
operator|(
name|code
operator|<<
literal|4
operator|)
operator|+
name|digit
expr_stmt|;
block|}
name|sb
operator|.
name|append
argument_list|(
operator|(
name|char
operator|)
name|code
argument_list|)
expr_stmt|;
name|i
operator|+=
literal|5
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|currentChar
operator|==
literal|'\\'
operator|&&
operator|(
name|i
operator|+
literal|4
operator|<
name|b
operator|.
name|length
argument_list|()
operator|)
condition|)
block|{
name|char
name|i1
init|=
name|b
operator|.
name|charAt
argument_list|(
name|i
operator|+
literal|1
argument_list|)
decl_stmt|;
name|char
name|i2
init|=
name|b
operator|.
name|charAt
argument_list|(
name|i
operator|+
literal|2
argument_list|)
decl_stmt|;
name|char
name|i3
init|=
name|b
operator|.
name|charAt
argument_list|(
name|i
operator|+
literal|3
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|i1
operator|>=
literal|'0'
operator|&&
name|i1
operator|<=
literal|'1'
operator|)
operator|&&
operator|(
name|i2
operator|>=
literal|'0'
operator|&&
name|i2
operator|<=
literal|'7'
operator|)
operator|&&
operator|(
name|i3
operator|>=
literal|'0'
operator|&&
name|i3
operator|<=
literal|'7'
operator|)
condition|)
block|{
name|byte
name|bVal
init|=
call|(
name|byte
call|)
argument_list|(
operator|(
name|i3
operator|-
literal|'0'
operator|)
operator|+
operator|(
operator|(
name|i2
operator|-
literal|'0'
operator|)
operator|*
literal|8
operator|)
operator|+
operator|(
operator|(
name|i1
operator|-
literal|'0'
operator|)
operator|*
literal|8
operator|*
literal|8
operator|)
argument_list|)
decl_stmt|;
name|byte
index|[]
name|bValArr
init|=
operator|new
name|byte
index|[
literal|1
index|]
decl_stmt|;
name|bValArr
index|[
literal|0
index|]
operator|=
name|bVal
expr_stmt|;
name|String
name|tmp
init|=
operator|new
name|String
argument_list|(
name|bValArr
argument_list|)
decl_stmt|;
name|sb
operator|.
name|append
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
name|i
operator|+=
literal|3
expr_stmt|;
continue|continue;
block|}
block|}
if|if
condition|(
name|currentChar
operator|==
literal|'\\'
operator|&&
operator|(
name|i
operator|+
literal|2
operator|<
name|b
operator|.
name|length
argument_list|()
operator|)
condition|)
block|{
name|char
name|n
init|=
name|b
operator|.
name|charAt
argument_list|(
name|i
operator|+
literal|1
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|n
condition|)
block|{
case|case
literal|'0'
case|:
name|sb
operator|.
name|append
argument_list|(
literal|"\0"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'\''
case|:
name|sb
operator|.
name|append
argument_list|(
literal|"'"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'"'
case|:
name|sb
operator|.
name|append
argument_list|(
literal|"\""
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'b'
case|:
name|sb
operator|.
name|append
argument_list|(
literal|"\b"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'n'
case|:
name|sb
operator|.
name|append
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
name|sb
operator|.
name|append
argument_list|(
literal|"\r"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
name|sb
operator|.
name|append
argument_list|(
literal|"\t"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'Z'
case|:
name|sb
operator|.
name|append
argument_list|(
literal|"\u001A"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'\\'
case|:
name|sb
operator|.
name|append
argument_list|(
literal|"\\"
argument_list|)
expr_stmt|;
break|break;
comment|// The following 2 lines are exactly what MySQL does TODO: why do we do this?
case|case
literal|'%'
case|:
name|sb
operator|.
name|append
argument_list|(
literal|"\\%"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'_'
case|:
name|sb
operator|.
name|append
argument_list|(
literal|"\\_"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|sb
operator|.
name|append
argument_list|(
name|n
argument_list|)
expr_stmt|;
block|}
name|i
operator|++
expr_stmt|;
block|}
else|else
block|{
name|sb
operator|.
name|append
argument_list|(
name|currentChar
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|sb
operator|.
name|toString
argument_list|()
return|;
block|}
comment|/**    * Escapes the string for AST; doesn't enclose it in quotes, however.    */
specifier|public
specifier|static
name|String
name|escapeSQLString
parameter_list|(
name|String
name|b
parameter_list|)
block|{
comment|// There's usually nothing to escape so we will be optimistic.
name|String
name|result
init|=
name|b
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|result
operator|.
name|length
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|char
name|currentChar
init|=
name|result
operator|.
name|charAt
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|currentChar
operator|==
literal|'\\'
operator|&&
operator|(
operator|(
name|i
operator|+
literal|1
operator|)
operator|<
name|result
operator|.
name|length
argument_list|()
operator|)
condition|)
block|{
comment|// TODO: do we need to handle the "this is what MySQL does" here?
name|char
name|nextChar
init|=
name|result
operator|.
name|charAt
argument_list|(
name|i
operator|+
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|nextChar
operator|==
literal|'%'
operator|||
name|nextChar
operator|==
literal|'_'
condition|)
block|{
operator|++
name|i
expr_stmt|;
continue|continue;
block|}
block|}
switch|switch
condition|(
name|currentChar
condition|)
block|{
case|case
literal|'\0'
case|:
name|result
operator|=
name|spliceString
argument_list|(
name|result
argument_list|,
name|i
argument_list|,
literal|"\\0"
argument_list|)
expr_stmt|;
operator|++
name|i
expr_stmt|;
break|break;
case|case
literal|'\''
case|:
name|result
operator|=
name|spliceString
argument_list|(
name|result
argument_list|,
name|i
argument_list|,
literal|"\\'"
argument_list|)
expr_stmt|;
operator|++
name|i
expr_stmt|;
break|break;
case|case
literal|'\"'
case|:
name|result
operator|=
name|spliceString
argument_list|(
name|result
argument_list|,
name|i
argument_list|,
literal|"\\\""
argument_list|)
expr_stmt|;
operator|++
name|i
expr_stmt|;
break|break;
case|case
literal|'\b'
case|:
name|result
operator|=
name|spliceString
argument_list|(
name|result
argument_list|,
name|i
argument_list|,
literal|"\\b"
argument_list|)
expr_stmt|;
operator|++
name|i
expr_stmt|;
break|break;
case|case
literal|'\n'
case|:
name|result
operator|=
name|spliceString
argument_list|(
name|result
argument_list|,
name|i
argument_list|,
literal|"\\n"
argument_list|)
expr_stmt|;
operator|++
name|i
expr_stmt|;
break|break;
case|case
literal|'\r'
case|:
name|result
operator|=
name|spliceString
argument_list|(
name|result
argument_list|,
name|i
argument_list|,
literal|"\\r"
argument_list|)
expr_stmt|;
operator|++
name|i
expr_stmt|;
break|break;
case|case
literal|'\t'
case|:
name|result
operator|=
name|spliceString
argument_list|(
name|result
argument_list|,
name|i
argument_list|,
literal|"\\t"
argument_list|)
expr_stmt|;
operator|++
name|i
expr_stmt|;
break|break;
case|case
literal|'\\'
case|:
name|result
operator|=
name|spliceString
argument_list|(
name|result
argument_list|,
name|i
argument_list|,
literal|"\\\\"
argument_list|)
expr_stmt|;
operator|++
name|i
expr_stmt|;
break|break;
case|case
literal|'\u001A'
case|:
name|result
operator|=
name|spliceString
argument_list|(
name|result
argument_list|,
name|i
argument_list|,
literal|"\\Z"
argument_list|)
expr_stmt|;
operator|++
name|i
expr_stmt|;
break|break;
default|default:
block|{
if|if
condition|(
name|currentChar
operator|<
literal|' '
condition|)
block|{
name|String
name|hex
init|=
name|Integer
operator|.
name|toHexString
argument_list|(
name|currentChar
argument_list|)
decl_stmt|;
name|String
name|unicode
init|=
literal|"\\u"
decl_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|4
init|;
name|j
operator|>
name|hex
operator|.
name|length
argument_list|()
condition|;
operator|--
name|j
control|)
block|{
name|unicode
operator|+=
literal|'0'
expr_stmt|;
block|}
name|unicode
operator|+=
name|hex
expr_stmt|;
name|result
operator|=
name|spliceString
argument_list|(
name|result
argument_list|,
name|i
argument_list|,
name|unicode
argument_list|)
expr_stmt|;
name|i
operator|+=
operator|(
name|unicode
operator|.
name|length
argument_list|()
operator|-
literal|1
operator|)
expr_stmt|;
block|}
break|break;
comment|// if not a control character, do nothing
block|}
block|}
block|}
return|return
name|result
return|;
block|}
specifier|private
specifier|static
name|String
name|spliceString
parameter_list|(
name|String
name|str
parameter_list|,
name|int
name|i
parameter_list|,
name|String
name|replacement
parameter_list|)
block|{
return|return
name|spliceString
argument_list|(
name|str
argument_list|,
name|i
argument_list|,
literal|1
argument_list|,
name|replacement
argument_list|)
return|;
block|}
specifier|private
specifier|static
name|String
name|spliceString
parameter_list|(
name|String
name|str
parameter_list|,
name|int
name|i
parameter_list|,
name|int
name|length
parameter_list|,
name|String
name|replacement
parameter_list|)
block|{
return|return
name|str
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|i
argument_list|)
operator|+
name|replacement
operator|+
name|str
operator|.
name|substring
argument_list|(
name|i
operator|+
name|length
argument_list|)
return|;
block|}
specifier|public
name|HashSet
argument_list|<
name|ReadEntity
argument_list|>
name|getInputs
parameter_list|()
block|{
return|return
name|inputs
return|;
block|}
specifier|public
name|HashSet
argument_list|<
name|WriteEntity
argument_list|>
name|getOutputs
parameter_list|()
block|{
return|return
name|outputs
return|;
block|}
comment|/**    * @return the schema for the fields which will be produced    * when the statement is executed, or null if not known    */
specifier|public
name|List
argument_list|<
name|FieldSchema
argument_list|>
name|getResultSchema
parameter_list|()
block|{
return|return
literal|null
return|;
block|}
specifier|protected
name|List
argument_list|<
name|FieldSchema
argument_list|>
name|getColumns
parameter_list|(
name|ASTNode
name|ast
parameter_list|)
throws|throws
name|SemanticException
block|{
return|return
name|getColumns
argument_list|(
name|ast
argument_list|,
literal|true
argument_list|)
return|;
block|}
comment|/**    * Get the list of FieldSchema out of the ASTNode.    */
specifier|public
specifier|static
name|List
argument_list|<
name|FieldSchema
argument_list|>
name|getColumns
parameter_list|(
name|ASTNode
name|ast
parameter_list|,
name|boolean
name|lowerCase
parameter_list|)
throws|throws
name|SemanticException
block|{
return|return
name|getColumns
argument_list|(
name|ast
argument_list|,
name|lowerCase
argument_list|,
operator|new
name|ArrayList
argument_list|<
name|SQLPrimaryKey
argument_list|>
argument_list|()
argument_list|,
operator|new
name|ArrayList
argument_list|<
name|SQLForeignKey
argument_list|>
argument_list|()
argument_list|,
operator|new
name|ArrayList
argument_list|<
name|SQLUniqueConstraint
argument_list|>
argument_list|()
argument_list|,
operator|new
name|ArrayList
argument_list|<
name|SQLNotNullConstraint
argument_list|>
argument_list|()
argument_list|)
return|;
block|}
specifier|private
specifier|static
class|class
name|ConstraintInfo
block|{
specifier|final
name|String
name|colName
decl_stmt|;
specifier|final
name|String
name|constraintName
decl_stmt|;
specifier|final
name|boolean
name|enable
decl_stmt|;
specifier|final
name|boolean
name|validate
decl_stmt|;
specifier|final
name|boolean
name|rely
decl_stmt|;
name|ConstraintInfo
parameter_list|(
name|String
name|colName
parameter_list|,
name|String
name|constraintName
parameter_list|,
name|boolean
name|enable
parameter_list|,
name|boolean
name|validate
parameter_list|,
name|boolean
name|rely
parameter_list|)
block|{
name|this
operator|.
name|colName
operator|=
name|colName
expr_stmt|;
name|this
operator|.
name|constraintName
operator|=
name|constraintName
expr_stmt|;
name|this
operator|.
name|enable
operator|=
name|enable
expr_stmt|;
name|this
operator|.
name|validate
operator|=
name|validate
expr_stmt|;
name|this
operator|.
name|rely
operator|=
name|rely
expr_stmt|;
block|}
block|}
comment|/**    * Process the primary keys from the ast node and populate the SQLPrimaryKey list.    */
specifier|protected
specifier|static
name|void
name|processPrimaryKeys
parameter_list|(
name|String
name|databaseName
parameter_list|,
name|String
name|tableName
parameter_list|,
name|ASTNode
name|child
parameter_list|,
name|List
argument_list|<
name|SQLPrimaryKey
argument_list|>
name|primaryKeys
parameter_list|)
throws|throws
name|SemanticException
block|{
name|List
argument_list|<
name|ConstraintInfo
argument_list|>
name|primaryKeyInfos
init|=
operator|new
name|ArrayList
argument_list|<
name|ConstraintInfo
argument_list|>
argument_list|()
decl_stmt|;
name|generateConstraintInfos
argument_list|(
name|child
argument_list|,
name|primaryKeyInfos
argument_list|)
expr_stmt|;
name|constraintInfosToPrimaryKeys
argument_list|(
name|databaseName
argument_list|,
name|tableName
argument_list|,
name|primaryKeyInfos
argument_list|,
name|primaryKeys
argument_list|)
expr_stmt|;
block|}
specifier|protected
specifier|static
name|void
name|processPrimaryKeys
parameter_list|(
name|String
name|databaseName
parameter_list|,
name|String
name|tableName
parameter_list|,
name|ASTNode
name|child
parameter_list|,
name|List
argument_list|<
name|String
argument_list|>
name|columnNames
parameter_list|,
name|List
argument_list|<
name|SQLPrimaryKey
argument_list|>
name|primaryKeys
parameter_list|)
throws|throws
name|SemanticException
block|{
name|List
argument_list|<
name|ConstraintInfo
argument_list|>
name|primaryKeyInfos
init|=
operator|new
name|ArrayList
argument_list|<
name|ConstraintInfo
argument_list|>
argument_list|()
decl_stmt|;
name|generateConstraintInfos
argument_list|(
name|child
argument_list|,
name|columnNames
argument_list|,
name|primaryKeyInfos
argument_list|)
expr_stmt|;
name|constraintInfosToPrimaryKeys
argument_list|(
name|databaseName
argument_list|,
name|tableName
argument_list|,
name|primaryKeyInfos
argument_list|,
name|primaryKeys
argument_list|)
expr_stmt|;
block|}
specifier|private
specifier|static
name|void
name|constraintInfosToPrimaryKeys
parameter_list|(
name|String
name|databaseName
parameter_list|,
name|String
name|tableName
parameter_list|,
name|List
argument_list|<
name|ConstraintInfo
argument_list|>
name|primaryKeyInfos
parameter_list|,
name|List
argument_list|<
name|SQLPrimaryKey
argument_list|>
name|primaryKeys
parameter_list|)
block|{
name|int
name|i
init|=
literal|1
decl_stmt|;
for|for
control|(
name|ConstraintInfo
name|primaryKeyInfo
range|:
name|primaryKeyInfos
control|)
block|{
name|primaryKeys
operator|.
name|add
argument_list|(
operator|new
name|SQLPrimaryKey
argument_list|(
name|databaseName
argument_list|,
name|tableName
argument_list|,
name|primaryKeyInfo
operator|.
name|colName
argument_list|,
name|i
operator|++
argument_list|,
name|primaryKeyInfo
operator|.
name|constraintName
argument_list|,
name|primaryKeyInfo
operator|.
name|enable
argument_list|,
name|primaryKeyInfo
operator|.
name|validate
argument_list|,
name|primaryKeyInfo
operator|.
name|rely
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Process the unique constraints from the ast node and populate the SQLUniqueConstraint list.    */
specifier|protected
specifier|static
name|void
name|processUniqueConstraints
parameter_list|(
name|String
name|databaseName
parameter_list|,
name|String
name|tableName
parameter_list|,
name|ASTNode
name|child
parameter_list|,
name|List
argument_list|<
name|SQLUniqueConstraint
argument_list|>
name|uniqueConstraints
parameter_list|)
throws|throws
name|SemanticException
block|{
name|List
argument_list|<
name|ConstraintInfo
argument_list|>
name|uniqueInfos
init|=
operator|new
name|ArrayList
argument_list|<
name|ConstraintInfo
argument_list|>
argument_list|()
decl_stmt|;
name|generateConstraintInfos
argument_list|(
name|child
argument_list|,
name|uniqueInfos
argument_list|)
expr_stmt|;
name|constraintInfosToUniqueConstraints
argument_list|(
name|databaseName
argument_list|,
name|tableName
argument_list|,
name|uniqueInfos
argument_list|,
name|uniqueConstraints
argument_list|)
expr_stmt|;
block|}
specifier|protected
specifier|static
name|void
name|processUniqueConstraints
parameter_list|(
name|String
name|databaseName
parameter_list|,
name|String
name|tableName
parameter_list|,
name|ASTNode
name|child
parameter_list|,
name|List
argument_list|<
name|String
argument_list|>
name|columnNames
parameter_list|,
name|List
argument_list|<
name|SQLUniqueConstraint
argument_list|>
name|uniqueConstraints
parameter_list|)
throws|throws
name|SemanticException
block|{
name|List
argument_list|<
name|ConstraintInfo
argument_list|>
name|uniqueInfos
init|=
operator|new
name|ArrayList
argument_list|<
name|ConstraintInfo
argument_list|>
argument_list|()
decl_stmt|;
name|generateConstraintInfos
argument_list|(
name|child
argument_list|,
name|columnNames
argument_list|,
name|uniqueInfos
argument_list|)
expr_stmt|;
name|constraintInfosToUniqueConstraints
argument_list|(
name|databaseName
argument_list|,
name|tableName
argument_list|,
name|uniqueInfos
argument_list|,
name|uniqueConstraints
argument_list|)
expr_stmt|;
block|}
specifier|private
specifier|static
name|void
name|constraintInfosToUniqueConstraints
parameter_list|(
name|String
name|databaseName
parameter_list|,
name|String
name|tableName
parameter_list|,
name|List
argument_list|<
name|ConstraintInfo
argument_list|>
name|uniqueInfos
parameter_list|,
name|List
argument_list|<
name|SQLUniqueConstraint
argument_list|>
name|uniqueConstraints
parameter_list|)
block|{
name|int
name|i
init|=
literal|1
decl_stmt|;
for|for
control|(
name|ConstraintInfo
name|uniqueInfo
range|:
name|uniqueInfos
control|)
block|{
name|uniqueConstraints
operator|.
name|add
argument_list|(
operator|new
name|SQLUniqueConstraint
argument_list|(
name|databaseName
argument_list|,
name|tableName
argument_list|,
name|uniqueInfo
operator|.
name|colName
argument_list|,
name|i
operator|++
argument_list|,
name|uniqueInfo
operator|.
name|constraintName
argument_list|,
name|uniqueInfo
operator|.
name|enable
argument_list|,
name|uniqueInfo
operator|.
name|validate
argument_list|,
name|uniqueInfo
operator|.
name|rely
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
specifier|protected
specifier|static
name|void
name|processNotNullConstraints
parameter_list|(
name|String
name|databaseName
parameter_list|,
name|String
name|tableName
parameter_list|,
name|ASTNode
name|child
parameter_list|,
name|List
argument_list|<
name|String
argument_list|>
name|columnNames
parameter_list|,
name|List
argument_list|<
name|SQLNotNullConstraint
argument_list|>
name|notNullConstraints
parameter_list|)
throws|throws
name|SemanticException
block|{
name|List
argument_list|<
name|ConstraintInfo
argument_list|>
name|notNullInfos
init|=
operator|new
name|ArrayList
argument_list|<
name|ConstraintInfo
argument_list|>
argument_list|()
decl_stmt|;
name|generateConstraintInfos
argument_list|(
name|child
argument_list|,
name|columnNames
argument_list|,
name|notNullInfos
argument_list|)
expr_stmt|;
name|constraintInfosToNotNullConstraints
argument_list|(
name|databaseName
argument_list|,
name|tableName
argument_list|,
name|notNullInfos
argument_list|,
name|notNullConstraints
argument_list|)
expr_stmt|;
block|}
specifier|private
specifier|static
name|void
name|constraintInfosToNotNullConstraints
parameter_list|(
name|String
name|databaseName
parameter_list|,
name|String
name|tableName
parameter_list|,
name|List
argument_list|<
name|ConstraintInfo
argument_list|>
name|notNullInfos
parameter_list|,
name|List
argument_list|<
name|SQLNotNullConstraint
argument_list|>
name|notNullConstraints
parameter_list|)
block|{
for|for
control|(
name|ConstraintInfo
name|notNullInfo
range|:
name|notNullInfos
control|)
block|{
name|notNullConstraints
operator|.
name|add
argument_list|(
operator|new
name|SQLNotNullConstraint
argument_list|(
name|databaseName
argument_list|,
name|tableName
argument_list|,
name|notNullInfo
operator|.
name|colName
argument_list|,
name|notNullInfo
operator|.
name|constraintName
argument_list|,
name|notNullInfo
operator|.
name|enable
argument_list|,
name|notNullInfo
operator|.
name|validate
argument_list|,
name|notNullInfo
operator|.
name|rely
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Get the constraint from the AST and populate the cstrInfos with the required    * information.    * @param child  The node with the constraint token    * @param cstrInfos Constraint information    * @throws SemanticException    */
specifier|private
specifier|static
name|void
name|generateConstraintInfos
parameter_list|(
name|ASTNode
name|child
parameter_list|,
name|List
argument_list|<
name|ConstraintInfo
argument_list|>
name|cstrInfos
parameter_list|)
throws|throws
name|SemanticException
block|{
name|ImmutableList
operator|.
name|Builder
argument_list|<
name|String
argument_list|>
name|columnNames
init|=
name|ImmutableList
operator|.
name|builder
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|child
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getChildCount
argument_list|()
condition|;
name|j
operator|++
control|)
block|{
name|Tree
name|columnName
init|=
name|child
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getChild
argument_list|(
name|j
argument_list|)
decl_stmt|;
name|checkColumnName
argument_list|(
name|columnName
operator|.
name|getText
argument_list|()
argument_list|)
expr_stmt|;
name|columnNames
operator|.
name|add
argument_list|(
name|unescapeIdentifier
argument_list|(
name|columnName
operator|.
name|getText
argument_list|()
operator|.
name|toLowerCase
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|generateConstraintInfos
argument_list|(
name|child
argument_list|,
name|columnNames
operator|.
name|build
argument_list|()
argument_list|,
name|cstrInfos
argument_list|)
expr_stmt|;
block|}
comment|/**    * Get the constraint from the AST and populate the cstrInfos with the required    * information.    * @param child  The node with the constraint token    * @param columnNames The name of the columns for the primary key    * @param cstrInfos Constraint information    * @throws SemanticException    */
specifier|private
specifier|static
name|void
name|generateConstraintInfos
parameter_list|(
name|ASTNode
name|child
parameter_list|,
name|List
argument_list|<
name|String
argument_list|>
name|columnNames
parameter_list|,
name|List
argument_list|<
name|ConstraintInfo
argument_list|>
name|cstrInfos
parameter_list|)
throws|throws
name|SemanticException
block|{
comment|// The ANTLR grammar looks like :
comment|// 1. KW_CONSTRAINT idfr=identifier KW_PRIMARY KW_KEY pkCols=columnParenthesesList
comment|//  constraintOptsCreate?
comment|// -> ^(TOK_PRIMARY_KEY $pkCols $idfr constraintOptsCreate?)
comment|// when the user specifies the constraint name.
comment|// 2.  KW_PRIMARY KW_KEY columnParenthesesList
comment|// constraintOptsCreate?
comment|// -> ^(TOK_PRIMARY_KEY columnParenthesesList constraintOptsCreate?)
comment|// when the user does not specify the constraint name.
comment|// Default values
name|String
name|constraintName
init|=
literal|null
decl_stmt|;
name|boolean
name|enable
init|=
literal|true
decl_stmt|;
name|boolean
name|validate
init|=
literal|true
decl_stmt|;
name|boolean
name|rely
init|=
literal|false
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|child
operator|.
name|getChildCount
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|ASTNode
name|grandChild
init|=
operator|(
name|ASTNode
operator|)
name|child
operator|.
name|getChild
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|int
name|type
init|=
name|grandChild
operator|.
name|getToken
argument_list|()
operator|.
name|getType
argument_list|()
decl_stmt|;
if|if
condition|(
name|type
operator|==
name|HiveParser
operator|.
name|TOK_CONSTRAINT_NAME
condition|)
block|{
name|constraintName
operator|=
name|unescapeIdentifier
argument_list|(
name|grandChild
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getText
argument_list|()
operator|.
name|toLowerCase
argument_list|()
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|type
operator|==
name|HiveParser
operator|.
name|TOK_ENABLE
condition|)
block|{
name|enable
operator|=
literal|true
expr_stmt|;
comment|// validate is true by default if we enable the constraint
name|validate
operator|=
literal|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|type
operator|==
name|HiveParser
operator|.
name|TOK_DISABLE
condition|)
block|{
name|enable
operator|=
literal|false
expr_stmt|;
comment|// validate is false by default if we disable the constraint
name|validate
operator|=
literal|false
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|type
operator|==
name|HiveParser
operator|.
name|TOK_VALIDATE
condition|)
block|{
name|validate
operator|=
literal|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|type
operator|==
name|HiveParser
operator|.
name|TOK_NOVALIDATE
condition|)
block|{
name|validate
operator|=
literal|false
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|type
operator|==
name|HiveParser
operator|.
name|TOK_RELY
condition|)
block|{
name|rely
operator|=
literal|true
expr_stmt|;
block|}
block|}
if|if
condition|(
name|enable
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|INVALID_CSTR_SYNTAX
operator|.
name|getMsg
argument_list|(
literal|"ENABLE feature not supported yet. "
operator|+
literal|"Please use DISABLE instead."
argument_list|)
argument_list|)
throw|;
block|}
if|if
condition|(
name|validate
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|INVALID_CSTR_SYNTAX
operator|.
name|getMsg
argument_list|(
literal|"VALIDATE feature not supported yet. "
operator|+
literal|"Please use NOVALIDATE instead."
argument_list|)
argument_list|)
throw|;
block|}
for|for
control|(
name|String
name|columnName
range|:
name|columnNames
control|)
block|{
name|cstrInfos
operator|.
name|add
argument_list|(
operator|new
name|ConstraintInfo
argument_list|(
name|columnName
argument_list|,
name|constraintName
argument_list|,
name|enable
argument_list|,
name|validate
argument_list|,
name|rely
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Process the foreign keys from the AST and populate the foreign keys in the SQLForeignKey list    * @param parent  Parent of the foreign key token node    * @param child Foreign Key token node    * @param foreignKeys SQLForeignKey list    * @throws SemanticException    */
specifier|protected
specifier|static
name|void
name|processForeignKeys
parameter_list|(
name|String
name|databaseName
parameter_list|,
name|String
name|tableName
parameter_list|,
name|ASTNode
name|child
parameter_list|,
name|List
argument_list|<
name|SQLForeignKey
argument_list|>
name|foreignKeys
parameter_list|)
throws|throws
name|SemanticException
block|{
comment|// The ANTLR grammar looks like :
comment|// 1.  KW_CONSTRAINT idfr=identifier KW_FOREIGN KW_KEY fkCols=columnParenthesesList
comment|// KW_REFERENCES tabName=tableName parCols=columnParenthesesList
comment|// enableSpec=enableSpecification validateSpec=validateSpecification relySpec=relySpecification
comment|// -> ^(TOK_FOREIGN_KEY $idfr $fkCols $tabName $parCols $relySpec $enableSpec $validateSpec)
comment|// when the user specifies the constraint name (i.e. child.getChildCount() == 7)
comment|// 2.  KW_FOREIGN KW_KEY fkCols=columnParenthesesList
comment|// KW_REFERENCES tabName=tableName parCols=columnParenthesesList
comment|// enableSpec=enableSpecification validateSpec=validateSpecification relySpec=relySpecification
comment|// -> ^(TOK_FOREIGN_KEY $fkCols  $tabName $parCols $relySpec $enableSpec $validateSpec)
comment|// when the user does not specify the constraint name (i.e. child.getChildCount() == 6)
name|String
name|constraintName
init|=
literal|null
decl_stmt|;
name|boolean
name|enable
init|=
literal|true
decl_stmt|;
name|boolean
name|validate
init|=
literal|true
decl_stmt|;
name|boolean
name|rely
init|=
literal|false
decl_stmt|;
name|int
name|fkIndex
init|=
operator|-
literal|1
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|child
operator|.
name|getChildCount
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|ASTNode
name|grandChild
init|=
operator|(
name|ASTNode
operator|)
name|child
operator|.
name|getChild
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|int
name|type
init|=
name|grandChild
operator|.
name|getToken
argument_list|()
operator|.
name|getType
argument_list|()
decl_stmt|;
if|if
condition|(
name|type
operator|==
name|HiveParser
operator|.
name|TOK_CONSTRAINT_NAME
condition|)
block|{
name|constraintName
operator|=
name|unescapeIdentifier
argument_list|(
name|grandChild
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getText
argument_list|()
operator|.
name|toLowerCase
argument_list|()
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|type
operator|==
name|HiveParser
operator|.
name|TOK_ENABLE
condition|)
block|{
name|enable
operator|=
literal|true
expr_stmt|;
comment|// validate is true by default if we enable the constraint
name|validate
operator|=
literal|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|type
operator|==
name|HiveParser
operator|.
name|TOK_DISABLE
condition|)
block|{
name|enable
operator|=
literal|false
expr_stmt|;
comment|// validate is false by default if we disable the constraint
name|validate
operator|=
literal|false
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|type
operator|==
name|HiveParser
operator|.
name|TOK_VALIDATE
condition|)
block|{
name|validate
operator|=
literal|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|type
operator|==
name|HiveParser
operator|.
name|TOK_NOVALIDATE
condition|)
block|{
name|validate
operator|=
literal|false
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|type
operator|==
name|HiveParser
operator|.
name|TOK_RELY
condition|)
block|{
name|rely
operator|=
literal|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|type
operator|==
name|HiveParser
operator|.
name|TOK_TABCOLNAME
operator|&&
name|fkIndex
operator|==
operator|-
literal|1
condition|)
block|{
name|fkIndex
operator|=
name|i
expr_stmt|;
block|}
block|}
if|if
condition|(
name|enable
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|INVALID_FK_SYNTAX
operator|.
name|getMsg
argument_list|(
literal|"ENABLE feature not supported yet. "
operator|+
literal|"Please use DISABLE instead."
argument_list|)
argument_list|)
throw|;
block|}
if|if
condition|(
name|validate
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|INVALID_FK_SYNTAX
operator|.
name|getMsg
argument_list|(
literal|"VALIDATE feature not supported yet. "
operator|+
literal|"Please use NOVALIDATE instead."
argument_list|)
argument_list|)
throw|;
block|}
name|int
name|ptIndex
init|=
name|fkIndex
operator|+
literal|1
decl_stmt|;
name|int
name|pkIndex
init|=
name|ptIndex
operator|+
literal|1
decl_stmt|;
if|if
condition|(
name|child
operator|.
name|getChild
argument_list|(
name|fkIndex
argument_list|)
operator|.
name|getChildCount
argument_list|()
operator|!=
name|child
operator|.
name|getChild
argument_list|(
name|pkIndex
argument_list|)
operator|.
name|getChildCount
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|INVALID_FK_SYNTAX
operator|.
name|getMsg
argument_list|(
literal|" The number of foreign key columns should be same as number of parent key columns "
argument_list|)
argument_list|)
throw|;
block|}
name|String
index|[]
name|parentDBTbl
init|=
name|getQualifiedTableName
argument_list|(
operator|(
name|ASTNode
operator|)
name|child
operator|.
name|getChild
argument_list|(
name|ptIndex
argument_list|)
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|child
operator|.
name|getChild
argument_list|(
name|fkIndex
argument_list|)
operator|.
name|getChildCount
argument_list|()
condition|;
name|j
operator|++
control|)
block|{
name|SQLForeignKey
name|sqlForeignKey
init|=
operator|new
name|SQLForeignKey
argument_list|()
decl_stmt|;
name|sqlForeignKey
operator|.
name|setFktable_db
argument_list|(
name|databaseName
argument_list|)
expr_stmt|;
name|sqlForeignKey
operator|.
name|setFktable_name
argument_list|(
name|tableName
argument_list|)
expr_stmt|;
name|Tree
name|fkgrandChild
init|=
name|child
operator|.
name|getChild
argument_list|(
name|fkIndex
argument_list|)
operator|.
name|getChild
argument_list|(
name|j
argument_list|)
decl_stmt|;
name|checkColumnName
argument_list|(
name|fkgrandChild
operator|.
name|getText
argument_list|()
argument_list|)
expr_stmt|;
name|sqlForeignKey
operator|.
name|setFkcolumn_name
argument_list|(
name|unescapeIdentifier
argument_list|(
name|fkgrandChild
operator|.
name|getText
argument_list|()
operator|.
name|toLowerCase
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|sqlForeignKey
operator|.
name|setPktable_db
argument_list|(
name|parentDBTbl
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|sqlForeignKey
operator|.
name|setPktable_name
argument_list|(
name|parentDBTbl
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|Tree
name|pkgrandChild
init|=
name|child
operator|.
name|getChild
argument_list|(
name|pkIndex
argument_list|)
operator|.
name|getChild
argument_list|(
name|j
argument_list|)
decl_stmt|;
name|sqlForeignKey
operator|.
name|setPkcolumn_name
argument_list|(
name|unescapeIdentifier
argument_list|(
name|pkgrandChild
operator|.
name|getText
argument_list|()
operator|.
name|toLowerCase
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|sqlForeignKey
operator|.
name|setKey_seq
argument_list|(
name|j
operator|+
literal|1
argument_list|)
expr_stmt|;
name|sqlForeignKey
operator|.
name|setFk_name
argument_list|(
name|constraintName
argument_list|)
expr_stmt|;
name|sqlForeignKey
operator|.
name|setEnable_cstr
argument_list|(
name|enable
argument_list|)
expr_stmt|;
name|sqlForeignKey
operator|.
name|setValidate_cstr
argument_list|(
name|validate
argument_list|)
expr_stmt|;
name|sqlForeignKey
operator|.
name|setRely_cstr
argument_list|(
name|rely
argument_list|)
expr_stmt|;
name|foreignKeys
operator|.
name|add
argument_list|(
name|sqlForeignKey
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
specifier|static
name|void
name|checkColumnName
parameter_list|(
name|String
name|columnName
parameter_list|)
throws|throws
name|SemanticException
block|{
if|if
condition|(
name|VirtualColumn
operator|.
name|VIRTUAL_COLUMN_NAMES
operator|.
name|contains
argument_list|(
name|columnName
operator|.
name|toUpperCase
argument_list|()
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|INVALID_COLUMN_NAME
operator|.
name|getMsg
argument_list|(
name|columnName
argument_list|)
argument_list|)
throw|;
block|}
block|}
comment|/**    * Get the list of FieldSchema out of the ASTNode.    * Additionally, populate the primaryKeys and foreignKeys if any.    */
specifier|public
specifier|static
name|List
argument_list|<
name|FieldSchema
argument_list|>
name|getColumns
parameter_list|(
name|ASTNode
name|ast
parameter_list|,
name|boolean
name|lowerCase
parameter_list|,
name|List
argument_list|<
name|SQLPrimaryKey
argument_list|>
name|primaryKeys
parameter_list|,
name|List
argument_list|<
name|SQLForeignKey
argument_list|>
name|foreignKeys
parameter_list|,
name|List
argument_list|<
name|SQLUniqueConstraint
argument_list|>
name|uniqueConstraints
parameter_list|,
name|List
argument_list|<
name|SQLNotNullConstraint
argument_list|>
name|notNullConstraints
parameter_list|)
throws|throws
name|SemanticException
block|{
name|List
argument_list|<
name|FieldSchema
argument_list|>
name|colList
init|=
operator|new
name|ArrayList
argument_list|<
name|FieldSchema
argument_list|>
argument_list|()
decl_stmt|;
name|Tree
name|parent
init|=
name|ast
operator|.
name|getParent
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|ast
operator|.
name|getChildCount
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|FieldSchema
name|col
init|=
operator|new
name|FieldSchema
argument_list|()
decl_stmt|;
name|ASTNode
name|child
init|=
operator|(
name|ASTNode
operator|)
name|ast
operator|.
name|getChild
argument_list|(
name|i
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|child
operator|.
name|getToken
argument_list|()
operator|.
name|getType
argument_list|()
condition|)
block|{
case|case
name|HiveParser
operator|.
name|TOK_UNIQUE
case|:
block|{
name|String
index|[]
name|qualifiedTabName
init|=
name|getQualifiedTableName
argument_list|(
operator|(
name|ASTNode
operator|)
name|parent
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|processUniqueConstraints
argument_list|(
name|qualifiedTabName
index|[
literal|0
index|]
argument_list|,
name|qualifiedTabName
index|[
literal|1
index|]
argument_list|,
name|child
argument_list|,
name|uniqueConstraints
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|HiveParser
operator|.
name|TOK_PRIMARY_KEY
case|:
block|{
if|if
condition|(
operator|!
name|primaryKeys
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|INVALID_CONSTRAINT
operator|.
name|getMsg
argument_list|(
literal|"Cannot exist more than one primary key definition for the same table"
argument_list|)
argument_list|)
throw|;
block|}
name|String
index|[]
name|qualifiedTabName
init|=
name|getQualifiedTableName
argument_list|(
operator|(
name|ASTNode
operator|)
name|parent
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|processPrimaryKeys
argument_list|(
name|qualifiedTabName
index|[
literal|0
index|]
argument_list|,
name|qualifiedTabName
index|[
literal|1
index|]
argument_list|,
name|child
argument_list|,
name|primaryKeys
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|HiveParser
operator|.
name|TOK_FOREIGN_KEY
case|:
block|{
name|String
index|[]
name|qualifiedTabName
init|=
name|getQualifiedTableName
argument_list|(
operator|(
name|ASTNode
operator|)
name|parent
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|processForeignKeys
argument_list|(
name|qualifiedTabName
index|[
literal|0
index|]
argument_list|,
name|qualifiedTabName
index|[
literal|1
index|]
argument_list|,
name|child
argument_list|,
name|foreignKeys
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
name|Tree
name|grandChild
init|=
name|child
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|grandChild
operator|!=
literal|null
condition|)
block|{
name|String
name|name
init|=
name|grandChild
operator|.
name|getText
argument_list|()
decl_stmt|;
if|if
condition|(
name|lowerCase
condition|)
block|{
name|name
operator|=
name|name
operator|.
name|toLowerCase
argument_list|()
expr_stmt|;
block|}
name|checkColumnName
argument_list|(
name|name
argument_list|)
expr_stmt|;
comment|// child 0 is the name of the column
name|col
operator|.
name|setName
argument_list|(
name|unescapeIdentifier
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
comment|// child 1 is the type of the column
name|ASTNode
name|typeChild
init|=
call|(
name|ASTNode
call|)
argument_list|(
name|child
operator|.
name|getChild
argument_list|(
literal|1
argument_list|)
argument_list|)
decl_stmt|;
name|col
operator|.
name|setType
argument_list|(
name|getTypeStringFromAST
argument_list|(
name|typeChild
argument_list|)
argument_list|)
expr_stmt|;
comment|// child 2 is the optional comment of the column
comment|// child 3 is the optional constraint
name|ASTNode
name|constraintChild
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|child
operator|.
name|getChildCount
argument_list|()
operator|==
literal|4
condition|)
block|{
name|col
operator|.
name|setComment
argument_list|(
name|unescapeSQLString
argument_list|(
name|child
operator|.
name|getChild
argument_list|(
literal|2
argument_list|)
operator|.
name|getText
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|constraintChild
operator|=
operator|(
name|ASTNode
operator|)
name|child
operator|.
name|getChild
argument_list|(
literal|3
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|child
operator|.
name|getChildCount
argument_list|()
operator|==
literal|3
operator|&&
operator|(
operator|(
name|ASTNode
operator|)
name|child
operator|.
name|getChild
argument_list|(
literal|2
argument_list|)
operator|)
operator|.
name|getToken
argument_list|()
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|StringLiteral
condition|)
block|{
name|col
operator|.
name|setComment
argument_list|(
name|unescapeSQLString
argument_list|(
name|child
operator|.
name|getChild
argument_list|(
literal|2
argument_list|)
operator|.
name|getText
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|child
operator|.
name|getChildCount
argument_list|()
operator|==
literal|3
condition|)
block|{
name|constraintChild
operator|=
operator|(
name|ASTNode
operator|)
name|child
operator|.
name|getChild
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|constraintChild
operator|!=
literal|null
condition|)
block|{
name|String
index|[]
name|qualifiedTabName
init|=
name|getQualifiedTableName
argument_list|(
operator|(
name|ASTNode
operator|)
name|parent
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
argument_list|)
decl_stmt|;
comment|// Process column constraint
switch|switch
condition|(
name|constraintChild
operator|.
name|getToken
argument_list|()
operator|.
name|getType
argument_list|()
condition|)
block|{
case|case
name|HiveParser
operator|.
name|TOK_NOT_NULL
case|:
name|processNotNullConstraints
argument_list|(
name|qualifiedTabName
index|[
literal|0
index|]
argument_list|,
name|qualifiedTabName
index|[
literal|1
index|]
argument_list|,
name|constraintChild
argument_list|,
name|ImmutableList
operator|.
name|of
argument_list|(
name|col
operator|.
name|getName
argument_list|()
argument_list|)
argument_list|,
name|notNullConstraints
argument_list|)
expr_stmt|;
break|break;
case|case
name|HiveParser
operator|.
name|TOK_UNIQUE
case|:
name|processUniqueConstraints
argument_list|(
name|qualifiedTabName
index|[
literal|0
index|]
argument_list|,
name|qualifiedTabName
index|[
literal|1
index|]
argument_list|,
name|constraintChild
argument_list|,
name|ImmutableList
operator|.
name|of
argument_list|(
name|col
operator|.
name|getName
argument_list|()
argument_list|)
argument_list|,
name|uniqueConstraints
argument_list|)
expr_stmt|;
break|break;
case|case
name|HiveParser
operator|.
name|TOK_PRIMARY_KEY
case|:
if|if
condition|(
operator|!
name|primaryKeys
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|INVALID_CONSTRAINT
operator|.
name|getMsg
argument_list|(
literal|"Cannot exist more than one primary key definition for the same table"
argument_list|)
argument_list|)
throw|;
block|}
name|processPrimaryKeys
argument_list|(
name|qualifiedTabName
index|[
literal|0
index|]
argument_list|,
name|qualifiedTabName
index|[
literal|1
index|]
argument_list|,
name|constraintChild
argument_list|,
name|ImmutableList
operator|.
name|of
argument_list|(
name|col
operator|.
name|getName
argument_list|()
argument_list|)
argument_list|,
name|primaryKeys
argument_list|)
expr_stmt|;
break|break;
case|case
name|HiveParser
operator|.
name|TOK_FOREIGN_KEY
case|:
name|processForeignKeys
argument_list|(
name|qualifiedTabName
index|[
literal|0
index|]
argument_list|,
name|qualifiedTabName
index|[
literal|1
index|]
argument_list|,
name|constraintChild
argument_list|,
name|foreignKeys
argument_list|)
expr_stmt|;
break|break;
default|default:
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|NOT_RECOGNIZED_CONSTRAINT
operator|.
name|getMsg
argument_list|(
name|constraintChild
operator|.
name|getToken
argument_list|()
operator|.
name|getText
argument_list|()
argument_list|)
argument_list|)
throw|;
block|}
block|}
block|}
name|colList
operator|.
name|add
argument_list|(
name|col
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
return|return
name|colList
return|;
block|}
specifier|public
specifier|static
name|List
argument_list|<
name|String
argument_list|>
name|getColumnNames
parameter_list|(
name|ASTNode
name|ast
parameter_list|)
block|{
name|List
argument_list|<
name|String
argument_list|>
name|colList
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
name|int
name|numCh
init|=
name|ast
operator|.
name|getChildCount
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numCh
condition|;
name|i
operator|++
control|)
block|{
name|ASTNode
name|child
init|=
operator|(
name|ASTNode
operator|)
name|ast
operator|.
name|getChild
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|colList
operator|.
name|add
argument_list|(
name|unescapeIdentifier
argument_list|(
name|child
operator|.
name|getText
argument_list|()
argument_list|)
operator|.
name|toLowerCase
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|colList
return|;
block|}
specifier|protected
name|List
argument_list|<
name|Order
argument_list|>
name|getColumnNamesOrder
parameter_list|(
name|ASTNode
name|ast
parameter_list|)
throws|throws
name|SemanticException
block|{
name|List
argument_list|<
name|Order
argument_list|>
name|colList
init|=
operator|new
name|ArrayList
argument_list|<
name|Order
argument_list|>
argument_list|()
decl_stmt|;
name|int
name|numCh
init|=
name|ast
operator|.
name|getChildCount
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numCh
condition|;
name|i
operator|++
control|)
block|{
name|ASTNode
name|child
init|=
operator|(
name|ASTNode
operator|)
name|ast
operator|.
name|getChild
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|child
operator|.
name|getToken
argument_list|()
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_TABSORTCOLNAMEASC
condition|)
block|{
name|child
operator|=
operator|(
name|ASTNode
operator|)
name|child
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|child
operator|.
name|getToken
argument_list|()
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_NULLS_FIRST
condition|)
block|{
name|colList
operator|.
name|add
argument_list|(
operator|new
name|Order
argument_list|(
name|unescapeIdentifier
argument_list|(
name|child
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getText
argument_list|()
argument_list|)
operator|.
name|toLowerCase
argument_list|()
argument_list|,
name|HIVE_COLUMN_ORDER_ASC
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
literal|"create/alter table: "
operator|+
literal|"not supported NULLS LAST for ORDER BY in ASC order"
argument_list|)
throw|;
block|}
block|}
else|else
block|{
name|child
operator|=
operator|(
name|ASTNode
operator|)
name|child
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|child
operator|.
name|getToken
argument_list|()
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_NULLS_LAST
condition|)
block|{
name|colList
operator|.
name|add
argument_list|(
operator|new
name|Order
argument_list|(
name|unescapeIdentifier
argument_list|(
name|child
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getText
argument_list|()
argument_list|)
operator|.
name|toLowerCase
argument_list|()
argument_list|,
name|HIVE_COLUMN_ORDER_DESC
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
literal|"create/alter table: "
operator|+
literal|"not supported NULLS FIRST for ORDER BY in DESC order"
argument_list|)
throw|;
block|}
block|}
block|}
return|return
name|colList
return|;
block|}
specifier|protected
specifier|static
name|String
name|getTypeStringFromAST
parameter_list|(
name|ASTNode
name|typeNode
parameter_list|)
throws|throws
name|SemanticException
block|{
switch|switch
condition|(
name|typeNode
operator|.
name|getType
argument_list|()
condition|)
block|{
case|case
name|HiveParser
operator|.
name|TOK_LIST
case|:
return|return
name|serdeConstants
operator|.
name|LIST_TYPE_NAME
operator|+
literal|"<"
operator|+
name|getTypeStringFromAST
argument_list|(
operator|(
name|ASTNode
operator|)
name|typeNode
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
argument_list|)
operator|+
literal|">"
return|;
case|case
name|HiveParser
operator|.
name|TOK_MAP
case|:
return|return
name|serdeConstants
operator|.
name|MAP_TYPE_NAME
operator|+
literal|"<"
operator|+
name|getTypeStringFromAST
argument_list|(
operator|(
name|ASTNode
operator|)
name|typeNode
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
argument_list|)
operator|+
literal|","
operator|+
name|getTypeStringFromAST
argument_list|(
operator|(
name|ASTNode
operator|)
name|typeNode
operator|.
name|getChild
argument_list|(
literal|1
argument_list|)
argument_list|)
operator|+
literal|">"
return|;
case|case
name|HiveParser
operator|.
name|TOK_STRUCT
case|:
return|return
name|getStructTypeStringFromAST
argument_list|(
name|typeNode
argument_list|)
return|;
case|case
name|HiveParser
operator|.
name|TOK_UNIONTYPE
case|:
return|return
name|getUnionTypeStringFromAST
argument_list|(
name|typeNode
argument_list|)
return|;
default|default:
return|return
name|DDLSemanticAnalyzer
operator|.
name|getTypeName
argument_list|(
name|typeNode
argument_list|)
return|;
block|}
block|}
specifier|private
specifier|static
name|String
name|getStructTypeStringFromAST
parameter_list|(
name|ASTNode
name|typeNode
parameter_list|)
throws|throws
name|SemanticException
block|{
name|String
name|typeStr
init|=
name|serdeConstants
operator|.
name|STRUCT_TYPE_NAME
operator|+
literal|"<"
decl_stmt|;
name|typeNode
operator|=
operator|(
name|ASTNode
operator|)
name|typeNode
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|int
name|children
init|=
name|typeNode
operator|.
name|getChildCount
argument_list|()
decl_stmt|;
if|if
condition|(
name|children
operator|<=
literal|0
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
literal|"empty struct not allowed."
argument_list|)
throw|;
block|}
name|StringBuilder
name|buffer
init|=
operator|new
name|StringBuilder
argument_list|(
name|typeStr
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|children
condition|;
name|i
operator|++
control|)
block|{
name|ASTNode
name|child
init|=
operator|(
name|ASTNode
operator|)
name|typeNode
operator|.
name|getChild
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|buffer
operator|.
name|append
argument_list|(
name|unescapeIdentifier
argument_list|(
name|child
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getText
argument_list|()
argument_list|)
argument_list|)
operator|.
name|append
argument_list|(
literal|":"
argument_list|)
expr_stmt|;
name|buffer
operator|.
name|append
argument_list|(
name|getTypeStringFromAST
argument_list|(
operator|(
name|ASTNode
operator|)
name|child
operator|.
name|getChild
argument_list|(
literal|1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<
name|children
operator|-
literal|1
condition|)
block|{
name|buffer
operator|.
name|append
argument_list|(
literal|","
argument_list|)
expr_stmt|;
block|}
block|}
name|buffer
operator|.
name|append
argument_list|(
literal|">"
argument_list|)
expr_stmt|;
return|return
name|buffer
operator|.
name|toString
argument_list|()
return|;
block|}
specifier|private
specifier|static
name|String
name|getUnionTypeStringFromAST
parameter_list|(
name|ASTNode
name|typeNode
parameter_list|)
throws|throws
name|SemanticException
block|{
name|String
name|typeStr
init|=
name|serdeConstants
operator|.
name|UNION_TYPE_NAME
operator|+
literal|"<"
decl_stmt|;
name|typeNode
operator|=
operator|(
name|ASTNode
operator|)
name|typeNode
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|int
name|children
init|=
name|typeNode
operator|.
name|getChildCount
argument_list|()
decl_stmt|;
if|if
condition|(
name|children
operator|<=
literal|0
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
literal|"empty union not allowed."
argument_list|)
throw|;
block|}
name|StringBuilder
name|buffer
init|=
operator|new
name|StringBuilder
argument_list|(
name|typeStr
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|children
condition|;
name|i
operator|++
control|)
block|{
name|buffer
operator|.
name|append
argument_list|(
name|getTypeStringFromAST
argument_list|(
operator|(
name|ASTNode
operator|)
name|typeNode
operator|.
name|getChild
argument_list|(
name|i
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<
name|children
operator|-
literal|1
condition|)
block|{
name|buffer
operator|.
name|append
argument_list|(
literal|","
argument_list|)
expr_stmt|;
block|}
block|}
name|buffer
operator|.
name|append
argument_list|(
literal|">"
argument_list|)
expr_stmt|;
name|typeStr
operator|=
name|buffer
operator|.
name|toString
argument_list|()
expr_stmt|;
return|return
name|typeStr
return|;
block|}
comment|/**    * TableSpec.    *    */
specifier|public
specifier|static
class|class
name|TableSpec
block|{
specifier|public
name|String
name|tableName
decl_stmt|;
specifier|public
name|Table
name|tableHandle
decl_stmt|;
specifier|public
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|partSpec
decl_stmt|;
comment|// has to use LinkedHashMap to enforce order
specifier|public
name|Partition
name|partHandle
decl_stmt|;
specifier|public
name|int
name|numDynParts
decl_stmt|;
comment|// number of dynamic partition columns
specifier|public
name|List
argument_list|<
name|Partition
argument_list|>
name|partitions
decl_stmt|;
comment|// involved partitions in TableScanOperator/FileSinkOperator
specifier|public
specifier|static
enum|enum
name|SpecType
block|{
name|TABLE_ONLY
block|,
name|STATIC_PARTITION
block|,
name|DYNAMIC_PARTITION
block|}
empty_stmt|;
specifier|public
name|SpecType
name|specType
decl_stmt|;
specifier|public
name|TableSpec
parameter_list|(
name|Hive
name|db
parameter_list|,
name|HiveConf
name|conf
parameter_list|,
name|ASTNode
name|ast
parameter_list|)
throws|throws
name|SemanticException
block|{
name|this
argument_list|(
name|db
argument_list|,
name|conf
argument_list|,
name|ast
argument_list|,
literal|true
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
specifier|public
name|TableSpec
parameter_list|(
name|Hive
name|db
parameter_list|,
name|HiveConf
name|conf
parameter_list|,
name|String
name|tableName
parameter_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|partSpec
parameter_list|)
throws|throws
name|HiveException
block|{
name|this
operator|.
name|tableName
operator|=
name|tableName
expr_stmt|;
name|this
operator|.
name|partSpec
operator|=
name|partSpec
expr_stmt|;
name|this
operator|.
name|tableHandle
operator|=
name|db
operator|.
name|getTable
argument_list|(
name|tableName
argument_list|)
expr_stmt|;
if|if
condition|(
name|partSpec
operator|!=
literal|null
condition|)
block|{
name|this
operator|.
name|specType
operator|=
name|SpecType
operator|.
name|STATIC_PARTITION
expr_stmt|;
name|this
operator|.
name|partHandle
operator|=
name|db
operator|.
name|getPartition
argument_list|(
name|tableHandle
argument_list|,
name|partSpec
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|this
operator|.
name|partitions
operator|=
name|Arrays
operator|.
name|asList
argument_list|(
name|partHandle
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|this
operator|.
name|specType
operator|=
name|SpecType
operator|.
name|TABLE_ONLY
expr_stmt|;
block|}
block|}
specifier|public
name|TableSpec
parameter_list|(
name|Table
name|tableHandle
parameter_list|,
name|List
argument_list|<
name|Partition
argument_list|>
name|partitions
parameter_list|)
throws|throws
name|HiveException
block|{
name|this
operator|.
name|tableHandle
operator|=
name|tableHandle
expr_stmt|;
name|this
operator|.
name|tableName
operator|=
name|tableHandle
operator|.
name|getTableName
argument_list|()
expr_stmt|;
if|if
condition|(
name|partitions
operator|!=
literal|null
operator|&&
operator|!
name|partitions
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|this
operator|.
name|specType
operator|=
name|SpecType
operator|.
name|STATIC_PARTITION
expr_stmt|;
name|this
operator|.
name|partitions
operator|=
name|partitions
expr_stmt|;
name|List
argument_list|<
name|FieldSchema
argument_list|>
name|partCols
init|=
name|this
operator|.
name|tableHandle
operator|.
name|getPartCols
argument_list|()
decl_stmt|;
name|this
operator|.
name|partSpec
operator|=
operator|new
name|LinkedHashMap
argument_list|<>
argument_list|()
expr_stmt|;
for|for
control|(
name|FieldSchema
name|partCol
range|:
name|partCols
control|)
block|{
name|partSpec
operator|.
name|put
argument_list|(
name|partCol
operator|.
name|getName
argument_list|()
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|this
operator|.
name|specType
operator|=
name|SpecType
operator|.
name|TABLE_ONLY
expr_stmt|;
block|}
block|}
specifier|public
name|TableSpec
parameter_list|(
name|Hive
name|db
parameter_list|,
name|HiveConf
name|conf
parameter_list|,
name|ASTNode
name|ast
parameter_list|,
name|boolean
name|allowDynamicPartitionsSpec
parameter_list|,
name|boolean
name|allowPartialPartitionsSpec
parameter_list|)
throws|throws
name|SemanticException
block|{
assert|assert
operator|(
name|ast
operator|.
name|getToken
argument_list|()
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_TAB
operator|||
name|ast
operator|.
name|getToken
argument_list|()
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_TABLE_PARTITION
operator|||
name|ast
operator|.
name|getToken
argument_list|()
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_TABTYPE
operator|||
name|ast
operator|.
name|getToken
argument_list|()
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_CREATETABLE
operator|||
name|ast
operator|.
name|getToken
argument_list|()
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_CREATE_MATERIALIZED_VIEW
operator|)
assert|;
name|int
name|childIndex
init|=
literal|0
decl_stmt|;
name|numDynParts
operator|=
literal|0
expr_stmt|;
try|try
block|{
comment|// get table metadata
name|tableName
operator|=
name|getUnescapedName
argument_list|(
operator|(
name|ASTNode
operator|)
name|ast
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|boolean
name|testMode
init|=
name|conf
operator|.
name|getBoolVar
argument_list|(
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVETESTMODE
argument_list|)
decl_stmt|;
if|if
condition|(
name|testMode
condition|)
block|{
name|tableName
operator|=
name|conf
operator|.
name|getVar
argument_list|(
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVETESTMODEPREFIX
argument_list|)
operator|+
name|tableName
expr_stmt|;
block|}
if|if
condition|(
name|ast
operator|.
name|getToken
argument_list|()
operator|.
name|getType
argument_list|()
operator|!=
name|HiveParser
operator|.
name|TOK_CREATETABLE
operator|&&
name|ast
operator|.
name|getToken
argument_list|()
operator|.
name|getType
argument_list|()
operator|!=
name|HiveParser
operator|.
name|TOK_CREATE_MATERIALIZED_VIEW
condition|)
block|{
name|tableHandle
operator|=
name|db
operator|.
name|getTable
argument_list|(
name|tableName
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|InvalidTableException
name|ite
parameter_list|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|INVALID_TABLE
operator|.
name|getMsg
argument_list|(
name|ast
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
argument_list|)
argument_list|,
name|ite
argument_list|)
throw|;
block|}
catch|catch
parameter_list|(
name|HiveException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|CANNOT_RETRIEVE_TABLE_METADATA
operator|.
name|getMsg
argument_list|(
name|ast
operator|.
name|getChild
argument_list|(
name|childIndex
argument_list|)
argument_list|,
name|e
operator|.
name|getMessage
argument_list|()
argument_list|)
argument_list|,
name|e
argument_list|)
throw|;
block|}
comment|// get partition metadata if partition specified
if|if
condition|(
name|ast
operator|.
name|getChildCount
argument_list|()
operator|==
literal|2
operator|&&
name|ast
operator|.
name|getToken
argument_list|()
operator|.
name|getType
argument_list|()
operator|!=
name|HiveParser
operator|.
name|TOK_CREATETABLE
operator|&&
name|ast
operator|.
name|getToken
argument_list|()
operator|.
name|getType
argument_list|()
operator|!=
name|HiveParser
operator|.
name|TOK_CREATE_MATERIALIZED_VIEW
condition|)
block|{
name|childIndex
operator|=
literal|1
expr_stmt|;
name|ASTNode
name|partspec
init|=
operator|(
name|ASTNode
operator|)
name|ast
operator|.
name|getChild
argument_list|(
literal|1
argument_list|)
decl_stmt|;
name|partitions
operator|=
operator|new
name|ArrayList
argument_list|<
name|Partition
argument_list|>
argument_list|()
expr_stmt|;
comment|// partSpec is a mapping from partition column name to its value.
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|tmpPartSpec
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
argument_list|(
name|partspec
operator|.
name|getChildCount
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|partspec
operator|.
name|getChildCount
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|ASTNode
name|partspec_val
init|=
operator|(
name|ASTNode
operator|)
name|partspec
operator|.
name|getChild
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|String
name|val
init|=
literal|null
decl_stmt|;
name|String
name|colName
init|=
name|unescapeIdentifier
argument_list|(
name|partspec_val
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getText
argument_list|()
operator|.
name|toLowerCase
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|partspec_val
operator|.
name|getChildCount
argument_list|()
operator|<
literal|2
condition|)
block|{
comment|// DP in the form of T partition (ds, hr)
if|if
condition|(
name|allowDynamicPartitionsSpec
condition|)
block|{
operator|++
name|numDynParts
expr_stmt|;
block|}
else|else
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|INVALID_PARTITION
operator|.
name|getMsg
argument_list|(
literal|" - Dynamic partitions not allowed"
argument_list|)
argument_list|)
throw|;
block|}
block|}
else|else
block|{
comment|// in the form of T partition (ds="2010-03-03")
name|val
operator|=
name|stripQuotes
argument_list|(
name|partspec_val
operator|.
name|getChild
argument_list|(
literal|1
argument_list|)
operator|.
name|getText
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|tmpPartSpec
operator|.
name|put
argument_list|(
name|colName
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
comment|// check if the columns, as well as value types in the partition() clause are valid
name|validatePartSpec
argument_list|(
name|tableHandle
argument_list|,
name|tmpPartSpec
argument_list|,
name|ast
argument_list|,
name|conf
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|FieldSchema
argument_list|>
name|parts
init|=
name|tableHandle
operator|.
name|getPartitionKeys
argument_list|()
decl_stmt|;
name|partSpec
operator|=
operator|new
name|LinkedHashMap
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
argument_list|(
name|partspec
operator|.
name|getChildCount
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|FieldSchema
name|fs
range|:
name|parts
control|)
block|{
name|String
name|partKey
init|=
name|fs
operator|.
name|getName
argument_list|()
decl_stmt|;
name|partSpec
operator|.
name|put
argument_list|(
name|partKey
argument_list|,
name|tmpPartSpec
operator|.
name|get
argument_list|(
name|partKey
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// check if the partition spec is valid
if|if
condition|(
name|numDynParts
operator|>
literal|0
condition|)
block|{
name|int
name|numStaPart
init|=
name|parts
operator|.
name|size
argument_list|()
operator|-
name|numDynParts
decl_stmt|;
if|if
condition|(
name|numStaPart
operator|==
literal|0
operator|&&
name|conf
operator|.
name|getVar
argument_list|(
name|HiveConf
operator|.
name|ConfVars
operator|.
name|DYNAMICPARTITIONINGMODE
argument_list|)
operator|.
name|equalsIgnoreCase
argument_list|(
literal|"strict"
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|DYNAMIC_PARTITION_STRICT_MODE
operator|.
name|getMsg
argument_list|()
argument_list|)
throw|;
block|}
comment|// check the partitions in partSpec be the same as defined in table schema
if|if
condition|(
name|partSpec
operator|.
name|keySet
argument_list|()
operator|.
name|size
argument_list|()
operator|!=
name|parts
operator|.
name|size
argument_list|()
condition|)
block|{
name|ErrorPartSpec
argument_list|(
name|partSpec
argument_list|,
name|parts
argument_list|)
expr_stmt|;
block|}
name|Iterator
argument_list|<
name|String
argument_list|>
name|itrPsKeys
init|=
name|partSpec
operator|.
name|keySet
argument_list|()
operator|.
name|iterator
argument_list|()
decl_stmt|;
for|for
control|(
name|FieldSchema
name|fs
range|:
name|parts
control|)
block|{
if|if
condition|(
operator|!
name|itrPsKeys
operator|.
name|next
argument_list|()
operator|.
name|toLowerCase
argument_list|()
operator|.
name|equals
argument_list|(
name|fs
operator|.
name|getName
argument_list|()
operator|.
name|toLowerCase
argument_list|()
argument_list|)
condition|)
block|{
name|ErrorPartSpec
argument_list|(
name|partSpec
argument_list|,
name|parts
argument_list|)
expr_stmt|;
block|}
block|}
comment|// check if static partition appear after dynamic partitions
for|for
control|(
name|FieldSchema
name|fs
range|:
name|parts
control|)
block|{
if|if
condition|(
name|partSpec
operator|.
name|get
argument_list|(
name|fs
operator|.
name|getName
argument_list|()
operator|.
name|toLowerCase
argument_list|()
argument_list|)
operator|==
literal|null
condition|)
block|{
if|if
condition|(
name|numStaPart
operator|>
literal|0
condition|)
block|{
comment|// found a DP, but there exists ST as subpartition
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|PARTITION_DYN_STA_ORDER
operator|.
name|getMsg
argument_list|(
name|ast
operator|.
name|getChild
argument_list|(
name|childIndex
argument_list|)
argument_list|)
argument_list|)
throw|;
block|}
break|break;
block|}
else|else
block|{
operator|--
name|numStaPart
expr_stmt|;
block|}
block|}
name|partHandle
operator|=
literal|null
expr_stmt|;
name|specType
operator|=
name|SpecType
operator|.
name|DYNAMIC_PARTITION
expr_stmt|;
block|}
else|else
block|{
try|try
block|{
if|if
condition|(
name|allowPartialPartitionsSpec
condition|)
block|{
name|partitions
operator|=
name|db
operator|.
name|getPartitions
argument_list|(
name|tableHandle
argument_list|,
name|partSpec
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// this doesn't create partition.
name|partHandle
operator|=
name|db
operator|.
name|getPartition
argument_list|(
name|tableHandle
argument_list|,
name|partSpec
argument_list|,
literal|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|partHandle
operator|==
literal|null
condition|)
block|{
comment|// if partSpec doesn't exists in DB, return a delegate one
comment|// and the actual partition is created in MoveTask
name|partHandle
operator|=
operator|new
name|Partition
argument_list|(
name|tableHandle
argument_list|,
name|partSpec
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|partitions
operator|.
name|add
argument_list|(
name|partHandle
argument_list|)
expr_stmt|;
block|}
block|}
block|}
catch|catch
parameter_list|(
name|HiveException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|INVALID_PARTITION
operator|.
name|getMsg
argument_list|(
name|ast
operator|.
name|getChild
argument_list|(
name|childIndex
argument_list|)
argument_list|)
argument_list|,
name|e
argument_list|)
throw|;
block|}
name|specType
operator|=
name|SpecType
operator|.
name|STATIC_PARTITION
expr_stmt|;
block|}
block|}
else|else
block|{
name|specType
operator|=
name|SpecType
operator|.
name|TABLE_ONLY
expr_stmt|;
block|}
block|}
specifier|public
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|getPartSpec
parameter_list|()
block|{
return|return
name|this
operator|.
name|partSpec
return|;
block|}
specifier|public
name|void
name|setPartSpec
parameter_list|(
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|partSpec
parameter_list|)
block|{
name|this
operator|.
name|partSpec
operator|=
name|partSpec
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|toString
parameter_list|()
block|{
if|if
condition|(
name|partHandle
operator|!=
literal|null
condition|)
block|{
return|return
name|partHandle
operator|.
name|toString
argument_list|()
return|;
block|}
else|else
block|{
return|return
name|tableHandle
operator|.
name|toString
argument_list|()
return|;
block|}
block|}
block|}
specifier|public
class|class
name|AnalyzeRewriteContext
block|{
specifier|private
name|String
name|tableName
decl_stmt|;
specifier|private
name|List
argument_list|<
name|String
argument_list|>
name|colName
decl_stmt|;
specifier|private
name|List
argument_list|<
name|String
argument_list|>
name|colType
decl_stmt|;
specifier|private
name|boolean
name|tblLvl
decl_stmt|;
specifier|public
name|String
name|getTableName
parameter_list|()
block|{
return|return
name|tableName
return|;
block|}
specifier|public
name|void
name|setTableName
parameter_list|(
name|String
name|tableName
parameter_list|)
block|{
name|this
operator|.
name|tableName
operator|=
name|tableName
expr_stmt|;
block|}
specifier|public
name|List
argument_list|<
name|String
argument_list|>
name|getColName
parameter_list|()
block|{
return|return
name|colName
return|;
block|}
specifier|public
name|void
name|setColName
parameter_list|(
name|List
argument_list|<
name|String
argument_list|>
name|colName
parameter_list|)
block|{
name|this
operator|.
name|colName
operator|=
name|colName
expr_stmt|;
block|}
specifier|public
name|boolean
name|isTblLvl
parameter_list|()
block|{
return|return
name|tblLvl
return|;
block|}
specifier|public
name|void
name|setTblLvl
parameter_list|(
name|boolean
name|isTblLvl
parameter_list|)
block|{
name|this
operator|.
name|tblLvl
operator|=
name|isTblLvl
expr_stmt|;
block|}
specifier|public
name|List
argument_list|<
name|String
argument_list|>
name|getColType
parameter_list|()
block|{
return|return
name|colType
return|;
block|}
specifier|public
name|void
name|setColType
parameter_list|(
name|List
argument_list|<
name|String
argument_list|>
name|colType
parameter_list|)
block|{
name|this
operator|.
name|colType
operator|=
name|colType
expr_stmt|;
block|}
block|}
comment|/**    * Gets the lineage information.    *    * @return LineageInfo associated with the query.    */
specifier|public
name|LineageInfo
name|getLineageInfo
parameter_list|()
block|{
return|return
name|linfo
return|;
block|}
comment|/**    * Sets the lineage information.    *    * @param linfo The LineageInfo structure that is set in the optimization phase.    */
specifier|public
name|void
name|setLineageInfo
parameter_list|(
name|LineageInfo
name|linfo
parameter_list|)
block|{
name|this
operator|.
name|linfo
operator|=
name|linfo
expr_stmt|;
block|}
comment|/**    * Gets the table access information.    *    * @return TableAccessInfo associated with the query.    */
specifier|public
name|TableAccessInfo
name|getTableAccessInfo
parameter_list|()
block|{
return|return
name|tableAccessInfo
return|;
block|}
comment|/**    * Sets the table access information.    *    * @param tableAccessInfo The TableAccessInfo structure that is set in the optimization phase.    */
specifier|public
name|void
name|setTableAccessInfo
parameter_list|(
name|TableAccessInfo
name|tableAccessInfo
parameter_list|)
block|{
name|this
operator|.
name|tableAccessInfo
operator|=
name|tableAccessInfo
expr_stmt|;
block|}
comment|/**    * Gets the column access information.    *    * @return ColumnAccessInfo associated with the query.    */
specifier|public
name|ColumnAccessInfo
name|getColumnAccessInfo
parameter_list|()
block|{
return|return
name|columnAccessInfo
return|;
block|}
comment|/**    * Sets the column access information.    *    * @param columnAccessInfo The ColumnAccessInfo structure that is set immediately after    * the optimization phase.    */
specifier|public
name|void
name|setColumnAccessInfo
parameter_list|(
name|ColumnAccessInfo
name|columnAccessInfo
parameter_list|)
block|{
name|this
operator|.
name|columnAccessInfo
operator|=
name|columnAccessInfo
expr_stmt|;
block|}
specifier|public
name|ColumnAccessInfo
name|getUpdateColumnAccessInfo
parameter_list|()
block|{
return|return
name|updateColumnAccessInfo
return|;
block|}
specifier|public
name|void
name|setUpdateColumnAccessInfo
parameter_list|(
name|ColumnAccessInfo
name|updateColumnAccessInfo
parameter_list|)
block|{
name|this
operator|.
name|updateColumnAccessInfo
operator|=
name|updateColumnAccessInfo
expr_stmt|;
block|}
comment|/**    * Checks if given specification is proper specification for prefix of    * partition cols, for table partitioned by ds, hr, min valid ones are    * (ds='2008-04-08'), (ds='2008-04-08', hr='12'), (ds='2008-04-08', hr='12', min='30')    * invalid one is for example (ds='2008-04-08', min='30')    * @param spec specification key-value map    * @return true if the specification is prefix; never returns false, but throws    * @throws HiveException    */
specifier|public
specifier|final
name|boolean
name|isValidPrefixSpec
parameter_list|(
name|Table
name|tTable
parameter_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|spec
parameter_list|)
throws|throws
name|HiveException
block|{
comment|// TODO - types need to be checked.
name|List
argument_list|<
name|FieldSchema
argument_list|>
name|partCols
init|=
name|tTable
operator|.
name|getPartitionKeys
argument_list|()
decl_stmt|;
if|if
condition|(
name|partCols
operator|==
literal|null
operator|||
operator|(
name|partCols
operator|.
name|size
argument_list|()
operator|==
literal|0
operator|)
condition|)
block|{
if|if
condition|(
name|spec
operator|!=
literal|null
condition|)
block|{
throw|throw
operator|new
name|HiveException
argument_list|(
literal|"table is not partitioned but partition spec exists: "
operator|+
name|spec
argument_list|)
throw|;
block|}
else|else
block|{
return|return
literal|true
return|;
block|}
block|}
if|if
condition|(
name|spec
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|HiveException
argument_list|(
literal|"partition spec is not specified"
argument_list|)
throw|;
block|}
name|Iterator
argument_list|<
name|String
argument_list|>
name|itrPsKeys
init|=
name|spec
operator|.
name|keySet
argument_list|()
operator|.
name|iterator
argument_list|()
decl_stmt|;
for|for
control|(
name|FieldSchema
name|fs
range|:
name|partCols
control|)
block|{
if|if
condition|(
operator|!
name|itrPsKeys
operator|.
name|hasNext
argument_list|()
condition|)
block|{
break|break;
block|}
if|if
condition|(
operator|!
name|itrPsKeys
operator|.
name|next
argument_list|()
operator|.
name|toLowerCase
argument_list|()
operator|.
name|equals
argument_list|(
name|fs
operator|.
name|getName
argument_list|()
operator|.
name|toLowerCase
argument_list|()
argument_list|)
condition|)
block|{
name|ErrorPartSpec
argument_list|(
name|spec
argument_list|,
name|partCols
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|itrPsKeys
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|ErrorPartSpec
argument_list|(
name|spec
argument_list|,
name|partCols
argument_list|)
expr_stmt|;
block|}
return|return
literal|true
return|;
block|}
specifier|private
specifier|static
name|void
name|ErrorPartSpec
parameter_list|(
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|partSpec
parameter_list|,
name|List
argument_list|<
name|FieldSchema
argument_list|>
name|parts
parameter_list|)
throws|throws
name|SemanticException
block|{
name|StringBuilder
name|sb
init|=
operator|new
name|StringBuilder
argument_list|(
literal|"Partition columns in the table schema are: ("
argument_list|)
decl_stmt|;
for|for
control|(
name|FieldSchema
name|fs
range|:
name|parts
control|)
block|{
name|sb
operator|.
name|append
argument_list|(
name|fs
operator|.
name|getName
argument_list|()
argument_list|)
operator|.
name|append
argument_list|(
literal|", "
argument_list|)
expr_stmt|;
block|}
name|sb
operator|.
name|setLength
argument_list|(
name|sb
operator|.
name|length
argument_list|()
operator|-
literal|2
argument_list|)
expr_stmt|;
comment|// remove the last ", "
name|sb
operator|.
name|append
argument_list|(
literal|"), while the partitions specified in the query are: ("
argument_list|)
expr_stmt|;
name|Iterator
argument_list|<
name|String
argument_list|>
name|itrPsKeys
init|=
name|partSpec
operator|.
name|keySet
argument_list|()
operator|.
name|iterator
argument_list|()
decl_stmt|;
while|while
condition|(
name|itrPsKeys
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|sb
operator|.
name|append
argument_list|(
name|itrPsKeys
operator|.
name|next
argument_list|()
argument_list|)
operator|.
name|append
argument_list|(
literal|", "
argument_list|)
expr_stmt|;
block|}
name|sb
operator|.
name|setLength
argument_list|(
name|sb
operator|.
name|length
argument_list|()
operator|-
literal|2
argument_list|)
expr_stmt|;
comment|// remove the last ", "
name|sb
operator|.
name|append
argument_list|(
literal|")."
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|PARTSPEC_DIFFER_FROM_SCHEMA
operator|.
name|getMsg
argument_list|(
name|sb
operator|.
name|toString
argument_list|()
argument_list|)
argument_list|)
throw|;
block|}
specifier|public
name|Hive
name|getDb
parameter_list|()
block|{
return|return
name|db
return|;
block|}
specifier|public
name|QueryProperties
name|getQueryProperties
parameter_list|()
block|{
return|return
name|queryProperties
return|;
block|}
specifier|public
name|Set
argument_list|<
name|FileSinkDesc
argument_list|>
name|getAcidFileSinks
parameter_list|()
block|{
return|return
name|acidFileSinks
return|;
block|}
specifier|public
name|boolean
name|hasAcidInQuery
parameter_list|()
block|{
return|return
name|acidInQuery
return|;
block|}
comment|/**    * Construct list bucketing context.    *    * @param skewedColNames    * @param skewedValues    * @param skewedColValueLocationMaps    * @param isStoredAsSubDirectories    * @return    */
specifier|protected
name|ListBucketingCtx
name|constructListBucketingCtx
parameter_list|(
name|List
argument_list|<
name|String
argument_list|>
name|skewedColNames
parameter_list|,
name|List
argument_list|<
name|List
argument_list|<
name|String
argument_list|>
argument_list|>
name|skewedValues
parameter_list|,
name|Map
argument_list|<
name|List
argument_list|<
name|String
argument_list|>
argument_list|,
name|String
argument_list|>
name|skewedColValueLocationMaps
parameter_list|,
name|boolean
name|isStoredAsSubDirectories
parameter_list|,
name|HiveConf
name|conf
parameter_list|)
block|{
name|ListBucketingCtx
name|lbCtx
init|=
operator|new
name|ListBucketingCtx
argument_list|()
decl_stmt|;
name|lbCtx
operator|.
name|setSkewedColNames
argument_list|(
name|skewedColNames
argument_list|)
expr_stmt|;
name|lbCtx
operator|.
name|setSkewedColValues
argument_list|(
name|skewedValues
argument_list|)
expr_stmt|;
name|lbCtx
operator|.
name|setLbLocationMap
argument_list|(
name|skewedColValueLocationMaps
argument_list|)
expr_stmt|;
name|lbCtx
operator|.
name|setStoredAsSubDirectories
argument_list|(
name|isStoredAsSubDirectories
argument_list|)
expr_stmt|;
name|lbCtx
operator|.
name|setDefaultKey
argument_list|(
name|ListBucketingPrunerUtils
operator|.
name|HIVE_LIST_BUCKETING_DEFAULT_KEY
argument_list|)
expr_stmt|;
name|lbCtx
operator|.
name|setDefaultDirName
argument_list|(
name|ListBucketingPrunerUtils
operator|.
name|HIVE_LIST_BUCKETING_DEFAULT_DIR_NAME
argument_list|)
expr_stmt|;
return|return
name|lbCtx
return|;
block|}
comment|/**    * Given a ASTNode, return list of values.    *    * use case:    *   create table xyz list bucketed (col1) with skew (1,2,5)    *   AST Node is for (1,2,5)    * @param ast    * @return    */
specifier|protected
name|List
argument_list|<
name|String
argument_list|>
name|getSkewedValueFromASTNode
parameter_list|(
name|ASTNode
name|ast
parameter_list|)
block|{
name|List
argument_list|<
name|String
argument_list|>
name|colList
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
name|int
name|numCh
init|=
name|ast
operator|.
name|getChildCount
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numCh
condition|;
name|i
operator|++
control|)
block|{
name|ASTNode
name|child
init|=
operator|(
name|ASTNode
operator|)
name|ast
operator|.
name|getChild
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|colList
operator|.
name|add
argument_list|(
name|stripQuotes
argument_list|(
name|child
operator|.
name|getText
argument_list|()
argument_list|)
operator|.
name|toLowerCase
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|colList
return|;
block|}
comment|/**    * Retrieve skewed values from ASTNode.    *    * @param node    * @return    * @throws SemanticException    */
specifier|protected
name|List
argument_list|<
name|String
argument_list|>
name|getSkewedValuesFromASTNode
parameter_list|(
name|Node
name|node
parameter_list|)
throws|throws
name|SemanticException
block|{
name|List
argument_list|<
name|String
argument_list|>
name|result
init|=
literal|null
decl_stmt|;
name|Tree
name|leafVNode
init|=
operator|(
operator|(
name|ASTNode
operator|)
name|node
operator|)
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|leafVNode
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|SKEWED_TABLE_NO_COLUMN_VALUE
operator|.
name|getMsg
argument_list|()
argument_list|)
throw|;
block|}
else|else
block|{
name|ASTNode
name|lVAstNode
init|=
operator|(
name|ASTNode
operator|)
name|leafVNode
decl_stmt|;
if|if
condition|(
name|lVAstNode
operator|.
name|getToken
argument_list|()
operator|.
name|getType
argument_list|()
operator|!=
name|HiveParser
operator|.
name|TOK_TABCOLVALUE
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|SKEWED_TABLE_NO_COLUMN_VALUE
operator|.
name|getMsg
argument_list|()
argument_list|)
throw|;
block|}
else|else
block|{
name|result
operator|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|(
name|getSkewedValueFromASTNode
argument_list|(
name|lVAstNode
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|result
return|;
block|}
comment|/**    * Analyze list bucket column names    *    * @param skewedColNames    * @param child    * @return    * @throws SemanticException    */
specifier|protected
name|List
argument_list|<
name|String
argument_list|>
name|analyzeSkewedTablDDLColNames
parameter_list|(
name|List
argument_list|<
name|String
argument_list|>
name|skewedColNames
parameter_list|,
name|ASTNode
name|child
parameter_list|)
throws|throws
name|SemanticException
block|{
name|Tree
name|nNode
init|=
name|child
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|nNode
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|SKEWED_TABLE_NO_COLUMN_NAME
operator|.
name|getMsg
argument_list|()
argument_list|)
throw|;
block|}
else|else
block|{
name|ASTNode
name|nAstNode
init|=
operator|(
name|ASTNode
operator|)
name|nNode
decl_stmt|;
if|if
condition|(
name|nAstNode
operator|.
name|getToken
argument_list|()
operator|.
name|getType
argument_list|()
operator|!=
name|HiveParser
operator|.
name|TOK_TABCOLNAME
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|SKEWED_TABLE_NO_COLUMN_NAME
operator|.
name|getMsg
argument_list|()
argument_list|)
throw|;
block|}
else|else
block|{
name|skewedColNames
operator|=
name|getColumnNames
argument_list|(
name|nAstNode
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|skewedColNames
return|;
block|}
comment|/**    * Handle skewed values in DDL.    *    * It can be used by both skewed by ... on () and set skewed location ().    *    * @param skewedValues    * @param child    * @throws SemanticException    */
specifier|protected
name|void
name|analyzeDDLSkewedValues
parameter_list|(
name|List
argument_list|<
name|List
argument_list|<
name|String
argument_list|>
argument_list|>
name|skewedValues
parameter_list|,
name|ASTNode
name|child
parameter_list|)
throws|throws
name|SemanticException
block|{
name|Tree
name|vNode
init|=
name|child
operator|.
name|getChild
argument_list|(
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|vNode
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|SKEWED_TABLE_NO_COLUMN_VALUE
operator|.
name|getMsg
argument_list|()
argument_list|)
throw|;
block|}
name|ASTNode
name|vAstNode
init|=
operator|(
name|ASTNode
operator|)
name|vNode
decl_stmt|;
switch|switch
condition|(
name|vAstNode
operator|.
name|getToken
argument_list|()
operator|.
name|getType
argument_list|()
condition|)
block|{
case|case
name|HiveParser
operator|.
name|TOK_TABCOLVALUE
case|:
for|for
control|(
name|String
name|str
range|:
name|getSkewedValueFromASTNode
argument_list|(
name|vAstNode
argument_list|)
control|)
block|{
name|List
argument_list|<
name|String
argument_list|>
name|sList
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|(
name|Arrays
operator|.
name|asList
argument_list|(
name|str
argument_list|)
argument_list|)
decl_stmt|;
name|skewedValues
operator|.
name|add
argument_list|(
name|sList
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|HiveParser
operator|.
name|TOK_TABCOLVALUE_PAIR
case|:
name|ArrayList
argument_list|<
name|Node
argument_list|>
name|vLNodes
init|=
name|vAstNode
operator|.
name|getChildren
argument_list|()
decl_stmt|;
for|for
control|(
name|Node
name|node
range|:
name|vLNodes
control|)
block|{
if|if
condition|(
operator|(
operator|(
name|ASTNode
operator|)
name|node
operator|)
operator|.
name|getToken
argument_list|()
operator|.
name|getType
argument_list|()
operator|!=
name|HiveParser
operator|.
name|TOK_TABCOLVALUES
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|SKEWED_TABLE_NO_COLUMN_VALUE
operator|.
name|getMsg
argument_list|()
argument_list|)
throw|;
block|}
else|else
block|{
name|skewedValues
operator|.
name|add
argument_list|(
name|getSkewedValuesFromASTNode
argument_list|(
name|node
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
default|default:
break|break;
block|}
block|}
comment|/**    * process stored as directories    *    * @param child    * @return    */
specifier|protected
name|boolean
name|analyzeStoredAdDirs
parameter_list|(
name|ASTNode
name|child
parameter_list|)
block|{
name|boolean
name|storedAsDirs
init|=
literal|false
decl_stmt|;
if|if
condition|(
operator|(
name|child
operator|.
name|getChildCount
argument_list|()
operator|==
literal|3
operator|)
operator|&&
operator|(
operator|(
operator|(
name|ASTNode
operator|)
name|child
operator|.
name|getChild
argument_list|(
literal|2
argument_list|)
operator|)
operator|.
name|getToken
argument_list|()
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_STOREDASDIRS
operator|)
condition|)
block|{
name|storedAsDirs
operator|=
literal|true
expr_stmt|;
block|}
return|return
name|storedAsDirs
return|;
block|}
specifier|private
specifier|static
name|boolean
name|getPartExprNodeDesc
parameter_list|(
name|ASTNode
name|astNode
parameter_list|,
name|HiveConf
name|conf
parameter_list|,
name|Map
argument_list|<
name|ASTNode
argument_list|,
name|ExprNodeDesc
argument_list|>
name|astExprNodeMap
parameter_list|)
throws|throws
name|SemanticException
block|{
if|if
condition|(
name|astNode
operator|==
literal|null
condition|)
block|{
return|return
literal|true
return|;
block|}
elseif|else
if|if
condition|(
operator|(
name|astNode
operator|.
name|getChildren
argument_list|()
operator|==
literal|null
operator|)
operator|||
operator|(
name|astNode
operator|.
name|getChildren
argument_list|()
operator|.
name|size
argument_list|()
operator|==
literal|0
operator|)
condition|)
block|{
return|return
name|astNode
operator|.
name|getType
argument_list|()
operator|!=
name|HiveParser
operator|.
name|TOK_PARTVAL
return|;
block|}
name|TypeCheckCtx
name|typeCheckCtx
init|=
operator|new
name|TypeCheckCtx
argument_list|(
literal|null
argument_list|)
decl_stmt|;
name|String
name|defaultPartitionName
init|=
name|HiveConf
operator|.
name|getVar
argument_list|(
name|conf
argument_list|,
name|HiveConf
operator|.
name|ConfVars
operator|.
name|DEFAULTPARTITIONNAME
argument_list|)
decl_stmt|;
name|boolean
name|result
init|=
literal|true
decl_stmt|;
for|for
control|(
name|Node
name|childNode
range|:
name|astNode
operator|.
name|getChildren
argument_list|()
control|)
block|{
name|ASTNode
name|childASTNode
init|=
operator|(
name|ASTNode
operator|)
name|childNode
decl_stmt|;
if|if
condition|(
name|childASTNode
operator|.
name|getType
argument_list|()
operator|!=
name|HiveParser
operator|.
name|TOK_PARTVAL
condition|)
block|{
name|result
operator|=
name|getPartExprNodeDesc
argument_list|(
name|childASTNode
argument_list|,
name|conf
argument_list|,
name|astExprNodeMap
argument_list|)
operator|&&
name|result
expr_stmt|;
block|}
else|else
block|{
name|boolean
name|isDynamicPart
init|=
name|childASTNode
operator|.
name|getChildren
argument_list|()
operator|.
name|size
argument_list|()
operator|<=
literal|1
decl_stmt|;
name|result
operator|=
operator|!
name|isDynamicPart
operator|&&
name|result
expr_stmt|;
if|if
condition|(
operator|!
name|isDynamicPart
condition|)
block|{
name|ASTNode
name|partVal
init|=
operator|(
name|ASTNode
operator|)
name|childASTNode
operator|.
name|getChildren
argument_list|()
operator|.
name|get
argument_list|(
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|defaultPartitionName
operator|.
name|equalsIgnoreCase
argument_list|(
name|unescapeSQLString
argument_list|(
name|partVal
operator|.
name|getText
argument_list|()
argument_list|)
argument_list|)
condition|)
block|{
name|astExprNodeMap
operator|.
name|put
argument_list|(
operator|(
name|ASTNode
operator|)
name|childASTNode
operator|.
name|getChildren
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|,
name|TypeCheckProcFactory
operator|.
name|genExprNode
argument_list|(
name|partVal
argument_list|,
name|typeCheckCtx
argument_list|)
operator|.
name|get
argument_list|(
name|partVal
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
return|return
name|result
return|;
block|}
specifier|public
specifier|static
name|void
name|validatePartSpec
parameter_list|(
name|Table
name|tbl
parameter_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|partSpec
parameter_list|,
name|ASTNode
name|astNode
parameter_list|,
name|HiveConf
name|conf
parameter_list|,
name|boolean
name|shouldBeFull
parameter_list|)
throws|throws
name|SemanticException
block|{
name|tbl
operator|.
name|validatePartColumnNames
argument_list|(
name|partSpec
argument_list|,
name|shouldBeFull
argument_list|)
expr_stmt|;
name|validatePartColumnType
argument_list|(
name|tbl
argument_list|,
name|partSpec
argument_list|,
name|astNode
argument_list|,
name|conf
argument_list|)
expr_stmt|;
block|}
specifier|public
specifier|static
name|void
name|validatePartColumnType
parameter_list|(
name|Table
name|tbl
parameter_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|partSpec
parameter_list|,
name|ASTNode
name|astNode
parameter_list|,
name|HiveConf
name|conf
parameter_list|)
throws|throws
name|SemanticException
block|{
if|if
condition|(
operator|!
name|HiveConf
operator|.
name|getBoolVar
argument_list|(
name|conf
argument_list|,
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVE_TYPE_CHECK_ON_INSERT
argument_list|)
condition|)
block|{
return|return;
block|}
name|Map
argument_list|<
name|ASTNode
argument_list|,
name|ExprNodeDesc
argument_list|>
name|astExprNodeMap
init|=
operator|new
name|HashMap
argument_list|<
name|ASTNode
argument_list|,
name|ExprNodeDesc
argument_list|>
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|getPartExprNodeDesc
argument_list|(
name|astNode
argument_list|,
name|conf
argument_list|,
name|astExprNodeMap
argument_list|)
condition|)
block|{
name|STATIC_LOG
operator|.
name|warn
argument_list|(
literal|"Dynamic partitioning is used; only validating "
operator|+
name|astExprNodeMap
operator|.
name|size
argument_list|()
operator|+
literal|" columns"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|astExprNodeMap
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return;
comment|// All columns are dynamic, nothing to do.
block|}
name|List
argument_list|<
name|FieldSchema
argument_list|>
name|parts
init|=
name|tbl
operator|.
name|getPartitionKeys
argument_list|()
decl_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|partCols
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
argument_list|(
name|parts
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|FieldSchema
name|col
range|:
name|parts
control|)
block|{
name|partCols
operator|.
name|put
argument_list|(
name|col
operator|.
name|getName
argument_list|()
argument_list|,
name|col
operator|.
name|getType
argument_list|()
operator|.
name|toLowerCase
argument_list|()
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|Entry
argument_list|<
name|ASTNode
argument_list|,
name|ExprNodeDesc
argument_list|>
name|astExprNodePair
range|:
name|astExprNodeMap
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|String
name|astKeyName
init|=
name|astExprNodePair
operator|.
name|getKey
argument_list|()
operator|.
name|toString
argument_list|()
operator|.
name|toLowerCase
argument_list|()
decl_stmt|;
if|if
condition|(
name|astExprNodePair
operator|.
name|getKey
argument_list|()
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|Identifier
condition|)
block|{
name|astKeyName
operator|=
name|stripIdentifierQuotes
argument_list|(
name|astKeyName
argument_list|)
expr_stmt|;
block|}
name|String
name|colType
init|=
name|partCols
operator|.
name|get
argument_list|(
name|astKeyName
argument_list|)
decl_stmt|;
name|ObjectInspector
name|inputOI
init|=
name|TypeInfoUtils
operator|.
name|getStandardJavaObjectInspectorFromTypeInfo
argument_list|(
name|astExprNodePair
operator|.
name|getValue
argument_list|()
operator|.
name|getTypeInfo
argument_list|()
argument_list|)
decl_stmt|;
name|TypeInfo
name|expectedType
init|=
name|TypeInfoUtils
operator|.
name|getTypeInfoFromTypeString
argument_list|(
name|colType
argument_list|)
decl_stmt|;
name|ObjectInspector
name|outputOI
init|=
name|TypeInfoUtils
operator|.
name|getStandardJavaObjectInspectorFromTypeInfo
argument_list|(
name|expectedType
argument_list|)
decl_stmt|;
comment|//  Since partVal is a constant, it is safe to cast ExprNodeDesc to ExprNodeConstantDesc.
comment|//  Its value should be in normalized format (e.g. no leading zero in integer, date is in
comment|//  format of YYYY-MM-DD etc)
name|Object
name|value
init|=
operator|(
operator|(
name|ExprNodeConstantDesc
operator|)
name|astExprNodePair
operator|.
name|getValue
argument_list|()
operator|)
operator|.
name|getValue
argument_list|()
decl_stmt|;
name|Object
name|convertedValue
init|=
name|value
decl_stmt|;
if|if
condition|(
operator|!
name|inputOI
operator|.
name|getTypeName
argument_list|()
operator|.
name|equals
argument_list|(
name|outputOI
operator|.
name|getTypeName
argument_list|()
argument_list|)
condition|)
block|{
name|convertedValue
operator|=
name|ObjectInspectorConverters
operator|.
name|getConverter
argument_list|(
name|inputOI
argument_list|,
name|outputOI
argument_list|)
operator|.
name|convert
argument_list|(
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|convertedValue
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|PARTITION_SPEC_TYPE_MISMATCH
argument_list|,
name|astKeyName
argument_list|,
name|inputOI
operator|.
name|getTypeName
argument_list|()
argument_list|,
name|outputOI
operator|.
name|getTypeName
argument_list|()
argument_list|)
throw|;
block|}
if|if
condition|(
operator|!
name|convertedValue
operator|.
name|toString
argument_list|()
operator|.
name|equals
argument_list|(
name|value
operator|.
name|toString
argument_list|()
argument_list|)
condition|)
block|{
comment|//  value might have been changed because of the normalization in conversion
name|STATIC_LOG
operator|.
name|warn
argument_list|(
literal|"Partition "
operator|+
name|astKeyName
operator|+
literal|" expects type "
operator|+
name|outputOI
operator|.
name|getTypeName
argument_list|()
operator|+
literal|" but input value is in type "
operator|+
name|inputOI
operator|.
name|getTypeName
argument_list|()
operator|+
literal|". Convert "
operator|+
name|value
operator|.
name|toString
argument_list|()
operator|+
literal|" to "
operator|+
name|convertedValue
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|convertedValue
operator|.
name|toString
argument_list|()
operator|.
name|equals
argument_list|(
name|partSpec
operator|.
name|get
argument_list|(
name|astKeyName
argument_list|)
argument_list|)
condition|)
block|{
name|STATIC_LOG
operator|.
name|warn
argument_list|(
literal|"Partition Spec "
operator|+
name|astKeyName
operator|+
literal|"="
operator|+
name|partSpec
operator|.
name|get
argument_list|(
name|astKeyName
argument_list|)
operator|+
literal|" has been changed to "
operator|+
name|astKeyName
operator|+
literal|"="
operator|+
name|convertedValue
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|partSpec
operator|.
name|put
argument_list|(
name|astKeyName
argument_list|,
name|convertedValue
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|VisibleForTesting
specifier|static
name|void
name|normalizeColSpec
parameter_list|(
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|partSpec
parameter_list|,
name|String
name|colName
parameter_list|,
name|String
name|colType
parameter_list|,
name|String
name|originalColSpec
parameter_list|,
name|Object
name|colValue
parameter_list|)
throws|throws
name|SemanticException
block|{
if|if
condition|(
name|colValue
operator|==
literal|null
condition|)
return|return;
comment|// nothing to do with nulls
name|String
name|normalizedColSpec
init|=
name|originalColSpec
decl_stmt|;
if|if
condition|(
name|colType
operator|.
name|equals
argument_list|(
name|serdeConstants
operator|.
name|DATE_TYPE_NAME
argument_list|)
condition|)
block|{
name|normalizedColSpec
operator|=
name|normalizeDateCol
argument_list|(
name|colValue
argument_list|,
name|originalColSpec
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|normalizedColSpec
operator|.
name|equals
argument_list|(
name|originalColSpec
argument_list|)
condition|)
block|{
name|STATIC_LOG
operator|.
name|warn
argument_list|(
literal|"Normalizing partition spec - "
operator|+
name|colName
operator|+
literal|" from "
operator|+
name|originalColSpec
operator|+
literal|" to "
operator|+
name|normalizedColSpec
argument_list|)
expr_stmt|;
name|partSpec
operator|.
name|put
argument_list|(
name|colName
argument_list|,
name|normalizedColSpec
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
specifier|static
name|String
name|normalizeDateCol
parameter_list|(
name|Object
name|colValue
parameter_list|,
name|String
name|originalColSpec
parameter_list|)
throws|throws
name|SemanticException
block|{
name|Date
name|value
decl_stmt|;
if|if
condition|(
name|colValue
operator|instanceof
name|DateWritable
condition|)
block|{
name|value
operator|=
operator|(
operator|(
name|DateWritable
operator|)
name|colValue
operator|)
operator|.
name|get
argument_list|(
literal|false
argument_list|)
expr_stmt|;
comment|// Time doesn't matter.
block|}
elseif|else
if|if
condition|(
name|colValue
operator|instanceof
name|Date
condition|)
block|{
name|value
operator|=
operator|(
name|Date
operator|)
name|colValue
expr_stmt|;
block|}
else|else
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
literal|"Unexpected date type "
operator|+
name|colValue
operator|.
name|getClass
argument_list|()
argument_list|)
throw|;
block|}
return|return
name|HiveMetaStore
operator|.
name|PARTITION_DATE_FORMAT
operator|.
name|get
argument_list|()
operator|.
name|format
argument_list|(
name|value
argument_list|)
return|;
block|}
specifier|protected
name|WriteEntity
name|toWriteEntity
parameter_list|(
name|String
name|location
parameter_list|)
throws|throws
name|SemanticException
block|{
return|return
name|toWriteEntity
argument_list|(
operator|new
name|Path
argument_list|(
name|location
argument_list|)
argument_list|)
return|;
block|}
specifier|protected
name|WriteEntity
name|toWriteEntity
parameter_list|(
name|Path
name|location
parameter_list|)
throws|throws
name|SemanticException
block|{
return|return
name|toWriteEntity
argument_list|(
name|location
argument_list|,
name|conf
argument_list|)
return|;
block|}
specifier|public
specifier|static
name|WriteEntity
name|toWriteEntity
parameter_list|(
name|Path
name|location
parameter_list|,
name|HiveConf
name|conf
parameter_list|)
throws|throws
name|SemanticException
block|{
try|try
block|{
name|Path
name|path
init|=
name|tryQualifyPath
argument_list|(
name|location
argument_list|,
name|conf
argument_list|)
decl_stmt|;
return|return
operator|new
name|WriteEntity
argument_list|(
name|path
argument_list|,
name|FileUtils
operator|.
name|isLocalFile
argument_list|(
name|conf
argument_list|,
name|path
operator|.
name|toUri
argument_list|()
argument_list|)
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
specifier|protected
name|ReadEntity
name|toReadEntity
parameter_list|(
name|String
name|location
parameter_list|)
throws|throws
name|SemanticException
block|{
return|return
name|toReadEntity
argument_list|(
operator|new
name|Path
argument_list|(
name|location
argument_list|)
argument_list|)
return|;
block|}
specifier|protected
name|ReadEntity
name|toReadEntity
parameter_list|(
name|Path
name|location
parameter_list|)
throws|throws
name|SemanticException
block|{
return|return
name|toReadEntity
argument_list|(
name|location
argument_list|,
name|conf
argument_list|)
return|;
block|}
specifier|public
specifier|static
name|ReadEntity
name|toReadEntity
parameter_list|(
name|Path
name|location
parameter_list|,
name|HiveConf
name|conf
parameter_list|)
throws|throws
name|SemanticException
block|{
try|try
block|{
name|Path
name|path
init|=
name|tryQualifyPath
argument_list|(
name|location
argument_list|,
name|conf
argument_list|)
decl_stmt|;
return|return
operator|new
name|ReadEntity
argument_list|(
name|path
argument_list|,
name|FileUtils
operator|.
name|isLocalFile
argument_list|(
name|conf
argument_list|,
name|path
operator|.
name|toUri
argument_list|()
argument_list|)
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
specifier|private
name|Path
name|tryQualifyPath
parameter_list|(
name|Path
name|path
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|tryQualifyPath
argument_list|(
name|path
argument_list|,
name|conf
argument_list|)
return|;
block|}
specifier|public
specifier|static
name|Path
name|tryQualifyPath
parameter_list|(
name|Path
name|path
parameter_list|,
name|HiveConf
name|conf
parameter_list|)
throws|throws
name|IOException
block|{
try|try
block|{
return|return
name|path
operator|.
name|getFileSystem
argument_list|(
name|conf
argument_list|)
operator|.
name|makeQualified
argument_list|(
name|path
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
return|return
name|path
return|;
comment|// some tests expected to pass invalid schema
block|}
block|}
specifier|protected
name|Database
name|getDatabase
parameter_list|(
name|String
name|dbName
parameter_list|)
throws|throws
name|SemanticException
block|{
return|return
name|getDatabase
argument_list|(
name|dbName
argument_list|,
literal|true
argument_list|)
return|;
block|}
specifier|protected
name|Database
name|getDatabase
parameter_list|(
name|String
name|dbName
parameter_list|,
name|boolean
name|throwException
parameter_list|)
throws|throws
name|SemanticException
block|{
name|Database
name|database
decl_stmt|;
try|try
block|{
name|database
operator|=
name|db
operator|.
name|getDatabase
argument_list|(
name|dbName
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|e
operator|.
name|getMessage
argument_list|()
argument_list|,
name|e
argument_list|)
throw|;
block|}
if|if
condition|(
name|database
operator|==
literal|null
operator|&&
name|throwException
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|DATABASE_NOT_EXISTS
operator|.
name|getMsg
argument_list|(
name|dbName
argument_list|)
argument_list|)
throw|;
block|}
return|return
name|database
return|;
block|}
specifier|protected
name|Table
name|getTable
parameter_list|(
name|String
index|[]
name|qualified
parameter_list|)
throws|throws
name|SemanticException
block|{
return|return
name|getTable
argument_list|(
name|qualified
index|[
literal|0
index|]
argument_list|,
name|qualified
index|[
literal|1
index|]
argument_list|,
literal|true
argument_list|)
return|;
block|}
specifier|protected
name|Table
name|getTable
parameter_list|(
name|String
index|[]
name|qualified
parameter_list|,
name|boolean
name|throwException
parameter_list|)
throws|throws
name|SemanticException
block|{
return|return
name|getTable
argument_list|(
name|qualified
index|[
literal|0
index|]
argument_list|,
name|qualified
index|[
literal|1
index|]
argument_list|,
name|throwException
argument_list|)
return|;
block|}
specifier|protected
name|Table
name|getTable
parameter_list|(
name|String
name|tblName
parameter_list|)
throws|throws
name|SemanticException
block|{
return|return
name|getTable
argument_list|(
literal|null
argument_list|,
name|tblName
argument_list|,
literal|true
argument_list|)
return|;
block|}
specifier|protected
name|Table
name|getTable
parameter_list|(
name|String
name|tblName
parameter_list|,
name|boolean
name|throwException
parameter_list|)
throws|throws
name|SemanticException
block|{
return|return
name|getTable
argument_list|(
literal|null
argument_list|,
name|tblName
argument_list|,
name|throwException
argument_list|)
return|;
block|}
specifier|protected
name|Table
name|getTable
parameter_list|(
name|String
name|database
parameter_list|,
name|String
name|tblName
parameter_list|,
name|boolean
name|throwException
parameter_list|)
throws|throws
name|SemanticException
block|{
name|Table
name|tab
decl_stmt|;
try|try
block|{
name|tab
operator|=
name|database
operator|==
literal|null
condition|?
name|db
operator|.
name|getTable
argument_list|(
name|tblName
argument_list|,
literal|false
argument_list|)
else|:
name|db
operator|.
name|getTable
argument_list|(
name|database
argument_list|,
name|tblName
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InvalidTableException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|INVALID_TABLE
operator|.
name|getMsg
argument_list|(
name|tblName
argument_list|)
argument_list|,
name|e
argument_list|)
throw|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|e
operator|.
name|getMessage
argument_list|()
argument_list|,
name|e
argument_list|)
throw|;
block|}
if|if
condition|(
name|tab
operator|==
literal|null
operator|&&
name|throwException
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|INVALID_TABLE
operator|.
name|getMsg
argument_list|(
name|tblName
argument_list|)
argument_list|)
throw|;
block|}
return|return
name|tab
return|;
block|}
specifier|protected
name|Partition
name|getPartition
parameter_list|(
name|Table
name|table
parameter_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|partSpec
parameter_list|,
name|boolean
name|throwException
parameter_list|)
throws|throws
name|SemanticException
block|{
name|Partition
name|partition
decl_stmt|;
try|try
block|{
name|partition
operator|=
name|db
operator|.
name|getPartition
argument_list|(
name|table
argument_list|,
name|partSpec
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|toMessage
argument_list|(
name|ErrorMsg
operator|.
name|INVALID_PARTITION
argument_list|,
name|partSpec
argument_list|)
argument_list|,
name|e
argument_list|)
throw|;
block|}
if|if
condition|(
name|partition
operator|==
literal|null
operator|&&
name|throwException
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|toMessage
argument_list|(
name|ErrorMsg
operator|.
name|INVALID_PARTITION
argument_list|,
name|partSpec
argument_list|)
argument_list|)
throw|;
block|}
return|return
name|partition
return|;
block|}
specifier|protected
name|List
argument_list|<
name|Partition
argument_list|>
name|getPartitions
parameter_list|(
name|Table
name|table
parameter_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|partSpec
parameter_list|,
name|boolean
name|throwException
parameter_list|)
throws|throws
name|SemanticException
block|{
name|List
argument_list|<
name|Partition
argument_list|>
name|partitions
decl_stmt|;
try|try
block|{
name|partitions
operator|=
name|partSpec
operator|==
literal|null
condition|?
name|db
operator|.
name|getPartitions
argument_list|(
name|table
argument_list|)
else|:
name|db
operator|.
name|getPartitions
argument_list|(
name|table
argument_list|,
name|partSpec
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|toMessage
argument_list|(
name|ErrorMsg
operator|.
name|INVALID_PARTITION
argument_list|,
name|partSpec
argument_list|)
argument_list|,
name|e
argument_list|)
throw|;
block|}
if|if
condition|(
name|partitions
operator|.
name|isEmpty
argument_list|()
operator|&&
name|throwException
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|toMessage
argument_list|(
name|ErrorMsg
operator|.
name|INVALID_PARTITION
argument_list|,
name|partSpec
argument_list|)
argument_list|)
throw|;
block|}
return|return
name|partitions
return|;
block|}
specifier|protected
name|String
name|toMessage
parameter_list|(
name|ErrorMsg
name|message
parameter_list|,
name|Object
name|detail
parameter_list|)
block|{
return|return
name|detail
operator|==
literal|null
condition|?
name|message
operator|.
name|getMsg
argument_list|()
else|:
name|message
operator|.
name|getMsg
argument_list|(
name|detail
operator|.
name|toString
argument_list|()
argument_list|)
return|;
block|}
specifier|public
name|List
argument_list|<
name|Task
argument_list|<
name|?
extends|extends
name|Serializable
argument_list|>
argument_list|>
name|getAllRootTasks
parameter_list|()
block|{
return|return
name|rootTasks
return|;
block|}
specifier|public
name|HashSet
argument_list|<
name|ReadEntity
argument_list|>
name|getAllInputs
parameter_list|()
block|{
return|return
name|inputs
return|;
block|}
specifier|public
name|HashSet
argument_list|<
name|WriteEntity
argument_list|>
name|getAllOutputs
parameter_list|()
block|{
return|return
name|outputs
return|;
block|}
specifier|public
name|QueryState
name|getQueryState
parameter_list|()
block|{
return|return
name|queryState
return|;
block|}
comment|/**    * Create a FetchTask for a given schema.    *    * @param schema string    */
specifier|protected
name|FetchTask
name|createFetchTask
parameter_list|(
name|String
name|schema
parameter_list|)
block|{
name|Properties
name|prop
init|=
operator|new
name|Properties
argument_list|()
decl_stmt|;
comment|// Sets delimiter to tab (ascii 9)
name|prop
operator|.
name|setProperty
argument_list|(
name|serdeConstants
operator|.
name|SERIALIZATION_FORMAT
argument_list|,
name|Integer
operator|.
name|toString
argument_list|(
name|Utilities
operator|.
name|tabCode
argument_list|)
argument_list|)
expr_stmt|;
name|prop
operator|.
name|setProperty
argument_list|(
name|serdeConstants
operator|.
name|SERIALIZATION_NULL_FORMAT
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
name|String
index|[]
name|colTypes
init|=
name|schema
operator|.
name|split
argument_list|(
literal|"#"
argument_list|)
decl_stmt|;
name|prop
operator|.
name|setProperty
argument_list|(
literal|"columns"
argument_list|,
name|colTypes
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|prop
operator|.
name|setProperty
argument_list|(
literal|"columns.types"
argument_list|,
name|colTypes
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|prop
operator|.
name|setProperty
argument_list|(
name|serdeConstants
operator|.
name|SERIALIZATION_LIB
argument_list|,
name|LazySimpleSerDe
operator|.
name|class
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
name|FetchWork
name|fetch
init|=
operator|new
name|FetchWork
argument_list|(
name|ctx
operator|.
name|getResFile
argument_list|()
argument_list|,
operator|new
name|TableDesc
argument_list|(
name|TextInputFormat
operator|.
name|class
argument_list|,
name|IgnoreKeyTextOutputFormat
operator|.
name|class
argument_list|,
name|prop
argument_list|)
argument_list|,
operator|-
literal|1
argument_list|)
decl_stmt|;
name|fetch
operator|.
name|setSerializationNullFormat
argument_list|(
literal|" "
argument_list|)
expr_stmt|;
return|return
operator|(
name|FetchTask
operator|)
name|TaskFactory
operator|.
name|get
argument_list|(
name|fetch
argument_list|,
name|conf
argument_list|)
return|;
block|}
block|}
end_class

end_unit

