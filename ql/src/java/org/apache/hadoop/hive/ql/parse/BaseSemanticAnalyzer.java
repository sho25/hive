begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|parse
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|Serializable
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|UnsupportedEncodingException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|sql
operator|.
name|Date
import|;
end_import

begin_import
import|import
name|java
operator|.
name|text
operator|.
name|DateFormat
import|;
end_import

begin_import
import|import
name|java
operator|.
name|text
operator|.
name|SimpleDateFormat
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|LinkedHashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|LinkedHashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
operator|.
name|Entry
import|;
end_import

begin_import
import|import
name|org
operator|.
name|antlr
operator|.
name|runtime
operator|.
name|tree
operator|.
name|CommonTree
import|;
end_import

begin_import
import|import
name|org
operator|.
name|antlr
operator|.
name|runtime
operator|.
name|tree
operator|.
name|Tree
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|Log
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|LogFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|conf
operator|.
name|HiveConf
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|metastore
operator|.
name|HiveMetaStore
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|metastore
operator|.
name|api
operator|.
name|Database
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|metastore
operator|.
name|api
operator|.
name|FieldSchema
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|metastore
operator|.
name|api
operator|.
name|Order
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|Context
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|ErrorMsg
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|QueryProperties
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|ExprNodeEvaluatorFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|FetchTask
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|Task
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|Utilities
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|hooks
operator|.
name|LineageInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|hooks
operator|.
name|ReadEntity
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|hooks
operator|.
name|WriteEntity
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|io
operator|.
name|IgnoreKeyTextOutputFormat
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|io
operator|.
name|RCFileInputFormat
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|io
operator|.
name|RCFileOutputFormat
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|io
operator|.
name|orc
operator|.
name|OrcInputFormat
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|io
operator|.
name|orc
operator|.
name|OrcOutputFormat
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|io
operator|.
name|orc
operator|.
name|OrcSerde
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|lib
operator|.
name|Node
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|metadata
operator|.
name|Hive
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|metadata
operator|.
name|HiveException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|metadata
operator|.
name|InvalidTableException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|metadata
operator|.
name|Partition
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|metadata
operator|.
name|Table
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|optimizer
operator|.
name|listbucketingpruner
operator|.
name|ListBucketingPrunerUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|ExprNodeDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|ListBucketingCtx
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|PlanUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|session
operator|.
name|SessionState
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|session
operator|.
name|SessionState
operator|.
name|LogHelper
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde
operator|.
name|serdeConstants
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|io
operator|.
name|DateWritable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|objectinspector
operator|.
name|ObjectInspector
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|objectinspector
operator|.
name|ObjectInspectorConverters
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|typeinfo
operator|.
name|TypeInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|typeinfo
operator|.
name|TypeInfoUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapred
operator|.
name|SequenceFileInputFormat
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapred
operator|.
name|SequenceFileOutputFormat
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapred
operator|.
name|TextInputFormat
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|VisibleForTesting
import|;
end_import

begin_comment
comment|/**  * BaseSemanticAnalyzer.  *  */
end_comment

begin_class
annotation|@
name|SuppressWarnings
argument_list|(
literal|"deprecation"
argument_list|)
specifier|public
specifier|abstract
class|class
name|BaseSemanticAnalyzer
block|{
specifier|private
specifier|static
specifier|final
name|Log
name|STATIC_LOG
init|=
name|LogFactory
operator|.
name|getLog
argument_list|(
name|BaseSemanticAnalyzer
operator|.
name|class
operator|.
name|getName
argument_list|()
argument_list|)
decl_stmt|;
specifier|protected
specifier|final
name|Hive
name|db
decl_stmt|;
specifier|protected
specifier|final
name|HiveConf
name|conf
decl_stmt|;
specifier|protected
name|List
argument_list|<
name|Task
argument_list|<
name|?
extends|extends
name|Serializable
argument_list|>
argument_list|>
name|rootTasks
decl_stmt|;
specifier|protected
name|FetchTask
name|fetchTask
decl_stmt|;
specifier|protected
specifier|final
name|Log
name|LOG
decl_stmt|;
specifier|protected
specifier|final
name|LogHelper
name|console
decl_stmt|;
specifier|protected
name|Context
name|ctx
decl_stmt|;
specifier|protected
name|HashMap
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|idToTableNameMap
decl_stmt|;
specifier|protected
name|QueryProperties
name|queryProperties
decl_stmt|;
specifier|public
specifier|static
name|int
name|HIVE_COLUMN_ORDER_ASC
init|=
literal|1
decl_stmt|;
specifier|public
specifier|static
name|int
name|HIVE_COLUMN_ORDER_DESC
init|=
literal|0
decl_stmt|;
comment|/**    * ReadEntitites that are passed to the hooks.    */
specifier|protected
name|HashSet
argument_list|<
name|ReadEntity
argument_list|>
name|inputs
decl_stmt|;
comment|/**    * List of WriteEntities that are passed to the hooks.    */
specifier|protected
name|HashSet
argument_list|<
name|WriteEntity
argument_list|>
name|outputs
decl_stmt|;
comment|/**    * Lineage information for the query.    */
specifier|protected
name|LineageInfo
name|linfo
decl_stmt|;
specifier|protected
name|TableAccessInfo
name|tableAccessInfo
decl_stmt|;
specifier|protected
name|ColumnAccessInfo
name|columnAccessInfo
decl_stmt|;
specifier|protected
specifier|static
specifier|final
name|String
name|TEXTFILE_INPUT
init|=
name|TextInputFormat
operator|.
name|class
operator|.
name|getName
argument_list|()
decl_stmt|;
specifier|protected
specifier|static
specifier|final
name|String
name|TEXTFILE_OUTPUT
init|=
name|IgnoreKeyTextOutputFormat
operator|.
name|class
operator|.
name|getName
argument_list|()
decl_stmt|;
specifier|protected
specifier|static
specifier|final
name|String
name|SEQUENCEFILE_INPUT
init|=
name|SequenceFileInputFormat
operator|.
name|class
operator|.
name|getName
argument_list|()
decl_stmt|;
specifier|protected
specifier|static
specifier|final
name|String
name|SEQUENCEFILE_OUTPUT
init|=
name|SequenceFileOutputFormat
operator|.
name|class
operator|.
name|getName
argument_list|()
decl_stmt|;
specifier|protected
specifier|static
specifier|final
name|String
name|RCFILE_INPUT
init|=
name|RCFileInputFormat
operator|.
name|class
operator|.
name|getName
argument_list|()
decl_stmt|;
specifier|protected
specifier|static
specifier|final
name|String
name|RCFILE_OUTPUT
init|=
name|RCFileOutputFormat
operator|.
name|class
operator|.
name|getName
argument_list|()
decl_stmt|;
specifier|protected
specifier|static
specifier|final
name|String
name|ORCFILE_INPUT
init|=
name|OrcInputFormat
operator|.
name|class
operator|.
name|getName
argument_list|()
decl_stmt|;
specifier|protected
specifier|static
specifier|final
name|String
name|ORCFILE_OUTPUT
init|=
name|OrcOutputFormat
operator|.
name|class
operator|.
name|getName
argument_list|()
decl_stmt|;
specifier|protected
specifier|static
specifier|final
name|String
name|ORCFILE_SERDE
init|=
name|OrcSerde
operator|.
name|class
operator|.
name|getName
argument_list|()
decl_stmt|;
class|class
name|RowFormatParams
block|{
name|String
name|fieldDelim
init|=
literal|null
decl_stmt|;
name|String
name|fieldEscape
init|=
literal|null
decl_stmt|;
name|String
name|collItemDelim
init|=
literal|null
decl_stmt|;
name|String
name|mapKeyDelim
init|=
literal|null
decl_stmt|;
name|String
name|lineDelim
init|=
literal|null
decl_stmt|;
name|String
name|nullFormat
init|=
literal|null
decl_stmt|;
specifier|protected
name|void
name|analyzeRowFormat
parameter_list|(
name|AnalyzeCreateCommonVars
name|shared
parameter_list|,
name|ASTNode
name|child
parameter_list|)
throws|throws
name|SemanticException
block|{
name|child
operator|=
operator|(
name|ASTNode
operator|)
name|child
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|int
name|numChildRowFormat
init|=
name|child
operator|.
name|getChildCount
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|numC
init|=
literal|0
init|;
name|numC
operator|<
name|numChildRowFormat
condition|;
name|numC
operator|++
control|)
block|{
name|ASTNode
name|rowChild
init|=
operator|(
name|ASTNode
operator|)
name|child
operator|.
name|getChild
argument_list|(
name|numC
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|rowChild
operator|.
name|getToken
argument_list|()
operator|.
name|getType
argument_list|()
condition|)
block|{
case|case
name|HiveParser
operator|.
name|TOK_TABLEROWFORMATFIELD
case|:
name|fieldDelim
operator|=
name|unescapeSQLString
argument_list|(
name|rowChild
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getText
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|rowChild
operator|.
name|getChildCount
argument_list|()
operator|>=
literal|2
condition|)
block|{
name|fieldEscape
operator|=
name|unescapeSQLString
argument_list|(
name|rowChild
operator|.
name|getChild
argument_list|(
literal|1
argument_list|)
operator|.
name|getText
argument_list|()
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|HiveParser
operator|.
name|TOK_TABLEROWFORMATCOLLITEMS
case|:
name|collItemDelim
operator|=
name|unescapeSQLString
argument_list|(
name|rowChild
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getText
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|HiveParser
operator|.
name|TOK_TABLEROWFORMATMAPKEYS
case|:
name|mapKeyDelim
operator|=
name|unescapeSQLString
argument_list|(
name|rowChild
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getText
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|HiveParser
operator|.
name|TOK_TABLEROWFORMATLINES
case|:
name|lineDelim
operator|=
name|unescapeSQLString
argument_list|(
name|rowChild
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getText
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|lineDelim
operator|.
name|equals
argument_list|(
literal|"\n"
argument_list|)
operator|&&
operator|!
name|lineDelim
operator|.
name|equals
argument_list|(
literal|"10"
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|SemanticAnalyzer
operator|.
name|generateErrorMessage
argument_list|(
name|rowChild
argument_list|,
name|ErrorMsg
operator|.
name|LINES_TERMINATED_BY_NON_NEWLINE
operator|.
name|getMsg
argument_list|()
argument_list|)
argument_list|)
throw|;
block|}
break|break;
case|case
name|HiveParser
operator|.
name|TOK_TABLEROWFORMATNULL
case|:
name|nullFormat
operator|=
name|unescapeSQLString
argument_list|(
name|rowChild
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getText
argument_list|()
argument_list|)
expr_stmt|;
break|break;
default|default:
assert|assert
literal|false
assert|;
block|}
block|}
block|}
block|}
class|class
name|AnalyzeCreateCommonVars
block|{
name|String
name|serde
init|=
literal|null
decl_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|serdeProps
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
argument_list|()
decl_stmt|;
block|}
class|class
name|StorageFormat
block|{
name|String
name|inputFormat
init|=
literal|null
decl_stmt|;
name|String
name|outputFormat
init|=
literal|null
decl_stmt|;
name|String
name|storageHandler
init|=
literal|null
decl_stmt|;
specifier|protected
name|boolean
name|fillStorageFormat
parameter_list|(
name|ASTNode
name|child
parameter_list|,
name|AnalyzeCreateCommonVars
name|shared
parameter_list|)
block|{
name|boolean
name|storageFormat
init|=
literal|false
decl_stmt|;
switch|switch
condition|(
name|child
operator|.
name|getToken
argument_list|()
operator|.
name|getType
argument_list|()
condition|)
block|{
case|case
name|HiveParser
operator|.
name|TOK_TBLSEQUENCEFILE
case|:
name|inputFormat
operator|=
name|SEQUENCEFILE_INPUT
expr_stmt|;
name|outputFormat
operator|=
name|SEQUENCEFILE_OUTPUT
expr_stmt|;
name|storageFormat
operator|=
literal|true
expr_stmt|;
break|break;
case|case
name|HiveParser
operator|.
name|TOK_TBLTEXTFILE
case|:
name|inputFormat
operator|=
name|TEXTFILE_INPUT
expr_stmt|;
name|outputFormat
operator|=
name|TEXTFILE_OUTPUT
expr_stmt|;
name|storageFormat
operator|=
literal|true
expr_stmt|;
break|break;
case|case
name|HiveParser
operator|.
name|TOK_TBLRCFILE
case|:
name|inputFormat
operator|=
name|RCFILE_INPUT
expr_stmt|;
name|outputFormat
operator|=
name|RCFILE_OUTPUT
expr_stmt|;
if|if
condition|(
name|shared
operator|.
name|serde
operator|==
literal|null
condition|)
block|{
name|shared
operator|.
name|serde
operator|=
name|conf
operator|.
name|getVar
argument_list|(
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVEDEFAULTRCFILESERDE
argument_list|)
expr_stmt|;
block|}
name|storageFormat
operator|=
literal|true
expr_stmt|;
break|break;
case|case
name|HiveParser
operator|.
name|TOK_TBLORCFILE
case|:
name|inputFormat
operator|=
name|ORCFILE_INPUT
expr_stmt|;
name|outputFormat
operator|=
name|ORCFILE_OUTPUT
expr_stmt|;
name|shared
operator|.
name|serde
operator|=
name|ORCFILE_SERDE
expr_stmt|;
name|storageFormat
operator|=
literal|true
expr_stmt|;
break|break;
case|case
name|HiveParser
operator|.
name|TOK_TABLEFILEFORMAT
case|:
name|inputFormat
operator|=
name|unescapeSQLString
argument_list|(
name|child
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getText
argument_list|()
argument_list|)
expr_stmt|;
name|outputFormat
operator|=
name|unescapeSQLString
argument_list|(
name|child
operator|.
name|getChild
argument_list|(
literal|1
argument_list|)
operator|.
name|getText
argument_list|()
argument_list|)
expr_stmt|;
name|storageFormat
operator|=
literal|true
expr_stmt|;
break|break;
case|case
name|HiveParser
operator|.
name|TOK_STORAGEHANDLER
case|:
name|storageHandler
operator|=
name|unescapeSQLString
argument_list|(
name|child
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getText
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|child
operator|.
name|getChildCount
argument_list|()
operator|==
literal|2
condition|)
block|{
name|readProps
argument_list|(
call|(
name|ASTNode
call|)
argument_list|(
name|child
operator|.
name|getChild
argument_list|(
literal|1
argument_list|)
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
argument_list|)
argument_list|,
name|shared
operator|.
name|serdeProps
argument_list|)
expr_stmt|;
block|}
name|storageFormat
operator|=
literal|true
expr_stmt|;
break|break;
block|}
return|return
name|storageFormat
return|;
block|}
specifier|protected
name|void
name|fillDefaultStorageFormat
parameter_list|(
name|AnalyzeCreateCommonVars
name|shared
parameter_list|)
block|{
if|if
condition|(
operator|(
name|inputFormat
operator|==
literal|null
operator|)
operator|&&
operator|(
name|storageHandler
operator|==
literal|null
operator|)
condition|)
block|{
if|if
condition|(
literal|"SequenceFile"
operator|.
name|equalsIgnoreCase
argument_list|(
name|conf
operator|.
name|getVar
argument_list|(
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVEDEFAULTFILEFORMAT
argument_list|)
argument_list|)
condition|)
block|{
name|inputFormat
operator|=
name|SEQUENCEFILE_INPUT
expr_stmt|;
name|outputFormat
operator|=
name|SEQUENCEFILE_OUTPUT
expr_stmt|;
block|}
elseif|else
if|if
condition|(
literal|"RCFile"
operator|.
name|equalsIgnoreCase
argument_list|(
name|conf
operator|.
name|getVar
argument_list|(
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVEDEFAULTFILEFORMAT
argument_list|)
argument_list|)
condition|)
block|{
name|inputFormat
operator|=
name|RCFILE_INPUT
expr_stmt|;
name|outputFormat
operator|=
name|RCFILE_OUTPUT
expr_stmt|;
name|shared
operator|.
name|serde
operator|=
name|conf
operator|.
name|getVar
argument_list|(
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVEDEFAULTRCFILESERDE
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
literal|"ORC"
operator|.
name|equalsIgnoreCase
argument_list|(
name|conf
operator|.
name|getVar
argument_list|(
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVEDEFAULTFILEFORMAT
argument_list|)
argument_list|)
condition|)
block|{
name|inputFormat
operator|=
name|ORCFILE_INPUT
expr_stmt|;
name|outputFormat
operator|=
name|ORCFILE_OUTPUT
expr_stmt|;
name|shared
operator|.
name|serde
operator|=
name|ORCFILE_SERDE
expr_stmt|;
block|}
else|else
block|{
name|inputFormat
operator|=
name|TEXTFILE_INPUT
expr_stmt|;
name|outputFormat
operator|=
name|TEXTFILE_OUTPUT
expr_stmt|;
block|}
block|}
block|}
block|}
specifier|public
name|BaseSemanticAnalyzer
parameter_list|(
name|HiveConf
name|conf
parameter_list|)
throws|throws
name|SemanticException
block|{
name|this
argument_list|(
name|conf
argument_list|,
name|createHiveDB
argument_list|(
name|conf
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|public
name|BaseSemanticAnalyzer
parameter_list|(
name|HiveConf
name|conf
parameter_list|,
name|Hive
name|db
parameter_list|)
throws|throws
name|SemanticException
block|{
try|try
block|{
name|this
operator|.
name|conf
operator|=
name|conf
expr_stmt|;
name|this
operator|.
name|db
operator|=
name|db
expr_stmt|;
name|rootTasks
operator|=
operator|new
name|ArrayList
argument_list|<
name|Task
argument_list|<
name|?
extends|extends
name|Serializable
argument_list|>
argument_list|>
argument_list|()
expr_stmt|;
name|LOG
operator|=
name|LogFactory
operator|.
name|getLog
argument_list|(
name|this
operator|.
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
name|console
operator|=
operator|new
name|LogHelper
argument_list|(
name|LOG
argument_list|)
expr_stmt|;
name|idToTableNameMap
operator|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
argument_list|()
expr_stmt|;
name|inputs
operator|=
operator|new
name|LinkedHashSet
argument_list|<
name|ReadEntity
argument_list|>
argument_list|()
expr_stmt|;
name|outputs
operator|=
operator|new
name|LinkedHashSet
argument_list|<
name|WriteEntity
argument_list|>
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
specifier|protected
specifier|static
name|Hive
name|createHiveDB
parameter_list|(
name|HiveConf
name|conf
parameter_list|)
throws|throws
name|SemanticException
block|{
try|try
block|{
return|return
name|Hive
operator|.
name|get
argument_list|(
name|conf
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|HiveException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
specifier|public
name|HashMap
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|getIdToTableNameMap
parameter_list|()
block|{
return|return
name|idToTableNameMap
return|;
block|}
specifier|public
specifier|abstract
name|void
name|analyzeInternal
parameter_list|(
name|ASTNode
name|ast
parameter_list|)
throws|throws
name|SemanticException
function_decl|;
specifier|public
name|void
name|init
parameter_list|()
block|{
comment|//no-op
block|}
specifier|public
name|void
name|initCtx
parameter_list|(
name|Context
name|ctx
parameter_list|)
block|{
name|this
operator|.
name|ctx
operator|=
name|ctx
expr_stmt|;
block|}
specifier|public
name|void
name|analyze
parameter_list|(
name|ASTNode
name|ast
parameter_list|,
name|Context
name|ctx
parameter_list|)
throws|throws
name|SemanticException
block|{
name|initCtx
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
name|init
argument_list|()
expr_stmt|;
name|analyzeInternal
argument_list|(
name|ast
argument_list|)
expr_stmt|;
block|}
specifier|public
name|void
name|validate
parameter_list|()
throws|throws
name|SemanticException
block|{
comment|// Implementations may choose to override this
block|}
specifier|public
name|List
argument_list|<
name|Task
argument_list|<
name|?
extends|extends
name|Serializable
argument_list|>
argument_list|>
name|getRootTasks
parameter_list|()
block|{
return|return
name|rootTasks
return|;
block|}
comment|/**    * @return the fetchTask    */
specifier|public
name|FetchTask
name|getFetchTask
parameter_list|()
block|{
return|return
name|fetchTask
return|;
block|}
comment|/**    * @param fetchTask    *          the fetchTask to set    */
specifier|public
name|void
name|setFetchTask
parameter_list|(
name|FetchTask
name|fetchTask
parameter_list|)
block|{
name|this
operator|.
name|fetchTask
operator|=
name|fetchTask
expr_stmt|;
block|}
specifier|protected
name|void
name|reset
parameter_list|()
block|{
name|rootTasks
operator|=
operator|new
name|ArrayList
argument_list|<
name|Task
argument_list|<
name|?
extends|extends
name|Serializable
argument_list|>
argument_list|>
argument_list|()
expr_stmt|;
block|}
specifier|public
specifier|static
name|String
name|stripIdentifierQuotes
parameter_list|(
name|String
name|val
parameter_list|)
block|{
if|if
condition|(
operator|(
name|val
operator|.
name|charAt
argument_list|(
literal|0
argument_list|)
operator|==
literal|'`'
operator|&&
name|val
operator|.
name|charAt
argument_list|(
name|val
operator|.
name|length
argument_list|()
operator|-
literal|1
argument_list|)
operator|==
literal|'`'
operator|)
condition|)
block|{
name|val
operator|=
name|val
operator|.
name|substring
argument_list|(
literal|1
argument_list|,
name|val
operator|.
name|length
argument_list|()
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
name|val
return|;
block|}
specifier|public
specifier|static
name|String
name|stripQuotes
parameter_list|(
name|String
name|val
parameter_list|)
block|{
return|return
name|PlanUtils
operator|.
name|stripQuotes
argument_list|(
name|val
argument_list|)
return|;
block|}
specifier|public
specifier|static
name|String
name|charSetString
parameter_list|(
name|String
name|charSetName
parameter_list|,
name|String
name|charSetString
parameter_list|)
throws|throws
name|SemanticException
block|{
try|try
block|{
comment|// The character set name starts with a _, so strip that
name|charSetName
operator|=
name|charSetName
operator|.
name|substring
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|charSetString
operator|.
name|charAt
argument_list|(
literal|0
argument_list|)
operator|==
literal|'\''
condition|)
block|{
return|return
operator|new
name|String
argument_list|(
name|unescapeSQLString
argument_list|(
name|charSetString
argument_list|)
operator|.
name|getBytes
argument_list|()
argument_list|,
name|charSetName
argument_list|)
return|;
block|}
else|else
comment|// hex input is also supported
block|{
assert|assert
name|charSetString
operator|.
name|charAt
argument_list|(
literal|0
argument_list|)
operator|==
literal|'0'
assert|;
assert|assert
name|charSetString
operator|.
name|charAt
argument_list|(
literal|1
argument_list|)
operator|==
literal|'x'
assert|;
name|charSetString
operator|=
name|charSetString
operator|.
name|substring
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|byte
index|[]
name|bArray
init|=
operator|new
name|byte
index|[
name|charSetString
operator|.
name|length
argument_list|()
operator|/
literal|2
index|]
decl_stmt|;
name|int
name|j
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|charSetString
operator|.
name|length
argument_list|()
condition|;
name|i
operator|+=
literal|2
control|)
block|{
name|int
name|val
init|=
name|Character
operator|.
name|digit
argument_list|(
name|charSetString
operator|.
name|charAt
argument_list|(
name|i
argument_list|)
argument_list|,
literal|16
argument_list|)
operator|*
literal|16
operator|+
name|Character
operator|.
name|digit
argument_list|(
name|charSetString
operator|.
name|charAt
argument_list|(
name|i
operator|+
literal|1
argument_list|)
argument_list|,
literal|16
argument_list|)
decl_stmt|;
if|if
condition|(
name|val
operator|>
literal|127
condition|)
block|{
name|val
operator|=
name|val
operator|-
literal|256
expr_stmt|;
block|}
name|bArray
index|[
name|j
operator|++
index|]
operator|=
operator|(
name|byte
operator|)
name|val
expr_stmt|;
block|}
name|String
name|res
init|=
operator|new
name|String
argument_list|(
name|bArray
argument_list|,
name|charSetName
argument_list|)
decl_stmt|;
return|return
name|res
return|;
block|}
block|}
catch|catch
parameter_list|(
name|UnsupportedEncodingException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
comment|/**    * Get dequoted name from a table/column node.    * @param tableOrColumnNode the table or column node    * @return for table node, db.tab or tab. for column node column.    */
specifier|public
specifier|static
name|String
name|getUnescapedName
parameter_list|(
name|ASTNode
name|tableOrColumnNode
parameter_list|)
block|{
return|return
name|getUnescapedName
argument_list|(
name|tableOrColumnNode
argument_list|,
literal|null
argument_list|)
return|;
block|}
specifier|public
specifier|static
name|String
name|getUnescapedName
parameter_list|(
name|ASTNode
name|tableOrColumnNode
parameter_list|,
name|String
name|currentDatabase
parameter_list|)
block|{
if|if
condition|(
name|tableOrColumnNode
operator|.
name|getToken
argument_list|()
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_TABNAME
condition|)
block|{
comment|// table node
if|if
condition|(
name|tableOrColumnNode
operator|.
name|getChildCount
argument_list|()
operator|==
literal|2
condition|)
block|{
name|String
name|dbName
init|=
name|unescapeIdentifier
argument_list|(
name|tableOrColumnNode
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getText
argument_list|()
argument_list|)
decl_stmt|;
name|String
name|tableName
init|=
name|unescapeIdentifier
argument_list|(
name|tableOrColumnNode
operator|.
name|getChild
argument_list|(
literal|1
argument_list|)
operator|.
name|getText
argument_list|()
argument_list|)
decl_stmt|;
return|return
name|dbName
operator|+
literal|"."
operator|+
name|tableName
return|;
block|}
name|String
name|tableName
init|=
name|unescapeIdentifier
argument_list|(
name|tableOrColumnNode
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getText
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|currentDatabase
operator|!=
literal|null
condition|)
block|{
return|return
name|currentDatabase
operator|+
literal|"."
operator|+
name|tableName
return|;
block|}
return|return
name|tableName
return|;
block|}
comment|// column node
return|return
name|unescapeIdentifier
argument_list|(
name|tableOrColumnNode
operator|.
name|getText
argument_list|()
argument_list|)
return|;
block|}
comment|/**    * Get the unqualified name from a table node.    *    * This method works for table names qualified with their schema (e.g., "db.table")    * and table names without schema qualification. In both cases, it returns    * the table name without the schema.    *    * @param node the table node    * @return the table name without schema qualification    *         (i.e., if name is "db.table" or "table", returns "table")    */
specifier|public
specifier|static
name|String
name|getUnescapedUnqualifiedTableName
parameter_list|(
name|ASTNode
name|node
parameter_list|)
block|{
assert|assert
name|node
operator|.
name|getChildCount
argument_list|()
operator|<=
literal|2
assert|;
if|if
condition|(
name|node
operator|.
name|getChildCount
argument_list|()
operator|==
literal|2
condition|)
block|{
name|node
operator|=
operator|(
name|ASTNode
operator|)
name|node
operator|.
name|getChild
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
name|getUnescapedName
argument_list|(
name|node
argument_list|)
return|;
block|}
comment|/**    * Remove the encapsulating "`" pair from the identifier. We allow users to    * use "`" to escape identifier for table names, column names and aliases, in    * case that coincide with Hive language keywords.    */
specifier|public
specifier|static
name|String
name|unescapeIdentifier
parameter_list|(
name|String
name|val
parameter_list|)
block|{
if|if
condition|(
name|val
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
if|if
condition|(
name|val
operator|.
name|charAt
argument_list|(
literal|0
argument_list|)
operator|==
literal|'`'
operator|&&
name|val
operator|.
name|charAt
argument_list|(
name|val
operator|.
name|length
argument_list|()
operator|-
literal|1
argument_list|)
operator|==
literal|'`'
condition|)
block|{
name|val
operator|=
name|val
operator|.
name|substring
argument_list|(
literal|1
argument_list|,
name|val
operator|.
name|length
argument_list|()
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
name|val
return|;
block|}
comment|/**    * Converts parsed key/value properties pairs into a map.    *    * @param prop ASTNode parent of the key/value pairs    *    * @param mapProp property map which receives the mappings    */
specifier|public
specifier|static
name|void
name|readProps
parameter_list|(
name|ASTNode
name|prop
parameter_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|mapProp
parameter_list|)
block|{
for|for
control|(
name|int
name|propChild
init|=
literal|0
init|;
name|propChild
operator|<
name|prop
operator|.
name|getChildCount
argument_list|()
condition|;
name|propChild
operator|++
control|)
block|{
name|String
name|key
init|=
name|unescapeSQLString
argument_list|(
name|prop
operator|.
name|getChild
argument_list|(
name|propChild
argument_list|)
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getText
argument_list|()
argument_list|)
decl_stmt|;
name|String
name|value
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|prop
operator|.
name|getChild
argument_list|(
name|propChild
argument_list|)
operator|.
name|getChild
argument_list|(
literal|1
argument_list|)
operator|!=
literal|null
condition|)
block|{
name|value
operator|=
name|unescapeSQLString
argument_list|(
name|prop
operator|.
name|getChild
argument_list|(
name|propChild
argument_list|)
operator|.
name|getChild
argument_list|(
literal|1
argument_list|)
operator|.
name|getText
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|mapProp
operator|.
name|put
argument_list|(
name|key
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
specifier|static
specifier|final
name|int
index|[]
name|multiplier
init|=
operator|new
name|int
index|[]
block|{
literal|1000
block|,
literal|100
block|,
literal|10
block|,
literal|1
block|}
decl_stmt|;
annotation|@
name|SuppressWarnings
argument_list|(
literal|"nls"
argument_list|)
specifier|public
specifier|static
name|String
name|unescapeSQLString
parameter_list|(
name|String
name|b
parameter_list|)
block|{
name|Character
name|enclosure
init|=
literal|null
decl_stmt|;
comment|// Some of the strings can be passed in as unicode. For example, the
comment|// delimiter can be passed in as \002 - So, we first check if the
comment|// string is a unicode number, else go back to the old behavior
name|StringBuilder
name|sb
init|=
operator|new
name|StringBuilder
argument_list|(
name|b
operator|.
name|length
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|b
operator|.
name|length
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|char
name|currentChar
init|=
name|b
operator|.
name|charAt
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|enclosure
operator|==
literal|null
condition|)
block|{
if|if
condition|(
name|currentChar
operator|==
literal|'\''
operator|||
name|b
operator|.
name|charAt
argument_list|(
name|i
argument_list|)
operator|==
literal|'\"'
condition|)
block|{
name|enclosure
operator|=
name|currentChar
expr_stmt|;
block|}
comment|// ignore all other chars outside the enclosure
continue|continue;
block|}
if|if
condition|(
name|enclosure
operator|.
name|equals
argument_list|(
name|currentChar
argument_list|)
condition|)
block|{
name|enclosure
operator|=
literal|null
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|currentChar
operator|==
literal|'\\'
operator|&&
operator|(
name|i
operator|+
literal|6
operator|<
name|b
operator|.
name|length
argument_list|()
operator|)
operator|&&
name|b
operator|.
name|charAt
argument_list|(
name|i
operator|+
literal|1
argument_list|)
operator|==
literal|'u'
condition|)
block|{
name|int
name|code
init|=
literal|0
decl_stmt|;
name|int
name|base
init|=
name|i
operator|+
literal|2
decl_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
literal|4
condition|;
name|j
operator|++
control|)
block|{
name|int
name|digit
init|=
name|Character
operator|.
name|digit
argument_list|(
name|b
operator|.
name|charAt
argument_list|(
name|j
operator|+
name|base
argument_list|)
argument_list|,
literal|16
argument_list|)
decl_stmt|;
name|code
operator|+=
name|digit
operator|*
name|multiplier
index|[
name|j
index|]
expr_stmt|;
block|}
name|sb
operator|.
name|append
argument_list|(
operator|(
name|char
operator|)
name|code
argument_list|)
expr_stmt|;
name|i
operator|+=
literal|5
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|currentChar
operator|==
literal|'\\'
operator|&&
operator|(
name|i
operator|+
literal|4
operator|<
name|b
operator|.
name|length
argument_list|()
operator|)
condition|)
block|{
name|char
name|i1
init|=
name|b
operator|.
name|charAt
argument_list|(
name|i
operator|+
literal|1
argument_list|)
decl_stmt|;
name|char
name|i2
init|=
name|b
operator|.
name|charAt
argument_list|(
name|i
operator|+
literal|2
argument_list|)
decl_stmt|;
name|char
name|i3
init|=
name|b
operator|.
name|charAt
argument_list|(
name|i
operator|+
literal|3
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|i1
operator|>=
literal|'0'
operator|&&
name|i1
operator|<=
literal|'1'
operator|)
operator|&&
operator|(
name|i2
operator|>=
literal|'0'
operator|&&
name|i2
operator|<=
literal|'7'
operator|)
operator|&&
operator|(
name|i3
operator|>=
literal|'0'
operator|&&
name|i3
operator|<=
literal|'7'
operator|)
condition|)
block|{
name|byte
name|bVal
init|=
call|(
name|byte
call|)
argument_list|(
operator|(
name|i3
operator|-
literal|'0'
operator|)
operator|+
operator|(
operator|(
name|i2
operator|-
literal|'0'
operator|)
operator|*
literal|8
operator|)
operator|+
operator|(
operator|(
name|i1
operator|-
literal|'0'
operator|)
operator|*
literal|8
operator|*
literal|8
operator|)
argument_list|)
decl_stmt|;
name|byte
index|[]
name|bValArr
init|=
operator|new
name|byte
index|[
literal|1
index|]
decl_stmt|;
name|bValArr
index|[
literal|0
index|]
operator|=
name|bVal
expr_stmt|;
name|String
name|tmp
init|=
operator|new
name|String
argument_list|(
name|bValArr
argument_list|)
decl_stmt|;
name|sb
operator|.
name|append
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
name|i
operator|+=
literal|3
expr_stmt|;
continue|continue;
block|}
block|}
if|if
condition|(
name|currentChar
operator|==
literal|'\\'
operator|&&
operator|(
name|i
operator|+
literal|2
operator|<
name|b
operator|.
name|length
argument_list|()
operator|)
condition|)
block|{
name|char
name|n
init|=
name|b
operator|.
name|charAt
argument_list|(
name|i
operator|+
literal|1
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|n
condition|)
block|{
case|case
literal|'0'
case|:
name|sb
operator|.
name|append
argument_list|(
literal|"\0"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'\''
case|:
name|sb
operator|.
name|append
argument_list|(
literal|"'"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'"'
case|:
name|sb
operator|.
name|append
argument_list|(
literal|"\""
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'b'
case|:
name|sb
operator|.
name|append
argument_list|(
literal|"\b"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'n'
case|:
name|sb
operator|.
name|append
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
name|sb
operator|.
name|append
argument_list|(
literal|"\r"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
name|sb
operator|.
name|append
argument_list|(
literal|"\t"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'Z'
case|:
name|sb
operator|.
name|append
argument_list|(
literal|"\u001A"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'\\'
case|:
name|sb
operator|.
name|append
argument_list|(
literal|"\\"
argument_list|)
expr_stmt|;
break|break;
comment|// The following 2 lines are exactly what MySQL does
case|case
literal|'%'
case|:
name|sb
operator|.
name|append
argument_list|(
literal|"\\%"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'_'
case|:
name|sb
operator|.
name|append
argument_list|(
literal|"\\_"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|sb
operator|.
name|append
argument_list|(
name|n
argument_list|)
expr_stmt|;
block|}
name|i
operator|++
expr_stmt|;
block|}
else|else
block|{
name|sb
operator|.
name|append
argument_list|(
name|currentChar
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|sb
operator|.
name|toString
argument_list|()
return|;
block|}
specifier|public
name|HashSet
argument_list|<
name|ReadEntity
argument_list|>
name|getInputs
parameter_list|()
block|{
return|return
name|inputs
return|;
block|}
specifier|public
name|HashSet
argument_list|<
name|WriteEntity
argument_list|>
name|getOutputs
parameter_list|()
block|{
return|return
name|outputs
return|;
block|}
comment|/**    * @return the schema for the fields which will be produced    * when the statement is executed, or null if not known    */
specifier|public
name|List
argument_list|<
name|FieldSchema
argument_list|>
name|getResultSchema
parameter_list|()
block|{
return|return
literal|null
return|;
block|}
specifier|protected
name|List
argument_list|<
name|FieldSchema
argument_list|>
name|getColumns
parameter_list|(
name|ASTNode
name|ast
parameter_list|)
throws|throws
name|SemanticException
block|{
return|return
name|getColumns
argument_list|(
name|ast
argument_list|,
literal|true
argument_list|)
return|;
block|}
specifier|protected
name|void
name|handleGenericFileFormat
parameter_list|(
name|ASTNode
name|node
parameter_list|)
throws|throws
name|SemanticException
block|{
name|ASTNode
name|child
init|=
operator|(
name|ASTNode
operator|)
name|node
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
decl_stmt|;
throw|throw
operator|new
name|SemanticException
argument_list|(
literal|"Unrecognized file format in STORED AS clause:"
operator|+
literal|" "
operator|+
operator|(
name|child
operator|==
literal|null
condition|?
literal|""
else|:
name|child
operator|.
name|getText
argument_list|()
operator|)
argument_list|)
throw|;
block|}
comment|/**    * Get the list of FieldSchema out of the ASTNode.    */
specifier|public
specifier|static
name|List
argument_list|<
name|FieldSchema
argument_list|>
name|getColumns
parameter_list|(
name|ASTNode
name|ast
parameter_list|,
name|boolean
name|lowerCase
parameter_list|)
throws|throws
name|SemanticException
block|{
name|List
argument_list|<
name|FieldSchema
argument_list|>
name|colList
init|=
operator|new
name|ArrayList
argument_list|<
name|FieldSchema
argument_list|>
argument_list|()
decl_stmt|;
name|int
name|numCh
init|=
name|ast
operator|.
name|getChildCount
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numCh
condition|;
name|i
operator|++
control|)
block|{
name|FieldSchema
name|col
init|=
operator|new
name|FieldSchema
argument_list|()
decl_stmt|;
name|ASTNode
name|child
init|=
operator|(
name|ASTNode
operator|)
name|ast
operator|.
name|getChild
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|Tree
name|grandChild
init|=
name|child
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|grandChild
operator|!=
literal|null
condition|)
block|{
name|String
name|name
init|=
name|grandChild
operator|.
name|getText
argument_list|()
decl_stmt|;
if|if
condition|(
name|lowerCase
condition|)
block|{
name|name
operator|=
name|name
operator|.
name|toLowerCase
argument_list|()
expr_stmt|;
block|}
comment|// child 0 is the name of the column
name|col
operator|.
name|setName
argument_list|(
name|unescapeIdentifier
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
comment|// child 1 is the type of the column
name|ASTNode
name|typeChild
init|=
call|(
name|ASTNode
call|)
argument_list|(
name|child
operator|.
name|getChild
argument_list|(
literal|1
argument_list|)
argument_list|)
decl_stmt|;
name|col
operator|.
name|setType
argument_list|(
name|getTypeStringFromAST
argument_list|(
name|typeChild
argument_list|)
argument_list|)
expr_stmt|;
comment|// child 2 is the optional comment of the column
if|if
condition|(
name|child
operator|.
name|getChildCount
argument_list|()
operator|==
literal|3
condition|)
block|{
name|col
operator|.
name|setComment
argument_list|(
name|unescapeSQLString
argument_list|(
name|child
operator|.
name|getChild
argument_list|(
literal|2
argument_list|)
operator|.
name|getText
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|colList
operator|.
name|add
argument_list|(
name|col
argument_list|)
expr_stmt|;
block|}
return|return
name|colList
return|;
block|}
specifier|public
specifier|static
name|List
argument_list|<
name|String
argument_list|>
name|getColumnNames
parameter_list|(
name|ASTNode
name|ast
parameter_list|)
block|{
name|List
argument_list|<
name|String
argument_list|>
name|colList
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
name|int
name|numCh
init|=
name|ast
operator|.
name|getChildCount
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numCh
condition|;
name|i
operator|++
control|)
block|{
name|ASTNode
name|child
init|=
operator|(
name|ASTNode
operator|)
name|ast
operator|.
name|getChild
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|colList
operator|.
name|add
argument_list|(
name|unescapeIdentifier
argument_list|(
name|child
operator|.
name|getText
argument_list|()
argument_list|)
operator|.
name|toLowerCase
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|colList
return|;
block|}
specifier|protected
name|List
argument_list|<
name|Order
argument_list|>
name|getColumnNamesOrder
parameter_list|(
name|ASTNode
name|ast
parameter_list|)
block|{
name|List
argument_list|<
name|Order
argument_list|>
name|colList
init|=
operator|new
name|ArrayList
argument_list|<
name|Order
argument_list|>
argument_list|()
decl_stmt|;
name|int
name|numCh
init|=
name|ast
operator|.
name|getChildCount
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numCh
condition|;
name|i
operator|++
control|)
block|{
name|ASTNode
name|child
init|=
operator|(
name|ASTNode
operator|)
name|ast
operator|.
name|getChild
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|child
operator|.
name|getToken
argument_list|()
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_TABSORTCOLNAMEASC
condition|)
block|{
name|colList
operator|.
name|add
argument_list|(
operator|new
name|Order
argument_list|(
name|unescapeIdentifier
argument_list|(
name|child
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getText
argument_list|()
argument_list|)
operator|.
name|toLowerCase
argument_list|()
argument_list|,
name|HIVE_COLUMN_ORDER_ASC
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|colList
operator|.
name|add
argument_list|(
operator|new
name|Order
argument_list|(
name|unescapeIdentifier
argument_list|(
name|child
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getText
argument_list|()
argument_list|)
operator|.
name|toLowerCase
argument_list|()
argument_list|,
name|HIVE_COLUMN_ORDER_DESC
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|colList
return|;
block|}
specifier|protected
specifier|static
name|String
name|getTypeStringFromAST
parameter_list|(
name|ASTNode
name|typeNode
parameter_list|)
throws|throws
name|SemanticException
block|{
switch|switch
condition|(
name|typeNode
operator|.
name|getType
argument_list|()
condition|)
block|{
case|case
name|HiveParser
operator|.
name|TOK_LIST
case|:
return|return
name|serdeConstants
operator|.
name|LIST_TYPE_NAME
operator|+
literal|"<"
operator|+
name|getTypeStringFromAST
argument_list|(
operator|(
name|ASTNode
operator|)
name|typeNode
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
argument_list|)
operator|+
literal|">"
return|;
case|case
name|HiveParser
operator|.
name|TOK_MAP
case|:
return|return
name|serdeConstants
operator|.
name|MAP_TYPE_NAME
operator|+
literal|"<"
operator|+
name|getTypeStringFromAST
argument_list|(
operator|(
name|ASTNode
operator|)
name|typeNode
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
argument_list|)
operator|+
literal|","
operator|+
name|getTypeStringFromAST
argument_list|(
operator|(
name|ASTNode
operator|)
name|typeNode
operator|.
name|getChild
argument_list|(
literal|1
argument_list|)
argument_list|)
operator|+
literal|">"
return|;
case|case
name|HiveParser
operator|.
name|TOK_STRUCT
case|:
return|return
name|getStructTypeStringFromAST
argument_list|(
name|typeNode
argument_list|)
return|;
case|case
name|HiveParser
operator|.
name|TOK_UNIONTYPE
case|:
return|return
name|getUnionTypeStringFromAST
argument_list|(
name|typeNode
argument_list|)
return|;
default|default:
return|return
name|DDLSemanticAnalyzer
operator|.
name|getTypeName
argument_list|(
name|typeNode
argument_list|)
return|;
block|}
block|}
specifier|private
specifier|static
name|String
name|getStructTypeStringFromAST
parameter_list|(
name|ASTNode
name|typeNode
parameter_list|)
throws|throws
name|SemanticException
block|{
name|String
name|typeStr
init|=
name|serdeConstants
operator|.
name|STRUCT_TYPE_NAME
operator|+
literal|"<"
decl_stmt|;
name|typeNode
operator|=
operator|(
name|ASTNode
operator|)
name|typeNode
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|int
name|children
init|=
name|typeNode
operator|.
name|getChildCount
argument_list|()
decl_stmt|;
if|if
condition|(
name|children
operator|<=
literal|0
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
literal|"empty struct not allowed."
argument_list|)
throw|;
block|}
name|StringBuilder
name|buffer
init|=
operator|new
name|StringBuilder
argument_list|(
name|typeStr
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|children
condition|;
name|i
operator|++
control|)
block|{
name|ASTNode
name|child
init|=
operator|(
name|ASTNode
operator|)
name|typeNode
operator|.
name|getChild
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|buffer
operator|.
name|append
argument_list|(
name|unescapeIdentifier
argument_list|(
name|child
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getText
argument_list|()
argument_list|)
argument_list|)
operator|.
name|append
argument_list|(
literal|":"
argument_list|)
expr_stmt|;
name|buffer
operator|.
name|append
argument_list|(
name|getTypeStringFromAST
argument_list|(
operator|(
name|ASTNode
operator|)
name|child
operator|.
name|getChild
argument_list|(
literal|1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<
name|children
operator|-
literal|1
condition|)
block|{
name|buffer
operator|.
name|append
argument_list|(
literal|","
argument_list|)
expr_stmt|;
block|}
block|}
name|buffer
operator|.
name|append
argument_list|(
literal|">"
argument_list|)
expr_stmt|;
return|return
name|buffer
operator|.
name|toString
argument_list|()
return|;
block|}
specifier|private
specifier|static
name|String
name|getUnionTypeStringFromAST
parameter_list|(
name|ASTNode
name|typeNode
parameter_list|)
throws|throws
name|SemanticException
block|{
name|String
name|typeStr
init|=
name|serdeConstants
operator|.
name|UNION_TYPE_NAME
operator|+
literal|"<"
decl_stmt|;
name|typeNode
operator|=
operator|(
name|ASTNode
operator|)
name|typeNode
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|int
name|children
init|=
name|typeNode
operator|.
name|getChildCount
argument_list|()
decl_stmt|;
if|if
condition|(
name|children
operator|<=
literal|0
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
literal|"empty union not allowed."
argument_list|)
throw|;
block|}
name|StringBuilder
name|buffer
init|=
operator|new
name|StringBuilder
argument_list|(
name|typeStr
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|children
condition|;
name|i
operator|++
control|)
block|{
name|buffer
operator|.
name|append
argument_list|(
name|getTypeStringFromAST
argument_list|(
operator|(
name|ASTNode
operator|)
name|typeNode
operator|.
name|getChild
argument_list|(
name|i
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<
name|children
operator|-
literal|1
condition|)
block|{
name|buffer
operator|.
name|append
argument_list|(
literal|","
argument_list|)
expr_stmt|;
block|}
block|}
name|buffer
operator|.
name|append
argument_list|(
literal|">"
argument_list|)
expr_stmt|;
name|typeStr
operator|=
name|buffer
operator|.
name|toString
argument_list|()
expr_stmt|;
return|return
name|typeStr
return|;
block|}
comment|/**    * tableSpec.    *    */
specifier|public
specifier|static
class|class
name|tableSpec
block|{
specifier|public
name|String
name|tableName
decl_stmt|;
specifier|public
name|Table
name|tableHandle
decl_stmt|;
specifier|public
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|partSpec
decl_stmt|;
comment|// has to use LinkedHashMap to enforce order
specifier|public
name|Partition
name|partHandle
decl_stmt|;
specifier|public
name|int
name|numDynParts
decl_stmt|;
comment|// number of dynamic partition columns
specifier|public
name|List
argument_list|<
name|Partition
argument_list|>
name|partitions
decl_stmt|;
comment|// involved partitions in TableScanOperator/FileSinkOperator
specifier|public
specifier|static
enum|enum
name|SpecType
block|{
name|TABLE_ONLY
block|,
name|STATIC_PARTITION
block|,
name|DYNAMIC_PARTITION
block|}
empty_stmt|;
specifier|public
name|SpecType
name|specType
decl_stmt|;
specifier|public
name|tableSpec
parameter_list|(
name|Hive
name|db
parameter_list|,
name|HiveConf
name|conf
parameter_list|,
name|ASTNode
name|ast
parameter_list|)
throws|throws
name|SemanticException
block|{
name|this
argument_list|(
name|db
argument_list|,
name|conf
argument_list|,
name|ast
argument_list|,
literal|true
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
specifier|public
name|tableSpec
parameter_list|(
name|Hive
name|db
parameter_list|,
name|HiveConf
name|conf
parameter_list|,
name|ASTNode
name|ast
parameter_list|,
name|boolean
name|allowDynamicPartitionsSpec
parameter_list|,
name|boolean
name|allowPartialPartitionsSpec
parameter_list|)
throws|throws
name|SemanticException
block|{
assert|assert
operator|(
name|ast
operator|.
name|getToken
argument_list|()
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_TAB
operator|||
name|ast
operator|.
name|getToken
argument_list|()
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_TABLE_PARTITION
operator|||
name|ast
operator|.
name|getToken
argument_list|()
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_TABTYPE
operator|||
name|ast
operator|.
name|getToken
argument_list|()
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_CREATETABLE
operator|)
assert|;
name|int
name|childIndex
init|=
literal|0
decl_stmt|;
name|numDynParts
operator|=
literal|0
expr_stmt|;
try|try
block|{
comment|// get table metadata
name|tableName
operator|=
name|getUnescapedName
argument_list|(
operator|(
name|ASTNode
operator|)
name|ast
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|boolean
name|testMode
init|=
name|conf
operator|.
name|getBoolVar
argument_list|(
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVETESTMODE
argument_list|)
decl_stmt|;
if|if
condition|(
name|testMode
condition|)
block|{
name|tableName
operator|=
name|conf
operator|.
name|getVar
argument_list|(
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVETESTMODEPREFIX
argument_list|)
operator|+
name|tableName
expr_stmt|;
block|}
if|if
condition|(
name|ast
operator|.
name|getToken
argument_list|()
operator|.
name|getType
argument_list|()
operator|!=
name|HiveParser
operator|.
name|TOK_CREATETABLE
condition|)
block|{
name|tableHandle
operator|=
name|db
operator|.
name|getTable
argument_list|(
name|tableName
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|InvalidTableException
name|ite
parameter_list|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|INVALID_TABLE
operator|.
name|getMsg
argument_list|(
name|ast
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
argument_list|)
argument_list|,
name|ite
argument_list|)
throw|;
block|}
catch|catch
parameter_list|(
name|HiveException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|GENERIC_ERROR
operator|.
name|getMsg
argument_list|(
name|ast
operator|.
name|getChild
argument_list|(
name|childIndex
argument_list|)
argument_list|,
name|e
operator|.
name|getMessage
argument_list|()
argument_list|)
argument_list|,
name|e
argument_list|)
throw|;
block|}
comment|// get partition metadata if partition specified
if|if
condition|(
name|ast
operator|.
name|getChildCount
argument_list|()
operator|==
literal|2
operator|&&
name|ast
operator|.
name|getToken
argument_list|()
operator|.
name|getType
argument_list|()
operator|!=
name|HiveParser
operator|.
name|TOK_CREATETABLE
condition|)
block|{
name|childIndex
operator|=
literal|1
expr_stmt|;
name|ASTNode
name|partspec
init|=
operator|(
name|ASTNode
operator|)
name|ast
operator|.
name|getChild
argument_list|(
literal|1
argument_list|)
decl_stmt|;
name|partitions
operator|=
operator|new
name|ArrayList
argument_list|<
name|Partition
argument_list|>
argument_list|()
expr_stmt|;
comment|// partSpec is a mapping from partition column name to its value.
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|tmpPartSpec
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
argument_list|(
name|partspec
operator|.
name|getChildCount
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|partspec
operator|.
name|getChildCount
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|ASTNode
name|partspec_val
init|=
operator|(
name|ASTNode
operator|)
name|partspec
operator|.
name|getChild
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|String
name|val
init|=
literal|null
decl_stmt|;
name|String
name|colName
init|=
name|unescapeIdentifier
argument_list|(
name|partspec_val
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getText
argument_list|()
operator|.
name|toLowerCase
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|partspec_val
operator|.
name|getChildCount
argument_list|()
operator|<
literal|2
condition|)
block|{
comment|// DP in the form of T partition (ds, hr)
if|if
condition|(
name|allowDynamicPartitionsSpec
condition|)
block|{
operator|++
name|numDynParts
expr_stmt|;
block|}
else|else
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|INVALID_PARTITION
operator|.
name|getMsg
argument_list|(
literal|" - Dynamic partitions not allowed"
argument_list|)
argument_list|)
throw|;
block|}
block|}
else|else
block|{
comment|// in the form of T partition (ds="2010-03-03")
name|val
operator|=
name|stripQuotes
argument_list|(
name|partspec_val
operator|.
name|getChild
argument_list|(
literal|1
argument_list|)
operator|.
name|getText
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|tmpPartSpec
operator|.
name|put
argument_list|(
name|colName
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
comment|// check if the columns, as well as value types in the partition() clause are valid
name|validatePartSpec
argument_list|(
name|tableHandle
argument_list|,
name|tmpPartSpec
argument_list|,
name|ast
argument_list|,
name|conf
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|FieldSchema
argument_list|>
name|parts
init|=
name|tableHandle
operator|.
name|getPartitionKeys
argument_list|()
decl_stmt|;
name|partSpec
operator|=
operator|new
name|LinkedHashMap
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
argument_list|(
name|partspec
operator|.
name|getChildCount
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|FieldSchema
name|fs
range|:
name|parts
control|)
block|{
name|String
name|partKey
init|=
name|fs
operator|.
name|getName
argument_list|()
decl_stmt|;
name|partSpec
operator|.
name|put
argument_list|(
name|partKey
argument_list|,
name|tmpPartSpec
operator|.
name|get
argument_list|(
name|partKey
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// check if the partition spec is valid
if|if
condition|(
name|numDynParts
operator|>
literal|0
condition|)
block|{
name|int
name|numStaPart
init|=
name|parts
operator|.
name|size
argument_list|()
operator|-
name|numDynParts
decl_stmt|;
if|if
condition|(
name|numStaPart
operator|==
literal|0
operator|&&
name|conf
operator|.
name|getVar
argument_list|(
name|HiveConf
operator|.
name|ConfVars
operator|.
name|DYNAMICPARTITIONINGMODE
argument_list|)
operator|.
name|equalsIgnoreCase
argument_list|(
literal|"strict"
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|DYNAMIC_PARTITION_STRICT_MODE
operator|.
name|getMsg
argument_list|()
argument_list|)
throw|;
block|}
comment|// check the partitions in partSpec be the same as defined in table schema
if|if
condition|(
name|partSpec
operator|.
name|keySet
argument_list|()
operator|.
name|size
argument_list|()
operator|!=
name|parts
operator|.
name|size
argument_list|()
condition|)
block|{
name|ErrorPartSpec
argument_list|(
name|partSpec
argument_list|,
name|parts
argument_list|)
expr_stmt|;
block|}
name|Iterator
argument_list|<
name|String
argument_list|>
name|itrPsKeys
init|=
name|partSpec
operator|.
name|keySet
argument_list|()
operator|.
name|iterator
argument_list|()
decl_stmt|;
for|for
control|(
name|FieldSchema
name|fs
range|:
name|parts
control|)
block|{
if|if
condition|(
operator|!
name|itrPsKeys
operator|.
name|next
argument_list|()
operator|.
name|toLowerCase
argument_list|()
operator|.
name|equals
argument_list|(
name|fs
operator|.
name|getName
argument_list|()
operator|.
name|toLowerCase
argument_list|()
argument_list|)
condition|)
block|{
name|ErrorPartSpec
argument_list|(
name|partSpec
argument_list|,
name|parts
argument_list|)
expr_stmt|;
block|}
block|}
comment|// check if static partition appear after dynamic partitions
for|for
control|(
name|FieldSchema
name|fs
range|:
name|parts
control|)
block|{
if|if
condition|(
name|partSpec
operator|.
name|get
argument_list|(
name|fs
operator|.
name|getName
argument_list|()
operator|.
name|toLowerCase
argument_list|()
argument_list|)
operator|==
literal|null
condition|)
block|{
if|if
condition|(
name|numStaPart
operator|>
literal|0
condition|)
block|{
comment|// found a DP, but there exists ST as subpartition
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|PARTITION_DYN_STA_ORDER
operator|.
name|getMsg
argument_list|(
name|ast
operator|.
name|getChild
argument_list|(
name|childIndex
argument_list|)
argument_list|)
argument_list|)
throw|;
block|}
break|break;
block|}
else|else
block|{
operator|--
name|numStaPart
expr_stmt|;
block|}
block|}
name|partHandle
operator|=
literal|null
expr_stmt|;
name|specType
operator|=
name|SpecType
operator|.
name|DYNAMIC_PARTITION
expr_stmt|;
block|}
else|else
block|{
try|try
block|{
if|if
condition|(
name|allowPartialPartitionsSpec
condition|)
block|{
name|partitions
operator|=
name|db
operator|.
name|getPartitions
argument_list|(
name|tableHandle
argument_list|,
name|partSpec
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// this doesn't create partition.
name|partHandle
operator|=
name|db
operator|.
name|getPartition
argument_list|(
name|tableHandle
argument_list|,
name|partSpec
argument_list|,
literal|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|partHandle
operator|==
literal|null
condition|)
block|{
comment|// if partSpec doesn't exists in DB, return a delegate one
comment|// and the actual partition is created in MoveTask
name|partHandle
operator|=
operator|new
name|Partition
argument_list|(
name|tableHandle
argument_list|,
name|partSpec
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|partitions
operator|.
name|add
argument_list|(
name|partHandle
argument_list|)
expr_stmt|;
block|}
block|}
block|}
catch|catch
parameter_list|(
name|HiveException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|INVALID_PARTITION
operator|.
name|getMsg
argument_list|(
name|ast
operator|.
name|getChild
argument_list|(
name|childIndex
argument_list|)
argument_list|)
argument_list|,
name|e
argument_list|)
throw|;
block|}
name|specType
operator|=
name|SpecType
operator|.
name|STATIC_PARTITION
expr_stmt|;
block|}
block|}
else|else
block|{
name|specType
operator|=
name|SpecType
operator|.
name|TABLE_ONLY
expr_stmt|;
block|}
block|}
specifier|public
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|getPartSpec
parameter_list|()
block|{
return|return
name|this
operator|.
name|partSpec
return|;
block|}
specifier|public
name|void
name|setPartSpec
parameter_list|(
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|partSpec
parameter_list|)
block|{
name|this
operator|.
name|partSpec
operator|=
name|partSpec
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|toString
parameter_list|()
block|{
if|if
condition|(
name|partHandle
operator|!=
literal|null
condition|)
block|{
return|return
name|partHandle
operator|.
name|toString
argument_list|()
return|;
block|}
else|else
block|{
return|return
name|tableHandle
operator|.
name|toString
argument_list|()
return|;
block|}
block|}
block|}
comment|/**    * Gets the lineage information.    *    * @return LineageInfo associated with the query.    */
specifier|public
name|LineageInfo
name|getLineageInfo
parameter_list|()
block|{
return|return
name|linfo
return|;
block|}
comment|/**    * Sets the lineage information.    *    * @param linfo The LineageInfo structure that is set in the optimization phase.    */
specifier|public
name|void
name|setLineageInfo
parameter_list|(
name|LineageInfo
name|linfo
parameter_list|)
block|{
name|this
operator|.
name|linfo
operator|=
name|linfo
expr_stmt|;
block|}
comment|/**    * Gets the table access information.    *    * @return TableAccessInfo associated with the query.    */
specifier|public
name|TableAccessInfo
name|getTableAccessInfo
parameter_list|()
block|{
return|return
name|tableAccessInfo
return|;
block|}
comment|/**    * Sets the table access information.    *    * @param taInfo The TableAccessInfo structure that is set in the optimization phase.    */
specifier|public
name|void
name|setTableAccessInfo
parameter_list|(
name|TableAccessInfo
name|tableAccessInfo
parameter_list|)
block|{
name|this
operator|.
name|tableAccessInfo
operator|=
name|tableAccessInfo
expr_stmt|;
block|}
comment|/**    * Gets the column access information.    *    * @return ColumnAccessInfo associated with the query.    */
specifier|public
name|ColumnAccessInfo
name|getColumnAccessInfo
parameter_list|()
block|{
return|return
name|columnAccessInfo
return|;
block|}
comment|/**    * Sets the column access information.    *    * @param columnAccessInfo The ColumnAccessInfo structure that is set immediately after    * the optimization phase.    */
specifier|public
name|void
name|setColumnAccessInfo
parameter_list|(
name|ColumnAccessInfo
name|columnAccessInfo
parameter_list|)
block|{
name|this
operator|.
name|columnAccessInfo
operator|=
name|columnAccessInfo
expr_stmt|;
block|}
specifier|protected
name|HashMap
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|extractPartitionSpecs
parameter_list|(
name|Tree
name|partspec
parameter_list|)
throws|throws
name|SemanticException
block|{
name|HashMap
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|partSpec
init|=
operator|new
name|LinkedHashMap
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|partspec
operator|.
name|getChildCount
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|CommonTree
name|partspec_val
init|=
operator|(
name|CommonTree
operator|)
name|partspec
operator|.
name|getChild
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|String
name|val
init|=
name|stripQuotes
argument_list|(
name|partspec_val
operator|.
name|getChild
argument_list|(
literal|1
argument_list|)
operator|.
name|getText
argument_list|()
argument_list|)
decl_stmt|;
name|partSpec
operator|.
name|put
argument_list|(
name|partspec_val
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getText
argument_list|()
operator|.
name|toLowerCase
argument_list|()
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
return|return
name|partSpec
return|;
block|}
comment|/**    * Checks if given specification is proper specification for prefix of    * partition cols, for table partitioned by ds, hr, min valid ones are    * (ds='2008-04-08'), (ds='2008-04-08', hr='12'), (ds='2008-04-08', hr='12', min='30')    * invalid one is for example (ds='2008-04-08', min='30')    * @param spec specification key-value map    * @return true if the specification is prefix; never returns false, but throws    * @throws HiveException    */
specifier|final
specifier|public
name|boolean
name|isValidPrefixSpec
parameter_list|(
name|Table
name|tTable
parameter_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|spec
parameter_list|)
throws|throws
name|HiveException
block|{
comment|// TODO - types need to be checked.
name|List
argument_list|<
name|FieldSchema
argument_list|>
name|partCols
init|=
name|tTable
operator|.
name|getPartitionKeys
argument_list|()
decl_stmt|;
if|if
condition|(
name|partCols
operator|==
literal|null
operator|||
operator|(
name|partCols
operator|.
name|size
argument_list|()
operator|==
literal|0
operator|)
condition|)
block|{
if|if
condition|(
name|spec
operator|!=
literal|null
condition|)
block|{
throw|throw
operator|new
name|HiveException
argument_list|(
literal|"table is not partitioned but partition spec exists: "
operator|+
name|spec
argument_list|)
throw|;
block|}
else|else
block|{
return|return
literal|true
return|;
block|}
block|}
if|if
condition|(
name|spec
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|HiveException
argument_list|(
literal|"partition spec is not specified"
argument_list|)
throw|;
block|}
name|Iterator
argument_list|<
name|String
argument_list|>
name|itrPsKeys
init|=
name|spec
operator|.
name|keySet
argument_list|()
operator|.
name|iterator
argument_list|()
decl_stmt|;
for|for
control|(
name|FieldSchema
name|fs
range|:
name|partCols
control|)
block|{
if|if
condition|(
operator|!
name|itrPsKeys
operator|.
name|hasNext
argument_list|()
condition|)
block|{
break|break;
block|}
if|if
condition|(
operator|!
name|itrPsKeys
operator|.
name|next
argument_list|()
operator|.
name|toLowerCase
argument_list|()
operator|.
name|equals
argument_list|(
name|fs
operator|.
name|getName
argument_list|()
operator|.
name|toLowerCase
argument_list|()
argument_list|)
condition|)
block|{
name|ErrorPartSpec
argument_list|(
name|spec
argument_list|,
name|partCols
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|itrPsKeys
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|ErrorPartSpec
argument_list|(
name|spec
argument_list|,
name|partCols
argument_list|)
expr_stmt|;
block|}
return|return
literal|true
return|;
block|}
specifier|private
specifier|static
name|void
name|ErrorPartSpec
parameter_list|(
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|partSpec
parameter_list|,
name|List
argument_list|<
name|FieldSchema
argument_list|>
name|parts
parameter_list|)
throws|throws
name|SemanticException
block|{
name|StringBuilder
name|sb
init|=
operator|new
name|StringBuilder
argument_list|(
literal|"Partition columns in the table schema are: ("
argument_list|)
decl_stmt|;
for|for
control|(
name|FieldSchema
name|fs
range|:
name|parts
control|)
block|{
name|sb
operator|.
name|append
argument_list|(
name|fs
operator|.
name|getName
argument_list|()
argument_list|)
operator|.
name|append
argument_list|(
literal|", "
argument_list|)
expr_stmt|;
block|}
name|sb
operator|.
name|setLength
argument_list|(
name|sb
operator|.
name|length
argument_list|()
operator|-
literal|2
argument_list|)
expr_stmt|;
comment|// remove the last ", "
name|sb
operator|.
name|append
argument_list|(
literal|"), while the partitions specified in the query are: ("
argument_list|)
expr_stmt|;
name|Iterator
argument_list|<
name|String
argument_list|>
name|itrPsKeys
init|=
name|partSpec
operator|.
name|keySet
argument_list|()
operator|.
name|iterator
argument_list|()
decl_stmt|;
while|while
condition|(
name|itrPsKeys
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|sb
operator|.
name|append
argument_list|(
name|itrPsKeys
operator|.
name|next
argument_list|()
argument_list|)
operator|.
name|append
argument_list|(
literal|", "
argument_list|)
expr_stmt|;
block|}
name|sb
operator|.
name|setLength
argument_list|(
name|sb
operator|.
name|length
argument_list|()
operator|-
literal|2
argument_list|)
expr_stmt|;
comment|// remove the last ", "
name|sb
operator|.
name|append
argument_list|(
literal|")."
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|PARTSPEC_DIFFER_FROM_SCHEMA
operator|.
name|getMsg
argument_list|(
name|sb
operator|.
name|toString
argument_list|()
argument_list|)
argument_list|)
throw|;
block|}
specifier|public
name|Hive
name|getDb
parameter_list|()
block|{
return|return
name|db
return|;
block|}
specifier|public
name|QueryProperties
name|getQueryProperties
parameter_list|()
block|{
return|return
name|queryProperties
return|;
block|}
comment|/**    * Construct list bucketing context.    *    * @param skewedColNames    * @param skewedValues    * @param skewedColValueLocationMaps    * @param isStoredAsSubDirectories    * @return    */
specifier|protected
name|ListBucketingCtx
name|constructListBucketingCtx
parameter_list|(
name|List
argument_list|<
name|String
argument_list|>
name|skewedColNames
parameter_list|,
name|List
argument_list|<
name|List
argument_list|<
name|String
argument_list|>
argument_list|>
name|skewedValues
parameter_list|,
name|Map
argument_list|<
name|List
argument_list|<
name|String
argument_list|>
argument_list|,
name|String
argument_list|>
name|skewedColValueLocationMaps
parameter_list|,
name|boolean
name|isStoredAsSubDirectories
parameter_list|,
name|HiveConf
name|conf
parameter_list|)
block|{
name|ListBucketingCtx
name|lbCtx
init|=
operator|new
name|ListBucketingCtx
argument_list|()
decl_stmt|;
name|lbCtx
operator|.
name|setSkewedColNames
argument_list|(
name|skewedColNames
argument_list|)
expr_stmt|;
name|lbCtx
operator|.
name|setSkewedColValues
argument_list|(
name|skewedValues
argument_list|)
expr_stmt|;
name|lbCtx
operator|.
name|setLbLocationMap
argument_list|(
name|skewedColValueLocationMaps
argument_list|)
expr_stmt|;
name|lbCtx
operator|.
name|setStoredAsSubDirectories
argument_list|(
name|isStoredAsSubDirectories
argument_list|)
expr_stmt|;
name|lbCtx
operator|.
name|setDefaultKey
argument_list|(
name|ListBucketingPrunerUtils
operator|.
name|HIVE_LIST_BUCKETING_DEFAULT_KEY
argument_list|)
expr_stmt|;
name|lbCtx
operator|.
name|setDefaultDirName
argument_list|(
name|ListBucketingPrunerUtils
operator|.
name|HIVE_LIST_BUCKETING_DEFAULT_DIR_NAME
argument_list|)
expr_stmt|;
return|return
name|lbCtx
return|;
block|}
comment|/**    * Given a ASTNode, return list of values.    *    * use case:    *   create table xyz list bucketed (col1) with skew (1,2,5)    *   AST Node is for (1,2,5)    * @param ast    * @return    */
specifier|protected
name|List
argument_list|<
name|String
argument_list|>
name|getSkewedValueFromASTNode
parameter_list|(
name|ASTNode
name|ast
parameter_list|)
block|{
name|List
argument_list|<
name|String
argument_list|>
name|colList
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
name|int
name|numCh
init|=
name|ast
operator|.
name|getChildCount
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numCh
condition|;
name|i
operator|++
control|)
block|{
name|ASTNode
name|child
init|=
operator|(
name|ASTNode
operator|)
name|ast
operator|.
name|getChild
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|colList
operator|.
name|add
argument_list|(
name|stripQuotes
argument_list|(
name|child
operator|.
name|getText
argument_list|()
argument_list|)
operator|.
name|toLowerCase
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|colList
return|;
block|}
comment|/**    * Retrieve skewed values from ASTNode.    *    * @param node    * @return    * @throws SemanticException    */
specifier|protected
name|List
argument_list|<
name|String
argument_list|>
name|getSkewedValuesFromASTNode
parameter_list|(
name|Node
name|node
parameter_list|)
throws|throws
name|SemanticException
block|{
name|List
argument_list|<
name|String
argument_list|>
name|result
init|=
literal|null
decl_stmt|;
name|Tree
name|leafVNode
init|=
operator|(
operator|(
name|ASTNode
operator|)
name|node
operator|)
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|leafVNode
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|SKEWED_TABLE_NO_COLUMN_VALUE
operator|.
name|getMsg
argument_list|()
argument_list|)
throw|;
block|}
else|else
block|{
name|ASTNode
name|lVAstNode
init|=
operator|(
name|ASTNode
operator|)
name|leafVNode
decl_stmt|;
if|if
condition|(
name|lVAstNode
operator|.
name|getToken
argument_list|()
operator|.
name|getType
argument_list|()
operator|!=
name|HiveParser
operator|.
name|TOK_TABCOLVALUE
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|SKEWED_TABLE_NO_COLUMN_VALUE
operator|.
name|getMsg
argument_list|()
argument_list|)
throw|;
block|}
else|else
block|{
name|result
operator|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|(
name|getSkewedValueFromASTNode
argument_list|(
name|lVAstNode
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|result
return|;
block|}
comment|/**    * Analyze list bucket column names    *    * @param skewedColNames    * @param child    * @return    * @throws SemanticException    */
specifier|protected
name|List
argument_list|<
name|String
argument_list|>
name|analyzeSkewedTablDDLColNames
parameter_list|(
name|List
argument_list|<
name|String
argument_list|>
name|skewedColNames
parameter_list|,
name|ASTNode
name|child
parameter_list|)
throws|throws
name|SemanticException
block|{
name|Tree
name|nNode
init|=
name|child
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|nNode
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|SKEWED_TABLE_NO_COLUMN_NAME
operator|.
name|getMsg
argument_list|()
argument_list|)
throw|;
block|}
else|else
block|{
name|ASTNode
name|nAstNode
init|=
operator|(
name|ASTNode
operator|)
name|nNode
decl_stmt|;
if|if
condition|(
name|nAstNode
operator|.
name|getToken
argument_list|()
operator|.
name|getType
argument_list|()
operator|!=
name|HiveParser
operator|.
name|TOK_TABCOLNAME
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|SKEWED_TABLE_NO_COLUMN_NAME
operator|.
name|getMsg
argument_list|()
argument_list|)
throw|;
block|}
else|else
block|{
name|skewedColNames
operator|=
name|getColumnNames
argument_list|(
name|nAstNode
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|skewedColNames
return|;
block|}
comment|/**    * Handle skewed values in DDL.    *    * It can be used by both skewed by ... on () and set skewed location ().    *    * @param skewedValues    * @param child    * @throws SemanticException    */
specifier|protected
name|void
name|analyzeDDLSkewedValues
parameter_list|(
name|List
argument_list|<
name|List
argument_list|<
name|String
argument_list|>
argument_list|>
name|skewedValues
parameter_list|,
name|ASTNode
name|child
parameter_list|)
throws|throws
name|SemanticException
block|{
name|Tree
name|vNode
init|=
name|child
operator|.
name|getChild
argument_list|(
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|vNode
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|SKEWED_TABLE_NO_COLUMN_VALUE
operator|.
name|getMsg
argument_list|()
argument_list|)
throw|;
block|}
name|ASTNode
name|vAstNode
init|=
operator|(
name|ASTNode
operator|)
name|vNode
decl_stmt|;
switch|switch
condition|(
name|vAstNode
operator|.
name|getToken
argument_list|()
operator|.
name|getType
argument_list|()
condition|)
block|{
case|case
name|HiveParser
operator|.
name|TOK_TABCOLVALUE
case|:
for|for
control|(
name|String
name|str
range|:
name|getSkewedValueFromASTNode
argument_list|(
name|vAstNode
argument_list|)
control|)
block|{
name|List
argument_list|<
name|String
argument_list|>
name|sList
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|(
name|Arrays
operator|.
name|asList
argument_list|(
name|str
argument_list|)
argument_list|)
decl_stmt|;
name|skewedValues
operator|.
name|add
argument_list|(
name|sList
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|HiveParser
operator|.
name|TOK_TABCOLVALUE_PAIR
case|:
name|ArrayList
argument_list|<
name|Node
argument_list|>
name|vLNodes
init|=
name|vAstNode
operator|.
name|getChildren
argument_list|()
decl_stmt|;
for|for
control|(
name|Node
name|node
range|:
name|vLNodes
control|)
block|{
if|if
condition|(
operator|(
operator|(
name|ASTNode
operator|)
name|node
operator|)
operator|.
name|getToken
argument_list|()
operator|.
name|getType
argument_list|()
operator|!=
name|HiveParser
operator|.
name|TOK_TABCOLVALUES
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|SKEWED_TABLE_NO_COLUMN_VALUE
operator|.
name|getMsg
argument_list|()
argument_list|)
throw|;
block|}
else|else
block|{
name|skewedValues
operator|.
name|add
argument_list|(
name|getSkewedValuesFromASTNode
argument_list|(
name|node
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
default|default:
break|break;
block|}
block|}
comment|/**    * process stored as directories    *    * @param child    * @return    */
specifier|protected
name|boolean
name|analyzeStoredAdDirs
parameter_list|(
name|ASTNode
name|child
parameter_list|)
block|{
name|boolean
name|storedAsDirs
init|=
literal|false
decl_stmt|;
if|if
condition|(
operator|(
name|child
operator|.
name|getChildCount
argument_list|()
operator|==
literal|3
operator|)
operator|&&
operator|(
operator|(
operator|(
name|ASTNode
operator|)
name|child
operator|.
name|getChild
argument_list|(
literal|2
argument_list|)
operator|)
operator|.
name|getToken
argument_list|()
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_STOREDASDIRS
operator|)
condition|)
block|{
name|storedAsDirs
operator|=
literal|true
expr_stmt|;
block|}
return|return
name|storedAsDirs
return|;
block|}
specifier|private
specifier|static
name|boolean
name|getPartExprNodeDesc
parameter_list|(
name|ASTNode
name|astNode
parameter_list|,
name|Map
argument_list|<
name|ASTNode
argument_list|,
name|ExprNodeDesc
argument_list|>
name|astExprNodeMap
parameter_list|)
throws|throws
name|SemanticException
block|{
if|if
condition|(
name|astNode
operator|==
literal|null
condition|)
block|{
return|return
literal|true
return|;
block|}
elseif|else
if|if
condition|(
operator|(
name|astNode
operator|.
name|getChildren
argument_list|()
operator|==
literal|null
operator|)
operator|||
operator|(
name|astNode
operator|.
name|getChildren
argument_list|()
operator|.
name|size
argument_list|()
operator|==
literal|0
operator|)
condition|)
block|{
return|return
name|astNode
operator|.
name|getType
argument_list|()
operator|!=
name|HiveParser
operator|.
name|TOK_PARTVAL
return|;
block|}
name|TypeCheckCtx
name|typeCheckCtx
init|=
operator|new
name|TypeCheckCtx
argument_list|(
literal|null
argument_list|)
decl_stmt|;
name|boolean
name|result
init|=
literal|true
decl_stmt|;
for|for
control|(
name|Node
name|childNode
range|:
name|astNode
operator|.
name|getChildren
argument_list|()
control|)
block|{
name|ASTNode
name|childASTNode
init|=
operator|(
name|ASTNode
operator|)
name|childNode
decl_stmt|;
if|if
condition|(
name|childASTNode
operator|.
name|getType
argument_list|()
operator|!=
name|HiveParser
operator|.
name|TOK_PARTVAL
condition|)
block|{
name|result
operator|=
name|getPartExprNodeDesc
argument_list|(
name|childASTNode
argument_list|,
name|astExprNodeMap
argument_list|)
operator|&&
name|result
expr_stmt|;
block|}
else|else
block|{
name|boolean
name|isDynamicPart
init|=
name|childASTNode
operator|.
name|getChildren
argument_list|()
operator|.
name|size
argument_list|()
operator|<=
literal|1
decl_stmt|;
name|result
operator|=
operator|!
name|isDynamicPart
operator|&&
name|result
expr_stmt|;
if|if
condition|(
operator|!
name|isDynamicPart
condition|)
block|{
name|ASTNode
name|partVal
init|=
operator|(
name|ASTNode
operator|)
name|childASTNode
operator|.
name|getChildren
argument_list|()
operator|.
name|get
argument_list|(
literal|1
argument_list|)
decl_stmt|;
name|astExprNodeMap
operator|.
name|put
argument_list|(
operator|(
name|ASTNode
operator|)
name|childASTNode
operator|.
name|getChildren
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|,
name|TypeCheckProcFactory
operator|.
name|genExprNode
argument_list|(
name|partVal
argument_list|,
name|typeCheckCtx
argument_list|)
operator|.
name|get
argument_list|(
name|partVal
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
name|result
return|;
block|}
specifier|public
specifier|static
name|void
name|validatePartSpec
parameter_list|(
name|Table
name|tbl
parameter_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|partSpec
parameter_list|,
name|ASTNode
name|astNode
parameter_list|,
name|HiveConf
name|conf
parameter_list|,
name|boolean
name|shouldBeFull
parameter_list|)
throws|throws
name|SemanticException
block|{
name|tbl
operator|.
name|validatePartColumnNames
argument_list|(
name|partSpec
argument_list|,
name|shouldBeFull
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|HiveConf
operator|.
name|getBoolVar
argument_list|(
name|conf
argument_list|,
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVE_TYPE_CHECK_ON_INSERT
argument_list|)
condition|)
block|{
return|return;
block|}
name|Map
argument_list|<
name|ASTNode
argument_list|,
name|ExprNodeDesc
argument_list|>
name|astExprNodeMap
init|=
operator|new
name|HashMap
argument_list|<
name|ASTNode
argument_list|,
name|ExprNodeDesc
argument_list|>
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|getPartExprNodeDesc
argument_list|(
name|astNode
argument_list|,
name|astExprNodeMap
argument_list|)
condition|)
block|{
name|STATIC_LOG
operator|.
name|warn
argument_list|(
literal|"Dynamic partitioning is used; only validating "
operator|+
name|astExprNodeMap
operator|.
name|size
argument_list|()
operator|+
literal|" columns"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|astExprNodeMap
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return;
comment|// All columns are dynamic, nothing to do.
block|}
name|List
argument_list|<
name|FieldSchema
argument_list|>
name|parts
init|=
name|tbl
operator|.
name|getPartitionKeys
argument_list|()
decl_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|partCols
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
argument_list|(
name|parts
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|FieldSchema
name|col
range|:
name|parts
control|)
block|{
name|partCols
operator|.
name|put
argument_list|(
name|col
operator|.
name|getName
argument_list|()
argument_list|,
name|col
operator|.
name|getType
argument_list|()
operator|.
name|toLowerCase
argument_list|()
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|Entry
argument_list|<
name|ASTNode
argument_list|,
name|ExprNodeDesc
argument_list|>
name|astExprNodePair
range|:
name|astExprNodeMap
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|String
name|astKeyName
init|=
name|astExprNodePair
operator|.
name|getKey
argument_list|()
operator|.
name|toString
argument_list|()
operator|.
name|toLowerCase
argument_list|()
decl_stmt|;
if|if
condition|(
name|astExprNodePair
operator|.
name|getKey
argument_list|()
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|Identifier
condition|)
block|{
name|astKeyName
operator|=
name|stripIdentifierQuotes
argument_list|(
name|astKeyName
argument_list|)
expr_stmt|;
block|}
name|String
name|colType
init|=
name|partCols
operator|.
name|get
argument_list|(
name|astKeyName
argument_list|)
decl_stmt|;
name|ObjectInspector
name|inputOI
init|=
name|astExprNodePair
operator|.
name|getValue
argument_list|()
operator|.
name|getWritableObjectInspector
argument_list|()
decl_stmt|;
name|TypeInfo
name|expectedType
init|=
name|TypeInfoUtils
operator|.
name|getTypeInfoFromTypeString
argument_list|(
name|colType
argument_list|)
decl_stmt|;
name|ObjectInspector
name|outputOI
init|=
name|TypeInfoUtils
operator|.
name|getStandardWritableObjectInspectorFromTypeInfo
argument_list|(
name|expectedType
argument_list|)
decl_stmt|;
name|Object
name|value
init|=
literal|null
decl_stmt|;
name|String
name|colSpec
init|=
name|partSpec
operator|.
name|get
argument_list|(
name|astKeyName
argument_list|)
decl_stmt|;
try|try
block|{
name|value
operator|=
name|ExprNodeEvaluatorFactory
operator|.
name|get
argument_list|(
name|astExprNodePair
operator|.
name|getValue
argument_list|()
argument_list|)
operator|.
name|evaluate
argument_list|(
name|colSpec
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|HiveException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|e
argument_list|)
throw|;
block|}
name|Object
name|convertedValue
init|=
name|ObjectInspectorConverters
operator|.
name|getConverter
argument_list|(
name|inputOI
argument_list|,
name|outputOI
argument_list|)
operator|.
name|convert
argument_list|(
name|value
argument_list|)
decl_stmt|;
if|if
condition|(
name|convertedValue
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|PARTITION_SPEC_TYPE_MISMATCH
argument_list|,
name|astKeyName
argument_list|,
name|inputOI
operator|.
name|getTypeName
argument_list|()
argument_list|,
name|outputOI
operator|.
name|getTypeName
argument_list|()
argument_list|)
throw|;
block|}
name|normalizeColSpec
argument_list|(
name|partSpec
argument_list|,
name|astKeyName
argument_list|,
name|colType
argument_list|,
name|colSpec
argument_list|,
name|convertedValue
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|VisibleForTesting
specifier|static
name|void
name|normalizeColSpec
parameter_list|(
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|partSpec
parameter_list|,
name|String
name|colName
parameter_list|,
name|String
name|colType
parameter_list|,
name|String
name|originalColSpec
parameter_list|,
name|Object
name|colValue
parameter_list|)
throws|throws
name|SemanticException
block|{
if|if
condition|(
name|colValue
operator|==
literal|null
condition|)
return|return;
comment|// nothing to do with nulls
name|String
name|normalizedColSpec
init|=
name|originalColSpec
decl_stmt|;
if|if
condition|(
name|colType
operator|.
name|equals
argument_list|(
name|serdeConstants
operator|.
name|DATE_TYPE_NAME
argument_list|)
condition|)
block|{
name|normalizedColSpec
operator|=
name|normalizeDateCol
argument_list|(
name|colValue
argument_list|,
name|originalColSpec
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|normalizedColSpec
operator|.
name|equals
argument_list|(
name|originalColSpec
argument_list|)
condition|)
block|{
name|STATIC_LOG
operator|.
name|warn
argument_list|(
literal|"Normalizing partition spec - "
operator|+
name|colName
operator|+
literal|" from "
operator|+
name|originalColSpec
operator|+
literal|" to "
operator|+
name|normalizedColSpec
argument_list|)
expr_stmt|;
name|partSpec
operator|.
name|put
argument_list|(
name|colName
argument_list|,
name|normalizedColSpec
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
specifier|static
name|String
name|normalizeDateCol
parameter_list|(
name|Object
name|colValue
parameter_list|,
name|String
name|originalColSpec
parameter_list|)
throws|throws
name|SemanticException
block|{
name|Date
name|value
decl_stmt|;
if|if
condition|(
name|colValue
operator|instanceof
name|DateWritable
condition|)
block|{
name|value
operator|=
operator|(
operator|(
name|DateWritable
operator|)
name|colValue
operator|)
operator|.
name|get
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|colValue
operator|instanceof
name|Date
condition|)
block|{
name|value
operator|=
operator|(
name|Date
operator|)
name|colValue
expr_stmt|;
block|}
else|else
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
literal|"Unexpected date type "
operator|+
name|colValue
operator|.
name|getClass
argument_list|()
argument_list|)
throw|;
block|}
return|return
name|HiveMetaStore
operator|.
name|PARTITION_DATE_FORMAT
operator|.
name|format
argument_list|(
name|value
argument_list|)
return|;
block|}
specifier|protected
name|Database
name|getDatabase
parameter_list|(
name|String
name|dbName
parameter_list|)
throws|throws
name|SemanticException
block|{
return|return
name|getDatabase
argument_list|(
name|dbName
argument_list|,
literal|true
argument_list|)
return|;
block|}
specifier|protected
name|Database
name|getDatabase
parameter_list|(
name|String
name|dbName
parameter_list|,
name|boolean
name|throwException
parameter_list|)
throws|throws
name|SemanticException
block|{
try|try
block|{
name|Database
name|database
init|=
name|db
operator|.
name|getDatabase
argument_list|(
name|dbName
argument_list|)
decl_stmt|;
if|if
condition|(
name|database
operator|==
literal|null
operator|&&
name|throwException
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|DATABASE_NOT_EXISTS
operator|.
name|getMsg
argument_list|(
name|dbName
argument_list|)
argument_list|)
throw|;
block|}
return|return
name|database
return|;
block|}
catch|catch
parameter_list|(
name|HiveException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|DATABASE_NOT_EXISTS
operator|.
name|getMsg
argument_list|(
name|dbName
argument_list|)
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
specifier|protected
name|Table
name|getTable
parameter_list|(
name|String
name|tblName
parameter_list|)
throws|throws
name|SemanticException
block|{
return|return
name|getTable
argument_list|(
literal|null
argument_list|,
name|tblName
argument_list|,
literal|true
argument_list|)
return|;
block|}
specifier|protected
name|Table
name|getTable
parameter_list|(
name|String
name|tblName
parameter_list|,
name|boolean
name|throwException
parameter_list|)
throws|throws
name|SemanticException
block|{
name|String
name|currentDb
init|=
name|SessionState
operator|.
name|get
argument_list|()
operator|.
name|getCurrentDatabase
argument_list|()
decl_stmt|;
return|return
name|getTable
argument_list|(
name|currentDb
argument_list|,
name|tblName
argument_list|,
name|throwException
argument_list|)
return|;
block|}
comment|// qnName : possibly contains database name (dot seperated)
specifier|protected
name|Table
name|getTableWithQN
parameter_list|(
name|String
name|qnName
parameter_list|,
name|boolean
name|throwException
parameter_list|)
throws|throws
name|SemanticException
block|{
name|int
name|dot
init|=
name|qnName
operator|.
name|indexOf
argument_list|(
literal|'.'
argument_list|)
decl_stmt|;
if|if
condition|(
name|dot
operator|<
literal|0
condition|)
block|{
name|String
name|currentDb
init|=
name|SessionState
operator|.
name|get
argument_list|()
operator|.
name|getCurrentDatabase
argument_list|()
decl_stmt|;
return|return
name|getTable
argument_list|(
name|currentDb
argument_list|,
name|qnName
argument_list|,
name|throwException
argument_list|)
return|;
block|}
return|return
name|getTable
argument_list|(
name|qnName
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|dot
argument_list|)
argument_list|,
name|qnName
operator|.
name|substring
argument_list|(
name|dot
operator|+
literal|1
argument_list|)
argument_list|,
name|throwException
argument_list|)
return|;
block|}
specifier|protected
name|Table
name|getTable
parameter_list|(
name|String
name|database
parameter_list|,
name|String
name|tblName
parameter_list|,
name|boolean
name|throwException
parameter_list|)
throws|throws
name|SemanticException
block|{
try|try
block|{
name|Table
name|tab
init|=
name|database
operator|==
literal|null
condition|?
name|db
operator|.
name|getTable
argument_list|(
name|tblName
argument_list|,
literal|false
argument_list|)
else|:
name|db
operator|.
name|getTable
argument_list|(
name|database
argument_list|,
name|tblName
argument_list|,
literal|false
argument_list|)
decl_stmt|;
if|if
condition|(
name|tab
operator|==
literal|null
operator|&&
name|throwException
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|INVALID_TABLE
operator|.
name|getMsg
argument_list|(
name|tblName
argument_list|)
argument_list|)
throw|;
block|}
return|return
name|tab
return|;
block|}
catch|catch
parameter_list|(
name|HiveException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|INVALID_TABLE
operator|.
name|getMsg
argument_list|(
name|tblName
argument_list|)
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
specifier|protected
name|Partition
name|getPartition
parameter_list|(
name|Table
name|table
parameter_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|partSpec
parameter_list|,
name|boolean
name|throwException
parameter_list|)
throws|throws
name|SemanticException
block|{
try|try
block|{
name|Partition
name|partition
init|=
name|db
operator|.
name|getPartition
argument_list|(
name|table
argument_list|,
name|partSpec
argument_list|,
literal|false
argument_list|)
decl_stmt|;
if|if
condition|(
name|partition
operator|==
literal|null
operator|&&
name|throwException
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|toMessage
argument_list|(
name|ErrorMsg
operator|.
name|INVALID_PARTITION
argument_list|,
name|partSpec
argument_list|)
argument_list|)
throw|;
block|}
return|return
name|partition
return|;
block|}
catch|catch
parameter_list|(
name|HiveException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|toMessage
argument_list|(
name|ErrorMsg
operator|.
name|INVALID_PARTITION
argument_list|,
name|partSpec
argument_list|)
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
specifier|protected
name|List
argument_list|<
name|Partition
argument_list|>
name|getPartitions
parameter_list|(
name|Table
name|table
parameter_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|partSpec
parameter_list|,
name|boolean
name|throwException
parameter_list|)
throws|throws
name|SemanticException
block|{
try|try
block|{
name|List
argument_list|<
name|Partition
argument_list|>
name|partitions
init|=
name|partSpec
operator|==
literal|null
condition|?
name|db
operator|.
name|getPartitions
argument_list|(
name|table
argument_list|)
else|:
name|db
operator|.
name|getPartitions
argument_list|(
name|table
argument_list|,
name|partSpec
argument_list|)
decl_stmt|;
if|if
condition|(
name|partitions
operator|.
name|isEmpty
argument_list|()
operator|&&
name|throwException
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|toMessage
argument_list|(
name|ErrorMsg
operator|.
name|INVALID_PARTITION
argument_list|,
name|partSpec
argument_list|)
argument_list|)
throw|;
block|}
return|return
name|partitions
return|;
block|}
catch|catch
parameter_list|(
name|HiveException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|toMessage
argument_list|(
name|ErrorMsg
operator|.
name|INVALID_PARTITION
argument_list|,
name|partSpec
argument_list|)
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
specifier|protected
name|String
name|toMessage
parameter_list|(
name|ErrorMsg
name|message
parameter_list|,
name|Object
name|detail
parameter_list|)
block|{
return|return
name|detail
operator|==
literal|null
condition|?
name|message
operator|.
name|getMsg
argument_list|()
else|:
name|message
operator|.
name|getMsg
argument_list|(
name|detail
operator|.
name|toString
argument_list|()
argument_list|)
return|;
block|}
block|}
end_class

end_unit

