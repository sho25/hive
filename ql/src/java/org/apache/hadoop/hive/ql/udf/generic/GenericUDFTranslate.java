begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|udf
operator|.
name|generic
package|;
end_package

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|ByteBuffer
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|Description
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|UDFArgumentException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|UDFArgumentLengthException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|UDFArgumentTypeException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|metadata
operator|.
name|HiveException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|udf
operator|.
name|UDFType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|objectinspector
operator|.
name|ObjectInspector
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|objectinspector
operator|.
name|ObjectInspector
operator|.
name|Category
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|objectinspector
operator|.
name|ObjectInspectorConverters
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|objectinspector
operator|.
name|PrimitiveObjectInspector
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|objectinspector
operator|.
name|PrimitiveObjectInspector
operator|.
name|PrimitiveCategory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|objectinspector
operator|.
name|primitive
operator|.
name|PrimitiveObjectInspectorFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|Text
import|;
end_import

begin_comment
comment|/**  * TRANSLATE(string input, string from, string to) is an equivalent function to translate in  * PostGresSQL. See explain extended annotation below to read more about how this UDF works  *  */
end_comment

begin_class
annotation|@
name|UDFType
argument_list|(
name|deterministic
operator|=
literal|true
argument_list|)
comment|//@formatter:off
annotation|@
name|Description
argument_list|(
name|name
operator|=
literal|"translate"
argument_list|,
name|value
operator|=
literal|"_FUNC_(input, from, to) - translates the input string by"
operator|+
literal|" replacing the characters present in the from string with the"
operator|+
literal|" corresponding characters in the to string"
argument_list|,
name|extended
operator|=
literal|"_FUNC_(string input, string from, string to) is an"
operator|+
literal|" equivalent function to translate in PostGreSQL. It works"
operator|+
literal|" on a character by character basis on the input string (first"
operator|+
literal|" parameter). A character in the input is checked for"
operator|+
literal|" presence in the from string (second parameter). If a"
operator|+
literal|" match happens, the character from to string (third "
operator|+
literal|"parameter) which appears at the same index as the character"
operator|+
literal|" in from string is obtained. This character is emitted in"
operator|+
literal|" the output string  instead of the original character from"
operator|+
literal|" the input string. If the to string is shorter than the"
operator|+
literal|" from string, there may not be a character present at"
operator|+
literal|" the same index in the to string. In such a case, nothing is"
operator|+
literal|" emitted for the original character and it's deleted from"
operator|+
literal|" the output string."
operator|+
literal|"\n"
operator|+
literal|"For example,"
operator|+
literal|"\n"
operator|+
literal|"\n"
operator|+
literal|"_FUNC_('abcdef', 'adc', '19') returns '1b9ef' replacing"
operator|+
literal|" 'a' with '1', 'd' with '9' and removing 'c' from the input"
operator|+
literal|" string"
operator|+
literal|"\n"
operator|+
literal|"\n"
operator|+
literal|"_FUNC_('a b c d', ' ', '') return 'abcd'"
operator|+
literal|" removing all spaces from the input string"
operator|+
literal|"\n"
operator|+
literal|"\n"
operator|+
literal|"If the same character is present multiple times in the"
operator|+
literal|" input string, the first occurence of the character is the"
operator|+
literal|" one that's considered for matching. However, it is not recommended"
operator|+
literal|" to have the same character more than once in the from"
operator|+
literal|" string since it's not required and adds to confusion."
operator|+
literal|"\n"
operator|+
literal|"\n"
operator|+
literal|"For example,"
operator|+
literal|"\n"
operator|+
literal|"\n"
operator|+
literal|"_FUNC_('abcdef', 'ada', '192') returns '1bc9ef' replaces"
operator|+
literal|" 'a' with '1' and 'd' with '9' ignoring the second"
operator|+
literal|" occurence of 'a' in the from string mapping it to '2'"
argument_list|)
comment|//@formatter:on
specifier|public
class|class
name|GenericUDFTranslate
extends|extends
name|GenericUDF
block|{
comment|// For all practical purposes a code point is a fancy name for character. A java char data type
comment|// can store characters that require 16 bits or less. However, the unicode specification has
comment|// changed to allow for characters whose representation requires more than 16 bits. Therefore we
comment|// need to represent each character (called a code point from hereon) as int. More details at
comment|// http://docs.oracle.com/javase/7/docs/api/java/lang/Character.html
comment|/**    * If a code point needs to be replaced with another code point, this map with store the mapping.    */
specifier|private
specifier|final
name|Map
argument_list|<
name|Integer
argument_list|,
name|Integer
argument_list|>
name|replacementMap
init|=
operator|new
name|HashMap
argument_list|<
name|Integer
argument_list|,
name|Integer
argument_list|>
argument_list|()
decl_stmt|;
comment|/**    * This set stores all the code points which needed to be deleted from the input string. The    * objects in deletionSet and keys in replacementMap are mutually exclusive    */
specifier|private
specifier|final
name|Set
argument_list|<
name|Integer
argument_list|>
name|deletionSet
init|=
operator|new
name|HashSet
argument_list|<
name|Integer
argument_list|>
argument_list|()
decl_stmt|;
comment|/**    * A placeholder for result.    */
specifier|private
specifier|final
name|Text
name|result
init|=
operator|new
name|Text
argument_list|()
decl_stmt|;
comment|/**    * The values of from parameter from the previous evaluate() call.    */
specifier|private
name|Text
name|lastFrom
init|=
literal|null
decl_stmt|;
comment|/**    * The values of to parameter from the previous evaluate() call.    */
specifier|private
name|Text
name|lastTo
init|=
literal|null
decl_stmt|;
comment|/**    * Converters for retrieving the arguments to the UDF.    */
specifier|private
specifier|transient
name|ObjectInspectorConverters
operator|.
name|Converter
index|[]
name|converters
decl_stmt|;
annotation|@
name|Override
specifier|public
name|ObjectInspector
name|initialize
parameter_list|(
name|ObjectInspector
index|[]
name|arguments
parameter_list|)
throws|throws
name|UDFArgumentException
block|{
if|if
condition|(
name|arguments
operator|.
name|length
operator|!=
literal|3
condition|)
block|{
throw|throw
operator|new
name|UDFArgumentLengthException
argument_list|(
literal|"_FUNC_ expects exactly 3 arguments"
argument_list|)
throw|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|arguments
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|arguments
index|[
name|i
index|]
operator|.
name|getCategory
argument_list|()
operator|!=
name|Category
operator|.
name|PRIMITIVE
condition|)
block|{
throw|throw
operator|new
name|UDFArgumentTypeException
argument_list|(
name|i
argument_list|,
literal|"A string argument was expected but an argument of type "
operator|+
name|arguments
index|[
name|i
index|]
operator|.
name|getTypeName
argument_list|()
operator|+
literal|" was given."
argument_list|)
throw|;
block|}
comment|// Now that we have made sure that the argument is of primitive type, we can get the primitive
comment|// category
name|PrimitiveCategory
name|primitiveCategory
init|=
operator|(
operator|(
name|PrimitiveObjectInspector
operator|)
name|arguments
index|[
name|i
index|]
operator|)
operator|.
name|getPrimitiveCategory
argument_list|()
decl_stmt|;
if|if
condition|(
name|primitiveCategory
operator|!=
name|PrimitiveCategory
operator|.
name|STRING
operator|&&
name|primitiveCategory
operator|!=
name|PrimitiveCategory
operator|.
name|CHAR
operator|&&
name|primitiveCategory
operator|!=
name|PrimitiveCategory
operator|.
name|VARCHAR
operator|&&
name|primitiveCategory
operator|!=
name|PrimitiveCategory
operator|.
name|VOID
condition|)
block|{
throw|throw
operator|new
name|UDFArgumentTypeException
argument_list|(
name|i
argument_list|,
literal|"A string, char, or varchar argument was expected but an argument of type "
operator|+
name|arguments
index|[
name|i
index|]
operator|.
name|getTypeName
argument_list|()
operator|+
literal|" was given."
argument_list|)
throw|;
block|}
block|}
name|converters
operator|=
operator|new
name|ObjectInspectorConverters
operator|.
name|Converter
index|[
name|arguments
operator|.
name|length
index|]
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|arguments
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|converters
index|[
name|i
index|]
operator|=
name|ObjectInspectorConverters
operator|.
name|getConverter
argument_list|(
name|arguments
index|[
name|i
index|]
argument_list|,
name|PrimitiveObjectInspectorFactory
operator|.
name|writableStringObjectInspector
argument_list|)
expr_stmt|;
block|}
comment|// We will be returning a Text object
return|return
name|PrimitiveObjectInspectorFactory
operator|.
name|writableStringObjectInspector
return|;
block|}
annotation|@
name|Override
specifier|public
name|Object
name|evaluate
parameter_list|(
name|DeferredObject
index|[]
name|arguments
parameter_list|)
throws|throws
name|HiveException
block|{
assert|assert
operator|(
name|arguments
operator|.
name|length
operator|==
literal|3
operator|)
assert|;
if|if
condition|(
name|arguments
index|[
literal|0
index|]
operator|.
name|get
argument_list|()
operator|==
literal|null
operator|||
name|arguments
index|[
literal|1
index|]
operator|.
name|get
argument_list|()
operator|==
literal|null
operator|||
name|arguments
index|[
literal|2
index|]
operator|.
name|get
argument_list|()
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
name|Text
name|input
init|=
operator|(
name|Text
operator|)
name|converters
index|[
literal|0
index|]
operator|.
name|convert
argument_list|(
name|arguments
index|[
literal|0
index|]
operator|.
name|get
argument_list|()
argument_list|)
decl_stmt|;
name|Text
name|from
init|=
operator|(
name|Text
operator|)
name|converters
index|[
literal|1
index|]
operator|.
name|convert
argument_list|(
name|arguments
index|[
literal|1
index|]
operator|.
name|get
argument_list|()
argument_list|)
decl_stmt|;
name|Text
name|to
init|=
operator|(
name|Text
operator|)
name|converters
index|[
literal|2
index|]
operator|.
name|convert
argument_list|(
name|arguments
index|[
literal|2
index|]
operator|.
name|get
argument_list|()
argument_list|)
decl_stmt|;
name|populateMappingsIfNecessary
argument_list|(
name|from
argument_list|,
name|to
argument_list|)
expr_stmt|;
name|String
name|resultString
init|=
name|processInput
argument_list|(
name|input
argument_list|)
decl_stmt|;
name|result
operator|.
name|set
argument_list|(
name|resultString
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
comment|/**    * Pre-processes the from and to strings by calling {@link #populateMappings(Text, Text)} if    * necessary.    *    * @param from    *          from string to be used for translation    * @param to    *          to string to be used for translation    */
specifier|private
name|void
name|populateMappingsIfNecessary
parameter_list|(
name|Text
name|from
parameter_list|,
name|Text
name|to
parameter_list|)
block|{
comment|// If the from and to strings haven't changed, we don't need to preprocess again to regenerate
comment|// the mappings of code points that need to replaced or deleted
if|if
condition|(
operator|(
name|lastFrom
operator|==
literal|null
operator|)
operator|||
operator|(
name|lastTo
operator|==
literal|null
operator|)
operator|||
operator|!
name|from
operator|.
name|equals
argument_list|(
name|lastFrom
argument_list|)
operator|||
operator|!
name|to
operator|.
name|equals
argument_list|(
name|lastTo
argument_list|)
condition|)
block|{
name|populateMappings
argument_list|(
name|from
argument_list|,
name|to
argument_list|)
expr_stmt|;
comment|// These are null when evaluate() is called for the first time
if|if
condition|(
name|lastFrom
operator|==
literal|null
condition|)
block|{
name|lastFrom
operator|=
operator|new
name|Text
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|lastTo
operator|==
literal|null
condition|)
block|{
name|lastTo
operator|=
operator|new
name|Text
argument_list|()
expr_stmt|;
block|}
comment|// Need to deep copy here since doing something like lastFrom = from instead, will make
comment|// lastFrom point to the same Text object which would make from.equals(lastFrom) always true
name|lastFrom
operator|.
name|set
argument_list|(
name|from
argument_list|)
expr_stmt|;
name|lastTo
operator|.
name|set
argument_list|(
name|to
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Pre-process the from and to strings populate {@link #replacementMap} and {@link #deletionSet}.    *    * @param from    *          from string to be used for translation    * @param to    *          to string to be used for translation    */
specifier|private
name|void
name|populateMappings
parameter_list|(
name|Text
name|from
parameter_list|,
name|Text
name|to
parameter_list|)
block|{
name|replacementMap
operator|.
name|clear
argument_list|()
expr_stmt|;
name|deletionSet
operator|.
name|clear
argument_list|()
expr_stmt|;
name|ByteBuffer
name|fromBytes
init|=
name|ByteBuffer
operator|.
name|wrap
argument_list|(
name|from
operator|.
name|getBytes
argument_list|()
argument_list|,
literal|0
argument_list|,
name|from
operator|.
name|getLength
argument_list|()
argument_list|)
decl_stmt|;
name|ByteBuffer
name|toBytes
init|=
name|ByteBuffer
operator|.
name|wrap
argument_list|(
name|to
operator|.
name|getBytes
argument_list|()
argument_list|,
literal|0
argument_list|,
name|to
operator|.
name|getLength
argument_list|()
argument_list|)
decl_stmt|;
comment|// Traverse through the from string, one code point at a time
while|while
condition|(
name|fromBytes
operator|.
name|hasRemaining
argument_list|()
condition|)
block|{
comment|// This will also move the iterator ahead by one code point
name|int
name|fromCodePoint
init|=
name|Text
operator|.
name|bytesToCodePoint
argument_list|(
name|fromBytes
argument_list|)
decl_stmt|;
comment|// If the to string has more code points, make sure to traverse it too
if|if
condition|(
name|toBytes
operator|.
name|hasRemaining
argument_list|()
condition|)
block|{
name|int
name|toCodePoint
init|=
name|Text
operator|.
name|bytesToCodePoint
argument_list|(
name|toBytes
argument_list|)
decl_stmt|;
comment|// If the code point from from string already has a replacement or is to be deleted, we
comment|// don't need to do anything, just move on to the next code point
if|if
condition|(
name|replacementMap
operator|.
name|containsKey
argument_list|(
name|fromCodePoint
argument_list|)
operator|||
name|deletionSet
operator|.
name|contains
argument_list|(
name|fromCodePoint
argument_list|)
condition|)
block|{
continue|continue;
block|}
name|replacementMap
operator|.
name|put
argument_list|(
name|fromCodePoint
argument_list|,
name|toCodePoint
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// If the code point from from string already has a replacement or is to be deleted, we
comment|// don't need to do anything, just move on to the next code point
if|if
condition|(
name|replacementMap
operator|.
name|containsKey
argument_list|(
name|fromCodePoint
argument_list|)
operator|||
name|deletionSet
operator|.
name|contains
argument_list|(
name|fromCodePoint
argument_list|)
condition|)
block|{
continue|continue;
block|}
name|deletionSet
operator|.
name|add
argument_list|(
name|fromCodePoint
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**    * Translates the input string based on {@link #replacementMap} and {@link #deletionSet} and    * returns the translated string.    *    * @param input    *          input string to perform the translation on    * @return translated string    */
specifier|private
name|String
name|processInput
parameter_list|(
name|Text
name|input
parameter_list|)
block|{
name|StringBuilder
name|resultBuilder
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
comment|// Obtain the byte buffer from the input string so we can traverse it code point by code point
name|ByteBuffer
name|inputBytes
init|=
name|ByteBuffer
operator|.
name|wrap
argument_list|(
name|input
operator|.
name|getBytes
argument_list|()
argument_list|,
literal|0
argument_list|,
name|input
operator|.
name|getLength
argument_list|()
argument_list|)
decl_stmt|;
comment|// Traverse the byte buffer containing the input string one code point at a time
while|while
condition|(
name|inputBytes
operator|.
name|hasRemaining
argument_list|()
condition|)
block|{
name|int
name|inputCodePoint
init|=
name|Text
operator|.
name|bytesToCodePoint
argument_list|(
name|inputBytes
argument_list|)
decl_stmt|;
comment|// If the code point exists in deletion set, no need to emit out anything for this code point.
comment|// Continue on to the next code point
if|if
condition|(
name|deletionSet
operator|.
name|contains
argument_list|(
name|inputCodePoint
argument_list|)
condition|)
block|{
continue|continue;
block|}
name|Integer
name|replacementCodePoint
init|=
name|replacementMap
operator|.
name|get
argument_list|(
name|inputCodePoint
argument_list|)
decl_stmt|;
comment|// If a replacement exists for this code point, emit out the replacement and append it to the
comment|// output string. If no such replacement exists, emit out the original input code point
name|char
index|[]
name|charArray
init|=
name|Character
operator|.
name|toChars
argument_list|(
operator|(
name|replacementCodePoint
operator|!=
literal|null
operator|)
condition|?
name|replacementCodePoint
else|:
name|inputCodePoint
argument_list|)
decl_stmt|;
name|resultBuilder
operator|.
name|append
argument_list|(
name|charArray
argument_list|)
expr_stmt|;
block|}
name|String
name|resultString
init|=
name|resultBuilder
operator|.
name|toString
argument_list|()
decl_stmt|;
return|return
name|resultString
return|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|getDisplayString
parameter_list|(
name|String
index|[]
name|children
parameter_list|)
block|{
assert|assert
operator|(
name|children
operator|.
name|length
operator|==
literal|3
operator|)
assert|;
return|return
name|getStandardDisplayString
argument_list|(
literal|"translate"
argument_list|,
name|children
argument_list|)
return|;
block|}
block|}
end_class

end_unit

