begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|optimizer
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|Serializable
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|LinkedHashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
operator|.
name|Entry
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Properties
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|Log
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|LogFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|Path
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|conf
operator|.
name|HiveConf
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|Context
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|ConditionalTask
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|DemuxOperator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|JoinOperator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|Operator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|OperatorFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|ReduceSinkOperator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|TableScanOperator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|Task
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|TaskFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|UnionOperator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|Utilities
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|mr
operator|.
name|ExecDriver
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|mr
operator|.
name|MapRedTask
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|hooks
operator|.
name|ReadEntity
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|metadata
operator|.
name|HiveException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|metadata
operator|.
name|Partition
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|optimizer
operator|.
name|GenMRProcContext
operator|.
name|GenMRUnionCtx
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|optimizer
operator|.
name|GenMRProcContext
operator|.
name|GenMapRedCtx
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|optimizer
operator|.
name|listbucketingpruner
operator|.
name|ListBucketingPruner
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|optimizer
operator|.
name|ppr
operator|.
name|PartitionPruner
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|parse
operator|.
name|OpParseContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|parse
operator|.
name|ParseContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|parse
operator|.
name|PrunedPartitionList
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|parse
operator|.
name|RowResolver
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|parse
operator|.
name|SemanticException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|ExprNodeDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|FetchWork
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|FileSinkDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|FilterDesc
operator|.
name|sampleDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|MapWork
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|MapredLocalWork
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|MapredWork
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|OperatorDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|PartitionDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|PlanUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|ReduceSinkDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|ReduceWork
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|TableDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|TableScanDesc
import|;
end_import

begin_comment
comment|/**  * General utility common functions for the Processor to convert operator into  * map-reduce tasks.  */
end_comment

begin_class
specifier|public
specifier|final
class|class
name|GenMapRedUtils
block|{
specifier|private
specifier|static
name|Log
name|LOG
decl_stmt|;
static|static
block|{
name|LOG
operator|=
name|LogFactory
operator|.
name|getLog
argument_list|(
literal|"org.apache.hadoop.hive.ql.optimizer.GenMapRedUtils"
argument_list|)
expr_stmt|;
block|}
specifier|private
specifier|static
name|boolean
name|needsTagging
parameter_list|(
name|ReduceWork
name|rWork
parameter_list|)
block|{
return|return
name|rWork
operator|!=
literal|null
operator|&&
operator|(
name|rWork
operator|.
name|getReducer
argument_list|()
operator|.
name|getClass
argument_list|()
operator|==
name|JoinOperator
operator|.
name|class
operator|||
name|rWork
operator|.
name|getReducer
argument_list|()
operator|.
name|getClass
argument_list|()
operator|==
name|DemuxOperator
operator|.
name|class
operator|)
return|;
block|}
comment|/**    * Initialize the current plan by adding it to root tasks.    *    * @param op    *          the reduce sink operator encountered    * @param opProcCtx    *          processing context    */
specifier|public
specifier|static
name|void
name|initPlan
parameter_list|(
name|ReduceSinkOperator
name|op
parameter_list|,
name|GenMRProcContext
name|opProcCtx
parameter_list|)
throws|throws
name|SemanticException
block|{
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
name|reducer
init|=
name|op
operator|.
name|getChildOperators
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|Map
argument_list|<
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
argument_list|,
name|GenMapRedCtx
argument_list|>
name|mapCurrCtx
init|=
name|opProcCtx
operator|.
name|getMapCurrCtx
argument_list|()
decl_stmt|;
name|GenMapRedCtx
name|mapredCtx
init|=
name|mapCurrCtx
operator|.
name|get
argument_list|(
name|op
operator|.
name|getParentOperators
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|Task
argument_list|<
name|?
extends|extends
name|Serializable
argument_list|>
name|currTask
init|=
name|mapredCtx
operator|.
name|getCurrTask
argument_list|()
decl_stmt|;
name|MapredWork
name|plan
init|=
operator|(
name|MapredWork
operator|)
name|currTask
operator|.
name|getWork
argument_list|()
decl_stmt|;
name|HashMap
argument_list|<
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
argument_list|,
name|Task
argument_list|<
name|?
extends|extends
name|Serializable
argument_list|>
argument_list|>
name|opTaskMap
init|=
name|opProcCtx
operator|.
name|getOpTaskMap
argument_list|()
decl_stmt|;
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
name|currTopOp
init|=
name|opProcCtx
operator|.
name|getCurrTopOp
argument_list|()
decl_stmt|;
name|opTaskMap
operator|.
name|put
argument_list|(
name|reducer
argument_list|,
name|currTask
argument_list|)
expr_stmt|;
name|plan
operator|.
name|setReduceWork
argument_list|(
operator|new
name|ReduceWork
argument_list|()
argument_list|)
expr_stmt|;
name|plan
operator|.
name|getReduceWork
argument_list|()
operator|.
name|setReducer
argument_list|(
name|reducer
argument_list|)
expr_stmt|;
name|ReduceSinkDesc
name|desc
init|=
name|op
operator|.
name|getConf
argument_list|()
decl_stmt|;
name|plan
operator|.
name|getReduceWork
argument_list|()
operator|.
name|setNumReduceTasks
argument_list|(
name|desc
operator|.
name|getNumReducers
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|needsTagging
argument_list|(
name|plan
operator|.
name|getReduceWork
argument_list|()
argument_list|)
condition|)
block|{
name|plan
operator|.
name|getReduceWork
argument_list|()
operator|.
name|setNeedsTagging
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
assert|assert
name|currTopOp
operator|!=
literal|null
assert|;
name|String
name|currAliasId
init|=
name|opProcCtx
operator|.
name|getCurrAliasId
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|opProcCtx
operator|.
name|isSeenOp
argument_list|(
name|currTask
argument_list|,
name|currTopOp
argument_list|)
condition|)
block|{
name|setTaskPlan
argument_list|(
name|currAliasId
argument_list|,
name|currTopOp
argument_list|,
name|currTask
argument_list|,
literal|false
argument_list|,
name|opProcCtx
argument_list|)
expr_stmt|;
block|}
name|currTopOp
operator|=
literal|null
expr_stmt|;
name|currAliasId
operator|=
literal|null
expr_stmt|;
name|opProcCtx
operator|.
name|setCurrTask
argument_list|(
name|currTask
argument_list|)
expr_stmt|;
name|opProcCtx
operator|.
name|setCurrTopOp
argument_list|(
name|currTopOp
argument_list|)
expr_stmt|;
name|opProcCtx
operator|.
name|setCurrAliasId
argument_list|(
name|currAliasId
argument_list|)
expr_stmt|;
block|}
comment|/**    * Initialize the current union plan.    *    * @param op    *          the reduce sink operator encountered    * @param opProcCtx    *          processing context    */
specifier|public
specifier|static
name|void
name|initUnionPlan
parameter_list|(
name|ReduceSinkOperator
name|op
parameter_list|,
name|UnionOperator
name|currUnionOp
parameter_list|,
name|GenMRProcContext
name|opProcCtx
parameter_list|,
name|Task
argument_list|<
name|?
extends|extends
name|Serializable
argument_list|>
name|unionTask
parameter_list|)
throws|throws
name|SemanticException
block|{
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
name|reducer
init|=
name|op
operator|.
name|getChildOperators
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|MapredWork
name|plan
init|=
operator|(
name|MapredWork
operator|)
name|unionTask
operator|.
name|getWork
argument_list|()
decl_stmt|;
name|HashMap
argument_list|<
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
argument_list|,
name|Task
argument_list|<
name|?
extends|extends
name|Serializable
argument_list|>
argument_list|>
name|opTaskMap
init|=
name|opProcCtx
operator|.
name|getOpTaskMap
argument_list|()
decl_stmt|;
name|opTaskMap
operator|.
name|put
argument_list|(
name|reducer
argument_list|,
name|unionTask
argument_list|)
expr_stmt|;
name|plan
operator|.
name|setReduceWork
argument_list|(
operator|new
name|ReduceWork
argument_list|()
argument_list|)
expr_stmt|;
name|plan
operator|.
name|getReduceWork
argument_list|()
operator|.
name|setReducer
argument_list|(
name|reducer
argument_list|)
expr_stmt|;
name|plan
operator|.
name|getReduceWork
argument_list|()
operator|.
name|setReducer
argument_list|(
name|reducer
argument_list|)
expr_stmt|;
name|ReduceSinkDesc
name|desc
init|=
name|op
operator|.
name|getConf
argument_list|()
decl_stmt|;
name|plan
operator|.
name|getReduceWork
argument_list|()
operator|.
name|setNumReduceTasks
argument_list|(
name|desc
operator|.
name|getNumReducers
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|needsTagging
argument_list|(
name|plan
operator|.
name|getReduceWork
argument_list|()
argument_list|)
condition|)
block|{
name|plan
operator|.
name|getReduceWork
argument_list|()
operator|.
name|setNeedsTagging
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
name|initUnionPlan
argument_list|(
name|opProcCtx
argument_list|,
name|currUnionOp
argument_list|,
name|unionTask
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
specifier|private
specifier|static
name|void
name|setUnionPlan
parameter_list|(
name|GenMRProcContext
name|opProcCtx
parameter_list|,
name|boolean
name|local
parameter_list|,
name|Task
argument_list|<
name|?
extends|extends
name|Serializable
argument_list|>
name|currTask
parameter_list|,
name|GenMRUnionCtx
name|uCtx
parameter_list|,
name|boolean
name|mergeTask
parameter_list|)
throws|throws
name|SemanticException
block|{
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
name|currTopOp
init|=
name|opProcCtx
operator|.
name|getCurrTopOp
argument_list|()
decl_stmt|;
if|if
condition|(
name|currTopOp
operator|!=
literal|null
condition|)
block|{
name|String
name|currAliasId
init|=
name|opProcCtx
operator|.
name|getCurrAliasId
argument_list|()
decl_stmt|;
if|if
condition|(
name|mergeTask
operator|||
operator|!
name|opProcCtx
operator|.
name|isSeenOp
argument_list|(
name|currTask
argument_list|,
name|currTopOp
argument_list|)
condition|)
block|{
name|setTaskPlan
argument_list|(
name|currAliasId
argument_list|,
name|currTopOp
argument_list|,
name|currTask
argument_list|,
name|local
argument_list|,
name|opProcCtx
argument_list|)
expr_stmt|;
block|}
name|currTopOp
operator|=
literal|null
expr_stmt|;
name|opProcCtx
operator|.
name|setCurrTopOp
argument_list|(
name|currTopOp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|List
argument_list|<
name|String
argument_list|>
name|taskTmpDirLst
init|=
name|uCtx
operator|.
name|getTaskTmpDir
argument_list|()
decl_stmt|;
if|if
condition|(
operator|(
name|taskTmpDirLst
operator|!=
literal|null
operator|)
operator|&&
operator|!
operator|(
name|taskTmpDirLst
operator|.
name|isEmpty
argument_list|()
operator|)
condition|)
block|{
name|List
argument_list|<
name|TableDesc
argument_list|>
name|tt_descLst
init|=
name|uCtx
operator|.
name|getTTDesc
argument_list|()
decl_stmt|;
assert|assert
operator|!
name|taskTmpDirLst
operator|.
name|isEmpty
argument_list|()
operator|&&
operator|!
name|tt_descLst
operator|.
name|isEmpty
argument_list|()
assert|;
assert|assert
name|taskTmpDirLst
operator|.
name|size
argument_list|()
operator|==
name|tt_descLst
operator|.
name|size
argument_list|()
assert|;
name|int
name|size
init|=
name|taskTmpDirLst
operator|.
name|size
argument_list|()
decl_stmt|;
assert|assert
name|local
operator|==
literal|false
assert|;
name|List
argument_list|<
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
argument_list|>
name|topOperators
init|=
name|uCtx
operator|.
name|getListTopOperators
argument_list|()
decl_stmt|;
name|MapredWork
name|plan
init|=
operator|(
name|MapredWork
operator|)
name|currTask
operator|.
name|getWork
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|pos
init|=
literal|0
init|;
name|pos
operator|<
name|size
condition|;
name|pos
operator|++
control|)
block|{
name|String
name|taskTmpDir
init|=
name|taskTmpDirLst
operator|.
name|get
argument_list|(
name|pos
argument_list|)
decl_stmt|;
name|TableDesc
name|tt_desc
init|=
name|tt_descLst
operator|.
name|get
argument_list|(
name|pos
argument_list|)
decl_stmt|;
name|MapWork
name|mWork
init|=
name|plan
operator|.
name|getMapWork
argument_list|()
decl_stmt|;
if|if
condition|(
name|mWork
operator|.
name|getPathToAliases
argument_list|()
operator|.
name|get
argument_list|(
name|taskTmpDir
argument_list|)
operator|==
literal|null
condition|)
block|{
name|mWork
operator|.
name|getPathToAliases
argument_list|()
operator|.
name|put
argument_list|(
name|taskTmpDir
argument_list|,
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
argument_list|)
expr_stmt|;
name|mWork
operator|.
name|getPathToAliases
argument_list|()
operator|.
name|get
argument_list|(
name|taskTmpDir
argument_list|)
operator|.
name|add
argument_list|(
name|taskTmpDir
argument_list|)
expr_stmt|;
name|mWork
operator|.
name|getPathToPartitionInfo
argument_list|()
operator|.
name|put
argument_list|(
name|taskTmpDir
argument_list|,
operator|new
name|PartitionDesc
argument_list|(
name|tt_desc
argument_list|,
literal|null
argument_list|)
argument_list|)
expr_stmt|;
name|mWork
operator|.
name|getAliasToWork
argument_list|()
operator|.
name|put
argument_list|(
name|taskTmpDir
argument_list|,
name|topOperators
operator|.
name|get
argument_list|(
name|pos
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
comment|/*    * It is a idempotent function to add various intermediate files as the source    * for the union. The plan has already been created.    */
specifier|public
specifier|static
name|void
name|initUnionPlan
parameter_list|(
name|GenMRProcContext
name|opProcCtx
parameter_list|,
name|UnionOperator
name|currUnionOp
parameter_list|,
name|Task
argument_list|<
name|?
extends|extends
name|Serializable
argument_list|>
name|currTask
parameter_list|,
name|boolean
name|local
parameter_list|)
throws|throws
name|SemanticException
block|{
comment|// In case of lateral views followed by a join, the same tree
comment|// can be traversed more than one
if|if
condition|(
name|currUnionOp
operator|!=
literal|null
condition|)
block|{
name|GenMRUnionCtx
name|uCtx
init|=
name|opProcCtx
operator|.
name|getUnionTask
argument_list|(
name|currUnionOp
argument_list|)
decl_stmt|;
assert|assert
name|uCtx
operator|!=
literal|null
assert|;
name|setUnionPlan
argument_list|(
name|opProcCtx
argument_list|,
name|local
argument_list|,
name|currTask
argument_list|,
name|uCtx
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
block|}
comment|/*    * join current union task to old task    */
specifier|public
specifier|static
name|void
name|joinUnionPlan
parameter_list|(
name|GenMRProcContext
name|opProcCtx
parameter_list|,
name|UnionOperator
name|currUnionOp
parameter_list|,
name|Task
argument_list|<
name|?
extends|extends
name|Serializable
argument_list|>
name|currentUnionTask
parameter_list|,
name|Task
argument_list|<
name|?
extends|extends
name|Serializable
argument_list|>
name|existingTask
parameter_list|,
name|boolean
name|local
parameter_list|)
throws|throws
name|SemanticException
block|{
assert|assert
name|currUnionOp
operator|!=
literal|null
assert|;
name|GenMRUnionCtx
name|uCtx
init|=
name|opProcCtx
operator|.
name|getUnionTask
argument_list|(
name|currUnionOp
argument_list|)
decl_stmt|;
assert|assert
name|uCtx
operator|!=
literal|null
assert|;
name|setUnionPlan
argument_list|(
name|opProcCtx
argument_list|,
name|local
argument_list|,
name|existingTask
argument_list|,
name|uCtx
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|Task
argument_list|<
name|?
extends|extends
name|Serializable
argument_list|>
argument_list|>
name|parTasks
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|opProcCtx
operator|.
name|getRootTasks
argument_list|()
operator|.
name|contains
argument_list|(
name|currentUnionTask
argument_list|)
condition|)
block|{
name|opProcCtx
operator|.
name|getRootTasks
argument_list|()
operator|.
name|remove
argument_list|(
name|currentUnionTask
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|opProcCtx
operator|.
name|getRootTasks
argument_list|()
operator|.
name|contains
argument_list|(
name|existingTask
argument_list|)
operator|&&
operator|(
name|existingTask
operator|.
name|getParentTasks
argument_list|()
operator|==
literal|null
operator|||
name|existingTask
operator|.
name|getParentTasks
argument_list|()
operator|.
name|isEmpty
argument_list|()
operator|)
condition|)
block|{
name|opProcCtx
operator|.
name|getRootTasks
argument_list|()
operator|.
name|add
argument_list|(
name|existingTask
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|currentUnionTask
operator|!=
literal|null
operator|)
operator|&&
operator|(
name|currentUnionTask
operator|.
name|getParentTasks
argument_list|()
operator|!=
literal|null
operator|)
operator|&&
operator|!
name|currentUnionTask
operator|.
name|getParentTasks
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|parTasks
operator|=
operator|new
name|ArrayList
argument_list|<
name|Task
argument_list|<
name|?
extends|extends
name|Serializable
argument_list|>
argument_list|>
argument_list|()
expr_stmt|;
name|parTasks
operator|.
name|addAll
argument_list|(
name|currentUnionTask
operator|.
name|getParentTasks
argument_list|()
argument_list|)
expr_stmt|;
name|Object
index|[]
name|parTaskArr
init|=
name|parTasks
operator|.
name|toArray
argument_list|()
decl_stmt|;
for|for
control|(
name|Object
name|parTask
range|:
name|parTaskArr
control|)
block|{
operator|(
operator|(
name|Task
argument_list|<
name|?
extends|extends
name|Serializable
argument_list|>
operator|)
name|parTask
operator|)
operator|.
name|removeDependentTask
argument_list|(
name|currentUnionTask
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|currentUnionTask
operator|!=
literal|null
operator|)
operator|&&
operator|(
name|parTasks
operator|!=
literal|null
operator|)
condition|)
block|{
for|for
control|(
name|Task
argument_list|<
name|?
extends|extends
name|Serializable
argument_list|>
name|parTask
range|:
name|parTasks
control|)
block|{
name|parTask
operator|.
name|addDependentTask
argument_list|(
name|existingTask
argument_list|)
expr_stmt|;
if|if
condition|(
name|opProcCtx
operator|.
name|getRootTasks
argument_list|()
operator|.
name|contains
argument_list|(
name|existingTask
argument_list|)
condition|)
block|{
name|opProcCtx
operator|.
name|getRootTasks
argument_list|()
operator|.
name|remove
argument_list|(
name|existingTask
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|opProcCtx
operator|.
name|setCurrTask
argument_list|(
name|existingTask
argument_list|)
expr_stmt|;
block|}
comment|/**    * Merge the current task into the old task for the reducer    *    * @param currTask    *          the current task for the current reducer    * @param oldTask    *          the old task for the current reducer    * @param opProcCtx    *          processing context    */
specifier|public
specifier|static
name|void
name|joinPlan
parameter_list|(
name|Task
argument_list|<
name|?
extends|extends
name|Serializable
argument_list|>
name|currTask
parameter_list|,
name|Task
argument_list|<
name|?
extends|extends
name|Serializable
argument_list|>
name|oldTask
parameter_list|,
name|GenMRProcContext
name|opProcCtx
parameter_list|)
throws|throws
name|SemanticException
block|{
assert|assert
name|currTask
operator|!=
literal|null
operator|&&
name|oldTask
operator|!=
literal|null
assert|;
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
name|currTopOp
init|=
name|opProcCtx
operator|.
name|getCurrTopOp
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|Task
argument_list|<
name|?
extends|extends
name|Serializable
argument_list|>
argument_list|>
name|parTasks
init|=
literal|null
decl_stmt|;
comment|// terminate the old task and make current task dependent on it
if|if
condition|(
name|currTask
operator|.
name|getParentTasks
argument_list|()
operator|!=
literal|null
operator|&&
operator|!
name|currTask
operator|.
name|getParentTasks
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|parTasks
operator|=
operator|new
name|ArrayList
argument_list|<
name|Task
argument_list|<
name|?
extends|extends
name|Serializable
argument_list|>
argument_list|>
argument_list|()
expr_stmt|;
name|parTasks
operator|.
name|addAll
argument_list|(
name|currTask
operator|.
name|getParentTasks
argument_list|()
argument_list|)
expr_stmt|;
name|Object
index|[]
name|parTaskArr
init|=
name|parTasks
operator|.
name|toArray
argument_list|()
decl_stmt|;
for|for
control|(
name|Object
name|element
range|:
name|parTaskArr
control|)
block|{
operator|(
operator|(
name|Task
argument_list|<
name|?
extends|extends
name|Serializable
argument_list|>
operator|)
name|element
operator|)
operator|.
name|removeDependentTask
argument_list|(
name|currTask
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|currTopOp
operator|!=
literal|null
condition|)
block|{
name|mergeInput
argument_list|(
name|currTopOp
argument_list|,
name|opProcCtx
argument_list|,
name|oldTask
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|parTasks
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|Task
argument_list|<
name|?
extends|extends
name|Serializable
argument_list|>
name|parTask
range|:
name|parTasks
control|)
block|{
name|parTask
operator|.
name|addDependentTask
argument_list|(
name|oldTask
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|oldTask
operator|instanceof
name|MapRedTask
operator|&&
name|currTask
operator|instanceof
name|MapRedTask
condition|)
block|{
operator|(
operator|(
name|MapRedTask
operator|)
name|currTask
operator|)
operator|.
name|getWork
argument_list|()
operator|.
name|getMapWork
argument_list|()
operator|.
name|mergingInto
argument_list|(
operator|(
operator|(
name|MapRedTask
operator|)
name|oldTask
operator|)
operator|.
name|getWork
argument_list|()
operator|.
name|getMapWork
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|opProcCtx
operator|.
name|setCurrTopOp
argument_list|(
literal|null
argument_list|)
expr_stmt|;
name|opProcCtx
operator|.
name|setCurrTask
argument_list|(
name|oldTask
argument_list|)
expr_stmt|;
block|}
comment|/**    * If currTopOp is not set for input of the task, add input for to the task    */
specifier|static
name|boolean
name|mergeInput
parameter_list|(
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
name|currTopOp
parameter_list|,
name|GenMRProcContext
name|opProcCtx
parameter_list|,
name|Task
argument_list|<
name|?
extends|extends
name|Serializable
argument_list|>
name|task
parameter_list|,
name|boolean
name|local
parameter_list|)
throws|throws
name|SemanticException
block|{
if|if
condition|(
operator|!
name|opProcCtx
operator|.
name|isSeenOp
argument_list|(
name|task
argument_list|,
name|currTopOp
argument_list|)
condition|)
block|{
name|String
name|currAliasId
init|=
name|opProcCtx
operator|.
name|getCurrAliasId
argument_list|()
decl_stmt|;
name|setTaskPlan
argument_list|(
name|currAliasId
argument_list|,
name|currTopOp
argument_list|,
name|task
argument_list|,
name|local
argument_list|,
name|opProcCtx
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
comment|/**    * Met cRS in pRS(parentTask)-cRS-OP(childTask) case    * Split and link two tasks by temporary file : pRS-FS / TS-cRS-OP    */
specifier|static
name|void
name|splitPlan
parameter_list|(
name|ReduceSinkOperator
name|cRS
parameter_list|,
name|Task
argument_list|<
name|?
extends|extends
name|Serializable
argument_list|>
name|parentTask
parameter_list|,
name|Task
argument_list|<
name|?
extends|extends
name|Serializable
argument_list|>
name|childTask
parameter_list|,
name|GenMRProcContext
name|opProcCtx
parameter_list|)
throws|throws
name|SemanticException
block|{
assert|assert
name|parentTask
operator|!=
literal|null
operator|&&
name|childTask
operator|!=
literal|null
assert|;
name|splitTasks
argument_list|(
name|cRS
argument_list|,
name|parentTask
argument_list|,
name|childTask
argument_list|,
name|opProcCtx
argument_list|)
expr_stmt|;
block|}
comment|/**    * Met cRS in pOP(parentTask with RS)-cRS-cOP(noTask) case    * Create new child task for cRS-cOP and link two tasks by temporary file : pOP-FS / TS-cRS-cOP    *    * @param cRS    *          the reduce sink operator encountered    * @param opProcCtx    *          processing context    */
specifier|static
name|void
name|splitPlan
parameter_list|(
name|ReduceSinkOperator
name|cRS
parameter_list|,
name|GenMRProcContext
name|opProcCtx
parameter_list|)
throws|throws
name|SemanticException
block|{
comment|// Generate a new task
name|ParseContext
name|parseCtx
init|=
name|opProcCtx
operator|.
name|getParseCtx
argument_list|()
decl_stmt|;
name|Task
argument_list|<
name|?
extends|extends
name|Serializable
argument_list|>
name|parentTask
init|=
name|opProcCtx
operator|.
name|getCurrTask
argument_list|()
decl_stmt|;
name|MapredWork
name|childPlan
init|=
name|getMapRedWork
argument_list|(
name|parseCtx
argument_list|)
decl_stmt|;
name|Task
argument_list|<
name|?
extends|extends
name|Serializable
argument_list|>
name|childTask
init|=
name|TaskFactory
operator|.
name|get
argument_list|(
name|childPlan
argument_list|,
name|parseCtx
operator|.
name|getConf
argument_list|()
argument_list|)
decl_stmt|;
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
name|reducer
init|=
name|cRS
operator|.
name|getChildOperators
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
comment|// Add the reducer
name|ReduceWork
name|rWork
init|=
operator|new
name|ReduceWork
argument_list|()
decl_stmt|;
name|childPlan
operator|.
name|setReduceWork
argument_list|(
name|rWork
argument_list|)
expr_stmt|;
name|rWork
operator|.
name|setReducer
argument_list|(
name|reducer
argument_list|)
expr_stmt|;
name|ReduceSinkDesc
name|desc
init|=
name|cRS
operator|.
name|getConf
argument_list|()
decl_stmt|;
name|childPlan
operator|.
name|getReduceWork
argument_list|()
operator|.
name|setNumReduceTasks
argument_list|(
operator|new
name|Integer
argument_list|(
name|desc
operator|.
name|getNumReducers
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|opProcCtx
operator|.
name|getOpTaskMap
argument_list|()
operator|.
name|put
argument_list|(
name|reducer
argument_list|,
name|childTask
argument_list|)
expr_stmt|;
name|splitTasks
argument_list|(
name|cRS
argument_list|,
name|parentTask
argument_list|,
name|childTask
argument_list|,
name|opProcCtx
argument_list|)
expr_stmt|;
block|}
comment|/**    * set the current task in the mapredWork.    *    * @param alias_id    *          current alias    * @param topOp    *          the top operator of the stack    * @param plan    *          current plan    * @param local    *          whether you need to add to map-reduce or local work    * @param opProcCtx    *          processing context    */
specifier|public
specifier|static
name|void
name|setTaskPlan
parameter_list|(
name|String
name|alias_id
parameter_list|,
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
name|topOp
parameter_list|,
name|Task
argument_list|<
name|?
argument_list|>
name|task
parameter_list|,
name|boolean
name|local
parameter_list|,
name|GenMRProcContext
name|opProcCtx
parameter_list|)
throws|throws
name|SemanticException
block|{
name|setTaskPlan
argument_list|(
name|alias_id
argument_list|,
name|topOp
argument_list|,
name|task
argument_list|,
name|local
argument_list|,
name|opProcCtx
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
specifier|private
specifier|static
name|ReadEntity
name|getParentViewInfo
parameter_list|(
name|String
name|alias_id
parameter_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|ReadEntity
argument_list|>
name|viewAliasToInput
parameter_list|)
block|{
name|String
index|[]
name|aliases
init|=
name|alias_id
operator|.
name|split
argument_list|(
literal|":"
argument_list|)
decl_stmt|;
name|String
name|currentAlias
init|=
literal|null
decl_stmt|;
name|ReadEntity
name|currentInput
init|=
literal|null
decl_stmt|;
comment|// Find the immediate parent possible.
comment|// For eg: for a query like 'select * from V3', where V3 -> V2, V2 -> V1, V1 -> T
comment|// -> implies depends on.
comment|// T's parent would be V1
for|for
control|(
name|int
name|pos
init|=
literal|0
init|;
name|pos
operator|<
name|aliases
operator|.
name|length
condition|;
name|pos
operator|++
control|)
block|{
name|currentAlias
operator|=
name|currentAlias
operator|==
literal|null
condition|?
name|aliases
index|[
name|pos
index|]
else|:
name|currentAlias
operator|+
literal|":"
operator|+
name|aliases
index|[
name|pos
index|]
expr_stmt|;
name|ReadEntity
name|input
init|=
name|viewAliasToInput
operator|.
name|get
argument_list|(
name|currentAlias
argument_list|)
decl_stmt|;
if|if
condition|(
name|input
operator|==
literal|null
condition|)
block|{
return|return
name|currentInput
return|;
block|}
name|currentInput
operator|=
name|input
expr_stmt|;
block|}
return|return
name|currentInput
return|;
block|}
comment|/**    * set the current task in the mapredWork.    *    * @param alias_id    *          current alias    * @param topOp    *          the top operator of the stack    * @param plan    *          current plan    * @param local    *          whether you need to add to map-reduce or local work    * @param opProcCtx    *          processing context    * @param pList    *          pruned partition list. If it is null it will be computed on-the-fly.    */
specifier|public
specifier|static
name|void
name|setTaskPlan
parameter_list|(
name|String
name|alias_id
parameter_list|,
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
name|topOp
parameter_list|,
name|Task
argument_list|<
name|?
argument_list|>
name|task
parameter_list|,
name|boolean
name|local
parameter_list|,
name|GenMRProcContext
name|opProcCtx
parameter_list|,
name|PrunedPartitionList
name|pList
parameter_list|)
throws|throws
name|SemanticException
block|{
name|MapWork
name|plan
init|=
operator|(
operator|(
name|MapredWork
operator|)
name|task
operator|.
name|getWork
argument_list|()
operator|)
operator|.
name|getMapWork
argument_list|()
decl_stmt|;
name|ParseContext
name|parseCtx
init|=
name|opProcCtx
operator|.
name|getParseCtx
argument_list|()
decl_stmt|;
name|Set
argument_list|<
name|ReadEntity
argument_list|>
name|inputs
init|=
name|opProcCtx
operator|.
name|getInputs
argument_list|()
decl_stmt|;
name|ArrayList
argument_list|<
name|Path
argument_list|>
name|partDir
init|=
operator|new
name|ArrayList
argument_list|<
name|Path
argument_list|>
argument_list|()
decl_stmt|;
name|ArrayList
argument_list|<
name|PartitionDesc
argument_list|>
name|partDesc
init|=
operator|new
name|ArrayList
argument_list|<
name|PartitionDesc
argument_list|>
argument_list|()
decl_stmt|;
name|Path
name|tblDir
init|=
literal|null
decl_stmt|;
name|TableDesc
name|tblDesc
init|=
literal|null
decl_stmt|;
name|PrunedPartitionList
name|partsList
init|=
name|pList
decl_stmt|;
name|plan
operator|.
name|setNameToSplitSample
argument_list|(
name|parseCtx
operator|.
name|getNameToSplitSample
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|partsList
operator|==
literal|null
condition|)
block|{
try|try
block|{
name|partsList
operator|=
name|parseCtx
operator|.
name|getOpToPartList
argument_list|()
operator|.
name|get
argument_list|(
operator|(
name|TableScanOperator
operator|)
name|topOp
argument_list|)
expr_stmt|;
if|if
condition|(
name|partsList
operator|==
literal|null
condition|)
block|{
name|partsList
operator|=
name|PartitionPruner
operator|.
name|prune
argument_list|(
name|parseCtx
operator|.
name|getTopToTable
argument_list|()
operator|.
name|get
argument_list|(
name|topOp
argument_list|)
argument_list|,
name|parseCtx
operator|.
name|getOpToPartPruner
argument_list|()
operator|.
name|get
argument_list|(
name|topOp
argument_list|)
argument_list|,
name|opProcCtx
operator|.
name|getConf
argument_list|()
argument_list|,
name|alias_id
argument_list|,
name|parseCtx
operator|.
name|getPrunedPartitions
argument_list|()
argument_list|)
expr_stmt|;
name|parseCtx
operator|.
name|getOpToPartList
argument_list|()
operator|.
name|put
argument_list|(
operator|(
name|TableScanOperator
operator|)
name|topOp
argument_list|,
name|partsList
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|SemanticException
name|e
parameter_list|)
block|{
throw|throw
name|e
throw|;
block|}
catch|catch
parameter_list|(
name|HiveException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|StringUtils
operator|.
name|stringifyException
argument_list|(
name|e
argument_list|)
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|SemanticException
argument_list|(
name|e
operator|.
name|getMessage
argument_list|()
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
comment|// Generate the map work for this alias_id
name|Set
argument_list|<
name|Partition
argument_list|>
name|parts
init|=
literal|null
decl_stmt|;
comment|// pass both confirmed and unknown partitions through the map-reduce
comment|// framework
name|parts
operator|=
name|partsList
operator|.
name|getConfirmedPartns
argument_list|()
expr_stmt|;
name|parts
operator|.
name|addAll
argument_list|(
name|partsList
operator|.
name|getUnknownPartns
argument_list|()
argument_list|)
expr_stmt|;
name|PartitionDesc
name|aliasPartnDesc
init|=
literal|null
decl_stmt|;
try|try
block|{
if|if
condition|(
operator|!
name|parts
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|aliasPartnDesc
operator|=
name|Utilities
operator|.
name|getPartitionDesc
argument_list|(
name|parts
operator|.
name|iterator
argument_list|()
operator|.
name|next
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|HiveException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|StringUtils
operator|.
name|stringifyException
argument_list|(
name|e
argument_list|)
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|SemanticException
argument_list|(
name|e
operator|.
name|getMessage
argument_list|()
argument_list|,
name|e
argument_list|)
throw|;
block|}
comment|// The table does not have any partitions
if|if
condition|(
name|aliasPartnDesc
operator|==
literal|null
condition|)
block|{
name|aliasPartnDesc
operator|=
operator|new
name|PartitionDesc
argument_list|(
name|Utilities
operator|.
name|getTableDesc
argument_list|(
name|parseCtx
operator|.
name|getTopToTable
argument_list|()
operator|.
name|get
argument_list|(
name|topOp
argument_list|)
argument_list|)
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|props
init|=
name|parseCtx
operator|.
name|getTopToProps
argument_list|()
operator|.
name|get
argument_list|(
name|topOp
argument_list|)
decl_stmt|;
if|if
condition|(
name|props
operator|!=
literal|null
condition|)
block|{
name|Properties
name|target
init|=
name|aliasPartnDesc
operator|.
name|getProperties
argument_list|()
decl_stmt|;
if|if
condition|(
name|target
operator|==
literal|null
condition|)
block|{
name|aliasPartnDesc
operator|.
name|setProperties
argument_list|(
name|target
operator|=
operator|new
name|Properties
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|target
operator|.
name|putAll
argument_list|(
name|props
argument_list|)
expr_stmt|;
block|}
name|plan
operator|.
name|getAliasToPartnInfo
argument_list|()
operator|.
name|put
argument_list|(
name|alias_id
argument_list|,
name|aliasPartnDesc
argument_list|)
expr_stmt|;
name|long
name|sizeNeeded
init|=
name|Integer
operator|.
name|MAX_VALUE
decl_stmt|;
name|int
name|fileLimit
init|=
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|parseCtx
operator|.
name|getGlobalLimitCtx
argument_list|()
operator|.
name|isEnable
argument_list|()
condition|)
block|{
name|long
name|sizePerRow
init|=
name|HiveConf
operator|.
name|getLongVar
argument_list|(
name|parseCtx
operator|.
name|getConf
argument_list|()
argument_list|,
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVELIMITMAXROWSIZE
argument_list|)
decl_stmt|;
name|sizeNeeded
operator|=
name|parseCtx
operator|.
name|getGlobalLimitCtx
argument_list|()
operator|.
name|getGlobalLimit
argument_list|()
operator|*
name|sizePerRow
expr_stmt|;
comment|// for the optimization that reduce number of input file, we limit number
comment|// of files allowed. If more than specific number of files have to be
comment|// selected, we skip this optimization. Since having too many files as
comment|// inputs can cause unpredictable latency. It's not necessarily to be
comment|// cheaper.
name|fileLimit
operator|=
name|HiveConf
operator|.
name|getIntVar
argument_list|(
name|parseCtx
operator|.
name|getConf
argument_list|()
argument_list|,
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVELIMITOPTLIMITFILE
argument_list|)
expr_stmt|;
if|if
condition|(
name|sizePerRow
operator|<=
literal|0
operator|||
name|fileLimit
operator|<=
literal|0
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Skip optimization to reduce input size of 'limit'"
argument_list|)
expr_stmt|;
name|parseCtx
operator|.
name|getGlobalLimitCtx
argument_list|()
operator|.
name|disableOpt
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|parts
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Empty input: skip limit optimiztion"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Try to reduce input size for 'limit' "
operator|+
literal|"sizeNeeded: "
operator|+
name|sizeNeeded
operator|+
literal|"  file limit : "
operator|+
name|fileLimit
argument_list|)
expr_stmt|;
block|}
block|}
name|boolean
name|isFirstPart
init|=
literal|true
decl_stmt|;
name|boolean
name|emptyInput
init|=
literal|true
decl_stmt|;
name|boolean
name|singlePartition
init|=
operator|(
name|parts
operator|.
name|size
argument_list|()
operator|==
literal|1
operator|)
decl_stmt|;
comment|// Track the dependencies for the view. Consider a query like: select * from V;
comment|// where V is a view of the form: select * from T
comment|// The dependencies should include V at depth 0, and T at depth 1 (inferred).
name|ReadEntity
name|parentViewInfo
init|=
name|getParentViewInfo
argument_list|(
name|alias_id
argument_list|,
name|parseCtx
operator|.
name|getViewAliasToInput
argument_list|()
argument_list|)
decl_stmt|;
comment|// The table should also be considered a part of inputs, even if the table is a
comment|// partitioned table and whether any partition is selected or not
name|PlanUtils
operator|.
name|addInput
argument_list|(
name|inputs
argument_list|,
operator|new
name|ReadEntity
argument_list|(
name|parseCtx
operator|.
name|getTopToTable
argument_list|()
operator|.
name|get
argument_list|(
name|topOp
argument_list|)
argument_list|,
name|parentViewInfo
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|Partition
name|part
range|:
name|parts
control|)
block|{
if|if
condition|(
name|part
operator|.
name|getTable
argument_list|()
operator|.
name|isPartitioned
argument_list|()
condition|)
block|{
name|PlanUtils
operator|.
name|addInput
argument_list|(
name|inputs
argument_list|,
operator|new
name|ReadEntity
argument_list|(
name|part
argument_list|,
name|parentViewInfo
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|PlanUtils
operator|.
name|addInput
argument_list|(
name|inputs
argument_list|,
operator|new
name|ReadEntity
argument_list|(
name|part
operator|.
name|getTable
argument_list|()
argument_list|,
name|parentViewInfo
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// Later the properties have to come from the partition as opposed
comment|// to from the table in order to support versioning.
name|Path
index|[]
name|paths
init|=
literal|null
decl_stmt|;
name|sampleDesc
name|sampleDescr
init|=
name|parseCtx
operator|.
name|getOpToSamplePruner
argument_list|()
operator|.
name|get
argument_list|(
name|topOp
argument_list|)
decl_stmt|;
comment|// Lookup list bucketing pruner
name|Map
argument_list|<
name|String
argument_list|,
name|ExprNodeDesc
argument_list|>
name|partToPruner
init|=
name|parseCtx
operator|.
name|getOpToPartToSkewedPruner
argument_list|()
operator|.
name|get
argument_list|(
name|topOp
argument_list|)
decl_stmt|;
name|ExprNodeDesc
name|listBucketingPruner
init|=
operator|(
name|partToPruner
operator|!=
literal|null
operator|)
condition|?
name|partToPruner
operator|.
name|get
argument_list|(
name|part
operator|.
name|getName
argument_list|()
argument_list|)
else|:
literal|null
decl_stmt|;
if|if
condition|(
name|sampleDescr
operator|!=
literal|null
condition|)
block|{
assert|assert
operator|(
name|listBucketingPruner
operator|==
literal|null
operator|)
operator|:
literal|"Sampling and list bucketing can't coexit."
assert|;
name|paths
operator|=
name|SamplePruner
operator|.
name|prune
argument_list|(
name|part
argument_list|,
name|sampleDescr
argument_list|)
expr_stmt|;
name|parseCtx
operator|.
name|getGlobalLimitCtx
argument_list|()
operator|.
name|disableOpt
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|listBucketingPruner
operator|!=
literal|null
condition|)
block|{
assert|assert
operator|(
name|sampleDescr
operator|==
literal|null
operator|)
operator|:
literal|"Sampling and list bucketing can't coexist."
assert|;
comment|/* Use list bucketing prunner's path. */
name|paths
operator|=
name|ListBucketingPruner
operator|.
name|prune
argument_list|(
name|parseCtx
argument_list|,
name|part
argument_list|,
name|listBucketingPruner
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// Now we only try the first partition, if the first partition doesn't
comment|// contain enough size, we change to normal mode.
if|if
condition|(
name|parseCtx
operator|.
name|getGlobalLimitCtx
argument_list|()
operator|.
name|isEnable
argument_list|()
condition|)
block|{
if|if
condition|(
name|isFirstPart
condition|)
block|{
name|long
name|sizeLeft
init|=
name|sizeNeeded
decl_stmt|;
name|ArrayList
argument_list|<
name|Path
argument_list|>
name|retPathList
init|=
operator|new
name|ArrayList
argument_list|<
name|Path
argument_list|>
argument_list|()
decl_stmt|;
name|SamplePruner
operator|.
name|LimitPruneRetStatus
name|status
init|=
name|SamplePruner
operator|.
name|limitPrune
argument_list|(
name|part
argument_list|,
name|sizeLeft
argument_list|,
name|fileLimit
argument_list|,
name|retPathList
argument_list|)
decl_stmt|;
if|if
condition|(
name|status
operator|.
name|equals
argument_list|(
name|SamplePruner
operator|.
name|LimitPruneRetStatus
operator|.
name|NoFile
argument_list|)
condition|)
block|{
continue|continue;
block|}
elseif|else
if|if
condition|(
name|status
operator|.
name|equals
argument_list|(
name|SamplePruner
operator|.
name|LimitPruneRetStatus
operator|.
name|NotQualify
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Use full input -- first "
operator|+
name|fileLimit
operator|+
literal|" files are more than "
operator|+
name|sizeNeeded
operator|+
literal|" bytes"
argument_list|)
expr_stmt|;
name|parseCtx
operator|.
name|getGlobalLimitCtx
argument_list|()
operator|.
name|disableOpt
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|emptyInput
operator|=
literal|false
expr_stmt|;
name|paths
operator|=
operator|new
name|Path
index|[
name|retPathList
operator|.
name|size
argument_list|()
index|]
expr_stmt|;
name|int
name|index
init|=
literal|0
decl_stmt|;
for|for
control|(
name|Path
name|path
range|:
name|retPathList
control|)
block|{
name|paths
index|[
name|index
operator|++
index|]
operator|=
name|path
expr_stmt|;
block|}
if|if
condition|(
name|status
operator|.
name|equals
argument_list|(
name|SamplePruner
operator|.
name|LimitPruneRetStatus
operator|.
name|NeedAllFiles
argument_list|)
operator|&&
name|singlePartition
condition|)
block|{
comment|// if all files are needed to meet the size limit, we disable
comment|// optimization. It usually happens for empty table/partition or
comment|// table/partition with only one file. By disabling this
comment|// optimization, we can avoid retrying the query if there is
comment|// not sufficient rows.
name|parseCtx
operator|.
name|getGlobalLimitCtx
argument_list|()
operator|.
name|disableOpt
argument_list|()
expr_stmt|;
block|}
block|}
name|isFirstPart
operator|=
literal|false
expr_stmt|;
block|}
else|else
block|{
name|paths
operator|=
operator|new
name|Path
index|[
literal|0
index|]
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|parseCtx
operator|.
name|getGlobalLimitCtx
argument_list|()
operator|.
name|isEnable
argument_list|()
condition|)
block|{
name|paths
operator|=
name|part
operator|.
name|getPath
argument_list|()
expr_stmt|;
block|}
block|}
comment|// is it a partitioned table ?
if|if
condition|(
operator|!
name|part
operator|.
name|getTable
argument_list|()
operator|.
name|isPartitioned
argument_list|()
condition|)
block|{
assert|assert
operator|(
operator|(
name|tblDir
operator|==
literal|null
operator|)
operator|&&
operator|(
name|tblDesc
operator|==
literal|null
operator|)
operator|)
assert|;
name|tblDir
operator|=
name|paths
index|[
literal|0
index|]
expr_stmt|;
name|tblDesc
operator|=
name|Utilities
operator|.
name|getTableDesc
argument_list|(
name|part
operator|.
name|getTable
argument_list|()
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|tblDesc
operator|==
literal|null
condition|)
block|{
name|tblDesc
operator|=
name|Utilities
operator|.
name|getTableDesc
argument_list|(
name|part
operator|.
name|getTable
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|props
operator|!=
literal|null
condition|)
block|{
name|Properties
name|target
init|=
name|tblDesc
operator|.
name|getProperties
argument_list|()
decl_stmt|;
if|if
condition|(
name|target
operator|==
literal|null
condition|)
block|{
name|tblDesc
operator|.
name|setProperties
argument_list|(
name|target
operator|=
operator|new
name|Properties
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|target
operator|.
name|putAll
argument_list|(
name|props
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|Path
name|p
range|:
name|paths
control|)
block|{
if|if
condition|(
name|p
operator|==
literal|null
condition|)
block|{
continue|continue;
block|}
name|String
name|path
init|=
name|p
operator|.
name|toString
argument_list|()
decl_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Adding "
operator|+
name|path
operator|+
literal|" of table"
operator|+
name|alias_id
argument_list|)
expr_stmt|;
block|}
name|partDir
operator|.
name|add
argument_list|(
name|p
argument_list|)
expr_stmt|;
try|try
block|{
if|if
condition|(
name|part
operator|.
name|getTable
argument_list|()
operator|.
name|isPartitioned
argument_list|()
condition|)
block|{
name|partDesc
operator|.
name|add
argument_list|(
name|Utilities
operator|.
name|getPartitionDesc
argument_list|(
name|part
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|partDesc
operator|.
name|add
argument_list|(
name|Utilities
operator|.
name|getPartitionDescFromTableDesc
argument_list|(
name|tblDesc
argument_list|,
name|part
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|HiveException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|StringUtils
operator|.
name|stringifyException
argument_list|(
name|e
argument_list|)
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|SemanticException
argument_list|(
name|e
operator|.
name|getMessage
argument_list|()
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
block|}
if|if
condition|(
name|emptyInput
condition|)
block|{
name|parseCtx
operator|.
name|getGlobalLimitCtx
argument_list|()
operator|.
name|disableOpt
argument_list|()
expr_stmt|;
block|}
name|Iterator
argument_list|<
name|Path
argument_list|>
name|iterPath
init|=
name|partDir
operator|.
name|iterator
argument_list|()
decl_stmt|;
name|Iterator
argument_list|<
name|PartitionDesc
argument_list|>
name|iterPartnDesc
init|=
name|partDesc
operator|.
name|iterator
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|local
condition|)
block|{
while|while
condition|(
name|iterPath
operator|.
name|hasNext
argument_list|()
condition|)
block|{
assert|assert
name|iterPartnDesc
operator|.
name|hasNext
argument_list|()
assert|;
name|String
name|path
init|=
name|iterPath
operator|.
name|next
argument_list|()
operator|.
name|toString
argument_list|()
decl_stmt|;
name|PartitionDesc
name|prtDesc
init|=
name|iterPartnDesc
operator|.
name|next
argument_list|()
decl_stmt|;
comment|// Add the path to alias mapping
if|if
condition|(
name|plan
operator|.
name|getPathToAliases
argument_list|()
operator|.
name|get
argument_list|(
name|path
argument_list|)
operator|==
literal|null
condition|)
block|{
name|plan
operator|.
name|getPathToAliases
argument_list|()
operator|.
name|put
argument_list|(
name|path
argument_list|,
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|plan
operator|.
name|getPathToAliases
argument_list|()
operator|.
name|get
argument_list|(
name|path
argument_list|)
operator|.
name|add
argument_list|(
name|alias_id
argument_list|)
expr_stmt|;
name|plan
operator|.
name|getPathToPartitionInfo
argument_list|()
operator|.
name|put
argument_list|(
name|path
argument_list|,
name|prtDesc
argument_list|)
expr_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Information added for path "
operator|+
name|path
argument_list|)
expr_stmt|;
block|}
block|}
assert|assert
name|plan
operator|.
name|getAliasToWork
argument_list|()
operator|.
name|get
argument_list|(
name|alias_id
argument_list|)
operator|==
literal|null
assert|;
name|plan
operator|.
name|getAliasToWork
argument_list|()
operator|.
name|put
argument_list|(
name|alias_id
argument_list|,
name|topOp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// populate local work if needed
name|MapredLocalWork
name|localPlan
init|=
name|plan
operator|.
name|getMapLocalWork
argument_list|()
decl_stmt|;
if|if
condition|(
name|localPlan
operator|==
literal|null
condition|)
block|{
name|localPlan
operator|=
operator|new
name|MapredLocalWork
argument_list|(
operator|new
name|LinkedHashMap
argument_list|<
name|String
argument_list|,
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
argument_list|>
argument_list|()
argument_list|,
operator|new
name|LinkedHashMap
argument_list|<
name|String
argument_list|,
name|FetchWork
argument_list|>
argument_list|()
argument_list|)
expr_stmt|;
block|}
assert|assert
name|localPlan
operator|.
name|getAliasToWork
argument_list|()
operator|.
name|get
argument_list|(
name|alias_id
argument_list|)
operator|==
literal|null
assert|;
assert|assert
name|localPlan
operator|.
name|getAliasToFetchWork
argument_list|()
operator|.
name|get
argument_list|(
name|alias_id
argument_list|)
operator|==
literal|null
assert|;
name|localPlan
operator|.
name|getAliasToWork
argument_list|()
operator|.
name|put
argument_list|(
name|alias_id
argument_list|,
name|topOp
argument_list|)
expr_stmt|;
if|if
condition|(
name|tblDir
operator|==
literal|null
condition|)
block|{
name|tblDesc
operator|=
name|Utilities
operator|.
name|getTableDesc
argument_list|(
name|partsList
operator|.
name|getSourceTable
argument_list|()
argument_list|)
expr_stmt|;
name|localPlan
operator|.
name|getAliasToFetchWork
argument_list|()
operator|.
name|put
argument_list|(
name|alias_id
argument_list|,
operator|new
name|FetchWork
argument_list|(
name|FetchWork
operator|.
name|convertPathToStringArray
argument_list|(
name|partDir
argument_list|)
argument_list|,
name|partDesc
argument_list|,
name|tblDesc
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|localPlan
operator|.
name|getAliasToFetchWork
argument_list|()
operator|.
name|put
argument_list|(
name|alias_id
argument_list|,
operator|new
name|FetchWork
argument_list|(
name|tblDir
operator|.
name|toString
argument_list|()
argument_list|,
name|tblDesc
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|plan
operator|.
name|setMapLocalWork
argument_list|(
name|localPlan
argument_list|)
expr_stmt|;
block|}
name|opProcCtx
operator|.
name|addSeenOp
argument_list|(
name|task
argument_list|,
name|topOp
argument_list|)
expr_stmt|;
block|}
comment|/**    * set the current task in the mapredWork.    *    * @param alias    *          current alias    * @param topOp    *          the top operator of the stack    * @param plan    *          current plan    * @param local    *          whether you need to add to map-reduce or local work    * @param tt_desc    *          table descriptor    */
specifier|public
specifier|static
name|void
name|setTaskPlan
parameter_list|(
name|String
name|path
parameter_list|,
name|String
name|alias
parameter_list|,
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
name|topOp
parameter_list|,
name|MapWork
name|plan
parameter_list|,
name|boolean
name|local
parameter_list|,
name|TableDesc
name|tt_desc
parameter_list|)
throws|throws
name|SemanticException
block|{
if|if
condition|(
name|path
operator|==
literal|null
operator|||
name|alias
operator|==
literal|null
condition|)
block|{
return|return;
block|}
if|if
condition|(
operator|!
name|local
condition|)
block|{
if|if
condition|(
name|plan
operator|.
name|getPathToAliases
argument_list|()
operator|.
name|get
argument_list|(
name|path
argument_list|)
operator|==
literal|null
condition|)
block|{
name|plan
operator|.
name|getPathToAliases
argument_list|()
operator|.
name|put
argument_list|(
name|path
argument_list|,
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|plan
operator|.
name|getPathToAliases
argument_list|()
operator|.
name|get
argument_list|(
name|path
argument_list|)
operator|.
name|add
argument_list|(
name|alias
argument_list|)
expr_stmt|;
name|plan
operator|.
name|getPathToPartitionInfo
argument_list|()
operator|.
name|put
argument_list|(
name|path
argument_list|,
operator|new
name|PartitionDesc
argument_list|(
name|tt_desc
argument_list|,
literal|null
argument_list|)
argument_list|)
expr_stmt|;
name|plan
operator|.
name|getAliasToWork
argument_list|()
operator|.
name|put
argument_list|(
name|alias
argument_list|,
name|topOp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// populate local work if needed
name|MapredLocalWork
name|localPlan
init|=
name|plan
operator|.
name|getMapLocalWork
argument_list|()
decl_stmt|;
if|if
condition|(
name|localPlan
operator|==
literal|null
condition|)
block|{
name|localPlan
operator|=
operator|new
name|MapredLocalWork
argument_list|(
operator|new
name|LinkedHashMap
argument_list|<
name|String
argument_list|,
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
argument_list|>
argument_list|()
argument_list|,
operator|new
name|LinkedHashMap
argument_list|<
name|String
argument_list|,
name|FetchWork
argument_list|>
argument_list|()
argument_list|)
expr_stmt|;
block|}
assert|assert
name|localPlan
operator|.
name|getAliasToWork
argument_list|()
operator|.
name|get
argument_list|(
name|alias
argument_list|)
operator|==
literal|null
assert|;
assert|assert
name|localPlan
operator|.
name|getAliasToFetchWork
argument_list|()
operator|.
name|get
argument_list|(
name|alias
argument_list|)
operator|==
literal|null
assert|;
name|localPlan
operator|.
name|getAliasToWork
argument_list|()
operator|.
name|put
argument_list|(
name|alias
argument_list|,
name|topOp
argument_list|)
expr_stmt|;
name|localPlan
operator|.
name|getAliasToFetchWork
argument_list|()
operator|.
name|put
argument_list|(
name|alias
argument_list|,
operator|new
name|FetchWork
argument_list|(
name|alias
argument_list|,
name|tt_desc
argument_list|)
argument_list|)
expr_stmt|;
name|plan
operator|.
name|setMapLocalWork
argument_list|(
name|localPlan
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * set key and value descriptor.    *    * @param plan    *          current plan    * @param topOp    *          current top operator in the path    */
specifier|public
specifier|static
name|void
name|setKeyAndValueDesc
parameter_list|(
name|ReduceWork
name|plan
parameter_list|,
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
name|topOp
parameter_list|)
block|{
if|if
condition|(
name|topOp
operator|==
literal|null
condition|)
block|{
return|return;
block|}
if|if
condition|(
name|topOp
operator|instanceof
name|ReduceSinkOperator
condition|)
block|{
name|ReduceSinkOperator
name|rs
init|=
operator|(
name|ReduceSinkOperator
operator|)
name|topOp
decl_stmt|;
name|plan
operator|.
name|setKeyDesc
argument_list|(
name|rs
operator|.
name|getConf
argument_list|()
operator|.
name|getKeySerializeInfo
argument_list|()
argument_list|)
expr_stmt|;
name|int
name|tag
init|=
name|Math
operator|.
name|max
argument_list|(
literal|0
argument_list|,
name|rs
operator|.
name|getConf
argument_list|()
operator|.
name|getTag
argument_list|()
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|TableDesc
argument_list|>
name|tagToSchema
init|=
name|plan
operator|.
name|getTagToValueDesc
argument_list|()
decl_stmt|;
while|while
condition|(
name|tag
operator|+
literal|1
operator|>
name|tagToSchema
operator|.
name|size
argument_list|()
condition|)
block|{
name|tagToSchema
operator|.
name|add
argument_list|(
literal|null
argument_list|)
expr_stmt|;
block|}
name|tagToSchema
operator|.
name|set
argument_list|(
name|tag
argument_list|,
name|rs
operator|.
name|getConf
argument_list|()
operator|.
name|getValueSerializeInfo
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|List
argument_list|<
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
argument_list|>
name|children
init|=
name|topOp
operator|.
name|getChildOperators
argument_list|()
decl_stmt|;
if|if
condition|(
name|children
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
name|op
range|:
name|children
control|)
block|{
name|setKeyAndValueDesc
argument_list|(
name|plan
argument_list|,
name|op
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/**    * Set the key and value description for all the tasks rooted at the given    * task. Loops over all the tasks recursively.    *    * @param task    */
specifier|public
specifier|static
name|void
name|setKeyAndValueDescForTaskTree
parameter_list|(
name|Task
argument_list|<
name|?
extends|extends
name|Serializable
argument_list|>
name|task
parameter_list|)
block|{
if|if
condition|(
name|task
operator|instanceof
name|ConditionalTask
condition|)
block|{
name|List
argument_list|<
name|Task
argument_list|<
name|?
extends|extends
name|Serializable
argument_list|>
argument_list|>
name|listTasks
init|=
operator|(
operator|(
name|ConditionalTask
operator|)
name|task
operator|)
operator|.
name|getListTasks
argument_list|()
decl_stmt|;
for|for
control|(
name|Task
argument_list|<
name|?
extends|extends
name|Serializable
argument_list|>
name|tsk
range|:
name|listTasks
control|)
block|{
name|setKeyAndValueDescForTaskTree
argument_list|(
name|tsk
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|task
operator|instanceof
name|ExecDriver
condition|)
block|{
name|MapredWork
name|work
init|=
operator|(
name|MapredWork
operator|)
name|task
operator|.
name|getWork
argument_list|()
decl_stmt|;
name|work
operator|.
name|getMapWork
argument_list|()
operator|.
name|deriveExplainAttributes
argument_list|()
expr_stmt|;
name|HashMap
argument_list|<
name|String
argument_list|,
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
argument_list|>
name|opMap
init|=
name|work
operator|.
name|getMapWork
argument_list|()
operator|.
name|getAliasToWork
argument_list|()
decl_stmt|;
if|if
condition|(
name|opMap
operator|!=
literal|null
operator|&&
operator|!
name|opMap
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
for|for
control|(
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
name|op
range|:
name|opMap
operator|.
name|values
argument_list|()
control|)
block|{
name|setKeyAndValueDesc
argument_list|(
name|work
operator|.
name|getReduceWork
argument_list|()
argument_list|,
name|op
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|task
operator|.
name|getChildTasks
argument_list|()
operator|==
literal|null
condition|)
block|{
return|return;
block|}
for|for
control|(
name|Task
argument_list|<
name|?
extends|extends
name|Serializable
argument_list|>
name|childTask
range|:
name|task
operator|.
name|getChildTasks
argument_list|()
control|)
block|{
name|setKeyAndValueDescForTaskTree
argument_list|(
name|childTask
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * create a new plan and return.    *    * @return the new plan    */
specifier|public
specifier|static
name|MapredWork
name|getMapRedWork
parameter_list|(
name|ParseContext
name|parseCtx
parameter_list|)
block|{
name|MapredWork
name|work
init|=
name|getMapRedWorkFromConf
argument_list|(
name|parseCtx
operator|.
name|getConf
argument_list|()
argument_list|)
decl_stmt|;
name|work
operator|.
name|getMapWork
argument_list|()
operator|.
name|setNameToSplitSample
argument_list|(
name|parseCtx
operator|.
name|getNameToSplitSample
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|work
return|;
block|}
comment|/**    * create a new plan and return. The pan won't contain the name to split    * sample information in parse context.    *    * @return the new plan    */
specifier|public
specifier|static
name|MapredWork
name|getMapRedWorkFromConf
parameter_list|(
name|HiveConf
name|conf
parameter_list|)
block|{
name|MapredWork
name|mrWork
init|=
operator|new
name|MapredWork
argument_list|()
decl_stmt|;
name|MapWork
name|work
init|=
name|mrWork
operator|.
name|getMapWork
argument_list|()
decl_stmt|;
name|boolean
name|mapperCannotSpanPartns
init|=
name|conf
operator|.
name|getBoolVar
argument_list|(
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVE_MAPPER_CANNOT_SPAN_MULTIPLE_PARTITIONS
argument_list|)
decl_stmt|;
name|work
operator|.
name|setMapperCannotSpanPartns
argument_list|(
name|mapperCannotSpanPartns
argument_list|)
expr_stmt|;
name|work
operator|.
name|setPathToAliases
argument_list|(
operator|new
name|LinkedHashMap
argument_list|<
name|String
argument_list|,
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|>
argument_list|()
argument_list|)
expr_stmt|;
name|work
operator|.
name|setPathToPartitionInfo
argument_list|(
operator|new
name|LinkedHashMap
argument_list|<
name|String
argument_list|,
name|PartitionDesc
argument_list|>
argument_list|()
argument_list|)
expr_stmt|;
name|work
operator|.
name|setAliasToWork
argument_list|(
operator|new
name|LinkedHashMap
argument_list|<
name|String
argument_list|,
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
argument_list|>
argument_list|()
argument_list|)
expr_stmt|;
name|work
operator|.
name|setHadoopSupportsSplittable
argument_list|(
name|conf
operator|.
name|getBoolVar
argument_list|(
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVE_COMBINE_INPUT_FORMAT_SUPPORTS_SPLITTABLE
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|mrWork
return|;
block|}
comment|/**    * insert in the map for the operator to row resolver.    *    * @param op    *          operator created    * @param rr    *          row resolver    * @param parseCtx    *          parse context    */
annotation|@
name|SuppressWarnings
argument_list|(
literal|"nls"
argument_list|)
specifier|public
specifier|static
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
name|putOpInsertMap
parameter_list|(
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
name|op
parameter_list|,
name|RowResolver
name|rr
parameter_list|,
name|ParseContext
name|parseCtx
parameter_list|)
block|{
name|OpParseContext
name|ctx
init|=
operator|new
name|OpParseContext
argument_list|(
name|rr
argument_list|)
decl_stmt|;
name|parseCtx
operator|.
name|getOpParseCtx
argument_list|()
operator|.
name|put
argument_list|(
name|op
argument_list|,
name|ctx
argument_list|)
expr_stmt|;
return|return
name|op
return|;
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"nls"
argument_list|)
comment|/**    * Split two tasks by creating a temporary file between them.    *    * @param op reduce sink operator being processed    * @param parentTask the parent task    * @param childTask the child task    * @param opProcCtx context    **/
specifier|private
specifier|static
name|void
name|splitTasks
parameter_list|(
name|ReduceSinkOperator
name|op
parameter_list|,
name|Task
argument_list|<
name|?
extends|extends
name|Serializable
argument_list|>
name|parentTask
parameter_list|,
name|Task
argument_list|<
name|?
extends|extends
name|Serializable
argument_list|>
name|childTask
parameter_list|,
name|GenMRProcContext
name|opProcCtx
parameter_list|)
throws|throws
name|SemanticException
block|{
if|if
condition|(
name|op
operator|.
name|getNumParent
argument_list|()
operator|!=
literal|1
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"Expecting operator "
operator|+
name|op
operator|+
literal|" to have one parent. "
operator|+
literal|"But found multiple parents : "
operator|+
name|op
operator|.
name|getParentOperators
argument_list|()
argument_list|)
throw|;
block|}
name|ParseContext
name|parseCtx
init|=
name|opProcCtx
operator|.
name|getParseCtx
argument_list|()
decl_stmt|;
name|parentTask
operator|.
name|addDependentTask
argument_list|(
name|childTask
argument_list|)
expr_stmt|;
comment|// Root Task cannot depend on any other task, therefore childTask cannot be
comment|// a root Task
name|List
argument_list|<
name|Task
argument_list|<
name|?
extends|extends
name|Serializable
argument_list|>
argument_list|>
name|rootTasks
init|=
name|opProcCtx
operator|.
name|getRootTasks
argument_list|()
decl_stmt|;
if|if
condition|(
name|rootTasks
operator|.
name|contains
argument_list|(
name|childTask
argument_list|)
condition|)
block|{
name|rootTasks
operator|.
name|remove
argument_list|(
name|childTask
argument_list|)
expr_stmt|;
block|}
comment|// generate the temporary file
name|Context
name|baseCtx
init|=
name|parseCtx
operator|.
name|getContext
argument_list|()
decl_stmt|;
name|String
name|taskTmpDir
init|=
name|baseCtx
operator|.
name|getMRTmpFileURI
argument_list|()
decl_stmt|;
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
name|parent
init|=
name|op
operator|.
name|getParentOperators
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|TableDesc
name|tt_desc
init|=
name|PlanUtils
operator|.
name|getIntermediateFileTableDesc
argument_list|(
name|PlanUtils
operator|.
name|getFieldSchemasFromRowSchema
argument_list|(
name|parent
operator|.
name|getSchema
argument_list|()
argument_list|,
literal|"temporarycol"
argument_list|)
argument_list|)
decl_stmt|;
comment|// Create a file sink operator for this file name
name|boolean
name|compressIntermediate
init|=
name|parseCtx
operator|.
name|getConf
argument_list|()
operator|.
name|getBoolVar
argument_list|(
name|HiveConf
operator|.
name|ConfVars
operator|.
name|COMPRESSINTERMEDIATE
argument_list|)
decl_stmt|;
name|FileSinkDesc
name|desc
init|=
operator|new
name|FileSinkDesc
argument_list|(
name|taskTmpDir
argument_list|,
name|tt_desc
argument_list|,
name|compressIntermediate
argument_list|)
decl_stmt|;
if|if
condition|(
name|compressIntermediate
condition|)
block|{
name|desc
operator|.
name|setCompressCodec
argument_list|(
name|parseCtx
operator|.
name|getConf
argument_list|()
operator|.
name|getVar
argument_list|(
name|HiveConf
operator|.
name|ConfVars
operator|.
name|COMPRESSINTERMEDIATECODEC
argument_list|)
argument_list|)
expr_stmt|;
name|desc
operator|.
name|setCompressType
argument_list|(
name|parseCtx
operator|.
name|getConf
argument_list|()
operator|.
name|getVar
argument_list|(
name|HiveConf
operator|.
name|ConfVars
operator|.
name|COMPRESSINTERMEDIATETYPE
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
name|fs_op
init|=
name|putOpInsertMap
argument_list|(
name|OperatorFactory
operator|.
name|get
argument_list|(
name|desc
argument_list|,
name|parent
operator|.
name|getSchema
argument_list|()
argument_list|)
argument_list|,
literal|null
argument_list|,
name|parseCtx
argument_list|)
decl_stmt|;
comment|// replace the reduce child with this operator
name|List
argument_list|<
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
argument_list|>
name|childOpList
init|=
name|parent
operator|.
name|getChildOperators
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|pos
init|=
literal|0
init|;
name|pos
operator|<
name|childOpList
operator|.
name|size
argument_list|()
condition|;
name|pos
operator|++
control|)
block|{
if|if
condition|(
name|childOpList
operator|.
name|get
argument_list|(
name|pos
argument_list|)
operator|==
name|op
condition|)
block|{
name|childOpList
operator|.
name|set
argument_list|(
name|pos
argument_list|,
name|fs_op
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|List
argument_list|<
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
argument_list|>
name|parentOpList
init|=
operator|new
name|ArrayList
argument_list|<
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
argument_list|>
argument_list|()
decl_stmt|;
name|parentOpList
operator|.
name|add
argument_list|(
name|parent
argument_list|)
expr_stmt|;
name|fs_op
operator|.
name|setParentOperators
argument_list|(
name|parentOpList
argument_list|)
expr_stmt|;
comment|// create a dummy tableScan operator on top of op
comment|// TableScanOperator is implicitly created here for each MapOperator
name|RowResolver
name|rowResolver
init|=
name|opProcCtx
operator|.
name|getParseCtx
argument_list|()
operator|.
name|getOpParseCtx
argument_list|()
operator|.
name|get
argument_list|(
name|parent
argument_list|)
operator|.
name|getRowResolver
argument_list|()
decl_stmt|;
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
name|ts_op
init|=
name|putOpInsertMap
argument_list|(
name|OperatorFactory
operator|.
name|get
argument_list|(
name|TableScanDesc
operator|.
name|class
argument_list|,
name|parent
operator|.
name|getSchema
argument_list|()
argument_list|)
argument_list|,
name|rowResolver
argument_list|,
name|parseCtx
argument_list|)
decl_stmt|;
name|childOpList
operator|=
operator|new
name|ArrayList
argument_list|<
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
argument_list|>
argument_list|()
expr_stmt|;
name|childOpList
operator|.
name|add
argument_list|(
name|op
argument_list|)
expr_stmt|;
name|ts_op
operator|.
name|setChildOperators
argument_list|(
name|childOpList
argument_list|)
expr_stmt|;
name|op
operator|.
name|getParentOperators
argument_list|()
operator|.
name|set
argument_list|(
literal|0
argument_list|,
name|ts_op
argument_list|)
expr_stmt|;
name|Map
argument_list|<
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
argument_list|,
name|GenMapRedCtx
argument_list|>
name|mapCurrCtx
init|=
name|opProcCtx
operator|.
name|getMapCurrCtx
argument_list|()
decl_stmt|;
name|mapCurrCtx
operator|.
name|put
argument_list|(
name|ts_op
argument_list|,
operator|new
name|GenMapRedCtx
argument_list|(
name|childTask
argument_list|,
literal|null
argument_list|)
argument_list|)
expr_stmt|;
name|String
name|streamDesc
init|=
name|taskTmpDir
decl_stmt|;
name|MapredWork
name|cplan
init|=
operator|(
name|MapredWork
operator|)
name|childTask
operator|.
name|getWork
argument_list|()
decl_stmt|;
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
name|reducer
init|=
name|op
operator|.
name|getChildOperators
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|needsTagging
argument_list|(
name|cplan
operator|.
name|getReduceWork
argument_list|()
argument_list|)
condition|)
block|{
name|String
name|origStreamDesc
decl_stmt|;
name|streamDesc
operator|=
literal|"$INTNAME"
expr_stmt|;
name|origStreamDesc
operator|=
name|streamDesc
expr_stmt|;
name|int
name|pos
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|cplan
operator|.
name|getMapWork
argument_list|()
operator|.
name|getAliasToWork
argument_list|()
operator|.
name|get
argument_list|(
name|streamDesc
argument_list|)
operator|!=
literal|null
condition|)
block|{
name|streamDesc
operator|=
name|origStreamDesc
operator|.
name|concat
argument_list|(
name|String
operator|.
name|valueOf
argument_list|(
operator|++
name|pos
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// TODO: Allocate work to remove the temporary files and make that
comment|// dependent on the redTask
name|cplan
operator|.
name|getReduceWork
argument_list|()
operator|.
name|setNeedsTagging
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
comment|// Add the path to alias mapping
name|setTaskPlan
argument_list|(
name|taskTmpDir
argument_list|,
name|streamDesc
argument_list|,
name|ts_op
argument_list|,
name|cplan
operator|.
name|getMapWork
argument_list|()
argument_list|,
literal|false
argument_list|,
name|tt_desc
argument_list|)
expr_stmt|;
name|opProcCtx
operator|.
name|setCurrTopOp
argument_list|(
literal|null
argument_list|)
expr_stmt|;
name|opProcCtx
operator|.
name|setCurrAliasId
argument_list|(
literal|null
argument_list|)
expr_stmt|;
name|opProcCtx
operator|.
name|setCurrTask
argument_list|(
name|childTask
argument_list|)
expr_stmt|;
name|opProcCtx
operator|.
name|addRootIfPossible
argument_list|(
name|parentTask
argument_list|)
expr_stmt|;
block|}
specifier|static
name|boolean
name|hasBranchFinished
parameter_list|(
name|Object
modifier|...
name|children
parameter_list|)
block|{
for|for
control|(
name|Object
name|child
range|:
name|children
control|)
block|{
if|if
condition|(
name|child
operator|==
literal|null
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
return|return
literal|true
return|;
block|}
comment|/**    * Replace the Map-side operator tree associated with targetAlias in    * target with the Map-side operator tree associated with sourceAlias in source.    * @param sourceAlias    * @param targetAlias    * @param source    * @param target    */
specifier|public
specifier|static
name|void
name|replaceMapWork
parameter_list|(
name|String
name|sourceAlias
parameter_list|,
name|String
name|targetAlias
parameter_list|,
name|MapWork
name|source
parameter_list|,
name|MapWork
name|target
parameter_list|)
block|{
name|Map
argument_list|<
name|String
argument_list|,
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|>
name|sourcePathToAliases
init|=
name|source
operator|.
name|getPathToAliases
argument_list|()
decl_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|PartitionDesc
argument_list|>
name|sourcePathToPartitionInfo
init|=
name|source
operator|.
name|getPathToPartitionInfo
argument_list|()
decl_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
argument_list|>
name|sourceAliasToWork
init|=
name|source
operator|.
name|getAliasToWork
argument_list|()
decl_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|PartitionDesc
argument_list|>
name|sourceAliasToPartnInfo
init|=
name|source
operator|.
name|getAliasToPartnInfo
argument_list|()
decl_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|>
name|targetPathToAliases
init|=
name|target
operator|.
name|getPathToAliases
argument_list|()
decl_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|PartitionDesc
argument_list|>
name|targetPathToPartitionInfo
init|=
name|target
operator|.
name|getPathToPartitionInfo
argument_list|()
decl_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
argument_list|>
name|targetAliasToWork
init|=
name|target
operator|.
name|getAliasToWork
argument_list|()
decl_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|PartitionDesc
argument_list|>
name|targetAliasToPartnInfo
init|=
name|target
operator|.
name|getAliasToPartnInfo
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|sourceAliasToWork
operator|.
name|containsKey
argument_list|(
name|sourceAlias
argument_list|)
operator|||
operator|!
name|targetAliasToWork
operator|.
name|containsKey
argument_list|(
name|targetAlias
argument_list|)
condition|)
block|{
comment|// Nothing to do if there is no operator tree associated with
comment|// sourceAlias in source or there is not operator tree associated
comment|// with targetAlias in target.
return|return;
block|}
if|if
condition|(
name|sourceAliasToWork
operator|.
name|size
argument_list|()
operator|>
literal|1
condition|)
block|{
comment|// If there are multiple aliases in source, we do not know
comment|// how to merge.
return|return;
block|}
comment|// Remove unnecessary information from target
name|targetAliasToWork
operator|.
name|remove
argument_list|(
name|targetAlias
argument_list|)
expr_stmt|;
name|targetAliasToPartnInfo
operator|.
name|remove
argument_list|(
name|targetAlias
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|pathsToRemove
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|Entry
argument_list|<
name|String
argument_list|,
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|>
name|entry
range|:
name|targetPathToAliases
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|ArrayList
argument_list|<
name|String
argument_list|>
name|aliases
init|=
name|entry
operator|.
name|getValue
argument_list|()
decl_stmt|;
name|aliases
operator|.
name|remove
argument_list|(
name|targetAlias
argument_list|)
expr_stmt|;
if|if
condition|(
name|aliases
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|pathsToRemove
operator|.
name|add
argument_list|(
name|entry
operator|.
name|getKey
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
name|String
name|pathToRemove
range|:
name|pathsToRemove
control|)
block|{
name|targetPathToAliases
operator|.
name|remove
argument_list|(
name|pathToRemove
argument_list|)
expr_stmt|;
name|targetPathToPartitionInfo
operator|.
name|remove
argument_list|(
name|pathToRemove
argument_list|)
expr_stmt|;
block|}
comment|// Add new information from source to target
name|targetAliasToWork
operator|.
name|put
argument_list|(
name|sourceAlias
argument_list|,
name|sourceAliasToWork
operator|.
name|get
argument_list|(
name|sourceAlias
argument_list|)
argument_list|)
expr_stmt|;
name|targetAliasToPartnInfo
operator|.
name|putAll
argument_list|(
name|sourceAliasToPartnInfo
argument_list|)
expr_stmt|;
name|targetPathToPartitionInfo
operator|.
name|putAll
argument_list|(
name|sourcePathToPartitionInfo
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|pathsToAdd
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|Entry
argument_list|<
name|String
argument_list|,
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|>
name|entry
range|:
name|sourcePathToAliases
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|ArrayList
argument_list|<
name|String
argument_list|>
name|aliases
init|=
name|entry
operator|.
name|getValue
argument_list|()
decl_stmt|;
if|if
condition|(
name|aliases
operator|.
name|contains
argument_list|(
name|sourceAlias
argument_list|)
condition|)
block|{
name|pathsToAdd
operator|.
name|add
argument_list|(
name|entry
operator|.
name|getKey
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
name|String
name|pathToAdd
range|:
name|pathsToAdd
control|)
block|{
if|if
condition|(
operator|!
name|targetPathToAliases
operator|.
name|containsKey
argument_list|(
name|pathToAdd
argument_list|)
condition|)
block|{
name|targetPathToAliases
operator|.
name|put
argument_list|(
name|pathToAdd
argument_list|,
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|targetPathToAliases
operator|.
name|get
argument_list|(
name|pathToAdd
argument_list|)
operator|.
name|add
argument_list|(
name|sourceAlias
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
name|GenMapRedUtils
parameter_list|()
block|{
comment|// prevent instantiation
block|}
block|}
end_class

end_unit

