begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|ppd
package|;
end_package

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|LinkedHashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Stack
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|FilterOperator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|GroupByOperator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|OperatorUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|SelectOperator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|ExprNodeColumnDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|ExprNodeDescUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|conf
operator|.
name|HiveConf
operator|.
name|ConfVars
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|CommonJoinOperator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|FunctionRegistry
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|JoinOperator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|Operator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|OperatorFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|ReduceSinkOperator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|RowSchema
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|TableScanOperator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|lib
operator|.
name|DefaultRuleDispatcher
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|lib
operator|.
name|Dispatcher
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|lib
operator|.
name|GraphWalker
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|lib
operator|.
name|Node
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|lib
operator|.
name|NodeProcessor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|lib
operator|.
name|NodeProcessorCtx
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|lib
operator|.
name|PreOrderOnceWalker
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|lib
operator|.
name|Rule
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|lib
operator|.
name|RuleRegExp
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|optimizer
operator|.
name|Transform
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|parse
operator|.
name|ParseContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|parse
operator|.
name|SemanticException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|ExprNodeDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|ExprNodeDynamicListDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|ExprNodeGenericFuncDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|FilterDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|JoinCondDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|JoinDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|OperatorDesc
import|;
end_import

begin_comment
comment|/**  * creates synthetic predicates that represent "IN (keylist other table)"  */
end_comment

begin_class
specifier|public
class|class
name|SyntheticJoinPredicate
extends|extends
name|Transform
block|{
specifier|private
specifier|static
specifier|transient
name|Logger
name|LOG
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|SyntheticJoinPredicate
operator|.
name|class
operator|.
name|getName
argument_list|()
argument_list|)
decl_stmt|;
annotation|@
name|Override
specifier|public
name|ParseContext
name|transform
parameter_list|(
name|ParseContext
name|pctx
parameter_list|)
throws|throws
name|SemanticException
block|{
name|boolean
name|enabled
init|=
literal|false
decl_stmt|;
name|String
name|queryEngine
init|=
name|pctx
operator|.
name|getConf
argument_list|()
operator|.
name|getVar
argument_list|(
name|ConfVars
operator|.
name|HIVE_EXECUTION_ENGINE
argument_list|)
decl_stmt|;
if|if
condition|(
name|queryEngine
operator|.
name|equals
argument_list|(
literal|"tez"
argument_list|)
operator|&&
name|pctx
operator|.
name|getConf
argument_list|()
operator|.
name|getBoolVar
argument_list|(
name|ConfVars
operator|.
name|TEZ_DYNAMIC_PARTITION_PRUNING
argument_list|)
condition|)
block|{
name|enabled
operator|=
literal|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|queryEngine
operator|.
name|equals
argument_list|(
literal|"spark"
argument_list|)
operator|&&
name|pctx
operator|.
name|getConf
argument_list|()
operator|.
name|isSparkDPPAny
argument_list|()
operator|)
condition|)
block|{
name|enabled
operator|=
literal|true
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|enabled
condition|)
block|{
return|return
name|pctx
return|;
block|}
name|Map
argument_list|<
name|Rule
argument_list|,
name|NodeProcessor
argument_list|>
name|opRules
init|=
operator|new
name|LinkedHashMap
argument_list|<
name|Rule
argument_list|,
name|NodeProcessor
argument_list|>
argument_list|()
decl_stmt|;
name|opRules
operator|.
name|put
argument_list|(
operator|new
name|RuleRegExp
argument_list|(
literal|"R1"
argument_list|,
literal|"("
operator|+
name|TableScanOperator
operator|.
name|getOperatorName
argument_list|()
operator|+
literal|"%"
operator|+
literal|".*"
operator|+
name|ReduceSinkOperator
operator|.
name|getOperatorName
argument_list|()
operator|+
literal|"%"
operator|+
name|JoinOperator
operator|.
name|getOperatorName
argument_list|()
operator|+
literal|"%)"
argument_list|)
argument_list|,
operator|new
name|JoinSynthetic
argument_list|()
argument_list|)
expr_stmt|;
comment|// The dispatcher fires the processor corresponding to the closest matching
comment|// rule and passes the context along
name|SyntheticContext
name|context
init|=
operator|new
name|SyntheticContext
argument_list|(
name|pctx
argument_list|)
decl_stmt|;
name|Dispatcher
name|disp
init|=
operator|new
name|DefaultRuleDispatcher
argument_list|(
literal|null
argument_list|,
name|opRules
argument_list|,
name|context
argument_list|)
decl_stmt|;
name|GraphWalker
name|ogw
init|=
operator|new
name|PreOrderOnceWalker
argument_list|(
name|disp
argument_list|)
decl_stmt|;
comment|// Create a list of top op nodes
name|List
argument_list|<
name|Node
argument_list|>
name|topNodes
init|=
operator|new
name|ArrayList
argument_list|<
name|Node
argument_list|>
argument_list|()
decl_stmt|;
name|topNodes
operator|.
name|addAll
argument_list|(
name|pctx
operator|.
name|getTopOps
argument_list|()
operator|.
name|values
argument_list|()
argument_list|)
expr_stmt|;
name|ogw
operator|.
name|startWalking
argument_list|(
name|topNodes
argument_list|,
literal|null
argument_list|)
expr_stmt|;
return|return
name|pctx
return|;
block|}
comment|// insert filter operator between target(child) and input(parent)
specifier|private
specifier|static
name|Operator
argument_list|<
name|FilterDesc
argument_list|>
name|createFilter
parameter_list|(
name|Operator
argument_list|<
name|?
argument_list|>
name|target
parameter_list|,
name|Operator
argument_list|<
name|?
argument_list|>
name|parent
parameter_list|,
name|RowSchema
name|parentRS
parameter_list|,
name|ExprNodeDesc
name|filterExpr
parameter_list|)
block|{
name|FilterDesc
name|filterDesc
init|=
operator|new
name|FilterDesc
argument_list|(
name|filterExpr
argument_list|,
literal|false
argument_list|)
decl_stmt|;
name|filterDesc
operator|.
name|setSyntheticJoinPredicate
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|Operator
argument_list|<
name|FilterDesc
argument_list|>
name|filter
init|=
name|OperatorFactory
operator|.
name|get
argument_list|(
name|parent
operator|.
name|getCompilationOpContext
argument_list|()
argument_list|,
name|filterDesc
argument_list|,
operator|new
name|RowSchema
argument_list|(
name|parentRS
operator|.
name|getSignature
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
name|filter
operator|.
name|getParentOperators
argument_list|()
operator|.
name|add
argument_list|(
name|parent
argument_list|)
expr_stmt|;
name|filter
operator|.
name|getChildOperators
argument_list|()
operator|.
name|add
argument_list|(
name|target
argument_list|)
expr_stmt|;
name|parent
operator|.
name|replaceChild
argument_list|(
name|target
argument_list|,
name|filter
argument_list|)
expr_stmt|;
name|target
operator|.
name|replaceParent
argument_list|(
name|parent
argument_list|,
name|filter
argument_list|)
expr_stmt|;
return|return
name|filter
return|;
block|}
specifier|private
specifier|static
class|class
name|SyntheticContext
implements|implements
name|NodeProcessorCtx
block|{
name|ParseContext
name|parseContext
decl_stmt|;
name|boolean
name|extended
decl_stmt|;
specifier|public
name|SyntheticContext
parameter_list|(
name|ParseContext
name|pCtx
parameter_list|)
block|{
name|parseContext
operator|=
name|pCtx
expr_stmt|;
name|extended
operator|=
name|parseContext
operator|.
name|getConf
argument_list|()
operator|.
name|getBoolVar
argument_list|(
name|ConfVars
operator|.
name|TEZ_DYNAMIC_PARTITION_PRUNING_EXTENDED
argument_list|)
expr_stmt|;
block|}
specifier|public
name|ParseContext
name|getParseContext
parameter_list|()
block|{
return|return
name|parseContext
return|;
block|}
specifier|public
name|boolean
name|isExtended
parameter_list|()
block|{
return|return
name|extended
return|;
block|}
block|}
specifier|private
specifier|static
class|class
name|JoinSynthetic
implements|implements
name|NodeProcessor
block|{
annotation|@
name|Override
specifier|public
name|Object
name|process
parameter_list|(
name|Node
name|nd
parameter_list|,
name|Stack
argument_list|<
name|Node
argument_list|>
name|stack
parameter_list|,
name|NodeProcessorCtx
name|procCtx
parameter_list|,
name|Object
modifier|...
name|nodeOutputs
parameter_list|)
throws|throws
name|SemanticException
block|{
name|SyntheticContext
name|sCtx
init|=
operator|(
name|SyntheticContext
operator|)
name|procCtx
decl_stmt|;
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
name|CommonJoinOperator
argument_list|<
name|JoinDesc
argument_list|>
name|join
init|=
operator|(
name|CommonJoinOperator
argument_list|<
name|JoinDesc
argument_list|>
operator|)
name|nd
decl_stmt|;
name|ReduceSinkOperator
name|source
init|=
operator|(
name|ReduceSinkOperator
operator|)
name|stack
operator|.
name|get
argument_list|(
name|stack
operator|.
name|size
argument_list|()
operator|-
literal|2
argument_list|)
decl_stmt|;
name|int
name|srcPos
init|=
name|join
operator|.
name|getParentOperators
argument_list|()
operator|.
name|indexOf
argument_list|(
name|source
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
argument_list|>
name|parents
init|=
name|join
operator|.
name|getParentOperators
argument_list|()
decl_stmt|;
name|int
index|[]
index|[]
name|targets
init|=
name|getTargets
argument_list|(
name|join
argument_list|)
decl_stmt|;
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
name|parent
init|=
name|source
operator|.
name|getParentOperators
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|RowSchema
name|parentRS
init|=
name|parent
operator|.
name|getSchema
argument_list|()
decl_stmt|;
comment|// don't generate for null-safes.
if|if
condition|(
name|join
operator|.
name|getConf
argument_list|()
operator|.
name|getNullSafes
argument_list|()
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|boolean
name|b
range|:
name|join
operator|.
name|getConf
argument_list|()
operator|.
name|getNullSafes
argument_list|()
control|)
block|{
if|if
condition|(
name|b
condition|)
block|{
return|return
literal|null
return|;
block|}
block|}
block|}
for|for
control|(
name|int
name|targetPos
range|:
name|targets
index|[
name|srcPos
index|]
control|)
block|{
if|if
condition|(
name|srcPos
operator|==
name|targetPos
condition|)
block|{
continue|continue;
block|}
name|ReduceSinkOperator
name|target
init|=
operator|(
name|ReduceSinkOperator
operator|)
name|parents
operator|.
name|get
argument_list|(
name|targetPos
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|ExprNodeDesc
argument_list|>
name|sourceKeys
init|=
name|source
operator|.
name|getConf
argument_list|()
operator|.
name|getKeyCols
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|ExprNodeDesc
argument_list|>
name|targetKeys
init|=
name|target
operator|.
name|getConf
argument_list|()
operator|.
name|getKeyCols
argument_list|()
decl_stmt|;
if|if
condition|(
name|sourceKeys
operator|.
name|size
argument_list|()
operator|<
literal|1
condition|)
block|{
continue|continue;
block|}
name|ExprNodeDesc
name|syntheticExpr
init|=
literal|null
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|sourceKeys
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
specifier|final
name|ExprNodeDesc
name|sourceKey
init|=
name|sourceKeys
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|ExprNodeDesc
argument_list|>
name|inArgs
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|inArgs
operator|.
name|add
argument_list|(
name|sourceKey
argument_list|)
expr_stmt|;
name|ExprNodeDynamicListDesc
name|dynamicExpr
init|=
operator|new
name|ExprNodeDynamicListDesc
argument_list|(
name|targetKeys
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|getTypeInfo
argument_list|()
argument_list|,
name|target
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|inArgs
operator|.
name|add
argument_list|(
name|dynamicExpr
argument_list|)
expr_stmt|;
name|ExprNodeDesc
name|syntheticInExpr
init|=
name|ExprNodeGenericFuncDesc
operator|.
name|newInstance
argument_list|(
name|FunctionRegistry
operator|.
name|getFunctionInfo
argument_list|(
literal|"in"
argument_list|)
operator|.
name|getGenericUDF
argument_list|()
argument_list|,
name|inArgs
argument_list|)
decl_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Synthetic predicate in "
operator|+
name|join
operator|+
literal|": "
operator|+
name|srcPos
operator|+
literal|" --> "
operator|+
name|targetPos
operator|+
literal|" ("
operator|+
name|syntheticInExpr
operator|+
literal|")"
argument_list|)
expr_stmt|;
block|}
name|List
argument_list|<
name|ExprNodeDesc
argument_list|>
name|andArgs
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
if|if
condition|(
name|syntheticExpr
operator|!=
literal|null
condition|)
block|{
name|andArgs
operator|.
name|add
argument_list|(
name|syntheticExpr
argument_list|)
expr_stmt|;
block|}
name|andArgs
operator|.
name|add
argument_list|(
name|syntheticInExpr
argument_list|)
expr_stmt|;
if|if
condition|(
name|sCtx
operator|.
name|isExtended
argument_list|()
condition|)
block|{
comment|// Backtrack
name|List
argument_list|<
name|ExprNodeDesc
argument_list|>
name|newExprs
init|=
name|createDerivatives
argument_list|(
name|target
operator|.
name|getParentOperators
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|,
name|targetKeys
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|,
name|sourceKey
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|newExprs
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
for|for
control|(
name|ExprNodeDesc
name|expr
range|:
name|newExprs
control|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Additional synthetic predicate in "
operator|+
name|join
operator|+
literal|": "
operator|+
name|srcPos
operator|+
literal|" --> "
operator|+
name|targetPos
operator|+
literal|" ("
operator|+
name|expr
operator|+
literal|")"
argument_list|)
expr_stmt|;
block|}
block|}
name|andArgs
operator|.
name|addAll
argument_list|(
name|newExprs
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|andArgs
operator|.
name|size
argument_list|()
operator|<
literal|2
condition|)
block|{
name|syntheticExpr
operator|=
name|syntheticInExpr
expr_stmt|;
block|}
else|else
block|{
comment|// Create AND expression
name|syntheticExpr
operator|=
name|ExprNodeGenericFuncDesc
operator|.
name|newInstance
argument_list|(
name|FunctionRegistry
operator|.
name|getFunctionInfo
argument_list|(
literal|"and"
argument_list|)
operator|.
name|getGenericUDF
argument_list|()
argument_list|,
name|andArgs
argument_list|)
expr_stmt|;
block|}
block|}
name|Operator
argument_list|<
name|FilterDesc
argument_list|>
name|newFilter
init|=
name|createFilter
argument_list|(
name|source
argument_list|,
name|parent
argument_list|,
name|parentRS
argument_list|,
name|syntheticExpr
argument_list|)
decl_stmt|;
name|parent
operator|=
name|newFilter
expr_stmt|;
block|}
return|return
literal|null
return|;
block|}
comment|// calculate filter propagation directions for each alias
comment|// L<->R for inner/semi join, L<-R for left outer join, R<-L for right outer
comment|// join
specifier|private
name|int
index|[]
index|[]
name|getTargets
parameter_list|(
name|CommonJoinOperator
argument_list|<
name|JoinDesc
argument_list|>
name|join
parameter_list|)
block|{
name|JoinCondDesc
index|[]
name|conds
init|=
name|join
operator|.
name|getConf
argument_list|()
operator|.
name|getConds
argument_list|()
decl_stmt|;
name|int
name|aliases
init|=
name|conds
operator|.
name|length
operator|+
literal|1
decl_stmt|;
name|Vectors
name|vector
init|=
operator|new
name|Vectors
argument_list|(
name|aliases
argument_list|)
decl_stmt|;
for|for
control|(
name|JoinCondDesc
name|cond
range|:
name|conds
control|)
block|{
name|int
name|left
init|=
name|cond
operator|.
name|getLeft
argument_list|()
decl_stmt|;
name|int
name|right
init|=
name|cond
operator|.
name|getRight
argument_list|()
decl_stmt|;
switch|switch
condition|(
name|cond
operator|.
name|getType
argument_list|()
condition|)
block|{
case|case
name|JoinDesc
operator|.
name|INNER_JOIN
case|:
case|case
name|JoinDesc
operator|.
name|LEFT_SEMI_JOIN
case|:
name|vector
operator|.
name|add
argument_list|(
name|left
argument_list|,
name|right
argument_list|)
expr_stmt|;
name|vector
operator|.
name|add
argument_list|(
name|right
argument_list|,
name|left
argument_list|)
expr_stmt|;
break|break;
case|case
name|JoinDesc
operator|.
name|LEFT_OUTER_JOIN
case|:
name|vector
operator|.
name|add
argument_list|(
name|right
argument_list|,
name|left
argument_list|)
expr_stmt|;
break|break;
case|case
name|JoinDesc
operator|.
name|RIGHT_OUTER_JOIN
case|:
name|vector
operator|.
name|add
argument_list|(
name|left
argument_list|,
name|right
argument_list|)
expr_stmt|;
break|break;
case|case
name|JoinDesc
operator|.
name|FULL_OUTER_JOIN
case|:
break|break;
block|}
block|}
name|int
index|[]
index|[]
name|result
init|=
operator|new
name|int
index|[
name|aliases
index|]
index|[]
decl_stmt|;
for|for
control|(
name|int
name|pos
init|=
literal|0
init|;
name|pos
operator|<
name|aliases
condition|;
name|pos
operator|++
control|)
block|{
comment|// find all targets recursively
name|result
index|[
name|pos
index|]
operator|=
name|vector
operator|.
name|traverse
argument_list|(
name|pos
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
specifier|private
name|List
argument_list|<
name|ExprNodeDesc
argument_list|>
name|createDerivatives
parameter_list|(
specifier|final
name|Operator
argument_list|<
name|?
argument_list|>
name|currentOp
parameter_list|,
specifier|final
name|ExprNodeDesc
name|currentNode
parameter_list|,
specifier|final
name|ExprNodeDesc
name|sourceKey
parameter_list|)
throws|throws
name|SemanticException
block|{
name|List
argument_list|<
name|ExprNodeDesc
argument_list|>
name|resultExprs
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
return|return
name|createDerivatives
argument_list|(
name|resultExprs
argument_list|,
name|currentOp
argument_list|,
name|currentNode
argument_list|,
name|sourceKey
argument_list|)
condition|?
name|resultExprs
else|:
operator|new
name|ArrayList
argument_list|<>
argument_list|()
return|;
block|}
specifier|private
name|boolean
name|createDerivatives
parameter_list|(
specifier|final
name|List
argument_list|<
name|ExprNodeDesc
argument_list|>
name|resultExprs
parameter_list|,
specifier|final
name|Operator
argument_list|<
name|?
argument_list|>
name|op
parameter_list|,
specifier|final
name|ExprNodeDesc
name|currentNode
parameter_list|,
specifier|final
name|ExprNodeDesc
name|sourceKey
parameter_list|)
throws|throws
name|SemanticException
block|{
comment|// 1. Obtain join operator upstream
name|Operator
argument_list|<
name|?
argument_list|>
name|currentOp
init|=
name|op
decl_stmt|;
while|while
condition|(
operator|!
operator|(
name|currentOp
operator|instanceof
name|CommonJoinOperator
operator|)
condition|)
block|{
if|if
condition|(
name|currentOp
operator|.
name|getParentOperators
argument_list|()
operator|==
literal|null
operator|||
name|currentOp
operator|.
name|getParentOperators
argument_list|()
operator|.
name|size
argument_list|()
operator|!=
literal|1
condition|)
block|{
comment|// Cannot backtrack
name|currentOp
operator|=
literal|null
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
operator|(
name|currentOp
operator|instanceof
name|FilterOperator
operator|)
operator|&&
operator|!
operator|(
name|currentOp
operator|instanceof
name|SelectOperator
operator|)
operator|&&
operator|!
operator|(
name|currentOp
operator|instanceof
name|ReduceSinkOperator
operator|)
operator|&&
operator|!
operator|(
name|currentOp
operator|instanceof
name|GroupByOperator
operator|)
condition|)
block|{
comment|// Operator not supported
name|currentOp
operator|=
literal|null
expr_stmt|;
break|break;
block|}
comment|// Move the pointer
name|currentOp
operator|=
name|currentOp
operator|.
name|getParentOperators
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|currentOp
operator|==
literal|null
condition|)
block|{
comment|// We did not find any join, we are done
return|return
literal|true
return|;
block|}
name|CommonJoinOperator
argument_list|<
name|JoinDesc
argument_list|>
name|joinOp
init|=
operator|(
name|CommonJoinOperator
operator|)
name|currentOp
decl_stmt|;
comment|// 2. Backtrack expression to join output
specifier|final
name|ExprNodeDesc
name|joinExprNode
init|=
name|ExprNodeDescUtils
operator|.
name|backtrack
argument_list|(
name|currentNode
argument_list|,
name|op
argument_list|,
name|joinOp
argument_list|)
decl_stmt|;
if|if
condition|(
name|joinExprNode
operator|==
literal|null
operator|||
operator|!
operator|(
name|joinExprNode
operator|instanceof
name|ExprNodeColumnDesc
operator|)
condition|)
block|{
comment|// TODO: We can extend to other expression types
comment|// We are done
return|return
literal|true
return|;
block|}
specifier|final
name|String
name|columnRefJoinInput
init|=
operator|(
operator|(
name|ExprNodeColumnDesc
operator|)
name|joinExprNode
operator|)
operator|.
name|getColumn
argument_list|()
decl_stmt|;
comment|// 3. Find input position in join for expression obtained
name|String
name|columnOutputName
init|=
literal|null
decl_stmt|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|ExprNodeDesc
argument_list|>
name|e
range|:
name|joinOp
operator|.
name|getColumnExprMap
argument_list|()
operator|.
name|entrySet
argument_list|()
control|)
block|{
if|if
condition|(
name|e
operator|.
name|getValue
argument_list|()
operator|==
name|joinExprNode
condition|)
block|{
name|columnOutputName
operator|=
name|e
operator|.
name|getKey
argument_list|()
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|columnOutputName
operator|==
literal|null
condition|)
block|{
comment|// Maybe the join is pruning columns, though it should not.
comment|// In any case, we are done
return|return
literal|true
return|;
block|}
specifier|final
name|int
name|srcPos
init|=
name|joinOp
operator|.
name|getConf
argument_list|()
operator|.
name|getReversedExprs
argument_list|()
operator|.
name|get
argument_list|(
name|columnOutputName
argument_list|)
decl_stmt|;
specifier|final
name|int
index|[]
index|[]
name|targets
init|=
name|getTargets
argument_list|(
name|joinOp
argument_list|)
decl_stmt|;
specifier|final
name|ReduceSinkOperator
name|rsOp
init|=
operator|(
name|ReduceSinkOperator
operator|)
name|joinOp
operator|.
name|getParentOperators
argument_list|()
operator|.
name|get
argument_list|(
name|srcPos
argument_list|)
decl_stmt|;
comment|// 4. Find expression in input RS operator.
specifier|final
name|Operator
argument_list|<
name|?
argument_list|>
name|rsOpInput
init|=
name|rsOp
operator|.
name|getParentOperators
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
specifier|final
name|ExprNodeDesc
name|rsOpInputExprNode
init|=
name|rsOp
operator|.
name|getColumnExprMap
argument_list|()
operator|.
name|get
argument_list|(
name|columnRefJoinInput
argument_list|)
decl_stmt|;
if|if
condition|(
name|rsOpInputExprNode
operator|==
literal|null
condition|)
block|{
comment|// Unexpected, we just bail out and we do not infer additional predicates
return|return
literal|false
return|;
block|}
name|int
name|posInRSOpKeys
init|=
operator|-
literal|1
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|rsOp
operator|.
name|getConf
argument_list|()
operator|.
name|getKeyCols
argument_list|()
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|rsOpInputExprNode
operator|.
name|isSame
argument_list|(
name|rsOp
operator|.
name|getConf
argument_list|()
operator|.
name|getKeyCols
argument_list|()
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|)
condition|)
block|{
name|posInRSOpKeys
operator|=
name|i
expr_stmt|;
break|break;
block|}
block|}
comment|// 5. If it is part of the key, we can create a new semijoin.
comment|// In addition, we can do the same for siblings
if|if
condition|(
name|posInRSOpKeys
operator|>=
literal|0
condition|)
block|{
comment|// We pass the tests, we add it to the args for the AND expression
name|addParentReduceSink
argument_list|(
name|resultExprs
argument_list|,
name|rsOp
argument_list|,
name|posInRSOpKeys
argument_list|,
name|sourceKey
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|targetPos
range|:
name|targets
index|[
name|srcPos
index|]
control|)
block|{
if|if
condition|(
name|srcPos
operator|==
name|targetPos
condition|)
block|{
continue|continue;
block|}
specifier|final
name|ReduceSinkOperator
name|otherRsOp
init|=
operator|(
name|ReduceSinkOperator
operator|)
name|joinOp
operator|.
name|getParentOperators
argument_list|()
operator|.
name|get
argument_list|(
name|targetPos
argument_list|)
decl_stmt|;
specifier|final
name|Operator
argument_list|<
name|?
argument_list|>
name|otherRsOpInput
init|=
name|otherRsOp
operator|.
name|getParentOperators
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
comment|// We pass the tests, we add it to the args for the AND expression
name|addParentReduceSink
argument_list|(
name|resultExprs
argument_list|,
name|otherRsOp
argument_list|,
name|posInRSOpKeys
argument_list|,
name|sourceKey
argument_list|)
expr_stmt|;
comment|// We propagate to operator below
name|boolean
name|success
init|=
name|createDerivatives
argument_list|(
name|resultExprs
argument_list|,
name|otherRsOpInput
argument_list|,
name|otherRsOp
operator|.
name|getConf
argument_list|()
operator|.
name|getKeyCols
argument_list|()
operator|.
name|get
argument_list|(
name|posInRSOpKeys
argument_list|)
argument_list|,
name|sourceKey
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|success
condition|)
block|{
comment|// Something went wrong, bail out
return|return
literal|false
return|;
block|}
block|}
block|}
comment|// 6. Whether it was part of the key or of the value, if we reach here, we can at least
comment|// continue propagating to operators below
name|boolean
name|success
init|=
name|createDerivatives
argument_list|(
name|resultExprs
argument_list|,
name|rsOpInput
argument_list|,
name|rsOpInputExprNode
argument_list|,
name|sourceKey
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|success
condition|)
block|{
comment|// Something went wrong, bail out
return|return
literal|false
return|;
block|}
comment|// 7. We are done, success
return|return
literal|true
return|;
block|}
specifier|private
name|void
name|addParentReduceSink
parameter_list|(
specifier|final
name|List
argument_list|<
name|ExprNodeDesc
argument_list|>
name|andArgs
parameter_list|,
specifier|final
name|ReduceSinkOperator
name|rsOp
parameter_list|,
specifier|final
name|int
name|keyIndex
parameter_list|,
specifier|final
name|ExprNodeDesc
name|sourceKey
parameter_list|)
throws|throws
name|SemanticException
block|{
name|ExprNodeDynamicListDesc
name|dynamicExpr
init|=
operator|new
name|ExprNodeDynamicListDesc
argument_list|(
name|rsOp
operator|.
name|getConf
argument_list|()
operator|.
name|getKeyCols
argument_list|()
operator|.
name|get
argument_list|(
name|keyIndex
argument_list|)
operator|.
name|getTypeInfo
argument_list|()
argument_list|,
name|rsOp
argument_list|,
name|keyIndex
argument_list|)
decl_stmt|;
comment|// Create synthetic IN expression
name|List
argument_list|<
name|ExprNodeDesc
argument_list|>
name|inArgs
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|inArgs
operator|.
name|add
argument_list|(
name|sourceKey
argument_list|)
expr_stmt|;
name|inArgs
operator|.
name|add
argument_list|(
name|dynamicExpr
argument_list|)
expr_stmt|;
name|ExprNodeDesc
name|newNode
init|=
name|ExprNodeGenericFuncDesc
operator|.
name|newInstance
argument_list|(
name|FunctionRegistry
operator|.
name|getFunctionInfo
argument_list|(
literal|"in"
argument_list|)
operator|.
name|getGenericUDF
argument_list|()
argument_list|,
name|inArgs
argument_list|)
decl_stmt|;
name|andArgs
operator|.
name|add
argument_list|(
name|newNode
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
specifier|static
class|class
name|Vectors
block|{
specifier|private
specifier|final
name|Set
argument_list|<
name|Integer
argument_list|>
index|[]
name|vector
decl_stmt|;
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
specifier|public
name|Vectors
parameter_list|(
name|int
name|length
parameter_list|)
block|{
name|vector
operator|=
operator|new
name|Set
index|[
name|length
index|]
expr_stmt|;
block|}
specifier|public
name|void
name|add
parameter_list|(
name|int
name|from
parameter_list|,
name|int
name|to
parameter_list|)
block|{
if|if
condition|(
name|vector
index|[
name|from
index|]
operator|==
literal|null
condition|)
block|{
name|vector
index|[
name|from
index|]
operator|=
operator|new
name|HashSet
argument_list|<
name|Integer
argument_list|>
argument_list|()
expr_stmt|;
block|}
name|vector
index|[
name|from
index|]
operator|.
name|add
argument_list|(
name|to
argument_list|)
expr_stmt|;
block|}
specifier|public
name|int
index|[]
name|traverse
parameter_list|(
name|int
name|pos
parameter_list|)
block|{
name|Set
argument_list|<
name|Integer
argument_list|>
name|targets
init|=
operator|new
name|HashSet
argument_list|<
name|Integer
argument_list|>
argument_list|()
decl_stmt|;
name|traverse
argument_list|(
name|targets
argument_list|,
name|pos
argument_list|)
expr_stmt|;
return|return
name|toArray
argument_list|(
name|targets
argument_list|)
return|;
block|}
specifier|private
name|int
index|[]
name|toArray
parameter_list|(
name|Set
argument_list|<
name|Integer
argument_list|>
name|values
parameter_list|)
block|{
name|int
name|index
init|=
literal|0
decl_stmt|;
name|int
index|[]
name|result
init|=
operator|new
name|int
index|[
name|values
operator|.
name|size
argument_list|()
index|]
decl_stmt|;
for|for
control|(
name|int
name|value
range|:
name|values
control|)
block|{
name|result
index|[
name|index
operator|++
index|]
operator|=
name|value
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
specifier|private
name|void
name|traverse
parameter_list|(
name|Set
argument_list|<
name|Integer
argument_list|>
name|targets
parameter_list|,
name|int
name|pos
parameter_list|)
block|{
if|if
condition|(
name|vector
index|[
name|pos
index|]
operator|==
literal|null
condition|)
block|{
return|return;
block|}
for|for
control|(
name|int
name|target
range|:
name|vector
index|[
name|pos
index|]
control|)
block|{
if|if
condition|(
name|targets
operator|.
name|add
argument_list|(
name|target
argument_list|)
condition|)
block|{
name|traverse
argument_list|(
name|targets
argument_list|,
name|target
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
end_class

end_unit

