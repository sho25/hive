begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|processors
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|File
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|FileInputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|FileOutputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|charset
operator|.
name|Charset
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|StringTokenizer
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicInteger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|compress
operator|.
name|archivers
operator|.
name|jar
operator|.
name|JarArchiveEntry
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|compress
operator|.
name|archivers
operator|.
name|jar
operator|.
name|JarArchiveOutputStream
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|io
operator|.
name|IOUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|conf
operator|.
name|HiveVariableSource
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|conf
operator|.
name|VariableSubstitution
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|metadata
operator|.
name|HiveException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|security
operator|.
name|authorization
operator|.
name|plugin
operator|.
name|HiveOperationType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|session
operator|.
name|SessionState
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|session
operator|.
name|SessionState
operator|.
name|LogHelper
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|session
operator|.
name|SessionState
operator|.
name|ResourceType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|tools
operator|.
name|ant
operator|.
name|BuildException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|tools
operator|.
name|ant
operator|.
name|Project
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|tools
operator|.
name|ant
operator|.
name|types
operator|.
name|Path
import|;
end_import

begin_import
import|import
name|org
operator|.
name|codehaus
operator|.
name|groovy
operator|.
name|ant
operator|.
name|Groovyc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|VisibleForTesting
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|io
operator|.
name|Files
import|;
end_import

begin_comment
comment|/**  * Processor allows users to build code inside a hive session, then  * use this code as a UDF, Serde, or even a more complex entity like an  * input format or hook.  *  * Note: This class is stateful and not thread safe. Create a new instance for  * each invocation of CompileProcessor.  *  */
end_comment

begin_class
specifier|public
class|class
name|CompileProcessor
implements|implements
name|CommandProcessor
block|{
specifier|public
specifier|static
specifier|final
name|Logger
name|LOG
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|CompileProcessor
operator|.
name|class
operator|.
name|getName
argument_list|()
argument_list|)
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|LogHelper
name|console
init|=
operator|new
name|LogHelper
argument_list|(
name|LOG
argument_list|)
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|String
name|IO_TMP_DIR
init|=
literal|"java.io.tmpdir"
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|String
name|GROOVY
init|=
literal|"GROOVY"
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|String
name|AS
init|=
literal|"AS"
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|String
name|NAMED
init|=
literal|"NAMED"
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|String
name|SYNTAX
init|=
literal|"syntax: COMPILE ` some code here ` AS groovy NAMED something.groovy"
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|AtomicInteger
name|runCount
decl_stmt|;
comment|/**    * The language of the compiled code. Used to select the appropriate compiler.    */
specifier|private
name|String
name|lang
decl_stmt|;
comment|/**    * The code to be compiled    */
specifier|private
name|String
name|code
decl_stmt|;
comment|/**    * The name of the file the code will be written to    */
specifier|private
name|String
name|named
decl_stmt|;
comment|/**    * The entire command sent to the processor    */
specifier|private
name|String
name|command
decl_stmt|;
comment|/**    * Used as part of a file name to help avoid collisions.    */
specifier|private
name|int
name|myId
decl_stmt|;
static|static
block|{
name|runCount
operator|=
operator|new
name|AtomicInteger
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/**    * User supplies dynamic code in this format:    * COMPILE ` some code here ` AS groovy NAMED something.groovy;    * CompileProcessor will compile and package this code into a jar. The jar    * will be added to the session state via the session state's    * ADD RESOURCE command.    * @param command a String to be compiled    * @return CommandProcessorResponse with 0 for success and 1 for failure    */
annotation|@
name|Override
specifier|public
name|CommandProcessorResponse
name|run
parameter_list|(
name|String
name|command
parameter_list|)
block|{
name|SessionState
name|ss
init|=
name|SessionState
operator|.
name|get
argument_list|()
decl_stmt|;
name|this
operator|.
name|command
operator|=
name|command
expr_stmt|;
name|CommandProcessorResponse
name|authErrResp
init|=
name|CommandUtil
operator|.
name|authorizeCommand
argument_list|(
name|ss
argument_list|,
name|HiveOperationType
operator|.
name|COMPILE
argument_list|,
name|Arrays
operator|.
name|asList
argument_list|(
name|command
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|authErrResp
operator|!=
literal|null
condition|)
block|{
comment|// there was an authorization issue
return|return
name|authErrResp
return|;
block|}
name|myId
operator|=
name|runCount
operator|.
name|getAndIncrement
argument_list|()
expr_stmt|;
try|try
block|{
name|parse
argument_list|(
name|ss
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|CompileProcessorException
name|e
parameter_list|)
block|{
return|return
name|CommandProcessorResponse
operator|.
name|create
argument_list|(
name|e
argument_list|)
return|;
block|}
name|CommandProcessorResponse
name|result
init|=
literal|null
decl_stmt|;
try|try
block|{
name|result
operator|=
name|compile
argument_list|(
name|ss
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|CompileProcessorException
name|e
parameter_list|)
block|{
return|return
name|CommandProcessorResponse
operator|.
name|create
argument_list|(
name|e
argument_list|)
return|;
block|}
return|return
name|result
return|;
block|}
comment|/**    * Parses the supplied command    * @param ss    * @throws CompileProcessorException if the code can not be compiled or the jar can not be made    */
annotation|@
name|VisibleForTesting
name|void
name|parse
parameter_list|(
name|SessionState
name|ss
parameter_list|)
throws|throws
name|CompileProcessorException
block|{
if|if
condition|(
name|ss
operator|!=
literal|null
condition|)
block|{
name|command
operator|=
operator|new
name|VariableSubstitution
argument_list|(
operator|new
name|HiveVariableSource
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|getHiveVariable
parameter_list|()
block|{
return|return
name|SessionState
operator|.
name|get
argument_list|()
operator|.
name|getHiveVariables
argument_list|()
return|;
block|}
block|}
argument_list|)
operator|.
name|substitute
argument_list|(
name|ss
operator|.
name|getConf
argument_list|()
argument_list|,
name|command
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|command
operator|==
literal|null
operator|||
name|command
operator|.
name|length
argument_list|()
operator|==
literal|0
condition|)
block|{
throw|throw
operator|new
name|CompileProcessorException
argument_list|(
literal|"Command was empty"
argument_list|)
throw|;
block|}
name|StringBuilder
name|toCompile
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|int
name|startPosition
init|=
literal|0
decl_stmt|;
name|int
name|endPosition
init|=
operator|-
literal|1
decl_stmt|;
comment|/* TODO Escape handling may be changed by a follow on.      * The largest issue is ; which are treated as statement      * terminators for the cli. Once the cli is fixed this      * code should be re-investigated      */
while|while
condition|(
name|command
operator|.
name|charAt
argument_list|(
name|startPosition
operator|++
argument_list|)
operator|!=
literal|'`'
operator|&&
name|startPosition
operator|<
name|command
operator|.
name|length
argument_list|()
condition|)
block|{      }
if|if
condition|(
name|startPosition
operator|==
name|command
operator|.
name|length
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|CompileProcessorException
argument_list|(
name|SYNTAX
argument_list|)
throw|;
block|}
for|for
control|(
name|int
name|i
init|=
name|startPosition
init|;
name|i
operator|<
name|command
operator|.
name|length
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|command
operator|.
name|charAt
argument_list|(
name|i
argument_list|)
operator|==
literal|'\\'
condition|)
block|{
name|toCompile
operator|.
name|append
argument_list|(
name|command
operator|.
name|charAt
argument_list|(
name|i
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|i
operator|=
name|i
operator|+
literal|1
expr_stmt|;
continue|continue;
block|}
elseif|else
if|if
condition|(
name|command
operator|.
name|charAt
argument_list|(
name|i
argument_list|)
operator|==
literal|'`'
condition|)
block|{
name|endPosition
operator|=
name|i
expr_stmt|;
break|break;
block|}
else|else
block|{
name|toCompile
operator|.
name|append
argument_list|(
name|command
operator|.
name|charAt
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|endPosition
operator|==
operator|-
literal|1
condition|)
block|{
throw|throw
operator|new
name|CompileProcessorException
argument_list|(
name|SYNTAX
argument_list|)
throw|;
block|}
name|StringTokenizer
name|st
init|=
operator|new
name|StringTokenizer
argument_list|(
name|command
operator|.
name|substring
argument_list|(
name|endPosition
operator|+
literal|1
argument_list|)
argument_list|,
literal|" "
argument_list|)
decl_stmt|;
if|if
condition|(
name|st
operator|.
name|countTokens
argument_list|()
operator|!=
literal|4
condition|)
block|{
throw|throw
operator|new
name|CompileProcessorException
argument_list|(
name|SYNTAX
argument_list|)
throw|;
block|}
name|String
name|shouldBeAs
init|=
name|st
operator|.
name|nextToken
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|shouldBeAs
operator|.
name|equalsIgnoreCase
argument_list|(
name|AS
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|CompileProcessorException
argument_list|(
name|SYNTAX
argument_list|)
throw|;
block|}
name|setLang
argument_list|(
name|st
operator|.
name|nextToken
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|lang
operator|.
name|equalsIgnoreCase
argument_list|(
name|GROOVY
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|CompileProcessorException
argument_list|(
literal|"Can not compile "
operator|+
name|lang
operator|+
literal|". Hive can only compile "
operator|+
name|GROOVY
argument_list|)
throw|;
block|}
name|String
name|shouldBeNamed
init|=
name|st
operator|.
name|nextToken
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|shouldBeNamed
operator|.
name|equalsIgnoreCase
argument_list|(
name|NAMED
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|CompileProcessorException
argument_list|(
name|SYNTAX
argument_list|)
throw|;
block|}
name|setNamed
argument_list|(
name|st
operator|.
name|nextToken
argument_list|()
argument_list|)
expr_stmt|;
name|setCode
argument_list|(
name|toCompile
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
annotation|@
name|VisibleForTesting
comment|/**    * Method converts statement into a file, compiles the file and then packages the file.    * @param ss    * @return Response code of 0 for success 1 for failure    * @throws CompileProcessorException    */
name|CommandProcessorResponse
name|compile
parameter_list|(
name|SessionState
name|ss
parameter_list|)
throws|throws
name|CompileProcessorException
block|{
name|Project
name|proj
init|=
operator|new
name|Project
argument_list|()
decl_stmt|;
name|String
name|ioTempDir
init|=
name|System
operator|.
name|getProperty
argument_list|(
name|IO_TMP_DIR
argument_list|)
decl_stmt|;
name|File
name|ioTempFile
init|=
operator|new
name|File
argument_list|(
name|ioTempDir
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|ioTempFile
operator|.
name|exists
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|CompileProcessorException
argument_list|(
name|ioTempDir
operator|+
literal|" does not exists"
argument_list|)
throw|;
block|}
if|if
condition|(
operator|!
name|ioTempFile
operator|.
name|isDirectory
argument_list|()
operator|||
operator|!
name|ioTempFile
operator|.
name|canWrite
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|CompileProcessorException
argument_list|(
name|ioTempDir
operator|+
literal|" is not a writable directory"
argument_list|)
throw|;
block|}
name|Groovyc
name|g
init|=
operator|new
name|Groovyc
argument_list|()
decl_stmt|;
name|long
name|runStamp
init|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
decl_stmt|;
name|String
name|jarId
init|=
name|myId
operator|+
literal|"_"
operator|+
name|runStamp
decl_stmt|;
name|g
operator|.
name|setProject
argument_list|(
name|proj
argument_list|)
expr_stmt|;
name|Path
name|sourcePath
init|=
operator|new
name|Path
argument_list|(
name|proj
argument_list|)
decl_stmt|;
name|File
name|destination
init|=
operator|new
name|File
argument_list|(
name|ioTempFile
argument_list|,
name|jarId
operator|+
literal|"out"
argument_list|)
decl_stmt|;
name|g
operator|.
name|setDestdir
argument_list|(
name|destination
argument_list|)
expr_stmt|;
name|File
name|input
init|=
operator|new
name|File
argument_list|(
name|ioTempFile
argument_list|,
name|jarId
operator|+
literal|"in"
argument_list|)
decl_stmt|;
name|sourcePath
operator|.
name|setLocation
argument_list|(
name|input
argument_list|)
expr_stmt|;
name|g
operator|.
name|setSrcdir
argument_list|(
name|sourcePath
argument_list|)
expr_stmt|;
name|input
operator|.
name|mkdir
argument_list|()
expr_stmt|;
name|File
name|fileToWrite
init|=
operator|new
name|File
argument_list|(
name|input
argument_list|,
name|this
operator|.
name|named
argument_list|)
decl_stmt|;
try|try
block|{
name|Files
operator|.
name|write
argument_list|(
name|this
operator|.
name|code
argument_list|,
name|fileToWrite
argument_list|,
name|Charset
operator|.
name|forName
argument_list|(
literal|"UTF-8"
argument_list|)
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e1
parameter_list|)
block|{
throw|throw
operator|new
name|CompileProcessorException
argument_list|(
literal|"writing file"
argument_list|,
name|e1
argument_list|)
throw|;
block|}
name|destination
operator|.
name|mkdir
argument_list|()
expr_stmt|;
try|try
block|{
name|g
operator|.
name|execute
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|BuildException
name|ex
parameter_list|)
block|{
throw|throw
operator|new
name|CompileProcessorException
argument_list|(
literal|"Problem compiling"
argument_list|,
name|ex
argument_list|)
throw|;
block|}
name|File
name|testArchive
init|=
operator|new
name|File
argument_list|(
name|ioTempFile
argument_list|,
name|jarId
operator|+
literal|".jar"
argument_list|)
decl_stmt|;
name|JarArchiveOutputStream
name|out
init|=
literal|null
decl_stmt|;
try|try
block|{
name|out
operator|=
operator|new
name|JarArchiveOutputStream
argument_list|(
operator|new
name|FileOutputStream
argument_list|(
name|testArchive
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|File
name|f
range|:
name|destination
operator|.
name|listFiles
argument_list|()
control|)
block|{
name|JarArchiveEntry
name|jentry
init|=
operator|new
name|JarArchiveEntry
argument_list|(
name|f
operator|.
name|getName
argument_list|()
argument_list|)
decl_stmt|;
name|FileInputStream
name|fis
init|=
operator|new
name|FileInputStream
argument_list|(
name|f
argument_list|)
decl_stmt|;
name|out
operator|.
name|putArchiveEntry
argument_list|(
name|jentry
argument_list|)
expr_stmt|;
name|IOUtils
operator|.
name|copy
argument_list|(
name|fis
argument_list|,
name|out
argument_list|)
expr_stmt|;
name|fis
operator|.
name|close
argument_list|()
expr_stmt|;
name|out
operator|.
name|closeArchiveEntry
argument_list|()
expr_stmt|;
block|}
name|out
operator|.
name|finish
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|CompileProcessorException
argument_list|(
literal|"Exception while writing jar"
argument_list|,
name|e
argument_list|)
throw|;
block|}
finally|finally
block|{
if|if
condition|(
name|out
operator|!=
literal|null
condition|)
block|{
try|try
block|{
name|out
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|WhatCanYouDo
parameter_list|)
block|{         }
block|}
block|}
if|if
condition|(
name|ss
operator|!=
literal|null
condition|)
block|{
name|ss
operator|.
name|add_resource
argument_list|(
name|ResourceType
operator|.
name|JAR
argument_list|,
name|testArchive
operator|.
name|getAbsolutePath
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|CommandProcessorResponse
name|good
init|=
operator|new
name|CommandProcessorResponse
argument_list|(
literal|0
argument_list|,
name|testArchive
operator|.
name|getAbsolutePath
argument_list|()
argument_list|,
literal|null
argument_list|)
decl_stmt|;
return|return
name|good
return|;
block|}
specifier|public
name|String
name|getLang
parameter_list|()
block|{
return|return
name|lang
return|;
block|}
specifier|public
name|void
name|setLang
parameter_list|(
name|String
name|lang
parameter_list|)
block|{
name|this
operator|.
name|lang
operator|=
name|lang
expr_stmt|;
block|}
specifier|public
name|String
name|getCode
parameter_list|()
block|{
return|return
name|code
return|;
block|}
specifier|public
name|void
name|setCode
parameter_list|(
name|String
name|code
parameter_list|)
block|{
name|this
operator|.
name|code
operator|=
name|code
expr_stmt|;
block|}
specifier|public
name|String
name|getNamed
parameter_list|()
block|{
return|return
name|named
return|;
block|}
specifier|public
name|void
name|setNamed
parameter_list|(
name|String
name|named
parameter_list|)
block|{
name|this
operator|.
name|named
operator|=
name|named
expr_stmt|;
block|}
specifier|public
name|String
name|getCommand
parameter_list|()
block|{
return|return
name|command
return|;
block|}
class|class
name|CompileProcessorException
extends|extends
name|HiveException
block|{
specifier|private
specifier|static
specifier|final
name|long
name|serialVersionUID
init|=
literal|1L
decl_stmt|;
name|CompileProcessorException
parameter_list|(
name|String
name|s
parameter_list|,
name|Throwable
name|t
parameter_list|)
block|{
name|super
argument_list|(
name|s
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
name|CompileProcessorException
parameter_list|(
name|String
name|s
parameter_list|)
block|{
name|super
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_class

end_unit

