begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|vector
operator|.
name|mapjoin
operator|.
name|fast
package|;
end_package

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|Log
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|LogFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|vector
operator|.
name|mapjoin
operator|.
name|hashtable
operator|.
name|VectorMapJoinHashMapResult
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|WriteBuffers
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|WriteBuffers
operator|.
name|ByteSegmentRef
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|WriteBuffers
operator|.
name|Position
import|;
end_import

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_comment
comment|// Supports random access.
end_comment

begin_class
specifier|public
class|class
name|VectorMapJoinFastValueStore
block|{
specifier|private
specifier|static
specifier|final
name|Log
name|LOG
init|=
name|LogFactory
operator|.
name|getLog
argument_list|(
name|VectorMapJoinFastValueStore
operator|.
name|class
operator|.
name|getName
argument_list|()
argument_list|)
decl_stmt|;
specifier|private
name|WriteBuffers
name|writeBuffers
decl_stmt|;
comment|/**    * A store for "lists" of arbitrary length values in memory.    *    * The memory is a "infinite" byte array or WriteBuffers object.    *    * We give the client a 64-bit (long) value reference to keep that has the offset within    * the "infinite" byte array of the last value inserted in a "list".    *    * We optimize the common case when "list"s are 1 element and values are short and store the    * value length in the value reference word.    *    * We also support keeping a count (up to a limit or cap) so help with join result generation    * algorithms.    *    * If the last value is big, the big length will be encoded as an integer at the beginning    * of the value followed by the big value bytes.    *    * Due to optimizing by keeping the last value's length in the value reference, when we have    * more than one value, a new value will need to keep the small value length of the next    * value.    *    * So, values after the first value have 4 parts: a relative offset word with flags, an    * optional length if the current value is big, an optional next value length if it is small,    * and the value bytes.    *    * Cases:    *  1) One element, small:    *    *    Value Reference -------------    *                                 |    *                                 |    *                                 v    *                                 {Small Value Bytes}    *    *  2) One element, big:    *    *   Value Reference --------------    *                                 |    *                                 |    *                                 v    *                                 {Big Value Len} {Big Value Bytes}    *    *  1) Multiple elements:    *    *    Value Reference ----------------    *                                    |    *                                    |    //  Last value added.    *                                    |    *                                    v    *                                    {Rel Offset Word} [Big Value Len] [Next Value Small Len] {Value Bytes}    *                                             |            optional        optional    *                                             |    *                                             |    *                                --- . . . ---    *                               |    *                               |      // 0 or more    *                               |    *                               v    *                              {Rel Offset Word} [Big Value Len] [Next Value Small Len] {Value Bytes}    *                                         |          optional        optional    *                                         |    *                                         |    *                     --------------------    *                    |    *                    |    *                    v    *                   [Big Value Length] {Value Bytes}    *                       optional    *    *                   // First value added without Relative Offset Word, etc.    */
specifier|public
name|WriteBuffers
name|writeBuffers
parameter_list|()
block|{
return|return
name|writeBuffers
return|;
block|}
specifier|public
specifier|static
class|class
name|HashMapResult
extends|extends
name|VectorMapJoinHashMapResult
block|{
specifier|private
name|VectorMapJoinFastValueStore
name|valueStore
decl_stmt|;
specifier|private
name|boolean
name|hasRows
decl_stmt|;
specifier|private
name|long
name|valueRefWord
decl_stmt|;
specifier|private
name|boolean
name|isSingleRow
decl_stmt|;
specifier|private
name|int
name|cappedCount
decl_stmt|;
specifier|private
name|boolean
name|haveReadCurrent
decl_stmt|;
specifier|private
name|int
name|readIndex
decl_stmt|;
specifier|private
name|boolean
name|isEof
decl_stmt|;
specifier|private
name|boolean
name|isNextEof
decl_stmt|;
specifier|private
name|boolean
name|isNextLast
decl_stmt|;
name|long
name|nextAbsoluteValueOffset
decl_stmt|;
name|boolean
name|isNextValueLengthSmall
decl_stmt|;
name|int
name|nextSmallValueLength
decl_stmt|;
specifier|private
name|ByteSegmentRef
name|byteSegmentRef
decl_stmt|;
specifier|private
name|Position
name|readPos
decl_stmt|;
specifier|public
name|HashMapResult
parameter_list|()
block|{
name|super
argument_list|()
expr_stmt|;
name|valueRefWord
operator|=
operator|-
literal|1
expr_stmt|;
name|hasRows
operator|=
literal|false
expr_stmt|;
name|byteSegmentRef
operator|=
operator|new
name|ByteSegmentRef
argument_list|()
expr_stmt|;
name|readPos
operator|=
operator|new
name|Position
argument_list|()
expr_stmt|;
block|}
specifier|public
name|void
name|set
parameter_list|(
name|VectorMapJoinFastValueStore
name|valueStore
parameter_list|,
name|long
name|valueRefWord
parameter_list|)
block|{
comment|// LOG.debug("VectorMapJoinFastValueStore set valueRefWord " + Long.toHexString(valueRefWord));
name|this
operator|.
name|valueStore
operator|=
name|valueStore
expr_stmt|;
name|this
operator|.
name|valueRefWord
operator|=
name|valueRefWord
expr_stmt|;
name|hasRows
operator|=
literal|true
expr_stmt|;
name|isSingleRow
operator|=
operator|(
operator|(
name|valueRefWord
operator|&
name|IsLastFlag
operator|.
name|flagOnMask
operator|)
operator|!=
literal|0
operator|)
expr_stmt|;
name|cappedCount
operator|=
call|(
name|int
call|)
argument_list|(
operator|(
name|valueRefWord
operator|&
name|CappedCount
operator|.
name|bitMask
operator|)
operator|>>
name|CappedCount
operator|.
name|bitShift
argument_list|)
expr_stmt|;
comment|// Position to beginning.
name|haveReadCurrent
operator|=
literal|false
expr_stmt|;
name|readIndex
operator|=
literal|0
expr_stmt|;
name|isEof
operator|=
literal|false
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|hasRows
parameter_list|()
block|{
return|return
name|hasRows
return|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|isSingleRow
parameter_list|()
block|{
if|if
condition|(
operator|!
name|hasRows
condition|)
block|{
return|return
literal|false
return|;
block|}
return|return
name|isSingleRow
return|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|isCappedCountAvailable
parameter_list|()
block|{
return|return
literal|true
return|;
block|}
annotation|@
name|Override
specifier|public
name|int
name|cappedCount
parameter_list|()
block|{
if|if
condition|(
operator|!
name|hasRows
condition|)
block|{
return|return
literal|0
return|;
block|}
return|return
name|cappedCount
return|;
block|}
annotation|@
name|Override
specifier|public
name|ByteSegmentRef
name|first
parameter_list|()
block|{
if|if
condition|(
operator|!
name|hasRows
condition|)
block|{
return|return
literal|null
return|;
block|}
comment|// Position to beginning.
name|haveReadCurrent
operator|=
literal|false
expr_stmt|;
name|readIndex
operator|=
literal|0
expr_stmt|;
name|isEof
operator|=
literal|false
expr_stmt|;
return|return
name|internalRead
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|ByteSegmentRef
name|next
parameter_list|()
block|{
if|if
condition|(
operator|!
name|hasRows
condition|)
block|{
return|return
literal|null
return|;
block|}
return|return
name|internalRead
argument_list|()
return|;
block|}
specifier|public
name|ByteSegmentRef
name|internalRead
parameter_list|()
block|{
name|long
name|absoluteValueOffset
decl_stmt|;
name|int
name|valueLength
decl_stmt|;
if|if
condition|(
name|readIndex
operator|==
literal|0
condition|)
block|{
comment|/*          * Extract information from reference word from slot table.          */
name|absoluteValueOffset
operator|=
operator|(
name|valueRefWord
operator|&
name|AbsoluteValueOffset
operator|.
name|bitMask
operator|)
expr_stmt|;
comment|// Position before the last written value.
name|valueStore
operator|.
name|writeBuffers
operator|.
name|setReadPoint
argument_list|(
name|absoluteValueOffset
argument_list|,
name|readPos
argument_list|)
expr_stmt|;
if|if
condition|(
name|isSingleRow
condition|)
block|{
name|isNextEof
operator|=
literal|true
expr_stmt|;
name|valueLength
operator|=
call|(
name|int
call|)
argument_list|(
operator|(
name|valueRefWord
operator|&
name|SmallValueLength
operator|.
name|bitMask
operator|)
operator|>>
name|SmallValueLength
operator|.
name|bitShift
argument_list|)
expr_stmt|;
name|boolean
name|isValueLengthSmall
init|=
operator|(
name|valueLength
operator|!=
name|SmallValueLength
operator|.
name|allBitsOn
operator|)
decl_stmt|;
if|if
condition|(
operator|!
name|isValueLengthSmall
condition|)
block|{
comment|// And, if current value is big we must read it.
name|valueLength
operator|=
name|valueStore
operator|.
name|writeBuffers
operator|.
name|readVInt
argument_list|(
name|readPos
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|isNextEof
operator|=
literal|false
expr_stmt|;
comment|// 2nd and beyond records have a relative offset word at the beginning.
name|long
name|relativeOffsetWord
init|=
name|valueStore
operator|.
name|writeBuffers
operator|.
name|readVLong
argument_list|(
name|readPos
argument_list|)
decl_stmt|;
name|long
name|relativeOffset
init|=
operator|(
name|relativeOffsetWord
operator|&
name|NextRelativeValueOffset
operator|.
name|bitMask
operator|)
operator|>>
name|NextRelativeValueOffset
operator|.
name|bitShift
decl_stmt|;
name|nextAbsoluteValueOffset
operator|=
name|absoluteValueOffset
operator|-
name|relativeOffset
expr_stmt|;
name|isNextLast
operator|=
operator|(
operator|(
name|relativeOffsetWord
operator|&
name|IsNextValueLastFlag
operator|.
name|flagOnMask
operator|)
operator|!=
literal|0
operator|)
expr_stmt|;
name|isNextValueLengthSmall
operator|=
operator|(
operator|(
name|relativeOffsetWord
operator|&
name|IsNextValueLengthSmallFlag
operator|.
name|flagOnMask
operator|)
operator|!=
literal|0
operator|)
expr_stmt|;
block|}
name|valueLength
operator|=
call|(
name|int
call|)
argument_list|(
operator|(
name|valueRefWord
operator|&
name|SmallValueLength
operator|.
name|bitMask
operator|)
operator|>>
name|SmallValueLength
operator|.
name|bitShift
argument_list|)
expr_stmt|;
name|boolean
name|isValueLengthSmall
init|=
operator|(
name|valueLength
operator|!=
name|SmallValueLength
operator|.
name|allBitsOn
operator|)
decl_stmt|;
if|if
condition|(
operator|!
name|isValueLengthSmall
condition|)
block|{
comment|// And, if current value is big we must read it.
name|valueLength
operator|=
name|valueStore
operator|.
name|writeBuffers
operator|.
name|readVInt
argument_list|(
name|readPos
argument_list|)
expr_stmt|;
block|}
comment|// 2nd and beyond have the next value's small length in the current record.
if|if
condition|(
name|isNextValueLengthSmall
condition|)
block|{
name|nextSmallValueLength
operator|=
name|valueStore
operator|.
name|writeBuffers
operator|.
name|readVInt
argument_list|(
name|readPos
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|nextSmallValueLength
operator|=
operator|-
literal|1
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|isNextEof
condition|)
block|{
return|return
literal|null
return|;
block|}
name|absoluteValueOffset
operator|=
name|nextAbsoluteValueOffset
expr_stmt|;
comment|// Position before the last written value.
name|valueStore
operator|.
name|writeBuffers
operator|.
name|setReadPoint
argument_list|(
name|absoluteValueOffset
argument_list|,
name|readPos
argument_list|)
expr_stmt|;
if|if
condition|(
name|isNextLast
condition|)
block|{
name|isNextEof
operator|=
literal|true
expr_stmt|;
if|if
condition|(
name|isNextValueLengthSmall
condition|)
block|{
name|valueLength
operator|=
name|nextSmallValueLength
expr_stmt|;
block|}
else|else
block|{
name|valueLength
operator|=
operator|(
name|int
operator|)
name|valueStore
operator|.
name|writeBuffers
operator|.
name|readVLong
argument_list|(
name|readPos
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|isNextEof
operator|=
literal|false
expr_stmt|;
comment|// 2nd and beyond records have a relative offset word at the beginning.
name|long
name|relativeOffsetWord
init|=
name|valueStore
operator|.
name|writeBuffers
operator|.
name|readVLong
argument_list|(
name|readPos
argument_list|)
decl_stmt|;
comment|// Read current value's big length now, if necessary.
if|if
condition|(
name|isNextValueLengthSmall
condition|)
block|{
name|valueLength
operator|=
name|nextSmallValueLength
expr_stmt|;
block|}
else|else
block|{
name|valueLength
operator|=
operator|(
name|int
operator|)
name|valueStore
operator|.
name|writeBuffers
operator|.
name|readVLong
argument_list|(
name|readPos
argument_list|)
expr_stmt|;
block|}
name|long
name|relativeOffset
init|=
operator|(
name|relativeOffsetWord
operator|&
name|NextRelativeValueOffset
operator|.
name|bitMask
operator|)
operator|>>
name|NextRelativeValueOffset
operator|.
name|bitShift
decl_stmt|;
name|nextAbsoluteValueOffset
operator|=
name|absoluteValueOffset
operator|-
name|relativeOffset
expr_stmt|;
name|isNextLast
operator|=
operator|(
operator|(
name|relativeOffsetWord
operator|&
name|IsNextValueLastFlag
operator|.
name|flagOnMask
operator|)
operator|!=
literal|0
operator|)
expr_stmt|;
name|isNextValueLengthSmall
operator|=
operator|(
operator|(
name|relativeOffsetWord
operator|&
name|IsNextValueLengthSmallFlag
operator|.
name|flagOnMask
operator|)
operator|!=
literal|0
operator|)
expr_stmt|;
if|if
condition|(
name|isNextValueLengthSmall
condition|)
block|{
comment|// TODO: Write readVInt
name|nextSmallValueLength
operator|=
operator|(
name|int
operator|)
name|valueStore
operator|.
name|writeBuffers
operator|.
name|readVLong
argument_list|(
name|readPos
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|nextSmallValueLength
operator|=
operator|-
literal|1
expr_stmt|;
block|}
block|}
block|}
comment|// Our reading is positioned to the value.
name|valueStore
operator|.
name|writeBuffers
operator|.
name|getByteSegmentRefToCurrent
argument_list|(
name|byteSegmentRef
argument_list|,
name|valueLength
argument_list|,
name|readPos
argument_list|)
expr_stmt|;
name|readIndex
operator|++
expr_stmt|;
return|return
name|byteSegmentRef
return|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|isEof
parameter_list|()
block|{
if|if
condition|(
operator|!
name|hasRows
condition|)
block|{
return|return
literal|true
return|;
block|}
return|return
name|isEof
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|forget
parameter_list|()
block|{     }
annotation|@
name|Override
specifier|public
name|String
name|toString
parameter_list|()
block|{
name|StringBuilder
name|sb
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|"("
operator|+
name|super
operator|.
name|toString
argument_list|()
operator|+
literal|", "
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|"cappedCount "
operator|+
name|cappedCount
argument_list|()
operator|+
literal|")"
argument_list|)
expr_stmt|;
return|return
name|sb
operator|.
name|toString
argument_list|()
return|;
block|}
block|}
comment|/**    * Bit-length fields within a 64-bit (long) value reference.    *    * Lowest field: An absolute byte offset the value in the WriteBuffers.    *    * 2nd field: For short values, the length of the value.  Otherwise, a special constant    * indicating a big value whose length is stored with the value.    *    * 3rd field: A value count, up to a limit (a cap).  Have a count helps the join result    * algorithms determine which optimization to use for M x N result cross products.    * A special constant indicates if the value count is>= the cap.    *    * Last field: an bit indicating whether there is only one value.    */
comment|// Lowest field.
specifier|private
specifier|final
class|class
name|AbsoluteValueOffset
block|{
specifier|private
specifier|static
specifier|final
name|int
name|bitLength
init|=
literal|40
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|long
name|allBitsOn
init|=
operator|(
literal|1L
operator|<<
name|bitLength
operator|)
operator|-
literal|1
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|long
name|bitMask
init|=
name|allBitsOn
decl_stmt|;
comment|// Make it a power of 2.
specifier|private
specifier|static
specifier|final
name|long
name|maxSize
init|=
literal|1L
operator|<<
operator|(
name|bitLength
operator|-
literal|2
operator|)
decl_stmt|;
block|}
specifier|private
specifier|final
class|class
name|SmallValueLength
block|{
specifier|private
specifier|static
specifier|final
name|int
name|bitLength
init|=
literal|10
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|int
name|allBitsOn
init|=
operator|(
literal|1
operator|<<
name|bitLength
operator|)
operator|-
literal|1
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|int
name|threshold
init|=
name|allBitsOn
decl_stmt|;
comment|// Lower this for big value testing.
specifier|private
specifier|static
specifier|final
name|int
name|bitShift
init|=
name|AbsoluteValueOffset
operator|.
name|bitLength
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|long
name|bitMask
init|=
operator|(
operator|(
name|long
operator|)
name|allBitsOn
operator|)
operator|<<
name|bitShift
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|long
name|allBitsOnBitShifted
init|=
operator|(
operator|(
name|long
operator|)
name|allBitsOn
operator|)
operator|<<
name|bitShift
decl_stmt|;
block|}
specifier|private
specifier|final
class|class
name|CappedCount
block|{
specifier|private
specifier|static
specifier|final
name|int
name|bitLength
init|=
literal|10
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|int
name|allBitsOn
init|=
operator|(
literal|1
operator|<<
name|bitLength
operator|)
operator|-
literal|1
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|int
name|limit
init|=
name|allBitsOn
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|int
name|bitShift
init|=
name|SmallValueLength
operator|.
name|bitShift
operator|+
name|SmallValueLength
operator|.
name|bitLength
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|long
name|bitMask
init|=
operator|(
operator|(
name|long
operator|)
name|allBitsOn
operator|)
operator|<<
name|bitShift
decl_stmt|;
block|}
specifier|private
specifier|final
class|class
name|IsLastFlag
block|{
specifier|private
specifier|static
specifier|final
name|int
name|bitShift
init|=
name|CappedCount
operator|.
name|bitShift
operator|+
name|CappedCount
operator|.
name|bitLength
decl_stmt|;
empty_stmt|;
specifier|private
specifier|static
specifier|final
name|long
name|flagOnMask
init|=
literal|1L
operator|<<
name|bitShift
decl_stmt|;
block|}
comment|// This bit should not be on for valid value references.  We use -1 for a no value marker.
specifier|private
specifier|final
class|class
name|IsInvalidFlag
block|{
specifier|private
specifier|static
specifier|final
name|int
name|bitShift
init|=
literal|63
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|long
name|flagOnMask
init|=
literal|1L
operator|<<
name|bitShift
decl_stmt|;
block|}
comment|/**    * Relative Offset Word stored at the beginning of all but the last value that has a    * relative offset and 2 flags.    *    * We put the flags at the low end of the word so the variable length integer will    * encode smaller.    *    * First bit is a flag indicating if the next value (not the current value) has a small length.    * When the first value is added and it has a small length, that length is stored in the    * value reference and not with the value.  So, when we have multiple values, we need a way to    * know to keep the next value's small length with the current value.    *    * Second bit is a flag indicating if the next value (not the current value) is the last value.    *    * The relative offset *backwards* to the next value.    */
specifier|private
specifier|final
class|class
name|IsNextValueLengthSmallFlag
block|{
specifier|private
specifier|static
specifier|final
name|int
name|bitLength
init|=
literal|1
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|long
name|flagOnMask
init|=
literal|1L
decl_stmt|;
block|}
specifier|private
specifier|final
class|class
name|IsNextValueLastFlag
block|{
specifier|private
specifier|static
specifier|final
name|int
name|bitLength
init|=
literal|1
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|int
name|bitShift
init|=
name|IsNextValueLengthSmallFlag
operator|.
name|bitLength
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|long
name|flagOnMask
init|=
literal|1L
operator|<<
name|bitShift
decl_stmt|;
block|}
specifier|private
specifier|final
class|class
name|NextRelativeValueOffset
block|{
specifier|private
specifier|static
specifier|final
name|int
name|bitLength
init|=
literal|40
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|long
name|allBitsOn
init|=
operator|(
literal|1L
operator|<<
name|bitLength
operator|)
operator|-
literal|1
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|int
name|bitShift
init|=
name|IsNextValueLastFlag
operator|.
name|bitShift
operator|+
name|IsNextValueLastFlag
operator|.
name|bitLength
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|long
name|bitMask
init|=
name|allBitsOn
operator|<<
name|bitShift
decl_stmt|;
block|}
specifier|public
name|long
name|addFirst
parameter_list|(
name|byte
index|[]
name|valueBytes
parameter_list|,
name|int
name|valueStart
parameter_list|,
name|int
name|valueLength
parameter_list|)
block|{
comment|// First value is written without: next relative offset, next value length, is next value last
comment|// flag, is next value length small flag, etc.
comment|/*      * We build up the Value Reference Word we will return that will be kept by the caller.      */
name|long
name|valueRefWord
init|=
name|IsLastFlag
operator|.
name|flagOnMask
decl_stmt|;
name|valueRefWord
operator||=
operator|(
operator|(
name|long
operator|)
literal|1
operator|<<
name|CappedCount
operator|.
name|bitShift
operator|)
expr_stmt|;
name|long
name|newAbsoluteOffset
decl_stmt|;
if|if
condition|(
name|valueLength
operator|<
name|SmallValueLength
operator|.
name|threshold
condition|)
block|{
comment|// Small case: Just write the value bytes only.
if|if
condition|(
name|valueLength
operator|==
literal|0
condition|)
block|{
comment|// We don't write a first empty value.
comment|// Get an offset to reduce the relative offset later if there are more than 1 value.
name|newAbsoluteOffset
operator|=
name|writeBuffers
operator|.
name|getWritePoint
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|newAbsoluteOffset
operator|=
name|writeBuffers
operator|.
name|getWritePoint
argument_list|()
expr_stmt|;
name|writeBuffers
operator|.
name|write
argument_list|(
name|valueBytes
argument_list|,
name|valueStart
argument_list|,
name|valueLength
argument_list|)
expr_stmt|;
block|}
comment|// The caller remembers the small value length.
name|valueRefWord
operator||=
operator|(
operator|(
name|long
operator|)
name|valueLength
operator|)
operator|<<
name|SmallValueLength
operator|.
name|bitShift
expr_stmt|;
block|}
else|else
block|{
comment|// Big case: write the length as a VInt and then the value bytes.
name|newAbsoluteOffset
operator|=
name|writeBuffers
operator|.
name|getWritePoint
argument_list|()
expr_stmt|;
name|writeBuffers
operator|.
name|writeVInt
argument_list|(
name|valueLength
argument_list|)
expr_stmt|;
name|writeBuffers
operator|.
name|write
argument_list|(
name|valueBytes
argument_list|,
name|valueStart
argument_list|,
name|valueLength
argument_list|)
expr_stmt|;
comment|// Use magic length value to indicate big.
name|valueRefWord
operator||=
name|SmallValueLength
operator|.
name|allBitsOnBitShifted
expr_stmt|;
block|}
comment|// LOG.debug("VectorMapJoinFastValueStore addFirst valueLength " + valueLength + " newAbsoluteOffset " + newAbsoluteOffset + " valueRefWord " + Long.toHexString(valueRefWord));
comment|// The lower bits are the absolute value offset.
name|valueRefWord
operator||=
name|newAbsoluteOffset
expr_stmt|;
return|return
name|valueRefWord
return|;
block|}
specifier|public
name|long
name|addMore
parameter_list|(
name|long
name|oldValueRef
parameter_list|,
name|byte
index|[]
name|valueBytes
parameter_list|,
name|int
name|valueStart
parameter_list|,
name|int
name|valueLength
parameter_list|)
block|{
if|if
condition|(
operator|(
name|oldValueRef
operator|&
name|IsInvalidFlag
operator|.
name|flagOnMask
operator|)
operator|!=
literal|0
condition|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Invalid optimized hash table reference"
argument_list|)
throw|;
block|}
comment|/*      * Extract information about the old value.      */
name|long
name|oldAbsoluteValueOffset
init|=
operator|(
name|oldValueRef
operator|&
name|AbsoluteValueOffset
operator|.
name|bitMask
operator|)
decl_stmt|;
name|int
name|oldSmallValueLength
init|=
call|(
name|int
call|)
argument_list|(
operator|(
name|oldValueRef
operator|&
name|SmallValueLength
operator|.
name|bitMask
operator|)
operator|>>
name|SmallValueLength
operator|.
name|bitShift
argument_list|)
decl_stmt|;
name|boolean
name|isOldValueLengthSmall
init|=
operator|(
name|oldSmallValueLength
operator|!=
name|SmallValueLength
operator|.
name|allBitsOn
operator|)
decl_stmt|;
name|int
name|oldCappedCount
init|=
call|(
name|int
call|)
argument_list|(
operator|(
name|oldValueRef
operator|&
name|CappedCount
operator|.
name|bitMask
operator|)
operator|>>
name|CappedCount
operator|.
name|bitShift
argument_list|)
decl_stmt|;
name|boolean
name|isOldValueLast
init|=
operator|(
operator|(
name|oldValueRef
operator|&
name|IsLastFlag
operator|.
name|flagOnMask
operator|)
operator|!=
literal|0
operator|)
decl_stmt|;
comment|// LOG.debug("VectorMapJoinFastValueStore addMore isOldValueLast " + isOldValueLast + " oldSmallValueLength " + oldSmallValueLength + " oldAbsoluteValueOffset " + oldAbsoluteValueOffset + " oldValueRef " + Long.toHexString(oldValueRef));
comment|/*      * Write information about the old value (which becomes our next) at the beginning      * of our new value.      */
name|long
name|newAbsoluteOffset
init|=
name|writeBuffers
operator|.
name|getWritePoint
argument_list|()
decl_stmt|;
name|long
name|relativeOffsetWord
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|isOldValueLengthSmall
condition|)
block|{
name|relativeOffsetWord
operator||=
name|IsNextValueLengthSmallFlag
operator|.
name|flagOnMask
expr_stmt|;
block|}
if|if
condition|(
name|isOldValueLast
condition|)
block|{
name|relativeOffsetWord
operator||=
name|IsNextValueLastFlag
operator|.
name|flagOnMask
expr_stmt|;
block|}
name|int
name|newCappedCount
init|=
name|oldCappedCount
decl_stmt|;
if|if
condition|(
name|newCappedCount
operator|<
name|CappedCount
operator|.
name|limit
condition|)
block|{
name|newCappedCount
operator|++
expr_stmt|;
block|}
name|long
name|relativeOffset
init|=
name|newAbsoluteOffset
operator|-
name|oldAbsoluteValueOffset
decl_stmt|;
name|relativeOffsetWord
operator||=
operator|(
name|relativeOffset
operator|<<
name|NextRelativeValueOffset
operator|.
name|bitShift
operator|)
expr_stmt|;
name|writeBuffers
operator|.
name|writeVLong
argument_list|(
name|relativeOffsetWord
argument_list|)
expr_stmt|;
comment|// When the next value is small it was not recorded with the old (i.e. next) value and we
comment|// have to remember it.
if|if
condition|(
name|isOldValueLengthSmall
condition|)
block|{
name|writeBuffers
operator|.
name|writeVInt
argument_list|(
name|oldSmallValueLength
argument_list|)
expr_stmt|;
block|}
comment|// Now, we have written all information about the next value, work on the *new* value.
name|long
name|newValueRef
init|=
operator|(
operator|(
name|long
operator|)
name|newCappedCount
operator|)
operator|<<
name|CappedCount
operator|.
name|bitShift
decl_stmt|;
name|boolean
name|isNewValueSmall
init|=
operator|(
name|valueLength
operator|<
name|SmallValueLength
operator|.
name|threshold
operator|)
decl_stmt|;
if|if
condition|(
operator|!
name|isNewValueSmall
condition|)
block|{
comment|// Use magic value to indicating we are writing the big value length.
name|newValueRef
operator||=
operator|(
operator|(
name|long
operator|)
name|SmallValueLength
operator|.
name|allBitsOn
operator|<<
name|SmallValueLength
operator|.
name|bitShift
operator|)
expr_stmt|;
name|writeBuffers
operator|.
name|writeVInt
argument_list|(
name|valueLength
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// Caller must remember small value length.
name|newValueRef
operator||=
operator|(
operator|(
name|long
operator|)
name|valueLength
operator|)
operator|<<
name|SmallValueLength
operator|.
name|bitShift
expr_stmt|;
block|}
name|writeBuffers
operator|.
name|write
argument_list|(
name|valueBytes
argument_list|,
name|valueStart
argument_list|,
name|valueLength
argument_list|)
expr_stmt|;
comment|// The lower bits are the absolute value offset.
name|newValueRef
operator||=
name|newAbsoluteOffset
expr_stmt|;
comment|// LOG.debug("VectorMapJoinFastValueStore addMore valueLength " + valueLength + " newAbsoluteOffset " + newAbsoluteOffset + " newValueRef " + Long.toHexString(newValueRef));
return|return
name|newValueRef
return|;
block|}
specifier|public
name|VectorMapJoinFastValueStore
parameter_list|(
name|int
name|writeBuffersSize
parameter_list|)
block|{
name|writeBuffers
operator|=
operator|new
name|WriteBuffers
argument_list|(
name|writeBuffersSize
argument_list|,
name|AbsoluteValueOffset
operator|.
name|maxSize
argument_list|)
expr_stmt|;
block|}
block|}
end_class

end_unit

