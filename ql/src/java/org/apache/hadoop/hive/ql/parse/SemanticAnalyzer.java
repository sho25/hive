begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|parse
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|Serializable
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|URI
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|LinkedHashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
operator|.
name|Entry
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|TreeSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|regex
operator|.
name|Pattern
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|regex
operator|.
name|PatternSyntaxException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|antlr
operator|.
name|runtime
operator|.
name|tree
operator|.
name|BaseTree
import|;
end_import

begin_import
import|import
name|org
operator|.
name|antlr
operator|.
name|runtime
operator|.
name|tree
operator|.
name|Tree
import|;
end_import

begin_import
import|import
name|org
operator|.
name|antlr
operator|.
name|runtime
operator|.
name|tree
operator|.
name|TreeWizard
import|;
end_import

begin_import
import|import
name|org
operator|.
name|antlr
operator|.
name|runtime
operator|.
name|tree
operator|.
name|TreeWizard
operator|.
name|ContextVisitor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|lang
operator|.
name|StringUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|Path
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|common
operator|.
name|FileUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|common
operator|.
name|JavaUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|common
operator|.
name|ObjectPair
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|conf
operator|.
name|HiveConf
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|conf
operator|.
name|HiveConf
operator|.
name|ConfVars
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|metastore
operator|.
name|TableType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|metastore
operator|.
name|Warehouse
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|metastore
operator|.
name|api
operator|.
name|FieldSchema
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|metastore
operator|.
name|api
operator|.
name|MetaException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|metastore
operator|.
name|api
operator|.
name|Order
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|ErrorMsg
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|QueryProperties
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|AbstractMapJoinOperator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|ArchiveUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|ColumnInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|FileSinkOperator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|FunctionInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|FunctionRegistry
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|GroupByOperator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|JoinOperator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|Operator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|OperatorFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|RecordReader
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|RecordWriter
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|ReduceSinkOperator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|RowSchema
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|SMBMapJoinOperator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|TableScanOperator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|Task
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|TaskFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|UnionOperator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|Utilities
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|hooks
operator|.
name|ReadEntity
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|hooks
operator|.
name|WriteEntity
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|io
operator|.
name|CombineHiveInputFormat
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|io
operator|.
name|HiveOutputFormat
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|io
operator|.
name|RCFileInputFormat
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|lib
operator|.
name|DefaultGraphWalker
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|lib
operator|.
name|Dispatcher
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|lib
operator|.
name|GraphWalker
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|lib
operator|.
name|Node
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|metadata
operator|.
name|DummyPartition
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|metadata
operator|.
name|Hive
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|metadata
operator|.
name|HiveException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|metadata
operator|.
name|HiveUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|metadata
operator|.
name|InvalidTableException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|metadata
operator|.
name|Partition
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|metadata
operator|.
name|Table
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|metadata
operator|.
name|VirtualColumn
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|optimizer
operator|.
name|Optimizer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|optimizer
operator|.
name|unionproc
operator|.
name|UnionProcContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|parse
operator|.
name|BaseSemanticAnalyzer
operator|.
name|tableSpec
operator|.
name|SpecType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|parse
operator|.
name|PTFInvocationSpec
operator|.
name|OrderExpression
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|parse
operator|.
name|PTFInvocationSpec
operator|.
name|OrderSpec
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|parse
operator|.
name|PTFInvocationSpec
operator|.
name|PTFInputSpec
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|parse
operator|.
name|PTFInvocationSpec
operator|.
name|PTFQueryInputSpec
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|parse
operator|.
name|PTFInvocationSpec
operator|.
name|PTFQueryInputType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|parse
operator|.
name|PTFInvocationSpec
operator|.
name|PartitionExpression
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|parse
operator|.
name|PTFInvocationSpec
operator|.
name|PartitionSpec
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|parse
operator|.
name|PTFInvocationSpec
operator|.
name|PartitionedTableFunctionSpec
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|parse
operator|.
name|PTFInvocationSpec
operator|.
name|PartitioningSpec
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|parse
operator|.
name|QBSubQuery
operator|.
name|SubQueryType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|parse
operator|.
name|SubQueryUtils
operator|.
name|ISubQueryJoinInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|parse
operator|.
name|WindowingSpec
operator|.
name|BoundarySpec
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|parse
operator|.
name|WindowingSpec
operator|.
name|CurrentRowSpec
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|parse
operator|.
name|WindowingSpec
operator|.
name|Direction
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|parse
operator|.
name|WindowingSpec
operator|.
name|RangeBoundarySpec
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|parse
operator|.
name|WindowingSpec
operator|.
name|ValueBoundarySpec
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|parse
operator|.
name|WindowingSpec
operator|.
name|WindowExpressionSpec
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|parse
operator|.
name|WindowingSpec
operator|.
name|WindowFrameSpec
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|parse
operator|.
name|WindowingSpec
operator|.
name|WindowFunctionSpec
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|parse
operator|.
name|WindowingSpec
operator|.
name|WindowSpec
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|AggregationDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|CreateTableDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|CreateTableLikeDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|CreateViewDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|DDLWork
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|DynamicPartitionCtx
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|ExprNodeColumnDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|ExprNodeColumnListDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|ExprNodeConstantDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|ExprNodeDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|ExprNodeDescUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|ExprNodeGenericFuncDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|ExprNodeNullDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|ExtractDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|FileSinkDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|FilterDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|FilterDesc
operator|.
name|sampleDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|ForwardDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|GroupByDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|HiveOperation
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|JoinCondDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|JoinDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|LateralViewForwardDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|LateralViewJoinDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|LimitDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|ListBucketingCtx
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|LoadFileDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|LoadTableDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|MapJoinDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|OperatorDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|PTFDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|PlanUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|ReduceSinkDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|ScriptDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|SelectDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|TableDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|TableScanDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|UDTFDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|UnionDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|ptf
operator|.
name|OrderExpressionDef
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|ptf
operator|.
name|PTFExpressionDef
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|ptf
operator|.
name|PartitionedTableFunctionDef
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|session
operator|.
name|SessionState
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|session
operator|.
name|SessionState
operator|.
name|ResourceType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|stats
operator|.
name|StatsFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|udf
operator|.
name|generic
operator|.
name|GenericUDAFEvaluator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|udf
operator|.
name|generic
operator|.
name|GenericUDAFEvaluator
operator|.
name|Mode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|udf
operator|.
name|generic
operator|.
name|GenericUDFHash
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|udf
operator|.
name|generic
operator|.
name|GenericUDFOPOr
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|udf
operator|.
name|generic
operator|.
name|GenericUDTF
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde
operator|.
name|serdeConstants
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|Deserializer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|MetadataTypedColumnsetSerDe
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|SerDeException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|lazy
operator|.
name|LazySimpleSerDe
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|objectinspector
operator|.
name|ConstantObjectInspector
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|objectinspector
operator|.
name|ObjectInspector
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|objectinspector
operator|.
name|ObjectInspector
operator|.
name|Category
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|objectinspector
operator|.
name|ObjectInspectorFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|objectinspector
operator|.
name|StandardStructObjectInspector
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|objectinspector
operator|.
name|StructField
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|objectinspector
operator|.
name|StructObjectInspector
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|typeinfo
operator|.
name|PrimitiveTypeInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|typeinfo
operator|.
name|TypeInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|typeinfo
operator|.
name|TypeInfoFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|typeinfo
operator|.
name|TypeInfoUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapred
operator|.
name|InputFormat
import|;
end_import

begin_comment
comment|/**  * Implementation of the semantic analyzer.  */
end_comment

begin_class
specifier|public
class|class
name|SemanticAnalyzer
extends|extends
name|BaseSemanticAnalyzer
block|{
specifier|private
name|HashMap
argument_list|<
name|TableScanOperator
argument_list|,
name|ExprNodeDesc
argument_list|>
name|opToPartPruner
decl_stmt|;
specifier|private
name|HashMap
argument_list|<
name|TableScanOperator
argument_list|,
name|PrunedPartitionList
argument_list|>
name|opToPartList
decl_stmt|;
specifier|private
name|HashMap
argument_list|<
name|String
argument_list|,
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
argument_list|>
name|topOps
decl_stmt|;
specifier|private
name|HashMap
argument_list|<
name|String
argument_list|,
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
argument_list|>
name|topSelOps
decl_stmt|;
specifier|private
name|LinkedHashMap
argument_list|<
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
argument_list|,
name|OpParseContext
argument_list|>
name|opParseCtx
decl_stmt|;
specifier|private
name|List
argument_list|<
name|LoadTableDesc
argument_list|>
name|loadTableWork
decl_stmt|;
specifier|private
name|List
argument_list|<
name|LoadFileDesc
argument_list|>
name|loadFileWork
decl_stmt|;
specifier|private
name|Map
argument_list|<
name|JoinOperator
argument_list|,
name|QBJoinTree
argument_list|>
name|joinContext
decl_stmt|;
specifier|private
name|Map
argument_list|<
name|SMBMapJoinOperator
argument_list|,
name|QBJoinTree
argument_list|>
name|smbMapJoinContext
decl_stmt|;
specifier|private
specifier|final
name|HashMap
argument_list|<
name|TableScanOperator
argument_list|,
name|Table
argument_list|>
name|topToTable
decl_stmt|;
specifier|private
specifier|final
name|Map
argument_list|<
name|FileSinkOperator
argument_list|,
name|Table
argument_list|>
name|fsopToTable
decl_stmt|;
specifier|private
specifier|final
name|List
argument_list|<
name|ReduceSinkOperator
argument_list|>
name|reduceSinkOperatorsAddedByEnforceBucketingSorting
decl_stmt|;
specifier|private
specifier|final
name|HashMap
argument_list|<
name|TableScanOperator
argument_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
argument_list|>
name|topToTableProps
decl_stmt|;
specifier|private
name|QB
name|qb
decl_stmt|;
specifier|private
name|ASTNode
name|ast
decl_stmt|;
specifier|private
name|int
name|destTableId
decl_stmt|;
specifier|private
name|UnionProcContext
name|uCtx
decl_stmt|;
name|List
argument_list|<
name|AbstractMapJoinOperator
argument_list|<
name|?
extends|extends
name|MapJoinDesc
argument_list|>
argument_list|>
name|listMapJoinOpsNoReducer
decl_stmt|;
specifier|private
name|HashMap
argument_list|<
name|TableScanOperator
argument_list|,
name|sampleDesc
argument_list|>
name|opToSamplePruner
decl_stmt|;
specifier|private
specifier|final
name|Map
argument_list|<
name|TableScanOperator
argument_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|ExprNodeDesc
argument_list|>
argument_list|>
name|opToPartToSkewedPruner
decl_stmt|;
comment|/**    * a map for the split sampling, from ailias to an instance of SplitSample    * that describes percentage and number.    */
specifier|private
specifier|final
name|HashMap
argument_list|<
name|String
argument_list|,
name|SplitSample
argument_list|>
name|nameToSplitSample
decl_stmt|;
name|Map
argument_list|<
name|GroupByOperator
argument_list|,
name|Set
argument_list|<
name|String
argument_list|>
argument_list|>
name|groupOpToInputTables
decl_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|PrunedPartitionList
argument_list|>
name|prunedPartitions
decl_stmt|;
specifier|private
name|List
argument_list|<
name|FieldSchema
argument_list|>
name|resultSchema
decl_stmt|;
specifier|private
name|CreateViewDesc
name|createVwDesc
decl_stmt|;
specifier|private
name|ArrayList
argument_list|<
name|String
argument_list|>
name|viewsExpanded
decl_stmt|;
specifier|private
name|ASTNode
name|viewSelect
decl_stmt|;
specifier|private
specifier|final
name|UnparseTranslator
name|unparseTranslator
decl_stmt|;
specifier|private
specifier|final
name|GlobalLimitCtx
name|globalLimitCtx
init|=
operator|new
name|GlobalLimitCtx
argument_list|()
decl_stmt|;
comment|// prefix for column names auto generated by hive
specifier|private
specifier|final
name|String
name|autogenColAliasPrfxLbl
decl_stmt|;
specifier|private
specifier|final
name|boolean
name|autogenColAliasPrfxIncludeFuncName
decl_stmt|;
comment|// Keep track of view alias to read entity corresponding to the view
comment|// For eg: for a query like 'select * from V3', where V3 -> V2, V2 -> V1, V1 -> T
comment|// keeps track of aliases for V3, V3:V2, V3:V2:V1.
comment|// This is used when T is added as an input for the query, the parents of T is
comment|// derived from the alias V3:V2:V1:T
specifier|private
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|ReadEntity
argument_list|>
name|viewAliasToInput
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|ReadEntity
argument_list|>
argument_list|()
decl_stmt|;
comment|// Max characters when auto generating the column name with func name
specifier|private
specifier|static
specifier|final
name|int
name|AUTOGEN_COLALIAS_PRFX_MAXLENGTH
init|=
literal|20
decl_stmt|;
comment|// flag for no scan during analyze ... compute statistics
specifier|protected
name|boolean
name|noscan
init|=
literal|false
decl_stmt|;
comment|//flag for partial scan during analyze ... compute statistics
specifier|protected
name|boolean
name|partialscan
init|=
literal|false
decl_stmt|;
specifier|private
specifier|static
class|class
name|Phase1Ctx
block|{
name|String
name|dest
decl_stmt|;
name|int
name|nextNum
decl_stmt|;
block|}
specifier|public
name|SemanticAnalyzer
parameter_list|(
name|HiveConf
name|conf
parameter_list|)
throws|throws
name|SemanticException
block|{
name|super
argument_list|(
name|conf
argument_list|)
expr_stmt|;
name|opToPartPruner
operator|=
operator|new
name|HashMap
argument_list|<
name|TableScanOperator
argument_list|,
name|ExprNodeDesc
argument_list|>
argument_list|()
expr_stmt|;
name|opToPartList
operator|=
operator|new
name|HashMap
argument_list|<
name|TableScanOperator
argument_list|,
name|PrunedPartitionList
argument_list|>
argument_list|()
expr_stmt|;
name|opToSamplePruner
operator|=
operator|new
name|HashMap
argument_list|<
name|TableScanOperator
argument_list|,
name|sampleDesc
argument_list|>
argument_list|()
expr_stmt|;
name|nameToSplitSample
operator|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|SplitSample
argument_list|>
argument_list|()
expr_stmt|;
name|topOps
operator|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
argument_list|>
argument_list|()
expr_stmt|;
name|topSelOps
operator|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
argument_list|>
argument_list|()
expr_stmt|;
name|loadTableWork
operator|=
operator|new
name|ArrayList
argument_list|<
name|LoadTableDesc
argument_list|>
argument_list|()
expr_stmt|;
name|loadFileWork
operator|=
operator|new
name|ArrayList
argument_list|<
name|LoadFileDesc
argument_list|>
argument_list|()
expr_stmt|;
name|opParseCtx
operator|=
operator|new
name|LinkedHashMap
argument_list|<
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
argument_list|,
name|OpParseContext
argument_list|>
argument_list|()
expr_stmt|;
name|joinContext
operator|=
operator|new
name|HashMap
argument_list|<
name|JoinOperator
argument_list|,
name|QBJoinTree
argument_list|>
argument_list|()
expr_stmt|;
name|smbMapJoinContext
operator|=
operator|new
name|HashMap
argument_list|<
name|SMBMapJoinOperator
argument_list|,
name|QBJoinTree
argument_list|>
argument_list|()
expr_stmt|;
name|topToTable
operator|=
operator|new
name|HashMap
argument_list|<
name|TableScanOperator
argument_list|,
name|Table
argument_list|>
argument_list|()
expr_stmt|;
name|fsopToTable
operator|=
operator|new
name|HashMap
argument_list|<
name|FileSinkOperator
argument_list|,
name|Table
argument_list|>
argument_list|()
expr_stmt|;
name|reduceSinkOperatorsAddedByEnforceBucketingSorting
operator|=
operator|new
name|ArrayList
argument_list|<
name|ReduceSinkOperator
argument_list|>
argument_list|()
expr_stmt|;
name|topToTableProps
operator|=
operator|new
name|HashMap
argument_list|<
name|TableScanOperator
argument_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
argument_list|>
argument_list|()
expr_stmt|;
name|destTableId
operator|=
literal|1
expr_stmt|;
name|uCtx
operator|=
literal|null
expr_stmt|;
name|listMapJoinOpsNoReducer
operator|=
operator|new
name|ArrayList
argument_list|<
name|AbstractMapJoinOperator
argument_list|<
name|?
extends|extends
name|MapJoinDesc
argument_list|>
argument_list|>
argument_list|()
expr_stmt|;
name|groupOpToInputTables
operator|=
operator|new
name|HashMap
argument_list|<
name|GroupByOperator
argument_list|,
name|Set
argument_list|<
name|String
argument_list|>
argument_list|>
argument_list|()
expr_stmt|;
name|prunedPartitions
operator|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|PrunedPartitionList
argument_list|>
argument_list|()
expr_stmt|;
name|unparseTranslator
operator|=
operator|new
name|UnparseTranslator
argument_list|(
name|conf
argument_list|)
expr_stmt|;
name|autogenColAliasPrfxLbl
operator|=
name|HiveConf
operator|.
name|getVar
argument_list|(
name|conf
argument_list|,
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVE_AUTOGEN_COLUMNALIAS_PREFIX_LABEL
argument_list|)
expr_stmt|;
name|autogenColAliasPrfxIncludeFuncName
operator|=
name|HiveConf
operator|.
name|getBoolVar
argument_list|(
name|conf
argument_list|,
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVE_AUTOGEN_COLUMNALIAS_PREFIX_INCLUDEFUNCNAME
argument_list|)
expr_stmt|;
name|queryProperties
operator|=
operator|new
name|QueryProperties
argument_list|()
expr_stmt|;
name|opToPartToSkewedPruner
operator|=
operator|new
name|HashMap
argument_list|<
name|TableScanOperator
argument_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|ExprNodeDesc
argument_list|>
argument_list|>
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Override
specifier|protected
name|void
name|reset
parameter_list|()
block|{
name|super
operator|.
name|reset
argument_list|()
expr_stmt|;
name|loadTableWork
operator|.
name|clear
argument_list|()
expr_stmt|;
name|loadFileWork
operator|.
name|clear
argument_list|()
expr_stmt|;
name|topOps
operator|.
name|clear
argument_list|()
expr_stmt|;
name|topSelOps
operator|.
name|clear
argument_list|()
expr_stmt|;
name|destTableId
operator|=
literal|1
expr_stmt|;
name|idToTableNameMap
operator|.
name|clear
argument_list|()
expr_stmt|;
name|qb
operator|=
literal|null
expr_stmt|;
name|ast
operator|=
literal|null
expr_stmt|;
name|uCtx
operator|=
literal|null
expr_stmt|;
name|joinContext
operator|.
name|clear
argument_list|()
expr_stmt|;
name|smbMapJoinContext
operator|.
name|clear
argument_list|()
expr_stmt|;
name|opParseCtx
operator|.
name|clear
argument_list|()
expr_stmt|;
name|groupOpToInputTables
operator|.
name|clear
argument_list|()
expr_stmt|;
name|prunedPartitions
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
specifier|public
name|void
name|initParseCtx
parameter_list|(
name|ParseContext
name|pctx
parameter_list|)
block|{
name|opToPartPruner
operator|=
name|pctx
operator|.
name|getOpToPartPruner
argument_list|()
expr_stmt|;
name|opToPartList
operator|=
name|pctx
operator|.
name|getOpToPartList
argument_list|()
expr_stmt|;
name|opToSamplePruner
operator|=
name|pctx
operator|.
name|getOpToSamplePruner
argument_list|()
expr_stmt|;
name|topOps
operator|=
name|pctx
operator|.
name|getTopOps
argument_list|()
expr_stmt|;
name|topSelOps
operator|=
name|pctx
operator|.
name|getTopSelOps
argument_list|()
expr_stmt|;
name|opParseCtx
operator|=
name|pctx
operator|.
name|getOpParseCtx
argument_list|()
expr_stmt|;
name|loadTableWork
operator|=
name|pctx
operator|.
name|getLoadTableWork
argument_list|()
expr_stmt|;
name|loadFileWork
operator|=
name|pctx
operator|.
name|getLoadFileWork
argument_list|()
expr_stmt|;
name|joinContext
operator|=
name|pctx
operator|.
name|getJoinContext
argument_list|()
expr_stmt|;
name|smbMapJoinContext
operator|=
name|pctx
operator|.
name|getSmbMapJoinContext
argument_list|()
expr_stmt|;
name|ctx
operator|=
name|pctx
operator|.
name|getContext
argument_list|()
expr_stmt|;
name|destTableId
operator|=
name|pctx
operator|.
name|getDestTableId
argument_list|()
expr_stmt|;
name|idToTableNameMap
operator|=
name|pctx
operator|.
name|getIdToTableNameMap
argument_list|()
expr_stmt|;
name|uCtx
operator|=
name|pctx
operator|.
name|getUCtx
argument_list|()
expr_stmt|;
name|listMapJoinOpsNoReducer
operator|=
name|pctx
operator|.
name|getListMapJoinOpsNoReducer
argument_list|()
expr_stmt|;
name|qb
operator|=
name|pctx
operator|.
name|getQB
argument_list|()
expr_stmt|;
name|groupOpToInputTables
operator|=
name|pctx
operator|.
name|getGroupOpToInputTables
argument_list|()
expr_stmt|;
name|prunedPartitions
operator|=
name|pctx
operator|.
name|getPrunedPartitions
argument_list|()
expr_stmt|;
name|fetchTask
operator|=
name|pctx
operator|.
name|getFetchTask
argument_list|()
expr_stmt|;
name|setLineageInfo
argument_list|(
name|pctx
operator|.
name|getLineageInfo
argument_list|()
argument_list|)
expr_stmt|;
block|}
specifier|public
name|ParseContext
name|getParseContext
parameter_list|()
block|{
return|return
operator|new
name|ParseContext
argument_list|(
name|conf
argument_list|,
name|qb
argument_list|,
name|ast
argument_list|,
name|opToPartPruner
argument_list|,
name|opToPartList
argument_list|,
name|topOps
argument_list|,
name|topSelOps
argument_list|,
name|opParseCtx
argument_list|,
name|joinContext
argument_list|,
name|smbMapJoinContext
argument_list|,
name|topToTable
argument_list|,
name|topToTableProps
argument_list|,
name|fsopToTable
argument_list|,
name|loadTableWork
argument_list|,
name|loadFileWork
argument_list|,
name|ctx
argument_list|,
name|idToTableNameMap
argument_list|,
name|destTableId
argument_list|,
name|uCtx
argument_list|,
name|listMapJoinOpsNoReducer
argument_list|,
name|groupOpToInputTables
argument_list|,
name|prunedPartitions
argument_list|,
name|opToSamplePruner
argument_list|,
name|globalLimitCtx
argument_list|,
name|nameToSplitSample
argument_list|,
name|inputs
argument_list|,
name|rootTasks
argument_list|,
name|opToPartToSkewedPruner
argument_list|,
name|viewAliasToInput
argument_list|,
name|reduceSinkOperatorsAddedByEnforceBucketingSorting
argument_list|,
name|queryProperties
argument_list|)
return|;
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"nls"
argument_list|)
specifier|public
name|void
name|doPhase1QBExpr
parameter_list|(
name|ASTNode
name|ast
parameter_list|,
name|QBExpr
name|qbexpr
parameter_list|,
name|String
name|id
parameter_list|,
name|String
name|alias
parameter_list|)
throws|throws
name|SemanticException
block|{
assert|assert
operator|(
name|ast
operator|.
name|getToken
argument_list|()
operator|!=
literal|null
operator|)
assert|;
switch|switch
condition|(
name|ast
operator|.
name|getToken
argument_list|()
operator|.
name|getType
argument_list|()
condition|)
block|{
case|case
name|HiveParser
operator|.
name|TOK_QUERY
case|:
block|{
name|QB
name|qb
init|=
operator|new
name|QB
argument_list|(
name|id
argument_list|,
name|alias
argument_list|,
literal|true
argument_list|)
decl_stmt|;
name|Phase1Ctx
name|ctx_1
init|=
name|initPhase1Ctx
argument_list|()
decl_stmt|;
name|doPhase1
argument_list|(
name|ast
argument_list|,
name|qb
argument_list|,
name|ctx_1
argument_list|)
expr_stmt|;
name|qbexpr
operator|.
name|setOpcode
argument_list|(
name|QBExpr
operator|.
name|Opcode
operator|.
name|NULLOP
argument_list|)
expr_stmt|;
name|qbexpr
operator|.
name|setQB
argument_list|(
name|qb
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|HiveParser
operator|.
name|TOK_UNION
case|:
block|{
name|qbexpr
operator|.
name|setOpcode
argument_list|(
name|QBExpr
operator|.
name|Opcode
operator|.
name|UNION
argument_list|)
expr_stmt|;
comment|// query 1
assert|assert
operator|(
name|ast
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|!=
literal|null
operator|)
assert|;
name|QBExpr
name|qbexpr1
init|=
operator|new
name|QBExpr
argument_list|(
name|alias
operator|+
literal|"-subquery1"
argument_list|)
decl_stmt|;
name|doPhase1QBExpr
argument_list|(
operator|(
name|ASTNode
operator|)
name|ast
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
argument_list|,
name|qbexpr1
argument_list|,
name|id
operator|+
literal|"-subquery1"
argument_list|,
name|alias
operator|+
literal|"-subquery1"
argument_list|)
expr_stmt|;
name|qbexpr
operator|.
name|setQBExpr1
argument_list|(
name|qbexpr1
argument_list|)
expr_stmt|;
comment|// query 2
assert|assert
operator|(
name|ast
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|!=
literal|null
operator|)
assert|;
name|QBExpr
name|qbexpr2
init|=
operator|new
name|QBExpr
argument_list|(
name|alias
operator|+
literal|"-subquery2"
argument_list|)
decl_stmt|;
name|doPhase1QBExpr
argument_list|(
operator|(
name|ASTNode
operator|)
name|ast
operator|.
name|getChild
argument_list|(
literal|1
argument_list|)
argument_list|,
name|qbexpr2
argument_list|,
name|id
operator|+
literal|"-subquery2"
argument_list|,
name|alias
operator|+
literal|"-subquery2"
argument_list|)
expr_stmt|;
name|qbexpr
operator|.
name|setQBExpr2
argument_list|(
name|qbexpr2
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
block|}
specifier|private
name|LinkedHashMap
argument_list|<
name|String
argument_list|,
name|ASTNode
argument_list|>
name|doPhase1GetAggregationsFromSelect
parameter_list|(
name|ASTNode
name|selExpr
parameter_list|,
name|QB
name|qb
parameter_list|,
name|String
name|dest
parameter_list|)
throws|throws
name|SemanticException
block|{
comment|// Iterate over the selects search for aggregation Trees.
comment|// Use String as keys to eliminate duplicate trees.
name|LinkedHashMap
argument_list|<
name|String
argument_list|,
name|ASTNode
argument_list|>
name|aggregationTrees
init|=
operator|new
name|LinkedHashMap
argument_list|<
name|String
argument_list|,
name|ASTNode
argument_list|>
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|ASTNode
argument_list|>
name|wdwFns
init|=
operator|new
name|ArrayList
argument_list|<
name|ASTNode
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|selExpr
operator|.
name|getChildCount
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|ASTNode
name|function
init|=
operator|(
name|ASTNode
operator|)
name|selExpr
operator|.
name|getChild
argument_list|(
name|i
argument_list|)
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|doPhase1GetAllAggregations
argument_list|(
operator|(
name|ASTNode
operator|)
name|function
argument_list|,
name|aggregationTrees
argument_list|,
name|wdwFns
argument_list|)
expr_stmt|;
block|}
comment|// window based aggregations are handled differently
for|for
control|(
name|ASTNode
name|wdwFn
range|:
name|wdwFns
control|)
block|{
name|WindowingSpec
name|spec
init|=
name|qb
operator|.
name|getWindowingSpec
argument_list|(
name|dest
argument_list|)
decl_stmt|;
if|if
condition|(
name|spec
operator|==
literal|null
condition|)
block|{
name|queryProperties
operator|.
name|setHasWindowing
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|spec
operator|=
operator|new
name|WindowingSpec
argument_list|()
expr_stmt|;
name|qb
operator|.
name|addDestToWindowingSpec
argument_list|(
name|dest
argument_list|,
name|spec
argument_list|)
expr_stmt|;
block|}
name|HashMap
argument_list|<
name|String
argument_list|,
name|ASTNode
argument_list|>
name|wExprsInDest
init|=
name|qb
operator|.
name|getParseInfo
argument_list|()
operator|.
name|getWindowingExprsForClause
argument_list|(
name|dest
argument_list|)
decl_stmt|;
name|int
name|wColIdx
init|=
name|spec
operator|.
name|getWindowExpressions
argument_list|()
operator|==
literal|null
condition|?
literal|0
else|:
name|spec
operator|.
name|getWindowExpressions
argument_list|()
operator|.
name|size
argument_list|()
decl_stmt|;
name|WindowFunctionSpec
name|wFnSpec
init|=
name|processWindowFunction
argument_list|(
name|wdwFn
argument_list|,
operator|(
name|ASTNode
operator|)
name|wdwFn
operator|.
name|getChild
argument_list|(
name|wdwFn
operator|.
name|getChildCount
argument_list|()
operator|-
literal|1
argument_list|)
argument_list|)
decl_stmt|;
comment|// If this is a duplicate invocation of a function; don't add to WindowingSpec.
if|if
condition|(
name|wExprsInDest
operator|!=
literal|null
operator|&&
name|wExprsInDest
operator|.
name|containsKey
argument_list|(
name|wFnSpec
operator|.
name|getExpression
argument_list|()
operator|.
name|toStringTree
argument_list|()
argument_list|)
condition|)
block|{
continue|continue;
block|}
name|wFnSpec
operator|.
name|setAlias
argument_list|(
literal|"_wcol"
operator|+
name|wColIdx
operator|++
argument_list|)
expr_stmt|;
name|spec
operator|.
name|addWindowFunction
argument_list|(
name|wFnSpec
argument_list|)
expr_stmt|;
name|qb
operator|.
name|getParseInfo
argument_list|()
operator|.
name|addWindowingExprToClause
argument_list|(
name|dest
argument_list|,
name|wFnSpec
operator|.
name|getExpression
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|aggregationTrees
return|;
block|}
specifier|private
name|void
name|doPhase1GetColumnAliasesFromSelect
parameter_list|(
name|ASTNode
name|selectExpr
parameter_list|,
name|QBParseInfo
name|qbp
parameter_list|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|selectExpr
operator|.
name|getChildCount
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|ASTNode
name|selExpr
init|=
operator|(
name|ASTNode
operator|)
name|selectExpr
operator|.
name|getChild
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|selExpr
operator|.
name|getToken
argument_list|()
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_SELEXPR
operator|)
operator|&&
operator|(
name|selExpr
operator|.
name|getChildCount
argument_list|()
operator|==
literal|2
operator|)
condition|)
block|{
name|String
name|columnAlias
init|=
name|unescapeIdentifier
argument_list|(
name|selExpr
operator|.
name|getChild
argument_list|(
literal|1
argument_list|)
operator|.
name|getText
argument_list|()
argument_list|)
decl_stmt|;
name|qbp
operator|.
name|setExprToColumnAlias
argument_list|(
operator|(
name|ASTNode
operator|)
name|selExpr
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
argument_list|,
name|columnAlias
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**    * DFS-scan the expressionTree to find all aggregation subtrees and put them    * in aggregations.    *    * @param expressionTree    * @param aggregations    *          the key to the HashTable is the toStringTree() representation of    *          the aggregation subtree.    * @throws SemanticException    */
specifier|private
name|void
name|doPhase1GetAllAggregations
parameter_list|(
name|ASTNode
name|expressionTree
parameter_list|,
name|HashMap
argument_list|<
name|String
argument_list|,
name|ASTNode
argument_list|>
name|aggregations
parameter_list|,
name|List
argument_list|<
name|ASTNode
argument_list|>
name|wdwFns
parameter_list|)
throws|throws
name|SemanticException
block|{
name|int
name|exprTokenType
init|=
name|expressionTree
operator|.
name|getToken
argument_list|()
operator|.
name|getType
argument_list|()
decl_stmt|;
if|if
condition|(
name|exprTokenType
operator|==
name|HiveParser
operator|.
name|TOK_FUNCTION
operator|||
name|exprTokenType
operator|==
name|HiveParser
operator|.
name|TOK_FUNCTIONDI
operator|||
name|exprTokenType
operator|==
name|HiveParser
operator|.
name|TOK_FUNCTIONSTAR
condition|)
block|{
assert|assert
operator|(
name|expressionTree
operator|.
name|getChildCount
argument_list|()
operator|!=
literal|0
operator|)
assert|;
if|if
condition|(
name|expressionTree
operator|.
name|getChild
argument_list|(
name|expressionTree
operator|.
name|getChildCount
argument_list|()
operator|-
literal|1
argument_list|)
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_WINDOWSPEC
condition|)
block|{
name|wdwFns
operator|.
name|add
argument_list|(
name|expressionTree
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|expressionTree
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|Identifier
condition|)
block|{
name|String
name|functionName
init|=
name|unescapeIdentifier
argument_list|(
name|expressionTree
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getText
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|FunctionRegistry
operator|.
name|impliesOrder
argument_list|(
name|functionName
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|MISSING_OVER_CLAUSE
operator|.
name|getMsg
argument_list|(
name|functionName
argument_list|)
argument_list|)
throw|;
block|}
if|if
condition|(
name|FunctionRegistry
operator|.
name|getGenericUDAFResolver
argument_list|(
name|functionName
argument_list|)
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|containsLeadLagUDF
argument_list|(
name|expressionTree
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|MISSING_OVER_CLAUSE
operator|.
name|getMsg
argument_list|(
name|functionName
argument_list|)
argument_list|)
throw|;
block|}
name|aggregations
operator|.
name|put
argument_list|(
name|expressionTree
operator|.
name|toStringTree
argument_list|()
argument_list|,
name|expressionTree
argument_list|)
expr_stmt|;
name|FunctionInfo
name|fi
init|=
name|FunctionRegistry
operator|.
name|getFunctionInfo
argument_list|(
name|functionName
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|fi
operator|.
name|isNative
argument_list|()
condition|)
block|{
name|unparseTranslator
operator|.
name|addIdentifierTranslation
argument_list|(
operator|(
name|ASTNode
operator|)
name|expressionTree
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
block|}
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|expressionTree
operator|.
name|getChildCount
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|doPhase1GetAllAggregations
argument_list|(
operator|(
name|ASTNode
operator|)
name|expressionTree
operator|.
name|getChild
argument_list|(
name|i
argument_list|)
argument_list|,
name|aggregations
argument_list|,
name|wdwFns
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
name|List
argument_list|<
name|ASTNode
argument_list|>
name|doPhase1GetDistinctFuncExprs
parameter_list|(
name|HashMap
argument_list|<
name|String
argument_list|,
name|ASTNode
argument_list|>
name|aggregationTrees
parameter_list|)
throws|throws
name|SemanticException
block|{
name|List
argument_list|<
name|ASTNode
argument_list|>
name|exprs
init|=
operator|new
name|ArrayList
argument_list|<
name|ASTNode
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|ASTNode
argument_list|>
name|entry
range|:
name|aggregationTrees
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|ASTNode
name|value
init|=
name|entry
operator|.
name|getValue
argument_list|()
decl_stmt|;
assert|assert
operator|(
name|value
operator|!=
literal|null
operator|)
assert|;
if|if
condition|(
name|value
operator|.
name|getToken
argument_list|()
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_FUNCTIONDI
condition|)
block|{
name|exprs
operator|.
name|add
argument_list|(
name|value
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|exprs
return|;
block|}
specifier|public
specifier|static
name|String
name|generateErrorMessage
parameter_list|(
name|ASTNode
name|ast
parameter_list|,
name|String
name|message
parameter_list|)
block|{
name|StringBuilder
name|sb
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|sb
operator|.
name|append
argument_list|(
name|ast
operator|.
name|getLine
argument_list|()
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|":"
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
name|ast
operator|.
name|getCharPositionInLine
argument_list|()
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|" "
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
name|message
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|". Error encountered near token '"
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
name|ErrorMsg
operator|.
name|getText
argument_list|(
name|ast
argument_list|)
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|"'"
argument_list|)
expr_stmt|;
return|return
name|sb
operator|.
name|toString
argument_list|()
return|;
block|}
comment|/**    * Goes though the tabref tree and finds the alias for the table. Once found,    * it records the table name-> alias association in aliasToTabs. It also makes    * an association from the alias to the table AST in parse info.    *    * @return the alias of the table    */
specifier|private
name|String
name|processTable
parameter_list|(
name|QB
name|qb
parameter_list|,
name|ASTNode
name|tabref
parameter_list|)
throws|throws
name|SemanticException
block|{
comment|// For each table reference get the table name
comment|// and the alias (if alias is not present, the table name
comment|// is used as an alias)
name|int
name|aliasIndex
init|=
literal|0
decl_stmt|;
name|int
name|propsIndex
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|tsampleIndex
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|ssampleIndex
init|=
operator|-
literal|1
decl_stmt|;
for|for
control|(
name|int
name|index
init|=
literal|1
init|;
name|index
operator|<
name|tabref
operator|.
name|getChildCount
argument_list|()
condition|;
name|index
operator|++
control|)
block|{
name|ASTNode
name|ct
init|=
operator|(
name|ASTNode
operator|)
name|tabref
operator|.
name|getChild
argument_list|(
name|index
argument_list|)
decl_stmt|;
if|if
condition|(
name|ct
operator|.
name|getToken
argument_list|()
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_TABLEBUCKETSAMPLE
condition|)
block|{
name|tsampleIndex
operator|=
name|index
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ct
operator|.
name|getToken
argument_list|()
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_TABLESPLITSAMPLE
condition|)
block|{
name|ssampleIndex
operator|=
name|index
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ct
operator|.
name|getToken
argument_list|()
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_TABLEPROPERTIES
condition|)
block|{
name|propsIndex
operator|=
name|index
expr_stmt|;
block|}
else|else
block|{
name|aliasIndex
operator|=
name|index
expr_stmt|;
block|}
block|}
name|ASTNode
name|tableTree
init|=
call|(
name|ASTNode
call|)
argument_list|(
name|tabref
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|String
name|tabIdName
init|=
name|getUnescapedName
argument_list|(
name|tableTree
argument_list|)
decl_stmt|;
name|String
name|alias
decl_stmt|;
if|if
condition|(
name|aliasIndex
operator|!=
literal|0
condition|)
block|{
name|alias
operator|=
name|unescapeIdentifier
argument_list|(
name|tabref
operator|.
name|getChild
argument_list|(
name|aliasIndex
argument_list|)
operator|.
name|getText
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|alias
operator|=
name|getUnescapedUnqualifiedTableName
argument_list|(
name|tableTree
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|propsIndex
operator|>=
literal|0
condition|)
block|{
name|Tree
name|propsAST
init|=
name|tabref
operator|.
name|getChild
argument_list|(
name|propsIndex
argument_list|)
decl_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|props
init|=
name|DDLSemanticAnalyzer
operator|.
name|getProps
argument_list|(
operator|(
name|ASTNode
operator|)
name|propsAST
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|qb
operator|.
name|setTabProps
argument_list|(
name|alias
argument_list|,
name|props
argument_list|)
expr_stmt|;
block|}
comment|// If the alias is already there then we have a conflict
if|if
condition|(
name|qb
operator|.
name|exists
argument_list|(
name|alias
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|AMBIGUOUS_TABLE_ALIAS
operator|.
name|getMsg
argument_list|(
name|tabref
operator|.
name|getChild
argument_list|(
name|aliasIndex
argument_list|)
argument_list|)
argument_list|)
throw|;
block|}
if|if
condition|(
name|tsampleIndex
operator|>=
literal|0
condition|)
block|{
name|ASTNode
name|sampleClause
init|=
operator|(
name|ASTNode
operator|)
name|tabref
operator|.
name|getChild
argument_list|(
name|tsampleIndex
argument_list|)
decl_stmt|;
name|ArrayList
argument_list|<
name|ASTNode
argument_list|>
name|sampleCols
init|=
operator|new
name|ArrayList
argument_list|<
name|ASTNode
argument_list|>
argument_list|()
decl_stmt|;
if|if
condition|(
name|sampleClause
operator|.
name|getChildCount
argument_list|()
operator|>
literal|2
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|2
init|;
name|i
operator|<
name|sampleClause
operator|.
name|getChildCount
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|sampleCols
operator|.
name|add
argument_list|(
operator|(
name|ASTNode
operator|)
name|sampleClause
operator|.
name|getChild
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|// TODO: For now only support sampling on up to two columns
comment|// Need to change it to list of columns
if|if
condition|(
name|sampleCols
operator|.
name|size
argument_list|()
operator|>
literal|2
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|generateErrorMessage
argument_list|(
operator|(
name|ASTNode
operator|)
name|tabref
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
argument_list|,
name|ErrorMsg
operator|.
name|SAMPLE_RESTRICTION
operator|.
name|getMsg
argument_list|()
argument_list|)
argument_list|)
throw|;
block|}
name|qb
operator|.
name|getParseInfo
argument_list|()
operator|.
name|setTabSample
argument_list|(
name|alias
argument_list|,
operator|new
name|TableSample
argument_list|(
name|unescapeIdentifier
argument_list|(
name|sampleClause
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getText
argument_list|()
argument_list|)
argument_list|,
name|unescapeIdentifier
argument_list|(
name|sampleClause
operator|.
name|getChild
argument_list|(
literal|1
argument_list|)
operator|.
name|getText
argument_list|()
argument_list|)
argument_list|,
name|sampleCols
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|unparseTranslator
operator|.
name|isEnabled
argument_list|()
condition|)
block|{
for|for
control|(
name|ASTNode
name|sampleCol
range|:
name|sampleCols
control|)
block|{
name|unparseTranslator
operator|.
name|addIdentifierTranslation
argument_list|(
operator|(
name|ASTNode
operator|)
name|sampleCol
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|ssampleIndex
operator|>=
literal|0
condition|)
block|{
name|ASTNode
name|sampleClause
init|=
operator|(
name|ASTNode
operator|)
name|tabref
operator|.
name|getChild
argument_list|(
name|ssampleIndex
argument_list|)
decl_stmt|;
name|Tree
name|type
init|=
name|sampleClause
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|Tree
name|numerator
init|=
name|sampleClause
operator|.
name|getChild
argument_list|(
literal|1
argument_list|)
decl_stmt|;
name|String
name|value
init|=
name|unescapeIdentifier
argument_list|(
name|numerator
operator|.
name|getText
argument_list|()
argument_list|)
decl_stmt|;
name|SplitSample
name|sample
decl_stmt|;
if|if
condition|(
name|type
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_PERCENT
condition|)
block|{
name|assertCombineInputFormat
argument_list|(
name|numerator
argument_list|,
literal|"Percentage"
argument_list|)
expr_stmt|;
name|Double
name|percent
init|=
name|Double
operator|.
name|valueOf
argument_list|(
name|value
argument_list|)
operator|.
name|doubleValue
argument_list|()
decl_stmt|;
if|if
condition|(
name|percent
argument_list|<
literal|0
operator|||
name|percent
argument_list|>
literal|100
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|generateErrorMessage
argument_list|(
operator|(
name|ASTNode
operator|)
name|numerator
argument_list|,
literal|"Sampling percentage should be between 0 and 100"
argument_list|)
argument_list|)
throw|;
block|}
name|int
name|seedNum
init|=
name|conf
operator|.
name|getIntVar
argument_list|(
name|ConfVars
operator|.
name|HIVESAMPLERANDOMNUM
argument_list|)
decl_stmt|;
name|sample
operator|=
operator|new
name|SplitSample
argument_list|(
name|percent
argument_list|,
name|seedNum
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|type
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_ROWCOUNT
condition|)
block|{
name|sample
operator|=
operator|new
name|SplitSample
argument_list|(
name|Integer
operator|.
name|valueOf
argument_list|(
name|value
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
assert|assert
name|type
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_LENGTH
assert|;
name|assertCombineInputFormat
argument_list|(
name|numerator
argument_list|,
literal|"Total Length"
argument_list|)
expr_stmt|;
name|long
name|length
init|=
name|Integer
operator|.
name|valueOf
argument_list|(
name|value
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|value
operator|.
name|length
argument_list|()
operator|-
literal|1
argument_list|)
argument_list|)
decl_stmt|;
name|char
name|last
init|=
name|value
operator|.
name|charAt
argument_list|(
name|value
operator|.
name|length
argument_list|()
operator|-
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|last
operator|==
literal|'k'
operator|||
name|last
operator|==
literal|'K'
condition|)
block|{
name|length
operator|<<=
literal|10
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|last
operator|==
literal|'m'
operator|||
name|last
operator|==
literal|'M'
condition|)
block|{
name|length
operator|<<=
literal|20
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|last
operator|==
literal|'g'
operator|||
name|last
operator|==
literal|'G'
condition|)
block|{
name|length
operator|<<=
literal|30
expr_stmt|;
block|}
name|int
name|seedNum
init|=
name|conf
operator|.
name|getIntVar
argument_list|(
name|ConfVars
operator|.
name|HIVESAMPLERANDOMNUM
argument_list|)
decl_stmt|;
name|sample
operator|=
operator|new
name|SplitSample
argument_list|(
name|length
argument_list|,
name|seedNum
argument_list|)
expr_stmt|;
block|}
name|String
name|alias_id
init|=
name|getAliasId
argument_list|(
name|alias
argument_list|,
name|qb
argument_list|)
decl_stmt|;
name|nameToSplitSample
operator|.
name|put
argument_list|(
name|alias_id
argument_list|,
name|sample
argument_list|)
expr_stmt|;
block|}
comment|// Insert this map into the stats
name|qb
operator|.
name|setTabAlias
argument_list|(
name|alias
argument_list|,
name|tabIdName
argument_list|)
expr_stmt|;
name|qb
operator|.
name|addAlias
argument_list|(
name|alias
argument_list|)
expr_stmt|;
name|qb
operator|.
name|getParseInfo
argument_list|()
operator|.
name|setSrcForAlias
argument_list|(
name|alias
argument_list|,
name|tableTree
argument_list|)
expr_stmt|;
name|unparseTranslator
operator|.
name|addTableNameTranslation
argument_list|(
name|tableTree
argument_list|,
name|SessionState
operator|.
name|get
argument_list|()
operator|.
name|getCurrentDatabase
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|aliasIndex
operator|!=
literal|0
condition|)
block|{
name|unparseTranslator
operator|.
name|addIdentifierTranslation
argument_list|(
operator|(
name|ASTNode
operator|)
name|tabref
operator|.
name|getChild
argument_list|(
name|aliasIndex
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|alias
return|;
block|}
specifier|private
name|void
name|assertCombineInputFormat
parameter_list|(
name|Tree
name|numerator
parameter_list|,
name|String
name|message
parameter_list|)
throws|throws
name|SemanticException
block|{
name|String
name|inputFormat
init|=
name|HiveConf
operator|.
name|getVar
argument_list|(
name|conf
argument_list|,
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVEINPUTFORMAT
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|inputFormat
operator|.
name|equals
argument_list|(
name|CombineHiveInputFormat
operator|.
name|class
operator|.
name|getName
argument_list|()
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|generateErrorMessage
argument_list|(
operator|(
name|ASTNode
operator|)
name|numerator
argument_list|,
name|message
operator|+
literal|" sampling is not supported in "
operator|+
name|inputFormat
argument_list|)
argument_list|)
throw|;
block|}
block|}
specifier|private
name|String
name|processSubQuery
parameter_list|(
name|QB
name|qb
parameter_list|,
name|ASTNode
name|subq
parameter_list|)
throws|throws
name|SemanticException
block|{
comment|// This is a subquery and must have an alias
if|if
condition|(
name|subq
operator|.
name|getChildCount
argument_list|()
operator|!=
literal|2
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|NO_SUBQUERY_ALIAS
operator|.
name|getMsg
argument_list|(
name|subq
argument_list|)
argument_list|)
throw|;
block|}
name|ASTNode
name|subqref
init|=
operator|(
name|ASTNode
operator|)
name|subq
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|String
name|alias
init|=
name|unescapeIdentifier
argument_list|(
name|subq
operator|.
name|getChild
argument_list|(
literal|1
argument_list|)
operator|.
name|getText
argument_list|()
argument_list|)
decl_stmt|;
comment|// Recursively do the first phase of semantic analysis for the subquery
name|QBExpr
name|qbexpr
init|=
operator|new
name|QBExpr
argument_list|(
name|alias
argument_list|)
decl_stmt|;
name|doPhase1QBExpr
argument_list|(
name|subqref
argument_list|,
name|qbexpr
argument_list|,
name|qb
operator|.
name|getId
argument_list|()
argument_list|,
name|alias
argument_list|)
expr_stmt|;
comment|// If the alias is already there then we have a conflict
if|if
condition|(
name|qb
operator|.
name|exists
argument_list|(
name|alias
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|AMBIGUOUS_TABLE_ALIAS
operator|.
name|getMsg
argument_list|(
name|subq
operator|.
name|getChild
argument_list|(
literal|1
argument_list|)
argument_list|)
argument_list|)
throw|;
block|}
comment|// Insert this map into the stats
name|qb
operator|.
name|setSubqAlias
argument_list|(
name|alias
argument_list|,
name|qbexpr
argument_list|)
expr_stmt|;
name|qb
operator|.
name|addAlias
argument_list|(
name|alias
argument_list|)
expr_stmt|;
name|unparseTranslator
operator|.
name|addIdentifierTranslation
argument_list|(
operator|(
name|ASTNode
operator|)
name|subq
operator|.
name|getChild
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|alias
return|;
block|}
specifier|private
name|boolean
name|isJoinToken
parameter_list|(
name|ASTNode
name|node
parameter_list|)
block|{
if|if
condition|(
operator|(
name|node
operator|.
name|getToken
argument_list|()
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_JOIN
operator|)
operator|||
operator|(
name|node
operator|.
name|getToken
argument_list|()
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_CROSSJOIN
operator|)
operator|||
operator|(
name|node
operator|.
name|getToken
argument_list|()
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_LEFTOUTERJOIN
operator|)
operator|||
operator|(
name|node
operator|.
name|getToken
argument_list|()
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_RIGHTOUTERJOIN
operator|)
operator|||
operator|(
name|node
operator|.
name|getToken
argument_list|()
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_FULLOUTERJOIN
operator|)
operator|||
operator|(
name|node
operator|.
name|getToken
argument_list|()
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_LEFTSEMIJOIN
operator|)
operator|||
operator|(
name|node
operator|.
name|getToken
argument_list|()
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_UNIQUEJOIN
operator|)
condition|)
block|{
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
comment|/**    * Given the AST with TOK_JOIN as the root, get all the aliases for the tables    * or subqueries in the join.    *    * @param qb    * @param join    * @throws SemanticException    */
annotation|@
name|SuppressWarnings
argument_list|(
literal|"nls"
argument_list|)
specifier|private
name|void
name|processJoin
parameter_list|(
name|QB
name|qb
parameter_list|,
name|ASTNode
name|join
parameter_list|)
throws|throws
name|SemanticException
block|{
name|int
name|numChildren
init|=
name|join
operator|.
name|getChildCount
argument_list|()
decl_stmt|;
if|if
condition|(
operator|(
name|numChildren
operator|!=
literal|2
operator|)
operator|&&
operator|(
name|numChildren
operator|!=
literal|3
operator|)
operator|&&
name|join
operator|.
name|getToken
argument_list|()
operator|.
name|getType
argument_list|()
operator|!=
name|HiveParser
operator|.
name|TOK_UNIQUEJOIN
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|generateErrorMessage
argument_list|(
name|join
argument_list|,
literal|"Join with multiple children"
argument_list|)
argument_list|)
throw|;
block|}
for|for
control|(
name|int
name|num
init|=
literal|0
init|;
name|num
operator|<
name|numChildren
condition|;
name|num
operator|++
control|)
block|{
name|ASTNode
name|child
init|=
operator|(
name|ASTNode
operator|)
name|join
operator|.
name|getChild
argument_list|(
name|num
argument_list|)
decl_stmt|;
if|if
condition|(
name|child
operator|.
name|getToken
argument_list|()
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_TABREF
condition|)
block|{
name|processTable
argument_list|(
name|qb
argument_list|,
name|child
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|child
operator|.
name|getToken
argument_list|()
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_SUBQUERY
condition|)
block|{
name|processSubQuery
argument_list|(
name|qb
argument_list|,
name|child
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|child
operator|.
name|getToken
argument_list|()
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_PTBLFUNCTION
condition|)
block|{
name|queryProperties
operator|.
name|setHasPTF
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|processPTF
argument_list|(
name|qb
argument_list|,
name|child
argument_list|)
expr_stmt|;
name|PTFInvocationSpec
name|ptfInvocationSpec
init|=
name|qb
operator|.
name|getPTFInvocationSpec
argument_list|(
name|child
argument_list|)
decl_stmt|;
name|String
name|inputAlias
init|=
name|ptfInvocationSpec
operator|==
literal|null
condition|?
literal|null
else|:
operator|(
operator|(
name|PartitionedTableFunctionSpec
operator|)
name|ptfInvocationSpec
operator|.
name|getFunction
argument_list|()
operator|)
operator|.
name|getAlias
argument_list|()
decl_stmt|;
empty_stmt|;
if|if
condition|(
name|inputAlias
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|generateErrorMessage
argument_list|(
name|child
argument_list|,
literal|"PTF invocation in a Join must have an alias"
argument_list|)
argument_list|)
throw|;
block|}
block|}
elseif|else
if|if
condition|(
name|child
operator|.
name|getToken
argument_list|()
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_LATERAL_VIEW
operator|||
name|child
operator|.
name|getToken
argument_list|()
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_LATERAL_VIEW_OUTER
condition|)
block|{
comment|// SELECT * FROM src1 LATERAL VIEW udtf() AS myTable JOIN src2 ...
comment|// is not supported. Instead, the lateral view must be in a subquery
comment|// SELECT * FROM (SELECT * FROM src1 LATERAL VIEW udtf() AS myTable) a
comment|// JOIN src2 ...
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|LATERAL_VIEW_WITH_JOIN
operator|.
name|getMsg
argument_list|(
name|join
argument_list|)
argument_list|)
throw|;
block|}
elseif|else
if|if
condition|(
name|isJoinToken
argument_list|(
name|child
argument_list|)
condition|)
block|{
name|processJoin
argument_list|(
name|qb
argument_list|,
name|child
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**    * Given the AST with TOK_LATERAL_VIEW as the root, get the alias for the    * table or subquery in the lateral view and also make a mapping from the    * alias to all the lateral view AST's.    *    * @param qb    * @param lateralView    * @return the alias for the table/subquery    * @throws SemanticException    */
specifier|private
name|String
name|processLateralView
parameter_list|(
name|QB
name|qb
parameter_list|,
name|ASTNode
name|lateralView
parameter_list|)
throws|throws
name|SemanticException
block|{
name|int
name|numChildren
init|=
name|lateralView
operator|.
name|getChildCount
argument_list|()
decl_stmt|;
assert|assert
operator|(
name|numChildren
operator|==
literal|2
operator|)
assert|;
name|ASTNode
name|next
init|=
operator|(
name|ASTNode
operator|)
name|lateralView
operator|.
name|getChild
argument_list|(
literal|1
argument_list|)
decl_stmt|;
name|String
name|alias
init|=
literal|null
decl_stmt|;
switch|switch
condition|(
name|next
operator|.
name|getToken
argument_list|()
operator|.
name|getType
argument_list|()
condition|)
block|{
case|case
name|HiveParser
operator|.
name|TOK_TABREF
case|:
name|alias
operator|=
name|processTable
argument_list|(
name|qb
argument_list|,
name|next
argument_list|)
expr_stmt|;
break|break;
case|case
name|HiveParser
operator|.
name|TOK_SUBQUERY
case|:
name|alias
operator|=
name|processSubQuery
argument_list|(
name|qb
argument_list|,
name|next
argument_list|)
expr_stmt|;
break|break;
case|case
name|HiveParser
operator|.
name|TOK_LATERAL_VIEW
case|:
case|case
name|HiveParser
operator|.
name|TOK_LATERAL_VIEW_OUTER
case|:
name|alias
operator|=
name|processLateralView
argument_list|(
name|qb
argument_list|,
name|next
argument_list|)
expr_stmt|;
break|break;
default|default:
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|LATERAL_VIEW_INVALID_CHILD
operator|.
name|getMsg
argument_list|(
name|lateralView
argument_list|)
argument_list|)
throw|;
block|}
name|alias
operator|=
name|alias
operator|.
name|toLowerCase
argument_list|()
expr_stmt|;
name|qb
operator|.
name|getParseInfo
argument_list|()
operator|.
name|addLateralViewForAlias
argument_list|(
name|alias
argument_list|,
name|lateralView
argument_list|)
expr_stmt|;
name|qb
operator|.
name|addAlias
argument_list|(
name|alias
argument_list|)
expr_stmt|;
return|return
name|alias
return|;
block|}
comment|/**    * Phase 1: (including, but not limited to):    *    * 1. Gets all the aliases for all the tables / subqueries and makes the    * appropriate mapping in aliasToTabs, aliasToSubq 2. Gets the location of the    * destination and names the clase "inclause" + i 3. Creates a map from a    * string representation of an aggregation tree to the actual aggregation AST    * 4. Creates a mapping from the clause name to the select expression AST in    * destToSelExpr 5. Creates a mapping from a table alias to the lateral view    * AST's in aliasToLateralViews    *    * @param ast    * @param qb    * @param ctx_1    * @throws SemanticException    */
annotation|@
name|SuppressWarnings
argument_list|(
block|{
literal|"fallthrough"
block|,
literal|"nls"
block|}
argument_list|)
specifier|public
name|boolean
name|doPhase1
parameter_list|(
name|ASTNode
name|ast
parameter_list|,
name|QB
name|qb
parameter_list|,
name|Phase1Ctx
name|ctx_1
parameter_list|)
throws|throws
name|SemanticException
block|{
name|boolean
name|phase1Result
init|=
literal|true
decl_stmt|;
name|QBParseInfo
name|qbp
init|=
name|qb
operator|.
name|getParseInfo
argument_list|()
decl_stmt|;
name|boolean
name|skipRecursion
init|=
literal|false
decl_stmt|;
if|if
condition|(
name|ast
operator|.
name|getToken
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|skipRecursion
operator|=
literal|true
expr_stmt|;
switch|switch
condition|(
name|ast
operator|.
name|getToken
argument_list|()
operator|.
name|getType
argument_list|()
condition|)
block|{
case|case
name|HiveParser
operator|.
name|TOK_SELECTDI
case|:
name|qb
operator|.
name|countSelDi
argument_list|()
expr_stmt|;
comment|// fall through
case|case
name|HiveParser
operator|.
name|TOK_SELECT
case|:
name|qb
operator|.
name|countSel
argument_list|()
expr_stmt|;
name|qbp
operator|.
name|setSelExprForClause
argument_list|(
name|ctx_1
operator|.
name|dest
argument_list|,
name|ast
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|ASTNode
operator|)
name|ast
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|)
operator|.
name|getToken
argument_list|()
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_HINTLIST
condition|)
block|{
name|qbp
operator|.
name|setHints
argument_list|(
operator|(
name|ASTNode
operator|)
name|ast
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|LinkedHashMap
argument_list|<
name|String
argument_list|,
name|ASTNode
argument_list|>
name|aggregations
init|=
name|doPhase1GetAggregationsFromSelect
argument_list|(
name|ast
argument_list|,
name|qb
argument_list|,
name|ctx_1
operator|.
name|dest
argument_list|)
decl_stmt|;
name|doPhase1GetColumnAliasesFromSelect
argument_list|(
name|ast
argument_list|,
name|qbp
argument_list|)
expr_stmt|;
name|qbp
operator|.
name|setAggregationExprsForClause
argument_list|(
name|ctx_1
operator|.
name|dest
argument_list|,
name|aggregations
argument_list|)
expr_stmt|;
name|qbp
operator|.
name|setDistinctFuncExprsForClause
argument_list|(
name|ctx_1
operator|.
name|dest
argument_list|,
name|doPhase1GetDistinctFuncExprs
argument_list|(
name|aggregations
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|HiveParser
operator|.
name|TOK_WHERE
case|:
name|qbp
operator|.
name|setWhrExprForClause
argument_list|(
name|ctx_1
operator|.
name|dest
argument_list|,
name|ast
argument_list|)
expr_stmt|;
break|break;
case|case
name|HiveParser
operator|.
name|TOK_INSERT_INTO
case|:
name|String
name|currentDatabase
init|=
name|SessionState
operator|.
name|get
argument_list|()
operator|.
name|getCurrentDatabase
argument_list|()
decl_stmt|;
name|String
name|tab_name
init|=
name|getUnescapedName
argument_list|(
operator|(
name|ASTNode
operator|)
name|ast
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
argument_list|,
name|currentDatabase
argument_list|)
decl_stmt|;
name|qbp
operator|.
name|addInsertIntoTable
argument_list|(
name|tab_name
argument_list|)
expr_stmt|;
comment|// TODO: is this supposed to fall thru?
case|case
name|HiveParser
operator|.
name|TOK_DESTINATION
case|:
name|ctx_1
operator|.
name|dest
operator|=
literal|"insclause-"
operator|+
name|ctx_1
operator|.
name|nextNum
expr_stmt|;
name|ctx_1
operator|.
name|nextNum
operator|++
expr_stmt|;
comment|// is there a insert in the subquery
if|if
condition|(
name|qbp
operator|.
name|getIsSubQ
argument_list|()
condition|)
block|{
name|ASTNode
name|ch
init|=
operator|(
name|ASTNode
operator|)
name|ast
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|ch
operator|.
name|getToken
argument_list|()
operator|.
name|getType
argument_list|()
operator|!=
name|HiveParser
operator|.
name|TOK_DIR
operator|)
operator|||
operator|(
operator|(
operator|(
name|ASTNode
operator|)
name|ch
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|)
operator|.
name|getToken
argument_list|()
operator|.
name|getType
argument_list|()
operator|!=
name|HiveParser
operator|.
name|TOK_TMP_FILE
operator|)
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|NO_INSERT_INSUBQUERY
operator|.
name|getMsg
argument_list|(
name|ast
argument_list|)
argument_list|)
throw|;
block|}
block|}
name|qbp
operator|.
name|setDestForClause
argument_list|(
name|ctx_1
operator|.
name|dest
argument_list|,
operator|(
name|ASTNode
operator|)
name|ast
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|HiveParser
operator|.
name|TOK_FROM
case|:
name|int
name|child_count
init|=
name|ast
operator|.
name|getChildCount
argument_list|()
decl_stmt|;
if|if
condition|(
name|child_count
operator|!=
literal|1
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|generateErrorMessage
argument_list|(
name|ast
argument_list|,
literal|"Multiple Children "
operator|+
name|child_count
argument_list|)
argument_list|)
throw|;
block|}
comment|// Check if this is a subquery / lateral view
name|ASTNode
name|frm
init|=
operator|(
name|ASTNode
operator|)
name|ast
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|frm
operator|.
name|getToken
argument_list|()
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_TABREF
condition|)
block|{
name|processTable
argument_list|(
name|qb
argument_list|,
name|frm
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|frm
operator|.
name|getToken
argument_list|()
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_SUBQUERY
condition|)
block|{
name|processSubQuery
argument_list|(
name|qb
argument_list|,
name|frm
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|frm
operator|.
name|getToken
argument_list|()
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_LATERAL_VIEW
operator|||
name|frm
operator|.
name|getToken
argument_list|()
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_LATERAL_VIEW_OUTER
condition|)
block|{
name|processLateralView
argument_list|(
name|qb
argument_list|,
name|frm
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|isJoinToken
argument_list|(
name|frm
argument_list|)
condition|)
block|{
name|queryProperties
operator|.
name|setHasJoin
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|processJoin
argument_list|(
name|qb
argument_list|,
name|frm
argument_list|)
expr_stmt|;
name|qbp
operator|.
name|setJoinExpr
argument_list|(
name|frm
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|frm
operator|.
name|getToken
argument_list|()
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_PTBLFUNCTION
condition|)
block|{
name|queryProperties
operator|.
name|setHasPTF
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|processPTF
argument_list|(
name|qb
argument_list|,
name|frm
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|HiveParser
operator|.
name|TOK_CLUSTERBY
case|:
comment|// Get the clusterby aliases - these are aliased to the entries in the
comment|// select list
name|queryProperties
operator|.
name|setHasClusterBy
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|qbp
operator|.
name|setClusterByExprForClause
argument_list|(
name|ctx_1
operator|.
name|dest
argument_list|,
name|ast
argument_list|)
expr_stmt|;
break|break;
case|case
name|HiveParser
operator|.
name|TOK_DISTRIBUTEBY
case|:
comment|// Get the distribute by aliases - these are aliased to the entries in
comment|// the
comment|// select list
name|queryProperties
operator|.
name|setHasDistributeBy
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|qbp
operator|.
name|setDistributeByExprForClause
argument_list|(
name|ctx_1
operator|.
name|dest
argument_list|,
name|ast
argument_list|)
expr_stmt|;
if|if
condition|(
name|qbp
operator|.
name|getClusterByForClause
argument_list|(
name|ctx_1
operator|.
name|dest
argument_list|)
operator|!=
literal|null
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|generateErrorMessage
argument_list|(
name|ast
argument_list|,
name|ErrorMsg
operator|.
name|CLUSTERBY_DISTRIBUTEBY_CONFLICT
operator|.
name|getMsg
argument_list|()
argument_list|)
argument_list|)
throw|;
block|}
elseif|else
if|if
condition|(
name|qbp
operator|.
name|getOrderByForClause
argument_list|(
name|ctx_1
operator|.
name|dest
argument_list|)
operator|!=
literal|null
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|generateErrorMessage
argument_list|(
name|ast
argument_list|,
name|ErrorMsg
operator|.
name|ORDERBY_DISTRIBUTEBY_CONFLICT
operator|.
name|getMsg
argument_list|()
argument_list|)
argument_list|)
throw|;
block|}
break|break;
case|case
name|HiveParser
operator|.
name|TOK_SORTBY
case|:
comment|// Get the sort by aliases - these are aliased to the entries in the
comment|// select list
name|queryProperties
operator|.
name|setHasSortBy
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|qbp
operator|.
name|setSortByExprForClause
argument_list|(
name|ctx_1
operator|.
name|dest
argument_list|,
name|ast
argument_list|)
expr_stmt|;
if|if
condition|(
name|qbp
operator|.
name|getClusterByForClause
argument_list|(
name|ctx_1
operator|.
name|dest
argument_list|)
operator|!=
literal|null
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|generateErrorMessage
argument_list|(
name|ast
argument_list|,
name|ErrorMsg
operator|.
name|CLUSTERBY_SORTBY_CONFLICT
operator|.
name|getMsg
argument_list|()
argument_list|)
argument_list|)
throw|;
block|}
elseif|else
if|if
condition|(
name|qbp
operator|.
name|getOrderByForClause
argument_list|(
name|ctx_1
operator|.
name|dest
argument_list|)
operator|!=
literal|null
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|generateErrorMessage
argument_list|(
name|ast
argument_list|,
name|ErrorMsg
operator|.
name|ORDERBY_SORTBY_CONFLICT
operator|.
name|getMsg
argument_list|()
argument_list|)
argument_list|)
throw|;
block|}
break|break;
case|case
name|HiveParser
operator|.
name|TOK_ORDERBY
case|:
comment|// Get the order by aliases - these are aliased to the entries in the
comment|// select list
name|queryProperties
operator|.
name|setHasOrderBy
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|qbp
operator|.
name|setOrderByExprForClause
argument_list|(
name|ctx_1
operator|.
name|dest
argument_list|,
name|ast
argument_list|)
expr_stmt|;
if|if
condition|(
name|qbp
operator|.
name|getClusterByForClause
argument_list|(
name|ctx_1
operator|.
name|dest
argument_list|)
operator|!=
literal|null
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|generateErrorMessage
argument_list|(
name|ast
argument_list|,
name|ErrorMsg
operator|.
name|CLUSTERBY_ORDERBY_CONFLICT
operator|.
name|getMsg
argument_list|()
argument_list|)
argument_list|)
throw|;
block|}
break|break;
case|case
name|HiveParser
operator|.
name|TOK_GROUPBY
case|:
case|case
name|HiveParser
operator|.
name|TOK_ROLLUP_GROUPBY
case|:
case|case
name|HiveParser
operator|.
name|TOK_CUBE_GROUPBY
case|:
case|case
name|HiveParser
operator|.
name|TOK_GROUPING_SETS
case|:
comment|// Get the groupby aliases - these are aliased to the entries in the
comment|// select list
name|queryProperties
operator|.
name|setHasGroupBy
argument_list|(
literal|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|qbp
operator|.
name|getJoinExpr
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|queryProperties
operator|.
name|setHasJoinFollowedByGroupBy
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|qbp
operator|.
name|getSelForClause
argument_list|(
name|ctx_1
operator|.
name|dest
argument_list|)
operator|.
name|getToken
argument_list|()
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_SELECTDI
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|generateErrorMessage
argument_list|(
name|ast
argument_list|,
name|ErrorMsg
operator|.
name|SELECT_DISTINCT_WITH_GROUPBY
operator|.
name|getMsg
argument_list|()
argument_list|)
argument_list|)
throw|;
block|}
name|qbp
operator|.
name|setGroupByExprForClause
argument_list|(
name|ctx_1
operator|.
name|dest
argument_list|,
name|ast
argument_list|)
expr_stmt|;
name|skipRecursion
operator|=
literal|true
expr_stmt|;
comment|// Rollup and Cubes are syntactic sugar on top of grouping sets
if|if
condition|(
name|ast
operator|.
name|getToken
argument_list|()
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_ROLLUP_GROUPBY
condition|)
block|{
name|qbp
operator|.
name|getDestRollups
argument_list|()
operator|.
name|add
argument_list|(
name|ctx_1
operator|.
name|dest
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ast
operator|.
name|getToken
argument_list|()
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_CUBE_GROUPBY
condition|)
block|{
name|qbp
operator|.
name|getDestCubes
argument_list|()
operator|.
name|add
argument_list|(
name|ctx_1
operator|.
name|dest
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ast
operator|.
name|getToken
argument_list|()
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_GROUPING_SETS
condition|)
block|{
name|qbp
operator|.
name|getDestGroupingSets
argument_list|()
operator|.
name|add
argument_list|(
name|ctx_1
operator|.
name|dest
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|HiveParser
operator|.
name|TOK_HAVING
case|:
name|qbp
operator|.
name|setHavingExprForClause
argument_list|(
name|ctx_1
operator|.
name|dest
argument_list|,
name|ast
argument_list|)
expr_stmt|;
name|qbp
operator|.
name|addAggregationExprsForClause
argument_list|(
name|ctx_1
operator|.
name|dest
argument_list|,
name|doPhase1GetAggregationsFromSelect
argument_list|(
name|ast
argument_list|,
name|qb
argument_list|,
name|ctx_1
operator|.
name|dest
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|HiveParser
operator|.
name|KW_WINDOW
case|:
if|if
condition|(
operator|!
name|qb
operator|.
name|hasWindowingSpec
argument_list|(
name|ctx_1
operator|.
name|dest
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|generateErrorMessage
argument_list|(
name|ast
argument_list|,
literal|"Query has no Cluster/Distribute By; but has a Window definition"
argument_list|)
argument_list|)
throw|;
block|}
name|handleQueryWindowClauses
argument_list|(
name|qb
argument_list|,
name|ctx_1
argument_list|,
name|ast
argument_list|)
expr_stmt|;
break|break;
case|case
name|HiveParser
operator|.
name|TOK_LIMIT
case|:
name|qbp
operator|.
name|setDestLimit
argument_list|(
name|ctx_1
operator|.
name|dest
argument_list|,
operator|new
name|Integer
argument_list|(
name|ast
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getText
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|HiveParser
operator|.
name|TOK_ANALYZE
case|:
comment|// Case of analyze command
name|String
name|table_name
init|=
name|getUnescapedName
argument_list|(
operator|(
name|ASTNode
operator|)
name|ast
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|qb
operator|.
name|setTabAlias
argument_list|(
name|table_name
argument_list|,
name|table_name
argument_list|)
expr_stmt|;
name|qb
operator|.
name|addAlias
argument_list|(
name|table_name
argument_list|)
expr_stmt|;
name|qb
operator|.
name|getParseInfo
argument_list|()
operator|.
name|setIsAnalyzeCommand
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|qb
operator|.
name|getParseInfo
argument_list|()
operator|.
name|setNoScanAnalyzeCommand
argument_list|(
name|this
operator|.
name|noscan
argument_list|)
expr_stmt|;
name|qb
operator|.
name|getParseInfo
argument_list|()
operator|.
name|setPartialScanAnalyzeCommand
argument_list|(
name|this
operator|.
name|partialscan
argument_list|)
expr_stmt|;
comment|// Allow analyze the whole table and dynamic partitions
name|HiveConf
operator|.
name|setVar
argument_list|(
name|conf
argument_list|,
name|HiveConf
operator|.
name|ConfVars
operator|.
name|DYNAMICPARTITIONINGMODE
argument_list|,
literal|"nonstrict"
argument_list|)
expr_stmt|;
name|HiveConf
operator|.
name|setVar
argument_list|(
name|conf
argument_list|,
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVEMAPREDMODE
argument_list|,
literal|"nonstrict"
argument_list|)
expr_stmt|;
break|break;
case|case
name|HiveParser
operator|.
name|TOK_UNION
case|:
comment|// currently, we dont support subq1 union subq2 - the user has to
comment|// explicitly say:
comment|// select * from (subq1 union subq2) subqalias
if|if
condition|(
operator|!
name|qbp
operator|.
name|getIsSubQ
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|generateErrorMessage
argument_list|(
name|ast
argument_list|,
name|ErrorMsg
operator|.
name|UNION_NOTIN_SUBQ
operator|.
name|getMsg
argument_list|()
argument_list|)
argument_list|)
throw|;
block|}
name|skipRecursion
operator|=
literal|false
expr_stmt|;
break|break;
case|case
name|HiveParser
operator|.
name|TOK_INSERT
case|:
name|ASTNode
name|destination
init|=
operator|(
name|ASTNode
operator|)
name|ast
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|Tree
name|tab
init|=
name|destination
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
decl_stmt|;
comment|// Proceed if AST contains partition& If Not Exists
if|if
condition|(
name|destination
operator|.
name|getChildCount
argument_list|()
operator|==
literal|2
operator|&&
name|tab
operator|.
name|getChildCount
argument_list|()
operator|==
literal|2
operator|&&
name|destination
operator|.
name|getChild
argument_list|(
literal|1
argument_list|)
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_IFNOTEXISTS
condition|)
block|{
name|String
name|tableName
init|=
name|tab
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getText
argument_list|()
decl_stmt|;
name|Tree
name|partitions
init|=
name|tab
operator|.
name|getChild
argument_list|(
literal|1
argument_list|)
decl_stmt|;
name|int
name|childCount
init|=
name|partitions
operator|.
name|getChildCount
argument_list|()
decl_stmt|;
name|HashMap
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|partition
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|childCount
condition|;
name|i
operator|++
control|)
block|{
name|String
name|partitionName
init|=
name|partitions
operator|.
name|getChild
argument_list|(
name|i
argument_list|)
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getText
argument_list|()
decl_stmt|;
name|Tree
name|pvalue
init|=
name|partitions
operator|.
name|getChild
argument_list|(
name|i
argument_list|)
operator|.
name|getChild
argument_list|(
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|pvalue
operator|==
literal|null
condition|)
block|{
break|break;
block|}
name|String
name|partitionVal
init|=
name|stripQuotes
argument_list|(
name|pvalue
operator|.
name|getText
argument_list|()
argument_list|)
decl_stmt|;
name|partition
operator|.
name|put
argument_list|(
name|partitionName
argument_list|,
name|partitionVal
argument_list|)
expr_stmt|;
block|}
comment|// if it is a dynamic partition throw the exception
if|if
condition|(
name|childCount
operator|!=
name|partition
operator|.
name|size
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|INSERT_INTO_DYNAMICPARTITION_IFNOTEXISTS
operator|.
name|getMsg
argument_list|(
name|partition
operator|.
name|toString
argument_list|()
argument_list|)
argument_list|)
throw|;
block|}
name|Table
name|table
init|=
literal|null
decl_stmt|;
try|try
block|{
name|table
operator|=
name|db
operator|.
name|getTable
argument_list|(
name|tableName
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|HiveException
name|ex
parameter_list|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ex
argument_list|)
throw|;
block|}
try|try
block|{
name|Partition
name|parMetaData
init|=
name|db
operator|.
name|getPartition
argument_list|(
name|table
argument_list|,
name|partition
argument_list|,
literal|false
argument_list|)
decl_stmt|;
comment|// Check partition exists if it exists skip the overwrite
if|if
condition|(
name|parMetaData
operator|!=
literal|null
condition|)
block|{
name|phase1Result
operator|=
literal|false
expr_stmt|;
name|skipRecursion
operator|=
literal|true
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Partition already exists so insert into overwrite "
operator|+
literal|"skipped for partition : "
operator|+
name|parMetaData
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
catch|catch
parameter_list|(
name|HiveException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Error while getting metadata : "
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
name|validatePartSpec
argument_list|(
name|table
argument_list|,
name|partition
argument_list|,
operator|(
name|ASTNode
operator|)
name|tab
argument_list|,
name|conf
argument_list|)
expr_stmt|;
block|}
name|skipRecursion
operator|=
literal|false
expr_stmt|;
break|break;
case|case
name|HiveParser
operator|.
name|TOK_LATERAL_VIEW
case|:
case|case
name|HiveParser
operator|.
name|TOK_LATERAL_VIEW_OUTER
case|:
comment|// todo: nested LV
assert|assert
name|ast
operator|.
name|getChildCount
argument_list|()
operator|==
literal|1
assert|;
name|qb
operator|.
name|getParseInfo
argument_list|()
operator|.
name|getDestToLateralView
argument_list|()
operator|.
name|put
argument_list|(
name|ctx_1
operator|.
name|dest
argument_list|,
name|ast
argument_list|)
expr_stmt|;
break|break;
default|default:
name|skipRecursion
operator|=
literal|false
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|skipRecursion
condition|)
block|{
comment|// Iterate over the rest of the children
name|int
name|child_count
init|=
name|ast
operator|.
name|getChildCount
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|child_pos
init|=
literal|0
init|;
name|child_pos
operator|<
name|child_count
operator|&&
name|phase1Result
condition|;
operator|++
name|child_pos
control|)
block|{
comment|// Recurse
name|phase1Result
operator|=
name|phase1Result
operator|&&
name|doPhase1
argument_list|(
operator|(
name|ASTNode
operator|)
name|ast
operator|.
name|getChild
argument_list|(
name|child_pos
argument_list|)
argument_list|,
name|qb
argument_list|,
name|ctx_1
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|phase1Result
return|;
block|}
specifier|private
name|void
name|getMetaData
parameter_list|(
name|QBExpr
name|qbexpr
parameter_list|)
throws|throws
name|SemanticException
block|{
name|getMetaData
argument_list|(
name|qbexpr
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|getMetaData
parameter_list|(
name|QBExpr
name|qbexpr
parameter_list|,
name|ReadEntity
name|parentInput
parameter_list|)
throws|throws
name|SemanticException
block|{
if|if
condition|(
name|qbexpr
operator|.
name|getOpcode
argument_list|()
operator|==
name|QBExpr
operator|.
name|Opcode
operator|.
name|NULLOP
condition|)
block|{
name|getMetaData
argument_list|(
name|qbexpr
operator|.
name|getQB
argument_list|()
argument_list|,
name|parentInput
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|getMetaData
argument_list|(
name|qbexpr
operator|.
name|getQBExpr1
argument_list|()
argument_list|,
name|parentInput
argument_list|)
expr_stmt|;
name|getMetaData
argument_list|(
name|qbexpr
operator|.
name|getQBExpr2
argument_list|()
argument_list|,
name|parentInput
argument_list|)
expr_stmt|;
block|}
block|}
specifier|public
name|void
name|getMetaData
parameter_list|(
name|QB
name|qb
parameter_list|)
throws|throws
name|SemanticException
block|{
name|getMetaData
argument_list|(
name|qb
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"nls"
argument_list|)
specifier|public
name|void
name|getMetaData
parameter_list|(
name|QB
name|qb
parameter_list|,
name|ReadEntity
name|parentInput
parameter_list|)
throws|throws
name|SemanticException
block|{
try|try
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Get metadata for source tables"
argument_list|)
expr_stmt|;
comment|// Go over the tables and populate the related structures.
comment|// We have to materialize the table alias list since we might
comment|// modify it in the middle for view rewrite.
name|List
argument_list|<
name|String
argument_list|>
name|tabAliases
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|(
name|qb
operator|.
name|getTabAliases
argument_list|()
argument_list|)
decl_stmt|;
comment|// Keep track of view alias to view name and read entity
comment|// For eg: for a query like 'select * from V3', where V3 -> V2, V2 -> V1, V1 -> T
comment|// keeps track of full view name and read entity corresponding to alias V3, V3:V2, V3:V2:V1.
comment|// This is needed for tracking the dependencies for inputs, along with their parents.
name|Map
argument_list|<
name|String
argument_list|,
name|ObjectPair
argument_list|<
name|String
argument_list|,
name|ReadEntity
argument_list|>
argument_list|>
name|aliasToViewInfo
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|ObjectPair
argument_list|<
name|String
argument_list|,
name|ReadEntity
argument_list|>
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|String
name|alias
range|:
name|tabAliases
control|)
block|{
name|String
name|tab_name
init|=
name|qb
operator|.
name|getTabNameForAlias
argument_list|(
name|alias
argument_list|)
decl_stmt|;
name|Table
name|tab
init|=
literal|null
decl_stmt|;
try|try
block|{
name|tab
operator|=
name|db
operator|.
name|getTable
argument_list|(
name|tab_name
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InvalidTableException
name|ite
parameter_list|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|INVALID_TABLE
operator|.
name|getMsg
argument_list|(
name|qb
operator|.
name|getParseInfo
argument_list|()
operator|.
name|getSrcForAlias
argument_list|(
name|alias
argument_list|)
argument_list|)
argument_list|)
throw|;
block|}
comment|// Disallow INSERT INTO on bucketized tables
if|if
condition|(
name|qb
operator|.
name|getParseInfo
argument_list|()
operator|.
name|isInsertIntoTable
argument_list|(
name|tab
operator|.
name|getDbName
argument_list|()
argument_list|,
name|tab
operator|.
name|getTableName
argument_list|()
argument_list|)
operator|&&
name|tab
operator|.
name|getNumBuckets
argument_list|()
operator|>
literal|0
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|INSERT_INTO_BUCKETIZED_TABLE
operator|.
name|getMsg
argument_list|(
literal|"Table: "
operator|+
name|tab_name
argument_list|)
argument_list|)
throw|;
block|}
comment|// We check offline of the table, as if people only select from an
comment|// non-existing partition of an offline table, the partition won't
comment|// be added to inputs and validate() won't have the information to
comment|// check the table's offline status.
comment|// TODO: Modify the code to remove the checking here and consolidate
comment|// it in validate()
comment|//
if|if
condition|(
name|tab
operator|.
name|isOffline
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|OFFLINE_TABLE_OR_PARTITION
operator|.
name|getMsg
argument_list|(
literal|"Table "
operator|+
name|getUnescapedName
argument_list|(
name|qb
operator|.
name|getParseInfo
argument_list|()
operator|.
name|getSrcForAlias
argument_list|(
name|alias
argument_list|)
argument_list|)
argument_list|)
argument_list|)
throw|;
block|}
if|if
condition|(
name|tab
operator|.
name|isView
argument_list|()
condition|)
block|{
if|if
condition|(
name|qb
operator|.
name|getParseInfo
argument_list|()
operator|.
name|isAnalyzeCommand
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|ANALYZE_VIEW
operator|.
name|getMsg
argument_list|()
argument_list|)
throw|;
block|}
name|String
name|fullViewName
init|=
name|tab
operator|.
name|getDbName
argument_list|()
operator|+
literal|"."
operator|+
name|tab
operator|.
name|getTableName
argument_list|()
decl_stmt|;
comment|// Prevent view cycles
if|if
condition|(
name|viewsExpanded
operator|.
name|contains
argument_list|(
name|fullViewName
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
literal|"Recursive view "
operator|+
name|fullViewName
operator|+
literal|" detected (cycle: "
operator|+
name|StringUtils
operator|.
name|join
argument_list|(
name|viewsExpanded
argument_list|,
literal|" -> "
argument_list|)
operator|+
literal|" -> "
operator|+
name|fullViewName
operator|+
literal|")."
argument_list|)
throw|;
block|}
name|replaceViewReferenceWithDefinition
argument_list|(
name|qb
argument_list|,
name|tab
argument_list|,
name|tab_name
argument_list|,
name|alias
argument_list|)
expr_stmt|;
comment|// This is the last time we'll see the Table objects for views, so add it to the inputs
comment|// now
name|ReadEntity
name|viewInput
init|=
operator|new
name|ReadEntity
argument_list|(
name|tab
argument_list|,
name|parentInput
argument_list|)
decl_stmt|;
name|viewInput
operator|=
name|PlanUtils
operator|.
name|addInput
argument_list|(
name|inputs
argument_list|,
name|viewInput
argument_list|)
expr_stmt|;
name|aliasToViewInfo
operator|.
name|put
argument_list|(
name|alias
argument_list|,
operator|new
name|ObjectPair
argument_list|<
name|String
argument_list|,
name|ReadEntity
argument_list|>
argument_list|(
name|fullViewName
argument_list|,
name|viewInput
argument_list|)
argument_list|)
expr_stmt|;
name|viewAliasToInput
operator|.
name|put
argument_list|(
name|getAliasId
argument_list|(
name|alias
argument_list|,
name|qb
argument_list|)
argument_list|,
name|viewInput
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|!
name|InputFormat
operator|.
name|class
operator|.
name|isAssignableFrom
argument_list|(
name|tab
operator|.
name|getInputFormatClass
argument_list|()
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|generateErrorMessage
argument_list|(
name|qb
operator|.
name|getParseInfo
argument_list|()
operator|.
name|getSrcForAlias
argument_list|(
name|alias
argument_list|)
argument_list|,
name|ErrorMsg
operator|.
name|INVALID_INPUT_FORMAT_TYPE
operator|.
name|getMsg
argument_list|()
argument_list|)
argument_list|)
throw|;
block|}
name|qb
operator|.
name|getMetaData
argument_list|()
operator|.
name|setSrcForAlias
argument_list|(
name|alias
argument_list|,
name|tab
argument_list|)
expr_stmt|;
if|if
condition|(
name|qb
operator|.
name|getParseInfo
argument_list|()
operator|.
name|isAnalyzeCommand
argument_list|()
condition|)
block|{
comment|// allow partial partition specification for nonscan since noscan is fast.
name|tableSpec
name|ts
init|=
operator|new
name|tableSpec
argument_list|(
name|db
argument_list|,
name|conf
argument_list|,
operator|(
name|ASTNode
operator|)
name|ast
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
argument_list|,
literal|true
argument_list|,
name|this
operator|.
name|noscan
argument_list|)
decl_stmt|;
if|if
condition|(
name|ts
operator|.
name|specType
operator|==
name|SpecType
operator|.
name|DYNAMIC_PARTITION
condition|)
block|{
comment|// dynamic partitions
try|try
block|{
name|ts
operator|.
name|partitions
operator|=
name|db
operator|.
name|getPartitionsByNames
argument_list|(
name|ts
operator|.
name|tableHandle
argument_list|,
name|ts
operator|.
name|partSpec
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|HiveException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|generateErrorMessage
argument_list|(
name|qb
operator|.
name|getParseInfo
argument_list|()
operator|.
name|getSrcForAlias
argument_list|(
name|alias
argument_list|)
argument_list|,
literal|"Cannot get partitions for "
operator|+
name|ts
operator|.
name|partSpec
argument_list|)
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
comment|// validate partial scan command
name|QBParseInfo
name|qbpi
init|=
name|qb
operator|.
name|getParseInfo
argument_list|()
decl_stmt|;
if|if
condition|(
name|qbpi
operator|.
name|isPartialScanAnalyzeCommand
argument_list|()
condition|)
block|{
name|Class
argument_list|<
name|?
extends|extends
name|InputFormat
argument_list|>
name|inputFormatClass
init|=
literal|null
decl_stmt|;
switch|switch
condition|(
name|ts
operator|.
name|specType
condition|)
block|{
case|case
name|TABLE_ONLY
case|:
name|inputFormatClass
operator|=
name|ts
operator|.
name|tableHandle
operator|.
name|getInputFormatClass
argument_list|()
expr_stmt|;
break|break;
case|case
name|STATIC_PARTITION
case|:
name|inputFormatClass
operator|=
name|ts
operator|.
name|partHandle
operator|.
name|getInputFormatClass
argument_list|()
expr_stmt|;
break|break;
default|default:
assert|assert
literal|false
assert|;
block|}
comment|// throw a HiveException for non-rcfile.
if|if
condition|(
operator|!
name|inputFormatClass
operator|.
name|equals
argument_list|(
name|RCFileInputFormat
operator|.
name|class
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|ANALYZE_TABLE_PARTIALSCAN_NON_RCFILE
operator|.
name|getMsg
argument_list|()
argument_list|)
throw|;
block|}
block|}
name|qb
operator|.
name|getParseInfo
argument_list|()
operator|.
name|addTableSpec
argument_list|(
name|alias
argument_list|,
name|ts
argument_list|)
expr_stmt|;
block|}
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"Get metadata for subqueries"
argument_list|)
expr_stmt|;
comment|// Go over the subqueries and getMetaData for these
for|for
control|(
name|String
name|alias
range|:
name|qb
operator|.
name|getSubqAliases
argument_list|()
control|)
block|{
name|boolean
name|wasView
init|=
name|aliasToViewInfo
operator|.
name|containsKey
argument_list|(
name|alias
argument_list|)
decl_stmt|;
name|ReadEntity
name|newParentInput
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|wasView
condition|)
block|{
name|viewsExpanded
operator|.
name|add
argument_list|(
name|aliasToViewInfo
operator|.
name|get
argument_list|(
name|alias
argument_list|)
operator|.
name|getFirst
argument_list|()
argument_list|)
expr_stmt|;
name|newParentInput
operator|=
name|aliasToViewInfo
operator|.
name|get
argument_list|(
name|alias
argument_list|)
operator|.
name|getSecond
argument_list|()
expr_stmt|;
block|}
name|QBExpr
name|qbexpr
init|=
name|qb
operator|.
name|getSubqForAlias
argument_list|(
name|alias
argument_list|)
decl_stmt|;
name|getMetaData
argument_list|(
name|qbexpr
argument_list|,
name|newParentInput
argument_list|)
expr_stmt|;
if|if
condition|(
name|wasView
condition|)
block|{
name|viewsExpanded
operator|.
name|remove
argument_list|(
name|viewsExpanded
operator|.
name|size
argument_list|()
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
name|RowFormatParams
name|rowFormatParams
init|=
operator|new
name|RowFormatParams
argument_list|()
decl_stmt|;
name|AnalyzeCreateCommonVars
name|shared
init|=
operator|new
name|AnalyzeCreateCommonVars
argument_list|()
decl_stmt|;
name|StorageFormat
name|storageFormat
init|=
operator|new
name|StorageFormat
argument_list|()
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Get metadata for destination tables"
argument_list|)
expr_stmt|;
comment|// Go over all the destination structures and populate the related
comment|// metadata
name|QBParseInfo
name|qbp
init|=
name|qb
operator|.
name|getParseInfo
argument_list|()
decl_stmt|;
for|for
control|(
name|String
name|name
range|:
name|qbp
operator|.
name|getClauseNamesForDest
argument_list|()
control|)
block|{
name|ASTNode
name|ast
init|=
name|qbp
operator|.
name|getDestForClause
argument_list|(
name|name
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|ast
operator|.
name|getToken
argument_list|()
operator|.
name|getType
argument_list|()
condition|)
block|{
case|case
name|HiveParser
operator|.
name|TOK_TAB
case|:
block|{
name|tableSpec
name|ts
init|=
operator|new
name|tableSpec
argument_list|(
name|db
argument_list|,
name|conf
argument_list|,
name|ast
argument_list|)
decl_stmt|;
if|if
condition|(
name|ts
operator|.
name|tableHandle
operator|.
name|isView
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|DML_AGAINST_VIEW
operator|.
name|getMsg
argument_list|()
argument_list|)
throw|;
block|}
name|Class
argument_list|<
name|?
argument_list|>
name|outputFormatClass
init|=
name|ts
operator|.
name|tableHandle
operator|.
name|getOutputFormatClass
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|HiveOutputFormat
operator|.
name|class
operator|.
name|isAssignableFrom
argument_list|(
name|outputFormatClass
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|INVALID_OUTPUT_FORMAT_TYPE
operator|.
name|getMsg
argument_list|(
name|ast
argument_list|,
literal|"The class is "
operator|+
name|outputFormatClass
operator|.
name|toString
argument_list|()
argument_list|)
argument_list|)
throw|;
block|}
comment|// tableSpec ts is got from the query (user specified),
comment|// which means the user didn't specify partitions in their query,
comment|// but whether the table itself is partitioned is not know.
if|if
condition|(
name|ts
operator|.
name|specType
operator|!=
name|SpecType
operator|.
name|STATIC_PARTITION
condition|)
block|{
comment|// This is a table or dynamic partition
name|qb
operator|.
name|getMetaData
argument_list|()
operator|.
name|setDestForAlias
argument_list|(
name|name
argument_list|,
name|ts
operator|.
name|tableHandle
argument_list|)
expr_stmt|;
comment|// has dynamic as well as static partitions
if|if
condition|(
name|ts
operator|.
name|partSpec
operator|!=
literal|null
operator|&&
name|ts
operator|.
name|partSpec
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
name|qb
operator|.
name|getMetaData
argument_list|()
operator|.
name|setPartSpecForAlias
argument_list|(
name|name
argument_list|,
name|ts
operator|.
name|partSpec
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// This is a partition
name|qb
operator|.
name|getMetaData
argument_list|()
operator|.
name|setDestForAlias
argument_list|(
name|name
argument_list|,
name|ts
operator|.
name|partHandle
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|HiveConf
operator|.
name|getBoolVar
argument_list|(
name|conf
argument_list|,
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVESTATSAUTOGATHER
argument_list|)
condition|)
block|{
comment|// Set that variable to automatically collect stats during the MapReduce job
name|qb
operator|.
name|getParseInfo
argument_list|()
operator|.
name|setIsInsertToTable
argument_list|(
literal|true
argument_list|)
expr_stmt|;
comment|// Add the table spec for the destination table.
name|qb
operator|.
name|getParseInfo
argument_list|()
operator|.
name|addTableSpec
argument_list|(
name|ts
operator|.
name|tableName
operator|.
name|toLowerCase
argument_list|()
argument_list|,
name|ts
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
case|case
name|HiveParser
operator|.
name|TOK_LOCAL_DIR
case|:
case|case
name|HiveParser
operator|.
name|TOK_DIR
case|:
block|{
comment|// This is a dfs file
name|String
name|fname
init|=
name|stripQuotes
argument_list|(
name|ast
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getText
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
operator|!
name|qb
operator|.
name|getParseInfo
argument_list|()
operator|.
name|getIsSubQ
argument_list|()
operator|)
operator|&&
operator|(
operator|(
operator|(
name|ASTNode
operator|)
name|ast
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|)
operator|.
name|getToken
argument_list|()
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_TMP_FILE
operator|)
condition|)
block|{
if|if
condition|(
name|qb
operator|.
name|isCTAS
argument_list|()
condition|)
block|{
name|qb
operator|.
name|setIsQuery
argument_list|(
literal|false
argument_list|)
expr_stmt|;
name|ctx
operator|.
name|setResDir
argument_list|(
literal|null
argument_list|)
expr_stmt|;
name|ctx
operator|.
name|setResFile
argument_list|(
literal|null
argument_list|)
expr_stmt|;
comment|// allocate a temporary output dir on the location of the table
name|String
name|tableName
init|=
name|getUnescapedName
argument_list|(
operator|(
name|ASTNode
operator|)
name|ast
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|Table
name|newTable
init|=
name|db
operator|.
name|newTable
argument_list|(
name|tableName
argument_list|)
decl_stmt|;
name|Path
name|location
decl_stmt|;
try|try
block|{
name|Warehouse
name|wh
init|=
operator|new
name|Warehouse
argument_list|(
name|conf
argument_list|)
decl_stmt|;
name|location
operator|=
name|wh
operator|.
name|getDatabasePath
argument_list|(
name|db
operator|.
name|getDatabase
argument_list|(
name|newTable
operator|.
name|getDbName
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|MetaException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|e
argument_list|)
throw|;
block|}
try|try
block|{
name|fname
operator|=
name|ctx
operator|.
name|getExternalTmpFileURI
argument_list|(
name|FileUtils
operator|.
name|makeQualified
argument_list|(
name|location
argument_list|,
name|conf
argument_list|)
operator|.
name|toUri
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|generateErrorMessage
argument_list|(
name|ast
argument_list|,
literal|"Error creating temporary folder on: "
operator|+
name|location
operator|.
name|toString
argument_list|()
argument_list|)
argument_list|,
name|e
argument_list|)
throw|;
block|}
if|if
condition|(
name|HiveConf
operator|.
name|getBoolVar
argument_list|(
name|conf
argument_list|,
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVESTATSAUTOGATHER
argument_list|)
condition|)
block|{
name|tableSpec
name|ts
init|=
operator|new
name|tableSpec
argument_list|(
name|db
argument_list|,
name|conf
argument_list|,
name|this
operator|.
name|ast
argument_list|)
decl_stmt|;
comment|// Set that variable to automatically collect stats during the MapReduce job
name|qb
operator|.
name|getParseInfo
argument_list|()
operator|.
name|setIsInsertToTable
argument_list|(
literal|true
argument_list|)
expr_stmt|;
comment|// Add the table spec for the destination table.
name|qb
operator|.
name|getParseInfo
argument_list|()
operator|.
name|addTableSpec
argument_list|(
name|ts
operator|.
name|tableName
operator|.
name|toLowerCase
argument_list|()
argument_list|,
name|ts
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|qb
operator|.
name|setIsQuery
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|fname
operator|=
name|ctx
operator|.
name|getMRTmpFileURI
argument_list|()
expr_stmt|;
name|ctx
operator|.
name|setResDir
argument_list|(
operator|new
name|Path
argument_list|(
name|fname
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|qb
operator|.
name|getMetaData
argument_list|()
operator|.
name|setDestForAlias
argument_list|(
name|name
argument_list|,
name|fname
argument_list|,
operator|(
name|ast
operator|.
name|getToken
argument_list|()
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_DIR
operator|)
argument_list|)
expr_stmt|;
name|CreateTableDesc
name|localDirectoryDesc
init|=
operator|new
name|CreateTableDesc
argument_list|()
decl_stmt|;
name|boolean
name|localDirectoryDescIsSet
init|=
literal|false
decl_stmt|;
name|int
name|numCh
init|=
name|ast
operator|.
name|getChildCount
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|num
init|=
literal|1
init|;
name|num
operator|<
name|numCh
condition|;
name|num
operator|++
control|)
block|{
name|ASTNode
name|child
init|=
operator|(
name|ASTNode
operator|)
name|ast
operator|.
name|getChild
argument_list|(
name|num
argument_list|)
decl_stmt|;
if|if
condition|(
name|ast
operator|.
name|getChild
argument_list|(
name|num
argument_list|)
operator|!=
literal|null
condition|)
block|{
switch|switch
condition|(
name|child
operator|.
name|getToken
argument_list|()
operator|.
name|getType
argument_list|()
condition|)
block|{
case|case
name|HiveParser
operator|.
name|TOK_TABLEROWFORMAT
case|:
name|rowFormatParams
operator|.
name|analyzeRowFormat
argument_list|(
name|shared
argument_list|,
name|child
argument_list|)
expr_stmt|;
name|localDirectoryDesc
operator|.
name|setFieldDelim
argument_list|(
name|rowFormatParams
operator|.
name|fieldDelim
argument_list|)
expr_stmt|;
name|localDirectoryDesc
operator|.
name|setLineDelim
argument_list|(
name|rowFormatParams
operator|.
name|lineDelim
argument_list|)
expr_stmt|;
name|localDirectoryDesc
operator|.
name|setCollItemDelim
argument_list|(
name|rowFormatParams
operator|.
name|collItemDelim
argument_list|)
expr_stmt|;
name|localDirectoryDesc
operator|.
name|setMapKeyDelim
argument_list|(
name|rowFormatParams
operator|.
name|mapKeyDelim
argument_list|)
expr_stmt|;
name|localDirectoryDesc
operator|.
name|setFieldEscape
argument_list|(
name|rowFormatParams
operator|.
name|fieldEscape
argument_list|)
expr_stmt|;
name|localDirectoryDesc
operator|.
name|setNullFormat
argument_list|(
name|rowFormatParams
operator|.
name|nullFormat
argument_list|)
expr_stmt|;
name|localDirectoryDescIsSet
operator|=
literal|true
expr_stmt|;
break|break;
case|case
name|HiveParser
operator|.
name|TOK_TABLESERIALIZER
case|:
name|ASTNode
name|serdeChild
init|=
operator|(
name|ASTNode
operator|)
name|child
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|shared
operator|.
name|serde
operator|=
name|unescapeSQLString
argument_list|(
name|serdeChild
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getText
argument_list|()
argument_list|)
expr_stmt|;
name|localDirectoryDesc
operator|.
name|setSerName
argument_list|(
name|shared
operator|.
name|serde
argument_list|)
expr_stmt|;
name|localDirectoryDescIsSet
operator|=
literal|true
expr_stmt|;
break|break;
case|case
name|HiveParser
operator|.
name|TOK_TBLSEQUENCEFILE
case|:
case|case
name|HiveParser
operator|.
name|TOK_TBLTEXTFILE
case|:
case|case
name|HiveParser
operator|.
name|TOK_TBLRCFILE
case|:
case|case
name|HiveParser
operator|.
name|TOK_TBLORCFILE
case|:
case|case
name|HiveParser
operator|.
name|TOK_TABLEFILEFORMAT
case|:
name|storageFormat
operator|.
name|fillStorageFormat
argument_list|(
name|child
argument_list|,
name|shared
argument_list|)
expr_stmt|;
name|localDirectoryDesc
operator|.
name|setOutputFormat
argument_list|(
name|storageFormat
operator|.
name|outputFormat
argument_list|)
expr_stmt|;
name|localDirectoryDesc
operator|.
name|setSerName
argument_list|(
name|shared
operator|.
name|serde
argument_list|)
expr_stmt|;
name|localDirectoryDescIsSet
operator|=
literal|true
expr_stmt|;
break|break;
block|}
block|}
block|}
if|if
condition|(
name|localDirectoryDescIsSet
condition|)
block|{
name|qb
operator|.
name|setLocalDirectoryDesc
argument_list|(
name|localDirectoryDesc
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
default|default:
throw|throw
operator|new
name|SemanticException
argument_list|(
name|generateErrorMessage
argument_list|(
name|ast
argument_list|,
literal|"Unknown Token Type "
operator|+
name|ast
operator|.
name|getToken
argument_list|()
operator|.
name|getType
argument_list|()
argument_list|)
argument_list|)
throw|;
block|}
block|}
block|}
catch|catch
parameter_list|(
name|HiveException
name|e
parameter_list|)
block|{
comment|// Has to use full name to make sure it does not conflict with
comment|// org.apache.commons.lang.StringUtils
name|LOG
operator|.
name|error
argument_list|(
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|StringUtils
operator|.
name|stringifyException
argument_list|(
name|e
argument_list|)
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|SemanticException
argument_list|(
name|e
operator|.
name|getMessage
argument_list|()
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
specifier|private
name|void
name|replaceViewReferenceWithDefinition
parameter_list|(
name|QB
name|qb
parameter_list|,
name|Table
name|tab
parameter_list|,
name|String
name|tab_name
parameter_list|,
name|String
name|alias
parameter_list|)
throws|throws
name|SemanticException
block|{
name|ParseDriver
name|pd
init|=
operator|new
name|ParseDriver
argument_list|()
decl_stmt|;
name|ASTNode
name|viewTree
decl_stmt|;
specifier|final
name|ASTNodeOrigin
name|viewOrigin
init|=
operator|new
name|ASTNodeOrigin
argument_list|(
literal|"VIEW"
argument_list|,
name|tab
operator|.
name|getTableName
argument_list|()
argument_list|,
name|tab
operator|.
name|getViewExpandedText
argument_list|()
argument_list|,
name|alias
argument_list|,
name|qb
operator|.
name|getParseInfo
argument_list|()
operator|.
name|getSrcForAlias
argument_list|(
name|alias
argument_list|)
argument_list|)
decl_stmt|;
try|try
block|{
name|String
name|viewText
init|=
name|tab
operator|.
name|getViewExpandedText
argument_list|()
decl_stmt|;
comment|// Reparse text, passing null for context to avoid clobbering
comment|// the top-level token stream.
name|ASTNode
name|tree
init|=
name|pd
operator|.
name|parse
argument_list|(
name|viewText
argument_list|,
name|ctx
argument_list|,
literal|false
argument_list|)
decl_stmt|;
name|tree
operator|=
name|ParseUtils
operator|.
name|findRootNonNullToken
argument_list|(
name|tree
argument_list|)
expr_stmt|;
name|viewTree
operator|=
name|tree
expr_stmt|;
name|Dispatcher
name|nodeOriginDispatcher
init|=
operator|new
name|Dispatcher
argument_list|()
block|{
specifier|public
name|Object
name|dispatch
parameter_list|(
name|Node
name|nd
parameter_list|,
name|java
operator|.
name|util
operator|.
name|Stack
argument_list|<
name|Node
argument_list|>
name|stack
parameter_list|,
name|Object
modifier|...
name|nodeOutputs
parameter_list|)
block|{
operator|(
operator|(
name|ASTNode
operator|)
name|nd
operator|)
operator|.
name|setOrigin
argument_list|(
name|viewOrigin
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
block|}
decl_stmt|;
name|GraphWalker
name|nodeOriginTagger
init|=
operator|new
name|DefaultGraphWalker
argument_list|(
name|nodeOriginDispatcher
argument_list|)
decl_stmt|;
name|nodeOriginTagger
operator|.
name|startWalking
argument_list|(
name|java
operator|.
name|util
operator|.
name|Collections
operator|.
expr|<
name|Node
operator|>
name|singleton
argument_list|(
name|viewTree
argument_list|)
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|ParseException
name|e
parameter_list|)
block|{
comment|// A user could encounter this if a stored view definition contains
comment|// an old SQL construct which has been eliminated in a later Hive
comment|// version, so we need to provide full debugging info to help
comment|// with fixing the view definition.
name|LOG
operator|.
name|error
argument_list|(
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|StringUtils
operator|.
name|stringifyException
argument_list|(
name|e
argument_list|)
argument_list|)
expr_stmt|;
name|StringBuilder
name|sb
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|sb
operator|.
name|append
argument_list|(
name|e
operator|.
name|getMessage
argument_list|()
argument_list|)
expr_stmt|;
name|ErrorMsg
operator|.
name|renderOrigin
argument_list|(
name|sb
argument_list|,
name|viewOrigin
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|SemanticException
argument_list|(
name|sb
operator|.
name|toString
argument_list|()
argument_list|,
name|e
argument_list|)
throw|;
block|}
name|QBExpr
name|qbexpr
init|=
operator|new
name|QBExpr
argument_list|(
name|alias
argument_list|)
decl_stmt|;
name|doPhase1QBExpr
argument_list|(
name|viewTree
argument_list|,
name|qbexpr
argument_list|,
name|qb
operator|.
name|getId
argument_list|()
argument_list|,
name|alias
argument_list|)
expr_stmt|;
name|qb
operator|.
name|rewriteViewToSubq
argument_list|(
name|alias
argument_list|,
name|tab_name
argument_list|,
name|qbexpr
argument_list|)
expr_stmt|;
block|}
specifier|private
name|boolean
name|isPresent
parameter_list|(
name|String
index|[]
name|list
parameter_list|,
name|String
name|elem
parameter_list|)
block|{
for|for
control|(
name|String
name|s
range|:
name|list
control|)
block|{
if|if
condition|(
name|s
operator|.
name|toLowerCase
argument_list|()
operator|.
name|equals
argument_list|(
name|elem
argument_list|)
condition|)
block|{
return|return
literal|true
return|;
block|}
block|}
return|return
literal|false
return|;
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"nls"
argument_list|)
name|void
name|parseJoinCondPopulateAlias
parameter_list|(
name|QBJoinTree
name|joinTree
parameter_list|,
name|ASTNode
name|condn
parameter_list|,
name|ArrayList
argument_list|<
name|String
argument_list|>
name|leftAliases
parameter_list|,
name|ArrayList
argument_list|<
name|String
argument_list|>
name|rightAliases
parameter_list|,
name|ArrayList
argument_list|<
name|String
argument_list|>
name|fields
parameter_list|)
throws|throws
name|SemanticException
block|{
comment|// String[] allAliases = joinTree.getAllAliases();
switch|switch
condition|(
name|condn
operator|.
name|getToken
argument_list|()
operator|.
name|getType
argument_list|()
condition|)
block|{
case|case
name|HiveParser
operator|.
name|TOK_TABLE_OR_COL
case|:
name|String
name|tableOrCol
init|=
name|unescapeIdentifier
argument_list|(
name|condn
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getText
argument_list|()
operator|.
name|toLowerCase
argument_list|()
argument_list|)
decl_stmt|;
name|unparseTranslator
operator|.
name|addIdentifierTranslation
argument_list|(
operator|(
name|ASTNode
operator|)
name|condn
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|isPresent
argument_list|(
name|joinTree
operator|.
name|getLeftAliases
argument_list|()
argument_list|,
name|tableOrCol
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|leftAliases
operator|.
name|contains
argument_list|(
name|tableOrCol
argument_list|)
condition|)
block|{
name|leftAliases
operator|.
name|add
argument_list|(
name|tableOrCol
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|isPresent
argument_list|(
name|joinTree
operator|.
name|getRightAliases
argument_list|()
argument_list|,
name|tableOrCol
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|rightAliases
operator|.
name|contains
argument_list|(
name|tableOrCol
argument_list|)
condition|)
block|{
name|rightAliases
operator|.
name|add
argument_list|(
name|tableOrCol
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// We don't support columns without table prefix in JOIN condition right
comment|// now.
comment|// We need to pass Metadata here to know which table the column belongs
comment|// to.
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|INVALID_TABLE_ALIAS
operator|.
name|getMsg
argument_list|(
name|condn
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
argument_list|)
argument_list|)
throw|;
block|}
break|break;
case|case
name|HiveParser
operator|.
name|Identifier
case|:
comment|// it may be a field name, return the identifier and let the caller decide
comment|// whether it is or not
if|if
condition|(
name|fields
operator|!=
literal|null
condition|)
block|{
name|fields
operator|.
name|add
argument_list|(
name|unescapeIdentifier
argument_list|(
name|condn
operator|.
name|getToken
argument_list|()
operator|.
name|getText
argument_list|()
operator|.
name|toLowerCase
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|unparseTranslator
operator|.
name|addIdentifierTranslation
argument_list|(
name|condn
argument_list|)
expr_stmt|;
break|break;
case|case
name|HiveParser
operator|.
name|Number
case|:
case|case
name|HiveParser
operator|.
name|StringLiteral
case|:
case|case
name|HiveParser
operator|.
name|BigintLiteral
case|:
case|case
name|HiveParser
operator|.
name|SmallintLiteral
case|:
case|case
name|HiveParser
operator|.
name|TinyintLiteral
case|:
case|case
name|HiveParser
operator|.
name|DecimalLiteral
case|:
case|case
name|HiveParser
operator|.
name|TOK_STRINGLITERALSEQUENCE
case|:
case|case
name|HiveParser
operator|.
name|TOK_CHARSETLITERAL
case|:
case|case
name|HiveParser
operator|.
name|KW_TRUE
case|:
case|case
name|HiveParser
operator|.
name|KW_FALSE
case|:
break|break;
case|case
name|HiveParser
operator|.
name|TOK_FUNCTION
case|:
comment|// check all the arguments
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<
name|condn
operator|.
name|getChildCount
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|parseJoinCondPopulateAlias
argument_list|(
name|joinTree
argument_list|,
operator|(
name|ASTNode
operator|)
name|condn
operator|.
name|getChild
argument_list|(
name|i
argument_list|)
argument_list|,
name|leftAliases
argument_list|,
name|rightAliases
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
comment|// This is an operator - so check whether it is unary or binary operator
if|if
condition|(
name|condn
operator|.
name|getChildCount
argument_list|()
operator|==
literal|1
condition|)
block|{
name|parseJoinCondPopulateAlias
argument_list|(
name|joinTree
argument_list|,
operator|(
name|ASTNode
operator|)
name|condn
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
argument_list|,
name|leftAliases
argument_list|,
name|rightAliases
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|condn
operator|.
name|getChildCount
argument_list|()
operator|==
literal|2
condition|)
block|{
name|ArrayList
argument_list|<
name|String
argument_list|>
name|fields1
init|=
literal|null
decl_stmt|;
comment|// if it is a dot operator, remember the field name of the rhs of the
comment|// left semijoin
if|if
condition|(
name|joinTree
operator|.
name|getNoSemiJoin
argument_list|()
operator|==
literal|false
operator|&&
name|condn
operator|.
name|getToken
argument_list|()
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|DOT
condition|)
block|{
comment|// get the semijoin rhs table name and field name
name|fields1
operator|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
expr_stmt|;
name|int
name|rhssize
init|=
name|rightAliases
operator|.
name|size
argument_list|()
decl_stmt|;
name|parseJoinCondPopulateAlias
argument_list|(
name|joinTree
argument_list|,
operator|(
name|ASTNode
operator|)
name|condn
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
argument_list|,
name|leftAliases
argument_list|,
name|rightAliases
argument_list|,
literal|null
argument_list|)
expr_stmt|;
name|String
name|rhsAlias
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|rightAliases
operator|.
name|size
argument_list|()
operator|>
name|rhssize
condition|)
block|{
comment|// the new table is rhs table
name|rhsAlias
operator|=
name|rightAliases
operator|.
name|get
argument_list|(
name|rightAliases
operator|.
name|size
argument_list|()
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
name|parseJoinCondPopulateAlias
argument_list|(
name|joinTree
argument_list|,
operator|(
name|ASTNode
operator|)
name|condn
operator|.
name|getChild
argument_list|(
literal|1
argument_list|)
argument_list|,
name|leftAliases
argument_list|,
name|rightAliases
argument_list|,
name|fields1
argument_list|)
expr_stmt|;
if|if
condition|(
name|rhsAlias
operator|!=
literal|null
operator|&&
name|fields1
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
name|joinTree
operator|.
name|addRHSSemijoinColumns
argument_list|(
name|rhsAlias
argument_list|,
name|condn
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|parseJoinCondPopulateAlias
argument_list|(
name|joinTree
argument_list|,
operator|(
name|ASTNode
operator|)
name|condn
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
argument_list|,
name|leftAliases
argument_list|,
name|rightAliases
argument_list|,
literal|null
argument_list|)
expr_stmt|;
name|parseJoinCondPopulateAlias
argument_list|(
name|joinTree
argument_list|,
operator|(
name|ASTNode
operator|)
name|condn
operator|.
name|getChild
argument_list|(
literal|1
argument_list|)
argument_list|,
name|leftAliases
argument_list|,
name|rightAliases
argument_list|,
name|fields1
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|condn
operator|.
name|toStringTree
argument_list|()
operator|+
literal|" encountered with "
operator|+
name|condn
operator|.
name|getChildCount
argument_list|()
operator|+
literal|" children"
argument_list|)
throw|;
block|}
break|break;
block|}
block|}
specifier|private
name|void
name|populateAliases
parameter_list|(
name|List
argument_list|<
name|String
argument_list|>
name|leftAliases
parameter_list|,
name|List
argument_list|<
name|String
argument_list|>
name|rightAliases
parameter_list|,
name|ASTNode
name|condn
parameter_list|,
name|QBJoinTree
name|joinTree
parameter_list|,
name|List
argument_list|<
name|String
argument_list|>
name|leftSrc
parameter_list|)
throws|throws
name|SemanticException
block|{
if|if
condition|(
operator|(
name|leftAliases
operator|.
name|size
argument_list|()
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|rightAliases
operator|.
name|size
argument_list|()
operator|!=
literal|0
operator|)
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|INVALID_JOIN_CONDITION_1
operator|.
name|getMsg
argument_list|(
name|condn
argument_list|)
argument_list|)
throw|;
block|}
if|if
condition|(
name|rightAliases
operator|.
name|size
argument_list|()
operator|!=
literal|0
condition|)
block|{
assert|assert
name|rightAliases
operator|.
name|size
argument_list|()
operator|==
literal|1
assert|;
name|joinTree
operator|.
name|getExpressions
argument_list|()
operator|.
name|get
argument_list|(
literal|1
argument_list|)
operator|.
name|add
argument_list|(
name|condn
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|leftAliases
operator|.
name|size
argument_list|()
operator|!=
literal|0
condition|)
block|{
name|joinTree
operator|.
name|getExpressions
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|add
argument_list|(
name|condn
argument_list|)
expr_stmt|;
for|for
control|(
name|String
name|s
range|:
name|leftAliases
control|)
block|{
if|if
condition|(
operator|!
name|leftSrc
operator|.
name|contains
argument_list|(
name|s
argument_list|)
condition|)
block|{
name|leftSrc
operator|.
name|add
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|INVALID_JOIN_CONDITION_2
operator|.
name|getMsg
argument_list|(
name|condn
argument_list|)
argument_list|)
throw|;
block|}
block|}
comment|/*    * refactored out of the Equality case of parseJoinCondition    * so that this can be recursively called on its left tree in the case when    * only left sources are referenced in a Predicate    */
name|void
name|applyEqualityPredicateToQBJoinTree
parameter_list|(
name|QBJoinTree
name|joinTree
parameter_list|,
name|JoinType
name|type
parameter_list|,
name|List
argument_list|<
name|String
argument_list|>
name|leftSrc
parameter_list|,
name|ASTNode
name|joinCond
parameter_list|,
name|ASTNode
name|leftCondn
parameter_list|,
name|ASTNode
name|rightCondn
parameter_list|,
name|List
argument_list|<
name|String
argument_list|>
name|leftCondAl1
parameter_list|,
name|List
argument_list|<
name|String
argument_list|>
name|leftCondAl2
parameter_list|,
name|List
argument_list|<
name|String
argument_list|>
name|rightCondAl1
parameter_list|,
name|List
argument_list|<
name|String
argument_list|>
name|rightCondAl2
parameter_list|)
throws|throws
name|SemanticException
block|{
if|if
condition|(
name|leftCondAl1
operator|.
name|size
argument_list|()
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|rightCondAl1
operator|.
name|size
argument_list|()
operator|!=
literal|0
operator|)
operator|||
operator|(
operator|(
name|rightCondAl1
operator|.
name|size
argument_list|()
operator|==
literal|0
operator|)
operator|&&
operator|(
name|rightCondAl2
operator|.
name|size
argument_list|()
operator|==
literal|0
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|type
operator|.
name|equals
argument_list|(
name|JoinType
operator|.
name|LEFTOUTER
argument_list|)
operator|||
name|type
operator|.
name|equals
argument_list|(
name|JoinType
operator|.
name|FULLOUTER
argument_list|)
condition|)
block|{
if|if
condition|(
name|conf
operator|.
name|getBoolVar
argument_list|(
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVEOUTERJOINSUPPORTSFILTERS
argument_list|)
condition|)
block|{
name|joinTree
operator|.
name|getFilters
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|add
argument_list|(
name|joinCond
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|LOG
operator|.
name|warn
argument_list|(
name|ErrorMsg
operator|.
name|OUTERJOIN_USES_FILTERS
argument_list|)
expr_stmt|;
name|joinTree
operator|.
name|getFiltersForPushing
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|add
argument_list|(
name|joinCond
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/*            * If the rhs references table sources and this QBJoinTree has a leftTree;            * hand it to the leftTree and let it recursively handle it.            * There are 3 cases of passing a condition down:            * 1. The leftSide&& rightSide don't contains references to the leftTree's rightAlias            *    => pass the lists down as is.            * 2. The leftSide contains refs to the leftTree's rightAlias, the rightSide doesn't            *    => switch the leftCondAl1 and leftConAl2 lists and pass down.            * 3. The rightSide contains refs to the leftTree's rightAlias, the leftSide doesn't            *    => switch the rightCondAl1 and rightConAl2 lists and pass down.            * 4. In case both contain references to the leftTree's rightAlias            *   => we cannot push the condition down.            * 5. If either contain references to both left& right            *    => we cannot push forward.            */
if|if
condition|(
name|rightCondAl1
operator|.
name|size
argument_list|()
operator|!=
literal|0
condition|)
block|{
name|QBJoinTree
name|leftTree
init|=
name|joinTree
operator|.
name|getJoinSrc
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|leftTreeLeftSrc
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
if|if
condition|(
name|leftTree
operator|!=
literal|null
condition|)
block|{
name|String
name|leftTreeRightSource
init|=
name|leftTree
operator|.
name|getRightAliases
argument_list|()
operator|!=
literal|null
operator|&&
name|leftTree
operator|.
name|getRightAliases
argument_list|()
operator|.
name|length
operator|>
literal|0
condition|?
name|leftTree
operator|.
name|getRightAliases
argument_list|()
index|[
literal|0
index|]
else|:
literal|null
decl_stmt|;
name|boolean
name|leftHasRightReference
init|=
literal|false
decl_stmt|;
for|for
control|(
name|String
name|r
range|:
name|leftCondAl1
control|)
block|{
if|if
condition|(
name|r
operator|.
name|equals
argument_list|(
name|leftTreeRightSource
argument_list|)
condition|)
block|{
name|leftHasRightReference
operator|=
literal|true
expr_stmt|;
break|break;
block|}
block|}
name|boolean
name|rightHasRightReference
init|=
literal|false
decl_stmt|;
for|for
control|(
name|String
name|r
range|:
name|rightCondAl1
control|)
block|{
if|if
condition|(
name|r
operator|.
name|equals
argument_list|(
name|leftTreeRightSource
argument_list|)
condition|)
block|{
name|rightHasRightReference
operator|=
literal|true
expr_stmt|;
break|break;
block|}
block|}
name|boolean
name|pushedDown
init|=
literal|false
decl_stmt|;
if|if
condition|(
operator|!
name|leftHasRightReference
operator|&&
operator|!
name|rightHasRightReference
condition|)
block|{
name|applyEqualityPredicateToQBJoinTree
argument_list|(
name|leftTree
argument_list|,
name|type
argument_list|,
name|leftTreeLeftSrc
argument_list|,
name|joinCond
argument_list|,
name|leftCondn
argument_list|,
name|rightCondn
argument_list|,
name|leftCondAl1
argument_list|,
name|leftCondAl2
argument_list|,
name|rightCondAl1
argument_list|,
name|rightCondAl2
argument_list|)
expr_stmt|;
name|pushedDown
operator|=
literal|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|leftHasRightReference
operator|&&
name|rightHasRightReference
operator|&&
name|rightCondAl1
operator|.
name|size
argument_list|()
operator|==
literal|1
condition|)
block|{
name|applyEqualityPredicateToQBJoinTree
argument_list|(
name|leftTree
argument_list|,
name|type
argument_list|,
name|leftTreeLeftSrc
argument_list|,
name|joinCond
argument_list|,
name|leftCondn
argument_list|,
name|rightCondn
argument_list|,
name|leftCondAl1
argument_list|,
name|leftCondAl2
argument_list|,
name|rightCondAl2
argument_list|,
name|rightCondAl1
argument_list|)
expr_stmt|;
name|pushedDown
operator|=
literal|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|leftHasRightReference
operator|&&
operator|!
name|rightHasRightReference
operator|&&
name|leftCondAl1
operator|.
name|size
argument_list|()
operator|==
literal|1
condition|)
block|{
name|applyEqualityPredicateToQBJoinTree
argument_list|(
name|leftTree
argument_list|,
name|type
argument_list|,
name|leftTreeLeftSrc
argument_list|,
name|joinCond
argument_list|,
name|leftCondn
argument_list|,
name|rightCondn
argument_list|,
name|leftCondAl2
argument_list|,
name|leftCondAl1
argument_list|,
name|rightCondAl1
argument_list|,
name|rightCondAl2
argument_list|)
expr_stmt|;
name|pushedDown
operator|=
literal|true
expr_stmt|;
block|}
if|if
condition|(
name|leftTreeLeftSrc
operator|.
name|size
argument_list|()
operator|==
literal|1
condition|)
block|{
name|leftTree
operator|.
name|setLeftAlias
argument_list|(
name|leftTreeLeftSrc
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pushedDown
condition|)
block|{
return|return;
block|}
block|}
comment|// leftTree != null
block|}
name|joinTree
operator|.
name|getFiltersForPushing
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|add
argument_list|(
name|joinCond
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|rightCondAl2
operator|.
name|size
argument_list|()
operator|!=
literal|0
condition|)
block|{
name|populateAliases
argument_list|(
name|leftCondAl1
argument_list|,
name|leftCondAl2
argument_list|,
name|leftCondn
argument_list|,
name|joinTree
argument_list|,
name|leftSrc
argument_list|)
expr_stmt|;
name|populateAliases
argument_list|(
name|rightCondAl1
argument_list|,
name|rightCondAl2
argument_list|,
name|rightCondn
argument_list|,
name|joinTree
argument_list|,
name|leftSrc
argument_list|)
expr_stmt|;
name|boolean
name|nullsafe
init|=
name|joinCond
operator|.
name|getToken
argument_list|()
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|EQUAL_NS
decl_stmt|;
name|joinTree
operator|.
name|getNullSafes
argument_list|()
operator|.
name|add
argument_list|(
name|nullsafe
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|leftCondAl2
operator|.
name|size
argument_list|()
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|rightCondAl2
operator|.
name|size
argument_list|()
operator|!=
literal|0
operator|)
operator|||
operator|(
operator|(
name|rightCondAl1
operator|.
name|size
argument_list|()
operator|==
literal|0
operator|)
operator|&&
operator|(
name|rightCondAl2
operator|.
name|size
argument_list|()
operator|==
literal|0
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|type
operator|.
name|equals
argument_list|(
name|JoinType
operator|.
name|RIGHTOUTER
argument_list|)
operator|||
name|type
operator|.
name|equals
argument_list|(
name|JoinType
operator|.
name|FULLOUTER
argument_list|)
condition|)
block|{
if|if
condition|(
name|conf
operator|.
name|getBoolVar
argument_list|(
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVEOUTERJOINSUPPORTSFILTERS
argument_list|)
condition|)
block|{
name|joinTree
operator|.
name|getFilters
argument_list|()
operator|.
name|get
argument_list|(
literal|1
argument_list|)
operator|.
name|add
argument_list|(
name|joinCond
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|LOG
operator|.
name|warn
argument_list|(
name|ErrorMsg
operator|.
name|OUTERJOIN_USES_FILTERS
argument_list|)
expr_stmt|;
name|joinTree
operator|.
name|getFiltersForPushing
argument_list|()
operator|.
name|get
argument_list|(
literal|1
argument_list|)
operator|.
name|add
argument_list|(
name|joinCond
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|joinTree
operator|.
name|getFiltersForPushing
argument_list|()
operator|.
name|get
argument_list|(
literal|1
argument_list|)
operator|.
name|add
argument_list|(
name|joinCond
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|rightCondAl1
operator|.
name|size
argument_list|()
operator|!=
literal|0
condition|)
block|{
name|populateAliases
argument_list|(
name|leftCondAl1
argument_list|,
name|leftCondAl2
argument_list|,
name|leftCondn
argument_list|,
name|joinTree
argument_list|,
name|leftSrc
argument_list|)
expr_stmt|;
name|populateAliases
argument_list|(
name|rightCondAl1
argument_list|,
name|rightCondAl2
argument_list|,
name|rightCondn
argument_list|,
name|joinTree
argument_list|,
name|leftSrc
argument_list|)
expr_stmt|;
name|boolean
name|nullsafe
init|=
name|joinCond
operator|.
name|getToken
argument_list|()
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|EQUAL_NS
decl_stmt|;
name|joinTree
operator|.
name|getNullSafes
argument_list|()
operator|.
name|add
argument_list|(
name|nullsafe
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|rightCondAl1
operator|.
name|size
argument_list|()
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|type
operator|.
name|equals
argument_list|(
name|JoinType
operator|.
name|LEFTOUTER
argument_list|)
operator|||
name|type
operator|.
name|equals
argument_list|(
name|JoinType
operator|.
name|FULLOUTER
argument_list|)
condition|)
block|{
if|if
condition|(
name|conf
operator|.
name|getBoolVar
argument_list|(
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVEOUTERJOINSUPPORTSFILTERS
argument_list|)
condition|)
block|{
name|joinTree
operator|.
name|getFilters
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|add
argument_list|(
name|joinCond
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|LOG
operator|.
name|warn
argument_list|(
name|ErrorMsg
operator|.
name|OUTERJOIN_USES_FILTERS
argument_list|)
expr_stmt|;
name|joinTree
operator|.
name|getFiltersForPushing
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|add
argument_list|(
name|joinCond
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|joinTree
operator|.
name|getFiltersForPushing
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|add
argument_list|(
name|joinCond
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|type
operator|.
name|equals
argument_list|(
name|JoinType
operator|.
name|RIGHTOUTER
argument_list|)
operator|||
name|type
operator|.
name|equals
argument_list|(
name|JoinType
operator|.
name|FULLOUTER
argument_list|)
condition|)
block|{
if|if
condition|(
name|conf
operator|.
name|getBoolVar
argument_list|(
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVEOUTERJOINSUPPORTSFILTERS
argument_list|)
condition|)
block|{
name|joinTree
operator|.
name|getFilters
argument_list|()
operator|.
name|get
argument_list|(
literal|1
argument_list|)
operator|.
name|add
argument_list|(
name|joinCond
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|LOG
operator|.
name|warn
argument_list|(
name|ErrorMsg
operator|.
name|OUTERJOIN_USES_FILTERS
argument_list|)
expr_stmt|;
name|joinTree
operator|.
name|getFiltersForPushing
argument_list|()
operator|.
name|get
argument_list|(
literal|1
argument_list|)
operator|.
name|add
argument_list|(
name|joinCond
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|joinTree
operator|.
name|getFiltersForPushing
argument_list|()
operator|.
name|get
argument_list|(
literal|1
argument_list|)
operator|.
name|add
argument_list|(
name|joinCond
argument_list|)
expr_stmt|;
block|}
block|}
block|}
specifier|private
name|void
name|parseJoinCondition
parameter_list|(
name|QBJoinTree
name|joinTree
parameter_list|,
name|ASTNode
name|joinCond
parameter_list|,
name|List
argument_list|<
name|String
argument_list|>
name|leftSrc
parameter_list|)
throws|throws
name|SemanticException
block|{
if|if
condition|(
name|joinCond
operator|==
literal|null
condition|)
block|{
return|return;
block|}
name|JoinCond
name|cond
init|=
name|joinTree
operator|.
name|getJoinCond
argument_list|()
index|[
literal|0
index|]
decl_stmt|;
name|JoinType
name|type
init|=
name|cond
operator|.
name|getJoinType
argument_list|()
decl_stmt|;
name|parseJoinCondition
argument_list|(
name|joinTree
argument_list|,
name|joinCond
argument_list|,
name|leftSrc
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|ArrayList
argument_list|<
name|ASTNode
argument_list|>
argument_list|>
name|filters
init|=
name|joinTree
operator|.
name|getFilters
argument_list|()
decl_stmt|;
if|if
condition|(
name|type
operator|==
name|JoinType
operator|.
name|LEFTOUTER
operator|||
name|type
operator|==
name|JoinType
operator|.
name|FULLOUTER
condition|)
block|{
name|joinTree
operator|.
name|addFilterMapping
argument_list|(
name|cond
operator|.
name|getLeft
argument_list|()
argument_list|,
name|cond
operator|.
name|getRight
argument_list|()
argument_list|,
name|filters
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|type
operator|==
name|JoinType
operator|.
name|RIGHTOUTER
operator|||
name|type
operator|==
name|JoinType
operator|.
name|FULLOUTER
condition|)
block|{
name|joinTree
operator|.
name|addFilterMapping
argument_list|(
name|cond
operator|.
name|getRight
argument_list|()
argument_list|,
name|cond
operator|.
name|getLeft
argument_list|()
argument_list|,
name|filters
operator|.
name|get
argument_list|(
literal|1
argument_list|)
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Parse the join condition. If the condition is a join condition, throw an    * error if it is not an equality. Otherwise, break it into left and right    * expressions and store in the join tree. If the condition is a join filter,    * add it to the filter list of join tree. The join condition can contains    * conditions on both the left and tree trees and filters on either.    * Currently, we only support equi-joins, so we throw an error if the    * condition involves both subtrees and is not a equality. Also, we only    * support AND i.e ORs are not supported currently as their semantics are not    * very clear, may lead to data explosion and there is no usecase.    *    * @param joinTree    *          jointree to be populated    * @param joinCond    *          join condition    * @param leftSrc    *          left sources    * @throws SemanticException    */
specifier|private
name|void
name|parseJoinCondition
parameter_list|(
name|QBJoinTree
name|joinTree
parameter_list|,
name|ASTNode
name|joinCond
parameter_list|,
name|List
argument_list|<
name|String
argument_list|>
name|leftSrc
parameter_list|,
name|JoinType
name|type
parameter_list|)
throws|throws
name|SemanticException
block|{
if|if
condition|(
name|joinCond
operator|==
literal|null
condition|)
block|{
return|return;
block|}
switch|switch
condition|(
name|joinCond
operator|.
name|getToken
argument_list|()
operator|.
name|getType
argument_list|()
condition|)
block|{
case|case
name|HiveParser
operator|.
name|KW_OR
case|:
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|INVALID_JOIN_CONDITION_3
operator|.
name|getMsg
argument_list|(
name|joinCond
argument_list|)
argument_list|)
throw|;
case|case
name|HiveParser
operator|.
name|KW_AND
case|:
name|parseJoinCondition
argument_list|(
name|joinTree
argument_list|,
operator|(
name|ASTNode
operator|)
name|joinCond
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
argument_list|,
name|leftSrc
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|parseJoinCondition
argument_list|(
name|joinTree
argument_list|,
operator|(
name|ASTNode
operator|)
name|joinCond
operator|.
name|getChild
argument_list|(
literal|1
argument_list|)
argument_list|,
name|leftSrc
argument_list|,
name|type
argument_list|)
expr_stmt|;
break|break;
case|case
name|HiveParser
operator|.
name|EQUAL_NS
case|:
case|case
name|HiveParser
operator|.
name|EQUAL
case|:
name|ASTNode
name|leftCondn
init|=
operator|(
name|ASTNode
operator|)
name|joinCond
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|ArrayList
argument_list|<
name|String
argument_list|>
name|leftCondAl1
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
name|ArrayList
argument_list|<
name|String
argument_list|>
name|leftCondAl2
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
name|parseJoinCondPopulateAlias
argument_list|(
name|joinTree
argument_list|,
name|leftCondn
argument_list|,
name|leftCondAl1
argument_list|,
name|leftCondAl2
argument_list|,
literal|null
argument_list|)
expr_stmt|;
name|ASTNode
name|rightCondn
init|=
operator|(
name|ASTNode
operator|)
name|joinCond
operator|.
name|getChild
argument_list|(
literal|1
argument_list|)
decl_stmt|;
name|ArrayList
argument_list|<
name|String
argument_list|>
name|rightCondAl1
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
name|ArrayList
argument_list|<
name|String
argument_list|>
name|rightCondAl2
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
name|parseJoinCondPopulateAlias
argument_list|(
name|joinTree
argument_list|,
name|rightCondn
argument_list|,
name|rightCondAl1
argument_list|,
name|rightCondAl2
argument_list|,
literal|null
argument_list|)
expr_stmt|;
comment|// is it a filter or a join condition
comment|// if it is filter see if it can be pushed above the join
comment|// filter cannot be pushed if
comment|// * join is full outer or
comment|// * join is left outer and filter is on left alias or
comment|// * join is right outer and filter is on right alias
if|if
condition|(
operator|(
operator|(
name|leftCondAl1
operator|.
name|size
argument_list|()
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|leftCondAl2
operator|.
name|size
argument_list|()
operator|!=
literal|0
operator|)
operator|)
operator|||
operator|(
operator|(
name|rightCondAl1
operator|.
name|size
argument_list|()
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|rightCondAl2
operator|.
name|size
argument_list|()
operator|!=
literal|0
operator|)
operator|)
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|INVALID_JOIN_CONDITION_1
operator|.
name|getMsg
argument_list|(
name|joinCond
argument_list|)
argument_list|)
throw|;
block|}
name|applyEqualityPredicateToQBJoinTree
argument_list|(
name|joinTree
argument_list|,
name|type
argument_list|,
name|leftSrc
argument_list|,
name|joinCond
argument_list|,
name|leftCondn
argument_list|,
name|rightCondn
argument_list|,
name|leftCondAl1
argument_list|,
name|leftCondAl2
argument_list|,
name|rightCondAl1
argument_list|,
name|rightCondAl2
argument_list|)
expr_stmt|;
break|break;
default|default:
name|boolean
name|isFunction
init|=
operator|(
name|joinCond
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_FUNCTION
operator|)
decl_stmt|;
comment|// Create all children
name|int
name|childrenBegin
init|=
operator|(
name|isFunction
condition|?
literal|1
else|:
literal|0
operator|)
decl_stmt|;
name|ArrayList
argument_list|<
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|>
name|leftAlias
init|=
operator|new
name|ArrayList
argument_list|<
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|>
argument_list|(
name|joinCond
operator|.
name|getChildCount
argument_list|()
operator|-
name|childrenBegin
argument_list|)
decl_stmt|;
name|ArrayList
argument_list|<
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|>
name|rightAlias
init|=
operator|new
name|ArrayList
argument_list|<
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|>
argument_list|(
name|joinCond
operator|.
name|getChildCount
argument_list|()
operator|-
name|childrenBegin
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|ci
init|=
literal|0
init|;
name|ci
operator|<
name|joinCond
operator|.
name|getChildCount
argument_list|()
operator|-
name|childrenBegin
condition|;
name|ci
operator|++
control|)
block|{
name|ArrayList
argument_list|<
name|String
argument_list|>
name|left
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
name|ArrayList
argument_list|<
name|String
argument_list|>
name|right
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
name|leftAlias
operator|.
name|add
argument_list|(
name|left
argument_list|)
expr_stmt|;
name|rightAlias
operator|.
name|add
argument_list|(
name|right
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|int
name|ci
init|=
name|childrenBegin
init|;
name|ci
operator|<
name|joinCond
operator|.
name|getChildCount
argument_list|()
condition|;
name|ci
operator|++
control|)
block|{
name|parseJoinCondPopulateAlias
argument_list|(
name|joinTree
argument_list|,
operator|(
name|ASTNode
operator|)
name|joinCond
operator|.
name|getChild
argument_list|(
name|ci
argument_list|)
argument_list|,
name|leftAlias
operator|.
name|get
argument_list|(
name|ci
operator|-
name|childrenBegin
argument_list|)
argument_list|,
name|rightAlias
operator|.
name|get
argument_list|(
name|ci
operator|-
name|childrenBegin
argument_list|)
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
name|boolean
name|leftAliasNull
init|=
literal|true
decl_stmt|;
for|for
control|(
name|ArrayList
argument_list|<
name|String
argument_list|>
name|left
range|:
name|leftAlias
control|)
block|{
if|if
condition|(
name|left
operator|.
name|size
argument_list|()
operator|!=
literal|0
condition|)
block|{
name|leftAliasNull
operator|=
literal|false
expr_stmt|;
break|break;
block|}
block|}
name|boolean
name|rightAliasNull
init|=
literal|true
decl_stmt|;
for|for
control|(
name|ArrayList
argument_list|<
name|String
argument_list|>
name|right
range|:
name|rightAlias
control|)
block|{
if|if
condition|(
name|right
operator|.
name|size
argument_list|()
operator|!=
literal|0
condition|)
block|{
name|rightAliasNull
operator|=
literal|false
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|leftAliasNull
operator|&&
operator|!
name|rightAliasNull
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|INVALID_JOIN_CONDITION_1
operator|.
name|getMsg
argument_list|(
name|joinCond
argument_list|)
argument_list|)
throw|;
block|}
if|if
condition|(
operator|!
name|leftAliasNull
condition|)
block|{
if|if
condition|(
name|type
operator|.
name|equals
argument_list|(
name|JoinType
operator|.
name|LEFTOUTER
argument_list|)
operator|||
name|type
operator|.
name|equals
argument_list|(
name|JoinType
operator|.
name|FULLOUTER
argument_list|)
condition|)
block|{
if|if
condition|(
name|conf
operator|.
name|getBoolVar
argument_list|(
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVEOUTERJOINSUPPORTSFILTERS
argument_list|)
condition|)
block|{
name|joinTree
operator|.
name|getFilters
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|add
argument_list|(
name|joinCond
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|LOG
operator|.
name|warn
argument_list|(
name|ErrorMsg
operator|.
name|OUTERJOIN_USES_FILTERS
argument_list|)
expr_stmt|;
name|joinTree
operator|.
name|getFiltersForPushing
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|add
argument_list|(
name|joinCond
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|joinTree
operator|.
name|getFiltersForPushing
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|add
argument_list|(
name|joinCond
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|type
operator|.
name|equals
argument_list|(
name|JoinType
operator|.
name|RIGHTOUTER
argument_list|)
operator|||
name|type
operator|.
name|equals
argument_list|(
name|JoinType
operator|.
name|FULLOUTER
argument_list|)
condition|)
block|{
if|if
condition|(
name|conf
operator|.
name|getBoolVar
argument_list|(
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVEOUTERJOINSUPPORTSFILTERS
argument_list|)
condition|)
block|{
name|joinTree
operator|.
name|getFilters
argument_list|()
operator|.
name|get
argument_list|(
literal|1
argument_list|)
operator|.
name|add
argument_list|(
name|joinCond
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|LOG
operator|.
name|warn
argument_list|(
name|ErrorMsg
operator|.
name|OUTERJOIN_USES_FILTERS
argument_list|)
expr_stmt|;
name|joinTree
operator|.
name|getFiltersForPushing
argument_list|()
operator|.
name|get
argument_list|(
literal|1
argument_list|)
operator|.
name|add
argument_list|(
name|joinCond
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|joinTree
operator|.
name|getFiltersForPushing
argument_list|()
operator|.
name|get
argument_list|(
literal|1
argument_list|)
operator|.
name|add
argument_list|(
name|joinCond
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
block|}
block|}
specifier|private
name|void
name|extractJoinCondsFromWhereClause
parameter_list|(
name|QBJoinTree
name|joinTree
parameter_list|,
name|QB
name|qb
parameter_list|,
name|String
name|dest
parameter_list|,
name|ASTNode
name|predicate
parameter_list|)
throws|throws
name|SemanticException
block|{
switch|switch
condition|(
name|predicate
operator|.
name|getType
argument_list|()
condition|)
block|{
case|case
name|HiveParser
operator|.
name|KW_AND
case|:
name|extractJoinCondsFromWhereClause
argument_list|(
name|joinTree
argument_list|,
name|qb
argument_list|,
name|dest
argument_list|,
operator|(
name|ASTNode
operator|)
name|predicate
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|extractJoinCondsFromWhereClause
argument_list|(
name|joinTree
argument_list|,
name|qb
argument_list|,
name|dest
argument_list|,
operator|(
name|ASTNode
operator|)
name|predicate
operator|.
name|getChild
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|HiveParser
operator|.
name|EQUAL_NS
case|:
case|case
name|HiveParser
operator|.
name|EQUAL
case|:
name|ASTNode
name|leftCondn
init|=
operator|(
name|ASTNode
operator|)
name|predicate
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|ArrayList
argument_list|<
name|String
argument_list|>
name|leftCondAl1
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
name|ArrayList
argument_list|<
name|String
argument_list|>
name|leftCondAl2
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
try|try
block|{
name|parseJoinCondPopulateAlias
argument_list|(
name|joinTree
argument_list|,
name|leftCondn
argument_list|,
name|leftCondAl1
argument_list|,
name|leftCondAl2
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|SemanticException
name|se
parameter_list|)
block|{
comment|// suppress here; if it is a real issue will get caught in where clause handling.
return|return;
block|}
name|ASTNode
name|rightCondn
init|=
operator|(
name|ASTNode
operator|)
name|predicate
operator|.
name|getChild
argument_list|(
literal|1
argument_list|)
decl_stmt|;
name|ArrayList
argument_list|<
name|String
argument_list|>
name|rightCondAl1
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
name|ArrayList
argument_list|<
name|String
argument_list|>
name|rightCondAl2
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
try|try
block|{
name|parseJoinCondPopulateAlias
argument_list|(
name|joinTree
argument_list|,
name|rightCondn
argument_list|,
name|rightCondAl1
argument_list|,
name|rightCondAl2
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|SemanticException
name|se
parameter_list|)
block|{
comment|// suppress here; if it is a real issue will get caught in where clause handling.
return|return;
block|}
if|if
condition|(
operator|(
operator|(
name|leftCondAl1
operator|.
name|size
argument_list|()
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|leftCondAl2
operator|.
name|size
argument_list|()
operator|!=
literal|0
operator|)
operator|)
operator|||
operator|(
operator|(
name|rightCondAl1
operator|.
name|size
argument_list|()
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|rightCondAl2
operator|.
name|size
argument_list|()
operator|!=
literal|0
operator|)
operator|)
condition|)
block|{
comment|// this is not a join condition.
return|return;
block|}
if|if
condition|(
operator|(
operator|(
name|leftCondAl1
operator|.
name|size
argument_list|()
operator|==
literal|0
operator|)
operator|&&
operator|(
name|leftCondAl2
operator|.
name|size
argument_list|()
operator|==
literal|0
operator|)
operator|)
operator|||
operator|(
operator|(
name|rightCondAl1
operator|.
name|size
argument_list|()
operator|==
literal|0
operator|)
operator|&&
operator|(
name|rightCondAl2
operator|.
name|size
argument_list|()
operator|==
literal|0
operator|)
operator|)
condition|)
block|{
comment|// this is not a join condition. Will get handled by predicate pushdown.
return|return;
block|}
name|List
argument_list|<
name|String
argument_list|>
name|leftSrc
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
name|JoinCond
name|cond
init|=
name|joinTree
operator|.
name|getJoinCond
argument_list|()
index|[
literal|0
index|]
decl_stmt|;
name|JoinType
name|type
init|=
name|cond
operator|.
name|getJoinType
argument_list|()
decl_stmt|;
name|applyEqualityPredicateToQBJoinTree
argument_list|(
name|joinTree
argument_list|,
name|type
argument_list|,
name|leftSrc
argument_list|,
name|predicate
argument_list|,
name|leftCondn
argument_list|,
name|rightCondn
argument_list|,
name|leftCondAl1
argument_list|,
name|leftCondAl2
argument_list|,
name|rightCondAl1
argument_list|,
name|rightCondAl2
argument_list|)
expr_stmt|;
if|if
condition|(
name|leftSrc
operator|.
name|size
argument_list|()
operator|==
literal|1
condition|)
block|{
name|joinTree
operator|.
name|setLeftAlias
argument_list|(
name|leftSrc
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// todo: hold onto this predicate, so that we don't add it to the Filter Operator.
break|break;
default|default:
return|return;
block|}
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"nls"
argument_list|)
specifier|public
parameter_list|<
name|T
extends|extends
name|OperatorDesc
parameter_list|>
name|Operator
argument_list|<
name|T
argument_list|>
name|putOpInsertMap
parameter_list|(
name|Operator
argument_list|<
name|T
argument_list|>
name|op
parameter_list|,
name|RowResolver
name|rr
parameter_list|)
block|{
name|OpParseContext
name|ctx
init|=
operator|new
name|OpParseContext
argument_list|(
name|rr
argument_list|)
decl_stmt|;
name|opParseCtx
operator|.
name|put
argument_list|(
name|op
argument_list|,
name|ctx
argument_list|)
expr_stmt|;
name|op
operator|.
name|augmentPlan
argument_list|()
expr_stmt|;
return|return
name|op
return|;
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"nls"
argument_list|)
specifier|private
name|Operator
name|genHavingPlan
parameter_list|(
name|String
name|dest
parameter_list|,
name|QB
name|qb
parameter_list|,
name|Operator
name|input
parameter_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|Operator
argument_list|>
name|aliasToOpInfo
parameter_list|)
throws|throws
name|SemanticException
block|{
name|ASTNode
name|havingExpr
init|=
name|qb
operator|.
name|getParseInfo
argument_list|()
operator|.
name|getHavingForClause
argument_list|(
name|dest
argument_list|)
decl_stmt|;
name|OpParseContext
name|inputCtx
init|=
name|opParseCtx
operator|.
name|get
argument_list|(
name|input
argument_list|)
decl_stmt|;
name|RowResolver
name|inputRR
init|=
name|inputCtx
operator|.
name|getRowResolver
argument_list|()
decl_stmt|;
name|Map
argument_list|<
name|ASTNode
argument_list|,
name|String
argument_list|>
name|exprToColumnAlias
init|=
name|qb
operator|.
name|getParseInfo
argument_list|()
operator|.
name|getAllExprToColumnAlias
argument_list|()
decl_stmt|;
for|for
control|(
name|ASTNode
name|astNode
range|:
name|exprToColumnAlias
operator|.
name|keySet
argument_list|()
control|)
block|{
if|if
condition|(
name|inputRR
operator|.
name|getExpression
argument_list|(
name|astNode
argument_list|)
operator|!=
literal|null
condition|)
block|{
name|inputRR
operator|.
name|put
argument_list|(
literal|""
argument_list|,
name|exprToColumnAlias
operator|.
name|get
argument_list|(
name|astNode
argument_list|)
argument_list|,
name|inputRR
operator|.
name|getExpression
argument_list|(
name|astNode
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|ASTNode
name|condn
init|=
operator|(
name|ASTNode
operator|)
name|havingExpr
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
decl_stmt|;
comment|/*      * Now a having clause can contain a SubQuery predicate;      * so we invoke genFilterPlan to handle SubQuery algebraic transformation,      * just as is done for SubQuery predicates appearing in the Where Clause.      */
name|Operator
name|output
init|=
name|genFilterPlan
argument_list|(
name|condn
argument_list|,
name|qb
argument_list|,
name|input
argument_list|,
name|aliasToOpInfo
argument_list|,
literal|true
argument_list|)
decl_stmt|;
name|output
operator|=
name|putOpInsertMap
argument_list|(
name|output
argument_list|,
name|inputRR
argument_list|)
expr_stmt|;
return|return
name|output
return|;
block|}
specifier|private
name|Operator
name|genPlanForSubQueryPredicate
parameter_list|(
name|QB
name|qbSQ
parameter_list|,
name|ISubQueryJoinInfo
name|subQueryPredicate
parameter_list|)
throws|throws
name|SemanticException
block|{
name|qbSQ
operator|.
name|setSubQueryDef
argument_list|(
name|subQueryPredicate
operator|.
name|getSubQuery
argument_list|()
argument_list|)
expr_stmt|;
name|Phase1Ctx
name|ctx_1
init|=
name|initPhase1Ctx
argument_list|()
decl_stmt|;
name|doPhase1
argument_list|(
name|subQueryPredicate
operator|.
name|getSubQueryAST
argument_list|()
argument_list|,
name|qbSQ
argument_list|,
name|ctx_1
argument_list|)
expr_stmt|;
name|getMetaData
argument_list|(
name|qbSQ
argument_list|)
expr_stmt|;
name|Operator
name|op
init|=
name|genPlan
argument_list|(
name|qbSQ
argument_list|)
decl_stmt|;
return|return
name|op
return|;
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"nls"
argument_list|)
specifier|private
name|Operator
name|genFilterPlan
parameter_list|(
name|ASTNode
name|searchCond
parameter_list|,
name|QB
name|qb
parameter_list|,
name|Operator
name|input
parameter_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|Operator
argument_list|>
name|aliasToOpInfo
parameter_list|,
name|boolean
name|forHavingClause
parameter_list|)
throws|throws
name|SemanticException
block|{
name|OpParseContext
name|inputCtx
init|=
name|opParseCtx
operator|.
name|get
argument_list|(
name|input
argument_list|)
decl_stmt|;
name|RowResolver
name|inputRR
init|=
name|inputCtx
operator|.
name|getRowResolver
argument_list|()
decl_stmt|;
comment|/*      * Handling of SubQuery Expressions:      * if "Where clause contains no SubQuery expressions" then      *   -->[true] ===CONTINUE_FILTER_PROCESSING===      * else      *   -->[false] "extract SubQuery expressions\n from Where clause"      *   if "this is a nested SubQuery or \nthere are more than 1 SubQuery expressions" then      *     -->[yes] "throw Unsupported Error"      *   else      *     --> "Rewrite Search condition to \nremove SubQuery predicate"      *      --> "build QBSubQuery"      *        --> "extract correlated predicates \nfrom Where Clause"      *        --> "add correlated Items to \nSelect List and Group By"      *        --> "construct Join Predicate \nfrom correlation predicates"      *     --> "Generate Plan for\n modified SubQuery"      *     --> "Build the Join Condition\n for Parent Query to SubQuery join"      *     --> "Build the QBJoinTree from the Join condition"      *     --> "Update Parent Query Filter\n with any Post Join conditions"      *     --> ===CONTINUE_FILTER_PROCESSING===      *   endif      * endif      *       * Support for Sub Queries in Having Clause:      * - By and large this works the same way as SubQueries in the Where Clause.      * - The one addum is the handling of aggregation expressions from the Outer Query      *   appearing in correlation clauses.       *   - So such correlating predicates are allowed:      *        min(OuterQuert.x) = SubQuery.y      *   - this requires special handling when converting to joins. See QBSubQuery.rewrite      *     method method for detailed comments.       */
name|List
argument_list|<
name|ASTNode
argument_list|>
name|subQueriesInOriginalTree
init|=
name|SubQueryUtils
operator|.
name|findSubQueries
argument_list|(
name|searchCond
argument_list|)
decl_stmt|;
if|if
condition|(
name|subQueriesInOriginalTree
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
comment|/*        * Restriction.9.m :: disallow nested SubQuery expressions.        */
if|if
condition|(
name|qb
operator|.
name|getSubQueryPredicateDef
argument_list|()
operator|!=
literal|null
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|UNSUPPORTED_SUBQUERY_EXPRESSION
operator|.
name|getMsg
argument_list|(
name|subQueriesInOriginalTree
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|,
literal|"Nested SubQuery expressions are not supported."
argument_list|)
argument_list|)
throw|;
block|}
comment|/*        * Restriction.8.m :: We allow only 1 SubQuery expression per Query.        */
if|if
condition|(
name|subQueriesInOriginalTree
operator|.
name|size
argument_list|()
operator|>
literal|1
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|UNSUPPORTED_SUBQUERY_EXPRESSION
operator|.
name|getMsg
argument_list|(
name|subQueriesInOriginalTree
operator|.
name|get
argument_list|(
literal|1
argument_list|)
argument_list|,
literal|"Only 1 SubQuery expression is supported."
argument_list|)
argument_list|)
throw|;
block|}
comment|/*        * Clone the Search AST; apply all rewrites on the clone.        */
name|ASTNode
name|clonedSearchCond
init|=
operator|(
name|ASTNode
operator|)
name|ParseDriver
operator|.
name|adaptor
operator|.
name|dupTree
argument_list|(
name|searchCond
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|ASTNode
argument_list|>
name|subQueries
init|=
name|SubQueryUtils
operator|.
name|findSubQueries
argument_list|(
name|clonedSearchCond
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|subQueries
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|ASTNode
name|subQueryAST
init|=
name|subQueries
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|ASTNode
name|originalSubQueryAST
init|=
name|subQueriesInOriginalTree
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|int
name|sqIdx
init|=
name|qb
operator|.
name|incrNumSubQueryPredicates
argument_list|()
decl_stmt|;
name|clonedSearchCond
operator|=
name|SubQueryUtils
operator|.
name|rewriteParentQueryWhere
argument_list|(
name|clonedSearchCond
argument_list|,
name|subQueryAST
argument_list|)
expr_stmt|;
name|QBSubQuery
name|subQuery
init|=
name|SubQueryUtils
operator|.
name|buildSubQuery
argument_list|(
name|qb
operator|.
name|getId
argument_list|()
argument_list|,
name|sqIdx
argument_list|,
name|subQueryAST
argument_list|,
name|originalSubQueryAST
argument_list|,
name|ctx
argument_list|)
decl_stmt|;
name|String
name|havingInputAlias
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|forHavingClause
condition|)
block|{
name|havingInputAlias
operator|=
literal|"gby_sq"
operator|+
name|sqIdx
expr_stmt|;
name|aliasToOpInfo
operator|.
name|put
argument_list|(
name|havingInputAlias
argument_list|,
name|input
argument_list|)
expr_stmt|;
block|}
name|subQuery
operator|.
name|validateAndRewriteAST
argument_list|(
name|inputRR
argument_list|,
name|forHavingClause
argument_list|,
name|havingInputAlias
argument_list|,
name|aliasToOpInfo
operator|.
name|keySet
argument_list|()
argument_list|)
expr_stmt|;
name|QB
name|qbSQ
init|=
operator|new
name|QB
argument_list|(
name|subQuery
operator|.
name|getOuterQueryId
argument_list|()
argument_list|,
name|subQuery
operator|.
name|getAlias
argument_list|()
argument_list|,
literal|true
argument_list|)
decl_stmt|;
name|Operator
name|sqPlanTopOp
init|=
name|genPlanForSubQueryPredicate
argument_list|(
name|qbSQ
argument_list|,
name|subQuery
argument_list|)
decl_stmt|;
name|aliasToOpInfo
operator|.
name|put
argument_list|(
name|subQuery
operator|.
name|getAlias
argument_list|()
argument_list|,
name|sqPlanTopOp
argument_list|)
expr_stmt|;
name|RowResolver
name|sqRR
init|=
name|opParseCtx
operator|.
name|get
argument_list|(
name|sqPlanTopOp
argument_list|)
operator|.
name|getRowResolver
argument_list|()
decl_stmt|;
comment|/*          * Check.5.h :: For In and Not In the SubQuery must implicitly or          * explicitly only contain one select item.          */
if|if
condition|(
name|subQuery
operator|.
name|getOperator
argument_list|()
operator|.
name|getType
argument_list|()
operator|!=
name|SubQueryType
operator|.
name|EXISTS
operator|&&
name|subQuery
operator|.
name|getOperator
argument_list|()
operator|.
name|getType
argument_list|()
operator|!=
name|SubQueryType
operator|.
name|NOT_EXISTS
operator|&&
name|sqRR
operator|.
name|getColumnInfos
argument_list|()
operator|.
name|size
argument_list|()
operator|-
name|subQuery
operator|.
name|getNumOfCorrelationExprsAddedToSQSelect
argument_list|()
operator|>
literal|1
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|INVALID_SUBQUERY_EXPRESSION
operator|.
name|getMsg
argument_list|(
name|subQueryAST
argument_list|,
literal|"SubQuery can contain only 1 item in Select List."
argument_list|)
argument_list|)
throw|;
block|}
comment|/*          * If this is a Not In SubQuery Predicate then Join in the Null Check SubQuery.          * See QBSubQuery.NotInCheck for details on why and how this is constructed.          */
if|if
condition|(
name|subQuery
operator|.
name|getNotInCheck
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|QBSubQuery
operator|.
name|NotInCheck
name|notInCheck
init|=
name|subQuery
operator|.
name|getNotInCheck
argument_list|()
decl_stmt|;
name|notInCheck
operator|.
name|setSQRR
argument_list|(
name|sqRR
argument_list|)
expr_stmt|;
name|QB
name|qbSQ_nic
init|=
operator|new
name|QB
argument_list|(
name|subQuery
operator|.
name|getOuterQueryId
argument_list|()
argument_list|,
name|notInCheck
operator|.
name|getAlias
argument_list|()
argument_list|,
literal|true
argument_list|)
decl_stmt|;
name|Operator
name|sqnicPlanTopOp
init|=
name|genPlanForSubQueryPredicate
argument_list|(
name|qbSQ_nic
argument_list|,
name|notInCheck
argument_list|)
decl_stmt|;
name|aliasToOpInfo
operator|.
name|put
argument_list|(
name|notInCheck
operator|.
name|getAlias
argument_list|()
argument_list|,
name|sqnicPlanTopOp
argument_list|)
expr_stmt|;
name|QBJoinTree
name|joinTree_nic
init|=
name|genSQJoinTree
argument_list|(
name|qb
argument_list|,
name|notInCheck
argument_list|,
name|input
argument_list|,
name|aliasToOpInfo
argument_list|)
decl_stmt|;
name|pushJoinFilters
argument_list|(
name|qb
argument_list|,
name|joinTree_nic
argument_list|,
name|aliasToOpInfo
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|input
operator|=
name|genJoinOperator
argument_list|(
name|qbSQ_nic
argument_list|,
name|joinTree_nic
argument_list|,
name|aliasToOpInfo
argument_list|,
name|input
argument_list|)
expr_stmt|;
name|inputRR
operator|=
name|opParseCtx
operator|.
name|get
argument_list|(
name|input
argument_list|)
operator|.
name|getRowResolver
argument_list|()
expr_stmt|;
if|if
condition|(
name|forHavingClause
condition|)
block|{
name|aliasToOpInfo
operator|.
name|put
argument_list|(
name|havingInputAlias
argument_list|,
name|input
argument_list|)
expr_stmt|;
block|}
block|}
comment|/*          * Gen Join between outer Operator and SQ op          */
name|subQuery
operator|.
name|buildJoinCondition
argument_list|(
name|inputRR
argument_list|,
name|sqRR
argument_list|,
name|forHavingClause
argument_list|,
name|havingInputAlias
argument_list|)
expr_stmt|;
name|QBJoinTree
name|joinTree
init|=
name|genSQJoinTree
argument_list|(
name|qb
argument_list|,
name|subQuery
argument_list|,
name|input
argument_list|,
name|aliasToOpInfo
argument_list|)
decl_stmt|;
comment|/*          * push filters only for this QBJoinTree. Child QBJoinTrees have already been handled.          */
name|pushJoinFilters
argument_list|(
name|qb
argument_list|,
name|joinTree
argument_list|,
name|aliasToOpInfo
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|input
operator|=
name|genJoinOperator
argument_list|(
name|qbSQ
argument_list|,
name|joinTree
argument_list|,
name|aliasToOpInfo
argument_list|,
name|input
argument_list|)
expr_stmt|;
name|searchCond
operator|=
name|subQuery
operator|.
name|updateOuterQueryFilter
argument_list|(
name|clonedSearchCond
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|genFilterPlan
argument_list|(
name|qb
argument_list|,
name|searchCond
argument_list|,
name|input
argument_list|)
return|;
block|}
comment|/**    * create a filter plan. The condition and the inputs are specified.    *    * @param qb    *          current query block    * @param condn    *          The condition to be resolved    * @param input    *          the input operator    */
annotation|@
name|SuppressWarnings
argument_list|(
literal|"nls"
argument_list|)
specifier|private
name|Operator
name|genFilterPlan
parameter_list|(
name|QB
name|qb
parameter_list|,
name|ASTNode
name|condn
parameter_list|,
name|Operator
name|input
parameter_list|)
throws|throws
name|SemanticException
block|{
name|OpParseContext
name|inputCtx
init|=
name|opParseCtx
operator|.
name|get
argument_list|(
name|input
argument_list|)
decl_stmt|;
name|RowResolver
name|inputRR
init|=
name|inputCtx
operator|.
name|getRowResolver
argument_list|()
decl_stmt|;
name|Operator
name|output
init|=
name|putOpInsertMap
argument_list|(
name|OperatorFactory
operator|.
name|getAndMakeChild
argument_list|(
operator|new
name|FilterDesc
argument_list|(
name|genExprNodeDesc
argument_list|(
name|condn
argument_list|,
name|inputRR
argument_list|)
argument_list|,
literal|false
argument_list|)
argument_list|,
operator|new
name|RowSchema
argument_list|(
name|inputRR
operator|.
name|getColumnInfos
argument_list|()
argument_list|)
argument_list|,
name|input
argument_list|)
argument_list|,
name|inputRR
argument_list|)
decl_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Created Filter Plan for "
operator|+
name|qb
operator|.
name|getId
argument_list|()
operator|+
literal|" row schema: "
operator|+
name|inputRR
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|output
return|;
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"nls"
argument_list|)
specifier|private
name|Integer
name|genColListRegex
parameter_list|(
name|String
name|colRegex
parameter_list|,
name|String
name|tabAlias
parameter_list|,
name|ASTNode
name|sel
parameter_list|,
name|ArrayList
argument_list|<
name|ExprNodeDesc
argument_list|>
name|col_list
parameter_list|,
name|RowResolver
name|input
parameter_list|,
name|Integer
name|pos
parameter_list|,
name|RowResolver
name|output
parameter_list|,
name|List
argument_list|<
name|String
argument_list|>
name|aliases
parameter_list|,
name|boolean
name|subQuery
parameter_list|)
throws|throws
name|SemanticException
block|{
comment|// The table alias should exist
if|if
condition|(
name|tabAlias
operator|!=
literal|null
operator|&&
operator|!
name|input
operator|.
name|hasTableAlias
argument_list|(
name|tabAlias
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|INVALID_TABLE_ALIAS
operator|.
name|getMsg
argument_list|(
name|sel
argument_list|)
argument_list|)
throw|;
block|}
comment|// TODO: Have to put in the support for AS clause
name|Pattern
name|regex
init|=
literal|null
decl_stmt|;
try|try
block|{
name|regex
operator|=
name|Pattern
operator|.
name|compile
argument_list|(
name|colRegex
argument_list|,
name|Pattern
operator|.
name|CASE_INSENSITIVE
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|PatternSyntaxException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|INVALID_COLUMN
operator|.
name|getMsg
argument_list|(
name|sel
argument_list|,
name|e
operator|.
name|getMessage
argument_list|()
argument_list|)
argument_list|)
throw|;
block|}
name|StringBuilder
name|replacementText
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|int
name|matched
init|=
literal|0
decl_stmt|;
comment|// add empty string to the list of aliases. Some operators (ex. GroupBy) add
comment|// ColumnInfos for table alias "".
if|if
condition|(
operator|!
name|aliases
operator|.
name|contains
argument_list|(
literal|""
argument_list|)
condition|)
block|{
name|aliases
operator|.
name|add
argument_list|(
literal|""
argument_list|)
expr_stmt|;
block|}
comment|/*      * track the input ColumnInfos that are added to the output.      * if a columnInfo has multiple mappings; then add the column only once,      * but carry the mappings forward.      */
name|Map
argument_list|<
name|ColumnInfo
argument_list|,
name|ColumnInfo
argument_list|>
name|inputColsProcessed
init|=
operator|new
name|HashMap
argument_list|<
name|ColumnInfo
argument_list|,
name|ColumnInfo
argument_list|>
argument_list|()
decl_stmt|;
comment|// For expr "*", aliases should be iterated in the order they are specified
comment|// in the query.
for|for
control|(
name|String
name|alias
range|:
name|aliases
control|)
block|{
name|HashMap
argument_list|<
name|String
argument_list|,
name|ColumnInfo
argument_list|>
name|fMap
init|=
name|input
operator|.
name|getFieldMap
argument_list|(
name|alias
argument_list|)
decl_stmt|;
if|if
condition|(
name|fMap
operator|==
literal|null
condition|)
block|{
continue|continue;
block|}
comment|// For the tab.* case, add all the columns to the fieldList
comment|// from the input schema
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|ColumnInfo
argument_list|>
name|entry
range|:
name|fMap
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|ColumnInfo
name|colInfo
init|=
name|entry
operator|.
name|getValue
argument_list|()
decl_stmt|;
name|String
name|name
init|=
name|colInfo
operator|.
name|getInternalName
argument_list|()
decl_stmt|;
name|String
index|[]
name|tmp
init|=
name|input
operator|.
name|reverseLookup
argument_list|(
name|name
argument_list|)
decl_stmt|;
comment|// Skip the colinfos which are not for this particular alias
if|if
condition|(
name|tabAlias
operator|!=
literal|null
operator|&&
operator|!
name|tmp
index|[
literal|0
index|]
operator|.
name|equalsIgnoreCase
argument_list|(
name|tabAlias
argument_list|)
condition|)
block|{
continue|continue;
block|}
if|if
condition|(
name|colInfo
operator|.
name|getIsVirtualCol
argument_list|()
operator|&&
name|colInfo
operator|.
name|isHiddenVirtualCol
argument_list|()
condition|)
block|{
continue|continue;
block|}
comment|// Not matching the regex?
if|if
condition|(
operator|!
name|regex
operator|.
name|matcher
argument_list|(
name|tmp
index|[
literal|1
index|]
argument_list|)
operator|.
name|matches
argument_list|()
condition|)
block|{
continue|continue;
block|}
if|if
condition|(
name|subQuery
condition|)
block|{
name|output
operator|.
name|checkColumn
argument_list|(
name|tmp
index|[
literal|0
index|]
argument_list|,
name|tmp
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
name|ColumnInfo
name|oColInfo
init|=
name|inputColsProcessed
operator|.
name|get
argument_list|(
name|colInfo
argument_list|)
decl_stmt|;
if|if
condition|(
name|oColInfo
operator|==
literal|null
condition|)
block|{
name|ExprNodeColumnDesc
name|expr
init|=
operator|new
name|ExprNodeColumnDesc
argument_list|(
name|colInfo
operator|.
name|getType
argument_list|()
argument_list|,
name|name
argument_list|,
name|colInfo
operator|.
name|getTabAlias
argument_list|()
argument_list|,
name|colInfo
operator|.
name|getIsVirtualCol
argument_list|()
argument_list|,
name|colInfo
operator|.
name|isSkewedCol
argument_list|()
argument_list|)
decl_stmt|;
name|col_list
operator|.
name|add
argument_list|(
name|expr
argument_list|)
expr_stmt|;
name|oColInfo
operator|=
operator|new
name|ColumnInfo
argument_list|(
name|getColumnInternalName
argument_list|(
name|pos
argument_list|)
argument_list|,
name|colInfo
operator|.
name|getType
argument_list|()
argument_list|,
name|colInfo
operator|.
name|getTabAlias
argument_list|()
argument_list|,
name|colInfo
operator|.
name|getIsVirtualCol
argument_list|()
argument_list|,
name|colInfo
operator|.
name|isHiddenVirtualCol
argument_list|()
argument_list|)
expr_stmt|;
name|inputColsProcessed
operator|.
name|put
argument_list|(
name|colInfo
argument_list|,
name|oColInfo
argument_list|)
expr_stmt|;
block|}
name|output
operator|.
name|put
argument_list|(
name|tmp
index|[
literal|0
index|]
argument_list|,
name|tmp
index|[
literal|1
index|]
argument_list|,
name|oColInfo
argument_list|)
expr_stmt|;
name|pos
operator|=
name|Integer
operator|.
name|valueOf
argument_list|(
name|pos
operator|.
name|intValue
argument_list|()
operator|+
literal|1
argument_list|)
expr_stmt|;
name|matched
operator|++
expr_stmt|;
if|if
condition|(
name|unparseTranslator
operator|.
name|isEnabled
argument_list|()
condition|)
block|{
if|if
condition|(
name|replacementText
operator|.
name|length
argument_list|()
operator|>
literal|0
condition|)
block|{
name|replacementText
operator|.
name|append
argument_list|(
literal|", "
argument_list|)
expr_stmt|;
block|}
name|replacementText
operator|.
name|append
argument_list|(
name|HiveUtils
operator|.
name|unparseIdentifier
argument_list|(
name|tmp
index|[
literal|0
index|]
argument_list|,
name|conf
argument_list|)
argument_list|)
expr_stmt|;
name|replacementText
operator|.
name|append
argument_list|(
literal|"."
argument_list|)
expr_stmt|;
name|replacementText
operator|.
name|append
argument_list|(
name|HiveUtils
operator|.
name|unparseIdentifier
argument_list|(
name|tmp
index|[
literal|1
index|]
argument_list|,
name|conf
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|matched
operator|==
literal|0
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|INVALID_COLUMN
operator|.
name|getMsg
argument_list|(
name|sel
argument_list|)
argument_list|)
throw|;
block|}
if|if
condition|(
name|unparseTranslator
operator|.
name|isEnabled
argument_list|()
condition|)
block|{
name|unparseTranslator
operator|.
name|addTranslation
argument_list|(
name|sel
argument_list|,
name|replacementText
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|pos
return|;
block|}
specifier|public
specifier|static
name|String
name|getColumnInternalName
parameter_list|(
name|int
name|pos
parameter_list|)
block|{
return|return
name|HiveConf
operator|.
name|getColumnInternalName
argument_list|(
name|pos
argument_list|)
return|;
block|}
specifier|private
name|String
name|getScriptProgName
parameter_list|(
name|String
name|cmd
parameter_list|)
block|{
name|int
name|end
init|=
name|cmd
operator|.
name|indexOf
argument_list|(
literal|" "
argument_list|)
decl_stmt|;
return|return
operator|(
name|end
operator|==
operator|-
literal|1
operator|)
condition|?
name|cmd
else|:
name|cmd
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|end
argument_list|)
return|;
block|}
specifier|private
name|String
name|getScriptArgs
parameter_list|(
name|String
name|cmd
parameter_list|)
block|{
name|int
name|end
init|=
name|cmd
operator|.
name|indexOf
argument_list|(
literal|" "
argument_list|)
decl_stmt|;
return|return
operator|(
name|end
operator|==
operator|-
literal|1
operator|)
condition|?
literal|""
else|:
name|cmd
operator|.
name|substring
argument_list|(
name|end
argument_list|,
name|cmd
operator|.
name|length
argument_list|()
argument_list|)
return|;
block|}
specifier|private
specifier|static
name|int
name|getPositionFromInternalName
parameter_list|(
name|String
name|internalName
parameter_list|)
block|{
return|return
name|HiveConf
operator|.
name|getPositionFromInternalName
argument_list|(
name|internalName
argument_list|)
return|;
block|}
specifier|private
name|String
name|fetchFilesNotInLocalFilesystem
parameter_list|(
name|String
name|cmd
parameter_list|)
block|{
name|SessionState
name|ss
init|=
name|SessionState
operator|.
name|get
argument_list|()
decl_stmt|;
name|String
name|progName
init|=
name|getScriptProgName
argument_list|(
name|cmd
argument_list|)
decl_stmt|;
if|if
condition|(
name|SessionState
operator|.
name|canDownloadResource
argument_list|(
name|progName
argument_list|)
condition|)
block|{
name|String
name|filePath
init|=
name|ss
operator|.
name|add_resource
argument_list|(
name|ResourceType
operator|.
name|FILE
argument_list|,
name|progName
argument_list|,
literal|true
argument_list|)
decl_stmt|;
if|if
condition|(
name|filePath
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Could not download the resource: "
operator|+
name|progName
argument_list|)
throw|;
block|}
name|Path
name|p
init|=
operator|new
name|Path
argument_list|(
name|filePath
argument_list|)
decl_stmt|;
name|String
name|fileName
init|=
name|p
operator|.
name|getName
argument_list|()
decl_stmt|;
name|String
name|scriptArgs
init|=
name|getScriptArgs
argument_list|(
name|cmd
argument_list|)
decl_stmt|;
name|String
name|finalCmd
init|=
name|fileName
operator|+
name|scriptArgs
decl_stmt|;
return|return
name|finalCmd
return|;
block|}
return|return
name|cmd
return|;
block|}
specifier|private
name|TableDesc
name|getTableDescFromSerDe
parameter_list|(
name|ASTNode
name|child
parameter_list|,
name|String
name|cols
parameter_list|,
name|String
name|colTypes
parameter_list|,
name|boolean
name|defaultCols
parameter_list|)
throws|throws
name|SemanticException
block|{
if|if
condition|(
name|child
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_SERDENAME
condition|)
block|{
name|String
name|serdeName
init|=
name|unescapeSQLString
argument_list|(
name|child
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getText
argument_list|()
argument_list|)
decl_stmt|;
name|Class
argument_list|<
name|?
extends|extends
name|Deserializer
argument_list|>
name|serdeClass
init|=
literal|null
decl_stmt|;
try|try
block|{
name|serdeClass
operator|=
operator|(
name|Class
argument_list|<
name|?
extends|extends
name|Deserializer
argument_list|>
operator|)
name|Class
operator|.
name|forName
argument_list|(
name|serdeName
argument_list|,
literal|true
argument_list|,
name|JavaUtils
operator|.
name|getClassLoader
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|ClassNotFoundException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|e
argument_list|)
throw|;
block|}
name|TableDesc
name|tblDesc
init|=
name|PlanUtils
operator|.
name|getTableDesc
argument_list|(
name|serdeClass
argument_list|,
name|Integer
operator|.
name|toString
argument_list|(
name|Utilities
operator|.
name|tabCode
argument_list|)
argument_list|,
name|cols
argument_list|,
name|colTypes
argument_list|,
name|defaultCols
argument_list|)
decl_stmt|;
comment|// copy all the properties
if|if
condition|(
name|child
operator|.
name|getChildCount
argument_list|()
operator|==
literal|2
condition|)
block|{
name|ASTNode
name|prop
init|=
call|(
name|ASTNode
call|)
argument_list|(
operator|(
name|ASTNode
operator|)
name|child
operator|.
name|getChild
argument_list|(
literal|1
argument_list|)
argument_list|)
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|propChild
init|=
literal|0
init|;
name|propChild
operator|<
name|prop
operator|.
name|getChildCount
argument_list|()
condition|;
name|propChild
operator|++
control|)
block|{
name|String
name|key
init|=
name|unescapeSQLString
argument_list|(
name|prop
operator|.
name|getChild
argument_list|(
name|propChild
argument_list|)
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getText
argument_list|()
argument_list|)
decl_stmt|;
name|String
name|value
init|=
name|unescapeSQLString
argument_list|(
name|prop
operator|.
name|getChild
argument_list|(
name|propChild
argument_list|)
operator|.
name|getChild
argument_list|(
literal|1
argument_list|)
operator|.
name|getText
argument_list|()
argument_list|)
decl_stmt|;
name|tblDesc
operator|.
name|getProperties
argument_list|()
operator|.
name|setProperty
argument_list|(
name|key
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|tblDesc
return|;
block|}
elseif|else
if|if
condition|(
name|child
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_SERDEPROPS
condition|)
block|{
name|TableDesc
name|tblDesc
init|=
name|PlanUtils
operator|.
name|getDefaultTableDesc
argument_list|(
name|Integer
operator|.
name|toString
argument_list|(
name|Utilities
operator|.
name|ctrlaCode
argument_list|)
argument_list|,
name|cols
argument_list|,
name|colTypes
argument_list|,
name|defaultCols
argument_list|)
decl_stmt|;
name|int
name|numChildRowFormat
init|=
name|child
operator|.
name|getChildCount
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|numC
init|=
literal|0
init|;
name|numC
operator|<
name|numChildRowFormat
condition|;
name|numC
operator|++
control|)
block|{
name|ASTNode
name|rowChild
init|=
operator|(
name|ASTNode
operator|)
name|child
operator|.
name|getChild
argument_list|(
name|numC
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|rowChild
operator|.
name|getToken
argument_list|()
operator|.
name|getType
argument_list|()
condition|)
block|{
case|case
name|HiveParser
operator|.
name|TOK_TABLEROWFORMATFIELD
case|:
name|String
name|fieldDelim
init|=
name|unescapeSQLString
argument_list|(
name|rowChild
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getText
argument_list|()
argument_list|)
decl_stmt|;
name|tblDesc
operator|.
name|getProperties
argument_list|()
operator|.
name|setProperty
argument_list|(
name|serdeConstants
operator|.
name|FIELD_DELIM
argument_list|,
name|fieldDelim
argument_list|)
expr_stmt|;
name|tblDesc
operator|.
name|getProperties
argument_list|()
operator|.
name|setProperty
argument_list|(
name|serdeConstants
operator|.
name|SERIALIZATION_FORMAT
argument_list|,
name|fieldDelim
argument_list|)
expr_stmt|;
if|if
condition|(
name|rowChild
operator|.
name|getChildCount
argument_list|()
operator|>=
literal|2
condition|)
block|{
name|String
name|fieldEscape
init|=
name|unescapeSQLString
argument_list|(
name|rowChild
operator|.
name|getChild
argument_list|(
literal|1
argument_list|)
operator|.
name|getText
argument_list|()
argument_list|)
decl_stmt|;
name|tblDesc
operator|.
name|getProperties
argument_list|()
operator|.
name|setProperty
argument_list|(
name|serdeConstants
operator|.
name|ESCAPE_CHAR
argument_list|,
name|fieldEscape
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|HiveParser
operator|.
name|TOK_TABLEROWFORMATCOLLITEMS
case|:
name|tblDesc
operator|.
name|getProperties
argument_list|()
operator|.
name|setProperty
argument_list|(
name|serdeConstants
operator|.
name|COLLECTION_DELIM
argument_list|,
name|unescapeSQLString
argument_list|(
name|rowChild
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getText
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|HiveParser
operator|.
name|TOK_TABLEROWFORMATMAPKEYS
case|:
name|tblDesc
operator|.
name|getProperties
argument_list|()
operator|.
name|setProperty
argument_list|(
name|serdeConstants
operator|.
name|MAPKEY_DELIM
argument_list|,
name|unescapeSQLString
argument_list|(
name|rowChild
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getText
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|HiveParser
operator|.
name|TOK_TABLEROWFORMATLINES
case|:
name|String
name|lineDelim
init|=
name|unescapeSQLString
argument_list|(
name|rowChild
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getText
argument_list|()
argument_list|)
decl_stmt|;
name|tblDesc
operator|.
name|getProperties
argument_list|()
operator|.
name|setProperty
argument_list|(
name|serdeConstants
operator|.
name|LINE_DELIM
argument_list|,
name|lineDelim
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|lineDelim
operator|.
name|equals
argument_list|(
literal|"\n"
argument_list|)
operator|&&
operator|!
name|lineDelim
operator|.
name|equals
argument_list|(
literal|"10"
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|generateErrorMessage
argument_list|(
name|rowChild
argument_list|,
name|ErrorMsg
operator|.
name|LINES_TERMINATED_BY_NON_NEWLINE
operator|.
name|getMsg
argument_list|()
argument_list|)
argument_list|)
throw|;
block|}
case|case
name|HiveParser
operator|.
name|TOK_TABLEROWFORMATNULL
case|:
name|String
name|nullFormat
init|=
name|unescapeSQLString
argument_list|(
name|rowChild
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getText
argument_list|()
argument_list|)
decl_stmt|;
name|tblDesc
operator|.
name|getProperties
argument_list|()
operator|.
name|setProperty
argument_list|(
name|serdeConstants
operator|.
name|SERIALIZATION_NULL_FORMAT
argument_list|,
name|nullFormat
argument_list|)
expr_stmt|;
break|break;
default|default:
assert|assert
literal|false
assert|;
block|}
block|}
return|return
name|tblDesc
return|;
block|}
comment|// should never come here
return|return
literal|null
return|;
block|}
specifier|private
name|void
name|failIfColAliasExists
parameter_list|(
name|Set
argument_list|<
name|String
argument_list|>
name|nameSet
parameter_list|,
name|String
name|name
parameter_list|)
throws|throws
name|SemanticException
block|{
if|if
condition|(
name|nameSet
operator|.
name|contains
argument_list|(
name|name
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|COLUMN_ALIAS_ALREADY_EXISTS
operator|.
name|getMsg
argument_list|(
name|name
argument_list|)
argument_list|)
throw|;
block|}
name|nameSet
operator|.
name|add
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"nls"
argument_list|)
specifier|private
name|Operator
name|genScriptPlan
parameter_list|(
name|ASTNode
name|trfm
parameter_list|,
name|QB
name|qb
parameter_list|,
name|Operator
name|input
parameter_list|)
throws|throws
name|SemanticException
block|{
comment|// If there is no "AS" clause, the output schema will be "key,value"
name|ArrayList
argument_list|<
name|ColumnInfo
argument_list|>
name|outputCols
init|=
operator|new
name|ArrayList
argument_list|<
name|ColumnInfo
argument_list|>
argument_list|()
decl_stmt|;
name|int
name|inputSerDeNum
init|=
literal|1
decl_stmt|,
name|inputRecordWriterNum
init|=
literal|2
decl_stmt|;
name|int
name|outputSerDeNum
init|=
literal|4
decl_stmt|,
name|outputRecordReaderNum
init|=
literal|5
decl_stmt|;
name|int
name|outputColsNum
init|=
literal|6
decl_stmt|;
name|boolean
name|outputColNames
init|=
literal|false
decl_stmt|,
name|outputColSchemas
init|=
literal|false
decl_stmt|;
name|int
name|execPos
init|=
literal|3
decl_stmt|;
name|boolean
name|defaultOutputCols
init|=
literal|false
decl_stmt|;
comment|// Go over all the children
if|if
condition|(
name|trfm
operator|.
name|getChildCount
argument_list|()
operator|>
name|outputColsNum
condition|)
block|{
name|ASTNode
name|outCols
init|=
operator|(
name|ASTNode
operator|)
name|trfm
operator|.
name|getChild
argument_list|(
name|outputColsNum
argument_list|)
decl_stmt|;
if|if
condition|(
name|outCols
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_ALIASLIST
condition|)
block|{
name|outputColNames
operator|=
literal|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|outCols
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_TABCOLLIST
condition|)
block|{
name|outputColSchemas
operator|=
literal|true
expr_stmt|;
block|}
block|}
comment|// If column type is not specified, use a string
if|if
condition|(
operator|!
name|outputColNames
operator|&&
operator|!
name|outputColSchemas
condition|)
block|{
name|String
name|intName
init|=
name|getColumnInternalName
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|ColumnInfo
name|colInfo
init|=
operator|new
name|ColumnInfo
argument_list|(
name|intName
argument_list|,
name|TypeInfoFactory
operator|.
name|stringTypeInfo
argument_list|,
literal|null
argument_list|,
literal|false
argument_list|)
decl_stmt|;
name|colInfo
operator|.
name|setAlias
argument_list|(
literal|"key"
argument_list|)
expr_stmt|;
name|outputCols
operator|.
name|add
argument_list|(
name|colInfo
argument_list|)
expr_stmt|;
name|intName
operator|=
name|getColumnInternalName
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|colInfo
operator|=
operator|new
name|ColumnInfo
argument_list|(
name|intName
argument_list|,
name|TypeInfoFactory
operator|.
name|stringTypeInfo
argument_list|,
literal|null
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|colInfo
operator|.
name|setAlias
argument_list|(
literal|"value"
argument_list|)
expr_stmt|;
name|outputCols
operator|.
name|add
argument_list|(
name|colInfo
argument_list|)
expr_stmt|;
name|defaultOutputCols
operator|=
literal|true
expr_stmt|;
block|}
else|else
block|{
name|ASTNode
name|collist
init|=
operator|(
name|ASTNode
operator|)
name|trfm
operator|.
name|getChild
argument_list|(
name|outputColsNum
argument_list|)
decl_stmt|;
name|int
name|ccount
init|=
name|collist
operator|.
name|getChildCount
argument_list|()
decl_stmt|;
name|Set
argument_list|<
name|String
argument_list|>
name|colAliasNamesDuplicateCheck
init|=
operator|new
name|HashSet
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
if|if
condition|(
name|outputColNames
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|ccount
condition|;
operator|++
name|i
control|)
block|{
name|String
name|colAlias
init|=
name|unescapeIdentifier
argument_list|(
operator|(
operator|(
name|ASTNode
operator|)
name|collist
operator|.
name|getChild
argument_list|(
name|i
argument_list|)
operator|)
operator|.
name|getText
argument_list|()
argument_list|)
decl_stmt|;
name|failIfColAliasExists
argument_list|(
name|colAliasNamesDuplicateCheck
argument_list|,
name|colAlias
argument_list|)
expr_stmt|;
name|String
name|intName
init|=
name|getColumnInternalName
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|ColumnInfo
name|colInfo
init|=
operator|new
name|ColumnInfo
argument_list|(
name|intName
argument_list|,
name|TypeInfoFactory
operator|.
name|stringTypeInfo
argument_list|,
literal|null
argument_list|,
literal|false
argument_list|)
decl_stmt|;
name|colInfo
operator|.
name|setAlias
argument_list|(
name|colAlias
argument_list|)
expr_stmt|;
name|outputCols
operator|.
name|add
argument_list|(
name|colInfo
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|ccount
condition|;
operator|++
name|i
control|)
block|{
name|ASTNode
name|child
init|=
operator|(
name|ASTNode
operator|)
name|collist
operator|.
name|getChild
argument_list|(
name|i
argument_list|)
decl_stmt|;
assert|assert
name|child
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_TABCOL
assert|;
name|String
name|colAlias
init|=
name|unescapeIdentifier
argument_list|(
operator|(
operator|(
name|ASTNode
operator|)
name|child
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|)
operator|.
name|getText
argument_list|()
argument_list|)
decl_stmt|;
name|failIfColAliasExists
argument_list|(
name|colAliasNamesDuplicateCheck
argument_list|,
name|colAlias
argument_list|)
expr_stmt|;
name|String
name|intName
init|=
name|getColumnInternalName
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|ColumnInfo
name|colInfo
init|=
operator|new
name|ColumnInfo
argument_list|(
name|intName
argument_list|,
name|TypeInfoUtils
operator|.
name|getTypeInfoFromTypeString
argument_list|(
name|getTypeStringFromAST
argument_list|(
operator|(
name|ASTNode
operator|)
name|child
operator|.
name|getChild
argument_list|(
literal|1
argument_list|)
argument_list|)
argument_list|)
argument_list|,
literal|null
argument_list|,
literal|false
argument_list|)
decl_stmt|;
name|colInfo
operator|.
name|setAlias
argument_list|(
name|colAlias
argument_list|)
expr_stmt|;
name|outputCols
operator|.
name|add
argument_list|(
name|colInfo
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|RowResolver
name|out_rwsch
init|=
operator|new
name|RowResolver
argument_list|()
decl_stmt|;
name|StringBuilder
name|columns
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|StringBuilder
name|columnTypes
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|outputCols
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|i
operator|!=
literal|0
condition|)
block|{
name|columns
operator|.
name|append
argument_list|(
literal|","
argument_list|)
expr_stmt|;
name|columnTypes
operator|.
name|append
argument_list|(
literal|","
argument_list|)
expr_stmt|;
block|}
name|columns
operator|.
name|append
argument_list|(
name|outputCols
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|getInternalName
argument_list|()
argument_list|)
expr_stmt|;
name|columnTypes
operator|.
name|append
argument_list|(
name|outputCols
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|getType
argument_list|()
operator|.
name|getTypeName
argument_list|()
argument_list|)
expr_stmt|;
name|out_rwsch
operator|.
name|put
argument_list|(
name|qb
operator|.
name|getParseInfo
argument_list|()
operator|.
name|getAlias
argument_list|()
argument_list|,
name|outputCols
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|getAlias
argument_list|()
argument_list|,
name|outputCols
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|StringBuilder
name|inpColumns
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|StringBuilder
name|inpColumnTypes
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|ArrayList
argument_list|<
name|ColumnInfo
argument_list|>
name|inputSchema
init|=
name|opParseCtx
operator|.
name|get
argument_list|(
name|input
argument_list|)
operator|.
name|getRowResolver
argument_list|()
operator|.
name|getColumnInfos
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|inputSchema
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|i
operator|!=
literal|0
condition|)
block|{
name|inpColumns
operator|.
name|append
argument_list|(
literal|","
argument_list|)
expr_stmt|;
name|inpColumnTypes
operator|.
name|append
argument_list|(
literal|","
argument_list|)
expr_stmt|;
block|}
name|inpColumns
operator|.
name|append
argument_list|(
name|inputSchema
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|getInternalName
argument_list|()
argument_list|)
expr_stmt|;
name|inpColumnTypes
operator|.
name|append
argument_list|(
name|inputSchema
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|getType
argument_list|()
operator|.
name|getTypeName
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|TableDesc
name|outInfo
decl_stmt|;
name|TableDesc
name|errInfo
decl_stmt|;
name|TableDesc
name|inInfo
decl_stmt|;
name|String
name|defaultSerdeName
init|=
name|conf
operator|.
name|getVar
argument_list|(
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVESCRIPTSERDE
argument_list|)
decl_stmt|;
name|Class
argument_list|<
name|?
extends|extends
name|Deserializer
argument_list|>
name|serde
decl_stmt|;
try|try
block|{
name|serde
operator|=
operator|(
name|Class
argument_list|<
name|?
extends|extends
name|Deserializer
argument_list|>
operator|)
name|Class
operator|.
name|forName
argument_list|(
name|defaultSerdeName
argument_list|,
literal|true
argument_list|,
name|JavaUtils
operator|.
name|getClassLoader
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|ClassNotFoundException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|e
argument_list|)
throw|;
block|}
name|int
name|fieldSeparator
init|=
name|Utilities
operator|.
name|tabCode
decl_stmt|;
if|if
condition|(
name|HiveConf
operator|.
name|getBoolVar
argument_list|(
name|conf
argument_list|,
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVESCRIPTESCAPE
argument_list|)
condition|)
block|{
name|fieldSeparator
operator|=
name|Utilities
operator|.
name|ctrlaCode
expr_stmt|;
block|}
comment|// Input and Output Serdes
if|if
condition|(
name|trfm
operator|.
name|getChild
argument_list|(
name|inputSerDeNum
argument_list|)
operator|.
name|getChildCount
argument_list|()
operator|>
literal|0
condition|)
block|{
name|inInfo
operator|=
name|getTableDescFromSerDe
argument_list|(
call|(
name|ASTNode
call|)
argument_list|(
operator|(
operator|(
name|ASTNode
operator|)
name|trfm
operator|.
name|getChild
argument_list|(
name|inputSerDeNum
argument_list|)
operator|)
argument_list|)
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
argument_list|,
name|inpColumns
operator|.
name|toString
argument_list|()
argument_list|,
name|inpColumnTypes
operator|.
name|toString
argument_list|()
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|inInfo
operator|=
name|PlanUtils
operator|.
name|getTableDesc
argument_list|(
name|serde
argument_list|,
name|Integer
operator|.
name|toString
argument_list|(
name|fieldSeparator
argument_list|)
argument_list|,
name|inpColumns
operator|.
name|toString
argument_list|()
argument_list|,
name|inpColumnTypes
operator|.
name|toString
argument_list|()
argument_list|,
literal|false
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|trfm
operator|.
name|getChild
argument_list|(
name|outputSerDeNum
argument_list|)
operator|.
name|getChildCount
argument_list|()
operator|>
literal|0
condition|)
block|{
name|outInfo
operator|=
name|getTableDescFromSerDe
argument_list|(
call|(
name|ASTNode
call|)
argument_list|(
operator|(
operator|(
name|ASTNode
operator|)
name|trfm
operator|.
name|getChild
argument_list|(
name|outputSerDeNum
argument_list|)
operator|)
argument_list|)
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
argument_list|,
name|columns
operator|.
name|toString
argument_list|()
argument_list|,
name|columnTypes
operator|.
name|toString
argument_list|()
argument_list|,
literal|false
argument_list|)
expr_stmt|;
comment|// This is for backward compatibility. If the user did not specify the
comment|// output column list, we assume that there are 2 columns: key and value.
comment|// However, if the script outputs: col1, col2, col3 seperated by TAB, the
comment|// requirement is: key is col and value is (col2 TAB col3)
block|}
else|else
block|{
name|outInfo
operator|=
name|PlanUtils
operator|.
name|getTableDesc
argument_list|(
name|serde
argument_list|,
name|Integer
operator|.
name|toString
argument_list|(
name|fieldSeparator
argument_list|)
argument_list|,
name|columns
operator|.
name|toString
argument_list|()
argument_list|,
name|columnTypes
operator|.
name|toString
argument_list|()
argument_list|,
name|defaultOutputCols
argument_list|)
expr_stmt|;
block|}
comment|// Error stream always uses the default serde with a single column
name|errInfo
operator|=
name|PlanUtils
operator|.
name|getTableDesc
argument_list|(
name|serde
argument_list|,
name|Integer
operator|.
name|toString
argument_list|(
name|Utilities
operator|.
name|tabCode
argument_list|)
argument_list|,
literal|"KEY"
argument_list|)
expr_stmt|;
comment|// Output record readers
name|Class
argument_list|<
name|?
extends|extends
name|RecordReader
argument_list|>
name|outRecordReader
init|=
name|getRecordReader
argument_list|(
operator|(
name|ASTNode
operator|)
name|trfm
operator|.
name|getChild
argument_list|(
name|outputRecordReaderNum
argument_list|)
argument_list|)
decl_stmt|;
name|Class
argument_list|<
name|?
extends|extends
name|RecordWriter
argument_list|>
name|inRecordWriter
init|=
name|getRecordWriter
argument_list|(
operator|(
name|ASTNode
operator|)
name|trfm
operator|.
name|getChild
argument_list|(
name|inputRecordWriterNum
argument_list|)
argument_list|)
decl_stmt|;
name|Class
argument_list|<
name|?
extends|extends
name|RecordReader
argument_list|>
name|errRecordReader
init|=
name|getDefaultRecordReader
argument_list|()
decl_stmt|;
name|Operator
name|output
init|=
name|putOpInsertMap
argument_list|(
name|OperatorFactory
operator|.
name|getAndMakeChild
argument_list|(
operator|new
name|ScriptDesc
argument_list|(
name|fetchFilesNotInLocalFilesystem
argument_list|(
name|stripQuotes
argument_list|(
name|trfm
operator|.
name|getChild
argument_list|(
name|execPos
argument_list|)
operator|.
name|getText
argument_list|()
argument_list|)
argument_list|)
argument_list|,
name|inInfo
argument_list|,
name|inRecordWriter
argument_list|,
name|outInfo
argument_list|,
name|outRecordReader
argument_list|,
name|errRecordReader
argument_list|,
name|errInfo
argument_list|)
argument_list|,
operator|new
name|RowSchema
argument_list|(
name|out_rwsch
operator|.
name|getColumnInfos
argument_list|()
argument_list|)
argument_list|,
name|input
argument_list|)
argument_list|,
name|out_rwsch
argument_list|)
decl_stmt|;
return|return
name|output
return|;
block|}
specifier|private
name|Class
argument_list|<
name|?
extends|extends
name|RecordReader
argument_list|>
name|getRecordReader
parameter_list|(
name|ASTNode
name|node
parameter_list|)
throws|throws
name|SemanticException
block|{
name|String
name|name
decl_stmt|;
if|if
condition|(
name|node
operator|.
name|getChildCount
argument_list|()
operator|==
literal|0
condition|)
block|{
name|name
operator|=
name|conf
operator|.
name|getVar
argument_list|(
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVESCRIPTRECORDREADER
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|name
operator|=
name|unescapeSQLString
argument_list|(
name|node
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getText
argument_list|()
argument_list|)
expr_stmt|;
block|}
try|try
block|{
return|return
operator|(
name|Class
argument_list|<
name|?
extends|extends
name|RecordReader
argument_list|>
operator|)
name|Class
operator|.
name|forName
argument_list|(
name|name
argument_list|,
literal|true
argument_list|,
name|JavaUtils
operator|.
name|getClassLoader
argument_list|()
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|ClassNotFoundException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
specifier|private
name|Class
argument_list|<
name|?
extends|extends
name|RecordReader
argument_list|>
name|getDefaultRecordReader
parameter_list|()
throws|throws
name|SemanticException
block|{
name|String
name|name
decl_stmt|;
name|name
operator|=
name|conf
operator|.
name|getVar
argument_list|(
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVESCRIPTRECORDREADER
argument_list|)
expr_stmt|;
try|try
block|{
return|return
operator|(
name|Class
argument_list|<
name|?
extends|extends
name|RecordReader
argument_list|>
operator|)
name|Class
operator|.
name|forName
argument_list|(
name|name
argument_list|,
literal|true
argument_list|,
name|JavaUtils
operator|.
name|getClassLoader
argument_list|()
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|ClassNotFoundException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
specifier|private
name|Class
argument_list|<
name|?
extends|extends
name|RecordWriter
argument_list|>
name|getRecordWriter
parameter_list|(
name|ASTNode
name|node
parameter_list|)
throws|throws
name|SemanticException
block|{
name|String
name|name
decl_stmt|;
if|if
condition|(
name|node
operator|.
name|getChildCount
argument_list|()
operator|==
literal|0
condition|)
block|{
name|name
operator|=
name|conf
operator|.
name|getVar
argument_list|(
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVESCRIPTRECORDWRITER
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|name
operator|=
name|unescapeSQLString
argument_list|(
name|node
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getText
argument_list|()
argument_list|)
expr_stmt|;
block|}
try|try
block|{
return|return
operator|(
name|Class
argument_list|<
name|?
extends|extends
name|RecordWriter
argument_list|>
operator|)
name|Class
operator|.
name|forName
argument_list|(
name|name
argument_list|,
literal|true
argument_list|,
name|JavaUtils
operator|.
name|getClassLoader
argument_list|()
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|ClassNotFoundException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
specifier|private
name|List
argument_list|<
name|Integer
argument_list|>
name|getGroupingSetsForRollup
parameter_list|(
name|int
name|size
parameter_list|)
block|{
name|List
argument_list|<
name|Integer
argument_list|>
name|groupingSetKeys
init|=
operator|new
name|ArrayList
argument_list|<
name|Integer
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<=
name|size
condition|;
name|i
operator|++
control|)
block|{
name|groupingSetKeys
operator|.
name|add
argument_list|(
operator|(
literal|1
operator|<<
name|i
operator|)
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
name|groupingSetKeys
return|;
block|}
specifier|private
name|List
argument_list|<
name|Integer
argument_list|>
name|getGroupingSetsForCube
parameter_list|(
name|int
name|size
parameter_list|)
block|{
name|int
name|count
init|=
literal|1
operator|<<
name|size
decl_stmt|;
name|List
argument_list|<
name|Integer
argument_list|>
name|results
init|=
operator|new
name|ArrayList
argument_list|<
name|Integer
argument_list|>
argument_list|(
name|count
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
operator|++
name|i
control|)
block|{
name|results
operator|.
name|add
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
return|return
name|results
return|;
block|}
comment|// This function returns the grouping sets along with the grouping expressions
comment|// Even if rollups and cubes are present in the query, they are converted to
comment|// grouping sets at this point
specifier|private
name|ObjectPair
argument_list|<
name|List
argument_list|<
name|ASTNode
argument_list|>
argument_list|,
name|List
argument_list|<
name|Integer
argument_list|>
argument_list|>
name|getGroupByGroupingSetsForClause
parameter_list|(
name|QBParseInfo
name|parseInfo
parameter_list|,
name|String
name|dest
parameter_list|)
throws|throws
name|SemanticException
block|{
name|List
argument_list|<
name|Integer
argument_list|>
name|groupingSets
init|=
operator|new
name|ArrayList
argument_list|<
name|Integer
argument_list|>
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|ASTNode
argument_list|>
name|groupByExprs
init|=
name|getGroupByForClause
argument_list|(
name|parseInfo
argument_list|,
name|dest
argument_list|)
decl_stmt|;
if|if
condition|(
name|parseInfo
operator|.
name|getDestRollups
argument_list|()
operator|.
name|contains
argument_list|(
name|dest
argument_list|)
condition|)
block|{
name|groupingSets
operator|=
name|getGroupingSetsForRollup
argument_list|(
name|groupByExprs
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|parseInfo
operator|.
name|getDestCubes
argument_list|()
operator|.
name|contains
argument_list|(
name|dest
argument_list|)
condition|)
block|{
name|groupingSets
operator|=
name|getGroupingSetsForCube
argument_list|(
name|groupByExprs
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|parseInfo
operator|.
name|getDestGroupingSets
argument_list|()
operator|.
name|contains
argument_list|(
name|dest
argument_list|)
condition|)
block|{
name|groupingSets
operator|=
name|getGroupingSets
argument_list|(
name|groupByExprs
argument_list|,
name|parseInfo
argument_list|,
name|dest
argument_list|)
expr_stmt|;
block|}
return|return
operator|new
name|ObjectPair
argument_list|<
name|List
argument_list|<
name|ASTNode
argument_list|>
argument_list|,
name|List
argument_list|<
name|Integer
argument_list|>
argument_list|>
argument_list|(
name|groupByExprs
argument_list|,
name|groupingSets
argument_list|)
return|;
block|}
specifier|private
name|List
argument_list|<
name|Integer
argument_list|>
name|getGroupingSets
parameter_list|(
name|List
argument_list|<
name|ASTNode
argument_list|>
name|groupByExpr
parameter_list|,
name|QBParseInfo
name|parseInfo
parameter_list|,
name|String
name|dest
parameter_list|)
throws|throws
name|SemanticException
block|{
name|Map
argument_list|<
name|String
argument_list|,
name|Integer
argument_list|>
name|exprPos
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|Integer
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|groupByExpr
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|ASTNode
name|node
init|=
name|groupByExpr
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|exprPos
operator|.
name|put
argument_list|(
name|node
operator|.
name|toStringTree
argument_list|()
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
name|ASTNode
name|root
init|=
name|parseInfo
operator|.
name|getGroupByForClause
argument_list|(
name|dest
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|Integer
argument_list|>
name|result
init|=
operator|new
name|ArrayList
argument_list|<
name|Integer
argument_list|>
argument_list|(
name|root
operator|==
literal|null
condition|?
literal|0
else|:
name|root
operator|.
name|getChildCount
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|root
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|root
operator|.
name|getChildCount
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|ASTNode
name|child
init|=
operator|(
name|ASTNode
operator|)
name|root
operator|.
name|getChild
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|child
operator|.
name|getType
argument_list|()
operator|!=
name|HiveParser
operator|.
name|TOK_GROUPING_SETS_EXPRESSION
condition|)
block|{
continue|continue;
block|}
name|int
name|bitmap
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|child
operator|.
name|getChildCount
argument_list|()
condition|;
operator|++
name|j
control|)
block|{
name|String
name|treeAsString
init|=
name|child
operator|.
name|getChild
argument_list|(
name|j
argument_list|)
operator|.
name|toStringTree
argument_list|()
decl_stmt|;
name|Integer
name|pos
init|=
name|exprPos
operator|.
name|get
argument_list|(
name|treeAsString
argument_list|)
decl_stmt|;
if|if
condition|(
name|pos
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|generateErrorMessage
argument_list|(
operator|(
name|ASTNode
operator|)
name|child
operator|.
name|getChild
argument_list|(
name|j
argument_list|)
argument_list|,
name|ErrorMsg
operator|.
name|HIVE_GROUPING_SETS_EXPR_NOT_IN_GROUPBY
operator|.
name|getErrorCodedMsg
argument_list|()
argument_list|)
argument_list|)
throw|;
block|}
name|bitmap
operator|=
name|setBit
argument_list|(
name|bitmap
argument_list|,
name|pos
argument_list|)
expr_stmt|;
block|}
name|result
operator|.
name|add
argument_list|(
name|bitmap
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|checkForNoAggr
argument_list|(
name|result
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|HIVE_GROUPING_SETS_AGGR_NOFUNC
operator|.
name|getMsg
argument_list|()
argument_list|)
throw|;
block|}
return|return
name|result
return|;
block|}
specifier|private
name|boolean
name|checkForNoAggr
parameter_list|(
name|List
argument_list|<
name|Integer
argument_list|>
name|bitmaps
parameter_list|)
block|{
name|boolean
name|ret
init|=
literal|true
decl_stmt|;
for|for
control|(
name|int
name|mask
range|:
name|bitmaps
control|)
block|{
name|ret
operator|&=
name|mask
operator|==
literal|0
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
specifier|private
name|int
name|setBit
parameter_list|(
name|int
name|bitmap
parameter_list|,
name|int
name|bitIdx
parameter_list|)
block|{
return|return
name|bitmap
operator||
operator|(
literal|1
operator|<<
name|bitIdx
operator|)
return|;
block|}
comment|/**    * This function is a wrapper of parseInfo.getGroupByForClause which    * automatically translates SELECT DISTINCT a,b,c to SELECT a,b,c GROUP BY    * a,b,c.    */
specifier|static
name|List
argument_list|<
name|ASTNode
argument_list|>
name|getGroupByForClause
parameter_list|(
name|QBParseInfo
name|parseInfo
parameter_list|,
name|String
name|dest
parameter_list|)
block|{
if|if
condition|(
name|parseInfo
operator|.
name|getSelForClause
argument_list|(
name|dest
argument_list|)
operator|.
name|getToken
argument_list|()
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_SELECTDI
condition|)
block|{
name|ASTNode
name|selectExprs
init|=
name|parseInfo
operator|.
name|getSelForClause
argument_list|(
name|dest
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|ASTNode
argument_list|>
name|result
init|=
operator|new
name|ArrayList
argument_list|<
name|ASTNode
argument_list|>
argument_list|(
name|selectExprs
operator|==
literal|null
condition|?
literal|0
else|:
name|selectExprs
operator|.
name|getChildCount
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|selectExprs
operator|!=
literal|null
condition|)
block|{
name|HashMap
argument_list|<
name|String
argument_list|,
name|ASTNode
argument_list|>
name|windowingExprs
init|=
name|parseInfo
operator|.
name|getWindowingExprsForClause
argument_list|(
name|dest
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|selectExprs
operator|.
name|getChildCount
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
operator|(
operator|(
name|ASTNode
operator|)
name|selectExprs
operator|.
name|getChild
argument_list|(
name|i
argument_list|)
operator|)
operator|.
name|getToken
argument_list|()
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_HINTLIST
condition|)
block|{
continue|continue;
block|}
comment|// table.column AS alias
name|ASTNode
name|grpbyExpr
init|=
operator|(
name|ASTNode
operator|)
name|selectExprs
operator|.
name|getChild
argument_list|(
name|i
argument_list|)
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
decl_stmt|;
comment|/*            * If this is handled by Windowing then ignore it.            */
if|if
condition|(
name|windowingExprs
operator|!=
literal|null
operator|&&
name|windowingExprs
operator|.
name|containsKey
argument_list|(
name|grpbyExpr
operator|.
name|toStringTree
argument_list|()
argument_list|)
condition|)
block|{
continue|continue;
block|}
name|result
operator|.
name|add
argument_list|(
name|grpbyExpr
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|result
return|;
block|}
else|else
block|{
name|ASTNode
name|grpByExprs
init|=
name|parseInfo
operator|.
name|getGroupByForClause
argument_list|(
name|dest
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|ASTNode
argument_list|>
name|result
init|=
operator|new
name|ArrayList
argument_list|<
name|ASTNode
argument_list|>
argument_list|(
name|grpByExprs
operator|==
literal|null
condition|?
literal|0
else|:
name|grpByExprs
operator|.
name|getChildCount
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|grpByExprs
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|grpByExprs
operator|.
name|getChildCount
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|ASTNode
name|grpbyExpr
init|=
operator|(
name|ASTNode
operator|)
name|grpByExprs
operator|.
name|getChild
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|grpbyExpr
operator|.
name|getType
argument_list|()
operator|!=
name|HiveParser
operator|.
name|TOK_GROUPING_SETS_EXPRESSION
condition|)
block|{
name|result
operator|.
name|add
argument_list|(
name|grpbyExpr
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
name|result
return|;
block|}
block|}
specifier|private
specifier|static
name|String
index|[]
name|getColAlias
parameter_list|(
name|ASTNode
name|selExpr
parameter_list|,
name|String
name|defaultName
parameter_list|,
name|RowResolver
name|inputRR
parameter_list|,
name|boolean
name|includeFuncName
parameter_list|,
name|int
name|colNum
parameter_list|)
block|{
name|String
name|colAlias
init|=
literal|null
decl_stmt|;
name|String
name|tabAlias
init|=
literal|null
decl_stmt|;
name|String
index|[]
name|colRef
init|=
operator|new
name|String
index|[
literal|2
index|]
decl_stmt|;
comment|//for queries with a windowing expressions, the selexpr may have a third child
if|if
condition|(
name|selExpr
operator|.
name|getChildCount
argument_list|()
operator|==
literal|2
operator|||
operator|(
name|selExpr
operator|.
name|getChildCount
argument_list|()
operator|==
literal|3
operator|&&
name|selExpr
operator|.
name|getChild
argument_list|(
literal|2
argument_list|)
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_WINDOWSPEC
operator|)
condition|)
block|{
comment|// return zz for "xx + yy AS zz"
name|colAlias
operator|=
name|unescapeIdentifier
argument_list|(
name|selExpr
operator|.
name|getChild
argument_list|(
literal|1
argument_list|)
operator|.
name|getText
argument_list|()
argument_list|)
expr_stmt|;
name|colRef
index|[
literal|0
index|]
operator|=
name|tabAlias
expr_stmt|;
name|colRef
index|[
literal|1
index|]
operator|=
name|colAlias
expr_stmt|;
return|return
name|colRef
return|;
block|}
name|ASTNode
name|root
init|=
operator|(
name|ASTNode
operator|)
name|selExpr
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|root
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_TABLE_OR_COL
condition|)
block|{
name|colAlias
operator|=
name|BaseSemanticAnalyzer
operator|.
name|unescapeIdentifier
argument_list|(
name|root
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getText
argument_list|()
argument_list|)
expr_stmt|;
name|colRef
index|[
literal|0
index|]
operator|=
name|tabAlias
expr_stmt|;
name|colRef
index|[
literal|1
index|]
operator|=
name|colAlias
expr_stmt|;
return|return
name|colRef
return|;
block|}
if|if
condition|(
name|root
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|DOT
condition|)
block|{
name|ASTNode
name|tab
init|=
operator|(
name|ASTNode
operator|)
name|root
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|tab
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_TABLE_OR_COL
condition|)
block|{
name|String
name|t
init|=
name|unescapeIdentifier
argument_list|(
name|tab
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getText
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|inputRR
operator|.
name|hasTableAlias
argument_list|(
name|t
argument_list|)
condition|)
block|{
name|tabAlias
operator|=
name|t
expr_stmt|;
block|}
block|}
comment|// Return zz for "xx.zz" and "xx.yy.zz"
name|ASTNode
name|col
init|=
operator|(
name|ASTNode
operator|)
name|root
operator|.
name|getChild
argument_list|(
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|col
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|Identifier
condition|)
block|{
name|colAlias
operator|=
name|unescapeIdentifier
argument_list|(
name|col
operator|.
name|getText
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
comment|// if specified generate alias using func name
if|if
condition|(
name|includeFuncName
operator|&&
operator|(
name|root
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_FUNCTION
operator|)
condition|)
block|{
name|String
name|expr_flattened
init|=
name|root
operator|.
name|toStringTree
argument_list|()
decl_stmt|;
comment|// remove all TOK tokens
name|String
name|expr_no_tok
init|=
name|expr_flattened
operator|.
name|replaceAll
argument_list|(
literal|"TOK_\\S+"
argument_list|,
literal|""
argument_list|)
decl_stmt|;
comment|// remove all non alphanumeric letters, replace whitespace spans with underscore
name|String
name|expr_formatted
init|=
name|expr_no_tok
operator|.
name|replaceAll
argument_list|(
literal|"\\W"
argument_list|,
literal|" "
argument_list|)
operator|.
name|trim
argument_list|()
operator|.
name|replaceAll
argument_list|(
literal|"\\s+"
argument_list|,
literal|"_"
argument_list|)
decl_stmt|;
comment|// limit length to 20 chars
if|if
condition|(
name|expr_formatted
operator|.
name|length
argument_list|()
operator|>
name|AUTOGEN_COLALIAS_PRFX_MAXLENGTH
condition|)
block|{
name|expr_formatted
operator|=
name|expr_formatted
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|AUTOGEN_COLALIAS_PRFX_MAXLENGTH
argument_list|)
expr_stmt|;
block|}
comment|// append colnum to make it unique
name|colAlias
operator|=
name|expr_formatted
operator|.
name|concat
argument_list|(
literal|"_"
operator|+
name|colNum
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|colAlias
operator|==
literal|null
condition|)
block|{
comment|// Return defaultName if selExpr is not a simple xx.yy.zz
name|colAlias
operator|=
name|defaultName
operator|+
name|colNum
expr_stmt|;
block|}
name|colRef
index|[
literal|0
index|]
operator|=
name|tabAlias
expr_stmt|;
name|colRef
index|[
literal|1
index|]
operator|=
name|colAlias
expr_stmt|;
return|return
name|colRef
return|;
block|}
comment|/**    * Returns whether the pattern is a regex expression (instead of a normal    * string). Normal string is a string with all alphabets/digits and "_".    */
specifier|private
specifier|static
name|boolean
name|isRegex
parameter_list|(
name|String
name|pattern
parameter_list|,
name|HiveConf
name|conf
parameter_list|)
block|{
name|String
name|qIdSupport
init|=
name|HiveConf
operator|.
name|getVar
argument_list|(
name|conf
argument_list|,
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVE_QUOTEDID_SUPPORT
argument_list|)
decl_stmt|;
if|if
condition|(
literal|"column"
operator|.
name|equals
argument_list|(
name|qIdSupport
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|pattern
operator|.
name|length
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|Character
operator|.
name|isLetterOrDigit
argument_list|(
name|pattern
operator|.
name|charAt
argument_list|(
name|i
argument_list|)
argument_list|)
operator|&&
name|pattern
operator|.
name|charAt
argument_list|(
name|i
argument_list|)
operator|!=
literal|'_'
condition|)
block|{
return|return
literal|true
return|;
block|}
block|}
return|return
literal|false
return|;
block|}
specifier|private
name|Operator
argument_list|<
name|?
argument_list|>
name|genSelectPlan
parameter_list|(
name|String
name|dest
parameter_list|,
name|QB
name|qb
parameter_list|,
name|Operator
argument_list|<
name|?
argument_list|>
name|input
parameter_list|)
throws|throws
name|SemanticException
block|{
name|ASTNode
name|selExprList
init|=
name|qb
operator|.
name|getParseInfo
argument_list|()
operator|.
name|getSelForClause
argument_list|(
name|dest
argument_list|)
decl_stmt|;
name|Operator
argument_list|<
name|?
argument_list|>
name|op
init|=
name|genSelectPlan
argument_list|(
name|selExprList
argument_list|,
name|qb
argument_list|,
name|input
argument_list|,
literal|false
argument_list|)
decl_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Created Select Plan for clause: "
operator|+
name|dest
argument_list|)
expr_stmt|;
block|}
return|return
name|op
return|;
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"nls"
argument_list|)
specifier|private
name|Operator
argument_list|<
name|?
argument_list|>
name|genSelectPlan
parameter_list|(
name|ASTNode
name|selExprList
parameter_list|,
name|QB
name|qb
parameter_list|,
name|Operator
argument_list|<
name|?
argument_list|>
name|input
parameter_list|,
name|boolean
name|outerLV
parameter_list|)
throws|throws
name|SemanticException
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"tree: "
operator|+
name|selExprList
operator|.
name|toStringTree
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|ArrayList
argument_list|<
name|ExprNodeDesc
argument_list|>
name|col_list
init|=
operator|new
name|ArrayList
argument_list|<
name|ExprNodeDesc
argument_list|>
argument_list|()
decl_stmt|;
name|RowResolver
name|out_rwsch
init|=
operator|new
name|RowResolver
argument_list|()
decl_stmt|;
name|ASTNode
name|trfm
init|=
literal|null
decl_stmt|;
name|Integer
name|pos
init|=
name|Integer
operator|.
name|valueOf
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|RowResolver
name|inputRR
init|=
name|opParseCtx
operator|.
name|get
argument_list|(
name|input
argument_list|)
operator|.
name|getRowResolver
argument_list|()
decl_stmt|;
comment|// SELECT * or SELECT TRANSFORM(*)
name|boolean
name|selectStar
init|=
literal|false
decl_stmt|;
name|int
name|posn
init|=
literal|0
decl_stmt|;
name|boolean
name|hintPresent
init|=
operator|(
name|selExprList
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_HINTLIST
operator|)
decl_stmt|;
if|if
condition|(
name|hintPresent
condition|)
block|{
name|posn
operator|++
expr_stmt|;
block|}
name|boolean
name|subQuery
init|=
name|qb
operator|.
name|getParseInfo
argument_list|()
operator|.
name|getIsSubQ
argument_list|()
decl_stmt|;
name|boolean
name|isInTransform
init|=
operator|(
name|selExprList
operator|.
name|getChild
argument_list|(
name|posn
argument_list|)
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_TRANSFORM
operator|)
decl_stmt|;
if|if
condition|(
name|isInTransform
condition|)
block|{
name|queryProperties
operator|.
name|setUsesScript
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|globalLimitCtx
operator|.
name|setHasTransformOrUDTF
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|trfm
operator|=
operator|(
name|ASTNode
operator|)
name|selExprList
operator|.
name|getChild
argument_list|(
name|posn
argument_list|)
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
comment|// Detect queries of the form SELECT udtf(col) AS ...
comment|// by looking for a function as the first child, and then checking to see
comment|// if the function is a Generic UDTF. It's not as clean as TRANSFORM due to
comment|// the lack of a special token.
name|boolean
name|isUDTF
init|=
literal|false
decl_stmt|;
name|String
name|udtfTableAlias
init|=
literal|null
decl_stmt|;
name|ArrayList
argument_list|<
name|String
argument_list|>
name|udtfColAliases
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
name|ASTNode
name|udtfExpr
init|=
operator|(
name|ASTNode
operator|)
name|selExprList
operator|.
name|getChild
argument_list|(
name|posn
argument_list|)
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|GenericUDTF
name|genericUDTF
init|=
literal|null
decl_stmt|;
name|int
name|udtfExprType
init|=
name|udtfExpr
operator|.
name|getType
argument_list|()
decl_stmt|;
if|if
condition|(
name|udtfExprType
operator|==
name|HiveParser
operator|.
name|TOK_FUNCTION
operator|||
name|udtfExprType
operator|==
name|HiveParser
operator|.
name|TOK_FUNCTIONSTAR
condition|)
block|{
name|String
name|funcName
init|=
name|TypeCheckProcFactory
operator|.
name|DefaultExprProcessor
operator|.
name|getFunctionText
argument_list|(
name|udtfExpr
argument_list|,
literal|true
argument_list|)
decl_stmt|;
name|FunctionInfo
name|fi
init|=
name|FunctionRegistry
operator|.
name|getFunctionInfo
argument_list|(
name|funcName
argument_list|)
decl_stmt|;
if|if
condition|(
name|fi
operator|!=
literal|null
condition|)
block|{
name|genericUDTF
operator|=
name|fi
operator|.
name|getGenericUDTF
argument_list|()
expr_stmt|;
block|}
name|isUDTF
operator|=
operator|(
name|genericUDTF
operator|!=
literal|null
operator|)
expr_stmt|;
if|if
condition|(
name|isUDTF
condition|)
block|{
name|globalLimitCtx
operator|.
name|setHasTransformOrUDTF
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|isUDTF
operator|&&
operator|!
name|fi
operator|.
name|isNative
argument_list|()
condition|)
block|{
name|unparseTranslator
operator|.
name|addIdentifierTranslation
argument_list|(
operator|(
name|ASTNode
operator|)
name|udtfExpr
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|isUDTF
operator|&&
operator|(
name|selectStar
operator|=
name|udtfExprType
operator|==
name|HiveParser
operator|.
name|TOK_FUNCTIONSTAR
operator|)
condition|)
block|{
name|genColListRegex
argument_list|(
literal|".*"
argument_list|,
literal|null
argument_list|,
operator|(
name|ASTNode
operator|)
name|udtfExpr
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
argument_list|,
name|col_list
argument_list|,
name|inputRR
argument_list|,
name|pos
argument_list|,
name|out_rwsch
argument_list|,
name|qb
operator|.
name|getAliases
argument_list|()
argument_list|,
name|subQuery
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|isUDTF
condition|)
block|{
comment|// Only support a single expression when it's a UDTF
if|if
condition|(
name|selExprList
operator|.
name|getChildCount
argument_list|()
operator|>
literal|1
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|generateErrorMessage
argument_list|(
operator|(
name|ASTNode
operator|)
name|selExprList
operator|.
name|getChild
argument_list|(
literal|1
argument_list|)
argument_list|,
name|ErrorMsg
operator|.
name|UDTF_MULTIPLE_EXPR
operator|.
name|getMsg
argument_list|()
argument_list|)
argument_list|)
throw|;
block|}
name|ASTNode
name|selExpr
init|=
operator|(
name|ASTNode
operator|)
name|selExprList
operator|.
name|getChild
argument_list|(
name|posn
argument_list|)
decl_stmt|;
comment|// Get the column / table aliases from the expression. Start from 1 as
comment|// 0 is the TOK_FUNCTION
comment|// column names also can be inferred from result of UDTF
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<
name|selExpr
operator|.
name|getChildCount
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|ASTNode
name|selExprChild
init|=
operator|(
name|ASTNode
operator|)
name|selExpr
operator|.
name|getChild
argument_list|(
name|i
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|selExprChild
operator|.
name|getType
argument_list|()
condition|)
block|{
case|case
name|HiveParser
operator|.
name|Identifier
case|:
name|udtfColAliases
operator|.
name|add
argument_list|(
name|unescapeIdentifier
argument_list|(
name|selExprChild
operator|.
name|getText
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|unparseTranslator
operator|.
name|addIdentifierTranslation
argument_list|(
name|selExprChild
argument_list|)
expr_stmt|;
break|break;
case|case
name|HiveParser
operator|.
name|TOK_TABALIAS
case|:
assert|assert
operator|(
name|selExprChild
operator|.
name|getChildCount
argument_list|()
operator|==
literal|1
operator|)
assert|;
name|udtfTableAlias
operator|=
name|unescapeIdentifier
argument_list|(
name|selExprChild
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getText
argument_list|()
argument_list|)
expr_stmt|;
name|qb
operator|.
name|addAlias
argument_list|(
name|udtfTableAlias
argument_list|)
expr_stmt|;
name|unparseTranslator
operator|.
name|addIdentifierTranslation
argument_list|(
operator|(
name|ASTNode
operator|)
name|selExprChild
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
assert|assert
operator|(
literal|false
operator|)
assert|;
block|}
block|}
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"UDTF table alias is "
operator|+
name|udtfTableAlias
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"UDTF col aliases are "
operator|+
name|udtfColAliases
argument_list|)
expr_stmt|;
block|}
block|}
comment|// The list of expressions after SELECT or SELECT TRANSFORM.
name|ASTNode
name|exprList
decl_stmt|;
if|if
condition|(
name|isInTransform
condition|)
block|{
name|exprList
operator|=
operator|(
name|ASTNode
operator|)
name|trfm
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|isUDTF
condition|)
block|{
name|exprList
operator|=
name|udtfExpr
expr_stmt|;
block|}
else|else
block|{
name|exprList
operator|=
name|selExprList
expr_stmt|;
block|}
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"genSelectPlan: input = "
operator|+
name|inputRR
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// For UDTF's, skip the function name to get the expressions
name|int
name|startPosn
init|=
name|isUDTF
condition|?
name|posn
operator|+
literal|1
else|:
name|posn
decl_stmt|;
if|if
condition|(
name|isInTransform
condition|)
block|{
name|startPosn
operator|=
literal|0
expr_stmt|;
block|}
comment|// Iterate over all expression (either after SELECT, or in SELECT TRANSFORM)
for|for
control|(
name|int
name|i
init|=
name|startPosn
init|;
name|i
operator|<
name|exprList
operator|.
name|getChildCount
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
comment|// child can be EXPR AS ALIAS, or EXPR.
name|ASTNode
name|child
init|=
operator|(
name|ASTNode
operator|)
name|exprList
operator|.
name|getChild
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|boolean
name|hasAsClause
init|=
operator|(
operator|!
name|isInTransform
operator|)
operator|&&
operator|(
name|child
operator|.
name|getChildCount
argument_list|()
operator|==
literal|2
operator|)
decl_stmt|;
name|boolean
name|isWindowSpec
init|=
name|child
operator|.
name|getChildCount
argument_list|()
operator|==
literal|3
condition|?
operator|(
name|child
operator|.
name|getChild
argument_list|(
literal|2
argument_list|)
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_WINDOWSPEC
operator|)
else|:
literal|false
decl_stmt|;
comment|// EXPR AS (ALIAS,...) parses, but is only allowed for UDTF's
comment|// This check is not needed and invalid when there is a transform b/c the
comment|// AST's are slightly different.
if|if
condition|(
operator|!
name|isWindowSpec
operator|&&
operator|!
name|isInTransform
operator|&&
operator|!
name|isUDTF
operator|&&
name|child
operator|.
name|getChildCount
argument_list|()
operator|>
literal|2
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|generateErrorMessage
argument_list|(
operator|(
name|ASTNode
operator|)
name|child
operator|.
name|getChild
argument_list|(
literal|2
argument_list|)
argument_list|,
name|ErrorMsg
operator|.
name|INVALID_AS
operator|.
name|getMsg
argument_list|()
argument_list|)
argument_list|)
throw|;
block|}
comment|// The real expression
name|ASTNode
name|expr
decl_stmt|;
name|String
name|tabAlias
decl_stmt|;
name|String
name|colAlias
decl_stmt|;
if|if
condition|(
name|isInTransform
operator|||
name|isUDTF
condition|)
block|{
name|tabAlias
operator|=
literal|null
expr_stmt|;
name|colAlias
operator|=
name|autogenColAliasPrfxLbl
operator|+
name|i
expr_stmt|;
name|expr
operator|=
name|child
expr_stmt|;
block|}
else|else
block|{
comment|// Get rid of TOK_SELEXPR
name|expr
operator|=
operator|(
name|ASTNode
operator|)
name|child
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|String
index|[]
name|colRef
init|=
name|getColAlias
argument_list|(
name|child
argument_list|,
name|autogenColAliasPrfxLbl
argument_list|,
name|inputRR
argument_list|,
name|autogenColAliasPrfxIncludeFuncName
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|tabAlias
operator|=
name|colRef
index|[
literal|0
index|]
expr_stmt|;
name|colAlias
operator|=
name|colRef
index|[
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|hasAsClause
condition|)
block|{
name|unparseTranslator
operator|.
name|addIdentifierTranslation
argument_list|(
operator|(
name|ASTNode
operator|)
name|child
operator|.
name|getChild
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|expr
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_ALLCOLREF
condition|)
block|{
name|pos
operator|=
name|genColListRegex
argument_list|(
literal|".*"
argument_list|,
name|expr
operator|.
name|getChildCount
argument_list|()
operator|==
literal|0
condition|?
literal|null
else|:
name|getUnescapedName
argument_list|(
operator|(
name|ASTNode
operator|)
name|expr
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
argument_list|)
operator|.
name|toLowerCase
argument_list|()
argument_list|,
name|expr
argument_list|,
name|col_list
argument_list|,
name|inputRR
argument_list|,
name|pos
argument_list|,
name|out_rwsch
argument_list|,
name|qb
operator|.
name|getAliases
argument_list|()
argument_list|,
name|subQuery
argument_list|)
expr_stmt|;
name|selectStar
operator|=
literal|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|expr
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_TABLE_OR_COL
operator|&&
operator|!
name|hasAsClause
operator|&&
operator|!
name|inputRR
operator|.
name|getIsExprResolver
argument_list|()
operator|&&
name|isRegex
argument_list|(
name|unescapeIdentifier
argument_list|(
name|expr
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getText
argument_list|()
argument_list|)
argument_list|,
name|conf
argument_list|)
condition|)
block|{
comment|// In case the expression is a regex COL.
comment|// This can only happen without AS clause
comment|// We don't allow this for ExprResolver - the Group By case
name|pos
operator|=
name|genColListRegex
argument_list|(
name|unescapeIdentifier
argument_list|(
name|expr
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getText
argument_list|()
argument_list|)
argument_list|,
literal|null
argument_list|,
name|expr
argument_list|,
name|col_list
argument_list|,
name|inputRR
argument_list|,
name|pos
argument_list|,
name|out_rwsch
argument_list|,
name|qb
operator|.
name|getAliases
argument_list|()
argument_list|,
name|subQuery
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|expr
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|DOT
operator|&&
name|expr
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_TABLE_OR_COL
operator|&&
name|inputRR
operator|.
name|hasTableAlias
argument_list|(
name|unescapeIdentifier
argument_list|(
name|expr
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getText
argument_list|()
operator|.
name|toLowerCase
argument_list|()
argument_list|)
argument_list|)
operator|&&
operator|!
name|hasAsClause
operator|&&
operator|!
name|inputRR
operator|.
name|getIsExprResolver
argument_list|()
operator|&&
name|isRegex
argument_list|(
name|unescapeIdentifier
argument_list|(
name|expr
operator|.
name|getChild
argument_list|(
literal|1
argument_list|)
operator|.
name|getText
argument_list|()
argument_list|)
argument_list|,
name|conf
argument_list|)
condition|)
block|{
comment|// In case the expression is TABLE.COL (col can be regex).
comment|// This can only happen without AS clause
comment|// We don't allow this for ExprResolver - the Group By case
name|pos
operator|=
name|genColListRegex
argument_list|(
name|unescapeIdentifier
argument_list|(
name|expr
operator|.
name|getChild
argument_list|(
literal|1
argument_list|)
operator|.
name|getText
argument_list|()
argument_list|)
argument_list|,
name|unescapeIdentifier
argument_list|(
name|expr
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getText
argument_list|()
operator|.
name|toLowerCase
argument_list|()
argument_list|)
argument_list|,
name|expr
argument_list|,
name|col_list
argument_list|,
name|inputRR
argument_list|,
name|pos
argument_list|,
name|out_rwsch
argument_list|,
name|qb
operator|.
name|getAliases
argument_list|()
argument_list|,
name|subQuery
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// Case when this is an expression
name|TypeCheckCtx
name|tcCtx
init|=
operator|new
name|TypeCheckCtx
argument_list|(
name|inputRR
argument_list|)
decl_stmt|;
comment|// We allow stateful functions in the SELECT list (but nowhere else)
name|tcCtx
operator|.
name|setAllowStatefulFunctions
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|ExprNodeDesc
name|exp
init|=
name|genExprNodeDesc
argument_list|(
name|expr
argument_list|,
name|inputRR
argument_list|,
name|tcCtx
argument_list|)
decl_stmt|;
name|String
name|recommended
init|=
name|recommendName
argument_list|(
name|exp
argument_list|,
name|colAlias
argument_list|)
decl_stmt|;
if|if
condition|(
name|recommended
operator|!=
literal|null
operator|&&
name|out_rwsch
operator|.
name|get
argument_list|(
literal|null
argument_list|,
name|recommended
argument_list|)
operator|==
literal|null
condition|)
block|{
name|colAlias
operator|=
name|recommended
expr_stmt|;
block|}
name|col_list
operator|.
name|add
argument_list|(
name|exp
argument_list|)
expr_stmt|;
if|if
condition|(
name|subQuery
condition|)
block|{
name|out_rwsch
operator|.
name|checkColumn
argument_list|(
name|tabAlias
argument_list|,
name|colAlias
argument_list|)
expr_stmt|;
block|}
name|ColumnInfo
name|colInfo
init|=
operator|new
name|ColumnInfo
argument_list|(
name|getColumnInternalName
argument_list|(
name|pos
argument_list|)
argument_list|,
name|exp
operator|.
name|getWritableObjectInspector
argument_list|()
argument_list|,
name|tabAlias
argument_list|,
literal|false
argument_list|)
decl_stmt|;
name|colInfo
operator|.
name|setSkewedCol
argument_list|(
operator|(
name|exp
operator|instanceof
name|ExprNodeColumnDesc
operator|)
condition|?
operator|(
operator|(
name|ExprNodeColumnDesc
operator|)
name|exp
operator|)
operator|.
name|isSkewedCol
argument_list|()
else|:
literal|false
argument_list|)
expr_stmt|;
name|out_rwsch
operator|.
name|put
argument_list|(
name|tabAlias
argument_list|,
name|colAlias
argument_list|,
name|colInfo
argument_list|)
expr_stmt|;
if|if
condition|(
name|exp
operator|instanceof
name|ExprNodeColumnDesc
condition|)
block|{
name|ExprNodeColumnDesc
name|colExp
init|=
operator|(
name|ExprNodeColumnDesc
operator|)
name|exp
decl_stmt|;
name|String
index|[]
name|altMapping
init|=
name|inputRR
operator|.
name|getAlternateMappings
argument_list|(
name|colExp
operator|.
name|getColumn
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|altMapping
operator|!=
literal|null
condition|)
block|{
name|out_rwsch
operator|.
name|put
argument_list|(
name|altMapping
index|[
literal|0
index|]
argument_list|,
name|altMapping
index|[
literal|1
index|]
argument_list|,
name|colInfo
argument_list|)
expr_stmt|;
block|}
block|}
name|pos
operator|=
name|Integer
operator|.
name|valueOf
argument_list|(
name|pos
operator|.
name|intValue
argument_list|()
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
name|selectStar
operator|=
name|selectStar
operator|&&
name|exprList
operator|.
name|getChildCount
argument_list|()
operator|==
name|posn
operator|+
literal|1
expr_stmt|;
name|ArrayList
argument_list|<
name|String
argument_list|>
name|columnNames
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|ExprNodeDesc
argument_list|>
name|colExprMap
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|ExprNodeDesc
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|col_list
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
comment|// Replace NULL with CAST(NULL AS STRING)
if|if
condition|(
name|col_list
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|instanceof
name|ExprNodeNullDesc
condition|)
block|{
name|col_list
operator|.
name|set
argument_list|(
name|i
argument_list|,
operator|new
name|ExprNodeConstantDesc
argument_list|(
name|TypeInfoFactory
operator|.
name|stringTypeInfo
argument_list|,
literal|null
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|String
name|outputCol
init|=
name|getColumnInternalName
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|colExprMap
operator|.
name|put
argument_list|(
name|outputCol
argument_list|,
name|col_list
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|columnNames
operator|.
name|add
argument_list|(
name|outputCol
argument_list|)
expr_stmt|;
block|}
name|Operator
name|output
init|=
name|putOpInsertMap
argument_list|(
name|OperatorFactory
operator|.
name|getAndMakeChild
argument_list|(
operator|new
name|SelectDesc
argument_list|(
name|col_list
argument_list|,
name|columnNames
argument_list|,
name|selectStar
argument_list|)
argument_list|,
operator|new
name|RowSchema
argument_list|(
name|out_rwsch
operator|.
name|getColumnInfos
argument_list|()
argument_list|)
argument_list|,
name|input
argument_list|)
argument_list|,
name|out_rwsch
argument_list|)
decl_stmt|;
name|output
operator|.
name|setColumnExprMap
argument_list|(
name|colExprMap
argument_list|)
expr_stmt|;
if|if
condition|(
name|isInTransform
condition|)
block|{
name|output
operator|=
name|genScriptPlan
argument_list|(
name|trfm
argument_list|,
name|qb
argument_list|,
name|output
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|isUDTF
condition|)
block|{
name|output
operator|=
name|genUDTFPlan
argument_list|(
name|genericUDTF
argument_list|,
name|udtfTableAlias
argument_list|,
name|udtfColAliases
argument_list|,
name|qb
argument_list|,
name|output
argument_list|,
name|outerLV
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Created Select Plan row schema: "
operator|+
name|out_rwsch
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|output
return|;
block|}
specifier|private
name|String
name|recommendName
parameter_list|(
name|ExprNodeDesc
name|exp
parameter_list|,
name|String
name|colAlias
parameter_list|)
block|{
if|if
condition|(
operator|!
name|colAlias
operator|.
name|startsWith
argument_list|(
name|autogenColAliasPrfxLbl
argument_list|)
condition|)
block|{
return|return
literal|null
return|;
block|}
name|String
name|column
init|=
name|ExprNodeDescUtils
operator|.
name|recommendInputName
argument_list|(
name|exp
argument_list|)
decl_stmt|;
if|if
condition|(
name|column
operator|!=
literal|null
operator|&&
operator|!
name|column
operator|.
name|startsWith
argument_list|(
name|autogenColAliasPrfxLbl
argument_list|)
condition|)
block|{
return|return
name|column
return|;
block|}
return|return
literal|null
return|;
block|}
comment|/**    * Class to store GenericUDAF related information.    */
specifier|static
class|class
name|GenericUDAFInfo
block|{
name|ArrayList
argument_list|<
name|ExprNodeDesc
argument_list|>
name|convertedParameters
decl_stmt|;
name|GenericUDAFEvaluator
name|genericUDAFEvaluator
decl_stmt|;
name|TypeInfo
name|returnType
decl_stmt|;
block|}
comment|/**    * Convert exprNodeDesc array to Typeinfo array.    */
specifier|static
name|ArrayList
argument_list|<
name|TypeInfo
argument_list|>
name|getTypeInfo
parameter_list|(
name|ArrayList
argument_list|<
name|ExprNodeDesc
argument_list|>
name|exprs
parameter_list|)
block|{
name|ArrayList
argument_list|<
name|TypeInfo
argument_list|>
name|result
init|=
operator|new
name|ArrayList
argument_list|<
name|TypeInfo
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|ExprNodeDesc
name|expr
range|:
name|exprs
control|)
block|{
name|result
operator|.
name|add
argument_list|(
name|expr
operator|.
name|getTypeInfo
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
comment|/**    * Convert exprNodeDesc array to ObjectInspector array.    */
specifier|static
name|ArrayList
argument_list|<
name|ObjectInspector
argument_list|>
name|getWritableObjectInspector
parameter_list|(
name|ArrayList
argument_list|<
name|ExprNodeDesc
argument_list|>
name|exprs
parameter_list|)
block|{
name|ArrayList
argument_list|<
name|ObjectInspector
argument_list|>
name|result
init|=
operator|new
name|ArrayList
argument_list|<
name|ObjectInspector
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|ExprNodeDesc
name|expr
range|:
name|exprs
control|)
block|{
name|result
operator|.
name|add
argument_list|(
name|expr
operator|.
name|getWritableObjectInspector
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
comment|/**    * Convert exprNodeDesc array to Typeinfo array.    */
specifier|static
name|ObjectInspector
index|[]
name|getStandardObjectInspector
parameter_list|(
name|ArrayList
argument_list|<
name|TypeInfo
argument_list|>
name|exprs
parameter_list|)
block|{
name|ObjectInspector
index|[]
name|result
init|=
operator|new
name|ObjectInspector
index|[
name|exprs
operator|.
name|size
argument_list|()
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|exprs
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|result
index|[
name|i
index|]
operator|=
name|TypeInfoUtils
operator|.
name|getStandardWritableObjectInspectorFromTypeInfo
argument_list|(
name|exprs
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
comment|/**    * Returns the GenericUDAFEvaluator for the aggregation. This is called once    * for each GroupBy aggregation.    */
specifier|static
name|GenericUDAFEvaluator
name|getGenericUDAFEvaluator
parameter_list|(
name|String
name|aggName
parameter_list|,
name|ArrayList
argument_list|<
name|ExprNodeDesc
argument_list|>
name|aggParameters
parameter_list|,
name|ASTNode
name|aggTree
parameter_list|,
name|boolean
name|isDistinct
parameter_list|,
name|boolean
name|isAllColumns
parameter_list|)
throws|throws
name|SemanticException
block|{
name|ArrayList
argument_list|<
name|ObjectInspector
argument_list|>
name|originalParameterTypeInfos
init|=
name|getWritableObjectInspector
argument_list|(
name|aggParameters
argument_list|)
decl_stmt|;
name|GenericUDAFEvaluator
name|result
init|=
name|FunctionRegistry
operator|.
name|getGenericUDAFEvaluator
argument_list|(
name|aggName
argument_list|,
name|originalParameterTypeInfos
argument_list|,
name|isDistinct
argument_list|,
name|isAllColumns
argument_list|)
decl_stmt|;
if|if
condition|(
literal|null
operator|==
name|result
condition|)
block|{
name|String
name|reason
init|=
literal|"Looking for UDAF Evaluator\""
operator|+
name|aggName
operator|+
literal|"\" with parameters "
operator|+
name|originalParameterTypeInfos
decl_stmt|;
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|INVALID_FUNCTION_SIGNATURE
operator|.
name|getMsg
argument_list|(
operator|(
name|ASTNode
operator|)
name|aggTree
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
argument_list|,
name|reason
argument_list|)
argument_list|)
throw|;
block|}
return|return
name|result
return|;
block|}
comment|/**    * Returns the GenericUDAFInfo struct for the aggregation.    *    * @param aggName    *          The name of the UDAF.    * @param aggParameters    *          The exprNodeDesc of the original parameters    * @param aggTree    *          The ASTNode node of the UDAF in the query.    * @return GenericUDAFInfo    * @throws SemanticException    *           when the UDAF is not found or has problems.    */
specifier|static
name|GenericUDAFInfo
name|getGenericUDAFInfo
parameter_list|(
name|GenericUDAFEvaluator
name|evaluator
parameter_list|,
name|GenericUDAFEvaluator
operator|.
name|Mode
name|emode
parameter_list|,
name|ArrayList
argument_list|<
name|ExprNodeDesc
argument_list|>
name|aggParameters
parameter_list|)
throws|throws
name|SemanticException
block|{
name|GenericUDAFInfo
name|r
init|=
operator|new
name|GenericUDAFInfo
argument_list|()
decl_stmt|;
comment|// set r.genericUDAFEvaluator
name|r
operator|.
name|genericUDAFEvaluator
operator|=
name|evaluator
expr_stmt|;
comment|// set r.returnType
name|ObjectInspector
name|returnOI
init|=
literal|null
decl_stmt|;
try|try
block|{
name|ArrayList
argument_list|<
name|ObjectInspector
argument_list|>
name|aggOIs
init|=
name|getWritableObjectInspector
argument_list|(
name|aggParameters
argument_list|)
decl_stmt|;
name|ObjectInspector
index|[]
name|aggOIArray
init|=
operator|new
name|ObjectInspector
index|[
name|aggOIs
operator|.
name|size
argument_list|()
index|]
decl_stmt|;
for|for
control|(
name|int
name|ii
init|=
literal|0
init|;
name|ii
operator|<
name|aggOIs
operator|.
name|size
argument_list|()
condition|;
operator|++
name|ii
control|)
block|{
name|aggOIArray
index|[
name|ii
index|]
operator|=
name|aggOIs
operator|.
name|get
argument_list|(
name|ii
argument_list|)
expr_stmt|;
block|}
name|returnOI
operator|=
name|r
operator|.
name|genericUDAFEvaluator
operator|.
name|init
argument_list|(
name|emode
argument_list|,
name|aggOIArray
argument_list|)
expr_stmt|;
name|r
operator|.
name|returnType
operator|=
name|TypeInfoUtils
operator|.
name|getTypeInfoFromObjectInspector
argument_list|(
name|returnOI
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|HiveException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|e
argument_list|)
throw|;
block|}
comment|// set r.convertedParameters
comment|// TODO: type conversion
name|r
operator|.
name|convertedParameters
operator|=
name|aggParameters
expr_stmt|;
return|return
name|r
return|;
block|}
specifier|private
specifier|static
name|GenericUDAFEvaluator
operator|.
name|Mode
name|groupByDescModeToUDAFMode
parameter_list|(
name|GroupByDesc
operator|.
name|Mode
name|mode
parameter_list|,
name|boolean
name|isDistinct
parameter_list|)
block|{
switch|switch
condition|(
name|mode
condition|)
block|{
case|case
name|COMPLETE
case|:
return|return
name|GenericUDAFEvaluator
operator|.
name|Mode
operator|.
name|COMPLETE
return|;
case|case
name|PARTIAL1
case|:
return|return
name|GenericUDAFEvaluator
operator|.
name|Mode
operator|.
name|PARTIAL1
return|;
case|case
name|PARTIAL2
case|:
return|return
name|GenericUDAFEvaluator
operator|.
name|Mode
operator|.
name|PARTIAL2
return|;
case|case
name|PARTIALS
case|:
return|return
name|isDistinct
condition|?
name|GenericUDAFEvaluator
operator|.
name|Mode
operator|.
name|PARTIAL1
else|:
name|GenericUDAFEvaluator
operator|.
name|Mode
operator|.
name|PARTIAL2
return|;
case|case
name|FINAL
case|:
return|return
name|GenericUDAFEvaluator
operator|.
name|Mode
operator|.
name|FINAL
return|;
case|case
name|HASH
case|:
return|return
name|GenericUDAFEvaluator
operator|.
name|Mode
operator|.
name|PARTIAL1
return|;
case|case
name|MERGEPARTIAL
case|:
return|return
name|isDistinct
condition|?
name|GenericUDAFEvaluator
operator|.
name|Mode
operator|.
name|COMPLETE
else|:
name|GenericUDAFEvaluator
operator|.
name|Mode
operator|.
name|FINAL
return|;
default|default:
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"internal error in groupByDescModeToUDAFMode"
argument_list|)
throw|;
block|}
block|}
comment|/**    * Check if the given internalName represents a constant parameter in aggregation parameters    * of an aggregation tree.    * This method is only invoked when map-side aggregation is not involved. In this case,    * every parameter in every aggregation tree should already have a corresponding ColumnInfo,    * which is generated when the corresponding ReduceSinkOperator of the GroupByOperator being    * generating is generated. If we find that this parameter is a constant parameter,    * we will return the corresponding ExprNodeDesc in reduceValues, and we will not need to    * use a new ExprNodeColumnDesc, which can not be treated as a constant parameter, for this    * parameter (since the writableObjectInspector of a ExprNodeColumnDesc will not be    * a instance of ConstantObjectInspector).    *    * @param reduceValues    *          value columns of the corresponding ReduceSinkOperator    * @param internalName    *          the internal name of this parameter    * @return the ExprNodeDesc of the constant parameter if the given internalName represents    *         a constant parameter; otherwise, return null    */
specifier|private
name|ExprNodeDesc
name|isConstantParameterInAggregationParameters
parameter_list|(
name|String
name|internalName
parameter_list|,
name|List
argument_list|<
name|ExprNodeDesc
argument_list|>
name|reduceValues
parameter_list|)
block|{
comment|// only the pattern of "VALUE._col([0-9]+)" should be handled.
name|String
index|[]
name|terms
init|=
name|internalName
operator|.
name|split
argument_list|(
literal|"\\."
argument_list|)
decl_stmt|;
if|if
condition|(
name|terms
operator|.
name|length
operator|!=
literal|2
operator|||
name|reduceValues
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
if|if
condition|(
name|Utilities
operator|.
name|ReduceField
operator|.
name|VALUE
operator|.
name|toString
argument_list|()
operator|.
name|equals
argument_list|(
name|terms
index|[
literal|0
index|]
argument_list|)
condition|)
block|{
name|int
name|pos
init|=
name|getPositionFromInternalName
argument_list|(
name|terms
index|[
literal|1
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
name|pos
operator|>=
literal|0
operator|&&
name|pos
operator|<
name|reduceValues
operator|.
name|size
argument_list|()
condition|)
block|{
name|ExprNodeDesc
name|reduceValue
init|=
name|reduceValues
operator|.
name|get
argument_list|(
name|pos
argument_list|)
decl_stmt|;
if|if
condition|(
name|reduceValue
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|reduceValue
operator|.
name|getWritableObjectInspector
argument_list|()
operator|instanceof
name|ConstantObjectInspector
condition|)
block|{
comment|// this internalName represents a constant parameter in aggregation parameters
return|return
name|reduceValue
return|;
block|}
block|}
block|}
block|}
return|return
literal|null
return|;
block|}
comment|/**    * Generate the GroupByOperator for the Query Block (parseInfo.getXXX(dest)).    * The new GroupByOperator will be a child of the reduceSinkOperatorInfo.    *    * @param mode    *          The mode of the aggregation (PARTIAL1 or COMPLETE)    * @param genericUDAFEvaluators    *          If not null, this function will store the mapping from Aggregation    *          StringTree to the genericUDAFEvaluator in this parameter, so it    *          can be used in the next-stage GroupBy aggregations.    * @return the new GroupByOperator    */
annotation|@
name|SuppressWarnings
argument_list|(
literal|"nls"
argument_list|)
specifier|private
name|Operator
name|genGroupByPlanGroupByOperator
parameter_list|(
name|QBParseInfo
name|parseInfo
parameter_list|,
name|String
name|dest
parameter_list|,
name|Operator
name|input
parameter_list|,
name|ReduceSinkOperator
name|rs
parameter_list|,
name|GroupByDesc
operator|.
name|Mode
name|mode
parameter_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|GenericUDAFEvaluator
argument_list|>
name|genericUDAFEvaluators
parameter_list|)
throws|throws
name|SemanticException
block|{
name|RowResolver
name|groupByInputRowResolver
init|=
name|opParseCtx
operator|.
name|get
argument_list|(
name|input
argument_list|)
operator|.
name|getRowResolver
argument_list|()
decl_stmt|;
name|RowResolver
name|groupByOutputRowResolver
init|=
operator|new
name|RowResolver
argument_list|()
decl_stmt|;
name|groupByOutputRowResolver
operator|.
name|setIsExprResolver
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|ArrayList
argument_list|<
name|ExprNodeDesc
argument_list|>
name|groupByKeys
init|=
operator|new
name|ArrayList
argument_list|<
name|ExprNodeDesc
argument_list|>
argument_list|()
decl_stmt|;
name|ArrayList
argument_list|<
name|AggregationDesc
argument_list|>
name|aggregations
init|=
operator|new
name|ArrayList
argument_list|<
name|AggregationDesc
argument_list|>
argument_list|()
decl_stmt|;
name|ArrayList
argument_list|<
name|String
argument_list|>
name|outputColumnNames
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|ExprNodeDesc
argument_list|>
name|colExprMap
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|ExprNodeDesc
argument_list|>
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|ASTNode
argument_list|>
name|grpByExprs
init|=
name|getGroupByForClause
argument_list|(
name|parseInfo
argument_list|,
name|dest
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|grpByExprs
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|ASTNode
name|grpbyExpr
init|=
name|grpByExprs
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|ColumnInfo
name|exprInfo
init|=
name|groupByInputRowResolver
operator|.
name|getExpression
argument_list|(
name|grpbyExpr
argument_list|)
decl_stmt|;
if|if
condition|(
name|exprInfo
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|INVALID_COLUMN
operator|.
name|getMsg
argument_list|(
name|grpbyExpr
argument_list|)
argument_list|)
throw|;
block|}
name|groupByKeys
operator|.
name|add
argument_list|(
operator|new
name|ExprNodeColumnDesc
argument_list|(
name|exprInfo
operator|.
name|getType
argument_list|()
argument_list|,
name|exprInfo
operator|.
name|getInternalName
argument_list|()
argument_list|,
literal|""
argument_list|,
literal|false
argument_list|)
argument_list|)
expr_stmt|;
name|String
name|field
init|=
name|getColumnInternalName
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|outputColumnNames
operator|.
name|add
argument_list|(
name|field
argument_list|)
expr_stmt|;
name|ColumnInfo
name|oColInfo
init|=
operator|new
name|ColumnInfo
argument_list|(
name|field
argument_list|,
name|exprInfo
operator|.
name|getType
argument_list|()
argument_list|,
literal|null
argument_list|,
literal|false
argument_list|)
decl_stmt|;
name|groupByOutputRowResolver
operator|.
name|putExpression
argument_list|(
name|grpbyExpr
argument_list|,
name|oColInfo
argument_list|)
expr_stmt|;
name|addAlternateGByKeyMappings
argument_list|(
name|grpbyExpr
argument_list|,
name|oColInfo
argument_list|,
name|input
argument_list|,
name|groupByOutputRowResolver
argument_list|)
expr_stmt|;
name|colExprMap
operator|.
name|put
argument_list|(
name|field
argument_list|,
name|groupByKeys
operator|.
name|get
argument_list|(
name|groupByKeys
operator|.
name|size
argument_list|()
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// For each aggregation
name|HashMap
argument_list|<
name|String
argument_list|,
name|ASTNode
argument_list|>
name|aggregationTrees
init|=
name|parseInfo
operator|.
name|getAggregationExprsForClause
argument_list|(
name|dest
argument_list|)
decl_stmt|;
assert|assert
operator|(
name|aggregationTrees
operator|!=
literal|null
operator|)
assert|;
comment|// get the last colName for the reduce KEY
comment|// it represents the column name corresponding to distinct aggr, if any
name|String
name|lastKeyColName
init|=
literal|null
decl_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|inputKeyCols
init|=
operator|(
operator|(
name|ReduceSinkDesc
operator|)
name|rs
operator|.
name|getConf
argument_list|()
operator|)
operator|.
name|getOutputKeyColumnNames
argument_list|()
decl_stmt|;
if|if
condition|(
name|inputKeyCols
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
name|lastKeyColName
operator|=
name|inputKeyCols
operator|.
name|get
argument_list|(
name|inputKeyCols
operator|.
name|size
argument_list|()
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
name|List
argument_list|<
name|ExprNodeDesc
argument_list|>
name|reduceValues
init|=
operator|(
operator|(
name|ReduceSinkDesc
operator|)
name|rs
operator|.
name|getConf
argument_list|()
operator|)
operator|.
name|getValueCols
argument_list|()
decl_stmt|;
name|int
name|numDistinctUDFs
init|=
literal|0
decl_stmt|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|ASTNode
argument_list|>
name|entry
range|:
name|aggregationTrees
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|ASTNode
name|value
init|=
name|entry
operator|.
name|getValue
argument_list|()
decl_stmt|;
comment|// This is the GenericUDAF name
name|String
name|aggName
init|=
name|unescapeIdentifier
argument_list|(
name|value
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getText
argument_list|()
argument_list|)
decl_stmt|;
name|boolean
name|isDistinct
init|=
name|value
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_FUNCTIONDI
decl_stmt|;
name|boolean
name|isAllColumns
init|=
name|value
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_FUNCTIONSTAR
decl_stmt|;
comment|// Convert children to aggParameters
name|ArrayList
argument_list|<
name|ExprNodeDesc
argument_list|>
name|aggParameters
init|=
operator|new
name|ArrayList
argument_list|<
name|ExprNodeDesc
argument_list|>
argument_list|()
decl_stmt|;
comment|// 0 is the function name
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<
name|value
operator|.
name|getChildCount
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|ASTNode
name|paraExpr
init|=
operator|(
name|ASTNode
operator|)
name|value
operator|.
name|getChild
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|ColumnInfo
name|paraExprInfo
init|=
name|groupByInputRowResolver
operator|.
name|getExpression
argument_list|(
name|paraExpr
argument_list|)
decl_stmt|;
if|if
condition|(
name|paraExprInfo
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|INVALID_COLUMN
operator|.
name|getMsg
argument_list|(
name|paraExpr
argument_list|)
argument_list|)
throw|;
block|}
name|String
name|paraExpression
init|=
name|paraExprInfo
operator|.
name|getInternalName
argument_list|()
decl_stmt|;
assert|assert
operator|(
name|paraExpression
operator|!=
literal|null
operator|)
assert|;
if|if
condition|(
name|isDistinct
operator|&&
name|lastKeyColName
operator|!=
literal|null
condition|)
block|{
comment|// if aggr is distinct, the parameter is name is constructed as
comment|// KEY.lastKeyColName:<tag>._colx
name|paraExpression
operator|=
name|Utilities
operator|.
name|ReduceField
operator|.
name|KEY
operator|.
name|name
argument_list|()
operator|+
literal|"."
operator|+
name|lastKeyColName
operator|+
literal|":"
operator|+
name|numDistinctUDFs
operator|+
literal|"."
operator|+
name|getColumnInternalName
argument_list|(
name|i
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
name|ExprNodeDesc
name|expr
init|=
operator|new
name|ExprNodeColumnDesc
argument_list|(
name|paraExprInfo
operator|.
name|getType
argument_list|()
argument_list|,
name|paraExpression
argument_list|,
name|paraExprInfo
operator|.
name|getTabAlias
argument_list|()
argument_list|,
name|paraExprInfo
operator|.
name|getIsVirtualCol
argument_list|()
argument_list|)
decl_stmt|;
name|ExprNodeDesc
name|reduceValue
init|=
name|isConstantParameterInAggregationParameters
argument_list|(
name|paraExprInfo
operator|.
name|getInternalName
argument_list|()
argument_list|,
name|reduceValues
argument_list|)
decl_stmt|;
if|if
condition|(
name|reduceValue
operator|!=
literal|null
condition|)
block|{
comment|// this parameter is a constant
name|expr
operator|=
name|reduceValue
expr_stmt|;
block|}
name|aggParameters
operator|.
name|add
argument_list|(
name|expr
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|isDistinct
condition|)
block|{
name|numDistinctUDFs
operator|++
expr_stmt|;
block|}
name|Mode
name|amode
init|=
name|groupByDescModeToUDAFMode
argument_list|(
name|mode
argument_list|,
name|isDistinct
argument_list|)
decl_stmt|;
name|GenericUDAFEvaluator
name|genericUDAFEvaluator
init|=
name|getGenericUDAFEvaluator
argument_list|(
name|aggName
argument_list|,
name|aggParameters
argument_list|,
name|value
argument_list|,
name|isDistinct
argument_list|,
name|isAllColumns
argument_list|)
decl_stmt|;
assert|assert
operator|(
name|genericUDAFEvaluator
operator|!=
literal|null
operator|)
assert|;
name|GenericUDAFInfo
name|udaf
init|=
name|getGenericUDAFInfo
argument_list|(
name|genericUDAFEvaluator
argument_list|,
name|amode
argument_list|,
name|aggParameters
argument_list|)
decl_stmt|;
name|aggregations
operator|.
name|add
argument_list|(
operator|new
name|AggregationDesc
argument_list|(
name|aggName
operator|.
name|toLowerCase
argument_list|()
argument_list|,
name|udaf
operator|.
name|genericUDAFEvaluator
argument_list|,
name|udaf
operator|.
name|convertedParameters
argument_list|,
name|isDistinct
argument_list|,
name|amode
argument_list|)
argument_list|)
expr_stmt|;
name|String
name|field
init|=
name|getColumnInternalName
argument_list|(
name|groupByKeys
operator|.
name|size
argument_list|()
operator|+
name|aggregations
operator|.
name|size
argument_list|()
operator|-
literal|1
argument_list|)
decl_stmt|;
name|outputColumnNames
operator|.
name|add
argument_list|(
name|field
argument_list|)
expr_stmt|;
name|groupByOutputRowResolver
operator|.
name|putExpression
argument_list|(
name|value
argument_list|,
operator|new
name|ColumnInfo
argument_list|(
name|field
argument_list|,
name|udaf
operator|.
name|returnType
argument_list|,
literal|""
argument_list|,
literal|false
argument_list|)
argument_list|)
expr_stmt|;
comment|// Save the evaluator so that it can be used by the next-stage
comment|// GroupByOperators
if|if
condition|(
name|genericUDAFEvaluators
operator|!=
literal|null
condition|)
block|{
name|genericUDAFEvaluators
operator|.
name|put
argument_list|(
name|entry
operator|.
name|getKey
argument_list|()
argument_list|,
name|genericUDAFEvaluator
argument_list|)
expr_stmt|;
block|}
block|}
name|float
name|groupByMemoryUsage
init|=
name|HiveConf
operator|.
name|getFloatVar
argument_list|(
name|conf
argument_list|,
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVEMAPAGGRHASHMEMORY
argument_list|)
decl_stmt|;
name|float
name|memoryThreshold
init|=
name|HiveConf
operator|.
name|getFloatVar
argument_list|(
name|conf
argument_list|,
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVEMAPAGGRMEMORYTHRESHOLD
argument_list|)
decl_stmt|;
name|Operator
name|op
init|=
name|putOpInsertMap
argument_list|(
name|OperatorFactory
operator|.
name|getAndMakeChild
argument_list|(
operator|new
name|GroupByDesc
argument_list|(
name|mode
argument_list|,
name|outputColumnNames
argument_list|,
name|groupByKeys
argument_list|,
name|aggregations
argument_list|,
literal|false
argument_list|,
name|groupByMemoryUsage
argument_list|,
name|memoryThreshold
argument_list|,
literal|null
argument_list|,
literal|false
argument_list|,
literal|0
argument_list|,
name|numDistinctUDFs
operator|>
literal|0
argument_list|)
argument_list|,
operator|new
name|RowSchema
argument_list|(
name|groupByOutputRowResolver
operator|.
name|getColumnInfos
argument_list|()
argument_list|)
argument_list|,
name|input
argument_list|)
argument_list|,
name|groupByOutputRowResolver
argument_list|)
decl_stmt|;
name|op
operator|.
name|setColumnExprMap
argument_list|(
name|colExprMap
argument_list|)
expr_stmt|;
return|return
name|op
return|;
block|}
comment|// Add the grouping set key to the group by operator.
comment|// This is not the first group by operator, but it is a subsequent group by operator
comment|// which is forwarding the grouping keys introduced by the grouping sets.
comment|// For eg: consider: select key, value, count(1) from T group by key, value with rollup.
comment|// Assuming map-side aggregation and no skew, the plan would look like:
comment|//
comment|// TableScan --> Select --> GroupBy1 --> ReduceSink --> GroupBy2 --> Select --> FileSink
comment|//
comment|// This function is called for GroupBy2 to pass the additional grouping keys introduced by
comment|// GroupBy1 for the grouping set (corresponding to the rollup).
specifier|private
name|void
name|addGroupingSetKey
parameter_list|(
name|List
argument_list|<
name|ExprNodeDesc
argument_list|>
name|groupByKeys
parameter_list|,
name|RowResolver
name|groupByInputRowResolver
parameter_list|,
name|RowResolver
name|groupByOutputRowResolver
parameter_list|,
name|List
argument_list|<
name|String
argument_list|>
name|outputColumnNames
parameter_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|ExprNodeDesc
argument_list|>
name|colExprMap
parameter_list|)
throws|throws
name|SemanticException
block|{
comment|// For grouping sets, add a dummy grouping key
name|String
name|groupingSetColumnName
init|=
name|groupByInputRowResolver
operator|.
name|get
argument_list|(
literal|null
argument_list|,
name|VirtualColumn
operator|.
name|GROUPINGID
operator|.
name|getName
argument_list|()
argument_list|)
operator|.
name|getInternalName
argument_list|()
decl_stmt|;
name|ExprNodeDesc
name|inputExpr
init|=
operator|new
name|ExprNodeColumnDesc
argument_list|(
name|TypeInfoFactory
operator|.
name|stringTypeInfo
argument_list|,
name|groupingSetColumnName
argument_list|,
literal|null
argument_list|,
literal|false
argument_list|)
decl_stmt|;
name|groupByKeys
operator|.
name|add
argument_list|(
name|inputExpr
argument_list|)
expr_stmt|;
name|String
name|field
init|=
name|getColumnInternalName
argument_list|(
name|groupByKeys
operator|.
name|size
argument_list|()
operator|-
literal|1
argument_list|)
decl_stmt|;
name|outputColumnNames
operator|.
name|add
argument_list|(
name|field
argument_list|)
expr_stmt|;
name|groupByOutputRowResolver
operator|.
name|put
argument_list|(
literal|null
argument_list|,
name|VirtualColumn
operator|.
name|GROUPINGID
operator|.
name|getName
argument_list|()
argument_list|,
operator|new
name|ColumnInfo
argument_list|(
name|field
argument_list|,
name|TypeInfoFactory
operator|.
name|stringTypeInfo
argument_list|,
literal|null
argument_list|,
literal|true
argument_list|)
argument_list|)
expr_stmt|;
name|colExprMap
operator|.
name|put
argument_list|(
name|field
argument_list|,
name|groupByKeys
operator|.
name|get
argument_list|(
name|groupByKeys
operator|.
name|size
argument_list|()
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// Process grouping set for the reduce sink operator
comment|// For eg: consider: select key, value, count(1) from T group by key, value with rollup.
comment|// Assuming map-side aggregation and no skew, the plan would look like:
comment|//
comment|// TableScan --> Select --> GroupBy1 --> ReduceSink --> GroupBy2 --> Select --> FileSink
comment|//
comment|// This function is called for ReduceSink to add the additional grouping keys introduced by
comment|// GroupBy1 into the reduce keys.
specifier|private
name|void
name|processGroupingSetReduceSinkOperator
parameter_list|(
name|RowResolver
name|reduceSinkInputRowResolver
parameter_list|,
name|RowResolver
name|reduceSinkOutputRowResolver
parameter_list|,
name|List
argument_list|<
name|ExprNodeDesc
argument_list|>
name|reduceKeys
parameter_list|,
name|List
argument_list|<
name|String
argument_list|>
name|outputKeyColumnNames
parameter_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|ExprNodeDesc
argument_list|>
name|colExprMap
parameter_list|)
throws|throws
name|SemanticException
block|{
comment|// add a key for reduce sink
name|String
name|groupingSetColumnName
init|=
name|reduceSinkInputRowResolver
operator|.
name|get
argument_list|(
literal|null
argument_list|,
name|VirtualColumn
operator|.
name|GROUPINGID
operator|.
name|getName
argument_list|()
argument_list|)
operator|.
name|getInternalName
argument_list|()
decl_stmt|;
name|ExprNodeDesc
name|inputExpr
init|=
operator|new
name|ExprNodeColumnDesc
argument_list|(
name|TypeInfoFactory
operator|.
name|stringTypeInfo
argument_list|,
name|groupingSetColumnName
argument_list|,
literal|null
argument_list|,
literal|false
argument_list|)
decl_stmt|;
name|reduceKeys
operator|.
name|add
argument_list|(
name|inputExpr
argument_list|)
expr_stmt|;
name|outputKeyColumnNames
operator|.
name|add
argument_list|(
name|getColumnInternalName
argument_list|(
name|reduceKeys
operator|.
name|size
argument_list|()
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|String
name|field
init|=
name|Utilities
operator|.
name|ReduceField
operator|.
name|KEY
operator|.
name|toString
argument_list|()
operator|+
literal|"."
operator|+
name|getColumnInternalName
argument_list|(
name|reduceKeys
operator|.
name|size
argument_list|()
operator|-
literal|1
argument_list|)
decl_stmt|;
name|ColumnInfo
name|colInfo
init|=
operator|new
name|ColumnInfo
argument_list|(
name|field
argument_list|,
name|reduceKeys
operator|.
name|get
argument_list|(
name|reduceKeys
operator|.
name|size
argument_list|()
operator|-
literal|1
argument_list|)
operator|.
name|getTypeInfo
argument_list|()
argument_list|,
literal|null
argument_list|,
literal|true
argument_list|)
decl_stmt|;
name|reduceSinkOutputRowResolver
operator|.
name|put
argument_list|(
literal|null
argument_list|,
name|VirtualColumn
operator|.
name|GROUPINGID
operator|.
name|getName
argument_list|()
argument_list|,
name|colInfo
argument_list|)
expr_stmt|;
name|colExprMap
operator|.
name|put
argument_list|(
name|colInfo
operator|.
name|getInternalName
argument_list|()
argument_list|,
name|inputExpr
argument_list|)
expr_stmt|;
block|}
comment|/**    * Generate the GroupByOperator for the Query Block (parseInfo.getXXX(dest)).    * The new GroupByOperator will be a child of the reduceSinkOperatorInfo.    *    * @param mode    *          The mode of the aggregation (MERGEPARTIAL, PARTIAL2)    * @param genericUDAFEvaluators    *          The mapping from Aggregation StringTree to the    *          genericUDAFEvaluator.    * @param distPartAggr    *          partial aggregation for distincts    * @param groupingSets    *          list of grouping sets    * @param groupingSetsPresent    *          whether grouping sets are present in this query    * @param groupingSetsConsumedCurrentMR    *          whether grouping sets are consumed by this group by    * @return the new GroupByOperator    */
annotation|@
name|SuppressWarnings
argument_list|(
literal|"nls"
argument_list|)
specifier|private
name|Operator
name|genGroupByPlanGroupByOperator1
parameter_list|(
name|QBParseInfo
name|parseInfo
parameter_list|,
name|String
name|dest
parameter_list|,
name|Operator
name|reduceSinkOperatorInfo
parameter_list|,
name|GroupByDesc
operator|.
name|Mode
name|mode
parameter_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|GenericUDAFEvaluator
argument_list|>
name|genericUDAFEvaluators
parameter_list|,
name|boolean
name|distPartAgg
parameter_list|,
name|List
argument_list|<
name|Integer
argument_list|>
name|groupingSets
parameter_list|,
name|boolean
name|groupingSetsPresent
parameter_list|,
name|boolean
name|groupingSetsNeedAdditionalMRJob
parameter_list|)
throws|throws
name|SemanticException
block|{
name|ArrayList
argument_list|<
name|String
argument_list|>
name|outputColumnNames
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
name|RowResolver
name|groupByInputRowResolver
init|=
name|opParseCtx
operator|.
name|get
argument_list|(
name|reduceSinkOperatorInfo
argument_list|)
operator|.
name|getRowResolver
argument_list|()
decl_stmt|;
name|RowResolver
name|groupByOutputRowResolver
init|=
operator|new
name|RowResolver
argument_list|()
decl_stmt|;
name|groupByOutputRowResolver
operator|.
name|setIsExprResolver
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|ArrayList
argument_list|<
name|ExprNodeDesc
argument_list|>
name|groupByKeys
init|=
operator|new
name|ArrayList
argument_list|<
name|ExprNodeDesc
argument_list|>
argument_list|()
decl_stmt|;
name|ArrayList
argument_list|<
name|AggregationDesc
argument_list|>
name|aggregations
init|=
operator|new
name|ArrayList
argument_list|<
name|AggregationDesc
argument_list|>
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|ASTNode
argument_list|>
name|grpByExprs
init|=
name|getGroupByForClause
argument_list|(
name|parseInfo
argument_list|,
name|dest
argument_list|)
decl_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|ExprNodeDesc
argument_list|>
name|colExprMap
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|ExprNodeDesc
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|grpByExprs
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|ASTNode
name|grpbyExpr
init|=
name|grpByExprs
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|ColumnInfo
name|exprInfo
init|=
name|groupByInputRowResolver
operator|.
name|getExpression
argument_list|(
name|grpbyExpr
argument_list|)
decl_stmt|;
if|if
condition|(
name|exprInfo
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|INVALID_COLUMN
operator|.
name|getMsg
argument_list|(
name|grpbyExpr
argument_list|)
argument_list|)
throw|;
block|}
name|groupByKeys
operator|.
name|add
argument_list|(
operator|new
name|ExprNodeColumnDesc
argument_list|(
name|exprInfo
operator|.
name|getType
argument_list|()
argument_list|,
name|exprInfo
operator|.
name|getInternalName
argument_list|()
argument_list|,
name|exprInfo
operator|.
name|getTabAlias
argument_list|()
argument_list|,
name|exprInfo
operator|.
name|getIsVirtualCol
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|String
name|field
init|=
name|getColumnInternalName
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|outputColumnNames
operator|.
name|add
argument_list|(
name|field
argument_list|)
expr_stmt|;
name|ColumnInfo
name|oColInfo
init|=
operator|new
name|ColumnInfo
argument_list|(
name|field
argument_list|,
name|exprInfo
operator|.
name|getType
argument_list|()
argument_list|,
literal|""
argument_list|,
literal|false
argument_list|)
decl_stmt|;
name|groupByOutputRowResolver
operator|.
name|putExpression
argument_list|(
name|grpbyExpr
argument_list|,
name|oColInfo
argument_list|)
expr_stmt|;
name|addAlternateGByKeyMappings
argument_list|(
name|grpbyExpr
argument_list|,
name|oColInfo
argument_list|,
name|reduceSinkOperatorInfo
argument_list|,
name|groupByOutputRowResolver
argument_list|)
expr_stmt|;
name|colExprMap
operator|.
name|put
argument_list|(
name|field
argument_list|,
name|groupByKeys
operator|.
name|get
argument_list|(
name|groupByKeys
operator|.
name|size
argument_list|()
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// This is only needed if a new grouping set key is being created
name|int
name|groupingSetsPosition
init|=
literal|0
decl_stmt|;
comment|// For grouping sets, add a dummy grouping key
if|if
condition|(
name|groupingSetsPresent
condition|)
block|{
comment|// Consider the query: select a,b, count(1) from T group by a,b with cube;
comment|// where it is being executed in a single map-reduce job
comment|// The plan is TableScan -> GroupBy1 -> ReduceSink -> GroupBy2 -> FileSink
comment|// GroupBy1 already added the grouping id as part of the row
comment|// This function is called for GroupBy2 to add grouping id as part of the groupby keys
if|if
condition|(
operator|!
name|groupingSetsNeedAdditionalMRJob
condition|)
block|{
name|addGroupingSetKey
argument_list|(
name|groupByKeys
argument_list|,
name|groupByInputRowResolver
argument_list|,
name|groupByOutputRowResolver
argument_list|,
name|outputColumnNames
argument_list|,
name|colExprMap
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|groupingSetsPosition
operator|=
name|groupByKeys
operator|.
name|size
argument_list|()
expr_stmt|;
comment|// The grouping set has not yet been processed. Create a new grouping key
comment|// Consider the query: select a,b, count(1) from T group by a,b with cube;
comment|// where it is being executed in 2 map-reduce jobs
comment|// The plan for 1st MR is TableScan -> GroupBy1 -> ReduceSink -> GroupBy2 -> FileSink
comment|// GroupBy1/ReduceSink worked as if grouping sets were not present
comment|// This function is called for GroupBy2 to create new rows for grouping sets
comment|// For each input row (a,b), 4 rows are created for the example above:
comment|// (a,b), (a,null), (null, b), (null, null)
name|createNewGroupingKey
argument_list|(
name|groupByKeys
argument_list|,
name|outputColumnNames
argument_list|,
name|groupByOutputRowResolver
argument_list|,
name|colExprMap
argument_list|)
expr_stmt|;
block|}
block|}
name|HashMap
argument_list|<
name|String
argument_list|,
name|ASTNode
argument_list|>
name|aggregationTrees
init|=
name|parseInfo
operator|.
name|getAggregationExprsForClause
argument_list|(
name|dest
argument_list|)
decl_stmt|;
comment|// get the last colName for the reduce KEY
comment|// it represents the column name corresponding to distinct aggr, if any
name|String
name|lastKeyColName
init|=
literal|null
decl_stmt|;
name|List
argument_list|<
name|ExprNodeDesc
argument_list|>
name|reduceValues
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|reduceSinkOperatorInfo
operator|.
name|getConf
argument_list|()
operator|instanceof
name|ReduceSinkDesc
condition|)
block|{
name|List
argument_list|<
name|String
argument_list|>
name|inputKeyCols
init|=
operator|(
operator|(
name|ReduceSinkDesc
operator|)
name|reduceSinkOperatorInfo
operator|.
name|getConf
argument_list|()
operator|)
operator|.
name|getOutputKeyColumnNames
argument_list|()
decl_stmt|;
if|if
condition|(
name|inputKeyCols
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
name|lastKeyColName
operator|=
name|inputKeyCols
operator|.
name|get
argument_list|(
name|inputKeyCols
operator|.
name|size
argument_list|()
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
name|reduceValues
operator|=
operator|(
operator|(
name|ReduceSinkDesc
operator|)
name|reduceSinkOperatorInfo
operator|.
name|getConf
argument_list|()
operator|)
operator|.
name|getValueCols
argument_list|()
expr_stmt|;
block|}
name|int
name|numDistinctUDFs
init|=
literal|0
decl_stmt|;
name|boolean
name|containsDistinctAggr
init|=
literal|false
decl_stmt|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|ASTNode
argument_list|>
name|entry
range|:
name|aggregationTrees
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|ASTNode
name|value
init|=
name|entry
operator|.
name|getValue
argument_list|()
decl_stmt|;
name|String
name|aggName
init|=
name|unescapeIdentifier
argument_list|(
name|value
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getText
argument_list|()
argument_list|)
decl_stmt|;
name|ArrayList
argument_list|<
name|ExprNodeDesc
argument_list|>
name|aggParameters
init|=
operator|new
name|ArrayList
argument_list|<
name|ExprNodeDesc
argument_list|>
argument_list|()
decl_stmt|;
name|boolean
name|isDistinct
init|=
operator|(
name|value
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_FUNCTIONDI
operator|)
decl_stmt|;
name|containsDistinctAggr
operator|=
name|containsDistinctAggr
operator|||
name|isDistinct
expr_stmt|;
comment|// If the function is distinct, partial aggregation has not been done on
comment|// the client side.
comment|// If distPartAgg is set, the client is letting us know that partial
comment|// aggregation has not been done.
comment|// For eg: select a, count(b+c), count(distinct d+e) group by a
comment|// For count(b+c), if partial aggregation has been performed, then we
comment|// directly look for count(b+c).
comment|// Otherwise, we look for b+c.
comment|// For distincts, partial aggregation is never performed on the client
comment|// side, so always look for the parameters: d+e
name|boolean
name|partialAggDone
init|=
operator|!
operator|(
name|distPartAgg
operator|||
name|isDistinct
operator|)
decl_stmt|;
if|if
condition|(
operator|!
name|partialAggDone
condition|)
block|{
comment|// 0 is the function name
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<
name|value
operator|.
name|getChildCount
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|ASTNode
name|paraExpr
init|=
operator|(
name|ASTNode
operator|)
name|value
operator|.
name|getChild
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|ColumnInfo
name|paraExprInfo
init|=
name|groupByInputRowResolver
operator|.
name|getExpression
argument_list|(
name|paraExpr
argument_list|)
decl_stmt|;
if|if
condition|(
name|paraExprInfo
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|INVALID_COLUMN
operator|.
name|getMsg
argument_list|(
name|paraExpr
argument_list|)
argument_list|)
throw|;
block|}
name|String
name|paraExpression
init|=
name|paraExprInfo
operator|.
name|getInternalName
argument_list|()
decl_stmt|;
assert|assert
operator|(
name|paraExpression
operator|!=
literal|null
operator|)
assert|;
if|if
condition|(
name|isDistinct
operator|&&
name|lastKeyColName
operator|!=
literal|null
condition|)
block|{
comment|// if aggr is distinct, the parameter is name is constructed as
comment|// KEY.lastKeyColName:<tag>._colx
name|paraExpression
operator|=
name|Utilities
operator|.
name|ReduceField
operator|.
name|KEY
operator|.
name|name
argument_list|()
operator|+
literal|"."
operator|+
name|lastKeyColName
operator|+
literal|":"
operator|+
name|numDistinctUDFs
operator|+
literal|"."
operator|+
name|getColumnInternalName
argument_list|(
name|i
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
name|ExprNodeDesc
name|expr
init|=
operator|new
name|ExprNodeColumnDesc
argument_list|(
name|paraExprInfo
operator|.
name|getType
argument_list|()
argument_list|,
name|paraExpression
argument_list|,
name|paraExprInfo
operator|.
name|getTabAlias
argument_list|()
argument_list|,
name|paraExprInfo
operator|.
name|getIsVirtualCol
argument_list|()
argument_list|)
decl_stmt|;
name|ExprNodeDesc
name|reduceValue
init|=
name|isConstantParameterInAggregationParameters
argument_list|(
name|paraExprInfo
operator|.
name|getInternalName
argument_list|()
argument_list|,
name|reduceValues
argument_list|)
decl_stmt|;
if|if
condition|(
name|reduceValue
operator|!=
literal|null
condition|)
block|{
comment|// this parameter is a constant
name|expr
operator|=
name|reduceValue
expr_stmt|;
block|}
name|aggParameters
operator|.
name|add
argument_list|(
name|expr
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|ColumnInfo
name|paraExprInfo
init|=
name|groupByInputRowResolver
operator|.
name|getExpression
argument_list|(
name|value
argument_list|)
decl_stmt|;
if|if
condition|(
name|paraExprInfo
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|INVALID_COLUMN
operator|.
name|getMsg
argument_list|(
name|value
argument_list|)
argument_list|)
throw|;
block|}
name|String
name|paraExpression
init|=
name|paraExprInfo
operator|.
name|getInternalName
argument_list|()
decl_stmt|;
assert|assert
operator|(
name|paraExpression
operator|!=
literal|null
operator|)
assert|;
name|aggParameters
operator|.
name|add
argument_list|(
operator|new
name|ExprNodeColumnDesc
argument_list|(
name|paraExprInfo
operator|.
name|getType
argument_list|()
argument_list|,
name|paraExpression
argument_list|,
name|paraExprInfo
operator|.
name|getTabAlias
argument_list|()
argument_list|,
name|paraExprInfo
operator|.
name|getIsVirtualCol
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|isDistinct
condition|)
block|{
name|numDistinctUDFs
operator|++
expr_stmt|;
block|}
name|boolean
name|isAllColumns
init|=
name|value
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_FUNCTIONSTAR
decl_stmt|;
name|Mode
name|amode
init|=
name|groupByDescModeToUDAFMode
argument_list|(
name|mode
argument_list|,
name|isDistinct
argument_list|)
decl_stmt|;
name|GenericUDAFEvaluator
name|genericUDAFEvaluator
init|=
literal|null
decl_stmt|;
comment|// For distincts, partial aggregations have not been done
if|if
condition|(
name|distPartAgg
condition|)
block|{
name|genericUDAFEvaluator
operator|=
name|getGenericUDAFEvaluator
argument_list|(
name|aggName
argument_list|,
name|aggParameters
argument_list|,
name|value
argument_list|,
name|isDistinct
argument_list|,
name|isAllColumns
argument_list|)
expr_stmt|;
assert|assert
operator|(
name|genericUDAFEvaluator
operator|!=
literal|null
operator|)
assert|;
name|genericUDAFEvaluators
operator|.
name|put
argument_list|(
name|entry
operator|.
name|getKey
argument_list|()
argument_list|,
name|genericUDAFEvaluator
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|genericUDAFEvaluator
operator|=
name|genericUDAFEvaluators
operator|.
name|get
argument_list|(
name|entry
operator|.
name|getKey
argument_list|()
argument_list|)
expr_stmt|;
assert|assert
operator|(
name|genericUDAFEvaluator
operator|!=
literal|null
operator|)
assert|;
block|}
name|GenericUDAFInfo
name|udaf
init|=
name|getGenericUDAFInfo
argument_list|(
name|genericUDAFEvaluator
argument_list|,
name|amode
argument_list|,
name|aggParameters
argument_list|)
decl_stmt|;
name|aggregations
operator|.
name|add
argument_list|(
operator|new
name|AggregationDesc
argument_list|(
name|aggName
operator|.
name|toLowerCase
argument_list|()
argument_list|,
name|udaf
operator|.
name|genericUDAFEvaluator
argument_list|,
name|udaf
operator|.
name|convertedParameters
argument_list|,
operator|(
name|mode
operator|!=
name|GroupByDesc
operator|.
name|Mode
operator|.
name|FINAL
operator|&&
name|isDistinct
operator|)
argument_list|,
name|amode
argument_list|)
argument_list|)
expr_stmt|;
name|String
name|field
init|=
name|getColumnInternalName
argument_list|(
name|groupByKeys
operator|.
name|size
argument_list|()
operator|+
name|aggregations
operator|.
name|size
argument_list|()
operator|-
literal|1
argument_list|)
decl_stmt|;
name|outputColumnNames
operator|.
name|add
argument_list|(
name|field
argument_list|)
expr_stmt|;
name|groupByOutputRowResolver
operator|.
name|putExpression
argument_list|(
name|value
argument_list|,
operator|new
name|ColumnInfo
argument_list|(
name|field
argument_list|,
name|udaf
operator|.
name|returnType
argument_list|,
literal|""
argument_list|,
literal|false
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|float
name|groupByMemoryUsage
init|=
name|HiveConf
operator|.
name|getFloatVar
argument_list|(
name|conf
argument_list|,
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVEMAPAGGRHASHMEMORY
argument_list|)
decl_stmt|;
name|float
name|memoryThreshold
init|=
name|HiveConf
operator|.
name|getFloatVar
argument_list|(
name|conf
argument_list|,
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVEMAPAGGRMEMORYTHRESHOLD
argument_list|)
decl_stmt|;
comment|// Nothing special needs to be done for grouping sets if
comment|// this is the final group by operator, and multiple rows corresponding to the
comment|// grouping sets have been generated upstream.
comment|// However, if an addition MR job has been created to handle grouping sets,
comment|// additional rows corresponding to grouping sets need to be created here.
name|Operator
name|op
init|=
name|putOpInsertMap
argument_list|(
name|OperatorFactory
operator|.
name|getAndMakeChild
argument_list|(
operator|new
name|GroupByDesc
argument_list|(
name|mode
argument_list|,
name|outputColumnNames
argument_list|,
name|groupByKeys
argument_list|,
name|aggregations
argument_list|,
name|distPartAgg
argument_list|,
name|groupByMemoryUsage
argument_list|,
name|memoryThreshold
argument_list|,
name|groupingSets
argument_list|,
name|groupingSetsPresent
operator|&&
name|groupingSetsNeedAdditionalMRJob
argument_list|,
name|groupingSetsPosition
argument_list|,
name|containsDistinctAggr
argument_list|)
argument_list|,
operator|new
name|RowSchema
argument_list|(
name|groupByOutputRowResolver
operator|.
name|getColumnInfos
argument_list|()
argument_list|)
argument_list|,
name|reduceSinkOperatorInfo
argument_list|)
argument_list|,
name|groupByOutputRowResolver
argument_list|)
decl_stmt|;
name|op
operator|.
name|setColumnExprMap
argument_list|(
name|colExprMap
argument_list|)
expr_stmt|;
return|return
name|op
return|;
block|}
comment|/*    * Create a new grouping key for grouping id.    * A dummy grouping id. is added. At runtime, the group by operator    * creates 'n' rows per input row, where 'n' is the number of grouping sets.    */
specifier|private
name|void
name|createNewGroupingKey
parameter_list|(
name|List
argument_list|<
name|ExprNodeDesc
argument_list|>
name|groupByKeys
parameter_list|,
name|List
argument_list|<
name|String
argument_list|>
name|outputColumnNames
parameter_list|,
name|RowResolver
name|groupByOutputRowResolver
parameter_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|ExprNodeDesc
argument_list|>
name|colExprMap
parameter_list|)
block|{
comment|// The value for the constant does not matter. It is replaced by the grouping set
comment|// value for the actual implementation
name|ExprNodeConstantDesc
name|constant
init|=
operator|new
name|ExprNodeConstantDesc
argument_list|(
literal|"0"
argument_list|)
decl_stmt|;
name|groupByKeys
operator|.
name|add
argument_list|(
name|constant
argument_list|)
expr_stmt|;
name|String
name|field
init|=
name|getColumnInternalName
argument_list|(
name|groupByKeys
operator|.
name|size
argument_list|()
operator|-
literal|1
argument_list|)
decl_stmt|;
name|outputColumnNames
operator|.
name|add
argument_list|(
name|field
argument_list|)
expr_stmt|;
name|groupByOutputRowResolver
operator|.
name|put
argument_list|(
literal|null
argument_list|,
name|VirtualColumn
operator|.
name|GROUPINGID
operator|.
name|getName
argument_list|()
argument_list|,
operator|new
name|ColumnInfo
argument_list|(
name|field
argument_list|,
name|TypeInfoFactory
operator|.
name|stringTypeInfo
argument_list|,
literal|null
argument_list|,
literal|true
argument_list|)
argument_list|)
expr_stmt|;
name|colExprMap
operator|.
name|put
argument_list|(
name|field
argument_list|,
name|constant
argument_list|)
expr_stmt|;
block|}
comment|/**    * Generate the map-side GroupByOperator for the Query Block    * (qb.getParseInfo().getXXX(dest)). The new GroupByOperator will be a child    * of the inputOperatorInfo.    *    * @param mode    *          The mode of the aggregation (HASH)    * @param genericUDAFEvaluators    *          If not null, this function will store the mapping from Aggregation    *          StringTree to the genericUDAFEvaluator in this parameter, so it    *          can be used in the next-stage GroupBy aggregations.    * @return the new GroupByOperator    */
annotation|@
name|SuppressWarnings
argument_list|(
literal|"nls"
argument_list|)
specifier|private
name|Operator
name|genGroupByPlanMapGroupByOperator
parameter_list|(
name|QB
name|qb
parameter_list|,
name|String
name|dest
parameter_list|,
name|List
argument_list|<
name|ASTNode
argument_list|>
name|grpByExprs
parameter_list|,
name|Operator
name|inputOperatorInfo
parameter_list|,
name|GroupByDesc
operator|.
name|Mode
name|mode
parameter_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|GenericUDAFEvaluator
argument_list|>
name|genericUDAFEvaluators
parameter_list|,
name|List
argument_list|<
name|Integer
argument_list|>
name|groupingSetKeys
parameter_list|,
name|boolean
name|groupingSetsPresent
parameter_list|)
throws|throws
name|SemanticException
block|{
name|RowResolver
name|groupByInputRowResolver
init|=
name|opParseCtx
operator|.
name|get
argument_list|(
name|inputOperatorInfo
argument_list|)
operator|.
name|getRowResolver
argument_list|()
decl_stmt|;
name|QBParseInfo
name|parseInfo
init|=
name|qb
operator|.
name|getParseInfo
argument_list|()
decl_stmt|;
name|RowResolver
name|groupByOutputRowResolver
init|=
operator|new
name|RowResolver
argument_list|()
decl_stmt|;
name|groupByOutputRowResolver
operator|.
name|setIsExprResolver
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|ArrayList
argument_list|<
name|ExprNodeDesc
argument_list|>
name|groupByKeys
init|=
operator|new
name|ArrayList
argument_list|<
name|ExprNodeDesc
argument_list|>
argument_list|()
decl_stmt|;
name|ArrayList
argument_list|<
name|String
argument_list|>
name|outputColumnNames
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
name|ArrayList
argument_list|<
name|AggregationDesc
argument_list|>
name|aggregations
init|=
operator|new
name|ArrayList
argument_list|<
name|AggregationDesc
argument_list|>
argument_list|()
decl_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|ExprNodeDesc
argument_list|>
name|colExprMap
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|ExprNodeDesc
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|grpByExprs
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|ASTNode
name|grpbyExpr
init|=
name|grpByExprs
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|ExprNodeDesc
name|grpByExprNode
init|=
name|genExprNodeDesc
argument_list|(
name|grpbyExpr
argument_list|,
name|groupByInputRowResolver
argument_list|)
decl_stmt|;
name|groupByKeys
operator|.
name|add
argument_list|(
name|grpByExprNode
argument_list|)
expr_stmt|;
name|String
name|field
init|=
name|getColumnInternalName
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|outputColumnNames
operator|.
name|add
argument_list|(
name|field
argument_list|)
expr_stmt|;
name|groupByOutputRowResolver
operator|.
name|putExpression
argument_list|(
name|grpbyExpr
argument_list|,
operator|new
name|ColumnInfo
argument_list|(
name|field
argument_list|,
name|grpByExprNode
operator|.
name|getTypeInfo
argument_list|()
argument_list|,
literal|""
argument_list|,
literal|false
argument_list|)
argument_list|)
expr_stmt|;
name|colExprMap
operator|.
name|put
argument_list|(
name|field
argument_list|,
name|groupByKeys
operator|.
name|get
argument_list|(
name|groupByKeys
operator|.
name|size
argument_list|()
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// The grouping set key is present after the grouping keys, before the distinct keys
name|int
name|groupingSetsPosition
init|=
name|groupByKeys
operator|.
name|size
argument_list|()
decl_stmt|;
comment|// For grouping sets, add a dummy grouping key
comment|// This dummy key needs to be added as a reduce key
comment|// For eg: consider: select key, value, count(1) from T group by key, value with rollup.
comment|// Assuming map-side aggregation and no skew, the plan would look like:
comment|//
comment|// TableScan --> Select --> GroupBy1 --> ReduceSink --> GroupBy2 --> Select --> FileSink
comment|//
comment|// This function is called for GroupBy1 to create an additional grouping key
comment|// for the grouping set (corresponding to the rollup).
if|if
condition|(
name|groupingSetsPresent
condition|)
block|{
name|createNewGroupingKey
argument_list|(
name|groupByKeys
argument_list|,
name|outputColumnNames
argument_list|,
name|groupByOutputRowResolver
argument_list|,
name|colExprMap
argument_list|)
expr_stmt|;
block|}
comment|// If there is a distinctFuncExp, add all parameters to the reduceKeys.
if|if
condition|(
operator|!
name|parseInfo
operator|.
name|getDistinctFuncExprsForClause
argument_list|(
name|dest
argument_list|)
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|List
argument_list|<
name|ASTNode
argument_list|>
name|list
init|=
name|parseInfo
operator|.
name|getDistinctFuncExprsForClause
argument_list|(
name|dest
argument_list|)
decl_stmt|;
for|for
control|(
name|ASTNode
name|value
range|:
name|list
control|)
block|{
comment|// 0 is function name
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<
name|value
operator|.
name|getChildCount
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|ASTNode
name|parameter
init|=
operator|(
name|ASTNode
operator|)
name|value
operator|.
name|getChild
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|groupByOutputRowResolver
operator|.
name|getExpression
argument_list|(
name|parameter
argument_list|)
operator|==
literal|null
condition|)
block|{
name|ExprNodeDesc
name|distExprNode
init|=
name|genExprNodeDesc
argument_list|(
name|parameter
argument_list|,
name|groupByInputRowResolver
argument_list|)
decl_stmt|;
name|groupByKeys
operator|.
name|add
argument_list|(
name|distExprNode
argument_list|)
expr_stmt|;
name|String
name|field
init|=
name|getColumnInternalName
argument_list|(
name|groupByKeys
operator|.
name|size
argument_list|()
operator|-
literal|1
argument_list|)
decl_stmt|;
name|outputColumnNames
operator|.
name|add
argument_list|(
name|field
argument_list|)
expr_stmt|;
name|groupByOutputRowResolver
operator|.
name|putExpression
argument_list|(
name|parameter
argument_list|,
operator|new
name|ColumnInfo
argument_list|(
name|field
argument_list|,
name|distExprNode
operator|.
name|getTypeInfo
argument_list|()
argument_list|,
literal|""
argument_list|,
literal|false
argument_list|)
argument_list|)
expr_stmt|;
name|colExprMap
operator|.
name|put
argument_list|(
name|field
argument_list|,
name|groupByKeys
operator|.
name|get
argument_list|(
name|groupByKeys
operator|.
name|size
argument_list|()
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
comment|// For each aggregation
name|HashMap
argument_list|<
name|String
argument_list|,
name|ASTNode
argument_list|>
name|aggregationTrees
init|=
name|parseInfo
operator|.
name|getAggregationExprsForClause
argument_list|(
name|dest
argument_list|)
decl_stmt|;
assert|assert
operator|(
name|aggregationTrees
operator|!=
literal|null
operator|)
assert|;
name|boolean
name|containsDistinctAggr
init|=
literal|false
decl_stmt|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|ASTNode
argument_list|>
name|entry
range|:
name|aggregationTrees
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|ASTNode
name|value
init|=
name|entry
operator|.
name|getValue
argument_list|()
decl_stmt|;
name|String
name|aggName
init|=
name|unescapeIdentifier
argument_list|(
name|value
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getText
argument_list|()
argument_list|)
decl_stmt|;
name|ArrayList
argument_list|<
name|ExprNodeDesc
argument_list|>
name|aggParameters
init|=
operator|new
name|ArrayList
argument_list|<
name|ExprNodeDesc
argument_list|>
argument_list|()
decl_stmt|;
comment|// 0 is the function name
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<
name|value
operator|.
name|getChildCount
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|ASTNode
name|paraExpr
init|=
operator|(
name|ASTNode
operator|)
name|value
operator|.
name|getChild
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|ExprNodeDesc
name|paraExprNode
init|=
name|genExprNodeDesc
argument_list|(
name|paraExpr
argument_list|,
name|groupByInputRowResolver
argument_list|)
decl_stmt|;
name|aggParameters
operator|.
name|add
argument_list|(
name|paraExprNode
argument_list|)
expr_stmt|;
block|}
name|boolean
name|isDistinct
init|=
name|value
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_FUNCTIONDI
decl_stmt|;
name|containsDistinctAggr
operator|=
name|containsDistinctAggr
operator|||
name|isDistinct
expr_stmt|;
name|boolean
name|isAllColumns
init|=
name|value
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_FUNCTIONSTAR
decl_stmt|;
name|Mode
name|amode
init|=
name|groupByDescModeToUDAFMode
argument_list|(
name|mode
argument_list|,
name|isDistinct
argument_list|)
decl_stmt|;
name|GenericUDAFEvaluator
name|genericUDAFEvaluator
init|=
name|getGenericUDAFEvaluator
argument_list|(
name|aggName
argument_list|,
name|aggParameters
argument_list|,
name|value
argument_list|,
name|isDistinct
argument_list|,
name|isAllColumns
argument_list|)
decl_stmt|;
assert|assert
operator|(
name|genericUDAFEvaluator
operator|!=
literal|null
operator|)
assert|;
name|GenericUDAFInfo
name|udaf
init|=
name|getGenericUDAFInfo
argument_list|(
name|genericUDAFEvaluator
argument_list|,
name|amode
argument_list|,
name|aggParameters
argument_list|)
decl_stmt|;
name|aggregations
operator|.
name|add
argument_list|(
operator|new
name|AggregationDesc
argument_list|(
name|aggName
operator|.
name|toLowerCase
argument_list|()
argument_list|,
name|udaf
operator|.
name|genericUDAFEvaluator
argument_list|,
name|udaf
operator|.
name|convertedParameters
argument_list|,
name|isDistinct
argument_list|,
name|amode
argument_list|)
argument_list|)
expr_stmt|;
name|String
name|field
init|=
name|getColumnInternalName
argument_list|(
name|groupByKeys
operator|.
name|size
argument_list|()
operator|+
name|aggregations
operator|.
name|size
argument_list|()
operator|-
literal|1
argument_list|)
decl_stmt|;
name|outputColumnNames
operator|.
name|add
argument_list|(
name|field
argument_list|)
expr_stmt|;
if|if
condition|(
name|groupByOutputRowResolver
operator|.
name|getExpression
argument_list|(
name|value
argument_list|)
operator|==
literal|null
condition|)
block|{
name|groupByOutputRowResolver
operator|.
name|putExpression
argument_list|(
name|value
argument_list|,
operator|new
name|ColumnInfo
argument_list|(
name|field
argument_list|,
name|udaf
operator|.
name|returnType
argument_list|,
literal|""
argument_list|,
literal|false
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// Save the evaluator so that it can be used by the next-stage
comment|// GroupByOperators
if|if
condition|(
name|genericUDAFEvaluators
operator|!=
literal|null
condition|)
block|{
name|genericUDAFEvaluators
operator|.
name|put
argument_list|(
name|entry
operator|.
name|getKey
argument_list|()
argument_list|,
name|genericUDAFEvaluator
argument_list|)
expr_stmt|;
block|}
block|}
name|float
name|groupByMemoryUsage
init|=
name|HiveConf
operator|.
name|getFloatVar
argument_list|(
name|conf
argument_list|,
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVEMAPAGGRHASHMEMORY
argument_list|)
decl_stmt|;
name|float
name|memoryThreshold
init|=
name|HiveConf
operator|.
name|getFloatVar
argument_list|(
name|conf
argument_list|,
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVEMAPAGGRMEMORYTHRESHOLD
argument_list|)
decl_stmt|;
name|Operator
name|op
init|=
name|putOpInsertMap
argument_list|(
name|OperatorFactory
operator|.
name|getAndMakeChild
argument_list|(
operator|new
name|GroupByDesc
argument_list|(
name|mode
argument_list|,
name|outputColumnNames
argument_list|,
name|groupByKeys
argument_list|,
name|aggregations
argument_list|,
literal|false
argument_list|,
name|groupByMemoryUsage
argument_list|,
name|memoryThreshold
argument_list|,
name|groupingSetKeys
argument_list|,
name|groupingSetsPresent
argument_list|,
name|groupingSetsPosition
argument_list|,
name|containsDistinctAggr
argument_list|)
argument_list|,
operator|new
name|RowSchema
argument_list|(
name|groupByOutputRowResolver
operator|.
name|getColumnInfos
argument_list|()
argument_list|)
argument_list|,
name|inputOperatorInfo
argument_list|)
argument_list|,
name|groupByOutputRowResolver
argument_list|)
decl_stmt|;
name|op
operator|.
name|setColumnExprMap
argument_list|(
name|colExprMap
argument_list|)
expr_stmt|;
return|return
name|op
return|;
block|}
comment|/**    * Generate the ReduceSinkOperator for the Group By Query Block    * (qb.getPartInfo().getXXX(dest)). The new ReduceSinkOperator will be a child    * of inputOperatorInfo.    *    * It will put all Group By keys and the distinct field (if any) in the    * map-reduce sort key, and all other fields in the map-reduce value.    *    * @param numPartitionFields    *          the number of fields for map-reduce partitioning. This is usually    *          the number of fields in the Group By keys.    * @return the new ReduceSinkOperator.    * @throws SemanticException    */
annotation|@
name|SuppressWarnings
argument_list|(
literal|"nls"
argument_list|)
specifier|private
name|ReduceSinkOperator
name|genGroupByPlanReduceSinkOperator
parameter_list|(
name|QB
name|qb
parameter_list|,
name|String
name|dest
parameter_list|,
name|Operator
name|inputOperatorInfo
parameter_list|,
name|List
argument_list|<
name|ASTNode
argument_list|>
name|grpByExprs
parameter_list|,
name|int
name|numPartitionFields
parameter_list|,
name|boolean
name|changeNumPartitionFields
parameter_list|,
name|int
name|numReducers
parameter_list|,
name|boolean
name|mapAggrDone
parameter_list|,
name|boolean
name|groupingSetsPresent
parameter_list|)
throws|throws
name|SemanticException
block|{
name|RowResolver
name|reduceSinkInputRowResolver
init|=
name|opParseCtx
operator|.
name|get
argument_list|(
name|inputOperatorInfo
argument_list|)
operator|.
name|getRowResolver
argument_list|()
decl_stmt|;
name|QBParseInfo
name|parseInfo
init|=
name|qb
operator|.
name|getParseInfo
argument_list|()
decl_stmt|;
name|RowResolver
name|reduceSinkOutputRowResolver
init|=
operator|new
name|RowResolver
argument_list|()
decl_stmt|;
name|reduceSinkOutputRowResolver
operator|.
name|setIsExprResolver
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|ExprNodeDesc
argument_list|>
name|colExprMap
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|ExprNodeDesc
argument_list|>
argument_list|()
decl_stmt|;
comment|// Pre-compute group-by keys and store in reduceKeys
name|List
argument_list|<
name|String
argument_list|>
name|outputKeyColumnNames
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|outputValueColumnNames
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
name|ArrayList
argument_list|<
name|ExprNodeDesc
argument_list|>
name|reduceKeys
init|=
name|getReduceKeysForReduceSink
argument_list|(
name|grpByExprs
argument_list|,
name|dest
argument_list|,
name|reduceSinkInputRowResolver
argument_list|,
name|reduceSinkOutputRowResolver
argument_list|,
name|outputKeyColumnNames
argument_list|,
name|colExprMap
argument_list|)
decl_stmt|;
comment|// add a key for reduce sink
if|if
condition|(
name|groupingSetsPresent
condition|)
block|{
comment|// Process grouping set for the reduce sink operator
name|processGroupingSetReduceSinkOperator
argument_list|(
name|reduceSinkInputRowResolver
argument_list|,
name|reduceSinkOutputRowResolver
argument_list|,
name|reduceKeys
argument_list|,
name|outputKeyColumnNames
argument_list|,
name|colExprMap
argument_list|)
expr_stmt|;
if|if
condition|(
name|changeNumPartitionFields
condition|)
block|{
name|numPartitionFields
operator|++
expr_stmt|;
block|}
block|}
name|List
argument_list|<
name|List
argument_list|<
name|Integer
argument_list|>
argument_list|>
name|distinctColIndices
init|=
name|getDistinctColIndicesForReduceSink
argument_list|(
name|parseInfo
argument_list|,
name|dest
argument_list|,
name|reduceKeys
argument_list|,
name|reduceSinkInputRowResolver
argument_list|,
name|reduceSinkOutputRowResolver
argument_list|,
name|outputKeyColumnNames
argument_list|,
name|colExprMap
argument_list|)
decl_stmt|;
name|ArrayList
argument_list|<
name|ExprNodeDesc
argument_list|>
name|reduceValues
init|=
operator|new
name|ArrayList
argument_list|<
name|ExprNodeDesc
argument_list|>
argument_list|()
decl_stmt|;
name|HashMap
argument_list|<
name|String
argument_list|,
name|ASTNode
argument_list|>
name|aggregationTrees
init|=
name|parseInfo
operator|.
name|getAggregationExprsForClause
argument_list|(
name|dest
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|mapAggrDone
condition|)
block|{
name|getReduceValuesForReduceSinkNoMapAgg
argument_list|(
name|parseInfo
argument_list|,
name|dest
argument_list|,
name|reduceSinkInputRowResolver
argument_list|,
name|reduceSinkOutputRowResolver
argument_list|,
name|outputValueColumnNames
argument_list|,
name|reduceValues
argument_list|,
name|colExprMap
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// Put partial aggregation results in reduceValues
name|int
name|inputField
init|=
name|reduceKeys
operator|.
name|size
argument_list|()
decl_stmt|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|ASTNode
argument_list|>
name|entry
range|:
name|aggregationTrees
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|TypeInfo
name|type
init|=
name|reduceSinkInputRowResolver
operator|.
name|getColumnInfos
argument_list|()
operator|.
name|get
argument_list|(
name|inputField
argument_list|)
operator|.
name|getType
argument_list|()
decl_stmt|;
name|ExprNodeColumnDesc
name|exprDesc
init|=
operator|new
name|ExprNodeColumnDesc
argument_list|(
name|type
argument_list|,
name|getColumnInternalName
argument_list|(
name|inputField
argument_list|)
argument_list|,
literal|""
argument_list|,
literal|false
argument_list|)
decl_stmt|;
name|reduceValues
operator|.
name|add
argument_list|(
name|exprDesc
argument_list|)
expr_stmt|;
name|inputField
operator|++
expr_stmt|;
name|outputValueColumnNames
operator|.
name|add
argument_list|(
name|getColumnInternalName
argument_list|(
name|reduceValues
operator|.
name|size
argument_list|()
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|String
name|field
init|=
name|Utilities
operator|.
name|ReduceField
operator|.
name|VALUE
operator|.
name|toString
argument_list|()
operator|+
literal|"."
operator|+
name|getColumnInternalName
argument_list|(
name|reduceValues
operator|.
name|size
argument_list|()
operator|-
literal|1
argument_list|)
decl_stmt|;
name|reduceSinkOutputRowResolver
operator|.
name|putExpression
argument_list|(
name|entry
operator|.
name|getValue
argument_list|()
argument_list|,
operator|new
name|ColumnInfo
argument_list|(
name|field
argument_list|,
name|type
argument_list|,
literal|null
argument_list|,
literal|false
argument_list|)
argument_list|)
expr_stmt|;
name|colExprMap
operator|.
name|put
argument_list|(
name|field
argument_list|,
name|exprDesc
argument_list|)
expr_stmt|;
block|}
block|}
name|ReduceSinkOperator
name|rsOp
init|=
operator|(
name|ReduceSinkOperator
operator|)
name|putOpInsertMap
argument_list|(
name|OperatorFactory
operator|.
name|getAndMakeChild
argument_list|(
name|PlanUtils
operator|.
name|getReduceSinkDesc
argument_list|(
name|reduceKeys
argument_list|,
name|groupingSetsPresent
condition|?
name|grpByExprs
operator|.
name|size
argument_list|()
operator|+
literal|1
else|:
name|grpByExprs
operator|.
name|size
argument_list|()
argument_list|,
name|reduceValues
argument_list|,
name|distinctColIndices
argument_list|,
name|outputKeyColumnNames
argument_list|,
name|outputValueColumnNames
argument_list|,
literal|true
argument_list|,
operator|-
literal|1
argument_list|,
name|numPartitionFields
argument_list|,
name|numReducers
argument_list|)
argument_list|,
operator|new
name|RowSchema
argument_list|(
name|reduceSinkOutputRowResolver
operator|.
name|getColumnInfos
argument_list|()
argument_list|)
argument_list|,
name|inputOperatorInfo
argument_list|)
argument_list|,
name|reduceSinkOutputRowResolver
argument_list|)
decl_stmt|;
name|rsOp
operator|.
name|setColumnExprMap
argument_list|(
name|colExprMap
argument_list|)
expr_stmt|;
return|return
name|rsOp
return|;
block|}
specifier|private
name|ArrayList
argument_list|<
name|ExprNodeDesc
argument_list|>
name|getReduceKeysForReduceSink
parameter_list|(
name|List
argument_list|<
name|ASTNode
argument_list|>
name|grpByExprs
parameter_list|,
name|String
name|dest
parameter_list|,
name|RowResolver
name|reduceSinkInputRowResolver
parameter_list|,
name|RowResolver
name|reduceSinkOutputRowResolver
parameter_list|,
name|List
argument_list|<
name|String
argument_list|>
name|outputKeyColumnNames
parameter_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|ExprNodeDesc
argument_list|>
name|colExprMap
parameter_list|)
throws|throws
name|SemanticException
block|{
name|ArrayList
argument_list|<
name|ExprNodeDesc
argument_list|>
name|reduceKeys
init|=
operator|new
name|ArrayList
argument_list|<
name|ExprNodeDesc
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|grpByExprs
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|ASTNode
name|grpbyExpr
init|=
name|grpByExprs
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|ExprNodeDesc
name|inputExpr
init|=
name|genExprNodeDesc
argument_list|(
name|grpbyExpr
argument_list|,
name|reduceSinkInputRowResolver
argument_list|)
decl_stmt|;
name|reduceKeys
operator|.
name|add
argument_list|(
name|inputExpr
argument_list|)
expr_stmt|;
if|if
condition|(
name|reduceSinkOutputRowResolver
operator|.
name|getExpression
argument_list|(
name|grpbyExpr
argument_list|)
operator|==
literal|null
condition|)
block|{
name|outputKeyColumnNames
operator|.
name|add
argument_list|(
name|getColumnInternalName
argument_list|(
name|reduceKeys
operator|.
name|size
argument_list|()
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|String
name|field
init|=
name|Utilities
operator|.
name|ReduceField
operator|.
name|KEY
operator|.
name|toString
argument_list|()
operator|+
literal|"."
operator|+
name|getColumnInternalName
argument_list|(
name|reduceKeys
operator|.
name|size
argument_list|()
operator|-
literal|1
argument_list|)
decl_stmt|;
name|ColumnInfo
name|colInfo
init|=
operator|new
name|ColumnInfo
argument_list|(
name|field
argument_list|,
name|reduceKeys
operator|.
name|get
argument_list|(
name|reduceKeys
operator|.
name|size
argument_list|()
operator|-
literal|1
argument_list|)
operator|.
name|getTypeInfo
argument_list|()
argument_list|,
literal|null
argument_list|,
literal|false
argument_list|)
decl_stmt|;
name|reduceSinkOutputRowResolver
operator|.
name|putExpression
argument_list|(
name|grpbyExpr
argument_list|,
name|colInfo
argument_list|)
expr_stmt|;
name|colExprMap
operator|.
name|put
argument_list|(
name|colInfo
operator|.
name|getInternalName
argument_list|()
argument_list|,
name|inputExpr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|DUPLICATE_GROUPBY_KEY
operator|.
name|getMsg
argument_list|(
name|grpbyExpr
argument_list|)
argument_list|)
throw|;
block|}
block|}
return|return
name|reduceKeys
return|;
block|}
specifier|private
name|List
argument_list|<
name|List
argument_list|<
name|Integer
argument_list|>
argument_list|>
name|getDistinctColIndicesForReduceSink
parameter_list|(
name|QBParseInfo
name|parseInfo
parameter_list|,
name|String
name|dest
parameter_list|,
name|List
argument_list|<
name|ExprNodeDesc
argument_list|>
name|reduceKeys
parameter_list|,
name|RowResolver
name|reduceSinkInputRowResolver
parameter_list|,
name|RowResolver
name|reduceSinkOutputRowResolver
parameter_list|,
name|List
argument_list|<
name|String
argument_list|>
name|outputKeyColumnNames
parameter_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|ExprNodeDesc
argument_list|>
name|colExprMap
parameter_list|)
throws|throws
name|SemanticException
block|{
name|List
argument_list|<
name|List
argument_list|<
name|Integer
argument_list|>
argument_list|>
name|distinctColIndices
init|=
operator|new
name|ArrayList
argument_list|<
name|List
argument_list|<
name|Integer
argument_list|>
argument_list|>
argument_list|()
decl_stmt|;
comment|// If there is a distinctFuncExp, add all parameters to the reduceKeys.
if|if
condition|(
operator|!
name|parseInfo
operator|.
name|getDistinctFuncExprsForClause
argument_list|(
name|dest
argument_list|)
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|List
argument_list|<
name|ASTNode
argument_list|>
name|distFuncs
init|=
name|parseInfo
operator|.
name|getDistinctFuncExprsForClause
argument_list|(
name|dest
argument_list|)
decl_stmt|;
name|String
name|colName
init|=
name|getColumnInternalName
argument_list|(
name|reduceKeys
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
name|outputKeyColumnNames
operator|.
name|add
argument_list|(
name|colName
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|distFuncs
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|ASTNode
name|value
init|=
name|distFuncs
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|int
name|numExprs
init|=
literal|0
decl_stmt|;
name|List
argument_list|<
name|Integer
argument_list|>
name|distinctIndices
init|=
operator|new
name|ArrayList
argument_list|<
name|Integer
argument_list|>
argument_list|()
decl_stmt|;
comment|// 0 is function name
for|for
control|(
name|int
name|j
init|=
literal|1
init|;
name|j
operator|<
name|value
operator|.
name|getChildCount
argument_list|()
condition|;
name|j
operator|++
control|)
block|{
name|ASTNode
name|parameter
init|=
operator|(
name|ASTNode
operator|)
name|value
operator|.
name|getChild
argument_list|(
name|j
argument_list|)
decl_stmt|;
name|ExprNodeDesc
name|expr
init|=
name|genExprNodeDesc
argument_list|(
name|parameter
argument_list|,
name|reduceSinkInputRowResolver
argument_list|)
decl_stmt|;
comment|// see if expr is already present in reduceKeys.
comment|// get index of expr in reduceKeys
name|int
name|ri
decl_stmt|;
for|for
control|(
name|ri
operator|=
literal|0
init|;
name|ri
operator|<
name|reduceKeys
operator|.
name|size
argument_list|()
condition|;
name|ri
operator|++
control|)
block|{
if|if
condition|(
name|reduceKeys
operator|.
name|get
argument_list|(
name|ri
argument_list|)
operator|.
name|getExprString
argument_list|()
operator|.
name|equals
argument_list|(
name|expr
operator|.
name|getExprString
argument_list|()
argument_list|)
condition|)
block|{
break|break;
block|}
block|}
comment|// add the expr to reduceKeys if it is not present
if|if
condition|(
name|ri
operator|==
name|reduceKeys
operator|.
name|size
argument_list|()
condition|)
block|{
name|String
name|name
init|=
name|getColumnInternalName
argument_list|(
name|numExprs
argument_list|)
decl_stmt|;
name|String
name|field
init|=
name|Utilities
operator|.
name|ReduceField
operator|.
name|KEY
operator|.
name|toString
argument_list|()
operator|+
literal|"."
operator|+
name|colName
operator|+
literal|":"
operator|+
name|i
operator|+
literal|"."
operator|+
name|name
decl_stmt|;
name|ColumnInfo
name|colInfo
init|=
operator|new
name|ColumnInfo
argument_list|(
name|field
argument_list|,
name|expr
operator|.
name|getTypeInfo
argument_list|()
argument_list|,
literal|null
argument_list|,
literal|false
argument_list|)
decl_stmt|;
name|reduceSinkOutputRowResolver
operator|.
name|putExpression
argument_list|(
name|parameter
argument_list|,
name|colInfo
argument_list|)
expr_stmt|;
name|colExprMap
operator|.
name|put
argument_list|(
name|field
argument_list|,
name|expr
argument_list|)
expr_stmt|;
name|reduceKeys
operator|.
name|add
argument_list|(
name|expr
argument_list|)
expr_stmt|;
block|}
comment|// add the index of expr in reduceKeys to distinctIndices
name|distinctIndices
operator|.
name|add
argument_list|(
name|ri
argument_list|)
expr_stmt|;
name|numExprs
operator|++
expr_stmt|;
block|}
name|distinctColIndices
operator|.
name|add
argument_list|(
name|distinctIndices
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|distinctColIndices
return|;
block|}
specifier|private
name|void
name|getReduceValuesForReduceSinkNoMapAgg
parameter_list|(
name|QBParseInfo
name|parseInfo
parameter_list|,
name|String
name|dest
parameter_list|,
name|RowResolver
name|reduceSinkInputRowResolver
parameter_list|,
name|RowResolver
name|reduceSinkOutputRowResolver
parameter_list|,
name|List
argument_list|<
name|String
argument_list|>
name|outputValueColumnNames
parameter_list|,
name|ArrayList
argument_list|<
name|ExprNodeDesc
argument_list|>
name|reduceValues
parameter_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|ExprNodeDesc
argument_list|>
name|colExprMap
parameter_list|)
throws|throws
name|SemanticException
block|{
name|HashMap
argument_list|<
name|String
argument_list|,
name|ASTNode
argument_list|>
name|aggregationTrees
init|=
name|parseInfo
operator|.
name|getAggregationExprsForClause
argument_list|(
name|dest
argument_list|)
decl_stmt|;
comment|// Put parameters to aggregations in reduceValues
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|ASTNode
argument_list|>
name|entry
range|:
name|aggregationTrees
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|ASTNode
name|value
init|=
name|entry
operator|.
name|getValue
argument_list|()
decl_stmt|;
comment|// 0 is function name
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<
name|value
operator|.
name|getChildCount
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|ASTNode
name|parameter
init|=
operator|(
name|ASTNode
operator|)
name|value
operator|.
name|getChild
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|reduceSinkOutputRowResolver
operator|.
name|getExpression
argument_list|(
name|parameter
argument_list|)
operator|==
literal|null
condition|)
block|{
name|ExprNodeDesc
name|exprDesc
init|=
name|genExprNodeDesc
argument_list|(
name|parameter
argument_list|,
name|reduceSinkInputRowResolver
argument_list|)
decl_stmt|;
name|reduceValues
operator|.
name|add
argument_list|(
name|exprDesc
argument_list|)
expr_stmt|;
name|outputValueColumnNames
operator|.
name|add
argument_list|(
name|getColumnInternalName
argument_list|(
name|reduceValues
operator|.
name|size
argument_list|()
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|String
name|field
init|=
name|Utilities
operator|.
name|ReduceField
operator|.
name|VALUE
operator|.
name|toString
argument_list|()
operator|+
literal|"."
operator|+
name|getColumnInternalName
argument_list|(
name|reduceValues
operator|.
name|size
argument_list|()
operator|-
literal|1
argument_list|)
decl_stmt|;
name|reduceSinkOutputRowResolver
operator|.
name|putExpression
argument_list|(
name|parameter
argument_list|,
operator|new
name|ColumnInfo
argument_list|(
name|field
argument_list|,
name|reduceValues
operator|.
name|get
argument_list|(
name|reduceValues
operator|.
name|size
argument_list|()
operator|-
literal|1
argument_list|)
operator|.
name|getTypeInfo
argument_list|()
argument_list|,
literal|null
argument_list|,
literal|false
argument_list|)
argument_list|)
expr_stmt|;
name|colExprMap
operator|.
name|put
argument_list|(
name|field
argument_list|,
name|exprDesc
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"nls"
argument_list|)
specifier|private
name|ReduceSinkOperator
name|genCommonGroupByPlanReduceSinkOperator
parameter_list|(
name|QB
name|qb
parameter_list|,
name|List
argument_list|<
name|String
argument_list|>
name|dests
parameter_list|,
name|Operator
name|inputOperatorInfo
parameter_list|)
throws|throws
name|SemanticException
block|{
name|RowResolver
name|reduceSinkInputRowResolver
init|=
name|opParseCtx
operator|.
name|get
argument_list|(
name|inputOperatorInfo
argument_list|)
operator|.
name|getRowResolver
argument_list|()
decl_stmt|;
name|QBParseInfo
name|parseInfo
init|=
name|qb
operator|.
name|getParseInfo
argument_list|()
decl_stmt|;
name|RowResolver
name|reduceSinkOutputRowResolver
init|=
operator|new
name|RowResolver
argument_list|()
decl_stmt|;
name|reduceSinkOutputRowResolver
operator|.
name|setIsExprResolver
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|ExprNodeDesc
argument_list|>
name|colExprMap
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|ExprNodeDesc
argument_list|>
argument_list|()
decl_stmt|;
comment|// The group by keys and distinct keys should be the same for all dests, so using the first
comment|// one to produce these will be the same as using any other.
name|String
name|dest
init|=
name|dests
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
comment|// Pre-compute group-by keys and store in reduceKeys
name|List
argument_list|<
name|String
argument_list|>
name|outputKeyColumnNames
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|outputValueColumnNames
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|ASTNode
argument_list|>
name|grpByExprs
init|=
name|getGroupByForClause
argument_list|(
name|parseInfo
argument_list|,
name|dest
argument_list|)
decl_stmt|;
name|ArrayList
argument_list|<
name|ExprNodeDesc
argument_list|>
name|reduceKeys
init|=
name|getReduceKeysForReduceSink
argument_list|(
name|grpByExprs
argument_list|,
name|dest
argument_list|,
name|reduceSinkInputRowResolver
argument_list|,
name|reduceSinkOutputRowResolver
argument_list|,
name|outputKeyColumnNames
argument_list|,
name|colExprMap
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|List
argument_list|<
name|Integer
argument_list|>
argument_list|>
name|distinctColIndices
init|=
name|getDistinctColIndicesForReduceSink
argument_list|(
name|parseInfo
argument_list|,
name|dest
argument_list|,
name|reduceKeys
argument_list|,
name|reduceSinkInputRowResolver
argument_list|,
name|reduceSinkOutputRowResolver
argument_list|,
name|outputKeyColumnNames
argument_list|,
name|colExprMap
argument_list|)
decl_stmt|;
name|ArrayList
argument_list|<
name|ExprNodeDesc
argument_list|>
name|reduceValues
init|=
operator|new
name|ArrayList
argument_list|<
name|ExprNodeDesc
argument_list|>
argument_list|()
decl_stmt|;
comment|// The dests can have different non-distinct aggregations, so we have to iterate over all of
comment|// them
for|for
control|(
name|String
name|destination
range|:
name|dests
control|)
block|{
name|getReduceValuesForReduceSinkNoMapAgg
argument_list|(
name|parseInfo
argument_list|,
name|destination
argument_list|,
name|reduceSinkInputRowResolver
argument_list|,
name|reduceSinkOutputRowResolver
argument_list|,
name|outputValueColumnNames
argument_list|,
name|reduceValues
argument_list|,
name|colExprMap
argument_list|)
expr_stmt|;
comment|// Need to pass all of the columns used in the where clauses as reduce values
name|ASTNode
name|whereClause
init|=
name|parseInfo
operator|.
name|getWhrForClause
argument_list|(
name|destination
argument_list|)
decl_stmt|;
if|if
condition|(
name|whereClause
operator|!=
literal|null
condition|)
block|{
assert|assert
name|whereClause
operator|.
name|getChildCount
argument_list|()
operator|==
literal|1
assert|;
name|ASTNode
name|predicates
init|=
operator|(
name|ASTNode
operator|)
name|whereClause
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|Map
argument_list|<
name|ASTNode
argument_list|,
name|ExprNodeDesc
argument_list|>
name|nodeOutputs
init|=
name|genAllExprNodeDesc
argument_list|(
name|predicates
argument_list|,
name|reduceSinkInputRowResolver
argument_list|)
decl_stmt|;
name|removeMappingForKeys
argument_list|(
name|predicates
argument_list|,
name|nodeOutputs
argument_list|,
name|reduceKeys
argument_list|)
expr_stmt|;
comment|// extract columns missing in current RS key/value
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|ASTNode
argument_list|,
name|ExprNodeDesc
argument_list|>
name|entry
range|:
name|nodeOutputs
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|ASTNode
name|parameter
init|=
operator|(
name|ASTNode
operator|)
name|entry
operator|.
name|getKey
argument_list|()
decl_stmt|;
name|ExprNodeDesc
name|expression
init|=
operator|(
name|ExprNodeDesc
operator|)
name|entry
operator|.
name|getValue
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|expression
operator|instanceof
name|ExprNodeColumnDesc
operator|)
condition|)
block|{
continue|continue;
block|}
if|if
condition|(
name|ExprNodeDescUtils
operator|.
name|indexOf
argument_list|(
name|expression
argument_list|,
name|reduceValues
argument_list|)
operator|>=
literal|0
condition|)
block|{
continue|continue;
block|}
name|String
name|internalName
init|=
name|getColumnInternalName
argument_list|(
name|reduceValues
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
name|String
name|field
init|=
name|Utilities
operator|.
name|ReduceField
operator|.
name|VALUE
operator|.
name|toString
argument_list|()
operator|+
literal|"."
operator|+
name|internalName
decl_stmt|;
name|reduceValues
operator|.
name|add
argument_list|(
name|expression
argument_list|)
expr_stmt|;
name|outputValueColumnNames
operator|.
name|add
argument_list|(
name|internalName
argument_list|)
expr_stmt|;
name|reduceSinkOutputRowResolver
operator|.
name|putExpression
argument_list|(
name|parameter
argument_list|,
operator|new
name|ColumnInfo
argument_list|(
name|field
argument_list|,
name|expression
operator|.
name|getTypeInfo
argument_list|()
argument_list|,
literal|null
argument_list|,
literal|false
argument_list|)
argument_list|)
expr_stmt|;
name|colExprMap
operator|.
name|put
argument_list|(
name|field
argument_list|,
name|expression
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|ReduceSinkOperator
name|rsOp
init|=
operator|(
name|ReduceSinkOperator
operator|)
name|putOpInsertMap
argument_list|(
name|OperatorFactory
operator|.
name|getAndMakeChild
argument_list|(
name|PlanUtils
operator|.
name|getReduceSinkDesc
argument_list|(
name|reduceKeys
argument_list|,
name|grpByExprs
operator|.
name|size
argument_list|()
argument_list|,
name|reduceValues
argument_list|,
name|distinctColIndices
argument_list|,
name|outputKeyColumnNames
argument_list|,
name|outputValueColumnNames
argument_list|,
literal|true
argument_list|,
operator|-
literal|1
argument_list|,
name|grpByExprs
operator|.
name|size
argument_list|()
argument_list|,
operator|-
literal|1
argument_list|)
argument_list|,
operator|new
name|RowSchema
argument_list|(
name|reduceSinkOutputRowResolver
operator|.
name|getColumnInfos
argument_list|()
argument_list|)
argument_list|,
name|inputOperatorInfo
argument_list|)
argument_list|,
name|reduceSinkOutputRowResolver
argument_list|)
decl_stmt|;
name|rsOp
operator|.
name|setColumnExprMap
argument_list|(
name|colExprMap
argument_list|)
expr_stmt|;
return|return
name|rsOp
return|;
block|}
comment|// Remove expression node descriptor and children of it for a given predicate
comment|// from mapping if it's already on RS keys.
comment|// Remaining column expressions would be a candidate for an RS value
specifier|private
name|void
name|removeMappingForKeys
parameter_list|(
name|ASTNode
name|predicate
parameter_list|,
name|Map
argument_list|<
name|ASTNode
argument_list|,
name|ExprNodeDesc
argument_list|>
name|mapping
parameter_list|,
name|List
argument_list|<
name|ExprNodeDesc
argument_list|>
name|keys
parameter_list|)
block|{
name|ExprNodeDesc
name|expr
init|=
operator|(
name|ExprNodeDesc
operator|)
name|mapping
operator|.
name|get
argument_list|(
name|predicate
argument_list|)
decl_stmt|;
if|if
condition|(
name|expr
operator|!=
literal|null
operator|&&
name|ExprNodeDescUtils
operator|.
name|indexOf
argument_list|(
name|expr
argument_list|,
name|keys
argument_list|)
operator|>=
literal|0
condition|)
block|{
name|removeRecursively
argument_list|(
name|predicate
argument_list|,
name|mapping
argument_list|)
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|predicate
operator|.
name|getChildCount
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|removeMappingForKeys
argument_list|(
operator|(
name|ASTNode
operator|)
name|predicate
operator|.
name|getChild
argument_list|(
name|i
argument_list|)
argument_list|,
name|mapping
argument_list|,
name|keys
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|// Remove expression node desc and all children of it from mapping
specifier|private
name|void
name|removeRecursively
parameter_list|(
name|ASTNode
name|current
parameter_list|,
name|Map
argument_list|<
name|ASTNode
argument_list|,
name|ExprNodeDesc
argument_list|>
name|mapping
parameter_list|)
block|{
name|mapping
operator|.
name|remove
argument_list|(
name|current
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|current
operator|.
name|getChildCount
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|removeRecursively
argument_list|(
operator|(
name|ASTNode
operator|)
name|current
operator|.
name|getChild
argument_list|(
name|i
argument_list|)
argument_list|,
name|mapping
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Generate the second ReduceSinkOperator for the Group By Plan    * (parseInfo.getXXX(dest)). The new ReduceSinkOperator will be a child of    * groupByOperatorInfo.    *    * The second ReduceSinkOperator will put the group by keys in the map-reduce    * sort key, and put the partial aggregation results in the map-reduce value.    *    * @param numPartitionFields    *          the number of fields in the map-reduce partition key. This should    *          always be the same as the number of Group By keys. We should be    *          able to remove this parameter since in this phase there is no    *          distinct any more.    * @return the new ReduceSinkOperator.    * @throws SemanticException    */
annotation|@
name|SuppressWarnings
argument_list|(
literal|"nls"
argument_list|)
specifier|private
name|Operator
name|genGroupByPlanReduceSinkOperator2MR
parameter_list|(
name|QBParseInfo
name|parseInfo
parameter_list|,
name|String
name|dest
parameter_list|,
name|Operator
name|groupByOperatorInfo
parameter_list|,
name|int
name|numPartitionFields
parameter_list|,
name|int
name|numReducers
parameter_list|,
name|boolean
name|groupingSetsPresent
parameter_list|)
throws|throws
name|SemanticException
block|{
name|RowResolver
name|reduceSinkInputRowResolver2
init|=
name|opParseCtx
operator|.
name|get
argument_list|(
name|groupByOperatorInfo
argument_list|)
operator|.
name|getRowResolver
argument_list|()
decl_stmt|;
name|RowResolver
name|reduceSinkOutputRowResolver2
init|=
operator|new
name|RowResolver
argument_list|()
decl_stmt|;
name|reduceSinkOutputRowResolver2
operator|.
name|setIsExprResolver
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|ExprNodeDesc
argument_list|>
name|colExprMap
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|ExprNodeDesc
argument_list|>
argument_list|()
decl_stmt|;
name|ArrayList
argument_list|<
name|ExprNodeDesc
argument_list|>
name|reduceKeys
init|=
operator|new
name|ArrayList
argument_list|<
name|ExprNodeDesc
argument_list|>
argument_list|()
decl_stmt|;
name|ArrayList
argument_list|<
name|String
argument_list|>
name|outputColumnNames
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
comment|// Get group-by keys and store in reduceKeys
name|List
argument_list|<
name|ASTNode
argument_list|>
name|grpByExprs
init|=
name|getGroupByForClause
argument_list|(
name|parseInfo
argument_list|,
name|dest
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|grpByExprs
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|ASTNode
name|grpbyExpr
init|=
name|grpByExprs
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|String
name|field
init|=
name|getColumnInternalName
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|outputColumnNames
operator|.
name|add
argument_list|(
name|field
argument_list|)
expr_stmt|;
name|TypeInfo
name|typeInfo
init|=
name|reduceSinkInputRowResolver2
operator|.
name|getExpression
argument_list|(
name|grpbyExpr
argument_list|)
operator|.
name|getType
argument_list|()
decl_stmt|;
name|ExprNodeColumnDesc
name|inputExpr
init|=
operator|new
name|ExprNodeColumnDesc
argument_list|(
name|typeInfo
argument_list|,
name|field
argument_list|,
literal|""
argument_list|,
literal|false
argument_list|)
decl_stmt|;
name|reduceKeys
operator|.
name|add
argument_list|(
name|inputExpr
argument_list|)
expr_stmt|;
name|ColumnInfo
name|colInfo
init|=
operator|new
name|ColumnInfo
argument_list|(
name|Utilities
operator|.
name|ReduceField
operator|.
name|KEY
operator|.
name|toString
argument_list|()
operator|+
literal|"."
operator|+
name|field
argument_list|,
name|typeInfo
argument_list|,
literal|""
argument_list|,
literal|false
argument_list|)
decl_stmt|;
name|reduceSinkOutputRowResolver2
operator|.
name|putExpression
argument_list|(
name|grpbyExpr
argument_list|,
name|colInfo
argument_list|)
expr_stmt|;
name|colExprMap
operator|.
name|put
argument_list|(
name|colInfo
operator|.
name|getInternalName
argument_list|()
argument_list|,
name|inputExpr
argument_list|)
expr_stmt|;
block|}
comment|// add a key for reduce sink
if|if
condition|(
name|groupingSetsPresent
condition|)
block|{
comment|// Note that partitioning fields dont need to change, since it is either
comment|// partitioned randomly, or by all grouping keys + distinct keys
name|processGroupingSetReduceSinkOperator
argument_list|(
name|reduceSinkInputRowResolver2
argument_list|,
name|reduceSinkOutputRowResolver2
argument_list|,
name|reduceKeys
argument_list|,
name|outputColumnNames
argument_list|,
name|colExprMap
argument_list|)
expr_stmt|;
block|}
comment|// Get partial aggregation results and store in reduceValues
name|ArrayList
argument_list|<
name|ExprNodeDesc
argument_list|>
name|reduceValues
init|=
operator|new
name|ArrayList
argument_list|<
name|ExprNodeDesc
argument_list|>
argument_list|()
decl_stmt|;
name|int
name|inputField
init|=
name|reduceKeys
operator|.
name|size
argument_list|()
decl_stmt|;
name|HashMap
argument_list|<
name|String
argument_list|,
name|ASTNode
argument_list|>
name|aggregationTrees
init|=
name|parseInfo
operator|.
name|getAggregationExprsForClause
argument_list|(
name|dest
argument_list|)
decl_stmt|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|ASTNode
argument_list|>
name|entry
range|:
name|aggregationTrees
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|String
name|field
init|=
name|getColumnInternalName
argument_list|(
name|inputField
argument_list|)
decl_stmt|;
name|ASTNode
name|t
init|=
name|entry
operator|.
name|getValue
argument_list|()
decl_stmt|;
name|TypeInfo
name|typeInfo
init|=
name|reduceSinkInputRowResolver2
operator|.
name|getExpression
argument_list|(
name|t
argument_list|)
operator|.
name|getType
argument_list|()
decl_stmt|;
name|ExprNodeColumnDesc
name|exprDesc
init|=
operator|new
name|ExprNodeColumnDesc
argument_list|(
name|typeInfo
argument_list|,
name|field
argument_list|,
literal|""
argument_list|,
literal|false
argument_list|)
decl_stmt|;
name|reduceValues
operator|.
name|add
argument_list|(
name|exprDesc
argument_list|)
expr_stmt|;
name|inputField
operator|++
expr_stmt|;
name|String
name|col
init|=
name|getColumnInternalName
argument_list|(
name|reduceValues
operator|.
name|size
argument_list|()
operator|-
literal|1
argument_list|)
decl_stmt|;
name|outputColumnNames
operator|.
name|add
argument_list|(
name|col
argument_list|)
expr_stmt|;
name|reduceSinkOutputRowResolver2
operator|.
name|putExpression
argument_list|(
name|t
argument_list|,
operator|new
name|ColumnInfo
argument_list|(
name|Utilities
operator|.
name|ReduceField
operator|.
name|VALUE
operator|.
name|toString
argument_list|()
operator|+
literal|"."
operator|+
name|col
argument_list|,
name|typeInfo
argument_list|,
literal|""
argument_list|,
literal|false
argument_list|)
argument_list|)
expr_stmt|;
name|colExprMap
operator|.
name|put
argument_list|(
name|col
argument_list|,
name|exprDesc
argument_list|)
expr_stmt|;
block|}
name|ReduceSinkOperator
name|rsOp
init|=
operator|(
name|ReduceSinkOperator
operator|)
name|putOpInsertMap
argument_list|(
name|OperatorFactory
operator|.
name|getAndMakeChild
argument_list|(
name|PlanUtils
operator|.
name|getReduceSinkDesc
argument_list|(
name|reduceKeys
argument_list|,
name|reduceValues
argument_list|,
name|outputColumnNames
argument_list|,
literal|true
argument_list|,
operator|-
literal|1
argument_list|,
name|numPartitionFields
argument_list|,
name|numReducers
argument_list|)
argument_list|,
operator|new
name|RowSchema
argument_list|(
name|reduceSinkOutputRowResolver2
operator|.
name|getColumnInfos
argument_list|()
argument_list|)
argument_list|,
name|groupByOperatorInfo
argument_list|)
argument_list|,
name|reduceSinkOutputRowResolver2
argument_list|)
decl_stmt|;
name|rsOp
operator|.
name|setColumnExprMap
argument_list|(
name|colExprMap
argument_list|)
expr_stmt|;
return|return
name|rsOp
return|;
block|}
comment|/**    * Generate the second GroupByOperator for the Group By Plan    * (parseInfo.getXXX(dest)). The new GroupByOperator will do the second    * aggregation based on the partial aggregation results.    *    * @param mode    *          the mode of aggregation (FINAL)    * @param genericUDAFEvaluators    *          The mapping from Aggregation StringTree to the    *          genericUDAFEvaluator.    * @return the new GroupByOperator    * @throws SemanticException    */
annotation|@
name|SuppressWarnings
argument_list|(
literal|"nls"
argument_list|)
specifier|private
name|Operator
name|genGroupByPlanGroupByOperator2MR
parameter_list|(
name|QBParseInfo
name|parseInfo
parameter_list|,
name|String
name|dest
parameter_list|,
name|Operator
name|reduceSinkOperatorInfo2
parameter_list|,
name|GroupByDesc
operator|.
name|Mode
name|mode
parameter_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|GenericUDAFEvaluator
argument_list|>
name|genericUDAFEvaluators
parameter_list|,
name|boolean
name|groupingSetsPresent
parameter_list|)
throws|throws
name|SemanticException
block|{
name|RowResolver
name|groupByInputRowResolver2
init|=
name|opParseCtx
operator|.
name|get
argument_list|(
name|reduceSinkOperatorInfo2
argument_list|)
operator|.
name|getRowResolver
argument_list|()
decl_stmt|;
name|RowResolver
name|groupByOutputRowResolver2
init|=
operator|new
name|RowResolver
argument_list|()
decl_stmt|;
name|groupByOutputRowResolver2
operator|.
name|setIsExprResolver
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|ArrayList
argument_list|<
name|ExprNodeDesc
argument_list|>
name|groupByKeys
init|=
operator|new
name|ArrayList
argument_list|<
name|ExprNodeDesc
argument_list|>
argument_list|()
decl_stmt|;
name|ArrayList
argument_list|<
name|AggregationDesc
argument_list|>
name|aggregations
init|=
operator|new
name|ArrayList
argument_list|<
name|AggregationDesc
argument_list|>
argument_list|()
decl_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|ExprNodeDesc
argument_list|>
name|colExprMap
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|ExprNodeDesc
argument_list|>
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|ASTNode
argument_list|>
name|grpByExprs
init|=
name|getGroupByForClause
argument_list|(
name|parseInfo
argument_list|,
name|dest
argument_list|)
decl_stmt|;
name|ArrayList
argument_list|<
name|String
argument_list|>
name|outputColumnNames
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|grpByExprs
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|ASTNode
name|grpbyExpr
init|=
name|grpByExprs
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|ColumnInfo
name|exprInfo
init|=
name|groupByInputRowResolver2
operator|.
name|getExpression
argument_list|(
name|grpbyExpr
argument_list|)
decl_stmt|;
if|if
condition|(
name|exprInfo
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|INVALID_COLUMN
operator|.
name|getMsg
argument_list|(
name|grpbyExpr
argument_list|)
argument_list|)
throw|;
block|}
name|String
name|expression
init|=
name|exprInfo
operator|.
name|getInternalName
argument_list|()
decl_stmt|;
name|groupByKeys
operator|.
name|add
argument_list|(
operator|new
name|ExprNodeColumnDesc
argument_list|(
name|exprInfo
operator|.
name|getType
argument_list|()
argument_list|,
name|expression
argument_list|,
name|exprInfo
operator|.
name|getTabAlias
argument_list|()
argument_list|,
name|exprInfo
operator|.
name|getIsVirtualCol
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|String
name|field
init|=
name|getColumnInternalName
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|outputColumnNames
operator|.
name|add
argument_list|(
name|field
argument_list|)
expr_stmt|;
name|ColumnInfo
name|oColInfo
init|=
operator|new
name|ColumnInfo
argument_list|(
name|field
argument_list|,
name|exprInfo
operator|.
name|getType
argument_list|()
argument_list|,
literal|""
argument_list|,
literal|false
argument_list|)
decl_stmt|;
name|groupByOutputRowResolver2
operator|.
name|putExpression
argument_list|(
name|grpbyExpr
argument_list|,
name|oColInfo
argument_list|)
expr_stmt|;
name|addAlternateGByKeyMappings
argument_list|(
name|grpbyExpr
argument_list|,
name|oColInfo
argument_list|,
name|reduceSinkOperatorInfo2
argument_list|,
name|groupByOutputRowResolver2
argument_list|)
expr_stmt|;
name|colExprMap
operator|.
name|put
argument_list|(
name|field
argument_list|,
name|groupByKeys
operator|.
name|get
argument_list|(
name|groupByKeys
operator|.
name|size
argument_list|()
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// For grouping sets, add a dummy grouping key
if|if
condition|(
name|groupingSetsPresent
condition|)
block|{
name|addGroupingSetKey
argument_list|(
name|groupByKeys
argument_list|,
name|groupByInputRowResolver2
argument_list|,
name|groupByOutputRowResolver2
argument_list|,
name|outputColumnNames
argument_list|,
name|colExprMap
argument_list|)
expr_stmt|;
block|}
name|HashMap
argument_list|<
name|String
argument_list|,
name|ASTNode
argument_list|>
name|aggregationTrees
init|=
name|parseInfo
operator|.
name|getAggregationExprsForClause
argument_list|(
name|dest
argument_list|)
decl_stmt|;
name|boolean
name|containsDistinctAggr
init|=
literal|false
decl_stmt|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|ASTNode
argument_list|>
name|entry
range|:
name|aggregationTrees
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|ArrayList
argument_list|<
name|ExprNodeDesc
argument_list|>
name|aggParameters
init|=
operator|new
name|ArrayList
argument_list|<
name|ExprNodeDesc
argument_list|>
argument_list|()
decl_stmt|;
name|ASTNode
name|value
init|=
name|entry
operator|.
name|getValue
argument_list|()
decl_stmt|;
name|ColumnInfo
name|paraExprInfo
init|=
name|groupByInputRowResolver2
operator|.
name|getExpression
argument_list|(
name|value
argument_list|)
decl_stmt|;
if|if
condition|(
name|paraExprInfo
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|INVALID_COLUMN
operator|.
name|getMsg
argument_list|(
name|value
argument_list|)
argument_list|)
throw|;
block|}
name|String
name|paraExpression
init|=
name|paraExprInfo
operator|.
name|getInternalName
argument_list|()
decl_stmt|;
assert|assert
operator|(
name|paraExpression
operator|!=
literal|null
operator|)
assert|;
name|aggParameters
operator|.
name|add
argument_list|(
operator|new
name|ExprNodeColumnDesc
argument_list|(
name|paraExprInfo
operator|.
name|getType
argument_list|()
argument_list|,
name|paraExpression
argument_list|,
name|paraExprInfo
operator|.
name|getTabAlias
argument_list|()
argument_list|,
name|paraExprInfo
operator|.
name|getIsVirtualCol
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|String
name|aggName
init|=
name|unescapeIdentifier
argument_list|(
name|value
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getText
argument_list|()
argument_list|)
decl_stmt|;
name|boolean
name|isDistinct
init|=
name|value
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_FUNCTIONDI
decl_stmt|;
name|containsDistinctAggr
operator|=
name|containsDistinctAggr
operator|||
name|isDistinct
expr_stmt|;
name|boolean
name|isStar
init|=
name|value
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_FUNCTIONSTAR
decl_stmt|;
name|Mode
name|amode
init|=
name|groupByDescModeToUDAFMode
argument_list|(
name|mode
argument_list|,
name|isDistinct
argument_list|)
decl_stmt|;
name|GenericUDAFEvaluator
name|genericUDAFEvaluator
init|=
name|genericUDAFEvaluators
operator|.
name|get
argument_list|(
name|entry
operator|.
name|getKey
argument_list|()
argument_list|)
decl_stmt|;
assert|assert
operator|(
name|genericUDAFEvaluator
operator|!=
literal|null
operator|)
assert|;
name|GenericUDAFInfo
name|udaf
init|=
name|getGenericUDAFInfo
argument_list|(
name|genericUDAFEvaluator
argument_list|,
name|amode
argument_list|,
name|aggParameters
argument_list|)
decl_stmt|;
name|aggregations
operator|.
name|add
argument_list|(
operator|new
name|AggregationDesc
argument_list|(
name|aggName
operator|.
name|toLowerCase
argument_list|()
argument_list|,
name|udaf
operator|.
name|genericUDAFEvaluator
argument_list|,
name|udaf
operator|.
name|convertedParameters
argument_list|,
operator|(
name|mode
operator|!=
name|GroupByDesc
operator|.
name|Mode
operator|.
name|FINAL
operator|&&
name|value
operator|.
name|getToken
argument_list|()
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_FUNCTIONDI
operator|)
argument_list|,
name|amode
argument_list|)
argument_list|)
expr_stmt|;
name|String
name|field
init|=
name|getColumnInternalName
argument_list|(
name|groupByKeys
operator|.
name|size
argument_list|()
operator|+
name|aggregations
operator|.
name|size
argument_list|()
operator|-
literal|1
argument_list|)
decl_stmt|;
name|outputColumnNames
operator|.
name|add
argument_list|(
name|field
argument_list|)
expr_stmt|;
name|groupByOutputRowResolver2
operator|.
name|putExpression
argument_list|(
name|value
argument_list|,
operator|new
name|ColumnInfo
argument_list|(
name|field
argument_list|,
name|udaf
operator|.
name|returnType
argument_list|,
literal|""
argument_list|,
literal|false
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|float
name|groupByMemoryUsage
init|=
name|HiveConf
operator|.
name|getFloatVar
argument_list|(
name|conf
argument_list|,
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVEMAPAGGRHASHMEMORY
argument_list|)
decl_stmt|;
name|float
name|memoryThreshold
init|=
name|HiveConf
operator|.
name|getFloatVar
argument_list|(
name|conf
argument_list|,
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVEMAPAGGRMEMORYTHRESHOLD
argument_list|)
decl_stmt|;
name|Operator
name|op
init|=
name|putOpInsertMap
argument_list|(
name|OperatorFactory
operator|.
name|getAndMakeChild
argument_list|(
operator|new
name|GroupByDesc
argument_list|(
name|mode
argument_list|,
name|outputColumnNames
argument_list|,
name|groupByKeys
argument_list|,
name|aggregations
argument_list|,
literal|false
argument_list|,
name|groupByMemoryUsage
argument_list|,
name|memoryThreshold
argument_list|,
literal|null
argument_list|,
literal|false
argument_list|,
literal|0
argument_list|,
name|containsDistinctAggr
argument_list|)
argument_list|,
operator|new
name|RowSchema
argument_list|(
name|groupByOutputRowResolver2
operator|.
name|getColumnInfos
argument_list|()
argument_list|)
argument_list|,
name|reduceSinkOperatorInfo2
argument_list|)
argument_list|,
name|groupByOutputRowResolver2
argument_list|)
decl_stmt|;
name|op
operator|.
name|setColumnExprMap
argument_list|(
name|colExprMap
argument_list|)
expr_stmt|;
return|return
name|op
return|;
block|}
comment|/**    * Generate a Group-By plan using a single map-reduce job (3 operators will be    * inserted):    *    * ReduceSink ( keys = (K1_EXP, K2_EXP, DISTINCT_EXP), values = (A1_EXP,    * A2_EXP) ) SortGroupBy (keys = (KEY.0,KEY.1), aggregations =    * (count_distinct(KEY.2), sum(VALUE.0), count(VALUE.1))) Select (final    * selects).    *    * @param dest    * @param qb    * @param input    * @return    * @throws SemanticException    *    *           Generate a Group-By plan using 1 map-reduce job. Spray by the    *           group by key, and sort by the distinct key (if any), and compute    *           aggregates * The aggregation evaluation functions are as    *           follows: Partitioning Key: grouping key    *    *           Sorting Key: grouping key if no DISTINCT grouping + distinct key    *           if DISTINCT    *    *           Reducer: iterate/merge (mode = COMPLETE)    **/
annotation|@
name|SuppressWarnings
argument_list|(
block|{
literal|"nls"
block|}
argument_list|)
specifier|private
name|Operator
name|genGroupByPlan1MR
parameter_list|(
name|String
name|dest
parameter_list|,
name|QB
name|qb
parameter_list|,
name|Operator
name|input
parameter_list|)
throws|throws
name|SemanticException
block|{
name|QBParseInfo
name|parseInfo
init|=
name|qb
operator|.
name|getParseInfo
argument_list|()
decl_stmt|;
name|int
name|numReducers
init|=
operator|-
literal|1
decl_stmt|;
name|ObjectPair
argument_list|<
name|List
argument_list|<
name|ASTNode
argument_list|>
argument_list|,
name|List
argument_list|<
name|Integer
argument_list|>
argument_list|>
name|grpByExprsGroupingSets
init|=
name|getGroupByGroupingSetsForClause
argument_list|(
name|parseInfo
argument_list|,
name|dest
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|ASTNode
argument_list|>
name|grpByExprs
init|=
name|grpByExprsGroupingSets
operator|.
name|getFirst
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|Integer
argument_list|>
name|groupingSets
init|=
name|grpByExprsGroupingSets
operator|.
name|getSecond
argument_list|()
decl_stmt|;
if|if
condition|(
name|grpByExprs
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|numReducers
operator|=
literal|1
expr_stmt|;
block|}
comment|// Grouping sets are not allowed
if|if
condition|(
operator|!
name|groupingSets
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|HIVE_GROUPING_SETS_AGGR_NOMAPAGGR
operator|.
name|getMsg
argument_list|()
argument_list|)
throw|;
block|}
comment|// ////// 1. Generate ReduceSinkOperator
name|ReduceSinkOperator
name|reduceSinkOperatorInfo
init|=
name|genGroupByPlanReduceSinkOperator
argument_list|(
name|qb
argument_list|,
name|dest
argument_list|,
name|input
argument_list|,
name|grpByExprs
argument_list|,
name|grpByExprs
operator|.
name|size
argument_list|()
argument_list|,
literal|false
argument_list|,
name|numReducers
argument_list|,
literal|false
argument_list|,
literal|false
argument_list|)
decl_stmt|;
comment|// ////// 2. Generate GroupbyOperator
name|Operator
name|groupByOperatorInfo
init|=
name|genGroupByPlanGroupByOperator
argument_list|(
name|parseInfo
argument_list|,
name|dest
argument_list|,
name|reduceSinkOperatorInfo
argument_list|,
name|reduceSinkOperatorInfo
argument_list|,
name|GroupByDesc
operator|.
name|Mode
operator|.
name|COMPLETE
argument_list|,
literal|null
argument_list|)
decl_stmt|;
return|return
name|groupByOperatorInfo
return|;
block|}
annotation|@
name|SuppressWarnings
argument_list|(
block|{
literal|"nls"
block|}
argument_list|)
specifier|private
name|Operator
name|genGroupByPlan1ReduceMultiGBY
parameter_list|(
name|List
argument_list|<
name|String
argument_list|>
name|dests
parameter_list|,
name|QB
name|qb
parameter_list|,
name|Operator
name|input
parameter_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|Operator
argument_list|>
name|aliasToOpInfo
parameter_list|)
throws|throws
name|SemanticException
block|{
name|QBParseInfo
name|parseInfo
init|=
name|qb
operator|.
name|getParseInfo
argument_list|()
decl_stmt|;
name|ExprNodeDesc
name|previous
init|=
literal|null
decl_stmt|;
name|Operator
name|selectInput
init|=
name|input
decl_stmt|;
comment|// In order to facilitate partition pruning, or the where clauses together and put them at the
comment|// top of the operator tree, this could also reduce the amount of data going to the reducer
name|List
argument_list|<
name|ExprNodeDesc
operator|.
name|ExprNodeDescEqualityWrapper
argument_list|>
name|whereExpressions
init|=
operator|new
name|ArrayList
argument_list|<
name|ExprNodeDesc
operator|.
name|ExprNodeDescEqualityWrapper
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|String
name|dest
range|:
name|dests
control|)
block|{
name|ASTNode
name|whereExpr
init|=
name|parseInfo
operator|.
name|getWhrForClause
argument_list|(
name|dest
argument_list|)
decl_stmt|;
if|if
condition|(
name|whereExpr
operator|!=
literal|null
condition|)
block|{
name|OpParseContext
name|inputCtx
init|=
name|opParseCtx
operator|.
name|get
argument_list|(
name|input
argument_list|)
decl_stmt|;
name|RowResolver
name|inputRR
init|=
name|inputCtx
operator|.
name|getRowResolver
argument_list|()
decl_stmt|;
name|ExprNodeDesc
name|current
init|=
name|genExprNodeDesc
argument_list|(
operator|(
name|ASTNode
operator|)
name|whereExpr
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
argument_list|,
name|inputRR
argument_list|)
decl_stmt|;
comment|// Check the list of where expressions already added so they aren't duplicated
name|ExprNodeDesc
operator|.
name|ExprNodeDescEqualityWrapper
name|currentWrapped
init|=
operator|new
name|ExprNodeDesc
operator|.
name|ExprNodeDescEqualityWrapper
argument_list|(
name|current
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|whereExpressions
operator|.
name|contains
argument_list|(
name|currentWrapped
argument_list|)
condition|)
block|{
name|whereExpressions
operator|.
name|add
argument_list|(
name|currentWrapped
argument_list|)
expr_stmt|;
block|}
else|else
block|{
continue|continue;
block|}
if|if
condition|(
name|previous
operator|==
literal|null
condition|)
block|{
comment|// If this is the first expression
name|previous
operator|=
name|current
expr_stmt|;
continue|continue;
block|}
name|GenericUDFOPOr
name|or
init|=
operator|new
name|GenericUDFOPOr
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|ExprNodeDesc
argument_list|>
name|expressions
init|=
operator|new
name|ArrayList
argument_list|<
name|ExprNodeDesc
argument_list|>
argument_list|(
literal|2
argument_list|)
decl_stmt|;
name|expressions
operator|.
name|add
argument_list|(
name|previous
argument_list|)
expr_stmt|;
name|expressions
operator|.
name|add
argument_list|(
name|current
argument_list|)
expr_stmt|;
name|ExprNodeDesc
name|orExpr
init|=
operator|new
name|ExprNodeGenericFuncDesc
argument_list|(
name|TypeInfoFactory
operator|.
name|booleanTypeInfo
argument_list|,
name|or
argument_list|,
name|expressions
argument_list|)
decl_stmt|;
name|previous
operator|=
name|orExpr
expr_stmt|;
block|}
else|else
block|{
comment|// If an expression does not have a where clause, there can be no common filter
name|previous
operator|=
literal|null
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|previous
operator|!=
literal|null
condition|)
block|{
name|OpParseContext
name|inputCtx
init|=
name|opParseCtx
operator|.
name|get
argument_list|(
name|input
argument_list|)
decl_stmt|;
name|RowResolver
name|inputRR
init|=
name|inputCtx
operator|.
name|getRowResolver
argument_list|()
decl_stmt|;
name|FilterDesc
name|orFilterDesc
init|=
operator|new
name|FilterDesc
argument_list|(
name|previous
argument_list|,
literal|false
argument_list|)
decl_stmt|;
name|selectInput
operator|=
name|putOpInsertMap
argument_list|(
name|OperatorFactory
operator|.
name|getAndMakeChild
argument_list|(
name|orFilterDesc
argument_list|,
operator|new
name|RowSchema
argument_list|(
name|inputRR
operator|.
name|getColumnInfos
argument_list|()
argument_list|)
argument_list|,
name|input
argument_list|)
argument_list|,
name|inputRR
argument_list|)
expr_stmt|;
block|}
comment|// insert a select operator here used by the ColumnPruner to reduce
comment|// the data to shuffle
name|Operator
name|select
init|=
name|insertSelectAllPlanForGroupBy
argument_list|(
name|selectInput
argument_list|)
decl_stmt|;
comment|// Generate ReduceSinkOperator
name|ReduceSinkOperator
name|reduceSinkOperatorInfo
init|=
name|genCommonGroupByPlanReduceSinkOperator
argument_list|(
name|qb
argument_list|,
name|dests
argument_list|,
name|select
argument_list|)
decl_stmt|;
comment|// It is assumed throughout the code that a reducer has a single child, add a
comment|// ForwardOperator so that we can add multiple filter/group by operators as children
name|RowResolver
name|reduceSinkOperatorInfoRR
init|=
name|opParseCtx
operator|.
name|get
argument_list|(
name|reduceSinkOperatorInfo
argument_list|)
operator|.
name|getRowResolver
argument_list|()
decl_stmt|;
name|Operator
name|forwardOp
init|=
name|putOpInsertMap
argument_list|(
name|OperatorFactory
operator|.
name|getAndMakeChild
argument_list|(
operator|new
name|ForwardDesc
argument_list|()
argument_list|,
operator|new
name|RowSchema
argument_list|(
name|reduceSinkOperatorInfoRR
operator|.
name|getColumnInfos
argument_list|()
argument_list|)
argument_list|,
name|reduceSinkOperatorInfo
argument_list|)
argument_list|,
name|reduceSinkOperatorInfoRR
argument_list|)
decl_stmt|;
name|Operator
name|curr
init|=
name|forwardOp
decl_stmt|;
for|for
control|(
name|String
name|dest
range|:
name|dests
control|)
block|{
name|curr
operator|=
name|forwardOp
expr_stmt|;
if|if
condition|(
name|parseInfo
operator|.
name|getWhrForClause
argument_list|(
name|dest
argument_list|)
operator|!=
literal|null
condition|)
block|{
name|ASTNode
name|whereExpr
init|=
name|qb
operator|.
name|getParseInfo
argument_list|()
operator|.
name|getWhrForClause
argument_list|(
name|dest
argument_list|)
decl_stmt|;
name|curr
operator|=
name|genFilterPlan
argument_list|(
operator|(
name|ASTNode
operator|)
name|whereExpr
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
argument_list|,
name|qb
argument_list|,
name|forwardOp
argument_list|,
name|aliasToOpInfo
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
comment|// Generate GroupbyOperator
name|Operator
name|groupByOperatorInfo
init|=
name|genGroupByPlanGroupByOperator
argument_list|(
name|parseInfo
argument_list|,
name|dest
argument_list|,
name|curr
argument_list|,
name|reduceSinkOperatorInfo
argument_list|,
name|GroupByDesc
operator|.
name|Mode
operator|.
name|COMPLETE
argument_list|,
literal|null
argument_list|)
decl_stmt|;
name|curr
operator|=
name|genPostGroupByBodyPlan
argument_list|(
name|groupByOperatorInfo
argument_list|,
name|dest
argument_list|,
name|qb
argument_list|,
name|aliasToOpInfo
argument_list|)
expr_stmt|;
block|}
return|return
name|curr
return|;
block|}
specifier|static
name|ArrayList
argument_list|<
name|GenericUDAFEvaluator
argument_list|>
name|getUDAFEvaluators
parameter_list|(
name|ArrayList
argument_list|<
name|AggregationDesc
argument_list|>
name|aggs
parameter_list|)
block|{
name|ArrayList
argument_list|<
name|GenericUDAFEvaluator
argument_list|>
name|result
init|=
operator|new
name|ArrayList
argument_list|<
name|GenericUDAFEvaluator
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|aggs
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|result
operator|.
name|add
argument_list|(
name|aggs
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|getGenericUDAFEvaluator
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
comment|/**    * Generate a Multi Group-By plan using a 2 map-reduce jobs.    *    * @param dest    * @param qb    * @param input    * @return    * @throws SemanticException    *    *           Generate a Group-By plan using a 2 map-reduce jobs. Spray by the    *           distinct key in hope of getting a uniform distribution, and    *           compute partial aggregates by the grouping key. Evaluate partial    *           aggregates first, and spray by the grouping key to compute actual    *           aggregates in the second phase. The agggregation evaluation    *           functions are as follows: Partitioning Key: distinct key    *    *           Sorting Key: distinct key    *    *           Reducer: iterate/terminatePartial (mode = PARTIAL1)    *    *           STAGE 2    *    *           Partitioning Key: grouping key    *    *           Sorting Key: grouping key    *    *           Reducer: merge/terminate (mode = FINAL)    */
annotation|@
name|SuppressWarnings
argument_list|(
literal|"nls"
argument_list|)
specifier|private
name|Operator
name|genGroupByPlan2MRMultiGroupBy
parameter_list|(
name|String
name|dest
parameter_list|,
name|QB
name|qb
parameter_list|,
name|Operator
name|input
parameter_list|)
throws|throws
name|SemanticException
block|{
comment|// ////// Generate GroupbyOperator for a map-side partial aggregation
name|Map
argument_list|<
name|String
argument_list|,
name|GenericUDAFEvaluator
argument_list|>
name|genericUDAFEvaluators
init|=
operator|new
name|LinkedHashMap
argument_list|<
name|String
argument_list|,
name|GenericUDAFEvaluator
argument_list|>
argument_list|()
decl_stmt|;
name|QBParseInfo
name|parseInfo
init|=
name|qb
operator|.
name|getParseInfo
argument_list|()
decl_stmt|;
comment|// ////// 2. Generate GroupbyOperator
name|Operator
name|groupByOperatorInfo
init|=
name|genGroupByPlanGroupByOperator1
argument_list|(
name|parseInfo
argument_list|,
name|dest
argument_list|,
name|input
argument_list|,
name|GroupByDesc
operator|.
name|Mode
operator|.
name|HASH
argument_list|,
name|genericUDAFEvaluators
argument_list|,
literal|true
argument_list|,
literal|null
argument_list|,
literal|false
argument_list|,
literal|false
argument_list|)
decl_stmt|;
name|int
name|numReducers
init|=
operator|-
literal|1
decl_stmt|;
name|List
argument_list|<
name|ASTNode
argument_list|>
name|grpByExprs
init|=
name|getGroupByForClause
argument_list|(
name|parseInfo
argument_list|,
name|dest
argument_list|)
decl_stmt|;
comment|// ////// 3. Generate ReduceSinkOperator2
name|Operator
name|reduceSinkOperatorInfo2
init|=
name|genGroupByPlanReduceSinkOperator2MR
argument_list|(
name|parseInfo
argument_list|,
name|dest
argument_list|,
name|groupByOperatorInfo
argument_list|,
name|grpByExprs
operator|.
name|size
argument_list|()
argument_list|,
name|numReducers
argument_list|,
literal|false
argument_list|)
decl_stmt|;
comment|// ////// 4. Generate GroupbyOperator2
name|Operator
name|groupByOperatorInfo2
init|=
name|genGroupByPlanGroupByOperator2MR
argument_list|(
name|parseInfo
argument_list|,
name|dest
argument_list|,
name|reduceSinkOperatorInfo2
argument_list|,
name|GroupByDesc
operator|.
name|Mode
operator|.
name|FINAL
argument_list|,
name|genericUDAFEvaluators
argument_list|,
literal|false
argument_list|)
decl_stmt|;
return|return
name|groupByOperatorInfo2
return|;
block|}
comment|/**    * Generate a Group-By plan using a 2 map-reduce jobs (5 operators will be    * inserted):    *    * ReduceSink ( keys = (K1_EXP, K2_EXP, DISTINCT_EXP), values = (A1_EXP,    * A2_EXP) ) NOTE: If DISTINCT_EXP is null, partition by rand() SortGroupBy    * (keys = (KEY.0,KEY.1), aggregations = (count_distinct(KEY.2), sum(VALUE.0),    * count(VALUE.1))) ReduceSink ( keys = (0,1), values=(2,3,4)) SortGroupBy    * (keys = (KEY.0,KEY.1), aggregations = (sum(VALUE.0), sum(VALUE.1),    * sum(VALUE.2))) Select (final selects).    *    * @param dest    * @param qb    * @param input    * @return    * @throws SemanticException    *    *           Generate a Group-By plan using a 2 map-reduce jobs. Spray by the    *           grouping key and distinct key (or a random number, if no distinct    *           is present) in hope of getting a uniform distribution, and    *           compute partial aggregates grouped by the reduction key (grouping    *           key + distinct key). Evaluate partial aggregates first, and spray    *           by the grouping key to compute actual aggregates in the second    *           phase. The agggregation evaluation functions are as follows:    *           Partitioning Key: random() if no DISTINCT grouping + distinct key    *           if DISTINCT    *    *           Sorting Key: grouping key if no DISTINCT grouping + distinct key    *           if DISTINCT    *    *           Reducer: iterate/terminatePartial (mode = PARTIAL1)    *    *           STAGE 2    *    *           Partitioning Key: grouping key    *    *           Sorting Key: grouping key if no DISTINCT grouping + distinct key    *           if DISTINCT    *    *           Reducer: merge/terminate (mode = FINAL)    */
annotation|@
name|SuppressWarnings
argument_list|(
literal|"nls"
argument_list|)
specifier|private
name|Operator
name|genGroupByPlan2MR
parameter_list|(
name|String
name|dest
parameter_list|,
name|QB
name|qb
parameter_list|,
name|Operator
name|input
parameter_list|)
throws|throws
name|SemanticException
block|{
name|QBParseInfo
name|parseInfo
init|=
name|qb
operator|.
name|getParseInfo
argument_list|()
decl_stmt|;
name|ObjectPair
argument_list|<
name|List
argument_list|<
name|ASTNode
argument_list|>
argument_list|,
name|List
argument_list|<
name|Integer
argument_list|>
argument_list|>
name|grpByExprsGroupingSets
init|=
name|getGroupByGroupingSetsForClause
argument_list|(
name|parseInfo
argument_list|,
name|dest
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|ASTNode
argument_list|>
name|grpByExprs
init|=
name|grpByExprsGroupingSets
operator|.
name|getFirst
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|Integer
argument_list|>
name|groupingSets
init|=
name|grpByExprsGroupingSets
operator|.
name|getSecond
argument_list|()
decl_stmt|;
comment|// Grouping sets are not allowed
comment|// This restriction can be lifted in future.
comment|// HIVE-3508 has been filed for this
if|if
condition|(
operator|!
name|groupingSets
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|HIVE_GROUPING_SETS_AGGR_NOMAPAGGR
operator|.
name|getMsg
argument_list|()
argument_list|)
throw|;
block|}
comment|// ////// 1. Generate ReduceSinkOperator
comment|// There is a special case when we want the rows to be randomly distributed
comment|// to
comment|// reducers for load balancing problem. That happens when there is no
comment|// DISTINCT
comment|// operator. We set the numPartitionColumns to -1 for this purpose. This is
comment|// captured by WritableComparableHiveObject.hashCode() function.
name|ReduceSinkOperator
name|reduceSinkOperatorInfo
init|=
name|genGroupByPlanReduceSinkOperator
argument_list|(
name|qb
argument_list|,
name|dest
argument_list|,
name|input
argument_list|,
name|grpByExprs
argument_list|,
operator|(
name|parseInfo
operator|.
name|getDistinctFuncExprsForClause
argument_list|(
name|dest
argument_list|)
operator|.
name|isEmpty
argument_list|()
condition|?
operator|-
literal|1
else|:
name|Integer
operator|.
name|MAX_VALUE
operator|)
argument_list|,
literal|false
argument_list|,
operator|-
literal|1
argument_list|,
literal|false
argument_list|,
literal|false
argument_list|)
decl_stmt|;
comment|// ////// 2. Generate GroupbyOperator
name|Map
argument_list|<
name|String
argument_list|,
name|GenericUDAFEvaluator
argument_list|>
name|genericUDAFEvaluators
init|=
operator|new
name|LinkedHashMap
argument_list|<
name|String
argument_list|,
name|GenericUDAFEvaluator
argument_list|>
argument_list|()
decl_stmt|;
name|GroupByOperator
name|groupByOperatorInfo
init|=
operator|(
name|GroupByOperator
operator|)
name|genGroupByPlanGroupByOperator
argument_list|(
name|parseInfo
argument_list|,
name|dest
argument_list|,
name|reduceSinkOperatorInfo
argument_list|,
name|reduceSinkOperatorInfo
argument_list|,
name|GroupByDesc
operator|.
name|Mode
operator|.
name|PARTIAL1
argument_list|,
name|genericUDAFEvaluators
argument_list|)
decl_stmt|;
name|int
name|numReducers
init|=
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|grpByExprs
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|numReducers
operator|=
literal|1
expr_stmt|;
block|}
comment|// ////// 3. Generate ReduceSinkOperator2
name|Operator
name|reduceSinkOperatorInfo2
init|=
name|genGroupByPlanReduceSinkOperator2MR
argument_list|(
name|parseInfo
argument_list|,
name|dest
argument_list|,
name|groupByOperatorInfo
argument_list|,
name|grpByExprs
operator|.
name|size
argument_list|()
argument_list|,
name|numReducers
argument_list|,
literal|false
argument_list|)
decl_stmt|;
comment|// ////// 4. Generate GroupbyOperator2
name|Operator
name|groupByOperatorInfo2
init|=
name|genGroupByPlanGroupByOperator2MR
argument_list|(
name|parseInfo
argument_list|,
name|dest
argument_list|,
name|reduceSinkOperatorInfo2
argument_list|,
name|GroupByDesc
operator|.
name|Mode
operator|.
name|FINAL
argument_list|,
name|genericUDAFEvaluators
argument_list|,
literal|false
argument_list|)
decl_stmt|;
return|return
name|groupByOperatorInfo2
return|;
block|}
specifier|private
name|boolean
name|optimizeMapAggrGroupBy
parameter_list|(
name|String
name|dest
parameter_list|,
name|QB
name|qb
parameter_list|)
block|{
name|List
argument_list|<
name|ASTNode
argument_list|>
name|grpByExprs
init|=
name|getGroupByForClause
argument_list|(
name|qb
operator|.
name|getParseInfo
argument_list|()
argument_list|,
name|dest
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|grpByExprs
operator|!=
literal|null
operator|)
operator|&&
operator|!
name|grpByExprs
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return
literal|false
return|;
block|}
if|if
condition|(
operator|!
name|qb
operator|.
name|getParseInfo
argument_list|()
operator|.
name|getDistinctFuncExprsForClause
argument_list|(
name|dest
argument_list|)
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return
literal|false
return|;
block|}
return|return
literal|true
return|;
block|}
specifier|static
specifier|private
name|void
name|extractColumns
parameter_list|(
name|Set
argument_list|<
name|String
argument_list|>
name|colNamesExprs
parameter_list|,
name|ExprNodeDesc
name|exprNode
parameter_list|)
throws|throws
name|SemanticException
block|{
if|if
condition|(
name|exprNode
operator|instanceof
name|ExprNodeColumnDesc
condition|)
block|{
name|colNamesExprs
operator|.
name|add
argument_list|(
operator|(
operator|(
name|ExprNodeColumnDesc
operator|)
name|exprNode
operator|)
operator|.
name|getColumn
argument_list|()
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|exprNode
operator|instanceof
name|ExprNodeGenericFuncDesc
condition|)
block|{
name|ExprNodeGenericFuncDesc
name|funcDesc
init|=
operator|(
name|ExprNodeGenericFuncDesc
operator|)
name|exprNode
decl_stmt|;
for|for
control|(
name|ExprNodeDesc
name|childExpr
range|:
name|funcDesc
operator|.
name|getChildren
argument_list|()
control|)
block|{
name|extractColumns
argument_list|(
name|colNamesExprs
argument_list|,
name|childExpr
argument_list|)
expr_stmt|;
block|}
block|}
block|}
specifier|static
specifier|private
name|boolean
name|hasCommonElement
parameter_list|(
name|Set
argument_list|<
name|String
argument_list|>
name|set1
parameter_list|,
name|Set
argument_list|<
name|String
argument_list|>
name|set2
parameter_list|)
block|{
for|for
control|(
name|String
name|elem1
range|:
name|set1
control|)
block|{
if|if
condition|(
name|set2
operator|.
name|contains
argument_list|(
name|elem1
argument_list|)
condition|)
block|{
return|return
literal|true
return|;
block|}
block|}
return|return
literal|false
return|;
block|}
specifier|private
name|void
name|checkExpressionsForGroupingSet
parameter_list|(
name|List
argument_list|<
name|ASTNode
argument_list|>
name|grpByExprs
parameter_list|,
name|List
argument_list|<
name|ASTNode
argument_list|>
name|distinctGrpByExprs
parameter_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|ASTNode
argument_list|>
name|aggregationTrees
parameter_list|,
name|RowResolver
name|inputRowResolver
parameter_list|)
throws|throws
name|SemanticException
block|{
name|Set
argument_list|<
name|String
argument_list|>
name|colNamesGroupByExprs
init|=
operator|new
name|HashSet
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
name|Set
argument_list|<
name|String
argument_list|>
name|colNamesGroupByDistinctExprs
init|=
operator|new
name|HashSet
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
name|Set
argument_list|<
name|String
argument_list|>
name|colNamesAggregateParameters
init|=
operator|new
name|HashSet
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
comment|// The columns in the group by expressions should not intersect with the columns in the
comment|// distinct expressions
for|for
control|(
name|ASTNode
name|grpByExpr
range|:
name|grpByExprs
control|)
block|{
name|extractColumns
argument_list|(
name|colNamesGroupByExprs
argument_list|,
name|genExprNodeDesc
argument_list|(
name|grpByExpr
argument_list|,
name|inputRowResolver
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// If there is a distinctFuncExp, add all parameters to the reduceKeys.
if|if
condition|(
operator|!
name|distinctGrpByExprs
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
for|for
control|(
name|ASTNode
name|value
range|:
name|distinctGrpByExprs
control|)
block|{
comment|// 0 is function name
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<
name|value
operator|.
name|getChildCount
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|ASTNode
name|parameter
init|=
operator|(
name|ASTNode
operator|)
name|value
operator|.
name|getChild
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|ExprNodeDesc
name|distExprNode
init|=
name|genExprNodeDesc
argument_list|(
name|parameter
argument_list|,
name|inputRowResolver
argument_list|)
decl_stmt|;
comment|// extract all the columns
name|extractColumns
argument_list|(
name|colNamesGroupByDistinctExprs
argument_list|,
name|distExprNode
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|hasCommonElement
argument_list|(
name|colNamesGroupByExprs
argument_list|,
name|colNamesGroupByDistinctExprs
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|HIVE_GROUPING_SETS_AGGR_EXPRESSION_INVALID
operator|.
name|getMsg
argument_list|()
argument_list|)
throw|;
block|}
block|}
block|}
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|ASTNode
argument_list|>
name|entry
range|:
name|aggregationTrees
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|ASTNode
name|value
init|=
name|entry
operator|.
name|getValue
argument_list|()
decl_stmt|;
name|ArrayList
argument_list|<
name|ExprNodeDesc
argument_list|>
name|aggParameters
init|=
operator|new
name|ArrayList
argument_list|<
name|ExprNodeDesc
argument_list|>
argument_list|()
decl_stmt|;
comment|// 0 is the function name
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<
name|value
operator|.
name|getChildCount
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|ASTNode
name|paraExpr
init|=
operator|(
name|ASTNode
operator|)
name|value
operator|.
name|getChild
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|ExprNodeDesc
name|paraExprNode
init|=
name|genExprNodeDesc
argument_list|(
name|paraExpr
argument_list|,
name|inputRowResolver
argument_list|)
decl_stmt|;
comment|// extract all the columns
name|extractColumns
argument_list|(
name|colNamesAggregateParameters
argument_list|,
name|paraExprNode
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|hasCommonElement
argument_list|(
name|colNamesGroupByExprs
argument_list|,
name|colNamesAggregateParameters
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|HIVE_GROUPING_SETS_AGGR_EXPRESSION_INVALID
operator|.
name|getMsg
argument_list|()
argument_list|)
throw|;
block|}
block|}
block|}
comment|/**    * Generate a Group-By plan using 1 map-reduce job. First perform a map-side    * partial aggregation (to reduce the amount of data), at this point of time,    * we may turn off map-side partial aggregation based on its performance. Then    * spray by the group by key, and sort by the distinct key (if any), and    * compute aggregates based on actual aggregates    *    * The agggregation evaluation functions are as follows:    *    * No grouping sets:    * Group By Operator:    * grouping keys: group by expressions if no DISTINCT    * grouping keys: group by expressions + distinct keys if DISTINCT    * Mapper: iterate/terminatePartial (mode = HASH)    * Partitioning Key: grouping key    * Sorting Key: grouping key if no DISTINCT    * grouping + distinct key if DISTINCT    * Reducer: iterate/terminate if DISTINCT    * merge/terminate if NO DISTINCT (mode MERGEPARTIAL)    *    * Grouping Sets:    * Group By Operator:    * grouping keys: group by expressions + grouping id. if no DISTINCT    * grouping keys: group by expressions + grouping id. + distinct keys if DISTINCT    * Mapper: iterate/terminatePartial (mode = HASH)    * Partitioning Key: grouping key + grouping id.    * Sorting Key: grouping key + grouping id. if no DISTINCT    * grouping + grouping id. + distinct key if DISTINCT    * Reducer: iterate/terminate if DISTINCT    * merge/terminate if NO DISTINCT (mode MERGEPARTIAL)    *    * Grouping Sets with an additional MR job introduced (distincts are not allowed):    * Group By Operator:    * grouping keys: group by expressions    * Mapper: iterate/terminatePartial (mode = HASH)    * Partitioning Key: grouping key    * Sorting Key: grouping key    * Reducer: merge/terminate (mode MERGEPARTIAL)    * Group by Operator:    * grouping keys: group by expressions + add a new grouping id. key    *    * STAGE 2    * Partitioning Key: grouping key + grouping id.    * Sorting Key: grouping key + grouping id.    * Reducer: merge/terminate (mode = FINAL)    * Group by Operator:    * grouping keys: group by expressions + grouping id.    */
annotation|@
name|SuppressWarnings
argument_list|(
literal|"nls"
argument_list|)
specifier|private
name|Operator
name|genGroupByPlanMapAggrNoSkew
parameter_list|(
name|String
name|dest
parameter_list|,
name|QB
name|qb
parameter_list|,
name|Operator
name|inputOperatorInfo
parameter_list|)
throws|throws
name|SemanticException
block|{
name|QBParseInfo
name|parseInfo
init|=
name|qb
operator|.
name|getParseInfo
argument_list|()
decl_stmt|;
name|ObjectPair
argument_list|<
name|List
argument_list|<
name|ASTNode
argument_list|>
argument_list|,
name|List
argument_list|<
name|Integer
argument_list|>
argument_list|>
name|grpByExprsGroupingSets
init|=
name|getGroupByGroupingSetsForClause
argument_list|(
name|parseInfo
argument_list|,
name|dest
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|ASTNode
argument_list|>
name|grpByExprs
init|=
name|grpByExprsGroupingSets
operator|.
name|getFirst
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|Integer
argument_list|>
name|groupingSets
init|=
name|grpByExprsGroupingSets
operator|.
name|getSecond
argument_list|()
decl_stmt|;
name|boolean
name|groupingSetsPresent
init|=
operator|!
name|groupingSets
operator|.
name|isEmpty
argument_list|()
decl_stmt|;
name|int
name|newMRJobGroupingSetsThreshold
init|=
name|conf
operator|.
name|getIntVar
argument_list|(
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVE_NEW_JOB_GROUPING_SET_CARDINALITY
argument_list|)
decl_stmt|;
if|if
condition|(
name|groupingSetsPresent
condition|)
block|{
name|checkExpressionsForGroupingSet
argument_list|(
name|grpByExprs
argument_list|,
name|parseInfo
operator|.
name|getDistinctFuncExprsForClause
argument_list|(
name|dest
argument_list|)
argument_list|,
name|parseInfo
operator|.
name|getAggregationExprsForClause
argument_list|(
name|dest
argument_list|)
argument_list|,
name|opParseCtx
operator|.
name|get
argument_list|(
name|inputOperatorInfo
argument_list|)
operator|.
name|getRowResolver
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// ////// Generate GroupbyOperator for a map-side partial aggregation
name|Map
argument_list|<
name|String
argument_list|,
name|GenericUDAFEvaluator
argument_list|>
name|genericUDAFEvaluators
init|=
operator|new
name|LinkedHashMap
argument_list|<
name|String
argument_list|,
name|GenericUDAFEvaluator
argument_list|>
argument_list|()
decl_stmt|;
comment|// Is the grouping sets data consumed in the current in MR job, or
comment|// does it need an additional MR job
name|boolean
name|groupingSetsNeedAdditionalMRJob
init|=
name|groupingSetsPresent
operator|&&
name|groupingSets
operator|.
name|size
argument_list|()
operator|>
name|newMRJobGroupingSetsThreshold
condition|?
literal|true
else|:
literal|false
decl_stmt|;
name|GroupByOperator
name|groupByOperatorInfo
init|=
operator|(
name|GroupByOperator
operator|)
name|genGroupByPlanMapGroupByOperator
argument_list|(
name|qb
argument_list|,
name|dest
argument_list|,
name|grpByExprs
argument_list|,
name|inputOperatorInfo
argument_list|,
name|GroupByDesc
operator|.
name|Mode
operator|.
name|HASH
argument_list|,
name|genericUDAFEvaluators
argument_list|,
name|groupingSets
argument_list|,
name|groupingSetsPresent
operator|&&
operator|!
name|groupingSetsNeedAdditionalMRJob
argument_list|)
decl_stmt|;
name|groupOpToInputTables
operator|.
name|put
argument_list|(
name|groupByOperatorInfo
argument_list|,
name|opParseCtx
operator|.
name|get
argument_list|(
name|inputOperatorInfo
argument_list|)
operator|.
name|getRowResolver
argument_list|()
operator|.
name|getTableNames
argument_list|()
argument_list|)
expr_stmt|;
name|int
name|numReducers
init|=
operator|-
literal|1
decl_stmt|;
comment|// Optimize the scenario when there are no grouping keys - only 1 reducer is
comment|// needed
if|if
condition|(
name|grpByExprs
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|numReducers
operator|=
literal|1
expr_stmt|;
block|}
comment|// ////// Generate ReduceSink Operator
name|boolean
name|isDistinct
init|=
operator|!
name|qb
operator|.
name|getParseInfo
argument_list|()
operator|.
name|getDistinctFuncExprsForClause
argument_list|(
name|dest
argument_list|)
operator|.
name|isEmpty
argument_list|()
decl_stmt|;
comment|// Distincts are not allowed with an additional mr job
if|if
condition|(
name|groupingSetsNeedAdditionalMRJob
operator|&&
name|isDistinct
condition|)
block|{
name|String
name|errorMsg
init|=
literal|"The number of rows per input row due to grouping sets is "
operator|+
name|groupingSets
operator|.
name|size
argument_list|()
decl_stmt|;
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|HIVE_GROUPING_SETS_THRESHOLD_NOT_ALLOWED_WITH_DISTINCTS
operator|.
name|getMsg
argument_list|(
name|errorMsg
argument_list|)
argument_list|)
throw|;
block|}
name|Operator
name|reduceSinkOperatorInfo
init|=
name|genGroupByPlanReduceSinkOperator
argument_list|(
name|qb
argument_list|,
name|dest
argument_list|,
name|groupByOperatorInfo
argument_list|,
name|grpByExprs
argument_list|,
name|grpByExprs
operator|.
name|size
argument_list|()
argument_list|,
literal|true
argument_list|,
name|numReducers
argument_list|,
literal|true
argument_list|,
name|groupingSetsPresent
operator|&&
operator|!
name|groupingSetsNeedAdditionalMRJob
argument_list|)
decl_stmt|;
comment|// Does it require a new MR job for grouping sets
if|if
condition|(
operator|!
name|groupingSetsPresent
operator|||
operator|!
name|groupingSetsNeedAdditionalMRJob
condition|)
block|{
comment|// This is a 1-stage map-reduce processing of the groupby. Tha map-side
comment|// aggregates was just used to
comment|// reduce output data. In case of distincts, partial results are not used,
comment|// and so iterate is again
comment|// invoked on the reducer. In case of non-distincts, partial results are
comment|// used, and merge is invoked
comment|// on the reducer.
return|return
name|genGroupByPlanGroupByOperator1
argument_list|(
name|parseInfo
argument_list|,
name|dest
argument_list|,
name|reduceSinkOperatorInfo
argument_list|,
name|GroupByDesc
operator|.
name|Mode
operator|.
name|MERGEPARTIAL
argument_list|,
name|genericUDAFEvaluators
argument_list|,
literal|false
argument_list|,
name|groupingSets
argument_list|,
name|groupingSetsPresent
argument_list|,
name|groupingSetsNeedAdditionalMRJob
argument_list|)
return|;
block|}
else|else
block|{
comment|// Add 'n' rows corresponding to the grouping sets. For each row, create 'n' rows,
comment|// one for each grouping set key. Since map-side aggregation has already been performed,
comment|// the number of rows would have been reduced. Moreover, the rows corresponding to the
comment|// grouping keys come together, so there is a higher chance of finding the rows in the hash
comment|// table.
name|Operator
name|groupByOperatorInfo2
init|=
name|genGroupByPlanGroupByOperator1
argument_list|(
name|parseInfo
argument_list|,
name|dest
argument_list|,
name|reduceSinkOperatorInfo
argument_list|,
name|GroupByDesc
operator|.
name|Mode
operator|.
name|PARTIALS
argument_list|,
name|genericUDAFEvaluators
argument_list|,
literal|false
argument_list|,
name|groupingSets
argument_list|,
name|groupingSetsPresent
argument_list|,
name|groupingSetsNeedAdditionalMRJob
argument_list|)
decl_stmt|;
comment|// ////// Generate ReduceSinkOperator2
name|Operator
name|reduceSinkOperatorInfo2
init|=
name|genGroupByPlanReduceSinkOperator2MR
argument_list|(
name|parseInfo
argument_list|,
name|dest
argument_list|,
name|groupByOperatorInfo2
argument_list|,
name|grpByExprs
operator|.
name|size
argument_list|()
operator|+
literal|1
argument_list|,
name|numReducers
argument_list|,
name|groupingSetsPresent
argument_list|)
decl_stmt|;
comment|// ////// Generate GroupbyOperator3
return|return
name|genGroupByPlanGroupByOperator2MR
argument_list|(
name|parseInfo
argument_list|,
name|dest
argument_list|,
name|reduceSinkOperatorInfo2
argument_list|,
name|GroupByDesc
operator|.
name|Mode
operator|.
name|FINAL
argument_list|,
name|genericUDAFEvaluators
argument_list|,
name|groupingSetsPresent
argument_list|)
return|;
block|}
block|}
comment|/**    * Generate a Group-By plan using a 2 map-reduce jobs. However, only 1    * group-by plan is generated if the query involves no grouping key and no    * distincts. In that case, the plan is same as generated by    * genGroupByPlanMapAggr1MR. Otherwise, the following plan is generated: First    * perform a map side partial aggregation (to reduce the amount of data). Then    * spray by the grouping key and distinct key (or a random number, if no    * distinct is present) in hope of getting a uniform distribution, and compute    * partial aggregates grouped by the reduction key (grouping key + distinct    * key). Evaluate partial aggregates first, and spray by the grouping key to    * compute actual aggregates in the second phase.    *    * The agggregation evaluation functions are as follows:    *    * No grouping sets:    * STAGE 1    * Group by Operator:    * grouping keys: group by expressions if no DISTINCT    * grouping keys: group by expressions + distinct keys if DISTINCT    * Mapper: iterate/terminatePartial (mode = HASH)    * Partitioning Key: random() if no DISTINCT    * grouping + distinct key if DISTINCT    * Sorting Key: grouping key if no DISTINCT    * grouping + distinct key if DISTINCT    * Reducer: iterate/terminatePartial if DISTINCT    * merge/terminatePartial if NO DISTINCT (mode = MERGEPARTIAL)    * Group by Operator:    * grouping keys: group by expressions    *    * STAGE 2    * Partitioning Key: grouping key    * Sorting Key: grouping key    * Reducer: merge/terminate (mode = FINAL)    *    * In the presence of grouping sets, the agggregation evaluation functions are as follows:    * STAGE 1    * Group by Operator:    * grouping keys: group by expressions + grouping id. if no DISTINCT    * grouping keys: group by expressions + + grouping id. + distinct keys if DISTINCT    * Mapper: iterate/terminatePartial (mode = HASH)    * Partitioning Key: random() if no DISTINCT    * grouping + grouping id. + distinct key if DISTINCT    * Sorting Key: grouping key + grouping id. if no DISTINCT    * grouping + grouping id. + distinct key if DISTINCT    * Reducer: iterate/terminatePartial if DISTINCT    * merge/terminatePartial if NO DISTINCT (mode = MERGEPARTIAL)    * Group by Operator:    * grouping keys: group by expressions + grouping id.    *    * STAGE 2    * Partitioning Key: grouping key    * Sorting Key: grouping key + grouping id.    * Reducer: merge/terminate (mode = FINAL)    */
annotation|@
name|SuppressWarnings
argument_list|(
literal|"nls"
argument_list|)
specifier|private
name|Operator
name|genGroupByPlanMapAggr2MR
parameter_list|(
name|String
name|dest
parameter_list|,
name|QB
name|qb
parameter_list|,
name|Operator
name|inputOperatorInfo
parameter_list|)
throws|throws
name|SemanticException
block|{
name|QBParseInfo
name|parseInfo
init|=
name|qb
operator|.
name|getParseInfo
argument_list|()
decl_stmt|;
name|ObjectPair
argument_list|<
name|List
argument_list|<
name|ASTNode
argument_list|>
argument_list|,
name|List
argument_list|<
name|Integer
argument_list|>
argument_list|>
name|grpByExprsGroupingSets
init|=
name|getGroupByGroupingSetsForClause
argument_list|(
name|parseInfo
argument_list|,
name|dest
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|ASTNode
argument_list|>
name|grpByExprs
init|=
name|grpByExprsGroupingSets
operator|.
name|getFirst
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|Integer
argument_list|>
name|groupingSets
init|=
name|grpByExprsGroupingSets
operator|.
name|getSecond
argument_list|()
decl_stmt|;
name|boolean
name|groupingSetsPresent
init|=
operator|!
name|groupingSets
operator|.
name|isEmpty
argument_list|()
decl_stmt|;
if|if
condition|(
name|groupingSetsPresent
condition|)
block|{
name|checkExpressionsForGroupingSet
argument_list|(
name|grpByExprs
argument_list|,
name|parseInfo
operator|.
name|getDistinctFuncExprsForClause
argument_list|(
name|dest
argument_list|)
argument_list|,
name|parseInfo
operator|.
name|getAggregationExprsForClause
argument_list|(
name|dest
argument_list|)
argument_list|,
name|opParseCtx
operator|.
name|get
argument_list|(
name|inputOperatorInfo
argument_list|)
operator|.
name|getRowResolver
argument_list|()
argument_list|)
expr_stmt|;
name|int
name|newMRJobGroupingSetsThreshold
init|=
name|conf
operator|.
name|getIntVar
argument_list|(
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVE_NEW_JOB_GROUPING_SET_CARDINALITY
argument_list|)
decl_stmt|;
comment|// Turn off skew if an additional MR job is required anyway for grouping sets.
if|if
condition|(
name|groupingSets
operator|.
name|size
argument_list|()
operator|>
name|newMRJobGroupingSetsThreshold
condition|)
block|{
name|String
name|errorMsg
init|=
literal|"The number of rows per input row due to grouping sets is "
operator|+
name|groupingSets
operator|.
name|size
argument_list|()
decl_stmt|;
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|HIVE_GROUPING_SETS_THRESHOLD_NOT_ALLOWED_WITH_SKEW
operator|.
name|getMsg
argument_list|(
name|errorMsg
argument_list|)
argument_list|)
throw|;
block|}
block|}
comment|// ////// Generate GroupbyOperator for a map-side partial aggregation
name|Map
argument_list|<
name|String
argument_list|,
name|GenericUDAFEvaluator
argument_list|>
name|genericUDAFEvaluators
init|=
operator|new
name|LinkedHashMap
argument_list|<
name|String
argument_list|,
name|GenericUDAFEvaluator
argument_list|>
argument_list|()
decl_stmt|;
name|GroupByOperator
name|groupByOperatorInfo
init|=
operator|(
name|GroupByOperator
operator|)
name|genGroupByPlanMapGroupByOperator
argument_list|(
name|qb
argument_list|,
name|dest
argument_list|,
name|grpByExprs
argument_list|,
name|inputOperatorInfo
argument_list|,
name|GroupByDesc
operator|.
name|Mode
operator|.
name|HASH
argument_list|,
name|genericUDAFEvaluators
argument_list|,
name|groupingSets
argument_list|,
name|groupingSetsPresent
argument_list|)
decl_stmt|;
name|groupOpToInputTables
operator|.
name|put
argument_list|(
name|groupByOperatorInfo
argument_list|,
name|opParseCtx
operator|.
name|get
argument_list|(
name|inputOperatorInfo
argument_list|)
operator|.
name|getRowResolver
argument_list|()
operator|.
name|getTableNames
argument_list|()
argument_list|)
expr_stmt|;
comment|// Optimize the scenario when there are no grouping keys and no distinct - 2
comment|// map-reduce jobs are not needed
comment|// For eg: select count(1) from T where t.ds = ....
if|if
condition|(
operator|!
name|optimizeMapAggrGroupBy
argument_list|(
name|dest
argument_list|,
name|qb
argument_list|)
condition|)
block|{
name|List
argument_list|<
name|ASTNode
argument_list|>
name|distinctFuncExprs
init|=
name|parseInfo
operator|.
name|getDistinctFuncExprsForClause
argument_list|(
name|dest
argument_list|)
decl_stmt|;
comment|// ////// Generate ReduceSink Operator
name|Operator
name|reduceSinkOperatorInfo
init|=
name|genGroupByPlanReduceSinkOperator
argument_list|(
name|qb
argument_list|,
name|dest
argument_list|,
name|groupByOperatorInfo
argument_list|,
name|grpByExprs
argument_list|,
name|distinctFuncExprs
operator|.
name|isEmpty
argument_list|()
condition|?
operator|-
literal|1
else|:
name|Integer
operator|.
name|MAX_VALUE
argument_list|,
literal|false
argument_list|,
operator|-
literal|1
argument_list|,
literal|true
argument_list|,
name|groupingSetsPresent
argument_list|)
decl_stmt|;
comment|// ////// Generate GroupbyOperator for a partial aggregation
name|Operator
name|groupByOperatorInfo2
init|=
name|genGroupByPlanGroupByOperator1
argument_list|(
name|parseInfo
argument_list|,
name|dest
argument_list|,
name|reduceSinkOperatorInfo
argument_list|,
name|GroupByDesc
operator|.
name|Mode
operator|.
name|PARTIALS
argument_list|,
name|genericUDAFEvaluators
argument_list|,
literal|false
argument_list|,
name|groupingSets
argument_list|,
name|groupingSetsPresent
argument_list|,
literal|false
argument_list|)
decl_stmt|;
name|int
name|numReducers
init|=
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|grpByExprs
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|numReducers
operator|=
literal|1
expr_stmt|;
block|}
comment|// ////// Generate ReduceSinkOperator2
name|Operator
name|reduceSinkOperatorInfo2
init|=
name|genGroupByPlanReduceSinkOperator2MR
argument_list|(
name|parseInfo
argument_list|,
name|dest
argument_list|,
name|groupByOperatorInfo2
argument_list|,
name|grpByExprs
operator|.
name|size
argument_list|()
argument_list|,
name|numReducers
argument_list|,
name|groupingSetsPresent
argument_list|)
decl_stmt|;
comment|// ////// Generate GroupbyOperator3
return|return
name|genGroupByPlanGroupByOperator2MR
argument_list|(
name|parseInfo
argument_list|,
name|dest
argument_list|,
name|reduceSinkOperatorInfo2
argument_list|,
name|GroupByDesc
operator|.
name|Mode
operator|.
name|FINAL
argument_list|,
name|genericUDAFEvaluators
argument_list|,
name|groupingSetsPresent
argument_list|)
return|;
block|}
else|else
block|{
comment|// If there are no grouping keys, grouping sets cannot be present
assert|assert
operator|!
name|groupingSetsPresent
assert|;
comment|// ////// Generate ReduceSink Operator
name|Operator
name|reduceSinkOperatorInfo
init|=
name|genGroupByPlanReduceSinkOperator
argument_list|(
name|qb
argument_list|,
name|dest
argument_list|,
name|groupByOperatorInfo
argument_list|,
name|grpByExprs
argument_list|,
name|grpByExprs
operator|.
name|size
argument_list|()
argument_list|,
literal|false
argument_list|,
literal|1
argument_list|,
literal|true
argument_list|,
name|groupingSetsPresent
argument_list|)
decl_stmt|;
return|return
name|genGroupByPlanGroupByOperator2MR
argument_list|(
name|parseInfo
argument_list|,
name|dest
argument_list|,
name|reduceSinkOperatorInfo
argument_list|,
name|GroupByDesc
operator|.
name|Mode
operator|.
name|FINAL
argument_list|,
name|genericUDAFEvaluators
argument_list|,
literal|false
argument_list|)
return|;
block|}
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"nls"
argument_list|)
specifier|private
name|Operator
name|genConversionOps
parameter_list|(
name|String
name|dest
parameter_list|,
name|QB
name|qb
parameter_list|,
name|Operator
name|input
parameter_list|)
throws|throws
name|SemanticException
block|{
name|Integer
name|dest_type
init|=
name|qb
operator|.
name|getMetaData
argument_list|()
operator|.
name|getDestTypeForAlias
argument_list|(
name|dest
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|dest_type
operator|.
name|intValue
argument_list|()
condition|)
block|{
case|case
name|QBMetaData
operator|.
name|DEST_TABLE
case|:
block|{
name|qb
operator|.
name|getMetaData
argument_list|()
operator|.
name|getDestTableForAlias
argument_list|(
name|dest
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|QBMetaData
operator|.
name|DEST_PARTITION
case|:
block|{
name|qb
operator|.
name|getMetaData
argument_list|()
operator|.
name|getDestPartitionForAlias
argument_list|(
name|dest
argument_list|)
operator|.
name|getTable
argument_list|()
expr_stmt|;
break|break;
block|}
default|default:
block|{
return|return
name|input
return|;
block|}
block|}
return|return
name|input
return|;
block|}
specifier|private
name|int
name|getReducersBucketing
parameter_list|(
name|int
name|totalFiles
parameter_list|,
name|int
name|maxReducers
parameter_list|)
block|{
name|int
name|numFiles
init|=
operator|(
name|int
operator|)
name|Math
operator|.
name|ceil
argument_list|(
operator|(
name|double
operator|)
name|totalFiles
operator|/
operator|(
name|double
operator|)
name|maxReducers
argument_list|)
decl_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
if|if
condition|(
name|totalFiles
operator|%
name|numFiles
operator|==
literal|0
condition|)
block|{
return|return
name|totalFiles
operator|/
name|numFiles
return|;
block|}
name|numFiles
operator|++
expr_stmt|;
block|}
block|}
specifier|private
specifier|static
class|class
name|SortBucketRSCtx
block|{
name|ArrayList
argument_list|<
name|ExprNodeDesc
argument_list|>
name|partnCols
decl_stmt|;
name|boolean
name|multiFileSpray
decl_stmt|;
name|int
name|numFiles
decl_stmt|;
name|int
name|totalFiles
decl_stmt|;
specifier|public
name|SortBucketRSCtx
parameter_list|()
block|{
name|partnCols
operator|=
literal|null
expr_stmt|;
name|multiFileSpray
operator|=
literal|false
expr_stmt|;
name|numFiles
operator|=
literal|1
expr_stmt|;
name|totalFiles
operator|=
literal|1
expr_stmt|;
block|}
comment|/**      * @return the partnCols      */
specifier|public
name|ArrayList
argument_list|<
name|ExprNodeDesc
argument_list|>
name|getPartnCols
parameter_list|()
block|{
return|return
name|partnCols
return|;
block|}
comment|/**      * @param partnCols      *          the partnCols to set      */
specifier|public
name|void
name|setPartnCols
parameter_list|(
name|ArrayList
argument_list|<
name|ExprNodeDesc
argument_list|>
name|partnCols
parameter_list|)
block|{
name|this
operator|.
name|partnCols
operator|=
name|partnCols
expr_stmt|;
block|}
comment|/**      * @return the multiFileSpray      */
specifier|public
name|boolean
name|isMultiFileSpray
parameter_list|()
block|{
return|return
name|multiFileSpray
return|;
block|}
comment|/**      * @param multiFileSpray      *          the multiFileSpray to set      */
specifier|public
name|void
name|setMultiFileSpray
parameter_list|(
name|boolean
name|multiFileSpray
parameter_list|)
block|{
name|this
operator|.
name|multiFileSpray
operator|=
name|multiFileSpray
expr_stmt|;
block|}
comment|/**      * @return the numFiles      */
specifier|public
name|int
name|getNumFiles
parameter_list|()
block|{
return|return
name|numFiles
return|;
block|}
comment|/**      * @param numFiles      *          the numFiles to set      */
specifier|public
name|void
name|setNumFiles
parameter_list|(
name|int
name|numFiles
parameter_list|)
block|{
name|this
operator|.
name|numFiles
operator|=
name|numFiles
expr_stmt|;
block|}
comment|/**      * @return the totalFiles      */
specifier|public
name|int
name|getTotalFiles
parameter_list|()
block|{
return|return
name|totalFiles
return|;
block|}
comment|/**      * @param totalFiles      *          the totalFiles to set      */
specifier|public
name|void
name|setTotalFiles
parameter_list|(
name|int
name|totalFiles
parameter_list|)
block|{
name|this
operator|.
name|totalFiles
operator|=
name|totalFiles
expr_stmt|;
block|}
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"nls"
argument_list|)
specifier|private
name|Operator
name|genBucketingSortingDest
parameter_list|(
name|String
name|dest
parameter_list|,
name|Operator
name|input
parameter_list|,
name|QB
name|qb
parameter_list|,
name|TableDesc
name|table_desc
parameter_list|,
name|Table
name|dest_tab
parameter_list|,
name|SortBucketRSCtx
name|ctx
parameter_list|)
throws|throws
name|SemanticException
block|{
comment|// If the table is bucketed, and bucketing is enforced, do the following:
comment|// If the number of buckets is smaller than the number of maximum reducers,
comment|// create those many reducers.
comment|// If not, create a multiFileSink instead of FileSink - the multiFileSink will
comment|// spray the data into multiple buckets. That way, we can support a very large
comment|// number of buckets without needing a very large number of reducers.
name|boolean
name|enforceBucketing
init|=
literal|false
decl_stmt|;
name|boolean
name|enforceSorting
init|=
literal|false
decl_stmt|;
name|ArrayList
argument_list|<
name|ExprNodeDesc
argument_list|>
name|partnCols
init|=
operator|new
name|ArrayList
argument_list|<
name|ExprNodeDesc
argument_list|>
argument_list|()
decl_stmt|;
name|ArrayList
argument_list|<
name|ExprNodeDesc
argument_list|>
name|partnColsNoConvert
init|=
operator|new
name|ArrayList
argument_list|<
name|ExprNodeDesc
argument_list|>
argument_list|()
decl_stmt|;
name|ArrayList
argument_list|<
name|ExprNodeDesc
argument_list|>
name|sortCols
init|=
operator|new
name|ArrayList
argument_list|<
name|ExprNodeDesc
argument_list|>
argument_list|()
decl_stmt|;
name|ArrayList
argument_list|<
name|Integer
argument_list|>
name|sortOrders
init|=
operator|new
name|ArrayList
argument_list|<
name|Integer
argument_list|>
argument_list|()
decl_stmt|;
name|boolean
name|multiFileSpray
init|=
literal|false
decl_stmt|;
name|int
name|numFiles
init|=
literal|1
decl_stmt|;
name|int
name|totalFiles
init|=
literal|1
decl_stmt|;
if|if
condition|(
operator|(
name|dest_tab
operator|.
name|getNumBuckets
argument_list|()
operator|>
literal|0
operator|)
operator|&&
operator|(
name|conf
operator|.
name|getBoolVar
argument_list|(
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVEENFORCEBUCKETING
argument_list|)
operator|)
condition|)
block|{
name|enforceBucketing
operator|=
literal|true
expr_stmt|;
name|partnCols
operator|=
name|getParitionColsFromBucketCols
argument_list|(
name|dest
argument_list|,
name|qb
argument_list|,
name|dest_tab
argument_list|,
name|table_desc
argument_list|,
name|input
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|partnColsNoConvert
operator|=
name|getParitionColsFromBucketCols
argument_list|(
name|dest
argument_list|,
name|qb
argument_list|,
name|dest_tab
argument_list|,
name|table_desc
argument_list|,
name|input
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|dest_tab
operator|.
name|getSortCols
argument_list|()
operator|!=
literal|null
operator|)
operator|&&
operator|(
name|dest_tab
operator|.
name|getSortCols
argument_list|()
operator|.
name|size
argument_list|()
operator|>
literal|0
operator|)
operator|&&
operator|(
name|conf
operator|.
name|getBoolVar
argument_list|(
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVEENFORCESORTING
argument_list|)
operator|)
condition|)
block|{
name|enforceSorting
operator|=
literal|true
expr_stmt|;
name|sortCols
operator|=
name|getSortCols
argument_list|(
name|dest
argument_list|,
name|qb
argument_list|,
name|dest_tab
argument_list|,
name|table_desc
argument_list|,
name|input
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|sortOrders
operator|=
name|getSortOrders
argument_list|(
name|dest
argument_list|,
name|qb
argument_list|,
name|dest_tab
argument_list|,
name|input
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|enforceBucketing
condition|)
block|{
name|partnCols
operator|=
name|sortCols
expr_stmt|;
name|partnColsNoConvert
operator|=
name|getSortCols
argument_list|(
name|dest
argument_list|,
name|qb
argument_list|,
name|dest_tab
argument_list|,
name|table_desc
argument_list|,
name|input
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|enforceBucketing
operator|||
name|enforceSorting
condition|)
block|{
name|int
name|maxReducers
init|=
name|conf
operator|.
name|getIntVar
argument_list|(
name|HiveConf
operator|.
name|ConfVars
operator|.
name|MAXREDUCERS
argument_list|)
decl_stmt|;
if|if
condition|(
name|conf
operator|.
name|getIntVar
argument_list|(
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HADOOPNUMREDUCERS
argument_list|)
operator|>
literal|0
condition|)
block|{
name|maxReducers
operator|=
name|conf
operator|.
name|getIntVar
argument_list|(
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HADOOPNUMREDUCERS
argument_list|)
expr_stmt|;
block|}
name|int
name|numBuckets
init|=
name|dest_tab
operator|.
name|getNumBuckets
argument_list|()
decl_stmt|;
if|if
condition|(
name|numBuckets
operator|>
name|maxReducers
condition|)
block|{
name|multiFileSpray
operator|=
literal|true
expr_stmt|;
name|totalFiles
operator|=
name|numBuckets
expr_stmt|;
if|if
condition|(
name|totalFiles
operator|%
name|maxReducers
operator|==
literal|0
condition|)
block|{
name|numFiles
operator|=
name|totalFiles
operator|/
name|maxReducers
expr_stmt|;
block|}
else|else
block|{
comment|// find the number of reducers such that it is a divisor of totalFiles
name|maxReducers
operator|=
name|getReducersBucketing
argument_list|(
name|totalFiles
argument_list|,
name|maxReducers
argument_list|)
expr_stmt|;
name|numFiles
operator|=
name|totalFiles
operator|/
name|maxReducers
expr_stmt|;
block|}
block|}
else|else
block|{
name|maxReducers
operator|=
name|numBuckets
expr_stmt|;
block|}
name|input
operator|=
name|genReduceSinkPlanForSortingBucketing
argument_list|(
name|dest_tab
argument_list|,
name|input
argument_list|,
name|sortCols
argument_list|,
name|sortOrders
argument_list|,
name|partnCols
argument_list|,
name|maxReducers
argument_list|)
expr_stmt|;
name|ctx
operator|.
name|setMultiFileSpray
argument_list|(
name|multiFileSpray
argument_list|)
expr_stmt|;
name|ctx
operator|.
name|setNumFiles
argument_list|(
name|numFiles
argument_list|)
expr_stmt|;
name|ctx
operator|.
name|setPartnCols
argument_list|(
name|partnColsNoConvert
argument_list|)
expr_stmt|;
name|ctx
operator|.
name|setTotalFiles
argument_list|(
name|totalFiles
argument_list|)
expr_stmt|;
block|}
return|return
name|input
return|;
block|}
comment|/**    * Check for HOLD_DDLTIME hint.    *    * @param qb    * @return true if HOLD_DDLTIME is set, false otherwise.    */
specifier|private
name|boolean
name|checkHoldDDLTime
parameter_list|(
name|QB
name|qb
parameter_list|)
block|{
name|ASTNode
name|hints
init|=
name|qb
operator|.
name|getParseInfo
argument_list|()
operator|.
name|getHints
argument_list|()
decl_stmt|;
if|if
condition|(
name|hints
operator|==
literal|null
condition|)
block|{
return|return
literal|false
return|;
block|}
for|for
control|(
name|int
name|pos
init|=
literal|0
init|;
name|pos
operator|<
name|hints
operator|.
name|getChildCount
argument_list|()
condition|;
name|pos
operator|++
control|)
block|{
name|ASTNode
name|hint
init|=
operator|(
name|ASTNode
operator|)
name|hints
operator|.
name|getChild
argument_list|(
name|pos
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
operator|(
name|ASTNode
operator|)
name|hint
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|)
operator|.
name|getToken
argument_list|()
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_HOLD_DDLTIME
condition|)
block|{
return|return
literal|true
return|;
block|}
block|}
return|return
literal|false
return|;
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"nls"
argument_list|)
specifier|private
name|Operator
name|genFileSinkPlan
parameter_list|(
name|String
name|dest
parameter_list|,
name|QB
name|qb
parameter_list|,
name|Operator
name|input
parameter_list|)
throws|throws
name|SemanticException
block|{
name|RowResolver
name|inputRR
init|=
name|opParseCtx
operator|.
name|get
argument_list|(
name|input
argument_list|)
operator|.
name|getRowResolver
argument_list|()
decl_stmt|;
name|QBMetaData
name|qbm
init|=
name|qb
operator|.
name|getMetaData
argument_list|()
decl_stmt|;
name|Integer
name|dest_type
init|=
name|qbm
operator|.
name|getDestTypeForAlias
argument_list|(
name|dest
argument_list|)
decl_stmt|;
name|Table
name|dest_tab
init|=
literal|null
decl_stmt|;
comment|// destination table if any
name|Partition
name|dest_part
init|=
literal|null
decl_stmt|;
comment|// destination partition if any
name|String
name|queryTmpdir
init|=
literal|null
decl_stmt|;
comment|// the intermediate destination directory
name|Path
name|dest_path
init|=
literal|null
decl_stmt|;
comment|// the final destination directory
name|TableDesc
name|table_desc
init|=
literal|null
decl_stmt|;
name|int
name|currentTableId
init|=
literal|0
decl_stmt|;
name|boolean
name|isLocal
init|=
literal|false
decl_stmt|;
name|SortBucketRSCtx
name|rsCtx
init|=
operator|new
name|SortBucketRSCtx
argument_list|()
decl_stmt|;
name|DynamicPartitionCtx
name|dpCtx
init|=
literal|null
decl_stmt|;
name|LoadTableDesc
name|ltd
init|=
literal|null
decl_stmt|;
name|boolean
name|holdDDLTime
init|=
name|checkHoldDDLTime
argument_list|(
name|qb
argument_list|)
decl_stmt|;
name|ListBucketingCtx
name|lbCtx
init|=
literal|null
decl_stmt|;
switch|switch
condition|(
name|dest_type
operator|.
name|intValue
argument_list|()
condition|)
block|{
case|case
name|QBMetaData
operator|.
name|DEST_TABLE
case|:
block|{
name|dest_tab
operator|=
name|qbm
operator|.
name|getDestTableForAlias
argument_list|(
name|dest
argument_list|)
expr_stmt|;
comment|// Is the user trying to insert into a external tables
if|if
condition|(
operator|(
operator|!
name|conf
operator|.
name|getBoolVar
argument_list|(
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVE_INSERT_INTO_EXTERNAL_TABLES
argument_list|)
operator|)
operator|&&
operator|(
name|dest_tab
operator|.
name|getTableType
argument_list|()
operator|.
name|equals
argument_list|(
name|TableType
operator|.
name|EXTERNAL_TABLE
argument_list|)
operator|)
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|INSERT_EXTERNAL_TABLE
operator|.
name|getMsg
argument_list|(
name|dest_tab
operator|.
name|getTableName
argument_list|()
argument_list|)
argument_list|)
throw|;
block|}
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|partSpec
init|=
name|qbm
operator|.
name|getPartSpecForAlias
argument_list|(
name|dest
argument_list|)
decl_stmt|;
name|dest_path
operator|=
name|dest_tab
operator|.
name|getPath
argument_list|()
expr_stmt|;
comment|// check for partition
name|List
argument_list|<
name|FieldSchema
argument_list|>
name|parts
init|=
name|dest_tab
operator|.
name|getPartitionKeys
argument_list|()
decl_stmt|;
if|if
condition|(
name|parts
operator|!=
literal|null
operator|&&
name|parts
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
comment|// table is partitioned
if|if
condition|(
name|partSpec
operator|==
literal|null
operator|||
name|partSpec
operator|.
name|size
argument_list|()
operator|==
literal|0
condition|)
block|{
comment|// user did NOT specify partition
throw|throw
operator|new
name|SemanticException
argument_list|(
name|generateErrorMessage
argument_list|(
name|qb
operator|.
name|getParseInfo
argument_list|()
operator|.
name|getDestForClause
argument_list|(
name|dest
argument_list|)
argument_list|,
name|ErrorMsg
operator|.
name|NEED_PARTITION_ERROR
operator|.
name|getMsg
argument_list|()
argument_list|)
argument_list|)
throw|;
block|}
comment|// the HOLD_DDLTIIME hint should not be used with dynamic partition since the
comment|// newly generated partitions should always update their DDLTIME
if|if
condition|(
name|holdDDLTime
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|generateErrorMessage
argument_list|(
name|qb
operator|.
name|getParseInfo
argument_list|()
operator|.
name|getDestForClause
argument_list|(
name|dest
argument_list|)
argument_list|,
name|ErrorMsg
operator|.
name|HOLD_DDLTIME_ON_NONEXIST_PARTITIONS
operator|.
name|getMsg
argument_list|()
argument_list|)
argument_list|)
throw|;
block|}
name|dpCtx
operator|=
name|qbm
operator|.
name|getDPCtx
argument_list|(
name|dest
argument_list|)
expr_stmt|;
if|if
condition|(
name|dpCtx
operator|==
literal|null
condition|)
block|{
name|Utilities
operator|.
name|validatePartSpecColumnNames
argument_list|(
name|dest_tab
argument_list|,
name|partSpec
argument_list|)
expr_stmt|;
name|dpCtx
operator|=
operator|new
name|DynamicPartitionCtx
argument_list|(
name|dest_tab
argument_list|,
name|partSpec
argument_list|,
name|conf
operator|.
name|getVar
argument_list|(
name|HiveConf
operator|.
name|ConfVars
operator|.
name|DEFAULTPARTITIONNAME
argument_list|)
argument_list|,
name|conf
operator|.
name|getIntVar
argument_list|(
name|HiveConf
operator|.
name|ConfVars
operator|.
name|DYNAMICPARTITIONMAXPARTSPERNODE
argument_list|)
argument_list|)
expr_stmt|;
name|qbm
operator|.
name|setDPCtx
argument_list|(
name|dest
argument_list|,
name|dpCtx
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|HiveConf
operator|.
name|getBoolVar
argument_list|(
name|conf
argument_list|,
name|HiveConf
operator|.
name|ConfVars
operator|.
name|DYNAMICPARTITIONING
argument_list|)
condition|)
block|{
comment|// allow DP
throw|throw
operator|new
name|SemanticException
argument_list|(
name|generateErrorMessage
argument_list|(
name|qb
operator|.
name|getParseInfo
argument_list|()
operator|.
name|getDestForClause
argument_list|(
name|dest
argument_list|)
argument_list|,
name|ErrorMsg
operator|.
name|DYNAMIC_PARTITION_DISABLED
operator|.
name|getMsg
argument_list|()
argument_list|)
argument_list|)
throw|;
block|}
if|if
condition|(
name|dpCtx
operator|.
name|getSPPath
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|dest_path
operator|=
operator|new
name|Path
argument_list|(
name|dest_tab
operator|.
name|getPath
argument_list|()
argument_list|,
name|dpCtx
operator|.
name|getSPPath
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|dest_tab
operator|.
name|getNumBuckets
argument_list|()
operator|>
literal|0
operator|)
operator|&&
operator|(
name|conf
operator|.
name|getBoolVar
argument_list|(
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVEENFORCEBUCKETING
argument_list|)
operator|)
condition|)
block|{
name|dpCtx
operator|.
name|setNumBuckets
argument_list|(
name|dest_tab
operator|.
name|getNumBuckets
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
name|boolean
name|isNonNativeTable
init|=
name|dest_tab
operator|.
name|isNonNative
argument_list|()
decl_stmt|;
if|if
condition|(
name|isNonNativeTable
condition|)
block|{
name|queryTmpdir
operator|=
name|dest_path
operator|.
name|toUri
argument_list|()
operator|.
name|getPath
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|queryTmpdir
operator|=
name|ctx
operator|.
name|getExternalTmpFileURI
argument_list|(
name|dest_path
operator|.
name|toUri
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|dpCtx
operator|!=
literal|null
condition|)
block|{
comment|// set the root of the temporay path where dynamic partition columns will populate
name|dpCtx
operator|.
name|setRootPath
argument_list|(
name|queryTmpdir
argument_list|)
expr_stmt|;
block|}
comment|// this table_desc does not contain the partitioning columns
name|table_desc
operator|=
name|Utilities
operator|.
name|getTableDesc
argument_list|(
name|dest_tab
argument_list|)
expr_stmt|;
comment|// Add sorting/bucketing if needed
name|input
operator|=
name|genBucketingSortingDest
argument_list|(
name|dest
argument_list|,
name|input
argument_list|,
name|qb
argument_list|,
name|table_desc
argument_list|,
name|dest_tab
argument_list|,
name|rsCtx
argument_list|)
expr_stmt|;
name|idToTableNameMap
operator|.
name|put
argument_list|(
name|String
operator|.
name|valueOf
argument_list|(
name|destTableId
argument_list|)
argument_list|,
name|dest_tab
operator|.
name|getTableName
argument_list|()
argument_list|)
expr_stmt|;
name|currentTableId
operator|=
name|destTableId
expr_stmt|;
name|destTableId
operator|++
expr_stmt|;
name|lbCtx
operator|=
name|constructListBucketingCtx
argument_list|(
name|dest_tab
operator|.
name|getSkewedColNames
argument_list|()
argument_list|,
name|dest_tab
operator|.
name|getSkewedColValues
argument_list|()
argument_list|,
name|dest_tab
operator|.
name|getSkewedColValueLocationMaps
argument_list|()
argument_list|,
name|dest_tab
operator|.
name|isStoredAsSubDirectories
argument_list|()
argument_list|,
name|conf
argument_list|)
expr_stmt|;
comment|// Create the work for moving the table
comment|// NOTE: specify Dynamic partitions in dest_tab for WriteEntity
if|if
condition|(
operator|!
name|isNonNativeTable
condition|)
block|{
name|ltd
operator|=
operator|new
name|LoadTableDesc
argument_list|(
operator|new
name|Path
argument_list|(
name|queryTmpdir
argument_list|)
argument_list|,
name|ctx
operator|.
name|getExternalTmpFileURI
argument_list|(
name|dest_path
operator|.
name|toUri
argument_list|()
argument_list|)
argument_list|,
name|table_desc
argument_list|,
name|dpCtx
argument_list|)
expr_stmt|;
name|ltd
operator|.
name|setReplace
argument_list|(
operator|!
name|qb
operator|.
name|getParseInfo
argument_list|()
operator|.
name|isInsertIntoTable
argument_list|(
name|dest_tab
operator|.
name|getDbName
argument_list|()
argument_list|,
name|dest_tab
operator|.
name|getTableName
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|ltd
operator|.
name|setLbCtx
argument_list|(
name|lbCtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|holdDDLTime
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"this query will not update transient_lastDdlTime!"
argument_list|)
expr_stmt|;
name|ltd
operator|.
name|setHoldDDLTime
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
name|loadTableWork
operator|.
name|add
argument_list|(
name|ltd
argument_list|)
expr_stmt|;
block|}
name|WriteEntity
name|output
init|=
literal|null
decl_stmt|;
comment|// Here only register the whole table for post-exec hook if no DP present
comment|// in the case of DP, we will register WriteEntity in MoveTask when the
comment|// list of dynamically created partitions are known.
if|if
condition|(
operator|(
name|dpCtx
operator|==
literal|null
operator|||
name|dpCtx
operator|.
name|getNumDPCols
argument_list|()
operator|==
literal|0
operator|)
condition|)
block|{
name|output
operator|=
operator|new
name|WriteEntity
argument_list|(
name|dest_tab
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|outputs
operator|.
name|add
argument_list|(
name|output
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|OUTPUT_SPECIFIED_MULTIPLE_TIMES
operator|.
name|getMsg
argument_list|(
name|dest_tab
operator|.
name|getTableName
argument_list|()
argument_list|)
argument_list|)
throw|;
block|}
block|}
if|if
condition|(
operator|(
name|dpCtx
operator|!=
literal|null
operator|)
operator|&&
operator|(
name|dpCtx
operator|.
name|getNumDPCols
argument_list|()
operator|>=
literal|0
operator|)
condition|)
block|{
comment|// No static partition specified
if|if
condition|(
name|dpCtx
operator|.
name|getNumSPCols
argument_list|()
operator|==
literal|0
condition|)
block|{
name|output
operator|=
operator|new
name|WriteEntity
argument_list|(
name|dest_tab
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|outputs
operator|.
name|add
argument_list|(
name|output
argument_list|)
expr_stmt|;
block|}
comment|// part of the partition specified
comment|// Create a DummyPartition in this case. Since, the metastore does not store partial
comment|// partitions currently, we need to store dummy partitions
else|else
block|{
try|try
block|{
name|String
name|ppath
init|=
name|dpCtx
operator|.
name|getSPPath
argument_list|()
decl_stmt|;
name|ppath
operator|=
name|ppath
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|ppath
operator|.
name|length
argument_list|()
operator|-
literal|1
argument_list|)
expr_stmt|;
name|DummyPartition
name|p
init|=
operator|new
name|DummyPartition
argument_list|(
name|dest_tab
argument_list|,
name|dest_tab
operator|.
name|getDbName
argument_list|()
operator|+
literal|"@"
operator|+
name|dest_tab
operator|.
name|getTableName
argument_list|()
operator|+
literal|"@"
operator|+
name|ppath
argument_list|,
name|partSpec
argument_list|)
decl_stmt|;
name|output
operator|=
operator|new
name|WriteEntity
argument_list|(
name|p
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|outputs
operator|.
name|add
argument_list|(
name|output
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|HiveException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|e
operator|.
name|getMessage
argument_list|()
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
block|}
name|ctx
operator|.
name|getLoadTableOutputMap
argument_list|()
operator|.
name|put
argument_list|(
name|ltd
argument_list|,
name|output
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|QBMetaData
operator|.
name|DEST_PARTITION
case|:
block|{
name|dest_part
operator|=
name|qbm
operator|.
name|getDestPartitionForAlias
argument_list|(
name|dest
argument_list|)
expr_stmt|;
name|dest_tab
operator|=
name|dest_part
operator|.
name|getTable
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
operator|!
name|conf
operator|.
name|getBoolVar
argument_list|(
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVE_INSERT_INTO_EXTERNAL_TABLES
argument_list|)
operator|)
operator|&&
name|dest_tab
operator|.
name|getTableType
argument_list|()
operator|.
name|equals
argument_list|(
name|TableType
operator|.
name|EXTERNAL_TABLE
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|INSERT_EXTERNAL_TABLE
operator|.
name|getMsg
argument_list|(
name|dest_tab
operator|.
name|getTableName
argument_list|()
argument_list|)
argument_list|)
throw|;
block|}
name|Path
name|tabPath
init|=
name|dest_tab
operator|.
name|getPath
argument_list|()
decl_stmt|;
name|Path
name|partPath
init|=
name|dest_part
operator|.
name|getPartitionPath
argument_list|()
decl_stmt|;
comment|// if the table is in a different dfs than the partition,
comment|// replace the partition's dfs with the table's dfs.
name|dest_path
operator|=
operator|new
name|Path
argument_list|(
name|tabPath
operator|.
name|toUri
argument_list|()
operator|.
name|getScheme
argument_list|()
argument_list|,
name|tabPath
operator|.
name|toUri
argument_list|()
operator|.
name|getAuthority
argument_list|()
argument_list|,
name|partPath
operator|.
name|toUri
argument_list|()
operator|.
name|getPath
argument_list|()
argument_list|)
expr_stmt|;
name|queryTmpdir
operator|=
name|ctx
operator|.
name|getExternalTmpFileURI
argument_list|(
name|dest_path
operator|.
name|toUri
argument_list|()
argument_list|)
expr_stmt|;
name|table_desc
operator|=
name|Utilities
operator|.
name|getTableDesc
argument_list|(
name|dest_tab
argument_list|)
expr_stmt|;
comment|// Add sorting/bucketing if needed
name|input
operator|=
name|genBucketingSortingDest
argument_list|(
name|dest
argument_list|,
name|input
argument_list|,
name|qb
argument_list|,
name|table_desc
argument_list|,
name|dest_tab
argument_list|,
name|rsCtx
argument_list|)
expr_stmt|;
name|idToTableNameMap
operator|.
name|put
argument_list|(
name|String
operator|.
name|valueOf
argument_list|(
name|destTableId
argument_list|)
argument_list|,
name|dest_tab
operator|.
name|getTableName
argument_list|()
argument_list|)
expr_stmt|;
name|currentTableId
operator|=
name|destTableId
expr_stmt|;
name|destTableId
operator|++
expr_stmt|;
name|lbCtx
operator|=
name|constructListBucketingCtx
argument_list|(
name|dest_part
operator|.
name|getSkewedColNames
argument_list|()
argument_list|,
name|dest_part
operator|.
name|getSkewedColValues
argument_list|()
argument_list|,
name|dest_part
operator|.
name|getSkewedColValueLocationMaps
argument_list|()
argument_list|,
name|dest_part
operator|.
name|isStoredAsSubDirectories
argument_list|()
argument_list|,
name|conf
argument_list|)
expr_stmt|;
name|ltd
operator|=
operator|new
name|LoadTableDesc
argument_list|(
operator|new
name|Path
argument_list|(
name|queryTmpdir
argument_list|)
argument_list|,
name|ctx
operator|.
name|getExternalTmpFileURI
argument_list|(
name|dest_path
operator|.
name|toUri
argument_list|()
argument_list|)
argument_list|,
name|table_desc
argument_list|,
name|dest_part
operator|.
name|getSpec
argument_list|()
argument_list|)
expr_stmt|;
name|ltd
operator|.
name|setReplace
argument_list|(
operator|!
name|qb
operator|.
name|getParseInfo
argument_list|()
operator|.
name|isInsertIntoTable
argument_list|(
name|dest_tab
operator|.
name|getDbName
argument_list|()
argument_list|,
name|dest_tab
operator|.
name|getTableName
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|ltd
operator|.
name|setLbCtx
argument_list|(
name|lbCtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|holdDDLTime
condition|)
block|{
try|try
block|{
name|Partition
name|part
init|=
name|db
operator|.
name|getPartition
argument_list|(
name|dest_tab
argument_list|,
name|dest_part
operator|.
name|getSpec
argument_list|()
argument_list|,
literal|false
argument_list|)
decl_stmt|;
if|if
condition|(
name|part
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|generateErrorMessage
argument_list|(
name|qb
operator|.
name|getParseInfo
argument_list|()
operator|.
name|getDestForClause
argument_list|(
name|dest
argument_list|)
argument_list|,
name|ErrorMsg
operator|.
name|HOLD_DDLTIME_ON_NONEXIST_PARTITIONS
operator|.
name|getMsg
argument_list|()
argument_list|)
argument_list|)
throw|;
block|}
block|}
catch|catch
parameter_list|(
name|HiveException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|e
argument_list|)
throw|;
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"this query will not update transient_lastDdlTime!"
argument_list|)
expr_stmt|;
name|ltd
operator|.
name|setHoldDDLTime
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
name|loadTableWork
operator|.
name|add
argument_list|(
name|ltd
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|outputs
operator|.
name|add
argument_list|(
operator|new
name|WriteEntity
argument_list|(
name|dest_part
argument_list|)
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|OUTPUT_SPECIFIED_MULTIPLE_TIMES
operator|.
name|getMsg
argument_list|(
name|dest_tab
operator|.
name|getTableName
argument_list|()
operator|+
literal|"@"
operator|+
name|dest_part
operator|.
name|getName
argument_list|()
argument_list|)
argument_list|)
throw|;
block|}
break|break;
block|}
case|case
name|QBMetaData
operator|.
name|DEST_LOCAL_FILE
case|:
name|isLocal
operator|=
literal|true
expr_stmt|;
comment|// fall through
case|case
name|QBMetaData
operator|.
name|DEST_DFS_FILE
case|:
block|{
name|dest_path
operator|=
operator|new
name|Path
argument_list|(
name|qbm
operator|.
name|getDestFileForAlias
argument_list|(
name|dest
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|isLocal
condition|)
block|{
comment|// for local directory - we always write to map-red intermediate
comment|// store and then copy to local fs
name|queryTmpdir
operator|=
name|ctx
operator|.
name|getMRTmpFileURI
argument_list|()
expr_stmt|;
block|}
else|else
block|{
comment|// otherwise write to the file system implied by the directory
comment|// no copy is required. we may want to revisit this policy in future
try|try
block|{
name|Path
name|qPath
init|=
name|FileUtils
operator|.
name|makeQualified
argument_list|(
name|dest_path
argument_list|,
name|conf
argument_list|)
decl_stmt|;
name|queryTmpdir
operator|=
name|ctx
operator|.
name|getExternalTmpFileURI
argument_list|(
name|qPath
operator|.
name|toUri
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
literal|"Error creating temporary folder on: "
operator|+
name|dest_path
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
name|String
name|cols
init|=
literal|""
decl_stmt|;
name|String
name|colTypes
init|=
literal|""
decl_stmt|;
name|ArrayList
argument_list|<
name|ColumnInfo
argument_list|>
name|colInfos
init|=
name|inputRR
operator|.
name|getColumnInfos
argument_list|()
decl_stmt|;
comment|// CTAS case: the file output format and serde are defined by the create
comment|// table command
comment|// rather than taking the default value
name|List
argument_list|<
name|FieldSchema
argument_list|>
name|field_schemas
init|=
literal|null
decl_stmt|;
name|CreateTableDesc
name|tblDesc
init|=
name|qb
operator|.
name|getTableDesc
argument_list|()
decl_stmt|;
if|if
condition|(
name|tblDesc
operator|!=
literal|null
condition|)
block|{
name|field_schemas
operator|=
operator|new
name|ArrayList
argument_list|<
name|FieldSchema
argument_list|>
argument_list|()
expr_stmt|;
block|}
name|boolean
name|first
init|=
literal|true
decl_stmt|;
for|for
control|(
name|ColumnInfo
name|colInfo
range|:
name|colInfos
control|)
block|{
name|String
index|[]
name|nm
init|=
name|inputRR
operator|.
name|reverseLookup
argument_list|(
name|colInfo
operator|.
name|getInternalName
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|nm
index|[
literal|1
index|]
operator|!=
literal|null
condition|)
block|{
comment|// non-null column alias
name|colInfo
operator|.
name|setAlias
argument_list|(
name|nm
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|field_schemas
operator|!=
literal|null
condition|)
block|{
name|FieldSchema
name|col
init|=
operator|new
name|FieldSchema
argument_list|()
decl_stmt|;
if|if
condition|(
literal|""
operator|.
name|equals
argument_list|(
name|nm
index|[
literal|0
index|]
argument_list|)
operator|||
name|nm
index|[
literal|1
index|]
operator|==
literal|null
condition|)
block|{
comment|// ast expression is not a valid column name for table
name|col
operator|.
name|setName
argument_list|(
name|colInfo
operator|.
name|getInternalName
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|col
operator|.
name|setName
argument_list|(
name|unescapeIdentifier
argument_list|(
name|colInfo
operator|.
name|getAlias
argument_list|()
argument_list|)
operator|.
name|toLowerCase
argument_list|()
argument_list|)
expr_stmt|;
comment|// remove ``
block|}
name|col
operator|.
name|setType
argument_list|(
name|colInfo
operator|.
name|getType
argument_list|()
operator|.
name|getTypeName
argument_list|()
argument_list|)
expr_stmt|;
name|field_schemas
operator|.
name|add
argument_list|(
name|col
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|first
condition|)
block|{
name|cols
operator|=
name|cols
operator|.
name|concat
argument_list|(
literal|","
argument_list|)
expr_stmt|;
name|colTypes
operator|=
name|colTypes
operator|.
name|concat
argument_list|(
literal|":"
argument_list|)
expr_stmt|;
block|}
name|first
operator|=
literal|false
expr_stmt|;
name|cols
operator|=
name|cols
operator|.
name|concat
argument_list|(
name|colInfo
operator|.
name|getInternalName
argument_list|()
argument_list|)
expr_stmt|;
comment|// Replace VOID type with string when the output is a temp table or
comment|// local files.
comment|// A VOID type can be generated under the query:
comment|//
comment|// select NULL from tt;
comment|// or
comment|// insert overwrite local directory "abc" select NULL from tt;
comment|//
comment|// where there is no column type to which the NULL value should be
comment|// converted.
comment|//
name|String
name|tName
init|=
name|colInfo
operator|.
name|getType
argument_list|()
operator|.
name|getTypeName
argument_list|()
decl_stmt|;
if|if
condition|(
name|tName
operator|.
name|equals
argument_list|(
name|serdeConstants
operator|.
name|VOID_TYPE_NAME
argument_list|)
condition|)
block|{
name|colTypes
operator|=
name|colTypes
operator|.
name|concat
argument_list|(
name|serdeConstants
operator|.
name|STRING_TYPE_NAME
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|colTypes
operator|=
name|colTypes
operator|.
name|concat
argument_list|(
name|tName
argument_list|)
expr_stmt|;
block|}
block|}
comment|// update the create table descriptor with the resulting schema.
if|if
condition|(
name|tblDesc
operator|!=
literal|null
condition|)
block|{
name|tblDesc
operator|.
name|setCols
argument_list|(
operator|new
name|ArrayList
argument_list|<
name|FieldSchema
argument_list|>
argument_list|(
name|field_schemas
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|ctx
operator|.
name|isMRTmpFileURI
argument_list|(
name|dest_path
operator|.
name|toUri
argument_list|()
operator|.
name|toString
argument_list|()
argument_list|)
condition|)
block|{
name|idToTableNameMap
operator|.
name|put
argument_list|(
name|String
operator|.
name|valueOf
argument_list|(
name|destTableId
argument_list|)
argument_list|,
name|dest_path
operator|.
name|toUri
argument_list|()
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|currentTableId
operator|=
name|destTableId
expr_stmt|;
name|destTableId
operator|++
expr_stmt|;
block|}
name|boolean
name|isDfsDir
init|=
operator|(
name|dest_type
operator|.
name|intValue
argument_list|()
operator|==
name|QBMetaData
operator|.
name|DEST_DFS_FILE
operator|)
decl_stmt|;
name|loadFileWork
operator|.
name|add
argument_list|(
operator|new
name|LoadFileDesc
argument_list|(
name|tblDesc
argument_list|,
operator|new
name|Path
argument_list|(
name|queryTmpdir
argument_list|)
argument_list|,
name|dest_path
argument_list|,
name|isDfsDir
argument_list|,
name|cols
argument_list|,
name|colTypes
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|tblDesc
operator|==
literal|null
condition|)
block|{
if|if
condition|(
name|qb
operator|.
name|getIsQuery
argument_list|()
condition|)
block|{
name|String
name|fileFormat
init|=
name|HiveConf
operator|.
name|getVar
argument_list|(
name|conf
argument_list|,
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVEQUERYRESULTFILEFORMAT
argument_list|)
decl_stmt|;
name|table_desc
operator|=
name|PlanUtils
operator|.
name|getDefaultQueryOutputTableDesc
argument_list|(
name|cols
argument_list|,
name|colTypes
argument_list|,
name|fileFormat
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|table_desc
operator|=
name|PlanUtils
operator|.
name|getDefaultTableDesc
argument_list|(
name|qb
operator|.
name|getLLocalDirectoryDesc
argument_list|()
argument_list|,
name|cols
argument_list|,
name|colTypes
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|table_desc
operator|=
name|PlanUtils
operator|.
name|getTableDesc
argument_list|(
name|tblDesc
argument_list|,
name|cols
argument_list|,
name|colTypes
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|outputs
operator|.
name|add
argument_list|(
operator|new
name|WriteEntity
argument_list|(
name|dest_path
argument_list|,
operator|!
name|isDfsDir
argument_list|)
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|OUTPUT_SPECIFIED_MULTIPLE_TIMES
operator|.
name|getMsg
argument_list|(
name|dest_path
operator|.
name|toUri
argument_list|()
operator|.
name|toString
argument_list|()
argument_list|)
argument_list|)
throw|;
block|}
break|break;
block|}
default|default:
throw|throw
operator|new
name|SemanticException
argument_list|(
literal|"Unknown destination type: "
operator|+
name|dest_type
argument_list|)
throw|;
block|}
name|input
operator|=
name|genConversionSelectOperator
argument_list|(
name|dest
argument_list|,
name|qb
argument_list|,
name|input
argument_list|,
name|table_desc
argument_list|,
name|dpCtx
argument_list|)
expr_stmt|;
name|inputRR
operator|=
name|opParseCtx
operator|.
name|get
argument_list|(
name|input
argument_list|)
operator|.
name|getRowResolver
argument_list|()
expr_stmt|;
name|ArrayList
argument_list|<
name|ColumnInfo
argument_list|>
name|vecCol
init|=
operator|new
name|ArrayList
argument_list|<
name|ColumnInfo
argument_list|>
argument_list|()
decl_stmt|;
try|try
block|{
name|StructObjectInspector
name|rowObjectInspector
init|=
operator|(
name|StructObjectInspector
operator|)
name|table_desc
operator|.
name|getDeserializer
argument_list|()
operator|.
name|getObjectInspector
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|?
extends|extends
name|StructField
argument_list|>
name|fields
init|=
name|rowObjectInspector
operator|.
name|getAllStructFieldRefs
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|fields
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|vecCol
operator|.
name|add
argument_list|(
operator|new
name|ColumnInfo
argument_list|(
name|fields
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|getFieldName
argument_list|()
argument_list|,
name|TypeInfoUtils
operator|.
name|getTypeInfoFromObjectInspector
argument_list|(
name|fields
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|getFieldObjectInspector
argument_list|()
argument_list|)
argument_list|,
literal|""
argument_list|,
literal|false
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|e
operator|.
name|getMessage
argument_list|()
argument_list|,
name|e
argument_list|)
throw|;
block|}
name|RowSchema
name|fsRS
init|=
operator|new
name|RowSchema
argument_list|(
name|vecCol
argument_list|)
decl_stmt|;
comment|// The output files of a FileSink can be merged if they are either not being written to a table
comment|// or are being written to a table which is either not bucketed or enforce bucketing is not set
comment|// and table the table is either not sorted or enforce sorting is not set
name|boolean
name|canBeMerged
init|=
operator|(
name|dest_tab
operator|==
literal|null
operator|||
operator|!
operator|(
operator|(
name|dest_tab
operator|.
name|getNumBuckets
argument_list|()
operator|>
literal|0
operator|&&
name|conf
operator|.
name|getBoolVar
argument_list|(
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVEENFORCEBUCKETING
argument_list|)
operator|)
operator|||
operator|(
name|dest_tab
operator|.
name|getSortCols
argument_list|()
operator|!=
literal|null
operator|&&
name|dest_tab
operator|.
name|getSortCols
argument_list|()
operator|.
name|size
argument_list|()
operator|>
literal|0
operator|&&
name|conf
operator|.
name|getBoolVar
argument_list|(
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVEENFORCESORTING
argument_list|)
operator|)
operator|)
operator|)
decl_stmt|;
name|FileSinkDesc
name|fileSinkDesc
init|=
operator|new
name|FileSinkDesc
argument_list|(
name|queryTmpdir
argument_list|,
name|table_desc
argument_list|,
name|conf
operator|.
name|getBoolVar
argument_list|(
name|HiveConf
operator|.
name|ConfVars
operator|.
name|COMPRESSRESULT
argument_list|)
argument_list|,
name|currentTableId
argument_list|,
name|rsCtx
operator|.
name|isMultiFileSpray
argument_list|()
argument_list|,
name|canBeMerged
argument_list|,
name|rsCtx
operator|.
name|getNumFiles
argument_list|()
argument_list|,
name|rsCtx
operator|.
name|getTotalFiles
argument_list|()
argument_list|,
name|rsCtx
operator|.
name|getPartnCols
argument_list|()
argument_list|,
name|dpCtx
argument_list|)
decl_stmt|;
comment|/* Set List Bucketing context. */
if|if
condition|(
name|lbCtx
operator|!=
literal|null
condition|)
block|{
name|lbCtx
operator|.
name|processRowSkewedIndex
argument_list|(
name|fsRS
argument_list|)
expr_stmt|;
name|lbCtx
operator|.
name|calculateSkewedValueSubDirList
argument_list|()
expr_stmt|;
block|}
name|fileSinkDesc
operator|.
name|setLbCtx
argument_list|(
name|lbCtx
argument_list|)
expr_stmt|;
comment|// set it in plan instead of runtime in FileSinkOperator
name|fileSinkDesc
operator|.
name|setStatsCollectRawDataSize
argument_list|(
name|HiveConf
operator|.
name|getBoolVar
argument_list|(
name|conf
argument_list|,
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVE_STATS_COLLECT_RAWDATASIZE
argument_list|)
argument_list|)
expr_stmt|;
comment|// set the stats publishing/aggregating key prefix
comment|// the same as directory name. The directory name
comment|// can be changed in the optimizer but the key should not be changed
comment|// it should be the same as the MoveWork's sourceDir.
name|fileSinkDesc
operator|.
name|setStatsAggPrefix
argument_list|(
name|fileSinkDesc
operator|.
name|getDirName
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|dest_part
operator|!=
literal|null
condition|)
block|{
try|try
block|{
name|String
name|staticSpec
init|=
name|Warehouse
operator|.
name|makePartPath
argument_list|(
name|dest_part
operator|.
name|getSpec
argument_list|()
argument_list|)
decl_stmt|;
name|fileSinkDesc
operator|.
name|setStaticSpec
argument_list|(
name|staticSpec
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|MetaException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
elseif|else
if|if
condition|(
name|dpCtx
operator|!=
literal|null
condition|)
block|{
name|fileSinkDesc
operator|.
name|setStaticSpec
argument_list|(
name|dpCtx
operator|.
name|getSPPath
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|Operator
name|output
init|=
name|putOpInsertMap
argument_list|(
name|OperatorFactory
operator|.
name|getAndMakeChild
argument_list|(
name|fileSinkDesc
argument_list|,
name|fsRS
argument_list|,
name|input
argument_list|)
argument_list|,
name|inputRR
argument_list|)
decl_stmt|;
if|if
condition|(
name|ltd
operator|!=
literal|null
operator|&&
name|SessionState
operator|.
name|get
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|SessionState
operator|.
name|get
argument_list|()
operator|.
name|getLineageState
argument_list|()
operator|.
name|mapDirToFop
argument_list|(
name|ltd
operator|.
name|getSourceDir
argument_list|()
argument_list|,
operator|(
name|FileSinkOperator
operator|)
name|output
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Created FileSink Plan for clause: "
operator|+
name|dest
operator|+
literal|"dest_path: "
operator|+
name|dest_path
operator|+
literal|" row schema: "
operator|+
name|inputRR
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|fsopToTable
operator|.
name|put
argument_list|(
operator|(
name|FileSinkOperator
operator|)
name|output
argument_list|,
name|dest_tab
argument_list|)
expr_stmt|;
return|return
name|output
return|;
block|}
comment|/**    * Generate the conversion SelectOperator that converts the columns into the    * types that are expected by the table_desc.    */
name|Operator
name|genConversionSelectOperator
parameter_list|(
name|String
name|dest
parameter_list|,
name|QB
name|qb
parameter_list|,
name|Operator
name|input
parameter_list|,
name|TableDesc
name|table_desc
parameter_list|,
name|DynamicPartitionCtx
name|dpCtx
parameter_list|)
throws|throws
name|SemanticException
block|{
name|StructObjectInspector
name|oi
init|=
literal|null
decl_stmt|;
try|try
block|{
name|Deserializer
name|deserializer
init|=
name|table_desc
operator|.
name|getDeserializerClass
argument_list|()
operator|.
name|newInstance
argument_list|()
decl_stmt|;
name|deserializer
operator|.
name|initialize
argument_list|(
name|conf
argument_list|,
name|table_desc
operator|.
name|getProperties
argument_list|()
argument_list|)
expr_stmt|;
name|oi
operator|=
operator|(
name|StructObjectInspector
operator|)
name|deserializer
operator|.
name|getObjectInspector
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|e
argument_list|)
throw|;
block|}
comment|// Check column number
name|List
argument_list|<
name|?
extends|extends
name|StructField
argument_list|>
name|tableFields
init|=
name|oi
operator|.
name|getAllStructFieldRefs
argument_list|()
decl_stmt|;
name|boolean
name|dynPart
init|=
name|HiveConf
operator|.
name|getBoolVar
argument_list|(
name|conf
argument_list|,
name|HiveConf
operator|.
name|ConfVars
operator|.
name|DYNAMICPARTITIONING
argument_list|)
decl_stmt|;
name|ArrayList
argument_list|<
name|ColumnInfo
argument_list|>
name|rowFields
init|=
name|opParseCtx
operator|.
name|get
argument_list|(
name|input
argument_list|)
operator|.
name|getRowResolver
argument_list|()
operator|.
name|getColumnInfos
argument_list|()
decl_stmt|;
name|int
name|inColumnCnt
init|=
name|rowFields
operator|.
name|size
argument_list|()
decl_stmt|;
name|int
name|outColumnCnt
init|=
name|tableFields
operator|.
name|size
argument_list|()
decl_stmt|;
if|if
condition|(
name|dynPart
operator|&&
name|dpCtx
operator|!=
literal|null
condition|)
block|{
name|outColumnCnt
operator|+=
name|dpCtx
operator|.
name|getNumDPCols
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|inColumnCnt
operator|!=
name|outColumnCnt
condition|)
block|{
name|String
name|reason
init|=
literal|"Table "
operator|+
name|dest
operator|+
literal|" has "
operator|+
name|outColumnCnt
operator|+
literal|" columns, but query has "
operator|+
name|inColumnCnt
operator|+
literal|" columns."
decl_stmt|;
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|TARGET_TABLE_COLUMN_MISMATCH
operator|.
name|getMsg
argument_list|(
name|qb
operator|.
name|getParseInfo
argument_list|()
operator|.
name|getDestForClause
argument_list|(
name|dest
argument_list|)
argument_list|,
name|reason
argument_list|)
argument_list|)
throw|;
block|}
elseif|else
if|if
condition|(
name|dynPart
operator|&&
name|dpCtx
operator|!=
literal|null
condition|)
block|{
comment|// create the mapping from input ExprNode to dest table DP column
name|dpCtx
operator|.
name|mapInputToDP
argument_list|(
name|rowFields
operator|.
name|subList
argument_list|(
name|tableFields
operator|.
name|size
argument_list|()
argument_list|,
name|rowFields
operator|.
name|size
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// Check column types
name|boolean
name|converted
init|=
literal|false
decl_stmt|;
name|int
name|columnNumber
init|=
name|tableFields
operator|.
name|size
argument_list|()
decl_stmt|;
name|ArrayList
argument_list|<
name|ExprNodeDesc
argument_list|>
name|expressions
init|=
operator|new
name|ArrayList
argument_list|<
name|ExprNodeDesc
argument_list|>
argument_list|(
name|columnNumber
argument_list|)
decl_stmt|;
comment|// MetadataTypedColumnsetSerDe does not need type conversions because it
comment|// does the conversion to String by itself.
name|boolean
name|isMetaDataSerDe
init|=
name|table_desc
operator|.
name|getDeserializerClass
argument_list|()
operator|.
name|equals
argument_list|(
name|MetadataTypedColumnsetSerDe
operator|.
name|class
argument_list|)
decl_stmt|;
name|boolean
name|isLazySimpleSerDe
init|=
name|table_desc
operator|.
name|getDeserializerClass
argument_list|()
operator|.
name|equals
argument_list|(
name|LazySimpleSerDe
operator|.
name|class
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|isMetaDataSerDe
condition|)
block|{
comment|// here only deals with non-partition columns. We deal with partition columns next
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|columnNumber
condition|;
name|i
operator|++
control|)
block|{
name|ObjectInspector
name|tableFieldOI
init|=
name|tableFields
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|getFieldObjectInspector
argument_list|()
decl_stmt|;
name|TypeInfo
name|tableFieldTypeInfo
init|=
name|TypeInfoUtils
operator|.
name|getTypeInfoFromObjectInspector
argument_list|(
name|tableFieldOI
argument_list|)
decl_stmt|;
name|TypeInfo
name|rowFieldTypeInfo
init|=
name|rowFields
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|getType
argument_list|()
decl_stmt|;
name|ExprNodeDesc
name|column
init|=
operator|new
name|ExprNodeColumnDesc
argument_list|(
name|rowFieldTypeInfo
argument_list|,
name|rowFields
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|getInternalName
argument_list|()
argument_list|,
literal|""
argument_list|,
literal|false
argument_list|,
name|rowFields
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|isSkewedCol
argument_list|()
argument_list|)
decl_stmt|;
comment|// LazySimpleSerDe can convert any types to String type using
comment|// JSON-format.
if|if
condition|(
operator|!
name|tableFieldTypeInfo
operator|.
name|equals
argument_list|(
name|rowFieldTypeInfo
argument_list|)
operator|&&
operator|!
operator|(
name|isLazySimpleSerDe
operator|&&
name|tableFieldTypeInfo
operator|.
name|getCategory
argument_list|()
operator|.
name|equals
argument_list|(
name|Category
operator|.
name|PRIMITIVE
argument_list|)
operator|&&
name|tableFieldTypeInfo
operator|.
name|equals
argument_list|(
name|TypeInfoFactory
operator|.
name|stringTypeInfo
argument_list|)
operator|)
condition|)
block|{
comment|// need to do some conversions here
name|converted
operator|=
literal|true
expr_stmt|;
if|if
condition|(
name|tableFieldTypeInfo
operator|.
name|getCategory
argument_list|()
operator|!=
name|Category
operator|.
name|PRIMITIVE
condition|)
block|{
comment|// cannot convert to complex types
name|column
operator|=
literal|null
expr_stmt|;
block|}
else|else
block|{
name|column
operator|=
name|ParseUtils
operator|.
name|createConversionCast
argument_list|(
name|column
argument_list|,
operator|(
name|PrimitiveTypeInfo
operator|)
name|tableFieldTypeInfo
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|column
operator|==
literal|null
condition|)
block|{
name|String
name|reason
init|=
literal|"Cannot convert column "
operator|+
name|i
operator|+
literal|" from "
operator|+
name|rowFieldTypeInfo
operator|+
literal|" to "
operator|+
name|tableFieldTypeInfo
operator|+
literal|"."
decl_stmt|;
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|TARGET_TABLE_COLUMN_MISMATCH
operator|.
name|getMsg
argument_list|(
name|qb
operator|.
name|getParseInfo
argument_list|()
operator|.
name|getDestForClause
argument_list|(
name|dest
argument_list|)
argument_list|,
name|reason
argument_list|)
argument_list|)
throw|;
block|}
block|}
name|expressions
operator|.
name|add
argument_list|(
name|column
argument_list|)
expr_stmt|;
block|}
block|}
comment|// deal with dynamic partition columns: convert ExprNodeDesc type to String??
if|if
condition|(
name|dynPart
operator|&&
name|dpCtx
operator|!=
literal|null
operator|&&
name|dpCtx
operator|.
name|getNumDPCols
argument_list|()
operator|>
literal|0
condition|)
block|{
comment|// DP columns starts with tableFields.size()
for|for
control|(
name|int
name|i
init|=
name|tableFields
operator|.
name|size
argument_list|()
init|;
name|i
operator|<
name|rowFields
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|TypeInfo
name|rowFieldTypeInfo
init|=
name|rowFields
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|getType
argument_list|()
decl_stmt|;
name|ExprNodeDesc
name|column
init|=
operator|new
name|ExprNodeColumnDesc
argument_list|(
name|rowFieldTypeInfo
argument_list|,
name|rowFields
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|getInternalName
argument_list|()
argument_list|,
literal|""
argument_list|,
literal|false
argument_list|)
decl_stmt|;
name|expressions
operator|.
name|add
argument_list|(
name|column
argument_list|)
expr_stmt|;
block|}
comment|// converted = true; // [TODO]: should we check& convert type to String and set it to true?
block|}
if|if
condition|(
name|converted
condition|)
block|{
comment|// add the select operator
name|RowResolver
name|rowResolver
init|=
operator|new
name|RowResolver
argument_list|()
decl_stmt|;
name|ArrayList
argument_list|<
name|String
argument_list|>
name|colName
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|expressions
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|String
name|name
init|=
name|getColumnInternalName
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|rowResolver
operator|.
name|put
argument_list|(
literal|""
argument_list|,
name|name
argument_list|,
operator|new
name|ColumnInfo
argument_list|(
name|name
argument_list|,
name|expressions
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|getTypeInfo
argument_list|()
argument_list|,
literal|""
argument_list|,
literal|false
argument_list|)
argument_list|)
expr_stmt|;
name|colName
operator|.
name|add
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
name|Operator
name|output
init|=
name|putOpInsertMap
argument_list|(
name|OperatorFactory
operator|.
name|getAndMakeChild
argument_list|(
operator|new
name|SelectDesc
argument_list|(
name|expressions
argument_list|,
name|colName
argument_list|)
argument_list|,
operator|new
name|RowSchema
argument_list|(
name|rowResolver
operator|.
name|getColumnInfos
argument_list|()
argument_list|)
argument_list|,
name|input
argument_list|)
argument_list|,
name|rowResolver
argument_list|)
decl_stmt|;
return|return
name|output
return|;
block|}
else|else
block|{
comment|// not converted
return|return
name|input
return|;
block|}
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"nls"
argument_list|)
specifier|private
name|Operator
name|genLimitPlan
parameter_list|(
name|String
name|dest
parameter_list|,
name|QB
name|qb
parameter_list|,
name|Operator
name|input
parameter_list|,
name|int
name|limit
parameter_list|)
throws|throws
name|SemanticException
block|{
comment|// A map-only job can be optimized - instead of converting it to a
comment|// map-reduce job, we can have another map
comment|// job to do the same to avoid the cost of sorting in the map-reduce phase.
comment|// A better approach would be to
comment|// write into a local file and then have a map-only job.
comment|// Add the limit operator to get the value fields
name|RowResolver
name|inputRR
init|=
name|opParseCtx
operator|.
name|get
argument_list|(
name|input
argument_list|)
operator|.
name|getRowResolver
argument_list|()
decl_stmt|;
name|LimitDesc
name|limitDesc
init|=
operator|new
name|LimitDesc
argument_list|(
name|limit
argument_list|)
decl_stmt|;
name|globalLimitCtx
operator|.
name|setLastReduceLimitDesc
argument_list|(
name|limitDesc
argument_list|)
expr_stmt|;
name|Operator
name|limitMap
init|=
name|putOpInsertMap
argument_list|(
name|OperatorFactory
operator|.
name|getAndMakeChild
argument_list|(
name|limitDesc
argument_list|,
operator|new
name|RowSchema
argument_list|(
name|inputRR
operator|.
name|getColumnInfos
argument_list|()
argument_list|)
argument_list|,
name|input
argument_list|)
argument_list|,
name|inputRR
argument_list|)
decl_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Created LimitOperator Plan for clause: "
operator|+
name|dest
operator|+
literal|" row schema: "
operator|+
name|inputRR
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|limitMap
return|;
block|}
specifier|private
name|Operator
name|genUDTFPlan
parameter_list|(
name|GenericUDTF
name|genericUDTF
parameter_list|,
name|String
name|outputTableAlias
parameter_list|,
name|ArrayList
argument_list|<
name|String
argument_list|>
name|colAliases
parameter_list|,
name|QB
name|qb
parameter_list|,
name|Operator
name|input
parameter_list|,
name|boolean
name|outerLV
parameter_list|)
throws|throws
name|SemanticException
block|{
comment|// No GROUP BY / DISTRIBUTE BY / SORT BY / CLUSTER BY
name|QBParseInfo
name|qbp
init|=
name|qb
operator|.
name|getParseInfo
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|qbp
operator|.
name|getDestToGroupBy
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|UDTF_NO_GROUP_BY
operator|.
name|getMsg
argument_list|()
argument_list|)
throw|;
block|}
if|if
condition|(
operator|!
name|qbp
operator|.
name|getDestToDistributeBy
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|UDTF_NO_DISTRIBUTE_BY
operator|.
name|getMsg
argument_list|()
argument_list|)
throw|;
block|}
if|if
condition|(
operator|!
name|qbp
operator|.
name|getDestToSortBy
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|UDTF_NO_SORT_BY
operator|.
name|getMsg
argument_list|()
argument_list|)
throw|;
block|}
if|if
condition|(
operator|!
name|qbp
operator|.
name|getDestToClusterBy
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|UDTF_NO_CLUSTER_BY
operator|.
name|getMsg
argument_list|()
argument_list|)
throw|;
block|}
if|if
condition|(
operator|!
name|qbp
operator|.
name|getAliasToLateralViews
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|UDTF_LATERAL_VIEW
operator|.
name|getMsg
argument_list|()
argument_list|)
throw|;
block|}
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Table alias: "
operator|+
name|outputTableAlias
operator|+
literal|" Col aliases: "
operator|+
name|colAliases
argument_list|)
expr_stmt|;
block|}
comment|// Use the RowResolver from the input operator to generate a input
comment|// ObjectInspector that can be used to initialize the UDTF. Then, the
comment|// resulting output object inspector can be used to make the RowResolver
comment|// for the UDTF operator
name|RowResolver
name|selectRR
init|=
name|opParseCtx
operator|.
name|get
argument_list|(
name|input
argument_list|)
operator|.
name|getRowResolver
argument_list|()
decl_stmt|;
name|ArrayList
argument_list|<
name|ColumnInfo
argument_list|>
name|inputCols
init|=
name|selectRR
operator|.
name|getColumnInfos
argument_list|()
decl_stmt|;
comment|// Create the object inspector for the input columns and initialize the UDTF
name|ArrayList
argument_list|<
name|String
argument_list|>
name|colNames
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
name|ObjectInspector
index|[]
name|colOIs
init|=
operator|new
name|ObjectInspector
index|[
name|inputCols
operator|.
name|size
argument_list|()
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|inputCols
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|colNames
operator|.
name|add
argument_list|(
name|inputCols
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|getInternalName
argument_list|()
argument_list|)
expr_stmt|;
name|colOIs
index|[
name|i
index|]
operator|=
name|inputCols
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|getObjectInspector
argument_list|()
expr_stmt|;
block|}
name|StandardStructObjectInspector
name|rowOI
init|=
name|ObjectInspectorFactory
operator|.
name|getStandardStructObjectInspector
argument_list|(
name|colNames
argument_list|,
name|Arrays
operator|.
name|asList
argument_list|(
name|colOIs
argument_list|)
argument_list|)
decl_stmt|;
name|StructObjectInspector
name|outputOI
init|=
name|genericUDTF
operator|.
name|initialize
argument_list|(
name|rowOI
argument_list|)
decl_stmt|;
name|int
name|numUdtfCols
init|=
name|outputOI
operator|.
name|getAllStructFieldRefs
argument_list|()
operator|.
name|size
argument_list|()
decl_stmt|;
if|if
condition|(
name|colAliases
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
comment|// user did not specfied alias names, infer names from outputOI
for|for
control|(
name|StructField
name|field
range|:
name|outputOI
operator|.
name|getAllStructFieldRefs
argument_list|()
control|)
block|{
name|colAliases
operator|.
name|add
argument_list|(
name|field
operator|.
name|getFieldName
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Make sure that the number of column aliases in the AS clause matches
comment|// the number of columns output by the UDTF
name|int
name|numSuppliedAliases
init|=
name|colAliases
operator|.
name|size
argument_list|()
decl_stmt|;
if|if
condition|(
name|numUdtfCols
operator|!=
name|numSuppliedAliases
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|UDTF_ALIAS_MISMATCH
operator|.
name|getMsg
argument_list|(
literal|"expected "
operator|+
name|numUdtfCols
operator|+
literal|" aliases "
operator|+
literal|"but got "
operator|+
name|numSuppliedAliases
argument_list|)
argument_list|)
throw|;
block|}
comment|// Generate the output column info's / row resolver using internal names.
name|ArrayList
argument_list|<
name|ColumnInfo
argument_list|>
name|udtfCols
init|=
operator|new
name|ArrayList
argument_list|<
name|ColumnInfo
argument_list|>
argument_list|()
decl_stmt|;
name|Iterator
argument_list|<
name|String
argument_list|>
name|colAliasesIter
init|=
name|colAliases
operator|.
name|iterator
argument_list|()
decl_stmt|;
for|for
control|(
name|StructField
name|sf
range|:
name|outputOI
operator|.
name|getAllStructFieldRefs
argument_list|()
control|)
block|{
name|String
name|colAlias
init|=
name|colAliasesIter
operator|.
name|next
argument_list|()
decl_stmt|;
assert|assert
operator|(
name|colAlias
operator|!=
literal|null
operator|)
assert|;
comment|// Since the UDTF operator feeds into a LVJ operator that will rename
comment|// all the internal names, we can just use field name from the UDTF's OI
comment|// as the internal name
name|ColumnInfo
name|col
init|=
operator|new
name|ColumnInfo
argument_list|(
name|sf
operator|.
name|getFieldName
argument_list|()
argument_list|,
name|TypeInfoUtils
operator|.
name|getTypeInfoFromObjectInspector
argument_list|(
name|sf
operator|.
name|getFieldObjectInspector
argument_list|()
argument_list|)
argument_list|,
name|outputTableAlias
argument_list|,
literal|false
argument_list|)
decl_stmt|;
name|udtfCols
operator|.
name|add
argument_list|(
name|col
argument_list|)
expr_stmt|;
block|}
comment|// Create the row resolver for this operator from the output columns
name|RowResolver
name|out_rwsch
init|=
operator|new
name|RowResolver
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|udtfCols
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|out_rwsch
operator|.
name|put
argument_list|(
name|outputTableAlias
argument_list|,
name|colAliases
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|,
name|udtfCols
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// Add the UDTFOperator to the operator DAG
name|Operator
argument_list|<
name|?
argument_list|>
name|udtf
init|=
name|putOpInsertMap
argument_list|(
name|OperatorFactory
operator|.
name|getAndMakeChild
argument_list|(
operator|new
name|UDTFDesc
argument_list|(
name|genericUDTF
argument_list|,
name|outerLV
argument_list|)
argument_list|,
operator|new
name|RowSchema
argument_list|(
name|out_rwsch
operator|.
name|getColumnInfos
argument_list|()
argument_list|)
argument_list|,
name|input
argument_list|)
argument_list|,
name|out_rwsch
argument_list|)
decl_stmt|;
return|return
name|udtf
return|;
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"nls"
argument_list|)
specifier|private
name|Operator
name|genLimitMapRedPlan
parameter_list|(
name|String
name|dest
parameter_list|,
name|QB
name|qb
parameter_list|,
name|Operator
name|input
parameter_list|,
name|int
name|limit
parameter_list|,
name|boolean
name|extraMRStep
parameter_list|)
throws|throws
name|SemanticException
block|{
comment|// A map-only job can be optimized - instead of converting it to a
comment|// map-reduce job, we can have another map
comment|// job to do the same to avoid the cost of sorting in the map-reduce phase.
comment|// A better approach would be to
comment|// write into a local file and then have a map-only job.
comment|// Add the limit operator to get the value fields
name|Operator
name|curr
init|=
name|genLimitPlan
argument_list|(
name|dest
argument_list|,
name|qb
argument_list|,
name|input
argument_list|,
name|limit
argument_list|)
decl_stmt|;
comment|// the client requested that an extra map-reduce step be performed
if|if
condition|(
operator|!
name|extraMRStep
condition|)
block|{
return|return
name|curr
return|;
block|}
comment|// Create a reduceSink operator followed by another limit
name|curr
operator|=
name|genReduceSinkPlan
argument_list|(
name|dest
argument_list|,
name|qb
argument_list|,
name|curr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
name|genLimitPlan
argument_list|(
name|dest
argument_list|,
name|qb
argument_list|,
name|curr
argument_list|,
name|limit
argument_list|)
return|;
block|}
specifier|private
name|ArrayList
argument_list|<
name|ExprNodeDesc
argument_list|>
name|getParitionColsFromBucketCols
parameter_list|(
name|String
name|dest
parameter_list|,
name|QB
name|qb
parameter_list|,
name|Table
name|tab
parameter_list|,
name|TableDesc
name|table_desc
parameter_list|,
name|Operator
name|input
parameter_list|,
name|boolean
name|convert
parameter_list|)
throws|throws
name|SemanticException
block|{
name|List
argument_list|<
name|String
argument_list|>
name|tabBucketCols
init|=
name|tab
operator|.
name|getBucketCols
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|FieldSchema
argument_list|>
name|tabCols
init|=
name|tab
operator|.
name|getCols
argument_list|()
decl_stmt|;
comment|// Partition by the bucketing column
name|List
argument_list|<
name|Integer
argument_list|>
name|posns
init|=
operator|new
name|ArrayList
argument_list|<
name|Integer
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|String
name|bucketCol
range|:
name|tabBucketCols
control|)
block|{
name|int
name|pos
init|=
literal|0
decl_stmt|;
for|for
control|(
name|FieldSchema
name|tabCol
range|:
name|tabCols
control|)
block|{
if|if
condition|(
name|bucketCol
operator|.
name|equals
argument_list|(
name|tabCol
operator|.
name|getName
argument_list|()
argument_list|)
condition|)
block|{
name|posns
operator|.
name|add
argument_list|(
name|pos
argument_list|)
expr_stmt|;
break|break;
block|}
name|pos
operator|++
expr_stmt|;
block|}
block|}
return|return
name|genConvertCol
argument_list|(
name|dest
argument_list|,
name|qb
argument_list|,
name|tab
argument_list|,
name|table_desc
argument_list|,
name|input
argument_list|,
name|posns
argument_list|,
name|convert
argument_list|)
return|;
block|}
specifier|private
name|ArrayList
argument_list|<
name|ExprNodeDesc
argument_list|>
name|genConvertCol
parameter_list|(
name|String
name|dest
parameter_list|,
name|QB
name|qb
parameter_list|,
name|Table
name|tab
parameter_list|,
name|TableDesc
name|table_desc
parameter_list|,
name|Operator
name|input
parameter_list|,
name|List
argument_list|<
name|Integer
argument_list|>
name|posns
parameter_list|,
name|boolean
name|convert
parameter_list|)
throws|throws
name|SemanticException
block|{
name|StructObjectInspector
name|oi
init|=
literal|null
decl_stmt|;
try|try
block|{
name|Deserializer
name|deserializer
init|=
name|table_desc
operator|.
name|getDeserializerClass
argument_list|()
operator|.
name|newInstance
argument_list|()
decl_stmt|;
name|deserializer
operator|.
name|initialize
argument_list|(
name|conf
argument_list|,
name|table_desc
operator|.
name|getProperties
argument_list|()
argument_list|)
expr_stmt|;
name|oi
operator|=
operator|(
name|StructObjectInspector
operator|)
name|deserializer
operator|.
name|getObjectInspector
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|e
argument_list|)
throw|;
block|}
name|List
argument_list|<
name|?
extends|extends
name|StructField
argument_list|>
name|tableFields
init|=
name|oi
operator|.
name|getAllStructFieldRefs
argument_list|()
decl_stmt|;
name|ArrayList
argument_list|<
name|ColumnInfo
argument_list|>
name|rowFields
init|=
name|opParseCtx
operator|.
name|get
argument_list|(
name|input
argument_list|)
operator|.
name|getRowResolver
argument_list|()
operator|.
name|getColumnInfos
argument_list|()
decl_stmt|;
comment|// Check column type
name|int
name|columnNumber
init|=
name|posns
operator|.
name|size
argument_list|()
decl_stmt|;
name|ArrayList
argument_list|<
name|ExprNodeDesc
argument_list|>
name|expressions
init|=
operator|new
name|ArrayList
argument_list|<
name|ExprNodeDesc
argument_list|>
argument_list|(
name|columnNumber
argument_list|)
decl_stmt|;
for|for
control|(
name|Integer
name|posn
range|:
name|posns
control|)
block|{
name|ObjectInspector
name|tableFieldOI
init|=
name|tableFields
operator|.
name|get
argument_list|(
name|posn
argument_list|)
operator|.
name|getFieldObjectInspector
argument_list|()
decl_stmt|;
name|TypeInfo
name|tableFieldTypeInfo
init|=
name|TypeInfoUtils
operator|.
name|getTypeInfoFromObjectInspector
argument_list|(
name|tableFieldOI
argument_list|)
decl_stmt|;
name|TypeInfo
name|rowFieldTypeInfo
init|=
name|rowFields
operator|.
name|get
argument_list|(
name|posn
argument_list|)
operator|.
name|getType
argument_list|()
decl_stmt|;
name|ExprNodeDesc
name|column
init|=
operator|new
name|ExprNodeColumnDesc
argument_list|(
name|rowFieldTypeInfo
argument_list|,
name|rowFields
operator|.
name|get
argument_list|(
name|posn
argument_list|)
operator|.
name|getInternalName
argument_list|()
argument_list|,
name|rowFields
operator|.
name|get
argument_list|(
name|posn
argument_list|)
operator|.
name|getTabAlias
argument_list|()
argument_list|,
name|rowFields
operator|.
name|get
argument_list|(
name|posn
argument_list|)
operator|.
name|getIsVirtualCol
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|convert
operator|&&
operator|!
name|tableFieldTypeInfo
operator|.
name|equals
argument_list|(
name|rowFieldTypeInfo
argument_list|)
condition|)
block|{
comment|// need to do some conversions here
if|if
condition|(
name|tableFieldTypeInfo
operator|.
name|getCategory
argument_list|()
operator|!=
name|Category
operator|.
name|PRIMITIVE
condition|)
block|{
comment|// cannot convert to complex types
name|column
operator|=
literal|null
expr_stmt|;
block|}
else|else
block|{
name|column
operator|=
name|ParseUtils
operator|.
name|createConversionCast
argument_list|(
name|column
argument_list|,
operator|(
name|PrimitiveTypeInfo
operator|)
name|tableFieldTypeInfo
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|column
operator|==
literal|null
condition|)
block|{
name|String
name|reason
init|=
literal|"Cannot convert column "
operator|+
name|posn
operator|+
literal|" from "
operator|+
name|rowFieldTypeInfo
operator|+
literal|" to "
operator|+
name|tableFieldTypeInfo
operator|+
literal|"."
decl_stmt|;
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|TARGET_TABLE_COLUMN_MISMATCH
operator|.
name|getMsg
argument_list|(
name|qb
operator|.
name|getParseInfo
argument_list|()
operator|.
name|getDestForClause
argument_list|(
name|dest
argument_list|)
argument_list|,
name|reason
argument_list|)
argument_list|)
throw|;
block|}
block|}
name|expressions
operator|.
name|add
argument_list|(
name|column
argument_list|)
expr_stmt|;
block|}
return|return
name|expressions
return|;
block|}
specifier|private
name|ArrayList
argument_list|<
name|ExprNodeDesc
argument_list|>
name|getSortCols
parameter_list|(
name|String
name|dest
parameter_list|,
name|QB
name|qb
parameter_list|,
name|Table
name|tab
parameter_list|,
name|TableDesc
name|table_desc
parameter_list|,
name|Operator
name|input
parameter_list|,
name|boolean
name|convert
parameter_list|)
throws|throws
name|SemanticException
block|{
name|RowResolver
name|inputRR
init|=
name|opParseCtx
operator|.
name|get
argument_list|(
name|input
argument_list|)
operator|.
name|getRowResolver
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|Order
argument_list|>
name|tabSortCols
init|=
name|tab
operator|.
name|getSortCols
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|FieldSchema
argument_list|>
name|tabCols
init|=
name|tab
operator|.
name|getCols
argument_list|()
decl_stmt|;
comment|// Partition by the bucketing column
name|List
argument_list|<
name|Integer
argument_list|>
name|posns
init|=
operator|new
name|ArrayList
argument_list|<
name|Integer
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|Order
name|sortCol
range|:
name|tabSortCols
control|)
block|{
name|int
name|pos
init|=
literal|0
decl_stmt|;
for|for
control|(
name|FieldSchema
name|tabCol
range|:
name|tabCols
control|)
block|{
if|if
condition|(
name|sortCol
operator|.
name|getCol
argument_list|()
operator|.
name|equals
argument_list|(
name|tabCol
operator|.
name|getName
argument_list|()
argument_list|)
condition|)
block|{
name|ColumnInfo
name|colInfo
init|=
name|inputRR
operator|.
name|getColumnInfos
argument_list|()
operator|.
name|get
argument_list|(
name|pos
argument_list|)
decl_stmt|;
name|posns
operator|.
name|add
argument_list|(
name|pos
argument_list|)
expr_stmt|;
break|break;
block|}
name|pos
operator|++
expr_stmt|;
block|}
block|}
return|return
name|genConvertCol
argument_list|(
name|dest
argument_list|,
name|qb
argument_list|,
name|tab
argument_list|,
name|table_desc
argument_list|,
name|input
argument_list|,
name|posns
argument_list|,
name|convert
argument_list|)
return|;
block|}
specifier|private
name|ArrayList
argument_list|<
name|Integer
argument_list|>
name|getSortOrders
parameter_list|(
name|String
name|dest
parameter_list|,
name|QB
name|qb
parameter_list|,
name|Table
name|tab
parameter_list|,
name|Operator
name|input
parameter_list|)
throws|throws
name|SemanticException
block|{
name|RowResolver
name|inputRR
init|=
name|opParseCtx
operator|.
name|get
argument_list|(
name|input
argument_list|)
operator|.
name|getRowResolver
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|Order
argument_list|>
name|tabSortCols
init|=
name|tab
operator|.
name|getSortCols
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|FieldSchema
argument_list|>
name|tabCols
init|=
name|tab
operator|.
name|getCols
argument_list|()
decl_stmt|;
name|ArrayList
argument_list|<
name|Integer
argument_list|>
name|orders
init|=
operator|new
name|ArrayList
argument_list|<
name|Integer
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|Order
name|sortCol
range|:
name|tabSortCols
control|)
block|{
for|for
control|(
name|FieldSchema
name|tabCol
range|:
name|tabCols
control|)
block|{
if|if
condition|(
name|sortCol
operator|.
name|getCol
argument_list|()
operator|.
name|equals
argument_list|(
name|tabCol
operator|.
name|getName
argument_list|()
argument_list|)
condition|)
block|{
name|orders
operator|.
name|add
argument_list|(
name|sortCol
operator|.
name|getOrder
argument_list|()
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
return|return
name|orders
return|;
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"nls"
argument_list|)
specifier|private
name|Operator
name|genReduceSinkPlanForSortingBucketing
parameter_list|(
name|Table
name|tab
parameter_list|,
name|Operator
name|input
parameter_list|,
name|ArrayList
argument_list|<
name|ExprNodeDesc
argument_list|>
name|sortCols
parameter_list|,
name|List
argument_list|<
name|Integer
argument_list|>
name|sortOrders
parameter_list|,
name|ArrayList
argument_list|<
name|ExprNodeDesc
argument_list|>
name|partitionCols
parameter_list|,
name|int
name|numReducers
parameter_list|)
throws|throws
name|SemanticException
block|{
name|RowResolver
name|inputRR
init|=
name|opParseCtx
operator|.
name|get
argument_list|(
name|input
argument_list|)
operator|.
name|getRowResolver
argument_list|()
decl_stmt|;
comment|// For the generation of the values expression just get the inputs
comment|// signature and generate field expressions for those
name|Map
argument_list|<
name|String
argument_list|,
name|ExprNodeDesc
argument_list|>
name|colExprMap
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|ExprNodeDesc
argument_list|>
argument_list|()
decl_stmt|;
name|ArrayList
argument_list|<
name|ExprNodeDesc
argument_list|>
name|valueCols
init|=
operator|new
name|ArrayList
argument_list|<
name|ExprNodeDesc
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|ColumnInfo
name|colInfo
range|:
name|inputRR
operator|.
name|getColumnInfos
argument_list|()
control|)
block|{
name|valueCols
operator|.
name|add
argument_list|(
operator|new
name|ExprNodeColumnDesc
argument_list|(
name|colInfo
operator|.
name|getType
argument_list|()
argument_list|,
name|colInfo
operator|.
name|getInternalName
argument_list|()
argument_list|,
name|colInfo
operator|.
name|getTabAlias
argument_list|()
argument_list|,
name|colInfo
operator|.
name|getIsVirtualCol
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|colExprMap
operator|.
name|put
argument_list|(
name|colInfo
operator|.
name|getInternalName
argument_list|()
argument_list|,
name|valueCols
operator|.
name|get
argument_list|(
name|valueCols
operator|.
name|size
argument_list|()
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|ArrayList
argument_list|<
name|String
argument_list|>
name|outputColumns
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|valueCols
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|outputColumns
operator|.
name|add
argument_list|(
name|getColumnInternalName
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|StringBuilder
name|order
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|sortOrder
range|:
name|sortOrders
control|)
block|{
name|order
operator|.
name|append
argument_list|(
name|sortOrder
operator|==
name|BaseSemanticAnalyzer
operator|.
name|HIVE_COLUMN_ORDER_ASC
condition|?
literal|'+'
else|:
literal|'-'
argument_list|)
expr_stmt|;
block|}
name|Operator
name|interim
init|=
name|putOpInsertMap
argument_list|(
name|OperatorFactory
operator|.
name|getAndMakeChild
argument_list|(
name|PlanUtils
operator|.
name|getReduceSinkDesc
argument_list|(
name|sortCols
argument_list|,
name|valueCols
argument_list|,
name|outputColumns
argument_list|,
literal|false
argument_list|,
operator|-
literal|1
argument_list|,
name|partitionCols
argument_list|,
name|order
operator|.
name|toString
argument_list|()
argument_list|,
name|numReducers
argument_list|)
argument_list|,
operator|new
name|RowSchema
argument_list|(
name|inputRR
operator|.
name|getColumnInfos
argument_list|()
argument_list|)
argument_list|,
name|input
argument_list|)
argument_list|,
name|inputRR
argument_list|)
decl_stmt|;
name|interim
operator|.
name|setColumnExprMap
argument_list|(
name|colExprMap
argument_list|)
expr_stmt|;
name|reduceSinkOperatorsAddedByEnforceBucketingSorting
operator|.
name|add
argument_list|(
operator|(
name|ReduceSinkOperator
operator|)
name|interim
argument_list|)
expr_stmt|;
comment|// Add the extract operator to get the value fields
name|RowResolver
name|out_rwsch
init|=
operator|new
name|RowResolver
argument_list|()
decl_stmt|;
name|RowResolver
name|interim_rwsch
init|=
name|inputRR
decl_stmt|;
name|Integer
name|pos
init|=
name|Integer
operator|.
name|valueOf
argument_list|(
literal|0
argument_list|)
decl_stmt|;
for|for
control|(
name|ColumnInfo
name|colInfo
range|:
name|interim_rwsch
operator|.
name|getColumnInfos
argument_list|()
control|)
block|{
name|String
index|[]
name|info
init|=
name|interim_rwsch
operator|.
name|reverseLookup
argument_list|(
name|colInfo
operator|.
name|getInternalName
argument_list|()
argument_list|)
decl_stmt|;
name|out_rwsch
operator|.
name|put
argument_list|(
name|info
index|[
literal|0
index|]
argument_list|,
name|info
index|[
literal|1
index|]
argument_list|,
operator|new
name|ColumnInfo
argument_list|(
name|getColumnInternalName
argument_list|(
name|pos
argument_list|)
argument_list|,
name|colInfo
operator|.
name|getType
argument_list|()
argument_list|,
name|info
index|[
literal|0
index|]
argument_list|,
name|colInfo
operator|.
name|getIsVirtualCol
argument_list|()
argument_list|,
name|colInfo
operator|.
name|isHiddenVirtualCol
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|pos
operator|=
name|Integer
operator|.
name|valueOf
argument_list|(
name|pos
operator|.
name|intValue
argument_list|()
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
name|Operator
name|output
init|=
name|putOpInsertMap
argument_list|(
name|OperatorFactory
operator|.
name|getAndMakeChild
argument_list|(
operator|new
name|ExtractDesc
argument_list|(
operator|new
name|ExprNodeColumnDesc
argument_list|(
name|TypeInfoFactory
operator|.
name|stringTypeInfo
argument_list|,
name|Utilities
operator|.
name|ReduceField
operator|.
name|VALUE
operator|.
name|toString
argument_list|()
argument_list|,
literal|""
argument_list|,
literal|false
argument_list|)
argument_list|)
argument_list|,
operator|new
name|RowSchema
argument_list|(
name|out_rwsch
operator|.
name|getColumnInfos
argument_list|()
argument_list|)
argument_list|,
name|interim
argument_list|)
argument_list|,
name|out_rwsch
argument_list|)
decl_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Created ReduceSink Plan for table: "
operator|+
name|tab
operator|.
name|getTableName
argument_list|()
operator|+
literal|" row schema: "
operator|+
name|out_rwsch
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|output
return|;
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"nls"
argument_list|)
specifier|private
name|Operator
name|genReduceSinkPlan
parameter_list|(
name|String
name|dest
parameter_list|,
name|QB
name|qb
parameter_list|,
name|Operator
name|input
parameter_list|,
name|int
name|numReducers
parameter_list|)
throws|throws
name|SemanticException
block|{
name|RowResolver
name|inputRR
init|=
name|opParseCtx
operator|.
name|get
argument_list|(
name|input
argument_list|)
operator|.
name|getRowResolver
argument_list|()
decl_stmt|;
comment|// First generate the expression for the partition and sort keys
comment|// The cluster by clause / distribute by clause has the aliases for
comment|// partition function
name|ASTNode
name|partitionExprs
init|=
name|qb
operator|.
name|getParseInfo
argument_list|()
operator|.
name|getClusterByForClause
argument_list|(
name|dest
argument_list|)
decl_stmt|;
if|if
condition|(
name|partitionExprs
operator|==
literal|null
condition|)
block|{
name|partitionExprs
operator|=
name|qb
operator|.
name|getParseInfo
argument_list|()
operator|.
name|getDistributeByForClause
argument_list|(
name|dest
argument_list|)
expr_stmt|;
block|}
name|ArrayList
argument_list|<
name|ExprNodeDesc
argument_list|>
name|partitionCols
init|=
operator|new
name|ArrayList
argument_list|<
name|ExprNodeDesc
argument_list|>
argument_list|()
decl_stmt|;
if|if
condition|(
name|partitionExprs
operator|!=
literal|null
condition|)
block|{
name|int
name|ccount
init|=
name|partitionExprs
operator|.
name|getChildCount
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|ccount
condition|;
operator|++
name|i
control|)
block|{
name|ASTNode
name|cl
init|=
operator|(
name|ASTNode
operator|)
name|partitionExprs
operator|.
name|getChild
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|partitionCols
operator|.
name|add
argument_list|(
name|genExprNodeDesc
argument_list|(
name|cl
argument_list|,
name|inputRR
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|ASTNode
name|sortExprs
init|=
name|qb
operator|.
name|getParseInfo
argument_list|()
operator|.
name|getClusterByForClause
argument_list|(
name|dest
argument_list|)
decl_stmt|;
if|if
condition|(
name|sortExprs
operator|==
literal|null
condition|)
block|{
name|sortExprs
operator|=
name|qb
operator|.
name|getParseInfo
argument_list|()
operator|.
name|getSortByForClause
argument_list|(
name|dest
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sortExprs
operator|==
literal|null
condition|)
block|{
name|sortExprs
operator|=
name|qb
operator|.
name|getParseInfo
argument_list|()
operator|.
name|getOrderByForClause
argument_list|(
name|dest
argument_list|)
expr_stmt|;
if|if
condition|(
name|sortExprs
operator|!=
literal|null
condition|)
block|{
assert|assert
name|numReducers
operator|==
literal|1
assert|;
comment|// in strict mode, in the presence of order by, limit must be specified
name|Integer
name|limit
init|=
name|qb
operator|.
name|getParseInfo
argument_list|()
operator|.
name|getDestLimit
argument_list|(
name|dest
argument_list|)
decl_stmt|;
if|if
condition|(
name|conf
operator|.
name|getVar
argument_list|(
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVEMAPREDMODE
argument_list|)
operator|.
name|equalsIgnoreCase
argument_list|(
literal|"strict"
argument_list|)
operator|&&
name|limit
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|generateErrorMessage
argument_list|(
name|sortExprs
argument_list|,
name|ErrorMsg
operator|.
name|NO_LIMIT_WITH_ORDERBY
operator|.
name|getMsg
argument_list|()
argument_list|)
argument_list|)
throw|;
block|}
block|}
block|}
name|ArrayList
argument_list|<
name|ExprNodeDesc
argument_list|>
name|sortCols
init|=
operator|new
name|ArrayList
argument_list|<
name|ExprNodeDesc
argument_list|>
argument_list|()
decl_stmt|;
name|StringBuilder
name|order
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
if|if
condition|(
name|sortExprs
operator|!=
literal|null
condition|)
block|{
name|int
name|ccount
init|=
name|sortExprs
operator|.
name|getChildCount
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|ccount
condition|;
operator|++
name|i
control|)
block|{
name|ASTNode
name|cl
init|=
operator|(
name|ASTNode
operator|)
name|sortExprs
operator|.
name|getChild
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|cl
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_TABSORTCOLNAMEASC
condition|)
block|{
comment|// SortBy ASC
name|order
operator|.
name|append
argument_list|(
literal|"+"
argument_list|)
expr_stmt|;
name|cl
operator|=
operator|(
name|ASTNode
operator|)
name|cl
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cl
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_TABSORTCOLNAMEDESC
condition|)
block|{
comment|// SortBy DESC
name|order
operator|.
name|append
argument_list|(
literal|"-"
argument_list|)
expr_stmt|;
name|cl
operator|=
operator|(
name|ASTNode
operator|)
name|cl
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// ClusterBy
name|order
operator|.
name|append
argument_list|(
literal|"+"
argument_list|)
expr_stmt|;
block|}
name|ExprNodeDesc
name|exprNode
init|=
name|genExprNodeDesc
argument_list|(
name|cl
argument_list|,
name|inputRR
argument_list|)
decl_stmt|;
name|sortCols
operator|.
name|add
argument_list|(
name|exprNode
argument_list|)
expr_stmt|;
block|}
block|}
comment|// For the generation of the values expression just get the inputs
comment|// signature and generate field expressions for those
name|Map
argument_list|<
name|String
argument_list|,
name|ExprNodeDesc
argument_list|>
name|colExprMap
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|ExprNodeDesc
argument_list|>
argument_list|()
decl_stmt|;
name|ArrayList
argument_list|<
name|ExprNodeDesc
argument_list|>
name|valueCols
init|=
operator|new
name|ArrayList
argument_list|<
name|ExprNodeDesc
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|ColumnInfo
name|colInfo
range|:
name|inputRR
operator|.
name|getColumnInfos
argument_list|()
control|)
block|{
name|valueCols
operator|.
name|add
argument_list|(
operator|new
name|ExprNodeColumnDesc
argument_list|(
name|colInfo
operator|.
name|getType
argument_list|()
argument_list|,
name|colInfo
operator|.
name|getInternalName
argument_list|()
argument_list|,
name|colInfo
operator|.
name|getTabAlias
argument_list|()
argument_list|,
name|colInfo
operator|.
name|getIsVirtualCol
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|colExprMap
operator|.
name|put
argument_list|(
name|colInfo
operator|.
name|getInternalName
argument_list|()
argument_list|,
name|valueCols
operator|.
name|get
argument_list|(
name|valueCols
operator|.
name|size
argument_list|()
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|ArrayList
argument_list|<
name|String
argument_list|>
name|outputColumns
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|valueCols
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|outputColumns
operator|.
name|add
argument_list|(
name|getColumnInternalName
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|Operator
name|interim
init|=
name|putOpInsertMap
argument_list|(
name|OperatorFactory
operator|.
name|getAndMakeChild
argument_list|(
name|PlanUtils
operator|.
name|getReduceSinkDesc
argument_list|(
name|sortCols
argument_list|,
name|valueCols
argument_list|,
name|outputColumns
argument_list|,
literal|false
argument_list|,
operator|-
literal|1
argument_list|,
name|partitionCols
argument_list|,
name|order
operator|.
name|toString
argument_list|()
argument_list|,
name|numReducers
argument_list|)
argument_list|,
operator|new
name|RowSchema
argument_list|(
name|inputRR
operator|.
name|getColumnInfos
argument_list|()
argument_list|)
argument_list|,
name|input
argument_list|)
argument_list|,
name|inputRR
argument_list|)
decl_stmt|;
name|interim
operator|.
name|setColumnExprMap
argument_list|(
name|colExprMap
argument_list|)
expr_stmt|;
comment|// Add the extract operator to get the value fields
name|RowResolver
name|out_rwsch
init|=
operator|new
name|RowResolver
argument_list|()
decl_stmt|;
name|RowResolver
name|interim_rwsch
init|=
name|inputRR
decl_stmt|;
name|Integer
name|pos
init|=
name|Integer
operator|.
name|valueOf
argument_list|(
literal|0
argument_list|)
decl_stmt|;
for|for
control|(
name|ColumnInfo
name|colInfo
range|:
name|interim_rwsch
operator|.
name|getColumnInfos
argument_list|()
control|)
block|{
name|String
index|[]
name|info
init|=
name|interim_rwsch
operator|.
name|reverseLookup
argument_list|(
name|colInfo
operator|.
name|getInternalName
argument_list|()
argument_list|)
decl_stmt|;
name|out_rwsch
operator|.
name|put
argument_list|(
name|info
index|[
literal|0
index|]
argument_list|,
name|info
index|[
literal|1
index|]
argument_list|,
operator|new
name|ColumnInfo
argument_list|(
name|getColumnInternalName
argument_list|(
name|pos
argument_list|)
argument_list|,
name|colInfo
operator|.
name|getType
argument_list|()
argument_list|,
name|info
index|[
literal|0
index|]
argument_list|,
name|colInfo
operator|.
name|getIsVirtualCol
argument_list|()
argument_list|,
name|colInfo
operator|.
name|isHiddenVirtualCol
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|pos
operator|=
name|Integer
operator|.
name|valueOf
argument_list|(
name|pos
operator|.
name|intValue
argument_list|()
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
name|Operator
name|output
init|=
name|putOpInsertMap
argument_list|(
name|OperatorFactory
operator|.
name|getAndMakeChild
argument_list|(
operator|new
name|ExtractDesc
argument_list|(
operator|new
name|ExprNodeColumnDesc
argument_list|(
name|TypeInfoFactory
operator|.
name|stringTypeInfo
argument_list|,
name|Utilities
operator|.
name|ReduceField
operator|.
name|VALUE
operator|.
name|toString
argument_list|()
argument_list|,
literal|""
argument_list|,
literal|false
argument_list|)
argument_list|)
argument_list|,
operator|new
name|RowSchema
argument_list|(
name|out_rwsch
operator|.
name|getColumnInfos
argument_list|()
argument_list|)
argument_list|,
name|interim
argument_list|)
argument_list|,
name|out_rwsch
argument_list|)
decl_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Created ReduceSink Plan for clause: "
operator|+
name|dest
operator|+
literal|" row schema: "
operator|+
name|out_rwsch
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|output
return|;
block|}
specifier|private
name|Operator
name|genJoinOperatorChildren
parameter_list|(
name|QBJoinTree
name|join
parameter_list|,
name|Operator
name|left
parameter_list|,
name|Operator
index|[]
name|right
parameter_list|,
name|HashSet
argument_list|<
name|Integer
argument_list|>
name|omitOpts
parameter_list|)
throws|throws
name|SemanticException
block|{
name|RowResolver
name|outputRS
init|=
operator|new
name|RowResolver
argument_list|()
decl_stmt|;
name|ArrayList
argument_list|<
name|String
argument_list|>
name|outputColumnNames
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
comment|// all children are base classes
name|Operator
argument_list|<
name|?
argument_list|>
index|[]
name|rightOps
init|=
operator|new
name|Operator
index|[
name|right
operator|.
name|length
index|]
decl_stmt|;
name|int
name|outputPos
init|=
literal|0
decl_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|Byte
argument_list|>
name|reversedExprs
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|Byte
argument_list|>
argument_list|()
decl_stmt|;
name|HashMap
argument_list|<
name|Byte
argument_list|,
name|List
argument_list|<
name|ExprNodeDesc
argument_list|>
argument_list|>
name|exprMap
init|=
operator|new
name|HashMap
argument_list|<
name|Byte
argument_list|,
name|List
argument_list|<
name|ExprNodeDesc
argument_list|>
argument_list|>
argument_list|()
decl_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|ExprNodeDesc
argument_list|>
name|colExprMap
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|ExprNodeDesc
argument_list|>
argument_list|()
decl_stmt|;
name|HashMap
argument_list|<
name|Integer
argument_list|,
name|Set
argument_list|<
name|String
argument_list|>
argument_list|>
name|posToAliasMap
init|=
operator|new
name|HashMap
argument_list|<
name|Integer
argument_list|,
name|Set
argument_list|<
name|String
argument_list|>
argument_list|>
argument_list|()
decl_stmt|;
name|HashMap
argument_list|<
name|Byte
argument_list|,
name|List
argument_list|<
name|ExprNodeDesc
argument_list|>
argument_list|>
name|filterMap
init|=
operator|new
name|HashMap
argument_list|<
name|Byte
argument_list|,
name|List
argument_list|<
name|ExprNodeDesc
argument_list|>
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|pos
init|=
literal|0
init|;
name|pos
operator|<
name|right
operator|.
name|length
condition|;
operator|++
name|pos
control|)
block|{
name|Operator
name|input
init|=
name|right
index|[
name|pos
index|]
decl_stmt|;
if|if
condition|(
name|input
operator|==
literal|null
condition|)
block|{
name|input
operator|=
name|left
expr_stmt|;
block|}
name|ArrayList
argument_list|<
name|ExprNodeDesc
argument_list|>
name|keyDesc
init|=
operator|new
name|ArrayList
argument_list|<
name|ExprNodeDesc
argument_list|>
argument_list|()
decl_stmt|;
name|ArrayList
argument_list|<
name|ExprNodeDesc
argument_list|>
name|filterDesc
init|=
operator|new
name|ArrayList
argument_list|<
name|ExprNodeDesc
argument_list|>
argument_list|()
decl_stmt|;
name|Byte
name|tag
init|=
name|Byte
operator|.
name|valueOf
argument_list|(
call|(
name|byte
call|)
argument_list|(
operator|(
call|(
name|ReduceSinkDesc
call|)
argument_list|(
name|input
operator|.
name|getConf
argument_list|()
argument_list|)
operator|)
operator|.
name|getTag
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
comment|// check whether this input operator produces output
if|if
condition|(
name|omitOpts
operator|==
literal|null
operator|||
operator|!
name|omitOpts
operator|.
name|contains
argument_list|(
name|pos
argument_list|)
condition|)
block|{
comment|// prepare output descriptors for the input opt
name|RowResolver
name|inputRS
init|=
name|opParseCtx
operator|.
name|get
argument_list|(
name|input
argument_list|)
operator|.
name|getRowResolver
argument_list|()
decl_stmt|;
name|Iterator
argument_list|<
name|String
argument_list|>
name|keysIter
init|=
name|inputRS
operator|.
name|getTableNames
argument_list|()
operator|.
name|iterator
argument_list|()
decl_stmt|;
name|Set
argument_list|<
name|String
argument_list|>
name|aliases
init|=
name|posToAliasMap
operator|.
name|get
argument_list|(
name|pos
argument_list|)
decl_stmt|;
if|if
condition|(
name|aliases
operator|==
literal|null
condition|)
block|{
name|aliases
operator|=
operator|new
name|HashSet
argument_list|<
name|String
argument_list|>
argument_list|()
expr_stmt|;
name|posToAliasMap
operator|.
name|put
argument_list|(
name|pos
argument_list|,
name|aliases
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|keysIter
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|String
name|key
init|=
name|keysIter
operator|.
name|next
argument_list|()
decl_stmt|;
name|aliases
operator|.
name|add
argument_list|(
name|key
argument_list|)
expr_stmt|;
name|HashMap
argument_list|<
name|String
argument_list|,
name|ColumnInfo
argument_list|>
name|map
init|=
name|inputRS
operator|.
name|getFieldMap
argument_list|(
name|key
argument_list|)
decl_stmt|;
name|Iterator
argument_list|<
name|String
argument_list|>
name|fNamesIter
init|=
name|map
operator|.
name|keySet
argument_list|()
operator|.
name|iterator
argument_list|()
decl_stmt|;
while|while
condition|(
name|fNamesIter
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|String
name|field
init|=
name|fNamesIter
operator|.
name|next
argument_list|()
decl_stmt|;
name|ColumnInfo
name|valueInfo
init|=
name|inputRS
operator|.
name|get
argument_list|(
name|key
argument_list|,
name|field
argument_list|)
decl_stmt|;
name|keyDesc
operator|.
name|add
argument_list|(
operator|new
name|ExprNodeColumnDesc
argument_list|(
name|valueInfo
operator|.
name|getType
argument_list|()
argument_list|,
name|valueInfo
operator|.
name|getInternalName
argument_list|()
argument_list|,
name|valueInfo
operator|.
name|getTabAlias
argument_list|()
argument_list|,
name|valueInfo
operator|.
name|getIsVirtualCol
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|outputRS
operator|.
name|get
argument_list|(
name|key
argument_list|,
name|field
argument_list|)
operator|==
literal|null
condition|)
block|{
name|String
name|colName
init|=
name|getColumnInternalName
argument_list|(
name|outputPos
argument_list|)
decl_stmt|;
name|outputPos
operator|++
expr_stmt|;
name|outputColumnNames
operator|.
name|add
argument_list|(
name|colName
argument_list|)
expr_stmt|;
name|colExprMap
operator|.
name|put
argument_list|(
name|colName
argument_list|,
name|keyDesc
operator|.
name|get
argument_list|(
name|keyDesc
operator|.
name|size
argument_list|()
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|outputRS
operator|.
name|put
argument_list|(
name|key
argument_list|,
name|field
argument_list|,
operator|new
name|ColumnInfo
argument_list|(
name|colName
argument_list|,
name|valueInfo
operator|.
name|getType
argument_list|()
argument_list|,
name|key
argument_list|,
name|valueInfo
operator|.
name|getIsVirtualCol
argument_list|()
argument_list|,
name|valueInfo
operator|.
name|isHiddenVirtualCol
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|reversedExprs
operator|.
name|put
argument_list|(
name|colName
argument_list|,
name|tag
argument_list|)
expr_stmt|;
block|}
block|}
block|}
for|for
control|(
name|ASTNode
name|cond
range|:
name|join
operator|.
name|getFilters
argument_list|()
operator|.
name|get
argument_list|(
name|tag
argument_list|)
control|)
block|{
name|filterDesc
operator|.
name|add
argument_list|(
name|genExprNodeDesc
argument_list|(
name|cond
argument_list|,
name|inputRS
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|exprMap
operator|.
name|put
argument_list|(
name|tag
argument_list|,
name|keyDesc
argument_list|)
expr_stmt|;
name|filterMap
operator|.
name|put
argument_list|(
name|tag
argument_list|,
name|filterDesc
argument_list|)
expr_stmt|;
name|rightOps
index|[
name|pos
index|]
operator|=
name|input
expr_stmt|;
block|}
name|JoinCondDesc
index|[]
name|joinCondns
init|=
operator|new
name|JoinCondDesc
index|[
name|join
operator|.
name|getJoinCond
argument_list|()
operator|.
name|length
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|join
operator|.
name|getJoinCond
argument_list|()
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|JoinCond
name|condn
init|=
name|join
operator|.
name|getJoinCond
argument_list|()
index|[
name|i
index|]
decl_stmt|;
name|joinCondns
index|[
name|i
index|]
operator|=
operator|new
name|JoinCondDesc
argument_list|(
name|condn
argument_list|)
expr_stmt|;
block|}
name|JoinDesc
name|desc
init|=
operator|new
name|JoinDesc
argument_list|(
name|exprMap
argument_list|,
name|outputColumnNames
argument_list|,
name|join
operator|.
name|getNoOuterJoin
argument_list|()
argument_list|,
name|joinCondns
argument_list|,
name|filterMap
argument_list|)
decl_stmt|;
name|desc
operator|.
name|setReversedExprs
argument_list|(
name|reversedExprs
argument_list|)
expr_stmt|;
name|desc
operator|.
name|setFilterMap
argument_list|(
name|join
operator|.
name|getFilterMap
argument_list|()
argument_list|)
expr_stmt|;
name|JoinOperator
name|joinOp
init|=
operator|(
name|JoinOperator
operator|)
name|OperatorFactory
operator|.
name|getAndMakeChild
argument_list|(
name|desc
argument_list|,
operator|new
name|RowSchema
argument_list|(
name|outputRS
operator|.
name|getColumnInfos
argument_list|()
argument_list|)
argument_list|,
name|rightOps
argument_list|)
decl_stmt|;
name|joinOp
operator|.
name|setColumnExprMap
argument_list|(
name|colExprMap
argument_list|)
expr_stmt|;
name|joinOp
operator|.
name|setPosToAliasMap
argument_list|(
name|posToAliasMap
argument_list|)
expr_stmt|;
if|if
condition|(
name|join
operator|.
name|getNullSafes
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|boolean
index|[]
name|nullsafes
init|=
operator|new
name|boolean
index|[
name|join
operator|.
name|getNullSafes
argument_list|()
operator|.
name|size
argument_list|()
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|nullsafes
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|nullsafes
index|[
name|i
index|]
operator|=
name|join
operator|.
name|getNullSafes
argument_list|()
operator|.
name|get
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
name|desc
operator|.
name|setNullSafes
argument_list|(
name|nullsafes
argument_list|)
expr_stmt|;
block|}
return|return
name|putOpInsertMap
argument_list|(
name|joinOp
argument_list|,
name|outputRS
argument_list|)
return|;
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"nls"
argument_list|)
specifier|private
name|Operator
name|genJoinReduceSinkChild
parameter_list|(
name|QB
name|qb
parameter_list|,
name|QBJoinTree
name|joinTree
parameter_list|,
name|Operator
name|child
parameter_list|,
name|String
name|srcName
parameter_list|,
name|int
name|pos
parameter_list|)
throws|throws
name|SemanticException
block|{
name|RowResolver
name|inputRS
init|=
name|opParseCtx
operator|.
name|get
argument_list|(
name|child
argument_list|)
operator|.
name|getRowResolver
argument_list|()
decl_stmt|;
name|RowResolver
name|outputRS
init|=
operator|new
name|RowResolver
argument_list|()
decl_stmt|;
name|ArrayList
argument_list|<
name|String
argument_list|>
name|outputColumns
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
name|ArrayList
argument_list|<
name|ExprNodeDesc
argument_list|>
name|reduceKeys
init|=
operator|new
name|ArrayList
argument_list|<
name|ExprNodeDesc
argument_list|>
argument_list|()
decl_stmt|;
comment|// Compute join keys and store in reduceKeys
name|ArrayList
argument_list|<
name|ASTNode
argument_list|>
name|exprs
init|=
name|joinTree
operator|.
name|getExpressions
argument_list|()
operator|.
name|get
argument_list|(
name|pos
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|exprs
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|ASTNode
name|expr
init|=
name|exprs
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|reduceKeys
operator|.
name|add
argument_list|(
name|genExprNodeDesc
argument_list|(
name|expr
argument_list|,
name|inputRS
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// Walk over the input row resolver and copy in the output
name|ArrayList
argument_list|<
name|ExprNodeDesc
argument_list|>
name|reduceValues
init|=
operator|new
name|ArrayList
argument_list|<
name|ExprNodeDesc
argument_list|>
argument_list|()
decl_stmt|;
name|Iterator
argument_list|<
name|String
argument_list|>
name|tblNamesIter
init|=
name|inputRS
operator|.
name|getTableNames
argument_list|()
operator|.
name|iterator
argument_list|()
decl_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|ExprNodeDesc
argument_list|>
name|colExprMap
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|ExprNodeDesc
argument_list|>
argument_list|()
decl_stmt|;
while|while
condition|(
name|tblNamesIter
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|String
name|src
init|=
name|tblNamesIter
operator|.
name|next
argument_list|()
decl_stmt|;
name|HashMap
argument_list|<
name|String
argument_list|,
name|ColumnInfo
argument_list|>
name|fMap
init|=
name|inputRS
operator|.
name|getFieldMap
argument_list|(
name|src
argument_list|)
decl_stmt|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|ColumnInfo
argument_list|>
name|entry
range|:
name|fMap
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|String
name|field
init|=
name|entry
operator|.
name|getKey
argument_list|()
decl_stmt|;
name|ColumnInfo
name|valueInfo
init|=
name|entry
operator|.
name|getValue
argument_list|()
decl_stmt|;
name|ExprNodeColumnDesc
name|inputExpr
init|=
operator|new
name|ExprNodeColumnDesc
argument_list|(
name|valueInfo
operator|.
name|getType
argument_list|()
argument_list|,
name|valueInfo
operator|.
name|getInternalName
argument_list|()
argument_list|,
name|valueInfo
operator|.
name|getTabAlias
argument_list|()
argument_list|,
name|valueInfo
operator|.
name|getIsVirtualCol
argument_list|()
argument_list|)
decl_stmt|;
name|reduceValues
operator|.
name|add
argument_list|(
name|inputExpr
argument_list|)
expr_stmt|;
if|if
condition|(
name|outputRS
operator|.
name|get
argument_list|(
name|src
argument_list|,
name|field
argument_list|)
operator|==
literal|null
condition|)
block|{
name|String
name|col
init|=
name|getColumnInternalName
argument_list|(
name|reduceValues
operator|.
name|size
argument_list|()
operator|-
literal|1
argument_list|)
decl_stmt|;
name|outputColumns
operator|.
name|add
argument_list|(
name|col
argument_list|)
expr_stmt|;
name|ColumnInfo
name|newColInfo
init|=
operator|new
name|ColumnInfo
argument_list|(
name|Utilities
operator|.
name|ReduceField
operator|.
name|VALUE
operator|.
name|toString
argument_list|()
operator|+
literal|"."
operator|+
name|col
argument_list|,
name|valueInfo
operator|.
name|getType
argument_list|()
argument_list|,
name|src
argument_list|,
name|valueInfo
operator|.
name|getIsVirtualCol
argument_list|()
argument_list|,
name|valueInfo
operator|.
name|isHiddenVirtualCol
argument_list|()
argument_list|)
decl_stmt|;
name|colExprMap
operator|.
name|put
argument_list|(
name|newColInfo
operator|.
name|getInternalName
argument_list|()
argument_list|,
name|inputExpr
argument_list|)
expr_stmt|;
name|outputRS
operator|.
name|put
argument_list|(
name|src
argument_list|,
name|field
argument_list|,
name|newColInfo
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|int
name|numReds
init|=
operator|-
literal|1
decl_stmt|;
comment|// Use only 1 reducer in case of cartesian product
if|if
condition|(
name|reduceKeys
operator|.
name|size
argument_list|()
operator|==
literal|0
condition|)
block|{
name|numReds
operator|=
literal|1
expr_stmt|;
comment|// Cartesian product is not supported in strict mode
if|if
condition|(
name|conf
operator|.
name|getVar
argument_list|(
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVEMAPREDMODE
argument_list|)
operator|.
name|equalsIgnoreCase
argument_list|(
literal|"strict"
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|NO_CARTESIAN_PRODUCT
operator|.
name|getMsg
argument_list|()
argument_list|)
throw|;
block|}
block|}
name|ReduceSinkOperator
name|rsOp
init|=
operator|(
name|ReduceSinkOperator
operator|)
name|putOpInsertMap
argument_list|(
name|OperatorFactory
operator|.
name|getAndMakeChild
argument_list|(
name|PlanUtils
operator|.
name|getReduceSinkDesc
argument_list|(
name|reduceKeys
argument_list|,
name|reduceValues
argument_list|,
name|outputColumns
argument_list|,
literal|false
argument_list|,
name|joinTree
operator|.
name|getNextTag
argument_list|()
argument_list|,
name|reduceKeys
operator|.
name|size
argument_list|()
argument_list|,
name|numReds
argument_list|)
argument_list|,
operator|new
name|RowSchema
argument_list|(
name|outputRS
operator|.
name|getColumnInfos
argument_list|()
argument_list|)
argument_list|,
name|child
argument_list|)
argument_list|,
name|outputRS
argument_list|)
decl_stmt|;
name|rsOp
operator|.
name|setColumnExprMap
argument_list|(
name|colExprMap
argument_list|)
expr_stmt|;
name|rsOp
operator|.
name|setInputAlias
argument_list|(
name|srcName
argument_list|)
expr_stmt|;
return|return
name|rsOp
return|;
block|}
specifier|private
name|Operator
name|genJoinOperator
parameter_list|(
name|QB
name|qb
parameter_list|,
name|QBJoinTree
name|joinTree
parameter_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|Operator
argument_list|>
name|map
parameter_list|,
name|Operator
name|joiningOp
parameter_list|)
throws|throws
name|SemanticException
block|{
name|QBJoinTree
name|leftChild
init|=
name|joinTree
operator|.
name|getJoinSrc
argument_list|()
decl_stmt|;
name|Operator
name|joinSrcOp
init|=
name|joiningOp
operator|instanceof
name|JoinOperator
condition|?
name|joiningOp
else|:
literal|null
decl_stmt|;
if|if
condition|(
name|joinSrcOp
operator|==
literal|null
operator|&&
name|leftChild
operator|!=
literal|null
condition|)
block|{
name|joinSrcOp
operator|=
name|genJoinOperator
argument_list|(
name|qb
argument_list|,
name|leftChild
argument_list|,
name|map
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|joinSrcOp
operator|!=
literal|null
condition|)
block|{
name|ArrayList
argument_list|<
name|ASTNode
argument_list|>
name|filter
init|=
name|joinTree
operator|.
name|getFiltersForPushing
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
for|for
control|(
name|ASTNode
name|cond
range|:
name|filter
control|)
block|{
name|joinSrcOp
operator|=
name|genFilterPlan
argument_list|(
name|qb
argument_list|,
name|cond
argument_list|,
name|joinSrcOp
argument_list|)
expr_stmt|;
block|}
name|joinSrcOp
operator|=
name|genJoinReduceSinkChild
argument_list|(
name|qb
argument_list|,
name|joinTree
argument_list|,
name|joinSrcOp
argument_list|,
literal|null
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|Operator
index|[]
name|srcOps
init|=
operator|new
name|Operator
index|[
name|joinTree
operator|.
name|getBaseSrc
argument_list|()
operator|.
name|length
index|]
decl_stmt|;
name|HashSet
argument_list|<
name|Integer
argument_list|>
name|omitOpts
init|=
literal|null
decl_stmt|;
comment|// set of input to the join that should be
comment|// omitted by the output
name|int
name|pos
init|=
literal|0
decl_stmt|;
for|for
control|(
name|String
name|src
range|:
name|joinTree
operator|.
name|getBaseSrc
argument_list|()
control|)
block|{
if|if
condition|(
name|src
operator|!=
literal|null
condition|)
block|{
name|Operator
name|srcOp
init|=
name|map
operator|.
name|get
argument_list|(
name|src
operator|.
name|toLowerCase
argument_list|()
argument_list|)
decl_stmt|;
comment|// for left-semi join, generate an additional selection& group-by
comment|// operator before ReduceSink
name|ArrayList
argument_list|<
name|ASTNode
argument_list|>
name|fields
init|=
name|joinTree
operator|.
name|getRHSSemijoinColumns
argument_list|(
name|src
argument_list|)
decl_stmt|;
if|if
condition|(
name|fields
operator|!=
literal|null
condition|)
block|{
comment|// the RHS table columns should be not be output from the join
if|if
condition|(
name|omitOpts
operator|==
literal|null
condition|)
block|{
name|omitOpts
operator|=
operator|new
name|HashSet
argument_list|<
name|Integer
argument_list|>
argument_list|()
expr_stmt|;
block|}
name|omitOpts
operator|.
name|add
argument_list|(
name|pos
argument_list|)
expr_stmt|;
comment|// generate a selection operator for group-by keys only
name|srcOp
operator|=
name|insertSelectForSemijoin
argument_list|(
name|fields
argument_list|,
name|srcOp
argument_list|)
expr_stmt|;
comment|// generate a groupby operator (HASH mode) for a map-side partial
comment|// aggregation for semijoin
name|srcOp
operator|=
name|genMapGroupByForSemijoin
argument_list|(
name|qb
argument_list|,
name|fields
argument_list|,
name|srcOp
argument_list|,
name|GroupByDesc
operator|.
name|Mode
operator|.
name|HASH
argument_list|)
expr_stmt|;
block|}
comment|// generate a ReduceSink operator for the join
name|srcOps
index|[
name|pos
index|]
operator|=
name|genJoinReduceSinkChild
argument_list|(
name|qb
argument_list|,
name|joinTree
argument_list|,
name|srcOp
argument_list|,
name|src
argument_list|,
name|pos
argument_list|)
expr_stmt|;
name|pos
operator|++
expr_stmt|;
block|}
else|else
block|{
assert|assert
name|pos
operator|==
literal|0
assert|;
name|srcOps
index|[
name|pos
operator|++
index|]
operator|=
literal|null
expr_stmt|;
block|}
block|}
comment|// Type checking and implicit type conversion for join keys
name|genJoinOperatorTypeCheck
argument_list|(
name|joinSrcOp
argument_list|,
name|srcOps
argument_list|)
expr_stmt|;
name|JoinOperator
name|joinOp
init|=
operator|(
name|JoinOperator
operator|)
name|genJoinOperatorChildren
argument_list|(
name|joinTree
argument_list|,
name|joinSrcOp
argument_list|,
name|srcOps
argument_list|,
name|omitOpts
argument_list|)
decl_stmt|;
name|joinContext
operator|.
name|put
argument_list|(
name|joinOp
argument_list|,
name|joinTree
argument_list|)
expr_stmt|;
name|Operator
name|op
init|=
name|joinOp
decl_stmt|;
for|for
control|(
name|ASTNode
name|condn
range|:
name|joinTree
operator|.
name|getPostJoinFilters
argument_list|()
control|)
block|{
name|op
operator|=
name|genFilterPlan
argument_list|(
name|qb
argument_list|,
name|condn
argument_list|,
name|op
argument_list|)
expr_stmt|;
block|}
return|return
name|op
return|;
block|}
comment|/**    * Construct a selection operator for semijoin that filter out all fields    * other than the group by keys.    *    * @param fields    *          list of fields need to be output    * @param input    *          input operator    * @return the selection operator.    * @throws SemanticException    */
specifier|private
name|Operator
name|insertSelectForSemijoin
parameter_list|(
name|ArrayList
argument_list|<
name|ASTNode
argument_list|>
name|fields
parameter_list|,
name|Operator
name|input
parameter_list|)
throws|throws
name|SemanticException
block|{
name|RowResolver
name|inputRR
init|=
name|opParseCtx
operator|.
name|get
argument_list|(
name|input
argument_list|)
operator|.
name|getRowResolver
argument_list|()
decl_stmt|;
name|ArrayList
argument_list|<
name|ExprNodeDesc
argument_list|>
name|colList
init|=
operator|new
name|ArrayList
argument_list|<
name|ExprNodeDesc
argument_list|>
argument_list|()
decl_stmt|;
name|ArrayList
argument_list|<
name|String
argument_list|>
name|columnNames
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
comment|// construct the list of columns that need to be projected
for|for
control|(
name|ASTNode
name|field
range|:
name|fields
control|)
block|{
name|ExprNodeColumnDesc
name|exprNode
init|=
operator|(
name|ExprNodeColumnDesc
operator|)
name|genExprNodeDesc
argument_list|(
name|field
argument_list|,
name|inputRR
argument_list|)
decl_stmt|;
name|colList
operator|.
name|add
argument_list|(
name|exprNode
argument_list|)
expr_stmt|;
name|columnNames
operator|.
name|add
argument_list|(
name|exprNode
operator|.
name|getColumn
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// create selection operator
name|Operator
name|output
init|=
name|putOpInsertMap
argument_list|(
name|OperatorFactory
operator|.
name|getAndMakeChild
argument_list|(
operator|new
name|SelectDesc
argument_list|(
name|colList
argument_list|,
name|columnNames
argument_list|,
literal|false
argument_list|)
argument_list|,
operator|new
name|RowSchema
argument_list|(
name|inputRR
operator|.
name|getColumnInfos
argument_list|()
argument_list|)
argument_list|,
name|input
argument_list|)
argument_list|,
name|inputRR
argument_list|)
decl_stmt|;
name|output
operator|.
name|setColumnExprMap
argument_list|(
name|input
operator|.
name|getColumnExprMap
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|output
return|;
block|}
specifier|private
name|Operator
name|genMapGroupByForSemijoin
parameter_list|(
name|QB
name|qb
parameter_list|,
name|ArrayList
argument_list|<
name|ASTNode
argument_list|>
name|fields
parameter_list|,
comment|// the
comment|// ASTNode
comment|// of
comment|// the
comment|// join
comment|// key
comment|// "tab.col"
name|Operator
name|inputOperatorInfo
parameter_list|,
name|GroupByDesc
operator|.
name|Mode
name|mode
parameter_list|)
throws|throws
name|SemanticException
block|{
name|RowResolver
name|groupByInputRowResolver
init|=
name|opParseCtx
operator|.
name|get
argument_list|(
name|inputOperatorInfo
argument_list|)
operator|.
name|getRowResolver
argument_list|()
decl_stmt|;
name|RowResolver
name|groupByOutputRowResolver
init|=
operator|new
name|RowResolver
argument_list|()
decl_stmt|;
name|ArrayList
argument_list|<
name|ExprNodeDesc
argument_list|>
name|groupByKeys
init|=
operator|new
name|ArrayList
argument_list|<
name|ExprNodeDesc
argument_list|>
argument_list|()
decl_stmt|;
name|ArrayList
argument_list|<
name|String
argument_list|>
name|outputColumnNames
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
name|ArrayList
argument_list|<
name|AggregationDesc
argument_list|>
name|aggregations
init|=
operator|new
name|ArrayList
argument_list|<
name|AggregationDesc
argument_list|>
argument_list|()
decl_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|ExprNodeDesc
argument_list|>
name|colExprMap
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|ExprNodeDesc
argument_list|>
argument_list|()
decl_stmt|;
name|qb
operator|.
name|getParseInfo
argument_list|()
expr_stmt|;
name|groupByOutputRowResolver
operator|.
name|setIsExprResolver
argument_list|(
literal|true
argument_list|)
expr_stmt|;
comment|// join keys should only
comment|// be columns but not be
comment|// expressions
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|fields
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
comment|// get the group by keys to ColumnInfo
name|ASTNode
name|colName
init|=
name|fields
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|ExprNodeDesc
name|grpByExprNode
init|=
name|genExprNodeDesc
argument_list|(
name|colName
argument_list|,
name|groupByInputRowResolver
argument_list|)
decl_stmt|;
name|groupByKeys
operator|.
name|add
argument_list|(
name|grpByExprNode
argument_list|)
expr_stmt|;
comment|// generate output column names
name|String
name|field
init|=
name|getColumnInternalName
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|outputColumnNames
operator|.
name|add
argument_list|(
name|field
argument_list|)
expr_stmt|;
name|ColumnInfo
name|colInfo2
init|=
operator|new
name|ColumnInfo
argument_list|(
name|field
argument_list|,
name|grpByExprNode
operator|.
name|getTypeInfo
argument_list|()
argument_list|,
literal|""
argument_list|,
literal|false
argument_list|)
decl_stmt|;
name|groupByOutputRowResolver
operator|.
name|putExpression
argument_list|(
name|colName
argument_list|,
name|colInfo2
argument_list|)
expr_stmt|;
comment|// establish mapping from the output column to the input column
name|colExprMap
operator|.
name|put
argument_list|(
name|field
argument_list|,
name|grpByExprNode
argument_list|)
expr_stmt|;
block|}
comment|// Generate group-by operator
name|float
name|groupByMemoryUsage
init|=
name|HiveConf
operator|.
name|getFloatVar
argument_list|(
name|conf
argument_list|,
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVEMAPAGGRHASHMEMORY
argument_list|)
decl_stmt|;
name|float
name|memoryThreshold
init|=
name|HiveConf
operator|.
name|getFloatVar
argument_list|(
name|conf
argument_list|,
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVEMAPAGGRMEMORYTHRESHOLD
argument_list|)
decl_stmt|;
name|Operator
name|op
init|=
name|putOpInsertMap
argument_list|(
name|OperatorFactory
operator|.
name|getAndMakeChild
argument_list|(
operator|new
name|GroupByDesc
argument_list|(
name|mode
argument_list|,
name|outputColumnNames
argument_list|,
name|groupByKeys
argument_list|,
name|aggregations
argument_list|,
literal|false
argument_list|,
name|groupByMemoryUsage
argument_list|,
name|memoryThreshold
argument_list|,
literal|null
argument_list|,
literal|false
argument_list|,
literal|0
argument_list|,
literal|false
argument_list|)
argument_list|,
operator|new
name|RowSchema
argument_list|(
name|groupByOutputRowResolver
operator|.
name|getColumnInfos
argument_list|()
argument_list|)
argument_list|,
name|inputOperatorInfo
argument_list|)
argument_list|,
name|groupByOutputRowResolver
argument_list|)
decl_stmt|;
name|op
operator|.
name|setColumnExprMap
argument_list|(
name|colExprMap
argument_list|)
expr_stmt|;
return|return
name|op
return|;
block|}
specifier|private
name|void
name|genJoinOperatorTypeCheck
parameter_list|(
name|Operator
name|left
parameter_list|,
name|Operator
index|[]
name|right
parameter_list|)
throws|throws
name|SemanticException
block|{
comment|// keys[i] -> ArrayList<exprNodeDesc> for the i-th join operator key list
name|ArrayList
argument_list|<
name|ArrayList
argument_list|<
name|ExprNodeDesc
argument_list|>
argument_list|>
name|keys
init|=
operator|new
name|ArrayList
argument_list|<
name|ArrayList
argument_list|<
name|ExprNodeDesc
argument_list|>
argument_list|>
argument_list|()
decl_stmt|;
name|int
name|keyLength
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|right
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|Operator
name|oi
init|=
operator|(
name|i
operator|==
literal|0
operator|&&
name|right
index|[
name|i
index|]
operator|==
literal|null
condition|?
name|left
else|:
name|right
index|[
name|i
index|]
operator|)
decl_stmt|;
name|ReduceSinkDesc
name|now
init|=
operator|(
call|(
name|ReduceSinkOperator
call|)
argument_list|(
name|oi
argument_list|)
operator|)
operator|.
name|getConf
argument_list|()
decl_stmt|;
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
name|keyLength
operator|=
name|now
operator|.
name|getKeyCols
argument_list|()
operator|.
name|size
argument_list|()
expr_stmt|;
block|}
else|else
block|{
assert|assert
operator|(
name|keyLength
operator|==
name|now
operator|.
name|getKeyCols
argument_list|()
operator|.
name|size
argument_list|()
operator|)
assert|;
block|}
name|keys
operator|.
name|add
argument_list|(
name|now
operator|.
name|getKeyCols
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// implicit type conversion hierarchy
for|for
control|(
name|int
name|k
init|=
literal|0
init|;
name|k
operator|<
name|keyLength
condition|;
name|k
operator|++
control|)
block|{
comment|// Find the common class for type conversion
name|TypeInfo
name|commonType
init|=
name|keys
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|get
argument_list|(
name|k
argument_list|)
operator|.
name|getTypeInfo
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<
name|right
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|TypeInfo
name|a
init|=
name|commonType
decl_stmt|;
name|TypeInfo
name|b
init|=
name|keys
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|get
argument_list|(
name|k
argument_list|)
operator|.
name|getTypeInfo
argument_list|()
decl_stmt|;
name|commonType
operator|=
name|FunctionRegistry
operator|.
name|getCommonClassForComparison
argument_list|(
name|a
argument_list|,
name|b
argument_list|)
expr_stmt|;
if|if
condition|(
name|commonType
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
literal|"Cannot do equality join on different types: "
operator|+
name|a
operator|.
name|getTypeName
argument_list|()
operator|+
literal|" and "
operator|+
name|b
operator|.
name|getTypeName
argument_list|()
argument_list|)
throw|;
block|}
block|}
comment|// Add implicit type conversion if necessary
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|right
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|TypeInfoUtils
operator|.
name|isConversionRequiredForComparison
argument_list|(
name|keys
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|get
argument_list|(
name|k
argument_list|)
operator|.
name|getTypeInfo
argument_list|()
argument_list|,
name|commonType
argument_list|)
condition|)
block|{
name|keys
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|set
argument_list|(
name|k
argument_list|,
name|ParseUtils
operator|.
name|createConversionCast
argument_list|(
name|keys
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|get
argument_list|(
name|k
argument_list|)
argument_list|,
operator|(
name|PrimitiveTypeInfo
operator|)
name|commonType
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|// regenerate keySerializationInfo because the ReduceSinkOperator's
comment|// output key types might have changed.
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|right
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|Operator
name|oi
init|=
operator|(
name|i
operator|==
literal|0
operator|&&
name|right
index|[
name|i
index|]
operator|==
literal|null
condition|?
name|left
else|:
name|right
index|[
name|i
index|]
operator|)
decl_stmt|;
name|ReduceSinkDesc
name|now
init|=
operator|(
call|(
name|ReduceSinkOperator
call|)
argument_list|(
name|oi
argument_list|)
operator|)
operator|.
name|getConf
argument_list|()
decl_stmt|;
name|now
operator|.
name|setKeySerializeInfo
argument_list|(
name|PlanUtils
operator|.
name|getReduceKeyTableDesc
argument_list|(
name|PlanUtils
operator|.
name|getFieldSchemasFromColumnList
argument_list|(
name|now
operator|.
name|getKeyCols
argument_list|()
argument_list|,
literal|"joinkey"
argument_list|)
argument_list|,
name|now
operator|.
name|getOrder
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
name|Operator
name|genJoinPlan
parameter_list|(
name|QB
name|qb
parameter_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|Operator
argument_list|>
name|map
parameter_list|)
throws|throws
name|SemanticException
block|{
name|QBJoinTree
name|joinTree
init|=
name|qb
operator|.
name|getQbJoinTree
argument_list|()
decl_stmt|;
name|Operator
name|joinOp
init|=
name|genJoinOperator
argument_list|(
name|qb
argument_list|,
name|joinTree
argument_list|,
name|map
argument_list|,
literal|null
argument_list|)
decl_stmt|;
return|return
name|joinOp
return|;
block|}
comment|/**    * Extract the filters from the join condition and push them on top of the    * source operators. This procedure traverses the query tree recursively,    */
specifier|private
name|void
name|pushJoinFilters
parameter_list|(
name|QB
name|qb
parameter_list|,
name|QBJoinTree
name|joinTree
parameter_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|Operator
argument_list|>
name|map
parameter_list|)
throws|throws
name|SemanticException
block|{
name|pushJoinFilters
argument_list|(
name|qb
argument_list|,
name|joinTree
argument_list|,
name|map
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
comment|/**    * Extract the filters from the join condition and push them on top of the    * source operators. This procedure traverses the query tree recursively,    */
specifier|private
name|void
name|pushJoinFilters
parameter_list|(
name|QB
name|qb
parameter_list|,
name|QBJoinTree
name|joinTree
parameter_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|Operator
argument_list|>
name|map
parameter_list|,
name|boolean
name|recursively
parameter_list|)
throws|throws
name|SemanticException
block|{
if|if
condition|(
name|recursively
condition|)
block|{
if|if
condition|(
name|joinTree
operator|.
name|getJoinSrc
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|pushJoinFilters
argument_list|(
name|qb
argument_list|,
name|joinTree
operator|.
name|getJoinSrc
argument_list|()
argument_list|,
name|map
argument_list|)
expr_stmt|;
block|}
block|}
name|ArrayList
argument_list|<
name|ArrayList
argument_list|<
name|ASTNode
argument_list|>
argument_list|>
name|filters
init|=
name|joinTree
operator|.
name|getFiltersForPushing
argument_list|()
decl_stmt|;
name|int
name|pos
init|=
literal|0
decl_stmt|;
for|for
control|(
name|String
name|src
range|:
name|joinTree
operator|.
name|getBaseSrc
argument_list|()
control|)
block|{
if|if
condition|(
name|src
operator|!=
literal|null
condition|)
block|{
name|Operator
name|srcOp
init|=
name|map
operator|.
name|get
argument_list|(
name|src
argument_list|)
decl_stmt|;
name|ArrayList
argument_list|<
name|ASTNode
argument_list|>
name|filter
init|=
name|filters
operator|.
name|get
argument_list|(
name|pos
argument_list|)
decl_stmt|;
for|for
control|(
name|ASTNode
name|cond
range|:
name|filter
control|)
block|{
name|srcOp
operator|=
name|genFilterPlan
argument_list|(
name|qb
argument_list|,
name|cond
argument_list|,
name|srcOp
argument_list|)
expr_stmt|;
block|}
name|map
operator|.
name|put
argument_list|(
name|src
argument_list|,
name|srcOp
argument_list|)
expr_stmt|;
block|}
name|pos
operator|++
expr_stmt|;
block|}
block|}
specifier|private
name|List
argument_list|<
name|String
argument_list|>
name|getMapSideJoinTables
parameter_list|(
name|QB
name|qb
parameter_list|)
block|{
name|List
argument_list|<
name|String
argument_list|>
name|cols
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
name|ASTNode
name|hints
init|=
name|qb
operator|.
name|getParseInfo
argument_list|()
operator|.
name|getHints
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|pos
init|=
literal|0
init|;
name|pos
operator|<
name|hints
operator|.
name|getChildCount
argument_list|()
condition|;
name|pos
operator|++
control|)
block|{
name|ASTNode
name|hint
init|=
operator|(
name|ASTNode
operator|)
name|hints
operator|.
name|getChild
argument_list|(
name|pos
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
operator|(
name|ASTNode
operator|)
name|hint
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|)
operator|.
name|getToken
argument_list|()
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_MAPJOIN
condition|)
block|{
comment|// the user has specified to ignore mapjoin hint
if|if
condition|(
operator|!
name|conf
operator|.
name|getBoolVar
argument_list|(
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVEIGNOREMAPJOINHINT
argument_list|)
operator|&&
operator|!
name|conf
operator|.
name|getBoolVar
argument_list|(
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVE_OPTIMIZE_TEZ
argument_list|)
condition|)
block|{
name|ASTNode
name|hintTblNames
init|=
operator|(
name|ASTNode
operator|)
name|hint
operator|.
name|getChild
argument_list|(
literal|1
argument_list|)
decl_stmt|;
name|int
name|numCh
init|=
name|hintTblNames
operator|.
name|getChildCount
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|tblPos
init|=
literal|0
init|;
name|tblPos
operator|<
name|numCh
condition|;
name|tblPos
operator|++
control|)
block|{
name|String
name|tblName
init|=
operator|(
operator|(
name|ASTNode
operator|)
name|hintTblNames
operator|.
name|getChild
argument_list|(
name|tblPos
argument_list|)
operator|)
operator|.
name|getText
argument_list|()
operator|.
name|toLowerCase
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|cols
operator|.
name|contains
argument_list|(
name|tblName
argument_list|)
condition|)
block|{
name|cols
operator|.
name|add
argument_list|(
name|tblName
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|queryProperties
operator|.
name|setMapJoinRemoved
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
name|cols
return|;
block|}
comment|// The join alias is modified before being inserted for consumption by sort-merge
comment|// join queries. If the join is part of a sub-query the alias is modified to include
comment|// the sub-query alias.
specifier|private
name|String
name|getModifiedAlias
parameter_list|(
name|QB
name|qb
parameter_list|,
name|String
name|alias
parameter_list|)
block|{
return|return
name|QB
operator|.
name|getAppendedAliasFromId
argument_list|(
name|qb
operator|.
name|getId
argument_list|()
argument_list|,
name|alias
argument_list|)
return|;
block|}
specifier|private
name|QBJoinTree
name|genUniqueJoinTree
parameter_list|(
name|QB
name|qb
parameter_list|,
name|ASTNode
name|joinParseTree
parameter_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|Operator
argument_list|>
name|aliasToOpInfo
parameter_list|)
throws|throws
name|SemanticException
block|{
name|QBJoinTree
name|joinTree
init|=
operator|new
name|QBJoinTree
argument_list|()
decl_stmt|;
name|joinTree
operator|.
name|setNoOuterJoin
argument_list|(
literal|false
argument_list|)
expr_stmt|;
name|joinTree
operator|.
name|setExpressions
argument_list|(
operator|new
name|ArrayList
argument_list|<
name|ArrayList
argument_list|<
name|ASTNode
argument_list|>
argument_list|>
argument_list|()
argument_list|)
expr_stmt|;
name|joinTree
operator|.
name|setFilters
argument_list|(
operator|new
name|ArrayList
argument_list|<
name|ArrayList
argument_list|<
name|ASTNode
argument_list|>
argument_list|>
argument_list|()
argument_list|)
expr_stmt|;
name|joinTree
operator|.
name|setFiltersForPushing
argument_list|(
operator|new
name|ArrayList
argument_list|<
name|ArrayList
argument_list|<
name|ASTNode
argument_list|>
argument_list|>
argument_list|()
argument_list|)
expr_stmt|;
comment|// Create joinTree structures to fill them up later
name|ArrayList
argument_list|<
name|String
argument_list|>
name|rightAliases
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
name|ArrayList
argument_list|<
name|String
argument_list|>
name|leftAliases
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
name|ArrayList
argument_list|<
name|String
argument_list|>
name|baseSrc
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
name|ArrayList
argument_list|<
name|Boolean
argument_list|>
name|preserved
init|=
operator|new
name|ArrayList
argument_list|<
name|Boolean
argument_list|>
argument_list|()
decl_stmt|;
name|boolean
name|lastPreserved
init|=
literal|false
decl_stmt|;
name|int
name|cols
init|=
operator|-
literal|1
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|joinParseTree
operator|.
name|getChildCount
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|ASTNode
name|child
init|=
operator|(
name|ASTNode
operator|)
name|joinParseTree
operator|.
name|getChild
argument_list|(
name|i
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|child
operator|.
name|getToken
argument_list|()
operator|.
name|getType
argument_list|()
condition|)
block|{
case|case
name|HiveParser
operator|.
name|TOK_TABREF
case|:
comment|// Handle a table - populate aliases appropriately:
comment|// leftAliases should contain the first table, rightAliases should
comment|// contain all other tables and baseSrc should contain all tables
name|String
name|tableName
init|=
name|getUnescapedUnqualifiedTableName
argument_list|(
operator|(
name|ASTNode
operator|)
name|child
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|String
name|alias
init|=
name|child
operator|.
name|getChildCount
argument_list|()
operator|==
literal|1
condition|?
name|tableName
else|:
name|unescapeIdentifier
argument_list|(
name|child
operator|.
name|getChild
argument_list|(
name|child
operator|.
name|getChildCount
argument_list|()
operator|-
literal|1
argument_list|)
operator|.
name|getText
argument_list|()
operator|.
name|toLowerCase
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
name|leftAliases
operator|.
name|add
argument_list|(
name|alias
argument_list|)
expr_stmt|;
name|joinTree
operator|.
name|setLeftAlias
argument_list|(
name|alias
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|rightAliases
operator|.
name|add
argument_list|(
name|alias
argument_list|)
expr_stmt|;
block|}
name|joinTree
operator|.
name|getAliasToOpInfo
argument_list|()
operator|.
name|put
argument_list|(
name|getModifiedAlias
argument_list|(
name|qb
argument_list|,
name|alias
argument_list|)
argument_list|,
name|aliasToOpInfo
operator|.
name|get
argument_list|(
name|alias
argument_list|)
argument_list|)
expr_stmt|;
name|joinTree
operator|.
name|setId
argument_list|(
name|qb
operator|.
name|getId
argument_list|()
argument_list|)
expr_stmt|;
name|baseSrc
operator|.
name|add
argument_list|(
name|alias
argument_list|)
expr_stmt|;
name|preserved
operator|.
name|add
argument_list|(
name|lastPreserved
argument_list|)
expr_stmt|;
name|lastPreserved
operator|=
literal|false
expr_stmt|;
break|break;
case|case
name|HiveParser
operator|.
name|TOK_EXPLIST
case|:
if|if
condition|(
name|cols
operator|==
operator|-
literal|1
operator|&&
name|child
operator|.
name|getChildCount
argument_list|()
operator|!=
literal|0
condition|)
block|{
name|cols
operator|=
name|child
operator|.
name|getChildCount
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|child
operator|.
name|getChildCount
argument_list|()
operator|!=
name|cols
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
literal|"Tables with different or invalid "
operator|+
literal|"number of keys in UNIQUEJOIN"
argument_list|)
throw|;
block|}
name|ArrayList
argument_list|<
name|ASTNode
argument_list|>
name|expressions
init|=
operator|new
name|ArrayList
argument_list|<
name|ASTNode
argument_list|>
argument_list|()
decl_stmt|;
name|ArrayList
argument_list|<
name|ASTNode
argument_list|>
name|filt
init|=
operator|new
name|ArrayList
argument_list|<
name|ASTNode
argument_list|>
argument_list|()
decl_stmt|;
name|ArrayList
argument_list|<
name|ASTNode
argument_list|>
name|filters
init|=
operator|new
name|ArrayList
argument_list|<
name|ASTNode
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|Node
name|exp
range|:
name|child
operator|.
name|getChildren
argument_list|()
control|)
block|{
name|expressions
operator|.
name|add
argument_list|(
operator|(
name|ASTNode
operator|)
name|exp
argument_list|)
expr_stmt|;
block|}
name|joinTree
operator|.
name|getExpressions
argument_list|()
operator|.
name|add
argument_list|(
name|expressions
argument_list|)
expr_stmt|;
name|joinTree
operator|.
name|getFilters
argument_list|()
operator|.
name|add
argument_list|(
name|filt
argument_list|)
expr_stmt|;
name|joinTree
operator|.
name|getFiltersForPushing
argument_list|()
operator|.
name|add
argument_list|(
name|filters
argument_list|)
expr_stmt|;
break|break;
case|case
name|HiveParser
operator|.
name|KW_PRESERVE
case|:
name|lastPreserved
operator|=
literal|true
expr_stmt|;
break|break;
case|case
name|HiveParser
operator|.
name|TOK_SUBQUERY
case|:
throw|throw
operator|new
name|SemanticException
argument_list|(
literal|"Subqueries are not supported in UNIQUEJOIN"
argument_list|)
throw|;
default|default:
throw|throw
operator|new
name|SemanticException
argument_list|(
literal|"Unexpected UNIQUEJOIN structure"
argument_list|)
throw|;
block|}
block|}
name|joinTree
operator|.
name|setBaseSrc
argument_list|(
name|baseSrc
operator|.
name|toArray
argument_list|(
operator|new
name|String
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|joinTree
operator|.
name|setLeftAliases
argument_list|(
name|leftAliases
operator|.
name|toArray
argument_list|(
operator|new
name|String
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|joinTree
operator|.
name|setRightAliases
argument_list|(
name|rightAliases
operator|.
name|toArray
argument_list|(
operator|new
name|String
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|JoinCond
index|[]
name|condn
init|=
operator|new
name|JoinCond
index|[
name|preserved
operator|.
name|size
argument_list|()
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|condn
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|condn
index|[
name|i
index|]
operator|=
operator|new
name|JoinCond
argument_list|(
name|preserved
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|joinTree
operator|.
name|setJoinCond
argument_list|(
name|condn
argument_list|)
expr_stmt|;
if|if
condition|(
name|qb
operator|.
name|getParseInfo
argument_list|()
operator|.
name|getHints
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|parseStreamTables
argument_list|(
name|joinTree
argument_list|,
name|qb
argument_list|)
expr_stmt|;
block|}
return|return
name|joinTree
return|;
block|}
comment|/*    * Setup a QBJoinTree between a SubQuery and its Parent Query. The Parent Query    * is the lhs of the Join.    *    * The Parent Query is represented by the last Operator needed to process its From Clause.    * In case of a single table Query this will be a TableScan, but it can be a Join Operator    * if the Parent Query contains Join clauses, or in case of a single source from clause,    * the source could be a SubQuery or a PTF invocation.    *    * We setup the QBJoinTree with the above constrains in place. So:    * - the lhs of the QBJoinTree can be a another QBJoinTree if the Parent Query operator    *   is a JoinOperator. In this case we get its QBJoinTree from the 'joinContext'    * - the rhs is always a reference to the SubQuery. Its alias is obtained from the    *   QBSubQuery object.    *    * The QBSubQuery also provides the Joining Condition AST. The Joining Condition has been    * transformed in QBSubQuery setup, before this call. The Joining condition has any correlated    * predicates and a predicate for joining the Parent Query expression with the SubQuery.    *    * The QBSubQuery also specifies what kind of Join to construct.    *    * Given this information, once we initialize the QBJoinTree, we call the 'parseJoinCondition'    * method to validate and parse Join conditions.    */
specifier|private
name|QBJoinTree
name|genSQJoinTree
parameter_list|(
name|QB
name|qb
parameter_list|,
name|ISubQueryJoinInfo
name|subQuery
parameter_list|,
name|Operator
name|joiningOp
parameter_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|Operator
argument_list|>
name|aliasToOpInfo
parameter_list|)
throws|throws
name|SemanticException
block|{
name|QBJoinTree
name|joinTree
init|=
operator|new
name|QBJoinTree
argument_list|()
decl_stmt|;
name|JoinCond
index|[]
name|condn
init|=
operator|new
name|JoinCond
index|[
literal|1
index|]
decl_stmt|;
switch|switch
condition|(
name|subQuery
operator|.
name|getJoinType
argument_list|()
condition|)
block|{
case|case
name|LEFTOUTER
case|:
name|joinTree
operator|.
name|setNoOuterJoin
argument_list|(
literal|false
argument_list|)
expr_stmt|;
name|condn
index|[
literal|0
index|]
operator|=
operator|new
name|JoinCond
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|,
name|JoinType
operator|.
name|LEFTOUTER
argument_list|)
expr_stmt|;
break|break;
case|case
name|RIGHTOUTER
case|:
name|joinTree
operator|.
name|setNoOuterJoin
argument_list|(
literal|false
argument_list|)
expr_stmt|;
name|condn
index|[
literal|0
index|]
operator|=
operator|new
name|JoinCond
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|,
name|JoinType
operator|.
name|RIGHTOUTER
argument_list|)
expr_stmt|;
break|break;
case|case
name|FULLOUTER
case|:
name|joinTree
operator|.
name|setNoOuterJoin
argument_list|(
literal|false
argument_list|)
expr_stmt|;
name|condn
index|[
literal|0
index|]
operator|=
operator|new
name|JoinCond
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|,
name|JoinType
operator|.
name|FULLOUTER
argument_list|)
expr_stmt|;
break|break;
case|case
name|LEFTSEMI
case|:
name|joinTree
operator|.
name|setNoSemiJoin
argument_list|(
literal|false
argument_list|)
expr_stmt|;
name|condn
index|[
literal|0
index|]
operator|=
operator|new
name|JoinCond
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|,
name|JoinType
operator|.
name|LEFTSEMI
argument_list|)
expr_stmt|;
break|break;
default|default:
name|condn
index|[
literal|0
index|]
operator|=
operator|new
name|JoinCond
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|,
name|JoinType
operator|.
name|INNER
argument_list|)
expr_stmt|;
name|joinTree
operator|.
name|setNoOuterJoin
argument_list|(
literal|true
argument_list|)
expr_stmt|;
break|break;
block|}
name|joinTree
operator|.
name|setJoinCond
argument_list|(
name|condn
argument_list|)
expr_stmt|;
if|if
condition|(
name|joiningOp
operator|instanceof
name|JoinOperator
condition|)
block|{
name|QBJoinTree
name|leftTree
init|=
name|joinContext
operator|.
name|get
argument_list|(
name|joiningOp
argument_list|)
decl_stmt|;
name|joinTree
operator|.
name|setJoinSrc
argument_list|(
name|leftTree
argument_list|)
expr_stmt|;
name|String
index|[]
name|leftChildAliases
init|=
name|leftTree
operator|.
name|getLeftAliases
argument_list|()
decl_stmt|;
name|String
name|leftAliases
index|[]
init|=
operator|new
name|String
index|[
name|leftChildAliases
operator|.
name|length
operator|+
literal|1
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|leftChildAliases
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|leftAliases
index|[
name|i
index|]
operator|=
name|leftChildAliases
index|[
name|i
index|]
expr_stmt|;
block|}
name|leftAliases
index|[
name|leftChildAliases
operator|.
name|length
index|]
operator|=
name|leftTree
operator|.
name|getRightAliases
argument_list|()
index|[
literal|0
index|]
expr_stmt|;
name|joinTree
operator|.
name|setLeftAliases
argument_list|(
name|leftAliases
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|String
name|alias
init|=
name|unescapeIdentifier
argument_list|(
name|SubQueryUtils
operator|.
name|getAlias
argument_list|(
name|joiningOp
argument_list|,
name|aliasToOpInfo
argument_list|)
operator|.
name|toLowerCase
argument_list|()
argument_list|)
decl_stmt|;
name|joinTree
operator|.
name|setLeftAlias
argument_list|(
name|alias
argument_list|)
expr_stmt|;
name|String
index|[]
name|leftAliases
init|=
operator|new
name|String
index|[
literal|1
index|]
decl_stmt|;
name|leftAliases
index|[
literal|0
index|]
operator|=
name|alias
expr_stmt|;
name|joinTree
operator|.
name|setLeftAliases
argument_list|(
name|leftAliases
argument_list|)
expr_stmt|;
name|String
index|[]
name|children
init|=
operator|new
name|String
index|[
literal|2
index|]
decl_stmt|;
name|children
index|[
literal|0
index|]
operator|=
name|alias
expr_stmt|;
name|joinTree
operator|.
name|setBaseSrc
argument_list|(
name|children
argument_list|)
expr_stmt|;
name|joinTree
operator|.
name|setId
argument_list|(
name|qb
operator|.
name|getId
argument_list|()
argument_list|)
expr_stmt|;
name|joinTree
operator|.
name|getAliasToOpInfo
argument_list|()
operator|.
name|put
argument_list|(
name|getModifiedAlias
argument_list|(
name|qb
argument_list|,
name|alias
argument_list|)
argument_list|,
name|aliasToOpInfo
operator|.
name|get
argument_list|(
name|alias
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|String
name|rightalias
init|=
name|unescapeIdentifier
argument_list|(
name|subQuery
operator|.
name|getAlias
argument_list|()
operator|.
name|toLowerCase
argument_list|()
argument_list|)
decl_stmt|;
name|String
index|[]
name|rightAliases
init|=
operator|new
name|String
index|[
literal|1
index|]
decl_stmt|;
name|rightAliases
index|[
literal|0
index|]
operator|=
name|rightalias
expr_stmt|;
name|joinTree
operator|.
name|setRightAliases
argument_list|(
name|rightAliases
argument_list|)
expr_stmt|;
name|String
index|[]
name|children
init|=
name|joinTree
operator|.
name|getBaseSrc
argument_list|()
decl_stmt|;
if|if
condition|(
name|children
operator|==
literal|null
condition|)
block|{
name|children
operator|=
operator|new
name|String
index|[
literal|2
index|]
expr_stmt|;
block|}
name|children
index|[
literal|1
index|]
operator|=
name|rightalias
expr_stmt|;
name|joinTree
operator|.
name|setBaseSrc
argument_list|(
name|children
argument_list|)
expr_stmt|;
name|joinTree
operator|.
name|setId
argument_list|(
name|qb
operator|.
name|getId
argument_list|()
argument_list|)
expr_stmt|;
name|joinTree
operator|.
name|getAliasToOpInfo
argument_list|()
operator|.
name|put
argument_list|(
name|getModifiedAlias
argument_list|(
name|qb
argument_list|,
name|rightalias
argument_list|)
argument_list|,
name|aliasToOpInfo
operator|.
name|get
argument_list|(
name|rightalias
argument_list|)
argument_list|)
expr_stmt|;
comment|// remember rhs table for semijoin
if|if
condition|(
name|joinTree
operator|.
name|getNoSemiJoin
argument_list|()
operator|==
literal|false
condition|)
block|{
name|joinTree
operator|.
name|addRHSSemijoin
argument_list|(
name|rightalias
argument_list|)
expr_stmt|;
block|}
name|ArrayList
argument_list|<
name|ArrayList
argument_list|<
name|ASTNode
argument_list|>
argument_list|>
name|expressions
init|=
operator|new
name|ArrayList
argument_list|<
name|ArrayList
argument_list|<
name|ASTNode
argument_list|>
argument_list|>
argument_list|()
decl_stmt|;
name|expressions
operator|.
name|add
argument_list|(
operator|new
name|ArrayList
argument_list|<
name|ASTNode
argument_list|>
argument_list|()
argument_list|)
expr_stmt|;
name|expressions
operator|.
name|add
argument_list|(
operator|new
name|ArrayList
argument_list|<
name|ASTNode
argument_list|>
argument_list|()
argument_list|)
expr_stmt|;
name|joinTree
operator|.
name|setExpressions
argument_list|(
name|expressions
argument_list|)
expr_stmt|;
name|ArrayList
argument_list|<
name|Boolean
argument_list|>
name|nullsafes
init|=
operator|new
name|ArrayList
argument_list|<
name|Boolean
argument_list|>
argument_list|()
decl_stmt|;
name|joinTree
operator|.
name|setNullSafes
argument_list|(
name|nullsafes
argument_list|)
expr_stmt|;
name|ArrayList
argument_list|<
name|ArrayList
argument_list|<
name|ASTNode
argument_list|>
argument_list|>
name|filters
init|=
operator|new
name|ArrayList
argument_list|<
name|ArrayList
argument_list|<
name|ASTNode
argument_list|>
argument_list|>
argument_list|()
decl_stmt|;
name|filters
operator|.
name|add
argument_list|(
operator|new
name|ArrayList
argument_list|<
name|ASTNode
argument_list|>
argument_list|()
argument_list|)
expr_stmt|;
name|filters
operator|.
name|add
argument_list|(
operator|new
name|ArrayList
argument_list|<
name|ASTNode
argument_list|>
argument_list|()
argument_list|)
expr_stmt|;
name|joinTree
operator|.
name|setFilters
argument_list|(
name|filters
argument_list|)
expr_stmt|;
name|joinTree
operator|.
name|setFilterMap
argument_list|(
operator|new
name|int
index|[
literal|2
index|]
index|[]
argument_list|)
expr_stmt|;
name|ArrayList
argument_list|<
name|ArrayList
argument_list|<
name|ASTNode
argument_list|>
argument_list|>
name|filtersForPushing
init|=
operator|new
name|ArrayList
argument_list|<
name|ArrayList
argument_list|<
name|ASTNode
argument_list|>
argument_list|>
argument_list|()
decl_stmt|;
name|filtersForPushing
operator|.
name|add
argument_list|(
operator|new
name|ArrayList
argument_list|<
name|ASTNode
argument_list|>
argument_list|()
argument_list|)
expr_stmt|;
name|filtersForPushing
operator|.
name|add
argument_list|(
operator|new
name|ArrayList
argument_list|<
name|ASTNode
argument_list|>
argument_list|()
argument_list|)
expr_stmt|;
name|joinTree
operator|.
name|setFiltersForPushing
argument_list|(
name|filtersForPushing
argument_list|)
expr_stmt|;
name|ASTNode
name|joinCond
init|=
name|subQuery
operator|.
name|getJoinConditionAST
argument_list|()
decl_stmt|;
name|ArrayList
argument_list|<
name|String
argument_list|>
name|leftSrc
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
name|parseJoinCondition
argument_list|(
name|joinTree
argument_list|,
name|joinCond
argument_list|,
name|leftSrc
argument_list|)
expr_stmt|;
if|if
condition|(
name|leftSrc
operator|.
name|size
argument_list|()
operator|==
literal|1
condition|)
block|{
name|joinTree
operator|.
name|setLeftAlias
argument_list|(
name|leftSrc
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|joinTree
return|;
block|}
specifier|private
name|QBJoinTree
name|genJoinTree
parameter_list|(
name|QB
name|qb
parameter_list|,
name|ASTNode
name|joinParseTree
parameter_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|Operator
argument_list|>
name|aliasToOpInfo
parameter_list|)
throws|throws
name|SemanticException
block|{
name|QBJoinTree
name|joinTree
init|=
operator|new
name|QBJoinTree
argument_list|()
decl_stmt|;
name|JoinCond
index|[]
name|condn
init|=
operator|new
name|JoinCond
index|[
literal|1
index|]
decl_stmt|;
switch|switch
condition|(
name|joinParseTree
operator|.
name|getToken
argument_list|()
operator|.
name|getType
argument_list|()
condition|)
block|{
case|case
name|HiveParser
operator|.
name|TOK_LEFTOUTERJOIN
case|:
name|joinTree
operator|.
name|setNoOuterJoin
argument_list|(
literal|false
argument_list|)
expr_stmt|;
name|condn
index|[
literal|0
index|]
operator|=
operator|new
name|JoinCond
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|,
name|JoinType
operator|.
name|LEFTOUTER
argument_list|)
expr_stmt|;
break|break;
case|case
name|HiveParser
operator|.
name|TOK_RIGHTOUTERJOIN
case|:
name|joinTree
operator|.
name|setNoOuterJoin
argument_list|(
literal|false
argument_list|)
expr_stmt|;
name|condn
index|[
literal|0
index|]
operator|=
operator|new
name|JoinCond
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|,
name|JoinType
operator|.
name|RIGHTOUTER
argument_list|)
expr_stmt|;
break|break;
case|case
name|HiveParser
operator|.
name|TOK_FULLOUTERJOIN
case|:
name|joinTree
operator|.
name|setNoOuterJoin
argument_list|(
literal|false
argument_list|)
expr_stmt|;
name|condn
index|[
literal|0
index|]
operator|=
operator|new
name|JoinCond
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|,
name|JoinType
operator|.
name|FULLOUTER
argument_list|)
expr_stmt|;
break|break;
case|case
name|HiveParser
operator|.
name|TOK_LEFTSEMIJOIN
case|:
name|joinTree
operator|.
name|setNoSemiJoin
argument_list|(
literal|false
argument_list|)
expr_stmt|;
name|condn
index|[
literal|0
index|]
operator|=
operator|new
name|JoinCond
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|,
name|JoinType
operator|.
name|LEFTSEMI
argument_list|)
expr_stmt|;
break|break;
default|default:
name|condn
index|[
literal|0
index|]
operator|=
operator|new
name|JoinCond
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|,
name|JoinType
operator|.
name|INNER
argument_list|)
expr_stmt|;
name|joinTree
operator|.
name|setNoOuterJoin
argument_list|(
literal|true
argument_list|)
expr_stmt|;
break|break;
block|}
name|joinTree
operator|.
name|setJoinCond
argument_list|(
name|condn
argument_list|)
expr_stmt|;
name|ASTNode
name|left
init|=
operator|(
name|ASTNode
operator|)
name|joinParseTree
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|ASTNode
name|right
init|=
operator|(
name|ASTNode
operator|)
name|joinParseTree
operator|.
name|getChild
argument_list|(
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|left
operator|.
name|getToken
argument_list|()
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_TABREF
operator|)
operator|||
operator|(
name|left
operator|.
name|getToken
argument_list|()
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_SUBQUERY
operator|)
operator|||
operator|(
name|left
operator|.
name|getToken
argument_list|()
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_PTBLFUNCTION
operator|)
condition|)
block|{
name|String
name|tableName
init|=
name|getUnescapedUnqualifiedTableName
argument_list|(
operator|(
name|ASTNode
operator|)
name|left
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
argument_list|)
operator|.
name|toLowerCase
argument_list|()
decl_stmt|;
name|String
name|alias
init|=
name|left
operator|.
name|getChildCount
argument_list|()
operator|==
literal|1
condition|?
name|tableName
else|:
name|unescapeIdentifier
argument_list|(
name|left
operator|.
name|getChild
argument_list|(
name|left
operator|.
name|getChildCount
argument_list|()
operator|-
literal|1
argument_list|)
operator|.
name|getText
argument_list|()
operator|.
name|toLowerCase
argument_list|()
argument_list|)
decl_stmt|;
comment|// ptf node form is: ^(TOK_PTBLFUNCTION $name $alias? partitionTableFunctionSource partitioningSpec? expression*)
comment|// guranteed to have an lias here: check done in processJoin
name|alias
operator|=
operator|(
name|left
operator|.
name|getToken
argument_list|()
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_PTBLFUNCTION
operator|)
condition|?
name|unescapeIdentifier
argument_list|(
name|left
operator|.
name|getChild
argument_list|(
literal|1
argument_list|)
operator|.
name|getText
argument_list|()
operator|.
name|toLowerCase
argument_list|()
argument_list|)
else|:
name|alias
expr_stmt|;
name|joinTree
operator|.
name|setLeftAlias
argument_list|(
name|alias
argument_list|)
expr_stmt|;
name|String
index|[]
name|leftAliases
init|=
operator|new
name|String
index|[
literal|1
index|]
decl_stmt|;
name|leftAliases
index|[
literal|0
index|]
operator|=
name|alias
expr_stmt|;
name|joinTree
operator|.
name|setLeftAliases
argument_list|(
name|leftAliases
argument_list|)
expr_stmt|;
name|String
index|[]
name|children
init|=
operator|new
name|String
index|[
literal|2
index|]
decl_stmt|;
name|children
index|[
literal|0
index|]
operator|=
name|alias
expr_stmt|;
name|joinTree
operator|.
name|setBaseSrc
argument_list|(
name|children
argument_list|)
expr_stmt|;
name|joinTree
operator|.
name|setId
argument_list|(
name|qb
operator|.
name|getId
argument_list|()
argument_list|)
expr_stmt|;
name|joinTree
operator|.
name|getAliasToOpInfo
argument_list|()
operator|.
name|put
argument_list|(
name|getModifiedAlias
argument_list|(
name|qb
argument_list|,
name|alias
argument_list|)
argument_list|,
name|aliasToOpInfo
operator|.
name|get
argument_list|(
name|alias
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|isJoinToken
argument_list|(
name|left
argument_list|)
condition|)
block|{
name|QBJoinTree
name|leftTree
init|=
name|genJoinTree
argument_list|(
name|qb
argument_list|,
name|left
argument_list|,
name|aliasToOpInfo
argument_list|)
decl_stmt|;
name|joinTree
operator|.
name|setJoinSrc
argument_list|(
name|leftTree
argument_list|)
expr_stmt|;
name|String
index|[]
name|leftChildAliases
init|=
name|leftTree
operator|.
name|getLeftAliases
argument_list|()
decl_stmt|;
name|String
name|leftAliases
index|[]
init|=
operator|new
name|String
index|[
name|leftChildAliases
operator|.
name|length
operator|+
literal|1
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|leftChildAliases
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|leftAliases
index|[
name|i
index|]
operator|=
name|leftChildAliases
index|[
name|i
index|]
expr_stmt|;
block|}
name|leftAliases
index|[
name|leftChildAliases
operator|.
name|length
index|]
operator|=
name|leftTree
operator|.
name|getRightAliases
argument_list|()
index|[
literal|0
index|]
expr_stmt|;
name|joinTree
operator|.
name|setLeftAliases
argument_list|(
name|leftAliases
argument_list|)
expr_stmt|;
block|}
else|else
block|{
assert|assert
operator|(
literal|false
operator|)
assert|;
block|}
if|if
condition|(
operator|(
name|right
operator|.
name|getToken
argument_list|()
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_TABREF
operator|)
operator|||
operator|(
name|right
operator|.
name|getToken
argument_list|()
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_SUBQUERY
operator|)
operator|||
operator|(
name|right
operator|.
name|getToken
argument_list|()
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_PTBLFUNCTION
operator|)
condition|)
block|{
name|String
name|tableName
init|=
name|getUnescapedUnqualifiedTableName
argument_list|(
operator|(
name|ASTNode
operator|)
name|right
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
argument_list|)
operator|.
name|toLowerCase
argument_list|()
decl_stmt|;
name|String
name|alias
init|=
name|right
operator|.
name|getChildCount
argument_list|()
operator|==
literal|1
condition|?
name|tableName
else|:
name|unescapeIdentifier
argument_list|(
name|right
operator|.
name|getChild
argument_list|(
name|right
operator|.
name|getChildCount
argument_list|()
operator|-
literal|1
argument_list|)
operator|.
name|getText
argument_list|()
operator|.
name|toLowerCase
argument_list|()
argument_list|)
decl_stmt|;
comment|// ptf node form is: ^(TOK_PTBLFUNCTION $name $alias? partitionTableFunctionSource partitioningSpec? expression*)
comment|// guranteed to have an lias here: check done in processJoin
name|alias
operator|=
operator|(
name|right
operator|.
name|getToken
argument_list|()
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_PTBLFUNCTION
operator|)
condition|?
name|unescapeIdentifier
argument_list|(
name|right
operator|.
name|getChild
argument_list|(
literal|1
argument_list|)
operator|.
name|getText
argument_list|()
operator|.
name|toLowerCase
argument_list|()
argument_list|)
else|:
name|alias
expr_stmt|;
name|String
index|[]
name|rightAliases
init|=
operator|new
name|String
index|[
literal|1
index|]
decl_stmt|;
name|rightAliases
index|[
literal|0
index|]
operator|=
name|alias
expr_stmt|;
name|joinTree
operator|.
name|setRightAliases
argument_list|(
name|rightAliases
argument_list|)
expr_stmt|;
name|String
index|[]
name|children
init|=
name|joinTree
operator|.
name|getBaseSrc
argument_list|()
decl_stmt|;
if|if
condition|(
name|children
operator|==
literal|null
condition|)
block|{
name|children
operator|=
operator|new
name|String
index|[
literal|2
index|]
expr_stmt|;
block|}
name|children
index|[
literal|1
index|]
operator|=
name|alias
expr_stmt|;
name|joinTree
operator|.
name|setBaseSrc
argument_list|(
name|children
argument_list|)
expr_stmt|;
name|joinTree
operator|.
name|setId
argument_list|(
name|qb
operator|.
name|getId
argument_list|()
argument_list|)
expr_stmt|;
name|joinTree
operator|.
name|getAliasToOpInfo
argument_list|()
operator|.
name|put
argument_list|(
name|getModifiedAlias
argument_list|(
name|qb
argument_list|,
name|alias
argument_list|)
argument_list|,
name|aliasToOpInfo
operator|.
name|get
argument_list|(
name|alias
argument_list|)
argument_list|)
expr_stmt|;
comment|// remember rhs table for semijoin
if|if
condition|(
name|joinTree
operator|.
name|getNoSemiJoin
argument_list|()
operator|==
literal|false
condition|)
block|{
name|joinTree
operator|.
name|addRHSSemijoin
argument_list|(
name|alias
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
assert|assert
literal|false
assert|;
block|}
name|ArrayList
argument_list|<
name|ArrayList
argument_list|<
name|ASTNode
argument_list|>
argument_list|>
name|expressions
init|=
operator|new
name|ArrayList
argument_list|<
name|ArrayList
argument_list|<
name|ASTNode
argument_list|>
argument_list|>
argument_list|()
decl_stmt|;
name|expressions
operator|.
name|add
argument_list|(
operator|new
name|ArrayList
argument_list|<
name|ASTNode
argument_list|>
argument_list|()
argument_list|)
expr_stmt|;
name|expressions
operator|.
name|add
argument_list|(
operator|new
name|ArrayList
argument_list|<
name|ASTNode
argument_list|>
argument_list|()
argument_list|)
expr_stmt|;
name|joinTree
operator|.
name|setExpressions
argument_list|(
name|expressions
argument_list|)
expr_stmt|;
name|ArrayList
argument_list|<
name|Boolean
argument_list|>
name|nullsafes
init|=
operator|new
name|ArrayList
argument_list|<
name|Boolean
argument_list|>
argument_list|()
decl_stmt|;
name|joinTree
operator|.
name|setNullSafes
argument_list|(
name|nullsafes
argument_list|)
expr_stmt|;
name|ArrayList
argument_list|<
name|ArrayList
argument_list|<
name|ASTNode
argument_list|>
argument_list|>
name|filters
init|=
operator|new
name|ArrayList
argument_list|<
name|ArrayList
argument_list|<
name|ASTNode
argument_list|>
argument_list|>
argument_list|()
decl_stmt|;
name|filters
operator|.
name|add
argument_list|(
operator|new
name|ArrayList
argument_list|<
name|ASTNode
argument_list|>
argument_list|()
argument_list|)
expr_stmt|;
name|filters
operator|.
name|add
argument_list|(
operator|new
name|ArrayList
argument_list|<
name|ASTNode
argument_list|>
argument_list|()
argument_list|)
expr_stmt|;
name|joinTree
operator|.
name|setFilters
argument_list|(
name|filters
argument_list|)
expr_stmt|;
name|joinTree
operator|.
name|setFilterMap
argument_list|(
operator|new
name|int
index|[
literal|2
index|]
index|[]
argument_list|)
expr_stmt|;
name|ArrayList
argument_list|<
name|ArrayList
argument_list|<
name|ASTNode
argument_list|>
argument_list|>
name|filtersForPushing
init|=
operator|new
name|ArrayList
argument_list|<
name|ArrayList
argument_list|<
name|ASTNode
argument_list|>
argument_list|>
argument_list|()
decl_stmt|;
name|filtersForPushing
operator|.
name|add
argument_list|(
operator|new
name|ArrayList
argument_list|<
name|ASTNode
argument_list|>
argument_list|()
argument_list|)
expr_stmt|;
name|filtersForPushing
operator|.
name|add
argument_list|(
operator|new
name|ArrayList
argument_list|<
name|ASTNode
argument_list|>
argument_list|()
argument_list|)
expr_stmt|;
name|joinTree
operator|.
name|setFiltersForPushing
argument_list|(
name|filtersForPushing
argument_list|)
expr_stmt|;
name|ASTNode
name|joinCond
init|=
operator|(
name|ASTNode
operator|)
name|joinParseTree
operator|.
name|getChild
argument_list|(
literal|2
argument_list|)
decl_stmt|;
name|ArrayList
argument_list|<
name|String
argument_list|>
name|leftSrc
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
name|parseJoinCondition
argument_list|(
name|joinTree
argument_list|,
name|joinCond
argument_list|,
name|leftSrc
argument_list|)
expr_stmt|;
if|if
condition|(
name|leftSrc
operator|.
name|size
argument_list|()
operator|==
literal|1
condition|)
block|{
name|joinTree
operator|.
name|setLeftAlias
argument_list|(
name|leftSrc
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// check the hints to see if the user has specified a map-side join. This
comment|// will be removed later on, once the cost-based
comment|// infrastructure is in place
if|if
condition|(
name|qb
operator|.
name|getParseInfo
argument_list|()
operator|.
name|getHints
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|List
argument_list|<
name|String
argument_list|>
name|mapSideTables
init|=
name|getMapSideJoinTables
argument_list|(
name|qb
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|mapAliases
init|=
name|joinTree
operator|.
name|getMapAliases
argument_list|()
decl_stmt|;
for|for
control|(
name|String
name|mapTbl
range|:
name|mapSideTables
control|)
block|{
name|boolean
name|mapTable
init|=
literal|false
decl_stmt|;
for|for
control|(
name|String
name|leftAlias
range|:
name|joinTree
operator|.
name|getLeftAliases
argument_list|()
control|)
block|{
if|if
condition|(
name|mapTbl
operator|.
name|equalsIgnoreCase
argument_list|(
name|leftAlias
argument_list|)
condition|)
block|{
name|mapTable
operator|=
literal|true
expr_stmt|;
block|}
block|}
for|for
control|(
name|String
name|rightAlias
range|:
name|joinTree
operator|.
name|getRightAliases
argument_list|()
control|)
block|{
if|if
condition|(
name|mapTbl
operator|.
name|equalsIgnoreCase
argument_list|(
name|rightAlias
argument_list|)
condition|)
block|{
name|mapTable
operator|=
literal|true
expr_stmt|;
block|}
block|}
if|if
condition|(
name|mapTable
condition|)
block|{
if|if
condition|(
name|mapAliases
operator|==
literal|null
condition|)
block|{
name|mapAliases
operator|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
expr_stmt|;
block|}
name|mapAliases
operator|.
name|add
argument_list|(
name|mapTbl
argument_list|)
expr_stmt|;
name|joinTree
operator|.
name|setMapSideJoin
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
block|}
name|joinTree
operator|.
name|setMapAliases
argument_list|(
name|mapAliases
argument_list|)
expr_stmt|;
name|parseStreamTables
argument_list|(
name|joinTree
argument_list|,
name|qb
argument_list|)
expr_stmt|;
block|}
return|return
name|joinTree
return|;
block|}
specifier|private
name|void
name|parseStreamTables
parameter_list|(
name|QBJoinTree
name|joinTree
parameter_list|,
name|QB
name|qb
parameter_list|)
block|{
name|List
argument_list|<
name|String
argument_list|>
name|streamAliases
init|=
name|joinTree
operator|.
name|getStreamAliases
argument_list|()
decl_stmt|;
for|for
control|(
name|Node
name|hintNode
range|:
name|qb
operator|.
name|getParseInfo
argument_list|()
operator|.
name|getHints
argument_list|()
operator|.
name|getChildren
argument_list|()
control|)
block|{
name|ASTNode
name|hint
init|=
operator|(
name|ASTNode
operator|)
name|hintNode
decl_stmt|;
if|if
condition|(
name|hint
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_STREAMTABLE
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|hint
operator|.
name|getChild
argument_list|(
literal|1
argument_list|)
operator|.
name|getChildCount
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|streamAliases
operator|==
literal|null
condition|)
block|{
name|streamAliases
operator|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
expr_stmt|;
block|}
name|streamAliases
operator|.
name|add
argument_list|(
name|hint
operator|.
name|getChild
argument_list|(
literal|1
argument_list|)
operator|.
name|getChild
argument_list|(
name|i
argument_list|)
operator|.
name|getText
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|joinTree
operator|.
name|setStreamAliases
argument_list|(
name|streamAliases
argument_list|)
expr_stmt|;
block|}
comment|/**    * Merges node to target    */
specifier|private
name|void
name|mergeJoins
parameter_list|(
name|QB
name|qb
parameter_list|,
name|QBJoinTree
name|node
parameter_list|,
name|QBJoinTree
name|target
parameter_list|,
name|int
name|pos
parameter_list|,
name|int
index|[]
name|tgtToNodeExprMap
parameter_list|)
block|{
name|String
index|[]
name|nodeRightAliases
init|=
name|node
operator|.
name|getRightAliases
argument_list|()
decl_stmt|;
name|String
index|[]
name|trgtRightAliases
init|=
name|target
operator|.
name|getRightAliases
argument_list|()
decl_stmt|;
name|String
index|[]
name|rightAliases
init|=
operator|new
name|String
index|[
name|nodeRightAliases
operator|.
name|length
operator|+
name|trgtRightAliases
operator|.
name|length
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|trgtRightAliases
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|rightAliases
index|[
name|i
index|]
operator|=
name|trgtRightAliases
index|[
name|i
index|]
expr_stmt|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|nodeRightAliases
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|rightAliases
index|[
name|i
operator|+
name|trgtRightAliases
operator|.
name|length
index|]
operator|=
name|nodeRightAliases
index|[
name|i
index|]
expr_stmt|;
block|}
name|target
operator|.
name|setRightAliases
argument_list|(
name|rightAliases
argument_list|)
expr_stmt|;
name|target
operator|.
name|getAliasToOpInfo
argument_list|()
operator|.
name|putAll
argument_list|(
name|node
operator|.
name|getAliasToOpInfo
argument_list|()
argument_list|)
expr_stmt|;
name|String
index|[]
name|nodeBaseSrc
init|=
name|node
operator|.
name|getBaseSrc
argument_list|()
decl_stmt|;
name|String
index|[]
name|trgtBaseSrc
init|=
name|target
operator|.
name|getBaseSrc
argument_list|()
decl_stmt|;
name|String
index|[]
name|baseSrc
init|=
operator|new
name|String
index|[
name|nodeBaseSrc
operator|.
name|length
operator|+
name|trgtBaseSrc
operator|.
name|length
operator|-
literal|1
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|trgtBaseSrc
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|baseSrc
index|[
name|i
index|]
operator|=
name|trgtBaseSrc
index|[
name|i
index|]
expr_stmt|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<
name|nodeBaseSrc
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|baseSrc
index|[
name|i
operator|+
name|trgtBaseSrc
operator|.
name|length
operator|-
literal|1
index|]
operator|=
name|nodeBaseSrc
index|[
name|i
index|]
expr_stmt|;
block|}
name|target
operator|.
name|setBaseSrc
argument_list|(
name|baseSrc
argument_list|)
expr_stmt|;
name|ArrayList
argument_list|<
name|ArrayList
argument_list|<
name|ASTNode
argument_list|>
argument_list|>
name|expr
init|=
name|target
operator|.
name|getExpressions
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|nodeRightAliases
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|List
argument_list|<
name|ASTNode
argument_list|>
name|nodeConds
init|=
name|node
operator|.
name|getExpressions
argument_list|()
operator|.
name|get
argument_list|(
name|i
operator|+
literal|1
argument_list|)
decl_stmt|;
name|ArrayList
argument_list|<
name|ASTNode
argument_list|>
name|reordereNodeConds
init|=
operator|new
name|ArrayList
argument_list|<
name|ASTNode
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|k
init|=
literal|0
init|;
name|k
operator|<
name|tgtToNodeExprMap
operator|.
name|length
condition|;
name|k
operator|++
control|)
block|{
name|reordereNodeConds
operator|.
name|add
argument_list|(
name|nodeConds
operator|.
name|get
argument_list|(
name|k
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|expr
operator|.
name|add
argument_list|(
name|reordereNodeConds
argument_list|)
expr_stmt|;
block|}
name|ArrayList
argument_list|<
name|Boolean
argument_list|>
name|nns
init|=
name|node
operator|.
name|getNullSafes
argument_list|()
decl_stmt|;
name|ArrayList
argument_list|<
name|Boolean
argument_list|>
name|tns
init|=
name|target
operator|.
name|getNullSafes
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|tns
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|tns
operator|.
name|set
argument_list|(
name|i
argument_list|,
name|tns
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|&
name|nns
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
comment|// any of condition contains non-NS, non-NS
block|}
name|ArrayList
argument_list|<
name|ArrayList
argument_list|<
name|ASTNode
argument_list|>
argument_list|>
name|filters
init|=
name|target
operator|.
name|getFilters
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|nodeRightAliases
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|filters
operator|.
name|add
argument_list|(
name|node
operator|.
name|getFilters
argument_list|()
operator|.
name|get
argument_list|(
name|i
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|node
operator|.
name|getFilters
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|size
argument_list|()
operator|!=
literal|0
condition|)
block|{
name|ArrayList
argument_list|<
name|ASTNode
argument_list|>
name|filterPos
init|=
name|filters
operator|.
name|get
argument_list|(
name|pos
argument_list|)
decl_stmt|;
name|filterPos
operator|.
name|addAll
argument_list|(
name|node
operator|.
name|getFilters
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|int
index|[]
index|[]
name|nmap
init|=
name|node
operator|.
name|getFilterMap
argument_list|()
decl_stmt|;
name|int
index|[]
index|[]
name|tmap
init|=
name|target
operator|.
name|getFilterMap
argument_list|()
decl_stmt|;
name|int
index|[]
index|[]
name|newmap
init|=
operator|new
name|int
index|[
name|tmap
operator|.
name|length
operator|+
name|nmap
operator|.
name|length
operator|-
literal|1
index|]
index|[]
decl_stmt|;
for|for
control|(
name|int
index|[]
name|mapping
range|:
name|nmap
control|)
block|{
if|if
condition|(
name|mapping
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|mapping
operator|.
name|length
condition|;
name|i
operator|+=
literal|2
control|)
block|{
if|if
condition|(
name|pos
operator|>
literal|0
operator|||
name|mapping
index|[
name|i
index|]
operator|>
literal|0
condition|)
block|{
name|mapping
index|[
name|i
index|]
operator|+=
name|trgtRightAliases
operator|.
name|length
expr_stmt|;
block|}
block|}
block|}
block|}
if|if
condition|(
name|nmap
index|[
literal|0
index|]
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|tmap
index|[
name|pos
index|]
operator|==
literal|null
condition|)
block|{
name|tmap
index|[
name|pos
index|]
operator|=
name|nmap
index|[
literal|0
index|]
expr_stmt|;
block|}
else|else
block|{
name|int
index|[]
name|appended
init|=
operator|new
name|int
index|[
name|tmap
index|[
name|pos
index|]
operator|.
name|length
operator|+
name|nmap
index|[
literal|0
index|]
operator|.
name|length
index|]
decl_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|tmap
index|[
name|pos
index|]
argument_list|,
literal|0
argument_list|,
name|appended
argument_list|,
literal|0
argument_list|,
name|tmap
index|[
name|pos
index|]
operator|.
name|length
argument_list|)
expr_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|nmap
index|[
literal|0
index|]
argument_list|,
literal|0
argument_list|,
name|appended
argument_list|,
name|tmap
index|[
name|pos
index|]
operator|.
name|length
argument_list|,
name|nmap
index|[
literal|0
index|]
operator|.
name|length
argument_list|)
expr_stmt|;
name|tmap
index|[
name|pos
index|]
operator|=
name|appended
expr_stmt|;
block|}
block|}
name|System
operator|.
name|arraycopy
argument_list|(
name|tmap
argument_list|,
literal|0
argument_list|,
name|newmap
argument_list|,
literal|0
argument_list|,
name|tmap
operator|.
name|length
argument_list|)
expr_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|nmap
argument_list|,
literal|1
argument_list|,
name|newmap
argument_list|,
name|tmap
operator|.
name|length
argument_list|,
name|nmap
operator|.
name|length
operator|-
literal|1
argument_list|)
expr_stmt|;
name|target
operator|.
name|setFilterMap
argument_list|(
name|newmap
argument_list|)
expr_stmt|;
name|ArrayList
argument_list|<
name|ArrayList
argument_list|<
name|ASTNode
argument_list|>
argument_list|>
name|filter
init|=
name|target
operator|.
name|getFiltersForPushing
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|nodeRightAliases
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|filter
operator|.
name|add
argument_list|(
name|node
operator|.
name|getFiltersForPushing
argument_list|()
operator|.
name|get
argument_list|(
name|i
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|node
operator|.
name|getFiltersForPushing
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|size
argument_list|()
operator|!=
literal|0
condition|)
block|{
comment|/*        * for each predicate:        * - does it refer to one or many aliases        * - if one: add it to the filterForPushing list of that alias        * - if many: add as a filter from merging trees.        */
for|for
control|(
name|ASTNode
name|nodeFilter
range|:
name|node
operator|.
name|getFiltersForPushing
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
control|)
block|{
name|int
name|fPos
init|=
name|ParseUtils
operator|.
name|checkJoinFilterRefersOneAlias
argument_list|(
name|target
operator|.
name|getBaseSrc
argument_list|()
argument_list|,
name|nodeFilter
argument_list|)
decl_stmt|;
if|if
condition|(
name|fPos
operator|!=
operator|-
literal|1
condition|)
block|{
name|filter
operator|.
name|get
argument_list|(
name|fPos
argument_list|)
operator|.
name|add
argument_list|(
name|nodeFilter
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|target
operator|.
name|addPostJoinFilter
argument_list|(
name|nodeFilter
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|node
operator|.
name|getNoOuterJoin
argument_list|()
operator|&&
name|target
operator|.
name|getNoOuterJoin
argument_list|()
condition|)
block|{
name|target
operator|.
name|setNoOuterJoin
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|target
operator|.
name|setNoOuterJoin
argument_list|(
literal|false
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|node
operator|.
name|getNoSemiJoin
argument_list|()
operator|&&
name|target
operator|.
name|getNoSemiJoin
argument_list|()
condition|)
block|{
name|target
operator|.
name|setNoSemiJoin
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|target
operator|.
name|setNoSemiJoin
argument_list|(
literal|false
argument_list|)
expr_stmt|;
block|}
name|target
operator|.
name|mergeRHSSemijoin
argument_list|(
name|node
argument_list|)
expr_stmt|;
name|JoinCond
index|[]
name|nodeCondns
init|=
name|node
operator|.
name|getJoinCond
argument_list|()
decl_stmt|;
name|int
name|nodeCondnsSize
init|=
name|nodeCondns
operator|.
name|length
decl_stmt|;
name|JoinCond
index|[]
name|targetCondns
init|=
name|target
operator|.
name|getJoinCond
argument_list|()
decl_stmt|;
name|int
name|targetCondnsSize
init|=
name|targetCondns
operator|.
name|length
decl_stmt|;
name|JoinCond
index|[]
name|newCondns
init|=
operator|new
name|JoinCond
index|[
name|nodeCondnsSize
operator|+
name|targetCondnsSize
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|targetCondnsSize
condition|;
name|i
operator|++
control|)
block|{
name|newCondns
index|[
name|i
index|]
operator|=
name|targetCondns
index|[
name|i
index|]
expr_stmt|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|nodeCondnsSize
condition|;
name|i
operator|++
control|)
block|{
name|JoinCond
name|nodeCondn
init|=
name|nodeCondns
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|nodeCondn
operator|.
name|getLeft
argument_list|()
operator|==
literal|0
condition|)
block|{
name|nodeCondn
operator|.
name|setLeft
argument_list|(
name|pos
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|nodeCondn
operator|.
name|setLeft
argument_list|(
name|nodeCondn
operator|.
name|getLeft
argument_list|()
operator|+
name|targetCondnsSize
argument_list|)
expr_stmt|;
block|}
name|nodeCondn
operator|.
name|setRight
argument_list|(
name|nodeCondn
operator|.
name|getRight
argument_list|()
operator|+
name|targetCondnsSize
argument_list|)
expr_stmt|;
name|newCondns
index|[
name|targetCondnsSize
operator|+
name|i
index|]
operator|=
name|nodeCondn
expr_stmt|;
block|}
name|target
operator|.
name|setJoinCond
argument_list|(
name|newCondns
argument_list|)
expr_stmt|;
if|if
condition|(
name|target
operator|.
name|isMapSideJoin
argument_list|()
condition|)
block|{
assert|assert
name|node
operator|.
name|isMapSideJoin
argument_list|()
assert|;
name|List
argument_list|<
name|String
argument_list|>
name|mapAliases
init|=
name|target
operator|.
name|getMapAliases
argument_list|()
decl_stmt|;
for|for
control|(
name|String
name|mapTbl
range|:
name|node
operator|.
name|getMapAliases
argument_list|()
control|)
block|{
if|if
condition|(
operator|!
name|mapAliases
operator|.
name|contains
argument_list|(
name|mapTbl
argument_list|)
condition|)
block|{
name|mapAliases
operator|.
name|add
argument_list|(
name|mapTbl
argument_list|)
expr_stmt|;
block|}
block|}
name|target
operator|.
name|setMapAliases
argument_list|(
name|mapAliases
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
name|ObjectPair
argument_list|<
name|Integer
argument_list|,
name|int
index|[]
argument_list|>
name|findMergePos
parameter_list|(
name|QBJoinTree
name|node
parameter_list|,
name|QBJoinTree
name|target
parameter_list|)
block|{
name|int
name|res
init|=
operator|-
literal|1
decl_stmt|;
name|String
name|leftAlias
init|=
name|node
operator|.
name|getLeftAlias
argument_list|()
decl_stmt|;
if|if
condition|(
name|leftAlias
operator|==
literal|null
condition|)
block|{
return|return
operator|new
name|ObjectPair
argument_list|(
operator|-
literal|1
argument_list|,
literal|null
argument_list|)
return|;
block|}
name|ArrayList
argument_list|<
name|ASTNode
argument_list|>
name|nodeCondn
init|=
name|node
operator|.
name|getExpressions
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|ArrayList
argument_list|<
name|ASTNode
argument_list|>
name|targetCondn
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|leftAlias
operator|.
name|equals
argument_list|(
name|target
operator|.
name|getLeftAlias
argument_list|()
argument_list|)
condition|)
block|{
name|targetCondn
operator|=
name|target
operator|.
name|getExpressions
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|res
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|target
operator|.
name|getRightAliases
argument_list|()
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|leftAlias
operator|.
name|equals
argument_list|(
name|target
operator|.
name|getRightAliases
argument_list|()
index|[
name|i
index|]
argument_list|)
condition|)
block|{
name|targetCondn
operator|=
name|target
operator|.
name|getExpressions
argument_list|()
operator|.
name|get
argument_list|(
name|i
operator|+
literal|1
argument_list|)
expr_stmt|;
name|res
operator|=
name|i
operator|+
literal|1
expr_stmt|;
break|break;
block|}
block|}
block|}
if|if
condition|(
name|targetCondn
operator|==
literal|null
condition|)
block|{
return|return
operator|new
name|ObjectPair
argument_list|(
operator|-
literal|1
argument_list|,
literal|null
argument_list|)
return|;
block|}
comment|/*      * The order of the join condition expressions don't matter.      * A merge can happen:      * - if every target condition is present in some position of the node condition list.      * - there is no node condition, which is not equal to any target condition.      */
name|int
index|[]
name|tgtToNodeExprMap
init|=
operator|new
name|int
index|[
name|targetCondn
operator|.
name|size
argument_list|()
index|]
decl_stmt|;
name|boolean
index|[]
name|nodeFiltersMapped
init|=
operator|new
name|boolean
index|[
name|nodeCondn
operator|.
name|size
argument_list|()
index|]
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|targetCondn
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|String
name|tgtExprTree
init|=
name|targetCondn
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|toStringTree
argument_list|()
decl_stmt|;
name|tgtToNodeExprMap
index|[
name|i
index|]
operator|=
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|nodeCondn
operator|.
name|size
argument_list|()
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|nodeCondn
operator|.
name|get
argument_list|(
name|j
argument_list|)
operator|.
name|toStringTree
argument_list|()
operator|.
name|equals
argument_list|(
name|tgtExprTree
argument_list|)
condition|)
block|{
name|tgtToNodeExprMap
index|[
name|i
index|]
operator|=
name|j
expr_stmt|;
name|nodeFiltersMapped
index|[
name|j
index|]
operator|=
literal|true
expr_stmt|;
block|}
block|}
if|if
condition|(
name|tgtToNodeExprMap
index|[
name|i
index|]
operator|==
operator|-
literal|1
condition|)
block|{
return|return
operator|new
name|ObjectPair
argument_list|(
operator|-
literal|1
argument_list|,
literal|null
argument_list|)
return|;
block|}
block|}
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|nodeCondn
operator|.
name|size
argument_list|()
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|nodeFiltersMapped
index|[
name|j
index|]
condition|)
block|{
return|return
operator|new
name|ObjectPair
argument_list|(
operator|-
literal|1
argument_list|,
literal|null
argument_list|)
return|;
block|}
block|}
return|return
operator|new
name|ObjectPair
argument_list|(
name|res
argument_list|,
name|tgtToNodeExprMap
argument_list|)
return|;
block|}
comment|// try merge join tree from inner most source
comment|// (it was merged from outer most to inner, which could be invalid)
comment|//
comment|// in a join tree ((A-B)-C)-D where C is not mergeable with A-B,
comment|// D can be merged with A-B into single join If and only if C and D has same join type
comment|// In this case, A-B-D join will be executed first and ABD-C join will be executed in next
specifier|private
name|void
name|mergeJoinTree
parameter_list|(
name|QB
name|qb
parameter_list|)
block|{
name|QBJoinTree
name|tree
init|=
name|qb
operator|.
name|getQbJoinTree
argument_list|()
decl_stmt|;
if|if
condition|(
name|tree
operator|.
name|getJoinSrc
argument_list|()
operator|==
literal|null
condition|)
block|{
return|return;
block|}
comment|// make array with QBJoinTree : outer most(0) --> inner most(n)
name|List
argument_list|<
name|QBJoinTree
argument_list|>
name|trees
init|=
operator|new
name|ArrayList
argument_list|<
name|QBJoinTree
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
init|;
name|tree
operator|!=
literal|null
condition|;
name|tree
operator|=
name|tree
operator|.
name|getJoinSrc
argument_list|()
control|)
block|{
name|trees
operator|.
name|add
argument_list|(
name|tree
argument_list|)
expr_stmt|;
block|}
comment|// merging from 'target'(inner) to 'node'(outer)
for|for
control|(
name|int
name|i
init|=
name|trees
operator|.
name|size
argument_list|()
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|QBJoinTree
name|target
init|=
name|trees
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|target
operator|==
literal|null
condition|)
block|{
continue|continue;
block|}
name|JoinType
name|prevType
init|=
literal|null
decl_stmt|;
comment|// save join type
for|for
control|(
name|int
name|j
init|=
name|i
operator|-
literal|1
init|;
name|j
operator|>=
literal|0
condition|;
name|j
operator|--
control|)
block|{
name|QBJoinTree
name|node
init|=
name|trees
operator|.
name|get
argument_list|(
name|j
argument_list|)
decl_stmt|;
if|if
condition|(
name|node
operator|==
literal|null
condition|)
block|{
continue|continue;
block|}
name|JoinType
name|currType
init|=
name|getType
argument_list|(
name|node
operator|.
name|getJoinCond
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|prevType
operator|!=
literal|null
operator|&&
name|prevType
operator|!=
name|currType
condition|)
block|{
break|break;
block|}
name|ObjectPair
argument_list|<
name|Integer
argument_list|,
name|int
index|[]
argument_list|>
name|mergeDetails
init|=
name|findMergePos
argument_list|(
name|node
argument_list|,
name|target
argument_list|)
decl_stmt|;
name|int
name|pos
init|=
name|mergeDetails
operator|.
name|getFirst
argument_list|()
decl_stmt|;
if|if
condition|(
name|pos
operator|>=
literal|0
condition|)
block|{
comment|// for outer joins, it should not exceed 16 aliases (short type)
if|if
condition|(
operator|!
name|node
operator|.
name|getNoOuterJoin
argument_list|()
operator|||
operator|!
name|target
operator|.
name|getNoOuterJoin
argument_list|()
condition|)
block|{
if|if
condition|(
name|node
operator|.
name|getRightAliases
argument_list|()
operator|.
name|length
operator|+
name|target
operator|.
name|getRightAliases
argument_list|()
operator|.
name|length
operator|+
literal|1
operator|>
literal|16
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
name|ErrorMsg
operator|.
name|JOINNODE_OUTERJOIN_MORETHAN_16
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
name|mergeJoins
argument_list|(
name|qb
argument_list|,
name|node
argument_list|,
name|target
argument_list|,
name|pos
argument_list|,
name|mergeDetails
operator|.
name|getSecond
argument_list|()
argument_list|)
expr_stmt|;
name|trees
operator|.
name|set
argument_list|(
name|j
argument_list|,
literal|null
argument_list|)
expr_stmt|;
continue|continue;
comment|// continue merging with next alias
block|}
if|if
condition|(
name|prevType
operator|==
literal|null
condition|)
block|{
name|prevType
operator|=
name|currType
expr_stmt|;
block|}
block|}
block|}
comment|// reconstruct join tree
name|QBJoinTree
name|current
init|=
literal|null
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|trees
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|QBJoinTree
name|target
init|=
name|trees
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|target
operator|==
literal|null
condition|)
block|{
continue|continue;
block|}
if|if
condition|(
name|current
operator|==
literal|null
condition|)
block|{
name|qb
operator|.
name|setQbJoinTree
argument_list|(
name|current
operator|=
name|target
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|current
operator|.
name|setJoinSrc
argument_list|(
name|target
argument_list|)
expr_stmt|;
name|current
operator|=
name|target
expr_stmt|;
block|}
block|}
block|}
comment|// Join types should be all the same for merging (or returns null)
specifier|private
name|JoinType
name|getType
parameter_list|(
name|JoinCond
index|[]
name|conds
parameter_list|)
block|{
name|JoinType
name|type
init|=
name|conds
index|[
literal|0
index|]
operator|.
name|getJoinType
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|k
init|=
literal|1
init|;
name|k
operator|<
name|conds
operator|.
name|length
condition|;
name|k
operator|++
control|)
block|{
if|if
condition|(
name|type
operator|!=
name|conds
index|[
name|k
index|]
operator|.
name|getJoinType
argument_list|()
condition|)
block|{
return|return
literal|null
return|;
block|}
block|}
return|return
name|type
return|;
block|}
specifier|private
name|Operator
name|insertSelectAllPlanForGroupBy
parameter_list|(
name|Operator
name|input
parameter_list|)
throws|throws
name|SemanticException
block|{
name|OpParseContext
name|inputCtx
init|=
name|opParseCtx
operator|.
name|get
argument_list|(
name|input
argument_list|)
decl_stmt|;
name|RowResolver
name|inputRR
init|=
name|inputCtx
operator|.
name|getRowResolver
argument_list|()
decl_stmt|;
name|ArrayList
argument_list|<
name|ColumnInfo
argument_list|>
name|columns
init|=
name|inputRR
operator|.
name|getColumnInfos
argument_list|()
decl_stmt|;
name|ArrayList
argument_list|<
name|ExprNodeDesc
argument_list|>
name|colList
init|=
operator|new
name|ArrayList
argument_list|<
name|ExprNodeDesc
argument_list|>
argument_list|()
decl_stmt|;
name|ArrayList
argument_list|<
name|String
argument_list|>
name|columnNames
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|ExprNodeDesc
argument_list|>
name|columnExprMap
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|ExprNodeDesc
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|columns
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|ColumnInfo
name|col
init|=
name|columns
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|colList
operator|.
name|add
argument_list|(
operator|new
name|ExprNodeColumnDesc
argument_list|(
name|col
operator|.
name|getType
argument_list|()
argument_list|,
name|col
operator|.
name|getInternalName
argument_list|()
argument_list|,
name|col
operator|.
name|getTabAlias
argument_list|()
argument_list|,
name|col
operator|.
name|getIsVirtualCol
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|columnNames
operator|.
name|add
argument_list|(
name|col
operator|.
name|getInternalName
argument_list|()
argument_list|)
expr_stmt|;
name|columnExprMap
operator|.
name|put
argument_list|(
name|col
operator|.
name|getInternalName
argument_list|()
argument_list|,
operator|new
name|ExprNodeColumnDesc
argument_list|(
name|col
operator|.
name|getType
argument_list|()
argument_list|,
name|col
operator|.
name|getInternalName
argument_list|()
argument_list|,
name|col
operator|.
name|getTabAlias
argument_list|()
argument_list|,
name|col
operator|.
name|getIsVirtualCol
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|Operator
name|output
init|=
name|putOpInsertMap
argument_list|(
name|OperatorFactory
operator|.
name|getAndMakeChild
argument_list|(
operator|new
name|SelectDesc
argument_list|(
name|colList
argument_list|,
name|columnNames
argument_list|,
literal|true
argument_list|)
argument_list|,
operator|new
name|RowSchema
argument_list|(
name|inputRR
operator|.
name|getColumnInfos
argument_list|()
argument_list|)
argument_list|,
name|input
argument_list|)
argument_list|,
name|inputRR
argument_list|)
decl_stmt|;
name|output
operator|.
name|setColumnExprMap
argument_list|(
name|columnExprMap
argument_list|)
expr_stmt|;
return|return
name|output
return|;
block|}
comment|// Return the common distinct expression
comment|// There should be more than 1 destination, with group bys in all of them.
specifier|private
name|List
argument_list|<
name|ASTNode
argument_list|>
name|getCommonDistinctExprs
parameter_list|(
name|QB
name|qb
parameter_list|,
name|Operator
name|input
parameter_list|)
block|{
name|QBParseInfo
name|qbp
init|=
name|qb
operator|.
name|getParseInfo
argument_list|()
decl_stmt|;
comment|// If a grouping set aggregation is present, common processing is not possible
if|if
condition|(
operator|!
name|qbp
operator|.
name|getDestCubes
argument_list|()
operator|.
name|isEmpty
argument_list|()
operator|||
operator|!
name|qbp
operator|.
name|getDestRollups
argument_list|()
operator|.
name|isEmpty
argument_list|()
operator|||
operator|!
name|qbp
operator|.
name|getDestToLateralView
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return
literal|null
return|;
block|}
name|RowResolver
name|inputRR
init|=
name|opParseCtx
operator|.
name|get
argument_list|(
name|input
argument_list|)
operator|.
name|getRowResolver
argument_list|()
decl_stmt|;
name|TreeSet
argument_list|<
name|String
argument_list|>
name|ks
init|=
operator|new
name|TreeSet
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
name|ks
operator|.
name|addAll
argument_list|(
name|qbp
operator|.
name|getClauseNames
argument_list|()
argument_list|)
expr_stmt|;
comment|// Go over all the destination tables
if|if
condition|(
name|ks
operator|.
name|size
argument_list|()
operator|<=
literal|1
condition|)
block|{
return|return
literal|null
return|;
block|}
name|List
argument_list|<
name|ExprNodeDesc
argument_list|>
name|oldList
init|=
literal|null
decl_stmt|;
name|List
argument_list|<
name|ASTNode
argument_list|>
name|oldASTList
init|=
literal|null
decl_stmt|;
for|for
control|(
name|String
name|dest
range|:
name|ks
control|)
block|{
comment|// If a filter is present, common processing is not possible
if|if
condition|(
name|qbp
operator|.
name|getWhrForClause
argument_list|(
name|dest
argument_list|)
operator|!=
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
if|if
condition|(
name|qbp
operator|.
name|getAggregationExprsForClause
argument_list|(
name|dest
argument_list|)
operator|.
name|size
argument_list|()
operator|==
literal|0
operator|&&
name|getGroupByForClause
argument_list|(
name|qbp
argument_list|,
name|dest
argument_list|)
operator|.
name|size
argument_list|()
operator|==
literal|0
condition|)
block|{
return|return
literal|null
return|;
block|}
comment|// All distinct expressions must be the same
name|List
argument_list|<
name|ASTNode
argument_list|>
name|list
init|=
name|qbp
operator|.
name|getDistinctFuncExprsForClause
argument_list|(
name|dest
argument_list|)
decl_stmt|;
if|if
condition|(
name|list
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return
literal|null
return|;
block|}
name|List
argument_list|<
name|ExprNodeDesc
argument_list|>
name|currDestList
decl_stmt|;
try|try
block|{
name|currDestList
operator|=
name|getDistinctExprs
argument_list|(
name|qbp
argument_list|,
name|dest
argument_list|,
name|inputRR
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|SemanticException
name|e
parameter_list|)
block|{
return|return
literal|null
return|;
block|}
name|List
argument_list|<
name|ASTNode
argument_list|>
name|currASTList
init|=
operator|new
name|ArrayList
argument_list|<
name|ASTNode
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|ASTNode
name|value
range|:
name|list
control|)
block|{
comment|// 0 is function name
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<
name|value
operator|.
name|getChildCount
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|ASTNode
name|parameter
init|=
operator|(
name|ASTNode
operator|)
name|value
operator|.
name|getChild
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|currASTList
operator|.
name|add
argument_list|(
name|parameter
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|oldList
operator|==
literal|null
condition|)
block|{
name|oldList
operator|=
name|currDestList
expr_stmt|;
name|oldASTList
operator|=
name|currASTList
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|matchExprLists
argument_list|(
name|oldList
argument_list|,
name|currDestList
argument_list|)
condition|)
block|{
return|return
literal|null
return|;
block|}
block|}
block|}
block|}
return|return
name|oldASTList
return|;
block|}
specifier|private
name|Operator
name|createCommonReduceSink
parameter_list|(
name|QB
name|qb
parameter_list|,
name|Operator
name|input
parameter_list|)
throws|throws
name|SemanticException
block|{
comment|// Go over all the tables and extract the common distinct key
name|List
argument_list|<
name|ASTNode
argument_list|>
name|distExprs
init|=
name|getCommonDistinctExprs
argument_list|(
name|qb
argument_list|,
name|input
argument_list|)
decl_stmt|;
name|QBParseInfo
name|qbp
init|=
name|qb
operator|.
name|getParseInfo
argument_list|()
decl_stmt|;
name|TreeSet
argument_list|<
name|String
argument_list|>
name|ks
init|=
operator|new
name|TreeSet
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
name|ks
operator|.
name|addAll
argument_list|(
name|qbp
operator|.
name|getClauseNames
argument_list|()
argument_list|)
expr_stmt|;
comment|// Pass the entire row
name|RowResolver
name|inputRR
init|=
name|opParseCtx
operator|.
name|get
argument_list|(
name|input
argument_list|)
operator|.
name|getRowResolver
argument_list|()
decl_stmt|;
name|RowResolver
name|reduceSinkOutputRowResolver
init|=
operator|new
name|RowResolver
argument_list|()
decl_stmt|;
name|reduceSinkOutputRowResolver
operator|.
name|setIsExprResolver
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|ArrayList
argument_list|<
name|ExprNodeDesc
argument_list|>
name|reduceKeys
init|=
operator|new
name|ArrayList
argument_list|<
name|ExprNodeDesc
argument_list|>
argument_list|()
decl_stmt|;
name|ArrayList
argument_list|<
name|ExprNodeDesc
argument_list|>
name|reduceValues
init|=
operator|new
name|ArrayList
argument_list|<
name|ExprNodeDesc
argument_list|>
argument_list|()
decl_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|ExprNodeDesc
argument_list|>
name|colExprMap
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|ExprNodeDesc
argument_list|>
argument_list|()
decl_stmt|;
comment|// Pre-compute distinct group-by keys and store in reduceKeys
name|List
argument_list|<
name|String
argument_list|>
name|outputColumnNames
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|ASTNode
name|distn
range|:
name|distExprs
control|)
block|{
name|ExprNodeDesc
name|distExpr
init|=
name|genExprNodeDesc
argument_list|(
name|distn
argument_list|,
name|inputRR
argument_list|)
decl_stmt|;
if|if
condition|(
name|reduceSinkOutputRowResolver
operator|.
name|getExpression
argument_list|(
name|distn
argument_list|)
operator|==
literal|null
condition|)
block|{
name|reduceKeys
operator|.
name|add
argument_list|(
name|distExpr
argument_list|)
expr_stmt|;
name|outputColumnNames
operator|.
name|add
argument_list|(
name|getColumnInternalName
argument_list|(
name|reduceKeys
operator|.
name|size
argument_list|()
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|String
name|field
init|=
name|Utilities
operator|.
name|ReduceField
operator|.
name|KEY
operator|.
name|toString
argument_list|()
operator|+
literal|"."
operator|+
name|getColumnInternalName
argument_list|(
name|reduceKeys
operator|.
name|size
argument_list|()
operator|-
literal|1
argument_list|)
decl_stmt|;
name|ColumnInfo
name|colInfo
init|=
operator|new
name|ColumnInfo
argument_list|(
name|field
argument_list|,
name|reduceKeys
operator|.
name|get
argument_list|(
name|reduceKeys
operator|.
name|size
argument_list|()
operator|-
literal|1
argument_list|)
operator|.
name|getTypeInfo
argument_list|()
argument_list|,
literal|""
argument_list|,
literal|false
argument_list|)
decl_stmt|;
name|reduceSinkOutputRowResolver
operator|.
name|putExpression
argument_list|(
name|distn
argument_list|,
name|colInfo
argument_list|)
expr_stmt|;
name|colExprMap
operator|.
name|put
argument_list|(
name|colInfo
operator|.
name|getInternalName
argument_list|()
argument_list|,
name|distExpr
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Go over all the grouping keys and aggregations
for|for
control|(
name|String
name|dest
range|:
name|ks
control|)
block|{
name|List
argument_list|<
name|ASTNode
argument_list|>
name|grpByExprs
init|=
name|getGroupByForClause
argument_list|(
name|qbp
argument_list|,
name|dest
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|grpByExprs
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|ASTNode
name|grpbyExpr
init|=
name|grpByExprs
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|reduceSinkOutputRowResolver
operator|.
name|getExpression
argument_list|(
name|grpbyExpr
argument_list|)
operator|==
literal|null
condition|)
block|{
name|ExprNodeDesc
name|grpByExprNode
init|=
name|genExprNodeDesc
argument_list|(
name|grpbyExpr
argument_list|,
name|inputRR
argument_list|)
decl_stmt|;
name|reduceValues
operator|.
name|add
argument_list|(
name|grpByExprNode
argument_list|)
expr_stmt|;
name|String
name|field
init|=
name|Utilities
operator|.
name|ReduceField
operator|.
name|VALUE
operator|.
name|toString
argument_list|()
operator|+
literal|"."
operator|+
name|getColumnInternalName
argument_list|(
name|reduceValues
operator|.
name|size
argument_list|()
operator|-
literal|1
argument_list|)
decl_stmt|;
name|ColumnInfo
name|colInfo
init|=
operator|new
name|ColumnInfo
argument_list|(
name|field
argument_list|,
name|reduceValues
operator|.
name|get
argument_list|(
name|reduceValues
operator|.
name|size
argument_list|()
operator|-
literal|1
argument_list|)
operator|.
name|getTypeInfo
argument_list|()
argument_list|,
literal|""
argument_list|,
literal|false
argument_list|)
decl_stmt|;
name|reduceSinkOutputRowResolver
operator|.
name|putExpression
argument_list|(
name|grpbyExpr
argument_list|,
name|colInfo
argument_list|)
expr_stmt|;
name|outputColumnNames
operator|.
name|add
argument_list|(
name|getColumnInternalName
argument_list|(
name|reduceValues
operator|.
name|size
argument_list|()
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|colExprMap
operator|.
name|put
argument_list|(
name|field
argument_list|,
name|grpByExprNode
argument_list|)
expr_stmt|;
block|}
block|}
comment|// For each aggregation
name|HashMap
argument_list|<
name|String
argument_list|,
name|ASTNode
argument_list|>
name|aggregationTrees
init|=
name|qbp
operator|.
name|getAggregationExprsForClause
argument_list|(
name|dest
argument_list|)
decl_stmt|;
assert|assert
operator|(
name|aggregationTrees
operator|!=
literal|null
operator|)
assert|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|ASTNode
argument_list|>
name|entry
range|:
name|aggregationTrees
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|ASTNode
name|value
init|=
name|entry
operator|.
name|getValue
argument_list|()
decl_stmt|;
comment|// 0 is the function name
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<
name|value
operator|.
name|getChildCount
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|ASTNode
name|paraExpr
init|=
operator|(
name|ASTNode
operator|)
name|value
operator|.
name|getChild
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|reduceSinkOutputRowResolver
operator|.
name|getExpression
argument_list|(
name|paraExpr
argument_list|)
operator|==
literal|null
condition|)
block|{
name|ExprNodeDesc
name|paraExprNode
init|=
name|genExprNodeDesc
argument_list|(
name|paraExpr
argument_list|,
name|inputRR
argument_list|)
decl_stmt|;
name|reduceValues
operator|.
name|add
argument_list|(
name|paraExprNode
argument_list|)
expr_stmt|;
name|String
name|field
init|=
name|Utilities
operator|.
name|ReduceField
operator|.
name|VALUE
operator|.
name|toString
argument_list|()
operator|+
literal|"."
operator|+
name|getColumnInternalName
argument_list|(
name|reduceValues
operator|.
name|size
argument_list|()
operator|-
literal|1
argument_list|)
decl_stmt|;
name|ColumnInfo
name|colInfo
init|=
operator|new
name|ColumnInfo
argument_list|(
name|field
argument_list|,
name|reduceValues
operator|.
name|get
argument_list|(
name|reduceValues
operator|.
name|size
argument_list|()
operator|-
literal|1
argument_list|)
operator|.
name|getTypeInfo
argument_list|()
argument_list|,
literal|""
argument_list|,
literal|false
argument_list|)
decl_stmt|;
name|reduceSinkOutputRowResolver
operator|.
name|putExpression
argument_list|(
name|paraExpr
argument_list|,
name|colInfo
argument_list|)
expr_stmt|;
name|outputColumnNames
operator|.
name|add
argument_list|(
name|getColumnInternalName
argument_list|(
name|reduceValues
operator|.
name|size
argument_list|()
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|colExprMap
operator|.
name|put
argument_list|(
name|field
argument_list|,
name|paraExprNode
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
name|ReduceSinkOperator
name|rsOp
init|=
operator|(
name|ReduceSinkOperator
operator|)
name|putOpInsertMap
argument_list|(
name|OperatorFactory
operator|.
name|getAndMakeChild
argument_list|(
name|PlanUtils
operator|.
name|getReduceSinkDesc
argument_list|(
name|reduceKeys
argument_list|,
name|reduceValues
argument_list|,
name|outputColumnNames
argument_list|,
literal|true
argument_list|,
operator|-
literal|1
argument_list|,
name|reduceKeys
operator|.
name|size
argument_list|()
argument_list|,
operator|-
literal|1
argument_list|)
argument_list|,
operator|new
name|RowSchema
argument_list|(
name|reduceSinkOutputRowResolver
operator|.
name|getColumnInfos
argument_list|()
argument_list|)
argument_list|,
name|input
argument_list|)
argument_list|,
name|reduceSinkOutputRowResolver
argument_list|)
decl_stmt|;
name|rsOp
operator|.
name|setColumnExprMap
argument_list|(
name|colExprMap
argument_list|)
expr_stmt|;
return|return
name|rsOp
return|;
block|}
comment|// Groups the clause names into lists so that any two clauses in the same list has the same
comment|// group by and distinct keys and no clause appears in more than one list. Returns a list of the
comment|// lists of clauses.
specifier|private
name|List
argument_list|<
name|List
argument_list|<
name|String
argument_list|>
argument_list|>
name|getCommonGroupByDestGroups
parameter_list|(
name|QB
name|qb
parameter_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
argument_list|>
name|inputs
parameter_list|)
throws|throws
name|SemanticException
block|{
name|QBParseInfo
name|qbp
init|=
name|qb
operator|.
name|getParseInfo
argument_list|()
decl_stmt|;
name|TreeSet
argument_list|<
name|String
argument_list|>
name|ks
init|=
operator|new
name|TreeSet
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
name|ks
operator|.
name|addAll
argument_list|(
name|qbp
operator|.
name|getClauseNames
argument_list|()
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|List
argument_list|<
name|String
argument_list|>
argument_list|>
name|commonGroupByDestGroups
init|=
operator|new
name|ArrayList
argument_list|<
name|List
argument_list|<
name|String
argument_list|>
argument_list|>
argument_list|()
decl_stmt|;
comment|// If this is a trivial query block return
if|if
condition|(
name|ks
operator|.
name|size
argument_list|()
operator|<=
literal|1
condition|)
block|{
name|List
argument_list|<
name|String
argument_list|>
name|oneList
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|(
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|ks
operator|.
name|size
argument_list|()
operator|==
literal|1
condition|)
block|{
name|oneList
operator|.
name|add
argument_list|(
name|ks
operator|.
name|first
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|commonGroupByDestGroups
operator|.
name|add
argument_list|(
name|oneList
argument_list|)
expr_stmt|;
return|return
name|commonGroupByDestGroups
return|;
block|}
name|List
argument_list|<
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
argument_list|>
name|inputOperators
init|=
operator|new
name|ArrayList
argument_list|<
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
argument_list|>
argument_list|(
name|ks
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|List
argument_list|<
name|ExprNodeDesc
argument_list|>
argument_list|>
name|sprayKeyLists
init|=
operator|new
name|ArrayList
argument_list|<
name|List
argument_list|<
name|ExprNodeDesc
argument_list|>
argument_list|>
argument_list|(
name|ks
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|List
argument_list|<
name|ExprNodeDesc
argument_list|>
argument_list|>
name|distinctKeyLists
init|=
operator|new
name|ArrayList
argument_list|<
name|List
argument_list|<
name|ExprNodeDesc
argument_list|>
argument_list|>
argument_list|(
name|ks
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
comment|// Iterate over each clause
for|for
control|(
name|String
name|dest
range|:
name|ks
control|)
block|{
name|Operator
name|input
init|=
name|inputs
operator|.
name|get
argument_list|(
name|dest
argument_list|)
decl_stmt|;
name|RowResolver
name|inputRR
init|=
name|opParseCtx
operator|.
name|get
argument_list|(
name|input
argument_list|)
operator|.
name|getRowResolver
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|ExprNodeDesc
argument_list|>
name|distinctKeys
init|=
name|getDistinctExprs
argument_list|(
name|qbp
argument_list|,
name|dest
argument_list|,
name|inputRR
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|ExprNodeDesc
argument_list|>
name|sprayKeys
init|=
operator|new
name|ArrayList
argument_list|<
name|ExprNodeDesc
argument_list|>
argument_list|()
decl_stmt|;
comment|// Add the group by expressions
name|List
argument_list|<
name|ASTNode
argument_list|>
name|grpByExprs
init|=
name|getGroupByForClause
argument_list|(
name|qbp
argument_list|,
name|dest
argument_list|)
decl_stmt|;
for|for
control|(
name|ASTNode
name|grpByExpr
range|:
name|grpByExprs
control|)
block|{
name|ExprNodeDesc
name|exprDesc
init|=
name|genExprNodeDesc
argument_list|(
name|grpByExpr
argument_list|,
name|inputRR
argument_list|)
decl_stmt|;
if|if
condition|(
name|ExprNodeDescUtils
operator|.
name|indexOf
argument_list|(
name|exprDesc
argument_list|,
name|sprayKeys
argument_list|)
operator|<
literal|0
condition|)
block|{
name|sprayKeys
operator|.
name|add
argument_list|(
name|exprDesc
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Loop through each of the lists of exprs, looking for a match
name|boolean
name|found
init|=
literal|false
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|sprayKeyLists
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|input
operator|.
name|equals
argument_list|(
name|inputOperators
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|)
condition|)
block|{
continue|continue;
block|}
if|if
condition|(
name|distinctKeys
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
comment|// current dest has no distinct keys.
name|List
argument_list|<
name|ExprNodeDesc
argument_list|>
name|combinedList
init|=
operator|new
name|ArrayList
argument_list|<
name|ExprNodeDesc
argument_list|>
argument_list|()
decl_stmt|;
name|combineExprNodeLists
argument_list|(
name|sprayKeyLists
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|,
name|distinctKeyLists
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|,
name|combinedList
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|matchExprLists
argument_list|(
name|combinedList
argument_list|,
name|sprayKeys
argument_list|)
condition|)
block|{
continue|continue;
block|}
comment|// else do the common code at the end.
block|}
else|else
block|{
if|if
condition|(
name|distinctKeyLists
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|List
argument_list|<
name|ExprNodeDesc
argument_list|>
name|combinedList
init|=
operator|new
name|ArrayList
argument_list|<
name|ExprNodeDesc
argument_list|>
argument_list|()
decl_stmt|;
name|combineExprNodeLists
argument_list|(
name|sprayKeys
argument_list|,
name|distinctKeys
argument_list|,
name|combinedList
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|matchExprLists
argument_list|(
name|combinedList
argument_list|,
name|sprayKeyLists
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|)
condition|)
block|{
continue|continue;
block|}
else|else
block|{
comment|// we have found a match. insert this distinct clause to head.
name|distinctKeyLists
operator|.
name|remove
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|sprayKeyLists
operator|.
name|remove
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|distinctKeyLists
operator|.
name|add
argument_list|(
name|i
argument_list|,
name|distinctKeys
argument_list|)
expr_stmt|;
name|sprayKeyLists
operator|.
name|add
argument_list|(
name|i
argument_list|,
name|sprayKeys
argument_list|)
expr_stmt|;
name|commonGroupByDestGroups
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|add
argument_list|(
literal|0
argument_list|,
name|dest
argument_list|)
expr_stmt|;
name|found
operator|=
literal|true
expr_stmt|;
break|break;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|!
name|matchExprLists
argument_list|(
name|distinctKeyLists
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|,
name|distinctKeys
argument_list|)
condition|)
block|{
continue|continue;
block|}
if|if
condition|(
operator|!
name|matchExprLists
argument_list|(
name|sprayKeyLists
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|,
name|sprayKeys
argument_list|)
condition|)
block|{
continue|continue;
block|}
comment|// else do common code
block|}
block|}
comment|// common code
comment|// A match was found, so add the clause to the corresponding list
name|commonGroupByDestGroups
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|add
argument_list|(
name|dest
argument_list|)
expr_stmt|;
name|found
operator|=
literal|true
expr_stmt|;
break|break;
block|}
comment|// No match was found, so create new entries
if|if
condition|(
operator|!
name|found
condition|)
block|{
name|inputOperators
operator|.
name|add
argument_list|(
name|input
argument_list|)
expr_stmt|;
name|sprayKeyLists
operator|.
name|add
argument_list|(
name|sprayKeys
argument_list|)
expr_stmt|;
name|distinctKeyLists
operator|.
name|add
argument_list|(
name|distinctKeys
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|destGroup
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
name|destGroup
operator|.
name|add
argument_list|(
name|dest
argument_list|)
expr_stmt|;
name|commonGroupByDestGroups
operator|.
name|add
argument_list|(
name|destGroup
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|commonGroupByDestGroups
return|;
block|}
specifier|private
name|void
name|combineExprNodeLists
parameter_list|(
name|List
argument_list|<
name|ExprNodeDesc
argument_list|>
name|list
parameter_list|,
name|List
argument_list|<
name|ExprNodeDesc
argument_list|>
name|list2
parameter_list|,
name|List
argument_list|<
name|ExprNodeDesc
argument_list|>
name|combinedList
parameter_list|)
block|{
name|combinedList
operator|.
name|addAll
argument_list|(
name|list
argument_list|)
expr_stmt|;
for|for
control|(
name|ExprNodeDesc
name|elem
range|:
name|list2
control|)
block|{
if|if
condition|(
operator|!
name|combinedList
operator|.
name|contains
argument_list|(
name|elem
argument_list|)
condition|)
block|{
name|combinedList
operator|.
name|add
argument_list|(
name|elem
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|// Returns whether or not two lists contain the same elements independent of order
specifier|private
name|boolean
name|matchExprLists
parameter_list|(
name|List
argument_list|<
name|ExprNodeDesc
argument_list|>
name|list1
parameter_list|,
name|List
argument_list|<
name|ExprNodeDesc
argument_list|>
name|list2
parameter_list|)
block|{
if|if
condition|(
name|list1
operator|.
name|size
argument_list|()
operator|!=
name|list2
operator|.
name|size
argument_list|()
condition|)
block|{
return|return
literal|false
return|;
block|}
for|for
control|(
name|ExprNodeDesc
name|exprNodeDesc
range|:
name|list1
control|)
block|{
if|if
condition|(
name|ExprNodeDescUtils
operator|.
name|indexOf
argument_list|(
name|exprNodeDesc
argument_list|,
name|list2
argument_list|)
operator|<
literal|0
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
return|return
literal|true
return|;
block|}
comment|// Returns a list of the distinct exprs without duplicates for a given clause name
specifier|private
name|List
argument_list|<
name|ExprNodeDesc
argument_list|>
name|getDistinctExprs
parameter_list|(
name|QBParseInfo
name|qbp
parameter_list|,
name|String
name|dest
parameter_list|,
name|RowResolver
name|inputRR
parameter_list|)
throws|throws
name|SemanticException
block|{
name|List
argument_list|<
name|ASTNode
argument_list|>
name|distinctAggExprs
init|=
name|qbp
operator|.
name|getDistinctFuncExprsForClause
argument_list|(
name|dest
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|ExprNodeDesc
argument_list|>
name|distinctExprs
init|=
operator|new
name|ArrayList
argument_list|<
name|ExprNodeDesc
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|ASTNode
name|distinctAggExpr
range|:
name|distinctAggExprs
control|)
block|{
comment|// 0 is function name
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<
name|distinctAggExpr
operator|.
name|getChildCount
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|ASTNode
name|parameter
init|=
operator|(
name|ASTNode
operator|)
name|distinctAggExpr
operator|.
name|getChild
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|ExprNodeDesc
name|expr
init|=
name|genExprNodeDesc
argument_list|(
name|parameter
argument_list|,
name|inputRR
argument_list|)
decl_stmt|;
if|if
condition|(
name|ExprNodeDescUtils
operator|.
name|indexOf
argument_list|(
name|expr
argument_list|,
name|distinctExprs
argument_list|)
operator|<
literal|0
condition|)
block|{
name|distinctExprs
operator|.
name|add
argument_list|(
name|expr
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
name|distinctExprs
return|;
block|}
comment|// see if there are any distinct expressions
specifier|private
name|boolean
name|distinctExprsExists
parameter_list|(
name|QB
name|qb
parameter_list|)
block|{
name|QBParseInfo
name|qbp
init|=
name|qb
operator|.
name|getParseInfo
argument_list|()
decl_stmt|;
name|TreeSet
argument_list|<
name|String
argument_list|>
name|ks
init|=
operator|new
name|TreeSet
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
name|ks
operator|.
name|addAll
argument_list|(
name|qbp
operator|.
name|getClauseNames
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|String
name|dest
range|:
name|ks
control|)
block|{
name|List
argument_list|<
name|ASTNode
argument_list|>
name|list
init|=
name|qbp
operator|.
name|getDistinctFuncExprsForClause
argument_list|(
name|dest
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|list
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return
literal|true
return|;
block|}
block|}
return|return
literal|false
return|;
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"nls"
argument_list|)
specifier|private
name|Operator
name|genBodyPlan
parameter_list|(
name|QB
name|qb
parameter_list|,
name|Operator
name|input
parameter_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|Operator
argument_list|>
name|aliasToOpInfo
parameter_list|)
throws|throws
name|SemanticException
block|{
name|QBParseInfo
name|qbp
init|=
name|qb
operator|.
name|getParseInfo
argument_list|()
decl_stmt|;
name|TreeSet
argument_list|<
name|String
argument_list|>
name|ks
init|=
operator|new
name|TreeSet
argument_list|<
name|String
argument_list|>
argument_list|(
name|qbp
operator|.
name|getClauseNames
argument_list|()
argument_list|)
decl_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
argument_list|>
name|inputs
init|=
name|createInputForDests
argument_list|(
name|qb
argument_list|,
name|input
argument_list|,
name|ks
argument_list|)
decl_stmt|;
comment|// For multi-group by with the same distinct, we ignore all user hints
comment|// currently. It doesnt matter whether he has asked to do
comment|// map-side aggregation or not. Map side aggregation is turned off
name|List
argument_list|<
name|ASTNode
argument_list|>
name|commonDistinctExprs
init|=
name|getCommonDistinctExprs
argument_list|(
name|qb
argument_list|,
name|input
argument_list|)
decl_stmt|;
comment|// Consider a query like:
comment|//
comment|//  from src
comment|//    insert overwrite table dest1 select col1, count(distinct colx) group by col1
comment|//    insert overwrite table dest2 select col2, count(distinct colx) group by col2;
comment|//
comment|// With HIVE_OPTIMIZE_MULTI_GROUPBY_COMMON_DISTINCTS set to true, first we spray by the distinct
comment|// value (colx), and then perform the 2 groups bys. This makes sense if map-side aggregation is
comment|// turned off. However, with maps-side aggregation, it might be useful in some cases to treat
comment|// the 2 inserts independently, thereby performing the query above in 2MR jobs instead of 3
comment|// (due to spraying by distinct key first).
name|boolean
name|optimizeMultiGroupBy
init|=
name|commonDistinctExprs
operator|!=
literal|null
operator|&&
name|conf
operator|.
name|getBoolVar
argument_list|(
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVE_OPTIMIZE_MULTI_GROUPBY_COMMON_DISTINCTS
argument_list|)
decl_stmt|;
name|Operator
name|curr
init|=
name|input
decl_stmt|;
comment|// if there is a single distinct, optimize that. Spray initially by the
comment|// distinct key,
comment|// no computation at the mapper. Have multiple group by operators at the
comment|// reducer - and then
comment|// proceed
if|if
condition|(
name|optimizeMultiGroupBy
condition|)
block|{
name|curr
operator|=
name|createCommonReduceSink
argument_list|(
name|qb
argument_list|,
name|input
argument_list|)
expr_stmt|;
name|RowResolver
name|currRR
init|=
name|opParseCtx
operator|.
name|get
argument_list|(
name|curr
argument_list|)
operator|.
name|getRowResolver
argument_list|()
decl_stmt|;
comment|// create a forward operator
name|input
operator|=
name|putOpInsertMap
argument_list|(
name|OperatorFactory
operator|.
name|getAndMakeChild
argument_list|(
operator|new
name|ForwardDesc
argument_list|()
argument_list|,
operator|new
name|RowSchema
argument_list|(
name|currRR
operator|.
name|getColumnInfos
argument_list|()
argument_list|)
argument_list|,
name|curr
argument_list|)
argument_list|,
name|currRR
argument_list|)
expr_stmt|;
for|for
control|(
name|String
name|dest
range|:
name|ks
control|)
block|{
name|curr
operator|=
name|input
expr_stmt|;
name|curr
operator|=
name|genGroupByPlan2MRMultiGroupBy
argument_list|(
name|dest
argument_list|,
name|qb
argument_list|,
name|curr
argument_list|)
expr_stmt|;
name|curr
operator|=
name|genSelectPlan
argument_list|(
name|dest
argument_list|,
name|qb
argument_list|,
name|curr
argument_list|)
expr_stmt|;
name|Integer
name|limit
init|=
name|qbp
operator|.
name|getDestLimit
argument_list|(
name|dest
argument_list|)
decl_stmt|;
if|if
condition|(
name|limit
operator|!=
literal|null
condition|)
block|{
name|curr
operator|=
name|genLimitMapRedPlan
argument_list|(
name|dest
argument_list|,
name|qb
argument_list|,
name|curr
argument_list|,
name|limit
operator|.
name|intValue
argument_list|()
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|qb
operator|.
name|getParseInfo
argument_list|()
operator|.
name|setOuterQueryLimit
argument_list|(
name|limit
operator|.
name|intValue
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|curr
operator|=
name|genFileSinkPlan
argument_list|(
name|dest
argument_list|,
name|qb
argument_list|,
name|curr
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|List
argument_list|<
name|List
argument_list|<
name|String
argument_list|>
argument_list|>
name|commonGroupByDestGroups
init|=
literal|null
decl_stmt|;
comment|// If we can put multiple group bys in a single reducer, determine suitable groups of
comment|// expressions, otherwise treat all the expressions as a single group
if|if
condition|(
name|conf
operator|.
name|getBoolVar
argument_list|(
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVEMULTIGROUPBYSINGLEREDUCER
argument_list|)
condition|)
block|{
try|try
block|{
name|commonGroupByDestGroups
operator|=
name|getCommonGroupByDestGroups
argument_list|(
name|qb
argument_list|,
name|inputs
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|SemanticException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Failed to group clauses by common spray keys."
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|commonGroupByDestGroups
operator|==
literal|null
condition|)
block|{
name|commonGroupByDestGroups
operator|=
operator|new
name|ArrayList
argument_list|<
name|List
argument_list|<
name|String
argument_list|>
argument_list|>
argument_list|()
expr_stmt|;
name|commonGroupByDestGroups
operator|.
name|add
argument_list|(
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|(
name|ks
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|commonGroupByDestGroups
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
comment|// Iterate over each group of subqueries with the same group by/distinct keys
for|for
control|(
name|List
argument_list|<
name|String
argument_list|>
name|commonGroupByDestGroup
range|:
name|commonGroupByDestGroups
control|)
block|{
if|if
condition|(
name|commonGroupByDestGroup
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
continue|continue;
block|}
name|String
name|firstDest
init|=
name|commonGroupByDestGroup
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|input
operator|=
name|inputs
operator|.
name|get
argument_list|(
name|firstDest
argument_list|)
expr_stmt|;
comment|// Constructs a standard group by plan if:
comment|// There is no other subquery with the same group by/distinct keys or
comment|// (There are no aggregations in a representative query for the group and
comment|// There is no group by in that representative query) or
comment|// The data is skewed or
comment|// The conf variable used to control combining group bys into a single reducer is false
if|if
condition|(
name|commonGroupByDestGroup
operator|.
name|size
argument_list|()
operator|==
literal|1
operator|||
operator|(
name|qbp
operator|.
name|getAggregationExprsForClause
argument_list|(
name|firstDest
argument_list|)
operator|.
name|size
argument_list|()
operator|==
literal|0
operator|&&
name|getGroupByForClause
argument_list|(
name|qbp
argument_list|,
name|firstDest
argument_list|)
operator|.
name|size
argument_list|()
operator|==
literal|0
operator|)
operator|||
name|conf
operator|.
name|getBoolVar
argument_list|(
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVEGROUPBYSKEW
argument_list|)
operator|||
operator|!
name|conf
operator|.
name|getBoolVar
argument_list|(
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVEMULTIGROUPBYSINGLEREDUCER
argument_list|)
condition|)
block|{
comment|// Go over all the destination tables
for|for
control|(
name|String
name|dest
range|:
name|commonGroupByDestGroup
control|)
block|{
name|curr
operator|=
name|inputs
operator|.
name|get
argument_list|(
name|dest
argument_list|)
expr_stmt|;
if|if
condition|(
name|qbp
operator|.
name|getWhrForClause
argument_list|(
name|dest
argument_list|)
operator|!=
literal|null
condition|)
block|{
name|ASTNode
name|whereExpr
init|=
name|qb
operator|.
name|getParseInfo
argument_list|()
operator|.
name|getWhrForClause
argument_list|(
name|dest
argument_list|)
decl_stmt|;
name|curr
operator|=
name|genFilterPlan
argument_list|(
operator|(
name|ASTNode
operator|)
name|whereExpr
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
argument_list|,
name|qb
argument_list|,
name|curr
argument_list|,
name|aliasToOpInfo
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|qbp
operator|.
name|getAggregationExprsForClause
argument_list|(
name|dest
argument_list|)
operator|.
name|size
argument_list|()
operator|!=
literal|0
operator|||
name|getGroupByForClause
argument_list|(
name|qbp
argument_list|,
name|dest
argument_list|)
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
comment|// multiple distincts is not supported with skew in data
if|if
condition|(
name|conf
operator|.
name|getBoolVar
argument_list|(
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVEGROUPBYSKEW
argument_list|)
operator|&&
name|qbp
operator|.
name|getDistinctFuncExprsForClause
argument_list|(
name|dest
argument_list|)
operator|.
name|size
argument_list|()
operator|>
literal|1
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|UNSUPPORTED_MULTIPLE_DISTINCTS
operator|.
name|getMsg
argument_list|()
argument_list|)
throw|;
block|}
comment|// insert a select operator here used by the ColumnPruner to reduce
comment|// the data to shuffle
name|curr
operator|=
name|insertSelectAllPlanForGroupBy
argument_list|(
name|curr
argument_list|)
expr_stmt|;
if|if
condition|(
name|conf
operator|.
name|getBoolVar
argument_list|(
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVEMAPSIDEAGGREGATE
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|conf
operator|.
name|getBoolVar
argument_list|(
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVEGROUPBYSKEW
argument_list|)
condition|)
block|{
name|curr
operator|=
name|genGroupByPlanMapAggrNoSkew
argument_list|(
name|dest
argument_list|,
name|qb
argument_list|,
name|curr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|curr
operator|=
name|genGroupByPlanMapAggr2MR
argument_list|(
name|dest
argument_list|,
name|qb
argument_list|,
name|curr
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|conf
operator|.
name|getBoolVar
argument_list|(
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVEGROUPBYSKEW
argument_list|)
condition|)
block|{
name|curr
operator|=
name|genGroupByPlan2MR
argument_list|(
name|dest
argument_list|,
name|qb
argument_list|,
name|curr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|curr
operator|=
name|genGroupByPlan1MR
argument_list|(
name|dest
argument_list|,
name|qb
argument_list|,
name|curr
argument_list|)
expr_stmt|;
block|}
block|}
name|curr
operator|=
name|genPostGroupByBodyPlan
argument_list|(
name|curr
argument_list|,
name|dest
argument_list|,
name|qb
argument_list|,
name|aliasToOpInfo
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|curr
operator|=
name|genGroupByPlan1ReduceMultiGBY
argument_list|(
name|commonGroupByDestGroup
argument_list|,
name|qb
argument_list|,
name|input
argument_list|,
name|aliasToOpInfo
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Created Body Plan for Query Block "
operator|+
name|qb
operator|.
name|getId
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|curr
return|;
block|}
specifier|private
name|Map
argument_list|<
name|String
argument_list|,
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
argument_list|>
name|createInputForDests
parameter_list|(
name|QB
name|qb
parameter_list|,
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
name|input
parameter_list|,
name|Set
argument_list|<
name|String
argument_list|>
name|dests
parameter_list|)
throws|throws
name|SemanticException
block|{
name|Map
argument_list|<
name|String
argument_list|,
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
argument_list|>
name|inputs
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|String
name|dest
range|:
name|dests
control|)
block|{
name|inputs
operator|.
name|put
argument_list|(
name|dest
argument_list|,
name|genLateralViewPlanForDest
argument_list|(
name|dest
argument_list|,
name|qb
argument_list|,
name|input
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|inputs
return|;
block|}
specifier|private
name|Operator
name|genPostGroupByBodyPlan
parameter_list|(
name|Operator
name|curr
parameter_list|,
name|String
name|dest
parameter_list|,
name|QB
name|qb
parameter_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|Operator
argument_list|>
name|aliasToOpInfo
parameter_list|)
throws|throws
name|SemanticException
block|{
name|QBParseInfo
name|qbp
init|=
name|qb
operator|.
name|getParseInfo
argument_list|()
decl_stmt|;
comment|// Insert HAVING plan here
if|if
condition|(
name|qbp
operator|.
name|getHavingForClause
argument_list|(
name|dest
argument_list|)
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|getGroupByForClause
argument_list|(
name|qbp
argument_list|,
name|dest
argument_list|)
operator|.
name|size
argument_list|()
operator|==
literal|0
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
literal|"HAVING specified without GROUP BY"
argument_list|)
throw|;
block|}
name|curr
operator|=
name|genHavingPlan
argument_list|(
name|dest
argument_list|,
name|qb
argument_list|,
name|curr
argument_list|,
name|aliasToOpInfo
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|queryProperties
operator|.
name|hasWindowing
argument_list|()
operator|&&
name|qb
operator|.
name|getWindowingSpec
argument_list|(
name|dest
argument_list|)
operator|!=
literal|null
condition|)
block|{
name|curr
operator|=
name|genWindowingPlan
argument_list|(
name|qb
operator|.
name|getWindowingSpec
argument_list|(
name|dest
argument_list|)
argument_list|,
name|curr
argument_list|)
expr_stmt|;
block|}
name|curr
operator|=
name|genSelectPlan
argument_list|(
name|dest
argument_list|,
name|qb
argument_list|,
name|curr
argument_list|)
expr_stmt|;
name|Integer
name|limit
init|=
name|qbp
operator|.
name|getDestLimit
argument_list|(
name|dest
argument_list|)
decl_stmt|;
comment|// Expressions are not supported currently without a alias.
comment|// Reduce sink is needed if the query contains a cluster by, distribute by,
comment|// order by or a sort by clause.
name|boolean
name|genReduceSink
init|=
literal|false
decl_stmt|;
comment|// Currently, expressions are not allowed in cluster by, distribute by,
comment|// order by or a sort by clause. For each of the above clause types, check
comment|// if the clause contains any expression.
if|if
condition|(
name|qbp
operator|.
name|getClusterByForClause
argument_list|(
name|dest
argument_list|)
operator|!=
literal|null
condition|)
block|{
name|genReduceSink
operator|=
literal|true
expr_stmt|;
block|}
if|if
condition|(
name|qbp
operator|.
name|getDistributeByForClause
argument_list|(
name|dest
argument_list|)
operator|!=
literal|null
condition|)
block|{
name|genReduceSink
operator|=
literal|true
expr_stmt|;
block|}
if|if
condition|(
name|qbp
operator|.
name|getOrderByForClause
argument_list|(
name|dest
argument_list|)
operator|!=
literal|null
condition|)
block|{
name|genReduceSink
operator|=
literal|true
expr_stmt|;
block|}
if|if
condition|(
name|qbp
operator|.
name|getSortByForClause
argument_list|(
name|dest
argument_list|)
operator|!=
literal|null
condition|)
block|{
name|genReduceSink
operator|=
literal|true
expr_stmt|;
block|}
if|if
condition|(
name|genReduceSink
condition|)
block|{
name|int
name|numReducers
init|=
operator|-
literal|1
decl_stmt|;
comment|// Use only 1 reducer if order by is present
if|if
condition|(
name|qbp
operator|.
name|getOrderByForClause
argument_list|(
name|dest
argument_list|)
operator|!=
literal|null
condition|)
block|{
name|numReducers
operator|=
literal|1
expr_stmt|;
block|}
name|curr
operator|=
name|genReduceSinkPlan
argument_list|(
name|dest
argument_list|,
name|qb
argument_list|,
name|curr
argument_list|,
name|numReducers
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|qbp
operator|.
name|getIsSubQ
argument_list|()
condition|)
block|{
if|if
condition|(
name|limit
operator|!=
literal|null
condition|)
block|{
comment|// In case of order by, only 1 reducer is used, so no need of
comment|// another shuffle
name|curr
operator|=
name|genLimitMapRedPlan
argument_list|(
name|dest
argument_list|,
name|qb
argument_list|,
name|curr
argument_list|,
name|limit
operator|.
name|intValue
argument_list|()
argument_list|,
name|qbp
operator|.
name|getOrderByForClause
argument_list|(
name|dest
argument_list|)
operator|!=
literal|null
condition|?
literal|false
else|:
literal|true
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|curr
operator|=
name|genConversionOps
argument_list|(
name|dest
argument_list|,
name|qb
argument_list|,
name|curr
argument_list|)
expr_stmt|;
comment|// exact limit can be taken care of by the fetch operator
if|if
condition|(
name|limit
operator|!=
literal|null
condition|)
block|{
name|boolean
name|extraMRStep
init|=
literal|true
decl_stmt|;
if|if
condition|(
name|qbp
operator|.
name|getOrderByForClause
argument_list|(
name|dest
argument_list|)
operator|!=
literal|null
operator|||
name|qb
operator|.
name|getIsQuery
argument_list|()
operator|&&
name|qbp
operator|.
name|getClusterByForClause
argument_list|(
name|dest
argument_list|)
operator|==
literal|null
operator|&&
name|qbp
operator|.
name|getSortByForClause
argument_list|(
name|dest
argument_list|)
operator|==
literal|null
condition|)
block|{
name|extraMRStep
operator|=
literal|false
expr_stmt|;
block|}
name|curr
operator|=
name|genLimitMapRedPlan
argument_list|(
name|dest
argument_list|,
name|qb
argument_list|,
name|curr
argument_list|,
name|limit
operator|.
name|intValue
argument_list|()
argument_list|,
name|extraMRStep
argument_list|)
expr_stmt|;
name|qb
operator|.
name|getParseInfo
argument_list|()
operator|.
name|setOuterQueryLimit
argument_list|(
name|limit
operator|.
name|intValue
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|SessionState
operator|.
name|get
argument_list|()
operator|.
name|getHiveOperation
argument_list|()
operator|.
name|equals
argument_list|(
name|HiveOperation
operator|.
name|CREATEVIEW
argument_list|)
condition|)
block|{
name|curr
operator|=
name|genFileSinkPlan
argument_list|(
name|dest
argument_list|,
name|qb
argument_list|,
name|curr
argument_list|)
expr_stmt|;
block|}
block|}
comment|// change curr ops row resolver's tab aliases to query alias if it
comment|// exists
if|if
condition|(
name|qb
operator|.
name|getParseInfo
argument_list|()
operator|.
name|getAlias
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|RowResolver
name|rr
init|=
name|opParseCtx
operator|.
name|get
argument_list|(
name|curr
argument_list|)
operator|.
name|getRowResolver
argument_list|()
decl_stmt|;
name|RowResolver
name|newRR
init|=
operator|new
name|RowResolver
argument_list|()
decl_stmt|;
name|String
name|alias
init|=
name|qb
operator|.
name|getParseInfo
argument_list|()
operator|.
name|getAlias
argument_list|()
decl_stmt|;
for|for
control|(
name|ColumnInfo
name|colInfo
range|:
name|rr
operator|.
name|getColumnInfos
argument_list|()
control|)
block|{
name|String
name|name
init|=
name|colInfo
operator|.
name|getInternalName
argument_list|()
decl_stmt|;
name|String
index|[]
name|tmp
init|=
name|rr
operator|.
name|reverseLookup
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
literal|""
operator|.
name|equals
argument_list|(
name|tmp
index|[
literal|0
index|]
argument_list|)
operator|||
name|tmp
index|[
literal|1
index|]
operator|==
literal|null
condition|)
block|{
comment|// ast expression is not a valid column name for table
name|tmp
index|[
literal|1
index|]
operator|=
name|colInfo
operator|.
name|getInternalName
argument_list|()
expr_stmt|;
block|}
name|newRR
operator|.
name|put
argument_list|(
name|alias
argument_list|,
name|tmp
index|[
literal|1
index|]
argument_list|,
name|colInfo
argument_list|)
expr_stmt|;
block|}
name|opParseCtx
operator|.
name|get
argument_list|(
name|curr
argument_list|)
operator|.
name|setRowResolver
argument_list|(
name|newRR
argument_list|)
expr_stmt|;
block|}
return|return
name|curr
return|;
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"nls"
argument_list|)
specifier|private
name|Operator
name|genUnionPlan
parameter_list|(
name|String
name|unionalias
parameter_list|,
name|String
name|leftalias
parameter_list|,
name|Operator
name|leftOp
parameter_list|,
name|String
name|rightalias
parameter_list|,
name|Operator
name|rightOp
parameter_list|)
throws|throws
name|SemanticException
block|{
comment|// Currently, the unions are not merged - each union has only 2 parents. So,
comment|// a n-way union will lead to (n-1) union operators.
comment|// This can be easily merged into 1 union
name|RowResolver
name|leftRR
init|=
name|opParseCtx
operator|.
name|get
argument_list|(
name|leftOp
argument_list|)
operator|.
name|getRowResolver
argument_list|()
decl_stmt|;
name|RowResolver
name|rightRR
init|=
name|opParseCtx
operator|.
name|get
argument_list|(
name|rightOp
argument_list|)
operator|.
name|getRowResolver
argument_list|()
decl_stmt|;
name|HashMap
argument_list|<
name|String
argument_list|,
name|ColumnInfo
argument_list|>
name|leftmap
init|=
name|leftRR
operator|.
name|getFieldMap
argument_list|(
name|leftalias
argument_list|)
decl_stmt|;
name|HashMap
argument_list|<
name|String
argument_list|,
name|ColumnInfo
argument_list|>
name|rightmap
init|=
name|rightRR
operator|.
name|getFieldMap
argument_list|(
name|rightalias
argument_list|)
decl_stmt|;
comment|// make sure the schemas of both sides are the same
name|ASTNode
name|tabref
init|=
name|qb
operator|.
name|getAliases
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|?
literal|null
else|:
name|qb
operator|.
name|getParseInfo
argument_list|()
operator|.
name|getSrcForAlias
argument_list|(
name|qb
operator|.
name|getAliases
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|leftmap
operator|.
name|size
argument_list|()
operator|!=
name|rightmap
operator|.
name|size
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
literal|"Schema of both sides of union should match."
argument_list|)
throw|;
block|}
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|ColumnInfo
argument_list|>
name|lEntry
range|:
name|leftmap
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|String
name|field
init|=
name|lEntry
operator|.
name|getKey
argument_list|()
decl_stmt|;
name|ColumnInfo
name|lInfo
init|=
name|lEntry
operator|.
name|getValue
argument_list|()
decl_stmt|;
name|ColumnInfo
name|rInfo
init|=
name|rightmap
operator|.
name|get
argument_list|(
name|field
argument_list|)
decl_stmt|;
if|if
condition|(
name|rInfo
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|generateErrorMessage
argument_list|(
name|tabref
argument_list|,
literal|"Schema of both sides of union should match. "
operator|+
name|rightalias
operator|+
literal|" does not have the field "
operator|+
name|field
argument_list|)
argument_list|)
throw|;
block|}
if|if
condition|(
name|lInfo
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|generateErrorMessage
argument_list|(
name|tabref
argument_list|,
literal|"Schema of both sides of union should match. "
operator|+
name|leftalias
operator|+
literal|" does not have the field "
operator|+
name|field
argument_list|)
argument_list|)
throw|;
block|}
if|if
condition|(
operator|!
name|lInfo
operator|.
name|getInternalName
argument_list|()
operator|.
name|equals
argument_list|(
name|rInfo
operator|.
name|getInternalName
argument_list|()
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|generateErrorMessage
argument_list|(
name|tabref
argument_list|,
literal|"Schema of both sides of union should match: field "
operator|+
name|field
operator|+
literal|":"
operator|+
literal|" appears on the left side of the UNION at column position: "
operator|+
name|getPositionFromInternalName
argument_list|(
name|lInfo
operator|.
name|getInternalName
argument_list|()
argument_list|)
operator|+
literal|", and on the right side of the UNION at column position: "
operator|+
name|getPositionFromInternalName
argument_list|(
name|rInfo
operator|.
name|getInternalName
argument_list|()
argument_list|)
operator|+
literal|". Column positions should match for a UNION"
argument_list|)
argument_list|)
throw|;
block|}
comment|// try widening coversion, otherwise fail union
name|TypeInfo
name|commonTypeInfo
init|=
name|FunctionRegistry
operator|.
name|getCommonClassForUnionAll
argument_list|(
name|lInfo
operator|.
name|getType
argument_list|()
argument_list|,
name|rInfo
operator|.
name|getType
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|commonTypeInfo
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|generateErrorMessage
argument_list|(
name|tabref
argument_list|,
literal|"Schema of both sides of union should match: Column "
operator|+
name|field
operator|+
literal|" is of type "
operator|+
name|lInfo
operator|.
name|getType
argument_list|()
operator|.
name|getTypeName
argument_list|()
operator|+
literal|" on first table and type "
operator|+
name|rInfo
operator|.
name|getType
argument_list|()
operator|.
name|getTypeName
argument_list|()
operator|+
literal|" on second table"
argument_list|)
argument_list|)
throw|;
block|}
block|}
comment|// construct the forward operator
name|RowResolver
name|unionoutRR
init|=
operator|new
name|RowResolver
argument_list|()
decl_stmt|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|ColumnInfo
argument_list|>
name|lEntry
range|:
name|leftmap
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|String
name|field
init|=
name|lEntry
operator|.
name|getKey
argument_list|()
decl_stmt|;
name|ColumnInfo
name|lInfo
init|=
name|lEntry
operator|.
name|getValue
argument_list|()
decl_stmt|;
name|ColumnInfo
name|rInfo
init|=
name|rightmap
operator|.
name|get
argument_list|(
name|field
argument_list|)
decl_stmt|;
name|ColumnInfo
name|unionColInfo
init|=
operator|new
name|ColumnInfo
argument_list|(
name|lInfo
argument_list|)
decl_stmt|;
name|unionColInfo
operator|.
name|setType
argument_list|(
name|FunctionRegistry
operator|.
name|getCommonClassForUnionAll
argument_list|(
name|lInfo
operator|.
name|getType
argument_list|()
argument_list|,
name|rInfo
operator|.
name|getType
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|unionoutRR
operator|.
name|put
argument_list|(
name|unionalias
argument_list|,
name|field
argument_list|,
name|unionColInfo
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|leftOp
operator|instanceof
name|UnionOperator
operator|)
condition|)
block|{
name|leftOp
operator|=
name|genInputSelectForUnion
argument_list|(
name|leftOp
argument_list|,
name|leftmap
argument_list|,
name|leftalias
argument_list|,
name|unionoutRR
argument_list|,
name|unionalias
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|rightOp
operator|instanceof
name|UnionOperator
operator|)
condition|)
block|{
name|rightOp
operator|=
name|genInputSelectForUnion
argument_list|(
name|rightOp
argument_list|,
name|rightmap
argument_list|,
name|rightalias
argument_list|,
name|unionoutRR
argument_list|,
name|unionalias
argument_list|)
expr_stmt|;
block|}
comment|// If one of the children is a union, merge with it
comment|// else create a new one
if|if
condition|(
operator|(
name|leftOp
operator|instanceof
name|UnionOperator
operator|)
operator|||
operator|(
name|rightOp
operator|instanceof
name|UnionOperator
operator|)
condition|)
block|{
if|if
condition|(
name|leftOp
operator|instanceof
name|UnionOperator
condition|)
block|{
comment|// make left a child of right
name|List
argument_list|<
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
argument_list|>
name|child
init|=
operator|new
name|ArrayList
argument_list|<
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
argument_list|>
argument_list|()
decl_stmt|;
name|child
operator|.
name|add
argument_list|(
name|leftOp
argument_list|)
expr_stmt|;
name|rightOp
operator|.
name|setChildOperators
argument_list|(
name|child
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
argument_list|>
name|parent
init|=
name|leftOp
operator|.
name|getParentOperators
argument_list|()
decl_stmt|;
name|parent
operator|.
name|add
argument_list|(
name|rightOp
argument_list|)
expr_stmt|;
name|UnionDesc
name|uDesc
init|=
operator|(
operator|(
name|UnionOperator
operator|)
name|leftOp
operator|)
operator|.
name|getConf
argument_list|()
decl_stmt|;
name|uDesc
operator|.
name|setNumInputs
argument_list|(
name|uDesc
operator|.
name|getNumInputs
argument_list|()
operator|+
literal|1
argument_list|)
expr_stmt|;
return|return
name|putOpInsertMap
argument_list|(
name|leftOp
argument_list|,
name|unionoutRR
argument_list|)
return|;
block|}
else|else
block|{
comment|// make right a child of left
name|List
argument_list|<
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
argument_list|>
name|child
init|=
operator|new
name|ArrayList
argument_list|<
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
argument_list|>
argument_list|()
decl_stmt|;
name|child
operator|.
name|add
argument_list|(
name|rightOp
argument_list|)
expr_stmt|;
name|leftOp
operator|.
name|setChildOperators
argument_list|(
name|child
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
argument_list|>
name|parent
init|=
name|rightOp
operator|.
name|getParentOperators
argument_list|()
decl_stmt|;
name|parent
operator|.
name|add
argument_list|(
name|leftOp
argument_list|)
expr_stmt|;
name|UnionDesc
name|uDesc
init|=
operator|(
operator|(
name|UnionOperator
operator|)
name|rightOp
operator|)
operator|.
name|getConf
argument_list|()
decl_stmt|;
name|uDesc
operator|.
name|setNumInputs
argument_list|(
name|uDesc
operator|.
name|getNumInputs
argument_list|()
operator|+
literal|1
argument_list|)
expr_stmt|;
return|return
name|putOpInsertMap
argument_list|(
name|rightOp
argument_list|,
name|unionoutRR
argument_list|)
return|;
block|}
block|}
comment|// Create a new union operator
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
name|unionforward
init|=
name|OperatorFactory
operator|.
name|getAndMakeChild
argument_list|(
operator|new
name|UnionDesc
argument_list|()
argument_list|,
operator|new
name|RowSchema
argument_list|(
name|unionoutRR
operator|.
name|getColumnInfos
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
comment|// set union operator as child of each of leftOp and rightOp
name|List
argument_list|<
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
argument_list|>
name|child
init|=
operator|new
name|ArrayList
argument_list|<
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
argument_list|>
argument_list|()
decl_stmt|;
name|child
operator|.
name|add
argument_list|(
name|unionforward
argument_list|)
expr_stmt|;
name|rightOp
operator|.
name|setChildOperators
argument_list|(
name|child
argument_list|)
expr_stmt|;
name|child
operator|=
operator|new
name|ArrayList
argument_list|<
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
argument_list|>
argument_list|()
expr_stmt|;
name|child
operator|.
name|add
argument_list|(
name|unionforward
argument_list|)
expr_stmt|;
name|leftOp
operator|.
name|setChildOperators
argument_list|(
name|child
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
argument_list|>
name|parent
init|=
operator|new
name|ArrayList
argument_list|<
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
argument_list|>
argument_list|()
decl_stmt|;
name|parent
operator|.
name|add
argument_list|(
name|leftOp
argument_list|)
expr_stmt|;
name|parent
operator|.
name|add
argument_list|(
name|rightOp
argument_list|)
expr_stmt|;
name|unionforward
operator|.
name|setParentOperators
argument_list|(
name|parent
argument_list|)
expr_stmt|;
comment|// create operator info list to return
return|return
name|putOpInsertMap
argument_list|(
name|unionforward
argument_list|,
name|unionoutRR
argument_list|)
return|;
block|}
comment|/**    * Generates a select operator which can go between the original input operator and the union    * operator. This select casts columns to match the type of the associated column in the union,    * other columns pass through unchanged. The new operator's only parent is the original input    * operator to the union, and it's only child is the union. If the input does not need to be    * cast, the original operator is returned, and no new select operator is added.    *    * @param origInputOp    *          The original input operator to the union.    * @param origInputFieldMap    *          A map from field name to ColumnInfo for the original input operator.    * @param origInputAlias    *          The alias associated with the original input operator.    * @param unionoutRR    *          The union's output row resolver.    * @param unionalias    *          The alias of the union.    * @return    * @throws SemanticException    */
specifier|private
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
name|genInputSelectForUnion
parameter_list|(
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
name|origInputOp
parameter_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|ColumnInfo
argument_list|>
name|origInputFieldMap
parameter_list|,
name|String
name|origInputAlias
parameter_list|,
name|RowResolver
name|unionoutRR
parameter_list|,
name|String
name|unionalias
parameter_list|)
throws|throws
name|SemanticException
block|{
name|List
argument_list|<
name|ExprNodeDesc
argument_list|>
name|columns
init|=
operator|new
name|ArrayList
argument_list|<
name|ExprNodeDesc
argument_list|>
argument_list|()
decl_stmt|;
name|boolean
name|needsCast
init|=
literal|false
decl_stmt|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|ColumnInfo
argument_list|>
name|unionEntry
range|:
name|unionoutRR
operator|.
name|getFieldMap
argument_list|(
name|unionalias
argument_list|)
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|String
name|field
init|=
name|unionEntry
operator|.
name|getKey
argument_list|()
decl_stmt|;
name|ColumnInfo
name|lInfo
init|=
name|origInputFieldMap
operator|.
name|get
argument_list|(
name|field
argument_list|)
decl_stmt|;
name|ExprNodeDesc
name|column
init|=
operator|new
name|ExprNodeColumnDesc
argument_list|(
name|lInfo
operator|.
name|getType
argument_list|()
argument_list|,
name|lInfo
operator|.
name|getInternalName
argument_list|()
argument_list|,
name|lInfo
operator|.
name|getTabAlias
argument_list|()
argument_list|,
name|lInfo
operator|.
name|getIsVirtualCol
argument_list|()
argument_list|,
name|lInfo
operator|.
name|isSkewedCol
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|lInfo
operator|.
name|getType
argument_list|()
operator|.
name|equals
argument_list|(
name|unionEntry
operator|.
name|getValue
argument_list|()
operator|.
name|getType
argument_list|()
argument_list|)
condition|)
block|{
name|needsCast
operator|=
literal|true
expr_stmt|;
name|column
operator|=
name|ParseUtils
operator|.
name|createConversionCast
argument_list|(
name|column
argument_list|,
operator|(
name|PrimitiveTypeInfo
operator|)
name|unionEntry
operator|.
name|getValue
argument_list|()
operator|.
name|getType
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|columns
operator|.
name|add
argument_list|(
name|column
argument_list|)
expr_stmt|;
block|}
comment|// If none of the columns need to be cast there's no need for an additional select operator
if|if
condition|(
operator|!
name|needsCast
condition|)
block|{
return|return
name|origInputOp
return|;
block|}
name|RowResolver
name|rowResolver
init|=
operator|new
name|RowResolver
argument_list|()
decl_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|ExprNodeDesc
argument_list|>
name|columnExprMap
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|ExprNodeDesc
argument_list|>
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|colName
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|columns
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|String
name|name
init|=
name|getColumnInternalName
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|ColumnInfo
name|col
init|=
operator|new
name|ColumnInfo
argument_list|(
name|name
argument_list|,
name|columns
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|getTypeInfo
argument_list|()
argument_list|,
literal|""
argument_list|,
literal|false
argument_list|)
decl_stmt|;
name|rowResolver
operator|.
name|put
argument_list|(
name|origInputAlias
argument_list|,
name|name
argument_list|,
name|col
argument_list|)
expr_stmt|;
name|colName
operator|.
name|add
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|columnExprMap
operator|.
name|put
argument_list|(
name|name
argument_list|,
name|columns
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|Operator
argument_list|<
name|SelectDesc
argument_list|>
name|newInputOp
init|=
name|OperatorFactory
operator|.
name|getAndMakeChild
argument_list|(
operator|new
name|SelectDesc
argument_list|(
name|columns
argument_list|,
name|colName
argument_list|)
argument_list|,
operator|new
name|RowSchema
argument_list|(
name|rowResolver
operator|.
name|getColumnInfos
argument_list|()
argument_list|)
argument_list|,
name|columnExprMap
argument_list|,
name|origInputOp
argument_list|)
decl_stmt|;
return|return
name|putOpInsertMap
argument_list|(
name|newInputOp
argument_list|,
name|rowResolver
argument_list|)
return|;
block|}
comment|/**    * Generates the sampling predicate from the TABLESAMPLE clause information.    * This function uses the bucket column list to decide the expression inputs    * to the predicate hash function in case useBucketCols is set to true,    * otherwise the expression list stored in the TableSample is used. The bucket    * columns of the table are used to generate this predicate in case no    * expressions are provided on the TABLESAMPLE clause and the table has    * clustering columns defined in it's metadata. The predicate created has the    * following structure:    *    * ((hash(expressions)& Integer.MAX_VALUE) % denominator) == numerator    *    * @param ts    *          TABLESAMPLE clause information    * @param bucketCols    *          The clustering columns of the table    * @param useBucketCols    *          Flag to indicate whether the bucketCols should be used as input to    *          the hash function    * @param alias    *          The alias used for the table in the row resolver    * @param rwsch    *          The row resolver used to resolve column references    * @param qbm    *          The metadata information for the query block which is used to    *          resolve unaliased columns    * @param planExpr    *          The plan tree for the expression. If the user specified this, the    *          parse expressions are not used    * @return exprNodeDesc    * @exception SemanticException    */
specifier|private
name|ExprNodeDesc
name|genSamplePredicate
parameter_list|(
name|TableSample
name|ts
parameter_list|,
name|List
argument_list|<
name|String
argument_list|>
name|bucketCols
parameter_list|,
name|boolean
name|useBucketCols
parameter_list|,
name|String
name|alias
parameter_list|,
name|RowResolver
name|rwsch
parameter_list|,
name|QBMetaData
name|qbm
parameter_list|,
name|ExprNodeDesc
name|planExpr
parameter_list|)
throws|throws
name|SemanticException
block|{
name|ExprNodeDesc
name|numeratorExpr
init|=
operator|new
name|ExprNodeConstantDesc
argument_list|(
name|TypeInfoFactory
operator|.
name|intTypeInfo
argument_list|,
name|Integer
operator|.
name|valueOf
argument_list|(
name|ts
operator|.
name|getNumerator
argument_list|()
operator|-
literal|1
argument_list|)
argument_list|)
decl_stmt|;
name|ExprNodeDesc
name|denominatorExpr
init|=
operator|new
name|ExprNodeConstantDesc
argument_list|(
name|TypeInfoFactory
operator|.
name|intTypeInfo
argument_list|,
name|Integer
operator|.
name|valueOf
argument_list|(
name|ts
operator|.
name|getDenominator
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
name|ExprNodeDesc
name|intMaxExpr
init|=
operator|new
name|ExprNodeConstantDesc
argument_list|(
name|TypeInfoFactory
operator|.
name|intTypeInfo
argument_list|,
name|Integer
operator|.
name|valueOf
argument_list|(
name|Integer
operator|.
name|MAX_VALUE
argument_list|)
argument_list|)
decl_stmt|;
name|ArrayList
argument_list|<
name|ExprNodeDesc
argument_list|>
name|args
init|=
operator|new
name|ArrayList
argument_list|<
name|ExprNodeDesc
argument_list|>
argument_list|()
decl_stmt|;
if|if
condition|(
name|planExpr
operator|!=
literal|null
condition|)
block|{
name|args
operator|.
name|add
argument_list|(
name|planExpr
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|useBucketCols
condition|)
block|{
for|for
control|(
name|String
name|col
range|:
name|bucketCols
control|)
block|{
name|ColumnInfo
name|ci
init|=
name|rwsch
operator|.
name|get
argument_list|(
name|alias
argument_list|,
name|col
argument_list|)
decl_stmt|;
comment|// TODO: change type to the one in the table schema
name|args
operator|.
name|add
argument_list|(
operator|new
name|ExprNodeColumnDesc
argument_list|(
name|ci
operator|.
name|getType
argument_list|()
argument_list|,
name|ci
operator|.
name|getInternalName
argument_list|()
argument_list|,
name|ci
operator|.
name|getTabAlias
argument_list|()
argument_list|,
name|ci
operator|.
name|getIsVirtualCol
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
for|for
control|(
name|ASTNode
name|expr
range|:
name|ts
operator|.
name|getExprs
argument_list|()
control|)
block|{
name|args
operator|.
name|add
argument_list|(
name|genExprNodeDesc
argument_list|(
name|expr
argument_list|,
name|rwsch
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|ExprNodeDesc
name|equalsExpr
init|=
literal|null
decl_stmt|;
block|{
name|ExprNodeDesc
name|hashfnExpr
init|=
operator|new
name|ExprNodeGenericFuncDesc
argument_list|(
name|TypeInfoFactory
operator|.
name|intTypeInfo
argument_list|,
operator|new
name|GenericUDFHash
argument_list|()
argument_list|,
name|args
argument_list|)
decl_stmt|;
assert|assert
operator|(
name|hashfnExpr
operator|!=
literal|null
operator|)
assert|;
name|LOG
operator|.
name|info
argument_list|(
literal|"hashfnExpr = "
operator|+
name|hashfnExpr
argument_list|)
expr_stmt|;
name|ExprNodeDesc
name|andExpr
init|=
name|TypeCheckProcFactory
operator|.
name|DefaultExprProcessor
operator|.
name|getFuncExprNodeDesc
argument_list|(
literal|"&"
argument_list|,
name|hashfnExpr
argument_list|,
name|intMaxExpr
argument_list|)
decl_stmt|;
assert|assert
operator|(
name|andExpr
operator|!=
literal|null
operator|)
assert|;
name|LOG
operator|.
name|info
argument_list|(
literal|"andExpr = "
operator|+
name|andExpr
argument_list|)
expr_stmt|;
name|ExprNodeDesc
name|modExpr
init|=
name|TypeCheckProcFactory
operator|.
name|DefaultExprProcessor
operator|.
name|getFuncExprNodeDesc
argument_list|(
literal|"%"
argument_list|,
name|andExpr
argument_list|,
name|denominatorExpr
argument_list|)
decl_stmt|;
assert|assert
operator|(
name|modExpr
operator|!=
literal|null
operator|)
assert|;
name|LOG
operator|.
name|info
argument_list|(
literal|"modExpr = "
operator|+
name|modExpr
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"numeratorExpr = "
operator|+
name|numeratorExpr
argument_list|)
expr_stmt|;
name|equalsExpr
operator|=
name|TypeCheckProcFactory
operator|.
name|DefaultExprProcessor
operator|.
name|getFuncExprNodeDesc
argument_list|(
literal|"=="
argument_list|,
name|modExpr
argument_list|,
name|numeratorExpr
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"equalsExpr = "
operator|+
name|equalsExpr
argument_list|)
expr_stmt|;
assert|assert
operator|(
name|equalsExpr
operator|!=
literal|null
operator|)
assert|;
block|}
return|return
name|equalsExpr
return|;
block|}
specifier|private
name|String
name|getAliasId
parameter_list|(
name|String
name|alias
parameter_list|,
name|QB
name|qb
parameter_list|)
block|{
return|return
operator|(
name|qb
operator|.
name|getId
argument_list|()
operator|==
literal|null
condition|?
name|alias
else|:
name|qb
operator|.
name|getId
argument_list|()
operator|+
literal|":"
operator|+
name|alias
operator|)
operator|.
name|toLowerCase
argument_list|()
return|;
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"nls"
argument_list|)
specifier|private
name|Operator
name|genTablePlan
parameter_list|(
name|String
name|alias
parameter_list|,
name|QB
name|qb
parameter_list|)
throws|throws
name|SemanticException
block|{
name|String
name|alias_id
init|=
name|getAliasId
argument_list|(
name|alias
argument_list|,
name|qb
argument_list|)
decl_stmt|;
name|Table
name|tab
init|=
name|qb
operator|.
name|getMetaData
argument_list|()
operator|.
name|getSrcForAlias
argument_list|(
name|alias
argument_list|)
decl_stmt|;
name|RowResolver
name|rwsch
decl_stmt|;
comment|// is the table already present
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
name|top
init|=
name|topOps
operator|.
name|get
argument_list|(
name|alias_id
argument_list|)
decl_stmt|;
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
name|dummySel
init|=
name|topSelOps
operator|.
name|get
argument_list|(
name|alias_id
argument_list|)
decl_stmt|;
if|if
condition|(
name|dummySel
operator|!=
literal|null
condition|)
block|{
name|top
operator|=
name|dummySel
expr_stmt|;
block|}
if|if
condition|(
name|top
operator|==
literal|null
condition|)
block|{
name|rwsch
operator|=
operator|new
name|RowResolver
argument_list|()
expr_stmt|;
try|try
block|{
name|StructObjectInspector
name|rowObjectInspector
init|=
operator|(
name|StructObjectInspector
operator|)
name|tab
operator|.
name|getDeserializer
argument_list|()
operator|.
name|getObjectInspector
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|?
extends|extends
name|StructField
argument_list|>
name|fields
init|=
name|rowObjectInspector
operator|.
name|getAllStructFieldRefs
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|fields
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
comment|/**            * if the column is a skewed column, use ColumnInfo accordingly            */
name|ColumnInfo
name|colInfo
init|=
operator|new
name|ColumnInfo
argument_list|(
name|fields
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|getFieldName
argument_list|()
argument_list|,
name|TypeInfoUtils
operator|.
name|getTypeInfoFromObjectInspector
argument_list|(
name|fields
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|getFieldObjectInspector
argument_list|()
argument_list|)
argument_list|,
name|alias
argument_list|,
literal|false
argument_list|)
decl_stmt|;
name|colInfo
operator|.
name|setSkewedCol
argument_list|(
operator|(
name|isSkewedCol
argument_list|(
name|alias
argument_list|,
name|qb
argument_list|,
name|fields
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|getFieldName
argument_list|()
argument_list|)
operator|)
condition|?
literal|true
else|:
literal|false
argument_list|)
expr_stmt|;
name|rwsch
operator|.
name|put
argument_list|(
name|alias
argument_list|,
name|fields
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|getFieldName
argument_list|()
argument_list|,
name|colInfo
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|SerDeException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
name|e
argument_list|)
throw|;
block|}
comment|// Hack!! - refactor once the metadata APIs with types are ready
comment|// Finally add the partitioning columns
for|for
control|(
name|FieldSchema
name|part_col
range|:
name|tab
operator|.
name|getPartCols
argument_list|()
control|)
block|{
name|LOG
operator|.
name|trace
argument_list|(
literal|"Adding partition col: "
operator|+
name|part_col
argument_list|)
expr_stmt|;
comment|// TODO: use the right type by calling part_col.getType() instead of
comment|// String.class. See HIVE-3059.
name|rwsch
operator|.
name|put
argument_list|(
name|alias
argument_list|,
name|part_col
operator|.
name|getName
argument_list|()
argument_list|,
operator|new
name|ColumnInfo
argument_list|(
name|part_col
operator|.
name|getName
argument_list|()
argument_list|,
name|TypeInfoFactory
operator|.
name|stringTypeInfo
argument_list|,
name|alias
argument_list|,
literal|true
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// put all virutal columns in RowResolver.
name|Iterator
argument_list|<
name|VirtualColumn
argument_list|>
name|vcs
init|=
name|VirtualColumn
operator|.
name|getRegistry
argument_list|(
name|conf
argument_list|)
operator|.
name|iterator
argument_list|()
decl_stmt|;
comment|// use a list for easy cumtomize
name|List
argument_list|<
name|VirtualColumn
argument_list|>
name|vcList
init|=
operator|new
name|ArrayList
argument_list|<
name|VirtualColumn
argument_list|>
argument_list|()
decl_stmt|;
while|while
condition|(
name|vcs
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|VirtualColumn
name|vc
init|=
name|vcs
operator|.
name|next
argument_list|()
decl_stmt|;
name|rwsch
operator|.
name|put
argument_list|(
name|alias
argument_list|,
name|vc
operator|.
name|getName
argument_list|()
argument_list|,
operator|new
name|ColumnInfo
argument_list|(
name|vc
operator|.
name|getName
argument_list|()
argument_list|,
name|vc
operator|.
name|getTypeInfo
argument_list|()
argument_list|,
name|alias
argument_list|,
literal|true
argument_list|,
name|vc
operator|.
name|getIsHidden
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|vcList
operator|.
name|add
argument_list|(
name|vc
argument_list|)
expr_stmt|;
block|}
comment|// Create the root of the operator tree
name|TableScanDesc
name|tsDesc
init|=
operator|new
name|TableScanDesc
argument_list|(
name|alias
argument_list|,
name|vcList
argument_list|)
decl_stmt|;
name|setupStats
argument_list|(
name|tsDesc
argument_list|,
name|qb
operator|.
name|getParseInfo
argument_list|()
argument_list|,
name|tab
argument_list|,
name|alias
argument_list|,
name|rwsch
argument_list|)
expr_stmt|;
name|SplitSample
name|sample
init|=
name|nameToSplitSample
operator|.
name|get
argument_list|(
name|alias_id
argument_list|)
decl_stmt|;
if|if
condition|(
name|sample
operator|!=
literal|null
operator|&&
name|sample
operator|.
name|getRowCount
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|tsDesc
operator|.
name|setRowLimit
argument_list|(
name|sample
operator|.
name|getRowCount
argument_list|()
argument_list|)
expr_stmt|;
name|nameToSplitSample
operator|.
name|remove
argument_list|(
name|alias_id
argument_list|)
expr_stmt|;
block|}
name|top
operator|=
name|putOpInsertMap
argument_list|(
name|OperatorFactory
operator|.
name|get
argument_list|(
name|tsDesc
argument_list|,
operator|new
name|RowSchema
argument_list|(
name|rwsch
operator|.
name|getColumnInfos
argument_list|()
argument_list|)
argument_list|)
argument_list|,
name|rwsch
argument_list|)
expr_stmt|;
comment|// Add this to the list of top operators - we always start from a table
comment|// scan
name|topOps
operator|.
name|put
argument_list|(
name|alias_id
argument_list|,
name|top
argument_list|)
expr_stmt|;
comment|// Add a mapping from the table scan operator to Table
name|topToTable
operator|.
name|put
argument_list|(
operator|(
name|TableScanOperator
operator|)
name|top
argument_list|,
name|tab
argument_list|)
expr_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|props
init|=
name|qb
operator|.
name|getTabPropsForAlias
argument_list|(
name|alias
argument_list|)
decl_stmt|;
if|if
condition|(
name|props
operator|!=
literal|null
condition|)
block|{
name|topToTableProps
operator|.
name|put
argument_list|(
operator|(
name|TableScanOperator
operator|)
name|top
argument_list|,
name|props
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|rwsch
operator|=
name|opParseCtx
operator|.
name|get
argument_list|(
name|top
argument_list|)
operator|.
name|getRowResolver
argument_list|()
expr_stmt|;
name|top
operator|.
name|setChildOperators
argument_list|(
literal|null
argument_list|)
expr_stmt|;
block|}
comment|// check if this table is sampled and needs more than input pruning
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
name|tableOp
init|=
name|top
decl_stmt|;
name|TableSample
name|ts
init|=
name|qb
operator|.
name|getParseInfo
argument_list|()
operator|.
name|getTabSample
argument_list|(
name|alias
argument_list|)
decl_stmt|;
if|if
condition|(
name|ts
operator|!=
literal|null
condition|)
block|{
name|int
name|num
init|=
name|ts
operator|.
name|getNumerator
argument_list|()
decl_stmt|;
name|int
name|den
init|=
name|ts
operator|.
name|getDenominator
argument_list|()
decl_stmt|;
name|ArrayList
argument_list|<
name|ASTNode
argument_list|>
name|sampleExprs
init|=
name|ts
operator|.
name|getExprs
argument_list|()
decl_stmt|;
comment|// TODO: Do the type checking of the expressions
name|List
argument_list|<
name|String
argument_list|>
name|tabBucketCols
init|=
name|tab
operator|.
name|getBucketCols
argument_list|()
decl_stmt|;
name|int
name|numBuckets
init|=
name|tab
operator|.
name|getNumBuckets
argument_list|()
decl_stmt|;
comment|// If there are no sample cols and no bucket cols then throw an error
if|if
condition|(
name|tabBucketCols
operator|.
name|size
argument_list|()
operator|==
literal|0
operator|&&
name|sampleExprs
operator|.
name|size
argument_list|()
operator|==
literal|0
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|NON_BUCKETED_TABLE
operator|.
name|getMsg
argument_list|()
operator|+
literal|" "
operator|+
name|tab
operator|.
name|getTableName
argument_list|()
argument_list|)
throw|;
block|}
if|if
condition|(
name|num
operator|>
name|den
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|BUCKETED_NUMERATOR_BIGGER_DENOMINATOR
operator|.
name|getMsg
argument_list|()
operator|+
literal|" "
operator|+
name|tab
operator|.
name|getTableName
argument_list|()
argument_list|)
throw|;
block|}
comment|// check if a predicate is needed
comment|// predicate is needed if either input pruning is not enough
comment|// or if input pruning is not possible
comment|// check if the sample columns are the same as the table bucket columns
name|boolean
name|colsEqual
init|=
literal|true
decl_stmt|;
if|if
condition|(
operator|(
name|sampleExprs
operator|.
name|size
argument_list|()
operator|!=
name|tabBucketCols
operator|.
name|size
argument_list|()
operator|)
operator|&&
operator|(
name|sampleExprs
operator|.
name|size
argument_list|()
operator|!=
literal|0
operator|)
condition|)
block|{
name|colsEqual
operator|=
literal|false
expr_stmt|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|sampleExprs
operator|.
name|size
argument_list|()
operator|&&
name|colsEqual
condition|;
name|i
operator|++
control|)
block|{
name|boolean
name|colFound
init|=
literal|false
decl_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|tabBucketCols
operator|.
name|size
argument_list|()
operator|&&
operator|!
name|colFound
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|sampleExprs
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|getToken
argument_list|()
operator|.
name|getType
argument_list|()
operator|!=
name|HiveParser
operator|.
name|TOK_TABLE_OR_COL
condition|)
block|{
break|break;
block|}
if|if
condition|(
operator|(
operator|(
name|ASTNode
operator|)
name|sampleExprs
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|)
operator|.
name|getText
argument_list|()
operator|.
name|equalsIgnoreCase
argument_list|(
name|tabBucketCols
operator|.
name|get
argument_list|(
name|j
argument_list|)
argument_list|)
condition|)
block|{
name|colFound
operator|=
literal|true
expr_stmt|;
block|}
block|}
name|colsEqual
operator|=
operator|(
name|colsEqual
operator|&&
name|colFound
operator|)
expr_stmt|;
block|}
comment|// Check if input can be pruned
name|ts
operator|.
name|setInputPruning
argument_list|(
operator|(
name|sampleExprs
operator|==
literal|null
operator|||
name|sampleExprs
operator|.
name|size
argument_list|()
operator|==
literal|0
operator|||
name|colsEqual
operator|)
argument_list|)
expr_stmt|;
comment|// check if input pruning is enough
if|if
condition|(
operator|(
name|sampleExprs
operator|==
literal|null
operator|||
name|sampleExprs
operator|.
name|size
argument_list|()
operator|==
literal|0
operator|||
name|colsEqual
operator|)
operator|&&
operator|(
name|num
operator|==
name|den
operator|||
operator|(
name|den
operator|%
name|numBuckets
operator|==
literal|0
operator|||
name|numBuckets
operator|%
name|den
operator|==
literal|0
operator|)
operator|)
condition|)
block|{
comment|// input pruning is enough; add the filter for the optimizer to use it
comment|// later
name|LOG
operator|.
name|info
argument_list|(
literal|"No need for sample filter"
argument_list|)
expr_stmt|;
name|ExprNodeDesc
name|samplePredicate
init|=
name|genSamplePredicate
argument_list|(
name|ts
argument_list|,
name|tabBucketCols
argument_list|,
name|colsEqual
argument_list|,
name|alias
argument_list|,
name|rwsch
argument_list|,
name|qb
operator|.
name|getMetaData
argument_list|()
argument_list|,
literal|null
argument_list|)
decl_stmt|;
name|tableOp
operator|=
name|OperatorFactory
operator|.
name|getAndMakeChild
argument_list|(
operator|new
name|FilterDesc
argument_list|(
name|samplePredicate
argument_list|,
literal|true
argument_list|,
operator|new
name|sampleDesc
argument_list|(
name|ts
operator|.
name|getNumerator
argument_list|()
argument_list|,
name|ts
operator|.
name|getDenominator
argument_list|()
argument_list|,
name|tabBucketCols
argument_list|,
literal|true
argument_list|)
argument_list|)
argument_list|,
operator|new
name|RowSchema
argument_list|(
name|rwsch
operator|.
name|getColumnInfos
argument_list|()
argument_list|)
argument_list|,
name|top
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// need to add filter
comment|// create tableOp to be filterDesc and set as child to 'top'
name|LOG
operator|.
name|info
argument_list|(
literal|"Need sample filter"
argument_list|)
expr_stmt|;
name|ExprNodeDesc
name|samplePredicate
init|=
name|genSamplePredicate
argument_list|(
name|ts
argument_list|,
name|tabBucketCols
argument_list|,
name|colsEqual
argument_list|,
name|alias
argument_list|,
name|rwsch
argument_list|,
name|qb
operator|.
name|getMetaData
argument_list|()
argument_list|,
literal|null
argument_list|)
decl_stmt|;
name|tableOp
operator|=
name|OperatorFactory
operator|.
name|getAndMakeChild
argument_list|(
operator|new
name|FilterDesc
argument_list|(
name|samplePredicate
argument_list|,
literal|true
argument_list|)
argument_list|,
operator|new
name|RowSchema
argument_list|(
name|rwsch
operator|.
name|getColumnInfos
argument_list|()
argument_list|)
argument_list|,
name|top
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|boolean
name|testMode
init|=
name|conf
operator|.
name|getBoolVar
argument_list|(
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVETESTMODE
argument_list|)
decl_stmt|;
if|if
condition|(
name|testMode
condition|)
block|{
name|String
name|tabName
init|=
name|tab
operator|.
name|getTableName
argument_list|()
decl_stmt|;
comment|// has the user explicitly asked not to sample this table
name|String
name|unSampleTblList
init|=
name|conf
operator|.
name|getVar
argument_list|(
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVETESTMODENOSAMPLE
argument_list|)
decl_stmt|;
name|String
index|[]
name|unSampleTbls
init|=
name|unSampleTblList
operator|.
name|split
argument_list|(
literal|","
argument_list|)
decl_stmt|;
name|boolean
name|unsample
init|=
literal|false
decl_stmt|;
for|for
control|(
name|String
name|unSampleTbl
range|:
name|unSampleTbls
control|)
block|{
if|if
condition|(
name|tabName
operator|.
name|equalsIgnoreCase
argument_list|(
name|unSampleTbl
argument_list|)
condition|)
block|{
name|unsample
operator|=
literal|true
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|unsample
condition|)
block|{
name|int
name|numBuckets
init|=
name|tab
operator|.
name|getNumBuckets
argument_list|()
decl_stmt|;
comment|// If the input table is bucketed, choose the first bucket
if|if
condition|(
name|numBuckets
operator|>
literal|0
condition|)
block|{
name|TableSample
name|tsSample
init|=
operator|new
name|TableSample
argument_list|(
literal|1
argument_list|,
name|numBuckets
argument_list|)
decl_stmt|;
name|tsSample
operator|.
name|setInputPruning
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|qb
operator|.
name|getParseInfo
argument_list|()
operator|.
name|setTabSample
argument_list|(
name|alias
argument_list|,
name|tsSample
argument_list|)
expr_stmt|;
name|ExprNodeDesc
name|samplePred
init|=
name|genSamplePredicate
argument_list|(
name|tsSample
argument_list|,
name|tab
operator|.
name|getBucketCols
argument_list|()
argument_list|,
literal|true
argument_list|,
name|alias
argument_list|,
name|rwsch
argument_list|,
name|qb
operator|.
name|getMetaData
argument_list|()
argument_list|,
literal|null
argument_list|)
decl_stmt|;
name|tableOp
operator|=
name|OperatorFactory
operator|.
name|getAndMakeChild
argument_list|(
operator|new
name|FilterDesc
argument_list|(
name|samplePred
argument_list|,
literal|true
argument_list|,
operator|new
name|sampleDesc
argument_list|(
name|tsSample
operator|.
name|getNumerator
argument_list|()
argument_list|,
name|tsSample
operator|.
name|getDenominator
argument_list|()
argument_list|,
name|tab
operator|.
name|getBucketCols
argument_list|()
argument_list|,
literal|true
argument_list|)
argument_list|)
argument_list|,
operator|new
name|RowSchema
argument_list|(
name|rwsch
operator|.
name|getColumnInfos
argument_list|()
argument_list|)
argument_list|,
name|top
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"No need for sample filter"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// The table is not bucketed, add a dummy filter :: rand()
name|int
name|freq
init|=
name|conf
operator|.
name|getIntVar
argument_list|(
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVETESTMODESAMPLEFREQ
argument_list|)
decl_stmt|;
name|TableSample
name|tsSample
init|=
operator|new
name|TableSample
argument_list|(
literal|1
argument_list|,
name|freq
argument_list|)
decl_stmt|;
name|tsSample
operator|.
name|setInputPruning
argument_list|(
literal|false
argument_list|)
expr_stmt|;
name|qb
operator|.
name|getParseInfo
argument_list|()
operator|.
name|setTabSample
argument_list|(
name|alias
argument_list|,
name|tsSample
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Need sample filter"
argument_list|)
expr_stmt|;
name|ExprNodeDesc
name|randFunc
init|=
name|TypeCheckProcFactory
operator|.
name|DefaultExprProcessor
operator|.
name|getFuncExprNodeDesc
argument_list|(
literal|"rand"
argument_list|,
operator|new
name|ExprNodeConstantDesc
argument_list|(
name|Integer
operator|.
name|valueOf
argument_list|(
literal|460476415
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|ExprNodeDesc
name|samplePred
init|=
name|genSamplePredicate
argument_list|(
name|tsSample
argument_list|,
literal|null
argument_list|,
literal|false
argument_list|,
name|alias
argument_list|,
name|rwsch
argument_list|,
name|qb
operator|.
name|getMetaData
argument_list|()
argument_list|,
name|randFunc
argument_list|)
decl_stmt|;
name|tableOp
operator|=
name|OperatorFactory
operator|.
name|getAndMakeChild
argument_list|(
operator|new
name|FilterDesc
argument_list|(
name|samplePred
argument_list|,
literal|true
argument_list|)
argument_list|,
operator|new
name|RowSchema
argument_list|(
name|rwsch
operator|.
name|getColumnInfos
argument_list|()
argument_list|)
argument_list|,
name|top
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
name|Operator
name|output
init|=
name|putOpInsertMap
argument_list|(
name|tableOp
argument_list|,
name|rwsch
argument_list|)
decl_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Created Table Plan for "
operator|+
name|alias
operator|+
literal|" "
operator|+
name|tableOp
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|output
return|;
block|}
specifier|private
name|boolean
name|isSkewedCol
parameter_list|(
name|String
name|alias
parameter_list|,
name|QB
name|qb
parameter_list|,
name|String
name|colName
parameter_list|)
block|{
name|boolean
name|isSkewedCol
init|=
literal|false
decl_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|skewedCols
init|=
name|qb
operator|.
name|getSkewedColumnNames
argument_list|(
name|alias
argument_list|)
decl_stmt|;
for|for
control|(
name|String
name|skewedCol
range|:
name|skewedCols
control|)
block|{
if|if
condition|(
name|skewedCol
operator|.
name|equalsIgnoreCase
argument_list|(
name|colName
argument_list|)
condition|)
block|{
name|isSkewedCol
operator|=
literal|true
expr_stmt|;
block|}
block|}
return|return
name|isSkewedCol
return|;
block|}
specifier|private
name|void
name|setupStats
parameter_list|(
name|TableScanDesc
name|tsDesc
parameter_list|,
name|QBParseInfo
name|qbp
parameter_list|,
name|Table
name|tab
parameter_list|,
name|String
name|alias
parameter_list|,
name|RowResolver
name|rwsch
parameter_list|)
throws|throws
name|SemanticException
block|{
if|if
condition|(
operator|!
name|qbp
operator|.
name|isAnalyzeCommand
argument_list|()
condition|)
block|{
name|tsDesc
operator|.
name|setGatherStats
argument_list|(
literal|false
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|tsDesc
operator|.
name|setGatherStats
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|tsDesc
operator|.
name|setStatsReliable
argument_list|(
name|conf
operator|.
name|getBoolVar
argument_list|(
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVE_STATS_RELIABLE
argument_list|)
argument_list|)
expr_stmt|;
name|tsDesc
operator|.
name|setMaxStatsKeyPrefixLength
argument_list|(
name|StatsFactory
operator|.
name|getMaxPrefixLength
argument_list|(
name|conf
argument_list|)
argument_list|)
expr_stmt|;
comment|// append additional virtual columns for storing statistics
name|Iterator
argument_list|<
name|VirtualColumn
argument_list|>
name|vcs
init|=
name|VirtualColumn
operator|.
name|getStatsRegistry
argument_list|(
name|conf
argument_list|)
operator|.
name|iterator
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|VirtualColumn
argument_list|>
name|vcList
init|=
operator|new
name|ArrayList
argument_list|<
name|VirtualColumn
argument_list|>
argument_list|()
decl_stmt|;
while|while
condition|(
name|vcs
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|VirtualColumn
name|vc
init|=
name|vcs
operator|.
name|next
argument_list|()
decl_stmt|;
name|rwsch
operator|.
name|put
argument_list|(
name|alias
argument_list|,
name|vc
operator|.
name|getName
argument_list|()
argument_list|,
operator|new
name|ColumnInfo
argument_list|(
name|vc
operator|.
name|getName
argument_list|()
argument_list|,
name|vc
operator|.
name|getTypeInfo
argument_list|()
argument_list|,
name|alias
argument_list|,
literal|true
argument_list|,
name|vc
operator|.
name|getIsHidden
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|vcList
operator|.
name|add
argument_list|(
name|vc
argument_list|)
expr_stmt|;
block|}
name|tsDesc
operator|.
name|addVirtualCols
argument_list|(
name|vcList
argument_list|)
expr_stmt|;
name|String
name|tblName
init|=
name|tab
operator|.
name|getTableName
argument_list|()
decl_stmt|;
name|tableSpec
name|tblSpec
init|=
name|qbp
operator|.
name|getTableSpec
argument_list|(
name|alias
argument_list|)
decl_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|partSpec
init|=
name|tblSpec
operator|.
name|getPartSpec
argument_list|()
decl_stmt|;
if|if
condition|(
name|partSpec
operator|!=
literal|null
condition|)
block|{
name|List
argument_list|<
name|String
argument_list|>
name|cols
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
name|cols
operator|.
name|addAll
argument_list|(
name|partSpec
operator|.
name|keySet
argument_list|()
argument_list|)
expr_stmt|;
name|tsDesc
operator|.
name|setPartColumns
argument_list|(
name|cols
argument_list|)
expr_stmt|;
block|}
comment|// Theoretically the key prefix could be any unique string shared
comment|// between TableScanOperator (when publishing) and StatsTask (when aggregating).
comment|// Here we use
comment|// db_name.table_name + partitionSec
comment|// as the prefix for easy of read during explain and debugging.
comment|// Currently, partition spec can only be static partition.
name|String
name|k
init|=
name|tblName
operator|+
name|Path
operator|.
name|SEPARATOR
decl_stmt|;
name|tsDesc
operator|.
name|setStatsAggPrefix
argument_list|(
name|tab
operator|.
name|getDbName
argument_list|()
operator|+
literal|"."
operator|+
name|k
argument_list|)
expr_stmt|;
comment|// set up WritenEntity for replication
name|outputs
operator|.
name|add
argument_list|(
operator|new
name|WriteEntity
argument_list|(
name|tab
argument_list|)
argument_list|)
expr_stmt|;
comment|// add WriteEntity for each matching partition
if|if
condition|(
name|tab
operator|.
name|isPartitioned
argument_list|()
condition|)
block|{
if|if
condition|(
name|partSpec
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|NEED_PARTITION_SPECIFICATION
operator|.
name|getMsg
argument_list|()
argument_list|)
throw|;
block|}
name|List
argument_list|<
name|Partition
argument_list|>
name|partitions
init|=
name|qbp
operator|.
name|getTableSpec
argument_list|()
operator|.
name|partitions
decl_stmt|;
if|if
condition|(
name|partitions
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|Partition
name|partn
range|:
name|partitions
control|)
block|{
comment|// inputs.add(new ReadEntity(partn)); // is this needed at all?
name|outputs
operator|.
name|add
argument_list|(
operator|new
name|WriteEntity
argument_list|(
name|partn
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
specifier|private
name|Operator
name|genPlan
parameter_list|(
name|QBExpr
name|qbexpr
parameter_list|)
throws|throws
name|SemanticException
block|{
if|if
condition|(
name|qbexpr
operator|.
name|getOpcode
argument_list|()
operator|==
name|QBExpr
operator|.
name|Opcode
operator|.
name|NULLOP
condition|)
block|{
return|return
name|genPlan
argument_list|(
name|qbexpr
operator|.
name|getQB
argument_list|()
argument_list|)
return|;
block|}
if|if
condition|(
name|qbexpr
operator|.
name|getOpcode
argument_list|()
operator|==
name|QBExpr
operator|.
name|Opcode
operator|.
name|UNION
condition|)
block|{
name|Operator
name|qbexpr1Ops
init|=
name|genPlan
argument_list|(
name|qbexpr
operator|.
name|getQBExpr1
argument_list|()
argument_list|)
decl_stmt|;
name|Operator
name|qbexpr2Ops
init|=
name|genPlan
argument_list|(
name|qbexpr
operator|.
name|getQBExpr2
argument_list|()
argument_list|)
decl_stmt|;
return|return
name|genUnionPlan
argument_list|(
name|qbexpr
operator|.
name|getAlias
argument_list|()
argument_list|,
name|qbexpr
operator|.
name|getQBExpr1
argument_list|()
operator|.
name|getAlias
argument_list|()
argument_list|,
name|qbexpr1Ops
argument_list|,
name|qbexpr
operator|.
name|getQBExpr2
argument_list|()
operator|.
name|getAlias
argument_list|()
argument_list|,
name|qbexpr2Ops
argument_list|)
return|;
block|}
return|return
literal|null
return|;
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"nls"
argument_list|)
specifier|public
name|Operator
name|genPlan
parameter_list|(
name|QB
name|qb
parameter_list|)
throws|throws
name|SemanticException
block|{
comment|// First generate all the opInfos for the elements in the from clause
name|Map
argument_list|<
name|String
argument_list|,
name|Operator
argument_list|>
name|aliasToOpInfo
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|Operator
argument_list|>
argument_list|()
decl_stmt|;
comment|// Recurse over the subqueries to fill the subquery part of the plan
for|for
control|(
name|String
name|alias
range|:
name|qb
operator|.
name|getSubqAliases
argument_list|()
control|)
block|{
name|QBExpr
name|qbexpr
init|=
name|qb
operator|.
name|getSubqForAlias
argument_list|(
name|alias
argument_list|)
decl_stmt|;
name|aliasToOpInfo
operator|.
name|put
argument_list|(
name|alias
argument_list|,
name|genPlan
argument_list|(
name|qbexpr
argument_list|)
argument_list|)
expr_stmt|;
name|qbexpr
operator|.
name|setAlias
argument_list|(
name|alias
argument_list|)
expr_stmt|;
block|}
comment|// Recurse over all the source tables
for|for
control|(
name|String
name|alias
range|:
name|qb
operator|.
name|getTabAliases
argument_list|()
control|)
block|{
name|Operator
name|op
init|=
name|genTablePlan
argument_list|(
name|alias
argument_list|,
name|qb
argument_list|)
decl_stmt|;
name|aliasToOpInfo
operator|.
name|put
argument_list|(
name|alias
argument_list|,
name|op
argument_list|)
expr_stmt|;
block|}
name|Operator
name|srcOpInfo
init|=
literal|null
decl_stmt|;
name|Operator
name|lastPTFOp
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|queryProperties
operator|.
name|hasPTF
argument_list|()
condition|)
block|{
comment|//After processing subqueries and source tables, process
comment|// partitioned table functions
name|HashMap
argument_list|<
name|ASTNode
argument_list|,
name|PTFInvocationSpec
argument_list|>
name|ptfNodeToSpec
init|=
name|qb
operator|.
name|getPTFNodeToSpec
argument_list|()
decl_stmt|;
if|if
condition|(
name|ptfNodeToSpec
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|Entry
argument_list|<
name|ASTNode
argument_list|,
name|PTFInvocationSpec
argument_list|>
name|entry
range|:
name|ptfNodeToSpec
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|ASTNode
name|ast
init|=
name|entry
operator|.
name|getKey
argument_list|()
decl_stmt|;
name|PTFInvocationSpec
name|spec
init|=
name|entry
operator|.
name|getValue
argument_list|()
decl_stmt|;
name|String
name|inputAlias
init|=
name|spec
operator|.
name|getQueryInputName
argument_list|()
decl_stmt|;
name|Operator
name|inOp
init|=
name|aliasToOpInfo
operator|.
name|get
argument_list|(
name|inputAlias
argument_list|)
decl_stmt|;
if|if
condition|(
name|inOp
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|generateErrorMessage
argument_list|(
name|ast
argument_list|,
literal|"Cannot resolve input Operator for PTF invocation"
argument_list|)
argument_list|)
throw|;
block|}
name|lastPTFOp
operator|=
name|genPTFPlan
argument_list|(
name|spec
argument_list|,
name|inOp
argument_list|)
expr_stmt|;
name|String
name|ptfAlias
init|=
operator|(
operator|(
name|PartitionedTableFunctionSpec
operator|)
name|spec
operator|.
name|getFunction
argument_list|()
operator|)
operator|.
name|getAlias
argument_list|()
decl_stmt|;
if|if
condition|(
name|ptfAlias
operator|!=
literal|null
condition|)
block|{
name|aliasToOpInfo
operator|.
name|put
argument_list|(
name|ptfAlias
argument_list|,
name|lastPTFOp
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
comment|// For all the source tables that have a lateral view, attach the
comment|// appropriate operators to the TS
name|genLateralViewPlans
argument_list|(
name|aliasToOpInfo
argument_list|,
name|qb
argument_list|)
expr_stmt|;
comment|// process join
if|if
condition|(
name|qb
operator|.
name|getParseInfo
argument_list|()
operator|.
name|getJoinExpr
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|ASTNode
name|joinExpr
init|=
name|qb
operator|.
name|getParseInfo
argument_list|()
operator|.
name|getJoinExpr
argument_list|()
decl_stmt|;
if|if
condition|(
name|joinExpr
operator|.
name|getToken
argument_list|()
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_UNIQUEJOIN
condition|)
block|{
name|QBJoinTree
name|joinTree
init|=
name|genUniqueJoinTree
argument_list|(
name|qb
argument_list|,
name|joinExpr
argument_list|,
name|aliasToOpInfo
argument_list|)
decl_stmt|;
name|qb
operator|.
name|setQbJoinTree
argument_list|(
name|joinTree
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|QBJoinTree
name|joinTree
init|=
name|genJoinTree
argument_list|(
name|qb
argument_list|,
name|joinExpr
argument_list|,
name|aliasToOpInfo
argument_list|)
decl_stmt|;
name|qb
operator|.
name|setQbJoinTree
argument_list|(
name|joinTree
argument_list|)
expr_stmt|;
comment|/*          * if there is only one destintaion in Query try to push where predicates          * as Join conditions          */
name|Set
argument_list|<
name|String
argument_list|>
name|dests
init|=
name|qb
operator|.
name|getParseInfo
argument_list|()
operator|.
name|getClauseNames
argument_list|()
decl_stmt|;
if|if
condition|(
name|dests
operator|.
name|size
argument_list|()
operator|==
literal|1
condition|)
block|{
name|String
name|dest
init|=
name|dests
operator|.
name|iterator
argument_list|()
operator|.
name|next
argument_list|()
decl_stmt|;
name|ASTNode
name|whereClause
init|=
name|qb
operator|.
name|getParseInfo
argument_list|()
operator|.
name|getWhrForClause
argument_list|(
name|dest
argument_list|)
decl_stmt|;
if|if
condition|(
name|whereClause
operator|!=
literal|null
condition|)
block|{
name|extractJoinCondsFromWhereClause
argument_list|(
name|joinTree
argument_list|,
name|qb
argument_list|,
name|dest
argument_list|,
operator|(
name|ASTNode
operator|)
name|whereClause
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|mergeJoinTree
argument_list|(
name|qb
argument_list|)
expr_stmt|;
block|}
comment|// if any filters are present in the join tree, push them on top of the
comment|// table
name|pushJoinFilters
argument_list|(
name|qb
argument_list|,
name|qb
operator|.
name|getQbJoinTree
argument_list|()
argument_list|,
name|aliasToOpInfo
argument_list|)
expr_stmt|;
name|srcOpInfo
operator|=
name|genJoinPlan
argument_list|(
name|qb
argument_list|,
name|aliasToOpInfo
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// Now if there are more than 1 sources then we have a join case
comment|// later we can extend this to the union all case as well
name|srcOpInfo
operator|=
name|aliasToOpInfo
operator|.
name|values
argument_list|()
operator|.
name|iterator
argument_list|()
operator|.
name|next
argument_list|()
expr_stmt|;
comment|// with ptfs, there maybe more (note for PTFChains:
comment|// 1 ptf invocation may entail multiple PTF operators)
name|srcOpInfo
operator|=
name|lastPTFOp
operator|!=
literal|null
condition|?
name|lastPTFOp
else|:
name|srcOpInfo
expr_stmt|;
block|}
name|Operator
name|bodyOpInfo
init|=
name|genBodyPlan
argument_list|(
name|qb
argument_list|,
name|srcOpInfo
argument_list|,
name|aliasToOpInfo
argument_list|)
decl_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Created Plan for Query Block "
operator|+
name|qb
operator|.
name|getId
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|this
operator|.
name|qb
operator|=
name|qb
expr_stmt|;
return|return
name|bodyOpInfo
return|;
block|}
comment|/**    * Generates the operator DAG needed to implement lateral views and attaches    * it to the TS operator.    *    * @param aliasToOpInfo    *          A mapping from a table alias to the TS operator. This function    *          replaces the operator mapping as necessary    * @param qb    * @throws SemanticException    */
name|void
name|genLateralViewPlans
parameter_list|(
name|Map
argument_list|<
name|String
argument_list|,
name|Operator
argument_list|>
name|aliasToOpInfo
parameter_list|,
name|QB
name|qb
parameter_list|)
throws|throws
name|SemanticException
block|{
name|Map
argument_list|<
name|String
argument_list|,
name|ArrayList
argument_list|<
name|ASTNode
argument_list|>
argument_list|>
name|aliasToLateralViews
init|=
name|qb
operator|.
name|getParseInfo
argument_list|()
operator|.
name|getAliasToLateralViews
argument_list|()
decl_stmt|;
for|for
control|(
name|Entry
argument_list|<
name|String
argument_list|,
name|Operator
argument_list|>
name|e
range|:
name|aliasToOpInfo
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|String
name|alias
init|=
name|e
operator|.
name|getKey
argument_list|()
decl_stmt|;
comment|// See if the alias has a lateral view. If so, chain the lateral view
comment|// operator on
name|ArrayList
argument_list|<
name|ASTNode
argument_list|>
name|lateralViews
init|=
name|aliasToLateralViews
operator|.
name|get
argument_list|(
name|alias
argument_list|)
decl_stmt|;
if|if
condition|(
name|lateralViews
operator|!=
literal|null
condition|)
block|{
name|Operator
name|op
init|=
name|e
operator|.
name|getValue
argument_list|()
decl_stmt|;
for|for
control|(
name|ASTNode
name|lateralViewTree
range|:
name|aliasToLateralViews
operator|.
name|get
argument_list|(
name|alias
argument_list|)
control|)
block|{
comment|// There are 2 paths from the TS operator (or a previous LVJ operator)
comment|// to the same LateralViewJoinOperator.
comment|// TS -> SelectOperator(*) -> LateralViewJoinOperator
comment|// TS -> SelectOperator (gets cols for UDTF) -> UDTFOperator0
comment|// -> LateralViewJoinOperator
comment|//
name|Operator
name|lateralViewJoin
init|=
name|genLateralViewPlan
argument_list|(
name|qb
argument_list|,
name|op
argument_list|,
name|lateralViewTree
argument_list|)
decl_stmt|;
name|op
operator|=
name|lateralViewJoin
expr_stmt|;
block|}
name|e
operator|.
name|setValue
argument_list|(
name|op
argument_list|)
expr_stmt|;
block|}
block|}
block|}
specifier|private
name|Operator
name|genLateralViewPlanForDest
parameter_list|(
name|String
name|dest
parameter_list|,
name|QB
name|qb
parameter_list|,
name|Operator
name|op
parameter_list|)
throws|throws
name|SemanticException
block|{
name|ASTNode
name|lateralViewTree
init|=
name|qb
operator|.
name|getParseInfo
argument_list|()
operator|.
name|getDestToLateralView
argument_list|()
operator|.
name|get
argument_list|(
name|dest
argument_list|)
decl_stmt|;
if|if
condition|(
name|lateralViewTree
operator|!=
literal|null
condition|)
block|{
return|return
name|genLateralViewPlan
argument_list|(
name|qb
argument_list|,
name|op
argument_list|,
name|lateralViewTree
argument_list|)
return|;
block|}
return|return
name|op
return|;
block|}
specifier|private
name|Operator
name|genLateralViewPlan
parameter_list|(
name|QB
name|qb
parameter_list|,
name|Operator
name|op
parameter_list|,
name|ASTNode
name|lateralViewTree
parameter_list|)
throws|throws
name|SemanticException
block|{
name|RowResolver
name|lvForwardRR
init|=
operator|new
name|RowResolver
argument_list|()
decl_stmt|;
name|RowResolver
name|source
init|=
name|opParseCtx
operator|.
name|get
argument_list|(
name|op
argument_list|)
operator|.
name|getRowResolver
argument_list|()
decl_stmt|;
for|for
control|(
name|ColumnInfo
name|col
range|:
name|source
operator|.
name|getColumnInfos
argument_list|()
control|)
block|{
name|String
index|[]
name|tabCol
init|=
name|source
operator|.
name|reverseLookup
argument_list|(
name|col
operator|.
name|getInternalName
argument_list|()
argument_list|)
decl_stmt|;
name|lvForwardRR
operator|.
name|put
argument_list|(
name|tabCol
index|[
literal|0
index|]
argument_list|,
name|tabCol
index|[
literal|1
index|]
argument_list|,
name|col
argument_list|)
expr_stmt|;
block|}
name|Operator
name|lvForward
init|=
name|putOpInsertMap
argument_list|(
name|OperatorFactory
operator|.
name|getAndMakeChild
argument_list|(
operator|new
name|LateralViewForwardDesc
argument_list|()
argument_list|,
operator|new
name|RowSchema
argument_list|(
name|lvForwardRR
operator|.
name|getColumnInfos
argument_list|()
argument_list|)
argument_list|,
name|op
argument_list|)
argument_list|,
name|lvForwardRR
argument_list|)
decl_stmt|;
comment|// The order in which the two paths are added is important. The
comment|// lateral view join operator depends on having the select operator
comment|// give it the row first.
comment|// Get the all path by making a select(*).
name|RowResolver
name|allPathRR
init|=
name|opParseCtx
operator|.
name|get
argument_list|(
name|lvForward
argument_list|)
operator|.
name|getRowResolver
argument_list|()
decl_stmt|;
comment|// Operator allPath = op;
name|Operator
name|allPath
init|=
name|putOpInsertMap
argument_list|(
name|OperatorFactory
operator|.
name|getAndMakeChild
argument_list|(
operator|new
name|SelectDesc
argument_list|(
literal|true
argument_list|)
argument_list|,
operator|new
name|RowSchema
argument_list|(
name|allPathRR
operator|.
name|getColumnInfos
argument_list|()
argument_list|)
argument_list|,
name|lvForward
argument_list|)
argument_list|,
name|allPathRR
argument_list|)
decl_stmt|;
comment|// Get the UDTF Path
name|QB
name|blankQb
init|=
operator|new
name|QB
argument_list|(
literal|null
argument_list|,
literal|null
argument_list|,
literal|false
argument_list|)
decl_stmt|;
name|Operator
name|udtfPath
init|=
name|genSelectPlan
argument_list|(
operator|(
name|ASTNode
operator|)
name|lateralViewTree
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
argument_list|,
name|blankQb
argument_list|,
name|lvForward
argument_list|,
name|lateralViewTree
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_LATERAL_VIEW_OUTER
argument_list|)
decl_stmt|;
comment|// add udtf aliases to QB
for|for
control|(
name|String
name|udtfAlias
range|:
name|blankQb
operator|.
name|getAliases
argument_list|()
control|)
block|{
name|qb
operator|.
name|addAlias
argument_list|(
name|udtfAlias
argument_list|)
expr_stmt|;
block|}
name|RowResolver
name|udtfPathRR
init|=
name|opParseCtx
operator|.
name|get
argument_list|(
name|udtfPath
argument_list|)
operator|.
name|getRowResolver
argument_list|()
decl_stmt|;
comment|// Merge the two into the lateral view join
comment|// The cols of the merged result will be the combination of both the
comment|// cols of the UDTF path and the cols of the all path. The internal
comment|// names have to be changed to avoid conflicts
name|RowResolver
name|lateralViewRR
init|=
operator|new
name|RowResolver
argument_list|()
decl_stmt|;
name|ArrayList
argument_list|<
name|String
argument_list|>
name|outputInternalColNames
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
name|LVmergeRowResolvers
argument_list|(
name|allPathRR
argument_list|,
name|lateralViewRR
argument_list|,
name|outputInternalColNames
argument_list|)
expr_stmt|;
name|LVmergeRowResolvers
argument_list|(
name|udtfPathRR
argument_list|,
name|lateralViewRR
argument_list|,
name|outputInternalColNames
argument_list|)
expr_stmt|;
comment|// For PPD, we need a column to expression map so that during the walk,
comment|// the processor knows how to transform the internal col names.
comment|// Following steps are dependant on the fact that we called
comment|// LVmerge.. in the above order
name|Map
argument_list|<
name|String
argument_list|,
name|ExprNodeDesc
argument_list|>
name|colExprMap
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|ExprNodeDesc
argument_list|>
argument_list|()
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
for|for
control|(
name|ColumnInfo
name|c
range|:
name|allPathRR
operator|.
name|getColumnInfos
argument_list|()
control|)
block|{
name|String
name|internalName
init|=
name|getColumnInternalName
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|i
operator|++
expr_stmt|;
name|colExprMap
operator|.
name|put
argument_list|(
name|internalName
argument_list|,
operator|new
name|ExprNodeColumnDesc
argument_list|(
name|c
operator|.
name|getType
argument_list|()
argument_list|,
name|c
operator|.
name|getInternalName
argument_list|()
argument_list|,
name|c
operator|.
name|getTabAlias
argument_list|()
argument_list|,
name|c
operator|.
name|getIsVirtualCol
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|Operator
name|lateralViewJoin
init|=
name|putOpInsertMap
argument_list|(
name|OperatorFactory
operator|.
name|getAndMakeChild
argument_list|(
operator|new
name|LateralViewJoinDesc
argument_list|(
name|outputInternalColNames
argument_list|)
argument_list|,
operator|new
name|RowSchema
argument_list|(
name|lateralViewRR
operator|.
name|getColumnInfos
argument_list|()
argument_list|)
argument_list|,
name|allPath
argument_list|,
name|udtfPath
argument_list|)
argument_list|,
name|lateralViewRR
argument_list|)
decl_stmt|;
name|lateralViewJoin
operator|.
name|setColumnExprMap
argument_list|(
name|colExprMap
argument_list|)
expr_stmt|;
return|return
name|lateralViewJoin
return|;
block|}
comment|/**    * A helper function that gets all the columns and respective aliases in the    * source and puts them into dest. It renames the internal names of the    * columns based on getColumnInternalName(position).    *    * Note that this helper method relies on RowResolver.getColumnInfos()    * returning the columns in the same order as they will be passed in the    * operator DAG.    *    * @param source    * @param dest    * @param outputColNames    *          - a list to which the new internal column names will be added, in    *          the same order as in the dest row resolver    */
specifier|private
name|void
name|LVmergeRowResolvers
parameter_list|(
name|RowResolver
name|source
parameter_list|,
name|RowResolver
name|dest
parameter_list|,
name|ArrayList
argument_list|<
name|String
argument_list|>
name|outputInternalColNames
parameter_list|)
block|{
for|for
control|(
name|ColumnInfo
name|c
range|:
name|source
operator|.
name|getColumnInfos
argument_list|()
control|)
block|{
name|String
name|internalName
init|=
name|getColumnInternalName
argument_list|(
name|outputInternalColNames
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
name|outputInternalColNames
operator|.
name|add
argument_list|(
name|internalName
argument_list|)
expr_stmt|;
name|ColumnInfo
name|newCol
init|=
operator|new
name|ColumnInfo
argument_list|(
name|internalName
argument_list|,
name|c
operator|.
name|getType
argument_list|()
argument_list|,
name|c
operator|.
name|getTabAlias
argument_list|()
argument_list|,
name|c
operator|.
name|getIsVirtualCol
argument_list|()
argument_list|,
name|c
operator|.
name|isHiddenVirtualCol
argument_list|()
argument_list|)
decl_stmt|;
name|String
index|[]
name|tableCol
init|=
name|source
operator|.
name|reverseLookup
argument_list|(
name|c
operator|.
name|getInternalName
argument_list|()
argument_list|)
decl_stmt|;
name|String
name|tableAlias
init|=
name|tableCol
index|[
literal|0
index|]
decl_stmt|;
name|String
name|colAlias
init|=
name|tableCol
index|[
literal|1
index|]
decl_stmt|;
name|dest
operator|.
name|put
argument_list|(
name|tableAlias
argument_list|,
name|colAlias
argument_list|,
name|newCol
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"nls"
argument_list|)
specifier|public
name|Phase1Ctx
name|initPhase1Ctx
parameter_list|()
block|{
name|Phase1Ctx
name|ctx_1
init|=
operator|new
name|Phase1Ctx
argument_list|()
decl_stmt|;
name|ctx_1
operator|.
name|nextNum
operator|=
literal|0
expr_stmt|;
name|ctx_1
operator|.
name|dest
operator|=
literal|"reduce"
expr_stmt|;
return|return
name|ctx_1
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|init
parameter_list|()
block|{
comment|// clear most members
name|reset
argument_list|()
expr_stmt|;
comment|// init
name|QB
name|qb
init|=
operator|new
name|QB
argument_list|(
literal|null
argument_list|,
literal|null
argument_list|,
literal|false
argument_list|)
decl_stmt|;
name|this
operator|.
name|qb
operator|=
name|qb
expr_stmt|;
block|}
annotation|@
name|Override
annotation|@
name|SuppressWarnings
argument_list|(
literal|"nls"
argument_list|)
specifier|public
name|void
name|analyzeInternal
parameter_list|(
name|ASTNode
name|ast
parameter_list|)
throws|throws
name|SemanticException
block|{
name|ASTNode
name|child
init|=
name|ast
decl_stmt|;
name|this
operator|.
name|ast
operator|=
name|ast
expr_stmt|;
name|viewsExpanded
operator|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Starting Semantic Analysis"
argument_list|)
expr_stmt|;
comment|// analyze and process the position alias
name|processPositionAlias
argument_list|(
name|ast
argument_list|)
expr_stmt|;
comment|// analyze create table command
if|if
condition|(
name|ast
operator|.
name|getToken
argument_list|()
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_CREATETABLE
condition|)
block|{
comment|// if it is not CTAS, we don't need to go further and just return
if|if
condition|(
operator|(
name|child
operator|=
name|analyzeCreateTable
argument_list|(
name|ast
argument_list|,
name|qb
argument_list|)
operator|)
operator|==
literal|null
condition|)
block|{
return|return;
block|}
block|}
else|else
block|{
name|SessionState
operator|.
name|get
argument_list|()
operator|.
name|setCommandType
argument_list|(
name|HiveOperation
operator|.
name|QUERY
argument_list|)
expr_stmt|;
block|}
comment|// analyze create view command
if|if
condition|(
name|ast
operator|.
name|getToken
argument_list|()
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_CREATEVIEW
operator|||
name|ast
operator|.
name|getToken
argument_list|()
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_ALTERVIEW_AS
condition|)
block|{
name|child
operator|=
name|analyzeCreateView
argument_list|(
name|ast
argument_list|,
name|qb
argument_list|)
expr_stmt|;
name|SessionState
operator|.
name|get
argument_list|()
operator|.
name|setCommandType
argument_list|(
name|HiveOperation
operator|.
name|CREATEVIEW
argument_list|)
expr_stmt|;
if|if
condition|(
name|child
operator|==
literal|null
condition|)
block|{
return|return;
block|}
name|viewSelect
operator|=
name|child
expr_stmt|;
comment|// prevent view from referencing itself
name|viewsExpanded
operator|.
name|add
argument_list|(
name|SessionState
operator|.
name|get
argument_list|()
operator|.
name|getCurrentDatabase
argument_list|()
operator|+
literal|"."
operator|+
name|createVwDesc
operator|.
name|getViewName
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// continue analyzing from the child ASTNode.
name|Phase1Ctx
name|ctx_1
init|=
name|initPhase1Ctx
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|doPhase1
argument_list|(
name|child
argument_list|,
name|qb
argument_list|,
name|ctx_1
argument_list|)
condition|)
block|{
comment|// if phase1Result false return
return|return;
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"Completed phase 1 of Semantic Analysis"
argument_list|)
expr_stmt|;
name|getMetaData
argument_list|(
name|qb
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Completed getting MetaData in Semantic Analysis"
argument_list|)
expr_stmt|;
comment|// Save the result schema derived from the sink operator produced
comment|// by genPlan. This has the correct column names, which clients
comment|// such as JDBC would prefer instead of the c0, c1 we'll end
comment|// up with later.
name|Operator
name|sinkOp
init|=
name|genPlan
argument_list|(
name|qb
argument_list|)
decl_stmt|;
name|resultSchema
operator|=
name|convertRowSchemaToViewSchema
argument_list|(
name|opParseCtx
operator|.
name|get
argument_list|(
name|sinkOp
argument_list|)
operator|.
name|getRowResolver
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|createVwDesc
operator|!=
literal|null
condition|)
block|{
name|saveViewDefinition
argument_list|()
expr_stmt|;
comment|// validate the create view statement
comment|// at this point, the createVwDesc gets all the information for semantic check
name|validateCreateView
argument_list|(
name|createVwDesc
argument_list|)
expr_stmt|;
comment|// Since we're only creating a view (not executing it), we
comment|// don't need to optimize or translate the plan (and in fact, those
comment|// procedures can interfere with the view creation). So
comment|// skip the rest of this method.
name|ctx
operator|.
name|setResDir
argument_list|(
literal|null
argument_list|)
expr_stmt|;
name|ctx
operator|.
name|setResFile
argument_list|(
literal|null
argument_list|)
expr_stmt|;
return|return;
block|}
name|ParseContext
name|pCtx
init|=
operator|new
name|ParseContext
argument_list|(
name|conf
argument_list|,
name|qb
argument_list|,
name|child
argument_list|,
name|opToPartPruner
argument_list|,
name|opToPartList
argument_list|,
name|topOps
argument_list|,
name|topSelOps
argument_list|,
name|opParseCtx
argument_list|,
name|joinContext
argument_list|,
name|smbMapJoinContext
argument_list|,
name|topToTable
argument_list|,
name|topToTableProps
argument_list|,
name|fsopToTable
argument_list|,
name|loadTableWork
argument_list|,
name|loadFileWork
argument_list|,
name|ctx
argument_list|,
name|idToTableNameMap
argument_list|,
name|destTableId
argument_list|,
name|uCtx
argument_list|,
name|listMapJoinOpsNoReducer
argument_list|,
name|groupOpToInputTables
argument_list|,
name|prunedPartitions
argument_list|,
name|opToSamplePruner
argument_list|,
name|globalLimitCtx
argument_list|,
name|nameToSplitSample
argument_list|,
name|inputs
argument_list|,
name|rootTasks
argument_list|,
name|opToPartToSkewedPruner
argument_list|,
name|viewAliasToInput
argument_list|,
name|reduceSinkOperatorsAddedByEnforceBucketingSorting
argument_list|,
name|queryProperties
argument_list|)
decl_stmt|;
comment|// Generate table access stats if required
if|if
condition|(
name|HiveConf
operator|.
name|getBoolVar
argument_list|(
name|this
operator|.
name|conf
argument_list|,
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVE_STATS_COLLECT_TABLEKEYS
argument_list|)
operator|==
literal|true
condition|)
block|{
name|TableAccessAnalyzer
name|tableAccessAnalyzer
init|=
operator|new
name|TableAccessAnalyzer
argument_list|(
name|pCtx
argument_list|)
decl_stmt|;
name|setTableAccessInfo
argument_list|(
name|tableAccessAnalyzer
operator|.
name|analyzeTableAccess
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Before logical optimization\n"
operator|+
name|Operator
operator|.
name|toString
argument_list|(
name|pCtx
operator|.
name|getTopOps
argument_list|()
operator|.
name|values
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|Optimizer
name|optm
init|=
operator|new
name|Optimizer
argument_list|()
decl_stmt|;
name|optm
operator|.
name|setPctx
argument_list|(
name|pCtx
argument_list|)
expr_stmt|;
name|optm
operator|.
name|initialize
argument_list|(
name|conf
argument_list|)
expr_stmt|;
name|pCtx
operator|=
name|optm
operator|.
name|optimize
argument_list|()
expr_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"After logical optimization\n"
operator|+
name|Operator
operator|.
name|toString
argument_list|(
name|pCtx
operator|.
name|getTopOps
argument_list|()
operator|.
name|values
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// Generate column access stats if required - wait until column pruning takes place
comment|// during optimization
if|if
condition|(
name|HiveConf
operator|.
name|getBoolVar
argument_list|(
name|this
operator|.
name|conf
argument_list|,
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVE_STATS_COLLECT_SCANCOLS
argument_list|)
operator|==
literal|true
condition|)
block|{
name|ColumnAccessAnalyzer
name|columnAccessAnalyzer
init|=
operator|new
name|ColumnAccessAnalyzer
argument_list|(
name|pCtx
argument_list|)
decl_stmt|;
name|setColumnAccessInfo
argument_list|(
name|columnAccessAnalyzer
operator|.
name|analyzeColumnAccess
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|ctx
operator|.
name|getExplainLogical
argument_list|()
condition|)
block|{
comment|// At this point we have the complete operator tree
comment|// from which we want to create the map-reduce plan
name|TaskCompiler
name|compiler
init|=
name|TaskCompilerFactory
operator|.
name|getCompiler
argument_list|(
name|conf
argument_list|,
name|pCtx
argument_list|)
decl_stmt|;
name|compiler
operator|.
name|init
argument_list|(
name|conf
argument_list|,
name|console
argument_list|,
name|db
argument_list|)
expr_stmt|;
name|compiler
operator|.
name|compile
argument_list|(
name|pCtx
argument_list|,
name|rootTasks
argument_list|,
name|inputs
argument_list|,
name|outputs
argument_list|)
expr_stmt|;
name|fetchTask
operator|=
name|pCtx
operator|.
name|getFetchTask
argument_list|()
expr_stmt|;
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"Completed plan generation"
argument_list|)
expr_stmt|;
return|return;
block|}
annotation|@
name|Override
specifier|public
name|List
argument_list|<
name|FieldSchema
argument_list|>
name|getResultSchema
parameter_list|()
block|{
return|return
name|resultSchema
return|;
block|}
specifier|private
name|void
name|saveViewDefinition
parameter_list|()
throws|throws
name|SemanticException
block|{
comment|// Make a copy of the statement's result schema, since we may
comment|// modify it below as part of imposing view column names.
name|List
argument_list|<
name|FieldSchema
argument_list|>
name|derivedSchema
init|=
operator|new
name|ArrayList
argument_list|<
name|FieldSchema
argument_list|>
argument_list|(
name|resultSchema
argument_list|)
decl_stmt|;
name|ParseUtils
operator|.
name|validateColumnNameUniqueness
argument_list|(
name|derivedSchema
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|FieldSchema
argument_list|>
name|imposedSchema
init|=
name|createVwDesc
operator|.
name|getSchema
argument_list|()
decl_stmt|;
if|if
condition|(
name|imposedSchema
operator|!=
literal|null
condition|)
block|{
name|int
name|explicitColCount
init|=
name|imposedSchema
operator|.
name|size
argument_list|()
decl_stmt|;
name|int
name|derivedColCount
init|=
name|derivedSchema
operator|.
name|size
argument_list|()
decl_stmt|;
if|if
condition|(
name|explicitColCount
operator|!=
name|derivedColCount
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|generateErrorMessage
argument_list|(
name|viewSelect
argument_list|,
name|ErrorMsg
operator|.
name|VIEW_COL_MISMATCH
operator|.
name|getMsg
argument_list|()
argument_list|)
argument_list|)
throw|;
block|}
block|}
comment|// Preserve the original view definition as specified by the user.
name|String
name|originalText
init|=
name|ctx
operator|.
name|getTokenRewriteStream
argument_list|()
operator|.
name|toString
argument_list|(
name|viewSelect
operator|.
name|getTokenStartIndex
argument_list|()
argument_list|,
name|viewSelect
operator|.
name|getTokenStopIndex
argument_list|()
argument_list|)
decl_stmt|;
name|createVwDesc
operator|.
name|setViewOriginalText
argument_list|(
name|originalText
argument_list|)
expr_stmt|;
comment|// Now expand the view definition with extras such as explicit column
comment|// references; this expanded form is what we'll re-parse when the view is
comment|// referenced later.
name|unparseTranslator
operator|.
name|applyTranslations
argument_list|(
name|ctx
operator|.
name|getTokenRewriteStream
argument_list|()
argument_list|)
expr_stmt|;
name|String
name|expandedText
init|=
name|ctx
operator|.
name|getTokenRewriteStream
argument_list|()
operator|.
name|toString
argument_list|(
name|viewSelect
operator|.
name|getTokenStartIndex
argument_list|()
argument_list|,
name|viewSelect
operator|.
name|getTokenStopIndex
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|imposedSchema
operator|!=
literal|null
condition|)
block|{
comment|// Merge the names from the imposed schema into the types
comment|// from the derived schema.
name|StringBuilder
name|sb
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|"SELECT "
argument_list|)
expr_stmt|;
name|int
name|n
init|=
name|derivedSchema
operator|.
name|size
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|i
operator|>
literal|0
condition|)
block|{
name|sb
operator|.
name|append
argument_list|(
literal|", "
argument_list|)
expr_stmt|;
block|}
name|FieldSchema
name|fieldSchema
init|=
name|derivedSchema
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
comment|// Modify a copy, not the original
name|fieldSchema
operator|=
operator|new
name|FieldSchema
argument_list|(
name|fieldSchema
argument_list|)
expr_stmt|;
name|derivedSchema
operator|.
name|set
argument_list|(
name|i
argument_list|,
name|fieldSchema
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
name|HiveUtils
operator|.
name|unparseIdentifier
argument_list|(
name|fieldSchema
operator|.
name|getName
argument_list|()
argument_list|,
name|conf
argument_list|)
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|" AS "
argument_list|)
expr_stmt|;
name|String
name|imposedName
init|=
name|imposedSchema
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|getName
argument_list|()
decl_stmt|;
name|sb
operator|.
name|append
argument_list|(
name|HiveUtils
operator|.
name|unparseIdentifier
argument_list|(
name|imposedName
argument_list|,
name|conf
argument_list|)
argument_list|)
expr_stmt|;
name|fieldSchema
operator|.
name|setName
argument_list|(
name|imposedName
argument_list|)
expr_stmt|;
comment|// We don't currently allow imposition of a type
name|fieldSchema
operator|.
name|setComment
argument_list|(
name|imposedSchema
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|getComment
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|sb
operator|.
name|append
argument_list|(
literal|" FROM ("
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
name|expandedText
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|") "
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
name|HiveUtils
operator|.
name|unparseIdentifier
argument_list|(
name|createVwDesc
operator|.
name|getViewName
argument_list|()
argument_list|,
name|conf
argument_list|)
argument_list|)
expr_stmt|;
name|expandedText
operator|=
name|sb
operator|.
name|toString
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|createVwDesc
operator|.
name|getPartColNames
argument_list|()
operator|!=
literal|null
condition|)
block|{
comment|// Make sure all partitioning columns referenced actually
comment|// exist and are in the correct order at the end
comment|// of the list of columns produced by the view. Also move the field
comment|// schema descriptors from derivedSchema to the partitioning key
comment|// descriptor.
name|List
argument_list|<
name|String
argument_list|>
name|partColNames
init|=
name|createVwDesc
operator|.
name|getPartColNames
argument_list|()
decl_stmt|;
if|if
condition|(
name|partColNames
operator|.
name|size
argument_list|()
operator|>
name|derivedSchema
operator|.
name|size
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|VIEW_PARTITION_MISMATCH
operator|.
name|getMsg
argument_list|()
argument_list|)
throw|;
block|}
comment|// Get the partition columns from the end of derivedSchema.
name|List
argument_list|<
name|FieldSchema
argument_list|>
name|partitionColumns
init|=
name|derivedSchema
operator|.
name|subList
argument_list|(
name|derivedSchema
operator|.
name|size
argument_list|()
operator|-
name|partColNames
operator|.
name|size
argument_list|()
argument_list|,
name|derivedSchema
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
comment|// Verify that the names match the PARTITIONED ON clause.
name|Iterator
argument_list|<
name|String
argument_list|>
name|colNameIter
init|=
name|partColNames
operator|.
name|iterator
argument_list|()
decl_stmt|;
name|Iterator
argument_list|<
name|FieldSchema
argument_list|>
name|schemaIter
init|=
name|partitionColumns
operator|.
name|iterator
argument_list|()
decl_stmt|;
while|while
condition|(
name|colNameIter
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|String
name|colName
init|=
name|colNameIter
operator|.
name|next
argument_list|()
decl_stmt|;
name|FieldSchema
name|fieldSchema
init|=
name|schemaIter
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|fieldSchema
operator|.
name|getName
argument_list|()
operator|.
name|equals
argument_list|(
name|colName
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|VIEW_PARTITION_MISMATCH
operator|.
name|getMsg
argument_list|()
argument_list|)
throw|;
block|}
block|}
comment|// Boundary case: require at least one non-partitioned column
comment|// for consistency with tables.
if|if
condition|(
name|partColNames
operator|.
name|size
argument_list|()
operator|==
name|derivedSchema
operator|.
name|size
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|VIEW_PARTITION_TOTAL
operator|.
name|getMsg
argument_list|()
argument_list|)
throw|;
block|}
comment|// Now make a copy.
name|createVwDesc
operator|.
name|setPartCols
argument_list|(
operator|new
name|ArrayList
argument_list|<
name|FieldSchema
argument_list|>
argument_list|(
name|partitionColumns
argument_list|)
argument_list|)
expr_stmt|;
comment|// Finally, remove the partition columns from the end of derivedSchema.
comment|// (Clearing the subList writes through to the underlying
comment|// derivedSchema ArrayList.)
name|partitionColumns
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
name|createVwDesc
operator|.
name|setSchema
argument_list|(
name|derivedSchema
argument_list|)
expr_stmt|;
name|createVwDesc
operator|.
name|setViewExpandedText
argument_list|(
name|expandedText
argument_list|)
expr_stmt|;
block|}
specifier|private
name|List
argument_list|<
name|FieldSchema
argument_list|>
name|convertRowSchemaToViewSchema
parameter_list|(
name|RowResolver
name|rr
parameter_list|)
block|{
name|List
argument_list|<
name|FieldSchema
argument_list|>
name|fieldSchemas
init|=
operator|new
name|ArrayList
argument_list|<
name|FieldSchema
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|ColumnInfo
name|colInfo
range|:
name|rr
operator|.
name|getColumnInfos
argument_list|()
control|)
block|{
if|if
condition|(
name|colInfo
operator|.
name|isHiddenVirtualCol
argument_list|()
condition|)
block|{
continue|continue;
block|}
name|String
name|colName
init|=
name|rr
operator|.
name|reverseLookup
argument_list|(
name|colInfo
operator|.
name|getInternalName
argument_list|()
argument_list|)
index|[
literal|1
index|]
decl_stmt|;
name|fieldSchemas
operator|.
name|add
argument_list|(
operator|new
name|FieldSchema
argument_list|(
name|colName
argument_list|,
name|colInfo
operator|.
name|getType
argument_list|()
operator|.
name|getTypeName
argument_list|()
argument_list|,
literal|null
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|fieldSchemas
return|;
block|}
comment|/**    * Generates an expression node descriptor for the expression with TypeCheckCtx.    */
specifier|public
name|ExprNodeDesc
name|genExprNodeDesc
parameter_list|(
name|ASTNode
name|expr
parameter_list|,
name|RowResolver
name|input
parameter_list|)
throws|throws
name|SemanticException
block|{
comment|// Since the user didn't supply a customized type-checking context,
comment|// use default settings.
name|TypeCheckCtx
name|tcCtx
init|=
operator|new
name|TypeCheckCtx
argument_list|(
name|input
argument_list|)
decl_stmt|;
return|return
name|genExprNodeDesc
argument_list|(
name|expr
argument_list|,
name|input
argument_list|,
name|tcCtx
argument_list|)
return|;
block|}
comment|/**    * Generates an expression node descriptors for the expression and children of it    * with default TypeCheckCtx.    */
specifier|public
name|Map
argument_list|<
name|ASTNode
argument_list|,
name|ExprNodeDesc
argument_list|>
name|genAllExprNodeDesc
parameter_list|(
name|ASTNode
name|expr
parameter_list|,
name|RowResolver
name|input
parameter_list|)
throws|throws
name|SemanticException
block|{
name|TypeCheckCtx
name|tcCtx
init|=
operator|new
name|TypeCheckCtx
argument_list|(
name|input
argument_list|)
decl_stmt|;
return|return
name|genAllExprNodeDesc
argument_list|(
name|expr
argument_list|,
name|input
argument_list|,
name|tcCtx
argument_list|)
return|;
block|}
comment|/**    * Returns expression node descriptor for the expression.    * If it's evaluated already in previous operator, it can be retrieved from cache.    */
specifier|public
name|ExprNodeDesc
name|genExprNodeDesc
parameter_list|(
name|ASTNode
name|expr
parameter_list|,
name|RowResolver
name|input
parameter_list|,
name|TypeCheckCtx
name|tcCtx
parameter_list|)
throws|throws
name|SemanticException
block|{
comment|// We recursively create the exprNodeDesc. Base cases: when we encounter
comment|// a column ref, we convert that into an exprNodeColumnDesc; when we
comment|// encounter
comment|// a constant, we convert that into an exprNodeConstantDesc. For others we
comment|// just
comment|// build the exprNodeFuncDesc with recursively built children.
comment|// If the current subExpression is pre-calculated, as in Group-By etc.
name|ExprNodeDesc
name|cached
init|=
name|getExprNodeDescCached
argument_list|(
name|expr
argument_list|,
name|input
argument_list|)
decl_stmt|;
if|if
condition|(
name|cached
operator|==
literal|null
condition|)
block|{
name|Map
argument_list|<
name|ASTNode
argument_list|,
name|ExprNodeDesc
argument_list|>
name|allExprs
init|=
name|genAllExprNodeDesc
argument_list|(
name|expr
argument_list|,
name|input
argument_list|,
name|tcCtx
argument_list|)
decl_stmt|;
return|return
name|allExprs
operator|.
name|get
argument_list|(
name|expr
argument_list|)
return|;
block|}
return|return
name|cached
return|;
block|}
comment|/**    * Find ExprNodeDesc for the expression cached in the RowResolver. Returns null if not exists.    */
specifier|private
name|ExprNodeDesc
name|getExprNodeDescCached
parameter_list|(
name|ASTNode
name|expr
parameter_list|,
name|RowResolver
name|input
parameter_list|)
throws|throws
name|SemanticException
block|{
name|ColumnInfo
name|colInfo
init|=
name|input
operator|.
name|getExpression
argument_list|(
name|expr
argument_list|)
decl_stmt|;
if|if
condition|(
name|colInfo
operator|!=
literal|null
condition|)
block|{
name|ASTNode
name|source
init|=
name|input
operator|.
name|getExpressionSource
argument_list|(
name|expr
argument_list|)
decl_stmt|;
if|if
condition|(
name|source
operator|!=
literal|null
condition|)
block|{
name|unparseTranslator
operator|.
name|addCopyTranslation
argument_list|(
name|expr
argument_list|,
name|source
argument_list|)
expr_stmt|;
block|}
return|return
operator|new
name|ExprNodeColumnDesc
argument_list|(
name|colInfo
operator|.
name|getType
argument_list|()
argument_list|,
name|colInfo
operator|.
name|getInternalName
argument_list|()
argument_list|,
name|colInfo
operator|.
name|getTabAlias
argument_list|()
argument_list|,
name|colInfo
operator|.
name|getIsVirtualCol
argument_list|()
argument_list|,
name|colInfo
operator|.
name|isSkewedCol
argument_list|()
argument_list|)
return|;
block|}
return|return
literal|null
return|;
block|}
comment|/**    * Generates all of the expression node descriptors for the expression and children of it    * passed in the arguments. This function uses the row resolver and the metadata information    * that are passed as arguments to resolve the column names to internal names.    *    * @param expr    *          The expression    * @param input    *          The row resolver    * @param tcCtx    *          Customized type-checking context    * @return expression to exprNodeDesc mapping    * @throws SemanticException Failed to evaluate expression    */
annotation|@
name|SuppressWarnings
argument_list|(
literal|"nls"
argument_list|)
specifier|public
name|Map
argument_list|<
name|ASTNode
argument_list|,
name|ExprNodeDesc
argument_list|>
name|genAllExprNodeDesc
parameter_list|(
name|ASTNode
name|expr
parameter_list|,
name|RowResolver
name|input
parameter_list|,
name|TypeCheckCtx
name|tcCtx
parameter_list|)
throws|throws
name|SemanticException
block|{
comment|// Create the walker and  the rules dispatcher.
name|tcCtx
operator|.
name|setUnparseTranslator
argument_list|(
name|unparseTranslator
argument_list|)
expr_stmt|;
name|Map
argument_list|<
name|ASTNode
argument_list|,
name|ExprNodeDesc
argument_list|>
name|nodeOutputs
init|=
name|TypeCheckProcFactory
operator|.
name|genExprNode
argument_list|(
name|expr
argument_list|,
name|tcCtx
argument_list|)
decl_stmt|;
name|ExprNodeDesc
name|desc
init|=
operator|(
name|ExprNodeDesc
operator|)
name|nodeOutputs
operator|.
name|get
argument_list|(
name|expr
argument_list|)
decl_stmt|;
if|if
condition|(
name|desc
operator|==
literal|null
condition|)
block|{
name|String
name|errMsg
init|=
name|tcCtx
operator|.
name|getError
argument_list|()
decl_stmt|;
if|if
condition|(
name|errMsg
operator|==
literal|null
condition|)
block|{
name|errMsg
operator|=
literal|"Error in parsing "
expr_stmt|;
block|}
throw|throw
operator|new
name|SemanticException
argument_list|(
name|errMsg
argument_list|)
throw|;
block|}
if|if
condition|(
name|desc
operator|instanceof
name|ExprNodeColumnListDesc
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
literal|"TOK_ALLCOLREF is not supported in current context"
argument_list|)
throw|;
block|}
if|if
condition|(
operator|!
name|unparseTranslator
operator|.
name|isEnabled
argument_list|()
condition|)
block|{
comment|// Not creating a view, so no need to track view expansions.
return|return
name|nodeOutputs
return|;
block|}
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|ASTNode
argument_list|,
name|ExprNodeDesc
argument_list|>
name|entry
range|:
name|nodeOutputs
operator|.
name|entrySet
argument_list|()
control|)
block|{
if|if
condition|(
operator|!
operator|(
name|entry
operator|.
name|getValue
argument_list|()
operator|instanceof
name|ExprNodeColumnDesc
operator|)
condition|)
block|{
continue|continue;
block|}
name|ASTNode
name|node
init|=
name|entry
operator|.
name|getKey
argument_list|()
decl_stmt|;
name|ExprNodeColumnDesc
name|columnDesc
init|=
operator|(
name|ExprNodeColumnDesc
operator|)
name|entry
operator|.
name|getValue
argument_list|()
decl_stmt|;
if|if
condition|(
operator|(
name|columnDesc
operator|.
name|getTabAlias
argument_list|()
operator|==
literal|null
operator|)
operator|||
operator|(
name|columnDesc
operator|.
name|getTabAlias
argument_list|()
operator|.
name|length
argument_list|()
operator|==
literal|0
operator|)
condition|)
block|{
comment|// These aren't real column refs; instead, they are special
comment|// internal expressions used in the representation of aggregation.
continue|continue;
block|}
name|String
index|[]
name|tmp
init|=
name|input
operator|.
name|reverseLookup
argument_list|(
name|columnDesc
operator|.
name|getColumn
argument_list|()
argument_list|)
decl_stmt|;
name|StringBuilder
name|replacementText
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|replacementText
operator|.
name|append
argument_list|(
name|HiveUtils
operator|.
name|unparseIdentifier
argument_list|(
name|tmp
index|[
literal|0
index|]
argument_list|,
name|conf
argument_list|)
argument_list|)
expr_stmt|;
name|replacementText
operator|.
name|append
argument_list|(
literal|"."
argument_list|)
expr_stmt|;
name|replacementText
operator|.
name|append
argument_list|(
name|HiveUtils
operator|.
name|unparseIdentifier
argument_list|(
name|tmp
index|[
literal|1
index|]
argument_list|,
name|conf
argument_list|)
argument_list|)
expr_stmt|;
name|unparseTranslator
operator|.
name|addTranslation
argument_list|(
name|node
argument_list|,
name|replacementText
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|nodeOutputs
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|validate
parameter_list|()
throws|throws
name|SemanticException
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"validation start"
argument_list|)
expr_stmt|;
comment|// Validate inputs and outputs have right protectmode to execute the query
for|for
control|(
name|ReadEntity
name|readEntity
range|:
name|getInputs
argument_list|()
control|)
block|{
name|ReadEntity
operator|.
name|Type
name|type
init|=
name|readEntity
operator|.
name|getType
argument_list|()
decl_stmt|;
if|if
condition|(
name|type
operator|!=
name|ReadEntity
operator|.
name|Type
operator|.
name|TABLE
operator|&&
name|type
operator|!=
name|ReadEntity
operator|.
name|Type
operator|.
name|PARTITION
condition|)
block|{
comment|// In current implementation it will never happen, but we leave it
comment|// here to make the logic complete.
continue|continue;
block|}
name|Table
name|tbl
init|=
name|readEntity
operator|.
name|getTable
argument_list|()
decl_stmt|;
name|Partition
name|p
init|=
name|readEntity
operator|.
name|getPartition
argument_list|()
decl_stmt|;
if|if
condition|(
name|tbl
operator|.
name|isOffline
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|OFFLINE_TABLE_OR_PARTITION
operator|.
name|getMsg
argument_list|(
literal|"Table "
operator|+
name|tbl
operator|.
name|getTableName
argument_list|()
argument_list|)
argument_list|)
throw|;
block|}
if|if
condition|(
name|type
operator|==
name|ReadEntity
operator|.
name|Type
operator|.
name|PARTITION
operator|&&
name|p
operator|!=
literal|null
operator|&&
name|p
operator|.
name|isOffline
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|OFFLINE_TABLE_OR_PARTITION
operator|.
name|getMsg
argument_list|(
literal|"Table "
operator|+
name|tbl
operator|.
name|getTableName
argument_list|()
operator|+
literal|" Partition "
operator|+
name|p
operator|.
name|getName
argument_list|()
argument_list|)
argument_list|)
throw|;
block|}
block|}
for|for
control|(
name|WriteEntity
name|writeEntity
range|:
name|getOutputs
argument_list|()
control|)
block|{
name|WriteEntity
operator|.
name|Type
name|type
init|=
name|writeEntity
operator|.
name|getType
argument_list|()
decl_stmt|;
if|if
condition|(
name|type
operator|==
name|WriteEntity
operator|.
name|Type
operator|.
name|PARTITION
operator|||
name|type
operator|==
name|WriteEntity
operator|.
name|Type
operator|.
name|DUMMYPARTITION
condition|)
block|{
name|String
name|conflictingArchive
decl_stmt|;
try|try
block|{
name|Partition
name|usedp
init|=
name|writeEntity
operator|.
name|getPartition
argument_list|()
decl_stmt|;
name|Table
name|tbl
init|=
name|usedp
operator|.
name|getTable
argument_list|()
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"validated "
operator|+
name|usedp
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
name|usedp
operator|.
name|getTable
argument_list|()
argument_list|)
expr_stmt|;
name|conflictingArchive
operator|=
name|ArchiveUtils
operator|.
name|conflictingArchiveNameOrNull
argument_list|(
name|db
argument_list|,
name|tbl
argument_list|,
name|usedp
operator|.
name|getSpec
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|HiveException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|e
argument_list|)
throw|;
block|}
if|if
condition|(
name|conflictingArchive
operator|!=
literal|null
condition|)
block|{
name|String
name|message
init|=
name|String
operator|.
name|format
argument_list|(
literal|"Insert conflict with existing archive: %s"
argument_list|,
name|conflictingArchive
argument_list|)
decl_stmt|;
throw|throw
operator|new
name|SemanticException
argument_list|(
name|message
argument_list|)
throw|;
block|}
block|}
if|if
condition|(
name|type
operator|!=
name|WriteEntity
operator|.
name|Type
operator|.
name|TABLE
operator|&&
name|type
operator|!=
name|WriteEntity
operator|.
name|Type
operator|.
name|PARTITION
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"not validating writeEntity, because entity is neither table nor partition"
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|Table
name|tbl
decl_stmt|;
name|Partition
name|p
decl_stmt|;
if|if
condition|(
name|type
operator|==
name|WriteEntity
operator|.
name|Type
operator|.
name|PARTITION
condition|)
block|{
name|Partition
name|inputPartition
init|=
name|writeEntity
operator|.
name|getPartition
argument_list|()
decl_stmt|;
comment|// If it is a partition, Partition's metastore is not fetched. We
comment|// need to fetch it.
try|try
block|{
name|p
operator|=
name|Hive
operator|.
name|get
argument_list|()
operator|.
name|getPartition
argument_list|(
name|inputPartition
operator|.
name|getTable
argument_list|()
argument_list|,
name|inputPartition
operator|.
name|getSpec
argument_list|()
argument_list|,
literal|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|!=
literal|null
condition|)
block|{
name|tbl
operator|=
name|p
operator|.
name|getTable
argument_list|()
expr_stmt|;
block|}
else|else
block|{
comment|// if p is null, we assume that we insert to a new partition
name|tbl
operator|=
name|inputPartition
operator|.
name|getTable
argument_list|()
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|HiveException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|e
argument_list|)
throw|;
block|}
if|if
condition|(
name|type
operator|==
name|WriteEntity
operator|.
name|Type
operator|.
name|PARTITION
operator|&&
name|p
operator|!=
literal|null
operator|&&
name|p
operator|.
name|isOffline
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|OFFLINE_TABLE_OR_PARTITION
operator|.
name|getMsg
argument_list|(
literal|" Table "
operator|+
name|tbl
operator|.
name|getTableName
argument_list|()
operator|+
literal|" Partition "
operator|+
name|p
operator|.
name|getName
argument_list|()
argument_list|)
argument_list|)
throw|;
block|}
block|}
else|else
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Not a partition."
argument_list|)
expr_stmt|;
name|tbl
operator|=
name|writeEntity
operator|.
name|getTable
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|tbl
operator|.
name|isOffline
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|OFFLINE_TABLE_OR_PARTITION
operator|.
name|getMsg
argument_list|(
literal|"Table "
operator|+
name|tbl
operator|.
name|getTableName
argument_list|()
argument_list|)
argument_list|)
throw|;
block|}
block|}
name|boolean
name|reworkMapredWork
init|=
name|HiveConf
operator|.
name|getBoolVar
argument_list|(
name|this
operator|.
name|conf
argument_list|,
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVE_REWORK_MAPREDWORK
argument_list|)
decl_stmt|;
comment|// validate all tasks
for|for
control|(
name|Task
argument_list|<
name|?
extends|extends
name|Serializable
argument_list|>
name|rootTask
range|:
name|rootTasks
control|)
block|{
name|validate
argument_list|(
name|rootTask
argument_list|,
name|reworkMapredWork
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|validate
parameter_list|(
name|Task
argument_list|<
name|?
extends|extends
name|Serializable
argument_list|>
name|task
parameter_list|,
name|boolean
name|reworkMapredWork
parameter_list|)
throws|throws
name|SemanticException
block|{
name|Utilities
operator|.
name|reworkMapRedWork
argument_list|(
name|task
argument_list|,
name|reworkMapredWork
argument_list|,
name|conf
argument_list|)
expr_stmt|;
if|if
condition|(
name|task
operator|.
name|getChildTasks
argument_list|()
operator|==
literal|null
condition|)
block|{
return|return;
block|}
for|for
control|(
name|Task
argument_list|<
name|?
extends|extends
name|Serializable
argument_list|>
name|childTask
range|:
name|task
operator|.
name|getChildTasks
argument_list|()
control|)
block|{
name|validate
argument_list|(
name|childTask
argument_list|,
name|reworkMapredWork
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Get the row resolver given an operator.    */
specifier|public
name|RowResolver
name|getRowResolver
parameter_list|(
name|Operator
name|opt
parameter_list|)
block|{
return|return
name|opParseCtx
operator|.
name|get
argument_list|(
name|opt
argument_list|)
operator|.
name|getRowResolver
argument_list|()
return|;
block|}
comment|/**    * Add default properties for table property. If a default parameter exists    * in the tblProp, the value in tblProp will be kept.    *    * @param table    *          property map    * @return Modified table property map    */
specifier|private
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|addDefaultProperties
parameter_list|(
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|tblProp
parameter_list|)
block|{
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|retValue
decl_stmt|;
if|if
condition|(
name|tblProp
operator|==
literal|null
condition|)
block|{
name|retValue
operator|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|retValue
operator|=
name|tblProp
expr_stmt|;
block|}
name|String
name|paraString
init|=
name|HiveConf
operator|.
name|getVar
argument_list|(
name|conf
argument_list|,
name|ConfVars
operator|.
name|NEWTABLEDEFAULTPARA
argument_list|)
decl_stmt|;
if|if
condition|(
name|paraString
operator|!=
literal|null
operator|&&
operator|!
name|paraString
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
for|for
control|(
name|String
name|keyValuePair
range|:
name|paraString
operator|.
name|split
argument_list|(
literal|","
argument_list|)
control|)
block|{
name|String
index|[]
name|keyValue
init|=
name|keyValuePair
operator|.
name|split
argument_list|(
literal|"="
argument_list|,
literal|2
argument_list|)
decl_stmt|;
if|if
condition|(
name|keyValue
operator|.
name|length
operator|!=
literal|2
condition|)
block|{
continue|continue;
block|}
if|if
condition|(
operator|!
name|retValue
operator|.
name|containsKey
argument_list|(
name|keyValue
index|[
literal|0
index|]
argument_list|)
condition|)
block|{
name|retValue
operator|.
name|put
argument_list|(
name|keyValue
index|[
literal|0
index|]
argument_list|,
name|keyValue
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
name|retValue
return|;
block|}
comment|/**    * Analyze the create table command. If it is a regular create-table or    * create-table-like statements, we create a DDLWork and return true. If it is    * a create-table-as-select, we get the necessary info such as the SerDe and    * Storage Format and put it in QB, and return false, indicating the rest of    * the semantic analyzer need to deal with the select statement with respect    * to the SerDe and Storage Format.    */
specifier|private
name|ASTNode
name|analyzeCreateTable
parameter_list|(
name|ASTNode
name|ast
parameter_list|,
name|QB
name|qb
parameter_list|)
throws|throws
name|SemanticException
block|{
name|String
name|tableName
init|=
name|getUnescapedName
argument_list|(
operator|(
name|ASTNode
operator|)
name|ast
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|String
name|likeTableName
init|=
literal|null
decl_stmt|;
name|List
argument_list|<
name|FieldSchema
argument_list|>
name|cols
init|=
operator|new
name|ArrayList
argument_list|<
name|FieldSchema
argument_list|>
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|FieldSchema
argument_list|>
name|partCols
init|=
operator|new
name|ArrayList
argument_list|<
name|FieldSchema
argument_list|>
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|bucketCols
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|Order
argument_list|>
name|sortCols
init|=
operator|new
name|ArrayList
argument_list|<
name|Order
argument_list|>
argument_list|()
decl_stmt|;
name|int
name|numBuckets
init|=
operator|-
literal|1
decl_stmt|;
name|String
name|comment
init|=
literal|null
decl_stmt|;
name|String
name|location
init|=
literal|null
decl_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|tblProps
init|=
literal|null
decl_stmt|;
name|boolean
name|ifNotExists
init|=
literal|false
decl_stmt|;
name|boolean
name|isExt
init|=
literal|false
decl_stmt|;
name|ASTNode
name|selectStmt
init|=
literal|null
decl_stmt|;
specifier|final
name|int
name|CREATE_TABLE
init|=
literal|0
decl_stmt|;
comment|// regular CREATE TABLE
specifier|final
name|int
name|CTLT
init|=
literal|1
decl_stmt|;
comment|// CREATE TABLE LIKE ... (CTLT)
specifier|final
name|int
name|CTAS
init|=
literal|2
decl_stmt|;
comment|// CREATE TABLE AS SELECT ... (CTAS)
name|int
name|command_type
init|=
name|CREATE_TABLE
decl_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|skewedColNames
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|List
argument_list|<
name|String
argument_list|>
argument_list|>
name|skewedValues
init|=
operator|new
name|ArrayList
argument_list|<
name|List
argument_list|<
name|String
argument_list|>
argument_list|>
argument_list|()
decl_stmt|;
name|Map
argument_list|<
name|List
argument_list|<
name|String
argument_list|>
argument_list|,
name|String
argument_list|>
name|listBucketColValuesMapping
init|=
operator|new
name|HashMap
argument_list|<
name|List
argument_list|<
name|String
argument_list|>
argument_list|,
name|String
argument_list|>
argument_list|()
decl_stmt|;
name|boolean
name|storedAsDirs
init|=
literal|false
decl_stmt|;
name|RowFormatParams
name|rowFormatParams
init|=
operator|new
name|RowFormatParams
argument_list|()
decl_stmt|;
name|StorageFormat
name|storageFormat
init|=
operator|new
name|StorageFormat
argument_list|()
decl_stmt|;
name|AnalyzeCreateCommonVars
name|shared
init|=
operator|new
name|AnalyzeCreateCommonVars
argument_list|()
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Creating table "
operator|+
name|tableName
operator|+
literal|" position="
operator|+
name|ast
operator|.
name|getCharPositionInLine
argument_list|()
argument_list|)
expr_stmt|;
name|int
name|numCh
init|=
name|ast
operator|.
name|getChildCount
argument_list|()
decl_stmt|;
comment|/*      * Check the 1st-level children and do simple semantic checks: 1) CTLT and      * CTAS should not coexists. 2) CTLT or CTAS should not coexists with column      * list (target table schema). 3) CTAS does not support partitioning (for      * now).      */
for|for
control|(
name|int
name|num
init|=
literal|1
init|;
name|num
operator|<
name|numCh
condition|;
name|num
operator|++
control|)
block|{
name|ASTNode
name|child
init|=
operator|(
name|ASTNode
operator|)
name|ast
operator|.
name|getChild
argument_list|(
name|num
argument_list|)
decl_stmt|;
if|if
condition|(
name|storageFormat
operator|.
name|fillStorageFormat
argument_list|(
name|child
argument_list|,
name|shared
argument_list|)
condition|)
block|{
continue|continue;
block|}
switch|switch
condition|(
name|child
operator|.
name|getToken
argument_list|()
operator|.
name|getType
argument_list|()
condition|)
block|{
case|case
name|HiveParser
operator|.
name|TOK_IFNOTEXISTS
case|:
name|ifNotExists
operator|=
literal|true
expr_stmt|;
break|break;
case|case
name|HiveParser
operator|.
name|KW_EXTERNAL
case|:
name|isExt
operator|=
literal|true
expr_stmt|;
break|break;
case|case
name|HiveParser
operator|.
name|TOK_LIKETABLE
case|:
if|if
condition|(
name|child
operator|.
name|getChildCount
argument_list|()
operator|>
literal|0
condition|)
block|{
name|likeTableName
operator|=
name|getUnescapedName
argument_list|(
operator|(
name|ASTNode
operator|)
name|child
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|likeTableName
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|command_type
operator|==
name|CTAS
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|CTAS_CTLT_COEXISTENCE
operator|.
name|getMsg
argument_list|()
argument_list|)
throw|;
block|}
if|if
condition|(
name|cols
operator|.
name|size
argument_list|()
operator|!=
literal|0
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|CTLT_COLLST_COEXISTENCE
operator|.
name|getMsg
argument_list|()
argument_list|)
throw|;
block|}
block|}
name|command_type
operator|=
name|CTLT
expr_stmt|;
block|}
break|break;
case|case
name|HiveParser
operator|.
name|TOK_QUERY
case|:
comment|// CTAS
if|if
condition|(
name|command_type
operator|==
name|CTLT
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|CTAS_CTLT_COEXISTENCE
operator|.
name|getMsg
argument_list|()
argument_list|)
throw|;
block|}
if|if
condition|(
name|cols
operator|.
name|size
argument_list|()
operator|!=
literal|0
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|CTAS_COLLST_COEXISTENCE
operator|.
name|getMsg
argument_list|()
argument_list|)
throw|;
block|}
if|if
condition|(
name|partCols
operator|.
name|size
argument_list|()
operator|!=
literal|0
operator|||
name|bucketCols
operator|.
name|size
argument_list|()
operator|!=
literal|0
condition|)
block|{
name|boolean
name|dynPart
init|=
name|HiveConf
operator|.
name|getBoolVar
argument_list|(
name|conf
argument_list|,
name|HiveConf
operator|.
name|ConfVars
operator|.
name|DYNAMICPARTITIONING
argument_list|)
decl_stmt|;
if|if
condition|(
name|dynPart
operator|==
literal|false
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|CTAS_PARCOL_COEXISTENCE
operator|.
name|getMsg
argument_list|()
argument_list|)
throw|;
block|}
else|else
block|{
comment|// TODO: support dynamic partition for CTAS
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|CTAS_PARCOL_COEXISTENCE
operator|.
name|getMsg
argument_list|()
argument_list|)
throw|;
block|}
block|}
if|if
condition|(
name|isExt
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|CTAS_EXTTBL_COEXISTENCE
operator|.
name|getMsg
argument_list|()
argument_list|)
throw|;
block|}
name|command_type
operator|=
name|CTAS
expr_stmt|;
name|selectStmt
operator|=
name|child
expr_stmt|;
break|break;
case|case
name|HiveParser
operator|.
name|TOK_TABCOLLIST
case|:
name|cols
operator|=
name|getColumns
argument_list|(
name|child
argument_list|)
expr_stmt|;
break|break;
case|case
name|HiveParser
operator|.
name|TOK_TABLECOMMENT
case|:
name|comment
operator|=
name|unescapeSQLString
argument_list|(
name|child
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getText
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|HiveParser
operator|.
name|TOK_TABLEPARTCOLS
case|:
name|partCols
operator|=
name|getColumns
argument_list|(
operator|(
name|ASTNode
operator|)
name|child
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
argument_list|,
literal|false
argument_list|)
expr_stmt|;
break|break;
case|case
name|HiveParser
operator|.
name|TOK_TABLEBUCKETS
case|:
name|bucketCols
operator|=
name|getColumnNames
argument_list|(
operator|(
name|ASTNode
operator|)
name|child
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|child
operator|.
name|getChildCount
argument_list|()
operator|==
literal|2
condition|)
block|{
name|numBuckets
operator|=
operator|(
name|Integer
operator|.
name|valueOf
argument_list|(
name|child
operator|.
name|getChild
argument_list|(
literal|1
argument_list|)
operator|.
name|getText
argument_list|()
argument_list|)
operator|)
operator|.
name|intValue
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|sortCols
operator|=
name|getColumnNamesOrder
argument_list|(
operator|(
name|ASTNode
operator|)
name|child
operator|.
name|getChild
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|numBuckets
operator|=
operator|(
name|Integer
operator|.
name|valueOf
argument_list|(
name|child
operator|.
name|getChild
argument_list|(
literal|2
argument_list|)
operator|.
name|getText
argument_list|()
argument_list|)
operator|)
operator|.
name|intValue
argument_list|()
expr_stmt|;
block|}
break|break;
case|case
name|HiveParser
operator|.
name|TOK_TABLEROWFORMAT
case|:
name|rowFormatParams
operator|.
name|analyzeRowFormat
argument_list|(
name|shared
argument_list|,
name|child
argument_list|)
expr_stmt|;
break|break;
case|case
name|HiveParser
operator|.
name|TOK_TABLELOCATION
case|:
name|location
operator|=
name|unescapeSQLString
argument_list|(
name|child
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getText
argument_list|()
argument_list|)
expr_stmt|;
name|location
operator|=
name|EximUtil
operator|.
name|relativeToAbsolutePath
argument_list|(
name|conf
argument_list|,
name|location
argument_list|)
expr_stmt|;
break|break;
case|case
name|HiveParser
operator|.
name|TOK_TABLEPROPERTIES
case|:
name|tblProps
operator|=
name|DDLSemanticAnalyzer
operator|.
name|getProps
argument_list|(
operator|(
name|ASTNode
operator|)
name|child
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|HiveParser
operator|.
name|TOK_TABLESERIALIZER
case|:
name|child
operator|=
operator|(
name|ASTNode
operator|)
name|child
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|shared
operator|.
name|serde
operator|=
name|unescapeSQLString
argument_list|(
name|child
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getText
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|child
operator|.
name|getChildCount
argument_list|()
operator|==
literal|2
condition|)
block|{
name|readProps
argument_list|(
call|(
name|ASTNode
call|)
argument_list|(
name|child
operator|.
name|getChild
argument_list|(
literal|1
argument_list|)
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
argument_list|)
argument_list|,
name|shared
operator|.
name|serdeProps
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|HiveParser
operator|.
name|TOK_FILEFORMAT_GENERIC
case|:
name|handleGenericFileFormat
argument_list|(
name|child
argument_list|)
expr_stmt|;
break|break;
case|case
name|HiveParser
operator|.
name|TOK_TABLESKEWED
case|:
comment|/**          * Throw an error if the user tries to use the DDL with          * hive.internal.ddl.list.bucketing.enable set to false.          */
name|HiveConf
name|hiveConf
init|=
name|SessionState
operator|.
name|get
argument_list|()
operator|.
name|getConf
argument_list|()
decl_stmt|;
comment|// skewed column names
name|skewedColNames
operator|=
name|analyzeSkewedTablDDLColNames
argument_list|(
name|skewedColNames
argument_list|,
name|child
argument_list|)
expr_stmt|;
comment|// skewed value
name|analyzeDDLSkewedValues
argument_list|(
name|skewedValues
argument_list|,
name|child
argument_list|)
expr_stmt|;
comment|// stored as directories
name|storedAsDirs
operator|=
name|analyzeStoredAdDirs
argument_list|(
name|child
argument_list|)
expr_stmt|;
break|break;
default|default:
assert|assert
literal|false
assert|;
block|}
block|}
name|storageFormat
operator|.
name|fillDefaultStorageFormat
argument_list|(
name|shared
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|command_type
operator|==
name|CTAS
operator|)
operator|&&
operator|(
name|storageFormat
operator|.
name|storageHandler
operator|!=
literal|null
operator|)
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|CREATE_NON_NATIVE_AS
operator|.
name|getMsg
argument_list|()
argument_list|)
throw|;
block|}
comment|// check for existence of table
if|if
condition|(
name|ifNotExists
condition|)
block|{
try|try
block|{
name|Table
name|table
init|=
name|getTableWithQN
argument_list|(
name|tableName
argument_list|,
literal|false
argument_list|)
decl_stmt|;
if|if
condition|(
name|table
operator|!=
literal|null
condition|)
block|{
comment|// table exists
return|return
literal|null
return|;
block|}
block|}
catch|catch
parameter_list|(
name|HiveException
name|e
parameter_list|)
block|{
name|e
operator|.
name|printStackTrace
argument_list|()
expr_stmt|;
block|}
block|}
comment|// Handle different types of CREATE TABLE command
name|CreateTableDesc
name|crtTblDesc
init|=
literal|null
decl_stmt|;
switch|switch
condition|(
name|command_type
condition|)
block|{
case|case
name|CREATE_TABLE
case|:
comment|// REGULAR CREATE TABLE DDL
name|tblProps
operator|=
name|addDefaultProperties
argument_list|(
name|tblProps
argument_list|)
expr_stmt|;
name|crtTblDesc
operator|=
operator|new
name|CreateTableDesc
argument_list|(
name|tableName
argument_list|,
name|isExt
argument_list|,
name|cols
argument_list|,
name|partCols
argument_list|,
name|bucketCols
argument_list|,
name|sortCols
argument_list|,
name|numBuckets
argument_list|,
name|rowFormatParams
operator|.
name|fieldDelim
argument_list|,
name|rowFormatParams
operator|.
name|fieldEscape
argument_list|,
name|rowFormatParams
operator|.
name|collItemDelim
argument_list|,
name|rowFormatParams
operator|.
name|mapKeyDelim
argument_list|,
name|rowFormatParams
operator|.
name|lineDelim
argument_list|,
name|comment
argument_list|,
name|storageFormat
operator|.
name|inputFormat
argument_list|,
name|storageFormat
operator|.
name|outputFormat
argument_list|,
name|location
argument_list|,
name|shared
operator|.
name|serde
argument_list|,
name|storageFormat
operator|.
name|storageHandler
argument_list|,
name|shared
operator|.
name|serdeProps
argument_list|,
name|tblProps
argument_list|,
name|ifNotExists
argument_list|,
name|skewedColNames
argument_list|,
name|skewedValues
argument_list|)
expr_stmt|;
name|crtTblDesc
operator|.
name|setStoredAsSubDirectories
argument_list|(
name|storedAsDirs
argument_list|)
expr_stmt|;
name|crtTblDesc
operator|.
name|setNullFormat
argument_list|(
name|rowFormatParams
operator|.
name|nullFormat
argument_list|)
expr_stmt|;
name|crtTblDesc
operator|.
name|validate
argument_list|()
expr_stmt|;
comment|// outputs is empty, which means this create table happens in the current
comment|// database.
name|SessionState
operator|.
name|get
argument_list|()
operator|.
name|setCommandType
argument_list|(
name|HiveOperation
operator|.
name|CREATETABLE
argument_list|)
expr_stmt|;
name|rootTasks
operator|.
name|add
argument_list|(
name|TaskFactory
operator|.
name|get
argument_list|(
operator|new
name|DDLWork
argument_list|(
name|getInputs
argument_list|()
argument_list|,
name|getOutputs
argument_list|()
argument_list|,
name|crtTblDesc
argument_list|)
argument_list|,
name|conf
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|CTLT
case|:
comment|// create table like<tbl_name>
name|tblProps
operator|=
name|addDefaultProperties
argument_list|(
name|tblProps
argument_list|)
expr_stmt|;
name|CreateTableLikeDesc
name|crtTblLikeDesc
init|=
operator|new
name|CreateTableLikeDesc
argument_list|(
name|tableName
argument_list|,
name|isExt
argument_list|,
name|storageFormat
operator|.
name|inputFormat
argument_list|,
name|storageFormat
operator|.
name|outputFormat
argument_list|,
name|location
argument_list|,
name|shared
operator|.
name|serde
argument_list|,
name|shared
operator|.
name|serdeProps
argument_list|,
name|tblProps
argument_list|,
name|ifNotExists
argument_list|,
name|likeTableName
argument_list|)
decl_stmt|;
name|SessionState
operator|.
name|get
argument_list|()
operator|.
name|setCommandType
argument_list|(
name|HiveOperation
operator|.
name|CREATETABLE
argument_list|)
expr_stmt|;
name|rootTasks
operator|.
name|add
argument_list|(
name|TaskFactory
operator|.
name|get
argument_list|(
operator|new
name|DDLWork
argument_list|(
name|getInputs
argument_list|()
argument_list|,
name|getOutputs
argument_list|()
argument_list|,
name|crtTblLikeDesc
argument_list|)
argument_list|,
name|conf
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|CTAS
case|:
comment|// create table as select
comment|// Verify that the table does not already exist
name|String
name|databaseName
decl_stmt|;
try|try
block|{
name|Table
name|dumpTable
init|=
name|db
operator|.
name|newTable
argument_list|(
name|tableName
argument_list|)
decl_stmt|;
name|databaseName
operator|=
name|dumpTable
operator|.
name|getDbName
argument_list|()
expr_stmt|;
if|if
condition|(
literal|null
operator|==
name|db
operator|.
name|getDatabase
argument_list|(
name|dumpTable
operator|.
name|getDbName
argument_list|()
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|DATABASE_NOT_EXISTS
operator|.
name|getMsg
argument_list|(
name|dumpTable
operator|.
name|getDbName
argument_list|()
argument_list|)
argument_list|)
throw|;
block|}
if|if
condition|(
literal|null
operator|!=
name|db
operator|.
name|getTable
argument_list|(
name|dumpTable
operator|.
name|getDbName
argument_list|()
argument_list|,
name|dumpTable
operator|.
name|getTableName
argument_list|()
argument_list|,
literal|false
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|TABLE_ALREADY_EXISTS
operator|.
name|getMsg
argument_list|(
name|tableName
argument_list|)
argument_list|)
throw|;
block|}
block|}
catch|catch
parameter_list|(
name|HiveException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|e
argument_list|)
throw|;
block|}
name|tblProps
operator|=
name|addDefaultProperties
argument_list|(
name|tblProps
argument_list|)
expr_stmt|;
name|crtTblDesc
operator|=
operator|new
name|CreateTableDesc
argument_list|(
name|databaseName
argument_list|,
name|tableName
argument_list|,
name|isExt
argument_list|,
name|cols
argument_list|,
name|partCols
argument_list|,
name|bucketCols
argument_list|,
name|sortCols
argument_list|,
name|numBuckets
argument_list|,
name|rowFormatParams
operator|.
name|fieldDelim
argument_list|,
name|rowFormatParams
operator|.
name|fieldEscape
argument_list|,
name|rowFormatParams
operator|.
name|collItemDelim
argument_list|,
name|rowFormatParams
operator|.
name|mapKeyDelim
argument_list|,
name|rowFormatParams
operator|.
name|lineDelim
argument_list|,
name|comment
argument_list|,
name|storageFormat
operator|.
name|inputFormat
argument_list|,
name|storageFormat
operator|.
name|outputFormat
argument_list|,
name|location
argument_list|,
name|shared
operator|.
name|serde
argument_list|,
name|storageFormat
operator|.
name|storageHandler
argument_list|,
name|shared
operator|.
name|serdeProps
argument_list|,
name|tblProps
argument_list|,
name|ifNotExists
argument_list|,
name|skewedColNames
argument_list|,
name|skewedValues
argument_list|)
expr_stmt|;
name|crtTblDesc
operator|.
name|setStoredAsSubDirectories
argument_list|(
name|storedAsDirs
argument_list|)
expr_stmt|;
name|crtTblDesc
operator|.
name|setNullFormat
argument_list|(
name|rowFormatParams
operator|.
name|nullFormat
argument_list|)
expr_stmt|;
name|qb
operator|.
name|setTableDesc
argument_list|(
name|crtTblDesc
argument_list|)
expr_stmt|;
name|SessionState
operator|.
name|get
argument_list|()
operator|.
name|setCommandType
argument_list|(
name|HiveOperation
operator|.
name|CREATETABLE_AS_SELECT
argument_list|)
expr_stmt|;
return|return
name|selectStmt
return|;
default|default:
throw|throw
operator|new
name|SemanticException
argument_list|(
literal|"Unrecognized command."
argument_list|)
throw|;
block|}
return|return
literal|null
return|;
block|}
specifier|private
name|ASTNode
name|analyzeCreateView
parameter_list|(
name|ASTNode
name|ast
parameter_list|,
name|QB
name|qb
parameter_list|)
throws|throws
name|SemanticException
block|{
name|String
name|tableName
init|=
name|getUnescapedName
argument_list|(
operator|(
name|ASTNode
operator|)
name|ast
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|FieldSchema
argument_list|>
name|cols
init|=
literal|null
decl_stmt|;
name|boolean
name|ifNotExists
init|=
literal|false
decl_stmt|;
name|boolean
name|orReplace
init|=
literal|false
decl_stmt|;
name|boolean
name|isAlterViewAs
init|=
literal|false
decl_stmt|;
name|String
name|comment
init|=
literal|null
decl_stmt|;
name|ASTNode
name|selectStmt
init|=
literal|null
decl_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|tblProps
init|=
literal|null
decl_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|partColNames
init|=
literal|null
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Creating view "
operator|+
name|tableName
operator|+
literal|" position="
operator|+
name|ast
operator|.
name|getCharPositionInLine
argument_list|()
argument_list|)
expr_stmt|;
name|int
name|numCh
init|=
name|ast
operator|.
name|getChildCount
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|num
init|=
literal|1
init|;
name|num
operator|<
name|numCh
condition|;
name|num
operator|++
control|)
block|{
name|ASTNode
name|child
init|=
operator|(
name|ASTNode
operator|)
name|ast
operator|.
name|getChild
argument_list|(
name|num
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|child
operator|.
name|getToken
argument_list|()
operator|.
name|getType
argument_list|()
condition|)
block|{
case|case
name|HiveParser
operator|.
name|TOK_IFNOTEXISTS
case|:
name|ifNotExists
operator|=
literal|true
expr_stmt|;
break|break;
case|case
name|HiveParser
operator|.
name|TOK_ORREPLACE
case|:
name|orReplace
operator|=
literal|true
expr_stmt|;
break|break;
case|case
name|HiveParser
operator|.
name|TOK_QUERY
case|:
name|selectStmt
operator|=
name|child
expr_stmt|;
break|break;
case|case
name|HiveParser
operator|.
name|TOK_TABCOLNAME
case|:
name|cols
operator|=
name|getColumns
argument_list|(
name|child
argument_list|)
expr_stmt|;
break|break;
case|case
name|HiveParser
operator|.
name|TOK_TABLECOMMENT
case|:
name|comment
operator|=
name|unescapeSQLString
argument_list|(
name|child
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getText
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|HiveParser
operator|.
name|TOK_TABLEPROPERTIES
case|:
name|tblProps
operator|=
name|DDLSemanticAnalyzer
operator|.
name|getProps
argument_list|(
operator|(
name|ASTNode
operator|)
name|child
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|HiveParser
operator|.
name|TOK_VIEWPARTCOLS
case|:
name|partColNames
operator|=
name|getColumnNames
argument_list|(
operator|(
name|ASTNode
operator|)
name|child
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
assert|assert
literal|false
assert|;
block|}
block|}
if|if
condition|(
name|ifNotExists
operator|&&
name|orReplace
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
literal|"Can't combine IF NOT EXISTS and OR REPLACE."
argument_list|)
throw|;
block|}
if|if
condition|(
name|ast
operator|.
name|getToken
argument_list|()
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_ALTERVIEW_AS
condition|)
block|{
name|isAlterViewAs
operator|=
literal|true
expr_stmt|;
name|orReplace
operator|=
literal|true
expr_stmt|;
block|}
name|createVwDesc
operator|=
operator|new
name|CreateViewDesc
argument_list|(
name|tableName
argument_list|,
name|cols
argument_list|,
name|comment
argument_list|,
name|tblProps
argument_list|,
name|partColNames
argument_list|,
name|ifNotExists
argument_list|,
name|orReplace
argument_list|,
name|isAlterViewAs
argument_list|)
expr_stmt|;
name|unparseTranslator
operator|.
name|enable
argument_list|()
expr_stmt|;
name|rootTasks
operator|.
name|add
argument_list|(
name|TaskFactory
operator|.
name|get
argument_list|(
operator|new
name|DDLWork
argument_list|(
name|getInputs
argument_list|()
argument_list|,
name|getOutputs
argument_list|()
argument_list|,
name|createVwDesc
argument_list|)
argument_list|,
name|conf
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|selectStmt
return|;
block|}
comment|// validate the create view statement
comment|// the statement could be CREATE VIEW, REPLACE VIEW, or ALTER VIEW AS SELECT
comment|// check semantic conditions
specifier|private
name|void
name|validateCreateView
parameter_list|(
name|CreateViewDesc
name|createVwDesc
parameter_list|)
throws|throws
name|SemanticException
block|{
try|try
block|{
name|Table
name|oldView
init|=
name|getTableWithQN
argument_list|(
name|createVwDesc
operator|.
name|getViewName
argument_list|()
argument_list|,
literal|false
argument_list|)
decl_stmt|;
comment|// ALTER VIEW AS SELECT requires the view must exist
if|if
condition|(
name|createVwDesc
operator|.
name|getIsAlterViewAs
argument_list|()
operator|&&
name|oldView
operator|==
literal|null
condition|)
block|{
name|String
name|viewNotExistErrorMsg
init|=
literal|"The following view does not exist: "
operator|+
name|createVwDesc
operator|.
name|getViewName
argument_list|()
decl_stmt|;
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|ALTER_VIEW_AS_SELECT_NOT_EXIST
operator|.
name|getMsg
argument_list|(
name|viewNotExistErrorMsg
argument_list|)
argument_list|)
throw|;
block|}
comment|//replace view
if|if
condition|(
name|createVwDesc
operator|.
name|getOrReplace
argument_list|()
operator|&&
name|oldView
operator|!=
literal|null
condition|)
block|{
comment|// Existing table is not a view
if|if
condition|(
operator|!
name|oldView
operator|.
name|getTableType
argument_list|()
operator|.
name|equals
argument_list|(
name|TableType
operator|.
name|VIRTUAL_VIEW
argument_list|)
condition|)
block|{
name|String
name|tableNotViewErrorMsg
init|=
literal|"The following is an existing table, not a view: "
operator|+
name|createVwDesc
operator|.
name|getViewName
argument_list|()
decl_stmt|;
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|EXISTING_TABLE_IS_NOT_VIEW
operator|.
name|getMsg
argument_list|(
name|tableNotViewErrorMsg
argument_list|)
argument_list|)
throw|;
block|}
comment|// if old view has partitions, it could not be replaced
name|String
name|partitionViewErrorMsg
init|=
literal|"The following view has partition, it could not be replaced: "
operator|+
name|createVwDesc
operator|.
name|getViewName
argument_list|()
decl_stmt|;
try|try
block|{
if|if
condition|(
operator|(
name|createVwDesc
operator|.
name|getPartCols
argument_list|()
operator|==
literal|null
operator|||
name|createVwDesc
operator|.
name|getPartCols
argument_list|()
operator|.
name|isEmpty
argument_list|()
operator|||
operator|!
name|createVwDesc
operator|.
name|getPartCols
argument_list|()
operator|.
name|equals
argument_list|(
name|oldView
operator|.
name|getPartCols
argument_list|()
argument_list|)
operator|)
operator|&&
operator|!
name|oldView
operator|.
name|getPartCols
argument_list|()
operator|.
name|isEmpty
argument_list|()
operator|&&
operator|!
name|db
operator|.
name|getPartitions
argument_list|(
name|oldView
argument_list|)
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|REPLACE_VIEW_WITH_PARTITION
operator|.
name|getMsg
argument_list|(
name|partitionViewErrorMsg
argument_list|)
argument_list|)
throw|;
block|}
block|}
catch|catch
parameter_list|(
name|HiveException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|REPLACE_VIEW_WITH_PARTITION
operator|.
name|getMsg
argument_list|(
name|partitionViewErrorMsg
argument_list|)
argument_list|)
throw|;
block|}
block|}
block|}
catch|catch
parameter_list|(
name|HiveException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|e
operator|.
name|getMessage
argument_list|()
argument_list|)
throw|;
block|}
block|}
comment|// Process the position alias in GROUPBY and ORDERBY
specifier|private
name|void
name|processPositionAlias
parameter_list|(
name|ASTNode
name|ast
parameter_list|)
throws|throws
name|SemanticException
block|{
if|if
condition|(
name|HiveConf
operator|.
name|getBoolVar
argument_list|(
name|conf
argument_list|,
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVE_GROUPBY_ORDERBY_POSITION_ALIAS
argument_list|)
operator|==
literal|false
condition|)
block|{
return|return;
block|}
if|if
condition|(
name|ast
operator|.
name|getChildCount
argument_list|()
operator|==
literal|0
condition|)
block|{
return|return;
block|}
name|boolean
name|isAllCol
decl_stmt|;
name|ASTNode
name|selectNode
init|=
literal|null
decl_stmt|;
name|ASTNode
name|groupbyNode
init|=
literal|null
decl_stmt|;
name|ASTNode
name|orderbyNode
init|=
literal|null
decl_stmt|;
comment|// get node type
name|int
name|child_count
init|=
name|ast
operator|.
name|getChildCount
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|child_pos
init|=
literal|0
init|;
name|child_pos
operator|<
name|child_count
condition|;
operator|++
name|child_pos
control|)
block|{
name|ASTNode
name|node
init|=
operator|(
name|ASTNode
operator|)
name|ast
operator|.
name|getChild
argument_list|(
name|child_pos
argument_list|)
decl_stmt|;
name|int
name|type
init|=
name|node
operator|.
name|getToken
argument_list|()
operator|.
name|getType
argument_list|()
decl_stmt|;
if|if
condition|(
name|type
operator|==
name|HiveParser
operator|.
name|TOK_SELECT
condition|)
block|{
name|selectNode
operator|=
name|node
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|type
operator|==
name|HiveParser
operator|.
name|TOK_GROUPBY
condition|)
block|{
name|groupbyNode
operator|=
name|node
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|type
operator|==
name|HiveParser
operator|.
name|TOK_ORDERBY
condition|)
block|{
name|orderbyNode
operator|=
name|node
expr_stmt|;
block|}
block|}
if|if
condition|(
name|selectNode
operator|!=
literal|null
condition|)
block|{
name|int
name|selectExpCnt
init|=
name|selectNode
operator|.
name|getChildCount
argument_list|()
decl_stmt|;
comment|// replace each of the position alias in GROUPBY with the actual column name
if|if
condition|(
name|groupbyNode
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|int
name|child_pos
init|=
literal|0
init|;
name|child_pos
operator|<
name|groupbyNode
operator|.
name|getChildCount
argument_list|()
condition|;
operator|++
name|child_pos
control|)
block|{
name|ASTNode
name|node
init|=
operator|(
name|ASTNode
operator|)
name|groupbyNode
operator|.
name|getChild
argument_list|(
name|child_pos
argument_list|)
decl_stmt|;
if|if
condition|(
name|node
operator|.
name|getToken
argument_list|()
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|Number
condition|)
block|{
name|int
name|pos
init|=
name|Integer
operator|.
name|parseInt
argument_list|(
name|node
operator|.
name|getText
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|pos
operator|>
literal|0
operator|&&
name|pos
operator|<=
name|selectExpCnt
condition|)
block|{
name|groupbyNode
operator|.
name|setChild
argument_list|(
name|child_pos
argument_list|,
operator|(
name|BaseTree
operator|)
name|selectNode
operator|.
name|getChild
argument_list|(
name|pos
operator|-
literal|1
argument_list|)
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|INVALID_POSITION_ALIAS_IN_GROUPBY
operator|.
name|getMsg
argument_list|(
literal|"Position alias: "
operator|+
name|pos
operator|+
literal|" does not exist\n"
operator|+
literal|"The Select List is indexed from 1 to "
operator|+
name|selectExpCnt
argument_list|)
argument_list|)
throw|;
block|}
block|}
block|}
block|}
comment|// replace each of the position alias in ORDERBY with the actual column name
if|if
condition|(
name|orderbyNode
operator|!=
literal|null
condition|)
block|{
name|isAllCol
operator|=
literal|false
expr_stmt|;
for|for
control|(
name|int
name|child_pos
init|=
literal|0
init|;
name|child_pos
operator|<
name|selectNode
operator|.
name|getChildCount
argument_list|()
condition|;
operator|++
name|child_pos
control|)
block|{
name|ASTNode
name|node
init|=
operator|(
name|ASTNode
operator|)
name|selectNode
operator|.
name|getChild
argument_list|(
name|child_pos
argument_list|)
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|node
operator|.
name|getToken
argument_list|()
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_ALLCOLREF
condition|)
block|{
name|isAllCol
operator|=
literal|true
expr_stmt|;
block|}
block|}
for|for
control|(
name|int
name|child_pos
init|=
literal|0
init|;
name|child_pos
operator|<
name|orderbyNode
operator|.
name|getChildCount
argument_list|()
condition|;
operator|++
name|child_pos
control|)
block|{
name|ASTNode
name|colNode
init|=
operator|(
name|ASTNode
operator|)
name|orderbyNode
operator|.
name|getChild
argument_list|(
name|child_pos
argument_list|)
decl_stmt|;
name|ASTNode
name|node
init|=
operator|(
name|ASTNode
operator|)
name|colNode
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|node
operator|.
name|getToken
argument_list|()
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|Number
condition|)
block|{
if|if
condition|(
operator|!
name|isAllCol
condition|)
block|{
name|int
name|pos
init|=
name|Integer
operator|.
name|parseInt
argument_list|(
name|node
operator|.
name|getText
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|pos
operator|>
literal|0
operator|&&
name|pos
operator|<=
name|selectExpCnt
condition|)
block|{
name|colNode
operator|.
name|setChild
argument_list|(
literal|0
argument_list|,
operator|(
name|BaseTree
operator|)
name|selectNode
operator|.
name|getChild
argument_list|(
name|pos
operator|-
literal|1
argument_list|)
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|INVALID_POSITION_ALIAS_IN_ORDERBY
operator|.
name|getMsg
argument_list|(
literal|"Position alias: "
operator|+
name|pos
operator|+
literal|" does not exist\n"
operator|+
literal|"The Select List is indexed from 1 to "
operator|+
name|selectExpCnt
argument_list|)
argument_list|)
throw|;
block|}
block|}
else|else
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|NO_SUPPORTED_ORDERBY_ALLCOLREF_POS
operator|.
name|getMsg
argument_list|()
argument_list|)
throw|;
block|}
block|}
block|}
block|}
block|}
comment|// Recursively process through the children ASTNodes
for|for
control|(
name|int
name|child_pos
init|=
literal|0
init|;
name|child_pos
operator|<
name|child_count
condition|;
operator|++
name|child_pos
control|)
block|{
name|processPositionAlias
argument_list|(
operator|(
name|ASTNode
operator|)
name|ast
operator|.
name|getChild
argument_list|(
name|child_pos
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
comment|/**    * process analyze ... partial command    *    * separate it from noscan command process so that it provides us flexibility    *    * @param tree    * @throws SemanticException    */
specifier|protected
name|void
name|processPartialScanCommand
parameter_list|(
name|ASTNode
name|tree
parameter_list|)
throws|throws
name|SemanticException
block|{
comment|// check if it is partial scan command
name|this
operator|.
name|checkPartialScan
argument_list|(
name|tree
argument_list|)
expr_stmt|;
comment|//validate partial scan
if|if
condition|(
name|this
operator|.
name|partialscan
condition|)
block|{
name|validateAnalyzePartialscan
argument_list|(
name|tree
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * process analyze ... noscan command    * @param tree    * @throws SemanticException    */
specifier|protected
name|void
name|processNoScanCommand
parameter_list|(
name|ASTNode
name|tree
parameter_list|)
throws|throws
name|SemanticException
block|{
comment|// check if it is noscan command
name|checkNoScan
argument_list|(
name|tree
argument_list|)
expr_stmt|;
comment|//validate noscan
if|if
condition|(
name|this
operator|.
name|noscan
condition|)
block|{
name|validateAnalyzeNoscan
argument_list|(
name|tree
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Validate noscan command    *    * @param tree    * @throws SemanticException    */
specifier|private
name|void
name|validateAnalyzeNoscan
parameter_list|(
name|ASTNode
name|tree
parameter_list|)
throws|throws
name|SemanticException
block|{
comment|// since it is noscan, it is true table name in command
name|String
name|tableName
init|=
name|getUnescapedName
argument_list|(
operator|(
name|ASTNode
operator|)
name|tree
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|Table
name|tbl
decl_stmt|;
try|try
block|{
name|tbl
operator|=
name|db
operator|.
name|getTable
argument_list|(
name|tableName
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|HiveException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|INVALID_TABLE
operator|.
name|getMsg
argument_list|(
name|tableName
argument_list|)
argument_list|)
throw|;
block|}
comment|/* noscan uses hdfs apis to retrieve such information from Namenode.      */
comment|/* But that will be specific to hdfs. Through storagehandler mechanism,   */
comment|/* storage of table could be on any storage system: hbase, cassandra etc. */
comment|/* A nice error message should be given to user. */
if|if
condition|(
name|tbl
operator|.
name|isNonNative
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|ANALYZE_TABLE_NOSCAN_NON_NATIVE
operator|.
name|getMsg
argument_list|(
name|tbl
operator|.
name|getTableName
argument_list|()
argument_list|)
argument_list|)
throw|;
block|}
block|}
comment|/**    * Validate partialscan command    *    * @param tree    * @throws SemanticException    */
specifier|private
name|void
name|validateAnalyzePartialscan
parameter_list|(
name|ASTNode
name|tree
parameter_list|)
throws|throws
name|SemanticException
block|{
comment|// since it is partialscan, it is true table name in command
name|String
name|tableName
init|=
name|getUnescapedName
argument_list|(
operator|(
name|ASTNode
operator|)
name|tree
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|Table
name|tbl
decl_stmt|;
try|try
block|{
name|tbl
operator|=
name|db
operator|.
name|getTable
argument_list|(
name|tableName
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|HiveException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|INVALID_TABLE
operator|.
name|getMsg
argument_list|(
name|tableName
argument_list|)
argument_list|)
throw|;
block|}
comment|/* partialscan uses hdfs apis to retrieve such information from Namenode.      */
comment|/* But that will be specific to hdfs. Through storagehandler mechanism,   */
comment|/* storage of table could be on any storage system: hbase, cassandra etc. */
comment|/* A nice error message should be given to user. */
if|if
condition|(
name|tbl
operator|.
name|isNonNative
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|ANALYZE_TABLE_PARTIALSCAN_NON_NATIVE
operator|.
name|getMsg
argument_list|(
name|tbl
operator|.
name|getTableName
argument_list|()
argument_list|)
argument_list|)
throw|;
block|}
comment|/**      * Partial scan doesn't support external table.      */
if|if
condition|(
name|tbl
operator|.
name|getTableType
argument_list|()
operator|.
name|equals
argument_list|(
name|TableType
operator|.
name|EXTERNAL_TABLE
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|ANALYZE_TABLE_PARTIALSCAN_EXTERNAL_TABLE
operator|.
name|getMsg
argument_list|(
name|tbl
operator|.
name|getTableName
argument_list|()
argument_list|)
argument_list|)
throw|;
block|}
if|if
condition|(
operator|!
name|HiveConf
operator|.
name|getBoolVar
argument_list|(
name|conf
argument_list|,
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVESTATSAUTOGATHER
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|ANALYZE_TABLE_PARTIALSCAN_AUTOGATHER
operator|.
name|getMsg
argument_list|()
argument_list|)
throw|;
block|}
block|}
comment|/**    * It will check if this is analyze ... compute statistics noscan    * @param tree    */
specifier|private
name|void
name|checkNoScan
parameter_list|(
name|ASTNode
name|tree
parameter_list|)
block|{
if|if
condition|(
name|tree
operator|.
name|getChildCount
argument_list|()
operator|>
literal|1
condition|)
block|{
name|ASTNode
name|child0
init|=
operator|(
name|ASTNode
operator|)
name|tree
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|ASTNode
name|child1
decl_stmt|;
if|if
condition|(
name|child0
operator|.
name|getToken
argument_list|()
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_TAB
condition|)
block|{
name|child0
operator|=
operator|(
name|ASTNode
operator|)
name|child0
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|child0
operator|.
name|getToken
argument_list|()
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_TABNAME
condition|)
block|{
name|child1
operator|=
operator|(
name|ASTNode
operator|)
name|tree
operator|.
name|getChild
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|child1
operator|.
name|getToken
argument_list|()
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|KW_NOSCAN
condition|)
block|{
name|this
operator|.
name|noscan
operator|=
literal|true
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
comment|/**    * It will check if this is analyze ... compute statistics partialscan    * @param tree    */
specifier|private
name|void
name|checkPartialScan
parameter_list|(
name|ASTNode
name|tree
parameter_list|)
block|{
if|if
condition|(
name|tree
operator|.
name|getChildCount
argument_list|()
operator|>
literal|1
condition|)
block|{
name|ASTNode
name|child0
init|=
operator|(
name|ASTNode
operator|)
name|tree
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|ASTNode
name|child1
decl_stmt|;
if|if
condition|(
name|child0
operator|.
name|getToken
argument_list|()
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_TAB
condition|)
block|{
name|child0
operator|=
operator|(
name|ASTNode
operator|)
name|child0
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|child0
operator|.
name|getToken
argument_list|()
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_TABNAME
condition|)
block|{
name|child1
operator|=
operator|(
name|ASTNode
operator|)
name|tree
operator|.
name|getChild
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|child1
operator|.
name|getToken
argument_list|()
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|KW_PARTIALSCAN
condition|)
block|{
name|this
operator|.
name|partialscan
operator|=
literal|true
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
specifier|public
name|QB
name|getQB
parameter_list|()
block|{
return|return
name|qb
return|;
block|}
specifier|public
name|void
name|setQB
parameter_list|(
name|QB
name|qb
parameter_list|)
block|{
name|this
operator|.
name|qb
operator|=
name|qb
expr_stmt|;
block|}
comment|//--------------------------- PTF handling -----------------------------------
comment|/*    * - a partitionTableFunctionSource can be a tableReference, a SubQuery or another    *   PTF invocation.    * - For a TABLEREF: set the source to the alias returned by processTable    * - For a SubQuery: set the source to the alias returned by processSubQuery    * - For a PTF invocation: recursively call processPTFChain.    */
specifier|private
name|PTFInputSpec
name|processPTFSource
parameter_list|(
name|QB
name|qb
parameter_list|,
name|ASTNode
name|inputNode
parameter_list|)
throws|throws
name|SemanticException
block|{
name|PTFInputSpec
name|qInSpec
init|=
literal|null
decl_stmt|;
name|int
name|type
init|=
name|inputNode
operator|.
name|getType
argument_list|()
decl_stmt|;
name|String
name|alias
decl_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|HiveParser
operator|.
name|TOK_TABREF
case|:
name|alias
operator|=
name|processTable
argument_list|(
name|qb
argument_list|,
name|inputNode
argument_list|)
expr_stmt|;
name|qInSpec
operator|=
operator|new
name|PTFQueryInputSpec
argument_list|()
expr_stmt|;
operator|(
operator|(
name|PTFQueryInputSpec
operator|)
name|qInSpec
operator|)
operator|.
name|setType
argument_list|(
name|PTFQueryInputType
operator|.
name|TABLE
argument_list|)
expr_stmt|;
operator|(
operator|(
name|PTFQueryInputSpec
operator|)
name|qInSpec
operator|)
operator|.
name|setSource
argument_list|(
name|alias
argument_list|)
expr_stmt|;
break|break;
case|case
name|HiveParser
operator|.
name|TOK_SUBQUERY
case|:
name|alias
operator|=
name|processSubQuery
argument_list|(
name|qb
argument_list|,
name|inputNode
argument_list|)
expr_stmt|;
name|qInSpec
operator|=
operator|new
name|PTFQueryInputSpec
argument_list|()
expr_stmt|;
operator|(
operator|(
name|PTFQueryInputSpec
operator|)
name|qInSpec
operator|)
operator|.
name|setType
argument_list|(
name|PTFQueryInputType
operator|.
name|SUBQUERY
argument_list|)
expr_stmt|;
operator|(
operator|(
name|PTFQueryInputSpec
operator|)
name|qInSpec
operator|)
operator|.
name|setSource
argument_list|(
name|alias
argument_list|)
expr_stmt|;
break|break;
case|case
name|HiveParser
operator|.
name|TOK_PTBLFUNCTION
case|:
name|qInSpec
operator|=
name|processPTFChain
argument_list|(
name|qb
argument_list|,
name|inputNode
argument_list|)
expr_stmt|;
break|break;
default|default:
throw|throw
operator|new
name|SemanticException
argument_list|(
name|generateErrorMessage
argument_list|(
name|inputNode
argument_list|,
literal|"Unknown input type to PTF"
argument_list|)
argument_list|)
throw|;
block|}
name|qInSpec
operator|.
name|setAstNode
argument_list|(
name|inputNode
argument_list|)
expr_stmt|;
return|return
name|qInSpec
return|;
block|}
comment|/*    * - tree form is    *   ^(TOK_PTBLFUNCTION name alias? partitionTableFunctionSource partitioningSpec? arguments*)    * - a partitionTableFunctionSource can be a tableReference, a SubQuery or another    *   PTF invocation.    */
specifier|private
name|PartitionedTableFunctionSpec
name|processPTFChain
parameter_list|(
name|QB
name|qb
parameter_list|,
name|ASTNode
name|ptf
parameter_list|)
throws|throws
name|SemanticException
block|{
name|int
name|child_count
init|=
name|ptf
operator|.
name|getChildCount
argument_list|()
decl_stmt|;
if|if
condition|(
name|child_count
operator|<
literal|2
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|generateErrorMessage
argument_list|(
name|ptf
argument_list|,
literal|"Not enough Children "
operator|+
name|child_count
argument_list|)
argument_list|)
throw|;
block|}
name|PartitionedTableFunctionSpec
name|ptfSpec
init|=
operator|new
name|PartitionedTableFunctionSpec
argument_list|()
decl_stmt|;
name|ptfSpec
operator|.
name|setAstNode
argument_list|(
name|ptf
argument_list|)
expr_stmt|;
comment|/*      * name      */
name|ASTNode
name|nameNode
init|=
operator|(
name|ASTNode
operator|)
name|ptf
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|ptfSpec
operator|.
name|setName
argument_list|(
name|nameNode
operator|.
name|getText
argument_list|()
argument_list|)
expr_stmt|;
name|int
name|inputIdx
init|=
literal|1
decl_stmt|;
comment|/*      * alias      */
name|ASTNode
name|secondChild
init|=
operator|(
name|ASTNode
operator|)
name|ptf
operator|.
name|getChild
argument_list|(
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|secondChild
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|Identifier
condition|)
block|{
name|ptfSpec
operator|.
name|setAlias
argument_list|(
name|secondChild
operator|.
name|getText
argument_list|()
argument_list|)
expr_stmt|;
name|inputIdx
operator|++
expr_stmt|;
block|}
comment|/*      * input      */
name|ASTNode
name|inputNode
init|=
operator|(
name|ASTNode
operator|)
name|ptf
operator|.
name|getChild
argument_list|(
name|inputIdx
argument_list|)
decl_stmt|;
name|ptfSpec
operator|.
name|setInput
argument_list|(
name|processPTFSource
argument_list|(
name|qb
argument_list|,
name|inputNode
argument_list|)
argument_list|)
expr_stmt|;
name|int
name|argStartIdx
init|=
name|inputIdx
operator|+
literal|1
decl_stmt|;
comment|/*      * partitioning Spec      */
name|int
name|pSpecIdx
init|=
name|inputIdx
operator|+
literal|1
decl_stmt|;
name|ASTNode
name|pSpecNode
init|=
name|ptf
operator|.
name|getChildCount
argument_list|()
operator|>
name|inputIdx
condition|?
operator|(
name|ASTNode
operator|)
name|ptf
operator|.
name|getChild
argument_list|(
name|pSpecIdx
argument_list|)
else|:
literal|null
decl_stmt|;
if|if
condition|(
name|pSpecNode
operator|!=
literal|null
operator|&&
name|pSpecNode
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_PARTITIONINGSPEC
condition|)
block|{
name|PartitioningSpec
name|partitioning
init|=
name|processPTFPartitionSpec
argument_list|(
name|pSpecNode
argument_list|)
decl_stmt|;
name|ptfSpec
operator|.
name|setPartitioning
argument_list|(
name|partitioning
argument_list|)
expr_stmt|;
name|argStartIdx
operator|++
expr_stmt|;
block|}
comment|/*      * arguments      */
for|for
control|(
name|int
name|i
init|=
name|argStartIdx
init|;
name|i
operator|<
name|ptf
operator|.
name|getChildCount
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|ptfSpec
operator|.
name|addArg
argument_list|(
operator|(
name|ASTNode
operator|)
name|ptf
operator|.
name|getChild
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|ptfSpec
return|;
block|}
comment|/*    * - invoked during FROM AST tree processing, on encountering a PTF invocation.    * - tree form is    *   ^(TOK_PTBLFUNCTION name partitionTableFunctionSource partitioningSpec? arguments*)    * - setup a PTFInvocationSpec for this top level PTF invocation.    */
specifier|private
name|void
name|processPTF
parameter_list|(
name|QB
name|qb
parameter_list|,
name|ASTNode
name|ptf
parameter_list|)
throws|throws
name|SemanticException
block|{
name|PartitionedTableFunctionSpec
name|ptfSpec
init|=
name|processPTFChain
argument_list|(
name|qb
argument_list|,
name|ptf
argument_list|)
decl_stmt|;
if|if
condition|(
name|ptfSpec
operator|.
name|getAlias
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|qb
operator|.
name|addAlias
argument_list|(
name|ptfSpec
operator|.
name|getAlias
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|PTFInvocationSpec
name|spec
init|=
operator|new
name|PTFInvocationSpec
argument_list|()
decl_stmt|;
name|spec
operator|.
name|setFunction
argument_list|(
name|ptfSpec
argument_list|)
expr_stmt|;
name|qb
operator|.
name|addPTFNodeToSpec
argument_list|(
name|ptf
argument_list|,
name|spec
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|handleQueryWindowClauses
parameter_list|(
name|QB
name|qb
parameter_list|,
name|Phase1Ctx
name|ctx_1
parameter_list|,
name|ASTNode
name|node
parameter_list|)
throws|throws
name|SemanticException
block|{
name|WindowingSpec
name|spec
init|=
name|qb
operator|.
name|getWindowingSpec
argument_list|(
name|ctx_1
operator|.
name|dest
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|node
operator|.
name|getChildCount
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|processQueryWindowClause
argument_list|(
name|spec
argument_list|,
operator|(
name|ASTNode
operator|)
name|node
operator|.
name|getChild
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
name|PartitionSpec
name|processPartitionSpec
parameter_list|(
name|ASTNode
name|node
parameter_list|)
block|{
name|PartitionSpec
name|pSpec
init|=
operator|new
name|PartitionSpec
argument_list|()
decl_stmt|;
name|int
name|exprCnt
init|=
name|node
operator|.
name|getChildCount
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|exprCnt
condition|;
name|i
operator|++
control|)
block|{
name|PartitionExpression
name|exprSpec
init|=
operator|new
name|PartitionExpression
argument_list|()
decl_stmt|;
name|exprSpec
operator|.
name|setExpression
argument_list|(
operator|(
name|ASTNode
operator|)
name|node
operator|.
name|getChild
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|pSpec
operator|.
name|addExpression
argument_list|(
name|exprSpec
argument_list|)
expr_stmt|;
block|}
return|return
name|pSpec
return|;
block|}
specifier|private
name|OrderSpec
name|processOrderSpec
parameter_list|(
name|ASTNode
name|sortNode
parameter_list|)
block|{
name|OrderSpec
name|oSpec
init|=
operator|new
name|OrderSpec
argument_list|()
decl_stmt|;
name|int
name|exprCnt
init|=
name|sortNode
operator|.
name|getChildCount
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|exprCnt
condition|;
name|i
operator|++
control|)
block|{
name|OrderExpression
name|exprSpec
init|=
operator|new
name|OrderExpression
argument_list|()
decl_stmt|;
name|exprSpec
operator|.
name|setExpression
argument_list|(
operator|(
name|ASTNode
operator|)
name|sortNode
operator|.
name|getChild
argument_list|(
name|i
argument_list|)
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sortNode
operator|.
name|getChild
argument_list|(
name|i
argument_list|)
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_TABSORTCOLNAMEASC
condition|)
block|{
name|exprSpec
operator|.
name|setOrder
argument_list|(
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|parse
operator|.
name|PTFInvocationSpec
operator|.
name|Order
operator|.
name|ASC
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|exprSpec
operator|.
name|setOrder
argument_list|(
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|parse
operator|.
name|PTFInvocationSpec
operator|.
name|Order
operator|.
name|DESC
argument_list|)
expr_stmt|;
block|}
name|oSpec
operator|.
name|addExpression
argument_list|(
name|exprSpec
argument_list|)
expr_stmt|;
block|}
return|return
name|oSpec
return|;
block|}
specifier|private
name|PartitioningSpec
name|processPTFPartitionSpec
parameter_list|(
name|ASTNode
name|pSpecNode
parameter_list|)
block|{
name|PartitioningSpec
name|partitioning
init|=
operator|new
name|PartitioningSpec
argument_list|()
decl_stmt|;
name|ASTNode
name|firstChild
init|=
operator|(
name|ASTNode
operator|)
name|pSpecNode
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|int
name|type
init|=
name|firstChild
operator|.
name|getType
argument_list|()
decl_stmt|;
name|int
name|exprCnt
decl_stmt|;
if|if
condition|(
name|type
operator|==
name|HiveParser
operator|.
name|TOK_DISTRIBUTEBY
operator|||
name|type
operator|==
name|HiveParser
operator|.
name|TOK_CLUSTERBY
condition|)
block|{
name|PartitionSpec
name|pSpec
init|=
name|processPartitionSpec
argument_list|(
name|firstChild
argument_list|)
decl_stmt|;
name|partitioning
operator|.
name|setPartSpec
argument_list|(
name|pSpec
argument_list|)
expr_stmt|;
name|ASTNode
name|sortNode
init|=
name|pSpecNode
operator|.
name|getChildCount
argument_list|()
operator|>
literal|1
condition|?
operator|(
name|ASTNode
operator|)
name|pSpecNode
operator|.
name|getChild
argument_list|(
literal|1
argument_list|)
else|:
literal|null
decl_stmt|;
if|if
condition|(
name|sortNode
operator|!=
literal|null
condition|)
block|{
name|OrderSpec
name|oSpec
init|=
name|processOrderSpec
argument_list|(
name|sortNode
argument_list|)
decl_stmt|;
name|partitioning
operator|.
name|setOrderSpec
argument_list|(
name|oSpec
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|type
operator|==
name|HiveParser
operator|.
name|TOK_SORTBY
operator|||
name|type
operator|==
name|HiveParser
operator|.
name|TOK_ORDERBY
condition|)
block|{
name|ASTNode
name|sortNode
init|=
name|firstChild
decl_stmt|;
name|OrderSpec
name|oSpec
init|=
name|processOrderSpec
argument_list|(
name|sortNode
argument_list|)
decl_stmt|;
name|partitioning
operator|.
name|setOrderSpec
argument_list|(
name|oSpec
argument_list|)
expr_stmt|;
block|}
return|return
name|partitioning
return|;
block|}
specifier|private
name|WindowFunctionSpec
name|processWindowFunction
parameter_list|(
name|ASTNode
name|node
parameter_list|,
name|ASTNode
name|wsNode
parameter_list|)
throws|throws
name|SemanticException
block|{
name|WindowFunctionSpec
name|wfSpec
init|=
operator|new
name|WindowFunctionSpec
argument_list|()
decl_stmt|;
switch|switch
condition|(
name|node
operator|.
name|getType
argument_list|()
condition|)
block|{
case|case
name|HiveParser
operator|.
name|TOK_FUNCTIONSTAR
case|:
name|wfSpec
operator|.
name|setStar
argument_list|(
literal|true
argument_list|)
expr_stmt|;
break|break;
case|case
name|HiveParser
operator|.
name|TOK_FUNCTIONDI
case|:
name|wfSpec
operator|.
name|setDistinct
argument_list|(
literal|true
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|wfSpec
operator|.
name|isDistinct
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|generateErrorMessage
argument_list|(
name|node
argument_list|,
literal|"Count/Sum distinct not supported with Windowing"
argument_list|)
argument_list|)
throw|;
block|}
name|wfSpec
operator|.
name|setExpression
argument_list|(
name|node
argument_list|)
expr_stmt|;
name|ASTNode
name|nameNode
init|=
operator|(
name|ASTNode
operator|)
name|node
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|wfSpec
operator|.
name|setName
argument_list|(
name|nameNode
operator|.
name|getText
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<
name|node
operator|.
name|getChildCount
argument_list|()
operator|-
literal|1
condition|;
name|i
operator|++
control|)
block|{
name|ASTNode
name|child
init|=
operator|(
name|ASTNode
operator|)
name|node
operator|.
name|getChild
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|wfSpec
operator|.
name|addArg
argument_list|(
name|child
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|wsNode
operator|!=
literal|null
condition|)
block|{
name|WindowSpec
name|ws
init|=
name|processWindowSpec
argument_list|(
name|wsNode
argument_list|)
decl_stmt|;
name|wfSpec
operator|.
name|setWindowSpec
argument_list|(
name|ws
argument_list|)
expr_stmt|;
block|}
return|return
name|wfSpec
return|;
block|}
specifier|private
name|boolean
name|containsLeadLagUDF
parameter_list|(
name|ASTNode
name|expressionTree
parameter_list|)
block|{
name|int
name|exprTokenType
init|=
name|expressionTree
operator|.
name|getToken
argument_list|()
operator|.
name|getType
argument_list|()
decl_stmt|;
if|if
condition|(
name|exprTokenType
operator|==
name|HiveParser
operator|.
name|TOK_FUNCTION
condition|)
block|{
assert|assert
operator|(
name|expressionTree
operator|.
name|getChildCount
argument_list|()
operator|!=
literal|0
operator|)
assert|;
if|if
condition|(
name|expressionTree
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|Identifier
condition|)
block|{
name|String
name|functionName
init|=
name|unescapeIdentifier
argument_list|(
name|expressionTree
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getText
argument_list|()
argument_list|)
decl_stmt|;
name|functionName
operator|=
name|functionName
operator|.
name|toLowerCase
argument_list|()
expr_stmt|;
if|if
condition|(
name|FunctionRegistry
operator|.
name|LAG_FUNC_NAME
operator|.
name|equals
argument_list|(
name|functionName
argument_list|)
operator|||
name|FunctionRegistry
operator|.
name|LEAD_FUNC_NAME
operator|.
name|equals
argument_list|(
name|functionName
argument_list|)
condition|)
block|{
return|return
literal|true
return|;
block|}
block|}
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|expressionTree
operator|.
name|getChildCount
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|containsLeadLagUDF
argument_list|(
operator|(
name|ASTNode
operator|)
name|expressionTree
operator|.
name|getChild
argument_list|(
name|i
argument_list|)
argument_list|)
condition|)
block|{
return|return
literal|true
return|;
block|}
block|}
return|return
literal|false
return|;
block|}
specifier|private
name|void
name|processQueryWindowClause
parameter_list|(
name|WindowingSpec
name|spec
parameter_list|,
name|ASTNode
name|node
parameter_list|)
throws|throws
name|SemanticException
block|{
name|ASTNode
name|nameNode
init|=
operator|(
name|ASTNode
operator|)
name|node
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|ASTNode
name|wsNode
init|=
operator|(
name|ASTNode
operator|)
name|node
operator|.
name|getChild
argument_list|(
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|spec
operator|.
name|getWindowSpecs
argument_list|()
operator|!=
literal|null
operator|&&
name|spec
operator|.
name|getWindowSpecs
argument_list|()
operator|.
name|containsKey
argument_list|(
name|nameNode
operator|.
name|getText
argument_list|()
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|generateErrorMessage
argument_list|(
name|nameNode
argument_list|,
literal|"Duplicate definition of window "
operator|+
name|nameNode
operator|.
name|getText
argument_list|()
operator|+
literal|" is not allowed"
argument_list|)
argument_list|)
throw|;
block|}
name|WindowSpec
name|ws
init|=
name|processWindowSpec
argument_list|(
name|wsNode
argument_list|)
decl_stmt|;
name|spec
operator|.
name|addWindowSpec
argument_list|(
name|nameNode
operator|.
name|getText
argument_list|()
argument_list|,
name|ws
argument_list|)
expr_stmt|;
block|}
specifier|private
name|WindowSpec
name|processWindowSpec
parameter_list|(
name|ASTNode
name|node
parameter_list|)
throws|throws
name|SemanticException
block|{
name|String
name|sourceId
init|=
literal|null
decl_stmt|;
name|PartitionSpec
name|partition
init|=
literal|null
decl_stmt|;
name|OrderSpec
name|order
init|=
literal|null
decl_stmt|;
name|WindowFrameSpec
name|windowFrame
init|=
literal|null
decl_stmt|;
name|boolean
name|hasSrcId
init|=
literal|false
decl_stmt|,
name|hasPartSpec
init|=
literal|false
decl_stmt|,
name|hasWF
init|=
literal|false
decl_stmt|;
name|int
name|srcIdIdx
init|=
operator|-
literal|1
decl_stmt|,
name|partIdx
init|=
operator|-
literal|1
decl_stmt|,
name|wfIdx
init|=
operator|-
literal|1
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|node
operator|.
name|getChildCount
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|int
name|type
init|=
name|node
operator|.
name|getChild
argument_list|(
name|i
argument_list|)
operator|.
name|getType
argument_list|()
decl_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|HiveParser
operator|.
name|Identifier
case|:
name|hasSrcId
operator|=
literal|true
expr_stmt|;
name|srcIdIdx
operator|=
name|i
expr_stmt|;
break|break;
case|case
name|HiveParser
operator|.
name|TOK_PARTITIONINGSPEC
case|:
name|hasPartSpec
operator|=
literal|true
expr_stmt|;
name|partIdx
operator|=
name|i
expr_stmt|;
break|break;
case|case
name|HiveParser
operator|.
name|TOK_WINDOWRANGE
case|:
case|case
name|HiveParser
operator|.
name|TOK_WINDOWVALUES
case|:
name|hasWF
operator|=
literal|true
expr_stmt|;
name|wfIdx
operator|=
name|i
expr_stmt|;
break|break;
block|}
block|}
name|WindowSpec
name|ws
init|=
operator|new
name|WindowSpec
argument_list|()
decl_stmt|;
if|if
condition|(
name|hasSrcId
condition|)
block|{
name|ASTNode
name|nameNode
init|=
operator|(
name|ASTNode
operator|)
name|node
operator|.
name|getChild
argument_list|(
name|srcIdIdx
argument_list|)
decl_stmt|;
name|ws
operator|.
name|setSourceId
argument_list|(
name|nameNode
operator|.
name|getText
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|hasPartSpec
condition|)
block|{
name|ASTNode
name|partNode
init|=
operator|(
name|ASTNode
operator|)
name|node
operator|.
name|getChild
argument_list|(
name|partIdx
argument_list|)
decl_stmt|;
name|PartitioningSpec
name|partitioning
init|=
name|processPTFPartitionSpec
argument_list|(
name|partNode
argument_list|)
decl_stmt|;
name|ws
operator|.
name|setPartitioning
argument_list|(
name|partitioning
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|hasWF
condition|)
block|{
name|ASTNode
name|wfNode
init|=
operator|(
name|ASTNode
operator|)
name|node
operator|.
name|getChild
argument_list|(
name|wfIdx
argument_list|)
decl_stmt|;
name|WindowFrameSpec
name|wfSpec
init|=
name|processWindowFrame
argument_list|(
name|wfNode
argument_list|)
decl_stmt|;
name|ws
operator|.
name|setWindowFrame
argument_list|(
name|wfSpec
argument_list|)
expr_stmt|;
block|}
return|return
name|ws
return|;
block|}
specifier|private
name|WindowFrameSpec
name|processWindowFrame
parameter_list|(
name|ASTNode
name|node
parameter_list|)
throws|throws
name|SemanticException
block|{
name|int
name|type
init|=
name|node
operator|.
name|getType
argument_list|()
decl_stmt|;
name|BoundarySpec
name|start
init|=
literal|null
decl_stmt|,
name|end
init|=
literal|null
decl_stmt|;
comment|/*      * A WindowFrame may contain just the Start Boundary or in the      * between style of expressing a WindowFrame both boundaries      * are specified.      */
name|start
operator|=
name|processBoundary
argument_list|(
name|type
argument_list|,
operator|(
name|ASTNode
operator|)
name|node
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|node
operator|.
name|getChildCount
argument_list|()
operator|>
literal|1
condition|)
block|{
name|end
operator|=
name|processBoundary
argument_list|(
name|type
argument_list|,
operator|(
name|ASTNode
operator|)
name|node
operator|.
name|getChild
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
operator|new
name|WindowFrameSpec
argument_list|(
name|start
argument_list|,
name|end
argument_list|)
return|;
block|}
specifier|private
name|BoundarySpec
name|processBoundary
parameter_list|(
name|int
name|frameType
parameter_list|,
name|ASTNode
name|node
parameter_list|)
throws|throws
name|SemanticException
block|{
name|BoundarySpec
name|bs
init|=
name|frameType
operator|==
name|HiveParser
operator|.
name|TOK_WINDOWRANGE
condition|?
operator|new
name|RangeBoundarySpec
argument_list|()
else|:
operator|new
name|ValueBoundarySpec
argument_list|()
decl_stmt|;
name|int
name|type
init|=
name|node
operator|.
name|getType
argument_list|()
decl_stmt|;
name|boolean
name|hasAmt
init|=
literal|true
decl_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|HiveParser
operator|.
name|KW_PRECEDING
case|:
name|bs
operator|.
name|setDirection
argument_list|(
name|Direction
operator|.
name|PRECEDING
argument_list|)
expr_stmt|;
break|break;
case|case
name|HiveParser
operator|.
name|KW_FOLLOWING
case|:
name|bs
operator|.
name|setDirection
argument_list|(
name|Direction
operator|.
name|FOLLOWING
argument_list|)
expr_stmt|;
break|break;
case|case
name|HiveParser
operator|.
name|KW_CURRENT
case|:
name|bs
operator|=
operator|new
name|CurrentRowSpec
argument_list|()
expr_stmt|;
name|hasAmt
operator|=
literal|false
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|hasAmt
condition|)
block|{
name|ASTNode
name|amtNode
init|=
operator|(
name|ASTNode
operator|)
name|node
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|amtNode
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|KW_UNBOUNDED
condition|)
block|{
name|bs
operator|.
name|setAmt
argument_list|(
name|BoundarySpec
operator|.
name|UNBOUNDED_AMOUNT
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|int
name|amt
init|=
name|Integer
operator|.
name|parseInt
argument_list|(
name|amtNode
operator|.
name|getText
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|amt
operator|<
literal|0
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
literal|"Window Frame Boundary Amount must be a +ve integer, amount provide is: "
operator|+
name|amt
argument_list|)
throw|;
block|}
name|bs
operator|.
name|setAmt
argument_list|(
name|amt
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|bs
return|;
block|}
comment|/*    * check if a Select Expr is a constant.    * - current logic used is to look for HiveParser.TOK_TABLE_OR_COL    * - if there is none then the expression is a constant.    */
specifier|private
specifier|static
class|class
name|ConstantExprCheck
implements|implements
name|ContextVisitor
block|{
name|boolean
name|isConstant
init|=
literal|true
decl_stmt|;
specifier|public
name|void
name|visit
parameter_list|(
name|Object
name|t
parameter_list|,
name|Object
name|parent
parameter_list|,
name|int
name|childIndex
parameter_list|,
name|Map
name|labels
parameter_list|)
block|{
if|if
condition|(
operator|!
name|isConstant
condition|)
block|{
return|return;
block|}
name|ASTNode
name|node
init|=
operator|(
name|ASTNode
operator|)
name|t
decl_stmt|;
if|if
condition|(
name|ParseDriver
operator|.
name|adaptor
operator|.
name|getType
argument_list|(
name|t
argument_list|)
operator|==
name|HiveParser
operator|.
name|TOK_TABLE_OR_COL
condition|)
block|{
name|isConstant
operator|=
literal|false
expr_stmt|;
block|}
block|}
specifier|public
name|void
name|reset
parameter_list|()
block|{
name|isConstant
operator|=
literal|true
expr_stmt|;
block|}
specifier|protected
name|boolean
name|isConstant
parameter_list|()
block|{
return|return
name|isConstant
return|;
block|}
block|}
specifier|private
specifier|static
class|class
name|AggregationExprCheck
implements|implements
name|ContextVisitor
block|{
name|HashMap
argument_list|<
name|String
argument_list|,
name|ASTNode
argument_list|>
name|destAggrExprs
decl_stmt|;
name|boolean
name|isAggr
init|=
literal|false
decl_stmt|;
specifier|public
name|AggregationExprCheck
parameter_list|(
name|HashMap
argument_list|<
name|String
argument_list|,
name|ASTNode
argument_list|>
name|destAggrExprs
parameter_list|)
block|{
name|super
argument_list|()
expr_stmt|;
name|this
operator|.
name|destAggrExprs
operator|=
name|destAggrExprs
expr_stmt|;
block|}
specifier|public
name|void
name|visit
parameter_list|(
name|Object
name|t
parameter_list|,
name|Object
name|parent
parameter_list|,
name|int
name|childIndex
parameter_list|,
name|Map
name|labels
parameter_list|)
block|{
if|if
condition|(
name|isAggr
condition|)
block|{
return|return;
block|}
if|if
condition|(
name|destAggrExprs
operator|.
name|values
argument_list|()
operator|.
name|contains
argument_list|(
name|t
argument_list|)
condition|)
block|{
name|isAggr
operator|=
literal|true
expr_stmt|;
block|}
block|}
specifier|public
name|void
name|reset
parameter_list|()
block|{
name|isAggr
operator|=
literal|false
expr_stmt|;
block|}
specifier|protected
name|boolean
name|isAggr
parameter_list|()
block|{
return|return
name|isAggr
return|;
block|}
block|}
comment|/*    * Returns false if there is a SelectExpr that is not a constant or an aggr.    *    */
specifier|private
name|boolean
name|isValidGroupBySelectList
parameter_list|(
name|QB
name|currQB
parameter_list|,
name|String
name|clause
parameter_list|)
block|{
name|ConstantExprCheck
name|constantExprCheck
init|=
operator|new
name|ConstantExprCheck
argument_list|()
decl_stmt|;
name|AggregationExprCheck
name|aggrExprCheck
init|=
operator|new
name|AggregationExprCheck
argument_list|(
name|currQB
operator|.
name|getParseInfo
argument_list|()
operator|.
name|getAggregationExprsForClause
argument_list|(
name|clause
argument_list|)
argument_list|)
decl_stmt|;
name|TreeWizard
name|tw
init|=
operator|new
name|TreeWizard
argument_list|(
name|ParseDriver
operator|.
name|adaptor
argument_list|,
name|HiveParser
operator|.
name|tokenNames
argument_list|)
decl_stmt|;
name|ASTNode
name|selectNode
init|=
name|currQB
operator|.
name|getParseInfo
argument_list|()
operator|.
name|getSelForClause
argument_list|(
name|clause
argument_list|)
decl_stmt|;
comment|/*      * for Select Distinct Queries we don't move any aggregations.      */
if|if
condition|(
name|selectNode
operator|!=
literal|null
operator|&&
name|selectNode
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_SELECTDI
condition|)
block|{
return|return
literal|true
return|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|selectNode
operator|!=
literal|null
operator|&&
name|i
operator|<
name|selectNode
operator|.
name|getChildCount
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|ASTNode
name|selectExpr
init|=
operator|(
name|ASTNode
operator|)
name|selectNode
operator|.
name|getChild
argument_list|(
name|i
argument_list|)
decl_stmt|;
comment|//check for TOK_HINTLIST expressions on ast
if|if
condition|(
name|selectExpr
operator|.
name|getType
argument_list|()
operator|!=
name|HiveParser
operator|.
name|TOK_SELEXPR
condition|)
block|{
continue|continue;
block|}
name|constantExprCheck
operator|.
name|reset
argument_list|()
expr_stmt|;
name|PTFTranslator
operator|.
name|visit
argument_list|(
name|selectExpr
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
argument_list|,
name|constantExprCheck
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|constantExprCheck
operator|.
name|isConstant
argument_list|()
condition|)
block|{
name|aggrExprCheck
operator|.
name|reset
argument_list|()
expr_stmt|;
name|PTFTranslator
operator|.
name|visit
argument_list|(
name|selectExpr
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
argument_list|,
name|aggrExprCheck
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|aggrExprCheck
operator|.
name|isAggr
argument_list|()
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
block|}
return|return
literal|true
return|;
block|}
comment|//--------------------------- PTF handling: PTFInvocationSpec to PTFDesc --------------------------
specifier|private
name|PTFDesc
name|translatePTFInvocationSpec
parameter_list|(
name|PTFInvocationSpec
name|ptfQSpec
parameter_list|,
name|RowResolver
name|inputRR
parameter_list|)
throws|throws
name|SemanticException
block|{
name|PTFDesc
name|ptfDesc
init|=
literal|null
decl_stmt|;
name|PTFTranslator
name|translator
init|=
operator|new
name|PTFTranslator
argument_list|()
decl_stmt|;
name|ptfDesc
operator|=
name|translator
operator|.
name|translate
argument_list|(
name|ptfQSpec
argument_list|,
name|this
argument_list|,
name|conf
argument_list|,
name|inputRR
argument_list|,
name|unparseTranslator
argument_list|)
expr_stmt|;
return|return
name|ptfDesc
return|;
block|}
name|Operator
name|genPTFPlan
parameter_list|(
name|PTFInvocationSpec
name|ptfQSpec
parameter_list|,
name|Operator
name|input
parameter_list|)
throws|throws
name|SemanticException
block|{
name|ArrayList
argument_list|<
name|PTFInvocationSpec
argument_list|>
name|componentQueries
init|=
name|PTFTranslator
operator|.
name|componentize
argument_list|(
name|ptfQSpec
argument_list|)
decl_stmt|;
for|for
control|(
name|PTFInvocationSpec
name|ptfSpec
range|:
name|componentQueries
control|)
block|{
name|input
operator|=
name|genPTFPlanForComponentQuery
argument_list|(
name|ptfSpec
argument_list|,
name|input
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Created PTF Plan "
argument_list|)
expr_stmt|;
block|}
return|return
name|input
return|;
block|}
comment|/**    * Construct the data structures containing ExprNodeDesc for partition    * columns and order columns. Use the input definition to construct the list    * of output columns for the ReduceSinkOperator    *    * @throws SemanticException    */
name|void
name|buildPTFReduceSinkDetails
parameter_list|(
name|PartitionedTableFunctionDef
name|tabDef
parameter_list|,
name|RowResolver
name|inputRR
parameter_list|,
name|ArrayList
argument_list|<
name|ExprNodeDesc
argument_list|>
name|partCols
parameter_list|,
name|ArrayList
argument_list|<
name|ExprNodeDesc
argument_list|>
name|valueCols
parameter_list|,
name|ArrayList
argument_list|<
name|ExprNodeDesc
argument_list|>
name|orderCols
parameter_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|ExprNodeDesc
argument_list|>
name|colExprMap
parameter_list|,
name|List
argument_list|<
name|String
argument_list|>
name|outputColumnNames
parameter_list|,
name|StringBuilder
name|orderString
parameter_list|,
name|RowResolver
name|rsOpRR
parameter_list|,
name|RowResolver
name|extractRR
parameter_list|)
throws|throws
name|SemanticException
block|{
name|List
argument_list|<
name|PTFExpressionDef
argument_list|>
name|partColList
init|=
name|tabDef
operator|.
name|getPartition
argument_list|()
operator|.
name|getExpressions
argument_list|()
decl_stmt|;
for|for
control|(
name|PTFExpressionDef
name|colDef
range|:
name|partColList
control|)
block|{
name|partCols
operator|.
name|add
argument_list|(
name|colDef
operator|.
name|getExprNode
argument_list|()
argument_list|)
expr_stmt|;
name|orderCols
operator|.
name|add
argument_list|(
name|colDef
operator|.
name|getExprNode
argument_list|()
argument_list|)
expr_stmt|;
name|orderString
operator|.
name|append
argument_list|(
literal|'+'
argument_list|)
expr_stmt|;
block|}
comment|/*      * Order columns are used as key columns for constructing      * the ReduceSinkOperator      * Since we do not explicitly add these to outputColumnNames,      * we need to set includeKeyCols = false while creating the      * ReduceSinkDesc      */
name|List
argument_list|<
name|OrderExpressionDef
argument_list|>
name|orderColList
init|=
name|tabDef
operator|.
name|getOrder
argument_list|()
operator|.
name|getExpressions
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|orderColList
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|OrderExpressionDef
name|colDef
init|=
name|orderColList
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|parse
operator|.
name|PTFInvocationSpec
operator|.
name|Order
name|order
init|=
name|colDef
operator|.
name|getOrder
argument_list|()
decl_stmt|;
if|if
condition|(
name|order
operator|.
name|name
argument_list|()
operator|.
name|equals
argument_list|(
literal|"ASC"
argument_list|)
condition|)
block|{
name|orderString
operator|.
name|append
argument_list|(
literal|'+'
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|orderString
operator|.
name|append
argument_list|(
literal|'-'
argument_list|)
expr_stmt|;
block|}
name|orderCols
operator|.
name|add
argument_list|(
name|colDef
operator|.
name|getExprNode
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|ArrayList
argument_list|<
name|ColumnInfo
argument_list|>
name|colInfoList
init|=
name|inputRR
operator|.
name|getColumnInfos
argument_list|()
decl_stmt|;
comment|/*      * construct the ReduceSinkRR      */
name|int
name|pos
init|=
literal|0
decl_stmt|;
for|for
control|(
name|ColumnInfo
name|colInfo
range|:
name|colInfoList
control|)
block|{
name|ExprNodeDesc
name|valueColExpr
init|=
operator|new
name|ExprNodeColumnDesc
argument_list|(
name|colInfo
operator|.
name|getType
argument_list|()
argument_list|,
name|colInfo
operator|.
name|getInternalName
argument_list|()
argument_list|,
name|colInfo
operator|.
name|getTabAlias
argument_list|()
argument_list|,
name|colInfo
operator|.
name|getIsVirtualCol
argument_list|()
argument_list|)
decl_stmt|;
name|valueCols
operator|.
name|add
argument_list|(
name|valueColExpr
argument_list|)
expr_stmt|;
name|colExprMap
operator|.
name|put
argument_list|(
name|colInfo
operator|.
name|getInternalName
argument_list|()
argument_list|,
name|valueColExpr
argument_list|)
expr_stmt|;
name|String
name|outColName
init|=
name|SemanticAnalyzer
operator|.
name|getColumnInternalName
argument_list|(
name|pos
operator|++
argument_list|)
decl_stmt|;
name|outputColumnNames
operator|.
name|add
argument_list|(
name|outColName
argument_list|)
expr_stmt|;
name|String
index|[]
name|alias
init|=
name|inputRR
operator|.
name|reverseLookup
argument_list|(
name|colInfo
operator|.
name|getInternalName
argument_list|()
argument_list|)
decl_stmt|;
name|ColumnInfo
name|newColInfo
init|=
operator|new
name|ColumnInfo
argument_list|(
name|outColName
argument_list|,
name|colInfo
operator|.
name|getType
argument_list|()
argument_list|,
name|alias
index|[
literal|0
index|]
argument_list|,
name|colInfo
operator|.
name|getIsVirtualCol
argument_list|()
argument_list|,
name|colInfo
operator|.
name|isHiddenVirtualCol
argument_list|()
argument_list|)
decl_stmt|;
name|rsOpRR
operator|.
name|put
argument_list|(
name|alias
index|[
literal|0
index|]
argument_list|,
name|alias
index|[
literal|1
index|]
argument_list|,
name|newColInfo
argument_list|)
expr_stmt|;
block|}
comment|/*      * construct the ExtractRR      */
name|LinkedHashMap
argument_list|<
name|String
index|[]
argument_list|,
name|ColumnInfo
argument_list|>
name|colsAddedByHaving
init|=
operator|new
name|LinkedHashMap
argument_list|<
name|String
index|[]
argument_list|,
name|ColumnInfo
argument_list|>
argument_list|()
decl_stmt|;
name|pos
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|ColumnInfo
name|colInfo
range|:
name|colInfoList
control|)
block|{
name|String
index|[]
name|alias
init|=
name|inputRR
operator|.
name|reverseLookup
argument_list|(
name|colInfo
operator|.
name|getInternalName
argument_list|()
argument_list|)
decl_stmt|;
comment|/*        * if we have already encountered this colInfo internalName.        * We encounter it again because it must be put for the Having clause.        * We will add these entries in the end; in a loop on colsAddedByHaving. See below.        */
if|if
condition|(
name|colsAddedByHaving
operator|.
name|containsKey
argument_list|(
name|alias
argument_list|)
condition|)
block|{
continue|continue;
block|}
name|ASTNode
name|astNode
init|=
name|PTFTranslator
operator|.
name|getASTNode
argument_list|(
name|colInfo
argument_list|,
name|inputRR
argument_list|)
decl_stmt|;
name|ColumnInfo
name|eColInfo
init|=
operator|new
name|ColumnInfo
argument_list|(
name|SemanticAnalyzer
operator|.
name|getColumnInternalName
argument_list|(
name|pos
operator|++
argument_list|)
argument_list|,
name|colInfo
operator|.
name|getType
argument_list|()
argument_list|,
name|alias
index|[
literal|0
index|]
argument_list|,
name|colInfo
operator|.
name|getIsVirtualCol
argument_list|()
argument_list|,
name|colInfo
operator|.
name|isHiddenVirtualCol
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|astNode
operator|==
literal|null
condition|)
block|{
name|extractRR
operator|.
name|put
argument_list|(
name|alias
index|[
literal|0
index|]
argument_list|,
name|alias
index|[
literal|1
index|]
argument_list|,
name|eColInfo
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/*          * in case having clause refers to this column may have been added twice;          * once with the ASTNode.toStringTree as the alias          * and then with the real alias.          */
name|extractRR
operator|.
name|putExpression
argument_list|(
name|astNode
argument_list|,
name|eColInfo
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|astNode
operator|.
name|toStringTree
argument_list|()
operator|.
name|toLowerCase
argument_list|()
operator|.
name|equals
argument_list|(
name|alias
index|[
literal|1
index|]
argument_list|)
condition|)
block|{
name|colsAddedByHaving
operator|.
name|put
argument_list|(
name|alias
argument_list|,
name|eColInfo
argument_list|)
expr_stmt|;
block|}
block|}
block|}
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|String
index|[]
argument_list|,
name|ColumnInfo
argument_list|>
name|columnAddedByHaving
range|:
name|colsAddedByHaving
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|String
index|[]
name|alias
init|=
name|columnAddedByHaving
operator|.
name|getKey
argument_list|()
decl_stmt|;
name|ColumnInfo
name|eColInfo
init|=
name|columnAddedByHaving
operator|.
name|getValue
argument_list|()
decl_stmt|;
name|extractRR
operator|.
name|put
argument_list|(
name|alias
index|[
literal|0
index|]
argument_list|,
name|alias
index|[
literal|1
index|]
argument_list|,
name|eColInfo
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
name|Operator
name|genPTFPlanForComponentQuery
parameter_list|(
name|PTFInvocationSpec
name|ptfQSpec
parameter_list|,
name|Operator
name|input
parameter_list|)
throws|throws
name|SemanticException
block|{
comment|/*      * 1. Create the PTFDesc from the Qspec attached to this QB.      */
name|RowResolver
name|rr
init|=
name|opParseCtx
operator|.
name|get
argument_list|(
name|input
argument_list|)
operator|.
name|getRowResolver
argument_list|()
decl_stmt|;
name|PTFDesc
name|ptfDesc
init|=
name|translatePTFInvocationSpec
argument_list|(
name|ptfQSpec
argument_list|,
name|rr
argument_list|)
decl_stmt|;
name|RowResolver
name|rsOpRR
init|=
operator|new
name|RowResolver
argument_list|()
decl_stmt|;
comment|/*      * Build an RR for the Extract Op from the ResuceSink Op's RR.      * Why?      * We need to remove the Virtual Columns present in the RS's RR. The OI      * that gets passed to Extract at runtime doesn't contain the Virtual Columns.      * So internal names get changed. Consider testCase testJoinWithLeadLag,      * which is a self join on part and also has a Windowing expression.      * The RR of the RS op at transaltion time looks something like this:      * (_co1,_col2,..,_col7, _col8(vc=true),_col9(vc=true),      * _col10,_col11,.._col15(vc=true),_col16(vc=true),..)      * At runtime the Virtual columns are removed and all the columns after _col7      * are shifted 1 or 2 positions.      * So in child Operators ColumnExprNodeDesc's are no longer referring to the right columns.      *      * So we build a new RR for the Extract Op, with the Virtual Columns removed.      * We hand this to the PTFTranslator as the      * starting RR to use to translate a PTF Chain.      */
name|RowResolver
name|extractOpRR
init|=
operator|new
name|RowResolver
argument_list|()
decl_stmt|;
comment|/*      * 2. build Map-side Op Graph. Graph template is either:      * Input -> PTF_map -> ReduceSink      * or      * Input -> ReduceSink      *      * Here the ExprNodeDescriptors in the QueryDef are based on the Input Operator's RR.      */
block|{
name|PartitionedTableFunctionDef
name|tabDef
init|=
name|ptfDesc
operator|.
name|getStartOfChain
argument_list|()
decl_stmt|;
comment|/*        * a. add Map-side PTF Operator if needed        */
if|if
condition|(
name|tabDef
operator|.
name|isTransformsRawInput
argument_list|()
condition|)
block|{
name|RowResolver
name|ptfMapRR
init|=
name|tabDef
operator|.
name|getRawInputShape
argument_list|()
operator|.
name|getRr
argument_list|()
decl_stmt|;
name|ptfDesc
operator|.
name|setMapSide
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|input
operator|=
name|putOpInsertMap
argument_list|(
name|OperatorFactory
operator|.
name|getAndMakeChild
argument_list|(
name|ptfDesc
argument_list|,
operator|new
name|RowSchema
argument_list|(
name|ptfMapRR
operator|.
name|getColumnInfos
argument_list|()
argument_list|)
argument_list|,
name|input
argument_list|)
argument_list|,
name|ptfMapRR
argument_list|)
expr_stmt|;
name|rr
operator|=
name|opParseCtx
operator|.
name|get
argument_list|(
name|input
argument_list|)
operator|.
name|getRowResolver
argument_list|()
expr_stmt|;
block|}
comment|/*        * b. Build Reduce Sink Details (keyCols, valueCols, outColNames etc.) for this ptfDesc.        */
name|ArrayList
argument_list|<
name|ExprNodeDesc
argument_list|>
name|partCols
init|=
operator|new
name|ArrayList
argument_list|<
name|ExprNodeDesc
argument_list|>
argument_list|()
decl_stmt|;
name|ArrayList
argument_list|<
name|ExprNodeDesc
argument_list|>
name|valueCols
init|=
operator|new
name|ArrayList
argument_list|<
name|ExprNodeDesc
argument_list|>
argument_list|()
decl_stmt|;
name|ArrayList
argument_list|<
name|ExprNodeDesc
argument_list|>
name|orderCols
init|=
operator|new
name|ArrayList
argument_list|<
name|ExprNodeDesc
argument_list|>
argument_list|()
decl_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|ExprNodeDesc
argument_list|>
name|colExprMap
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|ExprNodeDesc
argument_list|>
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|outputColumnNames
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
name|StringBuilder
name|orderString
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
comment|/*        * Use the input RR of TableScanOperator in case there is no map-side        * reshape of input.        * If the parent of ReduceSinkOperator is PTFOperator, use it's        * output RR.        */
name|buildPTFReduceSinkDetails
argument_list|(
name|tabDef
argument_list|,
name|rr
argument_list|,
name|partCols
argument_list|,
name|valueCols
argument_list|,
name|orderCols
argument_list|,
name|colExprMap
argument_list|,
name|outputColumnNames
argument_list|,
name|orderString
argument_list|,
name|rsOpRR
argument_list|,
name|extractOpRR
argument_list|)
expr_stmt|;
name|input
operator|=
name|putOpInsertMap
argument_list|(
name|OperatorFactory
operator|.
name|getAndMakeChild
argument_list|(
name|PlanUtils
operator|.
name|getReduceSinkDesc
argument_list|(
name|orderCols
argument_list|,
name|valueCols
argument_list|,
name|outputColumnNames
argument_list|,
literal|false
argument_list|,
operator|-
literal|1
argument_list|,
name|partCols
argument_list|,
name|orderString
operator|.
name|toString
argument_list|()
argument_list|,
operator|-
literal|1
argument_list|)
argument_list|,
operator|new
name|RowSchema
argument_list|(
name|rsOpRR
operator|.
name|getColumnInfos
argument_list|()
argument_list|)
argument_list|,
name|input
argument_list|)
argument_list|,
name|rsOpRR
argument_list|)
expr_stmt|;
name|input
operator|.
name|setColumnExprMap
argument_list|(
name|colExprMap
argument_list|)
expr_stmt|;
block|}
comment|/*      * 3. build Reduce-side Op Graph      */
block|{
comment|/*        * b. Construct Extract Operator.        */
name|input
operator|=
name|putOpInsertMap
argument_list|(
name|OperatorFactory
operator|.
name|getAndMakeChild
argument_list|(
operator|new
name|ExtractDesc
argument_list|(
operator|new
name|ExprNodeColumnDesc
argument_list|(
name|TypeInfoFactory
operator|.
name|stringTypeInfo
argument_list|,
name|Utilities
operator|.
name|ReduceField
operator|.
name|VALUE
operator|.
name|toString
argument_list|()
argument_list|,
literal|""
argument_list|,
literal|false
argument_list|)
argument_list|)
argument_list|,
operator|new
name|RowSchema
argument_list|(
name|extractOpRR
operator|.
name|getColumnInfos
argument_list|()
argument_list|)
argument_list|,
name|input
argument_list|)
argument_list|,
name|extractOpRR
argument_list|)
expr_stmt|;
comment|/*        * c. Rebuilt the QueryDef.        * Why?        * - so that the ExprNodeDescriptors in the QueryDef are based on the        *   Extract Operator's RowResolver        */
name|rr
operator|=
name|opParseCtx
operator|.
name|get
argument_list|(
name|input
argument_list|)
operator|.
name|getRowResolver
argument_list|()
expr_stmt|;
name|ptfDesc
operator|=
name|translatePTFInvocationSpec
argument_list|(
name|ptfQSpec
argument_list|,
name|rr
argument_list|)
expr_stmt|;
comment|/*        * d. Construct PTF Operator.        */
name|RowResolver
name|ptfOpRR
init|=
name|ptfDesc
operator|.
name|getFuncDef
argument_list|()
operator|.
name|getOutputShape
argument_list|()
operator|.
name|getRr
argument_list|()
decl_stmt|;
name|input
operator|=
name|putOpInsertMap
argument_list|(
name|OperatorFactory
operator|.
name|getAndMakeChild
argument_list|(
name|ptfDesc
argument_list|,
operator|new
name|RowSchema
argument_list|(
name|ptfOpRR
operator|.
name|getColumnInfos
argument_list|()
argument_list|)
argument_list|,
name|input
argument_list|)
argument_list|,
name|ptfOpRR
argument_list|)
expr_stmt|;
block|}
return|return
name|input
return|;
block|}
comment|//--------------------------- Windowing handling: PTFInvocationSpec to PTFDesc --------------------
name|Operator
name|genWindowingPlan
parameter_list|(
name|WindowingSpec
name|wSpec
parameter_list|,
name|Operator
name|input
parameter_list|)
throws|throws
name|SemanticException
block|{
name|wSpec
operator|.
name|validateAndMakeEffective
argument_list|()
expr_stmt|;
name|WindowingComponentizer
name|groups
init|=
operator|new
name|WindowingComponentizer
argument_list|(
name|wSpec
argument_list|)
decl_stmt|;
name|RowResolver
name|rr
init|=
name|opParseCtx
operator|.
name|get
argument_list|(
name|input
argument_list|)
operator|.
name|getRowResolver
argument_list|()
decl_stmt|;
while|while
condition|(
name|groups
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|wSpec
operator|=
name|groups
operator|.
name|next
argument_list|(
name|conf
argument_list|,
name|this
argument_list|,
name|unparseTranslator
argument_list|,
name|rr
argument_list|)
expr_stmt|;
name|input
operator|=
name|genReduceSinkPlanForWindowing
argument_list|(
name|wSpec
argument_list|,
name|rr
argument_list|,
name|input
argument_list|)
expr_stmt|;
name|rr
operator|=
name|opParseCtx
operator|.
name|get
argument_list|(
name|input
argument_list|)
operator|.
name|getRowResolver
argument_list|()
expr_stmt|;
name|PTFTranslator
name|translator
init|=
operator|new
name|PTFTranslator
argument_list|()
decl_stmt|;
name|PTFDesc
name|ptfDesc
init|=
name|translator
operator|.
name|translate
argument_list|(
name|wSpec
argument_list|,
name|this
argument_list|,
name|conf
argument_list|,
name|rr
argument_list|,
name|unparseTranslator
argument_list|)
decl_stmt|;
name|RowResolver
name|ptfOpRR
init|=
name|ptfDesc
operator|.
name|getFuncDef
argument_list|()
operator|.
name|getOutputShape
argument_list|()
operator|.
name|getRr
argument_list|()
decl_stmt|;
name|input
operator|=
name|putOpInsertMap
argument_list|(
name|OperatorFactory
operator|.
name|getAndMakeChild
argument_list|(
name|ptfDesc
argument_list|,
operator|new
name|RowSchema
argument_list|(
name|ptfOpRR
operator|.
name|getColumnInfos
argument_list|()
argument_list|)
argument_list|,
name|input
argument_list|)
argument_list|,
name|ptfOpRR
argument_list|)
expr_stmt|;
name|rr
operator|=
name|ptfOpRR
expr_stmt|;
block|}
return|return
name|input
return|;
block|}
specifier|private
name|Operator
name|genReduceSinkPlanForWindowing
parameter_list|(
name|WindowingSpec
name|spec
parameter_list|,
name|RowResolver
name|inputRR
parameter_list|,
name|Operator
name|input
parameter_list|)
throws|throws
name|SemanticException
block|{
name|ArrayList
argument_list|<
name|ExprNodeDesc
argument_list|>
name|partCols
init|=
operator|new
name|ArrayList
argument_list|<
name|ExprNodeDesc
argument_list|>
argument_list|()
decl_stmt|;
name|ArrayList
argument_list|<
name|ExprNodeDesc
argument_list|>
name|valueCols
init|=
operator|new
name|ArrayList
argument_list|<
name|ExprNodeDesc
argument_list|>
argument_list|()
decl_stmt|;
name|ArrayList
argument_list|<
name|ExprNodeDesc
argument_list|>
name|orderCols
init|=
operator|new
name|ArrayList
argument_list|<
name|ExprNodeDesc
argument_list|>
argument_list|()
decl_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|ExprNodeDesc
argument_list|>
name|colExprMap
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|ExprNodeDesc
argument_list|>
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|outputColumnNames
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
name|StringBuilder
name|orderString
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|ArrayList
argument_list|<
name|PartitionExpression
argument_list|>
name|partColList
init|=
name|spec
operator|.
name|getQueryPartitionSpec
argument_list|()
operator|.
name|getExpressions
argument_list|()
decl_stmt|;
for|for
control|(
name|PartitionExpression
name|partCol
range|:
name|partColList
control|)
block|{
name|ExprNodeDesc
name|partExpr
init|=
name|genExprNodeDesc
argument_list|(
name|partCol
operator|.
name|getExpression
argument_list|()
argument_list|,
name|inputRR
argument_list|)
decl_stmt|;
name|partCols
operator|.
name|add
argument_list|(
name|partExpr
argument_list|)
expr_stmt|;
name|orderCols
operator|.
name|add
argument_list|(
name|partExpr
argument_list|)
expr_stmt|;
name|orderString
operator|.
name|append
argument_list|(
literal|'+'
argument_list|)
expr_stmt|;
block|}
name|ArrayList
argument_list|<
name|OrderExpression
argument_list|>
name|orderColList
init|=
name|spec
operator|.
name|getQueryOrderSpec
argument_list|()
operator|==
literal|null
condition|?
operator|new
name|ArrayList
argument_list|<
name|PTFInvocationSpec
operator|.
name|OrderExpression
argument_list|>
argument_list|()
else|:
name|spec
operator|.
name|getQueryOrderSpec
argument_list|()
operator|.
name|getExpressions
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|orderColList
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|OrderExpression
name|orderCol
init|=
name|orderColList
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|parse
operator|.
name|PTFInvocationSpec
operator|.
name|Order
name|order
init|=
name|orderCol
operator|.
name|getOrder
argument_list|()
decl_stmt|;
if|if
condition|(
name|order
operator|.
name|name
argument_list|()
operator|.
name|equals
argument_list|(
literal|"ASC"
argument_list|)
condition|)
block|{
name|orderString
operator|.
name|append
argument_list|(
literal|'+'
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|orderString
operator|.
name|append
argument_list|(
literal|'-'
argument_list|)
expr_stmt|;
block|}
name|ExprNodeDesc
name|orderExpr
init|=
name|genExprNodeDesc
argument_list|(
name|orderCol
operator|.
name|getExpression
argument_list|()
argument_list|,
name|inputRR
argument_list|)
decl_stmt|;
name|orderCols
operator|.
name|add
argument_list|(
name|orderExpr
argument_list|)
expr_stmt|;
block|}
name|ArrayList
argument_list|<
name|ColumnInfo
argument_list|>
name|colInfoList
init|=
name|inputRR
operator|.
name|getColumnInfos
argument_list|()
decl_stmt|;
name|RowResolver
name|rsNewRR
init|=
operator|new
name|RowResolver
argument_list|()
decl_stmt|;
name|int
name|pos
init|=
literal|0
decl_stmt|;
for|for
control|(
name|ColumnInfo
name|colInfo
range|:
name|colInfoList
control|)
block|{
name|ExprNodeDesc
name|valueColExpr
init|=
operator|new
name|ExprNodeColumnDesc
argument_list|(
name|colInfo
operator|.
name|getType
argument_list|()
argument_list|,
name|colInfo
operator|.
name|getInternalName
argument_list|()
argument_list|,
name|colInfo
operator|.
name|getTabAlias
argument_list|()
argument_list|,
name|colInfo
operator|.
name|getIsVirtualCol
argument_list|()
argument_list|)
decl_stmt|;
name|valueCols
operator|.
name|add
argument_list|(
name|valueColExpr
argument_list|)
expr_stmt|;
name|colExprMap
operator|.
name|put
argument_list|(
name|colInfo
operator|.
name|getInternalName
argument_list|()
argument_list|,
name|valueColExpr
argument_list|)
expr_stmt|;
name|String
name|outColName
init|=
name|SemanticAnalyzer
operator|.
name|getColumnInternalName
argument_list|(
name|pos
operator|++
argument_list|)
decl_stmt|;
name|outputColumnNames
operator|.
name|add
argument_list|(
name|outColName
argument_list|)
expr_stmt|;
name|String
index|[]
name|alias
init|=
name|inputRR
operator|.
name|reverseLookup
argument_list|(
name|colInfo
operator|.
name|getInternalName
argument_list|()
argument_list|)
decl_stmt|;
name|ColumnInfo
name|newColInfo
init|=
operator|new
name|ColumnInfo
argument_list|(
name|outColName
argument_list|,
name|colInfo
operator|.
name|getType
argument_list|()
argument_list|,
name|alias
index|[
literal|0
index|]
argument_list|,
name|colInfo
operator|.
name|getIsVirtualCol
argument_list|()
argument_list|,
name|colInfo
operator|.
name|isHiddenVirtualCol
argument_list|()
argument_list|)
decl_stmt|;
name|rsNewRR
operator|.
name|put
argument_list|(
name|alias
index|[
literal|0
index|]
argument_list|,
name|alias
index|[
literal|1
index|]
argument_list|,
name|newColInfo
argument_list|)
expr_stmt|;
name|String
index|[]
name|altMapping
init|=
name|inputRR
operator|.
name|getAlternateMappings
argument_list|(
name|colInfo
operator|.
name|getInternalName
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|altMapping
operator|!=
literal|null
condition|)
block|{
name|rsNewRR
operator|.
name|put
argument_list|(
name|altMapping
index|[
literal|0
index|]
argument_list|,
name|altMapping
index|[
literal|1
index|]
argument_list|,
name|newColInfo
argument_list|)
expr_stmt|;
block|}
block|}
name|input
operator|=
name|putOpInsertMap
argument_list|(
name|OperatorFactory
operator|.
name|getAndMakeChild
argument_list|(
name|PlanUtils
operator|.
name|getReduceSinkDesc
argument_list|(
name|orderCols
argument_list|,
name|valueCols
argument_list|,
name|outputColumnNames
argument_list|,
literal|false
argument_list|,
operator|-
literal|1
argument_list|,
name|partCols
argument_list|,
name|orderString
operator|.
name|toString
argument_list|()
argument_list|,
operator|-
literal|1
argument_list|)
argument_list|,
operator|new
name|RowSchema
argument_list|(
name|rsNewRR
operator|.
name|getColumnInfos
argument_list|()
argument_list|)
argument_list|,
name|input
argument_list|)
argument_list|,
name|rsNewRR
argument_list|)
expr_stmt|;
name|input
operator|.
name|setColumnExprMap
argument_list|(
name|colExprMap
argument_list|)
expr_stmt|;
comment|// Construct the RR for extract operator
name|RowResolver
name|extractRR
init|=
operator|new
name|RowResolver
argument_list|()
decl_stmt|;
name|LinkedHashMap
argument_list|<
name|String
index|[]
argument_list|,
name|ColumnInfo
argument_list|>
name|colsAddedByHaving
init|=
operator|new
name|LinkedHashMap
argument_list|<
name|String
index|[]
argument_list|,
name|ColumnInfo
argument_list|>
argument_list|()
decl_stmt|;
name|pos
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|ColumnInfo
name|colInfo
range|:
name|colInfoList
control|)
block|{
name|String
index|[]
name|alias
init|=
name|inputRR
operator|.
name|reverseLookup
argument_list|(
name|colInfo
operator|.
name|getInternalName
argument_list|()
argument_list|)
decl_stmt|;
comment|/*        * if we have already encountered this colInfo internalName.        * We encounter it again because it must be put for the Having clause.        * We will add these entries in the end; in a loop on colsAddedByHaving. See below.        */
if|if
condition|(
name|colsAddedByHaving
operator|.
name|containsKey
argument_list|(
name|alias
argument_list|)
condition|)
block|{
continue|continue;
block|}
name|ASTNode
name|astNode
init|=
name|PTFTranslator
operator|.
name|getASTNode
argument_list|(
name|colInfo
argument_list|,
name|inputRR
argument_list|)
decl_stmt|;
name|ColumnInfo
name|eColInfo
init|=
operator|new
name|ColumnInfo
argument_list|(
name|SemanticAnalyzer
operator|.
name|getColumnInternalName
argument_list|(
name|pos
operator|++
argument_list|)
argument_list|,
name|colInfo
operator|.
name|getType
argument_list|()
argument_list|,
name|alias
index|[
literal|0
index|]
argument_list|,
name|colInfo
operator|.
name|getIsVirtualCol
argument_list|()
argument_list|,
name|colInfo
operator|.
name|isHiddenVirtualCol
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|astNode
operator|==
literal|null
condition|)
block|{
name|extractRR
operator|.
name|put
argument_list|(
name|alias
index|[
literal|0
index|]
argument_list|,
name|alias
index|[
literal|1
index|]
argument_list|,
name|eColInfo
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/*          * in case having clause refers to this column may have been added twice;          * once with the ASTNode.toStringTree as the alias          * and then with the real alias.          */
name|extractRR
operator|.
name|putExpression
argument_list|(
name|astNode
argument_list|,
name|eColInfo
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|astNode
operator|.
name|toStringTree
argument_list|()
operator|.
name|toLowerCase
argument_list|()
operator|.
name|equals
argument_list|(
name|alias
index|[
literal|1
index|]
argument_list|)
condition|)
block|{
name|colsAddedByHaving
operator|.
name|put
argument_list|(
name|alias
argument_list|,
name|eColInfo
argument_list|)
expr_stmt|;
block|}
block|}
name|String
index|[]
name|altMapping
init|=
name|inputRR
operator|.
name|getAlternateMappings
argument_list|(
name|colInfo
operator|.
name|getInternalName
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|altMapping
operator|!=
literal|null
condition|)
block|{
name|extractRR
operator|.
name|put
argument_list|(
name|altMapping
index|[
literal|0
index|]
argument_list|,
name|altMapping
index|[
literal|1
index|]
argument_list|,
name|eColInfo
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|String
index|[]
argument_list|,
name|ColumnInfo
argument_list|>
name|columnAddedByHaving
range|:
name|colsAddedByHaving
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|String
index|[]
name|alias
init|=
name|columnAddedByHaving
operator|.
name|getKey
argument_list|()
decl_stmt|;
name|ColumnInfo
name|eColInfo
init|=
name|columnAddedByHaving
operator|.
name|getValue
argument_list|()
decl_stmt|;
name|extractRR
operator|.
name|put
argument_list|(
name|alias
index|[
literal|0
index|]
argument_list|,
name|alias
index|[
literal|1
index|]
argument_list|,
name|eColInfo
argument_list|)
expr_stmt|;
block|}
comment|/*      * b. Construct Extract Operator.      */
name|input
operator|=
name|putOpInsertMap
argument_list|(
name|OperatorFactory
operator|.
name|getAndMakeChild
argument_list|(
operator|new
name|ExtractDesc
argument_list|(
operator|new
name|ExprNodeColumnDesc
argument_list|(
name|TypeInfoFactory
operator|.
name|stringTypeInfo
argument_list|,
name|Utilities
operator|.
name|ReduceField
operator|.
name|VALUE
operator|.
name|toString
argument_list|()
argument_list|,
literal|""
argument_list|,
literal|false
argument_list|)
argument_list|)
argument_list|,
operator|new
name|RowSchema
argument_list|(
name|inputRR
operator|.
name|getColumnInfos
argument_list|()
argument_list|)
argument_list|,
name|input
argument_list|)
argument_list|,
name|extractRR
argument_list|)
expr_stmt|;
return|return
name|input
return|;
block|}
specifier|public
specifier|static
name|ArrayList
argument_list|<
name|WindowExpressionSpec
argument_list|>
name|parseSelect
parameter_list|(
name|String
name|selectExprStr
parameter_list|)
throws|throws
name|SemanticException
block|{
name|ASTNode
name|selNode
init|=
literal|null
decl_stmt|;
try|try
block|{
name|ParseDriver
name|pd
init|=
operator|new
name|ParseDriver
argument_list|()
decl_stmt|;
name|selNode
operator|=
name|pd
operator|.
name|parseSelect
argument_list|(
name|selectExprStr
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|ParseException
name|pe
parameter_list|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|pe
argument_list|)
throw|;
block|}
name|ArrayList
argument_list|<
name|WindowExpressionSpec
argument_list|>
name|selSpec
init|=
operator|new
name|ArrayList
argument_list|<
name|WindowExpressionSpec
argument_list|>
argument_list|()
decl_stmt|;
name|int
name|childCount
init|=
name|selNode
operator|.
name|getChildCount
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|childCount
condition|;
name|i
operator|++
control|)
block|{
name|ASTNode
name|selExpr
init|=
operator|(
name|ASTNode
operator|)
name|selNode
operator|.
name|getChild
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|selExpr
operator|.
name|getType
argument_list|()
operator|!=
name|HiveParser
operator|.
name|TOK_SELEXPR
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"Only Select expressions supported in dynamic select list: %s"
argument_list|,
name|selectExprStr
argument_list|)
argument_list|)
throw|;
block|}
name|ASTNode
name|expr
init|=
operator|(
name|ASTNode
operator|)
name|selExpr
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|expr
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_ALLCOLREF
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"'%s' column not allowed in dynamic select list"
argument_list|,
name|selectExprStr
argument_list|)
argument_list|)
throw|;
block|}
name|ASTNode
name|aliasNode
init|=
name|selExpr
operator|.
name|getChildCount
argument_list|()
operator|>
literal|1
operator|&&
name|selExpr
operator|.
name|getChild
argument_list|(
literal|1
argument_list|)
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|Identifier
condition|?
operator|(
name|ASTNode
operator|)
name|selExpr
operator|.
name|getChild
argument_list|(
literal|1
argument_list|)
else|:
literal|null
decl_stmt|;
name|String
name|alias
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|aliasNode
operator|!=
literal|null
condition|)
block|{
name|alias
operator|=
name|aliasNode
operator|.
name|getText
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|String
index|[]
name|tabColAlias
init|=
name|getColAlias
argument_list|(
name|selExpr
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
literal|true
argument_list|,
operator|-
literal|1
argument_list|)
decl_stmt|;
name|alias
operator|=
name|tabColAlias
index|[
literal|1
index|]
expr_stmt|;
block|}
name|WindowExpressionSpec
name|exprSpec
init|=
operator|new
name|WindowExpressionSpec
argument_list|()
decl_stmt|;
name|exprSpec
operator|.
name|setAlias
argument_list|(
name|alias
argument_list|)
expr_stmt|;
name|exprSpec
operator|.
name|setExpression
argument_list|(
name|expr
argument_list|)
expr_stmt|;
name|selSpec
operator|.
name|add
argument_list|(
name|exprSpec
argument_list|)
expr_stmt|;
block|}
return|return
name|selSpec
return|;
block|}
specifier|private
name|void
name|addAlternateGByKeyMappings
parameter_list|(
name|ASTNode
name|gByExpr
parameter_list|,
name|ColumnInfo
name|colInfo
parameter_list|,
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
name|reduceSinkOp
parameter_list|,
name|RowResolver
name|gByRR
parameter_list|)
block|{
if|if
condition|(
name|gByExpr
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|DOT
operator|&&
name|gByExpr
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_TABLE_OR_COL
condition|)
block|{
name|String
name|tab_alias
init|=
name|BaseSemanticAnalyzer
operator|.
name|unescapeIdentifier
argument_list|(
name|gByExpr
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getText
argument_list|()
argument_list|)
decl_stmt|;
name|String
name|col_alias
init|=
name|BaseSemanticAnalyzer
operator|.
name|unescapeIdentifier
argument_list|(
name|gByExpr
operator|.
name|getChild
argument_list|(
literal|1
argument_list|)
operator|.
name|getText
argument_list|()
argument_list|)
decl_stmt|;
name|gByRR
operator|.
name|put
argument_list|(
name|tab_alias
argument_list|,
name|col_alias
argument_list|,
name|colInfo
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|gByExpr
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_TABLE_OR_COL
condition|)
block|{
name|String
name|col_alias
init|=
name|BaseSemanticAnalyzer
operator|.
name|unescapeIdentifier
argument_list|(
name|gByExpr
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getText
argument_list|()
argument_list|)
decl_stmt|;
name|String
name|tab_alias
init|=
literal|null
decl_stmt|;
comment|/* 		   * If the input to the GBy has a tab alias for the column, then add an entry 		   * based on that tab_alias. 		   * For e.g. this query: 		   * select b.x, count(*) from t1 b group by x 		   * needs (tab_alias=b, col_alias=x) in the GBy RR. 		   * tab_alias=b comes from looking at the RowResolver that is the ancestor 		   * before any GBy/ReduceSinks added for the GBY operation. 		   */
name|Operator
argument_list|<
name|?
extends|extends
name|OperatorDesc
argument_list|>
name|parent
init|=
name|reduceSinkOp
decl_stmt|;
while|while
condition|(
name|parent
operator|instanceof
name|ReduceSinkOperator
operator|||
name|parent
operator|instanceof
name|GroupByOperator
condition|)
block|{
name|parent
operator|=
name|parent
operator|.
name|getParentOperators
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
name|RowResolver
name|parentRR
init|=
name|opParseCtx
operator|.
name|get
argument_list|(
name|parent
argument_list|)
operator|.
name|getRowResolver
argument_list|()
decl_stmt|;
try|try
block|{
name|ColumnInfo
name|pColInfo
init|=
name|parentRR
operator|.
name|get
argument_list|(
name|tab_alias
argument_list|,
name|col_alias
argument_list|)
decl_stmt|;
name|tab_alias
operator|=
name|pColInfo
operator|==
literal|null
condition|?
literal|null
else|:
name|pColInfo
operator|.
name|getTabAlias
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|SemanticException
name|se
parameter_list|)
block|{ 		  }
name|gByRR
operator|.
name|put
argument_list|(
name|tab_alias
argument_list|,
name|col_alias
argument_list|,
name|colInfo
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_class

end_unit

