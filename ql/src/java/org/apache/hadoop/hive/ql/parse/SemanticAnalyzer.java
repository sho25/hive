begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|parse
package|;
end_package

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|*
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|File
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|Serializable
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|reflect
operator|.
name|Method
import|;
end_import

begin_import
import|import
name|org
operator|.
name|antlr
operator|.
name|runtime
operator|.
name|tree
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde
operator|.
name|SerDeField
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|metastore
operator|.
name|api
operator|.
name|FieldSchema
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|Context
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|io
operator|.
name|IgnoreKeyTextOutputFormat
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|metadata
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|conf
operator|.
name|HiveConf
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapred
operator|.
name|TextInputFormat
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|Path
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|lang
operator|.
name|StringUtils
import|;
end_import

begin_comment
comment|/**  * Implementation of the semantic analyzer  */
end_comment

begin_class
specifier|public
class|class
name|SemanticAnalyzer
extends|extends
name|BaseSemanticAnalyzer
block|{
specifier|private
name|HashMap
argument_list|<
name|String
argument_list|,
name|PartitionPruner
argument_list|>
name|aliasToPruner
decl_stmt|;
specifier|private
name|HashMap
argument_list|<
name|String
argument_list|,
name|SamplePruner
argument_list|>
name|aliasToSamplePruner
decl_stmt|;
specifier|private
name|HashMap
argument_list|<
name|String
argument_list|,
name|Operator
argument_list|<
name|?
extends|extends
name|Serializable
argument_list|>
argument_list|>
name|topOps
decl_stmt|;
specifier|private
name|List
argument_list|<
name|loadTableDesc
argument_list|>
name|loadTableWork
decl_stmt|;
specifier|private
name|List
argument_list|<
name|loadFileDesc
argument_list|>
name|loadFileWork
decl_stmt|;
specifier|private
specifier|static
class|class
name|Phase1Ctx
block|{
name|String
name|dest
decl_stmt|;
name|int
name|nextNum
decl_stmt|;
block|}
specifier|public
name|SemanticAnalyzer
parameter_list|(
name|HiveConf
name|conf
parameter_list|)
throws|throws
name|SemanticException
block|{
name|super
argument_list|(
name|conf
argument_list|)
expr_stmt|;
name|this
operator|.
name|aliasToPruner
operator|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|PartitionPruner
argument_list|>
argument_list|()
expr_stmt|;
name|this
operator|.
name|aliasToSamplePruner
operator|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|SamplePruner
argument_list|>
argument_list|()
expr_stmt|;
name|this
operator|.
name|topOps
operator|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|Operator
argument_list|<
name|?
extends|extends
name|Serializable
argument_list|>
argument_list|>
argument_list|()
expr_stmt|;
name|this
operator|.
name|loadTableWork
operator|=
operator|new
name|ArrayList
argument_list|<
name|loadTableDesc
argument_list|>
argument_list|()
expr_stmt|;
name|this
operator|.
name|loadFileWork
operator|=
operator|new
name|ArrayList
argument_list|<
name|loadFileDesc
argument_list|>
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Override
specifier|protected
name|void
name|reset
parameter_list|()
block|{
name|super
operator|.
name|reset
argument_list|()
expr_stmt|;
name|this
operator|.
name|aliasToPruner
operator|.
name|clear
argument_list|()
expr_stmt|;
name|this
operator|.
name|topOps
operator|.
name|clear
argument_list|()
expr_stmt|;
name|this
operator|.
name|loadTableWork
operator|.
name|clear
argument_list|()
expr_stmt|;
name|this
operator|.
name|loadFileWork
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"nls"
argument_list|)
specifier|private
name|void
name|doPhase1QBExpr
parameter_list|(
name|CommonTree
name|ast
parameter_list|,
name|QBExpr
name|qbexpr
parameter_list|,
name|String
name|id
parameter_list|,
name|String
name|alias
parameter_list|)
throws|throws
name|SemanticException
block|{
assert|assert
operator|(
name|ast
operator|.
name|getToken
argument_list|()
operator|!=
literal|null
operator|)
assert|;
switch|switch
condition|(
name|ast
operator|.
name|getToken
argument_list|()
operator|.
name|getType
argument_list|()
condition|)
block|{
case|case
name|HiveParser
operator|.
name|TOK_QUERY
case|:
block|{
name|QB
name|qb
init|=
operator|new
name|QB
argument_list|(
name|id
argument_list|,
name|alias
argument_list|,
literal|true
argument_list|)
decl_stmt|;
name|doPhase1
argument_list|(
name|ast
argument_list|,
name|qb
argument_list|,
name|initPhase1Ctx
argument_list|()
argument_list|)
expr_stmt|;
name|qbexpr
operator|.
name|setOpcode
argument_list|(
name|QBExpr
operator|.
name|Opcode
operator|.
name|NULLOP
argument_list|)
expr_stmt|;
name|qbexpr
operator|.
name|setQB
argument_list|(
name|qb
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|HiveParser
operator|.
name|TOK_UNION
case|:
block|{
name|qbexpr
operator|.
name|setOpcode
argument_list|(
name|QBExpr
operator|.
name|Opcode
operator|.
name|UNION
argument_list|)
expr_stmt|;
comment|// query 1
assert|assert
operator|(
name|ast
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|!=
literal|null
operator|)
assert|;
name|QBExpr
name|qbexpr1
init|=
operator|new
name|QBExpr
argument_list|(
name|alias
operator|+
literal|"-subquery1"
argument_list|)
decl_stmt|;
name|doPhase1QBExpr
argument_list|(
operator|(
name|CommonTree
operator|)
name|ast
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
argument_list|,
name|qbexpr1
argument_list|,
name|id
operator|+
literal|"-subquery1"
argument_list|,
name|alias
operator|+
literal|"-subquery1"
argument_list|)
expr_stmt|;
name|qbexpr
operator|.
name|setQBExpr1
argument_list|(
name|qbexpr1
argument_list|)
expr_stmt|;
comment|// query 2
assert|assert
operator|(
name|ast
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|!=
literal|null
operator|)
assert|;
name|QBExpr
name|qbexpr2
init|=
operator|new
name|QBExpr
argument_list|(
name|alias
operator|+
literal|"-subquery2"
argument_list|)
decl_stmt|;
name|doPhase1QBExpr
argument_list|(
operator|(
name|CommonTree
operator|)
name|ast
operator|.
name|getChild
argument_list|(
literal|1
argument_list|)
argument_list|,
name|qbexpr2
argument_list|,
name|id
operator|+
literal|"-subquery2"
argument_list|,
name|alias
operator|+
literal|"-subquery2"
argument_list|)
expr_stmt|;
name|qbexpr
operator|.
name|setQBExpr2
argument_list|(
name|qbexpr2
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
block|}
specifier|private
name|HashMap
argument_list|<
name|String
argument_list|,
name|CommonTree
argument_list|>
name|doPhase1GetAggregationsFromSelect
parameter_list|(
name|CommonTree
name|selExpr
parameter_list|)
block|{
comment|// Iterate over the selects search for aggregation Trees.
comment|// Use String as keys to eliminate duplicate trees.
name|HashMap
argument_list|<
name|String
argument_list|,
name|CommonTree
argument_list|>
name|aggregationTrees
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|CommonTree
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|selExpr
operator|.
name|getChildCount
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|CommonTree
name|sel
init|=
operator|(
name|CommonTree
operator|)
name|selExpr
operator|.
name|getChild
argument_list|(
name|i
argument_list|)
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|doPhase1GetAllAggregations
argument_list|(
name|sel
argument_list|,
name|aggregationTrees
argument_list|)
expr_stmt|;
block|}
return|return
name|aggregationTrees
return|;
block|}
comment|/**    * DFS-scan the expressionTree to find all aggregation subtrees and put them    * in aggregations.    *    * @param expressionTree    * @param aggregations    *          the key to the HashTable is the toStringTree() representation of    *          the aggregation subtree.    */
specifier|private
name|void
name|doPhase1GetAllAggregations
parameter_list|(
name|CommonTree
name|expressionTree
parameter_list|,
name|HashMap
argument_list|<
name|String
argument_list|,
name|CommonTree
argument_list|>
name|aggregations
parameter_list|)
block|{
if|if
condition|(
name|expressionTree
operator|.
name|getToken
argument_list|()
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_FUNCTION
operator|||
name|expressionTree
operator|.
name|getToken
argument_list|()
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_FUNCTIONDI
condition|)
block|{
assert|assert
operator|(
name|expressionTree
operator|.
name|getChildCount
argument_list|()
operator|!=
literal|0
operator|)
assert|;
assert|assert
operator|(
name|expressionTree
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|Identifier
operator|)
assert|;
name|String
name|functionName
init|=
name|expressionTree
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getText
argument_list|()
decl_stmt|;
if|if
condition|(
name|UDAFRegistry
operator|.
name|getUDAF
argument_list|(
name|functionName
argument_list|)
operator|!=
literal|null
condition|)
block|{
name|aggregations
operator|.
name|put
argument_list|(
name|expressionTree
operator|.
name|toStringTree
argument_list|()
argument_list|,
name|expressionTree
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|expressionTree
operator|.
name|getChildCount
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|doPhase1GetAllAggregations
argument_list|(
operator|(
name|CommonTree
operator|)
name|expressionTree
operator|.
name|getChild
argument_list|(
name|i
argument_list|)
argument_list|,
name|aggregations
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
name|CommonTree
name|doPhase1GetDistinctFuncExpr
parameter_list|(
name|HashMap
argument_list|<
name|String
argument_list|,
name|CommonTree
argument_list|>
name|aggregationTrees
parameter_list|)
throws|throws
name|SemanticException
block|{
name|CommonTree
name|expr
init|=
literal|null
decl_stmt|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|CommonTree
argument_list|>
name|entry
range|:
name|aggregationTrees
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|CommonTree
name|value
init|=
name|entry
operator|.
name|getValue
argument_list|()
decl_stmt|;
assert|assert
operator|(
name|value
operator|!=
literal|null
operator|)
assert|;
if|if
condition|(
name|value
operator|.
name|getToken
argument_list|()
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_FUNCTIONDI
condition|)
block|{
if|if
condition|(
name|expr
operator|==
literal|null
condition|)
block|{
name|expr
operator|=
name|value
expr_stmt|;
block|}
else|else
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|UNSUPPORTED_MULTIPLE_DISTINCTS
operator|.
name|getMsg
argument_list|(
name|expr
argument_list|)
argument_list|)
throw|;
block|}
block|}
block|}
return|return
name|expr
return|;
block|}
specifier|private
name|void
name|processTable
parameter_list|(
name|QB
name|qb
parameter_list|,
name|CommonTree
name|tabref
parameter_list|)
throws|throws
name|SemanticException
block|{
comment|// For each table reference get the table name
comment|// and the alias (if alias is not present, the table name
comment|// is used as an alias)
name|boolean
name|tableSamplePresent
init|=
literal|false
decl_stmt|;
name|int
name|aliasIndex
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|tabref
operator|.
name|getChildCount
argument_list|()
operator|==
literal|2
condition|)
block|{
comment|// tablename tablesample
comment|// OR
comment|// tablename alias
name|CommonTree
name|ct
init|=
operator|(
name|CommonTree
operator|)
name|tabref
operator|.
name|getChild
argument_list|(
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|ct
operator|.
name|getToken
argument_list|()
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_TABLESAMPLE
condition|)
block|{
name|tableSamplePresent
operator|=
literal|true
expr_stmt|;
block|}
else|else
block|{
name|aliasIndex
operator|=
literal|1
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|tabref
operator|.
name|getChildCount
argument_list|()
operator|==
literal|3
condition|)
block|{
comment|// table name table sample alias
name|aliasIndex
operator|=
literal|2
expr_stmt|;
name|tableSamplePresent
operator|=
literal|true
expr_stmt|;
block|}
name|CommonTree
name|tableTree
init|=
call|(
name|CommonTree
call|)
argument_list|(
name|tabref
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|String
name|alias
init|=
name|tabref
operator|.
name|getChild
argument_list|(
name|aliasIndex
argument_list|)
operator|.
name|getText
argument_list|()
decl_stmt|;
comment|// If the alias is already there then we have a conflict
if|if
condition|(
name|qb
operator|.
name|exists
argument_list|(
name|alias
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|AMBIGOUS_TABLE_ALIAS
operator|.
name|getMsg
argument_list|(
name|tabref
operator|.
name|getChild
argument_list|(
name|aliasIndex
argument_list|)
argument_list|)
argument_list|)
throw|;
block|}
if|if
condition|(
name|tableSamplePresent
condition|)
block|{
name|CommonTree
name|sampleClause
init|=
operator|(
name|CommonTree
operator|)
name|tabref
operator|.
name|getChild
argument_list|(
literal|1
argument_list|)
decl_stmt|;
name|ArrayList
argument_list|<
name|String
argument_list|>
name|sampleCols
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
if|if
condition|(
name|sampleClause
operator|.
name|getChildCount
argument_list|()
operator|>
literal|2
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|2
init|;
name|i
operator|<
name|sampleClause
operator|.
name|getChildCount
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|sampleCols
operator|.
name|add
argument_list|(
name|sampleClause
operator|.
name|getChild
argument_list|(
name|i
argument_list|)
operator|.
name|getText
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
comment|// TODO: For now only support sampling on up to two columns
comment|// Need to change it to list of columns
if|if
condition|(
name|sampleCols
operator|.
name|size
argument_list|()
operator|>
literal|2
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|SAMPLE_RESTRICTION
operator|.
name|getMsg
argument_list|(
name|tabref
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
argument_list|)
argument_list|)
throw|;
block|}
name|qb
operator|.
name|getParseInfo
argument_list|()
operator|.
name|setTabSample
argument_list|(
name|alias
argument_list|,
operator|new
name|TableSample
argument_list|(
name|sampleClause
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getText
argument_list|()
argument_list|,
name|sampleClause
operator|.
name|getChild
argument_list|(
literal|1
argument_list|)
operator|.
name|getText
argument_list|()
argument_list|,
name|sampleCols
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// Insert this map into the stats
name|String
name|table_name
init|=
name|tabref
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getText
argument_list|()
decl_stmt|;
name|qb
operator|.
name|setTabAlias
argument_list|(
name|alias
argument_list|,
name|table_name
argument_list|)
expr_stmt|;
name|qb
operator|.
name|getParseInfo
argument_list|()
operator|.
name|setSrcForAlias
argument_list|(
name|alias
argument_list|,
name|tableTree
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|processSubQuery
parameter_list|(
name|QB
name|qb
parameter_list|,
name|CommonTree
name|subq
parameter_list|)
throws|throws
name|SemanticException
block|{
comment|// This is a subquery and must have an alias
if|if
condition|(
name|subq
operator|.
name|getChildCount
argument_list|()
operator|!=
literal|2
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|NO_SUBQUERY_ALIAS
operator|.
name|getMsg
argument_list|(
name|subq
argument_list|)
argument_list|)
throw|;
block|}
name|CommonTree
name|subqref
init|=
operator|(
name|CommonTree
operator|)
name|subq
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|String
name|alias
init|=
name|subq
operator|.
name|getChild
argument_list|(
literal|1
argument_list|)
operator|.
name|getText
argument_list|()
decl_stmt|;
comment|// Recursively do the first phase of semantic analysis for the subquery
name|QBExpr
name|qbexpr
init|=
operator|new
name|QBExpr
argument_list|(
name|alias
argument_list|)
decl_stmt|;
name|doPhase1QBExpr
argument_list|(
name|subqref
argument_list|,
name|qbexpr
argument_list|,
name|qb
operator|.
name|getId
argument_list|()
argument_list|,
name|alias
argument_list|)
expr_stmt|;
comment|// If the alias is already there then we have a conflict
if|if
condition|(
name|qb
operator|.
name|exists
argument_list|(
name|alias
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|AMBIGOUS_TABLE_ALIAS
operator|.
name|getMsg
argument_list|(
name|subq
operator|.
name|getChild
argument_list|(
literal|1
argument_list|)
argument_list|)
argument_list|)
throw|;
block|}
comment|// Insert this map into the stats
name|qb
operator|.
name|setSubqAlias
argument_list|(
name|alias
argument_list|,
name|qbexpr
argument_list|)
expr_stmt|;
block|}
specifier|private
name|boolean
name|isJoinToken
parameter_list|(
name|CommonTree
name|node
parameter_list|)
block|{
if|if
condition|(
operator|(
name|node
operator|.
name|getToken
argument_list|()
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_JOIN
operator|)
operator|||
operator|(
name|node
operator|.
name|getToken
argument_list|()
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_LEFTOUTERJOIN
operator|)
operator|||
operator|(
name|node
operator|.
name|getToken
argument_list|()
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_RIGHTOUTERJOIN
operator|)
operator|||
operator|(
name|node
operator|.
name|getToken
argument_list|()
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_FULLOUTERJOIN
operator|)
condition|)
return|return
literal|true
return|;
return|return
literal|false
return|;
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"nls"
argument_list|)
specifier|private
name|void
name|processJoin
parameter_list|(
name|QB
name|qb
parameter_list|,
name|CommonTree
name|join
parameter_list|)
throws|throws
name|SemanticException
block|{
name|int
name|numChildren
init|=
name|join
operator|.
name|getChildCount
argument_list|()
decl_stmt|;
if|if
condition|(
operator|(
name|numChildren
operator|!=
literal|2
operator|)
operator|&&
operator|(
name|numChildren
operator|!=
literal|3
operator|)
condition|)
throw|throw
operator|new
name|SemanticException
argument_list|(
literal|"Join with multiple children"
argument_list|)
throw|;
for|for
control|(
name|int
name|num
init|=
literal|0
init|;
name|num
operator|<
name|numChildren
condition|;
name|num
operator|++
control|)
block|{
name|CommonTree
name|child
init|=
operator|(
name|CommonTree
operator|)
name|join
operator|.
name|getChild
argument_list|(
name|num
argument_list|)
decl_stmt|;
if|if
condition|(
name|child
operator|.
name|getToken
argument_list|()
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_TABREF
condition|)
name|processTable
argument_list|(
name|qb
argument_list|,
name|child
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|child
operator|.
name|getToken
argument_list|()
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_SUBQUERY
condition|)
name|processSubQuery
argument_list|(
name|qb
argument_list|,
name|child
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|isJoinToken
argument_list|(
name|child
argument_list|)
condition|)
name|processJoin
argument_list|(
name|qb
argument_list|,
name|child
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|SuppressWarnings
argument_list|(
block|{
literal|"fallthrough"
block|,
literal|"nls"
block|}
argument_list|)
specifier|private
name|void
name|doPhase1
parameter_list|(
name|CommonTree
name|ast
parameter_list|,
name|QB
name|qb
parameter_list|,
name|Phase1Ctx
name|ctx_1
parameter_list|)
throws|throws
name|SemanticException
block|{
name|QBParseInfo
name|qbp
init|=
name|qb
operator|.
name|getParseInfo
argument_list|()
decl_stmt|;
name|boolean
name|skipRecursion
init|=
literal|false
decl_stmt|;
if|if
condition|(
name|ast
operator|.
name|getToken
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|skipRecursion
operator|=
literal|true
expr_stmt|;
switch|switch
condition|(
name|ast
operator|.
name|getToken
argument_list|()
operator|.
name|getType
argument_list|()
condition|)
block|{
case|case
name|HiveParser
operator|.
name|TOK_SELECTDI
case|:
name|qb
operator|.
name|countSelDi
argument_list|()
expr_stmt|;
comment|// fall through
case|case
name|HiveParser
operator|.
name|TOK_SELECT
case|:
name|qb
operator|.
name|countSel
argument_list|()
expr_stmt|;
name|qbp
operator|.
name|setSelExprForClause
argument_list|(
name|ctx_1
operator|.
name|dest
argument_list|,
name|ast
argument_list|)
expr_stmt|;
name|HashMap
argument_list|<
name|String
argument_list|,
name|CommonTree
argument_list|>
name|aggregations
init|=
name|doPhase1GetAggregationsFromSelect
argument_list|(
name|ast
argument_list|)
decl_stmt|;
name|qbp
operator|.
name|setAggregationExprsForClause
argument_list|(
name|ctx_1
operator|.
name|dest
argument_list|,
name|aggregations
argument_list|)
expr_stmt|;
name|qbp
operator|.
name|setDistinctFuncExprForClause
argument_list|(
name|ctx_1
operator|.
name|dest
argument_list|,
name|doPhase1GetDistinctFuncExpr
argument_list|(
name|aggregations
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|HiveParser
operator|.
name|TOK_WHERE
case|:
block|{
name|qbp
operator|.
name|setWhrExprForClause
argument_list|(
name|ctx_1
operator|.
name|dest
argument_list|,
name|ast
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|HiveParser
operator|.
name|TOK_DESTINATION
case|:
block|{
name|ctx_1
operator|.
name|dest
operator|=
literal|"insclause-"
operator|+
name|ctx_1
operator|.
name|nextNum
expr_stmt|;
name|ctx_1
operator|.
name|nextNum
operator|++
expr_stmt|;
name|qbp
operator|.
name|setDestForClause
argument_list|(
name|ctx_1
operator|.
name|dest
argument_list|,
operator|(
name|CommonTree
operator|)
name|ast
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|HiveParser
operator|.
name|TOK_FROM
case|:
block|{
name|int
name|child_count
init|=
name|ast
operator|.
name|getChildCount
argument_list|()
decl_stmt|;
if|if
condition|(
name|child_count
operator|!=
literal|1
condition|)
throw|throw
operator|new
name|SemanticException
argument_list|(
literal|"Multiple Children "
operator|+
name|child_count
argument_list|)
throw|;
comment|// Check if this is a subquery
name|CommonTree
name|frm
init|=
operator|(
name|CommonTree
operator|)
name|ast
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|frm
operator|.
name|getToken
argument_list|()
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_TABREF
condition|)
name|processTable
argument_list|(
name|qb
argument_list|,
name|frm
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|frm
operator|.
name|getToken
argument_list|()
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_SUBQUERY
condition|)
name|processSubQuery
argument_list|(
name|qb
argument_list|,
name|frm
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|isJoinToken
argument_list|(
name|frm
argument_list|)
condition|)
block|{
name|processJoin
argument_list|(
name|qb
argument_list|,
name|frm
argument_list|)
expr_stmt|;
name|qbp
operator|.
name|setJoinExpr
argument_list|(
name|frm
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|HiveParser
operator|.
name|TOK_CLUSTERBY
case|:
block|{
comment|// Get the clusterby aliases - these are aliased to the entries in the
comment|// select list
name|qbp
operator|.
name|setClusterByExprForClause
argument_list|(
name|ctx_1
operator|.
name|dest
argument_list|,
name|ast
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|HiveParser
operator|.
name|TOK_GROUPBY
case|:
block|{
comment|// Get the groupby aliases - these are aliased to the entries in the
comment|// select list
if|if
condition|(
name|qbp
operator|.
name|getSelForClause
argument_list|(
name|ctx_1
operator|.
name|dest
argument_list|)
operator|.
name|getToken
argument_list|()
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_SELECTDI
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|SELECT_DISTINCT_WITH_GROUPBY
operator|.
name|getMsg
argument_list|(
name|ast
argument_list|)
argument_list|)
throw|;
block|}
name|qbp
operator|.
name|setGroupByExprForClause
argument_list|(
name|ctx_1
operator|.
name|dest
argument_list|,
name|ast
argument_list|)
expr_stmt|;
name|skipRecursion
operator|=
literal|true
expr_stmt|;
block|}
break|break;
default|default:
name|skipRecursion
operator|=
literal|false
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|skipRecursion
condition|)
block|{
comment|// Iterate over the rest of the children
name|int
name|child_count
init|=
name|ast
operator|.
name|getChildCount
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|child_pos
init|=
literal|0
init|;
name|child_pos
operator|<
name|child_count
condition|;
operator|++
name|child_pos
control|)
block|{
comment|// Recurse
name|doPhase1
argument_list|(
operator|(
name|CommonTree
operator|)
name|ast
operator|.
name|getChild
argument_list|(
name|child_pos
argument_list|)
argument_list|,
name|qb
argument_list|,
name|ctx_1
argument_list|)
expr_stmt|;
block|}
block|}
block|}
specifier|private
name|void
name|genPartitionPruners
parameter_list|(
name|QBExpr
name|qbexpr
parameter_list|)
throws|throws
name|SemanticException
block|{
if|if
condition|(
name|qbexpr
operator|.
name|getOpcode
argument_list|()
operator|==
name|QBExpr
operator|.
name|Opcode
operator|.
name|NULLOP
condition|)
block|{
name|genPartitionPruners
argument_list|(
name|qbexpr
operator|.
name|getQB
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|genPartitionPruners
argument_list|(
name|qbexpr
operator|.
name|getQBExpr1
argument_list|()
argument_list|)
expr_stmt|;
name|genPartitionPruners
argument_list|(
name|qbexpr
operator|.
name|getQBExpr2
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"nls"
argument_list|)
specifier|private
name|void
name|genPartitionPruners
parameter_list|(
name|QB
name|qb
parameter_list|)
throws|throws
name|SemanticException
block|{
comment|// Recursively prune subqueries
for|for
control|(
name|String
name|alias
range|:
name|qb
operator|.
name|getSubqAliases
argument_list|()
control|)
block|{
name|QBExpr
name|qbexpr
init|=
name|qb
operator|.
name|getSubqForAlias
argument_list|(
name|alias
argument_list|)
decl_stmt|;
name|genPartitionPruners
argument_list|(
name|qbexpr
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|String
name|alias
range|:
name|qb
operator|.
name|getTabAliases
argument_list|()
control|)
block|{
name|String
name|alias_id
init|=
operator|(
name|qb
operator|.
name|getId
argument_list|()
operator|==
literal|null
condition|?
name|alias
else|:
name|qb
operator|.
name|getId
argument_list|()
operator|+
literal|":"
operator|+
name|alias
operator|)
decl_stmt|;
name|PartitionPruner
name|pruner
init|=
operator|new
name|PartitionPruner
argument_list|(
name|alias
argument_list|,
name|qb
operator|.
name|getMetaData
argument_list|()
argument_list|)
decl_stmt|;
comment|// Pass each where clause to the pruner
name|QBParseInfo
name|qbp
init|=
name|qb
operator|.
name|getParseInfo
argument_list|()
decl_stmt|;
for|for
control|(
name|String
name|clause
range|:
name|qbp
operator|.
name|getClauseNames
argument_list|()
control|)
block|{
if|if
condition|(
name|qbp
operator|.
name|getWhrForClause
argument_list|(
name|clause
argument_list|)
operator|!=
literal|null
condition|)
block|{
name|pruner
operator|.
name|addExpression
argument_list|(
operator|(
name|CommonTree
operator|)
name|qbp
operator|.
name|getWhrForClause
argument_list|(
name|clause
argument_list|)
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Add the pruner to the list
name|this
operator|.
name|aliasToPruner
operator|.
name|put
argument_list|(
name|alias_id
argument_list|,
name|pruner
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|genSamplePruners
parameter_list|(
name|QBExpr
name|qbexpr
parameter_list|)
throws|throws
name|SemanticException
block|{
if|if
condition|(
name|qbexpr
operator|.
name|getOpcode
argument_list|()
operator|==
name|QBExpr
operator|.
name|Opcode
operator|.
name|NULLOP
condition|)
block|{
name|genSamplePruners
argument_list|(
name|qbexpr
operator|.
name|getQB
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|genSamplePruners
argument_list|(
name|qbexpr
operator|.
name|getQBExpr1
argument_list|()
argument_list|)
expr_stmt|;
name|genSamplePruners
argument_list|(
name|qbexpr
operator|.
name|getQBExpr2
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"nls"
argument_list|)
specifier|private
name|void
name|genSamplePruners
parameter_list|(
name|QB
name|qb
parameter_list|)
throws|throws
name|SemanticException
block|{
comment|// Recursively prune subqueries
for|for
control|(
name|String
name|alias
range|:
name|qb
operator|.
name|getSubqAliases
argument_list|()
control|)
block|{
name|QBExpr
name|qbexpr
init|=
name|qb
operator|.
name|getSubqForAlias
argument_list|(
name|alias
argument_list|)
decl_stmt|;
name|genSamplePruners
argument_list|(
name|qbexpr
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|String
name|alias
range|:
name|qb
operator|.
name|getTabAliases
argument_list|()
control|)
block|{
name|String
name|alias_id
init|=
operator|(
name|qb
operator|.
name|getId
argument_list|()
operator|==
literal|null
condition|?
name|alias
else|:
name|qb
operator|.
name|getId
argument_list|()
operator|+
literal|":"
operator|+
name|alias
operator|)
decl_stmt|;
name|QBParseInfo
name|qbp
init|=
name|qb
operator|.
name|getParseInfo
argument_list|()
decl_stmt|;
name|TableSample
name|tableSample
init|=
name|qbp
operator|.
name|getTabSample
argument_list|(
name|alias_id
argument_list|)
decl_stmt|;
if|if
condition|(
name|tableSample
operator|!=
literal|null
condition|)
block|{
name|SamplePruner
name|pruner
init|=
operator|new
name|SamplePruner
argument_list|(
name|alias
argument_list|,
name|tableSample
argument_list|)
decl_stmt|;
name|this
operator|.
name|aliasToSamplePruner
operator|.
name|put
argument_list|(
name|alias_id
argument_list|,
name|pruner
argument_list|)
expr_stmt|;
block|}
block|}
block|}
specifier|private
name|void
name|getMetaData
parameter_list|(
name|QBExpr
name|qbexpr
parameter_list|)
throws|throws
name|SemanticException
block|{
if|if
condition|(
name|qbexpr
operator|.
name|getOpcode
argument_list|()
operator|==
name|QBExpr
operator|.
name|Opcode
operator|.
name|NULLOP
condition|)
block|{
name|getMetaData
argument_list|(
name|qbexpr
operator|.
name|getQB
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|getMetaData
argument_list|(
name|qbexpr
operator|.
name|getQBExpr1
argument_list|()
argument_list|)
expr_stmt|;
name|getMetaData
argument_list|(
name|qbexpr
operator|.
name|getQBExpr2
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"nls"
argument_list|)
specifier|private
name|void
name|getMetaData
parameter_list|(
name|QB
name|qb
parameter_list|)
throws|throws
name|SemanticException
block|{
try|try
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Get metadata for source tables"
argument_list|)
expr_stmt|;
comment|// Go over the tables and populate the related structures
for|for
control|(
name|String
name|alias
range|:
name|qb
operator|.
name|getTabAliases
argument_list|()
control|)
block|{
name|String
name|tab_name
init|=
name|qb
operator|.
name|getTabNameForAlias
argument_list|(
name|alias
argument_list|)
decl_stmt|;
name|Table
name|tab
init|=
literal|null
decl_stmt|;
try|try
block|{
name|tab
operator|=
name|this
operator|.
name|db
operator|.
name|getTable
argument_list|(
name|tab_name
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InvalidTableException
name|ite
parameter_list|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|INVALID_TABLE
operator|.
name|getMsg
argument_list|(
name|qb
operator|.
name|getParseInfo
argument_list|()
operator|.
name|getSrcForAlias
argument_list|(
name|alias
argument_list|)
argument_list|)
argument_list|)
throw|;
block|}
name|qb
operator|.
name|getMetaData
argument_list|()
operator|.
name|setSrcForAlias
argument_list|(
name|alias
argument_list|,
name|tab
argument_list|)
expr_stmt|;
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"Get metadata for subqueries"
argument_list|)
expr_stmt|;
comment|// Go over the subqueries and getMetaData for these
for|for
control|(
name|String
name|alias
range|:
name|qb
operator|.
name|getSubqAliases
argument_list|()
control|)
block|{
name|QBExpr
name|qbexpr
init|=
name|qb
operator|.
name|getSubqForAlias
argument_list|(
name|alias
argument_list|)
decl_stmt|;
name|getMetaData
argument_list|(
name|qbexpr
argument_list|)
expr_stmt|;
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"Get metadata for destination tables"
argument_list|)
expr_stmt|;
comment|// Go over all the destination structures and populate the related
comment|// metadata
name|QBParseInfo
name|qbp
init|=
name|qb
operator|.
name|getParseInfo
argument_list|()
decl_stmt|;
for|for
control|(
name|String
name|name
range|:
name|qbp
operator|.
name|getClauseNamesForDest
argument_list|()
control|)
block|{
name|CommonTree
name|ast
init|=
name|qbp
operator|.
name|getDestForClause
argument_list|(
name|name
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|ast
operator|.
name|getToken
argument_list|()
operator|.
name|getType
argument_list|()
condition|)
block|{
case|case
name|HiveParser
operator|.
name|TOK_TAB
case|:
block|{
name|tableSpec
name|ts
init|=
operator|new
name|tableSpec
argument_list|(
name|this
operator|.
name|db
argument_list|,
name|ast
argument_list|)
decl_stmt|;
if|if
condition|(
name|ts
operator|.
name|partSpec
operator|==
literal|null
condition|)
block|{
comment|// This is a table
name|qb
operator|.
name|getMetaData
argument_list|()
operator|.
name|setDestForAlias
argument_list|(
name|name
argument_list|,
name|ts
operator|.
name|tableHandle
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// This is a partition
name|qb
operator|.
name|getMetaData
argument_list|()
operator|.
name|setDestForAlias
argument_list|(
name|name
argument_list|,
name|ts
operator|.
name|partHandle
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
case|case
name|HiveParser
operator|.
name|TOK_LOCAL_DIR
case|:
case|case
name|HiveParser
operator|.
name|TOK_DIR
case|:
block|{
comment|// This is a dfs file
name|String
name|fname
init|=
name|stripQuotes
argument_list|(
name|ast
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getText
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
operator|!
name|qb
operator|.
name|getParseInfo
argument_list|()
operator|.
name|getIsSubQ
argument_list|()
operator|)
operator|&&
operator|(
operator|(
operator|(
name|CommonTree
operator|)
name|ast
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|)
operator|.
name|getToken
argument_list|()
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_TMP_FILE
operator|)
condition|)
block|{
name|fname
operator|=
name|getTmpFileName
argument_list|()
expr_stmt|;
name|ctx
operator|.
name|setResDir
argument_list|(
operator|new
name|Path
argument_list|(
name|fname
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|qb
operator|.
name|getMetaData
argument_list|()
operator|.
name|setDestForAlias
argument_list|(
name|name
argument_list|,
name|fname
argument_list|,
operator|(
name|ast
operator|.
name|getToken
argument_list|()
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_DIR
operator|)
argument_list|)
expr_stmt|;
break|break;
block|}
default|default:
throw|throw
operator|new
name|SemanticException
argument_list|(
literal|"Unknown Token Type "
operator|+
name|ast
operator|.
name|getToken
argument_list|()
operator|.
name|getType
argument_list|()
argument_list|)
throw|;
block|}
block|}
block|}
catch|catch
parameter_list|(
name|HiveException
name|e
parameter_list|)
block|{
comment|// Has to use full name to make sure it does not conflict with org.apache.commons.lang.StringUtils
name|LOG
operator|.
name|error
argument_list|(
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|StringUtils
operator|.
name|stringifyException
argument_list|(
name|e
argument_list|)
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|SemanticException
argument_list|(
name|e
operator|.
name|getMessage
argument_list|()
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"nls"
argument_list|)
specifier|public
specifier|static
name|String
name|getJEXLOpName
parameter_list|(
name|String
name|name
parameter_list|)
block|{
if|if
condition|(
name|name
operator|.
name|equalsIgnoreCase
argument_list|(
literal|"AND"
argument_list|)
condition|)
block|{
return|return
literal|"&&"
return|;
block|}
elseif|else
if|if
condition|(
name|name
operator|.
name|equalsIgnoreCase
argument_list|(
literal|"OR"
argument_list|)
condition|)
block|{
return|return
literal|"||"
return|;
block|}
elseif|else
if|if
condition|(
name|name
operator|.
name|equalsIgnoreCase
argument_list|(
literal|"NOT"
argument_list|)
condition|)
block|{
return|return
literal|"!"
return|;
block|}
elseif|else
if|if
condition|(
name|name
operator|.
name|equalsIgnoreCase
argument_list|(
literal|"="
argument_list|)
condition|)
block|{
return|return
literal|"=="
return|;
block|}
elseif|else
if|if
condition|(
name|name
operator|.
name|equalsIgnoreCase
argument_list|(
literal|"<>"
argument_list|)
condition|)
block|{
return|return
literal|"!="
return|;
block|}
elseif|else
if|if
condition|(
name|name
operator|.
name|equalsIgnoreCase
argument_list|(
literal|"NULL"
argument_list|)
condition|)
block|{
return|return
literal|"== NULL"
return|;
block|}
elseif|else
if|if
condition|(
name|name
operator|.
name|equalsIgnoreCase
argument_list|(
literal|"NOT NULL"
argument_list|)
condition|)
block|{
return|return
literal|"!= NULL"
return|;
block|}
else|else
block|{
return|return
name|name
return|;
block|}
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"nls"
argument_list|)
specifier|public
specifier|static
name|String
name|getJEXLFuncName
parameter_list|(
name|String
name|name
parameter_list|)
block|{
return|return
literal|"__udf__"
operator|+
name|name
return|;
block|}
specifier|private
name|boolean
name|isPresent
parameter_list|(
name|String
index|[]
name|list
parameter_list|,
name|String
name|elem
parameter_list|)
block|{
for|for
control|(
name|String
name|s
range|:
name|list
control|)
if|if
condition|(
name|s
operator|.
name|equals
argument_list|(
name|elem
argument_list|)
condition|)
return|return
literal|true
return|;
return|return
literal|false
return|;
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"nls"
argument_list|)
specifier|private
name|void
name|parseJoinCondPopulateAlias
parameter_list|(
name|QBJoinTree
name|joinTree
parameter_list|,
name|CommonTree
name|condn
parameter_list|,
name|Vector
argument_list|<
name|String
argument_list|>
name|leftAliases
parameter_list|,
name|Vector
argument_list|<
name|String
argument_list|>
name|rightAliases
parameter_list|)
throws|throws
name|SemanticException
block|{
comment|// String[] allAliases = joinTree.getAllAliases();
switch|switch
condition|(
name|condn
operator|.
name|getToken
argument_list|()
operator|.
name|getType
argument_list|()
condition|)
block|{
case|case
name|HiveParser
operator|.
name|TOK_COLREF
case|:
name|String
name|tblName
init|=
name|condn
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getText
argument_list|()
decl_stmt|;
if|if
condition|(
name|isPresent
argument_list|(
name|joinTree
operator|.
name|getLeftAliases
argument_list|()
argument_list|,
name|tblName
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|leftAliases
operator|.
name|contains
argument_list|(
name|tblName
argument_list|)
condition|)
name|leftAliases
operator|.
name|add
argument_list|(
name|tblName
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|isPresent
argument_list|(
name|joinTree
operator|.
name|getRightAliases
argument_list|()
argument_list|,
name|tblName
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|rightAliases
operator|.
name|contains
argument_list|(
name|tblName
argument_list|)
condition|)
name|rightAliases
operator|.
name|add
argument_list|(
name|tblName
argument_list|)
expr_stmt|;
block|}
else|else
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|INVALID_TABLE_ALIAS
operator|.
name|getMsg
argument_list|(
name|condn
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
argument_list|)
argument_list|)
throw|;
break|break;
case|case
name|HiveParser
operator|.
name|Number
case|:
case|case
name|HiveParser
operator|.
name|StringLiteral
case|:
case|case
name|HiveParser
operator|.
name|KW_TRUE
case|:
case|case
name|HiveParser
operator|.
name|KW_FALSE
case|:
break|break;
case|case
name|HiveParser
operator|.
name|TOK_FUNCTION
case|:
comment|// check all the arguments
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<
name|condn
operator|.
name|getChildCount
argument_list|()
condition|;
name|i
operator|++
control|)
name|parseJoinCondPopulateAlias
argument_list|(
name|joinTree
argument_list|,
operator|(
name|CommonTree
operator|)
name|condn
operator|.
name|getChild
argument_list|(
name|i
argument_list|)
argument_list|,
name|leftAliases
argument_list|,
name|rightAliases
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|// This is an operator - so check whether it is unary or binary operator
if|if
condition|(
name|condn
operator|.
name|getChildCount
argument_list|()
operator|==
literal|1
condition|)
name|parseJoinCondPopulateAlias
argument_list|(
name|joinTree
argument_list|,
operator|(
name|CommonTree
operator|)
name|condn
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
argument_list|,
name|leftAliases
argument_list|,
name|rightAliases
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|condn
operator|.
name|getChildCount
argument_list|()
operator|==
literal|2
condition|)
block|{
name|parseJoinCondPopulateAlias
argument_list|(
name|joinTree
argument_list|,
operator|(
name|CommonTree
operator|)
name|condn
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
argument_list|,
name|leftAliases
argument_list|,
name|rightAliases
argument_list|)
expr_stmt|;
name|parseJoinCondPopulateAlias
argument_list|(
name|joinTree
argument_list|,
operator|(
name|CommonTree
operator|)
name|condn
operator|.
name|getChild
argument_list|(
literal|1
argument_list|)
argument_list|,
name|leftAliases
argument_list|,
name|rightAliases
argument_list|)
expr_stmt|;
block|}
else|else
throw|throw
operator|new
name|SemanticException
argument_list|(
name|condn
operator|.
name|toStringTree
argument_list|()
operator|+
literal|" encountered with "
operator|+
name|condn
operator|.
name|getChildCount
argument_list|()
operator|+
literal|" children"
argument_list|)
throw|;
break|break;
block|}
block|}
specifier|private
name|void
name|populateAliases
parameter_list|(
name|Vector
argument_list|<
name|String
argument_list|>
name|leftAliases
parameter_list|,
name|Vector
argument_list|<
name|String
argument_list|>
name|rightAliases
parameter_list|,
name|CommonTree
name|condn
parameter_list|,
name|QBJoinTree
name|joinTree
parameter_list|,
name|Vector
argument_list|<
name|String
argument_list|>
name|leftSrc
parameter_list|)
throws|throws
name|SemanticException
block|{
if|if
condition|(
operator|(
name|leftAliases
operator|.
name|size
argument_list|()
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|rightAliases
operator|.
name|size
argument_list|()
operator|!=
literal|0
operator|)
condition|)
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|INVALID_JOIN_CONDITION_1
operator|.
name|getMsg
argument_list|(
name|condn
argument_list|)
argument_list|)
throw|;
if|if
condition|(
name|rightAliases
operator|.
name|size
argument_list|()
operator|!=
literal|0
condition|)
block|{
assert|assert
name|rightAliases
operator|.
name|size
argument_list|()
operator|==
literal|1
assert|;
name|joinTree
operator|.
name|getExpressions
argument_list|()
operator|.
name|get
argument_list|(
literal|1
argument_list|)
operator|.
name|add
argument_list|(
name|condn
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|leftAliases
operator|.
name|size
argument_list|()
operator|!=
literal|0
condition|)
block|{
name|joinTree
operator|.
name|getExpressions
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|add
argument_list|(
name|condn
argument_list|)
expr_stmt|;
for|for
control|(
name|String
name|s
range|:
name|leftAliases
control|)
if|if
condition|(
operator|!
name|leftSrc
operator|.
name|contains
argument_list|(
name|s
argument_list|)
condition|)
name|leftSrc
operator|.
name|add
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
else|else
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|INVALID_JOIN_CONDITION_2
operator|.
name|getMsg
argument_list|(
name|condn
argument_list|)
argument_list|)
throw|;
block|}
specifier|private
name|void
name|parseJoinCondition
parameter_list|(
name|CommonTree
name|joinParseTree
parameter_list|,
name|QBJoinTree
name|joinTree
parameter_list|,
name|CommonTree
name|joinCond
parameter_list|,
name|Vector
argument_list|<
name|String
argument_list|>
name|leftSrc
parameter_list|)
throws|throws
name|SemanticException
block|{
switch|switch
condition|(
name|joinCond
operator|.
name|getToken
argument_list|()
operator|.
name|getType
argument_list|()
condition|)
block|{
case|case
name|HiveParser
operator|.
name|KW_AND
case|:
name|parseJoinCondition
argument_list|(
name|joinParseTree
argument_list|,
name|joinTree
argument_list|,
operator|(
name|CommonTree
operator|)
name|joinCond
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
argument_list|,
name|leftSrc
argument_list|)
expr_stmt|;
name|parseJoinCondition
argument_list|(
name|joinParseTree
argument_list|,
name|joinTree
argument_list|,
operator|(
name|CommonTree
operator|)
name|joinCond
operator|.
name|getChild
argument_list|(
literal|1
argument_list|)
argument_list|,
name|leftSrc
argument_list|)
expr_stmt|;
break|break;
case|case
name|HiveParser
operator|.
name|EQUAL
case|:
name|CommonTree
name|leftCondn
init|=
operator|(
name|CommonTree
operator|)
name|joinCond
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|Vector
argument_list|<
name|String
argument_list|>
name|leftAliases
init|=
operator|new
name|Vector
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
name|Vector
argument_list|<
name|String
argument_list|>
name|rightAliases
init|=
operator|new
name|Vector
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
name|parseJoinCondPopulateAlias
argument_list|(
name|joinTree
argument_list|,
name|leftCondn
argument_list|,
name|leftAliases
argument_list|,
name|rightAliases
argument_list|)
expr_stmt|;
name|populateAliases
argument_list|(
name|leftAliases
argument_list|,
name|rightAliases
argument_list|,
name|leftCondn
argument_list|,
name|joinTree
argument_list|,
name|leftSrc
argument_list|)
expr_stmt|;
name|CommonTree
name|rightCondn
init|=
operator|(
name|CommonTree
operator|)
name|joinCond
operator|.
name|getChild
argument_list|(
literal|1
argument_list|)
decl_stmt|;
name|leftAliases
operator|.
name|clear
argument_list|()
expr_stmt|;
name|rightAliases
operator|.
name|clear
argument_list|()
expr_stmt|;
name|parseJoinCondPopulateAlias
argument_list|(
name|joinTree
argument_list|,
name|rightCondn
argument_list|,
name|leftAliases
argument_list|,
name|rightAliases
argument_list|)
expr_stmt|;
name|populateAliases
argument_list|(
name|leftAliases
argument_list|,
name|rightAliases
argument_list|,
name|rightCondn
argument_list|,
name|joinTree
argument_list|,
name|leftSrc
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
comment|/**    * Returns the expression for the SerDe field.    * @return null if the tree cannot be represented by a SerDe field.    */
specifier|public
specifier|static
name|String
name|getSerDeFieldExpression
parameter_list|(
name|CommonTree
name|node
parameter_list|)
block|{
if|if
condition|(
name|node
operator|.
name|getToken
argument_list|()
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_COLREF
condition|)
block|{
comment|// String tabAlias = node.getChild(0).getText();
name|String
name|colName
init|=
name|node
operator|.
name|getChild
argument_list|(
literal|1
argument_list|)
operator|.
name|getText
argument_list|()
decl_stmt|;
return|return
name|colName
return|;
block|}
if|if
condition|(
name|node
operator|.
name|getChildCount
argument_list|()
operator|!=
literal|2
condition|)
block|{
return|return
literal|null
return|;
block|}
name|String
name|left
init|=
name|getSerDeFieldExpression
argument_list|(
operator|(
name|CommonTree
operator|)
name|node
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|left
operator|==
literal|null
condition|)
return|return
literal|null
return|;
if|if
condition|(
name|node
operator|.
name|getToken
argument_list|()
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|DOT
condition|)
block|{
return|return
name|left
operator|+
literal|'.'
operator|+
name|node
operator|.
name|getChild
argument_list|(
literal|1
argument_list|)
operator|.
name|getText
argument_list|()
return|;
block|}
elseif|else
if|if
condition|(
name|node
operator|.
name|getToken
argument_list|()
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|LSQUARE
condition|)
block|{
return|return
name|left
operator|+
literal|'['
operator|+
name|node
operator|.
name|getChild
argument_list|(
literal|1
argument_list|)
operator|.
name|getText
argument_list|()
operator|+
literal|']'
return|;
block|}
return|return
literal|null
return|;
block|}
comment|/**    * Returns the table name for the SerDe field.    * @return null if the tree cannot be represented by a SerDe field.    */
specifier|public
specifier|static
name|String
name|getTableName
parameter_list|(
name|CommonTree
name|node
parameter_list|)
block|{
while|while
condition|(
name|node
operator|.
name|getToken
argument_list|()
operator|.
name|getType
argument_list|()
operator|!=
name|HiveParser
operator|.
name|TOK_COLREF
condition|)
block|{
if|if
condition|(
name|node
operator|.
name|getChildCount
argument_list|()
operator|!=
literal|2
condition|)
return|return
literal|null
return|;
name|node
operator|=
operator|(
name|CommonTree
operator|)
name|node
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
return|return
name|node
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getText
argument_list|()
return|;
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"nls"
argument_list|)
specifier|private
name|OperatorInfoList
name|genFilterPlan
parameter_list|(
name|String
name|dest
parameter_list|,
name|QB
name|qb
parameter_list|,
name|OperatorInfoList
name|input
parameter_list|)
throws|throws
name|SemanticException
block|{
comment|// We can assert here that the input list is of size one
if|if
condition|(
name|input
operator|.
name|size
argument_list|()
operator|!=
literal|1
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
literal|"Filter has more than one inputs"
argument_list|)
throw|;
block|}
name|CommonTree
name|whereExpr
init|=
name|qb
operator|.
name|getParseInfo
argument_list|()
operator|.
name|getWhrForClause
argument_list|(
name|dest
argument_list|)
decl_stmt|;
name|OperatorInfoList
name|output
init|=
operator|(
name|OperatorInfoList
operator|)
name|input
operator|.
name|clone
argument_list|()
decl_stmt|;
name|output
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|setOp
argument_list|(
name|OperatorFactory
operator|.
name|getAndMakeChild
argument_list|(
operator|new
name|filterDesc
argument_list|(
name|genExprNodeDesc
argument_list|(
operator|(
name|CommonTree
operator|)
name|whereExpr
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
argument_list|,
name|qb
operator|.
name|getParseInfo
argument_list|()
operator|.
name|getAlias
argument_list|()
argument_list|,
name|input
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|getRowResolver
argument_list|()
argument_list|)
argument_list|)
argument_list|,
operator|new
name|RowSchema
argument_list|(
name|output
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|getRowResolver
argument_list|()
operator|.
name|getColumnInfos
argument_list|()
argument_list|)
argument_list|,
name|input
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|getOp
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Created Filter Plan for "
operator|+
name|qb
operator|.
name|getId
argument_list|()
operator|+
literal|":"
operator|+
name|dest
operator|+
literal|" row schema: "
operator|+
name|output
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|getRowResolver
argument_list|()
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|output
return|;
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"nls"
argument_list|)
specifier|private
name|void
name|genColList
parameter_list|(
name|String
name|alias
parameter_list|,
name|CommonTree
name|sel
parameter_list|,
name|ArrayList
argument_list|<
name|exprNodeDesc
argument_list|>
name|col_list
parameter_list|,
name|RowResolver
name|input
parameter_list|,
name|Integer
name|pos
parameter_list|,
name|RowResolver
name|output
parameter_list|,
name|String
name|colAlias
parameter_list|)
throws|throws
name|SemanticException
block|{
comment|// TODO: Have to put in the support for AS clause
name|String
name|tabName
init|=
operator|(
operator|(
name|CommonTree
operator|)
name|sel
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|)
operator|.
name|getToken
argument_list|()
operator|.
name|getText
argument_list|()
decl_stmt|;
name|ArrayList
argument_list|<
name|TypeInfo
argument_list|>
name|fieldTypeList
init|=
operator|new
name|ArrayList
argument_list|<
name|TypeInfo
argument_list|>
argument_list|()
decl_stmt|;
name|ArrayList
argument_list|<
name|String
argument_list|>
name|fieldList
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
if|if
condition|(
name|sel
operator|.
name|getToken
argument_list|()
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_ALLCOLREF
condition|)
block|{
comment|// This is the tab.* case
comment|// In this case add all the columns to the fieldList
comment|// from the input schema
for|for
control|(
name|ColumnInfo
name|colInfo
range|:
name|input
operator|.
name|getColumnInfos
argument_list|()
control|)
block|{
name|String
name|name
init|=
name|colInfo
operator|.
name|getInternalName
argument_list|()
decl_stmt|;
name|String
index|[]
name|tmp
init|=
name|input
operator|.
name|reverseLookup
argument_list|(
name|name
argument_list|)
decl_stmt|;
name|fieldList
operator|.
name|add
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|fieldTypeList
operator|.
name|add
argument_list|(
name|colInfo
operator|.
name|getType
argument_list|()
argument_list|)
expr_stmt|;
name|output
operator|.
name|put
argument_list|(
name|alias
argument_list|,
name|tmp
index|[
literal|1
index|]
argument_list|,
operator|new
name|ColumnInfo
argument_list|(
name|pos
operator|.
name|toString
argument_list|()
argument_list|,
name|colInfo
operator|.
name|getType
argument_list|()
argument_list|,
name|colInfo
operator|.
name|getIsVirtual
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|pos
operator|=
name|Integer
operator|.
name|valueOf
argument_list|(
name|pos
operator|.
name|intValue
argument_list|()
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// For now only allow columns of the form tab.col
if|if
condition|(
name|sel
operator|.
name|getChildCount
argument_list|()
operator|==
literal|1
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|NO_TABLE_ALIAS
operator|.
name|getMsg
argument_list|(
name|sel
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
argument_list|)
argument_list|)
throw|;
block|}
comment|// Lookup the name from the input
name|ColumnInfo
name|colInfo
init|=
name|input
operator|.
name|get
argument_list|(
name|tabName
argument_list|,
name|sel
operator|.
name|getChild
argument_list|(
literal|1
argument_list|)
operator|.
name|getText
argument_list|()
argument_list|)
decl_stmt|;
comment|// TODO: Hack it up for now: Later we have to pass the QB in order to check for the
comment|// table alias instead of relying on input.hasTableAlias
if|if
condition|(
name|colInfo
operator|==
literal|null
operator|&&
name|input
operator|.
name|getIsExprResolver
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|NON_KEY_EXPR_IN_GROUPBY
operator|.
name|getMsg
argument_list|(
name|sel
argument_list|)
argument_list|)
throw|;
block|}
elseif|else
if|if
condition|(
operator|!
name|input
operator|.
name|hasTableAlias
argument_list|(
name|tabName
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|INVALID_TABLE_ALIAS
operator|.
name|getMsg
argument_list|(
name|sel
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
argument_list|)
argument_list|)
throw|;
block|}
elseif|else
if|if
condition|(
name|colInfo
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|INVALID_COLUMN
operator|.
name|getMsg
argument_list|(
name|sel
operator|.
name|getChild
argument_list|(
literal|1
argument_list|)
argument_list|)
argument_list|)
throw|;
block|}
comment|// Add to the field list
name|fieldList
operator|.
name|add
argument_list|(
name|colInfo
operator|.
name|getInternalName
argument_list|()
argument_list|)
expr_stmt|;
name|fieldTypeList
operator|.
name|add
argument_list|(
name|colInfo
operator|.
name|getType
argument_list|()
argument_list|)
expr_stmt|;
comment|// Add to the output
if|if
condition|(
operator|!
name|StringUtils
operator|.
name|isEmpty
argument_list|(
name|alias
argument_list|)
operator|&&
operator|(
name|output
operator|.
name|get
argument_list|(
name|alias
argument_list|,
name|colAlias
argument_list|)
operator|!=
literal|null
operator|)
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|AMBIGOUS_COLUMN
operator|.
name|getMsg
argument_list|(
name|sel
operator|.
name|getChild
argument_list|(
literal|1
argument_list|)
argument_list|)
argument_list|)
throw|;
block|}
name|output
operator|.
name|put
argument_list|(
name|alias
argument_list|,
name|colAlias
argument_list|,
operator|new
name|ColumnInfo
argument_list|(
name|pos
operator|.
name|toString
argument_list|()
argument_list|,
name|colInfo
operator|.
name|getType
argument_list|()
argument_list|,
name|colInfo
operator|.
name|getIsVirtual
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|pos
operator|=
name|Integer
operator|.
name|valueOf
argument_list|(
name|pos
operator|.
name|intValue
argument_list|()
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
comment|// Generate the corresponding expressions
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|fieldList
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
comment|// Get the first expression
name|exprNodeColumnDesc
name|expr
init|=
operator|new
name|exprNodeColumnDesc
argument_list|(
name|fieldTypeList
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|,
name|fieldList
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|)
decl_stmt|;
name|col_list
operator|.
name|add
argument_list|(
name|expr
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"nls"
argument_list|)
specifier|private
name|OperatorInfoList
name|genScriptPlan
parameter_list|(
name|CommonTree
name|trfm
parameter_list|,
name|QB
name|qb
parameter_list|,
name|OperatorInfoList
name|input
parameter_list|)
throws|throws
name|SemanticException
block|{
comment|// We can assert here that the input list is of size one
if|if
condition|(
name|input
operator|.
name|size
argument_list|()
operator|!=
literal|1
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
literal|"Select has more than one inputs"
argument_list|)
throw|;
block|}
name|OperatorInfoList
name|output
init|=
operator|(
name|OperatorInfoList
operator|)
name|input
operator|.
name|clone
argument_list|()
decl_stmt|;
comment|// Change the rws in this case
name|CommonTree
name|collist
init|=
operator|(
name|CommonTree
operator|)
name|trfm
operator|.
name|getChild
argument_list|(
literal|1
argument_list|)
decl_stmt|;
name|int
name|ccount
init|=
name|collist
operator|.
name|getChildCount
argument_list|()
decl_stmt|;
name|RowResolver
name|out_rwsch
init|=
operator|new
name|RowResolver
argument_list|()
decl_stmt|;
name|StringBuilder
name|sb
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|ccount
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|i
operator|!=
literal|0
condition|)
block|{
name|sb
operator|.
name|append
argument_list|(
literal|","
argument_list|)
expr_stmt|;
block|}
name|sb
operator|.
name|append
argument_list|(
operator|(
operator|(
name|CommonTree
operator|)
name|collist
operator|.
name|getChild
argument_list|(
name|i
argument_list|)
operator|)
operator|.
name|getText
argument_list|()
argument_list|)
expr_stmt|;
name|out_rwsch
operator|.
name|put
argument_list|(
name|qb
operator|.
name|getParseInfo
argument_list|()
operator|.
name|getAlias
argument_list|()
argument_list|,
operator|(
operator|(
name|CommonTree
operator|)
name|collist
operator|.
name|getChild
argument_list|(
name|i
argument_list|)
operator|)
operator|.
name|getText
argument_list|()
argument_list|,
operator|new
name|ColumnInfo
argument_list|(
operator|(
operator|(
name|CommonTree
operator|)
name|collist
operator|.
name|getChild
argument_list|(
name|i
argument_list|)
operator|)
operator|.
name|getText
argument_list|()
argument_list|,
name|String
operator|.
name|class
argument_list|,
literal|false
argument_list|)
comment|// Everything is a string right now
argument_list|)
expr_stmt|;
block|}
name|output
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|setOp
argument_list|(
name|OperatorFactory
operator|.
name|getAndMakeChild
argument_list|(
operator|new
name|scriptDesc
argument_list|(
name|stripQuotes
argument_list|(
name|trfm
operator|.
name|getChild
argument_list|(
literal|2
argument_list|)
operator|.
name|getText
argument_list|()
argument_list|)
argument_list|,
operator|new
name|tableDesc
argument_list|(
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde
operator|.
name|simple_meta
operator|.
name|MetadataTypedColumnsetSerDe
operator|.
name|class
argument_list|,
name|TextInputFormat
operator|.
name|class
argument_list|,
name|IgnoreKeyTextOutputFormat
operator|.
name|class
argument_list|,
name|Utilities
operator|.
name|makeProperties
argument_list|(
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde
operator|.
name|Constants
operator|.
name|SERIALIZATION_FORMAT
argument_list|,
literal|""
operator|+
name|Utilities
operator|.
name|tabCode
argument_list|,
literal|"columns"
argument_list|,
name|sb
operator|.
name|toString
argument_list|()
argument_list|)
argument_list|)
argument_list|)
argument_list|,
operator|new
name|RowSchema
argument_list|(
name|out_rwsch
operator|.
name|getColumnInfos
argument_list|()
argument_list|)
argument_list|,
name|input
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|getOp
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|output
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|setRowResolver
argument_list|(
name|out_rwsch
argument_list|)
expr_stmt|;
return|return
name|output
return|;
block|}
comment|/**    * This function is a wrapper of parseInfo.getGroupByForClause which automatically    * translates SELECT DISTINCT a,b,c to SELECT a,b,c GROUP BY a,b,c.    */
specifier|static
name|List
argument_list|<
name|CommonTree
argument_list|>
name|getGroupByForClause
parameter_list|(
name|QBParseInfo
name|parseInfo
parameter_list|,
name|String
name|dest
parameter_list|)
block|{
if|if
condition|(
name|parseInfo
operator|.
name|getSelForClause
argument_list|(
name|dest
argument_list|)
operator|.
name|getToken
argument_list|()
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_SELECTDI
condition|)
block|{
name|CommonTree
name|selectExprs
init|=
name|parseInfo
operator|.
name|getSelForClause
argument_list|(
name|dest
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|CommonTree
argument_list|>
name|result
init|=
operator|new
name|ArrayList
argument_list|<
name|CommonTree
argument_list|>
argument_list|(
name|selectExprs
operator|==
literal|null
condition|?
literal|0
else|:
name|selectExprs
operator|.
name|getChildCount
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|selectExprs
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|selectExprs
operator|.
name|getChildCount
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
comment|// table.column AS alias
name|CommonTree
name|grpbyExpr
init|=
operator|(
name|CommonTree
operator|)
name|selectExprs
operator|.
name|getChild
argument_list|(
name|i
argument_list|)
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|result
operator|.
name|add
argument_list|(
name|grpbyExpr
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|result
return|;
block|}
else|else
block|{
name|CommonTree
name|grpByExprs
init|=
name|parseInfo
operator|.
name|getGroupByForClause
argument_list|(
name|dest
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|CommonTree
argument_list|>
name|result
init|=
operator|new
name|ArrayList
argument_list|<
name|CommonTree
argument_list|>
argument_list|(
name|grpByExprs
operator|==
literal|null
condition|?
literal|0
else|:
name|grpByExprs
operator|.
name|getChildCount
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|grpByExprs
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|grpByExprs
operator|.
name|getChildCount
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|CommonTree
name|grpbyExpr
init|=
operator|(
name|CommonTree
operator|)
name|grpByExprs
operator|.
name|getChild
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|result
operator|.
name|add
argument_list|(
name|grpbyExpr
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|result
return|;
block|}
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"nls"
argument_list|)
specifier|private
name|OperatorInfoList
name|genSelectPlan
parameter_list|(
name|String
name|dest
parameter_list|,
name|QB
name|qb
parameter_list|,
name|OperatorInfoList
name|input
parameter_list|)
throws|throws
name|SemanticException
block|{
comment|// We can assert here that the input list is of size one
if|if
condition|(
name|input
operator|.
name|size
argument_list|()
operator|!=
literal|1
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
literal|"Select has more than one inputs"
argument_list|)
throw|;
block|}
name|CommonTree
name|selExprList
init|=
name|qb
operator|.
name|getParseInfo
argument_list|()
operator|.
name|getSelForClause
argument_list|(
name|dest
argument_list|)
decl_stmt|;
name|ArrayList
argument_list|<
name|exprNodeDesc
argument_list|>
name|col_list
init|=
operator|new
name|ArrayList
argument_list|<
name|exprNodeDesc
argument_list|>
argument_list|()
decl_stmt|;
name|RowResolver
name|out_rwsch
init|=
operator|new
name|RowResolver
argument_list|()
decl_stmt|;
name|CommonTree
name|trfm
init|=
literal|null
decl_stmt|;
name|Integer
name|pos
init|=
name|Integer
operator|.
name|valueOf
argument_list|(
literal|0
argument_list|)
decl_stmt|;
comment|// Iterate over the selects
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|selExprList
operator|.
name|getChildCount
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
comment|// list of the columns
name|CommonTree
name|selExpr
init|=
operator|(
name|CommonTree
operator|)
name|selExprList
operator|.
name|getChild
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|String
name|colAlias
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|selExpr
operator|.
name|getChildCount
argument_list|()
operator|==
literal|2
condition|)
name|colAlias
operator|=
name|selExpr
operator|.
name|getChild
argument_list|(
literal|1
argument_list|)
operator|.
name|getText
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
name|selExpr
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getChildCount
argument_list|()
operator|>=
literal|2
condition|)
name|colAlias
operator|=
name|selExpr
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getChild
argument_list|(
literal|1
argument_list|)
operator|.
name|getText
argument_list|()
expr_stmt|;
name|CommonTree
name|sel
init|=
operator|(
name|CommonTree
operator|)
name|selExpr
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|sel
operator|.
name|getToken
argument_list|()
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_COLREF
operator|||
name|sel
operator|.
name|getToken
argument_list|()
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_ALLCOLREF
condition|)
block|{
name|genColList
argument_list|(
name|qb
operator|.
name|getParseInfo
argument_list|()
operator|.
name|getAlias
argument_list|()
argument_list|,
name|sel
argument_list|,
name|col_list
argument_list|,
name|input
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|getRowResolver
argument_list|()
argument_list|,
name|pos
argument_list|,
name|out_rwsch
argument_list|,
name|colAlias
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sel
operator|.
name|getToken
argument_list|()
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_TRANSFORM
condition|)
block|{
if|if
condition|(
name|i
operator|>
literal|0
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|INVALID_TRANSFORM
operator|.
name|getMsg
argument_list|(
name|sel
argument_list|)
argument_list|)
throw|;
block|}
name|trfm
operator|=
name|sel
expr_stmt|;
name|CommonTree
name|cols
init|=
operator|(
name|CommonTree
operator|)
name|trfm
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|cols
operator|.
name|getChildCount
argument_list|()
condition|;
operator|++
name|j
control|)
block|{
name|CommonTree
name|expr
init|=
operator|(
name|CommonTree
operator|)
name|cols
operator|.
name|getChild
argument_list|(
name|j
argument_list|)
decl_stmt|;
if|if
condition|(
name|expr
operator|.
name|getToken
argument_list|()
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_COLREF
operator|||
name|expr
operator|.
name|getToken
argument_list|()
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_ALLCOLREF
condition|)
block|{
name|genColList
argument_list|(
name|qb
operator|.
name|getParseInfo
argument_list|()
operator|.
name|getAlias
argument_list|()
argument_list|,
name|expr
argument_list|,
name|col_list
argument_list|,
name|input
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|getRowResolver
argument_list|()
argument_list|,
name|pos
argument_list|,
name|out_rwsch
argument_list|,
name|expr
operator|.
name|getChild
argument_list|(
literal|1
argument_list|)
operator|.
name|getText
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|exprNodeDesc
name|exp
init|=
name|genExprNodeDesc
argument_list|(
name|expr
argument_list|,
name|qb
operator|.
name|getParseInfo
argument_list|()
operator|.
name|getAlias
argument_list|()
argument_list|,
name|input
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|getRowResolver
argument_list|()
argument_list|)
decl_stmt|;
name|col_list
operator|.
name|add
argument_list|(
name|exp
argument_list|)
expr_stmt|;
name|out_rwsch
operator|.
name|put
argument_list|(
name|qb
operator|.
name|getParseInfo
argument_list|()
operator|.
name|getAlias
argument_list|()
argument_list|,
name|expr
operator|.
name|getText
argument_list|()
argument_list|,
operator|new
name|ColumnInfo
argument_list|(
operator|(
name|Integer
operator|.
name|valueOf
argument_list|(
name|pos
argument_list|)
operator|)
operator|.
name|toString
argument_list|()
argument_list|,
name|String
operator|.
name|class
argument_list|,
literal|false
argument_list|)
argument_list|)
expr_stmt|;
comment|// Everything is a string right now
block|}
block|}
block|}
else|else
block|{
comment|// Case when this is an expression
name|exprNodeDesc
name|exp
init|=
name|genExprNodeDesc
argument_list|(
name|sel
argument_list|,
name|qb
operator|.
name|getParseInfo
argument_list|()
operator|.
name|getAlias
argument_list|()
argument_list|,
name|input
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|getRowResolver
argument_list|()
argument_list|)
decl_stmt|;
name|col_list
operator|.
name|add
argument_list|(
name|exp
argument_list|)
expr_stmt|;
comment|// Since the as clause is lacking we just use the text representation
comment|// of the expression as the column name
name|out_rwsch
operator|.
name|put
argument_list|(
name|qb
operator|.
name|getParseInfo
argument_list|()
operator|.
name|getAlias
argument_list|()
argument_list|,
name|colAlias
argument_list|,
operator|new
name|ColumnInfo
argument_list|(
operator|(
name|Integer
operator|.
name|valueOf
argument_list|(
name|pos
argument_list|)
operator|)
operator|.
name|toString
argument_list|()
argument_list|,
name|String
operator|.
name|class
argument_list|,
literal|false
argument_list|)
argument_list|)
expr_stmt|;
comment|// Everything is a string right now
block|}
name|pos
operator|=
name|Integer
operator|.
name|valueOf
argument_list|(
name|pos
operator|.
name|intValue
argument_list|()
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
name|OperatorInfoList
name|output
init|=
operator|(
name|OperatorInfoList
operator|)
name|input
operator|.
name|clone
argument_list|()
decl_stmt|;
name|output
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|setOp
argument_list|(
name|OperatorFactory
operator|.
name|getAndMakeChild
argument_list|(
operator|new
name|selectDesc
argument_list|(
name|col_list
argument_list|)
argument_list|,
operator|new
name|RowSchema
argument_list|(
name|out_rwsch
operator|.
name|getColumnInfos
argument_list|()
argument_list|)
argument_list|,
name|input
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|getOp
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|output
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|setRowResolver
argument_list|(
name|out_rwsch
argument_list|)
expr_stmt|;
if|if
condition|(
name|trfm
operator|!=
literal|null
condition|)
block|{
name|output
operator|=
name|genScriptPlan
argument_list|(
name|trfm
argument_list|,
name|qb
argument_list|,
name|output
argument_list|)
expr_stmt|;
block|}
name|LOG
operator|.
name|debug
argument_list|(
literal|"Created Select Plan for clause: "
operator|+
name|dest
operator|+
literal|" row schema: "
operator|+
name|output
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|getRowResolver
argument_list|()
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|output
return|;
block|}
specifier|private
name|OperatorInfo
name|genGroupByPlanSelectOperator
parameter_list|(
name|QBParseInfo
name|parseInfo
parameter_list|,
name|String
name|dest
parameter_list|,
name|OperatorInfo
name|groupByOperatorInfo
parameter_list|)
throws|throws
name|SemanticException
block|{
name|RowResolver
name|groupByOutputRowResolver
init|=
name|groupByOperatorInfo
operator|.
name|getRowResolver
argument_list|()
decl_stmt|;
name|RowResolver
name|selectOutputRowResolver
init|=
operator|new
name|RowResolver
argument_list|()
decl_stmt|;
name|ArrayList
argument_list|<
name|exprNodeDesc
argument_list|>
name|selectCols
init|=
operator|new
name|ArrayList
argument_list|<
name|exprNodeDesc
argument_list|>
argument_list|()
decl_stmt|;
name|CommonTree
name|selectExpr
init|=
name|parseInfo
operator|.
name|getSelForClause
argument_list|(
name|dest
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|selectExpr
operator|.
name|getChildCount
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|CommonTree
name|sel
init|=
operator|(
name|CommonTree
operator|)
name|selectExpr
operator|.
name|getChild
argument_list|(
name|i
argument_list|)
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
decl_stmt|;
comment|// We need to recurse into the expression until we hit a UDAF or keys,
comment|// which are both in groupByOutputToColumns.
name|exprNodeDesc
name|exp
init|=
name|genExprNodeDesc
argument_list|(
name|sel
argument_list|,
name|parseInfo
operator|.
name|getAlias
argument_list|()
argument_list|,
name|groupByOutputRowResolver
argument_list|)
decl_stmt|;
name|selectCols
operator|.
name|add
argument_list|(
name|exp
argument_list|)
expr_stmt|;
name|selectOutputRowResolver
operator|.
name|put
argument_list|(
name|parseInfo
operator|.
name|getAlias
argument_list|()
argument_list|,
name|sel
operator|.
name|getText
argument_list|()
argument_list|,
operator|new
name|ColumnInfo
argument_list|(
operator|(
name|Integer
operator|.
name|valueOf
argument_list|(
name|i
argument_list|)
operator|)
operator|.
name|toString
argument_list|()
argument_list|,
name|String
operator|.
name|class
argument_list|,
literal|false
argument_list|)
argument_list|)
expr_stmt|;
comment|// Everything is a class right now
block|}
return|return
operator|new
name|OperatorInfo
argument_list|(
name|OperatorFactory
operator|.
name|getAndMakeChild
argument_list|(
operator|new
name|selectDesc
argument_list|(
name|selectCols
argument_list|)
argument_list|,
operator|new
name|RowSchema
argument_list|(
name|selectOutputRowResolver
operator|.
name|getColumnInfos
argument_list|()
argument_list|)
argument_list|,
name|groupByOperatorInfo
operator|.
name|getOp
argument_list|()
argument_list|)
argument_list|,
name|selectOutputRowResolver
argument_list|)
return|;
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"nls"
argument_list|)
specifier|private
name|OperatorInfo
name|genGroupByPlanGroupByOperator
parameter_list|(
name|QBParseInfo
name|parseInfo
parameter_list|,
name|String
name|dest
parameter_list|,
name|OperatorInfo
name|reduceSinkOperatorInfo
parameter_list|,
name|groupByDesc
operator|.
name|Mode
name|mode
parameter_list|)
throws|throws
name|SemanticException
block|{
name|RowResolver
name|gropuByInputRowResolver
init|=
name|reduceSinkOperatorInfo
operator|.
name|getRowResolver
argument_list|()
decl_stmt|;
name|RowResolver
name|groupByOutputRowResolver
init|=
operator|new
name|RowResolver
argument_list|()
decl_stmt|;
name|groupByOutputRowResolver
operator|.
name|setIsExprResolver
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|ArrayList
argument_list|<
name|exprNodeDesc
argument_list|>
name|groupByKeys
init|=
operator|new
name|ArrayList
argument_list|<
name|exprNodeDesc
argument_list|>
argument_list|()
decl_stmt|;
name|ArrayList
argument_list|<
name|aggregationDesc
argument_list|>
name|aggregations
init|=
operator|new
name|ArrayList
argument_list|<
name|aggregationDesc
argument_list|>
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|CommonTree
argument_list|>
name|grpByExprs
init|=
name|getGroupByForClause
argument_list|(
name|parseInfo
argument_list|,
name|dest
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|grpByExprs
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|CommonTree
name|grpbyExpr
init|=
name|grpByExprs
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|String
name|text
init|=
name|grpbyExpr
operator|.
name|toStringTree
argument_list|()
decl_stmt|;
name|ColumnInfo
name|exprInfo
init|=
name|gropuByInputRowResolver
operator|.
name|get
argument_list|(
literal|""
argument_list|,
name|text
argument_list|)
decl_stmt|;
if|if
condition|(
name|exprInfo
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|INVALID_COLUMN
operator|.
name|getMsg
argument_list|(
name|grpbyExpr
argument_list|)
argument_list|)
throw|;
block|}
name|groupByKeys
operator|.
name|add
argument_list|(
operator|new
name|exprNodeColumnDesc
argument_list|(
name|exprInfo
operator|.
name|getType
argument_list|()
argument_list|,
name|exprInfo
operator|.
name|getInternalName
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|String
name|field
init|=
operator|(
name|Integer
operator|.
name|valueOf
argument_list|(
name|i
argument_list|)
operator|)
operator|.
name|toString
argument_list|()
decl_stmt|;
name|groupByOutputRowResolver
operator|.
name|put
argument_list|(
literal|""
argument_list|,
name|grpbyExpr
operator|.
name|toStringTree
argument_list|()
argument_list|,
operator|new
name|ColumnInfo
argument_list|(
name|field
argument_list|,
name|exprInfo
operator|.
name|getType
argument_list|()
argument_list|,
name|exprInfo
operator|.
name|getIsVirtual
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// For each aggregation
name|HashMap
argument_list|<
name|String
argument_list|,
name|CommonTree
argument_list|>
name|aggregationTrees
init|=
name|parseInfo
operator|.
name|getAggregationExprsForClause
argument_list|(
name|dest
argument_list|)
decl_stmt|;
assert|assert
operator|(
name|aggregationTrees
operator|!=
literal|null
operator|)
assert|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|CommonTree
argument_list|>
name|entry
range|:
name|aggregationTrees
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|CommonTree
name|value
init|=
name|entry
operator|.
name|getValue
argument_list|()
decl_stmt|;
name|String
name|aggName
init|=
name|value
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getText
argument_list|()
decl_stmt|;
name|Class
argument_list|<
name|?
extends|extends
name|UDAF
argument_list|>
name|aggClass
init|=
name|UDAFRegistry
operator|.
name|getUDAF
argument_list|(
name|aggName
argument_list|)
decl_stmt|;
assert|assert
operator|(
name|aggClass
operator|!=
literal|null
operator|)
assert|;
name|ArrayList
argument_list|<
name|exprNodeDesc
argument_list|>
name|aggParameters
init|=
operator|new
name|ArrayList
argument_list|<
name|exprNodeDesc
argument_list|>
argument_list|()
decl_stmt|;
name|ArrayList
argument_list|<
name|Class
argument_list|<
name|?
argument_list|>
argument_list|>
name|aggClasses
init|=
operator|new
name|ArrayList
argument_list|<
name|Class
argument_list|<
name|?
argument_list|>
argument_list|>
argument_list|()
decl_stmt|;
comment|// 0 is the function name
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<
name|value
operator|.
name|getChildCount
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|String
name|text
init|=
name|value
operator|.
name|getChild
argument_list|(
name|i
argument_list|)
operator|.
name|toStringTree
argument_list|()
decl_stmt|;
name|CommonTree
name|paraExpr
init|=
operator|(
name|CommonTree
operator|)
name|value
operator|.
name|getChild
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|ColumnInfo
name|paraExprInfo
init|=
name|gropuByInputRowResolver
operator|.
name|get
argument_list|(
literal|""
argument_list|,
name|text
argument_list|)
decl_stmt|;
if|if
condition|(
name|paraExprInfo
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|INVALID_COLUMN
operator|.
name|getMsg
argument_list|(
name|paraExpr
argument_list|)
argument_list|)
throw|;
block|}
name|String
name|paraExpression
init|=
name|paraExprInfo
operator|.
name|getInternalName
argument_list|()
decl_stmt|;
assert|assert
operator|(
name|paraExpression
operator|!=
literal|null
operator|)
assert|;
name|aggParameters
operator|.
name|add
argument_list|(
operator|new
name|exprNodeColumnDesc
argument_list|(
name|paraExprInfo
operator|.
name|getType
argument_list|()
argument_list|,
name|paraExprInfo
operator|.
name|getInternalName
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|aggClasses
operator|.
name|add
argument_list|(
name|paraExprInfo
operator|.
name|getType
argument_list|()
operator|.
name|getPrimitiveClass
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
literal|null
operator|==
name|UDAFRegistry
operator|.
name|getUDAFMethod
argument_list|(
name|aggName
argument_list|,
name|aggClasses
argument_list|)
condition|)
block|{
name|String
name|reason
init|=
literal|"Looking for UDAF \""
operator|+
name|aggName
operator|+
literal|"\" with parameters "
operator|+
name|aggClasses
decl_stmt|;
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|INVALID_FUNCTION_SIGNATURE
operator|.
name|getMsg
argument_list|(
operator|(
name|CommonTree
operator|)
name|value
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
argument_list|,
name|reason
argument_list|)
argument_list|)
throw|;
block|}
name|aggregations
operator|.
name|add
argument_list|(
operator|new
name|aggregationDesc
argument_list|(
name|aggClass
argument_list|,
name|aggParameters
argument_list|,
name|value
operator|.
name|getToken
argument_list|()
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_FUNCTIONDI
argument_list|)
argument_list|)
expr_stmt|;
name|groupByOutputRowResolver
operator|.
name|put
argument_list|(
literal|""
argument_list|,
name|value
operator|.
name|toStringTree
argument_list|()
argument_list|,
operator|new
name|ColumnInfo
argument_list|(
name|Integer
operator|.
name|valueOf
argument_list|(
name|groupByKeys
operator|.
name|size
argument_list|()
operator|+
name|aggregations
operator|.
name|size
argument_list|()
operator|-
literal|1
argument_list|)
operator|.
name|toString
argument_list|()
argument_list|,
name|String
operator|.
name|class
argument_list|,
literal|false
argument_list|)
argument_list|)
expr_stmt|;
comment|// Everything is a string right now
block|}
return|return
operator|new
name|OperatorInfo
argument_list|(
name|OperatorFactory
operator|.
name|getAndMakeChild
argument_list|(
operator|new
name|groupByDesc
argument_list|(
name|mode
argument_list|,
name|groupByKeys
argument_list|,
name|aggregations
argument_list|)
argument_list|,
operator|new
name|RowSchema
argument_list|(
name|groupByOutputRowResolver
operator|.
name|getColumnInfos
argument_list|()
argument_list|)
argument_list|,
name|reduceSinkOperatorInfo
operator|.
name|getOp
argument_list|()
argument_list|)
argument_list|,
name|groupByOutputRowResolver
argument_list|)
return|;
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"nls"
argument_list|)
specifier|private
name|OperatorInfo
name|genGroupByPlanReduceSinkOperator
parameter_list|(
name|QBParseInfo
name|parseInfo
parameter_list|,
name|String
name|dest
parameter_list|,
name|OperatorInfo
name|inputOperatorInfo
parameter_list|,
name|int
name|numPartitionFields
parameter_list|)
throws|throws
name|SemanticException
block|{
name|RowResolver
name|reduceSinkInputRowResolver
init|=
name|inputOperatorInfo
operator|.
name|getRowResolver
argument_list|()
decl_stmt|;
name|RowResolver
name|reduceSinkOutputRowResolver
init|=
operator|new
name|RowResolver
argument_list|()
decl_stmt|;
name|reduceSinkOutputRowResolver
operator|.
name|setIsExprResolver
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|ArrayList
argument_list|<
name|exprNodeDesc
argument_list|>
name|reduceKeys
init|=
operator|new
name|ArrayList
argument_list|<
name|exprNodeDesc
argument_list|>
argument_list|()
decl_stmt|;
comment|// Pre-compute group-by keys and store in reduceKeys
name|List
argument_list|<
name|CommonTree
argument_list|>
name|grpByExprs
init|=
name|getGroupByForClause
argument_list|(
name|parseInfo
argument_list|,
name|dest
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|grpByExprs
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|CommonTree
name|grpbyExpr
init|=
name|grpByExprs
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|reduceKeys
operator|.
name|add
argument_list|(
name|genExprNodeDesc
argument_list|(
name|grpbyExpr
argument_list|,
name|parseInfo
operator|.
name|getAlias
argument_list|()
argument_list|,
name|reduceSinkInputRowResolver
argument_list|)
argument_list|)
expr_stmt|;
name|String
name|text
init|=
name|grpbyExpr
operator|.
name|toStringTree
argument_list|()
decl_stmt|;
if|if
condition|(
name|reduceSinkOutputRowResolver
operator|.
name|get
argument_list|(
literal|""
argument_list|,
name|text
argument_list|)
operator|==
literal|null
condition|)
block|{
name|reduceSinkOutputRowResolver
operator|.
name|put
argument_list|(
literal|""
argument_list|,
name|text
argument_list|,
operator|new
name|ColumnInfo
argument_list|(
name|Utilities
operator|.
name|ReduceField
operator|.
name|KEY
operator|.
name|toString
argument_list|()
operator|+
literal|"."
operator|+
name|Integer
operator|.
name|valueOf
argument_list|(
name|reduceKeys
operator|.
name|size
argument_list|()
operator|-
literal|1
argument_list|)
operator|.
name|toString
argument_list|()
argument_list|,
name|String
operator|.
name|class
argument_list|,
literal|false
argument_list|)
argument_list|)
expr_stmt|;
comment|// Everything is a string right now
block|}
else|else
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|DUPLICATE_GROUPBY_KEY
operator|.
name|getMsg
argument_list|(
name|grpbyExpr
argument_list|)
argument_list|)
throw|;
block|}
block|}
comment|// If there is a distinctFuncExp, add all parameters to the reduceKeys.
if|if
condition|(
name|parseInfo
operator|.
name|getDistinctFuncExprForClause
argument_list|(
name|dest
argument_list|)
operator|!=
literal|null
condition|)
block|{
name|CommonTree
name|value
init|=
name|parseInfo
operator|.
name|getDistinctFuncExprForClause
argument_list|(
name|dest
argument_list|)
decl_stmt|;
comment|// 0 is function name
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<
name|value
operator|.
name|getChildCount
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|CommonTree
name|parameter
init|=
operator|(
name|CommonTree
operator|)
name|value
operator|.
name|getChild
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|String
name|text
init|=
name|parameter
operator|.
name|toStringTree
argument_list|()
decl_stmt|;
if|if
condition|(
name|reduceSinkOutputRowResolver
operator|.
name|get
argument_list|(
literal|""
argument_list|,
name|text
argument_list|)
operator|==
literal|null
condition|)
block|{
name|reduceKeys
operator|.
name|add
argument_list|(
name|genExprNodeDesc
argument_list|(
name|parameter
argument_list|,
name|parseInfo
operator|.
name|getAlias
argument_list|()
argument_list|,
name|reduceSinkInputRowResolver
argument_list|)
argument_list|)
expr_stmt|;
name|reduceSinkOutputRowResolver
operator|.
name|put
argument_list|(
literal|""
argument_list|,
name|text
argument_list|,
operator|new
name|ColumnInfo
argument_list|(
name|Utilities
operator|.
name|ReduceField
operator|.
name|KEY
operator|.
name|toString
argument_list|()
operator|+
literal|"."
operator|+
name|Integer
operator|.
name|valueOf
argument_list|(
name|reduceKeys
operator|.
name|size
argument_list|()
operator|-
literal|1
argument_list|)
operator|.
name|toString
argument_list|()
argument_list|,
name|String
operator|.
name|class
argument_list|,
literal|false
argument_list|)
argument_list|)
expr_stmt|;
comment|// Everything is a string right now
block|}
block|}
block|}
comment|// Put parameters to aggregations in reduceValues
name|ArrayList
argument_list|<
name|exprNodeDesc
argument_list|>
name|reduceValues
init|=
operator|new
name|ArrayList
argument_list|<
name|exprNodeDesc
argument_list|>
argument_list|()
decl_stmt|;
name|HashMap
argument_list|<
name|String
argument_list|,
name|CommonTree
argument_list|>
name|aggregationTrees
init|=
name|parseInfo
operator|.
name|getAggregationExprsForClause
argument_list|(
name|dest
argument_list|)
decl_stmt|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|CommonTree
argument_list|>
name|entry
range|:
name|aggregationTrees
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|CommonTree
name|value
init|=
name|entry
operator|.
name|getValue
argument_list|()
decl_stmt|;
comment|// 0 is function name
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<
name|value
operator|.
name|getChildCount
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|CommonTree
name|parameter
init|=
operator|(
name|CommonTree
operator|)
name|value
operator|.
name|getChild
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|String
name|text
init|=
name|parameter
operator|.
name|toStringTree
argument_list|()
decl_stmt|;
if|if
condition|(
name|reduceSinkOutputRowResolver
operator|.
name|get
argument_list|(
literal|""
argument_list|,
name|text
argument_list|)
operator|==
literal|null
condition|)
block|{
name|reduceValues
operator|.
name|add
argument_list|(
name|genExprNodeDesc
argument_list|(
name|parameter
argument_list|,
name|parseInfo
operator|.
name|getAlias
argument_list|()
argument_list|,
name|reduceSinkInputRowResolver
argument_list|)
argument_list|)
expr_stmt|;
name|reduceSinkOutputRowResolver
operator|.
name|put
argument_list|(
literal|""
argument_list|,
name|text
argument_list|,
operator|new
name|ColumnInfo
argument_list|(
name|Utilities
operator|.
name|ReduceField
operator|.
name|VALUE
operator|.
name|toString
argument_list|()
operator|+
literal|"."
operator|+
name|Integer
operator|.
name|valueOf
argument_list|(
name|reduceValues
operator|.
name|size
argument_list|()
operator|-
literal|1
argument_list|)
operator|.
name|toString
argument_list|()
argument_list|,
name|String
operator|.
name|class
argument_list|,
literal|false
argument_list|)
argument_list|)
expr_stmt|;
comment|// Everything is a string right now
block|}
block|}
block|}
return|return
operator|new
name|OperatorInfo
argument_list|(
name|OperatorFactory
operator|.
name|getAndMakeChild
argument_list|(
operator|new
name|reduceSinkDesc
argument_list|(
name|reduceKeys
argument_list|,
name|reduceValues
argument_list|,
name|numPartitionFields
argument_list|)
argument_list|,
operator|new
name|RowSchema
argument_list|(
name|reduceSinkOutputRowResolver
operator|.
name|getColumnInfos
argument_list|()
argument_list|)
argument_list|,
name|inputOperatorInfo
operator|.
name|getOp
argument_list|()
argument_list|)
argument_list|,
name|reduceSinkOutputRowResolver
argument_list|)
return|;
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"nls"
argument_list|)
specifier|private
name|OperatorInfo
name|genGroupByPlanReduceSinkOperator2MR
parameter_list|(
name|QBParseInfo
name|parseInfo
parameter_list|,
name|String
name|dest
parameter_list|,
name|OperatorInfo
name|groupByOperatorInfo
parameter_list|,
name|int
name|numPartitionFields
parameter_list|)
block|{
name|RowResolver
name|reduceSinkOutputRowResolver2
init|=
operator|new
name|RowResolver
argument_list|()
decl_stmt|;
name|reduceSinkOutputRowResolver2
operator|.
name|setIsExprResolver
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|ArrayList
argument_list|<
name|exprNodeDesc
argument_list|>
name|reduceKeys
init|=
operator|new
name|ArrayList
argument_list|<
name|exprNodeDesc
argument_list|>
argument_list|()
decl_stmt|;
comment|// Get group-by keys and store in reduceKeys
name|List
argument_list|<
name|CommonTree
argument_list|>
name|grpByExprs
init|=
name|getGroupByForClause
argument_list|(
name|parseInfo
argument_list|,
name|dest
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|grpByExprs
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|CommonTree
name|grpbyExpr
init|=
name|grpByExprs
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|String
name|field
init|=
operator|(
name|Integer
operator|.
name|valueOf
argument_list|(
name|i
argument_list|)
operator|)
operator|.
name|toString
argument_list|()
decl_stmt|;
name|reduceKeys
operator|.
name|add
argument_list|(
operator|new
name|exprNodeColumnDesc
argument_list|(
name|TypeInfo
operator|.
name|getPrimitiveTypeInfo
argument_list|(
name|String
operator|.
name|class
argument_list|)
argument_list|,
name|field
argument_list|)
argument_list|)
expr_stmt|;
name|reduceSinkOutputRowResolver2
operator|.
name|put
argument_list|(
literal|""
argument_list|,
name|grpbyExpr
operator|.
name|toStringTree
argument_list|()
argument_list|,
operator|new
name|ColumnInfo
argument_list|(
name|Utilities
operator|.
name|ReduceField
operator|.
name|KEY
operator|.
name|toString
argument_list|()
operator|+
literal|"."
operator|+
name|field
argument_list|,
name|String
operator|.
name|class
argument_list|,
literal|false
argument_list|)
argument_list|)
expr_stmt|;
comment|// Everything is a string right now
block|}
comment|// Get partial aggregation results and store in reduceValues
name|ArrayList
argument_list|<
name|exprNodeDesc
argument_list|>
name|reduceValues
init|=
operator|new
name|ArrayList
argument_list|<
name|exprNodeDesc
argument_list|>
argument_list|()
decl_stmt|;
name|int
name|inputField
init|=
name|reduceKeys
operator|.
name|size
argument_list|()
decl_stmt|;
name|HashMap
argument_list|<
name|String
argument_list|,
name|CommonTree
argument_list|>
name|aggregationTrees
init|=
name|parseInfo
operator|.
name|getAggregationExprsForClause
argument_list|(
name|dest
argument_list|)
decl_stmt|;
for|for
control|(
name|Map
operator|.
name|Entry
name|entry
range|:
name|aggregationTrees
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|String
name|key
init|=
operator|(
name|String
operator|)
name|entry
operator|.
name|getKey
argument_list|()
decl_stmt|;
name|reduceValues
operator|.
name|add
argument_list|(
operator|new
name|exprNodeColumnDesc
argument_list|(
name|TypeInfo
operator|.
name|getPrimitiveTypeInfo
argument_list|(
name|String
operator|.
name|class
argument_list|)
argument_list|,
operator|(
name|Integer
operator|.
name|valueOf
argument_list|(
name|inputField
argument_list|)
operator|)
operator|.
name|toString
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|inputField
operator|++
expr_stmt|;
name|reduceSinkOutputRowResolver2
operator|.
name|put
argument_list|(
literal|""
argument_list|,
operator|(
operator|(
name|CommonTree
operator|)
name|entry
operator|.
name|getValue
argument_list|()
operator|)
operator|.
name|toStringTree
argument_list|()
argument_list|,
operator|new
name|ColumnInfo
argument_list|(
name|Utilities
operator|.
name|ReduceField
operator|.
name|VALUE
operator|.
name|toString
argument_list|()
operator|+
literal|"."
operator|+
operator|(
name|Integer
operator|.
name|valueOf
argument_list|(
name|reduceValues
operator|.
name|size
argument_list|()
operator|-
literal|1
argument_list|)
operator|)
operator|.
name|toString
argument_list|()
argument_list|,
name|String
operator|.
name|class
argument_list|,
literal|false
argument_list|)
argument_list|)
expr_stmt|;
comment|// Everything is a string right now
block|}
return|return
operator|new
name|OperatorInfo
argument_list|(
name|OperatorFactory
operator|.
name|getAndMakeChild
argument_list|(
operator|new
name|reduceSinkDesc
argument_list|(
name|reduceKeys
argument_list|,
name|reduceValues
argument_list|,
name|numPartitionFields
argument_list|)
argument_list|,
operator|new
name|RowSchema
argument_list|(
name|reduceSinkOutputRowResolver2
operator|.
name|getColumnInfos
argument_list|()
argument_list|)
argument_list|,
name|groupByOperatorInfo
operator|.
name|getOp
argument_list|()
argument_list|)
argument_list|,
name|reduceSinkOutputRowResolver2
argument_list|)
return|;
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"nls"
argument_list|)
specifier|private
name|OperatorInfo
name|genGroupByPlanGroupByOperator2MR
parameter_list|(
name|QBParseInfo
name|parseInfo
parameter_list|,
name|String
name|dest
parameter_list|,
name|OperatorInfo
name|reduceSinkOperatorInfo2
parameter_list|)
throws|throws
name|SemanticException
block|{
name|RowResolver
name|groupByInputRowResolver2
init|=
name|reduceSinkOperatorInfo2
operator|.
name|getRowResolver
argument_list|()
decl_stmt|;
name|RowResolver
name|groupByOutputRowResolver2
init|=
operator|new
name|RowResolver
argument_list|()
decl_stmt|;
name|groupByOutputRowResolver2
operator|.
name|setIsExprResolver
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|ArrayList
argument_list|<
name|exprNodeDesc
argument_list|>
name|groupByKeys
init|=
operator|new
name|ArrayList
argument_list|<
name|exprNodeDesc
argument_list|>
argument_list|()
decl_stmt|;
name|ArrayList
argument_list|<
name|aggregationDesc
argument_list|>
name|aggregations
init|=
operator|new
name|ArrayList
argument_list|<
name|aggregationDesc
argument_list|>
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|CommonTree
argument_list|>
name|grpByExprs
init|=
name|getGroupByForClause
argument_list|(
name|parseInfo
argument_list|,
name|dest
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|grpByExprs
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|CommonTree
name|grpbyExpr
init|=
name|grpByExprs
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|String
name|text
init|=
name|grpbyExpr
operator|.
name|toStringTree
argument_list|()
decl_stmt|;
name|ColumnInfo
name|exprInfo
init|=
name|groupByInputRowResolver2
operator|.
name|get
argument_list|(
literal|""
argument_list|,
name|text
argument_list|)
decl_stmt|;
if|if
condition|(
name|exprInfo
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|INVALID_COLUMN
operator|.
name|getMsg
argument_list|(
name|grpbyExpr
argument_list|)
argument_list|)
throw|;
block|}
name|String
name|expression
init|=
name|exprInfo
operator|.
name|getInternalName
argument_list|()
decl_stmt|;
name|groupByKeys
operator|.
name|add
argument_list|(
operator|new
name|exprNodeColumnDesc
argument_list|(
name|exprInfo
operator|.
name|getType
argument_list|()
argument_list|,
name|expression
argument_list|)
argument_list|)
expr_stmt|;
name|String
name|field
init|=
operator|(
name|Integer
operator|.
name|valueOf
argument_list|(
name|i
argument_list|)
operator|)
operator|.
name|toString
argument_list|()
decl_stmt|;
name|groupByOutputRowResolver2
operator|.
name|put
argument_list|(
literal|""
argument_list|,
name|grpbyExpr
operator|.
name|toStringTree
argument_list|()
argument_list|,
operator|new
name|ColumnInfo
argument_list|(
name|field
argument_list|,
name|exprInfo
operator|.
name|getType
argument_list|()
argument_list|,
name|exprInfo
operator|.
name|getIsVirtual
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|HashMap
argument_list|<
name|String
argument_list|,
name|CommonTree
argument_list|>
name|aggregationTrees
init|=
name|parseInfo
operator|.
name|getAggregationExprsForClause
argument_list|(
name|dest
argument_list|)
decl_stmt|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|CommonTree
argument_list|>
name|entry
range|:
name|aggregationTrees
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|CommonTree
name|value
init|=
name|entry
operator|.
name|getValue
argument_list|()
decl_stmt|;
name|String
name|aggName
init|=
name|value
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getText
argument_list|()
decl_stmt|;
name|Class
argument_list|<
name|?
extends|extends
name|UDAF
argument_list|>
name|aggClass
init|=
name|UDAFRegistry
operator|.
name|getUDAF
argument_list|(
name|aggName
argument_list|)
decl_stmt|;
assert|assert
operator|(
name|aggClass
operator|!=
literal|null
operator|)
assert|;
name|ArrayList
argument_list|<
name|exprNodeDesc
argument_list|>
name|aggParameters
init|=
operator|new
name|ArrayList
argument_list|<
name|exprNodeDesc
argument_list|>
argument_list|()
decl_stmt|;
name|String
name|text
init|=
name|entry
operator|.
name|getKey
argument_list|()
decl_stmt|;
name|ColumnInfo
name|paraExprInfo
init|=
name|groupByInputRowResolver2
operator|.
name|get
argument_list|(
literal|""
argument_list|,
name|text
argument_list|)
decl_stmt|;
if|if
condition|(
name|paraExprInfo
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|INVALID_COLUMN
operator|.
name|getMsg
argument_list|(
name|value
argument_list|)
argument_list|)
throw|;
block|}
name|String
name|paraExpression
init|=
name|paraExprInfo
operator|.
name|getInternalName
argument_list|()
decl_stmt|;
assert|assert
operator|(
name|paraExpression
operator|!=
literal|null
operator|)
assert|;
name|aggParameters
operator|.
name|add
argument_list|(
operator|new
name|exprNodeColumnDesc
argument_list|(
name|paraExprInfo
operator|.
name|getType
argument_list|()
argument_list|,
name|paraExpression
argument_list|)
argument_list|)
expr_stmt|;
name|aggregations
operator|.
name|add
argument_list|(
operator|new
name|aggregationDesc
argument_list|(
name|aggClass
argument_list|,
name|aggParameters
argument_list|,
literal|false
argument_list|)
argument_list|)
expr_stmt|;
name|groupByOutputRowResolver2
operator|.
name|put
argument_list|(
literal|""
argument_list|,
name|value
operator|.
name|toStringTree
argument_list|()
argument_list|,
operator|new
name|ColumnInfo
argument_list|(
name|Integer
operator|.
name|valueOf
argument_list|(
name|groupByKeys
operator|.
name|size
argument_list|()
operator|+
name|aggregations
operator|.
name|size
argument_list|()
operator|-
literal|1
argument_list|)
operator|.
name|toString
argument_list|()
argument_list|,
name|paraExprInfo
operator|.
name|getType
argument_list|()
argument_list|,
name|paraExprInfo
operator|.
name|getIsVirtual
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
comment|// Everything is a string right now
block|}
return|return
operator|new
name|OperatorInfo
argument_list|(
name|OperatorFactory
operator|.
name|getAndMakeChild
argument_list|(
operator|new
name|groupByDesc
argument_list|(
name|groupByDesc
operator|.
name|Mode
operator|.
name|PARTIAL2
argument_list|,
name|groupByKeys
argument_list|,
name|aggregations
argument_list|)
argument_list|,
operator|new
name|RowSchema
argument_list|(
name|groupByOutputRowResolver2
operator|.
name|getColumnInfos
argument_list|()
argument_list|)
argument_list|,
name|reduceSinkOperatorInfo2
operator|.
name|getOp
argument_list|()
argument_list|)
argument_list|,
name|groupByOutputRowResolver2
argument_list|)
return|;
block|}
comment|/**    * Generate a Group-By plan using a single map-reduce job (3 operators will be    * inserted):    *    * ReduceSink ( keys = (K1_EXP, K2_EXP, DISTINCT_EXP), values = (A1_EXP,    * A2_EXP) ) SortGroupBy (keys = (KEY.0,KEY.1), aggregations =    * (count_distinct(KEY.2), sum(VALUE.0), count(VALUE.1))) Select (final    * selects)    *    * @param dest    * @param qb    * @param input    * @return    * @throws SemanticException    */
annotation|@
name|SuppressWarnings
argument_list|(
block|{
literal|"unused"
block|,
literal|"nls"
block|}
argument_list|)
specifier|private
name|OperatorInfoList
name|genGroupByPlan1MR
parameter_list|(
name|String
name|dest
parameter_list|,
name|QB
name|qb
parameter_list|,
name|OperatorInfoList
name|inputList
parameter_list|)
throws|throws
name|SemanticException
block|{
comment|// We can assert here that the input list is of size one
if|if
condition|(
name|inputList
operator|.
name|size
argument_list|()
operator|!=
literal|1
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
literal|"Select has more than one inputs"
argument_list|)
throw|;
block|}
name|OperatorInfo
name|inputOperatorInfo
init|=
name|inputList
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|QBParseInfo
name|parseInfo
init|=
name|qb
operator|.
name|getParseInfo
argument_list|()
decl_stmt|;
comment|// ////// 1. Generate ReduceSinkOperator
name|OperatorInfo
name|reduceSinkOperatorInfo
init|=
name|genGroupByPlanReduceSinkOperator
argument_list|(
name|parseInfo
argument_list|,
name|dest
argument_list|,
name|inputOperatorInfo
argument_list|,
name|getGroupByForClause
argument_list|(
name|parseInfo
argument_list|,
name|dest
argument_list|)
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
comment|// ////// 2. Generate GroupbyOperator
name|OperatorInfo
name|groupByOperatorInfo
init|=
name|genGroupByPlanGroupByOperator
argument_list|(
name|parseInfo
argument_list|,
name|dest
argument_list|,
name|reduceSinkOperatorInfo
argument_list|,
name|groupByDesc
operator|.
name|Mode
operator|.
name|COMPLETE
argument_list|)
decl_stmt|;
comment|// ////// 3. Generate SelectOperator
name|OperatorInfo
name|selectOperatorInfo
init|=
name|genGroupByPlanSelectOperator
argument_list|(
name|parseInfo
argument_list|,
name|dest
argument_list|,
name|groupByOperatorInfo
argument_list|)
decl_stmt|;
comment|// ////// 4. Create output
name|OperatorInfoList
name|output
init|=
operator|new
name|OperatorInfoList
argument_list|()
decl_stmt|;
name|output
operator|.
name|add
argument_list|(
name|selectOperatorInfo
argument_list|)
expr_stmt|;
return|return
name|output
return|;
block|}
comment|/**    * Generate a Group-By plan using a 2 map-reduce jobs (5 operators will be    * inserted):    *    * ReduceSink ( keys = (K1_EXP, K2_EXP, DISTINCT_EXP), values = (A1_EXP,    * A2_EXP) ) NOTE: If DISTINCT_EXP is null, partition by rand() SortGroupBy    * (keys = (KEY.0,KEY.1), aggregations = (count_distinct(KEY.2), sum(VALUE.0),    * count(VALUE.1))) ReduceSink ( keys = (0,1), values=(2,3,4)) SortGroupBy    * (keys = (KEY.0,KEY.1), aggregations = (sum(VALUE.0), sum(VALUE.1),    * sum(VALUE.2))) Select (final selects)    *    * @param dest    * @param qb    * @param input    * @return    * @throws SemanticException    */
annotation|@
name|SuppressWarnings
argument_list|(
literal|"nls"
argument_list|)
specifier|private
name|OperatorInfoList
name|genGroupByPlan2MR
parameter_list|(
name|String
name|dest
parameter_list|,
name|QB
name|qb
parameter_list|,
name|OperatorInfoList
name|inputList
parameter_list|)
throws|throws
name|SemanticException
block|{
comment|// We can assert here that the input list is of size one
if|if
condition|(
name|inputList
operator|.
name|size
argument_list|()
operator|!=
literal|1
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
literal|"Select has more than one inputs"
argument_list|)
throw|;
block|}
name|OperatorInfo
name|inputOperatorInfo
init|=
name|inputList
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|QBParseInfo
name|parseInfo
init|=
name|qb
operator|.
name|getParseInfo
argument_list|()
decl_stmt|;
comment|// ////// 1. Generate ReduceSinkOperator
comment|// There is a special case when we want the rows to be randomly distributed to
comment|// reducers for load balancing problem.  That happens when there is no DISTINCT
comment|// operator.  We set the numPartitionColumns to -1 for this purpose.  This is
comment|// captured by WritableComparableHiveObject.hashCode() function.
name|OperatorInfo
name|reduceSinkOperatorInfo
init|=
name|genGroupByPlanReduceSinkOperator
argument_list|(
name|parseInfo
argument_list|,
name|dest
argument_list|,
name|inputOperatorInfo
argument_list|,
operator|(
name|parseInfo
operator|.
name|getDistinctFuncExprForClause
argument_list|(
name|dest
argument_list|)
operator|==
literal|null
condition|?
operator|-
literal|1
else|:
name|Integer
operator|.
name|MAX_VALUE
operator|)
argument_list|)
decl_stmt|;
comment|// ////// 2. Generate GroupbyOperator
name|OperatorInfo
name|groupByOperatorInfo
init|=
name|genGroupByPlanGroupByOperator
argument_list|(
name|parseInfo
argument_list|,
name|dest
argument_list|,
name|reduceSinkOperatorInfo
argument_list|,
name|groupByDesc
operator|.
name|Mode
operator|.
name|PARTIAL1
argument_list|)
decl_stmt|;
comment|// ////// 3. Generate ReduceSinkOperator2
name|OperatorInfo
name|reduceSinkOperatorInfo2
init|=
name|genGroupByPlanReduceSinkOperator2MR
argument_list|(
name|parseInfo
argument_list|,
name|dest
argument_list|,
name|groupByOperatorInfo
argument_list|,
name|getGroupByForClause
argument_list|(
name|parseInfo
argument_list|,
name|dest
argument_list|)
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
comment|// ////// 4. Generate GroupbyOperator2
name|OperatorInfo
name|groupByOperatorInfo2
init|=
name|genGroupByPlanGroupByOperator2MR
argument_list|(
name|parseInfo
argument_list|,
name|dest
argument_list|,
name|reduceSinkOperatorInfo2
argument_list|)
decl_stmt|;
comment|// ////// 5. Generate SelectOperator
name|OperatorInfo
name|selectOperatorInfo
init|=
name|genGroupByPlanSelectOperator
argument_list|(
name|parseInfo
argument_list|,
name|dest
argument_list|,
name|groupByOperatorInfo2
argument_list|)
decl_stmt|;
comment|// ////// 6. Create output
name|OperatorInfoList
name|output
init|=
operator|new
name|OperatorInfoList
argument_list|()
decl_stmt|;
name|output
operator|.
name|add
argument_list|(
name|selectOperatorInfo
argument_list|)
expr_stmt|;
return|return
name|output
return|;
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"nls"
argument_list|)
specifier|private
name|OperatorInfoList
name|genConversionOps
parameter_list|(
name|String
name|dest
parameter_list|,
name|QB
name|qb
parameter_list|,
name|OperatorInfoList
name|input
parameter_list|)
throws|throws
name|SemanticException
block|{
name|Integer
name|dest_type
init|=
name|qb
operator|.
name|getMetaData
argument_list|()
operator|.
name|getDestTypeForAlias
argument_list|(
name|dest
argument_list|)
decl_stmt|;
name|Table
name|dest_tab
init|=
literal|null
decl_stmt|;
switch|switch
condition|(
name|dest_type
operator|.
name|intValue
argument_list|()
condition|)
block|{
case|case
name|QBMetaData
operator|.
name|DEST_TABLE
case|:
block|{
name|dest_tab
operator|=
name|qb
operator|.
name|getMetaData
argument_list|()
operator|.
name|getDestTableForAlias
argument_list|(
name|dest
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|QBMetaData
operator|.
name|DEST_PARTITION
case|:
block|{
name|dest_tab
operator|=
name|qb
operator|.
name|getMetaData
argument_list|()
operator|.
name|getDestPartitionForAlias
argument_list|(
name|dest
argument_list|)
operator|.
name|getTable
argument_list|()
expr_stmt|;
break|break;
block|}
default|default:
block|{
return|return
name|input
return|;
block|}
block|}
comment|// We have the table object here - go over the row resolver
comment|// and check all the types are the same
name|Vector
argument_list|<
name|ColumnInfo
argument_list|>
name|srcOpns
init|=
name|input
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|getRowResolver
argument_list|()
operator|.
name|getColumnInfos
argument_list|()
decl_stmt|;
name|Vector
argument_list|<
name|ColumnInfo
argument_list|>
name|insOpns
init|=
operator|new
name|Vector
argument_list|<
name|ColumnInfo
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|SerDeField
name|field
range|:
name|dest_tab
operator|.
name|getFields
argument_list|(
literal|null
argument_list|)
control|)
block|{
name|insOpns
operator|.
name|add
argument_list|(
operator|new
name|ColumnInfo
argument_list|(
name|field
operator|.
name|getName
argument_list|()
argument_list|,
operator|new
name|TypeInfo
argument_list|(
name|dest_tab
operator|.
name|getSerDe
argument_list|()
argument_list|,
name|field
argument_list|)
argument_list|,
literal|false
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/*     if (insOpns.size() != srcOpns.size()) {       // TODO: change this to error message later       throw new SemanticException("Number of columns in the select expression does not " +                                    "match the number of columns in table " + dest_tab.getName() +                                   " expected " + insOpns.size() + " but got " + srcOpns.size());     }      boolean needSelOperator = false;     for(int i=0; i< insOpns.size(); ++i) {       if (!insOpns.get(i).getType().equals(srcOpns.get(i).getType())) {         needSelOperator = true;         throw new SemanticException("insert and select column type do not match for table " + dest_tab.getName());       }     }     */
return|return
name|input
return|;
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"nls"
argument_list|)
specifier|private
name|OperatorInfoList
name|genFileSinkPlan
parameter_list|(
name|String
name|dest
parameter_list|,
name|QB
name|qb
parameter_list|,
name|OperatorInfoList
name|input
parameter_list|)
throws|throws
name|SemanticException
block|{
comment|// We can assert here that the input list is of size one
if|if
condition|(
name|input
operator|.
name|size
argument_list|()
operator|!=
literal|1
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
literal|"Select has more than one inputs"
argument_list|)
throw|;
block|}
comment|// Generate the destination file
name|String
name|queryTmpdir
init|=
name|this
operator|.
name|scratchDir
operator|+
name|File
operator|.
name|separator
operator|+
name|this
operator|.
name|randomid
operator|+
literal|'.'
operator|+
name|this
operator|.
name|pathid
operator|+
literal|'.'
operator|+
name|dest
decl_stmt|;
name|this
operator|.
name|pathid
operator|++
expr_stmt|;
comment|// Next for the destination tables, fetch the information
comment|// create a temporary directory name and chain it to the plan
name|String
name|dest_path
init|=
literal|null
decl_stmt|;
name|tableDesc
name|table_desc
init|=
literal|null
decl_stmt|;
name|Integer
name|dest_type
init|=
name|qb
operator|.
name|getMetaData
argument_list|()
operator|.
name|getDestTypeForAlias
argument_list|(
name|dest
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|dest_type
operator|.
name|intValue
argument_list|()
condition|)
block|{
case|case
name|QBMetaData
operator|.
name|DEST_TABLE
case|:
block|{
name|Table
name|dest_tab
init|=
name|qb
operator|.
name|getMetaData
argument_list|()
operator|.
name|getDestTableForAlias
argument_list|(
name|dest
argument_list|)
decl_stmt|;
name|table_desc
operator|=
name|Utilities
operator|.
name|getTableDesc
argument_list|(
name|dest_tab
argument_list|)
expr_stmt|;
name|dest_path
operator|=
name|dest_tab
operator|.
name|getPath
argument_list|()
operator|.
name|toString
argument_list|()
expr_stmt|;
comment|// Create the work for moving the table
name|this
operator|.
name|loadTableWork
operator|.
name|add
argument_list|(
operator|new
name|loadTableDesc
argument_list|(
name|queryTmpdir
argument_list|,
name|table_desc
argument_list|,
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|QBMetaData
operator|.
name|DEST_PARTITION
case|:
block|{
name|Partition
name|dest_part
init|=
name|qb
operator|.
name|getMetaData
argument_list|()
operator|.
name|getDestPartitionForAlias
argument_list|(
name|dest
argument_list|)
decl_stmt|;
name|Table
name|dest_tab
init|=
name|dest_part
operator|.
name|getTable
argument_list|()
decl_stmt|;
name|table_desc
operator|=
name|Utilities
operator|.
name|getTableDesc
argument_list|(
name|dest_tab
argument_list|)
expr_stmt|;
name|dest_path
operator|=
name|dest_part
operator|.
name|getPath
argument_list|()
index|[
literal|0
index|]
operator|.
name|toString
argument_list|()
expr_stmt|;
name|this
operator|.
name|loadTableWork
operator|.
name|add
argument_list|(
operator|new
name|loadTableDesc
argument_list|(
name|queryTmpdir
argument_list|,
name|table_desc
argument_list|,
name|dest_part
operator|.
name|getSpec
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|QBMetaData
operator|.
name|DEST_LOCAL_FILE
case|:
case|case
name|QBMetaData
operator|.
name|DEST_DFS_FILE
case|:
block|{
name|table_desc
operator|=
name|Utilities
operator|.
name|defaultTd
expr_stmt|;
name|dest_path
operator|=
name|qb
operator|.
name|getMetaData
argument_list|()
operator|.
name|getDestFileForAlias
argument_list|(
name|dest
argument_list|)
expr_stmt|;
name|this
operator|.
name|loadFileWork
operator|.
name|add
argument_list|(
operator|new
name|loadFileDesc
argument_list|(
name|queryTmpdir
argument_list|,
name|dest_path
argument_list|,
operator|(
name|dest_type
operator|.
name|intValue
argument_list|()
operator|==
name|QBMetaData
operator|.
name|DEST_DFS_FILE
operator|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
default|default:
throw|throw
operator|new
name|SemanticException
argument_list|(
literal|"Unknown destination type: "
operator|+
name|dest_type
argument_list|)
throw|;
block|}
name|OperatorInfoList
name|output
init|=
operator|(
name|OperatorInfoList
operator|)
name|input
operator|.
name|clone
argument_list|()
decl_stmt|;
name|output
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|setOp
argument_list|(
name|OperatorFactory
operator|.
name|getAndMakeChild
argument_list|(
operator|new
name|fileSinkDesc
argument_list|(
name|queryTmpdir
argument_list|,
name|table_desc
argument_list|)
argument_list|,
operator|new
name|RowSchema
argument_list|(
name|output
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|getRowResolver
argument_list|()
operator|.
name|getColumnInfos
argument_list|()
argument_list|)
argument_list|,
name|input
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|getOp
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Created FileSink Plan for clause: "
operator|+
name|dest
operator|+
literal|"dest_path: "
operator|+
name|dest_path
operator|+
literal|" row schema: "
operator|+
name|output
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|getRowResolver
argument_list|()
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|output
return|;
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"nls"
argument_list|)
specifier|private
name|OperatorInfoList
name|genReduceSinkPlan
parameter_list|(
name|String
name|dest
parameter_list|,
name|QB
name|qb
parameter_list|,
name|OperatorInfoList
name|input
parameter_list|)
throws|throws
name|SemanticException
block|{
comment|// We can assert here that the input list is of size one
if|if
condition|(
name|input
operator|.
name|size
argument_list|()
operator|!=
literal|1
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
literal|"Select has more than one inputs"
argument_list|)
throw|;
block|}
comment|// First generate the expression for the key
comment|// The cluster by clause has the aliases for the keys
name|CommonTree
name|clby
init|=
name|qb
operator|.
name|getParseInfo
argument_list|()
operator|.
name|getClusterByForClause
argument_list|(
name|dest
argument_list|)
decl_stmt|;
name|ArrayList
argument_list|<
name|exprNodeDesc
argument_list|>
name|keyCols
init|=
operator|new
name|ArrayList
argument_list|<
name|exprNodeDesc
argument_list|>
argument_list|()
decl_stmt|;
name|int
name|ccount
init|=
name|clby
operator|.
name|getChildCount
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|ccount
condition|;
operator|++
name|i
control|)
block|{
name|CommonTree
name|cl
init|=
operator|(
name|CommonTree
operator|)
name|clby
operator|.
name|getChild
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|ColumnInfo
name|colInfo
init|=
name|input
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|getRowResolver
argument_list|()
operator|.
name|get
argument_list|(
name|qb
operator|.
name|getParseInfo
argument_list|()
operator|.
name|getAlias
argument_list|()
argument_list|,
name|cl
operator|.
name|getText
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|colInfo
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|INVALID_COLUMN
operator|.
name|getMsg
argument_list|(
name|cl
argument_list|)
argument_list|)
throw|;
block|}
name|keyCols
operator|.
name|add
argument_list|(
operator|new
name|exprNodeColumnDesc
argument_list|(
name|colInfo
operator|.
name|getType
argument_list|()
argument_list|,
name|colInfo
operator|.
name|getInternalName
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|ArrayList
argument_list|<
name|exprNodeDesc
argument_list|>
name|valueCols
init|=
operator|new
name|ArrayList
argument_list|<
name|exprNodeDesc
argument_list|>
argument_list|()
decl_stmt|;
comment|// For the generation of the values expression just get the inputs
comment|// signature and generate field expressions for those
for|for
control|(
name|ColumnInfo
name|colInfo
range|:
name|input
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|getRowResolver
argument_list|()
operator|.
name|getColumnInfos
argument_list|()
control|)
block|{
name|valueCols
operator|.
name|add
argument_list|(
operator|new
name|exprNodeColumnDesc
argument_list|(
name|colInfo
operator|.
name|getType
argument_list|()
argument_list|,
name|colInfo
operator|.
name|getInternalName
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|OperatorInfoList
name|interim
init|=
operator|(
name|OperatorInfoList
operator|)
name|input
operator|.
name|clone
argument_list|()
decl_stmt|;
name|interim
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|setOp
argument_list|(
name|OperatorFactory
operator|.
name|getAndMakeChild
argument_list|(
operator|new
name|reduceSinkDesc
argument_list|(
name|keyCols
argument_list|,
name|valueCols
argument_list|,
name|keyCols
operator|.
name|size
argument_list|()
argument_list|)
argument_list|,
operator|new
name|RowSchema
argument_list|(
name|interim
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|getRowResolver
argument_list|()
operator|.
name|getColumnInfos
argument_list|()
argument_list|)
argument_list|,
name|input
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|getOp
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
comment|// Add the extract operator to get the value fields
name|RowResolver
name|out_rwsch
init|=
operator|new
name|RowResolver
argument_list|()
decl_stmt|;
name|RowResolver
name|interim_rwsch
init|=
name|interim
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|getRowResolver
argument_list|()
decl_stmt|;
name|Integer
name|pos
init|=
name|Integer
operator|.
name|valueOf
argument_list|(
literal|0
argument_list|)
decl_stmt|;
for|for
control|(
name|ColumnInfo
name|colInfo
range|:
name|interim_rwsch
operator|.
name|getColumnInfos
argument_list|()
control|)
block|{
name|String
index|[]
name|info
init|=
name|interim_rwsch
operator|.
name|reverseLookup
argument_list|(
name|colInfo
operator|.
name|getInternalName
argument_list|()
argument_list|)
decl_stmt|;
name|out_rwsch
operator|.
name|put
argument_list|(
name|info
index|[
literal|0
index|]
argument_list|,
name|info
index|[
literal|1
index|]
argument_list|,
operator|new
name|ColumnInfo
argument_list|(
name|pos
operator|.
name|toString
argument_list|()
argument_list|,
name|colInfo
operator|.
name|getType
argument_list|()
argument_list|,
name|colInfo
operator|.
name|getIsVirtual
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|pos
operator|=
name|Integer
operator|.
name|valueOf
argument_list|(
name|pos
operator|.
name|intValue
argument_list|()
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
name|OperatorInfoList
name|output
init|=
operator|(
name|OperatorInfoList
operator|)
name|interim
operator|.
name|clone
argument_list|()
decl_stmt|;
name|output
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|setOp
argument_list|(
name|OperatorFactory
operator|.
name|getAndMakeChild
argument_list|(
operator|new
name|extractDesc
argument_list|(
operator|new
name|exprNodeColumnDesc
argument_list|(
name|String
operator|.
name|class
argument_list|,
name|Utilities
operator|.
name|ReduceField
operator|.
name|VALUE
operator|.
name|toString
argument_list|()
argument_list|)
argument_list|)
argument_list|,
operator|new
name|RowSchema
argument_list|(
name|out_rwsch
operator|.
name|getColumnInfos
argument_list|()
argument_list|)
argument_list|,
name|interim
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|getOp
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|output
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|setRowResolver
argument_list|(
name|out_rwsch
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Created ReduceSink Plan for clause: "
operator|+
name|dest
operator|+
literal|" row schema: "
operator|+
name|output
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|getRowResolver
argument_list|()
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|output
return|;
block|}
specifier|private
name|OperatorInfo
name|genJoinOperatorChildren
parameter_list|(
name|QBJoinTree
name|join
parameter_list|,
name|OperatorInfo
name|left
parameter_list|,
name|OperatorInfo
index|[]
name|right
parameter_list|)
block|{
name|RowResolver
name|outputRS
init|=
operator|new
name|RowResolver
argument_list|()
decl_stmt|;
comment|// all children are base classes
name|Operator
argument_list|<
name|?
argument_list|>
index|[]
name|rightOps
init|=
operator|new
name|Operator
index|[
name|right
operator|.
name|length
index|]
decl_stmt|;
name|int
name|pos
init|=
literal|0
decl_stmt|;
name|int
name|outputPos
init|=
literal|0
decl_stmt|;
name|HashMap
argument_list|<
name|Byte
argument_list|,
name|ArrayList
argument_list|<
name|exprNodeDesc
argument_list|>
argument_list|>
name|exprMap
init|=
operator|new
name|HashMap
argument_list|<
name|Byte
argument_list|,
name|ArrayList
argument_list|<
name|exprNodeDesc
argument_list|>
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|OperatorInfo
name|input
range|:
name|right
control|)
block|{
name|ArrayList
argument_list|<
name|exprNodeDesc
argument_list|>
name|keyDesc
init|=
operator|new
name|ArrayList
argument_list|<
name|exprNodeDesc
argument_list|>
argument_list|()
decl_stmt|;
if|if
condition|(
name|input
operator|==
literal|null
condition|)
name|input
operator|=
name|left
expr_stmt|;
name|Byte
name|tag
init|=
name|Byte
operator|.
name|valueOf
argument_list|(
call|(
name|byte
call|)
argument_list|(
operator|(
call|(
name|reduceSinkDesc
call|)
argument_list|(
name|input
operator|.
name|getOp
argument_list|()
operator|.
name|getConf
argument_list|()
argument_list|)
operator|)
operator|.
name|getTag
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
name|RowResolver
name|inputRS
init|=
name|input
operator|.
name|getRowResolver
argument_list|()
decl_stmt|;
name|Iterator
argument_list|<
name|String
argument_list|>
name|keysIter
init|=
name|inputRS
operator|.
name|getTableNames
argument_list|()
operator|.
name|iterator
argument_list|()
decl_stmt|;
while|while
condition|(
name|keysIter
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|String
name|key
init|=
name|keysIter
operator|.
name|next
argument_list|()
decl_stmt|;
name|HashMap
argument_list|<
name|String
argument_list|,
name|ColumnInfo
argument_list|>
name|map
init|=
name|inputRS
operator|.
name|getFieldMap
argument_list|(
name|key
argument_list|)
decl_stmt|;
name|Iterator
argument_list|<
name|String
argument_list|>
name|fNamesIter
init|=
name|map
operator|.
name|keySet
argument_list|()
operator|.
name|iterator
argument_list|()
decl_stmt|;
while|while
condition|(
name|fNamesIter
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|String
name|field
init|=
name|fNamesIter
operator|.
name|next
argument_list|()
decl_stmt|;
name|ColumnInfo
name|valueInfo
init|=
name|inputRS
operator|.
name|get
argument_list|(
name|key
argument_list|,
name|field
argument_list|)
decl_stmt|;
name|keyDesc
operator|.
name|add
argument_list|(
operator|new
name|exprNodeColumnDesc
argument_list|(
name|valueInfo
operator|.
name|getType
argument_list|()
argument_list|,
name|valueInfo
operator|.
name|getInternalName
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|outputRS
operator|.
name|get
argument_list|(
name|key
argument_list|,
name|field
argument_list|)
operator|==
literal|null
condition|)
name|outputRS
operator|.
name|put
argument_list|(
name|key
argument_list|,
name|field
argument_list|,
operator|new
name|ColumnInfo
argument_list|(
operator|(
name|Integer
operator|.
name|valueOf
argument_list|(
name|outputPos
operator|++
argument_list|)
operator|)
operator|.
name|toString
argument_list|()
argument_list|,
name|valueInfo
operator|.
name|getType
argument_list|()
argument_list|,
name|valueInfo
operator|.
name|getIsVirtual
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|exprMap
operator|.
name|put
argument_list|(
name|tag
argument_list|,
name|keyDesc
argument_list|)
expr_stmt|;
name|rightOps
index|[
name|pos
operator|++
index|]
operator|=
name|input
operator|.
name|getOp
argument_list|()
expr_stmt|;
block|}
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|joinCond
index|[]
name|joinCondns
init|=
operator|new
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|joinCond
index|[
name|join
operator|.
name|getJoinCond
argument_list|()
operator|.
name|length
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|join
operator|.
name|getJoinCond
argument_list|()
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|joinCond
name|condn
init|=
name|join
operator|.
name|getJoinCond
argument_list|()
index|[
name|i
index|]
decl_stmt|;
name|joinCondns
index|[
name|i
index|]
operator|=
operator|new
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|joinCond
argument_list|(
name|condn
argument_list|)
expr_stmt|;
block|}
return|return
operator|new
name|OperatorInfo
argument_list|(
name|OperatorFactory
operator|.
name|getAndMakeChild
argument_list|(
operator|new
name|joinDesc
argument_list|(
name|exprMap
argument_list|,
name|joinCondns
argument_list|)
argument_list|,
operator|new
name|RowSchema
argument_list|(
name|outputRS
operator|.
name|getColumnInfos
argument_list|()
argument_list|)
argument_list|,
name|rightOps
argument_list|)
argument_list|,
name|outputRS
argument_list|)
return|;
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"nls"
argument_list|)
specifier|private
name|OperatorInfo
name|genJoinReduceSinkChild
parameter_list|(
name|QB
name|qb
parameter_list|,
name|QBJoinTree
name|joinTree
parameter_list|,
name|OperatorInfo
name|child
parameter_list|,
name|String
name|srcName
parameter_list|,
name|int
name|pos
parameter_list|)
throws|throws
name|SemanticException
block|{
name|RowResolver
name|inputRS
init|=
name|child
operator|.
name|getRowResolver
argument_list|()
decl_stmt|;
name|RowResolver
name|outputRS
init|=
operator|new
name|RowResolver
argument_list|()
decl_stmt|;
name|ArrayList
argument_list|<
name|exprNodeDesc
argument_list|>
name|reduceKeys
init|=
operator|new
name|ArrayList
argument_list|<
name|exprNodeDesc
argument_list|>
argument_list|()
decl_stmt|;
comment|// Compute join keys and store in reduceKeys
name|Vector
argument_list|<
name|CommonTree
argument_list|>
name|exprs
init|=
name|joinTree
operator|.
name|getExpressions
argument_list|()
operator|.
name|get
argument_list|(
name|pos
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|exprs
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|CommonTree
name|expr
init|=
name|exprs
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|reduceKeys
operator|.
name|add
argument_list|(
name|genExprNodeDesc
argument_list|(
name|expr
argument_list|,
name|srcName
argument_list|,
name|inputRS
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// Walk over the input row resolver and copy in the output
name|ArrayList
argument_list|<
name|exprNodeDesc
argument_list|>
name|reduceValues
init|=
operator|new
name|ArrayList
argument_list|<
name|exprNodeDesc
argument_list|>
argument_list|()
decl_stmt|;
name|Iterator
argument_list|<
name|String
argument_list|>
name|tblNamesIter
init|=
name|inputRS
operator|.
name|getTableNames
argument_list|()
operator|.
name|iterator
argument_list|()
decl_stmt|;
while|while
condition|(
name|tblNamesIter
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|String
name|src
init|=
name|tblNamesIter
operator|.
name|next
argument_list|()
decl_stmt|;
name|HashMap
argument_list|<
name|String
argument_list|,
name|ColumnInfo
argument_list|>
name|fMap
init|=
name|inputRS
operator|.
name|getFieldMap
argument_list|(
name|src
argument_list|)
decl_stmt|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|ColumnInfo
argument_list|>
name|entry
range|:
name|fMap
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|String
name|field
init|=
name|entry
operator|.
name|getKey
argument_list|()
decl_stmt|;
name|ColumnInfo
name|valueInfo
init|=
name|entry
operator|.
name|getValue
argument_list|()
decl_stmt|;
name|reduceValues
operator|.
name|add
argument_list|(
operator|new
name|exprNodeColumnDesc
argument_list|(
name|valueInfo
operator|.
name|getType
argument_list|()
argument_list|,
name|valueInfo
operator|.
name|getInternalName
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|outputRS
operator|.
name|get
argument_list|(
name|src
argument_list|,
name|field
argument_list|)
operator|==
literal|null
condition|)
name|outputRS
operator|.
name|put
argument_list|(
name|src
argument_list|,
name|field
argument_list|,
operator|new
name|ColumnInfo
argument_list|(
name|Utilities
operator|.
name|ReduceField
operator|.
name|VALUE
operator|.
name|toString
argument_list|()
operator|+
literal|"."
operator|+
name|Integer
operator|.
name|valueOf
argument_list|(
name|reduceValues
operator|.
name|size
argument_list|()
operator|-
literal|1
argument_list|)
operator|.
name|toString
argument_list|()
argument_list|,
name|valueInfo
operator|.
name|getType
argument_list|()
argument_list|,
name|valueInfo
operator|.
name|getIsVirtual
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|new
name|OperatorInfo
argument_list|(
name|OperatorFactory
operator|.
name|getAndMakeChild
argument_list|(
operator|new
name|reduceSinkDesc
argument_list|(
name|reduceKeys
argument_list|,
name|reduceValues
argument_list|,
name|joinTree
operator|.
name|getNextTag
argument_list|()
argument_list|,
name|reduceKeys
operator|.
name|size
argument_list|()
argument_list|)
argument_list|,
operator|new
name|RowSchema
argument_list|(
name|outputRS
operator|.
name|getColumnInfos
argument_list|()
argument_list|)
argument_list|,
name|child
operator|.
name|getOp
argument_list|()
argument_list|)
argument_list|,
name|outputRS
argument_list|)
return|;
block|}
specifier|private
name|OperatorInfo
name|genJoinOperator
parameter_list|(
name|QB
name|qb
parameter_list|,
name|QBJoinTree
name|joinTree
parameter_list|,
name|HashMap
argument_list|<
name|String
argument_list|,
name|OperatorInfoList
argument_list|>
name|map
parameter_list|)
throws|throws
name|SemanticException
block|{
name|QBJoinTree
name|leftChild
init|=
name|joinTree
operator|.
name|getJoinSrc
argument_list|()
decl_stmt|;
name|OperatorInfo
name|joinSrcOp
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|leftChild
operator|!=
literal|null
condition|)
block|{
name|OperatorInfo
name|joinOp
init|=
name|genJoinOperator
argument_list|(
name|qb
argument_list|,
name|leftChild
argument_list|,
name|map
argument_list|)
decl_stmt|;
name|joinSrcOp
operator|=
name|genJoinReduceSinkChild
argument_list|(
name|qb
argument_list|,
name|joinTree
argument_list|,
name|joinOp
argument_list|,
literal|null
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|OperatorInfo
index|[]
name|srcOps
init|=
operator|new
name|OperatorInfo
index|[
name|joinTree
operator|.
name|getBaseSrc
argument_list|()
operator|.
name|length
index|]
decl_stmt|;
name|int
name|pos
init|=
literal|0
decl_stmt|;
for|for
control|(
name|String
name|src
range|:
name|joinTree
operator|.
name|getBaseSrc
argument_list|()
control|)
block|{
if|if
condition|(
name|src
operator|!=
literal|null
condition|)
block|{
name|OperatorInfo
name|srcOp
init|=
name|map
operator|.
name|get
argument_list|(
name|src
argument_list|)
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|srcOps
index|[
name|pos
index|]
operator|=
name|genJoinReduceSinkChild
argument_list|(
name|qb
argument_list|,
name|joinTree
argument_list|,
name|srcOp
argument_list|,
name|src
argument_list|,
name|pos
argument_list|)
expr_stmt|;
name|pos
operator|++
expr_stmt|;
block|}
else|else
block|{
assert|assert
name|pos
operator|==
literal|0
assert|;
name|srcOps
index|[
name|pos
operator|++
index|]
operator|=
literal|null
expr_stmt|;
block|}
block|}
comment|// Type checking and implicit type conversion for join keys
name|genJoinOperatorTypeCheck
argument_list|(
name|joinSrcOp
argument_list|,
name|srcOps
argument_list|)
expr_stmt|;
return|return
name|genJoinOperatorChildren
argument_list|(
name|joinTree
argument_list|,
name|joinSrcOp
argument_list|,
name|srcOps
argument_list|)
return|;
block|}
specifier|private
name|void
name|genJoinOperatorTypeCheck
parameter_list|(
name|OperatorInfo
name|left
parameter_list|,
name|OperatorInfo
index|[]
name|right
parameter_list|)
throws|throws
name|SemanticException
block|{
comment|// keys[i] -> ArrayList<exprNodeDesc> for the i-th join operator key list
name|ArrayList
argument_list|<
name|ArrayList
argument_list|<
name|exprNodeDesc
argument_list|>
argument_list|>
name|keys
init|=
operator|new
name|ArrayList
argument_list|<
name|ArrayList
argument_list|<
name|exprNodeDesc
argument_list|>
argument_list|>
argument_list|()
decl_stmt|;
name|int
name|keyLength
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|right
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|OperatorInfo
name|oi
init|=
operator|(
name|i
operator|==
literal|0
operator|&&
name|right
index|[
name|i
index|]
operator|==
literal|null
condition|?
name|left
else|:
name|right
index|[
name|i
index|]
operator|)
decl_stmt|;
name|reduceSinkDesc
name|now
init|=
operator|(
call|(
name|ReduceSinkOperator
call|)
argument_list|(
name|oi
operator|.
name|getOp
argument_list|()
argument_list|)
operator|)
operator|.
name|getConf
argument_list|()
decl_stmt|;
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
name|keyLength
operator|=
name|now
operator|.
name|getKeyCols
argument_list|()
operator|.
name|size
argument_list|()
expr_stmt|;
block|}
else|else
block|{
assert|assert
operator|(
name|keyLength
operator|==
name|now
operator|.
name|getKeyCols
argument_list|()
operator|.
name|size
argument_list|()
operator|)
assert|;
block|}
name|keys
operator|.
name|add
argument_list|(
name|now
operator|.
name|getKeyCols
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// implicit type conversion hierarchy
for|for
control|(
name|int
name|k
init|=
literal|0
init|;
name|k
operator|<
name|keyLength
condition|;
name|k
operator|++
control|)
block|{
comment|// Find the common class for type conversion
name|Class
argument_list|<
name|?
argument_list|>
name|commonClass
init|=
name|keys
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|get
argument_list|(
name|k
argument_list|)
operator|.
name|getTypeInfo
argument_list|()
operator|.
name|getPrimitiveClass
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<
name|right
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|Class
argument_list|<
name|?
argument_list|>
name|a
init|=
name|commonClass
decl_stmt|;
name|Class
argument_list|<
name|?
argument_list|>
name|b
init|=
name|keys
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|get
argument_list|(
name|k
argument_list|)
operator|.
name|getTypeInfo
argument_list|()
operator|.
name|getPrimitiveClass
argument_list|()
decl_stmt|;
name|commonClass
operator|=
name|UDFRegistry
operator|.
name|getCommonClass
argument_list|(
name|a
argument_list|,
name|b
argument_list|)
expr_stmt|;
if|if
condition|(
name|commonClass
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
literal|"Cannot do equality join on different types: "
operator|+
name|a
operator|.
name|getClass
argument_list|()
operator|+
literal|" and "
operator|+
name|b
operator|.
name|getClass
argument_list|()
argument_list|)
throw|;
block|}
block|}
comment|// Add implicit type conversion if necessary
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|right
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|commonClass
operator|.
name|isAssignableFrom
argument_list|(
name|keys
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|get
argument_list|(
name|k
argument_list|)
operator|.
name|getTypeInfo
argument_list|()
operator|.
name|getPrimitiveClass
argument_list|()
argument_list|)
condition|)
block|{
name|keys
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|set
argument_list|(
name|k
argument_list|,
name|getFuncExprNodeDesc
argument_list|(
name|commonClass
operator|.
name|getName
argument_list|()
argument_list|,
name|keys
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|get
argument_list|(
name|k
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
specifier|private
name|OperatorInfoList
name|genJoinPlan
parameter_list|(
name|QB
name|qb
parameter_list|,
name|HashMap
argument_list|<
name|String
argument_list|,
name|OperatorInfoList
argument_list|>
name|map
parameter_list|)
throws|throws
name|SemanticException
block|{
name|QBJoinTree
name|joinTree
init|=
name|qb
operator|.
name|getQbJoinTree
argument_list|()
decl_stmt|;
name|OperatorInfo
name|joinOp
init|=
name|genJoinOperator
argument_list|(
name|qb
argument_list|,
name|joinTree
argument_list|,
name|map
argument_list|)
decl_stmt|;
name|OperatorInfoList
name|output
init|=
operator|new
name|OperatorInfoList
argument_list|()
decl_stmt|;
name|output
operator|.
name|add
argument_list|(
name|joinOp
argument_list|)
expr_stmt|;
return|return
name|output
return|;
block|}
specifier|private
name|QBJoinTree
name|genJoinTree
parameter_list|(
name|CommonTree
name|joinParseTree
parameter_list|)
throws|throws
name|SemanticException
block|{
name|QBJoinTree
name|joinTree
init|=
operator|new
name|QBJoinTree
argument_list|()
decl_stmt|;
name|joinCond
index|[]
name|condn
init|=
operator|new
name|joinCond
index|[
literal|1
index|]
decl_stmt|;
if|if
condition|(
name|joinParseTree
operator|.
name|getToken
argument_list|()
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_LEFTOUTERJOIN
condition|)
block|{
name|joinTree
operator|.
name|setNoOuterJoin
argument_list|(
literal|false
argument_list|)
expr_stmt|;
name|condn
index|[
literal|0
index|]
operator|=
operator|new
name|joinCond
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|,
name|joinType
operator|.
name|LEFTOUTER
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|joinParseTree
operator|.
name|getToken
argument_list|()
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_RIGHTOUTERJOIN
condition|)
block|{
name|joinTree
operator|.
name|setNoOuterJoin
argument_list|(
literal|false
argument_list|)
expr_stmt|;
name|condn
index|[
literal|0
index|]
operator|=
operator|new
name|joinCond
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|,
name|joinType
operator|.
name|RIGHTOUTER
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|joinParseTree
operator|.
name|getToken
argument_list|()
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_FULLOUTERJOIN
condition|)
block|{
name|joinTree
operator|.
name|setNoOuterJoin
argument_list|(
literal|false
argument_list|)
expr_stmt|;
name|condn
index|[
literal|0
index|]
operator|=
operator|new
name|joinCond
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|,
name|joinType
operator|.
name|FULLOUTER
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|condn
index|[
literal|0
index|]
operator|=
operator|new
name|joinCond
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|,
name|joinType
operator|.
name|INNER
argument_list|)
expr_stmt|;
name|joinTree
operator|.
name|setNoOuterJoin
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
name|joinTree
operator|.
name|setJoinCond
argument_list|(
name|condn
argument_list|)
expr_stmt|;
name|CommonTree
name|left
init|=
operator|(
name|CommonTree
operator|)
name|joinParseTree
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|CommonTree
name|right
init|=
operator|(
name|CommonTree
operator|)
name|joinParseTree
operator|.
name|getChild
argument_list|(
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|left
operator|.
name|getToken
argument_list|()
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_TABREF
operator|)
operator|||
operator|(
name|left
operator|.
name|getToken
argument_list|()
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_SUBQUERY
operator|)
condition|)
block|{
name|String
name|table_name
init|=
name|left
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getText
argument_list|()
decl_stmt|;
name|String
name|alias
init|=
name|left
operator|.
name|getChildCount
argument_list|()
operator|==
literal|1
condition|?
name|table_name
else|:
name|left
operator|.
name|getChild
argument_list|(
literal|1
argument_list|)
operator|.
name|getText
argument_list|()
decl_stmt|;
name|joinTree
operator|.
name|setLeftAlias
argument_list|(
name|alias
argument_list|)
expr_stmt|;
name|String
index|[]
name|leftAliases
init|=
operator|new
name|String
index|[
literal|1
index|]
decl_stmt|;
name|leftAliases
index|[
literal|0
index|]
operator|=
name|alias
expr_stmt|;
name|joinTree
operator|.
name|setLeftAliases
argument_list|(
name|leftAliases
argument_list|)
expr_stmt|;
name|String
index|[]
name|children
init|=
operator|new
name|String
index|[
literal|2
index|]
decl_stmt|;
name|children
index|[
literal|0
index|]
operator|=
name|alias
expr_stmt|;
name|joinTree
operator|.
name|setBaseSrc
argument_list|(
name|children
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|isJoinToken
argument_list|(
name|left
argument_list|)
condition|)
block|{
name|QBJoinTree
name|leftTree
init|=
name|genJoinTree
argument_list|(
name|left
argument_list|)
decl_stmt|;
name|joinTree
operator|.
name|setJoinSrc
argument_list|(
name|leftTree
argument_list|)
expr_stmt|;
name|String
index|[]
name|leftChildAliases
init|=
name|leftTree
operator|.
name|getLeftAliases
argument_list|()
decl_stmt|;
name|String
name|leftAliases
index|[]
init|=
operator|new
name|String
index|[
name|leftChildAliases
operator|.
name|length
operator|+
literal|1
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|leftChildAliases
operator|.
name|length
condition|;
name|i
operator|++
control|)
name|leftAliases
index|[
name|i
index|]
operator|=
name|leftChildAliases
index|[
name|i
index|]
expr_stmt|;
name|leftAliases
index|[
name|leftChildAliases
operator|.
name|length
index|]
operator|=
name|leftTree
operator|.
name|getRightAliases
argument_list|()
index|[
literal|0
index|]
expr_stmt|;
name|joinTree
operator|.
name|setLeftAliases
argument_list|(
name|leftAliases
argument_list|)
expr_stmt|;
block|}
else|else
assert|assert
operator|(
literal|false
operator|)
assert|;
if|if
condition|(
operator|(
name|right
operator|.
name|getToken
argument_list|()
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_TABREF
operator|)
operator|||
operator|(
name|right
operator|.
name|getToken
argument_list|()
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_SUBQUERY
operator|)
condition|)
block|{
name|String
name|table_name
init|=
name|right
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getText
argument_list|()
decl_stmt|;
name|String
name|alias
init|=
name|right
operator|.
name|getChildCount
argument_list|()
operator|==
literal|1
condition|?
name|table_name
else|:
name|right
operator|.
name|getChild
argument_list|(
literal|1
argument_list|)
operator|.
name|getText
argument_list|()
decl_stmt|;
name|String
index|[]
name|rightAliases
init|=
operator|new
name|String
index|[
literal|1
index|]
decl_stmt|;
name|rightAliases
index|[
literal|0
index|]
operator|=
name|alias
expr_stmt|;
name|joinTree
operator|.
name|setRightAliases
argument_list|(
name|rightAliases
argument_list|)
expr_stmt|;
name|String
index|[]
name|children
init|=
name|joinTree
operator|.
name|getBaseSrc
argument_list|()
decl_stmt|;
if|if
condition|(
name|children
operator|==
literal|null
condition|)
name|children
operator|=
operator|new
name|String
index|[
literal|2
index|]
expr_stmt|;
name|children
index|[
literal|1
index|]
operator|=
name|alias
expr_stmt|;
name|joinTree
operator|.
name|setBaseSrc
argument_list|(
name|children
argument_list|)
expr_stmt|;
block|}
else|else
assert|assert
literal|false
assert|;
name|Vector
argument_list|<
name|Vector
argument_list|<
name|CommonTree
argument_list|>
argument_list|>
name|expressions
init|=
operator|new
name|Vector
argument_list|<
name|Vector
argument_list|<
name|CommonTree
argument_list|>
argument_list|>
argument_list|()
decl_stmt|;
name|expressions
operator|.
name|add
argument_list|(
operator|new
name|Vector
argument_list|<
name|CommonTree
argument_list|>
argument_list|()
argument_list|)
expr_stmt|;
name|expressions
operator|.
name|add
argument_list|(
operator|new
name|Vector
argument_list|<
name|CommonTree
argument_list|>
argument_list|()
argument_list|)
expr_stmt|;
name|joinTree
operator|.
name|setExpressions
argument_list|(
name|expressions
argument_list|)
expr_stmt|;
name|CommonTree
name|joinCond
init|=
operator|(
name|CommonTree
operator|)
name|joinParseTree
operator|.
name|getChild
argument_list|(
literal|2
argument_list|)
decl_stmt|;
assert|assert
name|joinCond
operator|!=
literal|null
assert|;
name|Vector
argument_list|<
name|String
argument_list|>
name|leftSrc
init|=
operator|new
name|Vector
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
name|parseJoinCondition
argument_list|(
name|joinParseTree
argument_list|,
name|joinTree
argument_list|,
name|joinCond
argument_list|,
name|leftSrc
argument_list|)
expr_stmt|;
if|if
condition|(
name|leftSrc
operator|.
name|size
argument_list|()
operator|==
literal|1
condition|)
name|joinTree
operator|.
name|setLeftAlias
argument_list|(
name|leftSrc
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|joinTree
return|;
block|}
specifier|private
name|void
name|mergeJoins
parameter_list|(
name|QB
name|qb
parameter_list|,
name|QBJoinTree
name|parent
parameter_list|,
name|QBJoinTree
name|node
parameter_list|,
name|QBJoinTree
name|target
parameter_list|,
name|int
name|pos
parameter_list|)
block|{
name|String
index|[]
name|nodeRightAliases
init|=
name|node
operator|.
name|getRightAliases
argument_list|()
decl_stmt|;
name|String
index|[]
name|trgtRightAliases
init|=
name|target
operator|.
name|getRightAliases
argument_list|()
decl_stmt|;
name|String
index|[]
name|rightAliases
init|=
operator|new
name|String
index|[
name|nodeRightAliases
operator|.
name|length
operator|+
name|trgtRightAliases
operator|.
name|length
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|trgtRightAliases
operator|.
name|length
condition|;
name|i
operator|++
control|)
name|rightAliases
index|[
name|i
index|]
operator|=
name|trgtRightAliases
index|[
name|i
index|]
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|nodeRightAliases
operator|.
name|length
condition|;
name|i
operator|++
control|)
name|rightAliases
index|[
name|i
operator|+
name|trgtRightAliases
operator|.
name|length
index|]
operator|=
name|nodeRightAliases
index|[
name|i
index|]
expr_stmt|;
name|target
operator|.
name|setRightAliases
argument_list|(
name|rightAliases
argument_list|)
expr_stmt|;
name|String
index|[]
name|nodeBaseSrc
init|=
name|node
operator|.
name|getBaseSrc
argument_list|()
decl_stmt|;
name|String
index|[]
name|trgtBaseSrc
init|=
name|target
operator|.
name|getBaseSrc
argument_list|()
decl_stmt|;
name|String
index|[]
name|baseSrc
init|=
operator|new
name|String
index|[
name|nodeBaseSrc
operator|.
name|length
operator|+
name|trgtBaseSrc
operator|.
name|length
operator|-
literal|1
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|trgtBaseSrc
operator|.
name|length
condition|;
name|i
operator|++
control|)
name|baseSrc
index|[
name|i
index|]
operator|=
name|trgtBaseSrc
index|[
name|i
index|]
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<
name|nodeBaseSrc
operator|.
name|length
condition|;
name|i
operator|++
control|)
name|baseSrc
index|[
name|i
operator|+
name|trgtBaseSrc
operator|.
name|length
operator|-
literal|1
index|]
operator|=
name|nodeBaseSrc
index|[
name|i
index|]
expr_stmt|;
name|target
operator|.
name|setBaseSrc
argument_list|(
name|baseSrc
argument_list|)
expr_stmt|;
name|Vector
argument_list|<
name|Vector
argument_list|<
name|CommonTree
argument_list|>
argument_list|>
name|expr
init|=
name|target
operator|.
name|getExpressions
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|nodeRightAliases
operator|.
name|length
condition|;
name|i
operator|++
control|)
name|expr
operator|.
name|add
argument_list|(
name|node
operator|.
name|getExpressions
argument_list|()
operator|.
name|get
argument_list|(
name|i
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|qb
operator|.
name|getQbJoinTree
argument_list|()
operator|==
name|node
condition|)
name|qb
operator|.
name|setQbJoinTree
argument_list|(
name|node
operator|.
name|getJoinSrc
argument_list|()
argument_list|)
expr_stmt|;
else|else
name|parent
operator|.
name|setJoinSrc
argument_list|(
name|node
operator|.
name|getJoinSrc
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|node
operator|.
name|getNoOuterJoin
argument_list|()
operator|&&
name|target
operator|.
name|getNoOuterJoin
argument_list|()
condition|)
name|target
operator|.
name|setNoOuterJoin
argument_list|(
literal|true
argument_list|)
expr_stmt|;
else|else
name|target
operator|.
name|setNoOuterJoin
argument_list|(
literal|false
argument_list|)
expr_stmt|;
name|joinCond
index|[]
name|nodeCondns
init|=
name|node
operator|.
name|getJoinCond
argument_list|()
decl_stmt|;
name|int
name|nodeCondnsSize
init|=
name|nodeCondns
operator|.
name|length
decl_stmt|;
name|joinCond
index|[]
name|targetCondns
init|=
name|target
operator|.
name|getJoinCond
argument_list|()
decl_stmt|;
name|int
name|targetCondnsSize
init|=
name|targetCondns
operator|.
name|length
decl_stmt|;
name|joinCond
index|[]
name|newCondns
init|=
operator|new
name|joinCond
index|[
name|nodeCondnsSize
operator|+
name|targetCondnsSize
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|targetCondnsSize
condition|;
name|i
operator|++
control|)
name|newCondns
index|[
name|i
index|]
operator|=
name|targetCondns
index|[
name|i
index|]
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|nodeCondnsSize
condition|;
name|i
operator|++
control|)
block|{
name|joinCond
name|nodeCondn
init|=
name|nodeCondns
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|nodeCondn
operator|.
name|getLeft
argument_list|()
operator|==
literal|0
condition|)
name|nodeCondn
operator|.
name|setLeft
argument_list|(
name|pos
argument_list|)
expr_stmt|;
else|else
name|nodeCondn
operator|.
name|setLeft
argument_list|(
name|nodeCondn
operator|.
name|getLeft
argument_list|()
operator|+
name|targetCondnsSize
operator|-
literal|1
argument_list|)
expr_stmt|;
name|nodeCondn
operator|.
name|setRight
argument_list|(
name|nodeCondn
operator|.
name|getRight
argument_list|()
operator|+
name|targetCondnsSize
operator|-
literal|1
argument_list|)
expr_stmt|;
name|newCondns
index|[
name|targetCondnsSize
operator|+
name|i
index|]
operator|=
name|nodeCondn
expr_stmt|;
block|}
name|target
operator|.
name|setJoinCond
argument_list|(
name|newCondns
argument_list|)
expr_stmt|;
block|}
specifier|private
name|int
name|findMergePos
parameter_list|(
name|QBJoinTree
name|node
parameter_list|,
name|QBJoinTree
name|target
parameter_list|)
block|{
name|int
name|res
init|=
operator|-
literal|1
decl_stmt|;
name|String
name|leftAlias
init|=
name|node
operator|.
name|getLeftAlias
argument_list|()
decl_stmt|;
if|if
condition|(
name|leftAlias
operator|==
literal|null
condition|)
return|return
operator|-
literal|1
return|;
name|Vector
argument_list|<
name|CommonTree
argument_list|>
name|nodeCondn
init|=
name|node
operator|.
name|getExpressions
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|Vector
argument_list|<
name|CommonTree
argument_list|>
name|targetCondn
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|leftAlias
operator|.
name|equals
argument_list|(
name|target
operator|.
name|getLeftAlias
argument_list|()
argument_list|)
condition|)
block|{
name|targetCondn
operator|=
name|target
operator|.
name|getExpressions
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|res
operator|=
literal|0
expr_stmt|;
block|}
else|else
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|target
operator|.
name|getRightAliases
argument_list|()
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|leftAlias
operator|.
name|equals
argument_list|(
name|target
operator|.
name|getRightAliases
argument_list|()
index|[
name|i
index|]
argument_list|)
condition|)
block|{
name|targetCondn
operator|=
name|target
operator|.
name|getExpressions
argument_list|()
operator|.
name|get
argument_list|(
name|i
operator|+
literal|1
argument_list|)
expr_stmt|;
name|res
operator|=
name|i
operator|+
literal|1
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|(
name|targetCondn
operator|==
literal|null
operator|)
operator|||
operator|(
name|nodeCondn
operator|.
name|size
argument_list|()
operator|!=
name|targetCondn
operator|.
name|size
argument_list|()
operator|)
condition|)
return|return
operator|-
literal|1
return|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|nodeCondn
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
name|nodeCondn
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|toStringTree
argument_list|()
operator|.
name|equals
argument_list|(
name|targetCondn
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|toStringTree
argument_list|()
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
return|return
name|res
return|;
block|}
specifier|private
name|boolean
name|mergeJoinNodes
parameter_list|(
name|QB
name|qb
parameter_list|,
name|QBJoinTree
name|parent
parameter_list|,
name|QBJoinTree
name|node
parameter_list|,
name|QBJoinTree
name|target
parameter_list|)
block|{
if|if
condition|(
name|target
operator|==
literal|null
condition|)
return|return
literal|false
return|;
name|int
name|res
init|=
name|findMergePos
argument_list|(
name|node
argument_list|,
name|target
argument_list|)
decl_stmt|;
if|if
condition|(
name|res
operator|!=
operator|-
literal|1
condition|)
block|{
name|mergeJoins
argument_list|(
name|qb
argument_list|,
name|parent
argument_list|,
name|node
argument_list|,
name|target
argument_list|,
name|res
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
return|return
name|mergeJoinNodes
argument_list|(
name|qb
argument_list|,
name|parent
argument_list|,
name|node
argument_list|,
name|target
operator|.
name|getJoinSrc
argument_list|()
argument_list|)
return|;
block|}
specifier|private
name|void
name|mergeJoinTree
parameter_list|(
name|QB
name|qb
parameter_list|)
block|{
name|QBJoinTree
name|root
init|=
name|qb
operator|.
name|getQbJoinTree
argument_list|()
decl_stmt|;
name|QBJoinTree
name|parent
init|=
literal|null
decl_stmt|;
while|while
condition|(
name|root
operator|!=
literal|null
condition|)
block|{
name|boolean
name|merged
init|=
name|mergeJoinNodes
argument_list|(
name|qb
argument_list|,
name|parent
argument_list|,
name|root
argument_list|,
name|root
operator|.
name|getJoinSrc
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|parent
operator|==
literal|null
condition|)
block|{
if|if
condition|(
name|merged
condition|)
name|root
operator|=
name|qb
operator|.
name|getQbJoinTree
argument_list|()
expr_stmt|;
else|else
block|{
name|parent
operator|=
name|root
expr_stmt|;
name|root
operator|=
name|root
operator|.
name|getJoinSrc
argument_list|()
expr_stmt|;
block|}
block|}
else|else
block|{
name|parent
operator|=
name|parent
operator|.
name|getJoinSrc
argument_list|()
expr_stmt|;
name|root
operator|=
name|parent
operator|.
name|getJoinSrc
argument_list|()
expr_stmt|;
block|}
block|}
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"nls"
argument_list|)
specifier|private
name|OperatorInfoList
name|genBodyPlan
parameter_list|(
name|QB
name|qb
parameter_list|,
name|OperatorInfoList
name|input
parameter_list|)
throws|throws
name|SemanticException
block|{
name|QBParseInfo
name|qbp
init|=
name|qb
operator|.
name|getParseInfo
argument_list|()
decl_stmt|;
name|OperatorInfoList
name|output
init|=
operator|new
name|OperatorInfoList
argument_list|()
decl_stmt|;
name|TreeSet
argument_list|<
name|String
argument_list|>
name|ks
init|=
operator|new
name|TreeSet
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
name|ks
operator|.
name|addAll
argument_list|(
name|qbp
operator|.
name|getClauseNames
argument_list|()
argument_list|)
expr_stmt|;
comment|// Go over all the destination tables
for|for
control|(
name|String
name|dest
range|:
name|ks
control|)
block|{
name|OperatorInfoList
name|curr
init|=
name|input
decl_stmt|;
if|if
condition|(
name|qbp
operator|.
name|getWhrForClause
argument_list|(
name|dest
argument_list|)
operator|!=
literal|null
condition|)
block|{
name|curr
operator|=
name|genFilterPlan
argument_list|(
name|dest
argument_list|,
name|qb
argument_list|,
name|curr
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|qbp
operator|.
name|getAggregationExprsForClause
argument_list|(
name|dest
argument_list|)
operator|.
name|size
argument_list|()
operator|!=
literal|0
operator|||
name|getGroupByForClause
argument_list|(
name|qbp
argument_list|,
name|dest
argument_list|)
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
comment|// We always do 2MR group-by for now.
comment|// In the future, we will do 1MR group-by for
comment|// 1. Queries without DISTINCT (we will add combiner to 1MR group-by);
comment|// 2. Queries with UDAFs that does not support partial aggregations.
name|curr
operator|=
name|genGroupByPlan2MR
argument_list|(
name|dest
argument_list|,
name|qb
argument_list|,
name|curr
argument_list|)
expr_stmt|;
comment|// curr = genGroupByPlan1MR(dest, qb, curr);
block|}
else|else
block|{
name|curr
operator|=
name|genSelectPlan
argument_list|(
name|dest
argument_list|,
name|qb
argument_list|,
name|curr
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|qbp
operator|.
name|getClusterByForClause
argument_list|(
name|dest
argument_list|)
operator|!=
literal|null
condition|)
block|{
name|curr
operator|=
name|genReduceSinkPlan
argument_list|(
name|dest
argument_list|,
name|qb
argument_list|,
name|curr
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|qbp
operator|.
name|getIsSubQ
argument_list|()
condition|)
block|{
name|curr
operator|=
name|genConversionOps
argument_list|(
name|dest
argument_list|,
name|qb
argument_list|,
name|curr
argument_list|)
expr_stmt|;
name|curr
operator|=
name|genFileSinkPlan
argument_list|(
name|dest
argument_list|,
name|qb
argument_list|,
name|curr
argument_list|)
expr_stmt|;
block|}
name|output
operator|.
name|addAll
argument_list|(
name|curr
argument_list|)
expr_stmt|;
block|}
name|LOG
operator|.
name|debug
argument_list|(
literal|"Created Body Plan for Query Block "
operator|+
name|qb
operator|.
name|getId
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|output
return|;
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"nls"
argument_list|)
specifier|private
name|OperatorInfoList
name|genUnionPlan
parameter_list|(
name|String
name|unionalias
parameter_list|,
name|String
name|leftalias
parameter_list|,
name|OperatorInfoList
name|left
parameter_list|,
name|String
name|rightalias
parameter_list|,
name|OperatorInfoList
name|right
parameter_list|)
throws|throws
name|SemanticException
block|{
if|if
condition|(
name|left
operator|.
name|size
argument_list|()
operator|!=
literal|1
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
literal|"Select has more than one inputs"
argument_list|)
throw|;
block|}
name|OperatorInfo
name|leftOp
init|=
name|left
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|RowResolver
name|leftRR
init|=
name|leftOp
operator|.
name|getRowResolver
argument_list|()
decl_stmt|;
name|OperatorInfo
name|rightOp
init|=
name|right
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|RowResolver
name|rightRR
init|=
name|rightOp
operator|.
name|getRowResolver
argument_list|()
decl_stmt|;
name|HashMap
argument_list|<
name|String
argument_list|,
name|ColumnInfo
argument_list|>
name|leftmap
init|=
name|leftRR
operator|.
name|getFieldMap
argument_list|(
name|leftalias
argument_list|)
decl_stmt|;
name|HashMap
argument_list|<
name|String
argument_list|,
name|ColumnInfo
argument_list|>
name|rightmap
init|=
name|rightRR
operator|.
name|getFieldMap
argument_list|(
name|rightalias
argument_list|)
decl_stmt|;
comment|// make sure the schemas of both sides are the same
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|ColumnInfo
argument_list|>
name|lEntry
range|:
name|leftmap
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|String
name|field
init|=
name|lEntry
operator|.
name|getKey
argument_list|()
decl_stmt|;
name|ColumnInfo
name|lInfo
init|=
name|lEntry
operator|.
name|getValue
argument_list|()
decl_stmt|;
name|ColumnInfo
name|rInfo
init|=
name|rightmap
operator|.
name|get
argument_list|(
name|field
argument_list|)
decl_stmt|;
if|if
condition|(
name|rInfo
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
literal|"Schema of both sides of union should match. "
operator|+
name|rightalias
operator|+
literal|" does not have the field "
operator|+
name|field
argument_list|)
throw|;
block|}
if|if
condition|(
name|lInfo
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
literal|"Schema of both sides of union should match. "
operator|+
name|leftalias
operator|+
literal|" does not have the field "
operator|+
name|field
argument_list|)
throw|;
block|}
if|if
condition|(
operator|!
name|lInfo
operator|.
name|getInternalName
argument_list|()
operator|.
name|equals
argument_list|(
name|rInfo
operator|.
name|getInternalName
argument_list|()
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
literal|"Schema of both sides of union should match: "
operator|+
name|field
operator|+
literal|":"
operator|+
name|lInfo
operator|.
name|getInternalName
argument_list|()
operator|+
literal|" "
operator|+
name|rInfo
operator|.
name|getInternalName
argument_list|()
argument_list|)
throw|;
block|}
block|}
comment|// construct the forward operator
name|RowResolver
name|unionoutRR
init|=
operator|new
name|RowResolver
argument_list|()
decl_stmt|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|ColumnInfo
argument_list|>
name|lEntry
range|:
name|leftmap
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|String
name|field
init|=
name|lEntry
operator|.
name|getKey
argument_list|()
decl_stmt|;
name|ColumnInfo
name|lInfo
init|=
name|lEntry
operator|.
name|getValue
argument_list|()
decl_stmt|;
name|unionoutRR
operator|.
name|put
argument_list|(
name|unionalias
argument_list|,
name|field
argument_list|,
name|lInfo
argument_list|)
expr_stmt|;
block|}
name|Operator
argument_list|<
name|?
extends|extends
name|Serializable
argument_list|>
name|unionforward
init|=
name|OperatorFactory
operator|.
name|get
argument_list|(
name|forwardDesc
operator|.
name|class
argument_list|,
operator|new
name|RowSchema
argument_list|(
name|unionoutRR
operator|.
name|getColumnInfos
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
comment|// set forward operator as child of each of leftOp and rightOp
name|List
argument_list|<
name|Operator
argument_list|<
name|?
extends|extends
name|Serializable
argument_list|>
argument_list|>
name|child
init|=
operator|new
name|ArrayList
argument_list|<
name|Operator
argument_list|<
name|?
extends|extends
name|Serializable
argument_list|>
argument_list|>
argument_list|()
decl_stmt|;
name|child
operator|.
name|add
argument_list|(
name|unionforward
argument_list|)
expr_stmt|;
name|rightOp
operator|.
name|getOp
argument_list|()
operator|.
name|setChildOperators
argument_list|(
name|child
argument_list|)
expr_stmt|;
name|leftOp
operator|.
name|getOp
argument_list|()
operator|.
name|setChildOperators
argument_list|(
name|child
argument_list|)
expr_stmt|;
comment|// create operator info list to return
name|OperatorInfoList
name|unionout
init|=
operator|new
name|OperatorInfoList
argument_list|()
decl_stmt|;
name|unionout
operator|.
name|add
argument_list|(
operator|new
name|OperatorInfo
argument_list|(
name|unionforward
argument_list|,
name|unionoutRR
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|unionout
return|;
block|}
specifier|private
name|exprNodeDesc
name|genSamplePredicate
parameter_list|(
name|TableSample
name|ts
parameter_list|)
block|{
comment|// ((default_sample_hashfn(cols)& Integer.MAX_VALUE) % denominator) == numerator
name|exprNodeDesc
name|numeratorExpr
init|=
operator|new
name|exprNodeConstantDesc
argument_list|(
name|TypeInfo
operator|.
name|getPrimitiveTypeInfo
argument_list|(
name|Integer
operator|.
name|class
argument_list|)
argument_list|,
name|Integer
operator|.
name|valueOf
argument_list|(
name|ts
operator|.
name|getNumerator
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
name|exprNodeDesc
name|denominatorExpr
init|=
operator|new
name|exprNodeConstantDesc
argument_list|(
name|TypeInfo
operator|.
name|getPrimitiveTypeInfo
argument_list|(
name|Integer
operator|.
name|class
argument_list|)
argument_list|,
name|Integer
operator|.
name|valueOf
argument_list|(
name|ts
operator|.
name|getDenominator
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
name|exprNodeDesc
name|intMaxExpr
init|=
operator|new
name|exprNodeConstantDesc
argument_list|(
name|TypeInfo
operator|.
name|getPrimitiveTypeInfo
argument_list|(
name|Integer
operator|.
name|class
argument_list|)
argument_list|,
name|Integer
operator|.
name|valueOf
argument_list|(
name|Integer
operator|.
name|MAX_VALUE
argument_list|)
argument_list|)
decl_stmt|;
name|ArrayList
argument_list|<
name|exprNodeDesc
argument_list|>
name|args
init|=
operator|new
name|ArrayList
argument_list|<
name|exprNodeDesc
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|String
name|col
range|:
name|ts
operator|.
name|getCols
argument_list|()
control|)
block|{
comment|// TODO: change type to the one in the table schema
name|args
operator|.
name|add
argument_list|(
operator|new
name|exprNodeColumnDesc
argument_list|(
name|String
operator|.
name|class
argument_list|,
name|col
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|exprNodeDesc
name|hashfnExpr
init|=
name|getFuncExprNodeDesc
argument_list|(
literal|"default_sample_hashfn"
argument_list|,
name|args
argument_list|)
decl_stmt|;
assert|assert
operator|(
name|hashfnExpr
operator|!=
literal|null
operator|)
assert|;
name|LOG
operator|.
name|info
argument_list|(
literal|"hashfnExpr = "
operator|+
name|hashfnExpr
argument_list|)
expr_stmt|;
name|exprNodeDesc
name|andExpr
init|=
name|getFuncExprNodeDesc
argument_list|(
literal|"&"
argument_list|,
name|hashfnExpr
argument_list|,
name|intMaxExpr
argument_list|)
decl_stmt|;
assert|assert
operator|(
name|andExpr
operator|!=
literal|null
operator|)
assert|;
name|LOG
operator|.
name|info
argument_list|(
literal|"andExpr = "
operator|+
name|andExpr
argument_list|)
expr_stmt|;
name|exprNodeDesc
name|modExpr
init|=
name|getFuncExprNodeDesc
argument_list|(
literal|"%"
argument_list|,
name|andExpr
argument_list|,
name|denominatorExpr
argument_list|)
decl_stmt|;
assert|assert
operator|(
name|modExpr
operator|!=
literal|null
operator|)
assert|;
name|LOG
operator|.
name|info
argument_list|(
literal|"modExpr = "
operator|+
name|modExpr
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"numeratorExpr = "
operator|+
name|numeratorExpr
argument_list|)
expr_stmt|;
name|exprNodeDesc
name|equalsExpr
init|=
name|getFuncExprNodeDesc
argument_list|(
literal|"=="
argument_list|,
name|modExpr
argument_list|,
name|numeratorExpr
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"equalsExpr = "
operator|+
name|equalsExpr
argument_list|)
expr_stmt|;
assert|assert
operator|(
name|equalsExpr
operator|!=
literal|null
operator|)
assert|;
return|return
name|equalsExpr
return|;
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"nls"
argument_list|)
specifier|private
name|OperatorInfoList
name|genTablePlan
parameter_list|(
name|String
name|alias
parameter_list|,
name|QB
name|qb
parameter_list|)
throws|throws
name|SemanticException
block|{
name|Table
name|tab
init|=
name|qb
operator|.
name|getMetaData
argument_list|()
operator|.
name|getSrcForAlias
argument_list|(
name|alias
argument_list|)
decl_stmt|;
name|RowResolver
name|rwsch
init|=
operator|new
name|RowResolver
argument_list|()
decl_stmt|;
for|for
control|(
name|SerDeField
name|field
range|:
name|tab
operator|.
name|getFields
argument_list|(
literal|null
argument_list|)
control|)
block|{
name|rwsch
operator|.
name|put
argument_list|(
name|alias
argument_list|,
name|field
operator|.
name|getName
argument_list|()
argument_list|,
operator|new
name|ColumnInfo
argument_list|(
name|field
operator|.
name|getName
argument_list|()
argument_list|,
operator|new
name|TypeInfo
argument_list|(
name|tab
operator|.
name|getSerDe
argument_list|()
argument_list|,
name|field
argument_list|)
argument_list|,
literal|false
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// Hack!! - refactor once the metadata APIs with types are ready
comment|// Finally add the partitioning columns
for|for
control|(
name|FieldSchema
name|part_col
range|:
name|tab
operator|.
name|getPartCols
argument_list|()
control|)
block|{
name|LOG
operator|.
name|trace
argument_list|(
literal|"Adding partition col: "
operator|+
name|part_col
argument_list|)
expr_stmt|;
comment|// TODO: use the right type by calling part_col.getType() instead of String.class
name|rwsch
operator|.
name|put
argument_list|(
name|alias
argument_list|,
name|part_col
operator|.
name|getName
argument_list|()
argument_list|,
operator|new
name|ColumnInfo
argument_list|(
name|part_col
operator|.
name|getName
argument_list|()
argument_list|,
name|String
operator|.
name|class
argument_list|,
literal|true
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// Create the root of the operator tree
name|Operator
argument_list|<
name|?
extends|extends
name|Serializable
argument_list|>
name|top
init|=
name|OperatorFactory
operator|.
name|get
argument_list|(
name|forwardDesc
operator|.
name|class
argument_list|,
operator|new
name|RowSchema
argument_list|(
name|rwsch
operator|.
name|getColumnInfos
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
name|String
name|alias_id
init|=
operator|(
name|qb
operator|.
name|getId
argument_list|()
operator|==
literal|null
condition|?
name|alias
else|:
name|qb
operator|.
name|getId
argument_list|()
operator|+
literal|":"
operator|+
name|alias
operator|)
decl_stmt|;
comment|// Add this to the list of top operators - we always start from a table scan
name|this
operator|.
name|topOps
operator|.
name|put
argument_list|(
name|alias_id
argument_list|,
name|top
argument_list|)
expr_stmt|;
comment|// check if this table is sampled and needs more than input pruning
name|Operator
argument_list|<
name|?
extends|extends
name|Serializable
argument_list|>
name|tableOp
init|=
name|top
decl_stmt|;
name|TableSample
name|ts
init|=
name|qb
operator|.
name|getParseInfo
argument_list|()
operator|.
name|getTabSample
argument_list|(
name|alias
argument_list|)
decl_stmt|;
if|if
condition|(
name|ts
operator|!=
literal|null
condition|)
block|{
name|int
name|num
init|=
name|ts
operator|.
name|getNumerator
argument_list|()
decl_stmt|;
name|int
name|den
init|=
name|ts
operator|.
name|getDenominator
argument_list|()
decl_stmt|;
name|ArrayList
argument_list|<
name|String
argument_list|>
name|sampleCols
init|=
name|ts
operator|.
name|getCols
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|FieldSchema
argument_list|>
name|tabCols
init|=
name|tab
operator|.
name|getCols
argument_list|()
decl_stmt|;
comment|// check if sampleCols are present in the table
for|for
control|(
name|String
name|col
range|:
name|sampleCols
control|)
block|{
name|boolean
name|found
init|=
literal|false
decl_stmt|;
for|for
control|(
name|FieldSchema
name|s
range|:
name|tabCols
control|)
block|{
if|if
condition|(
name|col
operator|.
name|equalsIgnoreCase
argument_list|(
name|s
operator|.
name|getName
argument_list|()
argument_list|)
condition|)
block|{
name|found
operator|=
literal|true
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|found
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|SAMPLE_COLUMN_NOT_FOUND
operator|.
name|getMsg
argument_list|(
name|qb
operator|.
name|getParseInfo
argument_list|()
operator|.
name|getSrcForAlias
argument_list|(
name|alias
argument_list|)
argument_list|,
literal|"Sampling column "
operator|+
name|col
operator|+
literal|" not found in table "
operator|+
name|tab
operator|.
name|getName
argument_list|()
argument_list|)
argument_list|)
throw|;
block|}
block|}
name|List
argument_list|<
name|String
argument_list|>
name|tabBucketCols
init|=
name|tab
operator|.
name|getBucketCols
argument_list|()
decl_stmt|;
name|int
name|numBuckets
init|=
name|tab
operator|.
name|getNumBuckets
argument_list|()
decl_stmt|;
comment|// check if a predicate is needed
comment|// predicate is needed if either input pruning is not enough
comment|// or if input pruning is not possible
comment|// check if the sample columns are the same as the table bucket columns
comment|// and if they are, create a new array of column names which is in the
comment|// same order as tabBucketCols
name|boolean
name|colsEqual
init|=
literal|true
decl_stmt|;
if|if
condition|(
name|sampleCols
operator|.
name|size
argument_list|()
operator|!=
name|tabBucketCols
operator|.
name|size
argument_list|()
condition|)
block|{
name|colsEqual
operator|=
literal|false
expr_stmt|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|sampleCols
operator|.
name|size
argument_list|()
operator|&&
name|colsEqual
condition|;
name|i
operator|++
control|)
block|{
name|boolean
name|colFound
init|=
literal|false
decl_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|tabBucketCols
operator|.
name|size
argument_list|()
operator|&&
operator|!
name|colFound
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|sampleCols
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|equalsIgnoreCase
argument_list|(
name|tabBucketCols
operator|.
name|get
argument_list|(
name|j
argument_list|)
argument_list|)
condition|)
block|{
name|colFound
operator|=
literal|true
expr_stmt|;
block|}
block|}
name|colsEqual
operator|=
name|colFound
expr_stmt|;
block|}
comment|// if the sample columns are the same, we need them in the same order
comment|// as tabBucketCols
if|if
condition|(
name|colsEqual
condition|)
block|{
name|ts
operator|.
name|setCols
argument_list|(
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|(
name|tabBucketCols
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// check if input pruning is enough
if|if
condition|(
operator|(
name|sampleCols
operator|==
literal|null
operator|||
name|sampleCols
operator|.
name|size
argument_list|()
operator|==
literal|0
operator|||
name|colsEqual
operator|)
operator|&&
operator|(
name|num
operator|==
name|den
operator|||
name|den
operator|<=
name|numBuckets
operator|&&
name|numBuckets
operator|%
name|den
operator|==
literal|0
operator|)
condition|)
block|{
comment|// input pruning is enough; no need for filter
name|LOG
operator|.
name|info
argument_list|(
literal|"No need for sample filter"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// need to add filter
comment|// create tableOp to be filterDesc and set as child to 'top'
name|LOG
operator|.
name|info
argument_list|(
literal|"Need sample filter"
argument_list|)
expr_stmt|;
name|exprNodeDesc
name|samplePredicate
init|=
name|genSamplePredicate
argument_list|(
name|ts
argument_list|)
decl_stmt|;
name|tableOp
operator|=
name|OperatorFactory
operator|.
name|getAndMakeChild
argument_list|(
operator|new
name|filterDesc
argument_list|(
name|samplePredicate
argument_list|)
argument_list|,
name|top
argument_list|)
expr_stmt|;
block|}
block|}
name|OperatorInfoList
name|output
init|=
operator|new
name|OperatorInfoList
argument_list|()
decl_stmt|;
name|output
operator|.
name|add
argument_list|(
operator|new
name|OperatorInfo
argument_list|(
name|tableOp
argument_list|,
name|rwsch
argument_list|)
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Created Table Plan for "
operator|+
name|alias
operator|+
literal|" "
operator|+
name|tableOp
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|output
return|;
block|}
specifier|private
name|OperatorInfoList
name|genPlan
parameter_list|(
name|QBExpr
name|qbexpr
parameter_list|)
throws|throws
name|SemanticException
block|{
if|if
condition|(
name|qbexpr
operator|.
name|getOpcode
argument_list|()
operator|==
name|QBExpr
operator|.
name|Opcode
operator|.
name|NULLOP
condition|)
block|{
name|OperatorInfoList
name|oplist
init|=
name|genPlan
argument_list|(
name|qbexpr
operator|.
name|getQB
argument_list|()
argument_list|)
decl_stmt|;
return|return
name|oplist
return|;
block|}
if|if
condition|(
name|qbexpr
operator|.
name|getOpcode
argument_list|()
operator|==
name|QBExpr
operator|.
name|Opcode
operator|.
name|UNION
condition|)
block|{
name|OperatorInfoList
name|qbexpr1Ops
init|=
name|genPlan
argument_list|(
name|qbexpr
operator|.
name|getQBExpr1
argument_list|()
argument_list|)
decl_stmt|;
name|OperatorInfoList
name|qbexpr2Ops
init|=
name|genPlan
argument_list|(
name|qbexpr
operator|.
name|getQBExpr2
argument_list|()
argument_list|)
decl_stmt|;
return|return
name|genUnionPlan
argument_list|(
name|qbexpr
operator|.
name|getAlias
argument_list|()
argument_list|,
name|qbexpr
operator|.
name|getQBExpr1
argument_list|()
operator|.
name|getAlias
argument_list|()
argument_list|,
name|qbexpr1Ops
argument_list|,
name|qbexpr
operator|.
name|getQBExpr2
argument_list|()
operator|.
name|getAlias
argument_list|()
argument_list|,
name|qbexpr2Ops
argument_list|)
return|;
block|}
return|return
literal|null
return|;
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"nls"
argument_list|)
specifier|private
name|OperatorInfoList
name|genPlan
parameter_list|(
name|QB
name|qb
parameter_list|)
throws|throws
name|SemanticException
block|{
comment|// First generate all the opInfos for the elements in the from clause
name|HashMap
argument_list|<
name|String
argument_list|,
name|OperatorInfoList
argument_list|>
name|aliasToOpInfo
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|OperatorInfoList
argument_list|>
argument_list|()
decl_stmt|;
comment|// Recurse over the subqueries to fill the subquery part of the plan
for|for
control|(
name|String
name|alias
range|:
name|qb
operator|.
name|getSubqAliases
argument_list|()
control|)
block|{
name|QBExpr
name|qbexpr
init|=
name|qb
operator|.
name|getSubqForAlias
argument_list|(
name|alias
argument_list|)
decl_stmt|;
name|aliasToOpInfo
operator|.
name|put
argument_list|(
name|alias
argument_list|,
name|genPlan
argument_list|(
name|qbexpr
argument_list|)
argument_list|)
expr_stmt|;
name|qbexpr
operator|.
name|setAlias
argument_list|(
name|alias
argument_list|)
expr_stmt|;
block|}
comment|// Recurse over all the source tables
for|for
control|(
name|String
name|alias
range|:
name|qb
operator|.
name|getTabAliases
argument_list|()
control|)
block|{
name|aliasToOpInfo
operator|.
name|put
argument_list|(
name|alias
argument_list|,
name|genTablePlan
argument_list|(
name|alias
argument_list|,
name|qb
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|OperatorInfoList
name|srcOpInfoList
init|=
literal|null
decl_stmt|;
comment|// process join
if|if
condition|(
name|qb
operator|.
name|getParseInfo
argument_list|()
operator|.
name|getJoinExpr
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|CommonTree
name|joinExpr
init|=
name|qb
operator|.
name|getParseInfo
argument_list|()
operator|.
name|getJoinExpr
argument_list|()
decl_stmt|;
name|QBJoinTree
name|joinTree
init|=
name|genJoinTree
argument_list|(
name|joinExpr
argument_list|)
decl_stmt|;
name|qb
operator|.
name|setQbJoinTree
argument_list|(
name|joinTree
argument_list|)
expr_stmt|;
name|mergeJoinTree
argument_list|(
name|qb
argument_list|)
expr_stmt|;
name|srcOpInfoList
operator|=
name|genJoinPlan
argument_list|(
name|qb
argument_list|,
name|aliasToOpInfo
argument_list|)
expr_stmt|;
block|}
else|else
comment|// Now if there are more than 1 sources then we have a join case
comment|// later we can extend this to the union all case as well
name|srcOpInfoList
operator|=
name|aliasToOpInfo
operator|.
name|values
argument_list|()
operator|.
name|iterator
argument_list|()
operator|.
name|next
argument_list|()
expr_stmt|;
name|OperatorInfoList
name|bodyOpInfoList
init|=
name|genBodyPlan
argument_list|(
name|qb
argument_list|,
name|srcOpInfoList
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Created Plan for Query Block "
operator|+
name|qb
operator|.
name|getId
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|bodyOpInfoList
return|;
block|}
specifier|private
name|Operator
argument_list|<
name|?
extends|extends
name|Serializable
argument_list|>
name|getReducer
parameter_list|(
name|Operator
argument_list|<
name|?
extends|extends
name|Serializable
argument_list|>
name|top
parameter_list|)
block|{
if|if
condition|(
name|top
operator|.
name|getClass
argument_list|()
operator|==
name|ReduceSinkOperator
operator|.
name|class
condition|)
block|{
comment|// Get the operator following the reduce sink
assert|assert
operator|(
name|top
operator|.
name|getChildOperators
argument_list|()
operator|.
name|size
argument_list|()
operator|==
literal|1
operator|)
assert|;
return|return
name|top
operator|.
name|getChildOperators
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
return|;
block|}
name|List
argument_list|<
name|Operator
argument_list|<
name|?
extends|extends
name|Serializable
argument_list|>
argument_list|>
name|childOps
init|=
name|top
operator|.
name|getChildOperators
argument_list|()
decl_stmt|;
if|if
condition|(
name|childOps
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|childOps
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|Operator
argument_list|<
name|?
extends|extends
name|Serializable
argument_list|>
name|reducer
init|=
name|getReducer
argument_list|(
name|childOps
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|reducer
operator|!=
literal|null
condition|)
block|{
return|return
name|reducer
return|;
block|}
block|}
return|return
literal|null
return|;
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"nls"
argument_list|)
specifier|private
name|void
name|genMapRedTasks
parameter_list|()
throws|throws
name|SemanticException
block|{
comment|// First we generate the move work as this needs to be made dependent on all
comment|// the tasks
comment|// that have a file sink operation
name|moveWork
name|mv
init|=
operator|new
name|moveWork
argument_list|(
name|loadTableWork
argument_list|,
name|loadFileWork
argument_list|)
decl_stmt|;
name|Task
argument_list|<
name|?
extends|extends
name|Serializable
argument_list|>
name|mvTask
init|=
name|TaskFactory
operator|.
name|get
argument_list|(
name|mv
argument_list|,
name|this
operator|.
name|conf
argument_list|)
decl_stmt|;
comment|// Maintain a map from the top level left most reducer in each of these
comment|// trees
comment|// to a task. This tells us whether we have to allocate another
comment|// root level task or we can reuse an existing one
name|HashMap
argument_list|<
name|Operator
argument_list|<
name|?
extends|extends
name|Serializable
argument_list|>
argument_list|,
name|Task
argument_list|<
name|?
extends|extends
name|Serializable
argument_list|>
argument_list|>
name|opTaskMap
init|=
operator|new
name|HashMap
argument_list|<
name|Operator
argument_list|<
name|?
extends|extends
name|Serializable
argument_list|>
argument_list|,
name|Task
argument_list|<
name|?
extends|extends
name|Serializable
argument_list|>
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|String
name|alias_id
range|:
name|this
operator|.
name|topOps
operator|.
name|keySet
argument_list|()
control|)
block|{
name|Operator
argument_list|<
name|?
extends|extends
name|Serializable
argument_list|>
name|topOp
init|=
name|this
operator|.
name|topOps
operator|.
name|get
argument_list|(
name|alias_id
argument_list|)
decl_stmt|;
name|Operator
argument_list|<
name|?
extends|extends
name|Serializable
argument_list|>
name|reducer
init|=
name|getReducer
argument_list|(
name|topOp
argument_list|)
decl_stmt|;
name|Task
argument_list|<
name|?
extends|extends
name|Serializable
argument_list|>
name|rootTask
init|=
name|opTaskMap
operator|.
name|get
argument_list|(
name|reducer
argument_list|)
decl_stmt|;
if|if
condition|(
name|rootTask
operator|==
literal|null
condition|)
block|{
name|rootTask
operator|=
name|TaskFactory
operator|.
name|get
argument_list|(
name|getMapRedWork
argument_list|()
argument_list|,
name|this
operator|.
name|conf
argument_list|)
expr_stmt|;
name|opTaskMap
operator|.
name|put
argument_list|(
name|reducer
argument_list|,
name|rootTask
argument_list|)
expr_stmt|;
operator|(
operator|(
name|mapredWork
operator|)
name|rootTask
operator|.
name|getWork
argument_list|()
operator|)
operator|.
name|setReducer
argument_list|(
name|reducer
argument_list|)
expr_stmt|;
name|this
operator|.
name|rootTasks
operator|.
name|add
argument_list|(
name|rootTask
argument_list|)
expr_stmt|;
block|}
name|genTaskPlan
argument_list|(
name|topOp
argument_list|,
name|rootTask
argument_list|,
name|opTaskMap
argument_list|,
name|mvTask
argument_list|)
expr_stmt|;
comment|// Generate the map work for this alias_id
name|PartitionPruner
name|pruner
init|=
name|this
operator|.
name|aliasToPruner
operator|.
name|get
argument_list|(
name|alias_id
argument_list|)
decl_stmt|;
name|Set
argument_list|<
name|Partition
argument_list|>
name|parts
init|=
literal|null
decl_stmt|;
try|try
block|{
name|parts
operator|=
name|pruner
operator|.
name|prune
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|HiveException
name|e
parameter_list|)
block|{
comment|// Has to use full name to make sure it does not conflict with org.apache.commons.lang.StringUtils
name|LOG
operator|.
name|error
argument_list|(
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|StringUtils
operator|.
name|stringifyException
argument_list|(
name|e
argument_list|)
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|SemanticException
argument_list|(
name|e
operator|.
name|getMessage
argument_list|()
argument_list|,
name|e
argument_list|)
throw|;
block|}
name|SamplePruner
name|samplePruner
init|=
name|this
operator|.
name|aliasToSamplePruner
operator|.
name|get
argument_list|(
name|alias_id
argument_list|)
decl_stmt|;
name|mapredWork
name|plan
init|=
operator|(
name|mapredWork
operator|)
name|rootTask
operator|.
name|getWork
argument_list|()
decl_stmt|;
for|for
control|(
name|Partition
name|part
range|:
name|parts
control|)
block|{
comment|// Later the properties have to come from the partition as opposed
comment|// to from the table in order to support versioning.
name|Path
name|paths
index|[]
decl_stmt|;
if|if
condition|(
name|samplePruner
operator|!=
literal|null
condition|)
block|{
name|paths
operator|=
name|samplePruner
operator|.
name|prune
argument_list|(
name|part
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|paths
operator|=
name|part
operator|.
name|getPath
argument_list|()
expr_stmt|;
block|}
for|for
control|(
name|Path
name|p
range|:
name|paths
control|)
block|{
name|String
name|path
init|=
name|p
operator|.
name|toString
argument_list|()
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Adding "
operator|+
name|path
operator|+
literal|" of table"
operator|+
name|alias_id
argument_list|)
expr_stmt|;
comment|// Add the path to alias mapping
if|if
condition|(
name|plan
operator|.
name|getPathToAliases
argument_list|()
operator|.
name|get
argument_list|(
name|path
argument_list|)
operator|==
literal|null
condition|)
block|{
name|plan
operator|.
name|getPathToAliases
argument_list|()
operator|.
name|put
argument_list|(
name|path
argument_list|,
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|plan
operator|.
name|getPathToAliases
argument_list|()
operator|.
name|get
argument_list|(
name|path
argument_list|)
operator|.
name|add
argument_list|(
name|alias_id
argument_list|)
expr_stmt|;
name|plan
operator|.
name|getPathToPartitionInfo
argument_list|()
operator|.
name|put
argument_list|(
name|path
argument_list|,
name|Utilities
operator|.
name|getPartitionDesc
argument_list|(
name|part
argument_list|)
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Information added for path "
operator|+
name|path
argument_list|)
expr_stmt|;
block|}
block|}
name|plan
operator|.
name|getAliasToWork
argument_list|()
operator|.
name|put
argument_list|(
name|alias_id
argument_list|,
name|topOp
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Created Map Work for "
operator|+
name|alias_id
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"nls"
argument_list|)
specifier|private
name|void
name|genTaskPlan
parameter_list|(
name|Operator
argument_list|<
name|?
extends|extends
name|Serializable
argument_list|>
name|op
parameter_list|,
name|Task
argument_list|<
name|?
extends|extends
name|Serializable
argument_list|>
name|currTask
parameter_list|,
name|HashMap
argument_list|<
name|Operator
argument_list|<
name|?
extends|extends
name|Serializable
argument_list|>
argument_list|,
name|Task
argument_list|<
name|?
extends|extends
name|Serializable
argument_list|>
argument_list|>
name|redTaskMap
parameter_list|,
name|Task
argument_list|<
name|?
extends|extends
name|Serializable
argument_list|>
name|mvTask
parameter_list|)
block|{
comment|// Check if this is a file sink operator
if|if
condition|(
name|op
operator|.
name|getClass
argument_list|()
operator|==
name|FileSinkOperator
operator|.
name|class
condition|)
block|{
comment|// If this is a file sink operator then set the move task to be dependent
comment|// on the current task
name|currTask
operator|.
name|addDependentTask
argument_list|(
name|mvTask
argument_list|)
expr_stmt|;
block|}
name|List
argument_list|<
name|Operator
argument_list|<
name|?
extends|extends
name|Serializable
argument_list|>
argument_list|>
name|childOps
init|=
name|op
operator|.
name|getChildOperators
argument_list|()
decl_stmt|;
comment|// If there are no children then we are done
if|if
condition|(
name|childOps
operator|==
literal|null
condition|)
block|{
return|return;
block|}
comment|// Otherwise go through the children and check for the operator following
comment|// the reduce sink operator
name|mapredWork
name|plan
init|=
operator|(
name|mapredWork
operator|)
name|currTask
operator|.
name|getWork
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|childOps
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|Operator
argument_list|<
name|?
extends|extends
name|Serializable
argument_list|>
name|child
init|=
name|childOps
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|child
operator|.
name|getClass
argument_list|()
operator|==
name|ReduceSinkOperator
operator|.
name|class
condition|)
block|{
comment|// Get the operator following the reduce sink
assert|assert
operator|(
name|child
operator|.
name|getChildOperators
argument_list|()
operator|.
name|size
argument_list|()
operator|==
literal|1
operator|)
assert|;
name|Operator
argument_list|<
name|?
extends|extends
name|Serializable
argument_list|>
name|reducer
init|=
name|child
operator|.
name|getChildOperators
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
assert|assert
operator|(
name|plan
operator|.
name|getReducer
argument_list|()
operator|!=
literal|null
operator|)
assert|;
if|if
condition|(
name|plan
operator|.
name|getReducer
argument_list|()
operator|==
name|reducer
condition|)
block|{
if|if
condition|(
name|child
operator|.
name|getChildOperators
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|getClass
argument_list|()
operator|==
name|JoinOperator
operator|.
name|class
condition|)
name|plan
operator|.
name|setNeedsTagging
argument_list|(
literal|true
argument_list|)
expr_stmt|;
comment|// Recurse on the reducer
name|genTaskPlan
argument_list|(
name|reducer
argument_list|,
name|currTask
argument_list|,
name|redTaskMap
argument_list|,
name|mvTask
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|plan
operator|.
name|getReducer
argument_list|()
operator|!=
name|reducer
condition|)
block|{
name|Task
argument_list|<
name|?
extends|extends
name|Serializable
argument_list|>
name|ctask
init|=
literal|null
decl_stmt|;
name|mapredWork
name|cplan
init|=
literal|null
decl_stmt|;
comment|// First check if the reducer already has an associated task
name|ctask
operator|=
name|redTaskMap
operator|.
name|get
argument_list|(
name|reducer
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctask
operator|==
literal|null
condition|)
block|{
comment|// For this case we need to generate a new task
name|cplan
operator|=
name|getMapRedWork
argument_list|()
expr_stmt|;
name|ctask
operator|=
name|TaskFactory
operator|.
name|get
argument_list|(
name|cplan
argument_list|,
name|this
operator|.
name|conf
argument_list|)
expr_stmt|;
comment|// Add the reducer
name|cplan
operator|.
name|setReducer
argument_list|(
name|reducer
argument_list|)
expr_stmt|;
name|redTaskMap
operator|.
name|put
argument_list|(
name|reducer
argument_list|,
name|ctask
argument_list|)
expr_stmt|;
comment|// Recurse on the reducer
name|genTaskPlan
argument_list|(
name|reducer
argument_list|,
name|ctask
argument_list|,
name|redTaskMap
argument_list|,
name|mvTask
argument_list|)
expr_stmt|;
comment|// generate the temporary file
name|String
name|taskTmpDir
init|=
name|this
operator|.
name|scratchDir
operator|+
name|File
operator|.
name|separator
operator|+
name|this
operator|.
name|randomid
operator|+
literal|'.'
operator|+
name|this
operator|.
name|pathid
decl_stmt|;
name|this
operator|.
name|pathid
operator|++
expr_stmt|;
comment|// Go over the row schema of the input operator and generate the
comment|// column names using that
name|StringBuilder
name|sb
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|boolean
name|isfirst
init|=
literal|true
decl_stmt|;
for|for
control|(
name|ColumnInfo
name|colInfo
range|:
name|op
operator|.
name|getSchema
argument_list|()
operator|.
name|getSignature
argument_list|()
control|)
block|{
if|if
condition|(
operator|!
name|isfirst
condition|)
block|{
name|sb
operator|.
name|append
argument_list|(
literal|","
argument_list|)
expr_stmt|;
block|}
name|sb
operator|.
name|append
argument_list|(
name|colInfo
operator|.
name|getInternalName
argument_list|()
argument_list|)
expr_stmt|;
name|isfirst
operator|=
literal|false
expr_stmt|;
block|}
name|tableDesc
name|tt_desc
init|=
operator|new
name|tableDesc
argument_list|(
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde
operator|.
name|simple_meta
operator|.
name|MetadataTypedColumnsetSerDe
operator|.
name|class
argument_list|,
name|TextInputFormat
operator|.
name|class
argument_list|,
name|IgnoreKeyTextOutputFormat
operator|.
name|class
argument_list|,
name|Utilities
operator|.
name|makeProperties
argument_list|(
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde
operator|.
name|Constants
operator|.
name|SERIALIZATION_FORMAT
argument_list|,
literal|""
operator|+
name|Utilities
operator|.
name|ctrlaCode
argument_list|,
literal|"columns"
argument_list|,
name|sb
operator|.
name|toString
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
comment|// Create a file sink operator for this file name
name|Operator
argument_list|<
name|?
extends|extends
name|Serializable
argument_list|>
name|fs_op
init|=
name|OperatorFactory
operator|.
name|get
argument_list|(
operator|new
name|fileSinkDesc
argument_list|(
name|taskTmpDir
argument_list|,
name|tt_desc
argument_list|)
argument_list|,
name|op
operator|.
name|getSchema
argument_list|()
argument_list|)
decl_stmt|;
comment|// replace the reduce child with this operator
name|childOps
operator|.
name|set
argument_list|(
name|i
argument_list|,
name|fs_op
argument_list|)
expr_stmt|;
comment|// Add the path to alias mapping
if|if
condition|(
name|cplan
operator|.
name|getPathToAliases
argument_list|()
operator|.
name|get
argument_list|(
name|taskTmpDir
argument_list|)
operator|==
literal|null
condition|)
block|{
name|cplan
operator|.
name|getPathToAliases
argument_list|()
operator|.
name|put
argument_list|(
name|taskTmpDir
argument_list|,
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|String
name|streamDesc
decl_stmt|;
if|if
condition|(
name|child
operator|.
name|getChildOperators
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|getClass
argument_list|()
operator|==
name|JoinOperator
operator|.
name|class
condition|)
name|streamDesc
operator|=
literal|"$INTNAME"
expr_stmt|;
else|else
name|streamDesc
operator|=
name|taskTmpDir
expr_stmt|;
name|cplan
operator|.
name|getPathToAliases
argument_list|()
operator|.
name|get
argument_list|(
name|taskTmpDir
argument_list|)
operator|.
name|add
argument_list|(
name|streamDesc
argument_list|)
expr_stmt|;
name|cplan
operator|.
name|getPathToPartitionInfo
argument_list|()
operator|.
name|put
argument_list|(
name|taskTmpDir
argument_list|,
operator|new
name|partitionDesc
argument_list|(
name|tt_desc
argument_list|,
literal|null
argument_list|)
argument_list|)
expr_stmt|;
name|cplan
operator|.
name|getAliasToWork
argument_list|()
operator|.
name|put
argument_list|(
name|streamDesc
argument_list|,
name|child
argument_list|)
expr_stmt|;
comment|// Make this task dependent on the current task
name|currTask
operator|.
name|addDependentTask
argument_list|(
name|ctask
argument_list|)
expr_stmt|;
comment|// TODO: Allocate work to remove the temporary files and make that
comment|// dependent on the cTask
if|if
condition|(
name|child
operator|.
name|getChildOperators
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|getClass
argument_list|()
operator|==
name|JoinOperator
operator|.
name|class
condition|)
name|cplan
operator|.
name|setNeedsTagging
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
block|}
name|child
operator|.
name|setChildOperators
argument_list|(
literal|null
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// For any other operator just recurse
name|genTaskPlan
argument_list|(
name|child
argument_list|,
name|currTask
argument_list|,
name|redTaskMap
argument_list|,
name|mvTask
argument_list|)
expr_stmt|;
block|}
block|}
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"nls"
argument_list|)
specifier|private
name|Phase1Ctx
name|initPhase1Ctx
parameter_list|()
block|{
name|Phase1Ctx
name|ctx_1
init|=
operator|new
name|Phase1Ctx
argument_list|()
decl_stmt|;
name|ctx_1
operator|.
name|nextNum
operator|=
literal|0
expr_stmt|;
name|ctx_1
operator|.
name|dest
operator|=
literal|"reduce"
expr_stmt|;
return|return
name|ctx_1
return|;
block|}
specifier|private
name|mapredWork
name|getMapRedWork
parameter_list|()
block|{
name|mapredWork
name|work
init|=
operator|new
name|mapredWork
argument_list|()
decl_stmt|;
name|work
operator|.
name|setPathToAliases
argument_list|(
operator|new
name|LinkedHashMap
argument_list|<
name|String
argument_list|,
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|>
argument_list|()
argument_list|)
expr_stmt|;
name|work
operator|.
name|setPathToPartitionInfo
argument_list|(
operator|new
name|LinkedHashMap
argument_list|<
name|String
argument_list|,
name|partitionDesc
argument_list|>
argument_list|()
argument_list|)
expr_stmt|;
name|work
operator|.
name|setAliasToWork
argument_list|(
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|Operator
argument_list|<
name|?
extends|extends
name|Serializable
argument_list|>
argument_list|>
argument_list|()
argument_list|)
expr_stmt|;
name|work
operator|.
name|setReducer
argument_list|(
literal|null
argument_list|)
expr_stmt|;
return|return
name|work
return|;
block|}
annotation|@
name|Override
annotation|@
name|SuppressWarnings
argument_list|(
literal|"nls"
argument_list|)
specifier|public
name|void
name|analyze
parameter_list|(
name|CommonTree
name|ast
parameter_list|,
name|Context
name|ctx
parameter_list|)
throws|throws
name|SemanticException
block|{
name|this
operator|.
name|ctx
operator|=
name|ctx
expr_stmt|;
name|reset
argument_list|()
expr_stmt|;
name|QB
name|qb
init|=
operator|new
name|QB
argument_list|(
literal|null
argument_list|,
literal|null
argument_list|,
literal|false
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Starting Semantic Analysis"
argument_list|)
expr_stmt|;
name|doPhase1
argument_list|(
name|ast
argument_list|,
name|qb
argument_list|,
name|initPhase1Ctx
argument_list|()
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Completed phase 1 of Semantic Analysis"
argument_list|)
expr_stmt|;
name|getMetaData
argument_list|(
name|qb
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Completed getting MetaData in Semantic Analysis"
argument_list|)
expr_stmt|;
name|genPlan
argument_list|(
name|qb
argument_list|)
expr_stmt|;
comment|// Do any partition pruning
name|genPartitionPruners
argument_list|(
name|qb
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Completed partition pruning"
argument_list|)
expr_stmt|;
comment|// Do any sample pruning
name|genSamplePruners
argument_list|(
name|qb
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Completed sample pruning"
argument_list|)
expr_stmt|;
comment|// TODO - this can be extended to create multiple
comment|// map reduce plans later
comment|// At this point we have the complete operator tree
comment|// from which we want to find the reduce operator
name|genMapRedTasks
argument_list|()
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Completed plan generation"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/**    * Get the exprNodeDesc    * @param name    * @param children    * @return    */
specifier|public
specifier|static
name|exprNodeDesc
name|getFuncExprNodeDesc
parameter_list|(
name|String
name|name
parameter_list|,
name|exprNodeDesc
modifier|...
name|children
parameter_list|)
block|{
return|return
name|getFuncExprNodeDesc
argument_list|(
name|name
argument_list|,
name|Arrays
operator|.
name|asList
argument_list|(
name|children
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * This function create an ExprNodeDesc for a UDF function given the children (arguments).    * It will insert implicit type conversion functions if necessary.     */
specifier|public
specifier|static
name|exprNodeDesc
name|getFuncExprNodeDesc
parameter_list|(
name|String
name|udfName
parameter_list|,
name|List
argument_list|<
name|exprNodeDesc
argument_list|>
name|children
parameter_list|)
block|{
comment|// Find the corresponding method
name|ArrayList
argument_list|<
name|Class
argument_list|<
name|?
argument_list|>
argument_list|>
name|argumentClasses
init|=
operator|new
name|ArrayList
argument_list|<
name|Class
argument_list|<
name|?
argument_list|>
argument_list|>
argument_list|(
name|children
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|children
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|exprNodeDesc
name|child
init|=
name|children
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
assert|assert
operator|(
name|child
operator|!=
literal|null
operator|)
assert|;
name|TypeInfo
name|childTypeInfo
init|=
name|child
operator|.
name|getTypeInfo
argument_list|()
decl_stmt|;
assert|assert
operator|(
name|childTypeInfo
operator|!=
literal|null
operator|)
assert|;
name|argumentClasses
operator|.
name|add
argument_list|(
name|childTypeInfo
operator|.
name|getPrimitiveClass
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|Method
name|udfMethod
init|=
name|UDFRegistry
operator|.
name|getUDFMethod
argument_list|(
name|udfName
argument_list|,
literal|false
argument_list|,
name|argumentClasses
argument_list|)
decl_stmt|;
if|if
condition|(
name|udfMethod
operator|==
literal|null
condition|)
return|return
literal|null
return|;
name|ArrayList
argument_list|<
name|exprNodeDesc
argument_list|>
name|ch
init|=
operator|new
name|ArrayList
argument_list|<
name|exprNodeDesc
argument_list|>
argument_list|()
decl_stmt|;
name|Class
argument_list|<
name|?
argument_list|>
index|[]
name|pTypes
init|=
name|udfMethod
operator|.
name|getParameterTypes
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|children
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|exprNodeDesc
name|desc
init|=
name|children
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|Class
argument_list|<
name|?
argument_list|>
name|pType
init|=
name|TypeInfo
operator|.
name|generalizePrimitive
argument_list|(
name|pTypes
index|[
name|i
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
name|desc
operator|instanceof
name|exprNodeNullDesc
condition|)
block|{
name|exprNodeConstantDesc
name|newCh
init|=
operator|new
name|exprNodeConstantDesc
argument_list|(
name|TypeInfo
operator|.
name|getPrimitiveTypeInfo
argument_list|(
name|pType
argument_list|)
argument_list|,
literal|null
argument_list|)
decl_stmt|;
name|ch
operator|.
name|add
argument_list|(
name|newCh
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|pType
operator|.
name|isAssignableFrom
argument_list|(
name|desc
operator|.
name|getTypeInfo
argument_list|()
operator|.
name|getPrimitiveClass
argument_list|()
argument_list|)
condition|)
block|{
comment|// no type conversion needed
name|ch
operator|.
name|add
argument_list|(
name|desc
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// must be implicit type conversion
name|Class
argument_list|<
name|?
argument_list|>
name|from
init|=
name|argumentClasses
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|Class
argument_list|<
name|?
argument_list|>
name|to
init|=
name|pType
decl_stmt|;
assert|assert
operator|(
name|UDFRegistry
operator|.
name|implicitConvertable
argument_list|(
name|from
argument_list|,
name|to
argument_list|)
operator|)
assert|;
name|Method
name|m
init|=
name|UDFRegistry
operator|.
name|getUDFMethod
argument_list|(
name|to
operator|.
name|getName
argument_list|()
argument_list|,
literal|true
argument_list|,
name|from
argument_list|)
decl_stmt|;
assert|assert
operator|(
name|m
operator|!=
literal|null
operator|)
assert|;
name|Class
name|c
init|=
name|UDFRegistry
operator|.
name|getUDFClass
argument_list|(
name|to
operator|.
name|getName
argument_list|()
argument_list|)
decl_stmt|;
assert|assert
operator|(
name|c
operator|!=
literal|null
operator|)
assert|;
comment|// get the conversion method
name|ArrayList
argument_list|<
name|exprNodeDesc
argument_list|>
name|conversionArg
init|=
operator|new
name|ArrayList
argument_list|<
name|exprNodeDesc
argument_list|>
argument_list|(
literal|1
argument_list|)
decl_stmt|;
name|conversionArg
operator|.
name|add
argument_list|(
name|desc
argument_list|)
expr_stmt|;
name|ch
operator|.
name|add
argument_list|(
operator|new
name|exprNodeFuncDesc
argument_list|(
name|TypeInfo
operator|.
name|getPrimitiveTypeInfo
argument_list|(
name|pType
argument_list|)
argument_list|,
name|c
argument_list|,
name|m
argument_list|,
name|conversionArg
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|exprNodeFuncDesc
name|desc
init|=
operator|new
name|exprNodeFuncDesc
argument_list|(
name|TypeInfo
operator|.
name|getPrimitiveTypeInfo
argument_list|(
name|TypeInfo
operator|.
name|generalizePrimitive
argument_list|(
name|udfMethod
operator|.
name|getReturnType
argument_list|()
argument_list|)
argument_list|)
argument_list|,
name|UDFRegistry
operator|.
name|getUDFClass
argument_list|(
name|udfName
argument_list|)
argument_list|,
name|udfMethod
argument_list|,
name|ch
argument_list|)
decl_stmt|;
return|return
name|desc
return|;
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"nls"
argument_list|)
specifier|private
name|exprNodeDesc
name|genExprNodeDesc
parameter_list|(
name|CommonTree
name|expr
parameter_list|,
name|String
name|alias
parameter_list|,
name|RowResolver
name|input
parameter_list|)
throws|throws
name|SemanticException
block|{
comment|//  We recursively create the exprNodeDesc.  Base cases:  when we encounter
comment|//  a column ref, we convert that into an exprNodeColumnDesc;  when we encounter
comment|//  a constant, we convert that into an exprNodeConstantDesc.  For others we just
comment|//  build the exprNodeFuncDesc with recursively built children.
name|exprNodeDesc
name|desc
init|=
literal|null
decl_stmt|;
comment|//  If the current subExpression is pre-calculated, as in Group-By etc.
name|ColumnInfo
name|colInfo
init|=
name|input
operator|.
name|get
argument_list|(
literal|""
argument_list|,
name|expr
operator|.
name|toStringTree
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|colInfo
operator|!=
literal|null
condition|)
block|{
name|desc
operator|=
operator|new
name|exprNodeColumnDesc
argument_list|(
name|colInfo
operator|.
name|getType
argument_list|()
argument_list|,
name|colInfo
operator|.
name|getInternalName
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|desc
return|;
block|}
comment|//  Is this a simple expr node (not a TOK_COLREF or a TOK_FUNCTION or an operator)?
name|desc
operator|=
name|genSimpleExprNodeDesc
argument_list|(
name|expr
argument_list|)
expr_stmt|;
if|if
condition|(
name|desc
operator|!=
literal|null
condition|)
block|{
return|return
name|desc
return|;
block|}
name|int
name|tokType
init|=
name|expr
operator|.
name|getType
argument_list|()
decl_stmt|;
switch|switch
condition|(
name|tokType
condition|)
block|{
case|case
name|HiveParser
operator|.
name|TOK_COLREF
case|:
block|{
assert|assert
operator|(
name|expr
operator|.
name|getChildCount
argument_list|()
operator|==
literal|2
operator|)
assert|;
name|String
name|tabAlias
init|=
name|SemanticAnalyzer
operator|.
name|getTableName
argument_list|(
name|expr
argument_list|)
decl_stmt|;
name|String
name|colName
init|=
name|SemanticAnalyzer
operator|.
name|getSerDeFieldExpression
argument_list|(
name|expr
argument_list|)
decl_stmt|;
if|if
condition|(
name|tabAlias
operator|==
literal|null
operator|||
name|colName
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|INVALID_XPATH
operator|.
name|getMsg
argument_list|(
name|expr
argument_list|)
argument_list|)
throw|;
block|}
name|colInfo
operator|=
name|input
operator|.
name|get
argument_list|(
name|tabAlias
argument_list|,
name|colName
argument_list|)
expr_stmt|;
if|if
condition|(
name|colInfo
operator|==
literal|null
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"input: "
operator|+
name|input
operator|.
name|toString
argument_list|()
operator|+
literal|" expr: "
operator|+
name|expr
operator|.
name|toStringTree
argument_list|()
operator|+
literal|" e: "
operator|+
name|input
operator|.
name|getIsExprResolver
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|//    TODO: Hack it up for now: Later we have to pass the QB in order to check for the
comment|//    table alias instead of relying on input.hasTableAlias
if|if
condition|(
name|colInfo
operator|==
literal|null
operator|&&
name|input
operator|.
name|getIsExprResolver
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|NON_KEY_EXPR_IN_GROUPBY
operator|.
name|getMsg
argument_list|(
name|expr
argument_list|)
argument_list|)
throw|;
block|}
elseif|else
if|if
condition|(
operator|!
name|input
operator|.
name|hasTableAlias
argument_list|(
name|expr
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getText
argument_list|()
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|INVALID_TABLE_ALIAS
operator|.
name|getMsg
argument_list|(
operator|(
name|CommonTree
operator|)
name|expr
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
argument_list|)
argument_list|)
throw|;
block|}
elseif|else
if|if
condition|(
name|colInfo
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|INVALID_COLUMN
operator|.
name|getMsg
argument_list|(
operator|(
name|CommonTree
operator|)
name|expr
operator|.
name|getChild
argument_list|(
literal|1
argument_list|)
argument_list|)
argument_list|)
throw|;
block|}
name|desc
operator|=
operator|new
name|exprNodeColumnDesc
argument_list|(
name|colInfo
operator|.
name|getType
argument_list|()
argument_list|,
name|colInfo
operator|.
name|getInternalName
argument_list|()
argument_list|)
expr_stmt|;
break|break;
block|}
default|default:
block|{
name|boolean
name|isFunction
init|=
operator|(
name|expr
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_FUNCTION
operator|)
decl_stmt|;
comment|// Create all children
name|int
name|childrenBegin
init|=
operator|(
name|isFunction
condition|?
literal|1
else|:
literal|0
operator|)
decl_stmt|;
name|ArrayList
argument_list|<
name|exprNodeDesc
argument_list|>
name|children
init|=
operator|new
name|ArrayList
argument_list|<
name|exprNodeDesc
argument_list|>
argument_list|(
name|expr
operator|.
name|getChildCount
argument_list|()
operator|-
name|childrenBegin
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|ci
init|=
name|childrenBegin
init|;
name|ci
operator|<
name|expr
operator|.
name|getChildCount
argument_list|()
condition|;
name|ci
operator|++
control|)
block|{
name|children
operator|.
name|add
argument_list|(
name|genExprNodeDesc
argument_list|(
operator|(
name|CommonTree
operator|)
name|expr
operator|.
name|getChild
argument_list|(
name|ci
argument_list|)
argument_list|,
name|alias
argument_list|,
name|input
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// Create function desc
name|desc
operator|=
name|getXpathOrFuncExprNodeDesc
argument_list|(
name|expr
argument_list|,
name|isFunction
argument_list|,
name|children
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
return|return
name|desc
return|;
block|}
specifier|static
name|HashMap
argument_list|<
name|Integer
argument_list|,
name|String
argument_list|>
name|specialFunctionTextHashMap
decl_stmt|;
specifier|static
name|HashMap
argument_list|<
name|Integer
argument_list|,
name|String
argument_list|>
name|conversionFunctionTextHashMap
decl_stmt|;
static|static
block|{
name|specialFunctionTextHashMap
operator|=
operator|new
name|HashMap
argument_list|<
name|Integer
argument_list|,
name|String
argument_list|>
argument_list|()
expr_stmt|;
name|specialFunctionTextHashMap
operator|.
name|put
argument_list|(
name|HiveParser
operator|.
name|TOK_ISNULL
argument_list|,
literal|"isnull"
argument_list|)
expr_stmt|;
name|specialFunctionTextHashMap
operator|.
name|put
argument_list|(
name|HiveParser
operator|.
name|TOK_ISNOTNULL
argument_list|,
literal|"isnotnull"
argument_list|)
expr_stmt|;
name|conversionFunctionTextHashMap
operator|=
operator|new
name|HashMap
argument_list|<
name|Integer
argument_list|,
name|String
argument_list|>
argument_list|()
expr_stmt|;
name|conversionFunctionTextHashMap
operator|.
name|put
argument_list|(
name|HiveParser
operator|.
name|TOK_BOOLEAN
argument_list|,
name|Boolean
operator|.
name|class
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
name|conversionFunctionTextHashMap
operator|.
name|put
argument_list|(
name|HiveParser
operator|.
name|TOK_TINYINT
argument_list|,
name|Byte
operator|.
name|class
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
name|conversionFunctionTextHashMap
operator|.
name|put
argument_list|(
name|HiveParser
operator|.
name|TOK_INT
argument_list|,
name|Integer
operator|.
name|class
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
name|conversionFunctionTextHashMap
operator|.
name|put
argument_list|(
name|HiveParser
operator|.
name|TOK_BIGINT
argument_list|,
name|Long
operator|.
name|class
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
name|conversionFunctionTextHashMap
operator|.
name|put
argument_list|(
name|HiveParser
operator|.
name|TOK_FLOAT
argument_list|,
name|Float
operator|.
name|class
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
name|conversionFunctionTextHashMap
operator|.
name|put
argument_list|(
name|HiveParser
operator|.
name|TOK_DOUBLE
argument_list|,
name|Double
operator|.
name|class
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
name|conversionFunctionTextHashMap
operator|.
name|put
argument_list|(
name|HiveParser
operator|.
name|TOK_STRING
argument_list|,
name|String
operator|.
name|class
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
name|conversionFunctionTextHashMap
operator|.
name|put
argument_list|(
name|HiveParser
operator|.
name|TOK_DATE
argument_list|,
name|java
operator|.
name|sql
operator|.
name|Date
operator|.
name|class
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
block|}
specifier|public
specifier|static
name|boolean
name|isRedundantConversionFunction
parameter_list|(
name|CommonTree
name|expr
parameter_list|,
name|boolean
name|isFunction
parameter_list|,
name|ArrayList
argument_list|<
name|exprNodeDesc
argument_list|>
name|children
parameter_list|)
block|{
if|if
condition|(
operator|!
name|isFunction
condition|)
return|return
literal|false
return|;
comment|// children is always one less than the expr.getChildCount(), since the latter contains function name.
assert|assert
operator|(
name|children
operator|.
name|size
argument_list|()
operator|==
name|expr
operator|.
name|getChildCount
argument_list|()
operator|-
literal|1
operator|)
assert|;
comment|// conversion functions take a single parameter
if|if
condition|(
name|children
operator|.
name|size
argument_list|()
operator|!=
literal|1
condition|)
return|return
literal|false
return|;
name|String
name|funcText
init|=
name|conversionFunctionTextHashMap
operator|.
name|get
argument_list|(
operator|(
operator|(
name|CommonTree
operator|)
name|expr
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|)
operator|.
name|getType
argument_list|()
argument_list|)
decl_stmt|;
comment|// not a conversion function
if|if
condition|(
name|funcText
operator|==
literal|null
condition|)
return|return
literal|false
return|;
comment|// return true when the child type and the conversion target type is the same
return|return
name|children
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|getTypeInfo
argument_list|()
operator|.
name|getPrimitiveClass
argument_list|()
operator|.
name|getName
argument_list|()
operator|.
name|equals
argument_list|(
name|funcText
argument_list|)
return|;
block|}
specifier|public
specifier|static
name|String
name|getFunctionText
parameter_list|(
name|CommonTree
name|expr
parameter_list|,
name|boolean
name|isFunction
parameter_list|)
block|{
name|String
name|funcText
decl_stmt|;
if|if
condition|(
operator|!
name|isFunction
condition|)
block|{
comment|// For operator, the function name is the operator text
name|funcText
operator|=
name|expr
operator|.
name|getText
argument_list|()
expr_stmt|;
block|}
else|else
block|{
comment|// For TOK_FUNCTION, the function name is stored in the first child.
assert|assert
operator|(
name|expr
operator|.
name|getChildCount
argument_list|()
operator|>=
literal|1
operator|)
assert|;
name|funcText
operator|=
name|specialFunctionTextHashMap
operator|.
name|get
argument_list|(
operator|(
operator|(
name|CommonTree
operator|)
name|expr
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|)
operator|.
name|getType
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|funcText
operator|==
literal|null
condition|)
block|{
name|funcText
operator|=
name|conversionFunctionTextHashMap
operator|.
name|get
argument_list|(
operator|(
operator|(
name|CommonTree
operator|)
name|expr
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|)
operator|.
name|getType
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|funcText
operator|==
literal|null
condition|)
block|{
name|funcText
operator|=
operator|(
operator|(
name|CommonTree
operator|)
name|expr
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|)
operator|.
name|getText
argument_list|()
expr_stmt|;
block|}
block|}
return|return
name|funcText
return|;
block|}
specifier|static
name|exprNodeDesc
name|getXpathOrFuncExprNodeDesc
parameter_list|(
name|CommonTree
name|expr
parameter_list|,
name|boolean
name|isFunction
parameter_list|,
name|ArrayList
argument_list|<
name|exprNodeDesc
argument_list|>
name|children
parameter_list|)
throws|throws
name|SemanticException
block|{
comment|// return the child directly if the conversion is redundant.
if|if
condition|(
name|isRedundantConversionFunction
argument_list|(
name|expr
argument_list|,
name|isFunction
argument_list|,
name|children
argument_list|)
condition|)
block|{
assert|assert
operator|(
name|children
operator|.
name|size
argument_list|()
operator|==
literal|1
operator|)
assert|;
return|return
name|children
operator|.
name|get
argument_list|(
literal|0
argument_list|)
return|;
block|}
name|String
name|funcText
init|=
name|getFunctionText
argument_list|(
name|expr
argument_list|,
name|isFunction
argument_list|)
decl_stmt|;
name|exprNodeDesc
name|desc
decl_stmt|;
if|if
condition|(
name|funcText
operator|.
name|equals
argument_list|(
literal|"."
argument_list|)
condition|)
block|{
comment|// "." :  FIELD Expression
assert|assert
operator|(
name|children
operator|.
name|size
argument_list|()
operator|==
literal|2
operator|)
assert|;
comment|// Only allow constant field name for now
assert|assert
operator|(
name|children
operator|.
name|get
argument_list|(
literal|1
argument_list|)
operator|instanceof
name|exprNodeConstantDesc
operator|)
assert|;
name|exprNodeDesc
name|object
init|=
name|children
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|exprNodeConstantDesc
name|fieldName
init|=
operator|(
name|exprNodeConstantDesc
operator|)
name|children
operator|.
name|get
argument_list|(
literal|1
argument_list|)
decl_stmt|;
assert|assert
operator|(
name|fieldName
operator|.
name|getValue
argument_list|()
operator|instanceof
name|String
operator|)
assert|;
comment|// Calculate TypeInfo
name|String
name|fieldNameString
init|=
operator|(
name|String
operator|)
name|fieldName
operator|.
name|getValue
argument_list|()
decl_stmt|;
name|TypeInfo
name|t
init|=
name|object
operator|.
name|getTypeInfo
argument_list|()
operator|.
name|getFieldType
argument_list|(
name|fieldNameString
argument_list|)
decl_stmt|;
name|desc
operator|=
operator|new
name|exprNodeFieldDesc
argument_list|(
name|t
argument_list|,
name|children
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|,
name|fieldNameString
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|funcText
operator|.
name|equals
argument_list|(
literal|"["
argument_list|)
condition|)
block|{
comment|// "[]" : LSQUARE/INDEX Expression
assert|assert
operator|(
name|children
operator|.
name|size
argument_list|()
operator|==
literal|2
operator|)
assert|;
comment|// Only allow constant integer index for now
if|if
condition|(
operator|!
operator|(
name|children
operator|.
name|get
argument_list|(
literal|1
argument_list|)
operator|instanceof
name|exprNodeConstantDesc
operator|)
operator|||
operator|!
operator|(
operator|(
operator|(
name|exprNodeConstantDesc
operator|)
name|children
operator|.
name|get
argument_list|(
literal|1
argument_list|)
operator|)
operator|.
name|getValue
argument_list|()
operator|instanceof
name|Integer
operator|)
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|INVALID_ARRAYINDEX_CONSTANT
operator|.
name|getMsg
argument_list|(
name|expr
argument_list|)
argument_list|)
throw|;
block|}
comment|// Calculate TypeInfo
name|TypeInfo
name|t
init|=
name|children
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|getTypeInfo
argument_list|()
operator|.
name|getListElementType
argument_list|()
decl_stmt|;
name|desc
operator|=
operator|new
name|exprNodeIndexDesc
argument_list|(
name|t
argument_list|,
name|children
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|,
name|children
operator|.
name|get
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// other operators or functions
name|Class
argument_list|<
name|?
extends|extends
name|UDF
argument_list|>
name|udf
init|=
name|UDFRegistry
operator|.
name|getUDFClass
argument_list|(
name|funcText
argument_list|)
decl_stmt|;
if|if
condition|(
name|udf
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|INVALID_FUNCTION
operator|.
name|getMsg
argument_list|(
operator|(
name|CommonTree
operator|)
name|expr
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
argument_list|)
argument_list|)
throw|;
block|}
name|desc
operator|=
name|getFuncExprNodeDesc
argument_list|(
name|funcText
argument_list|,
name|children
argument_list|)
expr_stmt|;
if|if
condition|(
name|desc
operator|==
literal|null
condition|)
block|{
name|ArrayList
argument_list|<
name|Class
argument_list|<
name|?
argument_list|>
argument_list|>
name|argumentClasses
init|=
operator|new
name|ArrayList
argument_list|<
name|Class
argument_list|<
name|?
argument_list|>
argument_list|>
argument_list|(
name|children
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|children
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|argumentClasses
operator|.
name|add
argument_list|(
name|children
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|getTypeInfo
argument_list|()
operator|.
name|getPrimitiveClass
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|isFunction
condition|)
block|{
name|String
name|reason
init|=
literal|"Looking for UDF \""
operator|+
name|expr
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getText
argument_list|()
operator|+
literal|"\" with parameters "
operator|+
name|argumentClasses
decl_stmt|;
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|INVALID_FUNCTION_SIGNATURE
operator|.
name|getMsg
argument_list|(
operator|(
name|CommonTree
operator|)
name|expr
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
argument_list|,
name|reason
argument_list|)
argument_list|)
throw|;
block|}
else|else
block|{
name|String
name|reason
init|=
literal|"Looking for Operator \""
operator|+
name|expr
operator|.
name|getText
argument_list|()
operator|+
literal|"\" with parameters "
operator|+
name|argumentClasses
decl_stmt|;
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|INVALID_OPERATOR_SIGNATURE
operator|.
name|getMsg
argument_list|(
name|expr
argument_list|,
name|reason
argument_list|)
argument_list|)
throw|;
block|}
block|}
block|}
return|return
name|desc
return|;
block|}
specifier|static
name|exprNodeDesc
name|genSimpleExprNodeDesc
parameter_list|(
name|CommonTree
name|expr
parameter_list|)
throws|throws
name|SemanticException
block|{
name|exprNodeDesc
name|desc
init|=
literal|null
decl_stmt|;
switch|switch
condition|(
name|expr
operator|.
name|getType
argument_list|()
condition|)
block|{
case|case
name|HiveParser
operator|.
name|TOK_NULL
case|:
name|desc
operator|=
operator|new
name|exprNodeNullDesc
argument_list|()
expr_stmt|;
break|break;
case|case
name|HiveParser
operator|.
name|Identifier
case|:
comment|// This is the case for an XPATH element (like "c" in "a.b.c.d")
name|desc
operator|=
operator|new
name|exprNodeConstantDesc
argument_list|(
name|TypeInfo
operator|.
name|getPrimitiveTypeInfo
argument_list|(
name|String
operator|.
name|class
argument_list|)
argument_list|,
name|expr
operator|.
name|getText
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|HiveParser
operator|.
name|Number
case|:
name|Number
name|v
init|=
literal|null
decl_stmt|;
try|try
block|{
name|v
operator|=
name|Double
operator|.
name|valueOf
argument_list|(
name|expr
operator|.
name|getText
argument_list|()
argument_list|)
expr_stmt|;
name|v
operator|=
name|Long
operator|.
name|valueOf
argument_list|(
name|expr
operator|.
name|getText
argument_list|()
argument_list|)
expr_stmt|;
name|v
operator|=
name|Integer
operator|.
name|valueOf
argument_list|(
name|expr
operator|.
name|getText
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|NumberFormatException
name|e
parameter_list|)
block|{
comment|// do nothing here, we will throw an exception in the following block
block|}
if|if
condition|(
name|v
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|INVALID_NUMERICAL_CONSTANT
operator|.
name|getMsg
argument_list|(
name|expr
argument_list|)
argument_list|)
throw|;
block|}
name|desc
operator|=
operator|new
name|exprNodeConstantDesc
argument_list|(
name|v
argument_list|)
expr_stmt|;
break|break;
case|case
name|HiveParser
operator|.
name|StringLiteral
case|:
name|desc
operator|=
operator|new
name|exprNodeConstantDesc
argument_list|(
name|String
operator|.
name|class
argument_list|,
name|BaseSemanticAnalyzer
operator|.
name|unescapeSQLString
argument_list|(
name|expr
operator|.
name|getText
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|HiveParser
operator|.
name|KW_TRUE
case|:
name|desc
operator|=
operator|new
name|exprNodeConstantDesc
argument_list|(
name|Boolean
operator|.
name|class
argument_list|,
name|Boolean
operator|.
name|TRUE
argument_list|)
expr_stmt|;
break|break;
case|case
name|HiveParser
operator|.
name|KW_FALSE
case|:
name|desc
operator|=
operator|new
name|exprNodeConstantDesc
argument_list|(
name|Boolean
operator|.
name|class
argument_list|,
name|Boolean
operator|.
name|FALSE
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
name|desc
return|;
block|}
block|}
end_class

end_unit

