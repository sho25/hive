begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|parse
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|Serializable
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Formatter
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|LinkedHashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|LinkedHashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|TreeSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Vector
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|regex
operator|.
name|Pattern
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|regex
operator|.
name|PatternSyntaxException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|ClassNotFoundException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|lang
operator|.
name|StringUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|Path
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|common
operator|.
name|FileUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|conf
operator|.
name|HiveConf
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|metastore
operator|.
name|MetaStoreUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|metastore
operator|.
name|api
operator|.
name|FieldSchema
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|ColumnInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|ConditionalTask
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|ExecDriver
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|FunctionRegistry
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|GroupByOperator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|JoinOperator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|MapJoinOperator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|MapRedTask
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|Operator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|OperatorFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|RecordReader
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|ReduceSinkOperator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|RowSchema
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|TableScanOperator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|Task
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|TaskFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|UnionOperator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|UDF
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|Utilities
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|io
operator|.
name|HiveOutputFormat
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|io
operator|.
name|IgnoreKeyTextOutputFormat
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|lib
operator|.
name|DefaultGraphWalker
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|lib
operator|.
name|DefaultRuleDispatcher
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|lib
operator|.
name|Dispatcher
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|lib
operator|.
name|GraphWalker
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|lib
operator|.
name|Node
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|lib
operator|.
name|NodeProcessor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|lib
operator|.
name|Rule
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|lib
operator|.
name|RuleRegExp
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|metadata
operator|.
name|HiveException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|metadata
operator|.
name|InvalidTableException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|metadata
operator|.
name|Partition
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|metadata
operator|.
name|Table
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|optimizer
operator|.
name|MapJoinFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|optimizer
operator|.
name|GenMRFileSink1
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|optimizer
operator|.
name|GenMapRedUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|optimizer
operator|.
name|GenMROperator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|optimizer
operator|.
name|GenMRProcContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|optimizer
operator|.
name|GenMRRedSink1
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|optimizer
operator|.
name|GenMRRedSink2
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|optimizer
operator|.
name|GenMRTableScan1
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|optimizer
operator|.
name|GenMRUnion1
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|optimizer
operator|.
name|Optimizer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|optimizer
operator|.
name|GenMRProcContext
operator|.
name|GenMapRedCtx
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|optimizer
operator|.
name|unionproc
operator|.
name|UnionProcContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|optimizer
operator|.
name|GenMRRedSink3
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|optimizer
operator|.
name|GenMRRedSink4
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|PlanUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|aggregationDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|exprNodeColumnDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|exprNodeConstantDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|exprNodeDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|exprNodeGenericFuncDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|exprNodeNullDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|extractDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|fetchWork
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|fileSinkDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|filterDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|forwardDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|groupByDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|joinDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|limitDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|loadFileDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|loadTableDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|mapredWork
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|moveWork
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|partitionDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|reduceSinkDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|scriptDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|selectDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|tableDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|tableScanDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|unionDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|ppd
operator|.
name|PredicatePushDown
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|session
operator|.
name|SessionState
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|udf
operator|.
name|generic
operator|.
name|GenericUDAFEvaluator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|udf
operator|.
name|generic
operator|.
name|GenericUDFHash
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|udf
operator|.
name|generic
operator|.
name|GenericUDAFEvaluator
operator|.
name|Mode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|Deserializer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|MetadataTypedColumnsetSerDe
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|SerDeException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|lazy
operator|.
name|LazySimpleSerDe
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|objectinspector
operator|.
name|ObjectInspector
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|objectinspector
operator|.
name|StructField
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|objectinspector
operator|.
name|StructObjectInspector
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|objectinspector
operator|.
name|ObjectInspector
operator|.
name|Category
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|typeinfo
operator|.
name|TypeInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|typeinfo
operator|.
name|TypeInfoFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|typeinfo
operator|.
name|TypeInfoUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapred
operator|.
name|InputFormat
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapred
operator|.
name|TextInputFormat
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde
operator|.
name|Constants
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|common
operator|.
name|JavaUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|TextRecordReader
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|TypedBytesRecordReader
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|hooks
operator|.
name|ReadEntity
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|hooks
operator|.
name|WriteEntity
import|;
end_import

begin_comment
comment|/**  * Implementation of the semantic analyzer  */
end_comment

begin_class
specifier|public
class|class
name|SemanticAnalyzer
extends|extends
name|BaseSemanticAnalyzer
block|{
specifier|private
name|HashMap
argument_list|<
name|String
argument_list|,
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|parse
operator|.
name|ASTPartitionPruner
argument_list|>
name|aliasToPruner
decl_stmt|;
specifier|private
name|HashMap
argument_list|<
name|TableScanOperator
argument_list|,
name|exprNodeDesc
argument_list|>
name|opToPartPruner
decl_stmt|;
specifier|private
name|HashMap
argument_list|<
name|String
argument_list|,
name|SamplePruner
argument_list|>
name|aliasToSamplePruner
decl_stmt|;
specifier|private
name|HashMap
argument_list|<
name|String
argument_list|,
name|Operator
argument_list|<
name|?
extends|extends
name|Serializable
argument_list|>
argument_list|>
name|topOps
decl_stmt|;
specifier|private
name|HashMap
argument_list|<
name|String
argument_list|,
name|Operator
argument_list|<
name|?
extends|extends
name|Serializable
argument_list|>
argument_list|>
name|topSelOps
decl_stmt|;
specifier|private
name|LinkedHashMap
argument_list|<
name|Operator
argument_list|<
name|?
extends|extends
name|Serializable
argument_list|>
argument_list|,
name|OpParseContext
argument_list|>
name|opParseCtx
decl_stmt|;
specifier|private
name|List
argument_list|<
name|loadTableDesc
argument_list|>
name|loadTableWork
decl_stmt|;
specifier|private
name|List
argument_list|<
name|loadFileDesc
argument_list|>
name|loadFileWork
decl_stmt|;
specifier|private
name|Map
argument_list|<
name|JoinOperator
argument_list|,
name|QBJoinTree
argument_list|>
name|joinContext
decl_stmt|;
specifier|private
name|HashMap
argument_list|<
name|TableScanOperator
argument_list|,
name|Table
argument_list|>
name|topToTable
decl_stmt|;
specifier|private
name|QB
name|qb
decl_stmt|;
specifier|private
name|ASTNode
name|ast
decl_stmt|;
specifier|private
name|int
name|destTableId
decl_stmt|;
specifier|private
name|UnionProcContext
name|uCtx
decl_stmt|;
name|List
argument_list|<
name|MapJoinOperator
argument_list|>
name|listMapJoinOpsNoReducer
decl_stmt|;
comment|/**    * ReadEntitites that are passed to the hooks.    */
specifier|private
name|Set
argument_list|<
name|ReadEntity
argument_list|>
name|inputs
decl_stmt|;
comment|/**    * List of WriteEntities that are passed to the hooks.    */
specifier|private
name|Set
argument_list|<
name|WriteEntity
argument_list|>
name|outputs
decl_stmt|;
specifier|private
specifier|static
class|class
name|Phase1Ctx
block|{
name|String
name|dest
decl_stmt|;
name|int
name|nextNum
decl_stmt|;
block|}
specifier|public
name|SemanticAnalyzer
parameter_list|(
name|HiveConf
name|conf
parameter_list|)
throws|throws
name|SemanticException
block|{
name|super
argument_list|(
name|conf
argument_list|)
expr_stmt|;
name|this
operator|.
name|aliasToPruner
operator|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|parse
operator|.
name|ASTPartitionPruner
argument_list|>
argument_list|()
expr_stmt|;
name|this
operator|.
name|opToPartPruner
operator|=
operator|new
name|HashMap
argument_list|<
name|TableScanOperator
argument_list|,
name|exprNodeDesc
argument_list|>
argument_list|()
expr_stmt|;
name|this
operator|.
name|aliasToSamplePruner
operator|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|SamplePruner
argument_list|>
argument_list|()
expr_stmt|;
name|this
operator|.
name|topOps
operator|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|Operator
argument_list|<
name|?
extends|extends
name|Serializable
argument_list|>
argument_list|>
argument_list|()
expr_stmt|;
name|this
operator|.
name|topSelOps
operator|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|Operator
argument_list|<
name|?
extends|extends
name|Serializable
argument_list|>
argument_list|>
argument_list|()
expr_stmt|;
name|this
operator|.
name|loadTableWork
operator|=
operator|new
name|ArrayList
argument_list|<
name|loadTableDesc
argument_list|>
argument_list|()
expr_stmt|;
name|this
operator|.
name|loadFileWork
operator|=
operator|new
name|ArrayList
argument_list|<
name|loadFileDesc
argument_list|>
argument_list|()
expr_stmt|;
name|opParseCtx
operator|=
operator|new
name|LinkedHashMap
argument_list|<
name|Operator
argument_list|<
name|?
extends|extends
name|Serializable
argument_list|>
argument_list|,
name|OpParseContext
argument_list|>
argument_list|()
expr_stmt|;
name|joinContext
operator|=
operator|new
name|HashMap
argument_list|<
name|JoinOperator
argument_list|,
name|QBJoinTree
argument_list|>
argument_list|()
expr_stmt|;
name|topToTable
operator|=
operator|new
name|HashMap
argument_list|<
name|TableScanOperator
argument_list|,
name|Table
argument_list|>
argument_list|()
expr_stmt|;
name|this
operator|.
name|destTableId
operator|=
literal|1
expr_stmt|;
name|this
operator|.
name|uCtx
operator|=
literal|null
expr_stmt|;
name|this
operator|.
name|listMapJoinOpsNoReducer
operator|=
operator|new
name|ArrayList
argument_list|<
name|MapJoinOperator
argument_list|>
argument_list|()
expr_stmt|;
name|inputs
operator|=
operator|new
name|LinkedHashSet
argument_list|<
name|ReadEntity
argument_list|>
argument_list|()
expr_stmt|;
name|outputs
operator|=
operator|new
name|LinkedHashSet
argument_list|<
name|WriteEntity
argument_list|>
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Override
specifier|protected
name|void
name|reset
parameter_list|()
block|{
name|super
operator|.
name|reset
argument_list|()
expr_stmt|;
name|this
operator|.
name|aliasToPruner
operator|.
name|clear
argument_list|()
expr_stmt|;
name|this
operator|.
name|loadTableWork
operator|.
name|clear
argument_list|()
expr_stmt|;
name|this
operator|.
name|loadFileWork
operator|.
name|clear
argument_list|()
expr_stmt|;
name|this
operator|.
name|topOps
operator|.
name|clear
argument_list|()
expr_stmt|;
name|this
operator|.
name|topSelOps
operator|.
name|clear
argument_list|()
expr_stmt|;
name|this
operator|.
name|destTableId
operator|=
literal|1
expr_stmt|;
name|this
operator|.
name|idToTableNameMap
operator|.
name|clear
argument_list|()
expr_stmt|;
name|qb
operator|=
literal|null
expr_stmt|;
name|ast
operator|=
literal|null
expr_stmt|;
name|uCtx
operator|=
literal|null
expr_stmt|;
name|this
operator|.
name|aliasToSamplePruner
operator|.
name|clear
argument_list|()
expr_stmt|;
name|this
operator|.
name|joinContext
operator|.
name|clear
argument_list|()
expr_stmt|;
name|this
operator|.
name|opParseCtx
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
specifier|public
name|void
name|init
parameter_list|(
name|ParseContext
name|pctx
parameter_list|)
block|{
name|aliasToPruner
operator|=
name|pctx
operator|.
name|getAliasToPruner
argument_list|()
expr_stmt|;
name|opToPartPruner
operator|=
name|pctx
operator|.
name|getOpToPartPruner
argument_list|()
expr_stmt|;
name|aliasToSamplePruner
operator|=
name|pctx
operator|.
name|getAliasToSamplePruner
argument_list|()
expr_stmt|;
name|topOps
operator|=
name|pctx
operator|.
name|getTopOps
argument_list|()
expr_stmt|;
name|topSelOps
operator|=
name|pctx
operator|.
name|getTopSelOps
argument_list|()
expr_stmt|;
name|opParseCtx
operator|=
name|pctx
operator|.
name|getOpParseCtx
argument_list|()
expr_stmt|;
name|loadTableWork
operator|=
name|pctx
operator|.
name|getLoadTableWork
argument_list|()
expr_stmt|;
name|loadFileWork
operator|=
name|pctx
operator|.
name|getLoadFileWork
argument_list|()
expr_stmt|;
name|joinContext
operator|=
name|pctx
operator|.
name|getJoinContext
argument_list|()
expr_stmt|;
name|ctx
operator|=
name|pctx
operator|.
name|getContext
argument_list|()
expr_stmt|;
name|destTableId
operator|=
name|pctx
operator|.
name|getDestTableId
argument_list|()
expr_stmt|;
name|idToTableNameMap
operator|=
name|pctx
operator|.
name|getIdToTableNameMap
argument_list|()
expr_stmt|;
name|this
operator|.
name|uCtx
operator|=
name|pctx
operator|.
name|getUCtx
argument_list|()
expr_stmt|;
name|this
operator|.
name|listMapJoinOpsNoReducer
operator|=
name|pctx
operator|.
name|getListMapJoinOpsNoReducer
argument_list|()
expr_stmt|;
name|qb
operator|=
name|pctx
operator|.
name|getQB
argument_list|()
expr_stmt|;
block|}
specifier|public
name|ParseContext
name|getParseContext
parameter_list|()
block|{
return|return
operator|new
name|ParseContext
argument_list|(
name|conf
argument_list|,
name|qb
argument_list|,
name|ast
argument_list|,
name|aliasToPruner
argument_list|,
name|opToPartPruner
argument_list|,
name|aliasToSamplePruner
argument_list|,
name|topOps
argument_list|,
name|topSelOps
argument_list|,
name|opParseCtx
argument_list|,
name|joinContext
argument_list|,
name|topToTable
argument_list|,
name|loadTableWork
argument_list|,
name|loadFileWork
argument_list|,
name|ctx
argument_list|,
name|idToTableNameMap
argument_list|,
name|destTableId
argument_list|,
name|uCtx
argument_list|,
name|listMapJoinOpsNoReducer
argument_list|)
return|;
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"nls"
argument_list|)
specifier|public
name|void
name|doPhase1QBExpr
parameter_list|(
name|ASTNode
name|ast
parameter_list|,
name|QBExpr
name|qbexpr
parameter_list|,
name|String
name|id
parameter_list|,
name|String
name|alias
parameter_list|)
throws|throws
name|SemanticException
block|{
assert|assert
operator|(
name|ast
operator|.
name|getToken
argument_list|()
operator|!=
literal|null
operator|)
assert|;
switch|switch
condition|(
name|ast
operator|.
name|getToken
argument_list|()
operator|.
name|getType
argument_list|()
condition|)
block|{
case|case
name|HiveParser
operator|.
name|TOK_QUERY
case|:
block|{
name|QB
name|qb
init|=
operator|new
name|QB
argument_list|(
name|id
argument_list|,
name|alias
argument_list|,
literal|true
argument_list|)
decl_stmt|;
name|doPhase1
argument_list|(
name|ast
argument_list|,
name|qb
argument_list|,
name|initPhase1Ctx
argument_list|()
argument_list|)
expr_stmt|;
name|qbexpr
operator|.
name|setOpcode
argument_list|(
name|QBExpr
operator|.
name|Opcode
operator|.
name|NULLOP
argument_list|)
expr_stmt|;
name|qbexpr
operator|.
name|setQB
argument_list|(
name|qb
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|HiveParser
operator|.
name|TOK_UNION
case|:
block|{
name|qbexpr
operator|.
name|setOpcode
argument_list|(
name|QBExpr
operator|.
name|Opcode
operator|.
name|UNION
argument_list|)
expr_stmt|;
comment|// query 1
assert|assert
operator|(
name|ast
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|!=
literal|null
operator|)
assert|;
name|QBExpr
name|qbexpr1
init|=
operator|new
name|QBExpr
argument_list|(
name|alias
operator|+
literal|"-subquery1"
argument_list|)
decl_stmt|;
name|doPhase1QBExpr
argument_list|(
operator|(
name|ASTNode
operator|)
name|ast
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
argument_list|,
name|qbexpr1
argument_list|,
name|id
operator|+
literal|"-subquery1"
argument_list|,
name|alias
operator|+
literal|"-subquery1"
argument_list|)
expr_stmt|;
name|qbexpr
operator|.
name|setQBExpr1
argument_list|(
name|qbexpr1
argument_list|)
expr_stmt|;
comment|// query 2
assert|assert
operator|(
name|ast
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|!=
literal|null
operator|)
assert|;
name|QBExpr
name|qbexpr2
init|=
operator|new
name|QBExpr
argument_list|(
name|alias
operator|+
literal|"-subquery2"
argument_list|)
decl_stmt|;
name|doPhase1QBExpr
argument_list|(
operator|(
name|ASTNode
operator|)
name|ast
operator|.
name|getChild
argument_list|(
literal|1
argument_list|)
argument_list|,
name|qbexpr2
argument_list|,
name|id
operator|+
literal|"-subquery2"
argument_list|,
name|alias
operator|+
literal|"-subquery2"
argument_list|)
expr_stmt|;
name|qbexpr
operator|.
name|setQBExpr2
argument_list|(
name|qbexpr2
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
block|}
specifier|private
name|LinkedHashMap
argument_list|<
name|String
argument_list|,
name|ASTNode
argument_list|>
name|doPhase1GetAggregationsFromSelect
parameter_list|(
name|ASTNode
name|selExpr
parameter_list|)
block|{
comment|// Iterate over the selects search for aggregation Trees.
comment|// Use String as keys to eliminate duplicate trees.
name|LinkedHashMap
argument_list|<
name|String
argument_list|,
name|ASTNode
argument_list|>
name|aggregationTrees
init|=
operator|new
name|LinkedHashMap
argument_list|<
name|String
argument_list|,
name|ASTNode
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|selExpr
operator|.
name|getChildCount
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|ASTNode
name|sel
init|=
operator|(
name|ASTNode
operator|)
name|selExpr
operator|.
name|getChild
argument_list|(
name|i
argument_list|)
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|doPhase1GetAllAggregations
argument_list|(
name|sel
argument_list|,
name|aggregationTrees
argument_list|)
expr_stmt|;
block|}
return|return
name|aggregationTrees
return|;
block|}
comment|/**    * DFS-scan the expressionTree to find all aggregation subtrees and put them    * in aggregations.    *    * @param expressionTree    * @param aggregations    *          the key to the HashTable is the toStringTree() representation of    *          the aggregation subtree.    */
specifier|private
name|void
name|doPhase1GetAllAggregations
parameter_list|(
name|ASTNode
name|expressionTree
parameter_list|,
name|HashMap
argument_list|<
name|String
argument_list|,
name|ASTNode
argument_list|>
name|aggregations
parameter_list|)
block|{
if|if
condition|(
name|expressionTree
operator|.
name|getToken
argument_list|()
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_FUNCTION
operator|||
name|expressionTree
operator|.
name|getToken
argument_list|()
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_FUNCTIONDI
condition|)
block|{
assert|assert
operator|(
name|expressionTree
operator|.
name|getChildCount
argument_list|()
operator|!=
literal|0
operator|)
assert|;
if|if
condition|(
name|expressionTree
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|Identifier
condition|)
block|{
name|String
name|functionName
init|=
name|unescapeIdentifier
argument_list|(
name|expressionTree
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getText
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|FunctionRegistry
operator|.
name|getGenericUDAFResolver
argument_list|(
name|functionName
argument_list|)
operator|!=
literal|null
condition|)
block|{
name|aggregations
operator|.
name|put
argument_list|(
name|expressionTree
operator|.
name|toStringTree
argument_list|()
argument_list|,
name|expressionTree
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|expressionTree
operator|.
name|getChildCount
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|doPhase1GetAllAggregations
argument_list|(
operator|(
name|ASTNode
operator|)
name|expressionTree
operator|.
name|getChild
argument_list|(
name|i
argument_list|)
argument_list|,
name|aggregations
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
name|ASTNode
name|doPhase1GetDistinctFuncExpr
parameter_list|(
name|HashMap
argument_list|<
name|String
argument_list|,
name|ASTNode
argument_list|>
name|aggregationTrees
parameter_list|)
throws|throws
name|SemanticException
block|{
name|ASTNode
name|expr
init|=
literal|null
decl_stmt|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|ASTNode
argument_list|>
name|entry
range|:
name|aggregationTrees
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|ASTNode
name|value
init|=
name|entry
operator|.
name|getValue
argument_list|()
decl_stmt|;
assert|assert
operator|(
name|value
operator|!=
literal|null
operator|)
assert|;
if|if
condition|(
name|value
operator|.
name|getToken
argument_list|()
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_FUNCTIONDI
condition|)
block|{
if|if
condition|(
name|expr
operator|==
literal|null
condition|)
block|{
name|expr
operator|=
name|value
expr_stmt|;
block|}
else|else
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|UNSUPPORTED_MULTIPLE_DISTINCTS
operator|.
name|getMsg
argument_list|(
name|expr
argument_list|)
argument_list|)
throw|;
block|}
block|}
block|}
return|return
name|expr
return|;
block|}
specifier|private
name|void
name|processTable
parameter_list|(
name|QB
name|qb
parameter_list|,
name|ASTNode
name|tabref
parameter_list|)
throws|throws
name|SemanticException
block|{
comment|// For each table reference get the table name
comment|// and the alias (if alias is not present, the table name
comment|// is used as an alias)
name|boolean
name|tableSamplePresent
init|=
literal|false
decl_stmt|;
name|int
name|aliasIndex
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|tabref
operator|.
name|getChildCount
argument_list|()
operator|==
literal|2
condition|)
block|{
comment|// tablename tablesample
comment|// OR
comment|// tablename alias
name|ASTNode
name|ct
init|=
operator|(
name|ASTNode
operator|)
name|tabref
operator|.
name|getChild
argument_list|(
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|ct
operator|.
name|getToken
argument_list|()
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_TABLESAMPLE
condition|)
block|{
name|tableSamplePresent
operator|=
literal|true
expr_stmt|;
block|}
else|else
block|{
name|aliasIndex
operator|=
literal|1
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|tabref
operator|.
name|getChildCount
argument_list|()
operator|==
literal|3
condition|)
block|{
comment|// table name table sample alias
name|aliasIndex
operator|=
literal|2
expr_stmt|;
name|tableSamplePresent
operator|=
literal|true
expr_stmt|;
block|}
name|ASTNode
name|tableTree
init|=
call|(
name|ASTNode
call|)
argument_list|(
name|tabref
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|String
name|alias
init|=
name|unescapeIdentifier
argument_list|(
name|tabref
operator|.
name|getChild
argument_list|(
name|aliasIndex
argument_list|)
operator|.
name|getText
argument_list|()
argument_list|)
decl_stmt|;
comment|// If the alias is already there then we have a conflict
if|if
condition|(
name|qb
operator|.
name|exists
argument_list|(
name|alias
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|AMBIGUOUS_TABLE_ALIAS
operator|.
name|getMsg
argument_list|(
name|tabref
operator|.
name|getChild
argument_list|(
name|aliasIndex
argument_list|)
argument_list|)
argument_list|)
throw|;
block|}
if|if
condition|(
name|tableSamplePresent
condition|)
block|{
name|ASTNode
name|sampleClause
init|=
operator|(
name|ASTNode
operator|)
name|tabref
operator|.
name|getChild
argument_list|(
literal|1
argument_list|)
decl_stmt|;
name|ArrayList
argument_list|<
name|ASTNode
argument_list|>
name|sampleCols
init|=
operator|new
name|ArrayList
argument_list|<
name|ASTNode
argument_list|>
argument_list|()
decl_stmt|;
if|if
condition|(
name|sampleClause
operator|.
name|getChildCount
argument_list|()
operator|>
literal|2
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|2
init|;
name|i
operator|<
name|sampleClause
operator|.
name|getChildCount
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|sampleCols
operator|.
name|add
argument_list|(
operator|(
name|ASTNode
operator|)
name|sampleClause
operator|.
name|getChild
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|// TODO: For now only support sampling on up to two columns
comment|// Need to change it to list of columns
if|if
condition|(
name|sampleCols
operator|.
name|size
argument_list|()
operator|>
literal|2
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|SAMPLE_RESTRICTION
operator|.
name|getMsg
argument_list|(
name|tabref
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
argument_list|)
argument_list|)
throw|;
block|}
name|qb
operator|.
name|getParseInfo
argument_list|()
operator|.
name|setTabSample
argument_list|(
name|alias
argument_list|,
operator|new
name|TableSample
argument_list|(
name|unescapeIdentifier
argument_list|(
name|sampleClause
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getText
argument_list|()
argument_list|)
argument_list|,
name|unescapeIdentifier
argument_list|(
name|sampleClause
operator|.
name|getChild
argument_list|(
literal|1
argument_list|)
operator|.
name|getText
argument_list|()
argument_list|)
argument_list|,
name|sampleCols
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// Insert this map into the stats
name|String
name|table_name
init|=
name|unescapeIdentifier
argument_list|(
name|tabref
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getText
argument_list|()
argument_list|)
decl_stmt|;
name|qb
operator|.
name|setTabAlias
argument_list|(
name|alias
argument_list|,
name|table_name
argument_list|)
expr_stmt|;
name|qb
operator|.
name|getParseInfo
argument_list|()
operator|.
name|setSrcForAlias
argument_list|(
name|alias
argument_list|,
name|tableTree
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|processSubQuery
parameter_list|(
name|QB
name|qb
parameter_list|,
name|ASTNode
name|subq
parameter_list|)
throws|throws
name|SemanticException
block|{
comment|// This is a subquery and must have an alias
if|if
condition|(
name|subq
operator|.
name|getChildCount
argument_list|()
operator|!=
literal|2
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|NO_SUBQUERY_ALIAS
operator|.
name|getMsg
argument_list|(
name|subq
argument_list|)
argument_list|)
throw|;
block|}
name|ASTNode
name|subqref
init|=
operator|(
name|ASTNode
operator|)
name|subq
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|String
name|alias
init|=
name|unescapeIdentifier
argument_list|(
name|subq
operator|.
name|getChild
argument_list|(
literal|1
argument_list|)
operator|.
name|getText
argument_list|()
argument_list|)
decl_stmt|;
comment|// Recursively do the first phase of semantic analysis for the subquery
name|QBExpr
name|qbexpr
init|=
operator|new
name|QBExpr
argument_list|(
name|alias
argument_list|)
decl_stmt|;
name|doPhase1QBExpr
argument_list|(
name|subqref
argument_list|,
name|qbexpr
argument_list|,
name|qb
operator|.
name|getId
argument_list|()
argument_list|,
name|alias
argument_list|)
expr_stmt|;
comment|// If the alias is already there then we have a conflict
if|if
condition|(
name|qb
operator|.
name|exists
argument_list|(
name|alias
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|AMBIGUOUS_TABLE_ALIAS
operator|.
name|getMsg
argument_list|(
name|subq
operator|.
name|getChild
argument_list|(
literal|1
argument_list|)
argument_list|)
argument_list|)
throw|;
block|}
comment|// Insert this map into the stats
name|qb
operator|.
name|setSubqAlias
argument_list|(
name|alias
argument_list|,
name|qbexpr
argument_list|)
expr_stmt|;
block|}
specifier|private
name|boolean
name|isJoinToken
parameter_list|(
name|ASTNode
name|node
parameter_list|)
block|{
if|if
condition|(
operator|(
name|node
operator|.
name|getToken
argument_list|()
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_JOIN
operator|)
operator|||
operator|(
name|node
operator|.
name|getToken
argument_list|()
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_LEFTOUTERJOIN
operator|)
operator|||
operator|(
name|node
operator|.
name|getToken
argument_list|()
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_RIGHTOUTERJOIN
operator|)
operator|||
operator|(
name|node
operator|.
name|getToken
argument_list|()
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_FULLOUTERJOIN
operator|)
condition|)
return|return
literal|true
return|;
return|return
literal|false
return|;
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"nls"
argument_list|)
specifier|private
name|void
name|processJoin
parameter_list|(
name|QB
name|qb
parameter_list|,
name|ASTNode
name|join
parameter_list|)
throws|throws
name|SemanticException
block|{
name|int
name|numChildren
init|=
name|join
operator|.
name|getChildCount
argument_list|()
decl_stmt|;
if|if
condition|(
operator|(
name|numChildren
operator|!=
literal|2
operator|)
operator|&&
operator|(
name|numChildren
operator|!=
literal|3
operator|)
condition|)
throw|throw
operator|new
name|SemanticException
argument_list|(
literal|"Join with multiple children"
argument_list|)
throw|;
for|for
control|(
name|int
name|num
init|=
literal|0
init|;
name|num
operator|<
name|numChildren
condition|;
name|num
operator|++
control|)
block|{
name|ASTNode
name|child
init|=
operator|(
name|ASTNode
operator|)
name|join
operator|.
name|getChild
argument_list|(
name|num
argument_list|)
decl_stmt|;
if|if
condition|(
name|child
operator|.
name|getToken
argument_list|()
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_TABREF
condition|)
name|processTable
argument_list|(
name|qb
argument_list|,
name|child
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|child
operator|.
name|getToken
argument_list|()
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_SUBQUERY
condition|)
name|processSubQuery
argument_list|(
name|qb
argument_list|,
name|child
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|isJoinToken
argument_list|(
name|child
argument_list|)
condition|)
name|processJoin
argument_list|(
name|qb
argument_list|,
name|child
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|SuppressWarnings
argument_list|(
block|{
literal|"fallthrough"
block|,
literal|"nls"
block|}
argument_list|)
specifier|public
name|void
name|doPhase1
parameter_list|(
name|ASTNode
name|ast
parameter_list|,
name|QB
name|qb
parameter_list|,
name|Phase1Ctx
name|ctx_1
parameter_list|)
throws|throws
name|SemanticException
block|{
name|QBParseInfo
name|qbp
init|=
name|qb
operator|.
name|getParseInfo
argument_list|()
decl_stmt|;
name|boolean
name|skipRecursion
init|=
literal|false
decl_stmt|;
if|if
condition|(
name|ast
operator|.
name|getToken
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|skipRecursion
operator|=
literal|true
expr_stmt|;
switch|switch
condition|(
name|ast
operator|.
name|getToken
argument_list|()
operator|.
name|getType
argument_list|()
condition|)
block|{
case|case
name|HiveParser
operator|.
name|TOK_SELECTDI
case|:
name|qb
operator|.
name|countSelDi
argument_list|()
expr_stmt|;
comment|// fall through
case|case
name|HiveParser
operator|.
name|TOK_SELECT
case|:
name|qb
operator|.
name|countSel
argument_list|()
expr_stmt|;
name|qbp
operator|.
name|setSelExprForClause
argument_list|(
name|ctx_1
operator|.
name|dest
argument_list|,
name|ast
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|ASTNode
operator|)
name|ast
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|)
operator|.
name|getToken
argument_list|()
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_HINTLIST
condition|)
name|qbp
operator|.
name|setHints
argument_list|(
operator|(
name|ASTNode
operator|)
name|ast
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|LinkedHashMap
argument_list|<
name|String
argument_list|,
name|ASTNode
argument_list|>
name|aggregations
init|=
name|doPhase1GetAggregationsFromSelect
argument_list|(
name|ast
argument_list|)
decl_stmt|;
name|qbp
operator|.
name|setAggregationExprsForClause
argument_list|(
name|ctx_1
operator|.
name|dest
argument_list|,
name|aggregations
argument_list|)
expr_stmt|;
name|qbp
operator|.
name|setDistinctFuncExprForClause
argument_list|(
name|ctx_1
operator|.
name|dest
argument_list|,
name|doPhase1GetDistinctFuncExpr
argument_list|(
name|aggregations
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|HiveParser
operator|.
name|TOK_WHERE
case|:
block|{
name|qbp
operator|.
name|setWhrExprForClause
argument_list|(
name|ctx_1
operator|.
name|dest
argument_list|,
name|ast
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|HiveParser
operator|.
name|TOK_DESTINATION
case|:
block|{
name|ctx_1
operator|.
name|dest
operator|=
literal|"insclause-"
operator|+
name|ctx_1
operator|.
name|nextNum
expr_stmt|;
name|ctx_1
operator|.
name|nextNum
operator|++
expr_stmt|;
comment|// is there a insert in the subquery
if|if
condition|(
name|qbp
operator|.
name|getIsSubQ
argument_list|()
condition|)
block|{
name|ASTNode
name|ch
init|=
operator|(
name|ASTNode
operator|)
name|ast
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|ch
operator|.
name|getToken
argument_list|()
operator|.
name|getType
argument_list|()
operator|!=
name|HiveParser
operator|.
name|TOK_DIR
operator|)
operator|||
operator|(
operator|(
operator|(
name|ASTNode
operator|)
name|ch
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|)
operator|.
name|getToken
argument_list|()
operator|.
name|getType
argument_list|()
operator|!=
name|HiveParser
operator|.
name|TOK_TMP_FILE
operator|)
condition|)
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|NO_INSERT_INSUBQUERY
operator|.
name|getMsg
argument_list|(
name|ast
argument_list|)
argument_list|)
throw|;
block|}
name|qbp
operator|.
name|setDestForClause
argument_list|(
name|ctx_1
operator|.
name|dest
argument_list|,
operator|(
name|ASTNode
operator|)
name|ast
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|HiveParser
operator|.
name|TOK_FROM
case|:
block|{
name|int
name|child_count
init|=
name|ast
operator|.
name|getChildCount
argument_list|()
decl_stmt|;
if|if
condition|(
name|child_count
operator|!=
literal|1
condition|)
throw|throw
operator|new
name|SemanticException
argument_list|(
literal|"Multiple Children "
operator|+
name|child_count
argument_list|)
throw|;
comment|// Check if this is a subquery
name|ASTNode
name|frm
init|=
operator|(
name|ASTNode
operator|)
name|ast
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|frm
operator|.
name|getToken
argument_list|()
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_TABREF
condition|)
name|processTable
argument_list|(
name|qb
argument_list|,
name|frm
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|frm
operator|.
name|getToken
argument_list|()
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_SUBQUERY
condition|)
name|processSubQuery
argument_list|(
name|qb
argument_list|,
name|frm
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|isJoinToken
argument_list|(
name|frm
argument_list|)
condition|)
block|{
name|processJoin
argument_list|(
name|qb
argument_list|,
name|frm
argument_list|)
expr_stmt|;
name|qbp
operator|.
name|setJoinExpr
argument_list|(
name|frm
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|HiveParser
operator|.
name|TOK_CLUSTERBY
case|:
block|{
comment|// Get the clusterby aliases - these are aliased to the entries in the
comment|// select list
name|qbp
operator|.
name|setClusterByExprForClause
argument_list|(
name|ctx_1
operator|.
name|dest
argument_list|,
name|ast
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|HiveParser
operator|.
name|TOK_DISTRIBUTEBY
case|:
block|{
comment|// Get the distribute by  aliases - these are aliased to the entries in the
comment|// select list
name|qbp
operator|.
name|setDistributeByExprForClause
argument_list|(
name|ctx_1
operator|.
name|dest
argument_list|,
name|ast
argument_list|)
expr_stmt|;
if|if
condition|(
name|qbp
operator|.
name|getClusterByForClause
argument_list|(
name|ctx_1
operator|.
name|dest
argument_list|)
operator|!=
literal|null
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|CLUSTERBY_DISTRIBUTEBY_CONFLICT
operator|.
name|getMsg
argument_list|(
name|ast
argument_list|)
argument_list|)
throw|;
block|}
elseif|else
if|if
condition|(
name|qbp
operator|.
name|getOrderByForClause
argument_list|(
name|ctx_1
operator|.
name|dest
argument_list|)
operator|!=
literal|null
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|ORDERBY_DISTRIBUTEBY_CONFLICT
operator|.
name|getMsg
argument_list|(
name|ast
argument_list|)
argument_list|)
throw|;
block|}
block|}
break|break;
case|case
name|HiveParser
operator|.
name|TOK_SORTBY
case|:
block|{
comment|// Get the sort by aliases - these are aliased to the entries in the
comment|// select list
name|qbp
operator|.
name|setSortByExprForClause
argument_list|(
name|ctx_1
operator|.
name|dest
argument_list|,
name|ast
argument_list|)
expr_stmt|;
if|if
condition|(
name|qbp
operator|.
name|getClusterByForClause
argument_list|(
name|ctx_1
operator|.
name|dest
argument_list|)
operator|!=
literal|null
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|CLUSTERBY_SORTBY_CONFLICT
operator|.
name|getMsg
argument_list|(
name|ast
argument_list|)
argument_list|)
throw|;
block|}
elseif|else
if|if
condition|(
name|qbp
operator|.
name|getOrderByForClause
argument_list|(
name|ctx_1
operator|.
name|dest
argument_list|)
operator|!=
literal|null
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|ORDERBY_SORTBY_CONFLICT
operator|.
name|getMsg
argument_list|(
name|ast
argument_list|)
argument_list|)
throw|;
block|}
block|}
break|break;
case|case
name|HiveParser
operator|.
name|TOK_ORDERBY
case|:
block|{
comment|// Get the order by aliases - these are aliased to the entries in the
comment|// select list
name|qbp
operator|.
name|setOrderByExprForClause
argument_list|(
name|ctx_1
operator|.
name|dest
argument_list|,
name|ast
argument_list|)
expr_stmt|;
if|if
condition|(
name|qbp
operator|.
name|getClusterByForClause
argument_list|(
name|ctx_1
operator|.
name|dest
argument_list|)
operator|!=
literal|null
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|CLUSTERBY_ORDERBY_CONFLICT
operator|.
name|getMsg
argument_list|(
name|ast
argument_list|)
argument_list|)
throw|;
block|}
block|}
break|break;
case|case
name|HiveParser
operator|.
name|TOK_GROUPBY
case|:
block|{
comment|// Get the groupby aliases - these are aliased to the entries in the
comment|// select list
if|if
condition|(
name|qbp
operator|.
name|getSelForClause
argument_list|(
name|ctx_1
operator|.
name|dest
argument_list|)
operator|.
name|getToken
argument_list|()
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_SELECTDI
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|SELECT_DISTINCT_WITH_GROUPBY
operator|.
name|getMsg
argument_list|(
name|ast
argument_list|)
argument_list|)
throw|;
block|}
name|qbp
operator|.
name|setGroupByExprForClause
argument_list|(
name|ctx_1
operator|.
name|dest
argument_list|,
name|ast
argument_list|)
expr_stmt|;
name|skipRecursion
operator|=
literal|true
expr_stmt|;
block|}
break|break;
case|case
name|HiveParser
operator|.
name|TOK_LIMIT
case|:
block|{
name|qbp
operator|.
name|setDestLimit
argument_list|(
name|ctx_1
operator|.
name|dest
argument_list|,
operator|new
name|Integer
argument_list|(
name|ast
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getText
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|HiveParser
operator|.
name|TOK_UNION
case|:
comment|// currently, we dont support subq1 union subq2 - the user has to explicitly say:
comment|// select * from (subq1 union subq2) subqalias
if|if
condition|(
operator|!
name|qbp
operator|.
name|getIsSubQ
argument_list|()
condition|)
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|UNION_NOTIN_SUBQ
operator|.
name|getMsg
argument_list|()
argument_list|)
throw|;
default|default:
name|skipRecursion
operator|=
literal|false
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|skipRecursion
condition|)
block|{
comment|// Iterate over the rest of the children
name|int
name|child_count
init|=
name|ast
operator|.
name|getChildCount
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|child_pos
init|=
literal|0
init|;
name|child_pos
operator|<
name|child_count
condition|;
operator|++
name|child_pos
control|)
block|{
comment|// Recurse
name|doPhase1
argument_list|(
operator|(
name|ASTNode
operator|)
name|ast
operator|.
name|getChild
argument_list|(
name|child_pos
argument_list|)
argument_list|,
name|qb
argument_list|,
name|ctx_1
argument_list|)
expr_stmt|;
block|}
block|}
block|}
specifier|private
name|void
name|genPartitionPruners
parameter_list|(
name|QBExpr
name|qbexpr
parameter_list|)
throws|throws
name|SemanticException
block|{
if|if
condition|(
name|qbexpr
operator|.
name|getOpcode
argument_list|()
operator|==
name|QBExpr
operator|.
name|Opcode
operator|.
name|NULLOP
condition|)
block|{
name|genPartitionPruners
argument_list|(
name|qbexpr
operator|.
name|getQB
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|genPartitionPruners
argument_list|(
name|qbexpr
operator|.
name|getQBExpr1
argument_list|()
argument_list|)
expr_stmt|;
name|genPartitionPruners
argument_list|(
name|qbexpr
operator|.
name|getQBExpr2
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**     * Generate partition pruners. The filters can occur in the where clause and in the JOIN conditions. First, walk over the     * filters in the join condition and AND them, since all of them are needed. Then for each where clause, traverse the     * filter.     * Note that, currently we do not propagate filters over subqueries. For eg: if the query is of the type:    * select ... FROM t1 JOIN (select ... t2) x where x.partition    * we will not recognize that x.partition condition introduces a parition pruner on t2    *     */
annotation|@
name|SuppressWarnings
argument_list|(
literal|"nls"
argument_list|)
specifier|private
name|void
name|genPartitionPruners
parameter_list|(
name|QB
name|qb
parameter_list|)
throws|throws
name|SemanticException
block|{
name|Map
argument_list|<
name|String
argument_list|,
name|Boolean
argument_list|>
name|joinPartnPruner
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|Boolean
argument_list|>
argument_list|()
decl_stmt|;
name|QBParseInfo
name|qbp
init|=
name|qb
operator|.
name|getParseInfo
argument_list|()
decl_stmt|;
comment|// Recursively prune subqueries
for|for
control|(
name|String
name|alias
range|:
name|qb
operator|.
name|getSubqAliases
argument_list|()
control|)
block|{
name|QBExpr
name|qbexpr
init|=
name|qb
operator|.
name|getSubqForAlias
argument_list|(
name|alias
argument_list|)
decl_stmt|;
name|genPartitionPruners
argument_list|(
name|qbexpr
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|String
name|alias
range|:
name|qb
operator|.
name|getTabAliases
argument_list|()
control|)
block|{
name|String
name|alias_id
init|=
operator|(
name|qb
operator|.
name|getId
argument_list|()
operator|==
literal|null
condition|?
name|alias
else|:
name|qb
operator|.
name|getId
argument_list|()
operator|+
literal|":"
operator|+
name|alias
operator|)
decl_stmt|;
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|parse
operator|.
name|ASTPartitionPruner
name|pruner
init|=
operator|new
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|parse
operator|.
name|ASTPartitionPruner
argument_list|(
name|alias
argument_list|,
name|qb
operator|.
name|getMetaData
argument_list|()
argument_list|,
name|conf
argument_list|)
decl_stmt|;
comment|// Pass each where clause to the pruner
for|for
control|(
name|String
name|clause
range|:
name|qbp
operator|.
name|getClauseNames
argument_list|()
control|)
block|{
name|ASTNode
name|whexp
init|=
operator|(
name|ASTNode
operator|)
name|qbp
operator|.
name|getWhrForClause
argument_list|(
name|clause
argument_list|)
decl_stmt|;
if|if
condition|(
name|whexp
operator|!=
literal|null
condition|)
block|{
name|pruner
operator|.
name|addExpression
argument_list|(
operator|(
name|ASTNode
operator|)
name|whexp
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Add the pruner to the list
name|this
operator|.
name|aliasToPruner
operator|.
name|put
argument_list|(
name|alias_id
argument_list|,
name|pruner
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|qb
operator|.
name|getTabAliases
argument_list|()
operator|.
name|isEmpty
argument_list|()
operator|&&
name|qb
operator|.
name|getQbJoinTree
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|int
name|pos
init|=
literal|0
decl_stmt|;
for|for
control|(
name|String
name|alias
range|:
name|qb
operator|.
name|getQbJoinTree
argument_list|()
operator|.
name|getBaseSrc
argument_list|()
control|)
block|{
if|if
condition|(
name|alias
operator|!=
literal|null
condition|)
block|{
name|String
name|alias_id
init|=
operator|(
name|qb
operator|.
name|getId
argument_list|()
operator|==
literal|null
condition|?
name|alias
else|:
name|qb
operator|.
name|getId
argument_list|()
operator|+
literal|":"
operator|+
name|alias
operator|)
decl_stmt|;
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|parse
operator|.
name|ASTPartitionPruner
name|pruner
init|=
name|this
operator|.
name|aliasToPruner
operator|.
name|get
argument_list|(
name|alias_id
argument_list|)
decl_stmt|;
if|if
condition|(
name|pruner
operator|==
literal|null
condition|)
block|{
comment|// this means that the alias is a subquery
name|pos
operator|++
expr_stmt|;
continue|continue;
block|}
name|Vector
argument_list|<
name|ASTNode
argument_list|>
name|filters
init|=
name|qb
operator|.
name|getQbJoinTree
argument_list|()
operator|.
name|getFilters
argument_list|()
operator|.
name|get
argument_list|(
name|pos
argument_list|)
decl_stmt|;
for|for
control|(
name|ASTNode
name|cond
range|:
name|filters
control|)
block|{
name|pruner
operator|.
name|addJoinOnExpression
argument_list|(
name|cond
argument_list|)
expr_stmt|;
if|if
condition|(
name|pruner
operator|.
name|hasPartitionPredicate
argument_list|(
name|cond
argument_list|)
condition|)
name|joinPartnPruner
operator|.
name|put
argument_list|(
name|alias_id
argument_list|,
operator|new
name|Boolean
argument_list|(
literal|true
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|qb
operator|.
name|getQbJoinTree
argument_list|()
operator|.
name|getJoinSrc
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|filters
operator|=
name|qb
operator|.
name|getQbJoinTree
argument_list|()
operator|.
name|getFilters
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|ASTNode
name|cond
range|:
name|filters
control|)
block|{
name|pruner
operator|.
name|addJoinOnExpression
argument_list|(
name|cond
argument_list|)
expr_stmt|;
if|if
condition|(
name|pruner
operator|.
name|hasPartitionPredicate
argument_list|(
name|cond
argument_list|)
condition|)
name|joinPartnPruner
operator|.
name|put
argument_list|(
name|alias_id
argument_list|,
operator|new
name|Boolean
argument_list|(
literal|true
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|pos
operator|++
expr_stmt|;
block|}
block|}
comment|// Do old-style partition pruner check only if the new partition pruner
comment|// is not enabled.
if|if
condition|(
operator|!
name|HiveConf
operator|.
name|getBoolVar
argument_list|(
name|conf
argument_list|,
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVEOPTPPD
argument_list|)
operator|||
operator|!
name|HiveConf
operator|.
name|getBoolVar
argument_list|(
name|conf
argument_list|,
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVEOPTPPR
argument_list|)
condition|)
block|{
for|for
control|(
name|String
name|alias
range|:
name|qb
operator|.
name|getTabAliases
argument_list|()
control|)
block|{
name|String
name|alias_id
init|=
operator|(
name|qb
operator|.
name|getId
argument_list|()
operator|==
literal|null
condition|?
name|alias
else|:
name|qb
operator|.
name|getId
argument_list|()
operator|+
literal|":"
operator|+
name|alias
operator|)
decl_stmt|;
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|parse
operator|.
name|ASTPartitionPruner
name|pruner
init|=
name|this
operator|.
name|aliasToPruner
operator|.
name|get
argument_list|(
name|alias_id
argument_list|)
decl_stmt|;
if|if
condition|(
name|joinPartnPruner
operator|.
name|get
argument_list|(
name|alias_id
argument_list|)
operator|==
literal|null
condition|)
block|{
comment|// Pass each where clause to the pruner
for|for
control|(
name|String
name|clause
range|:
name|qbp
operator|.
name|getClauseNames
argument_list|()
control|)
block|{
name|ASTNode
name|whexp
init|=
operator|(
name|ASTNode
operator|)
name|qbp
operator|.
name|getWhrForClause
argument_list|(
name|clause
argument_list|)
decl_stmt|;
if|if
condition|(
name|pruner
operator|.
name|getTable
argument_list|()
operator|.
name|isPartitioned
argument_list|()
operator|&&
name|conf
operator|.
name|getVar
argument_list|(
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVEMAPREDMODE
argument_list|)
operator|.
name|equalsIgnoreCase
argument_list|(
literal|"strict"
argument_list|)
operator|&&
operator|(
name|whexp
operator|==
literal|null
operator|||
operator|!
name|pruner
operator|.
name|hasPartitionPredicate
argument_list|(
operator|(
name|ASTNode
operator|)
name|whexp
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
argument_list|)
operator|)
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|NO_PARTITION_PREDICATE
operator|.
name|getMsg
argument_list|(
name|whexp
operator|!=
literal|null
condition|?
name|whexp
else|:
name|qbp
operator|.
name|getSelForClause
argument_list|(
name|clause
argument_list|)
argument_list|,
literal|" for Alias "
operator|+
name|alias
operator|+
literal|" Table "
operator|+
name|pruner
operator|.
name|getTable
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|)
argument_list|)
throw|;
block|}
block|}
block|}
block|}
block|}
block|}
specifier|private
name|void
name|genSamplePruners
parameter_list|(
name|QBExpr
name|qbexpr
parameter_list|)
throws|throws
name|SemanticException
block|{
if|if
condition|(
name|qbexpr
operator|.
name|getOpcode
argument_list|()
operator|==
name|QBExpr
operator|.
name|Opcode
operator|.
name|NULLOP
condition|)
block|{
name|genSamplePruners
argument_list|(
name|qbexpr
operator|.
name|getQB
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|genSamplePruners
argument_list|(
name|qbexpr
operator|.
name|getQBExpr1
argument_list|()
argument_list|)
expr_stmt|;
name|genSamplePruners
argument_list|(
name|qbexpr
operator|.
name|getQBExpr2
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"nls"
argument_list|)
specifier|private
name|void
name|genSamplePruners
parameter_list|(
name|QB
name|qb
parameter_list|)
throws|throws
name|SemanticException
block|{
comment|// Recursively prune subqueries
for|for
control|(
name|String
name|alias
range|:
name|qb
operator|.
name|getSubqAliases
argument_list|()
control|)
block|{
name|QBExpr
name|qbexpr
init|=
name|qb
operator|.
name|getSubqForAlias
argument_list|(
name|alias
argument_list|)
decl_stmt|;
name|genSamplePruners
argument_list|(
name|qbexpr
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|String
name|alias
range|:
name|qb
operator|.
name|getTabAliases
argument_list|()
control|)
block|{
name|String
name|alias_id
init|=
operator|(
name|qb
operator|.
name|getId
argument_list|()
operator|==
literal|null
condition|?
name|alias
else|:
name|qb
operator|.
name|getId
argument_list|()
operator|+
literal|":"
operator|+
name|alias
operator|)
decl_stmt|;
name|QBParseInfo
name|qbp
init|=
name|qb
operator|.
name|getParseInfo
argument_list|()
decl_stmt|;
name|TableSample
name|tableSample
init|=
name|qbp
operator|.
name|getTabSample
argument_list|(
name|alias_id
argument_list|)
decl_stmt|;
if|if
condition|(
name|tableSample
operator|!=
literal|null
condition|)
block|{
name|SamplePruner
name|pruner
init|=
operator|new
name|SamplePruner
argument_list|(
name|alias
argument_list|,
name|tableSample
argument_list|)
decl_stmt|;
name|this
operator|.
name|aliasToSamplePruner
operator|.
name|put
argument_list|(
name|alias_id
argument_list|,
name|pruner
argument_list|)
expr_stmt|;
block|}
block|}
block|}
specifier|private
name|void
name|getMetaData
parameter_list|(
name|QBExpr
name|qbexpr
parameter_list|)
throws|throws
name|SemanticException
block|{
if|if
condition|(
name|qbexpr
operator|.
name|getOpcode
argument_list|()
operator|==
name|QBExpr
operator|.
name|Opcode
operator|.
name|NULLOP
condition|)
block|{
name|getMetaData
argument_list|(
name|qbexpr
operator|.
name|getQB
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|getMetaData
argument_list|(
name|qbexpr
operator|.
name|getQBExpr1
argument_list|()
argument_list|)
expr_stmt|;
name|getMetaData
argument_list|(
name|qbexpr
operator|.
name|getQBExpr2
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"nls"
argument_list|)
specifier|public
name|void
name|getMetaData
parameter_list|(
name|QB
name|qb
parameter_list|)
throws|throws
name|SemanticException
block|{
try|try
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Get metadata for source tables"
argument_list|)
expr_stmt|;
comment|// Go over the tables and populate the related structures
for|for
control|(
name|String
name|alias
range|:
name|qb
operator|.
name|getTabAliases
argument_list|()
control|)
block|{
name|String
name|tab_name
init|=
name|qb
operator|.
name|getTabNameForAlias
argument_list|(
name|alias
argument_list|)
decl_stmt|;
name|Table
name|tab
init|=
literal|null
decl_stmt|;
try|try
block|{
name|tab
operator|=
name|this
operator|.
name|db
operator|.
name|getTable
argument_list|(
name|MetaStoreUtils
operator|.
name|DEFAULT_DATABASE_NAME
argument_list|,
name|tab_name
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InvalidTableException
name|ite
parameter_list|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|INVALID_TABLE
operator|.
name|getMsg
argument_list|(
name|qb
operator|.
name|getParseInfo
argument_list|()
operator|.
name|getSrcForAlias
argument_list|(
name|alias
argument_list|)
argument_list|)
argument_list|)
throw|;
block|}
if|if
condition|(
operator|!
name|InputFormat
operator|.
name|class
operator|.
name|isAssignableFrom
argument_list|(
name|tab
operator|.
name|getInputFormatClass
argument_list|()
argument_list|)
condition|)
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|INVALID_INPUT_FORMAT_TYPE
operator|.
name|getMsg
argument_list|(
name|qb
operator|.
name|getParseInfo
argument_list|()
operator|.
name|getSrcForAlias
argument_list|(
name|alias
argument_list|)
argument_list|)
argument_list|)
throw|;
name|qb
operator|.
name|getMetaData
argument_list|()
operator|.
name|setSrcForAlias
argument_list|(
name|alias
argument_list|,
name|tab
argument_list|)
expr_stmt|;
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"Get metadata for subqueries"
argument_list|)
expr_stmt|;
comment|// Go over the subqueries and getMetaData for these
for|for
control|(
name|String
name|alias
range|:
name|qb
operator|.
name|getSubqAliases
argument_list|()
control|)
block|{
name|QBExpr
name|qbexpr
init|=
name|qb
operator|.
name|getSubqForAlias
argument_list|(
name|alias
argument_list|)
decl_stmt|;
name|getMetaData
argument_list|(
name|qbexpr
argument_list|)
expr_stmt|;
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"Get metadata for destination tables"
argument_list|)
expr_stmt|;
comment|// Go over all the destination structures and populate the related
comment|// metadata
name|QBParseInfo
name|qbp
init|=
name|qb
operator|.
name|getParseInfo
argument_list|()
decl_stmt|;
for|for
control|(
name|String
name|name
range|:
name|qbp
operator|.
name|getClauseNamesForDest
argument_list|()
control|)
block|{
name|ASTNode
name|ast
init|=
name|qbp
operator|.
name|getDestForClause
argument_list|(
name|name
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|ast
operator|.
name|getToken
argument_list|()
operator|.
name|getType
argument_list|()
condition|)
block|{
case|case
name|HiveParser
operator|.
name|TOK_TAB
case|:
block|{
name|tableSpec
name|ts
init|=
operator|new
name|tableSpec
argument_list|(
name|this
operator|.
name|db
argument_list|,
name|conf
argument_list|,
name|ast
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|HiveOutputFormat
operator|.
name|class
operator|.
name|isAssignableFrom
argument_list|(
name|ts
operator|.
name|tableHandle
operator|.
name|getOutputFormatClass
argument_list|()
argument_list|)
condition|)
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|INVALID_OUTPUT_FORMAT_TYPE
operator|.
name|getMsg
argument_list|(
name|ast
argument_list|)
argument_list|)
throw|;
if|if
condition|(
name|ts
operator|.
name|partSpec
operator|==
literal|null
condition|)
block|{
comment|// This is a table
name|qb
operator|.
name|getMetaData
argument_list|()
operator|.
name|setDestForAlias
argument_list|(
name|name
argument_list|,
name|ts
operator|.
name|tableHandle
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// This is a partition
name|qb
operator|.
name|getMetaData
argument_list|()
operator|.
name|setDestForAlias
argument_list|(
name|name
argument_list|,
name|ts
operator|.
name|partHandle
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
case|case
name|HiveParser
operator|.
name|TOK_LOCAL_DIR
case|:
case|case
name|HiveParser
operator|.
name|TOK_DIR
case|:
block|{
comment|// This is a dfs file
name|String
name|fname
init|=
name|stripQuotes
argument_list|(
name|ast
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getText
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
operator|!
name|qb
operator|.
name|getParseInfo
argument_list|()
operator|.
name|getIsSubQ
argument_list|()
operator|)
operator|&&
operator|(
operator|(
operator|(
name|ASTNode
operator|)
name|ast
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|)
operator|.
name|getToken
argument_list|()
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_TMP_FILE
operator|)
condition|)
block|{
name|fname
operator|=
name|ctx
operator|.
name|getMRTmpFileURI
argument_list|()
expr_stmt|;
name|ctx
operator|.
name|setResDir
argument_list|(
operator|new
name|Path
argument_list|(
name|fname
argument_list|)
argument_list|)
expr_stmt|;
name|qb
operator|.
name|setIsQuery
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
name|qb
operator|.
name|getMetaData
argument_list|()
operator|.
name|setDestForAlias
argument_list|(
name|name
argument_list|,
name|fname
argument_list|,
operator|(
name|ast
operator|.
name|getToken
argument_list|()
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_DIR
operator|)
argument_list|)
expr_stmt|;
break|break;
block|}
default|default:
throw|throw
operator|new
name|SemanticException
argument_list|(
literal|"Unknown Token Type "
operator|+
name|ast
operator|.
name|getToken
argument_list|()
operator|.
name|getType
argument_list|()
argument_list|)
throw|;
block|}
block|}
block|}
catch|catch
parameter_list|(
name|HiveException
name|e
parameter_list|)
block|{
comment|// Has to use full name to make sure it does not conflict with org.apache.commons.lang.StringUtils
name|LOG
operator|.
name|error
argument_list|(
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|StringUtils
operator|.
name|stringifyException
argument_list|(
name|e
argument_list|)
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|SemanticException
argument_list|(
name|e
operator|.
name|getMessage
argument_list|()
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
specifier|private
name|boolean
name|isPresent
parameter_list|(
name|String
index|[]
name|list
parameter_list|,
name|String
name|elem
parameter_list|)
block|{
for|for
control|(
name|String
name|s
range|:
name|list
control|)
if|if
condition|(
name|s
operator|.
name|equals
argument_list|(
name|elem
argument_list|)
condition|)
return|return
literal|true
return|;
return|return
literal|false
return|;
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"nls"
argument_list|)
specifier|private
name|void
name|parseJoinCondPopulateAlias
parameter_list|(
name|QBJoinTree
name|joinTree
parameter_list|,
name|ASTNode
name|condn
parameter_list|,
name|Vector
argument_list|<
name|String
argument_list|>
name|leftAliases
parameter_list|,
name|Vector
argument_list|<
name|String
argument_list|>
name|rightAliases
parameter_list|)
throws|throws
name|SemanticException
block|{
comment|// String[] allAliases = joinTree.getAllAliases();
switch|switch
condition|(
name|condn
operator|.
name|getToken
argument_list|()
operator|.
name|getType
argument_list|()
condition|)
block|{
case|case
name|HiveParser
operator|.
name|TOK_TABLE_OR_COL
case|:
name|String
name|tableOrCol
init|=
name|unescapeIdentifier
argument_list|(
name|condn
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getText
argument_list|()
operator|.
name|toLowerCase
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|isPresent
argument_list|(
name|joinTree
operator|.
name|getLeftAliases
argument_list|()
argument_list|,
name|tableOrCol
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|leftAliases
operator|.
name|contains
argument_list|(
name|tableOrCol
argument_list|)
condition|)
name|leftAliases
operator|.
name|add
argument_list|(
name|tableOrCol
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|isPresent
argument_list|(
name|joinTree
operator|.
name|getRightAliases
argument_list|()
argument_list|,
name|tableOrCol
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|rightAliases
operator|.
name|contains
argument_list|(
name|tableOrCol
argument_list|)
condition|)
name|rightAliases
operator|.
name|add
argument_list|(
name|tableOrCol
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// We don't support columns without table prefix in JOIN condition right now.
comment|// We need to pass Metadata here to know which table the column belongs to.
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|INVALID_TABLE_ALIAS
operator|.
name|getMsg
argument_list|(
name|condn
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
argument_list|)
argument_list|)
throw|;
block|}
break|break;
case|case
name|HiveParser
operator|.
name|Number
case|:
case|case
name|HiveParser
operator|.
name|StringLiteral
case|:
case|case
name|HiveParser
operator|.
name|Identifier
case|:
case|case
name|HiveParser
operator|.
name|TOK_CHARSETLITERAL
case|:
case|case
name|HiveParser
operator|.
name|KW_TRUE
case|:
case|case
name|HiveParser
operator|.
name|KW_FALSE
case|:
break|break;
case|case
name|HiveParser
operator|.
name|TOK_FUNCTION
case|:
comment|// check all the arguments
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<
name|condn
operator|.
name|getChildCount
argument_list|()
condition|;
name|i
operator|++
control|)
name|parseJoinCondPopulateAlias
argument_list|(
name|joinTree
argument_list|,
operator|(
name|ASTNode
operator|)
name|condn
operator|.
name|getChild
argument_list|(
name|i
argument_list|)
argument_list|,
name|leftAliases
argument_list|,
name|rightAliases
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|// This is an operator - so check whether it is unary or binary operator
if|if
condition|(
name|condn
operator|.
name|getChildCount
argument_list|()
operator|==
literal|1
condition|)
name|parseJoinCondPopulateAlias
argument_list|(
name|joinTree
argument_list|,
operator|(
name|ASTNode
operator|)
name|condn
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
argument_list|,
name|leftAliases
argument_list|,
name|rightAliases
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|condn
operator|.
name|getChildCount
argument_list|()
operator|==
literal|2
condition|)
block|{
name|parseJoinCondPopulateAlias
argument_list|(
name|joinTree
argument_list|,
operator|(
name|ASTNode
operator|)
name|condn
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
argument_list|,
name|leftAliases
argument_list|,
name|rightAliases
argument_list|)
expr_stmt|;
name|parseJoinCondPopulateAlias
argument_list|(
name|joinTree
argument_list|,
operator|(
name|ASTNode
operator|)
name|condn
operator|.
name|getChild
argument_list|(
literal|1
argument_list|)
argument_list|,
name|leftAliases
argument_list|,
name|rightAliases
argument_list|)
expr_stmt|;
block|}
else|else
throw|throw
operator|new
name|SemanticException
argument_list|(
name|condn
operator|.
name|toStringTree
argument_list|()
operator|+
literal|" encountered with "
operator|+
name|condn
operator|.
name|getChildCount
argument_list|()
operator|+
literal|" children"
argument_list|)
throw|;
break|break;
block|}
block|}
specifier|private
name|void
name|populateAliases
parameter_list|(
name|Vector
argument_list|<
name|String
argument_list|>
name|leftAliases
parameter_list|,
name|Vector
argument_list|<
name|String
argument_list|>
name|rightAliases
parameter_list|,
name|ASTNode
name|condn
parameter_list|,
name|QBJoinTree
name|joinTree
parameter_list|,
name|Vector
argument_list|<
name|String
argument_list|>
name|leftSrc
parameter_list|)
throws|throws
name|SemanticException
block|{
if|if
condition|(
operator|(
name|leftAliases
operator|.
name|size
argument_list|()
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|rightAliases
operator|.
name|size
argument_list|()
operator|!=
literal|0
operator|)
condition|)
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|INVALID_JOIN_CONDITION_1
operator|.
name|getMsg
argument_list|(
name|condn
argument_list|)
argument_list|)
throw|;
if|if
condition|(
name|rightAliases
operator|.
name|size
argument_list|()
operator|!=
literal|0
condition|)
block|{
assert|assert
name|rightAliases
operator|.
name|size
argument_list|()
operator|==
literal|1
assert|;
name|joinTree
operator|.
name|getExpressions
argument_list|()
operator|.
name|get
argument_list|(
literal|1
argument_list|)
operator|.
name|add
argument_list|(
name|condn
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|leftAliases
operator|.
name|size
argument_list|()
operator|!=
literal|0
condition|)
block|{
name|joinTree
operator|.
name|getExpressions
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|add
argument_list|(
name|condn
argument_list|)
expr_stmt|;
for|for
control|(
name|String
name|s
range|:
name|leftAliases
control|)
if|if
condition|(
operator|!
name|leftSrc
operator|.
name|contains
argument_list|(
name|s
argument_list|)
condition|)
name|leftSrc
operator|.
name|add
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
else|else
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|INVALID_JOIN_CONDITION_2
operator|.
name|getMsg
argument_list|(
name|condn
argument_list|)
argument_list|)
throw|;
block|}
comment|/**    * Parse the join condition.     * If the condition is a join condition, throw an error if it is not an equality. Otherwise, break it into left and     * right expressions and store in the join tree.    * If the condition is a join filter, add it to the filter list of join tree.  The join condition can contains conditions    * on both the left and tree trees and filters on either. Currently, we only support equi-joins, so we throw an error    * if the condition involves both subtrees and is not a equality. Also, we only support AND i.e ORs are not supported     * currently as their semantics are not very clear, may lead to data explosion and there is no usecase.    * @param joinTree  jointree to be populated    * @param joinCond  join condition    * @param leftSrc   left sources    * @throws SemanticException    */
specifier|private
name|void
name|parseJoinCondition
parameter_list|(
name|QBJoinTree
name|joinTree
parameter_list|,
name|ASTNode
name|joinCond
parameter_list|,
name|Vector
argument_list|<
name|String
argument_list|>
name|leftSrc
parameter_list|)
throws|throws
name|SemanticException
block|{
if|if
condition|(
name|joinCond
operator|==
literal|null
condition|)
return|return;
switch|switch
condition|(
name|joinCond
operator|.
name|getToken
argument_list|()
operator|.
name|getType
argument_list|()
condition|)
block|{
case|case
name|HiveParser
operator|.
name|KW_OR
case|:
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|INVALID_JOIN_CONDITION_3
operator|.
name|getMsg
argument_list|(
name|joinCond
argument_list|)
argument_list|)
throw|;
case|case
name|HiveParser
operator|.
name|KW_AND
case|:
name|parseJoinCondition
argument_list|(
name|joinTree
argument_list|,
operator|(
name|ASTNode
operator|)
name|joinCond
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
argument_list|,
name|leftSrc
argument_list|)
expr_stmt|;
name|parseJoinCondition
argument_list|(
name|joinTree
argument_list|,
operator|(
name|ASTNode
operator|)
name|joinCond
operator|.
name|getChild
argument_list|(
literal|1
argument_list|)
argument_list|,
name|leftSrc
argument_list|)
expr_stmt|;
break|break;
case|case
name|HiveParser
operator|.
name|EQUAL
case|:
name|ASTNode
name|leftCondn
init|=
operator|(
name|ASTNode
operator|)
name|joinCond
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|Vector
argument_list|<
name|String
argument_list|>
name|leftCondAl1
init|=
operator|new
name|Vector
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
name|Vector
argument_list|<
name|String
argument_list|>
name|leftCondAl2
init|=
operator|new
name|Vector
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
name|parseJoinCondPopulateAlias
argument_list|(
name|joinTree
argument_list|,
name|leftCondn
argument_list|,
name|leftCondAl1
argument_list|,
name|leftCondAl2
argument_list|)
expr_stmt|;
name|ASTNode
name|rightCondn
init|=
operator|(
name|ASTNode
operator|)
name|joinCond
operator|.
name|getChild
argument_list|(
literal|1
argument_list|)
decl_stmt|;
name|Vector
argument_list|<
name|String
argument_list|>
name|rightCondAl1
init|=
operator|new
name|Vector
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
name|Vector
argument_list|<
name|String
argument_list|>
name|rightCondAl2
init|=
operator|new
name|Vector
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
name|parseJoinCondPopulateAlias
argument_list|(
name|joinTree
argument_list|,
name|rightCondn
argument_list|,
name|rightCondAl1
argument_list|,
name|rightCondAl2
argument_list|)
expr_stmt|;
comment|// is it a filter or a join condition
if|if
condition|(
operator|(
operator|(
name|leftCondAl1
operator|.
name|size
argument_list|()
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|leftCondAl2
operator|.
name|size
argument_list|()
operator|!=
literal|0
operator|)
operator|)
operator|||
operator|(
operator|(
name|rightCondAl1
operator|.
name|size
argument_list|()
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|rightCondAl2
operator|.
name|size
argument_list|()
operator|!=
literal|0
operator|)
operator|)
condition|)
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|INVALID_JOIN_CONDITION_1
operator|.
name|getMsg
argument_list|(
name|joinCond
argument_list|)
argument_list|)
throw|;
if|if
condition|(
name|leftCondAl1
operator|.
name|size
argument_list|()
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|rightCondAl1
operator|.
name|size
argument_list|()
operator|!=
literal|0
operator|)
operator|||
operator|(
operator|(
name|rightCondAl1
operator|.
name|size
argument_list|()
operator|==
literal|0
operator|)
operator|&&
operator|(
name|rightCondAl2
operator|.
name|size
argument_list|()
operator|==
literal|0
operator|)
operator|)
condition|)
name|joinTree
operator|.
name|getFilters
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|add
argument_list|(
name|joinCond
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|rightCondAl2
operator|.
name|size
argument_list|()
operator|!=
literal|0
condition|)
block|{
name|populateAliases
argument_list|(
name|leftCondAl1
argument_list|,
name|leftCondAl2
argument_list|,
name|leftCondn
argument_list|,
name|joinTree
argument_list|,
name|leftSrc
argument_list|)
expr_stmt|;
name|populateAliases
argument_list|(
name|rightCondAl1
argument_list|,
name|rightCondAl2
argument_list|,
name|rightCondn
argument_list|,
name|joinTree
argument_list|,
name|leftSrc
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|leftCondAl2
operator|.
name|size
argument_list|()
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|rightCondAl2
operator|.
name|size
argument_list|()
operator|!=
literal|0
operator|)
operator|||
operator|(
operator|(
name|rightCondAl1
operator|.
name|size
argument_list|()
operator|==
literal|0
operator|)
operator|&&
operator|(
name|rightCondAl2
operator|.
name|size
argument_list|()
operator|==
literal|0
operator|)
operator|)
condition|)
name|joinTree
operator|.
name|getFilters
argument_list|()
operator|.
name|get
argument_list|(
literal|1
argument_list|)
operator|.
name|add
argument_list|(
name|joinCond
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|rightCondAl1
operator|.
name|size
argument_list|()
operator|!=
literal|0
condition|)
block|{
name|populateAliases
argument_list|(
name|leftCondAl1
argument_list|,
name|leftCondAl2
argument_list|,
name|leftCondn
argument_list|,
name|joinTree
argument_list|,
name|leftSrc
argument_list|)
expr_stmt|;
name|populateAliases
argument_list|(
name|rightCondAl1
argument_list|,
name|rightCondAl2
argument_list|,
name|rightCondn
argument_list|,
name|joinTree
argument_list|,
name|leftSrc
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|rightCondAl1
operator|.
name|size
argument_list|()
operator|!=
literal|0
condition|)
name|joinTree
operator|.
name|getFilters
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|add
argument_list|(
name|joinCond
argument_list|)
expr_stmt|;
else|else
name|joinTree
operator|.
name|getFilters
argument_list|()
operator|.
name|get
argument_list|(
literal|1
argument_list|)
operator|.
name|add
argument_list|(
name|joinCond
argument_list|)
expr_stmt|;
break|break;
default|default:
name|boolean
name|isFunction
init|=
operator|(
name|joinCond
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_FUNCTION
operator|)
decl_stmt|;
comment|// Create all children
name|int
name|childrenBegin
init|=
operator|(
name|isFunction
condition|?
literal|1
else|:
literal|0
operator|)
decl_stmt|;
name|ArrayList
argument_list|<
name|Vector
argument_list|<
name|String
argument_list|>
argument_list|>
name|leftAlias
init|=
operator|new
name|ArrayList
argument_list|<
name|Vector
argument_list|<
name|String
argument_list|>
argument_list|>
argument_list|(
name|joinCond
operator|.
name|getChildCount
argument_list|()
operator|-
name|childrenBegin
argument_list|)
decl_stmt|;
name|ArrayList
argument_list|<
name|Vector
argument_list|<
name|String
argument_list|>
argument_list|>
name|rightAlias
init|=
operator|new
name|ArrayList
argument_list|<
name|Vector
argument_list|<
name|String
argument_list|>
argument_list|>
argument_list|(
name|joinCond
operator|.
name|getChildCount
argument_list|()
operator|-
name|childrenBegin
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|ci
init|=
literal|0
init|;
name|ci
operator|<
name|joinCond
operator|.
name|getChildCount
argument_list|()
operator|-
name|childrenBegin
condition|;
name|ci
operator|++
control|)
block|{
name|Vector
argument_list|<
name|String
argument_list|>
name|left
init|=
operator|new
name|Vector
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
name|Vector
argument_list|<
name|String
argument_list|>
name|right
init|=
operator|new
name|Vector
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
name|leftAlias
operator|.
name|add
argument_list|(
name|left
argument_list|)
expr_stmt|;
name|rightAlias
operator|.
name|add
argument_list|(
name|right
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|int
name|ci
init|=
name|childrenBegin
init|;
name|ci
operator|<
name|joinCond
operator|.
name|getChildCount
argument_list|()
condition|;
name|ci
operator|++
control|)
name|parseJoinCondPopulateAlias
argument_list|(
name|joinTree
argument_list|,
operator|(
name|ASTNode
operator|)
name|joinCond
operator|.
name|getChild
argument_list|(
name|ci
argument_list|)
argument_list|,
name|leftAlias
operator|.
name|get
argument_list|(
name|ci
operator|-
name|childrenBegin
argument_list|)
argument_list|,
name|rightAlias
operator|.
name|get
argument_list|(
name|ci
operator|-
name|childrenBegin
argument_list|)
argument_list|)
expr_stmt|;
name|boolean
name|leftAliasNull
init|=
literal|true
decl_stmt|;
for|for
control|(
name|Vector
argument_list|<
name|String
argument_list|>
name|left
range|:
name|leftAlias
control|)
block|{
if|if
condition|(
name|left
operator|.
name|size
argument_list|()
operator|!=
literal|0
condition|)
block|{
name|leftAliasNull
operator|=
literal|false
expr_stmt|;
break|break;
block|}
block|}
name|boolean
name|rightAliasNull
init|=
literal|true
decl_stmt|;
for|for
control|(
name|Vector
argument_list|<
name|String
argument_list|>
name|right
range|:
name|rightAlias
control|)
block|{
if|if
condition|(
name|right
operator|.
name|size
argument_list|()
operator|!=
literal|0
condition|)
block|{
name|rightAliasNull
operator|=
literal|false
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|leftAliasNull
operator|&&
operator|!
name|rightAliasNull
condition|)
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|INVALID_JOIN_CONDITION_1
operator|.
name|getMsg
argument_list|(
name|joinCond
argument_list|)
argument_list|)
throw|;
if|if
condition|(
operator|!
name|leftAliasNull
condition|)
name|joinTree
operator|.
name|getFilters
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|add
argument_list|(
name|joinCond
argument_list|)
expr_stmt|;
else|else
name|joinTree
operator|.
name|getFilters
argument_list|()
operator|.
name|get
argument_list|(
literal|1
argument_list|)
operator|.
name|add
argument_list|(
name|joinCond
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"nls"
argument_list|)
specifier|public
parameter_list|<
name|T
extends|extends
name|Serializable
parameter_list|>
name|Operator
argument_list|<
name|T
argument_list|>
name|putOpInsertMap
parameter_list|(
name|Operator
argument_list|<
name|T
argument_list|>
name|op
parameter_list|,
name|RowResolver
name|rr
parameter_list|)
block|{
name|OpParseContext
name|ctx
init|=
operator|new
name|OpParseContext
argument_list|(
name|rr
argument_list|)
decl_stmt|;
name|opParseCtx
operator|.
name|put
argument_list|(
name|op
argument_list|,
name|ctx
argument_list|)
expr_stmt|;
return|return
name|op
return|;
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"nls"
argument_list|)
specifier|private
name|Operator
name|genFilterPlan
parameter_list|(
name|String
name|dest
parameter_list|,
name|QB
name|qb
parameter_list|,
name|Operator
name|input
parameter_list|)
throws|throws
name|SemanticException
block|{
name|ASTNode
name|whereExpr
init|=
name|qb
operator|.
name|getParseInfo
argument_list|()
operator|.
name|getWhrForClause
argument_list|(
name|dest
argument_list|)
decl_stmt|;
return|return
name|genFilterPlan
argument_list|(
name|qb
argument_list|,
operator|(
name|ASTNode
operator|)
name|whereExpr
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
argument_list|,
name|input
argument_list|)
return|;
block|}
comment|/**    * create a filter plan. The condition and the inputs are specified.    * @param qb current query block    * @param condn The condition to be resolved    * @param input the input operator    */
annotation|@
name|SuppressWarnings
argument_list|(
literal|"nls"
argument_list|)
specifier|private
name|Operator
name|genFilterPlan
parameter_list|(
name|QB
name|qb
parameter_list|,
name|ASTNode
name|condn
parameter_list|,
name|Operator
name|input
parameter_list|)
throws|throws
name|SemanticException
block|{
name|OpParseContext
name|inputCtx
init|=
name|opParseCtx
operator|.
name|get
argument_list|(
name|input
argument_list|)
decl_stmt|;
name|RowResolver
name|inputRR
init|=
name|inputCtx
operator|.
name|getRR
argument_list|()
decl_stmt|;
name|Operator
name|output
init|=
name|putOpInsertMap
argument_list|(
name|OperatorFactory
operator|.
name|getAndMakeChild
argument_list|(
operator|new
name|filterDesc
argument_list|(
name|genExprNodeDesc
argument_list|(
name|condn
argument_list|,
name|inputRR
argument_list|)
argument_list|,
literal|false
argument_list|)
argument_list|,
operator|new
name|RowSchema
argument_list|(
name|inputRR
operator|.
name|getColumnInfos
argument_list|()
argument_list|)
argument_list|,
name|input
argument_list|)
argument_list|,
name|inputRR
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Created Filter Plan for "
operator|+
name|qb
operator|.
name|getId
argument_list|()
operator|+
literal|" row schema: "
operator|+
name|inputRR
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|output
return|;
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"nls"
argument_list|)
specifier|private
name|Integer
name|genColListRegex
parameter_list|(
name|String
name|colRegex
parameter_list|,
name|String
name|tabAlias
parameter_list|,
name|String
name|alias
parameter_list|,
name|ASTNode
name|sel
parameter_list|,
name|ArrayList
argument_list|<
name|exprNodeDesc
argument_list|>
name|col_list
parameter_list|,
name|RowResolver
name|input
parameter_list|,
name|Integer
name|pos
parameter_list|,
name|RowResolver
name|output
parameter_list|)
throws|throws
name|SemanticException
block|{
comment|// The table alias should exist
if|if
condition|(
name|tabAlias
operator|!=
literal|null
operator|&&
operator|!
name|input
operator|.
name|hasTableAlias
argument_list|(
name|tabAlias
argument_list|)
condition|)
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|INVALID_TABLE_ALIAS
operator|.
name|getMsg
argument_list|(
name|sel
argument_list|)
argument_list|)
throw|;
comment|// TODO: Have to put in the support for AS clause
name|Pattern
name|regex
init|=
literal|null
decl_stmt|;
try|try
block|{
name|regex
operator|=
name|Pattern
operator|.
name|compile
argument_list|(
name|colRegex
argument_list|,
name|Pattern
operator|.
name|CASE_INSENSITIVE
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|PatternSyntaxException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|INVALID_COLUMN
operator|.
name|getMsg
argument_list|(
name|sel
argument_list|,
name|e
operator|.
name|getMessage
argument_list|()
argument_list|)
argument_list|)
throw|;
block|}
name|int
name|matched
init|=
literal|0
decl_stmt|;
comment|// This is the tab.* case
comment|// In this case add all the columns to the fieldList
comment|// from the input schema
for|for
control|(
name|ColumnInfo
name|colInfo
range|:
name|input
operator|.
name|getColumnInfos
argument_list|()
control|)
block|{
name|String
name|name
init|=
name|colInfo
operator|.
name|getInternalName
argument_list|()
decl_stmt|;
name|String
index|[]
name|tmp
init|=
name|input
operator|.
name|reverseLookup
argument_list|(
name|name
argument_list|)
decl_stmt|;
comment|// Skip the colinfos which are not for this particular alias
if|if
condition|(
name|tabAlias
operator|!=
literal|null
operator|&&
operator|!
name|tmp
index|[
literal|0
index|]
operator|.
name|equalsIgnoreCase
argument_list|(
name|tabAlias
argument_list|)
condition|)
block|{
continue|continue;
block|}
comment|// Not matching the regex?
if|if
condition|(
operator|!
name|regex
operator|.
name|matcher
argument_list|(
name|tmp
index|[
literal|1
index|]
argument_list|)
operator|.
name|matches
argument_list|()
condition|)
block|{
continue|continue;
block|}
name|exprNodeColumnDesc
name|expr
init|=
operator|new
name|exprNodeColumnDesc
argument_list|(
name|colInfo
operator|.
name|getType
argument_list|()
argument_list|,
name|name
argument_list|,
name|colInfo
operator|.
name|getTabAlias
argument_list|()
argument_list|,
name|colInfo
operator|.
name|getIsPartitionCol
argument_list|()
argument_list|)
decl_stmt|;
name|col_list
operator|.
name|add
argument_list|(
name|expr
argument_list|)
expr_stmt|;
name|output
operator|.
name|put
argument_list|(
name|tmp
index|[
literal|0
index|]
argument_list|,
name|tmp
index|[
literal|1
index|]
argument_list|,
operator|new
name|ColumnInfo
argument_list|(
name|getColumnInternalName
argument_list|(
name|pos
argument_list|)
argument_list|,
name|colInfo
operator|.
name|getType
argument_list|()
argument_list|,
name|colInfo
operator|.
name|getTabAlias
argument_list|()
argument_list|,
name|colInfo
operator|.
name|getIsPartitionCol
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|pos
operator|=
name|Integer
operator|.
name|valueOf
argument_list|(
name|pos
operator|.
name|intValue
argument_list|()
operator|+
literal|1
argument_list|)
expr_stmt|;
name|matched
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|matched
operator|==
literal|0
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|INVALID_COLUMN
operator|.
name|getMsg
argument_list|(
name|sel
argument_list|)
argument_list|)
throw|;
block|}
return|return
name|pos
return|;
block|}
specifier|public
specifier|static
name|String
name|getColumnInternalName
parameter_list|(
name|int
name|pos
parameter_list|)
block|{
return|return
name|HiveConf
operator|.
name|getColumnInternalName
argument_list|(
name|pos
argument_list|)
return|;
block|}
comment|/**    * If the user script command needs any modifications - do it here    */
specifier|private
name|String
name|getFixedCmd
parameter_list|(
name|String
name|cmd
parameter_list|)
block|{
name|SessionState
name|ss
init|=
name|SessionState
operator|.
name|get
argument_list|()
decl_stmt|;
if|if
condition|(
name|ss
operator|==
literal|null
condition|)
return|return
name|cmd
return|;
comment|// for local mode - replace any references to packaged files by name with
comment|// the reference to the original file path
if|if
condition|(
name|ss
operator|.
name|getConf
argument_list|()
operator|.
name|get
argument_list|(
literal|"mapred.job.tracker"
argument_list|,
literal|"local"
argument_list|)
operator|.
name|equals
argument_list|(
literal|"local"
argument_list|)
condition|)
block|{
name|Set
argument_list|<
name|String
argument_list|>
name|files
init|=
name|ss
operator|.
name|list_resource
argument_list|(
name|SessionState
operator|.
name|ResourceType
operator|.
name|FILE
argument_list|,
literal|null
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|files
operator|!=
literal|null
operator|)
operator|&&
operator|!
name|files
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|int
name|end
init|=
name|cmd
operator|.
name|indexOf
argument_list|(
literal|" "
argument_list|)
decl_stmt|;
name|String
name|prog
init|=
operator|(
name|end
operator|==
operator|-
literal|1
operator|)
condition|?
name|cmd
else|:
name|cmd
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|end
argument_list|)
decl_stmt|;
name|String
name|args
init|=
operator|(
name|end
operator|==
operator|-
literal|1
operator|)
condition|?
literal|""
else|:
name|cmd
operator|.
name|substring
argument_list|(
name|end
argument_list|,
name|cmd
operator|.
name|length
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|String
name|oneFile
range|:
name|files
control|)
block|{
name|Path
name|p
init|=
operator|new
name|Path
argument_list|(
name|oneFile
argument_list|)
decl_stmt|;
if|if
condition|(
name|p
operator|.
name|getName
argument_list|()
operator|.
name|equals
argument_list|(
name|prog
argument_list|)
condition|)
block|{
name|cmd
operator|=
name|oneFile
operator|+
name|args
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
return|return
name|cmd
return|;
block|}
specifier|private
name|tableDesc
name|getTableDescFromSerDe
parameter_list|(
name|ASTNode
name|child
parameter_list|,
name|String
name|cols
parameter_list|,
name|String
name|colTypes
parameter_list|,
name|boolean
name|defaultCols
parameter_list|)
throws|throws
name|SemanticException
block|{
if|if
condition|(
name|child
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_SERDENAME
condition|)
block|{
name|String
name|serdeName
init|=
name|unescapeSQLString
argument_list|(
name|child
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getText
argument_list|()
argument_list|)
decl_stmt|;
name|Class
argument_list|<
name|?
extends|extends
name|Deserializer
argument_list|>
name|serdeClass
init|=
literal|null
decl_stmt|;
try|try
block|{
name|serdeClass
operator|=
operator|(
name|Class
argument_list|<
name|?
extends|extends
name|Deserializer
argument_list|>
operator|)
name|Class
operator|.
name|forName
argument_list|(
name|serdeName
argument_list|,
literal|true
argument_list|,
name|JavaUtils
operator|.
name|getClassLoader
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|ClassNotFoundException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|e
argument_list|)
throw|;
block|}
name|tableDesc
name|tblDesc
init|=
name|PlanUtils
operator|.
name|getTableDesc
argument_list|(
name|serdeClass
argument_list|,
name|Integer
operator|.
name|toString
argument_list|(
name|Utilities
operator|.
name|tabCode
argument_list|)
argument_list|,
name|cols
argument_list|,
name|colTypes
argument_list|,
name|defaultCols
argument_list|,
literal|true
argument_list|)
decl_stmt|;
comment|// copy all the properties
if|if
condition|(
name|child
operator|.
name|getChildCount
argument_list|()
operator|==
literal|2
condition|)
block|{
name|ASTNode
name|prop
init|=
call|(
name|ASTNode
call|)
argument_list|(
operator|(
name|ASTNode
operator|)
name|child
operator|.
name|getChild
argument_list|(
literal|1
argument_list|)
argument_list|)
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|propChild
init|=
literal|0
init|;
name|propChild
operator|<
name|prop
operator|.
name|getChildCount
argument_list|()
condition|;
name|propChild
operator|++
control|)
block|{
name|String
name|key
init|=
name|unescapeSQLString
argument_list|(
name|prop
operator|.
name|getChild
argument_list|(
name|propChild
argument_list|)
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getText
argument_list|()
argument_list|)
decl_stmt|;
name|String
name|value
init|=
name|unescapeSQLString
argument_list|(
name|prop
operator|.
name|getChild
argument_list|(
name|propChild
argument_list|)
operator|.
name|getChild
argument_list|(
literal|1
argument_list|)
operator|.
name|getText
argument_list|()
argument_list|)
decl_stmt|;
name|tblDesc
operator|.
name|getProperties
argument_list|()
operator|.
name|setProperty
argument_list|(
name|key
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|tblDesc
return|;
block|}
elseif|else
if|if
condition|(
name|child
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_SERDEPROPS
condition|)
block|{
name|tableDesc
name|tblDesc
init|=
name|PlanUtils
operator|.
name|getDefaultTableDesc
argument_list|(
name|Integer
operator|.
name|toString
argument_list|(
name|Utilities
operator|.
name|ctrlaCode
argument_list|)
argument_list|,
name|cols
argument_list|,
name|colTypes
argument_list|,
name|defaultCols
argument_list|)
decl_stmt|;
name|int
name|numChildRowFormat
init|=
name|child
operator|.
name|getChildCount
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|numC
init|=
literal|0
init|;
name|numC
operator|<
name|numChildRowFormat
condition|;
name|numC
operator|++
control|)
block|{
name|ASTNode
name|rowChild
init|=
operator|(
name|ASTNode
operator|)
name|child
operator|.
name|getChild
argument_list|(
name|numC
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|rowChild
operator|.
name|getToken
argument_list|()
operator|.
name|getType
argument_list|()
condition|)
block|{
case|case
name|HiveParser
operator|.
name|TOK_TABLEROWFORMATFIELD
case|:
name|String
name|fieldDelim
init|=
name|unescapeSQLString
argument_list|(
name|rowChild
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getText
argument_list|()
argument_list|)
decl_stmt|;
name|tblDesc
operator|.
name|getProperties
argument_list|()
operator|.
name|setProperty
argument_list|(
name|Constants
operator|.
name|FIELD_DELIM
argument_list|,
name|fieldDelim
argument_list|)
expr_stmt|;
name|tblDesc
operator|.
name|getProperties
argument_list|()
operator|.
name|setProperty
argument_list|(
name|Constants
operator|.
name|SERIALIZATION_FORMAT
argument_list|,
name|fieldDelim
argument_list|)
expr_stmt|;
if|if
condition|(
name|rowChild
operator|.
name|getChildCount
argument_list|()
operator|>=
literal|2
condition|)
block|{
name|String
name|fieldEscape
init|=
name|unescapeSQLString
argument_list|(
name|rowChild
operator|.
name|getChild
argument_list|(
literal|1
argument_list|)
operator|.
name|getText
argument_list|()
argument_list|)
decl_stmt|;
name|tblDesc
operator|.
name|getProperties
argument_list|()
operator|.
name|setProperty
argument_list|(
name|Constants
operator|.
name|ESCAPE_CHAR
argument_list|,
name|fieldDelim
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|HiveParser
operator|.
name|TOK_TABLEROWFORMATCOLLITEMS
case|:
name|tblDesc
operator|.
name|getProperties
argument_list|()
operator|.
name|setProperty
argument_list|(
name|Constants
operator|.
name|COLLECTION_DELIM
argument_list|,
name|unescapeSQLString
argument_list|(
name|rowChild
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getText
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|HiveParser
operator|.
name|TOK_TABLEROWFORMATMAPKEYS
case|:
name|tblDesc
operator|.
name|getProperties
argument_list|()
operator|.
name|setProperty
argument_list|(
name|Constants
operator|.
name|MAPKEY_DELIM
argument_list|,
name|unescapeSQLString
argument_list|(
name|rowChild
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getText
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|HiveParser
operator|.
name|TOK_TABLEROWFORMATLINES
case|:
name|tblDesc
operator|.
name|getProperties
argument_list|()
operator|.
name|setProperty
argument_list|(
name|Constants
operator|.
name|LINE_DELIM
argument_list|,
name|unescapeSQLString
argument_list|(
name|rowChild
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getText
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
assert|assert
literal|false
assert|;
block|}
block|}
return|return
name|tblDesc
return|;
block|}
comment|// should never come here
return|return
literal|null
return|;
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"nls"
argument_list|)
specifier|private
name|Operator
name|genScriptPlan
parameter_list|(
name|ASTNode
name|trfm
parameter_list|,
name|QB
name|qb
parameter_list|,
name|Operator
name|input
parameter_list|)
throws|throws
name|SemanticException
block|{
comment|// If there is no "AS" clause, the output schema will be "key,value"
name|ArrayList
argument_list|<
name|ColumnInfo
argument_list|>
name|outputCols
init|=
operator|new
name|ArrayList
argument_list|<
name|ColumnInfo
argument_list|>
argument_list|()
decl_stmt|;
name|int
name|inputSerDeNum
init|=
literal|1
decl_stmt|;
name|int
name|outputSerDeNum
init|=
literal|3
decl_stmt|,
name|outputRecordReaderNum
init|=
literal|4
decl_stmt|;
name|int
name|outputColsNum
init|=
literal|5
decl_stmt|;
name|boolean
name|outputColNames
init|=
literal|false
decl_stmt|,
name|outputColSchemas
init|=
literal|false
decl_stmt|;
name|int
name|execPos
init|=
literal|2
decl_stmt|;
name|boolean
name|defaultOutputCols
init|=
literal|false
decl_stmt|;
comment|// Go over all the children
if|if
condition|(
name|trfm
operator|.
name|getChildCount
argument_list|()
operator|>
name|outputColsNum
condition|)
block|{
name|ASTNode
name|outCols
init|=
operator|(
name|ASTNode
operator|)
name|trfm
operator|.
name|getChild
argument_list|(
name|outputColsNum
argument_list|)
decl_stmt|;
if|if
condition|(
name|outCols
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_ALIASLIST
condition|)
name|outputColNames
operator|=
literal|true
expr_stmt|;
elseif|else
if|if
condition|(
name|outCols
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_TABCOLLIST
condition|)
name|outputColSchemas
operator|=
literal|true
expr_stmt|;
block|}
comment|// If column type is not specified, use a string
if|if
condition|(
operator|!
name|outputColNames
operator|&&
operator|!
name|outputColSchemas
condition|)
block|{
name|outputCols
operator|.
name|add
argument_list|(
operator|new
name|ColumnInfo
argument_list|(
literal|"key"
argument_list|,
name|TypeInfoFactory
operator|.
name|stringTypeInfo
argument_list|,
literal|null
argument_list|,
literal|false
argument_list|)
argument_list|)
expr_stmt|;
name|outputCols
operator|.
name|add
argument_list|(
operator|new
name|ColumnInfo
argument_list|(
literal|"value"
argument_list|,
name|TypeInfoFactory
operator|.
name|stringTypeInfo
argument_list|,
literal|null
argument_list|,
literal|false
argument_list|)
argument_list|)
expr_stmt|;
name|defaultOutputCols
operator|=
literal|true
expr_stmt|;
block|}
else|else
block|{
name|ASTNode
name|collist
init|=
operator|(
name|ASTNode
operator|)
name|trfm
operator|.
name|getChild
argument_list|(
name|outputColsNum
argument_list|)
decl_stmt|;
name|int
name|ccount
init|=
name|collist
operator|.
name|getChildCount
argument_list|()
decl_stmt|;
if|if
condition|(
name|outputColNames
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|ccount
condition|;
operator|++
name|i
control|)
block|{
name|outputCols
operator|.
name|add
argument_list|(
operator|new
name|ColumnInfo
argument_list|(
name|unescapeIdentifier
argument_list|(
operator|(
operator|(
name|ASTNode
operator|)
name|collist
operator|.
name|getChild
argument_list|(
name|i
argument_list|)
operator|)
operator|.
name|getText
argument_list|()
argument_list|)
argument_list|,
name|TypeInfoFactory
operator|.
name|stringTypeInfo
argument_list|,
literal|null
argument_list|,
literal|false
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|ccount
condition|;
operator|++
name|i
control|)
block|{
name|ASTNode
name|child
init|=
operator|(
name|ASTNode
operator|)
name|collist
operator|.
name|getChild
argument_list|(
name|i
argument_list|)
decl_stmt|;
assert|assert
name|child
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_TABCOL
assert|;
name|outputCols
operator|.
name|add
argument_list|(
operator|new
name|ColumnInfo
argument_list|(
name|unescapeIdentifier
argument_list|(
operator|(
operator|(
name|ASTNode
operator|)
name|child
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|)
operator|.
name|getText
argument_list|()
argument_list|)
argument_list|,
name|TypeInfoUtils
operator|.
name|getTypeInfoFromTypeString
argument_list|(
name|DDLSemanticAnalyzer
operator|.
name|getTypeName
argument_list|(
operator|(
operator|(
name|ASTNode
operator|)
name|child
operator|.
name|getChild
argument_list|(
literal|1
argument_list|)
operator|)
operator|.
name|getType
argument_list|()
argument_list|)
argument_list|)
argument_list|,
literal|null
argument_list|,
literal|false
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|RowResolver
name|out_rwsch
init|=
operator|new
name|RowResolver
argument_list|()
decl_stmt|;
name|StringBuilder
name|columns
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|StringBuilder
name|columnTypes
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|outputCols
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|i
operator|!=
literal|0
condition|)
block|{
name|columns
operator|.
name|append
argument_list|(
literal|","
argument_list|)
expr_stmt|;
name|columnTypes
operator|.
name|append
argument_list|(
literal|","
argument_list|)
expr_stmt|;
block|}
name|columns
operator|.
name|append
argument_list|(
name|outputCols
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|getInternalName
argument_list|()
argument_list|)
expr_stmt|;
name|columnTypes
operator|.
name|append
argument_list|(
name|outputCols
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|getType
argument_list|()
operator|.
name|getTypeName
argument_list|()
argument_list|)
expr_stmt|;
name|out_rwsch
operator|.
name|put
argument_list|(
name|qb
operator|.
name|getParseInfo
argument_list|()
operator|.
name|getAlias
argument_list|()
argument_list|,
name|outputCols
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|getInternalName
argument_list|()
argument_list|,
name|outputCols
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|StringBuilder
name|inpColumns
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|StringBuilder
name|inpColumnTypes
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|Vector
argument_list|<
name|ColumnInfo
argument_list|>
name|inputSchema
init|=
name|opParseCtx
operator|.
name|get
argument_list|(
name|input
argument_list|)
operator|.
name|getRR
argument_list|()
operator|.
name|getColumnInfos
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|inputSchema
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|i
operator|!=
literal|0
condition|)
block|{
name|inpColumns
operator|.
name|append
argument_list|(
literal|","
argument_list|)
expr_stmt|;
name|inpColumnTypes
operator|.
name|append
argument_list|(
literal|","
argument_list|)
expr_stmt|;
block|}
name|inpColumns
operator|.
name|append
argument_list|(
name|inputSchema
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|getInternalName
argument_list|()
argument_list|)
expr_stmt|;
name|inpColumnTypes
operator|.
name|append
argument_list|(
name|inputSchema
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|getType
argument_list|()
operator|.
name|getTypeName
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|tableDesc
name|outInfo
decl_stmt|;
name|tableDesc
name|inInfo
decl_stmt|;
name|String
name|defaultSerdeName
init|=
name|conf
operator|.
name|getVar
argument_list|(
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVESCRIPTSERDE
argument_list|)
decl_stmt|;
name|Class
argument_list|<
name|?
extends|extends
name|Deserializer
argument_list|>
name|serde
decl_stmt|;
try|try
block|{
name|serde
operator|=
operator|(
name|Class
argument_list|<
name|?
extends|extends
name|Deserializer
argument_list|>
operator|)
name|Class
operator|.
name|forName
argument_list|(
name|defaultSerdeName
argument_list|,
literal|true
argument_list|,
name|JavaUtils
operator|.
name|getClassLoader
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|ClassNotFoundException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|e
argument_list|)
throw|;
block|}
comment|// Input and Output Serdes
if|if
condition|(
name|trfm
operator|.
name|getChild
argument_list|(
name|inputSerDeNum
argument_list|)
operator|.
name|getChildCount
argument_list|()
operator|>
literal|0
condition|)
name|inInfo
operator|=
name|getTableDescFromSerDe
argument_list|(
call|(
name|ASTNode
call|)
argument_list|(
operator|(
operator|(
name|ASTNode
operator|)
name|trfm
operator|.
name|getChild
argument_list|(
name|inputSerDeNum
argument_list|)
operator|)
argument_list|)
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
argument_list|,
name|inpColumns
operator|.
name|toString
argument_list|()
argument_list|,
name|inpColumnTypes
operator|.
name|toString
argument_list|()
argument_list|,
literal|false
argument_list|)
expr_stmt|;
else|else
name|inInfo
operator|=
name|PlanUtils
operator|.
name|getTableDesc
argument_list|(
name|serde
argument_list|,
name|Integer
operator|.
name|toString
argument_list|(
name|Utilities
operator|.
name|tabCode
argument_list|)
argument_list|,
name|inpColumns
operator|.
name|toString
argument_list|()
argument_list|,
name|inpColumnTypes
operator|.
name|toString
argument_list|()
argument_list|,
literal|false
argument_list|,
literal|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|trfm
operator|.
name|getChild
argument_list|(
name|inputSerDeNum
argument_list|)
operator|.
name|getChildCount
argument_list|()
operator|>
literal|0
condition|)
name|outInfo
operator|=
name|getTableDescFromSerDe
argument_list|(
call|(
name|ASTNode
call|)
argument_list|(
operator|(
operator|(
name|ASTNode
operator|)
name|trfm
operator|.
name|getChild
argument_list|(
name|outputSerDeNum
argument_list|)
operator|)
argument_list|)
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
argument_list|,
name|columns
operator|.
name|toString
argument_list|()
argument_list|,
name|columnTypes
operator|.
name|toString
argument_list|()
argument_list|,
literal|false
argument_list|)
expr_stmt|;
comment|// This is for backward compatibility. If the user did not specify the output column list, we assume that there are 2 columns: key and value.
comment|// However, if the script outputs: col1, col2, col3 seperated by TAB, the requirement is: key is col and value is (col2 TAB col3)
else|else
name|outInfo
operator|=
name|PlanUtils
operator|.
name|getTableDesc
argument_list|(
name|serde
argument_list|,
name|Integer
operator|.
name|toString
argument_list|(
name|Utilities
operator|.
name|tabCode
argument_list|)
argument_list|,
name|columns
operator|.
name|toString
argument_list|()
argument_list|,
name|columnTypes
operator|.
name|toString
argument_list|()
argument_list|,
name|defaultOutputCols
argument_list|)
expr_stmt|;
comment|// Output record readers
name|Class
argument_list|<
name|?
extends|extends
name|RecordReader
argument_list|>
name|outRecordReader
init|=
name|getRecordReader
argument_list|(
operator|(
name|ASTNode
operator|)
name|trfm
operator|.
name|getChild
argument_list|(
name|outputRecordReaderNum
argument_list|)
argument_list|)
decl_stmt|;
name|Operator
name|output
init|=
name|putOpInsertMap
argument_list|(
name|OperatorFactory
operator|.
name|getAndMakeChild
argument_list|(
operator|new
name|scriptDesc
argument_list|(
name|getFixedCmd
argument_list|(
name|stripQuotes
argument_list|(
name|trfm
operator|.
name|getChild
argument_list|(
name|execPos
argument_list|)
operator|.
name|getText
argument_list|()
argument_list|)
argument_list|)
argument_list|,
name|inInfo
argument_list|,
name|outInfo
argument_list|,
name|outRecordReader
argument_list|)
argument_list|,
operator|new
name|RowSchema
argument_list|(
name|out_rwsch
operator|.
name|getColumnInfos
argument_list|()
argument_list|)
argument_list|,
name|input
argument_list|)
argument_list|,
name|out_rwsch
argument_list|)
decl_stmt|;
return|return
name|output
return|;
block|}
specifier|private
name|Class
argument_list|<
name|?
extends|extends
name|RecordReader
argument_list|>
name|getRecordReader
parameter_list|(
name|ASTNode
name|node
parameter_list|)
throws|throws
name|SemanticException
block|{
name|String
name|name
decl_stmt|;
if|if
condition|(
name|node
operator|.
name|getChildCount
argument_list|()
operator|==
literal|0
condition|)
name|name
operator|=
name|conf
operator|.
name|getVar
argument_list|(
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVESCRIPTRECORDREADER
argument_list|)
expr_stmt|;
else|else
name|name
operator|=
name|unescapeSQLString
argument_list|(
name|node
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getText
argument_list|()
argument_list|)
expr_stmt|;
try|try
block|{
return|return
operator|(
name|Class
argument_list|<
name|?
extends|extends
name|RecordReader
argument_list|>
operator|)
name|Class
operator|.
name|forName
argument_list|(
name|name
argument_list|,
literal|true
argument_list|,
name|JavaUtils
operator|.
name|getClassLoader
argument_list|()
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|ClassNotFoundException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
comment|/**    * This function is a wrapper of parseInfo.getGroupByForClause which automatically    * translates SELECT DISTINCT a,b,c to SELECT a,b,c GROUP BY a,b,c.    */
specifier|static
name|List
argument_list|<
name|ASTNode
argument_list|>
name|getGroupByForClause
parameter_list|(
name|QBParseInfo
name|parseInfo
parameter_list|,
name|String
name|dest
parameter_list|)
block|{
if|if
condition|(
name|parseInfo
operator|.
name|getSelForClause
argument_list|(
name|dest
argument_list|)
operator|.
name|getToken
argument_list|()
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_SELECTDI
condition|)
block|{
name|ASTNode
name|selectExprs
init|=
name|parseInfo
operator|.
name|getSelForClause
argument_list|(
name|dest
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|ASTNode
argument_list|>
name|result
init|=
operator|new
name|ArrayList
argument_list|<
name|ASTNode
argument_list|>
argument_list|(
name|selectExprs
operator|==
literal|null
condition|?
literal|0
else|:
name|selectExprs
operator|.
name|getChildCount
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|selectExprs
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|selectExprs
operator|.
name|getChildCount
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
comment|// table.column AS alias
name|ASTNode
name|grpbyExpr
init|=
operator|(
name|ASTNode
operator|)
name|selectExprs
operator|.
name|getChild
argument_list|(
name|i
argument_list|)
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|result
operator|.
name|add
argument_list|(
name|grpbyExpr
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|result
return|;
block|}
else|else
block|{
name|ASTNode
name|grpByExprs
init|=
name|parseInfo
operator|.
name|getGroupByForClause
argument_list|(
name|dest
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|ASTNode
argument_list|>
name|result
init|=
operator|new
name|ArrayList
argument_list|<
name|ASTNode
argument_list|>
argument_list|(
name|grpByExprs
operator|==
literal|null
condition|?
literal|0
else|:
name|grpByExprs
operator|.
name|getChildCount
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|grpByExprs
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|grpByExprs
operator|.
name|getChildCount
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|ASTNode
name|grpbyExpr
init|=
operator|(
name|ASTNode
operator|)
name|grpByExprs
operator|.
name|getChild
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|result
operator|.
name|add
argument_list|(
name|grpbyExpr
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|result
return|;
block|}
block|}
specifier|private
specifier|static
name|String
index|[]
name|getColAlias
parameter_list|(
name|ASTNode
name|selExpr
parameter_list|,
name|String
name|defaultName
parameter_list|,
name|RowResolver
name|inputRR
parameter_list|)
block|{
name|String
name|colAlias
init|=
literal|null
decl_stmt|;
name|String
name|tabAlias
init|=
literal|null
decl_stmt|;
name|String
index|[]
name|colRef
init|=
operator|new
name|String
index|[
literal|2
index|]
decl_stmt|;
if|if
condition|(
name|selExpr
operator|.
name|getChildCount
argument_list|()
operator|==
literal|2
condition|)
block|{
comment|// return zz for "xx + yy AS zz"
name|colAlias
operator|=
name|unescapeIdentifier
argument_list|(
name|selExpr
operator|.
name|getChild
argument_list|(
literal|1
argument_list|)
operator|.
name|getText
argument_list|()
argument_list|)
expr_stmt|;
name|colRef
index|[
literal|0
index|]
operator|=
name|tabAlias
expr_stmt|;
name|colRef
index|[
literal|1
index|]
operator|=
name|colAlias
expr_stmt|;
return|return
name|colRef
return|;
block|}
name|ASTNode
name|root
init|=
operator|(
name|ASTNode
operator|)
name|selExpr
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|root
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_TABLE_OR_COL
condition|)
block|{
name|colAlias
operator|=
name|root
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getText
argument_list|()
expr_stmt|;
name|colRef
index|[
literal|0
index|]
operator|=
name|tabAlias
expr_stmt|;
name|colRef
index|[
literal|1
index|]
operator|=
name|colAlias
expr_stmt|;
return|return
name|colRef
return|;
block|}
if|if
condition|(
name|root
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|DOT
condition|)
block|{
name|ASTNode
name|tab
init|=
operator|(
name|ASTNode
operator|)
name|root
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|tab
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_TABLE_OR_COL
condition|)
block|{
name|String
name|t
init|=
name|unescapeIdentifier
argument_list|(
name|tab
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getText
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|inputRR
operator|.
name|hasTableAlias
argument_list|(
name|t
argument_list|)
condition|)
block|{
name|tabAlias
operator|=
name|t
expr_stmt|;
block|}
block|}
comment|// Return zz for "xx.zz" and "xx.yy.zz"
name|ASTNode
name|col
init|=
operator|(
name|ASTNode
operator|)
name|root
operator|.
name|getChild
argument_list|(
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|col
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|Identifier
condition|)
block|{
name|colAlias
operator|=
name|unescapeIdentifier
argument_list|(
name|col
operator|.
name|getText
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|colAlias
operator|==
literal|null
condition|)
block|{
comment|// Return defaultName if selExpr is not a simple xx.yy.zz
name|colAlias
operator|=
name|defaultName
expr_stmt|;
block|}
name|colRef
index|[
literal|0
index|]
operator|=
name|tabAlias
expr_stmt|;
name|colRef
index|[
literal|1
index|]
operator|=
name|colAlias
expr_stmt|;
return|return
name|colRef
return|;
block|}
comment|/**    * Returns whether the pattern is a regex expression (instead of a normal string).    * Normal string is a string with all alphabets/digits and "_".    */
specifier|private
specifier|static
name|boolean
name|isRegex
parameter_list|(
name|String
name|pattern
parameter_list|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|pattern
operator|.
name|length
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|Character
operator|.
name|isLetterOrDigit
argument_list|(
name|pattern
operator|.
name|charAt
argument_list|(
name|i
argument_list|)
argument_list|)
operator|&&
name|pattern
operator|.
name|charAt
argument_list|(
name|i
argument_list|)
operator|!=
literal|'_'
condition|)
block|{
return|return
literal|true
return|;
block|}
block|}
return|return
literal|false
return|;
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"nls"
argument_list|)
specifier|private
name|Operator
name|genSelectPlan
parameter_list|(
name|String
name|dest
parameter_list|,
name|QB
name|qb
parameter_list|,
name|Operator
name|input
parameter_list|)
throws|throws
name|SemanticException
block|{
name|ASTNode
name|selExprList
init|=
name|qb
operator|.
name|getParseInfo
argument_list|()
operator|.
name|getSelForClause
argument_list|(
name|dest
argument_list|)
decl_stmt|;
name|ArrayList
argument_list|<
name|exprNodeDesc
argument_list|>
name|col_list
init|=
operator|new
name|ArrayList
argument_list|<
name|exprNodeDesc
argument_list|>
argument_list|()
decl_stmt|;
name|RowResolver
name|out_rwsch
init|=
operator|new
name|RowResolver
argument_list|()
decl_stmt|;
name|ASTNode
name|trfm
init|=
literal|null
decl_stmt|;
name|String
name|alias
init|=
name|qb
operator|.
name|getParseInfo
argument_list|()
operator|.
name|getAlias
argument_list|()
decl_stmt|;
name|Integer
name|pos
init|=
name|Integer
operator|.
name|valueOf
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|RowResolver
name|inputRR
init|=
name|opParseCtx
operator|.
name|get
argument_list|(
name|input
argument_list|)
operator|.
name|getRR
argument_list|()
decl_stmt|;
comment|// SELECT * or SELECT TRANSFORM(*)
name|boolean
name|selectStar
init|=
literal|false
decl_stmt|;
name|int
name|posn
init|=
literal|0
decl_stmt|;
name|boolean
name|hintPresent
init|=
operator|(
name|selExprList
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_HINTLIST
operator|)
decl_stmt|;
if|if
condition|(
name|hintPresent
condition|)
block|{
name|posn
operator|++
expr_stmt|;
block|}
name|boolean
name|isInTransform
init|=
operator|(
name|selExprList
operator|.
name|getChild
argument_list|(
name|posn
argument_list|)
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_TRANSFORM
operator|)
decl_stmt|;
if|if
condition|(
name|isInTransform
condition|)
block|{
name|trfm
operator|=
operator|(
name|ASTNode
operator|)
name|selExprList
operator|.
name|getChild
argument_list|(
name|posn
argument_list|)
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
comment|// The list of expressions after SELECT or SELECT TRANSFORM.
name|ASTNode
name|exprList
init|=
operator|(
name|isInTransform
condition|?
operator|(
name|ASTNode
operator|)
name|trfm
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
else|:
name|selExprList
operator|)
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"genSelectPlan: input = "
operator|+
name|inputRR
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
comment|// Iterate over all expression (either after SELECT, or in SELECT TRANSFORM)
for|for
control|(
name|int
name|i
init|=
name|posn
init|;
name|i
operator|<
name|exprList
operator|.
name|getChildCount
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
comment|// child can be EXPR AS ALIAS, or EXPR.
name|ASTNode
name|child
init|=
operator|(
name|ASTNode
operator|)
name|exprList
operator|.
name|getChild
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|boolean
name|hasAsClause
init|=
operator|(
operator|!
name|isInTransform
operator|)
operator|&&
operator|(
name|child
operator|.
name|getChildCount
argument_list|()
operator|==
literal|2
operator|)
decl_stmt|;
comment|// The real expression
name|ASTNode
name|expr
decl_stmt|;
name|String
name|tabAlias
decl_stmt|;
name|String
name|colAlias
decl_stmt|;
if|if
condition|(
name|isInTransform
condition|)
block|{
name|tabAlias
operator|=
literal|null
expr_stmt|;
name|colAlias
operator|=
literal|"_C"
operator|+
name|i
expr_stmt|;
name|expr
operator|=
name|child
expr_stmt|;
block|}
else|else
block|{
name|String
index|[]
name|colRef
init|=
name|getColAlias
argument_list|(
name|child
argument_list|,
literal|"_C"
operator|+
name|i
argument_list|,
name|inputRR
argument_list|)
decl_stmt|;
name|tabAlias
operator|=
name|colRef
index|[
literal|0
index|]
expr_stmt|;
name|colAlias
operator|=
name|colRef
index|[
literal|1
index|]
expr_stmt|;
comment|// Get rid of TOK_SELEXPR
name|expr
operator|=
operator|(
name|ASTNode
operator|)
name|child
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|expr
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_ALLCOLREF
condition|)
block|{
name|pos
operator|=
name|genColListRegex
argument_list|(
literal|".*"
argument_list|,
name|expr
operator|.
name|getChildCount
argument_list|()
operator|==
literal|0
condition|?
literal|null
else|:
name|unescapeIdentifier
argument_list|(
name|expr
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getText
argument_list|()
operator|.
name|toLowerCase
argument_list|()
argument_list|)
argument_list|,
name|alias
argument_list|,
name|expr
argument_list|,
name|col_list
argument_list|,
name|inputRR
argument_list|,
name|pos
argument_list|,
name|out_rwsch
argument_list|)
expr_stmt|;
name|selectStar
operator|=
literal|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|expr
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_TABLE_OR_COL
operator|&&
operator|!
name|hasAsClause
operator|&&
operator|!
name|inputRR
operator|.
name|getIsExprResolver
argument_list|()
operator|&&
name|isRegex
argument_list|(
name|unescapeIdentifier
argument_list|(
name|expr
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getText
argument_list|()
argument_list|)
argument_list|)
condition|)
block|{
comment|// In case the expression is a regex COL.
comment|// This can only happen without AS clause
comment|// We don't allow this for ExprResolver - the Group By case
name|pos
operator|=
name|genColListRegex
argument_list|(
name|unescapeIdentifier
argument_list|(
name|expr
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getText
argument_list|()
argument_list|)
argument_list|,
literal|null
argument_list|,
name|alias
argument_list|,
name|expr
argument_list|,
name|col_list
argument_list|,
name|inputRR
argument_list|,
name|pos
argument_list|,
name|out_rwsch
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|expr
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|DOT
operator|&&
name|expr
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_TABLE_OR_COL
operator|&&
name|inputRR
operator|.
name|hasTableAlias
argument_list|(
name|unescapeIdentifier
argument_list|(
name|expr
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getText
argument_list|()
operator|.
name|toLowerCase
argument_list|()
argument_list|)
argument_list|)
operator|&&
operator|!
name|hasAsClause
operator|&&
operator|!
name|inputRR
operator|.
name|getIsExprResolver
argument_list|()
operator|&&
name|isRegex
argument_list|(
name|unescapeIdentifier
argument_list|(
name|expr
operator|.
name|getChild
argument_list|(
literal|1
argument_list|)
operator|.
name|getText
argument_list|()
argument_list|)
argument_list|)
condition|)
block|{
comment|// In case the expression is TABLE.COL (col can be regex).
comment|// This can only happen without AS clause
comment|// We don't allow this for ExprResolver - the Group By case
name|pos
operator|=
name|genColListRegex
argument_list|(
name|unescapeIdentifier
argument_list|(
name|expr
operator|.
name|getChild
argument_list|(
literal|1
argument_list|)
operator|.
name|getText
argument_list|()
argument_list|)
argument_list|,
name|unescapeIdentifier
argument_list|(
name|expr
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getText
argument_list|()
operator|.
name|toLowerCase
argument_list|()
argument_list|)
argument_list|,
name|alias
argument_list|,
name|expr
argument_list|,
name|col_list
argument_list|,
name|inputRR
argument_list|,
name|pos
argument_list|,
name|out_rwsch
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// Case when this is an expression
name|exprNodeDesc
name|exp
init|=
name|genExprNodeDesc
argument_list|(
name|expr
argument_list|,
name|inputRR
argument_list|)
decl_stmt|;
name|col_list
operator|.
name|add
argument_list|(
name|exp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|StringUtils
operator|.
name|isEmpty
argument_list|(
name|alias
argument_list|)
operator|&&
operator|(
name|out_rwsch
operator|.
name|get
argument_list|(
literal|null
argument_list|,
name|colAlias
argument_list|)
operator|!=
literal|null
operator|)
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|AMBIGUOUS_COLUMN
operator|.
name|getMsg
argument_list|(
name|expr
operator|.
name|getChild
argument_list|(
literal|1
argument_list|)
argument_list|)
argument_list|)
throw|;
block|}
name|out_rwsch
operator|.
name|put
argument_list|(
name|tabAlias
argument_list|,
name|colAlias
argument_list|,
operator|new
name|ColumnInfo
argument_list|(
name|getColumnInternalName
argument_list|(
name|pos
argument_list|)
argument_list|,
name|exp
operator|.
name|getTypeInfo
argument_list|()
argument_list|,
name|tabAlias
argument_list|,
literal|false
argument_list|)
argument_list|)
expr_stmt|;
name|pos
operator|=
name|Integer
operator|.
name|valueOf
argument_list|(
name|pos
operator|.
name|intValue
argument_list|()
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
name|selectStar
operator|=
name|selectStar
operator|&&
name|exprList
operator|.
name|getChildCount
argument_list|()
operator|==
name|posn
operator|+
literal|1
expr_stmt|;
name|ArrayList
argument_list|<
name|String
argument_list|>
name|columnNames
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|exprNodeDesc
argument_list|>
name|colExprMap
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|exprNodeDesc
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|col_list
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
comment|// Replace NULL with CAST(NULL AS STRING)
if|if
condition|(
name|col_list
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|instanceof
name|exprNodeNullDesc
condition|)
block|{
name|col_list
operator|.
name|set
argument_list|(
name|i
argument_list|,
operator|new
name|exprNodeConstantDesc
argument_list|(
name|TypeInfoFactory
operator|.
name|stringTypeInfo
argument_list|,
literal|null
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|String
name|outputCol
init|=
name|getColumnInternalName
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|colExprMap
operator|.
name|put
argument_list|(
name|outputCol
argument_list|,
name|col_list
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|columnNames
operator|.
name|add
argument_list|(
name|outputCol
argument_list|)
expr_stmt|;
block|}
name|Operator
name|output
init|=
name|putOpInsertMap
argument_list|(
name|OperatorFactory
operator|.
name|getAndMakeChild
argument_list|(
operator|new
name|selectDesc
argument_list|(
name|col_list
argument_list|,
name|columnNames
argument_list|,
name|selectStar
argument_list|)
argument_list|,
operator|new
name|RowSchema
argument_list|(
name|out_rwsch
operator|.
name|getColumnInfos
argument_list|()
argument_list|)
argument_list|,
name|input
argument_list|)
argument_list|,
name|out_rwsch
argument_list|)
decl_stmt|;
name|output
operator|.
name|setColumnExprMap
argument_list|(
name|colExprMap
argument_list|)
expr_stmt|;
if|if
condition|(
name|isInTransform
condition|)
block|{
name|output
operator|=
name|genScriptPlan
argument_list|(
name|trfm
argument_list|,
name|qb
argument_list|,
name|output
argument_list|)
expr_stmt|;
block|}
name|LOG
operator|.
name|debug
argument_list|(
literal|"Created Select Plan for clause: "
operator|+
name|dest
operator|+
literal|" row schema: "
operator|+
name|out_rwsch
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|output
return|;
block|}
comment|/**    * Class to store GenericUDAF related information.    */
specifier|static
class|class
name|GenericUDAFInfo
block|{
name|ArrayList
argument_list|<
name|exprNodeDesc
argument_list|>
name|convertedParameters
decl_stmt|;
name|GenericUDAFEvaluator
name|genericUDAFEvaluator
decl_stmt|;
name|TypeInfo
name|returnType
decl_stmt|;
block|}
comment|/**    * Convert exprNodeDesc array to Typeinfo array.     */
specifier|static
name|ArrayList
argument_list|<
name|TypeInfo
argument_list|>
name|getTypeInfo
parameter_list|(
name|ArrayList
argument_list|<
name|exprNodeDesc
argument_list|>
name|exprs
parameter_list|)
block|{
name|ArrayList
argument_list|<
name|TypeInfo
argument_list|>
name|result
init|=
operator|new
name|ArrayList
argument_list|<
name|TypeInfo
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|exprNodeDesc
name|expr
range|:
name|exprs
control|)
block|{
name|result
operator|.
name|add
argument_list|(
name|expr
operator|.
name|getTypeInfo
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
comment|/**    * Convert exprNodeDesc array to Typeinfo array.     */
specifier|static
name|ObjectInspector
index|[]
name|getStandardObjectInspector
parameter_list|(
name|ArrayList
argument_list|<
name|TypeInfo
argument_list|>
name|exprs
parameter_list|)
block|{
name|ObjectInspector
index|[]
name|result
init|=
operator|new
name|ObjectInspector
index|[
name|exprs
operator|.
name|size
argument_list|()
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|exprs
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|result
index|[
name|i
index|]
operator|=
name|TypeInfoUtils
operator|.
name|getStandardWritableObjectInspectorFromTypeInfo
argument_list|(
name|exprs
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
comment|/**    * Returns the GenericUDAFEvaluator for the aggregation.    * This is called once for each GroupBy aggregation.    */
specifier|static
name|GenericUDAFEvaluator
name|getGenericUDAFEvaluator
parameter_list|(
name|String
name|aggName
parameter_list|,
name|ArrayList
argument_list|<
name|exprNodeDesc
argument_list|>
name|aggParameters
parameter_list|,
name|ASTNode
name|aggTree
parameter_list|)
throws|throws
name|SemanticException
block|{
name|ArrayList
argument_list|<
name|TypeInfo
argument_list|>
name|originalParameterTypeInfos
init|=
name|getTypeInfo
argument_list|(
name|aggParameters
argument_list|)
decl_stmt|;
name|GenericUDAFEvaluator
name|result
init|=
name|FunctionRegistry
operator|.
name|getGenericUDAFEvaluator
argument_list|(
name|aggName
argument_list|,
name|originalParameterTypeInfos
argument_list|)
decl_stmt|;
if|if
condition|(
literal|null
operator|==
name|result
condition|)
block|{
name|String
name|reason
init|=
literal|"Looking for UDAF Evaluator\""
operator|+
name|aggName
operator|+
literal|"\" with parameters "
operator|+
name|originalParameterTypeInfos
decl_stmt|;
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|INVALID_FUNCTION_SIGNATURE
operator|.
name|getMsg
argument_list|(
operator|(
name|ASTNode
operator|)
name|aggTree
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
argument_list|,
name|reason
argument_list|)
argument_list|)
throw|;
block|}
return|return
name|result
return|;
block|}
comment|/**    * Returns the GenericUDAFInfo struct for the aggregation.    * @param aggName  The name of the UDAF.    * @param aggParameters  The exprNodeDesc of the original parameters     * @param aggTree   The ASTNode node of the UDAF in the query.    * @return GenericUDAFInfo     * @throws SemanticException when the UDAF is not found or has problems.    */
specifier|static
name|GenericUDAFInfo
name|getGenericUDAFInfo
parameter_list|(
name|GenericUDAFEvaluator
name|evaluator
parameter_list|,
name|GenericUDAFEvaluator
operator|.
name|Mode
name|emode
parameter_list|,
name|ArrayList
argument_list|<
name|exprNodeDesc
argument_list|>
name|aggParameters
parameter_list|)
throws|throws
name|SemanticException
block|{
name|GenericUDAFInfo
name|r
init|=
operator|new
name|GenericUDAFInfo
argument_list|()
decl_stmt|;
comment|// set r.genericUDAFEvaluator
name|r
operator|.
name|genericUDAFEvaluator
operator|=
name|evaluator
expr_stmt|;
comment|// set r.returnType
name|ObjectInspector
name|returnOI
init|=
literal|null
decl_stmt|;
try|try
block|{
name|ObjectInspector
index|[]
name|aggObjectInspectors
init|=
name|getStandardObjectInspector
argument_list|(
name|getTypeInfo
argument_list|(
name|aggParameters
argument_list|)
argument_list|)
decl_stmt|;
name|returnOI
operator|=
name|r
operator|.
name|genericUDAFEvaluator
operator|.
name|init
argument_list|(
name|emode
argument_list|,
name|aggObjectInspectors
argument_list|)
expr_stmt|;
name|r
operator|.
name|returnType
operator|=
name|TypeInfoUtils
operator|.
name|getTypeInfoFromObjectInspector
argument_list|(
name|returnOI
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|HiveException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|e
argument_list|)
throw|;
block|}
comment|// set r.convertedParameters
comment|// TODO: type conversion
name|r
operator|.
name|convertedParameters
operator|=
name|aggParameters
expr_stmt|;
return|return
name|r
return|;
block|}
specifier|private
specifier|static
name|GenericUDAFEvaluator
operator|.
name|Mode
name|groupByDescModeToUDAFMode
parameter_list|(
name|groupByDesc
operator|.
name|Mode
name|mode
parameter_list|,
name|boolean
name|isDistinct
parameter_list|)
block|{
switch|switch
condition|(
name|mode
condition|)
block|{
case|case
name|COMPLETE
case|:
return|return
name|GenericUDAFEvaluator
operator|.
name|Mode
operator|.
name|COMPLETE
return|;
case|case
name|PARTIAL1
case|:
return|return
name|GenericUDAFEvaluator
operator|.
name|Mode
operator|.
name|PARTIAL1
return|;
case|case
name|PARTIAL2
case|:
return|return
name|GenericUDAFEvaluator
operator|.
name|Mode
operator|.
name|PARTIAL2
return|;
case|case
name|PARTIALS
case|:
return|return
name|isDistinct
condition|?
name|GenericUDAFEvaluator
operator|.
name|Mode
operator|.
name|PARTIAL1
else|:
name|GenericUDAFEvaluator
operator|.
name|Mode
operator|.
name|PARTIAL2
return|;
case|case
name|FINAL
case|:
return|return
name|GenericUDAFEvaluator
operator|.
name|Mode
operator|.
name|FINAL
return|;
case|case
name|HASH
case|:
return|return
name|GenericUDAFEvaluator
operator|.
name|Mode
operator|.
name|PARTIAL1
return|;
case|case
name|MERGEPARTIAL
case|:
return|return
name|isDistinct
condition|?
name|GenericUDAFEvaluator
operator|.
name|Mode
operator|.
name|COMPLETE
else|:
name|GenericUDAFEvaluator
operator|.
name|Mode
operator|.
name|FINAL
return|;
default|default:
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"internal error in groupByDescModeToUDAFMode"
argument_list|)
throw|;
block|}
block|}
comment|/**    * Generate the GroupByOperator for the Query Block (parseInfo.getXXX(dest)).    * The new GroupByOperator will be a child of the reduceSinkOperatorInfo.    *     * @param mode The mode of the aggregation (PARTIAL1 or COMPLETE)    * @param genericUDAFEvaluators  If not null, this function will store the mapping    *            from Aggregation StringTree to the genericUDAFEvaluator in this parameter,    *            so it can be used in the next-stage GroupBy aggregations.     * @return the new GroupByOperator    */
annotation|@
name|SuppressWarnings
argument_list|(
literal|"nls"
argument_list|)
specifier|private
name|Operator
name|genGroupByPlanGroupByOperator
parameter_list|(
name|QBParseInfo
name|parseInfo
parameter_list|,
name|String
name|dest
parameter_list|,
name|Operator
name|reduceSinkOperatorInfo
parameter_list|,
name|groupByDesc
operator|.
name|Mode
name|mode
parameter_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|GenericUDAFEvaluator
argument_list|>
name|genericUDAFEvaluators
parameter_list|)
throws|throws
name|SemanticException
block|{
name|RowResolver
name|groupByInputRowResolver
init|=
name|opParseCtx
operator|.
name|get
argument_list|(
name|reduceSinkOperatorInfo
argument_list|)
operator|.
name|getRR
argument_list|()
decl_stmt|;
name|RowResolver
name|groupByOutputRowResolver
init|=
operator|new
name|RowResolver
argument_list|()
decl_stmt|;
name|groupByOutputRowResolver
operator|.
name|setIsExprResolver
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|ArrayList
argument_list|<
name|exprNodeDesc
argument_list|>
name|groupByKeys
init|=
operator|new
name|ArrayList
argument_list|<
name|exprNodeDesc
argument_list|>
argument_list|()
decl_stmt|;
name|ArrayList
argument_list|<
name|aggregationDesc
argument_list|>
name|aggregations
init|=
operator|new
name|ArrayList
argument_list|<
name|aggregationDesc
argument_list|>
argument_list|()
decl_stmt|;
name|ArrayList
argument_list|<
name|String
argument_list|>
name|outputColumnNames
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|exprNodeDesc
argument_list|>
name|colExprMap
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|exprNodeDesc
argument_list|>
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|ASTNode
argument_list|>
name|grpByExprs
init|=
name|getGroupByForClause
argument_list|(
name|parseInfo
argument_list|,
name|dest
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|grpByExprs
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|ASTNode
name|grpbyExpr
init|=
name|grpByExprs
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|String
name|text
init|=
name|grpbyExpr
operator|.
name|toStringTree
argument_list|()
decl_stmt|;
name|ColumnInfo
name|exprInfo
init|=
name|groupByInputRowResolver
operator|.
name|get
argument_list|(
literal|""
argument_list|,
name|text
argument_list|)
decl_stmt|;
if|if
condition|(
name|exprInfo
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|INVALID_COLUMN
operator|.
name|getMsg
argument_list|(
name|grpbyExpr
argument_list|)
argument_list|)
throw|;
block|}
name|groupByKeys
operator|.
name|add
argument_list|(
operator|new
name|exprNodeColumnDesc
argument_list|(
name|exprInfo
operator|.
name|getType
argument_list|()
argument_list|,
name|exprInfo
operator|.
name|getInternalName
argument_list|()
argument_list|,
literal|""
argument_list|,
literal|false
argument_list|)
argument_list|)
expr_stmt|;
name|String
name|field
init|=
name|getColumnInternalName
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|outputColumnNames
operator|.
name|add
argument_list|(
name|field
argument_list|)
expr_stmt|;
name|groupByOutputRowResolver
operator|.
name|put
argument_list|(
literal|""
argument_list|,
name|grpbyExpr
operator|.
name|toStringTree
argument_list|()
argument_list|,
operator|new
name|ColumnInfo
argument_list|(
name|field
argument_list|,
name|exprInfo
operator|.
name|getType
argument_list|()
argument_list|,
literal|null
argument_list|,
literal|false
argument_list|)
argument_list|)
expr_stmt|;
name|colExprMap
operator|.
name|put
argument_list|(
name|field
argument_list|,
name|groupByKeys
operator|.
name|get
argument_list|(
name|groupByKeys
operator|.
name|size
argument_list|()
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// For each aggregation
name|HashMap
argument_list|<
name|String
argument_list|,
name|ASTNode
argument_list|>
name|aggregationTrees
init|=
name|parseInfo
operator|.
name|getAggregationExprsForClause
argument_list|(
name|dest
argument_list|)
decl_stmt|;
assert|assert
operator|(
name|aggregationTrees
operator|!=
literal|null
operator|)
assert|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|ASTNode
argument_list|>
name|entry
range|:
name|aggregationTrees
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|ASTNode
name|value
init|=
name|entry
operator|.
name|getValue
argument_list|()
decl_stmt|;
comment|// This is the GenericUDAF name
name|String
name|aggName
init|=
name|value
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getText
argument_list|()
decl_stmt|;
comment|// Convert children to aggParameters
name|ArrayList
argument_list|<
name|exprNodeDesc
argument_list|>
name|aggParameters
init|=
operator|new
name|ArrayList
argument_list|<
name|exprNodeDesc
argument_list|>
argument_list|()
decl_stmt|;
comment|// 0 is the function name
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<
name|value
operator|.
name|getChildCount
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|String
name|text
init|=
name|value
operator|.
name|getChild
argument_list|(
name|i
argument_list|)
operator|.
name|toStringTree
argument_list|()
decl_stmt|;
name|ASTNode
name|paraExpr
init|=
operator|(
name|ASTNode
operator|)
name|value
operator|.
name|getChild
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|ColumnInfo
name|paraExprInfo
init|=
name|groupByInputRowResolver
operator|.
name|get
argument_list|(
literal|""
argument_list|,
name|text
argument_list|)
decl_stmt|;
if|if
condition|(
name|paraExprInfo
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|INVALID_COLUMN
operator|.
name|getMsg
argument_list|(
name|paraExpr
argument_list|)
argument_list|)
throw|;
block|}
name|String
name|paraExpression
init|=
name|paraExprInfo
operator|.
name|getInternalName
argument_list|()
decl_stmt|;
assert|assert
operator|(
name|paraExpression
operator|!=
literal|null
operator|)
assert|;
name|aggParameters
operator|.
name|add
argument_list|(
operator|new
name|exprNodeColumnDesc
argument_list|(
name|paraExprInfo
operator|.
name|getType
argument_list|()
argument_list|,
name|paraExprInfo
operator|.
name|getInternalName
argument_list|()
argument_list|,
name|paraExprInfo
operator|.
name|getTabAlias
argument_list|()
argument_list|,
name|paraExprInfo
operator|.
name|getIsPartitionCol
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|boolean
name|isDistinct
init|=
name|value
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_FUNCTIONDI
decl_stmt|;
name|Mode
name|amode
init|=
name|groupByDescModeToUDAFMode
argument_list|(
name|mode
argument_list|,
name|isDistinct
argument_list|)
decl_stmt|;
name|GenericUDAFEvaluator
name|genericUDAFEvaluator
init|=
name|getGenericUDAFEvaluator
argument_list|(
name|aggName
argument_list|,
name|aggParameters
argument_list|,
name|value
argument_list|)
decl_stmt|;
assert|assert
operator|(
name|genericUDAFEvaluator
operator|!=
literal|null
operator|)
assert|;
name|GenericUDAFInfo
name|udaf
init|=
name|getGenericUDAFInfo
argument_list|(
name|genericUDAFEvaluator
argument_list|,
name|amode
argument_list|,
name|aggParameters
argument_list|)
decl_stmt|;
name|aggregations
operator|.
name|add
argument_list|(
operator|new
name|aggregationDesc
argument_list|(
name|aggName
operator|.
name|toLowerCase
argument_list|()
argument_list|,
name|udaf
operator|.
name|genericUDAFEvaluator
argument_list|,
name|udaf
operator|.
name|convertedParameters
argument_list|,
name|isDistinct
argument_list|,
name|amode
argument_list|)
argument_list|)
expr_stmt|;
name|String
name|field
init|=
name|getColumnInternalName
argument_list|(
name|groupByKeys
operator|.
name|size
argument_list|()
operator|+
name|aggregations
operator|.
name|size
argument_list|()
operator|-
literal|1
argument_list|)
decl_stmt|;
name|outputColumnNames
operator|.
name|add
argument_list|(
name|field
argument_list|)
expr_stmt|;
name|groupByOutputRowResolver
operator|.
name|put
argument_list|(
literal|""
argument_list|,
name|value
operator|.
name|toStringTree
argument_list|()
argument_list|,
operator|new
name|ColumnInfo
argument_list|(
name|field
argument_list|,
name|udaf
operator|.
name|returnType
argument_list|,
literal|""
argument_list|,
literal|false
argument_list|)
argument_list|)
expr_stmt|;
comment|// Save the evaluator so that it can be used by the next-stage GroupByOperators
if|if
condition|(
name|genericUDAFEvaluators
operator|!=
literal|null
condition|)
block|{
name|genericUDAFEvaluators
operator|.
name|put
argument_list|(
name|entry
operator|.
name|getKey
argument_list|()
argument_list|,
name|genericUDAFEvaluator
argument_list|)
expr_stmt|;
block|}
block|}
name|Operator
name|op
init|=
name|putOpInsertMap
argument_list|(
name|OperatorFactory
operator|.
name|getAndMakeChild
argument_list|(
operator|new
name|groupByDesc
argument_list|(
name|mode
argument_list|,
name|outputColumnNames
argument_list|,
name|groupByKeys
argument_list|,
name|aggregations
argument_list|,
literal|false
argument_list|)
argument_list|,
operator|new
name|RowSchema
argument_list|(
name|groupByOutputRowResolver
operator|.
name|getColumnInfos
argument_list|()
argument_list|)
argument_list|,
name|reduceSinkOperatorInfo
argument_list|)
argument_list|,
name|groupByOutputRowResolver
argument_list|)
decl_stmt|;
name|op
operator|.
name|setColumnExprMap
argument_list|(
name|colExprMap
argument_list|)
expr_stmt|;
return|return
name|op
return|;
block|}
comment|/**    * Generate the GroupByOperator for the Query Block (parseInfo.getXXX(dest)).    * The new GroupByOperator will be a child of the reduceSinkOperatorInfo.    *     * @param mode The mode of the aggregation (MERGEPARTIAL, PARTIAL2)    * @param genericUDAFEvaluators  The mapping from Aggregation StringTree to the     *            genericUDAFEvaluator.     * @param distPartAggr partial aggregation for distincts    * @return the new GroupByOperator    */
annotation|@
name|SuppressWarnings
argument_list|(
literal|"nls"
argument_list|)
specifier|private
name|Operator
name|genGroupByPlanGroupByOperator1
parameter_list|(
name|QBParseInfo
name|parseInfo
parameter_list|,
name|String
name|dest
parameter_list|,
name|Operator
name|reduceSinkOperatorInfo
parameter_list|,
name|groupByDesc
operator|.
name|Mode
name|mode
parameter_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|GenericUDAFEvaluator
argument_list|>
name|genericUDAFEvaluators
parameter_list|,
name|boolean
name|distPartAgg
parameter_list|)
throws|throws
name|SemanticException
block|{
name|ArrayList
argument_list|<
name|String
argument_list|>
name|outputColumnNames
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
name|RowResolver
name|groupByInputRowResolver
init|=
name|opParseCtx
operator|.
name|get
argument_list|(
name|reduceSinkOperatorInfo
argument_list|)
operator|.
name|getRR
argument_list|()
decl_stmt|;
name|RowResolver
name|groupByOutputRowResolver
init|=
operator|new
name|RowResolver
argument_list|()
decl_stmt|;
name|groupByOutputRowResolver
operator|.
name|setIsExprResolver
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|ArrayList
argument_list|<
name|exprNodeDesc
argument_list|>
name|groupByKeys
init|=
operator|new
name|ArrayList
argument_list|<
name|exprNodeDesc
argument_list|>
argument_list|()
decl_stmt|;
name|ArrayList
argument_list|<
name|aggregationDesc
argument_list|>
name|aggregations
init|=
operator|new
name|ArrayList
argument_list|<
name|aggregationDesc
argument_list|>
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|ASTNode
argument_list|>
name|grpByExprs
init|=
name|getGroupByForClause
argument_list|(
name|parseInfo
argument_list|,
name|dest
argument_list|)
decl_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|exprNodeDesc
argument_list|>
name|colExprMap
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|exprNodeDesc
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|grpByExprs
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|ASTNode
name|grpbyExpr
init|=
name|grpByExprs
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|String
name|text
init|=
name|grpbyExpr
operator|.
name|toStringTree
argument_list|()
decl_stmt|;
name|ColumnInfo
name|exprInfo
init|=
name|groupByInputRowResolver
operator|.
name|get
argument_list|(
literal|""
argument_list|,
name|text
argument_list|)
decl_stmt|;
if|if
condition|(
name|exprInfo
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|INVALID_COLUMN
operator|.
name|getMsg
argument_list|(
name|grpbyExpr
argument_list|)
argument_list|)
throw|;
block|}
name|groupByKeys
operator|.
name|add
argument_list|(
operator|new
name|exprNodeColumnDesc
argument_list|(
name|exprInfo
operator|.
name|getType
argument_list|()
argument_list|,
name|exprInfo
operator|.
name|getInternalName
argument_list|()
argument_list|,
name|exprInfo
operator|.
name|getTabAlias
argument_list|()
argument_list|,
name|exprInfo
operator|.
name|getIsPartitionCol
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|String
name|field
init|=
name|getColumnInternalName
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|outputColumnNames
operator|.
name|add
argument_list|(
name|field
argument_list|)
expr_stmt|;
name|groupByOutputRowResolver
operator|.
name|put
argument_list|(
literal|""
argument_list|,
name|grpbyExpr
operator|.
name|toStringTree
argument_list|()
argument_list|,
operator|new
name|ColumnInfo
argument_list|(
name|field
argument_list|,
name|exprInfo
operator|.
name|getType
argument_list|()
argument_list|,
literal|""
argument_list|,
literal|false
argument_list|)
argument_list|)
expr_stmt|;
name|colExprMap
operator|.
name|put
argument_list|(
name|field
argument_list|,
name|groupByKeys
operator|.
name|get
argument_list|(
name|groupByKeys
operator|.
name|size
argument_list|()
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|HashMap
argument_list|<
name|String
argument_list|,
name|ASTNode
argument_list|>
name|aggregationTrees
init|=
name|parseInfo
operator|.
name|getAggregationExprsForClause
argument_list|(
name|dest
argument_list|)
decl_stmt|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|ASTNode
argument_list|>
name|entry
range|:
name|aggregationTrees
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|ASTNode
name|value
init|=
name|entry
operator|.
name|getValue
argument_list|()
decl_stmt|;
name|String
name|aggName
init|=
name|value
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getText
argument_list|()
decl_stmt|;
name|ArrayList
argument_list|<
name|exprNodeDesc
argument_list|>
name|aggParameters
init|=
operator|new
name|ArrayList
argument_list|<
name|exprNodeDesc
argument_list|>
argument_list|()
decl_stmt|;
comment|// If the function is distinct, partial aggregartion has not been done on the client side.
comment|// If distPartAgg is set, the client is letting us know that partial aggregation has not been done.
comment|// For eg: select a, count(b+c), count(distinct d+e) group by a
comment|// For count(b+c), if partial aggregation has been performed, then we directly look for count(b+c).
comment|// Otherwise, we look for b+c.
comment|// For distincts, partial aggregation is never performed on the client side, so always look for the parameters: d+e
name|boolean
name|partialAggDone
init|=
operator|!
operator|(
name|distPartAgg
operator|||
operator|(
name|value
operator|.
name|getToken
argument_list|()
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_FUNCTIONDI
operator|)
operator|)
decl_stmt|;
if|if
condition|(
operator|!
name|partialAggDone
condition|)
block|{
comment|// 0 is the function name
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<
name|value
operator|.
name|getChildCount
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|String
name|text
init|=
name|value
operator|.
name|getChild
argument_list|(
name|i
argument_list|)
operator|.
name|toStringTree
argument_list|()
decl_stmt|;
name|ASTNode
name|paraExpr
init|=
operator|(
name|ASTNode
operator|)
name|value
operator|.
name|getChild
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|ColumnInfo
name|paraExprInfo
init|=
name|groupByInputRowResolver
operator|.
name|get
argument_list|(
literal|""
argument_list|,
name|text
argument_list|)
decl_stmt|;
if|if
condition|(
name|paraExprInfo
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|INVALID_COLUMN
operator|.
name|getMsg
argument_list|(
name|paraExpr
argument_list|)
argument_list|)
throw|;
block|}
name|String
name|paraExpression
init|=
name|paraExprInfo
operator|.
name|getInternalName
argument_list|()
decl_stmt|;
assert|assert
operator|(
name|paraExpression
operator|!=
literal|null
operator|)
assert|;
name|aggParameters
operator|.
name|add
argument_list|(
operator|new
name|exprNodeColumnDesc
argument_list|(
name|paraExprInfo
operator|.
name|getType
argument_list|()
argument_list|,
name|paraExprInfo
operator|.
name|getInternalName
argument_list|()
argument_list|,
name|paraExprInfo
operator|.
name|getTabAlias
argument_list|()
argument_list|,
name|paraExprInfo
operator|.
name|getIsPartitionCol
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|String
name|text
init|=
name|entry
operator|.
name|getKey
argument_list|()
decl_stmt|;
name|ColumnInfo
name|paraExprInfo
init|=
name|groupByInputRowResolver
operator|.
name|get
argument_list|(
literal|""
argument_list|,
name|text
argument_list|)
decl_stmt|;
if|if
condition|(
name|paraExprInfo
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|INVALID_COLUMN
operator|.
name|getMsg
argument_list|(
name|value
argument_list|)
argument_list|)
throw|;
block|}
name|String
name|paraExpression
init|=
name|paraExprInfo
operator|.
name|getInternalName
argument_list|()
decl_stmt|;
assert|assert
operator|(
name|paraExpression
operator|!=
literal|null
operator|)
assert|;
name|aggParameters
operator|.
name|add
argument_list|(
operator|new
name|exprNodeColumnDesc
argument_list|(
name|paraExprInfo
operator|.
name|getType
argument_list|()
argument_list|,
name|paraExpression
argument_list|,
name|paraExprInfo
operator|.
name|getTabAlias
argument_list|()
argument_list|,
name|paraExprInfo
operator|.
name|getIsPartitionCol
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|boolean
name|isDistinct
init|=
operator|(
name|value
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_FUNCTIONDI
operator|)
decl_stmt|;
name|Mode
name|amode
init|=
name|groupByDescModeToUDAFMode
argument_list|(
name|mode
argument_list|,
name|isDistinct
argument_list|)
decl_stmt|;
name|GenericUDAFEvaluator
name|genericUDAFEvaluator
init|=
literal|null
decl_stmt|;
comment|// For distincts, partial aggregations have not been done
if|if
condition|(
name|distPartAgg
condition|)
block|{
name|genericUDAFEvaluator
operator|=
name|getGenericUDAFEvaluator
argument_list|(
name|aggName
argument_list|,
name|aggParameters
argument_list|,
name|value
argument_list|)
expr_stmt|;
assert|assert
operator|(
name|genericUDAFEvaluator
operator|!=
literal|null
operator|)
assert|;
name|genericUDAFEvaluators
operator|.
name|put
argument_list|(
name|entry
operator|.
name|getKey
argument_list|()
argument_list|,
name|genericUDAFEvaluator
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|genericUDAFEvaluator
operator|=
name|genericUDAFEvaluators
operator|.
name|get
argument_list|(
name|entry
operator|.
name|getKey
argument_list|()
argument_list|)
expr_stmt|;
assert|assert
operator|(
name|genericUDAFEvaluator
operator|!=
literal|null
operator|)
assert|;
block|}
name|GenericUDAFInfo
name|udaf
init|=
name|getGenericUDAFInfo
argument_list|(
name|genericUDAFEvaluator
argument_list|,
name|amode
argument_list|,
name|aggParameters
argument_list|)
decl_stmt|;
name|aggregations
operator|.
name|add
argument_list|(
operator|new
name|aggregationDesc
argument_list|(
name|aggName
operator|.
name|toLowerCase
argument_list|()
argument_list|,
name|udaf
operator|.
name|genericUDAFEvaluator
argument_list|,
name|udaf
operator|.
name|convertedParameters
argument_list|,
operator|(
name|mode
operator|!=
name|groupByDesc
operator|.
name|Mode
operator|.
name|FINAL
operator|&&
name|isDistinct
operator|)
argument_list|,
name|amode
argument_list|)
argument_list|)
expr_stmt|;
name|String
name|field
init|=
name|getColumnInternalName
argument_list|(
name|groupByKeys
operator|.
name|size
argument_list|()
operator|+
name|aggregations
operator|.
name|size
argument_list|()
operator|-
literal|1
argument_list|)
decl_stmt|;
name|outputColumnNames
operator|.
name|add
argument_list|(
name|field
argument_list|)
expr_stmt|;
name|groupByOutputRowResolver
operator|.
name|put
argument_list|(
literal|""
argument_list|,
name|value
operator|.
name|toStringTree
argument_list|()
argument_list|,
operator|new
name|ColumnInfo
argument_list|(
name|field
argument_list|,
name|udaf
operator|.
name|returnType
argument_list|,
literal|""
argument_list|,
literal|false
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|Operator
name|op
init|=
name|putOpInsertMap
argument_list|(
name|OperatorFactory
operator|.
name|getAndMakeChild
argument_list|(
operator|new
name|groupByDesc
argument_list|(
name|mode
argument_list|,
name|outputColumnNames
argument_list|,
name|groupByKeys
argument_list|,
name|aggregations
argument_list|,
name|distPartAgg
argument_list|)
argument_list|,
operator|new
name|RowSchema
argument_list|(
name|groupByOutputRowResolver
operator|.
name|getColumnInfos
argument_list|()
argument_list|)
argument_list|,
name|reduceSinkOperatorInfo
argument_list|)
argument_list|,
name|groupByOutputRowResolver
argument_list|)
decl_stmt|;
name|op
operator|.
name|setColumnExprMap
argument_list|(
name|colExprMap
argument_list|)
expr_stmt|;
return|return
name|op
return|;
block|}
comment|/**    * Generate the map-side GroupByOperator for the Query Block (qb.getParseInfo().getXXX(dest)).    * The new GroupByOperator will be a child of the inputOperatorInfo.    *     * @param mode The mode of the aggregation (HASH)    * @param genericUDAFEvaluators  If not null, this function will store the mapping    *            from Aggregation StringTree to the genericUDAFEvaluator in this parameter,    *            so it can be used in the next-stage GroupBy aggregations.     * @return the new GroupByOperator    */
annotation|@
name|SuppressWarnings
argument_list|(
literal|"nls"
argument_list|)
specifier|private
name|Operator
name|genGroupByPlanMapGroupByOperator
parameter_list|(
name|QB
name|qb
parameter_list|,
name|String
name|dest
parameter_list|,
name|Operator
name|inputOperatorInfo
parameter_list|,
name|groupByDesc
operator|.
name|Mode
name|mode
parameter_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|GenericUDAFEvaluator
argument_list|>
name|genericUDAFEvaluators
parameter_list|)
throws|throws
name|SemanticException
block|{
name|RowResolver
name|groupByInputRowResolver
init|=
name|opParseCtx
operator|.
name|get
argument_list|(
name|inputOperatorInfo
argument_list|)
operator|.
name|getRR
argument_list|()
decl_stmt|;
name|QBParseInfo
name|parseInfo
init|=
name|qb
operator|.
name|getParseInfo
argument_list|()
decl_stmt|;
name|RowResolver
name|groupByOutputRowResolver
init|=
operator|new
name|RowResolver
argument_list|()
decl_stmt|;
name|groupByOutputRowResolver
operator|.
name|setIsExprResolver
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|ArrayList
argument_list|<
name|exprNodeDesc
argument_list|>
name|groupByKeys
init|=
operator|new
name|ArrayList
argument_list|<
name|exprNodeDesc
argument_list|>
argument_list|()
decl_stmt|;
name|ArrayList
argument_list|<
name|String
argument_list|>
name|outputColumnNames
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
name|ArrayList
argument_list|<
name|aggregationDesc
argument_list|>
name|aggregations
init|=
operator|new
name|ArrayList
argument_list|<
name|aggregationDesc
argument_list|>
argument_list|()
decl_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|exprNodeDesc
argument_list|>
name|colExprMap
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|exprNodeDesc
argument_list|>
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|ASTNode
argument_list|>
name|grpByExprs
init|=
name|getGroupByForClause
argument_list|(
name|parseInfo
argument_list|,
name|dest
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|grpByExprs
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|ASTNode
name|grpbyExpr
init|=
name|grpByExprs
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|exprNodeDesc
name|grpByExprNode
init|=
name|genExprNodeDesc
argument_list|(
name|grpbyExpr
argument_list|,
name|groupByInputRowResolver
argument_list|)
decl_stmt|;
name|groupByKeys
operator|.
name|add
argument_list|(
name|grpByExprNode
argument_list|)
expr_stmt|;
name|String
name|field
init|=
name|getColumnInternalName
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|outputColumnNames
operator|.
name|add
argument_list|(
name|field
argument_list|)
expr_stmt|;
name|groupByOutputRowResolver
operator|.
name|put
argument_list|(
literal|""
argument_list|,
name|grpbyExpr
operator|.
name|toStringTree
argument_list|()
argument_list|,
operator|new
name|ColumnInfo
argument_list|(
name|field
argument_list|,
name|grpByExprNode
operator|.
name|getTypeInfo
argument_list|()
argument_list|,
literal|""
argument_list|,
literal|false
argument_list|)
argument_list|)
expr_stmt|;
name|colExprMap
operator|.
name|put
argument_list|(
name|field
argument_list|,
name|groupByKeys
operator|.
name|get
argument_list|(
name|groupByKeys
operator|.
name|size
argument_list|()
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// If there is a distinctFuncExp, add all parameters to the reduceKeys.
if|if
condition|(
name|parseInfo
operator|.
name|getDistinctFuncExprForClause
argument_list|(
name|dest
argument_list|)
operator|!=
literal|null
condition|)
block|{
name|ASTNode
name|value
init|=
name|parseInfo
operator|.
name|getDistinctFuncExprForClause
argument_list|(
name|dest
argument_list|)
decl_stmt|;
name|int
name|numDistn
init|=
literal|0
decl_stmt|;
comment|// 0 is function name
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<
name|value
operator|.
name|getChildCount
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|ASTNode
name|parameter
init|=
operator|(
name|ASTNode
operator|)
name|value
operator|.
name|getChild
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|String
name|text
init|=
name|parameter
operator|.
name|toStringTree
argument_list|()
decl_stmt|;
if|if
condition|(
name|groupByOutputRowResolver
operator|.
name|get
argument_list|(
literal|""
argument_list|,
name|text
argument_list|)
operator|==
literal|null
condition|)
block|{
name|exprNodeDesc
name|distExprNode
init|=
name|genExprNodeDesc
argument_list|(
name|parameter
argument_list|,
name|groupByInputRowResolver
argument_list|)
decl_stmt|;
name|groupByKeys
operator|.
name|add
argument_list|(
name|distExprNode
argument_list|)
expr_stmt|;
name|numDistn
operator|++
expr_stmt|;
name|String
name|field
init|=
name|getColumnInternalName
argument_list|(
name|grpByExprs
operator|.
name|size
argument_list|()
operator|+
name|numDistn
operator|-
literal|1
argument_list|)
decl_stmt|;
name|outputColumnNames
operator|.
name|add
argument_list|(
name|field
argument_list|)
expr_stmt|;
name|groupByOutputRowResolver
operator|.
name|put
argument_list|(
literal|""
argument_list|,
name|text
argument_list|,
operator|new
name|ColumnInfo
argument_list|(
name|field
argument_list|,
name|distExprNode
operator|.
name|getTypeInfo
argument_list|()
argument_list|,
literal|""
argument_list|,
literal|false
argument_list|)
argument_list|)
expr_stmt|;
name|colExprMap
operator|.
name|put
argument_list|(
name|field
argument_list|,
name|groupByKeys
operator|.
name|get
argument_list|(
name|groupByKeys
operator|.
name|size
argument_list|()
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|// For each aggregation
name|HashMap
argument_list|<
name|String
argument_list|,
name|ASTNode
argument_list|>
name|aggregationTrees
init|=
name|parseInfo
operator|.
name|getAggregationExprsForClause
argument_list|(
name|dest
argument_list|)
decl_stmt|;
assert|assert
operator|(
name|aggregationTrees
operator|!=
literal|null
operator|)
assert|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|ASTNode
argument_list|>
name|entry
range|:
name|aggregationTrees
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|ASTNode
name|value
init|=
name|entry
operator|.
name|getValue
argument_list|()
decl_stmt|;
name|String
name|aggName
init|=
name|value
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getText
argument_list|()
decl_stmt|;
name|ArrayList
argument_list|<
name|exprNodeDesc
argument_list|>
name|aggParameters
init|=
operator|new
name|ArrayList
argument_list|<
name|exprNodeDesc
argument_list|>
argument_list|()
decl_stmt|;
name|ArrayList
argument_list|<
name|Class
argument_list|<
name|?
argument_list|>
argument_list|>
name|aggClasses
init|=
operator|new
name|ArrayList
argument_list|<
name|Class
argument_list|<
name|?
argument_list|>
argument_list|>
argument_list|()
decl_stmt|;
comment|// 0 is the function name
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<
name|value
operator|.
name|getChildCount
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|ASTNode
name|paraExpr
init|=
operator|(
name|ASTNode
operator|)
name|value
operator|.
name|getChild
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|exprNodeDesc
name|paraExprNode
init|=
name|genExprNodeDesc
argument_list|(
name|paraExpr
argument_list|,
name|groupByInputRowResolver
argument_list|)
decl_stmt|;
name|aggParameters
operator|.
name|add
argument_list|(
name|paraExprNode
argument_list|)
expr_stmt|;
block|}
name|boolean
name|isDistinct
init|=
name|value
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_FUNCTIONDI
decl_stmt|;
name|Mode
name|amode
init|=
name|groupByDescModeToUDAFMode
argument_list|(
name|mode
argument_list|,
name|isDistinct
argument_list|)
decl_stmt|;
name|GenericUDAFEvaluator
name|genericUDAFEvaluator
init|=
name|getGenericUDAFEvaluator
argument_list|(
name|aggName
argument_list|,
name|aggParameters
argument_list|,
name|value
argument_list|)
decl_stmt|;
assert|assert
operator|(
name|genericUDAFEvaluator
operator|!=
literal|null
operator|)
assert|;
name|GenericUDAFInfo
name|udaf
init|=
name|getGenericUDAFInfo
argument_list|(
name|genericUDAFEvaluator
argument_list|,
name|amode
argument_list|,
name|aggParameters
argument_list|)
decl_stmt|;
name|aggregations
operator|.
name|add
argument_list|(
operator|new
name|aggregationDesc
argument_list|(
name|aggName
operator|.
name|toLowerCase
argument_list|()
argument_list|,
name|udaf
operator|.
name|genericUDAFEvaluator
argument_list|,
name|udaf
operator|.
name|convertedParameters
argument_list|,
name|isDistinct
argument_list|,
name|amode
argument_list|)
argument_list|)
expr_stmt|;
name|String
name|field
init|=
name|getColumnInternalName
argument_list|(
name|groupByKeys
operator|.
name|size
argument_list|()
operator|+
name|aggregations
operator|.
name|size
argument_list|()
operator|-
literal|1
argument_list|)
decl_stmt|;
name|outputColumnNames
operator|.
name|add
argument_list|(
name|field
argument_list|)
expr_stmt|;
name|groupByOutputRowResolver
operator|.
name|put
argument_list|(
literal|""
argument_list|,
name|value
operator|.
name|toStringTree
argument_list|()
argument_list|,
operator|new
name|ColumnInfo
argument_list|(
name|field
argument_list|,
name|udaf
operator|.
name|returnType
argument_list|,
literal|""
argument_list|,
literal|false
argument_list|)
argument_list|)
expr_stmt|;
comment|// Save the evaluator so that it can be used by the next-stage GroupByOperators
if|if
condition|(
name|genericUDAFEvaluators
operator|!=
literal|null
condition|)
block|{
name|genericUDAFEvaluators
operator|.
name|put
argument_list|(
name|entry
operator|.
name|getKey
argument_list|()
argument_list|,
name|genericUDAFEvaluator
argument_list|)
expr_stmt|;
block|}
block|}
name|Operator
name|op
init|=
name|putOpInsertMap
argument_list|(
name|OperatorFactory
operator|.
name|getAndMakeChild
argument_list|(
operator|new
name|groupByDesc
argument_list|(
name|mode
argument_list|,
name|outputColumnNames
argument_list|,
name|groupByKeys
argument_list|,
name|aggregations
argument_list|,
literal|false
argument_list|)
argument_list|,
operator|new
name|RowSchema
argument_list|(
name|groupByOutputRowResolver
operator|.
name|getColumnInfos
argument_list|()
argument_list|)
argument_list|,
name|inputOperatorInfo
argument_list|)
argument_list|,
name|groupByOutputRowResolver
argument_list|)
decl_stmt|;
name|op
operator|.
name|setColumnExprMap
argument_list|(
name|colExprMap
argument_list|)
expr_stmt|;
return|return
name|op
return|;
block|}
comment|/**    * Generate the ReduceSinkOperator for the Group By Query Block (qb.getPartInfo().getXXX(dest)).    * The new ReduceSinkOperator will be a child of inputOperatorInfo.    *     * It will put all Group By keys and the distinct field (if any) in the map-reduce sort key,    * and all other fields in the map-reduce value.    *     * @param numPartitionFields  the number of fields for map-reduce partitioning.    *      This is usually the number of fields in the Group By keys.    * @return the new ReduceSinkOperator.    * @throws SemanticException    */
annotation|@
name|SuppressWarnings
argument_list|(
literal|"nls"
argument_list|)
specifier|private
name|Operator
name|genGroupByPlanReduceSinkOperator
parameter_list|(
name|QB
name|qb
parameter_list|,
name|String
name|dest
parameter_list|,
name|Operator
name|inputOperatorInfo
parameter_list|,
name|int
name|numPartitionFields
parameter_list|,
name|int
name|numReducers
parameter_list|,
name|boolean
name|mapAggrDone
parameter_list|)
throws|throws
name|SemanticException
block|{
name|RowResolver
name|reduceSinkInputRowResolver
init|=
name|opParseCtx
operator|.
name|get
argument_list|(
name|inputOperatorInfo
argument_list|)
operator|.
name|getRR
argument_list|()
decl_stmt|;
name|QBParseInfo
name|parseInfo
init|=
name|qb
operator|.
name|getParseInfo
argument_list|()
decl_stmt|;
name|RowResolver
name|reduceSinkOutputRowResolver
init|=
operator|new
name|RowResolver
argument_list|()
decl_stmt|;
name|reduceSinkOutputRowResolver
operator|.
name|setIsExprResolver
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|exprNodeDesc
argument_list|>
name|colExprMap
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|exprNodeDesc
argument_list|>
argument_list|()
decl_stmt|;
name|ArrayList
argument_list|<
name|exprNodeDesc
argument_list|>
name|reduceKeys
init|=
operator|new
name|ArrayList
argument_list|<
name|exprNodeDesc
argument_list|>
argument_list|()
decl_stmt|;
comment|// Pre-compute group-by keys and store in reduceKeys
name|List
argument_list|<
name|String
argument_list|>
name|outputColumnNames
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|ASTNode
argument_list|>
name|grpByExprs
init|=
name|getGroupByForClause
argument_list|(
name|parseInfo
argument_list|,
name|dest
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|grpByExprs
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|ASTNode
name|grpbyExpr
init|=
name|grpByExprs
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|exprNodeDesc
name|inputExpr
init|=
name|genExprNodeDesc
argument_list|(
name|grpbyExpr
argument_list|,
name|reduceSinkInputRowResolver
argument_list|)
decl_stmt|;
name|reduceKeys
operator|.
name|add
argument_list|(
name|inputExpr
argument_list|)
expr_stmt|;
name|String
name|text
init|=
name|grpbyExpr
operator|.
name|toStringTree
argument_list|()
decl_stmt|;
if|if
condition|(
name|reduceSinkOutputRowResolver
operator|.
name|get
argument_list|(
literal|""
argument_list|,
name|text
argument_list|)
operator|==
literal|null
condition|)
block|{
name|outputColumnNames
operator|.
name|add
argument_list|(
name|getColumnInternalName
argument_list|(
name|reduceKeys
operator|.
name|size
argument_list|()
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|String
name|field
init|=
name|Utilities
operator|.
name|ReduceField
operator|.
name|KEY
operator|.
name|toString
argument_list|()
operator|+
literal|"."
operator|+
name|getColumnInternalName
argument_list|(
name|reduceKeys
operator|.
name|size
argument_list|()
operator|-
literal|1
argument_list|)
decl_stmt|;
name|ColumnInfo
name|colInfo
init|=
operator|new
name|ColumnInfo
argument_list|(
name|field
argument_list|,
name|reduceKeys
operator|.
name|get
argument_list|(
name|reduceKeys
operator|.
name|size
argument_list|()
operator|-
literal|1
argument_list|)
operator|.
name|getTypeInfo
argument_list|()
argument_list|,
literal|null
argument_list|,
literal|false
argument_list|)
decl_stmt|;
name|reduceSinkOutputRowResolver
operator|.
name|put
argument_list|(
literal|""
argument_list|,
name|text
argument_list|,
name|colInfo
argument_list|)
expr_stmt|;
name|colExprMap
operator|.
name|put
argument_list|(
name|colInfo
operator|.
name|getInternalName
argument_list|()
argument_list|,
name|inputExpr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|DUPLICATE_GROUPBY_KEY
operator|.
name|getMsg
argument_list|(
name|grpbyExpr
argument_list|)
argument_list|)
throw|;
block|}
block|}
comment|// If there is a distinctFuncExp, add all parameters to the reduceKeys.
if|if
condition|(
name|parseInfo
operator|.
name|getDistinctFuncExprForClause
argument_list|(
name|dest
argument_list|)
operator|!=
literal|null
condition|)
block|{
name|ASTNode
name|value
init|=
name|parseInfo
operator|.
name|getDistinctFuncExprForClause
argument_list|(
name|dest
argument_list|)
decl_stmt|;
comment|// 0 is function name
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<
name|value
operator|.
name|getChildCount
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|ASTNode
name|parameter
init|=
operator|(
name|ASTNode
operator|)
name|value
operator|.
name|getChild
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|String
name|text
init|=
name|parameter
operator|.
name|toStringTree
argument_list|()
decl_stmt|;
if|if
condition|(
name|reduceSinkOutputRowResolver
operator|.
name|get
argument_list|(
literal|""
argument_list|,
name|text
argument_list|)
operator|==
literal|null
condition|)
block|{
name|reduceKeys
operator|.
name|add
argument_list|(
name|genExprNodeDesc
argument_list|(
name|parameter
argument_list|,
name|reduceSinkInputRowResolver
argument_list|)
argument_list|)
expr_stmt|;
name|outputColumnNames
operator|.
name|add
argument_list|(
name|getColumnInternalName
argument_list|(
name|reduceKeys
operator|.
name|size
argument_list|()
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|String
name|field
init|=
name|Utilities
operator|.
name|ReduceField
operator|.
name|KEY
operator|.
name|toString
argument_list|()
operator|+
literal|"."
operator|+
name|getColumnInternalName
argument_list|(
name|reduceKeys
operator|.
name|size
argument_list|()
operator|-
literal|1
argument_list|)
decl_stmt|;
name|ColumnInfo
name|colInfo
init|=
operator|new
name|ColumnInfo
argument_list|(
name|field
argument_list|,
name|reduceKeys
operator|.
name|get
argument_list|(
name|reduceKeys
operator|.
name|size
argument_list|()
operator|-
literal|1
argument_list|)
operator|.
name|getTypeInfo
argument_list|()
argument_list|,
literal|null
argument_list|,
literal|false
argument_list|)
decl_stmt|;
name|reduceSinkOutputRowResolver
operator|.
name|put
argument_list|(
literal|""
argument_list|,
name|text
argument_list|,
name|colInfo
argument_list|)
expr_stmt|;
name|colExprMap
operator|.
name|put
argument_list|(
name|colInfo
operator|.
name|getInternalName
argument_list|()
argument_list|,
name|reduceKeys
operator|.
name|get
argument_list|(
name|reduceKeys
operator|.
name|size
argument_list|()
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|ArrayList
argument_list|<
name|exprNodeDesc
argument_list|>
name|reduceValues
init|=
operator|new
name|ArrayList
argument_list|<
name|exprNodeDesc
argument_list|>
argument_list|()
decl_stmt|;
name|HashMap
argument_list|<
name|String
argument_list|,
name|ASTNode
argument_list|>
name|aggregationTrees
init|=
name|parseInfo
operator|.
name|getAggregationExprsForClause
argument_list|(
name|dest
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|mapAggrDone
condition|)
block|{
comment|// Put parameters to aggregations in reduceValues
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|ASTNode
argument_list|>
name|entry
range|:
name|aggregationTrees
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|ASTNode
name|value
init|=
name|entry
operator|.
name|getValue
argument_list|()
decl_stmt|;
comment|// 0 is function name
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<
name|value
operator|.
name|getChildCount
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|ASTNode
name|parameter
init|=
operator|(
name|ASTNode
operator|)
name|value
operator|.
name|getChild
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|String
name|text
init|=
name|parameter
operator|.
name|toStringTree
argument_list|()
decl_stmt|;
if|if
condition|(
name|reduceSinkOutputRowResolver
operator|.
name|get
argument_list|(
literal|""
argument_list|,
name|text
argument_list|)
operator|==
literal|null
condition|)
block|{
name|reduceValues
operator|.
name|add
argument_list|(
name|genExprNodeDesc
argument_list|(
name|parameter
argument_list|,
name|reduceSinkInputRowResolver
argument_list|)
argument_list|)
expr_stmt|;
name|outputColumnNames
operator|.
name|add
argument_list|(
name|getColumnInternalName
argument_list|(
name|reduceValues
operator|.
name|size
argument_list|()
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|String
name|field
init|=
name|Utilities
operator|.
name|ReduceField
operator|.
name|VALUE
operator|.
name|toString
argument_list|()
operator|+
literal|"."
operator|+
name|getColumnInternalName
argument_list|(
name|reduceValues
operator|.
name|size
argument_list|()
operator|-
literal|1
argument_list|)
decl_stmt|;
name|reduceSinkOutputRowResolver
operator|.
name|put
argument_list|(
literal|""
argument_list|,
name|text
argument_list|,
operator|new
name|ColumnInfo
argument_list|(
name|field
argument_list|,
name|reduceValues
operator|.
name|get
argument_list|(
name|reduceValues
operator|.
name|size
argument_list|()
operator|-
literal|1
argument_list|)
operator|.
name|getTypeInfo
argument_list|()
argument_list|,
literal|null
argument_list|,
literal|false
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
else|else
block|{
comment|// Put partial aggregation results in reduceValues
name|int
name|inputField
init|=
name|reduceKeys
operator|.
name|size
argument_list|()
decl_stmt|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|ASTNode
argument_list|>
name|entry
range|:
name|aggregationTrees
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|TypeInfo
name|type
init|=
name|reduceSinkInputRowResolver
operator|.
name|getColumnInfos
argument_list|()
operator|.
name|get
argument_list|(
name|inputField
argument_list|)
operator|.
name|getType
argument_list|()
decl_stmt|;
name|reduceValues
operator|.
name|add
argument_list|(
operator|new
name|exprNodeColumnDesc
argument_list|(
name|type
argument_list|,
name|getColumnInternalName
argument_list|(
name|inputField
argument_list|)
argument_list|,
literal|""
argument_list|,
literal|false
argument_list|)
argument_list|)
expr_stmt|;
name|inputField
operator|++
expr_stmt|;
name|outputColumnNames
operator|.
name|add
argument_list|(
name|getColumnInternalName
argument_list|(
name|reduceValues
operator|.
name|size
argument_list|()
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|String
name|field
init|=
name|Utilities
operator|.
name|ReduceField
operator|.
name|VALUE
operator|.
name|toString
argument_list|()
operator|+
literal|"."
operator|+
name|getColumnInternalName
argument_list|(
name|reduceValues
operator|.
name|size
argument_list|()
operator|-
literal|1
argument_list|)
decl_stmt|;
name|reduceSinkOutputRowResolver
operator|.
name|put
argument_list|(
literal|""
argument_list|,
operator|(
operator|(
name|ASTNode
operator|)
name|entry
operator|.
name|getValue
argument_list|()
operator|)
operator|.
name|toStringTree
argument_list|()
argument_list|,
operator|new
name|ColumnInfo
argument_list|(
name|field
argument_list|,
name|type
argument_list|,
literal|null
argument_list|,
literal|false
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|ReduceSinkOperator
name|rsOp
init|=
operator|(
name|ReduceSinkOperator
operator|)
name|putOpInsertMap
argument_list|(
name|OperatorFactory
operator|.
name|getAndMakeChild
argument_list|(
name|PlanUtils
operator|.
name|getReduceSinkDesc
argument_list|(
name|reduceKeys
argument_list|,
name|reduceValues
argument_list|,
name|outputColumnNames
argument_list|,
literal|true
argument_list|,
operator|-
literal|1
argument_list|,
name|numPartitionFields
argument_list|,
name|numReducers
argument_list|)
argument_list|,
operator|new
name|RowSchema
argument_list|(
name|reduceSinkOutputRowResolver
operator|.
name|getColumnInfos
argument_list|()
argument_list|)
argument_list|,
name|inputOperatorInfo
argument_list|)
argument_list|,
name|reduceSinkOutputRowResolver
argument_list|)
decl_stmt|;
name|rsOp
operator|.
name|setColumnExprMap
argument_list|(
name|colExprMap
argument_list|)
expr_stmt|;
return|return
name|rsOp
return|;
block|}
comment|/**    * Generate the second ReduceSinkOperator for the Group By Plan (parseInfo.getXXX(dest)).    * The new ReduceSinkOperator will be a child of groupByOperatorInfo.    *     * The second ReduceSinkOperator will put the group by keys in the map-reduce sort    * key, and put the partial aggregation results in the map-reduce value.     *      * @param numPartitionFields the number of fields in the map-reduce partition key.    *     This should always be the same as the number of Group By keys.  We should be     *     able to remove this parameter since in this phase there is no distinct any more.      * @return the new ReduceSinkOperator.    * @throws SemanticException    */
annotation|@
name|SuppressWarnings
argument_list|(
literal|"nls"
argument_list|)
specifier|private
name|Operator
name|genGroupByPlanReduceSinkOperator2MR
parameter_list|(
name|QBParseInfo
name|parseInfo
parameter_list|,
name|String
name|dest
parameter_list|,
name|Operator
name|groupByOperatorInfo
parameter_list|,
name|int
name|numPartitionFields
parameter_list|,
name|int
name|numReducers
parameter_list|)
throws|throws
name|SemanticException
block|{
name|RowResolver
name|reduceSinkInputRowResolver2
init|=
name|opParseCtx
operator|.
name|get
argument_list|(
name|groupByOperatorInfo
argument_list|)
operator|.
name|getRR
argument_list|()
decl_stmt|;
name|RowResolver
name|reduceSinkOutputRowResolver2
init|=
operator|new
name|RowResolver
argument_list|()
decl_stmt|;
name|reduceSinkOutputRowResolver2
operator|.
name|setIsExprResolver
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|exprNodeDesc
argument_list|>
name|colExprMap
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|exprNodeDesc
argument_list|>
argument_list|()
decl_stmt|;
name|ArrayList
argument_list|<
name|exprNodeDesc
argument_list|>
name|reduceKeys
init|=
operator|new
name|ArrayList
argument_list|<
name|exprNodeDesc
argument_list|>
argument_list|()
decl_stmt|;
name|ArrayList
argument_list|<
name|String
argument_list|>
name|outputColumnNames
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
comment|// Get group-by keys and store in reduceKeys
name|List
argument_list|<
name|ASTNode
argument_list|>
name|grpByExprs
init|=
name|getGroupByForClause
argument_list|(
name|parseInfo
argument_list|,
name|dest
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|grpByExprs
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|ASTNode
name|grpbyExpr
init|=
name|grpByExprs
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|String
name|field
init|=
name|getColumnInternalName
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|outputColumnNames
operator|.
name|add
argument_list|(
name|field
argument_list|)
expr_stmt|;
name|TypeInfo
name|typeInfo
init|=
name|reduceSinkInputRowResolver2
operator|.
name|get
argument_list|(
literal|""
argument_list|,
name|grpbyExpr
operator|.
name|toStringTree
argument_list|()
argument_list|)
operator|.
name|getType
argument_list|()
decl_stmt|;
name|exprNodeColumnDesc
name|inputExpr
init|=
operator|new
name|exprNodeColumnDesc
argument_list|(
name|typeInfo
argument_list|,
name|field
argument_list|,
literal|""
argument_list|,
literal|false
argument_list|)
decl_stmt|;
name|reduceKeys
operator|.
name|add
argument_list|(
name|inputExpr
argument_list|)
expr_stmt|;
name|ColumnInfo
name|colInfo
init|=
operator|new
name|ColumnInfo
argument_list|(
name|Utilities
operator|.
name|ReduceField
operator|.
name|KEY
operator|.
name|toString
argument_list|()
operator|+
literal|"."
operator|+
name|field
argument_list|,
name|typeInfo
argument_list|,
literal|""
argument_list|,
literal|false
argument_list|)
decl_stmt|;
name|reduceSinkOutputRowResolver2
operator|.
name|put
argument_list|(
literal|""
argument_list|,
name|grpbyExpr
operator|.
name|toStringTree
argument_list|()
argument_list|,
name|colInfo
argument_list|)
expr_stmt|;
name|colExprMap
operator|.
name|put
argument_list|(
name|colInfo
operator|.
name|getInternalName
argument_list|()
argument_list|,
name|inputExpr
argument_list|)
expr_stmt|;
block|}
comment|// Get partial aggregation results and store in reduceValues
name|ArrayList
argument_list|<
name|exprNodeDesc
argument_list|>
name|reduceValues
init|=
operator|new
name|ArrayList
argument_list|<
name|exprNodeDesc
argument_list|>
argument_list|()
decl_stmt|;
name|int
name|inputField
init|=
name|reduceKeys
operator|.
name|size
argument_list|()
decl_stmt|;
name|HashMap
argument_list|<
name|String
argument_list|,
name|ASTNode
argument_list|>
name|aggregationTrees
init|=
name|parseInfo
operator|.
name|getAggregationExprsForClause
argument_list|(
name|dest
argument_list|)
decl_stmt|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|ASTNode
argument_list|>
name|entry
range|:
name|aggregationTrees
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|String
name|field
init|=
name|getColumnInternalName
argument_list|(
name|inputField
argument_list|)
decl_stmt|;
name|ASTNode
name|t
init|=
name|entry
operator|.
name|getValue
argument_list|()
decl_stmt|;
name|TypeInfo
name|typeInfo
init|=
name|reduceSinkInputRowResolver2
operator|.
name|get
argument_list|(
literal|""
argument_list|,
name|t
operator|.
name|toStringTree
argument_list|()
argument_list|)
operator|.
name|getType
argument_list|()
decl_stmt|;
name|reduceValues
operator|.
name|add
argument_list|(
operator|new
name|exprNodeColumnDesc
argument_list|(
name|typeInfo
argument_list|,
name|field
argument_list|,
literal|""
argument_list|,
literal|false
argument_list|)
argument_list|)
expr_stmt|;
name|inputField
operator|++
expr_stmt|;
name|String
name|col
init|=
name|getColumnInternalName
argument_list|(
name|reduceValues
operator|.
name|size
argument_list|()
operator|-
literal|1
argument_list|)
decl_stmt|;
name|outputColumnNames
operator|.
name|add
argument_list|(
name|col
argument_list|)
expr_stmt|;
name|reduceSinkOutputRowResolver2
operator|.
name|put
argument_list|(
literal|""
argument_list|,
name|t
operator|.
name|toStringTree
argument_list|()
argument_list|,
operator|new
name|ColumnInfo
argument_list|(
name|Utilities
operator|.
name|ReduceField
operator|.
name|VALUE
operator|.
name|toString
argument_list|()
operator|+
literal|"."
operator|+
name|col
argument_list|,
name|typeInfo
argument_list|,
literal|""
argument_list|,
literal|false
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|ReduceSinkOperator
name|rsOp
init|=
operator|(
name|ReduceSinkOperator
operator|)
name|putOpInsertMap
argument_list|(
name|OperatorFactory
operator|.
name|getAndMakeChild
argument_list|(
name|PlanUtils
operator|.
name|getReduceSinkDesc
argument_list|(
name|reduceKeys
argument_list|,
name|reduceValues
argument_list|,
name|outputColumnNames
argument_list|,
literal|true
argument_list|,
operator|-
literal|1
argument_list|,
name|numPartitionFields
argument_list|,
name|numReducers
argument_list|)
argument_list|,
operator|new
name|RowSchema
argument_list|(
name|reduceSinkOutputRowResolver2
operator|.
name|getColumnInfos
argument_list|()
argument_list|)
argument_list|,
name|groupByOperatorInfo
argument_list|)
argument_list|,
name|reduceSinkOutputRowResolver2
argument_list|)
decl_stmt|;
name|rsOp
operator|.
name|setColumnExprMap
argument_list|(
name|colExprMap
argument_list|)
expr_stmt|;
return|return
name|rsOp
return|;
block|}
comment|/**    * Generate the second GroupByOperator for the Group By Plan (parseInfo.getXXX(dest)).    * The new GroupByOperator will do the second aggregation based on the partial aggregation     * results.    *     * @param mode the mode of aggregation (FINAL)      * @param genericUDAFEvaluators  The mapping from Aggregation StringTree to the     *            genericUDAFEvaluator.     * @return the new GroupByOperator    * @throws SemanticException    */
annotation|@
name|SuppressWarnings
argument_list|(
literal|"nls"
argument_list|)
specifier|private
name|Operator
name|genGroupByPlanGroupByOperator2MR
parameter_list|(
name|QBParseInfo
name|parseInfo
parameter_list|,
name|String
name|dest
parameter_list|,
name|Operator
name|reduceSinkOperatorInfo2
parameter_list|,
name|groupByDesc
operator|.
name|Mode
name|mode
parameter_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|GenericUDAFEvaluator
argument_list|>
name|genericUDAFEvaluators
parameter_list|)
throws|throws
name|SemanticException
block|{
name|RowResolver
name|groupByInputRowResolver2
init|=
name|opParseCtx
operator|.
name|get
argument_list|(
name|reduceSinkOperatorInfo2
argument_list|)
operator|.
name|getRR
argument_list|()
decl_stmt|;
name|RowResolver
name|groupByOutputRowResolver2
init|=
operator|new
name|RowResolver
argument_list|()
decl_stmt|;
name|groupByOutputRowResolver2
operator|.
name|setIsExprResolver
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|ArrayList
argument_list|<
name|exprNodeDesc
argument_list|>
name|groupByKeys
init|=
operator|new
name|ArrayList
argument_list|<
name|exprNodeDesc
argument_list|>
argument_list|()
decl_stmt|;
name|ArrayList
argument_list|<
name|aggregationDesc
argument_list|>
name|aggregations
init|=
operator|new
name|ArrayList
argument_list|<
name|aggregationDesc
argument_list|>
argument_list|()
decl_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|exprNodeDesc
argument_list|>
name|colExprMap
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|exprNodeDesc
argument_list|>
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|ASTNode
argument_list|>
name|grpByExprs
init|=
name|getGroupByForClause
argument_list|(
name|parseInfo
argument_list|,
name|dest
argument_list|)
decl_stmt|;
name|ArrayList
argument_list|<
name|String
argument_list|>
name|outputColumnNames
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|grpByExprs
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|ASTNode
name|grpbyExpr
init|=
name|grpByExprs
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|String
name|text
init|=
name|grpbyExpr
operator|.
name|toStringTree
argument_list|()
decl_stmt|;
name|ColumnInfo
name|exprInfo
init|=
name|groupByInputRowResolver2
operator|.
name|get
argument_list|(
literal|""
argument_list|,
name|text
argument_list|)
decl_stmt|;
if|if
condition|(
name|exprInfo
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|INVALID_COLUMN
operator|.
name|getMsg
argument_list|(
name|grpbyExpr
argument_list|)
argument_list|)
throw|;
block|}
name|String
name|expression
init|=
name|exprInfo
operator|.
name|getInternalName
argument_list|()
decl_stmt|;
name|groupByKeys
operator|.
name|add
argument_list|(
operator|new
name|exprNodeColumnDesc
argument_list|(
name|exprInfo
operator|.
name|getType
argument_list|()
argument_list|,
name|expression
argument_list|,
name|exprInfo
operator|.
name|getTabAlias
argument_list|()
argument_list|,
name|exprInfo
operator|.
name|getIsPartitionCol
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|String
name|field
init|=
name|getColumnInternalName
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|outputColumnNames
operator|.
name|add
argument_list|(
name|field
argument_list|)
expr_stmt|;
name|groupByOutputRowResolver2
operator|.
name|put
argument_list|(
literal|""
argument_list|,
name|grpbyExpr
operator|.
name|toStringTree
argument_list|()
argument_list|,
operator|new
name|ColumnInfo
argument_list|(
name|field
argument_list|,
name|exprInfo
operator|.
name|getType
argument_list|()
argument_list|,
literal|""
argument_list|,
literal|false
argument_list|)
argument_list|)
expr_stmt|;
name|colExprMap
operator|.
name|put
argument_list|(
name|field
argument_list|,
name|groupByKeys
operator|.
name|get
argument_list|(
name|groupByKeys
operator|.
name|size
argument_list|()
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|HashMap
argument_list|<
name|String
argument_list|,
name|ASTNode
argument_list|>
name|aggregationTrees
init|=
name|parseInfo
operator|.
name|getAggregationExprsForClause
argument_list|(
name|dest
argument_list|)
decl_stmt|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|ASTNode
argument_list|>
name|entry
range|:
name|aggregationTrees
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|ArrayList
argument_list|<
name|exprNodeDesc
argument_list|>
name|aggParameters
init|=
operator|new
name|ArrayList
argument_list|<
name|exprNodeDesc
argument_list|>
argument_list|()
decl_stmt|;
name|ASTNode
name|value
init|=
name|entry
operator|.
name|getValue
argument_list|()
decl_stmt|;
name|String
name|text
init|=
name|entry
operator|.
name|getKey
argument_list|()
decl_stmt|;
name|ColumnInfo
name|paraExprInfo
init|=
name|groupByInputRowResolver2
operator|.
name|get
argument_list|(
literal|""
argument_list|,
name|text
argument_list|)
decl_stmt|;
if|if
condition|(
name|paraExprInfo
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|INVALID_COLUMN
operator|.
name|getMsg
argument_list|(
name|value
argument_list|)
argument_list|)
throw|;
block|}
name|String
name|paraExpression
init|=
name|paraExprInfo
operator|.
name|getInternalName
argument_list|()
decl_stmt|;
assert|assert
operator|(
name|paraExpression
operator|!=
literal|null
operator|)
assert|;
name|aggParameters
operator|.
name|add
argument_list|(
operator|new
name|exprNodeColumnDesc
argument_list|(
name|paraExprInfo
operator|.
name|getType
argument_list|()
argument_list|,
name|paraExpression
argument_list|,
name|paraExprInfo
operator|.
name|getTabAlias
argument_list|()
argument_list|,
name|paraExprInfo
operator|.
name|getIsPartitionCol
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|String
name|aggName
init|=
name|value
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getText
argument_list|()
decl_stmt|;
name|boolean
name|isDistinct
init|=
name|value
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_FUNCTIONDI
decl_stmt|;
name|Mode
name|amode
init|=
name|groupByDescModeToUDAFMode
argument_list|(
name|mode
argument_list|,
name|isDistinct
argument_list|)
decl_stmt|;
name|GenericUDAFEvaluator
name|genericUDAFEvaluator
init|=
name|genericUDAFEvaluators
operator|.
name|get
argument_list|(
name|entry
operator|.
name|getKey
argument_list|()
argument_list|)
decl_stmt|;
assert|assert
operator|(
name|genericUDAFEvaluator
operator|!=
literal|null
operator|)
assert|;
name|GenericUDAFInfo
name|udaf
init|=
name|getGenericUDAFInfo
argument_list|(
name|genericUDAFEvaluator
argument_list|,
name|amode
argument_list|,
name|aggParameters
argument_list|)
decl_stmt|;
name|aggregations
operator|.
name|add
argument_list|(
operator|new
name|aggregationDesc
argument_list|(
name|aggName
operator|.
name|toLowerCase
argument_list|()
argument_list|,
name|udaf
operator|.
name|genericUDAFEvaluator
argument_list|,
name|udaf
operator|.
name|convertedParameters
argument_list|,
operator|(
name|mode
operator|!=
name|groupByDesc
operator|.
name|Mode
operator|.
name|FINAL
operator|&&
name|value
operator|.
name|getToken
argument_list|()
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_FUNCTIONDI
operator|)
argument_list|,
name|amode
argument_list|)
argument_list|)
expr_stmt|;
name|String
name|field
init|=
name|getColumnInternalName
argument_list|(
name|groupByKeys
operator|.
name|size
argument_list|()
operator|+
name|aggregations
operator|.
name|size
argument_list|()
operator|-
literal|1
argument_list|)
decl_stmt|;
name|outputColumnNames
operator|.
name|add
argument_list|(
name|field
argument_list|)
expr_stmt|;
name|groupByOutputRowResolver2
operator|.
name|put
argument_list|(
literal|""
argument_list|,
name|value
operator|.
name|toStringTree
argument_list|()
argument_list|,
operator|new
name|ColumnInfo
argument_list|(
name|field
argument_list|,
name|udaf
operator|.
name|returnType
argument_list|,
literal|""
argument_list|,
literal|false
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|Operator
name|op
init|=
name|putOpInsertMap
argument_list|(
name|OperatorFactory
operator|.
name|getAndMakeChild
argument_list|(
operator|new
name|groupByDesc
argument_list|(
name|mode
argument_list|,
name|outputColumnNames
argument_list|,
name|groupByKeys
argument_list|,
name|aggregations
argument_list|,
literal|false
argument_list|)
argument_list|,
operator|new
name|RowSchema
argument_list|(
name|groupByOutputRowResolver2
operator|.
name|getColumnInfos
argument_list|()
argument_list|)
argument_list|,
name|reduceSinkOperatorInfo2
argument_list|)
argument_list|,
name|groupByOutputRowResolver2
argument_list|)
decl_stmt|;
name|op
operator|.
name|setColumnExprMap
argument_list|(
name|colExprMap
argument_list|)
expr_stmt|;
return|return
name|op
return|;
block|}
comment|/**    * Generate a Group-By plan using a single map-reduce job (3 operators will be    * inserted):    *    * ReduceSink ( keys = (K1_EXP, K2_EXP, DISTINCT_EXP), values = (A1_EXP,    * A2_EXP) ) SortGroupBy (keys = (KEY.0,KEY.1), aggregations =    * (count_distinct(KEY.2), sum(VALUE.0), count(VALUE.1))) Select (final    * selects)    *    * @param dest    * @param qb    * @param input    * @return    * @throws SemanticException    *    * Generate a Group-By plan using 1 map-reduce job.     * Spray by the group by key, and sort by the distinct key (if any), and     * compute aggregates   *     * The agggregation evaluation functions are as follows:    *   Partitioning Key:     *      grouping key    *    *   Sorting Key:     *      grouping key if no DISTINCT    *      grouping + distinct key if DISTINCT    *     *   Reducer: iterate/merge    *   (mode = COMPLETE)    **/
annotation|@
name|SuppressWarnings
argument_list|(
block|{
literal|"unused"
block|,
literal|"nls"
block|}
argument_list|)
specifier|private
name|Operator
name|genGroupByPlan1MR
parameter_list|(
name|String
name|dest
parameter_list|,
name|QB
name|qb
parameter_list|,
name|Operator
name|input
parameter_list|)
throws|throws
name|SemanticException
block|{
name|QBParseInfo
name|parseInfo
init|=
name|qb
operator|.
name|getParseInfo
argument_list|()
decl_stmt|;
name|int
name|numReducers
init|=
operator|-
literal|1
decl_stmt|;
name|List
argument_list|<
name|ASTNode
argument_list|>
name|grpByExprs
init|=
name|getGroupByForClause
argument_list|(
name|parseInfo
argument_list|,
name|dest
argument_list|)
decl_stmt|;
if|if
condition|(
name|grpByExprs
operator|.
name|isEmpty
argument_list|()
condition|)
name|numReducers
operator|=
literal|1
expr_stmt|;
comment|// ////// 1. Generate ReduceSinkOperator
name|Operator
name|reduceSinkOperatorInfo
init|=
name|genGroupByPlanReduceSinkOperator
argument_list|(
name|qb
argument_list|,
name|dest
argument_list|,
name|input
argument_list|,
name|grpByExprs
operator|.
name|size
argument_list|()
argument_list|,
name|numReducers
argument_list|,
literal|false
argument_list|)
decl_stmt|;
comment|// ////// 2. Generate GroupbyOperator
name|Operator
name|groupByOperatorInfo
init|=
name|genGroupByPlanGroupByOperator
argument_list|(
name|parseInfo
argument_list|,
name|dest
argument_list|,
name|reduceSinkOperatorInfo
argument_list|,
name|groupByDesc
operator|.
name|Mode
operator|.
name|COMPLETE
argument_list|,
literal|null
argument_list|)
decl_stmt|;
return|return
name|groupByOperatorInfo
return|;
block|}
specifier|static
name|ArrayList
argument_list|<
name|GenericUDAFEvaluator
argument_list|>
name|getUDAFEvaluators
parameter_list|(
name|ArrayList
argument_list|<
name|aggregationDesc
argument_list|>
name|aggs
parameter_list|)
block|{
name|ArrayList
argument_list|<
name|GenericUDAFEvaluator
argument_list|>
name|result
init|=
operator|new
name|ArrayList
argument_list|<
name|GenericUDAFEvaluator
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|aggs
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|result
operator|.
name|add
argument_list|(
name|aggs
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|getGenericUDAFEvaluator
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
comment|/**    * Generate a Multi Group-By plan using a 2 map-reduce jobs.    * @param dest    * @param qb    * @param input    * @return    * @throws SemanticException    *    * Generate a Group-By plan using a 2 map-reduce jobs.     * Spray by the distinct key in hope of getting a uniform distribution, and compute partial aggregates     * by the grouping key.    * Evaluate partial aggregates first, and spray by the grouping key to compute actual    * aggregates in the second phase.    * The agggregation evaluation functions are as follows:    *   Partitioning Key:     *     distinct key    *    *   Sorting Key:     *     distinct key    *     *   Reducer: iterate/terminatePartial    *   (mode = PARTIAL1)    *     *   STAGE 2    *    *   Partitioning Key:     *      grouping key     *    *   Sorting Key:     *      grouping key     *    *   Reducer: merge/terminate    *   (mode = FINAL)    */
annotation|@
name|SuppressWarnings
argument_list|(
literal|"nls"
argument_list|)
specifier|private
name|Operator
name|genGroupByPlan2MRMultiGroupBy
parameter_list|(
name|String
name|dest
parameter_list|,
name|QB
name|qb
parameter_list|,
name|Operator
name|input
parameter_list|)
throws|throws
name|SemanticException
block|{
comment|// ////// Generate GroupbyOperator for a map-side partial aggregation
name|Map
argument_list|<
name|String
argument_list|,
name|GenericUDAFEvaluator
argument_list|>
name|genericUDAFEvaluators
init|=
operator|new
name|LinkedHashMap
argument_list|<
name|String
argument_list|,
name|GenericUDAFEvaluator
argument_list|>
argument_list|()
decl_stmt|;
name|QBParseInfo
name|parseInfo
init|=
name|qb
operator|.
name|getParseInfo
argument_list|()
decl_stmt|;
comment|// ////// 2. Generate GroupbyOperator
name|Operator
name|groupByOperatorInfo
init|=
name|genGroupByPlanGroupByOperator1
argument_list|(
name|parseInfo
argument_list|,
name|dest
argument_list|,
name|input
argument_list|,
name|groupByDesc
operator|.
name|Mode
operator|.
name|HASH
argument_list|,
name|genericUDAFEvaluators
argument_list|,
literal|true
argument_list|)
decl_stmt|;
name|int
name|numReducers
init|=
operator|-
literal|1
decl_stmt|;
name|List
argument_list|<
name|ASTNode
argument_list|>
name|grpByExprs
init|=
name|getGroupByForClause
argument_list|(
name|parseInfo
argument_list|,
name|dest
argument_list|)
decl_stmt|;
comment|// ////// 3. Generate ReduceSinkOperator2
name|Operator
name|reduceSinkOperatorInfo2
init|=
name|genGroupByPlanReduceSinkOperator2MR
argument_list|(
name|parseInfo
argument_list|,
name|dest
argument_list|,
name|groupByOperatorInfo
argument_list|,
name|grpByExprs
operator|.
name|size
argument_list|()
argument_list|,
name|numReducers
argument_list|)
decl_stmt|;
comment|// ////// 4. Generate GroupbyOperator2
name|Operator
name|groupByOperatorInfo2
init|=
name|genGroupByPlanGroupByOperator2MR
argument_list|(
name|parseInfo
argument_list|,
name|dest
argument_list|,
name|reduceSinkOperatorInfo2
argument_list|,
name|groupByDesc
operator|.
name|Mode
operator|.
name|FINAL
argument_list|,
name|genericUDAFEvaluators
argument_list|)
decl_stmt|;
return|return
name|groupByOperatorInfo2
return|;
block|}
comment|/**    * Generate a Group-By plan using a 2 map-reduce jobs (5 operators will be    * inserted):    *    * ReduceSink ( keys = (K1_EXP, K2_EXP, DISTINCT_EXP), values = (A1_EXP,    * A2_EXP) ) NOTE: If DISTINCT_EXP is null, partition by rand() SortGroupBy    * (keys = (KEY.0,KEY.1), aggregations = (count_distinct(KEY.2), sum(VALUE.0),    * count(VALUE.1))) ReduceSink ( keys = (0,1), values=(2,3,4)) SortGroupBy    * (keys = (KEY.0,KEY.1), aggregations = (sum(VALUE.0), sum(VALUE.1),    * sum(VALUE.2))) Select (final selects)    *    * @param dest    * @param qb    * @param input    * @return    * @throws SemanticException    *    * Generate a Group-By plan using a 2 map-reduce jobs.     * Spray by the grouping key and distinct key (or a random number, if no distinct is     * present) in hope of getting a uniform distribution, and compute partial aggregates     * grouped by the reduction key (grouping key + distinct key).    * Evaluate partial aggregates first, and spray by the grouping key to compute actual    * aggregates in the second phase.    * The agggregation evaluation functions are as follows:    *   Partitioning Key:     *      random() if no DISTINCT    *      grouping + distinct key if DISTINCT    *    *   Sorting Key:     *      grouping key if no DISTINCT    *      grouping + distinct key if DISTINCT    *     *   Reducer: iterate/terminatePartial    *   (mode = PARTIAL1)    *     *   STAGE 2    *    *   Partitioning Key:     *      grouping key     *    *   Sorting Key:     *      grouping key if no DISTINCT    *      grouping + distinct key if DISTINCT    *    *   Reducer: merge/terminate    *   (mode = FINAL)    */
annotation|@
name|SuppressWarnings
argument_list|(
literal|"nls"
argument_list|)
specifier|private
name|Operator
name|genGroupByPlan2MR
parameter_list|(
name|String
name|dest
parameter_list|,
name|QB
name|qb
parameter_list|,
name|Operator
name|input
parameter_list|)
throws|throws
name|SemanticException
block|{
name|QBParseInfo
name|parseInfo
init|=
name|qb
operator|.
name|getParseInfo
argument_list|()
decl_stmt|;
comment|// ////// 1. Generate ReduceSinkOperator
comment|// There is a special case when we want the rows to be randomly distributed to
comment|// reducers for load balancing problem.  That happens when there is no DISTINCT
comment|// operator.  We set the numPartitionColumns to -1 for this purpose.  This is
comment|// captured by WritableComparableHiveObject.hashCode() function.
name|Operator
name|reduceSinkOperatorInfo
init|=
name|genGroupByPlanReduceSinkOperator
argument_list|(
name|qb
argument_list|,
name|dest
argument_list|,
name|input
argument_list|,
operator|(
name|parseInfo
operator|.
name|getDistinctFuncExprForClause
argument_list|(
name|dest
argument_list|)
operator|==
literal|null
condition|?
operator|-
literal|1
else|:
name|Integer
operator|.
name|MAX_VALUE
operator|)
argument_list|,
operator|-
literal|1
argument_list|,
literal|false
argument_list|)
decl_stmt|;
comment|// ////// 2. Generate GroupbyOperator
name|Map
argument_list|<
name|String
argument_list|,
name|GenericUDAFEvaluator
argument_list|>
name|genericUDAFEvaluators
init|=
operator|new
name|LinkedHashMap
argument_list|<
name|String
argument_list|,
name|GenericUDAFEvaluator
argument_list|>
argument_list|()
decl_stmt|;
name|GroupByOperator
name|groupByOperatorInfo
init|=
operator|(
name|GroupByOperator
operator|)
name|genGroupByPlanGroupByOperator
argument_list|(
name|parseInfo
argument_list|,
name|dest
argument_list|,
name|reduceSinkOperatorInfo
argument_list|,
name|groupByDesc
operator|.
name|Mode
operator|.
name|PARTIAL1
argument_list|,
name|genericUDAFEvaluators
argument_list|)
decl_stmt|;
name|int
name|numReducers
init|=
operator|-
literal|1
decl_stmt|;
name|List
argument_list|<
name|ASTNode
argument_list|>
name|grpByExprs
init|=
name|getGroupByForClause
argument_list|(
name|parseInfo
argument_list|,
name|dest
argument_list|)
decl_stmt|;
if|if
condition|(
name|grpByExprs
operator|.
name|isEmpty
argument_list|()
condition|)
name|numReducers
operator|=
literal|1
expr_stmt|;
comment|// ////// 3. Generate ReduceSinkOperator2
name|Operator
name|reduceSinkOperatorInfo2
init|=
name|genGroupByPlanReduceSinkOperator2MR
argument_list|(
name|parseInfo
argument_list|,
name|dest
argument_list|,
name|groupByOperatorInfo
argument_list|,
name|grpByExprs
operator|.
name|size
argument_list|()
argument_list|,
name|numReducers
argument_list|)
decl_stmt|;
comment|// ////// 4. Generate GroupbyOperator2
name|Operator
name|groupByOperatorInfo2
init|=
name|genGroupByPlanGroupByOperator2MR
argument_list|(
name|parseInfo
argument_list|,
name|dest
argument_list|,
name|reduceSinkOperatorInfo2
argument_list|,
name|groupByDesc
operator|.
name|Mode
operator|.
name|FINAL
argument_list|,
name|genericUDAFEvaluators
argument_list|)
decl_stmt|;
return|return
name|groupByOperatorInfo2
return|;
block|}
specifier|private
name|boolean
name|optimizeMapAggrGroupBy
parameter_list|(
name|String
name|dest
parameter_list|,
name|QB
name|qb
parameter_list|)
block|{
name|List
argument_list|<
name|ASTNode
argument_list|>
name|grpByExprs
init|=
name|getGroupByForClause
argument_list|(
name|qb
operator|.
name|getParseInfo
argument_list|()
argument_list|,
name|dest
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|grpByExprs
operator|!=
literal|null
operator|)
operator|&&
operator|!
name|grpByExprs
operator|.
name|isEmpty
argument_list|()
condition|)
return|return
literal|false
return|;
if|if
condition|(
name|qb
operator|.
name|getParseInfo
argument_list|()
operator|.
name|getDistinctFuncExprForClause
argument_list|(
name|dest
argument_list|)
operator|!=
literal|null
condition|)
return|return
literal|false
return|;
return|return
literal|true
return|;
block|}
comment|/**    * Generate a Group-By plan using 1 map-reduce job.     * First perform a map-side partial aggregation (to reduce the amount of data), at this    * point of time, we may turn off map-side partial aggregation based on its performance.     * Then spray by the group by key, and sort by the distinct key (if any), and     * compute aggregates based on actual aggregates    *     * The agggregation evaluation functions are as follows:    *   Mapper: iterate/terminatePartial          *   (mode = HASH)    *    *   Partitioning Key:     *      grouping key    *    *   Sorting Key:     *      grouping key if no DISTINCT    *      grouping + distinct key if DISTINCT    *     *   Reducer: iterate/terminate if DISTINCT    *            merge/terminate if NO DISTINCT    *   (mode = MERGEPARTIAL)    */
annotation|@
name|SuppressWarnings
argument_list|(
literal|"nls"
argument_list|)
specifier|private
name|Operator
name|genGroupByPlanMapAggr1MR
parameter_list|(
name|String
name|dest
parameter_list|,
name|QB
name|qb
parameter_list|,
name|Operator
name|inputOperatorInfo
parameter_list|)
throws|throws
name|SemanticException
block|{
name|QBParseInfo
name|parseInfo
init|=
name|qb
operator|.
name|getParseInfo
argument_list|()
decl_stmt|;
comment|// ////// Generate GroupbyOperator for a map-side partial aggregation
name|Map
argument_list|<
name|String
argument_list|,
name|GenericUDAFEvaluator
argument_list|>
name|genericUDAFEvaluators
init|=
operator|new
name|LinkedHashMap
argument_list|<
name|String
argument_list|,
name|GenericUDAFEvaluator
argument_list|>
argument_list|()
decl_stmt|;
name|GroupByOperator
name|groupByOperatorInfo
init|=
operator|(
name|GroupByOperator
operator|)
name|genGroupByPlanMapGroupByOperator
argument_list|(
name|qb
argument_list|,
name|dest
argument_list|,
name|inputOperatorInfo
argument_list|,
name|groupByDesc
operator|.
name|Mode
operator|.
name|HASH
argument_list|,
name|genericUDAFEvaluators
argument_list|)
decl_stmt|;
name|int
name|numReducers
init|=
operator|-
literal|1
decl_stmt|;
comment|// Optimize the scenario when there are no grouping keys - only 1 reducer is needed
name|List
argument_list|<
name|ASTNode
argument_list|>
name|grpByExprs
init|=
name|getGroupByForClause
argument_list|(
name|parseInfo
argument_list|,
name|dest
argument_list|)
decl_stmt|;
if|if
condition|(
name|grpByExprs
operator|.
name|isEmpty
argument_list|()
condition|)
name|numReducers
operator|=
literal|1
expr_stmt|;
comment|// ////// Generate ReduceSink Operator
name|Operator
name|reduceSinkOperatorInfo
init|=
name|genGroupByPlanReduceSinkOperator
argument_list|(
name|qb
argument_list|,
name|dest
argument_list|,
name|groupByOperatorInfo
argument_list|,
name|grpByExprs
operator|.
name|size
argument_list|()
argument_list|,
name|numReducers
argument_list|,
literal|true
argument_list|)
decl_stmt|;
comment|// This is a 1-stage map-reduce processing of the groupby. Tha map-side aggregates was just used to
comment|// reduce output data. In case of distincts, partial results are not used, and so iterate is again
comment|// invoked on the reducer. In case of non-distincts, partial results are used, and merge is invoked
comment|// on the reducer.
return|return
name|genGroupByPlanGroupByOperator1
argument_list|(
name|parseInfo
argument_list|,
name|dest
argument_list|,
name|reduceSinkOperatorInfo
argument_list|,
name|groupByDesc
operator|.
name|Mode
operator|.
name|MERGEPARTIAL
argument_list|,
name|genericUDAFEvaluators
argument_list|,
literal|false
argument_list|)
return|;
block|}
comment|/**    * Generate a Group-By plan using a 2 map-reduce jobs.     * However, only 1 group-by plan is generated if the query involves no grouping key and    * no distincts. In that case, the plan is same as generated by genGroupByPlanMapAggr1MR.    * Otherwise, the following plan is generated:    * First perform a map side partial aggregation (to reduce the amount of data). Then     * spray by the grouping key and distinct key (or a random number, if no distinct is     * present) in hope of getting a uniform distribution, and compute partial aggregates     * grouped by the reduction key (grouping key + distinct key).    * Evaluate partial aggregates first, and spray by the grouping key to compute actual    * aggregates in the second phase.    * The agggregation evaluation functions are as follows:    *   Mapper: iterate/terminatePartial          *   (mode = HASH)    *     *   Partitioning Key:     *      random() if no DISTINCT    *      grouping + distinct key if DISTINCT    *    *   Sorting Key:     *      grouping key if no DISTINCT    *      grouping + distinct key if DISTINCT    *     *   Reducer: iterate/terminatePartial if DISTINCT    *            merge/terminatePartial if NO DISTINCT    *   (mode = MERGEPARTIAL)    *     *   STAGE 2    *    *   Partitioining Key:     *      grouping key     *    *   Sorting Key:     *      grouping key if no DISTINCT    *      grouping + distinct key if DISTINCT    *    *   Reducer: merge/terminate    *   (mode = FINAL)    */
annotation|@
name|SuppressWarnings
argument_list|(
literal|"nls"
argument_list|)
specifier|private
name|Operator
name|genGroupByPlanMapAggr2MR
parameter_list|(
name|String
name|dest
parameter_list|,
name|QB
name|qb
parameter_list|,
name|Operator
name|inputOperatorInfo
parameter_list|)
throws|throws
name|SemanticException
block|{
name|QBParseInfo
name|parseInfo
init|=
name|qb
operator|.
name|getParseInfo
argument_list|()
decl_stmt|;
comment|// ////// Generate GroupbyOperator for a map-side partial aggregation
name|Map
argument_list|<
name|String
argument_list|,
name|GenericUDAFEvaluator
argument_list|>
name|genericUDAFEvaluators
init|=
operator|new
name|LinkedHashMap
argument_list|<
name|String
argument_list|,
name|GenericUDAFEvaluator
argument_list|>
argument_list|()
decl_stmt|;
name|GroupByOperator
name|groupByOperatorInfo
init|=
operator|(
name|GroupByOperator
operator|)
name|genGroupByPlanMapGroupByOperator
argument_list|(
name|qb
argument_list|,
name|dest
argument_list|,
name|inputOperatorInfo
argument_list|,
name|groupByDesc
operator|.
name|Mode
operator|.
name|HASH
argument_list|,
name|genericUDAFEvaluators
argument_list|)
decl_stmt|;
comment|// Optimize the scenario when there are no grouping keys and no distinct - 2 map-reduce jobs are not needed
comment|// For eg: select count(1) from T where t.ds = ....
if|if
condition|(
operator|!
name|optimizeMapAggrGroupBy
argument_list|(
name|dest
argument_list|,
name|qb
argument_list|)
condition|)
block|{
comment|// ////// Generate ReduceSink Operator
name|Operator
name|reduceSinkOperatorInfo
init|=
name|genGroupByPlanReduceSinkOperator
argument_list|(
name|qb
argument_list|,
name|dest
argument_list|,
name|groupByOperatorInfo
argument_list|,
operator|(
name|parseInfo
operator|.
name|getDistinctFuncExprForClause
argument_list|(
name|dest
argument_list|)
operator|==
literal|null
condition|?
operator|-
literal|1
else|:
name|Integer
operator|.
name|MAX_VALUE
operator|)
argument_list|,
operator|-
literal|1
argument_list|,
literal|true
argument_list|)
decl_stmt|;
comment|// ////// Generate GroupbyOperator for a partial aggregation
name|Operator
name|groupByOperatorInfo2
init|=
name|genGroupByPlanGroupByOperator1
argument_list|(
name|parseInfo
argument_list|,
name|dest
argument_list|,
name|reduceSinkOperatorInfo
argument_list|,
name|groupByDesc
operator|.
name|Mode
operator|.
name|PARTIALS
argument_list|,
name|genericUDAFEvaluators
argument_list|,
literal|false
argument_list|)
decl_stmt|;
name|int
name|numReducers
init|=
operator|-
literal|1
decl_stmt|;
name|List
argument_list|<
name|ASTNode
argument_list|>
name|grpByExprs
init|=
name|getGroupByForClause
argument_list|(
name|parseInfo
argument_list|,
name|dest
argument_list|)
decl_stmt|;
if|if
condition|(
name|grpByExprs
operator|.
name|isEmpty
argument_list|()
condition|)
name|numReducers
operator|=
literal|1
expr_stmt|;
comment|// //////  Generate ReduceSinkOperator2
name|Operator
name|reduceSinkOperatorInfo2
init|=
name|genGroupByPlanReduceSinkOperator2MR
argument_list|(
name|parseInfo
argument_list|,
name|dest
argument_list|,
name|groupByOperatorInfo2
argument_list|,
name|grpByExprs
operator|.
name|size
argument_list|()
argument_list|,
name|numReducers
argument_list|)
decl_stmt|;
comment|// ////// Generate GroupbyOperator3
return|return
name|genGroupByPlanGroupByOperator2MR
argument_list|(
name|parseInfo
argument_list|,
name|dest
argument_list|,
name|reduceSinkOperatorInfo2
argument_list|,
name|groupByDesc
operator|.
name|Mode
operator|.
name|FINAL
argument_list|,
name|genericUDAFEvaluators
argument_list|)
return|;
block|}
else|else
block|{
comment|// ////// Generate ReduceSink Operator
name|Operator
name|reduceSinkOperatorInfo
init|=
name|genGroupByPlanReduceSinkOperator
argument_list|(
name|qb
argument_list|,
name|dest
argument_list|,
name|groupByOperatorInfo
argument_list|,
name|getGroupByForClause
argument_list|(
name|parseInfo
argument_list|,
name|dest
argument_list|)
operator|.
name|size
argument_list|()
argument_list|,
literal|1
argument_list|,
literal|true
argument_list|)
decl_stmt|;
return|return
name|genGroupByPlanGroupByOperator2MR
argument_list|(
name|parseInfo
argument_list|,
name|dest
argument_list|,
name|reduceSinkOperatorInfo
argument_list|,
name|groupByDesc
operator|.
name|Mode
operator|.
name|FINAL
argument_list|,
name|genericUDAFEvaluators
argument_list|)
return|;
block|}
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"nls"
argument_list|)
specifier|private
name|Operator
name|genConversionOps
parameter_list|(
name|String
name|dest
parameter_list|,
name|QB
name|qb
parameter_list|,
name|Operator
name|input
parameter_list|)
throws|throws
name|SemanticException
block|{
name|Integer
name|dest_type
init|=
name|qb
operator|.
name|getMetaData
argument_list|()
operator|.
name|getDestTypeForAlias
argument_list|(
name|dest
argument_list|)
decl_stmt|;
name|Table
name|dest_tab
init|=
literal|null
decl_stmt|;
switch|switch
condition|(
name|dest_type
operator|.
name|intValue
argument_list|()
condition|)
block|{
case|case
name|QBMetaData
operator|.
name|DEST_TABLE
case|:
block|{
name|dest_tab
operator|=
name|qb
operator|.
name|getMetaData
argument_list|()
operator|.
name|getDestTableForAlias
argument_list|(
name|dest
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|QBMetaData
operator|.
name|DEST_PARTITION
case|:
block|{
name|dest_tab
operator|=
name|qb
operator|.
name|getMetaData
argument_list|()
operator|.
name|getDestPartitionForAlias
argument_list|(
name|dest
argument_list|)
operator|.
name|getTable
argument_list|()
expr_stmt|;
break|break;
block|}
default|default:
block|{
return|return
name|input
return|;
block|}
block|}
return|return
name|input
return|;
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"nls"
argument_list|)
specifier|private
name|Operator
name|genFileSinkPlan
parameter_list|(
name|String
name|dest
parameter_list|,
name|QB
name|qb
parameter_list|,
name|Operator
name|input
parameter_list|)
throws|throws
name|SemanticException
block|{
name|RowResolver
name|inputRR
init|=
name|opParseCtx
operator|.
name|get
argument_list|(
name|input
argument_list|)
operator|.
name|getRR
argument_list|()
decl_stmt|;
name|QBMetaData
name|qbm
init|=
name|qb
operator|.
name|getMetaData
argument_list|()
decl_stmt|;
name|Integer
name|dest_type
init|=
name|qbm
operator|.
name|getDestTypeForAlias
argument_list|(
name|dest
argument_list|)
decl_stmt|;
name|Table
name|dest_tab
decl_stmt|;
comment|// destination table if any
name|String
name|queryTmpdir
decl_stmt|;
comment|// the intermediate destination directory
name|Path
name|dest_path
decl_stmt|;
comment|// the final destination directory
name|tableDesc
name|table_desc
init|=
literal|null
decl_stmt|;
name|int
name|currentTableId
init|=
literal|0
decl_stmt|;
name|boolean
name|isLocal
init|=
literal|false
decl_stmt|;
switch|switch
condition|(
name|dest_type
operator|.
name|intValue
argument_list|()
condition|)
block|{
case|case
name|QBMetaData
operator|.
name|DEST_TABLE
case|:
block|{
name|dest_tab
operator|=
name|qbm
operator|.
name|getDestTableForAlias
argument_list|(
name|dest
argument_list|)
expr_stmt|;
comment|//check for partition
name|List
argument_list|<
name|FieldSchema
argument_list|>
name|parts
init|=
name|dest_tab
operator|.
name|getTTable
argument_list|()
operator|.
name|getPartitionKeys
argument_list|()
decl_stmt|;
if|if
condition|(
name|parts
operator|!=
literal|null
operator|&&
name|parts
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|NEED_PARTITION_ERROR
operator|.
name|getMsg
argument_list|()
argument_list|)
throw|;
block|}
name|dest_path
operator|=
name|dest_tab
operator|.
name|getPath
argument_list|()
expr_stmt|;
name|queryTmpdir
operator|=
name|ctx
operator|.
name|getExternalTmpFileURI
argument_list|(
name|dest_path
operator|.
name|toUri
argument_list|()
argument_list|)
expr_stmt|;
name|table_desc
operator|=
name|Utilities
operator|.
name|getTableDesc
argument_list|(
name|dest_tab
argument_list|)
expr_stmt|;
name|this
operator|.
name|idToTableNameMap
operator|.
name|put
argument_list|(
name|String
operator|.
name|valueOf
argument_list|(
name|this
operator|.
name|destTableId
argument_list|)
argument_list|,
name|dest_tab
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
name|currentTableId
operator|=
name|this
operator|.
name|destTableId
expr_stmt|;
name|this
operator|.
name|destTableId
operator|++
expr_stmt|;
comment|// Create the work for moving the table
name|this
operator|.
name|loadTableWork
operator|.
name|add
argument_list|(
operator|new
name|loadTableDesc
argument_list|(
name|queryTmpdir
argument_list|,
name|ctx
operator|.
name|getExternalTmpFileURI
argument_list|(
name|dest_path
operator|.
name|toUri
argument_list|()
argument_list|)
argument_list|,
name|table_desc
argument_list|,
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|outputs
operator|.
name|add
argument_list|(
operator|new
name|WriteEntity
argument_list|(
name|dest_tab
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|QBMetaData
operator|.
name|DEST_PARTITION
case|:
block|{
name|Partition
name|dest_part
init|=
name|qbm
operator|.
name|getDestPartitionForAlias
argument_list|(
name|dest
argument_list|)
decl_stmt|;
name|dest_tab
operator|=
name|dest_part
operator|.
name|getTable
argument_list|()
expr_stmt|;
name|dest_path
operator|=
name|dest_part
operator|.
name|getPath
argument_list|()
index|[
literal|0
index|]
expr_stmt|;
name|queryTmpdir
operator|=
name|ctx
operator|.
name|getExternalTmpFileURI
argument_list|(
name|dest_path
operator|.
name|toUri
argument_list|()
argument_list|)
expr_stmt|;
name|table_desc
operator|=
name|Utilities
operator|.
name|getTableDesc
argument_list|(
name|dest_tab
argument_list|)
expr_stmt|;
name|this
operator|.
name|idToTableNameMap
operator|.
name|put
argument_list|(
name|String
operator|.
name|valueOf
argument_list|(
name|this
operator|.
name|destTableId
argument_list|)
argument_list|,
name|dest_tab
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
name|currentTableId
operator|=
name|this
operator|.
name|destTableId
expr_stmt|;
name|this
operator|.
name|destTableId
operator|++
expr_stmt|;
name|this
operator|.
name|loadTableWork
operator|.
name|add
argument_list|(
operator|new
name|loadTableDesc
argument_list|(
name|queryTmpdir
argument_list|,
name|ctx
operator|.
name|getExternalTmpFileURI
argument_list|(
name|dest_path
operator|.
name|toUri
argument_list|()
argument_list|)
argument_list|,
name|table_desc
argument_list|,
name|dest_part
operator|.
name|getSpec
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|outputs
operator|.
name|add
argument_list|(
operator|new
name|WriteEntity
argument_list|(
name|dest_part
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|QBMetaData
operator|.
name|DEST_LOCAL_FILE
case|:
name|isLocal
operator|=
literal|true
expr_stmt|;
comment|// fall through
case|case
name|QBMetaData
operator|.
name|DEST_DFS_FILE
case|:
block|{
name|dest_path
operator|=
operator|new
name|Path
argument_list|(
name|qbm
operator|.
name|getDestFileForAlias
argument_list|(
name|dest
argument_list|)
argument_list|)
expr_stmt|;
name|String
name|destStr
init|=
name|dest_path
operator|.
name|toString
argument_list|()
decl_stmt|;
if|if
condition|(
name|isLocal
condition|)
block|{
comment|// for local directory - we always write to map-red intermediate
comment|// store and then copy to local fs
name|queryTmpdir
operator|=
name|ctx
operator|.
name|getMRTmpFileURI
argument_list|()
expr_stmt|;
block|}
else|else
block|{
comment|// otherwise write to the file system implied by the directory
comment|// no copy is required. we may want to revisit this policy in future
try|try
block|{
name|Path
name|qPath
init|=
name|FileUtils
operator|.
name|makeQualified
argument_list|(
name|dest_path
argument_list|,
name|conf
argument_list|)
decl_stmt|;
name|queryTmpdir
operator|=
name|ctx
operator|.
name|getExternalTmpFileURI
argument_list|(
name|qPath
operator|.
name|toUri
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
literal|"Error creating temporary folder on: "
operator|+
name|dest_path
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
name|String
name|cols
init|=
operator|new
name|String
argument_list|()
decl_stmt|;
name|String
name|colTypes
init|=
operator|new
name|String
argument_list|()
decl_stmt|;
name|Vector
argument_list|<
name|ColumnInfo
argument_list|>
name|colInfos
init|=
name|inputRR
operator|.
name|getColumnInfos
argument_list|()
decl_stmt|;
name|boolean
name|first
init|=
literal|true
decl_stmt|;
for|for
control|(
name|ColumnInfo
name|colInfo
range|:
name|colInfos
control|)
block|{
name|String
index|[]
name|nm
init|=
name|inputRR
operator|.
name|reverseLookup
argument_list|(
name|colInfo
operator|.
name|getInternalName
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|first
condition|)
block|{
name|cols
operator|=
name|cols
operator|.
name|concat
argument_list|(
literal|","
argument_list|)
expr_stmt|;
name|colTypes
operator|=
name|colTypes
operator|.
name|concat
argument_list|(
literal|":"
argument_list|)
expr_stmt|;
block|}
name|first
operator|=
literal|false
expr_stmt|;
name|cols
operator|=
name|cols
operator|.
name|concat
argument_list|(
name|colInfo
operator|.
name|getInternalName
argument_list|()
argument_list|)
expr_stmt|;
comment|// Replace VOID type with string when the output is a temp table or local files.
comment|// A VOID type can be generated under the query:
comment|//
comment|//     select NULL from tt;
comment|// or
comment|//     insert overwrite local directory "abc" select NULL from tt;
comment|//
comment|// where there is no column type to which the NULL value should be converted.
comment|//
name|String
name|tName
init|=
name|colInfo
operator|.
name|getType
argument_list|()
operator|.
name|getTypeName
argument_list|()
decl_stmt|;
if|if
condition|(
name|tName
operator|.
name|equals
argument_list|(
name|Constants
operator|.
name|VOID_TYPE_NAME
argument_list|)
condition|)
name|colTypes
operator|=
name|colTypes
operator|.
name|concat
argument_list|(
name|Constants
operator|.
name|STRING_TYPE_NAME
argument_list|)
expr_stmt|;
else|else
name|colTypes
operator|=
name|colTypes
operator|.
name|concat
argument_list|(
name|tName
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|ctx
operator|.
name|isMRTmpFileURI
argument_list|(
name|destStr
argument_list|)
condition|)
block|{
name|this
operator|.
name|idToTableNameMap
operator|.
name|put
argument_list|(
name|String
operator|.
name|valueOf
argument_list|(
name|this
operator|.
name|destTableId
argument_list|)
argument_list|,
name|destStr
argument_list|)
expr_stmt|;
name|currentTableId
operator|=
name|this
operator|.
name|destTableId
expr_stmt|;
name|this
operator|.
name|destTableId
operator|++
expr_stmt|;
block|}
name|boolean
name|isDfsDir
init|=
operator|(
name|dest_type
operator|.
name|intValue
argument_list|()
operator|==
name|QBMetaData
operator|.
name|DEST_DFS_FILE
operator|)
decl_stmt|;
name|this
operator|.
name|loadFileWork
operator|.
name|add
argument_list|(
operator|new
name|loadFileDesc
argument_list|(
name|queryTmpdir
argument_list|,
name|destStr
argument_list|,
name|isDfsDir
argument_list|,
name|cols
argument_list|,
name|colTypes
argument_list|)
argument_list|)
expr_stmt|;
name|table_desc
operator|=
name|PlanUtils
operator|.
name|getDefaultTableDesc
argument_list|(
name|Integer
operator|.
name|toString
argument_list|(
name|Utilities
operator|.
name|ctrlaCode
argument_list|)
argument_list|,
name|cols
argument_list|,
name|colTypes
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|outputs
operator|.
name|add
argument_list|(
operator|new
name|WriteEntity
argument_list|(
name|destStr
argument_list|,
operator|!
name|isDfsDir
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
default|default:
throw|throw
operator|new
name|SemanticException
argument_list|(
literal|"Unknown destination type: "
operator|+
name|dest_type
argument_list|)
throw|;
block|}
name|input
operator|=
name|genConversionSelectOperator
argument_list|(
name|dest
argument_list|,
name|qb
argument_list|,
name|input
argument_list|,
name|table_desc
argument_list|)
expr_stmt|;
name|inputRR
operator|=
name|opParseCtx
operator|.
name|get
argument_list|(
name|input
argument_list|)
operator|.
name|getRR
argument_list|()
expr_stmt|;
name|Vector
argument_list|<
name|ColumnInfo
argument_list|>
name|vecCol
init|=
operator|new
name|Vector
argument_list|<
name|ColumnInfo
argument_list|>
argument_list|()
decl_stmt|;
try|try
block|{
name|StructObjectInspector
name|rowObjectInspector
init|=
operator|(
name|StructObjectInspector
operator|)
name|table_desc
operator|.
name|getDeserializer
argument_list|()
operator|.
name|getObjectInspector
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|?
extends|extends
name|StructField
argument_list|>
name|fields
init|=
name|rowObjectInspector
operator|.
name|getAllStructFieldRefs
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|fields
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
name|vecCol
operator|.
name|add
argument_list|(
operator|new
name|ColumnInfo
argument_list|(
name|fields
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|getFieldName
argument_list|()
argument_list|,
name|TypeInfoUtils
operator|.
name|getTypeInfoFromObjectInspector
argument_list|(
name|fields
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|getFieldObjectInspector
argument_list|()
argument_list|)
argument_list|,
literal|""
argument_list|,
literal|false
argument_list|)
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|e
operator|.
name|getMessage
argument_list|()
argument_list|)
throw|;
block|}
name|RowSchema
name|fsRS
init|=
operator|new
name|RowSchema
argument_list|(
name|vecCol
argument_list|)
decl_stmt|;
name|Operator
name|output
init|=
name|putOpInsertMap
argument_list|(
name|OperatorFactory
operator|.
name|getAndMakeChild
argument_list|(
operator|new
name|fileSinkDesc
argument_list|(
name|queryTmpdir
argument_list|,
name|table_desc
argument_list|,
name|conf
operator|.
name|getBoolVar
argument_list|(
name|HiveConf
operator|.
name|ConfVars
operator|.
name|COMPRESSRESULT
argument_list|)
argument_list|,
name|currentTableId
argument_list|)
argument_list|,
name|fsRS
argument_list|,
name|input
argument_list|)
argument_list|,
name|inputRR
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Created FileSink Plan for clause: "
operator|+
name|dest
operator|+
literal|"dest_path: "
operator|+
name|dest_path
operator|+
literal|" row schema: "
operator|+
name|inputRR
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|output
return|;
block|}
comment|/**    * Generate the conversion SelectOperator that converts the columns into     * the types that are expected by the table_desc.    */
name|Operator
name|genConversionSelectOperator
parameter_list|(
name|String
name|dest
parameter_list|,
name|QB
name|qb
parameter_list|,
name|Operator
name|input
parameter_list|,
name|tableDesc
name|table_desc
parameter_list|)
throws|throws
name|SemanticException
block|{
name|StructObjectInspector
name|oi
init|=
literal|null
decl_stmt|;
try|try
block|{
name|Deserializer
name|deserializer
init|=
name|table_desc
operator|.
name|getDeserializerClass
argument_list|()
operator|.
name|newInstance
argument_list|()
decl_stmt|;
name|deserializer
operator|.
name|initialize
argument_list|(
name|conf
argument_list|,
name|table_desc
operator|.
name|getProperties
argument_list|()
argument_list|)
expr_stmt|;
name|oi
operator|=
operator|(
name|StructObjectInspector
operator|)
name|deserializer
operator|.
name|getObjectInspector
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|e
argument_list|)
throw|;
block|}
comment|// Check column number
name|List
argument_list|<
name|?
extends|extends
name|StructField
argument_list|>
name|tableFields
init|=
name|oi
operator|.
name|getAllStructFieldRefs
argument_list|()
decl_stmt|;
name|Vector
argument_list|<
name|ColumnInfo
argument_list|>
name|rowFields
init|=
name|opParseCtx
operator|.
name|get
argument_list|(
name|input
argument_list|)
operator|.
name|getRR
argument_list|()
operator|.
name|getColumnInfos
argument_list|()
decl_stmt|;
if|if
condition|(
name|tableFields
operator|.
name|size
argument_list|()
operator|!=
name|rowFields
operator|.
name|size
argument_list|()
condition|)
block|{
name|String
name|reason
init|=
literal|"Table "
operator|+
name|dest
operator|+
literal|" has "
operator|+
name|tableFields
operator|.
name|size
argument_list|()
operator|+
literal|" columns but query has "
operator|+
name|rowFields
operator|.
name|size
argument_list|()
operator|+
literal|" columns."
decl_stmt|;
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|TARGET_TABLE_COLUMN_MISMATCH
operator|.
name|getMsg
argument_list|(
name|qb
operator|.
name|getParseInfo
argument_list|()
operator|.
name|getDestForClause
argument_list|(
name|dest
argument_list|)
argument_list|,
name|reason
argument_list|)
argument_list|)
throw|;
block|}
comment|// Check column types
name|boolean
name|converted
init|=
literal|false
decl_stmt|;
name|int
name|columnNumber
init|=
name|tableFields
operator|.
name|size
argument_list|()
decl_stmt|;
name|ArrayList
argument_list|<
name|exprNodeDesc
argument_list|>
name|expressions
init|=
operator|new
name|ArrayList
argument_list|<
name|exprNodeDesc
argument_list|>
argument_list|(
name|columnNumber
argument_list|)
decl_stmt|;
comment|// MetadataTypedColumnsetSerDe does not need type conversions because it does
comment|// the conversion to String by itself.
name|boolean
name|isMetaDataSerDe
init|=
name|table_desc
operator|.
name|getDeserializerClass
argument_list|()
operator|.
name|equals
argument_list|(
name|MetadataTypedColumnsetSerDe
operator|.
name|class
argument_list|)
decl_stmt|;
name|boolean
name|isLazySimpleSerDe
init|=
name|table_desc
operator|.
name|getDeserializerClass
argument_list|()
operator|.
name|equals
argument_list|(
name|LazySimpleSerDe
operator|.
name|class
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|isMetaDataSerDe
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|columnNumber
condition|;
name|i
operator|++
control|)
block|{
name|ObjectInspector
name|tableFieldOI
init|=
name|tableFields
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|getFieldObjectInspector
argument_list|()
decl_stmt|;
name|TypeInfo
name|tableFieldTypeInfo
init|=
name|TypeInfoUtils
operator|.
name|getTypeInfoFromObjectInspector
argument_list|(
name|tableFieldOI
argument_list|)
decl_stmt|;
name|TypeInfo
name|rowFieldTypeInfo
init|=
name|rowFields
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|getType
argument_list|()
decl_stmt|;
name|exprNodeDesc
name|column
init|=
operator|new
name|exprNodeColumnDesc
argument_list|(
name|rowFieldTypeInfo
argument_list|,
name|rowFields
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|getInternalName
argument_list|()
argument_list|,
literal|""
argument_list|,
literal|false
argument_list|)
decl_stmt|;
comment|// LazySimpleSerDe can convert any types to String type using JSON-format.
if|if
condition|(
operator|!
name|tableFieldTypeInfo
operator|.
name|equals
argument_list|(
name|rowFieldTypeInfo
argument_list|)
operator|&&
operator|!
operator|(
name|isLazySimpleSerDe
operator|&&
name|tableFieldTypeInfo
operator|.
name|getCategory
argument_list|()
operator|.
name|equals
argument_list|(
name|Category
operator|.
name|PRIMITIVE
argument_list|)
operator|&&
name|tableFieldTypeInfo
operator|.
name|equals
argument_list|(
name|TypeInfoFactory
operator|.
name|stringTypeInfo
argument_list|)
operator|)
condition|)
block|{
comment|// need to do some conversions here
name|converted
operator|=
literal|true
expr_stmt|;
if|if
condition|(
name|tableFieldTypeInfo
operator|.
name|getCategory
argument_list|()
operator|!=
name|Category
operator|.
name|PRIMITIVE
condition|)
block|{
comment|// cannot convert to complex types
name|column
operator|=
literal|null
expr_stmt|;
block|}
else|else
block|{
name|column
operator|=
name|TypeCheckProcFactory
operator|.
name|DefaultExprProcessor
operator|.
name|getFuncExprNodeDesc
argument_list|(
name|tableFieldTypeInfo
operator|.
name|getTypeName
argument_list|()
argument_list|,
name|column
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|column
operator|==
literal|null
condition|)
block|{
name|String
name|reason
init|=
literal|"Cannot convert column "
operator|+
name|i
operator|+
literal|" from "
operator|+
name|rowFieldTypeInfo
operator|+
literal|" to "
operator|+
name|tableFieldTypeInfo
operator|+
literal|"."
decl_stmt|;
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|TARGET_TABLE_COLUMN_MISMATCH
operator|.
name|getMsg
argument_list|(
name|qb
operator|.
name|getParseInfo
argument_list|()
operator|.
name|getDestForClause
argument_list|(
name|dest
argument_list|)
argument_list|,
name|reason
argument_list|)
argument_list|)
throw|;
block|}
block|}
name|expressions
operator|.
name|add
argument_list|(
name|column
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|converted
condition|)
block|{
comment|// add the select operator
name|RowResolver
name|rowResolver
init|=
operator|new
name|RowResolver
argument_list|()
decl_stmt|;
name|ArrayList
argument_list|<
name|String
argument_list|>
name|colName
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|expressions
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|String
name|name
init|=
name|getColumnInternalName
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|rowResolver
operator|.
name|put
argument_list|(
literal|""
argument_list|,
name|name
argument_list|,
operator|new
name|ColumnInfo
argument_list|(
name|name
argument_list|,
name|expressions
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|getTypeInfo
argument_list|()
argument_list|,
literal|""
argument_list|,
literal|false
argument_list|)
argument_list|)
expr_stmt|;
name|colName
operator|.
name|add
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
name|Operator
name|output
init|=
name|putOpInsertMap
argument_list|(
name|OperatorFactory
operator|.
name|getAndMakeChild
argument_list|(
operator|new
name|selectDesc
argument_list|(
name|expressions
argument_list|,
name|colName
argument_list|)
argument_list|,
operator|new
name|RowSchema
argument_list|(
name|rowResolver
operator|.
name|getColumnInfos
argument_list|()
argument_list|)
argument_list|,
name|input
argument_list|)
argument_list|,
name|rowResolver
argument_list|)
decl_stmt|;
return|return
name|output
return|;
block|}
else|else
block|{
comment|// not converted
return|return
name|input
return|;
block|}
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"nls"
argument_list|)
specifier|private
name|Operator
name|genLimitPlan
parameter_list|(
name|String
name|dest
parameter_list|,
name|QB
name|qb
parameter_list|,
name|Operator
name|input
parameter_list|,
name|int
name|limit
parameter_list|)
throws|throws
name|SemanticException
block|{
comment|// A map-only job can be optimized - instead of converting it to a map-reduce job, we can have another map
comment|// job to do the same to avoid the cost of sorting in the map-reduce phase. A better approach would be to
comment|// write into a local file and then have a map-only job.
comment|// Add the limit operator to get the value fields
name|RowResolver
name|inputRR
init|=
name|opParseCtx
operator|.
name|get
argument_list|(
name|input
argument_list|)
operator|.
name|getRR
argument_list|()
decl_stmt|;
name|Operator
name|limitMap
init|=
name|putOpInsertMap
argument_list|(
name|OperatorFactory
operator|.
name|getAndMakeChild
argument_list|(
operator|new
name|limitDesc
argument_list|(
name|limit
argument_list|)
argument_list|,
operator|new
name|RowSchema
argument_list|(
name|inputRR
operator|.
name|getColumnInfos
argument_list|()
argument_list|)
argument_list|,
name|input
argument_list|)
argument_list|,
name|inputRR
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Created LimitOperator Plan for clause: "
operator|+
name|dest
operator|+
literal|" row schema: "
operator|+
name|inputRR
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|limitMap
return|;
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"nls"
argument_list|)
specifier|private
name|Operator
name|genLimitMapRedPlan
parameter_list|(
name|String
name|dest
parameter_list|,
name|QB
name|qb
parameter_list|,
name|Operator
name|input
parameter_list|,
name|int
name|limit
parameter_list|,
name|boolean
name|extraMRStep
parameter_list|)
throws|throws
name|SemanticException
block|{
comment|// A map-only job can be optimized - instead of converting it to a map-reduce job, we can have another map
comment|// job to do the same to avoid the cost of sorting in the map-reduce phase. A better approach would be to
comment|// write into a local file and then have a map-only job.
comment|// Add the limit operator to get the value fields
name|Operator
name|curr
init|=
name|genLimitPlan
argument_list|(
name|dest
argument_list|,
name|qb
argument_list|,
name|input
argument_list|,
name|limit
argument_list|)
decl_stmt|;
comment|// the client requested that an extra map-reduce step be performed
if|if
condition|(
operator|!
name|extraMRStep
condition|)
return|return
name|curr
return|;
comment|// Create a reduceSink operator followed by another limit
name|curr
operator|=
name|genReduceSinkPlan
argument_list|(
name|dest
argument_list|,
name|qb
argument_list|,
name|curr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
name|genLimitPlan
argument_list|(
name|dest
argument_list|,
name|qb
argument_list|,
name|curr
argument_list|,
name|limit
argument_list|)
return|;
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"nls"
argument_list|)
specifier|private
name|Operator
name|genReduceSinkPlan
parameter_list|(
name|String
name|dest
parameter_list|,
name|QB
name|qb
parameter_list|,
name|Operator
name|input
parameter_list|,
name|int
name|numReducers
parameter_list|)
throws|throws
name|SemanticException
block|{
name|RowResolver
name|inputRR
init|=
name|opParseCtx
operator|.
name|get
argument_list|(
name|input
argument_list|)
operator|.
name|getRR
argument_list|()
decl_stmt|;
comment|// First generate the expression for the partition and sort keys
comment|// The cluster by clause / distribute by clause has the aliases for partition function
name|ASTNode
name|partitionExprs
init|=
name|qb
operator|.
name|getParseInfo
argument_list|()
operator|.
name|getClusterByForClause
argument_list|(
name|dest
argument_list|)
decl_stmt|;
if|if
condition|(
name|partitionExprs
operator|==
literal|null
condition|)
block|{
name|partitionExprs
operator|=
name|qb
operator|.
name|getParseInfo
argument_list|()
operator|.
name|getDistributeByForClause
argument_list|(
name|dest
argument_list|)
expr_stmt|;
block|}
name|ArrayList
argument_list|<
name|exprNodeDesc
argument_list|>
name|partitionCols
init|=
operator|new
name|ArrayList
argument_list|<
name|exprNodeDesc
argument_list|>
argument_list|()
decl_stmt|;
if|if
condition|(
name|partitionExprs
operator|!=
literal|null
condition|)
block|{
name|int
name|ccount
init|=
name|partitionExprs
operator|.
name|getChildCount
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|ccount
condition|;
operator|++
name|i
control|)
block|{
name|ASTNode
name|cl
init|=
operator|(
name|ASTNode
operator|)
name|partitionExprs
operator|.
name|getChild
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|partitionCols
operator|.
name|add
argument_list|(
name|genExprNodeDesc
argument_list|(
name|cl
argument_list|,
name|inputRR
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|ASTNode
name|sortExprs
init|=
name|qb
operator|.
name|getParseInfo
argument_list|()
operator|.
name|getClusterByForClause
argument_list|(
name|dest
argument_list|)
decl_stmt|;
if|if
condition|(
name|sortExprs
operator|==
literal|null
condition|)
block|{
name|sortExprs
operator|=
name|qb
operator|.
name|getParseInfo
argument_list|()
operator|.
name|getSortByForClause
argument_list|(
name|dest
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sortExprs
operator|==
literal|null
condition|)
block|{
name|sortExprs
operator|=
name|qb
operator|.
name|getParseInfo
argument_list|()
operator|.
name|getOrderByForClause
argument_list|(
name|dest
argument_list|)
expr_stmt|;
if|if
condition|(
name|sortExprs
operator|!=
literal|null
condition|)
block|{
assert|assert
name|numReducers
operator|==
literal|1
assert|;
comment|// in strict mode, in the presence of order by, limit must be specified
name|Integer
name|limit
init|=
name|qb
operator|.
name|getParseInfo
argument_list|()
operator|.
name|getDestLimit
argument_list|(
name|dest
argument_list|)
decl_stmt|;
if|if
condition|(
name|conf
operator|.
name|getVar
argument_list|(
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVEMAPREDMODE
argument_list|)
operator|.
name|equalsIgnoreCase
argument_list|(
literal|"strict"
argument_list|)
operator|&&
name|limit
operator|==
literal|null
condition|)
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|NO_LIMIT_WITH_ORDERBY
operator|.
name|getMsg
argument_list|(
name|sortExprs
argument_list|)
argument_list|)
throw|;
block|}
block|}
name|ArrayList
argument_list|<
name|exprNodeDesc
argument_list|>
name|sortCols
init|=
operator|new
name|ArrayList
argument_list|<
name|exprNodeDesc
argument_list|>
argument_list|()
decl_stmt|;
name|StringBuilder
name|order
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
if|if
condition|(
name|sortExprs
operator|!=
literal|null
condition|)
block|{
name|int
name|ccount
init|=
name|sortExprs
operator|.
name|getChildCount
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|ccount
condition|;
operator|++
name|i
control|)
block|{
name|ASTNode
name|cl
init|=
operator|(
name|ASTNode
operator|)
name|sortExprs
operator|.
name|getChild
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|cl
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_TABSORTCOLNAMEASC
condition|)
block|{
comment|// SortBy ASC
name|order
operator|.
name|append
argument_list|(
literal|"+"
argument_list|)
expr_stmt|;
name|cl
operator|=
operator|(
name|ASTNode
operator|)
name|cl
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cl
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_TABSORTCOLNAMEDESC
condition|)
block|{
comment|// SortBy DESC
name|order
operator|.
name|append
argument_list|(
literal|"-"
argument_list|)
expr_stmt|;
name|cl
operator|=
operator|(
name|ASTNode
operator|)
name|cl
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// ClusterBy
name|order
operator|.
name|append
argument_list|(
literal|"+"
argument_list|)
expr_stmt|;
block|}
name|exprNodeDesc
name|exprNode
init|=
name|genExprNodeDesc
argument_list|(
name|cl
argument_list|,
name|inputRR
argument_list|)
decl_stmt|;
name|sortCols
operator|.
name|add
argument_list|(
name|exprNode
argument_list|)
expr_stmt|;
block|}
block|}
comment|// For the generation of the values expression just get the inputs
comment|// signature and generate field expressions for those
name|Map
argument_list|<
name|String
argument_list|,
name|exprNodeDesc
argument_list|>
name|colExprMap
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|exprNodeDesc
argument_list|>
argument_list|()
decl_stmt|;
name|ArrayList
argument_list|<
name|exprNodeDesc
argument_list|>
name|valueCols
init|=
operator|new
name|ArrayList
argument_list|<
name|exprNodeDesc
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|ColumnInfo
name|colInfo
range|:
name|inputRR
operator|.
name|getColumnInfos
argument_list|()
control|)
block|{
name|valueCols
operator|.
name|add
argument_list|(
operator|new
name|exprNodeColumnDesc
argument_list|(
name|colInfo
operator|.
name|getType
argument_list|()
argument_list|,
name|colInfo
operator|.
name|getInternalName
argument_list|()
argument_list|,
name|colInfo
operator|.
name|getTabAlias
argument_list|()
argument_list|,
name|colInfo
operator|.
name|getIsPartitionCol
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|colExprMap
operator|.
name|put
argument_list|(
name|colInfo
operator|.
name|getInternalName
argument_list|()
argument_list|,
name|valueCols
operator|.
name|get
argument_list|(
name|valueCols
operator|.
name|size
argument_list|()
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|ArrayList
argument_list|<
name|String
argument_list|>
name|outputColumns
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|valueCols
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
name|outputColumns
operator|.
name|add
argument_list|(
name|getColumnInternalName
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|Operator
name|interim
init|=
name|putOpInsertMap
argument_list|(
name|OperatorFactory
operator|.
name|getAndMakeChild
argument_list|(
name|PlanUtils
operator|.
name|getReduceSinkDesc
argument_list|(
name|sortCols
argument_list|,
name|valueCols
argument_list|,
name|outputColumns
argument_list|,
literal|false
argument_list|,
operator|-
literal|1
argument_list|,
name|partitionCols
argument_list|,
name|order
operator|.
name|toString
argument_list|()
argument_list|,
name|numReducers
argument_list|)
argument_list|,
operator|new
name|RowSchema
argument_list|(
name|inputRR
operator|.
name|getColumnInfos
argument_list|()
argument_list|)
argument_list|,
name|input
argument_list|)
argument_list|,
name|inputRR
argument_list|)
decl_stmt|;
name|interim
operator|.
name|setColumnExprMap
argument_list|(
name|colExprMap
argument_list|)
expr_stmt|;
comment|// Add the extract operator to get the value fields
name|RowResolver
name|out_rwsch
init|=
operator|new
name|RowResolver
argument_list|()
decl_stmt|;
name|RowResolver
name|interim_rwsch
init|=
name|inputRR
decl_stmt|;
name|Integer
name|pos
init|=
name|Integer
operator|.
name|valueOf
argument_list|(
literal|0
argument_list|)
decl_stmt|;
for|for
control|(
name|ColumnInfo
name|colInfo
range|:
name|interim_rwsch
operator|.
name|getColumnInfos
argument_list|()
control|)
block|{
name|String
index|[]
name|info
init|=
name|interim_rwsch
operator|.
name|reverseLookup
argument_list|(
name|colInfo
operator|.
name|getInternalName
argument_list|()
argument_list|)
decl_stmt|;
name|out_rwsch
operator|.
name|put
argument_list|(
name|info
index|[
literal|0
index|]
argument_list|,
name|info
index|[
literal|1
index|]
argument_list|,
operator|new
name|ColumnInfo
argument_list|(
name|getColumnInternalName
argument_list|(
name|pos
argument_list|)
argument_list|,
name|colInfo
operator|.
name|getType
argument_list|()
argument_list|,
name|info
index|[
literal|0
index|]
argument_list|,
literal|false
argument_list|)
argument_list|)
expr_stmt|;
name|pos
operator|=
name|Integer
operator|.
name|valueOf
argument_list|(
name|pos
operator|.
name|intValue
argument_list|()
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
name|Operator
name|output
init|=
name|putOpInsertMap
argument_list|(
name|OperatorFactory
operator|.
name|getAndMakeChild
argument_list|(
operator|new
name|extractDesc
argument_list|(
operator|new
name|exprNodeColumnDesc
argument_list|(
name|TypeInfoFactory
operator|.
name|stringTypeInfo
argument_list|,
name|Utilities
operator|.
name|ReduceField
operator|.
name|VALUE
operator|.
name|toString
argument_list|()
argument_list|,
literal|""
argument_list|,
literal|false
argument_list|)
argument_list|)
argument_list|,
operator|new
name|RowSchema
argument_list|(
name|out_rwsch
operator|.
name|getColumnInfos
argument_list|()
argument_list|)
argument_list|,
name|interim
argument_list|)
argument_list|,
name|out_rwsch
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Created ReduceSink Plan for clause: "
operator|+
name|dest
operator|+
literal|" row schema: "
operator|+
name|out_rwsch
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|output
return|;
block|}
specifier|private
name|Operator
name|genJoinOperatorChildren
parameter_list|(
name|QBJoinTree
name|join
parameter_list|,
name|Operator
name|left
parameter_list|,
name|Operator
index|[]
name|right
parameter_list|)
throws|throws
name|SemanticException
block|{
name|RowResolver
name|outputRS
init|=
operator|new
name|RowResolver
argument_list|()
decl_stmt|;
name|ArrayList
argument_list|<
name|String
argument_list|>
name|outputColumnNames
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
comment|// all children are base classes
name|Operator
argument_list|<
name|?
argument_list|>
index|[]
name|rightOps
init|=
operator|new
name|Operator
index|[
name|right
operator|.
name|length
index|]
decl_stmt|;
name|int
name|pos
init|=
literal|0
decl_stmt|;
name|int
name|outputPos
init|=
literal|0
decl_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|Byte
argument_list|>
name|reversedExprs
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|Byte
argument_list|>
argument_list|()
decl_stmt|;
name|HashMap
argument_list|<
name|Byte
argument_list|,
name|List
argument_list|<
name|exprNodeDesc
argument_list|>
argument_list|>
name|exprMap
init|=
operator|new
name|HashMap
argument_list|<
name|Byte
argument_list|,
name|List
argument_list|<
name|exprNodeDesc
argument_list|>
argument_list|>
argument_list|()
decl_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|exprNodeDesc
argument_list|>
name|colExprMap
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|exprNodeDesc
argument_list|>
argument_list|()
decl_stmt|;
name|HashMap
argument_list|<
name|Integer
argument_list|,
name|Set
argument_list|<
name|String
argument_list|>
argument_list|>
name|posToAliasMap
init|=
operator|new
name|HashMap
argument_list|<
name|Integer
argument_list|,
name|Set
argument_list|<
name|String
argument_list|>
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|Operator
name|input
range|:
name|right
control|)
block|{
name|ArrayList
argument_list|<
name|exprNodeDesc
argument_list|>
name|keyDesc
init|=
operator|new
name|ArrayList
argument_list|<
name|exprNodeDesc
argument_list|>
argument_list|()
decl_stmt|;
if|if
condition|(
name|input
operator|==
literal|null
condition|)
name|input
operator|=
name|left
expr_stmt|;
name|Byte
name|tag
init|=
name|Byte
operator|.
name|valueOf
argument_list|(
call|(
name|byte
call|)
argument_list|(
operator|(
call|(
name|reduceSinkDesc
call|)
argument_list|(
name|input
operator|.
name|getConf
argument_list|()
argument_list|)
operator|)
operator|.
name|getTag
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
name|RowResolver
name|inputRS
init|=
name|opParseCtx
operator|.
name|get
argument_list|(
name|input
argument_list|)
operator|.
name|getRR
argument_list|()
decl_stmt|;
name|Iterator
argument_list|<
name|String
argument_list|>
name|keysIter
init|=
name|inputRS
operator|.
name|getTableNames
argument_list|()
operator|.
name|iterator
argument_list|()
decl_stmt|;
name|Set
argument_list|<
name|String
argument_list|>
name|aliases
init|=
name|posToAliasMap
operator|.
name|get
argument_list|(
name|pos
argument_list|)
decl_stmt|;
if|if
condition|(
name|aliases
operator|==
literal|null
condition|)
block|{
name|aliases
operator|=
operator|new
name|HashSet
argument_list|<
name|String
argument_list|>
argument_list|()
expr_stmt|;
name|posToAliasMap
operator|.
name|put
argument_list|(
name|pos
argument_list|,
name|aliases
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|keysIter
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|String
name|key
init|=
name|keysIter
operator|.
name|next
argument_list|()
decl_stmt|;
name|aliases
operator|.
name|add
argument_list|(
name|key
argument_list|)
expr_stmt|;
name|HashMap
argument_list|<
name|String
argument_list|,
name|ColumnInfo
argument_list|>
name|map
init|=
name|inputRS
operator|.
name|getFieldMap
argument_list|(
name|key
argument_list|)
decl_stmt|;
name|Iterator
argument_list|<
name|String
argument_list|>
name|fNamesIter
init|=
name|map
operator|.
name|keySet
argument_list|()
operator|.
name|iterator
argument_list|()
decl_stmt|;
while|while
condition|(
name|fNamesIter
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|String
name|field
init|=
name|fNamesIter
operator|.
name|next
argument_list|()
decl_stmt|;
name|ColumnInfo
name|valueInfo
init|=
name|inputRS
operator|.
name|get
argument_list|(
name|key
argument_list|,
name|field
argument_list|)
decl_stmt|;
name|keyDesc
operator|.
name|add
argument_list|(
operator|new
name|exprNodeColumnDesc
argument_list|(
name|valueInfo
operator|.
name|getType
argument_list|()
argument_list|,
name|valueInfo
operator|.
name|getInternalName
argument_list|()
argument_list|,
name|valueInfo
operator|.
name|getTabAlias
argument_list|()
argument_list|,
name|valueInfo
operator|.
name|getIsPartitionCol
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|outputRS
operator|.
name|get
argument_list|(
name|key
argument_list|,
name|field
argument_list|)
operator|==
literal|null
condition|)
block|{
name|String
name|colName
init|=
name|getColumnInternalName
argument_list|(
name|outputPos
argument_list|)
decl_stmt|;
name|outputPos
operator|++
expr_stmt|;
name|outputColumnNames
operator|.
name|add
argument_list|(
name|colName
argument_list|)
expr_stmt|;
name|colExprMap
operator|.
name|put
argument_list|(
name|colName
argument_list|,
name|keyDesc
operator|.
name|get
argument_list|(
name|keyDesc
operator|.
name|size
argument_list|()
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|outputRS
operator|.
name|put
argument_list|(
name|key
argument_list|,
name|field
argument_list|,
operator|new
name|ColumnInfo
argument_list|(
name|colName
argument_list|,
name|valueInfo
operator|.
name|getType
argument_list|()
argument_list|,
name|key
argument_list|,
literal|false
argument_list|)
argument_list|)
expr_stmt|;
name|reversedExprs
operator|.
name|put
argument_list|(
name|colName
argument_list|,
name|tag
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|exprMap
operator|.
name|put
argument_list|(
name|tag
argument_list|,
name|keyDesc
argument_list|)
expr_stmt|;
name|rightOps
index|[
name|pos
operator|++
index|]
operator|=
name|input
expr_stmt|;
block|}
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|joinCond
index|[]
name|joinCondns
init|=
operator|new
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|joinCond
index|[
name|join
operator|.
name|getJoinCond
argument_list|()
operator|.
name|length
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|join
operator|.
name|getJoinCond
argument_list|()
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|joinCond
name|condn
init|=
name|join
operator|.
name|getJoinCond
argument_list|()
index|[
name|i
index|]
decl_stmt|;
name|joinCondns
index|[
name|i
index|]
operator|=
operator|new
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|joinCond
argument_list|(
name|condn
argument_list|)
expr_stmt|;
block|}
name|joinDesc
name|desc
init|=
operator|new
name|joinDesc
argument_list|(
name|exprMap
argument_list|,
name|outputColumnNames
argument_list|,
name|joinCondns
argument_list|)
decl_stmt|;
name|desc
operator|.
name|setReversedExprs
argument_list|(
name|reversedExprs
argument_list|)
expr_stmt|;
name|JoinOperator
name|joinOp
init|=
operator|(
name|JoinOperator
operator|)
name|OperatorFactory
operator|.
name|getAndMakeChild
argument_list|(
name|desc
argument_list|,
operator|new
name|RowSchema
argument_list|(
name|outputRS
operator|.
name|getColumnInfos
argument_list|()
argument_list|)
argument_list|,
name|rightOps
argument_list|)
decl_stmt|;
name|joinOp
operator|.
name|setColumnExprMap
argument_list|(
name|colExprMap
argument_list|)
expr_stmt|;
name|joinOp
operator|.
name|setPosToAliasMap
argument_list|(
name|posToAliasMap
argument_list|)
expr_stmt|;
return|return
name|putOpInsertMap
argument_list|(
name|joinOp
argument_list|,
name|outputRS
argument_list|)
return|;
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"nls"
argument_list|)
specifier|private
name|Operator
name|genJoinReduceSinkChild
parameter_list|(
name|QB
name|qb
parameter_list|,
name|QBJoinTree
name|joinTree
parameter_list|,
name|Operator
name|child
parameter_list|,
name|String
name|srcName
parameter_list|,
name|int
name|pos
parameter_list|)
throws|throws
name|SemanticException
block|{
name|RowResolver
name|inputRS
init|=
name|opParseCtx
operator|.
name|get
argument_list|(
name|child
argument_list|)
operator|.
name|getRR
argument_list|()
decl_stmt|;
name|RowResolver
name|outputRS
init|=
operator|new
name|RowResolver
argument_list|()
decl_stmt|;
name|ArrayList
argument_list|<
name|String
argument_list|>
name|outputColumns
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
name|ArrayList
argument_list|<
name|exprNodeDesc
argument_list|>
name|reduceKeys
init|=
operator|new
name|ArrayList
argument_list|<
name|exprNodeDesc
argument_list|>
argument_list|()
decl_stmt|;
comment|// Compute join keys and store in reduceKeys
name|Vector
argument_list|<
name|ASTNode
argument_list|>
name|exprs
init|=
name|joinTree
operator|.
name|getExpressions
argument_list|()
operator|.
name|get
argument_list|(
name|pos
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|exprs
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|ASTNode
name|expr
init|=
name|exprs
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|reduceKeys
operator|.
name|add
argument_list|(
name|genExprNodeDesc
argument_list|(
name|expr
argument_list|,
name|inputRS
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// Walk over the input row resolver and copy in the output
name|ArrayList
argument_list|<
name|exprNodeDesc
argument_list|>
name|reduceValues
init|=
operator|new
name|ArrayList
argument_list|<
name|exprNodeDesc
argument_list|>
argument_list|()
decl_stmt|;
name|Iterator
argument_list|<
name|String
argument_list|>
name|tblNamesIter
init|=
name|inputRS
operator|.
name|getTableNames
argument_list|()
operator|.
name|iterator
argument_list|()
decl_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|exprNodeDesc
argument_list|>
name|colExprMap
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|exprNodeDesc
argument_list|>
argument_list|()
decl_stmt|;
while|while
condition|(
name|tblNamesIter
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|String
name|src
init|=
name|tblNamesIter
operator|.
name|next
argument_list|()
decl_stmt|;
name|HashMap
argument_list|<
name|String
argument_list|,
name|ColumnInfo
argument_list|>
name|fMap
init|=
name|inputRS
operator|.
name|getFieldMap
argument_list|(
name|src
argument_list|)
decl_stmt|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|ColumnInfo
argument_list|>
name|entry
range|:
name|fMap
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|String
name|field
init|=
name|entry
operator|.
name|getKey
argument_list|()
decl_stmt|;
name|ColumnInfo
name|valueInfo
init|=
name|entry
operator|.
name|getValue
argument_list|()
decl_stmt|;
name|exprNodeColumnDesc
name|inputExpr
init|=
operator|new
name|exprNodeColumnDesc
argument_list|(
name|valueInfo
operator|.
name|getType
argument_list|()
argument_list|,
name|valueInfo
operator|.
name|getInternalName
argument_list|()
argument_list|,
name|valueInfo
operator|.
name|getTabAlias
argument_list|()
argument_list|,
name|valueInfo
operator|.
name|getIsPartitionCol
argument_list|()
argument_list|)
decl_stmt|;
name|reduceValues
operator|.
name|add
argument_list|(
name|inputExpr
argument_list|)
expr_stmt|;
if|if
condition|(
name|outputRS
operator|.
name|get
argument_list|(
name|src
argument_list|,
name|field
argument_list|)
operator|==
literal|null
condition|)
block|{
name|String
name|col
init|=
name|getColumnInternalName
argument_list|(
name|reduceValues
operator|.
name|size
argument_list|()
operator|-
literal|1
argument_list|)
decl_stmt|;
name|outputColumns
operator|.
name|add
argument_list|(
name|col
argument_list|)
expr_stmt|;
name|ColumnInfo
name|newColInfo
init|=
operator|new
name|ColumnInfo
argument_list|(
name|Utilities
operator|.
name|ReduceField
operator|.
name|VALUE
operator|.
name|toString
argument_list|()
operator|+
literal|"."
operator|+
name|col
argument_list|,
name|valueInfo
operator|.
name|getType
argument_list|()
argument_list|,
name|src
argument_list|,
literal|false
argument_list|)
decl_stmt|;
name|colExprMap
operator|.
name|put
argument_list|(
name|newColInfo
operator|.
name|getInternalName
argument_list|()
argument_list|,
name|inputExpr
argument_list|)
expr_stmt|;
name|outputRS
operator|.
name|put
argument_list|(
name|src
argument_list|,
name|field
argument_list|,
name|newColInfo
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|int
name|numReds
init|=
operator|-
literal|1
decl_stmt|;
comment|// Use only 1 reducer in case of cartesian product
if|if
condition|(
name|reduceKeys
operator|.
name|size
argument_list|()
operator|==
literal|0
condition|)
block|{
name|numReds
operator|=
literal|1
expr_stmt|;
comment|// Cartesian product is not supported in strict mode
if|if
condition|(
name|conf
operator|.
name|getVar
argument_list|(
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVEMAPREDMODE
argument_list|)
operator|.
name|equalsIgnoreCase
argument_list|(
literal|"strict"
argument_list|)
condition|)
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|NO_CARTESIAN_PRODUCT
operator|.
name|getMsg
argument_list|()
argument_list|)
throw|;
block|}
name|ReduceSinkOperator
name|rsOp
init|=
operator|(
name|ReduceSinkOperator
operator|)
name|putOpInsertMap
argument_list|(
name|OperatorFactory
operator|.
name|getAndMakeChild
argument_list|(
name|PlanUtils
operator|.
name|getReduceSinkDesc
argument_list|(
name|reduceKeys
argument_list|,
name|reduceValues
argument_list|,
name|outputColumns
argument_list|,
literal|false
argument_list|,
name|joinTree
operator|.
name|getNextTag
argument_list|()
argument_list|,
name|reduceKeys
operator|.
name|size
argument_list|()
argument_list|,
name|numReds
argument_list|)
argument_list|,
operator|new
name|RowSchema
argument_list|(
name|outputRS
operator|.
name|getColumnInfos
argument_list|()
argument_list|)
argument_list|,
name|child
argument_list|)
argument_list|,
name|outputRS
argument_list|)
decl_stmt|;
name|rsOp
operator|.
name|setColumnExprMap
argument_list|(
name|colExprMap
argument_list|)
expr_stmt|;
return|return
name|rsOp
return|;
block|}
specifier|private
name|Operator
name|genJoinOperator
parameter_list|(
name|QB
name|qb
parameter_list|,
name|QBJoinTree
name|joinTree
parameter_list|,
name|HashMap
argument_list|<
name|String
argument_list|,
name|Operator
argument_list|>
name|map
parameter_list|)
throws|throws
name|SemanticException
block|{
name|QBJoinTree
name|leftChild
init|=
name|joinTree
operator|.
name|getJoinSrc
argument_list|()
decl_stmt|;
name|Operator
name|joinSrcOp
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|leftChild
operator|!=
literal|null
condition|)
block|{
name|Operator
name|joinOp
init|=
name|genJoinOperator
argument_list|(
name|qb
argument_list|,
name|leftChild
argument_list|,
name|map
argument_list|)
decl_stmt|;
name|Vector
argument_list|<
name|ASTNode
argument_list|>
name|filter
init|=
name|joinTree
operator|.
name|getFilters
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
for|for
control|(
name|ASTNode
name|cond
range|:
name|filter
control|)
name|joinOp
operator|=
name|genFilterPlan
argument_list|(
name|qb
argument_list|,
name|cond
argument_list|,
name|joinOp
argument_list|)
expr_stmt|;
name|joinSrcOp
operator|=
name|genJoinReduceSinkChild
argument_list|(
name|qb
argument_list|,
name|joinTree
argument_list|,
name|joinOp
argument_list|,
literal|null
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|Operator
index|[]
name|srcOps
init|=
operator|new
name|Operator
index|[
name|joinTree
operator|.
name|getBaseSrc
argument_list|()
operator|.
name|length
index|]
decl_stmt|;
name|int
name|pos
init|=
literal|0
decl_stmt|;
for|for
control|(
name|String
name|src
range|:
name|joinTree
operator|.
name|getBaseSrc
argument_list|()
control|)
block|{
if|if
condition|(
name|src
operator|!=
literal|null
condition|)
block|{
name|Operator
name|srcOp
init|=
name|map
operator|.
name|get
argument_list|(
name|src
argument_list|)
decl_stmt|;
name|srcOps
index|[
name|pos
index|]
operator|=
name|genJoinReduceSinkChild
argument_list|(
name|qb
argument_list|,
name|joinTree
argument_list|,
name|srcOp
argument_list|,
name|src
argument_list|,
name|pos
argument_list|)
expr_stmt|;
name|pos
operator|++
expr_stmt|;
block|}
else|else
block|{
assert|assert
name|pos
operator|==
literal|0
assert|;
name|srcOps
index|[
name|pos
operator|++
index|]
operator|=
literal|null
expr_stmt|;
block|}
block|}
comment|// Type checking and implicit type conversion for join keys
name|genJoinOperatorTypeCheck
argument_list|(
name|joinSrcOp
argument_list|,
name|srcOps
argument_list|)
expr_stmt|;
name|JoinOperator
name|joinOp
init|=
operator|(
name|JoinOperator
operator|)
name|genJoinOperatorChildren
argument_list|(
name|joinTree
argument_list|,
name|joinSrcOp
argument_list|,
name|srcOps
argument_list|)
decl_stmt|;
name|joinContext
operator|.
name|put
argument_list|(
name|joinOp
argument_list|,
name|joinTree
argument_list|)
expr_stmt|;
return|return
name|joinOp
return|;
block|}
specifier|private
name|void
name|genJoinOperatorTypeCheck
parameter_list|(
name|Operator
name|left
parameter_list|,
name|Operator
index|[]
name|right
parameter_list|)
throws|throws
name|SemanticException
block|{
comment|// keys[i] -> ArrayList<exprNodeDesc> for the i-th join operator key list
name|ArrayList
argument_list|<
name|ArrayList
argument_list|<
name|exprNodeDesc
argument_list|>
argument_list|>
name|keys
init|=
operator|new
name|ArrayList
argument_list|<
name|ArrayList
argument_list|<
name|exprNodeDesc
argument_list|>
argument_list|>
argument_list|()
decl_stmt|;
name|int
name|keyLength
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|right
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|Operator
name|oi
init|=
operator|(
name|i
operator|==
literal|0
operator|&&
name|right
index|[
name|i
index|]
operator|==
literal|null
condition|?
name|left
else|:
name|right
index|[
name|i
index|]
operator|)
decl_stmt|;
name|reduceSinkDesc
name|now
init|=
operator|(
call|(
name|ReduceSinkOperator
call|)
argument_list|(
name|oi
argument_list|)
operator|)
operator|.
name|getConf
argument_list|()
decl_stmt|;
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
name|keyLength
operator|=
name|now
operator|.
name|getKeyCols
argument_list|()
operator|.
name|size
argument_list|()
expr_stmt|;
block|}
else|else
block|{
assert|assert
operator|(
name|keyLength
operator|==
name|now
operator|.
name|getKeyCols
argument_list|()
operator|.
name|size
argument_list|()
operator|)
assert|;
block|}
name|keys
operator|.
name|add
argument_list|(
name|now
operator|.
name|getKeyCols
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// implicit type conversion hierarchy
for|for
control|(
name|int
name|k
init|=
literal|0
init|;
name|k
operator|<
name|keyLength
condition|;
name|k
operator|++
control|)
block|{
comment|// Find the common class for type conversion
name|TypeInfo
name|commonType
init|=
name|keys
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|get
argument_list|(
name|k
argument_list|)
operator|.
name|getTypeInfo
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<
name|right
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|TypeInfo
name|a
init|=
name|commonType
decl_stmt|;
name|TypeInfo
name|b
init|=
name|keys
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|get
argument_list|(
name|k
argument_list|)
operator|.
name|getTypeInfo
argument_list|()
decl_stmt|;
name|commonType
operator|=
name|FunctionRegistry
operator|.
name|getCommonClassForComparison
argument_list|(
name|a
argument_list|,
name|b
argument_list|)
expr_stmt|;
if|if
condition|(
name|commonType
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
literal|"Cannot do equality join on different types: "
operator|+
name|a
operator|.
name|getTypeName
argument_list|()
operator|+
literal|" and "
operator|+
name|b
operator|.
name|getTypeName
argument_list|()
argument_list|)
throw|;
block|}
block|}
comment|// Add implicit type conversion if necessary
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|right
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|commonType
operator|.
name|equals
argument_list|(
name|keys
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|get
argument_list|(
name|k
argument_list|)
operator|.
name|getTypeInfo
argument_list|()
argument_list|)
condition|)
block|{
name|keys
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|set
argument_list|(
name|k
argument_list|,
name|TypeCheckProcFactory
operator|.
name|DefaultExprProcessor
operator|.
name|getFuncExprNodeDesc
argument_list|(
name|commonType
operator|.
name|getTypeName
argument_list|()
argument_list|,
name|keys
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|get
argument_list|(
name|k
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|// regenerate keySerializationInfo because the ReduceSinkOperator's
comment|// output key types might have changed.
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|right
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|Operator
name|oi
init|=
operator|(
name|i
operator|==
literal|0
operator|&&
name|right
index|[
name|i
index|]
operator|==
literal|null
condition|?
name|left
else|:
name|right
index|[
name|i
index|]
operator|)
decl_stmt|;
name|reduceSinkDesc
name|now
init|=
operator|(
call|(
name|ReduceSinkOperator
call|)
argument_list|(
name|oi
argument_list|)
operator|)
operator|.
name|getConf
argument_list|()
decl_stmt|;
name|now
operator|.
name|setKeySerializeInfo
argument_list|(
name|PlanUtils
operator|.
name|getReduceKeyTableDesc
argument_list|(
name|PlanUtils
operator|.
name|getFieldSchemasFromColumnList
argument_list|(
name|now
operator|.
name|getKeyCols
argument_list|()
argument_list|,
literal|"joinkey"
argument_list|)
argument_list|,
name|now
operator|.
name|getOrder
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
name|Operator
name|genJoinPlan
parameter_list|(
name|QB
name|qb
parameter_list|,
name|HashMap
argument_list|<
name|String
argument_list|,
name|Operator
argument_list|>
name|map
parameter_list|)
throws|throws
name|SemanticException
block|{
name|QBJoinTree
name|joinTree
init|=
name|qb
operator|.
name|getQbJoinTree
argument_list|()
decl_stmt|;
name|Operator
name|joinOp
init|=
name|genJoinOperator
argument_list|(
name|qb
argument_list|,
name|joinTree
argument_list|,
name|map
argument_list|)
decl_stmt|;
return|return
name|joinOp
return|;
block|}
comment|/**    * Extract the filters from the join condition and push them on top of the source operators. This procedure     * traverses the query tree recursively,    */
specifier|private
name|void
name|pushJoinFilters
parameter_list|(
name|QB
name|qb
parameter_list|,
name|QBJoinTree
name|joinTree
parameter_list|,
name|HashMap
argument_list|<
name|String
argument_list|,
name|Operator
argument_list|>
name|map
parameter_list|)
throws|throws
name|SemanticException
block|{
name|Vector
argument_list|<
name|Vector
argument_list|<
name|ASTNode
argument_list|>
argument_list|>
name|filters
init|=
name|joinTree
operator|.
name|getFilters
argument_list|()
decl_stmt|;
if|if
condition|(
name|joinTree
operator|.
name|getJoinSrc
argument_list|()
operator|!=
literal|null
condition|)
name|pushJoinFilters
argument_list|(
name|qb
argument_list|,
name|joinTree
operator|.
name|getJoinSrc
argument_list|()
argument_list|,
name|map
argument_list|)
expr_stmt|;
name|int
name|pos
init|=
literal|0
decl_stmt|;
for|for
control|(
name|String
name|src
range|:
name|joinTree
operator|.
name|getBaseSrc
argument_list|()
control|)
block|{
if|if
condition|(
name|src
operator|!=
literal|null
condition|)
block|{
name|Operator
name|srcOp
init|=
name|map
operator|.
name|get
argument_list|(
name|src
argument_list|)
decl_stmt|;
name|Vector
argument_list|<
name|ASTNode
argument_list|>
name|filter
init|=
name|filters
operator|.
name|get
argument_list|(
name|pos
argument_list|)
decl_stmt|;
for|for
control|(
name|ASTNode
name|cond
range|:
name|filter
control|)
name|srcOp
operator|=
name|genFilterPlan
argument_list|(
name|qb
argument_list|,
name|cond
argument_list|,
name|srcOp
argument_list|)
expr_stmt|;
name|map
operator|.
name|put
argument_list|(
name|src
argument_list|,
name|srcOp
argument_list|)
expr_stmt|;
block|}
name|pos
operator|++
expr_stmt|;
block|}
block|}
specifier|private
name|List
argument_list|<
name|String
argument_list|>
name|getMapSideJoinTables
parameter_list|(
name|QB
name|qb
parameter_list|)
block|{
name|List
argument_list|<
name|String
argument_list|>
name|cols
init|=
literal|null
decl_stmt|;
name|ASTNode
name|hints
init|=
name|qb
operator|.
name|getParseInfo
argument_list|()
operator|.
name|getHints
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|pos
init|=
literal|0
init|;
name|pos
operator|<
name|hints
operator|.
name|getChildCount
argument_list|()
condition|;
name|pos
operator|++
control|)
block|{
name|ASTNode
name|hint
init|=
operator|(
name|ASTNode
operator|)
name|hints
operator|.
name|getChild
argument_list|(
name|pos
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
operator|(
name|ASTNode
operator|)
name|hint
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|)
operator|.
name|getToken
argument_list|()
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_MAPJOIN
condition|)
block|{
name|ASTNode
name|hintTblNames
init|=
operator|(
name|ASTNode
operator|)
name|hint
operator|.
name|getChild
argument_list|(
literal|1
argument_list|)
decl_stmt|;
name|int
name|numCh
init|=
name|hintTblNames
operator|.
name|getChildCount
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|tblPos
init|=
literal|0
init|;
name|tblPos
operator|<
name|numCh
condition|;
name|tblPos
operator|++
control|)
block|{
name|String
name|tblName
init|=
operator|(
operator|(
name|ASTNode
operator|)
name|hintTblNames
operator|.
name|getChild
argument_list|(
name|tblPos
argument_list|)
operator|)
operator|.
name|getText
argument_list|()
decl_stmt|;
if|if
condition|(
name|cols
operator|==
literal|null
condition|)
name|cols
operator|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|cols
operator|.
name|contains
argument_list|(
name|tblName
argument_list|)
condition|)
name|cols
operator|.
name|add
argument_list|(
name|tblName
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
name|cols
return|;
block|}
specifier|private
name|QBJoinTree
name|genJoinTree
parameter_list|(
name|QB
name|qb
parameter_list|,
name|ASTNode
name|joinParseTree
parameter_list|)
throws|throws
name|SemanticException
block|{
name|QBJoinTree
name|joinTree
init|=
operator|new
name|QBJoinTree
argument_list|()
decl_stmt|;
name|joinCond
index|[]
name|condn
init|=
operator|new
name|joinCond
index|[
literal|1
index|]
decl_stmt|;
if|if
condition|(
name|joinParseTree
operator|.
name|getToken
argument_list|()
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_LEFTOUTERJOIN
condition|)
block|{
name|joinTree
operator|.
name|setNoOuterJoin
argument_list|(
literal|false
argument_list|)
expr_stmt|;
name|condn
index|[
literal|0
index|]
operator|=
operator|new
name|joinCond
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|,
name|joinType
operator|.
name|LEFTOUTER
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|joinParseTree
operator|.
name|getToken
argument_list|()
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_RIGHTOUTERJOIN
condition|)
block|{
name|joinTree
operator|.
name|setNoOuterJoin
argument_list|(
literal|false
argument_list|)
expr_stmt|;
name|condn
index|[
literal|0
index|]
operator|=
operator|new
name|joinCond
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|,
name|joinType
operator|.
name|RIGHTOUTER
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|joinParseTree
operator|.
name|getToken
argument_list|()
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_FULLOUTERJOIN
condition|)
block|{
name|joinTree
operator|.
name|setNoOuterJoin
argument_list|(
literal|false
argument_list|)
expr_stmt|;
name|condn
index|[
literal|0
index|]
operator|=
operator|new
name|joinCond
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|,
name|joinType
operator|.
name|FULLOUTER
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|condn
index|[
literal|0
index|]
operator|=
operator|new
name|joinCond
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|,
name|joinType
operator|.
name|INNER
argument_list|)
expr_stmt|;
name|joinTree
operator|.
name|setNoOuterJoin
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
name|joinTree
operator|.
name|setJoinCond
argument_list|(
name|condn
argument_list|)
expr_stmt|;
name|ASTNode
name|left
init|=
operator|(
name|ASTNode
operator|)
name|joinParseTree
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|ASTNode
name|right
init|=
operator|(
name|ASTNode
operator|)
name|joinParseTree
operator|.
name|getChild
argument_list|(
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|left
operator|.
name|getToken
argument_list|()
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_TABREF
operator|)
operator|||
operator|(
name|left
operator|.
name|getToken
argument_list|()
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_SUBQUERY
operator|)
condition|)
block|{
name|String
name|table_name
init|=
name|unescapeIdentifier
argument_list|(
name|left
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getText
argument_list|()
argument_list|)
decl_stmt|;
name|String
name|alias
init|=
name|left
operator|.
name|getChildCount
argument_list|()
operator|==
literal|1
condition|?
name|table_name
else|:
name|unescapeIdentifier
argument_list|(
name|left
operator|.
name|getChild
argument_list|(
name|left
operator|.
name|getChildCount
argument_list|()
operator|-
literal|1
argument_list|)
operator|.
name|getText
argument_list|()
operator|.
name|toLowerCase
argument_list|()
argument_list|)
decl_stmt|;
name|joinTree
operator|.
name|setLeftAlias
argument_list|(
name|alias
argument_list|)
expr_stmt|;
name|String
index|[]
name|leftAliases
init|=
operator|new
name|String
index|[
literal|1
index|]
decl_stmt|;
name|leftAliases
index|[
literal|0
index|]
operator|=
name|alias
expr_stmt|;
name|joinTree
operator|.
name|setLeftAliases
argument_list|(
name|leftAliases
argument_list|)
expr_stmt|;
name|String
index|[]
name|children
init|=
operator|new
name|String
index|[
literal|2
index|]
decl_stmt|;
name|children
index|[
literal|0
index|]
operator|=
name|alias
expr_stmt|;
name|joinTree
operator|.
name|setBaseSrc
argument_list|(
name|children
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|isJoinToken
argument_list|(
name|left
argument_list|)
condition|)
block|{
name|QBJoinTree
name|leftTree
init|=
name|genJoinTree
argument_list|(
name|qb
argument_list|,
name|left
argument_list|)
decl_stmt|;
name|joinTree
operator|.
name|setJoinSrc
argument_list|(
name|leftTree
argument_list|)
expr_stmt|;
name|String
index|[]
name|leftChildAliases
init|=
name|leftTree
operator|.
name|getLeftAliases
argument_list|()
decl_stmt|;
name|String
name|leftAliases
index|[]
init|=
operator|new
name|String
index|[
name|leftChildAliases
operator|.
name|length
operator|+
literal|1
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|leftChildAliases
operator|.
name|length
condition|;
name|i
operator|++
control|)
name|leftAliases
index|[
name|i
index|]
operator|=
name|leftChildAliases
index|[
name|i
index|]
expr_stmt|;
name|leftAliases
index|[
name|leftChildAliases
operator|.
name|length
index|]
operator|=
name|leftTree
operator|.
name|getRightAliases
argument_list|()
index|[
literal|0
index|]
expr_stmt|;
name|joinTree
operator|.
name|setLeftAliases
argument_list|(
name|leftAliases
argument_list|)
expr_stmt|;
block|}
else|else
assert|assert
operator|(
literal|false
operator|)
assert|;
if|if
condition|(
operator|(
name|right
operator|.
name|getToken
argument_list|()
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_TABREF
operator|)
operator|||
operator|(
name|right
operator|.
name|getToken
argument_list|()
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_SUBQUERY
operator|)
condition|)
block|{
name|String
name|table_name
init|=
name|unescapeIdentifier
argument_list|(
name|right
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getText
argument_list|()
argument_list|)
decl_stmt|;
name|String
name|alias
init|=
name|right
operator|.
name|getChildCount
argument_list|()
operator|==
literal|1
condition|?
name|table_name
else|:
name|unescapeIdentifier
argument_list|(
name|right
operator|.
name|getChild
argument_list|(
name|right
operator|.
name|getChildCount
argument_list|()
operator|-
literal|1
argument_list|)
operator|.
name|getText
argument_list|()
operator|.
name|toLowerCase
argument_list|()
argument_list|)
decl_stmt|;
name|String
index|[]
name|rightAliases
init|=
operator|new
name|String
index|[
literal|1
index|]
decl_stmt|;
name|rightAliases
index|[
literal|0
index|]
operator|=
name|alias
expr_stmt|;
name|joinTree
operator|.
name|setRightAliases
argument_list|(
name|rightAliases
argument_list|)
expr_stmt|;
name|String
index|[]
name|children
init|=
name|joinTree
operator|.
name|getBaseSrc
argument_list|()
decl_stmt|;
if|if
condition|(
name|children
operator|==
literal|null
condition|)
name|children
operator|=
operator|new
name|String
index|[
literal|2
index|]
expr_stmt|;
name|children
index|[
literal|1
index|]
operator|=
name|alias
expr_stmt|;
name|joinTree
operator|.
name|setBaseSrc
argument_list|(
name|children
argument_list|)
expr_stmt|;
block|}
else|else
assert|assert
literal|false
assert|;
name|Vector
argument_list|<
name|Vector
argument_list|<
name|ASTNode
argument_list|>
argument_list|>
name|expressions
init|=
operator|new
name|Vector
argument_list|<
name|Vector
argument_list|<
name|ASTNode
argument_list|>
argument_list|>
argument_list|()
decl_stmt|;
name|expressions
operator|.
name|add
argument_list|(
operator|new
name|Vector
argument_list|<
name|ASTNode
argument_list|>
argument_list|()
argument_list|)
expr_stmt|;
name|expressions
operator|.
name|add
argument_list|(
operator|new
name|Vector
argument_list|<
name|ASTNode
argument_list|>
argument_list|()
argument_list|)
expr_stmt|;
name|joinTree
operator|.
name|setExpressions
argument_list|(
name|expressions
argument_list|)
expr_stmt|;
name|Vector
argument_list|<
name|Vector
argument_list|<
name|ASTNode
argument_list|>
argument_list|>
name|filters
init|=
operator|new
name|Vector
argument_list|<
name|Vector
argument_list|<
name|ASTNode
argument_list|>
argument_list|>
argument_list|()
decl_stmt|;
name|filters
operator|.
name|add
argument_list|(
operator|new
name|Vector
argument_list|<
name|ASTNode
argument_list|>
argument_list|()
argument_list|)
expr_stmt|;
name|filters
operator|.
name|add
argument_list|(
operator|new
name|Vector
argument_list|<
name|ASTNode
argument_list|>
argument_list|()
argument_list|)
expr_stmt|;
name|joinTree
operator|.
name|setFilters
argument_list|(
name|filters
argument_list|)
expr_stmt|;
name|ASTNode
name|joinCond
init|=
operator|(
name|ASTNode
operator|)
name|joinParseTree
operator|.
name|getChild
argument_list|(
literal|2
argument_list|)
decl_stmt|;
name|Vector
argument_list|<
name|String
argument_list|>
name|leftSrc
init|=
operator|new
name|Vector
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
name|parseJoinCondition
argument_list|(
name|joinTree
argument_list|,
name|joinCond
argument_list|,
name|leftSrc
argument_list|)
expr_stmt|;
if|if
condition|(
name|leftSrc
operator|.
name|size
argument_list|()
operator|==
literal|1
condition|)
name|joinTree
operator|.
name|setLeftAlias
argument_list|(
name|leftSrc
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
comment|// check the hints to see if the user has specified a map-side join. This will be removed later on, once the cost-based
comment|// infrastructure is in place
if|if
condition|(
name|qb
operator|.
name|getParseInfo
argument_list|()
operator|.
name|getHints
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|List
argument_list|<
name|String
argument_list|>
name|mapSideTables
init|=
name|getMapSideJoinTables
argument_list|(
name|qb
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|mapAliases
init|=
name|joinTree
operator|.
name|getMapAliases
argument_list|()
decl_stmt|;
for|for
control|(
name|String
name|mapTbl
range|:
name|mapSideTables
control|)
block|{
name|boolean
name|mapTable
init|=
literal|false
decl_stmt|;
for|for
control|(
name|String
name|leftAlias
range|:
name|joinTree
operator|.
name|getLeftAliases
argument_list|()
control|)
block|{
if|if
condition|(
name|mapTbl
operator|.
name|equals
argument_list|(
name|leftAlias
argument_list|)
condition|)
name|mapTable
operator|=
literal|true
expr_stmt|;
block|}
for|for
control|(
name|String
name|rightAlias
range|:
name|joinTree
operator|.
name|getRightAliases
argument_list|()
control|)
block|{
if|if
condition|(
name|mapTbl
operator|.
name|equals
argument_list|(
name|rightAlias
argument_list|)
condition|)
name|mapTable
operator|=
literal|true
expr_stmt|;
block|}
if|if
condition|(
name|mapTable
condition|)
block|{
if|if
condition|(
name|mapAliases
operator|==
literal|null
condition|)
block|{
name|mapAliases
operator|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
expr_stmt|;
block|}
name|mapAliases
operator|.
name|add
argument_list|(
name|mapTbl
argument_list|)
expr_stmt|;
name|joinTree
operator|.
name|setMapSideJoin
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
block|}
name|joinTree
operator|.
name|setMapAliases
argument_list|(
name|mapAliases
argument_list|)
expr_stmt|;
block|}
return|return
name|joinTree
return|;
block|}
specifier|private
name|void
name|mergeJoins
parameter_list|(
name|QB
name|qb
parameter_list|,
name|QBJoinTree
name|parent
parameter_list|,
name|QBJoinTree
name|node
parameter_list|,
name|QBJoinTree
name|target
parameter_list|,
name|int
name|pos
parameter_list|)
block|{
name|String
index|[]
name|nodeRightAliases
init|=
name|node
operator|.
name|getRightAliases
argument_list|()
decl_stmt|;
name|String
index|[]
name|trgtRightAliases
init|=
name|target
operator|.
name|getRightAliases
argument_list|()
decl_stmt|;
name|String
index|[]
name|rightAliases
init|=
operator|new
name|String
index|[
name|nodeRightAliases
operator|.
name|length
operator|+
name|trgtRightAliases
operator|.
name|length
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|trgtRightAliases
operator|.
name|length
condition|;
name|i
operator|++
control|)
name|rightAliases
index|[
name|i
index|]
operator|=
name|trgtRightAliases
index|[
name|i
index|]
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|nodeRightAliases
operator|.
name|length
condition|;
name|i
operator|++
control|)
name|rightAliases
index|[
name|i
operator|+
name|trgtRightAliases
operator|.
name|length
index|]
operator|=
name|nodeRightAliases
index|[
name|i
index|]
expr_stmt|;
name|target
operator|.
name|setRightAliases
argument_list|(
name|rightAliases
argument_list|)
expr_stmt|;
name|String
index|[]
name|nodeBaseSrc
init|=
name|node
operator|.
name|getBaseSrc
argument_list|()
decl_stmt|;
name|String
index|[]
name|trgtBaseSrc
init|=
name|target
operator|.
name|getBaseSrc
argument_list|()
decl_stmt|;
name|String
index|[]
name|baseSrc
init|=
operator|new
name|String
index|[
name|nodeBaseSrc
operator|.
name|length
operator|+
name|trgtBaseSrc
operator|.
name|length
operator|-
literal|1
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|trgtBaseSrc
operator|.
name|length
condition|;
name|i
operator|++
control|)
name|baseSrc
index|[
name|i
index|]
operator|=
name|trgtBaseSrc
index|[
name|i
index|]
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<
name|nodeBaseSrc
operator|.
name|length
condition|;
name|i
operator|++
control|)
name|baseSrc
index|[
name|i
operator|+
name|trgtBaseSrc
operator|.
name|length
operator|-
literal|1
index|]
operator|=
name|nodeBaseSrc
index|[
name|i
index|]
expr_stmt|;
name|target
operator|.
name|setBaseSrc
argument_list|(
name|baseSrc
argument_list|)
expr_stmt|;
name|Vector
argument_list|<
name|Vector
argument_list|<
name|ASTNode
argument_list|>
argument_list|>
name|expr
init|=
name|target
operator|.
name|getExpressions
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|nodeRightAliases
operator|.
name|length
condition|;
name|i
operator|++
control|)
name|expr
operator|.
name|add
argument_list|(
name|node
operator|.
name|getExpressions
argument_list|()
operator|.
name|get
argument_list|(
name|i
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|Vector
argument_list|<
name|Vector
argument_list|<
name|ASTNode
argument_list|>
argument_list|>
name|filter
init|=
name|target
operator|.
name|getFilters
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|nodeRightAliases
operator|.
name|length
condition|;
name|i
operator|++
control|)
name|filter
operator|.
name|add
argument_list|(
name|node
operator|.
name|getFilters
argument_list|()
operator|.
name|get
argument_list|(
name|i
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|node
operator|.
name|getFilters
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|size
argument_list|()
operator|!=
literal|0
condition|)
block|{
name|Vector
argument_list|<
name|ASTNode
argument_list|>
name|filterPos
init|=
name|filter
operator|.
name|get
argument_list|(
name|pos
argument_list|)
decl_stmt|;
name|filterPos
operator|.
name|addAll
argument_list|(
name|node
operator|.
name|getFilters
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|qb
operator|.
name|getQbJoinTree
argument_list|()
operator|==
name|node
condition|)
name|qb
operator|.
name|setQbJoinTree
argument_list|(
name|node
operator|.
name|getJoinSrc
argument_list|()
argument_list|)
expr_stmt|;
else|else
name|parent
operator|.
name|setJoinSrc
argument_list|(
name|node
operator|.
name|getJoinSrc
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|node
operator|.
name|getNoOuterJoin
argument_list|()
operator|&&
name|target
operator|.
name|getNoOuterJoin
argument_list|()
condition|)
name|target
operator|.
name|setNoOuterJoin
argument_list|(
literal|true
argument_list|)
expr_stmt|;
else|else
name|target
operator|.
name|setNoOuterJoin
argument_list|(
literal|false
argument_list|)
expr_stmt|;
name|joinCond
index|[]
name|nodeCondns
init|=
name|node
operator|.
name|getJoinCond
argument_list|()
decl_stmt|;
name|int
name|nodeCondnsSize
init|=
name|nodeCondns
operator|.
name|length
decl_stmt|;
name|joinCond
index|[]
name|targetCondns
init|=
name|target
operator|.
name|getJoinCond
argument_list|()
decl_stmt|;
name|int
name|targetCondnsSize
init|=
name|targetCondns
operator|.
name|length
decl_stmt|;
name|joinCond
index|[]
name|newCondns
init|=
operator|new
name|joinCond
index|[
name|nodeCondnsSize
operator|+
name|targetCondnsSize
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|targetCondnsSize
condition|;
name|i
operator|++
control|)
name|newCondns
index|[
name|i
index|]
operator|=
name|targetCondns
index|[
name|i
index|]
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|nodeCondnsSize
condition|;
name|i
operator|++
control|)
block|{
name|joinCond
name|nodeCondn
init|=
name|nodeCondns
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|nodeCondn
operator|.
name|getLeft
argument_list|()
operator|==
literal|0
condition|)
name|nodeCondn
operator|.
name|setLeft
argument_list|(
name|pos
argument_list|)
expr_stmt|;
else|else
name|nodeCondn
operator|.
name|setLeft
argument_list|(
name|nodeCondn
operator|.
name|getLeft
argument_list|()
operator|+
name|targetCondnsSize
argument_list|)
expr_stmt|;
name|nodeCondn
operator|.
name|setRight
argument_list|(
name|nodeCondn
operator|.
name|getRight
argument_list|()
operator|+
name|targetCondnsSize
argument_list|)
expr_stmt|;
name|newCondns
index|[
name|targetCondnsSize
operator|+
name|i
index|]
operator|=
name|nodeCondn
expr_stmt|;
block|}
name|target
operator|.
name|setJoinCond
argument_list|(
name|newCondns
argument_list|)
expr_stmt|;
if|if
condition|(
name|target
operator|.
name|isMapSideJoin
argument_list|()
condition|)
block|{
assert|assert
name|node
operator|.
name|isMapSideJoin
argument_list|()
assert|;
name|List
argument_list|<
name|String
argument_list|>
name|mapAliases
init|=
name|target
operator|.
name|getMapAliases
argument_list|()
decl_stmt|;
for|for
control|(
name|String
name|mapTbl
range|:
name|node
operator|.
name|getMapAliases
argument_list|()
control|)
if|if
condition|(
operator|!
name|mapAliases
operator|.
name|contains
argument_list|(
name|mapTbl
argument_list|)
condition|)
name|mapAliases
operator|.
name|add
argument_list|(
name|mapTbl
argument_list|)
expr_stmt|;
name|target
operator|.
name|setMapAliases
argument_list|(
name|mapAliases
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
name|int
name|findMergePos
parameter_list|(
name|QBJoinTree
name|node
parameter_list|,
name|QBJoinTree
name|target
parameter_list|)
block|{
name|int
name|res
init|=
operator|-
literal|1
decl_stmt|;
name|String
name|leftAlias
init|=
name|node
operator|.
name|getLeftAlias
argument_list|()
decl_stmt|;
if|if
condition|(
name|leftAlias
operator|==
literal|null
condition|)
return|return
operator|-
literal|1
return|;
name|Vector
argument_list|<
name|ASTNode
argument_list|>
name|nodeCondn
init|=
name|node
operator|.
name|getExpressions
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|Vector
argument_list|<
name|ASTNode
argument_list|>
name|targetCondn
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|leftAlias
operator|.
name|equals
argument_list|(
name|target
operator|.
name|getLeftAlias
argument_list|()
argument_list|)
condition|)
block|{
name|targetCondn
operator|=
name|target
operator|.
name|getExpressions
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|res
operator|=
literal|0
expr_stmt|;
block|}
else|else
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|target
operator|.
name|getRightAliases
argument_list|()
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|leftAlias
operator|.
name|equals
argument_list|(
name|target
operator|.
name|getRightAliases
argument_list|()
index|[
name|i
index|]
argument_list|)
condition|)
block|{
name|targetCondn
operator|=
name|target
operator|.
name|getExpressions
argument_list|()
operator|.
name|get
argument_list|(
name|i
operator|+
literal|1
argument_list|)
expr_stmt|;
name|res
operator|=
name|i
operator|+
literal|1
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|(
name|targetCondn
operator|==
literal|null
operator|)
operator|||
operator|(
name|nodeCondn
operator|.
name|size
argument_list|()
operator|!=
name|targetCondn
operator|.
name|size
argument_list|()
operator|)
condition|)
return|return
operator|-
literal|1
return|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|nodeCondn
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
name|nodeCondn
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|toStringTree
argument_list|()
operator|.
name|equals
argument_list|(
name|targetCondn
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|toStringTree
argument_list|()
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
return|return
name|res
return|;
block|}
specifier|private
name|boolean
name|mergeJoinNodes
parameter_list|(
name|QB
name|qb
parameter_list|,
name|QBJoinTree
name|parent
parameter_list|,
name|QBJoinTree
name|node
parameter_list|,
name|QBJoinTree
name|target
parameter_list|)
block|{
if|if
condition|(
name|target
operator|==
literal|null
condition|)
return|return
literal|false
return|;
name|int
name|res
init|=
name|findMergePos
argument_list|(
name|node
argument_list|,
name|target
argument_list|)
decl_stmt|;
if|if
condition|(
name|res
operator|!=
operator|-
literal|1
condition|)
block|{
name|mergeJoins
argument_list|(
name|qb
argument_list|,
name|parent
argument_list|,
name|node
argument_list|,
name|target
argument_list|,
name|res
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
return|return
name|mergeJoinNodes
argument_list|(
name|qb
argument_list|,
name|parent
argument_list|,
name|node
argument_list|,
name|target
operator|.
name|getJoinSrc
argument_list|()
argument_list|)
return|;
block|}
specifier|private
name|void
name|mergeJoinTree
parameter_list|(
name|QB
name|qb
parameter_list|)
block|{
name|QBJoinTree
name|root
init|=
name|qb
operator|.
name|getQbJoinTree
argument_list|()
decl_stmt|;
name|QBJoinTree
name|parent
init|=
literal|null
decl_stmt|;
while|while
condition|(
name|root
operator|!=
literal|null
condition|)
block|{
name|boolean
name|merged
init|=
name|mergeJoinNodes
argument_list|(
name|qb
argument_list|,
name|parent
argument_list|,
name|root
argument_list|,
name|root
operator|.
name|getJoinSrc
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|parent
operator|==
literal|null
condition|)
block|{
if|if
condition|(
name|merged
condition|)
name|root
operator|=
name|qb
operator|.
name|getQbJoinTree
argument_list|()
expr_stmt|;
else|else
block|{
name|parent
operator|=
name|root
expr_stmt|;
name|root
operator|=
name|root
operator|.
name|getJoinSrc
argument_list|()
expr_stmt|;
block|}
block|}
else|else
block|{
name|parent
operator|=
name|parent
operator|.
name|getJoinSrc
argument_list|()
expr_stmt|;
name|root
operator|=
name|parent
operator|.
name|getJoinSrc
argument_list|()
expr_stmt|;
block|}
block|}
block|}
specifier|private
name|Operator
name|insertSelectAllPlanForGroupBy
parameter_list|(
name|String
name|dest
parameter_list|,
name|Operator
name|input
parameter_list|)
throws|throws
name|SemanticException
block|{
name|OpParseContext
name|inputCtx
init|=
name|opParseCtx
operator|.
name|get
argument_list|(
name|input
argument_list|)
decl_stmt|;
name|RowResolver
name|inputRR
init|=
name|inputCtx
operator|.
name|getRR
argument_list|()
decl_stmt|;
name|Vector
argument_list|<
name|ColumnInfo
argument_list|>
name|columns
init|=
name|inputRR
operator|.
name|getColumnInfos
argument_list|()
decl_stmt|;
name|ArrayList
argument_list|<
name|exprNodeDesc
argument_list|>
name|colList
init|=
operator|new
name|ArrayList
argument_list|<
name|exprNodeDesc
argument_list|>
argument_list|()
decl_stmt|;
name|ArrayList
argument_list|<
name|String
argument_list|>
name|columnNames
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|columns
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|ColumnInfo
name|col
init|=
name|columns
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|colList
operator|.
name|add
argument_list|(
operator|new
name|exprNodeColumnDesc
argument_list|(
name|col
operator|.
name|getType
argument_list|()
argument_list|,
name|col
operator|.
name|getInternalName
argument_list|()
argument_list|,
name|col
operator|.
name|getTabAlias
argument_list|()
argument_list|,
name|col
operator|.
name|getIsPartitionCol
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|columnNames
operator|.
name|add
argument_list|(
name|col
operator|.
name|getInternalName
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|Operator
name|output
init|=
name|putOpInsertMap
argument_list|(
name|OperatorFactory
operator|.
name|getAndMakeChild
argument_list|(
operator|new
name|selectDesc
argument_list|(
name|colList
argument_list|,
name|columnNames
argument_list|,
literal|true
argument_list|)
argument_list|,
operator|new
name|RowSchema
argument_list|(
name|inputRR
operator|.
name|getColumnInfos
argument_list|()
argument_list|)
argument_list|,
name|input
argument_list|)
argument_list|,
name|inputRR
argument_list|)
decl_stmt|;
name|output
operator|.
name|setColumnExprMap
argument_list|(
name|input
operator|.
name|getColumnExprMap
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|output
return|;
block|}
comment|// Return the common distinct expression
comment|// There should be more than 1 destination, with group bys in all of them.
specifier|private
name|List
argument_list|<
name|ASTNode
argument_list|>
name|getCommonDistinctExprs
parameter_list|(
name|QB
name|qb
parameter_list|,
name|Operator
name|input
parameter_list|)
block|{
name|RowResolver
name|inputRR
init|=
name|opParseCtx
operator|.
name|get
argument_list|(
name|input
argument_list|)
operator|.
name|getRR
argument_list|()
decl_stmt|;
name|QBParseInfo
name|qbp
init|=
name|qb
operator|.
name|getParseInfo
argument_list|()
decl_stmt|;
name|TreeSet
argument_list|<
name|String
argument_list|>
name|ks
init|=
operator|new
name|TreeSet
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
name|ks
operator|.
name|addAll
argument_list|(
name|qbp
operator|.
name|getClauseNames
argument_list|()
argument_list|)
expr_stmt|;
comment|// Go over all the destination tables
if|if
condition|(
name|ks
operator|.
name|size
argument_list|()
operator|<=
literal|1
condition|)
return|return
literal|null
return|;
name|List
argument_list|<
name|exprNodeDesc
argument_list|>
name|oldList
init|=
literal|null
decl_stmt|;
name|List
argument_list|<
name|ASTNode
argument_list|>
name|oldASTList
init|=
literal|null
decl_stmt|;
for|for
control|(
name|String
name|dest
range|:
name|ks
control|)
block|{
name|Operator
name|curr
init|=
name|input
decl_stmt|;
comment|// If a filter is present, common processing is not possible
if|if
condition|(
name|qbp
operator|.
name|getWhrForClause
argument_list|(
name|dest
argument_list|)
operator|!=
literal|null
condition|)
return|return
literal|null
return|;
if|if
condition|(
name|qbp
operator|.
name|getAggregationExprsForClause
argument_list|(
name|dest
argument_list|)
operator|.
name|size
argument_list|()
operator|==
literal|0
operator|&&
name|getGroupByForClause
argument_list|(
name|qbp
argument_list|,
name|dest
argument_list|)
operator|.
name|size
argument_list|()
operator|==
literal|0
condition|)
return|return
literal|null
return|;
comment|// All distinct expressions must be the same
name|ASTNode
name|value
init|=
name|qbp
operator|.
name|getDistinctFuncExprForClause
argument_list|(
name|dest
argument_list|)
decl_stmt|;
if|if
condition|(
name|value
operator|==
literal|null
condition|)
return|return
literal|null
return|;
name|List
argument_list|<
name|exprNodeDesc
argument_list|>
name|currDestList
init|=
operator|new
name|ArrayList
argument_list|<
name|exprNodeDesc
argument_list|>
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|ASTNode
argument_list|>
name|currASTList
init|=
operator|new
name|ArrayList
argument_list|<
name|ASTNode
argument_list|>
argument_list|()
decl_stmt|;
try|try
block|{
comment|// 0 is function name
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<
name|value
operator|.
name|getChildCount
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|ASTNode
name|parameter
init|=
operator|(
name|ASTNode
operator|)
name|value
operator|.
name|getChild
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|currDestList
operator|.
name|add
argument_list|(
name|genExprNodeDesc
argument_list|(
name|parameter
argument_list|,
name|inputRR
argument_list|)
argument_list|)
expr_stmt|;
name|currASTList
operator|.
name|add
argument_list|(
name|parameter
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|SemanticException
name|e
parameter_list|)
block|{
return|return
literal|null
return|;
block|}
if|if
condition|(
name|oldList
operator|==
literal|null
condition|)
block|{
name|oldList
operator|=
name|currDestList
expr_stmt|;
name|oldASTList
operator|=
name|currASTList
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|oldList
operator|.
name|size
argument_list|()
operator|!=
name|currDestList
operator|.
name|size
argument_list|()
condition|)
return|return
literal|null
return|;
for|for
control|(
name|int
name|pos
init|=
literal|0
init|;
name|pos
operator|<
name|oldList
operator|.
name|size
argument_list|()
condition|;
name|pos
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|oldList
operator|.
name|get
argument_list|(
name|pos
argument_list|)
operator|.
name|isSame
argument_list|(
name|currDestList
operator|.
name|get
argument_list|(
name|pos
argument_list|)
argument_list|)
condition|)
return|return
literal|null
return|;
block|}
block|}
block|}
return|return
name|oldASTList
return|;
block|}
specifier|private
name|Operator
name|createCommonReduceSink
parameter_list|(
name|QB
name|qb
parameter_list|,
name|Operator
name|input
parameter_list|)
throws|throws
name|SemanticException
block|{
comment|// Go over all the tables and extract the common distinct key
name|List
argument_list|<
name|ASTNode
argument_list|>
name|distExprs
init|=
name|getCommonDistinctExprs
argument_list|(
name|qb
argument_list|,
name|input
argument_list|)
decl_stmt|;
name|QBParseInfo
name|qbp
init|=
name|qb
operator|.
name|getParseInfo
argument_list|()
decl_stmt|;
name|TreeSet
argument_list|<
name|String
argument_list|>
name|ks
init|=
operator|new
name|TreeSet
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
name|ks
operator|.
name|addAll
argument_list|(
name|qbp
operator|.
name|getClauseNames
argument_list|()
argument_list|)
expr_stmt|;
comment|// Pass the entire row
name|RowResolver
name|inputRR
init|=
name|opParseCtx
operator|.
name|get
argument_list|(
name|input
argument_list|)
operator|.
name|getRR
argument_list|()
decl_stmt|;
name|RowResolver
name|reduceSinkOutputRowResolver
init|=
operator|new
name|RowResolver
argument_list|()
decl_stmt|;
name|reduceSinkOutputRowResolver
operator|.
name|setIsExprResolver
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|ArrayList
argument_list|<
name|exprNodeDesc
argument_list|>
name|reduceKeys
init|=
operator|new
name|ArrayList
argument_list|<
name|exprNodeDesc
argument_list|>
argument_list|()
decl_stmt|;
name|ArrayList
argument_list|<
name|exprNodeDesc
argument_list|>
name|reduceValues
init|=
operator|new
name|ArrayList
argument_list|<
name|exprNodeDesc
argument_list|>
argument_list|()
decl_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|exprNodeDesc
argument_list|>
name|colExprMap
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|exprNodeDesc
argument_list|>
argument_list|()
decl_stmt|;
comment|// Pre-compute distinct group-by keys and store in reduceKeys
name|List
argument_list|<
name|String
argument_list|>
name|outputColumnNames
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|ASTNode
name|distn
range|:
name|distExprs
control|)
block|{
name|exprNodeDesc
name|distExpr
init|=
name|genExprNodeDesc
argument_list|(
name|distn
argument_list|,
name|inputRR
argument_list|)
decl_stmt|;
name|reduceKeys
operator|.
name|add
argument_list|(
name|distExpr
argument_list|)
expr_stmt|;
name|String
name|text
init|=
name|distn
operator|.
name|toStringTree
argument_list|()
decl_stmt|;
if|if
condition|(
name|reduceSinkOutputRowResolver
operator|.
name|get
argument_list|(
literal|""
argument_list|,
name|text
argument_list|)
operator|==
literal|null
condition|)
block|{
name|outputColumnNames
operator|.
name|add
argument_list|(
name|getColumnInternalName
argument_list|(
name|reduceKeys
operator|.
name|size
argument_list|()
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|String
name|field
init|=
name|Utilities
operator|.
name|ReduceField
operator|.
name|KEY
operator|.
name|toString
argument_list|()
operator|+
literal|"."
operator|+
name|getColumnInternalName
argument_list|(
name|reduceKeys
operator|.
name|size
argument_list|()
operator|-
literal|1
argument_list|)
decl_stmt|;
name|ColumnInfo
name|colInfo
init|=
operator|new
name|ColumnInfo
argument_list|(
name|field
argument_list|,
name|reduceKeys
operator|.
name|get
argument_list|(
name|reduceKeys
operator|.
name|size
argument_list|()
operator|-
literal|1
argument_list|)
operator|.
name|getTypeInfo
argument_list|()
argument_list|,
literal|""
argument_list|,
literal|false
argument_list|)
decl_stmt|;
name|reduceSinkOutputRowResolver
operator|.
name|put
argument_list|(
literal|""
argument_list|,
name|text
argument_list|,
name|colInfo
argument_list|)
expr_stmt|;
name|colExprMap
operator|.
name|put
argument_list|(
name|colInfo
operator|.
name|getInternalName
argument_list|()
argument_list|,
name|distExpr
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Go over all the grouping keys and aggregations
for|for
control|(
name|String
name|dest
range|:
name|ks
control|)
block|{
name|List
argument_list|<
name|ASTNode
argument_list|>
name|grpByExprs
init|=
name|getGroupByForClause
argument_list|(
name|qbp
argument_list|,
name|dest
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|grpByExprs
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|ASTNode
name|grpbyExpr
init|=
name|grpByExprs
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|String
name|text
init|=
name|grpbyExpr
operator|.
name|toStringTree
argument_list|()
decl_stmt|;
if|if
condition|(
name|reduceSinkOutputRowResolver
operator|.
name|get
argument_list|(
literal|""
argument_list|,
name|text
argument_list|)
operator|==
literal|null
condition|)
block|{
name|exprNodeDesc
name|grpByExprNode
init|=
name|genExprNodeDesc
argument_list|(
name|grpbyExpr
argument_list|,
name|inputRR
argument_list|)
decl_stmt|;
name|reduceValues
operator|.
name|add
argument_list|(
name|grpByExprNode
argument_list|)
expr_stmt|;
name|String
name|field
init|=
name|Utilities
operator|.
name|ReduceField
operator|.
name|VALUE
operator|.
name|toString
argument_list|()
operator|+
literal|"."
operator|+
name|getColumnInternalName
argument_list|(
name|reduceValues
operator|.
name|size
argument_list|()
operator|-
literal|1
argument_list|)
decl_stmt|;
name|ColumnInfo
name|colInfo
init|=
operator|new
name|ColumnInfo
argument_list|(
name|field
argument_list|,
name|reduceValues
operator|.
name|get
argument_list|(
name|reduceValues
operator|.
name|size
argument_list|()
operator|-
literal|1
argument_list|)
operator|.
name|getTypeInfo
argument_list|()
argument_list|,
literal|""
argument_list|,
literal|false
argument_list|)
decl_stmt|;
name|reduceSinkOutputRowResolver
operator|.
name|put
argument_list|(
literal|""
argument_list|,
name|text
argument_list|,
name|colInfo
argument_list|)
expr_stmt|;
name|outputColumnNames
operator|.
name|add
argument_list|(
name|getColumnInternalName
argument_list|(
name|reduceValues
operator|.
name|size
argument_list|()
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|// For each aggregation
name|HashMap
argument_list|<
name|String
argument_list|,
name|ASTNode
argument_list|>
name|aggregationTrees
init|=
name|qbp
operator|.
name|getAggregationExprsForClause
argument_list|(
name|dest
argument_list|)
decl_stmt|;
assert|assert
operator|(
name|aggregationTrees
operator|!=
literal|null
operator|)
assert|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|ASTNode
argument_list|>
name|entry
range|:
name|aggregationTrees
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|ASTNode
name|value
init|=
name|entry
operator|.
name|getValue
argument_list|()
decl_stmt|;
name|String
name|aggName
init|=
name|value
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getText
argument_list|()
decl_stmt|;
comment|// 0 is the function name
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<
name|value
operator|.
name|getChildCount
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|ASTNode
name|paraExpr
init|=
operator|(
name|ASTNode
operator|)
name|value
operator|.
name|getChild
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|String
name|text
init|=
name|paraExpr
operator|.
name|toStringTree
argument_list|()
decl_stmt|;
if|if
condition|(
name|reduceSinkOutputRowResolver
operator|.
name|get
argument_list|(
literal|""
argument_list|,
name|text
argument_list|)
operator|==
literal|null
condition|)
block|{
name|exprNodeDesc
name|paraExprNode
init|=
name|genExprNodeDesc
argument_list|(
name|paraExpr
argument_list|,
name|inputRR
argument_list|)
decl_stmt|;
name|reduceValues
operator|.
name|add
argument_list|(
name|paraExprNode
argument_list|)
expr_stmt|;
name|String
name|field
init|=
name|Utilities
operator|.
name|ReduceField
operator|.
name|VALUE
operator|.
name|toString
argument_list|()
operator|+
literal|"."
operator|+
name|getColumnInternalName
argument_list|(
name|reduceValues
operator|.
name|size
argument_list|()
operator|-
literal|1
argument_list|)
decl_stmt|;
name|ColumnInfo
name|colInfo
init|=
operator|new
name|ColumnInfo
argument_list|(
name|field
argument_list|,
name|reduceValues
operator|.
name|get
argument_list|(
name|reduceValues
operator|.
name|size
argument_list|()
operator|-
literal|1
argument_list|)
operator|.
name|getTypeInfo
argument_list|()
argument_list|,
literal|""
argument_list|,
literal|false
argument_list|)
decl_stmt|;
name|reduceSinkOutputRowResolver
operator|.
name|put
argument_list|(
literal|""
argument_list|,
name|text
argument_list|,
name|colInfo
argument_list|)
expr_stmt|;
name|outputColumnNames
operator|.
name|add
argument_list|(
name|getColumnInternalName
argument_list|(
name|reduceValues
operator|.
name|size
argument_list|()
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
name|ReduceSinkOperator
name|rsOp
init|=
operator|(
name|ReduceSinkOperator
operator|)
name|putOpInsertMap
argument_list|(
name|OperatorFactory
operator|.
name|getAndMakeChild
argument_list|(
name|PlanUtils
operator|.
name|getReduceSinkDesc
argument_list|(
name|reduceKeys
argument_list|,
name|reduceValues
argument_list|,
name|outputColumnNames
argument_list|,
literal|true
argument_list|,
operator|-
literal|1
argument_list|,
name|reduceKeys
operator|.
name|size
argument_list|()
argument_list|,
operator|-
literal|1
argument_list|)
argument_list|,
operator|new
name|RowSchema
argument_list|(
name|reduceSinkOutputRowResolver
operator|.
name|getColumnInfos
argument_list|()
argument_list|)
argument_list|,
name|input
argument_list|)
argument_list|,
name|reduceSinkOutputRowResolver
argument_list|)
decl_stmt|;
name|rsOp
operator|.
name|setColumnExprMap
argument_list|(
name|colExprMap
argument_list|)
expr_stmt|;
return|return
name|rsOp
return|;
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"nls"
argument_list|)
specifier|private
name|Operator
name|genBodyPlan
parameter_list|(
name|QB
name|qb
parameter_list|,
name|Operator
name|input
parameter_list|)
throws|throws
name|SemanticException
block|{
name|QBParseInfo
name|qbp
init|=
name|qb
operator|.
name|getParseInfo
argument_list|()
decl_stmt|;
name|TreeSet
argument_list|<
name|String
argument_list|>
name|ks
init|=
operator|new
name|TreeSet
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
name|ks
operator|.
name|addAll
argument_list|(
name|qbp
operator|.
name|getClauseNames
argument_list|()
argument_list|)
expr_stmt|;
comment|// For multi-group by with the same distinct, we ignore all user hints currently. It doesnt matter whether he has asked to do
comment|// map-side aggregation or not. Map side aggregation is turned off
name|boolean
name|optimizeMultiGroupBy
init|=
operator|(
name|getCommonDistinctExprs
argument_list|(
name|qb
argument_list|,
name|input
argument_list|)
operator|!=
literal|null
operator|)
decl_stmt|;
name|Operator
name|curr
init|=
literal|null
decl_stmt|;
comment|// If there are multiple group-bys, map-side aggregation is turned off, there are no filters
comment|// and there is a single distinct, optimize that. Spray initially by the distinct key,
comment|// no computation at the mapper. Have multiple group by operators at the reducer - and then
comment|// proceed
if|if
condition|(
name|optimizeMultiGroupBy
condition|)
block|{
name|curr
operator|=
name|createCommonReduceSink
argument_list|(
name|qb
argument_list|,
name|input
argument_list|)
expr_stmt|;
name|RowResolver
name|currRR
init|=
name|opParseCtx
operator|.
name|get
argument_list|(
name|curr
argument_list|)
operator|.
name|getRR
argument_list|()
decl_stmt|;
comment|// create a forward operator
name|input
operator|=
name|putOpInsertMap
argument_list|(
name|OperatorFactory
operator|.
name|getAndMakeChild
argument_list|(
operator|new
name|forwardDesc
argument_list|()
argument_list|,
operator|new
name|RowSchema
argument_list|(
name|currRR
operator|.
name|getColumnInfos
argument_list|()
argument_list|)
argument_list|,
name|curr
argument_list|)
argument_list|,
name|currRR
argument_list|)
expr_stmt|;
for|for
control|(
name|String
name|dest
range|:
name|ks
control|)
block|{
name|curr
operator|=
name|input
expr_stmt|;
name|curr
operator|=
name|genGroupByPlan2MRMultiGroupBy
argument_list|(
name|dest
argument_list|,
name|qb
argument_list|,
name|curr
argument_list|)
expr_stmt|;
name|curr
operator|=
name|genSelectPlan
argument_list|(
name|dest
argument_list|,
name|qb
argument_list|,
name|curr
argument_list|)
expr_stmt|;
name|Integer
name|limit
init|=
name|qbp
operator|.
name|getDestLimit
argument_list|(
name|dest
argument_list|)
decl_stmt|;
if|if
condition|(
name|limit
operator|!=
literal|null
condition|)
block|{
name|curr
operator|=
name|genLimitMapRedPlan
argument_list|(
name|dest
argument_list|,
name|qb
argument_list|,
name|curr
argument_list|,
name|limit
operator|.
name|intValue
argument_list|()
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|qb
operator|.
name|getParseInfo
argument_list|()
operator|.
name|setOuterQueryLimit
argument_list|(
name|limit
operator|.
name|intValue
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|curr
operator|=
name|genFileSinkPlan
argument_list|(
name|dest
argument_list|,
name|qb
argument_list|,
name|curr
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// Go over all the destination tables
for|for
control|(
name|String
name|dest
range|:
name|ks
control|)
block|{
name|curr
operator|=
name|input
expr_stmt|;
if|if
condition|(
name|qbp
operator|.
name|getWhrForClause
argument_list|(
name|dest
argument_list|)
operator|!=
literal|null
condition|)
block|{
name|curr
operator|=
name|genFilterPlan
argument_list|(
name|dest
argument_list|,
name|qb
argument_list|,
name|curr
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|qbp
operator|.
name|getAggregationExprsForClause
argument_list|(
name|dest
argument_list|)
operator|.
name|size
argument_list|()
operator|!=
literal|0
operator|||
name|getGroupByForClause
argument_list|(
name|qbp
argument_list|,
name|dest
argument_list|)
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
comment|// insert a select operator here used by the ColumnPruner to reduce the data to shuffle
name|curr
operator|=
name|insertSelectAllPlanForGroupBy
argument_list|(
name|dest
argument_list|,
name|curr
argument_list|)
expr_stmt|;
if|if
condition|(
name|conf
operator|.
name|getVar
argument_list|(
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVEMAPSIDEAGGREGATE
argument_list|)
operator|.
name|equalsIgnoreCase
argument_list|(
literal|"true"
argument_list|)
condition|)
block|{
if|if
condition|(
name|conf
operator|.
name|getVar
argument_list|(
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVEGROUPBYSKEW
argument_list|)
operator|.
name|equalsIgnoreCase
argument_list|(
literal|"false"
argument_list|)
condition|)
name|curr
operator|=
name|genGroupByPlanMapAggr1MR
argument_list|(
name|dest
argument_list|,
name|qb
argument_list|,
name|curr
argument_list|)
expr_stmt|;
else|else
name|curr
operator|=
name|genGroupByPlanMapAggr2MR
argument_list|(
name|dest
argument_list|,
name|qb
argument_list|,
name|curr
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|conf
operator|.
name|getVar
argument_list|(
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVEGROUPBYSKEW
argument_list|)
operator|.
name|equalsIgnoreCase
argument_list|(
literal|"true"
argument_list|)
condition|)
name|curr
operator|=
name|genGroupByPlan2MR
argument_list|(
name|dest
argument_list|,
name|qb
argument_list|,
name|curr
argument_list|)
expr_stmt|;
else|else
name|curr
operator|=
name|genGroupByPlan1MR
argument_list|(
name|dest
argument_list|,
name|qb
argument_list|,
name|curr
argument_list|)
expr_stmt|;
block|}
name|curr
operator|=
name|genSelectPlan
argument_list|(
name|dest
argument_list|,
name|qb
argument_list|,
name|curr
argument_list|)
expr_stmt|;
name|Integer
name|limit
init|=
name|qbp
operator|.
name|getDestLimit
argument_list|(
name|dest
argument_list|)
decl_stmt|;
if|if
condition|(
name|qbp
operator|.
name|getClusterByForClause
argument_list|(
name|dest
argument_list|)
operator|!=
literal|null
operator|||
name|qbp
operator|.
name|getDistributeByForClause
argument_list|(
name|dest
argument_list|)
operator|!=
literal|null
operator|||
name|qbp
operator|.
name|getOrderByForClause
argument_list|(
name|dest
argument_list|)
operator|!=
literal|null
operator|||
name|qbp
operator|.
name|getSortByForClause
argument_list|(
name|dest
argument_list|)
operator|!=
literal|null
condition|)
block|{
name|int
name|numReducers
init|=
operator|-
literal|1
decl_stmt|;
comment|// Use only 1 reducer if order by is present
if|if
condition|(
name|qbp
operator|.
name|getOrderByForClause
argument_list|(
name|dest
argument_list|)
operator|!=
literal|null
condition|)
name|numReducers
operator|=
literal|1
expr_stmt|;
name|curr
operator|=
name|genReduceSinkPlan
argument_list|(
name|dest
argument_list|,
name|qb
argument_list|,
name|curr
argument_list|,
name|numReducers
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|qbp
operator|.
name|getIsSubQ
argument_list|()
condition|)
block|{
if|if
condition|(
name|limit
operator|!=
literal|null
condition|)
block|{
comment|// In case of order by, only 1 reducer is used, so no need of another shuffle
name|curr
operator|=
name|genLimitMapRedPlan
argument_list|(
name|dest
argument_list|,
name|qb
argument_list|,
name|curr
argument_list|,
name|limit
operator|.
name|intValue
argument_list|()
argument_list|,
name|qbp
operator|.
name|getOrderByForClause
argument_list|(
name|dest
argument_list|)
operator|!=
literal|null
condition|?
literal|false
else|:
literal|true
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|curr
operator|=
name|genConversionOps
argument_list|(
name|dest
argument_list|,
name|qb
argument_list|,
name|curr
argument_list|)
expr_stmt|;
comment|// exact limit can be taken care of by the fetch operator
if|if
condition|(
name|limit
operator|!=
literal|null
condition|)
block|{
name|boolean
name|extraMRStep
init|=
literal|true
decl_stmt|;
if|if
condition|(
name|qb
operator|.
name|getIsQuery
argument_list|()
operator|&&
name|qbp
operator|.
name|getClusterByForClause
argument_list|(
name|dest
argument_list|)
operator|==
literal|null
operator|&&
name|qbp
operator|.
name|getSortByForClause
argument_list|(
name|dest
argument_list|)
operator|==
literal|null
condition|)
name|extraMRStep
operator|=
literal|false
expr_stmt|;
name|curr
operator|=
name|genLimitMapRedPlan
argument_list|(
name|dest
argument_list|,
name|qb
argument_list|,
name|curr
argument_list|,
name|limit
operator|.
name|intValue
argument_list|()
argument_list|,
name|extraMRStep
argument_list|)
expr_stmt|;
name|qb
operator|.
name|getParseInfo
argument_list|()
operator|.
name|setOuterQueryLimit
argument_list|(
name|limit
operator|.
name|intValue
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|curr
operator|=
name|genFileSinkPlan
argument_list|(
name|dest
argument_list|,
name|qb
argument_list|,
name|curr
argument_list|)
expr_stmt|;
block|}
comment|// change curr ops row resolver's tab aliases to query alias if it exists
if|if
condition|(
name|qb
operator|.
name|getParseInfo
argument_list|()
operator|.
name|getAlias
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|RowResolver
name|rr
init|=
name|opParseCtx
operator|.
name|get
argument_list|(
name|curr
argument_list|)
operator|.
name|getRR
argument_list|()
decl_stmt|;
name|RowResolver
name|newRR
init|=
operator|new
name|RowResolver
argument_list|()
decl_stmt|;
name|String
name|alias
init|=
name|qb
operator|.
name|getParseInfo
argument_list|()
operator|.
name|getAlias
argument_list|()
decl_stmt|;
for|for
control|(
name|ColumnInfo
name|colInfo
range|:
name|rr
operator|.
name|getColumnInfos
argument_list|()
control|)
block|{
name|String
name|name
init|=
name|colInfo
operator|.
name|getInternalName
argument_list|()
decl_stmt|;
name|String
index|[]
name|tmp
init|=
name|rr
operator|.
name|reverseLookup
argument_list|(
name|name
argument_list|)
decl_stmt|;
name|newRR
operator|.
name|put
argument_list|(
name|alias
argument_list|,
name|tmp
index|[
literal|1
index|]
argument_list|,
name|colInfo
argument_list|)
expr_stmt|;
block|}
name|opParseCtx
operator|.
name|get
argument_list|(
name|curr
argument_list|)
operator|.
name|setRR
argument_list|(
name|newRR
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|LOG
operator|.
name|debug
argument_list|(
literal|"Created Body Plan for Query Block "
operator|+
name|qb
operator|.
name|getId
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|curr
return|;
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"nls"
argument_list|)
specifier|private
name|Operator
name|genUnionPlan
parameter_list|(
name|String
name|unionalias
parameter_list|,
name|String
name|leftalias
parameter_list|,
name|Operator
name|leftOp
parameter_list|,
name|String
name|rightalias
parameter_list|,
name|Operator
name|rightOp
parameter_list|)
throws|throws
name|SemanticException
block|{
comment|// Currently, the unions are not merged - each union has only 2 parents. So, a n-way union will lead to (n-1) union operators.
comment|// This can be easily merged into 1 union
name|RowResolver
name|leftRR
init|=
name|opParseCtx
operator|.
name|get
argument_list|(
name|leftOp
argument_list|)
operator|.
name|getRR
argument_list|()
decl_stmt|;
name|RowResolver
name|rightRR
init|=
name|opParseCtx
operator|.
name|get
argument_list|(
name|rightOp
argument_list|)
operator|.
name|getRR
argument_list|()
decl_stmt|;
name|HashMap
argument_list|<
name|String
argument_list|,
name|ColumnInfo
argument_list|>
name|leftmap
init|=
name|leftRR
operator|.
name|getFieldMap
argument_list|(
name|leftalias
argument_list|)
decl_stmt|;
name|HashMap
argument_list|<
name|String
argument_list|,
name|ColumnInfo
argument_list|>
name|rightmap
init|=
name|rightRR
operator|.
name|getFieldMap
argument_list|(
name|rightalias
argument_list|)
decl_stmt|;
comment|// make sure the schemas of both sides are the same
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|ColumnInfo
argument_list|>
name|lEntry
range|:
name|leftmap
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|String
name|field
init|=
name|lEntry
operator|.
name|getKey
argument_list|()
decl_stmt|;
name|ColumnInfo
name|lInfo
init|=
name|lEntry
operator|.
name|getValue
argument_list|()
decl_stmt|;
name|ColumnInfo
name|rInfo
init|=
name|rightmap
operator|.
name|get
argument_list|(
name|field
argument_list|)
decl_stmt|;
if|if
condition|(
name|rInfo
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
literal|"Schema of both sides of union should match. "
operator|+
name|rightalias
operator|+
literal|" does not have the field "
operator|+
name|field
argument_list|)
throw|;
block|}
if|if
condition|(
name|lInfo
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
literal|"Schema of both sides of union should match. "
operator|+
name|leftalias
operator|+
literal|" does not have the field "
operator|+
name|field
argument_list|)
throw|;
block|}
if|if
condition|(
operator|!
name|lInfo
operator|.
name|getInternalName
argument_list|()
operator|.
name|equals
argument_list|(
name|rInfo
operator|.
name|getInternalName
argument_list|()
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
literal|"Schema of both sides of union should match: "
operator|+
name|field
operator|+
literal|":"
operator|+
name|lInfo
operator|.
name|getInternalName
argument_list|()
operator|+
literal|" "
operator|+
name|rInfo
operator|.
name|getInternalName
argument_list|()
argument_list|)
throw|;
block|}
if|if
condition|(
operator|!
name|lInfo
operator|.
name|getType
argument_list|()
operator|.
name|getTypeName
argument_list|()
operator|.
name|equals
argument_list|(
name|rInfo
operator|.
name|getType
argument_list|()
operator|.
name|getTypeName
argument_list|()
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
literal|"Schema of both sides of union should match: Column "
operator|+
name|field
operator|+
literal|" is of type "
operator|+
name|lInfo
operator|.
name|getType
argument_list|()
operator|.
name|getTypeName
argument_list|()
operator|+
literal|" on first table and type "
operator|+
name|rInfo
operator|.
name|getType
argument_list|()
operator|.
name|getTypeName
argument_list|()
operator|+
literal|" on second table"
argument_list|)
throw|;
block|}
block|}
comment|// construct the forward operator
name|RowResolver
name|unionoutRR
init|=
operator|new
name|RowResolver
argument_list|()
decl_stmt|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|ColumnInfo
argument_list|>
name|lEntry
range|:
name|leftmap
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|String
name|field
init|=
name|lEntry
operator|.
name|getKey
argument_list|()
decl_stmt|;
name|ColumnInfo
name|lInfo
init|=
name|lEntry
operator|.
name|getValue
argument_list|()
decl_stmt|;
name|unionoutRR
operator|.
name|put
argument_list|(
name|unionalias
argument_list|,
name|field
argument_list|,
name|lInfo
argument_list|)
expr_stmt|;
block|}
comment|// If one of the children is a union, merge with it
comment|// else create a new one
if|if
condition|(
operator|(
name|leftOp
operator|instanceof
name|UnionOperator
operator|)
operator|||
operator|(
name|rightOp
operator|instanceof
name|UnionOperator
operator|)
condition|)
block|{
if|if
condition|(
name|leftOp
operator|instanceof
name|UnionOperator
condition|)
block|{
comment|// make left a child of right
name|List
argument_list|<
name|Operator
argument_list|<
name|?
extends|extends
name|Serializable
argument_list|>
argument_list|>
name|child
init|=
operator|new
name|ArrayList
argument_list|<
name|Operator
argument_list|<
name|?
extends|extends
name|Serializable
argument_list|>
argument_list|>
argument_list|()
decl_stmt|;
name|child
operator|.
name|add
argument_list|(
name|leftOp
argument_list|)
expr_stmt|;
name|rightOp
operator|.
name|setChildOperators
argument_list|(
name|child
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|Operator
argument_list|<
name|?
extends|extends
name|Serializable
argument_list|>
argument_list|>
name|parent
init|=
name|leftOp
operator|.
name|getParentOperators
argument_list|()
decl_stmt|;
name|parent
operator|.
name|add
argument_list|(
name|rightOp
argument_list|)
expr_stmt|;
name|unionDesc
name|uDesc
init|=
operator|(
operator|(
name|UnionOperator
operator|)
name|leftOp
operator|)
operator|.
name|getConf
argument_list|()
decl_stmt|;
name|uDesc
operator|.
name|setNumInputs
argument_list|(
name|uDesc
operator|.
name|getNumInputs
argument_list|()
operator|+
literal|1
argument_list|)
expr_stmt|;
return|return
name|putOpInsertMap
argument_list|(
name|leftOp
argument_list|,
name|unionoutRR
argument_list|)
return|;
block|}
else|else
block|{
comment|// make right a child of left
name|List
argument_list|<
name|Operator
argument_list|<
name|?
extends|extends
name|Serializable
argument_list|>
argument_list|>
name|child
init|=
operator|new
name|ArrayList
argument_list|<
name|Operator
argument_list|<
name|?
extends|extends
name|Serializable
argument_list|>
argument_list|>
argument_list|()
decl_stmt|;
name|child
operator|.
name|add
argument_list|(
name|rightOp
argument_list|)
expr_stmt|;
name|leftOp
operator|.
name|setChildOperators
argument_list|(
name|child
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|Operator
argument_list|<
name|?
extends|extends
name|Serializable
argument_list|>
argument_list|>
name|parent
init|=
name|rightOp
operator|.
name|getParentOperators
argument_list|()
decl_stmt|;
name|parent
operator|.
name|add
argument_list|(
name|leftOp
argument_list|)
expr_stmt|;
name|unionDesc
name|uDesc
init|=
operator|(
operator|(
name|UnionOperator
operator|)
name|rightOp
operator|)
operator|.
name|getConf
argument_list|()
decl_stmt|;
name|uDesc
operator|.
name|setNumInputs
argument_list|(
name|uDesc
operator|.
name|getNumInputs
argument_list|()
operator|+
literal|1
argument_list|)
expr_stmt|;
return|return
name|putOpInsertMap
argument_list|(
name|rightOp
argument_list|,
name|unionoutRR
argument_list|)
return|;
block|}
block|}
comment|// Create a new union operator
name|Operator
argument_list|<
name|?
extends|extends
name|Serializable
argument_list|>
name|unionforward
init|=
name|OperatorFactory
operator|.
name|getAndMakeChild
argument_list|(
operator|new
name|unionDesc
argument_list|()
argument_list|,
operator|new
name|RowSchema
argument_list|(
name|unionoutRR
operator|.
name|getColumnInfos
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
comment|// set union operator as child of each of leftOp and rightOp
name|List
argument_list|<
name|Operator
argument_list|<
name|?
extends|extends
name|Serializable
argument_list|>
argument_list|>
name|child
init|=
operator|new
name|ArrayList
argument_list|<
name|Operator
argument_list|<
name|?
extends|extends
name|Serializable
argument_list|>
argument_list|>
argument_list|()
decl_stmt|;
name|child
operator|.
name|add
argument_list|(
name|unionforward
argument_list|)
expr_stmt|;
name|rightOp
operator|.
name|setChildOperators
argument_list|(
name|child
argument_list|)
expr_stmt|;
name|child
operator|=
operator|new
name|ArrayList
argument_list|<
name|Operator
argument_list|<
name|?
extends|extends
name|Serializable
argument_list|>
argument_list|>
argument_list|()
expr_stmt|;
name|child
operator|.
name|add
argument_list|(
name|unionforward
argument_list|)
expr_stmt|;
name|leftOp
operator|.
name|setChildOperators
argument_list|(
name|child
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|Operator
argument_list|<
name|?
extends|extends
name|Serializable
argument_list|>
argument_list|>
name|parent
init|=
operator|new
name|ArrayList
argument_list|<
name|Operator
argument_list|<
name|?
extends|extends
name|Serializable
argument_list|>
argument_list|>
argument_list|()
decl_stmt|;
name|parent
operator|.
name|add
argument_list|(
name|leftOp
argument_list|)
expr_stmt|;
name|parent
operator|.
name|add
argument_list|(
name|rightOp
argument_list|)
expr_stmt|;
name|unionforward
operator|.
name|setParentOperators
argument_list|(
name|parent
argument_list|)
expr_stmt|;
comment|// create operator info list to return
return|return
name|putOpInsertMap
argument_list|(
name|unionforward
argument_list|,
name|unionoutRR
argument_list|)
return|;
block|}
comment|/**    * Generates the sampling predicate from the TABLESAMPLE clause information. This function uses the     * bucket column list to decide the expression inputs to the predicate hash function in case useBucketCols    * is set to true, otherwise the expression list stored in the TableSample is used. The bucket columns of     * the table are used to generate this predicate in case no expressions are provided on the TABLESAMPLE    * clause and the table has clustering columns defined in it's metadata.    * The predicate created has the following structure:    *     *     ((hash(expressions)& Integer.MAX_VALUE) % denominator) == numerator    *     * @param ts TABLESAMPLE clause information    * @param bucketCols The clustering columns of the table    * @param useBucketCols Flag to indicate whether the bucketCols should be used as input to the hash    *                      function    * @param alias The alias used for the table in the row resolver    * @param rwsch The row resolver used to resolve column references    * @param qbm The metadata information for the query block which is used to resolve unaliased columns    * @param planExpr The plan tree for the expression. If the user specified this, the parse expressions are not used    * @return exprNodeDesc    * @exception SemanticException    */
specifier|private
name|exprNodeDesc
name|genSamplePredicate
parameter_list|(
name|TableSample
name|ts
parameter_list|,
name|List
argument_list|<
name|String
argument_list|>
name|bucketCols
parameter_list|,
name|boolean
name|useBucketCols
parameter_list|,
name|String
name|alias
parameter_list|,
name|RowResolver
name|rwsch
parameter_list|,
name|QBMetaData
name|qbm
parameter_list|,
name|exprNodeDesc
name|planExpr
parameter_list|)
throws|throws
name|SemanticException
block|{
name|exprNodeDesc
name|numeratorExpr
init|=
operator|new
name|exprNodeConstantDesc
argument_list|(
name|TypeInfoFactory
operator|.
name|intTypeInfo
argument_list|,
name|Integer
operator|.
name|valueOf
argument_list|(
name|ts
operator|.
name|getNumerator
argument_list|()
operator|-
literal|1
argument_list|)
argument_list|)
decl_stmt|;
name|exprNodeDesc
name|denominatorExpr
init|=
operator|new
name|exprNodeConstantDesc
argument_list|(
name|TypeInfoFactory
operator|.
name|intTypeInfo
argument_list|,
name|Integer
operator|.
name|valueOf
argument_list|(
name|ts
operator|.
name|getDenominator
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
name|exprNodeDesc
name|intMaxExpr
init|=
operator|new
name|exprNodeConstantDesc
argument_list|(
name|TypeInfoFactory
operator|.
name|intTypeInfo
argument_list|,
name|Integer
operator|.
name|valueOf
argument_list|(
name|Integer
operator|.
name|MAX_VALUE
argument_list|)
argument_list|)
decl_stmt|;
name|ArrayList
argument_list|<
name|exprNodeDesc
argument_list|>
name|args
init|=
operator|new
name|ArrayList
argument_list|<
name|exprNodeDesc
argument_list|>
argument_list|()
decl_stmt|;
if|if
condition|(
name|planExpr
operator|!=
literal|null
condition|)
name|args
operator|.
name|add
argument_list|(
name|planExpr
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|useBucketCols
condition|)
block|{
for|for
control|(
name|String
name|col
range|:
name|bucketCols
control|)
block|{
name|ColumnInfo
name|ci
init|=
name|rwsch
operator|.
name|get
argument_list|(
name|alias
argument_list|,
name|col
argument_list|)
decl_stmt|;
comment|// TODO: change type to the one in the table schema
name|args
operator|.
name|add
argument_list|(
operator|new
name|exprNodeColumnDesc
argument_list|(
name|ci
operator|.
name|getType
argument_list|()
argument_list|,
name|ci
operator|.
name|getInternalName
argument_list|()
argument_list|,
name|ci
operator|.
name|getTabAlias
argument_list|()
argument_list|,
name|ci
operator|.
name|getIsPartitionCol
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
for|for
control|(
name|ASTNode
name|expr
range|:
name|ts
operator|.
name|getExprs
argument_list|()
control|)
block|{
name|args
operator|.
name|add
argument_list|(
name|genExprNodeDesc
argument_list|(
name|expr
argument_list|,
name|rwsch
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|exprNodeDesc
name|equalsExpr
init|=
literal|null
decl_stmt|;
block|{
name|exprNodeDesc
name|hashfnExpr
init|=
operator|new
name|exprNodeGenericFuncDesc
argument_list|(
name|TypeInfoFactory
operator|.
name|intTypeInfo
argument_list|,
operator|new
name|GenericUDFHash
argument_list|()
argument_list|,
name|args
argument_list|)
decl_stmt|;
assert|assert
operator|(
name|hashfnExpr
operator|!=
literal|null
operator|)
assert|;
name|LOG
operator|.
name|info
argument_list|(
literal|"hashfnExpr = "
operator|+
name|hashfnExpr
argument_list|)
expr_stmt|;
name|exprNodeDesc
name|andExpr
init|=
name|TypeCheckProcFactory
operator|.
name|DefaultExprProcessor
operator|.
name|getFuncExprNodeDesc
argument_list|(
literal|"&"
argument_list|,
name|hashfnExpr
argument_list|,
name|intMaxExpr
argument_list|)
decl_stmt|;
assert|assert
operator|(
name|andExpr
operator|!=
literal|null
operator|)
assert|;
name|LOG
operator|.
name|info
argument_list|(
literal|"andExpr = "
operator|+
name|andExpr
argument_list|)
expr_stmt|;
name|exprNodeDesc
name|modExpr
init|=
name|TypeCheckProcFactory
operator|.
name|DefaultExprProcessor
operator|.
name|getFuncExprNodeDesc
argument_list|(
literal|"%"
argument_list|,
name|andExpr
argument_list|,
name|denominatorExpr
argument_list|)
decl_stmt|;
assert|assert
operator|(
name|modExpr
operator|!=
literal|null
operator|)
assert|;
name|LOG
operator|.
name|info
argument_list|(
literal|"modExpr = "
operator|+
name|modExpr
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"numeratorExpr = "
operator|+
name|numeratorExpr
argument_list|)
expr_stmt|;
name|equalsExpr
operator|=
name|TypeCheckProcFactory
operator|.
name|DefaultExprProcessor
operator|.
name|getFuncExprNodeDesc
argument_list|(
literal|"=="
argument_list|,
name|modExpr
argument_list|,
name|numeratorExpr
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"equalsExpr = "
operator|+
name|equalsExpr
argument_list|)
expr_stmt|;
assert|assert
operator|(
name|equalsExpr
operator|!=
literal|null
operator|)
assert|;
block|}
return|return
name|equalsExpr
return|;
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"nls"
argument_list|)
specifier|private
name|Operator
name|genTablePlan
parameter_list|(
name|String
name|alias
parameter_list|,
name|QB
name|qb
parameter_list|)
throws|throws
name|SemanticException
block|{
name|String
name|alias_id
init|=
operator|(
name|qb
operator|.
name|getId
argument_list|()
operator|==
literal|null
condition|?
name|alias
else|:
name|qb
operator|.
name|getId
argument_list|()
operator|+
literal|":"
operator|+
name|alias
operator|)
decl_stmt|;
name|Table
name|tab
init|=
name|qb
operator|.
name|getMetaData
argument_list|()
operator|.
name|getSrcForAlias
argument_list|(
name|alias
argument_list|)
decl_stmt|;
name|RowResolver
name|rwsch
decl_stmt|;
comment|// is the table already present
name|Operator
argument_list|<
name|?
extends|extends
name|Serializable
argument_list|>
name|top
init|=
name|this
operator|.
name|topOps
operator|.
name|get
argument_list|(
name|alias_id
argument_list|)
decl_stmt|;
name|Operator
argument_list|<
name|?
extends|extends
name|Serializable
argument_list|>
name|dummySel
init|=
name|this
operator|.
name|topSelOps
operator|.
name|get
argument_list|(
name|alias_id
argument_list|)
decl_stmt|;
if|if
condition|(
name|dummySel
operator|!=
literal|null
condition|)
name|top
operator|=
name|dummySel
expr_stmt|;
if|if
condition|(
name|top
operator|==
literal|null
condition|)
block|{
name|rwsch
operator|=
operator|new
name|RowResolver
argument_list|()
expr_stmt|;
try|try
block|{
name|StructObjectInspector
name|rowObjectInspector
init|=
operator|(
name|StructObjectInspector
operator|)
name|tab
operator|.
name|getDeserializer
argument_list|()
operator|.
name|getObjectInspector
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|?
extends|extends
name|StructField
argument_list|>
name|fields
init|=
name|rowObjectInspector
operator|.
name|getAllStructFieldRefs
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|fields
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|rwsch
operator|.
name|put
argument_list|(
name|alias
argument_list|,
name|fields
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|getFieldName
argument_list|()
argument_list|,
operator|new
name|ColumnInfo
argument_list|(
name|fields
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|getFieldName
argument_list|()
argument_list|,
name|TypeInfoUtils
operator|.
name|getTypeInfoFromObjectInspector
argument_list|(
name|fields
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|getFieldObjectInspector
argument_list|()
argument_list|)
argument_list|,
name|alias
argument_list|,
literal|false
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|SerDeException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
name|e
argument_list|)
throw|;
block|}
comment|// Hack!! - refactor once the metadata APIs with types are ready
comment|// Finally add the partitioning columns
for|for
control|(
name|FieldSchema
name|part_col
range|:
name|tab
operator|.
name|getPartCols
argument_list|()
control|)
block|{
name|LOG
operator|.
name|trace
argument_list|(
literal|"Adding partition col: "
operator|+
name|part_col
argument_list|)
expr_stmt|;
comment|// TODO: use the right type by calling part_col.getType() instead of String.class
name|rwsch
operator|.
name|put
argument_list|(
name|alias
argument_list|,
name|part_col
operator|.
name|getName
argument_list|()
argument_list|,
operator|new
name|ColumnInfo
argument_list|(
name|part_col
operator|.
name|getName
argument_list|()
argument_list|,
name|TypeInfoFactory
operator|.
name|stringTypeInfo
argument_list|,
name|alias
argument_list|,
literal|true
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// Create the root of the operator tree
name|top
operator|=
name|putOpInsertMap
argument_list|(
name|OperatorFactory
operator|.
name|get
argument_list|(
operator|new
name|tableScanDesc
argument_list|(
name|alias
argument_list|)
argument_list|,
operator|new
name|RowSchema
argument_list|(
name|rwsch
operator|.
name|getColumnInfos
argument_list|()
argument_list|)
argument_list|)
argument_list|,
name|rwsch
argument_list|)
expr_stmt|;
comment|// Add this to the list of top operators - we always start from a table scan
name|this
operator|.
name|topOps
operator|.
name|put
argument_list|(
name|alias_id
argument_list|,
name|top
argument_list|)
expr_stmt|;
comment|// Add a mapping from the table scan operator to Table
name|this
operator|.
name|topToTable
operator|.
name|put
argument_list|(
operator|(
name|TableScanOperator
operator|)
name|top
argument_list|,
name|tab
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|rwsch
operator|=
name|opParseCtx
operator|.
name|get
argument_list|(
name|top
argument_list|)
operator|.
name|getRR
argument_list|()
expr_stmt|;
name|top
operator|.
name|setChildOperators
argument_list|(
literal|null
argument_list|)
expr_stmt|;
block|}
comment|// check if this table is sampled and needs more than input pruning
name|Operator
argument_list|<
name|?
extends|extends
name|Serializable
argument_list|>
name|tableOp
init|=
name|top
decl_stmt|;
name|TableSample
name|ts
init|=
name|qb
operator|.
name|getParseInfo
argument_list|()
operator|.
name|getTabSample
argument_list|(
name|alias
argument_list|)
decl_stmt|;
if|if
condition|(
name|ts
operator|!=
literal|null
condition|)
block|{
name|int
name|num
init|=
name|ts
operator|.
name|getNumerator
argument_list|()
decl_stmt|;
name|int
name|den
init|=
name|ts
operator|.
name|getDenominator
argument_list|()
decl_stmt|;
name|ArrayList
argument_list|<
name|ASTNode
argument_list|>
name|sampleExprs
init|=
name|ts
operator|.
name|getExprs
argument_list|()
decl_stmt|;
comment|// TODO: Do the type checking of the expressions
name|List
argument_list|<
name|String
argument_list|>
name|tabBucketCols
init|=
name|tab
operator|.
name|getBucketCols
argument_list|()
decl_stmt|;
name|int
name|numBuckets
init|=
name|tab
operator|.
name|getNumBuckets
argument_list|()
decl_stmt|;
comment|// If there are no sample cols and no bucket cols then throw an error
if|if
condition|(
name|tabBucketCols
operator|.
name|size
argument_list|()
operator|==
literal|0
operator|&&
name|sampleExprs
operator|.
name|size
argument_list|()
operator|==
literal|0
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|NON_BUCKETED_TABLE
operator|.
name|getMsg
argument_list|()
operator|+
literal|" "
operator|+
name|tab
operator|.
name|getName
argument_list|()
argument_list|)
throw|;
block|}
comment|// check if a predicate is needed
comment|// predicate is needed if either input pruning is not enough
comment|// or if input pruning is not possible
comment|// check if the sample columns are the same as the table bucket columns
name|boolean
name|colsEqual
init|=
literal|true
decl_stmt|;
if|if
condition|(
operator|(
name|sampleExprs
operator|.
name|size
argument_list|()
operator|!=
name|tabBucketCols
operator|.
name|size
argument_list|()
operator|)
operator|&&
operator|(
name|sampleExprs
operator|.
name|size
argument_list|()
operator|!=
literal|0
operator|)
condition|)
block|{
name|colsEqual
operator|=
literal|false
expr_stmt|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|sampleExprs
operator|.
name|size
argument_list|()
operator|&&
name|colsEqual
condition|;
name|i
operator|++
control|)
block|{
name|boolean
name|colFound
init|=
literal|false
decl_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|tabBucketCols
operator|.
name|size
argument_list|()
operator|&&
operator|!
name|colFound
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|sampleExprs
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|getToken
argument_list|()
operator|.
name|getType
argument_list|()
operator|!=
name|HiveParser
operator|.
name|TOK_TABLE_OR_COL
condition|)
block|{
break|break;
block|}
if|if
condition|(
operator|(
operator|(
name|ASTNode
operator|)
name|sampleExprs
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|)
operator|.
name|getText
argument_list|()
operator|.
name|equalsIgnoreCase
argument_list|(
name|tabBucketCols
operator|.
name|get
argument_list|(
name|j
argument_list|)
argument_list|)
condition|)
block|{
name|colFound
operator|=
literal|true
expr_stmt|;
block|}
block|}
name|colsEqual
operator|=
operator|(
name|colsEqual
operator|&&
name|colFound
operator|)
expr_stmt|;
block|}
comment|// Check if input can be pruned
name|ts
operator|.
name|setInputPruning
argument_list|(
operator|(
name|sampleExprs
operator|==
literal|null
operator|||
name|sampleExprs
operator|.
name|size
argument_list|()
operator|==
literal|0
operator|||
name|colsEqual
operator|)
argument_list|)
expr_stmt|;
comment|// check if input pruning is enough
if|if
condition|(
operator|(
name|sampleExprs
operator|==
literal|null
operator|||
name|sampleExprs
operator|.
name|size
argument_list|()
operator|==
literal|0
operator|||
name|colsEqual
operator|)
operator|&&
operator|(
name|num
operator|==
name|den
operator|||
name|den
operator|<=
name|numBuckets
operator|&&
name|numBuckets
operator|%
name|den
operator|==
literal|0
operator|)
condition|)
block|{
comment|// input pruning is enough; no need for filter
name|LOG
operator|.
name|info
argument_list|(
literal|"No need for sample filter"
argument_list|)
expr_stmt|;
comment|// TODO sample predicate is not needed, but we are adding it anyway since
comment|// input pruning is broken for subqueries. will remove this once we move
comment|// compilation of sampling to use the operator tree
name|exprNodeDesc
name|samplePredicate
init|=
name|genSamplePredicate
argument_list|(
name|ts
argument_list|,
name|tabBucketCols
argument_list|,
name|colsEqual
argument_list|,
name|alias
argument_list|,
name|rwsch
argument_list|,
name|qb
operator|.
name|getMetaData
argument_list|()
argument_list|,
literal|null
argument_list|)
decl_stmt|;
name|tableOp
operator|=
name|OperatorFactory
operator|.
name|getAndMakeChild
argument_list|(
operator|new
name|filterDesc
argument_list|(
name|samplePredicate
argument_list|,
literal|true
argument_list|)
argument_list|,
name|top
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// need to add filter
comment|// create tableOp to be filterDesc and set as child to 'top'
name|LOG
operator|.
name|info
argument_list|(
literal|"Need sample filter"
argument_list|)
expr_stmt|;
name|exprNodeDesc
name|samplePredicate
init|=
name|genSamplePredicate
argument_list|(
name|ts
argument_list|,
name|tabBucketCols
argument_list|,
name|colsEqual
argument_list|,
name|alias
argument_list|,
name|rwsch
argument_list|,
name|qb
operator|.
name|getMetaData
argument_list|()
argument_list|,
literal|null
argument_list|)
decl_stmt|;
name|tableOp
operator|=
name|OperatorFactory
operator|.
name|getAndMakeChild
argument_list|(
operator|new
name|filterDesc
argument_list|(
name|samplePredicate
argument_list|,
literal|true
argument_list|)
argument_list|,
name|top
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|boolean
name|testMode
init|=
name|conf
operator|.
name|getBoolVar
argument_list|(
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVETESTMODE
argument_list|)
decl_stmt|;
if|if
condition|(
name|testMode
condition|)
block|{
name|String
name|tabName
init|=
name|tab
operator|.
name|getName
argument_list|()
decl_stmt|;
comment|// has the user explicitly asked not to sample this table
name|String
name|unSampleTblList
init|=
name|conf
operator|.
name|getVar
argument_list|(
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVETESTMODENOSAMPLE
argument_list|)
decl_stmt|;
name|String
index|[]
name|unSampleTbls
init|=
name|unSampleTblList
operator|.
name|split
argument_list|(
literal|","
argument_list|)
decl_stmt|;
name|boolean
name|unsample
init|=
literal|false
decl_stmt|;
for|for
control|(
name|String
name|unSampleTbl
range|:
name|unSampleTbls
control|)
if|if
condition|(
name|tabName
operator|.
name|equalsIgnoreCase
argument_list|(
name|unSampleTbl
argument_list|)
condition|)
name|unsample
operator|=
literal|true
expr_stmt|;
if|if
condition|(
operator|!
name|unsample
condition|)
block|{
name|int
name|numBuckets
init|=
name|tab
operator|.
name|getNumBuckets
argument_list|()
decl_stmt|;
comment|// If the input table is bucketed, choose the first bucket
if|if
condition|(
name|numBuckets
operator|>
literal|0
condition|)
block|{
name|TableSample
name|tsSample
init|=
operator|new
name|TableSample
argument_list|(
literal|1
argument_list|,
name|numBuckets
argument_list|)
decl_stmt|;
name|tsSample
operator|.
name|setInputPruning
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|qb
operator|.
name|getParseInfo
argument_list|()
operator|.
name|setTabSample
argument_list|(
name|alias
argument_list|,
name|tsSample
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"No need for sample filter"
argument_list|)
expr_stmt|;
block|}
comment|// The table is not bucketed, add a dummy filter :: rand()
else|else
block|{
name|int
name|freq
init|=
name|conf
operator|.
name|getIntVar
argument_list|(
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVETESTMODESAMPLEFREQ
argument_list|)
decl_stmt|;
name|TableSample
name|tsSample
init|=
operator|new
name|TableSample
argument_list|(
literal|1
argument_list|,
name|freq
argument_list|)
decl_stmt|;
name|tsSample
operator|.
name|setInputPruning
argument_list|(
literal|false
argument_list|)
expr_stmt|;
name|qb
operator|.
name|getParseInfo
argument_list|()
operator|.
name|setTabSample
argument_list|(
name|alias
argument_list|,
name|tsSample
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Need sample filter"
argument_list|)
expr_stmt|;
name|exprNodeDesc
name|randFunc
init|=
name|TypeCheckProcFactory
operator|.
name|DefaultExprProcessor
operator|.
name|getFuncExprNodeDesc
argument_list|(
literal|"rand"
argument_list|,
operator|new
name|exprNodeConstantDesc
argument_list|(
name|Integer
operator|.
name|valueOf
argument_list|(
literal|460476415
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|exprNodeDesc
name|samplePred
init|=
name|genSamplePredicate
argument_list|(
name|tsSample
argument_list|,
literal|null
argument_list|,
literal|false
argument_list|,
name|alias
argument_list|,
name|rwsch
argument_list|,
name|qb
operator|.
name|getMetaData
argument_list|()
argument_list|,
name|randFunc
argument_list|)
decl_stmt|;
name|tableOp
operator|=
name|OperatorFactory
operator|.
name|getAndMakeChild
argument_list|(
operator|new
name|filterDesc
argument_list|(
name|samplePred
argument_list|,
literal|true
argument_list|)
argument_list|,
name|top
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
name|Operator
name|output
init|=
name|putOpInsertMap
argument_list|(
name|tableOp
argument_list|,
name|rwsch
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Created Table Plan for "
operator|+
name|alias
operator|+
literal|" "
operator|+
name|tableOp
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|output
return|;
block|}
specifier|private
name|Operator
name|genPlan
parameter_list|(
name|QBExpr
name|qbexpr
parameter_list|)
throws|throws
name|SemanticException
block|{
if|if
condition|(
name|qbexpr
operator|.
name|getOpcode
argument_list|()
operator|==
name|QBExpr
operator|.
name|Opcode
operator|.
name|NULLOP
condition|)
block|{
return|return
name|genPlan
argument_list|(
name|qbexpr
operator|.
name|getQB
argument_list|()
argument_list|)
return|;
block|}
if|if
condition|(
name|qbexpr
operator|.
name|getOpcode
argument_list|()
operator|==
name|QBExpr
operator|.
name|Opcode
operator|.
name|UNION
condition|)
block|{
name|Operator
name|qbexpr1Ops
init|=
name|genPlan
argument_list|(
name|qbexpr
operator|.
name|getQBExpr1
argument_list|()
argument_list|)
decl_stmt|;
name|Operator
name|qbexpr2Ops
init|=
name|genPlan
argument_list|(
name|qbexpr
operator|.
name|getQBExpr2
argument_list|()
argument_list|)
decl_stmt|;
return|return
name|genUnionPlan
argument_list|(
name|qbexpr
operator|.
name|getAlias
argument_list|()
argument_list|,
name|qbexpr
operator|.
name|getQBExpr1
argument_list|()
operator|.
name|getAlias
argument_list|()
argument_list|,
name|qbexpr1Ops
argument_list|,
name|qbexpr
operator|.
name|getQBExpr2
argument_list|()
operator|.
name|getAlias
argument_list|()
argument_list|,
name|qbexpr2Ops
argument_list|)
return|;
block|}
return|return
literal|null
return|;
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"nls"
argument_list|)
specifier|public
name|Operator
name|genPlan
parameter_list|(
name|QB
name|qb
parameter_list|)
throws|throws
name|SemanticException
block|{
comment|// First generate all the opInfos for the elements in the from clause
name|HashMap
argument_list|<
name|String
argument_list|,
name|Operator
argument_list|>
name|aliasToOpInfo
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|Operator
argument_list|>
argument_list|()
decl_stmt|;
comment|// Recurse over the subqueries to fill the subquery part of the plan
for|for
control|(
name|String
name|alias
range|:
name|qb
operator|.
name|getSubqAliases
argument_list|()
control|)
block|{
name|QBExpr
name|qbexpr
init|=
name|qb
operator|.
name|getSubqForAlias
argument_list|(
name|alias
argument_list|)
decl_stmt|;
name|aliasToOpInfo
operator|.
name|put
argument_list|(
name|alias
argument_list|,
name|genPlan
argument_list|(
name|qbexpr
argument_list|)
argument_list|)
expr_stmt|;
name|qbexpr
operator|.
name|setAlias
argument_list|(
name|alias
argument_list|)
expr_stmt|;
block|}
comment|// Recurse over all the source tables
for|for
control|(
name|String
name|alias
range|:
name|qb
operator|.
name|getTabAliases
argument_list|()
control|)
block|{
name|aliasToOpInfo
operator|.
name|put
argument_list|(
name|alias
argument_list|,
name|genTablePlan
argument_list|(
name|alias
argument_list|,
name|qb
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|Operator
name|srcOpInfo
init|=
literal|null
decl_stmt|;
comment|// process join
if|if
condition|(
name|qb
operator|.
name|getParseInfo
argument_list|()
operator|.
name|getJoinExpr
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|ASTNode
name|joinExpr
init|=
name|qb
operator|.
name|getParseInfo
argument_list|()
operator|.
name|getJoinExpr
argument_list|()
decl_stmt|;
name|QBJoinTree
name|joinTree
init|=
name|genJoinTree
argument_list|(
name|qb
argument_list|,
name|joinExpr
argument_list|)
decl_stmt|;
name|qb
operator|.
name|setQbJoinTree
argument_list|(
name|joinTree
argument_list|)
expr_stmt|;
name|mergeJoinTree
argument_list|(
name|qb
argument_list|)
expr_stmt|;
comment|// if any filters are present in the join tree, push them on top of the table
name|pushJoinFilters
argument_list|(
name|qb
argument_list|,
name|qb
operator|.
name|getQbJoinTree
argument_list|()
argument_list|,
name|aliasToOpInfo
argument_list|)
expr_stmt|;
name|srcOpInfo
operator|=
name|genJoinPlan
argument_list|(
name|qb
argument_list|,
name|aliasToOpInfo
argument_list|)
expr_stmt|;
block|}
else|else
comment|// Now if there are more than 1 sources then we have a join case
comment|// later we can extend this to the union all case as well
name|srcOpInfo
operator|=
name|aliasToOpInfo
operator|.
name|values
argument_list|()
operator|.
name|iterator
argument_list|()
operator|.
name|next
argument_list|()
expr_stmt|;
name|Operator
name|bodyOpInfo
init|=
name|genBodyPlan
argument_list|(
name|qb
argument_list|,
name|srcOpInfo
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Created Plan for Query Block "
operator|+
name|qb
operator|.
name|getId
argument_list|()
argument_list|)
expr_stmt|;
name|this
operator|.
name|qb
operator|=
name|qb
expr_stmt|;
return|return
name|bodyOpInfo
return|;
block|}
specifier|private
name|Operator
argument_list|<
name|?
extends|extends
name|Serializable
argument_list|>
name|getReduceSink
parameter_list|(
name|Operator
argument_list|<
name|?
extends|extends
name|Serializable
argument_list|>
name|top
parameter_list|)
block|{
if|if
condition|(
name|top
operator|.
name|getClass
argument_list|()
operator|==
name|ReduceSinkOperator
operator|.
name|class
condition|)
block|{
comment|// Get the operator following the reduce sink
assert|assert
operator|(
name|top
operator|.
name|getChildOperators
argument_list|()
operator|.
name|size
argument_list|()
operator|==
literal|1
operator|)
assert|;
return|return
name|top
return|;
block|}
name|List
argument_list|<
name|Operator
argument_list|<
name|?
extends|extends
name|Serializable
argument_list|>
argument_list|>
name|childOps
init|=
name|top
operator|.
name|getChildOperators
argument_list|()
decl_stmt|;
if|if
condition|(
name|childOps
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|childOps
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|Operator
argument_list|<
name|?
extends|extends
name|Serializable
argument_list|>
name|reducer
init|=
name|getReduceSink
argument_list|(
name|childOps
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|reducer
operator|!=
literal|null
condition|)
block|{
return|return
name|reducer
return|;
block|}
block|}
return|return
literal|null
return|;
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"nls"
argument_list|)
specifier|private
name|void
name|genMapRedTasks
parameter_list|(
name|QB
name|qb
parameter_list|)
throws|throws
name|SemanticException
block|{
name|fetchWork
name|fetch
init|=
literal|null
decl_stmt|;
name|List
argument_list|<
name|Task
argument_list|<
name|?
extends|extends
name|Serializable
argument_list|>
argument_list|>
name|mvTask
init|=
operator|new
name|ArrayList
argument_list|<
name|Task
argument_list|<
name|?
extends|extends
name|Serializable
argument_list|>
argument_list|>
argument_list|()
decl_stmt|;
name|Task
argument_list|<
name|?
extends|extends
name|Serializable
argument_list|>
name|fetchTask
init|=
literal|null
decl_stmt|;
name|QBParseInfo
name|qbParseInfo
init|=
name|qb
operator|.
name|getParseInfo
argument_list|()
decl_stmt|;
if|if
condition|(
name|qb
operator|.
name|isSelectStarQuery
argument_list|()
operator|&&
name|qbParseInfo
operator|.
name|getDestToClusterBy
argument_list|()
operator|.
name|isEmpty
argument_list|()
operator|&&
name|qbParseInfo
operator|.
name|getDestToDistributeBy
argument_list|()
operator|.
name|isEmpty
argument_list|()
operator|&&
name|qbParseInfo
operator|.
name|getDestToOrderBy
argument_list|()
operator|.
name|isEmpty
argument_list|()
operator|&&
name|qbParseInfo
operator|.
name|getDestToSortBy
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|Iterator
argument_list|<
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|Table
argument_list|>
argument_list|>
name|iter
init|=
name|qb
operator|.
name|getMetaData
argument_list|()
operator|.
name|getAliasToTable
argument_list|()
operator|.
name|entrySet
argument_list|()
operator|.
name|iterator
argument_list|()
decl_stmt|;
name|Table
name|tab
init|=
operator|(
operator|(
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|Table
argument_list|>
operator|)
name|iter
operator|.
name|next
argument_list|()
operator|)
operator|.
name|getValue
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|tab
operator|.
name|isPartitioned
argument_list|()
condition|)
block|{
if|if
condition|(
name|qbParseInfo
operator|.
name|getDestToWhereExpr
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
name|fetch
operator|=
operator|new
name|fetchWork
argument_list|(
name|tab
operator|.
name|getPath
argument_list|()
operator|.
name|toString
argument_list|()
argument_list|,
name|Utilities
operator|.
name|getTableDesc
argument_list|(
name|tab
argument_list|)
argument_list|,
name|qb
operator|.
name|getParseInfo
argument_list|()
operator|.
name|getOuterQueryLimit
argument_list|()
argument_list|)
expr_stmt|;
name|inputs
operator|.
name|add
argument_list|(
operator|new
name|ReadEntity
argument_list|(
name|tab
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|aliasToPruner
operator|.
name|size
argument_list|()
operator|==
literal|1
condition|)
block|{
name|Iterator
argument_list|<
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|parse
operator|.
name|ASTPartitionPruner
argument_list|>
argument_list|>
name|iterP
init|=
name|aliasToPruner
operator|.
name|entrySet
argument_list|()
operator|.
name|iterator
argument_list|()
decl_stmt|;
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|parse
operator|.
name|ASTPartitionPruner
name|pr
init|=
operator|(
operator|(
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|parse
operator|.
name|ASTPartitionPruner
argument_list|>
operator|)
name|iterP
operator|.
name|next
argument_list|()
operator|)
operator|.
name|getValue
argument_list|()
decl_stmt|;
if|if
condition|(
name|pr
operator|.
name|onlyContainsPartitionCols
argument_list|()
condition|)
block|{
name|List
argument_list|<
name|String
argument_list|>
name|listP
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|partitionDesc
argument_list|>
name|partP
init|=
operator|new
name|ArrayList
argument_list|<
name|partitionDesc
argument_list|>
argument_list|()
decl_stmt|;
name|PrunedPartitionList
name|partsList
init|=
literal|null
decl_stmt|;
name|Set
argument_list|<
name|Partition
argument_list|>
name|parts
init|=
literal|null
decl_stmt|;
try|try
block|{
name|partsList
operator|=
name|pr
operator|.
name|prune
argument_list|()
expr_stmt|;
comment|// If there is any unknown partition, create a map-reduce job for the filter to prune correctly
if|if
condition|(
name|partsList
operator|.
name|getUnknownPartns
argument_list|()
operator|.
name|size
argument_list|()
operator|==
literal|0
condition|)
block|{
name|parts
operator|=
name|partsList
operator|.
name|getConfirmedPartns
argument_list|()
expr_stmt|;
name|Iterator
argument_list|<
name|Partition
argument_list|>
name|iterParts
init|=
name|parts
operator|.
name|iterator
argument_list|()
decl_stmt|;
while|while
condition|(
name|iterParts
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|Partition
name|part
init|=
name|iterParts
operator|.
name|next
argument_list|()
decl_stmt|;
name|listP
operator|.
name|add
argument_list|(
name|part
operator|.
name|getPartitionPath
argument_list|()
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|partP
operator|.
name|add
argument_list|(
name|Utilities
operator|.
name|getPartitionDesc
argument_list|(
name|part
argument_list|)
argument_list|)
expr_stmt|;
name|inputs
operator|.
name|add
argument_list|(
operator|new
name|ReadEntity
argument_list|(
name|part
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|fetch
operator|=
operator|new
name|fetchWork
argument_list|(
name|listP
argument_list|,
name|partP
argument_list|,
name|qb
operator|.
name|getParseInfo
argument_list|()
operator|.
name|getOuterQueryLimit
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|HiveException
name|e
parameter_list|)
block|{
comment|// Has to use full name to make sure it does not conflict with org.apache.commons.lang.StringUtils
name|LOG
operator|.
name|error
argument_list|(
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|StringUtils
operator|.
name|stringifyException
argument_list|(
name|e
argument_list|)
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|SemanticException
argument_list|(
name|e
operator|.
name|getMessage
argument_list|()
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
block|}
block|}
if|if
condition|(
name|fetch
operator|!=
literal|null
condition|)
block|{
name|fetchTask
operator|=
name|TaskFactory
operator|.
name|get
argument_list|(
name|fetch
argument_list|,
name|this
operator|.
name|conf
argument_list|)
expr_stmt|;
name|setFetchTask
argument_list|(
name|fetchTask
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
comment|// In case of a select, use a fetch task instead of a move task
if|if
condition|(
name|qb
operator|.
name|getIsQuery
argument_list|()
condition|)
block|{
if|if
condition|(
operator|(
operator|!
name|loadTableWork
operator|.
name|isEmpty
argument_list|()
operator|)
operator|||
operator|(
name|loadFileWork
operator|.
name|size
argument_list|()
operator|!=
literal|1
operator|)
condition|)
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|GENERIC_ERROR
operator|.
name|getMsg
argument_list|()
argument_list|)
throw|;
name|String
name|cols
init|=
name|loadFileWork
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|getColumns
argument_list|()
decl_stmt|;
name|String
name|colTypes
init|=
name|loadFileWork
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|getColumnTypes
argument_list|()
decl_stmt|;
name|fetch
operator|=
operator|new
name|fetchWork
argument_list|(
operator|new
name|Path
argument_list|(
name|loadFileWork
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|getSourceDir
argument_list|()
argument_list|)
operator|.
name|toString
argument_list|()
argument_list|,
operator|new
name|tableDesc
argument_list|(
name|LazySimpleSerDe
operator|.
name|class
argument_list|,
name|TextInputFormat
operator|.
name|class
argument_list|,
name|IgnoreKeyTextOutputFormat
operator|.
name|class
argument_list|,
name|Utilities
operator|.
name|makeProperties
argument_list|(
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde
operator|.
name|Constants
operator|.
name|SERIALIZATION_FORMAT
argument_list|,
literal|""
operator|+
name|Utilities
operator|.
name|ctrlaCode
argument_list|,
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde
operator|.
name|Constants
operator|.
name|LIST_COLUMNS
argument_list|,
name|cols
argument_list|,
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde
operator|.
name|Constants
operator|.
name|LIST_COLUMN_TYPES
argument_list|,
name|colTypes
argument_list|)
argument_list|)
argument_list|,
name|qb
operator|.
name|getParseInfo
argument_list|()
operator|.
name|getOuterQueryLimit
argument_list|()
argument_list|)
expr_stmt|;
name|fetchTask
operator|=
name|TaskFactory
operator|.
name|get
argument_list|(
name|fetch
argument_list|,
name|this
operator|.
name|conf
argument_list|)
expr_stmt|;
name|setFetchTask
argument_list|(
name|fetchTask
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// First we generate the move work as this needs to be made dependent on all
comment|// the tasks that have a file sink operation
name|List
argument_list|<
name|moveWork
argument_list|>
name|mv
init|=
operator|new
name|ArrayList
argument_list|<
name|moveWork
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|loadTableDesc
name|ltd
range|:
name|loadTableWork
control|)
name|mvTask
operator|.
name|add
argument_list|(
name|TaskFactory
operator|.
name|get
argument_list|(
operator|new
name|moveWork
argument_list|(
name|ltd
argument_list|,
literal|null
argument_list|,
literal|false
argument_list|)
argument_list|,
name|this
operator|.
name|conf
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|loadFileDesc
name|lfd
range|:
name|loadFileWork
control|)
name|mvTask
operator|.
name|add
argument_list|(
name|TaskFactory
operator|.
name|get
argument_list|(
operator|new
name|moveWork
argument_list|(
literal|null
argument_list|,
name|lfd
argument_list|,
literal|false
argument_list|)
argument_list|,
name|this
operator|.
name|conf
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// generate map reduce plans
name|GenMRProcContext
name|procCtx
init|=
operator|new
name|GenMRProcContext
argument_list|(
name|conf
argument_list|,
operator|new
name|HashMap
argument_list|<
name|Operator
argument_list|<
name|?
extends|extends
name|Serializable
argument_list|>
argument_list|,
name|Task
argument_list|<
name|?
extends|extends
name|Serializable
argument_list|>
argument_list|>
argument_list|()
condition|,
operator|new
name|ArrayList
argument_list|<
name|Operator
argument_list|<
name|?
extends|extends
name|Serializable
argument_list|>
argument_list|>
argument_list|()
condition|,
name|getParseContext
argument_list|()
condition|,
name|mvTask
condition|,
name|this
operator|.
name|rootTasks
condition|,
operator|new
name|LinkedHashMap
argument_list|<
name|Operator
argument_list|<
name|?
extends|extends
name|Serializable
argument_list|>
argument_list|,
name|GenMapRedCtx
argument_list|>
argument_list|()
condition|,
name|inputs
condition|,
name|outputs
argument_list|)
decl_stmt|;
comment|// create a walker which walks the tree in a DFS manner while maintaining the operator stack.
comment|// The dispatcher generates the plan from the operator tree
name|Map
argument_list|<
name|Rule
argument_list|,
name|NodeProcessor
argument_list|>
name|opRules
init|=
operator|new
name|LinkedHashMap
argument_list|<
name|Rule
argument_list|,
name|NodeProcessor
argument_list|>
argument_list|()
decl_stmt|;
name|opRules
operator|.
name|put
argument_list|(
operator|new
name|RuleRegExp
argument_list|(
operator|new
name|String
argument_list|(
literal|"R1"
argument_list|)
argument_list|,
literal|"TS%"
argument_list|)
argument_list|,
operator|new
name|GenMRTableScan1
argument_list|()
argument_list|)
expr_stmt|;
name|opRules
operator|.
name|put
argument_list|(
operator|new
name|RuleRegExp
argument_list|(
operator|new
name|String
argument_list|(
literal|"R2"
argument_list|)
argument_list|,
literal|"TS%.*RS%"
argument_list|)
argument_list|,
operator|new
name|GenMRRedSink1
argument_list|()
argument_list|)
expr_stmt|;
name|opRules
operator|.
name|put
argument_list|(
operator|new
name|RuleRegExp
argument_list|(
operator|new
name|String
argument_list|(
literal|"R3"
argument_list|)
argument_list|,
literal|"RS%.*RS%"
argument_list|)
argument_list|,
operator|new
name|GenMRRedSink2
argument_list|()
argument_list|)
expr_stmt|;
name|opRules
operator|.
name|put
argument_list|(
operator|new
name|RuleRegExp
argument_list|(
operator|new
name|String
argument_list|(
literal|"R4"
argument_list|)
argument_list|,
literal|"FS%"
argument_list|)
argument_list|,
operator|new
name|GenMRFileSink1
argument_list|()
argument_list|)
expr_stmt|;
name|opRules
operator|.
name|put
argument_list|(
operator|new
name|RuleRegExp
argument_list|(
operator|new
name|String
argument_list|(
literal|"R5"
argument_list|)
argument_list|,
literal|"UNION%"
argument_list|)
argument_list|,
operator|new
name|GenMRUnion1
argument_list|()
argument_list|)
expr_stmt|;
name|opRules
operator|.
name|put
argument_list|(
operator|new
name|RuleRegExp
argument_list|(
operator|new
name|String
argument_list|(
literal|"R6"
argument_list|)
argument_list|,
literal|"UNION%.*RS%"
argument_list|)
argument_list|,
operator|new
name|GenMRRedSink3
argument_list|()
argument_list|)
expr_stmt|;
name|opRules
operator|.
name|put
argument_list|(
operator|new
name|RuleRegExp
argument_list|(
operator|new
name|String
argument_list|(
literal|"R6"
argument_list|)
argument_list|,
literal|"MAPJOIN%.*RS%"
argument_list|)
argument_list|,
operator|new
name|GenMRRedSink4
argument_list|()
argument_list|)
expr_stmt|;
name|opRules
operator|.
name|put
argument_list|(
operator|new
name|RuleRegExp
argument_list|(
operator|new
name|String
argument_list|(
literal|"R7"
argument_list|)
argument_list|,
literal|"TS%.*MAPJOIN%"
argument_list|)
argument_list|,
name|MapJoinFactory
operator|.
name|getTableScanMapJoin
argument_list|()
argument_list|)
expr_stmt|;
name|opRules
operator|.
name|put
argument_list|(
operator|new
name|RuleRegExp
argument_list|(
operator|new
name|String
argument_list|(
literal|"R8"
argument_list|)
argument_list|,
literal|"RS%.*MAPJOIN%"
argument_list|)
argument_list|,
name|MapJoinFactory
operator|.
name|getReduceSinkMapJoin
argument_list|()
argument_list|)
expr_stmt|;
name|opRules
operator|.
name|put
argument_list|(
operator|new
name|RuleRegExp
argument_list|(
operator|new
name|String
argument_list|(
literal|"R9"
argument_list|)
argument_list|,
literal|"UNION%.*MAPJOIN%"
argument_list|)
argument_list|,
name|MapJoinFactory
operator|.
name|getUnionMapJoin
argument_list|()
argument_list|)
expr_stmt|;
name|opRules
operator|.
name|put
argument_list|(
operator|new
name|RuleRegExp
argument_list|(
operator|new
name|String
argument_list|(
literal|"R10"
argument_list|)
argument_list|,
literal|"MAPJOIN%.*MAPJOIN%"
argument_list|)
argument_list|,
name|MapJoinFactory
operator|.
name|getMapJoinMapJoin
argument_list|()
argument_list|)
expr_stmt|;
name|opRules
operator|.
name|put
argument_list|(
operator|new
name|RuleRegExp
argument_list|(
operator|new
name|String
argument_list|(
literal|"R11"
argument_list|)
argument_list|,
literal|"MAPJOIN%SEL%"
argument_list|)
argument_list|,
name|MapJoinFactory
operator|.
name|getMapJoin
argument_list|()
argument_list|)
expr_stmt|;
comment|// The dispatcher fires the processor corresponding to the closest matching rule and passes the context along
name|Dispatcher
name|disp
init|=
operator|new
name|DefaultRuleDispatcher
argument_list|(
operator|new
name|GenMROperator
argument_list|()
argument_list|,
name|opRules
argument_list|,
name|procCtx
argument_list|)
decl_stmt|;
name|GraphWalker
name|ogw
init|=
operator|new
name|GenMapRedWalker
argument_list|(
name|disp
argument_list|)
decl_stmt|;
name|ArrayList
argument_list|<
name|Node
argument_list|>
name|topNodes
init|=
operator|new
name|ArrayList
argument_list|<
name|Node
argument_list|>
argument_list|()
decl_stmt|;
name|topNodes
operator|.
name|addAll
argument_list|(
name|this
operator|.
name|topOps
operator|.
name|values
argument_list|()
argument_list|)
expr_stmt|;
name|ogw
operator|.
name|startWalking
argument_list|(
name|topNodes
argument_list|,
literal|null
argument_list|)
expr_stmt|;
comment|// reduce sink does not have any kids - since the plan by now has been broken up into multiple
comment|// tasks, iterate over all tasks.
comment|// For each task, go over all operators recursively
for|for
control|(
name|Task
argument_list|<
name|?
extends|extends
name|Serializable
argument_list|>
name|rootTask
range|:
name|rootTasks
control|)
name|breakTaskTree
argument_list|(
name|rootTask
argument_list|)
expr_stmt|;
comment|// For each task, set the key descriptor for the reducer
for|for
control|(
name|Task
argument_list|<
name|?
extends|extends
name|Serializable
argument_list|>
name|rootTask
range|:
name|rootTasks
control|)
name|setKeyDescTaskTree
argument_list|(
name|rootTask
argument_list|)
expr_stmt|;
comment|// For each operator, generate the counters if needed
if|if
condition|(
name|HiveConf
operator|.
name|getBoolVar
argument_list|(
name|conf
argument_list|,
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVEJOBPROGRESS
argument_list|)
condition|)
for|for
control|(
name|Task
argument_list|<
name|?
extends|extends
name|Serializable
argument_list|>
name|rootTask
range|:
name|rootTasks
control|)
name|generateCountersTask
argument_list|(
name|rootTask
argument_list|)
expr_stmt|;
block|}
comment|// loop over all the tasks recursviely
specifier|private
name|void
name|generateCountersTask
parameter_list|(
name|Task
argument_list|<
name|?
extends|extends
name|Serializable
argument_list|>
name|task
parameter_list|)
block|{
if|if
condition|(
operator|(
name|task
operator|instanceof
name|MapRedTask
operator|)
operator|||
operator|(
name|task
operator|instanceof
name|ExecDriver
operator|)
condition|)
block|{
name|HashMap
argument_list|<
name|String
argument_list|,
name|Operator
argument_list|<
name|?
extends|extends
name|Serializable
argument_list|>
argument_list|>
name|opMap
init|=
operator|(
operator|(
name|mapredWork
operator|)
name|task
operator|.
name|getWork
argument_list|()
operator|)
operator|.
name|getAliasToWork
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|opMap
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
for|for
control|(
name|Operator
argument_list|<
name|?
extends|extends
name|Serializable
argument_list|>
name|op
range|:
name|opMap
operator|.
name|values
argument_list|()
control|)
block|{
name|generateCountersOperator
argument_list|(
name|op
argument_list|)
expr_stmt|;
block|}
block|}
name|Operator
argument_list|<
name|?
extends|extends
name|Serializable
argument_list|>
name|reducer
init|=
operator|(
operator|(
name|mapredWork
operator|)
name|task
operator|.
name|getWork
argument_list|()
operator|)
operator|.
name|getReducer
argument_list|()
decl_stmt|;
if|if
condition|(
name|reducer
operator|!=
literal|null
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Generating counters for operator "
operator|+
name|reducer
argument_list|)
expr_stmt|;
name|generateCountersOperator
argument_list|(
name|reducer
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|task
operator|instanceof
name|ConditionalTask
condition|)
block|{
name|List
argument_list|<
name|Task
argument_list|<
name|?
extends|extends
name|Serializable
argument_list|>
argument_list|>
name|listTasks
init|=
operator|(
operator|(
name|ConditionalTask
operator|)
name|task
operator|)
operator|.
name|getListTasks
argument_list|()
decl_stmt|;
for|for
control|(
name|Task
argument_list|<
name|?
extends|extends
name|Serializable
argument_list|>
name|tsk
range|:
name|listTasks
control|)
name|generateCountersTask
argument_list|(
name|tsk
argument_list|)
expr_stmt|;
block|}
comment|// Start the counters from scratch - a hack for hadoop 17.
name|Operator
operator|.
name|resetLastEnumUsed
argument_list|()
expr_stmt|;
if|if
condition|(
name|task
operator|.
name|getChildTasks
argument_list|()
operator|==
literal|null
condition|)
return|return;
for|for
control|(
name|Task
argument_list|<
name|?
extends|extends
name|Serializable
argument_list|>
name|childTask
range|:
name|task
operator|.
name|getChildTasks
argument_list|()
control|)
name|generateCountersTask
argument_list|(
name|childTask
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|generateCountersOperator
parameter_list|(
name|Operator
argument_list|<
name|?
extends|extends
name|Serializable
argument_list|>
name|op
parameter_list|)
block|{
name|op
operator|.
name|assignCounterNameToEnum
argument_list|()
expr_stmt|;
if|if
condition|(
name|op
operator|.
name|getChildOperators
argument_list|()
operator|==
literal|null
condition|)
return|return;
for|for
control|(
name|Operator
argument_list|<
name|?
extends|extends
name|Serializable
argument_list|>
name|child
range|:
name|op
operator|.
name|getChildOperators
argument_list|()
control|)
name|generateCountersOperator
argument_list|(
name|child
argument_list|)
expr_stmt|;
block|}
comment|// loop over all the tasks recursviely
specifier|private
name|void
name|breakTaskTree
parameter_list|(
name|Task
argument_list|<
name|?
extends|extends
name|Serializable
argument_list|>
name|task
parameter_list|)
block|{
if|if
condition|(
operator|(
name|task
operator|instanceof
name|MapRedTask
operator|)
operator|||
operator|(
name|task
operator|instanceof
name|ExecDriver
operator|)
condition|)
block|{
name|HashMap
argument_list|<
name|String
argument_list|,
name|Operator
argument_list|<
name|?
extends|extends
name|Serializable
argument_list|>
argument_list|>
name|opMap
init|=
operator|(
operator|(
name|mapredWork
operator|)
name|task
operator|.
name|getWork
argument_list|()
operator|)
operator|.
name|getAliasToWork
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|opMap
operator|.
name|isEmpty
argument_list|()
condition|)
for|for
control|(
name|Operator
argument_list|<
name|?
extends|extends
name|Serializable
argument_list|>
name|op
range|:
name|opMap
operator|.
name|values
argument_list|()
control|)
block|{
name|breakOperatorTree
argument_list|(
name|op
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|task
operator|instanceof
name|ConditionalTask
condition|)
block|{
name|List
argument_list|<
name|Task
argument_list|<
name|?
extends|extends
name|Serializable
argument_list|>
argument_list|>
name|listTasks
init|=
operator|(
operator|(
name|ConditionalTask
operator|)
name|task
operator|)
operator|.
name|getListTasks
argument_list|()
decl_stmt|;
for|for
control|(
name|Task
argument_list|<
name|?
extends|extends
name|Serializable
argument_list|>
name|tsk
range|:
name|listTasks
control|)
name|breakTaskTree
argument_list|(
name|tsk
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|task
operator|.
name|getChildTasks
argument_list|()
operator|==
literal|null
condition|)
return|return;
for|for
control|(
name|Task
argument_list|<
name|?
extends|extends
name|Serializable
argument_list|>
name|childTask
range|:
name|task
operator|.
name|getChildTasks
argument_list|()
control|)
name|breakTaskTree
argument_list|(
name|childTask
argument_list|)
expr_stmt|;
block|}
comment|// loop over all the operators recursviely
specifier|private
name|void
name|breakOperatorTree
parameter_list|(
name|Operator
argument_list|<
name|?
extends|extends
name|Serializable
argument_list|>
name|topOp
parameter_list|)
block|{
if|if
condition|(
name|topOp
operator|instanceof
name|ReduceSinkOperator
condition|)
name|topOp
operator|.
name|setChildOperators
argument_list|(
literal|null
argument_list|)
expr_stmt|;
if|if
condition|(
name|topOp
operator|.
name|getChildOperators
argument_list|()
operator|==
literal|null
condition|)
return|return;
for|for
control|(
name|Operator
argument_list|<
name|?
extends|extends
name|Serializable
argument_list|>
name|op
range|:
name|topOp
operator|.
name|getChildOperators
argument_list|()
control|)
name|breakOperatorTree
argument_list|(
name|op
argument_list|)
expr_stmt|;
block|}
comment|// loop over all the tasks recursviely
specifier|private
name|void
name|setKeyDescTaskTree
parameter_list|(
name|Task
argument_list|<
name|?
extends|extends
name|Serializable
argument_list|>
name|task
parameter_list|)
block|{
if|if
condition|(
operator|(
name|task
operator|instanceof
name|MapRedTask
operator|)
operator|||
operator|(
name|task
operator|instanceof
name|ExecDriver
operator|)
condition|)
block|{
name|mapredWork
name|work
init|=
operator|(
name|mapredWork
operator|)
name|task
operator|.
name|getWork
argument_list|()
decl_stmt|;
name|HashMap
argument_list|<
name|String
argument_list|,
name|Operator
argument_list|<
name|?
extends|extends
name|Serializable
argument_list|>
argument_list|>
name|opMap
init|=
name|work
operator|.
name|getAliasToWork
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|opMap
operator|.
name|isEmpty
argument_list|()
condition|)
for|for
control|(
name|Operator
argument_list|<
name|?
extends|extends
name|Serializable
argument_list|>
name|op
range|:
name|opMap
operator|.
name|values
argument_list|()
control|)
name|GenMapRedUtils
operator|.
name|setKeyAndValueDesc
argument_list|(
name|work
argument_list|,
name|op
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|task
operator|instanceof
name|ConditionalTask
condition|)
block|{
name|List
argument_list|<
name|Task
argument_list|<
name|?
extends|extends
name|Serializable
argument_list|>
argument_list|>
name|listTasks
init|=
operator|(
operator|(
name|ConditionalTask
operator|)
name|task
operator|)
operator|.
name|getListTasks
argument_list|()
decl_stmt|;
for|for
control|(
name|Task
argument_list|<
name|?
extends|extends
name|Serializable
argument_list|>
name|tsk
range|:
name|listTasks
control|)
name|setKeyDescTaskTree
argument_list|(
name|tsk
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|task
operator|.
name|getChildTasks
argument_list|()
operator|==
literal|null
condition|)
return|return;
for|for
control|(
name|Task
argument_list|<
name|?
extends|extends
name|Serializable
argument_list|>
name|childTask
range|:
name|task
operator|.
name|getChildTasks
argument_list|()
control|)
name|setKeyDescTaskTree
argument_list|(
name|childTask
argument_list|)
expr_stmt|;
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"nls"
argument_list|)
specifier|public
name|Phase1Ctx
name|initPhase1Ctx
parameter_list|()
block|{
name|Phase1Ctx
name|ctx_1
init|=
operator|new
name|Phase1Ctx
argument_list|()
decl_stmt|;
name|ctx_1
operator|.
name|nextNum
operator|=
literal|0
expr_stmt|;
name|ctx_1
operator|.
name|dest
operator|=
literal|"reduce"
expr_stmt|;
return|return
name|ctx_1
return|;
block|}
annotation|@
name|Override
annotation|@
name|SuppressWarnings
argument_list|(
literal|"nls"
argument_list|)
specifier|public
name|void
name|analyzeInternal
parameter_list|(
name|ASTNode
name|ast
parameter_list|)
throws|throws
name|SemanticException
block|{
name|reset
argument_list|()
expr_stmt|;
name|QB
name|qb
init|=
operator|new
name|QB
argument_list|(
literal|null
argument_list|,
literal|null
argument_list|,
literal|false
argument_list|)
decl_stmt|;
name|this
operator|.
name|qb
operator|=
name|qb
expr_stmt|;
name|this
operator|.
name|ast
operator|=
name|ast
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Starting Semantic Analysis"
argument_list|)
expr_stmt|;
name|doPhase1
argument_list|(
name|ast
argument_list|,
name|qb
argument_list|,
name|initPhase1Ctx
argument_list|()
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Completed phase 1 of Semantic Analysis"
argument_list|)
expr_stmt|;
name|getMetaData
argument_list|(
name|qb
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Completed getting MetaData in Semantic Analysis"
argument_list|)
expr_stmt|;
name|genPlan
argument_list|(
name|qb
argument_list|)
expr_stmt|;
name|ParseContext
name|pCtx
init|=
operator|new
name|ParseContext
argument_list|(
name|conf
argument_list|,
name|qb
argument_list|,
name|ast
argument_list|,
name|aliasToPruner
argument_list|,
name|opToPartPruner
argument_list|,
name|aliasToSamplePruner
argument_list|,
name|topOps
argument_list|,
name|topSelOps
argument_list|,
name|opParseCtx
argument_list|,
name|joinContext
argument_list|,
name|topToTable
argument_list|,
name|loadTableWork
argument_list|,
name|loadFileWork
argument_list|,
name|ctx
argument_list|,
name|idToTableNameMap
argument_list|,
name|destTableId
argument_list|,
name|uCtx
argument_list|,
name|listMapJoinOpsNoReducer
argument_list|)
decl_stmt|;
name|Optimizer
name|optm
init|=
operator|new
name|Optimizer
argument_list|()
decl_stmt|;
name|optm
operator|.
name|setPctx
argument_list|(
name|pCtx
argument_list|)
expr_stmt|;
name|optm
operator|.
name|initialize
argument_list|(
name|conf
argument_list|)
expr_stmt|;
name|pCtx
operator|=
name|optm
operator|.
name|optimize
argument_list|()
expr_stmt|;
name|init
argument_list|(
name|pCtx
argument_list|)
expr_stmt|;
name|qb
operator|=
name|pCtx
operator|.
name|getQB
argument_list|()
expr_stmt|;
comment|// Do any partition pruning using ASTPartitionPruner
name|genPartitionPruners
argument_list|(
name|qb
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Completed partition pruning"
argument_list|)
expr_stmt|;
comment|// Do any sample pruning
name|genSamplePruners
argument_list|(
name|qb
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Completed sample pruning"
argument_list|)
expr_stmt|;
comment|// At this point we have the complete operator tree
comment|// from which we want to find the reduce operator
name|genMapRedTasks
argument_list|(
name|qb
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Completed plan generation"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/**    * Generates and expression node descriptor for the expression passed in the arguments. This    * function uses the row resolver and the metadata informatinon that are passed as arguments    * to resolve the column names to internal names.    * @param expr The expression    * @param input The row resolver    * @return exprNodeDesc    * @throws SemanticException    */
annotation|@
name|SuppressWarnings
argument_list|(
literal|"nls"
argument_list|)
specifier|public
specifier|static
name|exprNodeDesc
name|genExprNodeDesc
parameter_list|(
name|ASTNode
name|expr
parameter_list|,
name|RowResolver
name|input
parameter_list|)
throws|throws
name|SemanticException
block|{
comment|//  We recursively create the exprNodeDesc.  Base cases:  when we encounter
comment|//  a column ref, we convert that into an exprNodeColumnDesc;  when we encounter
comment|//  a constant, we convert that into an exprNodeConstantDesc.  For others we just
comment|//  build the exprNodeFuncDesc with recursively built children.
comment|//  If the current subExpression is pre-calculated, as in Group-By etc.
name|ColumnInfo
name|colInfo
init|=
name|input
operator|.
name|get
argument_list|(
literal|""
argument_list|,
name|expr
operator|.
name|toStringTree
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|colInfo
operator|!=
literal|null
condition|)
block|{
return|return
operator|new
name|exprNodeColumnDesc
argument_list|(
name|colInfo
operator|.
name|getType
argument_list|()
argument_list|,
name|colInfo
operator|.
name|getInternalName
argument_list|()
argument_list|,
name|colInfo
operator|.
name|getTabAlias
argument_list|()
argument_list|,
name|colInfo
operator|.
name|getIsPartitionCol
argument_list|()
argument_list|)
return|;
block|}
comment|// Create the walker, the rules dispatcher and the context.
name|TypeCheckCtx
name|tcCtx
init|=
operator|new
name|TypeCheckCtx
argument_list|(
name|input
argument_list|)
decl_stmt|;
comment|// create a walker which walks the tree in a DFS manner while maintaining the operator stack. The dispatcher
comment|// generates the plan from the operator tree
name|Map
argument_list|<
name|Rule
argument_list|,
name|NodeProcessor
argument_list|>
name|opRules
init|=
operator|new
name|LinkedHashMap
argument_list|<
name|Rule
argument_list|,
name|NodeProcessor
argument_list|>
argument_list|()
decl_stmt|;
name|StringBuilder
name|sb
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|Formatter
name|fm
init|=
operator|new
name|Formatter
argument_list|(
name|sb
argument_list|)
decl_stmt|;
name|opRules
operator|.
name|put
argument_list|(
operator|new
name|RuleRegExp
argument_list|(
literal|"R1"
argument_list|,
name|HiveParser
operator|.
name|TOK_NULL
operator|+
literal|"%"
argument_list|)
argument_list|,
name|TypeCheckProcFactory
operator|.
name|getNullExprProcessor
argument_list|()
argument_list|)
expr_stmt|;
name|opRules
operator|.
name|put
argument_list|(
operator|new
name|RuleRegExp
argument_list|(
literal|"R2"
argument_list|,
name|HiveParser
operator|.
name|Number
operator|+
literal|"%"
argument_list|)
argument_list|,
name|TypeCheckProcFactory
operator|.
name|getNumExprProcessor
argument_list|()
argument_list|)
expr_stmt|;
name|opRules
operator|.
name|put
argument_list|(
operator|new
name|RuleRegExp
argument_list|(
literal|"R3"
argument_list|,
name|HiveParser
operator|.
name|Identifier
operator|+
literal|"%|"
operator|+
name|HiveParser
operator|.
name|StringLiteral
operator|+
literal|"%|"
operator|+
name|HiveParser
operator|.
name|TOK_CHARSETLITERAL
operator|+
literal|"%|"
operator|+
name|HiveParser
operator|.
name|KW_IF
operator|+
literal|"%|"
operator|+
name|HiveParser
operator|.
name|KW_CASE
operator|+
literal|"%|"
operator|+
name|HiveParser
operator|.
name|KW_WHEN
operator|+
literal|"%"
argument_list|)
argument_list|,
name|TypeCheckProcFactory
operator|.
name|getStrExprProcessor
argument_list|()
argument_list|)
expr_stmt|;
name|opRules
operator|.
name|put
argument_list|(
operator|new
name|RuleRegExp
argument_list|(
literal|"R4"
argument_list|,
name|HiveParser
operator|.
name|KW_TRUE
operator|+
literal|"%|"
operator|+
name|HiveParser
operator|.
name|KW_FALSE
operator|+
literal|"%"
argument_list|)
argument_list|,
name|TypeCheckProcFactory
operator|.
name|getBoolExprProcessor
argument_list|()
argument_list|)
expr_stmt|;
name|opRules
operator|.
name|put
argument_list|(
operator|new
name|RuleRegExp
argument_list|(
literal|"R5"
argument_list|,
name|HiveParser
operator|.
name|TOK_TABLE_OR_COL
operator|+
literal|"%"
argument_list|)
argument_list|,
name|TypeCheckProcFactory
operator|.
name|getColumnExprProcessor
argument_list|()
argument_list|)
expr_stmt|;
comment|// The dispatcher fires the processor corresponding to the closest matching rule and passes the context along
name|Dispatcher
name|disp
init|=
operator|new
name|DefaultRuleDispatcher
argument_list|(
name|TypeCheckProcFactory
operator|.
name|getDefaultExprProcessor
argument_list|()
argument_list|,
name|opRules
argument_list|,
name|tcCtx
argument_list|)
decl_stmt|;
name|GraphWalker
name|ogw
init|=
operator|new
name|DefaultGraphWalker
argument_list|(
name|disp
argument_list|)
decl_stmt|;
comment|// Create a list of topop nodes
name|ArrayList
argument_list|<
name|Node
argument_list|>
name|topNodes
init|=
operator|new
name|ArrayList
argument_list|<
name|Node
argument_list|>
argument_list|()
decl_stmt|;
name|topNodes
operator|.
name|add
argument_list|(
name|expr
argument_list|)
expr_stmt|;
name|HashMap
argument_list|<
name|Node
argument_list|,
name|Object
argument_list|>
name|nodeOutputs
init|=
operator|new
name|HashMap
argument_list|<
name|Node
argument_list|,
name|Object
argument_list|>
argument_list|()
decl_stmt|;
name|ogw
operator|.
name|startWalking
argument_list|(
name|topNodes
argument_list|,
name|nodeOutputs
argument_list|)
expr_stmt|;
name|exprNodeDesc
name|desc
init|=
operator|(
name|exprNodeDesc
operator|)
name|nodeOutputs
operator|.
name|get
argument_list|(
name|expr
argument_list|)
decl_stmt|;
if|if
condition|(
name|desc
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|tcCtx
operator|.
name|getError
argument_list|()
argument_list|)
throw|;
block|}
return|return
name|desc
return|;
block|}
comment|/**    * Gets the table Alias for the column from the column name. This function throws    * and exception in case the same column name is present in multiple table. The exception     * message indicates that the ambiguity could not be resolved.    *     * @param qbm The metadata where the function looks for the table alias    * @param colName The name of the non aliased column    * @param pt The parse tree corresponding to the column(this is used for error reporting)    * @return String    * @throws SemanticException    */
specifier|static
name|String
name|getTabAliasForCol
parameter_list|(
name|QBMetaData
name|qbm
parameter_list|,
name|String
name|colName
parameter_list|,
name|ASTNode
name|pt
parameter_list|)
throws|throws
name|SemanticException
block|{
name|String
name|tabAlias
init|=
literal|null
decl_stmt|;
name|boolean
name|found
init|=
literal|false
decl_stmt|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|Table
argument_list|>
name|ent
range|:
name|qbm
operator|.
name|getAliasToTable
argument_list|()
operator|.
name|entrySet
argument_list|()
control|)
block|{
for|for
control|(
name|FieldSchema
name|field
range|:
name|ent
operator|.
name|getValue
argument_list|()
operator|.
name|getAllCols
argument_list|()
control|)
block|{
if|if
condition|(
name|colName
operator|.
name|equalsIgnoreCase
argument_list|(
name|field
operator|.
name|getName
argument_list|()
argument_list|)
condition|)
block|{
if|if
condition|(
name|found
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|AMBIGUOUS_COLUMN
operator|.
name|getMsg
argument_list|(
name|pt
argument_list|)
argument_list|)
throw|;
block|}
name|found
operator|=
literal|true
expr_stmt|;
name|tabAlias
operator|=
name|ent
operator|.
name|getKey
argument_list|()
expr_stmt|;
block|}
block|}
block|}
return|return
name|tabAlias
return|;
block|}
specifier|public
name|void
name|validate
parameter_list|()
throws|throws
name|SemanticException
block|{
comment|// Check if the plan contains atleast one path.
comment|// validate all tasks
for|for
control|(
name|Task
argument_list|<
name|?
extends|extends
name|Serializable
argument_list|>
name|rootTask
range|:
name|rootTasks
control|)
name|validate
argument_list|(
name|rootTask
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|validate
parameter_list|(
name|Task
argument_list|<
name|?
extends|extends
name|Serializable
argument_list|>
name|task
parameter_list|)
throws|throws
name|SemanticException
block|{
if|if
condition|(
operator|(
name|task
operator|instanceof
name|MapRedTask
operator|)
operator|||
operator|(
name|task
operator|instanceof
name|ExecDriver
operator|)
condition|)
block|{
name|mapredWork
name|work
init|=
operator|(
name|mapredWork
operator|)
name|task
operator|.
name|getWork
argument_list|()
decl_stmt|;
if|if
condition|(
name|conf
operator|.
name|getVar
argument_list|(
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVEMAPREDMODE
argument_list|)
operator|.
name|equalsIgnoreCase
argument_list|(
literal|"strict"
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|work
operator|.
name|getPathToAliases
argument_list|()
operator|==
literal|null
operator|)
operator|||
operator|(
name|work
operator|.
name|getPathToAliases
argument_list|()
operator|.
name|isEmpty
argument_list|()
operator|)
condition|)
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|NO_VALID_PARTN
operator|.
name|getMsg
argument_list|()
argument_list|)
throw|;
block|}
block|}
if|if
condition|(
name|task
operator|.
name|getChildTasks
argument_list|()
operator|==
literal|null
condition|)
return|return;
for|for
control|(
name|Task
argument_list|<
name|?
extends|extends
name|Serializable
argument_list|>
name|childTask
range|:
name|task
operator|.
name|getChildTasks
argument_list|()
control|)
name|validate
argument_list|(
name|childTask
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|Set
argument_list|<
name|ReadEntity
argument_list|>
name|getInputs
parameter_list|()
block|{
return|return
name|inputs
return|;
block|}
specifier|public
name|Set
argument_list|<
name|WriteEntity
argument_list|>
name|getOutputs
parameter_list|()
block|{
return|return
name|outputs
return|;
block|}
block|}
end_class

end_unit

