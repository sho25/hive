begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|parse
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|Serializable
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|LinkedHashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
operator|.
name|Entry
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|TreeSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|regex
operator|.
name|Pattern
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|regex
operator|.
name|PatternSyntaxException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|lang
operator|.
name|StringUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|ContentSummary
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|Path
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|PathFilter
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|common
operator|.
name|FileUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|common
operator|.
name|JavaUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|conf
operator|.
name|HiveConf
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|conf
operator|.
name|HiveConf
operator|.
name|ConfVars
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|metastore
operator|.
name|Warehouse
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|metastore
operator|.
name|api
operator|.
name|FieldSchema
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|metastore
operator|.
name|api
operator|.
name|MetaException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|metastore
operator|.
name|api
operator|.
name|Order
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|Context
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|AbstractMapJoinOperator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|ColumnInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|ConditionalTask
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|ExecDriver
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|FetchTask
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|FileSinkOperator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|FunctionInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|FunctionRegistry
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|GroupByOperator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|JoinOperator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|MapRedTask
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|Operator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|OperatorFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|RecordReader
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|RecordWriter
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|ReduceSinkOperator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|RowSchema
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|TableScanOperator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|Task
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|TaskFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|UnionOperator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|Utilities
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|hooks
operator|.
name|ReadEntity
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|hooks
operator|.
name|WriteEntity
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|io
operator|.
name|CombineHiveInputFormat
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|io
operator|.
name|HiveFileFormatUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|io
operator|.
name|HiveOutputFormat
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|lib
operator|.
name|DefaultGraphWalker
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|lib
operator|.
name|DefaultRuleDispatcher
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|lib
operator|.
name|Dispatcher
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|lib
operator|.
name|GraphWalker
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|lib
operator|.
name|Node
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|lib
operator|.
name|NodeProcessor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|lib
operator|.
name|Rule
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|lib
operator|.
name|RuleRegExp
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|metadata
operator|.
name|DummyPartition
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|metadata
operator|.
name|Hive
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|metadata
operator|.
name|HiveException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|metadata
operator|.
name|HiveUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|metadata
operator|.
name|InvalidTableException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|metadata
operator|.
name|Partition
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|metadata
operator|.
name|Table
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|metadata
operator|.
name|VirtualColumn
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|optimizer
operator|.
name|GenMRFileSink1
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|optimizer
operator|.
name|GenMROperator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|optimizer
operator|.
name|GenMRProcContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|optimizer
operator|.
name|GenMRProcContext
operator|.
name|GenMapRedCtx
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|optimizer
operator|.
name|GenMRRedSink1
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|optimizer
operator|.
name|GenMRRedSink2
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|optimizer
operator|.
name|GenMRRedSink3
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|optimizer
operator|.
name|GenMRRedSink4
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|optimizer
operator|.
name|GenMRTableScan1
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|optimizer
operator|.
name|GenMRUnion1
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|optimizer
operator|.
name|GenMapRedUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|optimizer
operator|.
name|MapJoinFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|optimizer
operator|.
name|Optimizer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|optimizer
operator|.
name|physical
operator|.
name|PhysicalContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|optimizer
operator|.
name|physical
operator|.
name|PhysicalOptimizer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|optimizer
operator|.
name|ppr
operator|.
name|PartitionPruner
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|optimizer
operator|.
name|unionproc
operator|.
name|UnionProcContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|parse
operator|.
name|BaseSemanticAnalyzer
operator|.
name|tableSpec
operator|.
name|SpecType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|AggregationDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|CreateTableDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|CreateTableLikeDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|CreateViewDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|DDLWork
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|DynamicPartitionCtx
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|ExprNodeColumnDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|ExprNodeConstantDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|ExprNodeDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|ExprNodeGenericFuncDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|ExprNodeNullDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|ExtractDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|FetchWork
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|FileSinkDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|FilterDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|FilterDesc
operator|.
name|sampleDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|ForwardDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|GroupByDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|HiveOperation
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|JoinCondDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|JoinDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|LateralViewForwardDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|LateralViewJoinDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|LimitDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|LoadFileDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|LoadTableDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|MapJoinDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|MapredWork
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|MoveWork
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|PartitionDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|PlanUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|ReduceSinkDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|ScriptDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|SelectDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|TableDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|TableScanDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|UDTFDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|plan
operator|.
name|UnionDesc
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|session
operator|.
name|SessionState
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|session
operator|.
name|SessionState
operator|.
name|ResourceType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|udf
operator|.
name|generic
operator|.
name|GenericUDAFEvaluator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|udf
operator|.
name|generic
operator|.
name|GenericUDAFEvaluator
operator|.
name|Mode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|udf
operator|.
name|generic
operator|.
name|GenericUDFHash
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|udf
operator|.
name|generic
operator|.
name|GenericUDTF
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde
operator|.
name|Constants
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|Deserializer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|MetadataTypedColumnsetSerDe
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|SerDeException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|SerDeUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|lazy
operator|.
name|LazySimpleSerDe
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|objectinspector
operator|.
name|ObjectInspector
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|objectinspector
operator|.
name|ObjectInspector
operator|.
name|Category
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|objectinspector
operator|.
name|StructField
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|objectinspector
operator|.
name|StructObjectInspector
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|typeinfo
operator|.
name|TypeInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|typeinfo
operator|.
name|TypeInfoFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|serde2
operator|.
name|typeinfo
operator|.
name|TypeInfoUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapred
operator|.
name|InputFormat
import|;
end_import

begin_comment
comment|/**  * Implementation of the semantic analyzer.  */
end_comment

begin_class
specifier|public
class|class
name|SemanticAnalyzer
extends|extends
name|BaseSemanticAnalyzer
block|{
specifier|private
name|HashMap
argument_list|<
name|TableScanOperator
argument_list|,
name|ExprNodeDesc
argument_list|>
name|opToPartPruner
decl_stmt|;
specifier|private
name|HashMap
argument_list|<
name|TableScanOperator
argument_list|,
name|PrunedPartitionList
argument_list|>
name|opToPartList
decl_stmt|;
specifier|private
name|HashMap
argument_list|<
name|String
argument_list|,
name|Operator
argument_list|<
name|?
extends|extends
name|Serializable
argument_list|>
argument_list|>
name|topOps
decl_stmt|;
specifier|private
name|HashMap
argument_list|<
name|String
argument_list|,
name|Operator
argument_list|<
name|?
extends|extends
name|Serializable
argument_list|>
argument_list|>
name|topSelOps
decl_stmt|;
specifier|private
name|LinkedHashMap
argument_list|<
name|Operator
argument_list|<
name|?
extends|extends
name|Serializable
argument_list|>
argument_list|,
name|OpParseContext
argument_list|>
name|opParseCtx
decl_stmt|;
specifier|private
name|List
argument_list|<
name|LoadTableDesc
argument_list|>
name|loadTableWork
decl_stmt|;
specifier|private
name|List
argument_list|<
name|LoadFileDesc
argument_list|>
name|loadFileWork
decl_stmt|;
specifier|private
name|Map
argument_list|<
name|JoinOperator
argument_list|,
name|QBJoinTree
argument_list|>
name|joinContext
decl_stmt|;
specifier|private
specifier|final
name|HashMap
argument_list|<
name|TableScanOperator
argument_list|,
name|Table
argument_list|>
name|topToTable
decl_stmt|;
specifier|private
name|QB
name|qb
decl_stmt|;
specifier|private
name|ASTNode
name|ast
decl_stmt|;
specifier|private
name|int
name|destTableId
decl_stmt|;
specifier|private
name|UnionProcContext
name|uCtx
decl_stmt|;
name|List
argument_list|<
name|AbstractMapJoinOperator
argument_list|<
name|?
extends|extends
name|MapJoinDesc
argument_list|>
argument_list|>
name|listMapJoinOpsNoReducer
decl_stmt|;
specifier|private
name|HashMap
argument_list|<
name|TableScanOperator
argument_list|,
name|sampleDesc
argument_list|>
name|opToSamplePruner
decl_stmt|;
comment|/**    * a map for the split sampling, from ailias to an instance of SplitSample    * that describes percentage and number.    */
specifier|private
specifier|final
name|HashMap
argument_list|<
name|String
argument_list|,
name|SplitSample
argument_list|>
name|nameToSplitSample
decl_stmt|;
name|Map
argument_list|<
name|GroupByOperator
argument_list|,
name|Set
argument_list|<
name|String
argument_list|>
argument_list|>
name|groupOpToInputTables
decl_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|PrunedPartitionList
argument_list|>
name|prunedPartitions
decl_stmt|;
specifier|private
name|List
argument_list|<
name|FieldSchema
argument_list|>
name|resultSchema
decl_stmt|;
specifier|private
name|CreateViewDesc
name|createVwDesc
decl_stmt|;
specifier|private
name|ArrayList
argument_list|<
name|String
argument_list|>
name|viewsExpanded
decl_stmt|;
specifier|private
name|ASTNode
name|viewSelect
decl_stmt|;
specifier|private
specifier|final
name|UnparseTranslator
name|unparseTranslator
decl_stmt|;
specifier|private
specifier|final
name|GlobalLimitCtx
name|globalLimitCtx
init|=
operator|new
name|GlobalLimitCtx
argument_list|()
decl_stmt|;
specifier|public
specifier|static
class|class
name|GlobalLimitCtx
block|{
specifier|private
name|boolean
name|enable
init|=
literal|false
decl_stmt|;
specifier|private
name|int
name|globalLimit
init|=
operator|-
literal|1
decl_stmt|;
specifier|private
name|boolean
name|hasTransformOrUDTF
init|=
literal|false
decl_stmt|;
specifier|private
name|LimitDesc
name|lastReduceLimitDesc
init|=
literal|null
decl_stmt|;
specifier|public
name|int
name|getGlobalLimit
parameter_list|()
block|{
return|return
name|globalLimit
return|;
block|}
specifier|public
name|boolean
name|ifHasTransformOrUDTF
parameter_list|()
block|{
return|return
name|hasTransformOrUDTF
return|;
block|}
specifier|public
name|void
name|setHasTransformOrUDTF
parameter_list|(
name|boolean
name|hasTransformOrUDTF
parameter_list|)
block|{
name|this
operator|.
name|hasTransformOrUDTF
operator|=
name|hasTransformOrUDTF
expr_stmt|;
block|}
specifier|public
name|LimitDesc
name|getLastReduceLimitDesc
parameter_list|()
block|{
return|return
name|lastReduceLimitDesc
return|;
block|}
specifier|public
name|void
name|setLastReduceLimitDesc
parameter_list|(
name|LimitDesc
name|lastReduceLimitDesc
parameter_list|)
block|{
name|this
operator|.
name|lastReduceLimitDesc
operator|=
name|lastReduceLimitDesc
expr_stmt|;
block|}
specifier|public
name|boolean
name|isEnable
parameter_list|()
block|{
return|return
name|enable
return|;
block|}
specifier|public
name|void
name|enableOpt
parameter_list|(
name|int
name|globalLimit
parameter_list|)
block|{
name|this
operator|.
name|enable
operator|=
literal|true
expr_stmt|;
name|this
operator|.
name|globalLimit
operator|=
name|globalLimit
expr_stmt|;
block|}
specifier|public
name|void
name|disableOpt
parameter_list|()
block|{
name|this
operator|.
name|enable
operator|=
literal|false
expr_stmt|;
name|this
operator|.
name|globalLimit
operator|=
operator|-
literal|1
expr_stmt|;
name|this
operator|.
name|lastReduceLimitDesc
operator|=
literal|null
expr_stmt|;
block|}
block|}
specifier|private
specifier|static
class|class
name|Phase1Ctx
block|{
name|String
name|dest
decl_stmt|;
name|int
name|nextNum
decl_stmt|;
block|}
specifier|public
name|SemanticAnalyzer
parameter_list|(
name|HiveConf
name|conf
parameter_list|)
throws|throws
name|SemanticException
block|{
name|super
argument_list|(
name|conf
argument_list|)
expr_stmt|;
name|opToPartPruner
operator|=
operator|new
name|HashMap
argument_list|<
name|TableScanOperator
argument_list|,
name|ExprNodeDesc
argument_list|>
argument_list|()
expr_stmt|;
name|opToPartList
operator|=
operator|new
name|HashMap
argument_list|<
name|TableScanOperator
argument_list|,
name|PrunedPartitionList
argument_list|>
argument_list|()
expr_stmt|;
name|opToSamplePruner
operator|=
operator|new
name|HashMap
argument_list|<
name|TableScanOperator
argument_list|,
name|sampleDesc
argument_list|>
argument_list|()
expr_stmt|;
name|nameToSplitSample
operator|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|SplitSample
argument_list|>
argument_list|()
expr_stmt|;
name|topOps
operator|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|Operator
argument_list|<
name|?
extends|extends
name|Serializable
argument_list|>
argument_list|>
argument_list|()
expr_stmt|;
name|topSelOps
operator|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|Operator
argument_list|<
name|?
extends|extends
name|Serializable
argument_list|>
argument_list|>
argument_list|()
expr_stmt|;
name|loadTableWork
operator|=
operator|new
name|ArrayList
argument_list|<
name|LoadTableDesc
argument_list|>
argument_list|()
expr_stmt|;
name|loadFileWork
operator|=
operator|new
name|ArrayList
argument_list|<
name|LoadFileDesc
argument_list|>
argument_list|()
expr_stmt|;
name|opParseCtx
operator|=
operator|new
name|LinkedHashMap
argument_list|<
name|Operator
argument_list|<
name|?
extends|extends
name|Serializable
argument_list|>
argument_list|,
name|OpParseContext
argument_list|>
argument_list|()
expr_stmt|;
name|joinContext
operator|=
operator|new
name|HashMap
argument_list|<
name|JoinOperator
argument_list|,
name|QBJoinTree
argument_list|>
argument_list|()
expr_stmt|;
name|topToTable
operator|=
operator|new
name|HashMap
argument_list|<
name|TableScanOperator
argument_list|,
name|Table
argument_list|>
argument_list|()
expr_stmt|;
name|destTableId
operator|=
literal|1
expr_stmt|;
name|uCtx
operator|=
literal|null
expr_stmt|;
name|listMapJoinOpsNoReducer
operator|=
operator|new
name|ArrayList
argument_list|<
name|AbstractMapJoinOperator
argument_list|<
name|?
extends|extends
name|MapJoinDesc
argument_list|>
argument_list|>
argument_list|()
expr_stmt|;
name|groupOpToInputTables
operator|=
operator|new
name|HashMap
argument_list|<
name|GroupByOperator
argument_list|,
name|Set
argument_list|<
name|String
argument_list|>
argument_list|>
argument_list|()
expr_stmt|;
name|prunedPartitions
operator|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|PrunedPartitionList
argument_list|>
argument_list|()
expr_stmt|;
name|unparseTranslator
operator|=
operator|new
name|UnparseTranslator
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Override
specifier|protected
name|void
name|reset
parameter_list|()
block|{
name|super
operator|.
name|reset
argument_list|()
expr_stmt|;
name|loadTableWork
operator|.
name|clear
argument_list|()
expr_stmt|;
name|loadFileWork
operator|.
name|clear
argument_list|()
expr_stmt|;
name|topOps
operator|.
name|clear
argument_list|()
expr_stmt|;
name|topSelOps
operator|.
name|clear
argument_list|()
expr_stmt|;
name|destTableId
operator|=
literal|1
expr_stmt|;
name|idToTableNameMap
operator|.
name|clear
argument_list|()
expr_stmt|;
name|qb
operator|=
literal|null
expr_stmt|;
name|ast
operator|=
literal|null
expr_stmt|;
name|uCtx
operator|=
literal|null
expr_stmt|;
name|joinContext
operator|.
name|clear
argument_list|()
expr_stmt|;
name|opParseCtx
operator|.
name|clear
argument_list|()
expr_stmt|;
name|groupOpToInputTables
operator|.
name|clear
argument_list|()
expr_stmt|;
name|prunedPartitions
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
specifier|public
name|void
name|init
parameter_list|(
name|ParseContext
name|pctx
parameter_list|)
block|{
name|opToPartPruner
operator|=
name|pctx
operator|.
name|getOpToPartPruner
argument_list|()
expr_stmt|;
name|opToPartList
operator|=
name|pctx
operator|.
name|getOpToPartList
argument_list|()
expr_stmt|;
name|opToSamplePruner
operator|=
name|pctx
operator|.
name|getOpToSamplePruner
argument_list|()
expr_stmt|;
name|topOps
operator|=
name|pctx
operator|.
name|getTopOps
argument_list|()
expr_stmt|;
name|topSelOps
operator|=
name|pctx
operator|.
name|getTopSelOps
argument_list|()
expr_stmt|;
name|opParseCtx
operator|=
name|pctx
operator|.
name|getOpParseCtx
argument_list|()
expr_stmt|;
name|loadTableWork
operator|=
name|pctx
operator|.
name|getLoadTableWork
argument_list|()
expr_stmt|;
name|loadFileWork
operator|=
name|pctx
operator|.
name|getLoadFileWork
argument_list|()
expr_stmt|;
name|joinContext
operator|=
name|pctx
operator|.
name|getJoinContext
argument_list|()
expr_stmt|;
name|ctx
operator|=
name|pctx
operator|.
name|getContext
argument_list|()
expr_stmt|;
name|destTableId
operator|=
name|pctx
operator|.
name|getDestTableId
argument_list|()
expr_stmt|;
name|idToTableNameMap
operator|=
name|pctx
operator|.
name|getIdToTableNameMap
argument_list|()
expr_stmt|;
name|uCtx
operator|=
name|pctx
operator|.
name|getUCtx
argument_list|()
expr_stmt|;
name|listMapJoinOpsNoReducer
operator|=
name|pctx
operator|.
name|getListMapJoinOpsNoReducer
argument_list|()
expr_stmt|;
name|qb
operator|=
name|pctx
operator|.
name|getQB
argument_list|()
expr_stmt|;
name|groupOpToInputTables
operator|=
name|pctx
operator|.
name|getGroupOpToInputTables
argument_list|()
expr_stmt|;
name|prunedPartitions
operator|=
name|pctx
operator|.
name|getPrunedPartitions
argument_list|()
expr_stmt|;
name|setLineageInfo
argument_list|(
name|pctx
operator|.
name|getLineageInfo
argument_list|()
argument_list|)
expr_stmt|;
block|}
specifier|public
name|ParseContext
name|getParseContext
parameter_list|()
block|{
return|return
operator|new
name|ParseContext
argument_list|(
name|conf
argument_list|,
name|qb
argument_list|,
name|ast
argument_list|,
name|opToPartPruner
argument_list|,
name|opToPartList
argument_list|,
name|topOps
argument_list|,
name|topSelOps
argument_list|,
name|opParseCtx
argument_list|,
name|joinContext
argument_list|,
name|topToTable
argument_list|,
name|loadTableWork
argument_list|,
name|loadFileWork
argument_list|,
name|ctx
argument_list|,
name|idToTableNameMap
argument_list|,
name|destTableId
argument_list|,
name|uCtx
argument_list|,
name|listMapJoinOpsNoReducer
argument_list|,
name|groupOpToInputTables
argument_list|,
name|prunedPartitions
argument_list|,
name|opToSamplePruner
argument_list|,
name|globalLimitCtx
argument_list|,
name|nameToSplitSample
argument_list|,
name|inputs
argument_list|,
name|rootTasks
argument_list|)
return|;
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"nls"
argument_list|)
specifier|public
name|void
name|doPhase1QBExpr
parameter_list|(
name|ASTNode
name|ast
parameter_list|,
name|QBExpr
name|qbexpr
parameter_list|,
name|String
name|id
parameter_list|,
name|String
name|alias
parameter_list|)
throws|throws
name|SemanticException
block|{
assert|assert
operator|(
name|ast
operator|.
name|getToken
argument_list|()
operator|!=
literal|null
operator|)
assert|;
switch|switch
condition|(
name|ast
operator|.
name|getToken
argument_list|()
operator|.
name|getType
argument_list|()
condition|)
block|{
case|case
name|HiveParser
operator|.
name|TOK_QUERY
case|:
block|{
name|QB
name|qb
init|=
operator|new
name|QB
argument_list|(
name|id
argument_list|,
name|alias
argument_list|,
literal|true
argument_list|)
decl_stmt|;
name|doPhase1
argument_list|(
name|ast
argument_list|,
name|qb
argument_list|,
name|initPhase1Ctx
argument_list|()
argument_list|)
expr_stmt|;
name|qbexpr
operator|.
name|setOpcode
argument_list|(
name|QBExpr
operator|.
name|Opcode
operator|.
name|NULLOP
argument_list|)
expr_stmt|;
name|qbexpr
operator|.
name|setQB
argument_list|(
name|qb
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|HiveParser
operator|.
name|TOK_UNION
case|:
block|{
name|qbexpr
operator|.
name|setOpcode
argument_list|(
name|QBExpr
operator|.
name|Opcode
operator|.
name|UNION
argument_list|)
expr_stmt|;
comment|// query 1
assert|assert
operator|(
name|ast
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|!=
literal|null
operator|)
assert|;
name|QBExpr
name|qbexpr1
init|=
operator|new
name|QBExpr
argument_list|(
name|alias
operator|+
literal|"-subquery1"
argument_list|)
decl_stmt|;
name|doPhase1QBExpr
argument_list|(
operator|(
name|ASTNode
operator|)
name|ast
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
argument_list|,
name|qbexpr1
argument_list|,
name|id
operator|+
literal|"-subquery1"
argument_list|,
name|alias
operator|+
literal|"-subquery1"
argument_list|)
expr_stmt|;
name|qbexpr
operator|.
name|setQBExpr1
argument_list|(
name|qbexpr1
argument_list|)
expr_stmt|;
comment|// query 2
assert|assert
operator|(
name|ast
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|!=
literal|null
operator|)
assert|;
name|QBExpr
name|qbexpr2
init|=
operator|new
name|QBExpr
argument_list|(
name|alias
operator|+
literal|"-subquery2"
argument_list|)
decl_stmt|;
name|doPhase1QBExpr
argument_list|(
operator|(
name|ASTNode
operator|)
name|ast
operator|.
name|getChild
argument_list|(
literal|1
argument_list|)
argument_list|,
name|qbexpr2
argument_list|,
name|id
operator|+
literal|"-subquery2"
argument_list|,
name|alias
operator|+
literal|"-subquery2"
argument_list|)
expr_stmt|;
name|qbexpr
operator|.
name|setQBExpr2
argument_list|(
name|qbexpr2
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
block|}
specifier|private
name|LinkedHashMap
argument_list|<
name|String
argument_list|,
name|ASTNode
argument_list|>
name|doPhase1GetAggregationsFromSelect
parameter_list|(
name|ASTNode
name|selExpr
parameter_list|)
block|{
comment|// Iterate over the selects search for aggregation Trees.
comment|// Use String as keys to eliminate duplicate trees.
name|LinkedHashMap
argument_list|<
name|String
argument_list|,
name|ASTNode
argument_list|>
name|aggregationTrees
init|=
operator|new
name|LinkedHashMap
argument_list|<
name|String
argument_list|,
name|ASTNode
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|selExpr
operator|.
name|getChildCount
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|ASTNode
name|sel
init|=
operator|(
name|ASTNode
operator|)
name|selExpr
operator|.
name|getChild
argument_list|(
name|i
argument_list|)
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|doPhase1GetAllAggregations
argument_list|(
name|sel
argument_list|,
name|aggregationTrees
argument_list|)
expr_stmt|;
block|}
return|return
name|aggregationTrees
return|;
block|}
specifier|private
name|void
name|doPhase1GetColumnAliasesFromSelect
parameter_list|(
name|ASTNode
name|selectExpr
parameter_list|,
name|QBParseInfo
name|qbp
parameter_list|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|selectExpr
operator|.
name|getChildCount
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|ASTNode
name|selExpr
init|=
operator|(
name|ASTNode
operator|)
name|selectExpr
operator|.
name|getChild
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|selExpr
operator|.
name|getToken
argument_list|()
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_SELEXPR
operator|)
operator|&&
operator|(
name|selExpr
operator|.
name|getChildCount
argument_list|()
operator|==
literal|2
operator|)
condition|)
block|{
name|String
name|columnAlias
init|=
name|unescapeIdentifier
argument_list|(
name|selExpr
operator|.
name|getChild
argument_list|(
literal|1
argument_list|)
operator|.
name|getText
argument_list|()
argument_list|)
decl_stmt|;
name|qbp
operator|.
name|setExprToColumnAlias
argument_list|(
operator|(
name|ASTNode
operator|)
name|selExpr
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
argument_list|,
name|columnAlias
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**    * DFS-scan the expressionTree to find all aggregation subtrees and put them    * in aggregations.    *    * @param expressionTree    * @param aggregations    *          the key to the HashTable is the toStringTree() representation of    *          the aggregation subtree.    */
specifier|private
name|void
name|doPhase1GetAllAggregations
parameter_list|(
name|ASTNode
name|expressionTree
parameter_list|,
name|HashMap
argument_list|<
name|String
argument_list|,
name|ASTNode
argument_list|>
name|aggregations
parameter_list|)
block|{
name|int
name|exprTokenType
init|=
name|expressionTree
operator|.
name|getToken
argument_list|()
operator|.
name|getType
argument_list|()
decl_stmt|;
if|if
condition|(
name|exprTokenType
operator|==
name|HiveParser
operator|.
name|TOK_FUNCTION
operator|||
name|exprTokenType
operator|==
name|HiveParser
operator|.
name|TOK_FUNCTIONDI
operator|||
name|exprTokenType
operator|==
name|HiveParser
operator|.
name|TOK_FUNCTIONSTAR
condition|)
block|{
assert|assert
operator|(
name|expressionTree
operator|.
name|getChildCount
argument_list|()
operator|!=
literal|0
operator|)
assert|;
if|if
condition|(
name|expressionTree
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|Identifier
condition|)
block|{
name|String
name|functionName
init|=
name|unescapeIdentifier
argument_list|(
name|expressionTree
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getText
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|FunctionRegistry
operator|.
name|getGenericUDAFResolver
argument_list|(
name|functionName
argument_list|)
operator|!=
literal|null
condition|)
block|{
name|aggregations
operator|.
name|put
argument_list|(
name|expressionTree
operator|.
name|toStringTree
argument_list|()
argument_list|,
name|expressionTree
argument_list|)
expr_stmt|;
name|FunctionInfo
name|fi
init|=
name|FunctionRegistry
operator|.
name|getFunctionInfo
argument_list|(
name|functionName
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|fi
operator|.
name|isNative
argument_list|()
condition|)
block|{
name|unparseTranslator
operator|.
name|addIdentifierTranslation
argument_list|(
operator|(
name|ASTNode
operator|)
name|expressionTree
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
block|}
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|expressionTree
operator|.
name|getChildCount
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|doPhase1GetAllAggregations
argument_list|(
operator|(
name|ASTNode
operator|)
name|expressionTree
operator|.
name|getChild
argument_list|(
name|i
argument_list|)
argument_list|,
name|aggregations
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
name|List
argument_list|<
name|ASTNode
argument_list|>
name|doPhase1GetDistinctFuncExprs
parameter_list|(
name|HashMap
argument_list|<
name|String
argument_list|,
name|ASTNode
argument_list|>
name|aggregationTrees
parameter_list|)
throws|throws
name|SemanticException
block|{
name|List
argument_list|<
name|ASTNode
argument_list|>
name|exprs
init|=
operator|new
name|ArrayList
argument_list|<
name|ASTNode
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|ASTNode
argument_list|>
name|entry
range|:
name|aggregationTrees
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|ASTNode
name|value
init|=
name|entry
operator|.
name|getValue
argument_list|()
decl_stmt|;
assert|assert
operator|(
name|value
operator|!=
literal|null
operator|)
assert|;
if|if
condition|(
name|value
operator|.
name|getToken
argument_list|()
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_FUNCTIONDI
condition|)
block|{
name|exprs
operator|.
name|add
argument_list|(
name|value
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|exprs
return|;
block|}
specifier|public
specifier|static
name|String
name|generateErrorMessage
parameter_list|(
name|ASTNode
name|ast
parameter_list|,
name|String
name|message
parameter_list|)
block|{
name|StringBuilder
name|sb
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|sb
operator|.
name|append
argument_list|(
name|ast
operator|.
name|getLine
argument_list|()
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|":"
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
name|ast
operator|.
name|getCharPositionInLine
argument_list|()
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|" "
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
name|message
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|". Error encountered near token '"
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
name|ErrorMsg
operator|.
name|getText
argument_list|(
name|ast
argument_list|)
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|"'"
argument_list|)
expr_stmt|;
return|return
name|sb
operator|.
name|toString
argument_list|()
return|;
block|}
comment|/**    * Goes though the tabref tree and finds the alias for the table. Once found,    * it records the table name-> alias association in aliasToTabs. It also makes    * an association from the alias to the table AST in parse info.    *    * @return the alias of the table    */
specifier|private
name|String
name|processTable
parameter_list|(
name|QB
name|qb
parameter_list|,
name|ASTNode
name|tabref
parameter_list|)
throws|throws
name|SemanticException
block|{
comment|// For each table reference get the table name
comment|// and the alias (if alias is not present, the table name
comment|// is used as an alias)
name|boolean
name|tableSamplePresent
init|=
literal|false
decl_stmt|;
name|boolean
name|splitSamplePresent
init|=
literal|false
decl_stmt|;
name|int
name|aliasIndex
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|tabref
operator|.
name|getChildCount
argument_list|()
operator|==
literal|2
condition|)
block|{
comment|// tablename tablesample
comment|// OR
comment|// tablename alias
name|ASTNode
name|ct
init|=
operator|(
name|ASTNode
operator|)
name|tabref
operator|.
name|getChild
argument_list|(
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|ct
operator|.
name|getToken
argument_list|()
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_TABLEBUCKETSAMPLE
condition|)
block|{
name|tableSamplePresent
operator|=
literal|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ct
operator|.
name|getToken
argument_list|()
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_TABLESPLITSAMPLE
condition|)
block|{
name|splitSamplePresent
operator|=
literal|true
expr_stmt|;
block|}
else|else
block|{
name|aliasIndex
operator|=
literal|1
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|tabref
operator|.
name|getChildCount
argument_list|()
operator|==
literal|3
condition|)
block|{
comment|// table name table sample alias
name|aliasIndex
operator|=
literal|2
expr_stmt|;
name|ASTNode
name|ct
init|=
operator|(
name|ASTNode
operator|)
name|tabref
operator|.
name|getChild
argument_list|(
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|ct
operator|.
name|getToken
argument_list|()
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_TABLEBUCKETSAMPLE
condition|)
block|{
name|tableSamplePresent
operator|=
literal|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ct
operator|.
name|getToken
argument_list|()
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_TABLESPLITSAMPLE
condition|)
block|{
name|splitSamplePresent
operator|=
literal|true
expr_stmt|;
block|}
block|}
name|ASTNode
name|tableTree
init|=
call|(
name|ASTNode
call|)
argument_list|(
name|tabref
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|String
name|tabIdName
init|=
name|getUnescapedName
argument_list|(
name|tableTree
argument_list|)
decl_stmt|;
name|String
name|alias
init|=
operator|(
name|aliasIndex
operator|!=
literal|0
operator|)
condition|?
name|unescapeIdentifier
argument_list|(
name|tabref
operator|.
name|getChild
argument_list|(
name|aliasIndex
argument_list|)
operator|.
name|getText
argument_list|()
argument_list|)
else|:
name|tabIdName
decl_stmt|;
comment|// If the alias is already there then we have a conflict
if|if
condition|(
name|qb
operator|.
name|exists
argument_list|(
name|alias
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|AMBIGUOUS_TABLE_ALIAS
operator|.
name|getMsg
argument_list|(
name|tabref
operator|.
name|getChild
argument_list|(
name|aliasIndex
argument_list|)
argument_list|)
argument_list|)
throw|;
block|}
if|if
condition|(
name|tableSamplePresent
condition|)
block|{
name|ASTNode
name|sampleClause
init|=
operator|(
name|ASTNode
operator|)
name|tabref
operator|.
name|getChild
argument_list|(
literal|1
argument_list|)
decl_stmt|;
name|ArrayList
argument_list|<
name|ASTNode
argument_list|>
name|sampleCols
init|=
operator|new
name|ArrayList
argument_list|<
name|ASTNode
argument_list|>
argument_list|()
decl_stmt|;
if|if
condition|(
name|sampleClause
operator|.
name|getChildCount
argument_list|()
operator|>
literal|2
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|2
init|;
name|i
operator|<
name|sampleClause
operator|.
name|getChildCount
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|sampleCols
operator|.
name|add
argument_list|(
operator|(
name|ASTNode
operator|)
name|sampleClause
operator|.
name|getChild
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|// TODO: For now only support sampling on up to two columns
comment|// Need to change it to list of columns
if|if
condition|(
name|sampleCols
operator|.
name|size
argument_list|()
operator|>
literal|2
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|generateErrorMessage
argument_list|(
operator|(
name|ASTNode
operator|)
name|tabref
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
argument_list|,
name|ErrorMsg
operator|.
name|SAMPLE_RESTRICTION
operator|.
name|getMsg
argument_list|()
argument_list|)
argument_list|)
throw|;
block|}
name|qb
operator|.
name|getParseInfo
argument_list|()
operator|.
name|setTabSample
argument_list|(
name|alias
argument_list|,
operator|new
name|TableSample
argument_list|(
name|unescapeIdentifier
argument_list|(
name|sampleClause
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getText
argument_list|()
argument_list|)
argument_list|,
name|unescapeIdentifier
argument_list|(
name|sampleClause
operator|.
name|getChild
argument_list|(
literal|1
argument_list|)
operator|.
name|getText
argument_list|()
argument_list|)
argument_list|,
name|sampleCols
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|unparseTranslator
operator|.
name|isEnabled
argument_list|()
condition|)
block|{
for|for
control|(
name|ASTNode
name|sampleCol
range|:
name|sampleCols
control|)
block|{
name|unparseTranslator
operator|.
name|addIdentifierTranslation
argument_list|(
operator|(
name|ASTNode
operator|)
name|sampleCol
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|splitSamplePresent
condition|)
block|{
comment|// only CombineHiveInputFormat supports this optimize
name|String
name|inputFormat
init|=
name|HiveConf
operator|.
name|getVar
argument_list|(
name|conf
argument_list|,
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVEINPUTFORMAT
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|inputFormat
operator|.
name|equals
argument_list|(
name|CombineHiveInputFormat
operator|.
name|class
operator|.
name|getName
argument_list|()
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|generateErrorMessage
argument_list|(
operator|(
name|ASTNode
operator|)
name|tabref
operator|.
name|getChild
argument_list|(
literal|1
argument_list|)
argument_list|,
literal|"Percentage sampling is not supported in "
operator|+
name|inputFormat
argument_list|)
argument_list|)
throw|;
block|}
name|ASTNode
name|sampleClause
init|=
operator|(
name|ASTNode
operator|)
name|tabref
operator|.
name|getChild
argument_list|(
literal|1
argument_list|)
decl_stmt|;
name|String
name|alias_id
init|=
name|getAliasId
argument_list|(
name|alias
argument_list|,
name|qb
argument_list|)
decl_stmt|;
name|String
name|strPercentage
init|=
name|unescapeIdentifier
argument_list|(
name|sampleClause
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getText
argument_list|()
argument_list|)
decl_stmt|;
name|Double
name|percent
init|=
name|Double
operator|.
name|valueOf
argument_list|(
name|strPercentage
argument_list|)
operator|.
name|doubleValue
argument_list|()
decl_stmt|;
if|if
condition|(
name|percent
argument_list|<
literal|0
operator|||
name|percent
argument_list|>
literal|100
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|generateErrorMessage
argument_list|(
name|sampleClause
argument_list|,
literal|"Sampling percentage should be between 0 and 100"
argument_list|)
argument_list|)
throw|;
block|}
name|nameToSplitSample
operator|.
name|put
argument_list|(
name|alias_id
argument_list|,
operator|new
name|SplitSample
argument_list|(
name|percent
argument_list|,
name|conf
operator|.
name|getIntVar
argument_list|(
name|ConfVars
operator|.
name|HIVESAMPLERANDOMNUM
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// Insert this map into the stats
name|qb
operator|.
name|setTabAlias
argument_list|(
name|alias
argument_list|,
name|tabIdName
argument_list|)
expr_stmt|;
name|qb
operator|.
name|addAlias
argument_list|(
name|alias
argument_list|)
expr_stmt|;
name|qb
operator|.
name|getParseInfo
argument_list|()
operator|.
name|setSrcForAlias
argument_list|(
name|alias
argument_list|,
name|tableTree
argument_list|)
expr_stmt|;
name|unparseTranslator
operator|.
name|addTableNameTranslation
argument_list|(
name|tableTree
argument_list|)
expr_stmt|;
if|if
condition|(
name|aliasIndex
operator|!=
literal|0
condition|)
block|{
name|unparseTranslator
operator|.
name|addIdentifierTranslation
argument_list|(
operator|(
name|ASTNode
operator|)
name|tabref
operator|.
name|getChild
argument_list|(
name|aliasIndex
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|alias
return|;
block|}
specifier|private
name|String
name|processSubQuery
parameter_list|(
name|QB
name|qb
parameter_list|,
name|ASTNode
name|subq
parameter_list|)
throws|throws
name|SemanticException
block|{
comment|// This is a subquery and must have an alias
if|if
condition|(
name|subq
operator|.
name|getChildCount
argument_list|()
operator|!=
literal|2
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|NO_SUBQUERY_ALIAS
operator|.
name|getMsg
argument_list|(
name|subq
argument_list|)
argument_list|)
throw|;
block|}
name|ASTNode
name|subqref
init|=
operator|(
name|ASTNode
operator|)
name|subq
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|String
name|alias
init|=
name|unescapeIdentifier
argument_list|(
name|subq
operator|.
name|getChild
argument_list|(
literal|1
argument_list|)
operator|.
name|getText
argument_list|()
argument_list|)
decl_stmt|;
comment|// Recursively do the first phase of semantic analysis for the subquery
name|QBExpr
name|qbexpr
init|=
operator|new
name|QBExpr
argument_list|(
name|alias
argument_list|)
decl_stmt|;
name|doPhase1QBExpr
argument_list|(
name|subqref
argument_list|,
name|qbexpr
argument_list|,
name|qb
operator|.
name|getId
argument_list|()
argument_list|,
name|alias
argument_list|)
expr_stmt|;
comment|// If the alias is already there then we have a conflict
if|if
condition|(
name|qb
operator|.
name|exists
argument_list|(
name|alias
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|AMBIGUOUS_TABLE_ALIAS
operator|.
name|getMsg
argument_list|(
name|subq
operator|.
name|getChild
argument_list|(
literal|1
argument_list|)
argument_list|)
argument_list|)
throw|;
block|}
comment|// Insert this map into the stats
name|qb
operator|.
name|setSubqAlias
argument_list|(
name|alias
argument_list|,
name|qbexpr
argument_list|)
expr_stmt|;
name|qb
operator|.
name|addAlias
argument_list|(
name|alias
argument_list|)
expr_stmt|;
name|unparseTranslator
operator|.
name|addIdentifierTranslation
argument_list|(
operator|(
name|ASTNode
operator|)
name|subq
operator|.
name|getChild
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|alias
return|;
block|}
specifier|private
name|boolean
name|isJoinToken
parameter_list|(
name|ASTNode
name|node
parameter_list|)
block|{
if|if
condition|(
operator|(
name|node
operator|.
name|getToken
argument_list|()
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_JOIN
operator|)
operator|||
operator|(
name|node
operator|.
name|getToken
argument_list|()
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_LEFTOUTERJOIN
operator|)
operator|||
operator|(
name|node
operator|.
name|getToken
argument_list|()
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_RIGHTOUTERJOIN
operator|)
operator|||
operator|(
name|node
operator|.
name|getToken
argument_list|()
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_FULLOUTERJOIN
operator|)
operator|||
operator|(
name|node
operator|.
name|getToken
argument_list|()
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_LEFTSEMIJOIN
operator|)
operator|||
operator|(
name|node
operator|.
name|getToken
argument_list|()
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_UNIQUEJOIN
operator|)
condition|)
block|{
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
comment|/**    * Given the AST with TOK_JOIN as the root, get all the aliases for the tables    * or subqueries in the join.    *    * @param qb    * @param join    * @throws SemanticException    */
annotation|@
name|SuppressWarnings
argument_list|(
literal|"nls"
argument_list|)
specifier|private
name|void
name|processJoin
parameter_list|(
name|QB
name|qb
parameter_list|,
name|ASTNode
name|join
parameter_list|)
throws|throws
name|SemanticException
block|{
name|int
name|numChildren
init|=
name|join
operator|.
name|getChildCount
argument_list|()
decl_stmt|;
if|if
condition|(
operator|(
name|numChildren
operator|!=
literal|2
operator|)
operator|&&
operator|(
name|numChildren
operator|!=
literal|3
operator|)
operator|&&
name|join
operator|.
name|getToken
argument_list|()
operator|.
name|getType
argument_list|()
operator|!=
name|HiveParser
operator|.
name|TOK_UNIQUEJOIN
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|generateErrorMessage
argument_list|(
name|join
argument_list|,
literal|"Join with multiple children"
argument_list|)
argument_list|)
throw|;
block|}
for|for
control|(
name|int
name|num
init|=
literal|0
init|;
name|num
operator|<
name|numChildren
condition|;
name|num
operator|++
control|)
block|{
name|ASTNode
name|child
init|=
operator|(
name|ASTNode
operator|)
name|join
operator|.
name|getChild
argument_list|(
name|num
argument_list|)
decl_stmt|;
if|if
condition|(
name|child
operator|.
name|getToken
argument_list|()
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_TABREF
condition|)
block|{
name|processTable
argument_list|(
name|qb
argument_list|,
name|child
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|child
operator|.
name|getToken
argument_list|()
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_SUBQUERY
condition|)
block|{
name|processSubQuery
argument_list|(
name|qb
argument_list|,
name|child
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|child
operator|.
name|getToken
argument_list|()
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_LATERAL_VIEW
condition|)
block|{
comment|// SELECT * FROM src1 LATERAL VIEW udtf() AS myTable JOIN src2 ...
comment|// is not supported. Instead, the lateral view must be in a subquery
comment|// SELECT * FROM (SELECT * FROM src1 LATERAL VIEW udtf() AS myTable) a
comment|// JOIN src2 ...
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|LATERAL_VIEW_WITH_JOIN
operator|.
name|getMsg
argument_list|(
name|join
argument_list|)
argument_list|)
throw|;
block|}
elseif|else
if|if
condition|(
name|isJoinToken
argument_list|(
name|child
argument_list|)
condition|)
block|{
name|processJoin
argument_list|(
name|qb
argument_list|,
name|child
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**    * Given the AST with TOK_LATERAL_VIEW as the root, get the alias for the    * table or subquery in the lateral view and also make a mapping from the    * alias to all the lateral view AST's.    *    * @param qb    * @param lateralView    * @return the alias for the table/subquery    * @throws SemanticException    */
specifier|private
name|String
name|processLateralView
parameter_list|(
name|QB
name|qb
parameter_list|,
name|ASTNode
name|lateralView
parameter_list|)
throws|throws
name|SemanticException
block|{
name|int
name|numChildren
init|=
name|lateralView
operator|.
name|getChildCount
argument_list|()
decl_stmt|;
assert|assert
operator|(
name|numChildren
operator|==
literal|2
operator|)
assert|;
name|ASTNode
name|next
init|=
operator|(
name|ASTNode
operator|)
name|lateralView
operator|.
name|getChild
argument_list|(
literal|1
argument_list|)
decl_stmt|;
name|String
name|alias
init|=
literal|null
decl_stmt|;
switch|switch
condition|(
name|next
operator|.
name|getToken
argument_list|()
operator|.
name|getType
argument_list|()
condition|)
block|{
case|case
name|HiveParser
operator|.
name|TOK_TABREF
case|:
name|alias
operator|=
name|processTable
argument_list|(
name|qb
argument_list|,
name|next
argument_list|)
expr_stmt|;
break|break;
case|case
name|HiveParser
operator|.
name|TOK_SUBQUERY
case|:
name|alias
operator|=
name|processSubQuery
argument_list|(
name|qb
argument_list|,
name|next
argument_list|)
expr_stmt|;
break|break;
case|case
name|HiveParser
operator|.
name|TOK_LATERAL_VIEW
case|:
name|alias
operator|=
name|processLateralView
argument_list|(
name|qb
argument_list|,
name|next
argument_list|)
expr_stmt|;
break|break;
default|default:
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|LATERAL_VIEW_INVALID_CHILD
operator|.
name|getMsg
argument_list|(
name|lateralView
argument_list|)
argument_list|)
throw|;
block|}
name|alias
operator|=
name|alias
operator|.
name|toLowerCase
argument_list|()
expr_stmt|;
name|qb
operator|.
name|getParseInfo
argument_list|()
operator|.
name|addLateralViewForAlias
argument_list|(
name|alias
argument_list|,
name|lateralView
argument_list|)
expr_stmt|;
name|qb
operator|.
name|addAlias
argument_list|(
name|alias
argument_list|)
expr_stmt|;
return|return
name|alias
return|;
block|}
comment|/**    * Phase 1: (including, but not limited to):    *    * 1. Gets all the aliases for all the tables / subqueries and makes the    * appropriate mapping in aliasToTabs, aliasToSubq 2. Gets the location of the    * destination and names the clase "inclause" + i 3. Creates a map from a    * string representation of an aggregation tree to the actual aggregation AST    * 4. Creates a mapping from the clause name to the select expression AST in    * destToSelExpr 5. Creates a mapping from a table alias to the lateral view    * AST's in aliasToLateralViews    *    * @param ast    * @param qb    * @param ctx_1    * @throws SemanticException    */
annotation|@
name|SuppressWarnings
argument_list|(
block|{
literal|"fallthrough"
block|,
literal|"nls"
block|}
argument_list|)
specifier|public
name|void
name|doPhase1
parameter_list|(
name|ASTNode
name|ast
parameter_list|,
name|QB
name|qb
parameter_list|,
name|Phase1Ctx
name|ctx_1
parameter_list|)
throws|throws
name|SemanticException
block|{
name|QBParseInfo
name|qbp
init|=
name|qb
operator|.
name|getParseInfo
argument_list|()
decl_stmt|;
name|boolean
name|skipRecursion
init|=
literal|false
decl_stmt|;
if|if
condition|(
name|ast
operator|.
name|getToken
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|skipRecursion
operator|=
literal|true
expr_stmt|;
switch|switch
condition|(
name|ast
operator|.
name|getToken
argument_list|()
operator|.
name|getType
argument_list|()
condition|)
block|{
case|case
name|HiveParser
operator|.
name|TOK_SELECTDI
case|:
name|qb
operator|.
name|countSelDi
argument_list|()
expr_stmt|;
comment|// fall through
case|case
name|HiveParser
operator|.
name|TOK_SELECT
case|:
name|qb
operator|.
name|countSel
argument_list|()
expr_stmt|;
name|qbp
operator|.
name|setSelExprForClause
argument_list|(
name|ctx_1
operator|.
name|dest
argument_list|,
name|ast
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|ASTNode
operator|)
name|ast
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|)
operator|.
name|getToken
argument_list|()
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_HINTLIST
condition|)
block|{
name|qbp
operator|.
name|setHints
argument_list|(
operator|(
name|ASTNode
operator|)
name|ast
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|LinkedHashMap
argument_list|<
name|String
argument_list|,
name|ASTNode
argument_list|>
name|aggregations
init|=
name|doPhase1GetAggregationsFromSelect
argument_list|(
name|ast
argument_list|)
decl_stmt|;
name|doPhase1GetColumnAliasesFromSelect
argument_list|(
name|ast
argument_list|,
name|qbp
argument_list|)
expr_stmt|;
name|qbp
operator|.
name|setAggregationExprsForClause
argument_list|(
name|ctx_1
operator|.
name|dest
argument_list|,
name|aggregations
argument_list|)
expr_stmt|;
name|qbp
operator|.
name|setDistinctFuncExprsForClause
argument_list|(
name|ctx_1
operator|.
name|dest
argument_list|,
name|doPhase1GetDistinctFuncExprs
argument_list|(
name|aggregations
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|HiveParser
operator|.
name|TOK_WHERE
case|:
name|qbp
operator|.
name|setWhrExprForClause
argument_list|(
name|ctx_1
operator|.
name|dest
argument_list|,
name|ast
argument_list|)
expr_stmt|;
break|break;
case|case
name|HiveParser
operator|.
name|TOK_INSERT_INTO
case|:
name|String
name|tab_name
init|=
name|getUnescapedName
argument_list|(
operator|(
name|ASTNode
operator|)
name|ast
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|qbp
operator|.
name|addInsertIntoTable
argument_list|(
name|tab_name
argument_list|)
expr_stmt|;
case|case
name|HiveParser
operator|.
name|TOK_DESTINATION
case|:
name|ctx_1
operator|.
name|dest
operator|=
literal|"insclause-"
operator|+
name|ctx_1
operator|.
name|nextNum
expr_stmt|;
name|ctx_1
operator|.
name|nextNum
operator|++
expr_stmt|;
comment|// is there a insert in the subquery
if|if
condition|(
name|qbp
operator|.
name|getIsSubQ
argument_list|()
condition|)
block|{
name|ASTNode
name|ch
init|=
operator|(
name|ASTNode
operator|)
name|ast
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|ch
operator|.
name|getToken
argument_list|()
operator|.
name|getType
argument_list|()
operator|!=
name|HiveParser
operator|.
name|TOK_DIR
operator|)
operator|||
operator|(
operator|(
operator|(
name|ASTNode
operator|)
name|ch
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|)
operator|.
name|getToken
argument_list|()
operator|.
name|getType
argument_list|()
operator|!=
name|HiveParser
operator|.
name|TOK_TMP_FILE
operator|)
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|NO_INSERT_INSUBQUERY
operator|.
name|getMsg
argument_list|(
name|ast
argument_list|)
argument_list|)
throw|;
block|}
block|}
name|qbp
operator|.
name|setDestForClause
argument_list|(
name|ctx_1
operator|.
name|dest
argument_list|,
operator|(
name|ASTNode
operator|)
name|ast
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|HiveParser
operator|.
name|TOK_FROM
case|:
name|int
name|child_count
init|=
name|ast
operator|.
name|getChildCount
argument_list|()
decl_stmt|;
if|if
condition|(
name|child_count
operator|!=
literal|1
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|generateErrorMessage
argument_list|(
name|ast
argument_list|,
literal|"Multiple Children "
operator|+
name|child_count
argument_list|)
argument_list|)
throw|;
block|}
comment|// Check if this is a subquery / lateral view
name|ASTNode
name|frm
init|=
operator|(
name|ASTNode
operator|)
name|ast
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|frm
operator|.
name|getToken
argument_list|()
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_TABREF
condition|)
block|{
name|processTable
argument_list|(
name|qb
argument_list|,
name|frm
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|frm
operator|.
name|getToken
argument_list|()
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_SUBQUERY
condition|)
block|{
name|processSubQuery
argument_list|(
name|qb
argument_list|,
name|frm
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|frm
operator|.
name|getToken
argument_list|()
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_LATERAL_VIEW
condition|)
block|{
name|processLateralView
argument_list|(
name|qb
argument_list|,
name|frm
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|isJoinToken
argument_list|(
name|frm
argument_list|)
condition|)
block|{
name|processJoin
argument_list|(
name|qb
argument_list|,
name|frm
argument_list|)
expr_stmt|;
name|qbp
operator|.
name|setJoinExpr
argument_list|(
name|frm
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|HiveParser
operator|.
name|TOK_CLUSTERBY
case|:
comment|// Get the clusterby aliases - these are aliased to the entries in the
comment|// select list
name|qbp
operator|.
name|setClusterByExprForClause
argument_list|(
name|ctx_1
operator|.
name|dest
argument_list|,
name|ast
argument_list|)
expr_stmt|;
break|break;
case|case
name|HiveParser
operator|.
name|TOK_DISTRIBUTEBY
case|:
comment|// Get the distribute by aliases - these are aliased to the entries in
comment|// the
comment|// select list
name|qbp
operator|.
name|setDistributeByExprForClause
argument_list|(
name|ctx_1
operator|.
name|dest
argument_list|,
name|ast
argument_list|)
expr_stmt|;
if|if
condition|(
name|qbp
operator|.
name|getClusterByForClause
argument_list|(
name|ctx_1
operator|.
name|dest
argument_list|)
operator|!=
literal|null
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|generateErrorMessage
argument_list|(
name|ast
argument_list|,
name|ErrorMsg
operator|.
name|CLUSTERBY_DISTRIBUTEBY_CONFLICT
operator|.
name|getMsg
argument_list|()
argument_list|)
argument_list|)
throw|;
block|}
elseif|else
if|if
condition|(
name|qbp
operator|.
name|getOrderByForClause
argument_list|(
name|ctx_1
operator|.
name|dest
argument_list|)
operator|!=
literal|null
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|generateErrorMessage
argument_list|(
name|ast
argument_list|,
name|ErrorMsg
operator|.
name|ORDERBY_DISTRIBUTEBY_CONFLICT
operator|.
name|getMsg
argument_list|()
argument_list|)
argument_list|)
throw|;
block|}
break|break;
case|case
name|HiveParser
operator|.
name|TOK_SORTBY
case|:
comment|// Get the sort by aliases - these are aliased to the entries in the
comment|// select list
name|qbp
operator|.
name|setSortByExprForClause
argument_list|(
name|ctx_1
operator|.
name|dest
argument_list|,
name|ast
argument_list|)
expr_stmt|;
if|if
condition|(
name|qbp
operator|.
name|getClusterByForClause
argument_list|(
name|ctx_1
operator|.
name|dest
argument_list|)
operator|!=
literal|null
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|generateErrorMessage
argument_list|(
name|ast
argument_list|,
name|ErrorMsg
operator|.
name|CLUSTERBY_SORTBY_CONFLICT
operator|.
name|getMsg
argument_list|()
argument_list|)
argument_list|)
throw|;
block|}
elseif|else
if|if
condition|(
name|qbp
operator|.
name|getOrderByForClause
argument_list|(
name|ctx_1
operator|.
name|dest
argument_list|)
operator|!=
literal|null
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|generateErrorMessage
argument_list|(
name|ast
argument_list|,
name|ErrorMsg
operator|.
name|ORDERBY_SORTBY_CONFLICT
operator|.
name|getMsg
argument_list|()
argument_list|)
argument_list|)
throw|;
block|}
break|break;
case|case
name|HiveParser
operator|.
name|TOK_ORDERBY
case|:
comment|// Get the order by aliases - these are aliased to the entries in the
comment|// select list
name|qbp
operator|.
name|setOrderByExprForClause
argument_list|(
name|ctx_1
operator|.
name|dest
argument_list|,
name|ast
argument_list|)
expr_stmt|;
if|if
condition|(
name|qbp
operator|.
name|getClusterByForClause
argument_list|(
name|ctx_1
operator|.
name|dest
argument_list|)
operator|!=
literal|null
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|generateErrorMessage
argument_list|(
name|ast
argument_list|,
name|ErrorMsg
operator|.
name|CLUSTERBY_ORDERBY_CONFLICT
operator|.
name|getMsg
argument_list|()
argument_list|)
argument_list|)
throw|;
block|}
break|break;
case|case
name|HiveParser
operator|.
name|TOK_GROUPBY
case|:
comment|// Get the groupby aliases - these are aliased to the entries in the
comment|// select list
if|if
condition|(
name|qbp
operator|.
name|getSelForClause
argument_list|(
name|ctx_1
operator|.
name|dest
argument_list|)
operator|.
name|getToken
argument_list|()
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_SELECTDI
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|generateErrorMessage
argument_list|(
name|ast
argument_list|,
name|ErrorMsg
operator|.
name|SELECT_DISTINCT_WITH_GROUPBY
operator|.
name|getMsg
argument_list|()
argument_list|)
argument_list|)
throw|;
block|}
name|qbp
operator|.
name|setGroupByExprForClause
argument_list|(
name|ctx_1
operator|.
name|dest
argument_list|,
name|ast
argument_list|)
expr_stmt|;
name|skipRecursion
operator|=
literal|true
expr_stmt|;
break|break;
case|case
name|HiveParser
operator|.
name|TOK_HAVING
case|:
name|qbp
operator|.
name|setHavingExprForClause
argument_list|(
name|ctx_1
operator|.
name|dest
argument_list|,
name|ast
argument_list|)
expr_stmt|;
name|qbp
operator|.
name|addAggregationExprsForClause
argument_list|(
name|ctx_1
operator|.
name|dest
argument_list|,
name|doPhase1GetAggregationsFromSelect
argument_list|(
name|ast
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|HiveParser
operator|.
name|TOK_LIMIT
case|:
name|qbp
operator|.
name|setDestLimit
argument_list|(
name|ctx_1
operator|.
name|dest
argument_list|,
operator|new
name|Integer
argument_list|(
name|ast
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getText
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|HiveParser
operator|.
name|TOK_ANALYZE
case|:
comment|// Case of analyze command
name|String
name|table_name
init|=
name|getUnescapedName
argument_list|(
operator|(
name|ASTNode
operator|)
name|ast
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|qb
operator|.
name|setTabAlias
argument_list|(
name|table_name
argument_list|,
name|table_name
argument_list|)
expr_stmt|;
name|qb
operator|.
name|addAlias
argument_list|(
name|table_name
argument_list|)
expr_stmt|;
name|qb
operator|.
name|getParseInfo
argument_list|()
operator|.
name|setIsAnalyzeCommand
argument_list|(
literal|true
argument_list|)
expr_stmt|;
comment|// Allow analyze the whole table and dynamic partitions
name|HiveConf
operator|.
name|setVar
argument_list|(
name|conf
argument_list|,
name|HiveConf
operator|.
name|ConfVars
operator|.
name|DYNAMICPARTITIONINGMODE
argument_list|,
literal|"nonstrict"
argument_list|)
expr_stmt|;
name|HiveConf
operator|.
name|setVar
argument_list|(
name|conf
argument_list|,
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVEMAPREDMODE
argument_list|,
literal|"nonstrict"
argument_list|)
expr_stmt|;
break|break;
case|case
name|HiveParser
operator|.
name|TOK_UNION
case|:
comment|// currently, we dont support subq1 union subq2 - the user has to
comment|// explicitly say:
comment|// select * from (subq1 union subq2) subqalias
if|if
condition|(
operator|!
name|qbp
operator|.
name|getIsSubQ
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|generateErrorMessage
argument_list|(
name|ast
argument_list|,
name|ErrorMsg
operator|.
name|UNION_NOTIN_SUBQ
operator|.
name|getMsg
argument_list|()
argument_list|)
argument_list|)
throw|;
block|}
default|default:
name|skipRecursion
operator|=
literal|false
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|skipRecursion
condition|)
block|{
comment|// Iterate over the rest of the children
name|int
name|child_count
init|=
name|ast
operator|.
name|getChildCount
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|child_pos
init|=
literal|0
init|;
name|child_pos
operator|<
name|child_count
condition|;
operator|++
name|child_pos
control|)
block|{
comment|// Recurse
name|doPhase1
argument_list|(
operator|(
name|ASTNode
operator|)
name|ast
operator|.
name|getChild
argument_list|(
name|child_pos
argument_list|)
argument_list|,
name|qb
argument_list|,
name|ctx_1
argument_list|)
expr_stmt|;
block|}
block|}
block|}
specifier|private
name|void
name|getMetaData
parameter_list|(
name|QBExpr
name|qbexpr
parameter_list|)
throws|throws
name|SemanticException
block|{
if|if
condition|(
name|qbexpr
operator|.
name|getOpcode
argument_list|()
operator|==
name|QBExpr
operator|.
name|Opcode
operator|.
name|NULLOP
condition|)
block|{
name|getMetaData
argument_list|(
name|qbexpr
operator|.
name|getQB
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|getMetaData
argument_list|(
name|qbexpr
operator|.
name|getQBExpr1
argument_list|()
argument_list|)
expr_stmt|;
name|getMetaData
argument_list|(
name|qbexpr
operator|.
name|getQBExpr2
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"nls"
argument_list|)
specifier|public
name|void
name|getMetaData
parameter_list|(
name|QB
name|qb
parameter_list|)
throws|throws
name|SemanticException
block|{
try|try
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Get metadata for source tables"
argument_list|)
expr_stmt|;
comment|// Go over the tables and populate the related structures.
comment|// We have to materialize the table alias list since we might
comment|// modify it in the middle for view rewrite.
name|List
argument_list|<
name|String
argument_list|>
name|tabAliases
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|(
name|qb
operator|.
name|getTabAliases
argument_list|()
argument_list|)
decl_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|aliasToViewName
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|String
name|alias
range|:
name|tabAliases
control|)
block|{
name|String
name|tab_name
init|=
name|qb
operator|.
name|getTabNameForAlias
argument_list|(
name|alias
argument_list|)
decl_stmt|;
name|Table
name|tab
init|=
literal|null
decl_stmt|;
try|try
block|{
name|tab
operator|=
name|db
operator|.
name|getTable
argument_list|(
name|tab_name
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InvalidTableException
name|ite
parameter_list|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|INVALID_TABLE
operator|.
name|getMsg
argument_list|(
name|qb
operator|.
name|getParseInfo
argument_list|()
operator|.
name|getSrcForAlias
argument_list|(
name|alias
argument_list|)
argument_list|)
argument_list|)
throw|;
block|}
comment|// Disallow INSERT INTO on bucketized tables
if|if
condition|(
name|qb
operator|.
name|getParseInfo
argument_list|()
operator|.
name|isInsertIntoTable
argument_list|(
name|tab_name
argument_list|)
operator|&&
name|tab
operator|.
name|getNumBuckets
argument_list|()
operator|>
literal|0
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|INSERT_INTO_BUCKETIZED_TABLE
operator|.
name|getMsg
argument_list|(
literal|"Table: "
operator|+
name|tab_name
argument_list|)
argument_list|)
throw|;
block|}
comment|// We check offline of the table, as if people only select from an
comment|// non-existing partition of an offline table, the partition won't
comment|// be added to inputs and validate() won't have the information to
comment|// check the table's offline status.
comment|// TODO: Modify the code to remove the checking here and consolidate
comment|// it in validate()
comment|//
if|if
condition|(
name|tab
operator|.
name|isOffline
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|OFFLINE_TABLE_OR_PARTITION
operator|.
name|getMsg
argument_list|(
literal|"Table "
operator|+
name|getUnescapedName
argument_list|(
name|qb
operator|.
name|getParseInfo
argument_list|()
operator|.
name|getSrcForAlias
argument_list|(
name|alias
argument_list|)
argument_list|)
argument_list|)
argument_list|)
throw|;
block|}
if|if
condition|(
name|tab
operator|.
name|isView
argument_list|()
condition|)
block|{
comment|// TODO: add support to referencing views in foreign databases.
if|if
condition|(
operator|!
name|tab
operator|.
name|getDbName
argument_list|()
operator|.
name|equals
argument_list|(
name|db
operator|.
name|getCurrentDatabase
argument_list|()
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|INVALID_TABLE_ALIAS
operator|.
name|getMsg
argument_list|(
literal|"Referencing view from foreign databases is not supported."
argument_list|)
argument_list|)
throw|;
block|}
if|if
condition|(
name|qb
operator|.
name|getParseInfo
argument_list|()
operator|.
name|isAnalyzeCommand
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|ANALYZE_VIEW
operator|.
name|getMsg
argument_list|()
argument_list|)
throw|;
block|}
name|String
name|fullViewName
init|=
name|tab
operator|.
name|getDbName
argument_list|()
operator|+
literal|"."
operator|+
name|tab
operator|.
name|getTableName
argument_list|()
decl_stmt|;
comment|// Prevent view cycles
if|if
condition|(
name|viewsExpanded
operator|.
name|contains
argument_list|(
name|fullViewName
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
literal|"Recursive view "
operator|+
name|fullViewName
operator|+
literal|" detected (cycle: "
operator|+
name|StringUtils
operator|.
name|join
argument_list|(
name|viewsExpanded
argument_list|,
literal|" -> "
argument_list|)
operator|+
literal|" -> "
operator|+
name|fullViewName
operator|+
literal|")."
argument_list|)
throw|;
block|}
name|replaceViewReferenceWithDefinition
argument_list|(
name|qb
argument_list|,
name|tab
argument_list|,
name|tab_name
argument_list|,
name|alias
argument_list|)
expr_stmt|;
name|aliasToViewName
operator|.
name|put
argument_list|(
name|alias
argument_list|,
name|fullViewName
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|!
name|InputFormat
operator|.
name|class
operator|.
name|isAssignableFrom
argument_list|(
name|tab
operator|.
name|getInputFormatClass
argument_list|()
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|generateErrorMessage
argument_list|(
name|qb
operator|.
name|getParseInfo
argument_list|()
operator|.
name|getSrcForAlias
argument_list|(
name|alias
argument_list|)
argument_list|,
name|ErrorMsg
operator|.
name|INVALID_INPUT_FORMAT_TYPE
operator|.
name|getMsg
argument_list|()
argument_list|)
argument_list|)
throw|;
block|}
name|qb
operator|.
name|getMetaData
argument_list|()
operator|.
name|setSrcForAlias
argument_list|(
name|alias
argument_list|,
name|tab
argument_list|)
expr_stmt|;
if|if
condition|(
name|qb
operator|.
name|getParseInfo
argument_list|()
operator|.
name|isAnalyzeCommand
argument_list|()
condition|)
block|{
name|tableSpec
name|ts
init|=
operator|new
name|tableSpec
argument_list|(
name|db
argument_list|,
name|conf
argument_list|,
operator|(
name|ASTNode
operator|)
name|ast
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|ts
operator|.
name|specType
operator|==
name|SpecType
operator|.
name|DYNAMIC_PARTITION
condition|)
block|{
comment|// dynamic partitions
try|try
block|{
name|ts
operator|.
name|partitions
operator|=
name|db
operator|.
name|getPartitionsByNames
argument_list|(
name|ts
operator|.
name|tableHandle
argument_list|,
name|ts
operator|.
name|partSpec
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|HiveException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|generateErrorMessage
argument_list|(
name|qb
operator|.
name|getParseInfo
argument_list|()
operator|.
name|getSrcForAlias
argument_list|(
name|alias
argument_list|)
argument_list|,
literal|"Cannot get partitions for "
operator|+
name|ts
operator|.
name|partSpec
argument_list|)
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
name|qb
operator|.
name|getParseInfo
argument_list|()
operator|.
name|addTableSpec
argument_list|(
name|alias
argument_list|,
name|ts
argument_list|)
expr_stmt|;
block|}
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"Get metadata for subqueries"
argument_list|)
expr_stmt|;
comment|// Go over the subqueries and getMetaData for these
for|for
control|(
name|String
name|alias
range|:
name|qb
operator|.
name|getSubqAliases
argument_list|()
control|)
block|{
name|boolean
name|wasView
init|=
name|aliasToViewName
operator|.
name|containsKey
argument_list|(
name|alias
argument_list|)
decl_stmt|;
if|if
condition|(
name|wasView
condition|)
block|{
name|viewsExpanded
operator|.
name|add
argument_list|(
name|aliasToViewName
operator|.
name|get
argument_list|(
name|alias
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|QBExpr
name|qbexpr
init|=
name|qb
operator|.
name|getSubqForAlias
argument_list|(
name|alias
argument_list|)
decl_stmt|;
name|getMetaData
argument_list|(
name|qbexpr
argument_list|)
expr_stmt|;
if|if
condition|(
name|wasView
condition|)
block|{
name|viewsExpanded
operator|.
name|remove
argument_list|(
name|viewsExpanded
operator|.
name|size
argument_list|()
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"Get metadata for destination tables"
argument_list|)
expr_stmt|;
comment|// Go over all the destination structures and populate the related
comment|// metadata
name|QBParseInfo
name|qbp
init|=
name|qb
operator|.
name|getParseInfo
argument_list|()
decl_stmt|;
for|for
control|(
name|String
name|name
range|:
name|qbp
operator|.
name|getClauseNamesForDest
argument_list|()
control|)
block|{
name|ASTNode
name|ast
init|=
name|qbp
operator|.
name|getDestForClause
argument_list|(
name|name
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|ast
operator|.
name|getToken
argument_list|()
operator|.
name|getType
argument_list|()
condition|)
block|{
case|case
name|HiveParser
operator|.
name|TOK_TAB
case|:
block|{
name|tableSpec
name|ts
init|=
operator|new
name|tableSpec
argument_list|(
name|db
argument_list|,
name|conf
argument_list|,
name|ast
argument_list|)
decl_stmt|;
if|if
condition|(
name|ts
operator|.
name|tableHandle
operator|.
name|isView
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|DML_AGAINST_VIEW
operator|.
name|getMsg
argument_list|()
argument_list|)
throw|;
block|}
name|Class
argument_list|<
name|?
argument_list|>
name|outputFormatClass
init|=
name|ts
operator|.
name|tableHandle
operator|.
name|getOutputFormatClass
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|HiveOutputFormat
operator|.
name|class
operator|.
name|isAssignableFrom
argument_list|(
name|outputFormatClass
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|INVALID_OUTPUT_FORMAT_TYPE
operator|.
name|getMsg
argument_list|(
name|ast
argument_list|,
literal|"The class is "
operator|+
name|outputFormatClass
operator|.
name|toString
argument_list|()
argument_list|)
argument_list|)
throw|;
block|}
comment|// tableSpec ts is got from the query (user specified),
comment|// which means the user didn't specify partitions in their query,
comment|// but whether the table itself is partitioned is not know.
if|if
condition|(
name|ts
operator|.
name|specType
operator|!=
name|SpecType
operator|.
name|STATIC_PARTITION
condition|)
block|{
comment|// This is a table or dynamic partition
name|qb
operator|.
name|getMetaData
argument_list|()
operator|.
name|setDestForAlias
argument_list|(
name|name
argument_list|,
name|ts
operator|.
name|tableHandle
argument_list|)
expr_stmt|;
comment|// has dynamic as well as static partitions
if|if
condition|(
name|ts
operator|.
name|partSpec
operator|!=
literal|null
operator|&&
name|ts
operator|.
name|partSpec
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
name|qb
operator|.
name|getMetaData
argument_list|()
operator|.
name|setPartSpecForAlias
argument_list|(
name|name
argument_list|,
name|ts
operator|.
name|partSpec
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// This is a partition
name|qb
operator|.
name|getMetaData
argument_list|()
operator|.
name|setDestForAlias
argument_list|(
name|name
argument_list|,
name|ts
operator|.
name|partHandle
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|HiveConf
operator|.
name|getBoolVar
argument_list|(
name|conf
argument_list|,
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVESTATSAUTOGATHER
argument_list|)
condition|)
block|{
comment|// Set that variable to automatically collect stats during the MapReduce job
name|qb
operator|.
name|getParseInfo
argument_list|()
operator|.
name|setIsInsertToTable
argument_list|(
literal|true
argument_list|)
expr_stmt|;
comment|// Add the table spec for the destination table.
name|qb
operator|.
name|getParseInfo
argument_list|()
operator|.
name|addTableSpec
argument_list|(
name|ts
operator|.
name|tableName
operator|.
name|toLowerCase
argument_list|()
argument_list|,
name|ts
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
case|case
name|HiveParser
operator|.
name|TOK_LOCAL_DIR
case|:
case|case
name|HiveParser
operator|.
name|TOK_DIR
case|:
block|{
comment|// This is a dfs file
name|String
name|fname
init|=
name|stripQuotes
argument_list|(
name|ast
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getText
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
operator|!
name|qb
operator|.
name|getParseInfo
argument_list|()
operator|.
name|getIsSubQ
argument_list|()
operator|)
operator|&&
operator|(
operator|(
operator|(
name|ASTNode
operator|)
name|ast
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|)
operator|.
name|getToken
argument_list|()
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_TMP_FILE
operator|)
condition|)
block|{
if|if
condition|(
name|qb
operator|.
name|isCTAS
argument_list|()
condition|)
block|{
name|qb
operator|.
name|setIsQuery
argument_list|(
literal|false
argument_list|)
expr_stmt|;
name|ctx
operator|.
name|setResDir
argument_list|(
literal|null
argument_list|)
expr_stmt|;
name|ctx
operator|.
name|setResFile
argument_list|(
literal|null
argument_list|)
expr_stmt|;
comment|// allocate a temporary output dir on the location of the table
name|String
name|location
init|=
name|conf
operator|.
name|getVar
argument_list|(
name|HiveConf
operator|.
name|ConfVars
operator|.
name|METASTOREWAREHOUSE
argument_list|)
decl_stmt|;
try|try
block|{
name|fname
operator|=
name|ctx
operator|.
name|getExternalTmpFileURI
argument_list|(
name|FileUtils
operator|.
name|makeQualified
argument_list|(
operator|new
name|Path
argument_list|(
name|location
argument_list|)
argument_list|,
name|conf
argument_list|)
operator|.
name|toUri
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|generateErrorMessage
argument_list|(
name|ast
argument_list|,
literal|"Error creating temporary folder on: "
operator|+
name|location
argument_list|)
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
else|else
block|{
name|qb
operator|.
name|setIsQuery
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|fname
operator|=
name|ctx
operator|.
name|getMRTmpFileURI
argument_list|()
expr_stmt|;
name|ctx
operator|.
name|setResDir
argument_list|(
operator|new
name|Path
argument_list|(
name|fname
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|qb
operator|.
name|getMetaData
argument_list|()
operator|.
name|setDestForAlias
argument_list|(
name|name
argument_list|,
name|fname
argument_list|,
operator|(
name|ast
operator|.
name|getToken
argument_list|()
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_DIR
operator|)
argument_list|)
expr_stmt|;
break|break;
block|}
default|default:
throw|throw
operator|new
name|SemanticException
argument_list|(
name|generateErrorMessage
argument_list|(
name|ast
argument_list|,
literal|"Unknown Token Type "
operator|+
name|ast
operator|.
name|getToken
argument_list|()
operator|.
name|getType
argument_list|()
argument_list|)
argument_list|)
throw|;
block|}
block|}
block|}
catch|catch
parameter_list|(
name|HiveException
name|e
parameter_list|)
block|{
comment|// Has to use full name to make sure it does not conflict with
comment|// org.apache.commons.lang.StringUtils
name|LOG
operator|.
name|error
argument_list|(
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|StringUtils
operator|.
name|stringifyException
argument_list|(
name|e
argument_list|)
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|SemanticException
argument_list|(
name|e
operator|.
name|getMessage
argument_list|()
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
specifier|private
name|void
name|replaceViewReferenceWithDefinition
parameter_list|(
name|QB
name|qb
parameter_list|,
name|Table
name|tab
parameter_list|,
name|String
name|tab_name
parameter_list|,
name|String
name|alias
parameter_list|)
throws|throws
name|SemanticException
block|{
name|ParseDriver
name|pd
init|=
operator|new
name|ParseDriver
argument_list|()
decl_stmt|;
name|ASTNode
name|viewTree
decl_stmt|;
specifier|final
name|ASTNodeOrigin
name|viewOrigin
init|=
operator|new
name|ASTNodeOrigin
argument_list|(
literal|"VIEW"
argument_list|,
name|tab
operator|.
name|getTableName
argument_list|()
argument_list|,
name|tab
operator|.
name|getViewExpandedText
argument_list|()
argument_list|,
name|alias
argument_list|,
name|qb
operator|.
name|getParseInfo
argument_list|()
operator|.
name|getSrcForAlias
argument_list|(
name|alias
argument_list|)
argument_list|)
decl_stmt|;
try|try
block|{
name|String
name|viewText
init|=
name|tab
operator|.
name|getViewExpandedText
argument_list|()
decl_stmt|;
comment|// Reparse text, passing null for context to avoid clobbering
comment|// the top-level token stream.
name|ASTNode
name|tree
init|=
name|pd
operator|.
name|parse
argument_list|(
name|viewText
argument_list|,
literal|null
argument_list|)
decl_stmt|;
name|tree
operator|=
name|ParseUtils
operator|.
name|findRootNonNullToken
argument_list|(
name|tree
argument_list|)
expr_stmt|;
name|viewTree
operator|=
name|tree
expr_stmt|;
name|Dispatcher
name|nodeOriginDispatcher
init|=
operator|new
name|Dispatcher
argument_list|()
block|{
specifier|public
name|Object
name|dispatch
parameter_list|(
name|Node
name|nd
parameter_list|,
name|java
operator|.
name|util
operator|.
name|Stack
argument_list|<
name|Node
argument_list|>
name|stack
parameter_list|,
name|Object
modifier|...
name|nodeOutputs
parameter_list|)
block|{
operator|(
operator|(
name|ASTNode
operator|)
name|nd
operator|)
operator|.
name|setOrigin
argument_list|(
name|viewOrigin
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
block|}
decl_stmt|;
name|GraphWalker
name|nodeOriginTagger
init|=
operator|new
name|DefaultGraphWalker
argument_list|(
name|nodeOriginDispatcher
argument_list|)
decl_stmt|;
name|nodeOriginTagger
operator|.
name|startWalking
argument_list|(
name|java
operator|.
name|util
operator|.
name|Collections
operator|.
expr|<
name|Node
operator|>
name|singleton
argument_list|(
name|viewTree
argument_list|)
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|ParseException
name|e
parameter_list|)
block|{
comment|// A user could encounter this if a stored view definition contains
comment|// an old SQL construct which has been eliminated in a later Hive
comment|// version, so we need to provide full debugging info to help
comment|// with fixing the view definition.
name|LOG
operator|.
name|error
argument_list|(
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|StringUtils
operator|.
name|stringifyException
argument_list|(
name|e
argument_list|)
argument_list|)
expr_stmt|;
name|StringBuilder
name|sb
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|sb
operator|.
name|append
argument_list|(
name|e
operator|.
name|getMessage
argument_list|()
argument_list|)
expr_stmt|;
name|ErrorMsg
operator|.
name|renderOrigin
argument_list|(
name|sb
argument_list|,
name|viewOrigin
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|SemanticException
argument_list|(
name|sb
operator|.
name|toString
argument_list|()
argument_list|,
name|e
argument_list|)
throw|;
block|}
name|QBExpr
name|qbexpr
init|=
operator|new
name|QBExpr
argument_list|(
name|alias
argument_list|)
decl_stmt|;
name|doPhase1QBExpr
argument_list|(
name|viewTree
argument_list|,
name|qbexpr
argument_list|,
name|qb
operator|.
name|getId
argument_list|()
argument_list|,
name|alias
argument_list|)
expr_stmt|;
name|qb
operator|.
name|rewriteViewToSubq
argument_list|(
name|alias
argument_list|,
name|tab_name
argument_list|,
name|qbexpr
argument_list|)
expr_stmt|;
block|}
specifier|private
name|boolean
name|isPresent
parameter_list|(
name|String
index|[]
name|list
parameter_list|,
name|String
name|elem
parameter_list|)
block|{
for|for
control|(
name|String
name|s
range|:
name|list
control|)
block|{
if|if
condition|(
name|s
operator|.
name|toLowerCase
argument_list|()
operator|.
name|equals
argument_list|(
name|elem
argument_list|)
condition|)
block|{
return|return
literal|true
return|;
block|}
block|}
return|return
literal|false
return|;
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"nls"
argument_list|)
specifier|private
name|void
name|parseJoinCondPopulateAlias
parameter_list|(
name|QBJoinTree
name|joinTree
parameter_list|,
name|ASTNode
name|condn
parameter_list|,
name|ArrayList
argument_list|<
name|String
argument_list|>
name|leftAliases
parameter_list|,
name|ArrayList
argument_list|<
name|String
argument_list|>
name|rightAliases
parameter_list|,
name|ArrayList
argument_list|<
name|String
argument_list|>
name|fields
parameter_list|)
throws|throws
name|SemanticException
block|{
comment|// String[] allAliases = joinTree.getAllAliases();
switch|switch
condition|(
name|condn
operator|.
name|getToken
argument_list|()
operator|.
name|getType
argument_list|()
condition|)
block|{
case|case
name|HiveParser
operator|.
name|TOK_TABLE_OR_COL
case|:
name|String
name|tableOrCol
init|=
name|unescapeIdentifier
argument_list|(
name|condn
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getText
argument_list|()
operator|.
name|toLowerCase
argument_list|()
argument_list|)
decl_stmt|;
name|unparseTranslator
operator|.
name|addIdentifierTranslation
argument_list|(
operator|(
name|ASTNode
operator|)
name|condn
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|isPresent
argument_list|(
name|joinTree
operator|.
name|getLeftAliases
argument_list|()
argument_list|,
name|tableOrCol
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|leftAliases
operator|.
name|contains
argument_list|(
name|tableOrCol
argument_list|)
condition|)
block|{
name|leftAliases
operator|.
name|add
argument_list|(
name|tableOrCol
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|isPresent
argument_list|(
name|joinTree
operator|.
name|getRightAliases
argument_list|()
argument_list|,
name|tableOrCol
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|rightAliases
operator|.
name|contains
argument_list|(
name|tableOrCol
argument_list|)
condition|)
block|{
name|rightAliases
operator|.
name|add
argument_list|(
name|tableOrCol
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// We don't support columns without table prefix in JOIN condition right
comment|// now.
comment|// We need to pass Metadata here to know which table the column belongs
comment|// to.
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|INVALID_TABLE_ALIAS
operator|.
name|getMsg
argument_list|(
name|condn
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
argument_list|)
argument_list|)
throw|;
block|}
break|break;
case|case
name|HiveParser
operator|.
name|Identifier
case|:
comment|// it may be a field name, return the identifier and let the caller decide
comment|// whether it is or not
if|if
condition|(
name|fields
operator|!=
literal|null
condition|)
block|{
name|fields
operator|.
name|add
argument_list|(
name|unescapeIdentifier
argument_list|(
name|condn
operator|.
name|getToken
argument_list|()
operator|.
name|getText
argument_list|()
operator|.
name|toLowerCase
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|unparseTranslator
operator|.
name|addIdentifierTranslation
argument_list|(
name|condn
argument_list|)
expr_stmt|;
break|break;
case|case
name|HiveParser
operator|.
name|Number
case|:
case|case
name|HiveParser
operator|.
name|StringLiteral
case|:
case|case
name|HiveParser
operator|.
name|TOK_CHARSETLITERAL
case|:
case|case
name|HiveParser
operator|.
name|KW_TRUE
case|:
case|case
name|HiveParser
operator|.
name|KW_FALSE
case|:
break|break;
case|case
name|HiveParser
operator|.
name|TOK_FUNCTION
case|:
comment|// check all the arguments
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<
name|condn
operator|.
name|getChildCount
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|parseJoinCondPopulateAlias
argument_list|(
name|joinTree
argument_list|,
operator|(
name|ASTNode
operator|)
name|condn
operator|.
name|getChild
argument_list|(
name|i
argument_list|)
argument_list|,
name|leftAliases
argument_list|,
name|rightAliases
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
comment|// This is an operator - so check whether it is unary or binary operator
if|if
condition|(
name|condn
operator|.
name|getChildCount
argument_list|()
operator|==
literal|1
condition|)
block|{
name|parseJoinCondPopulateAlias
argument_list|(
name|joinTree
argument_list|,
operator|(
name|ASTNode
operator|)
name|condn
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
argument_list|,
name|leftAliases
argument_list|,
name|rightAliases
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|condn
operator|.
name|getChildCount
argument_list|()
operator|==
literal|2
condition|)
block|{
name|ArrayList
argument_list|<
name|String
argument_list|>
name|fields1
init|=
literal|null
decl_stmt|;
comment|// if it is a dot operator, remember the field name of the rhs of the
comment|// left semijoin
if|if
condition|(
name|joinTree
operator|.
name|getNoSemiJoin
argument_list|()
operator|==
literal|false
operator|&&
name|condn
operator|.
name|getToken
argument_list|()
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|DOT
condition|)
block|{
comment|// get the semijoin rhs table name and field name
name|fields1
operator|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
expr_stmt|;
name|int
name|rhssize
init|=
name|rightAliases
operator|.
name|size
argument_list|()
decl_stmt|;
name|parseJoinCondPopulateAlias
argument_list|(
name|joinTree
argument_list|,
operator|(
name|ASTNode
operator|)
name|condn
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
argument_list|,
name|leftAliases
argument_list|,
name|rightAliases
argument_list|,
literal|null
argument_list|)
expr_stmt|;
name|String
name|rhsAlias
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|rightAliases
operator|.
name|size
argument_list|()
operator|>
name|rhssize
condition|)
block|{
comment|// the new table is rhs table
name|rhsAlias
operator|=
name|rightAliases
operator|.
name|get
argument_list|(
name|rightAliases
operator|.
name|size
argument_list|()
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
name|parseJoinCondPopulateAlias
argument_list|(
name|joinTree
argument_list|,
operator|(
name|ASTNode
operator|)
name|condn
operator|.
name|getChild
argument_list|(
literal|1
argument_list|)
argument_list|,
name|leftAliases
argument_list|,
name|rightAliases
argument_list|,
name|fields1
argument_list|)
expr_stmt|;
if|if
condition|(
name|rhsAlias
operator|!=
literal|null
operator|&&
name|fields1
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
name|joinTree
operator|.
name|addRHSSemijoinColumns
argument_list|(
name|rhsAlias
argument_list|,
name|condn
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|parseJoinCondPopulateAlias
argument_list|(
name|joinTree
argument_list|,
operator|(
name|ASTNode
operator|)
name|condn
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
argument_list|,
name|leftAliases
argument_list|,
name|rightAliases
argument_list|,
literal|null
argument_list|)
expr_stmt|;
name|parseJoinCondPopulateAlias
argument_list|(
name|joinTree
argument_list|,
operator|(
name|ASTNode
operator|)
name|condn
operator|.
name|getChild
argument_list|(
literal|1
argument_list|)
argument_list|,
name|leftAliases
argument_list|,
name|rightAliases
argument_list|,
name|fields1
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|condn
operator|.
name|toStringTree
argument_list|()
operator|+
literal|" encountered with "
operator|+
name|condn
operator|.
name|getChildCount
argument_list|()
operator|+
literal|" children"
argument_list|)
throw|;
block|}
break|break;
block|}
block|}
specifier|private
name|void
name|populateAliases
parameter_list|(
name|ArrayList
argument_list|<
name|String
argument_list|>
name|leftAliases
parameter_list|,
name|ArrayList
argument_list|<
name|String
argument_list|>
name|rightAliases
parameter_list|,
name|ASTNode
name|condn
parameter_list|,
name|QBJoinTree
name|joinTree
parameter_list|,
name|ArrayList
argument_list|<
name|String
argument_list|>
name|leftSrc
parameter_list|)
throws|throws
name|SemanticException
block|{
if|if
condition|(
operator|(
name|leftAliases
operator|.
name|size
argument_list|()
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|rightAliases
operator|.
name|size
argument_list|()
operator|!=
literal|0
operator|)
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|INVALID_JOIN_CONDITION_1
operator|.
name|getMsg
argument_list|(
name|condn
argument_list|)
argument_list|)
throw|;
block|}
if|if
condition|(
name|rightAliases
operator|.
name|size
argument_list|()
operator|!=
literal|0
condition|)
block|{
assert|assert
name|rightAliases
operator|.
name|size
argument_list|()
operator|==
literal|1
assert|;
name|joinTree
operator|.
name|getExpressions
argument_list|()
operator|.
name|get
argument_list|(
literal|1
argument_list|)
operator|.
name|add
argument_list|(
name|condn
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|leftAliases
operator|.
name|size
argument_list|()
operator|!=
literal|0
condition|)
block|{
name|joinTree
operator|.
name|getExpressions
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|add
argument_list|(
name|condn
argument_list|)
expr_stmt|;
for|for
control|(
name|String
name|s
range|:
name|leftAliases
control|)
block|{
if|if
condition|(
operator|!
name|leftSrc
operator|.
name|contains
argument_list|(
name|s
argument_list|)
condition|)
block|{
name|leftSrc
operator|.
name|add
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|INVALID_JOIN_CONDITION_2
operator|.
name|getMsg
argument_list|(
name|condn
argument_list|)
argument_list|)
throw|;
block|}
block|}
comment|/**    * Parse the join condition. If the condition is a join condition, throw an    * error if it is not an equality. Otherwise, break it into left and right    * expressions and store in the join tree. If the condition is a join filter,    * add it to the filter list of join tree. The join condition can contains    * conditions on both the left and tree trees and filters on either.    * Currently, we only support equi-joins, so we throw an error if the    * condition involves both subtrees and is not a equality. Also, we only    * support AND i.e ORs are not supported currently as their semantics are not    * very clear, may lead to data explosion and there is no usecase.    *    * @param joinTree    *          jointree to be populated    * @param joinCond    *          join condition    * @param leftSrc    *          left sources    * @throws SemanticException    */
specifier|private
name|void
name|parseJoinCondition
parameter_list|(
name|QBJoinTree
name|joinTree
parameter_list|,
name|ASTNode
name|joinCond
parameter_list|,
name|ArrayList
argument_list|<
name|String
argument_list|>
name|leftSrc
parameter_list|)
throws|throws
name|SemanticException
block|{
if|if
condition|(
name|joinCond
operator|==
literal|null
condition|)
block|{
return|return;
block|}
name|JoinType
name|type
init|=
name|joinTree
operator|.
name|getJoinCond
argument_list|()
index|[
literal|0
index|]
operator|.
name|getJoinType
argument_list|()
decl_stmt|;
switch|switch
condition|(
name|joinCond
operator|.
name|getToken
argument_list|()
operator|.
name|getType
argument_list|()
condition|)
block|{
case|case
name|HiveParser
operator|.
name|KW_OR
case|:
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|INVALID_JOIN_CONDITION_3
operator|.
name|getMsg
argument_list|(
name|joinCond
argument_list|)
argument_list|)
throw|;
case|case
name|HiveParser
operator|.
name|KW_AND
case|:
name|parseJoinCondition
argument_list|(
name|joinTree
argument_list|,
operator|(
name|ASTNode
operator|)
name|joinCond
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
argument_list|,
name|leftSrc
argument_list|)
expr_stmt|;
name|parseJoinCondition
argument_list|(
name|joinTree
argument_list|,
operator|(
name|ASTNode
operator|)
name|joinCond
operator|.
name|getChild
argument_list|(
literal|1
argument_list|)
argument_list|,
name|leftSrc
argument_list|)
expr_stmt|;
break|break;
case|case
name|HiveParser
operator|.
name|EQUAL
case|:
name|ASTNode
name|leftCondn
init|=
operator|(
name|ASTNode
operator|)
name|joinCond
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|ArrayList
argument_list|<
name|String
argument_list|>
name|leftCondAl1
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
name|ArrayList
argument_list|<
name|String
argument_list|>
name|leftCondAl2
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
name|parseJoinCondPopulateAlias
argument_list|(
name|joinTree
argument_list|,
name|leftCondn
argument_list|,
name|leftCondAl1
argument_list|,
name|leftCondAl2
argument_list|,
literal|null
argument_list|)
expr_stmt|;
name|ASTNode
name|rightCondn
init|=
operator|(
name|ASTNode
operator|)
name|joinCond
operator|.
name|getChild
argument_list|(
literal|1
argument_list|)
decl_stmt|;
name|ArrayList
argument_list|<
name|String
argument_list|>
name|rightCondAl1
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
name|ArrayList
argument_list|<
name|String
argument_list|>
name|rightCondAl2
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
name|parseJoinCondPopulateAlias
argument_list|(
name|joinTree
argument_list|,
name|rightCondn
argument_list|,
name|rightCondAl1
argument_list|,
name|rightCondAl2
argument_list|,
literal|null
argument_list|)
expr_stmt|;
comment|// is it a filter or a join condition
comment|// if it is filter see if it can be pushed above the join
comment|// filter cannot be pushed if
comment|// * join is full outer or
comment|// * join is left outer and filter is on left alias or
comment|// * join is right outer and filter is on right alias
if|if
condition|(
operator|(
operator|(
name|leftCondAl1
operator|.
name|size
argument_list|()
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|leftCondAl2
operator|.
name|size
argument_list|()
operator|!=
literal|0
operator|)
operator|)
operator|||
operator|(
operator|(
name|rightCondAl1
operator|.
name|size
argument_list|()
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|rightCondAl2
operator|.
name|size
argument_list|()
operator|!=
literal|0
operator|)
operator|)
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|INVALID_JOIN_CONDITION_1
operator|.
name|getMsg
argument_list|(
name|joinCond
argument_list|)
argument_list|)
throw|;
block|}
if|if
condition|(
name|leftCondAl1
operator|.
name|size
argument_list|()
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|rightCondAl1
operator|.
name|size
argument_list|()
operator|!=
literal|0
operator|)
operator|||
operator|(
operator|(
name|rightCondAl1
operator|.
name|size
argument_list|()
operator|==
literal|0
operator|)
operator|&&
operator|(
name|rightCondAl2
operator|.
name|size
argument_list|()
operator|==
literal|0
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|type
operator|.
name|equals
argument_list|(
name|JoinType
operator|.
name|LEFTOUTER
argument_list|)
operator|||
name|type
operator|.
name|equals
argument_list|(
name|JoinType
operator|.
name|FULLOUTER
argument_list|)
condition|)
block|{
if|if
condition|(
name|conf
operator|.
name|getBoolVar
argument_list|(
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVEOUTERJOINSUPPORTSFILTERS
argument_list|)
condition|)
block|{
name|joinTree
operator|.
name|getFilters
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|add
argument_list|(
name|joinCond
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|LOG
operator|.
name|warn
argument_list|(
name|ErrorMsg
operator|.
name|OUTERJOIN_USES_FILTERS
argument_list|)
expr_stmt|;
name|joinTree
operator|.
name|getFiltersForPushing
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|add
argument_list|(
name|joinCond
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|joinTree
operator|.
name|getFiltersForPushing
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|add
argument_list|(
name|joinCond
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|rightCondAl2
operator|.
name|size
argument_list|()
operator|!=
literal|0
condition|)
block|{
name|populateAliases
argument_list|(
name|leftCondAl1
argument_list|,
name|leftCondAl2
argument_list|,
name|leftCondn
argument_list|,
name|joinTree
argument_list|,
name|leftSrc
argument_list|)
expr_stmt|;
name|populateAliases
argument_list|(
name|rightCondAl1
argument_list|,
name|rightCondAl2
argument_list|,
name|rightCondn
argument_list|,
name|joinTree
argument_list|,
name|leftSrc
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|leftCondAl2
operator|.
name|size
argument_list|()
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|rightCondAl2
operator|.
name|size
argument_list|()
operator|!=
literal|0
operator|)
operator|||
operator|(
operator|(
name|rightCondAl1
operator|.
name|size
argument_list|()
operator|==
literal|0
operator|)
operator|&&
operator|(
name|rightCondAl2
operator|.
name|size
argument_list|()
operator|==
literal|0
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|type
operator|.
name|equals
argument_list|(
name|JoinType
operator|.
name|RIGHTOUTER
argument_list|)
operator|||
name|type
operator|.
name|equals
argument_list|(
name|JoinType
operator|.
name|FULLOUTER
argument_list|)
condition|)
block|{
if|if
condition|(
name|conf
operator|.
name|getBoolVar
argument_list|(
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVEOUTERJOINSUPPORTSFILTERS
argument_list|)
condition|)
block|{
name|joinTree
operator|.
name|getFilters
argument_list|()
operator|.
name|get
argument_list|(
literal|1
argument_list|)
operator|.
name|add
argument_list|(
name|joinCond
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|LOG
operator|.
name|warn
argument_list|(
name|ErrorMsg
operator|.
name|OUTERJOIN_USES_FILTERS
argument_list|)
expr_stmt|;
name|joinTree
operator|.
name|getFiltersForPushing
argument_list|()
operator|.
name|get
argument_list|(
literal|1
argument_list|)
operator|.
name|add
argument_list|(
name|joinCond
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|joinTree
operator|.
name|getFiltersForPushing
argument_list|()
operator|.
name|get
argument_list|(
literal|1
argument_list|)
operator|.
name|add
argument_list|(
name|joinCond
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|rightCondAl1
operator|.
name|size
argument_list|()
operator|!=
literal|0
condition|)
block|{
name|populateAliases
argument_list|(
name|leftCondAl1
argument_list|,
name|leftCondAl2
argument_list|,
name|leftCondn
argument_list|,
name|joinTree
argument_list|,
name|leftSrc
argument_list|)
expr_stmt|;
name|populateAliases
argument_list|(
name|rightCondAl1
argument_list|,
name|rightCondAl2
argument_list|,
name|rightCondn
argument_list|,
name|joinTree
argument_list|,
name|leftSrc
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|rightCondAl1
operator|.
name|size
argument_list|()
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|type
operator|.
name|equals
argument_list|(
name|JoinType
operator|.
name|LEFTOUTER
argument_list|)
operator|||
name|type
operator|.
name|equals
argument_list|(
name|JoinType
operator|.
name|FULLOUTER
argument_list|)
condition|)
block|{
if|if
condition|(
name|conf
operator|.
name|getBoolVar
argument_list|(
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVEOUTERJOINSUPPORTSFILTERS
argument_list|)
condition|)
block|{
name|joinTree
operator|.
name|getFilters
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|add
argument_list|(
name|joinCond
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|LOG
operator|.
name|warn
argument_list|(
name|ErrorMsg
operator|.
name|OUTERJOIN_USES_FILTERS
argument_list|)
expr_stmt|;
name|joinTree
operator|.
name|getFiltersForPushing
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|add
argument_list|(
name|joinCond
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|joinTree
operator|.
name|getFiltersForPushing
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|add
argument_list|(
name|joinCond
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|type
operator|.
name|equals
argument_list|(
name|JoinType
operator|.
name|RIGHTOUTER
argument_list|)
operator|||
name|type
operator|.
name|equals
argument_list|(
name|JoinType
operator|.
name|FULLOUTER
argument_list|)
condition|)
block|{
if|if
condition|(
name|conf
operator|.
name|getBoolVar
argument_list|(
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVEOUTERJOINSUPPORTSFILTERS
argument_list|)
condition|)
block|{
name|joinTree
operator|.
name|getFilters
argument_list|()
operator|.
name|get
argument_list|(
literal|1
argument_list|)
operator|.
name|add
argument_list|(
name|joinCond
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|LOG
operator|.
name|warn
argument_list|(
name|ErrorMsg
operator|.
name|OUTERJOIN_USES_FILTERS
argument_list|)
expr_stmt|;
name|joinTree
operator|.
name|getFiltersForPushing
argument_list|()
operator|.
name|get
argument_list|(
literal|1
argument_list|)
operator|.
name|add
argument_list|(
name|joinCond
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|joinTree
operator|.
name|getFiltersForPushing
argument_list|()
operator|.
name|get
argument_list|(
literal|1
argument_list|)
operator|.
name|add
argument_list|(
name|joinCond
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
default|default:
name|boolean
name|isFunction
init|=
operator|(
name|joinCond
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_FUNCTION
operator|)
decl_stmt|;
comment|// Create all children
name|int
name|childrenBegin
init|=
operator|(
name|isFunction
condition|?
literal|1
else|:
literal|0
operator|)
decl_stmt|;
name|ArrayList
argument_list|<
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|>
name|leftAlias
init|=
operator|new
name|ArrayList
argument_list|<
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|>
argument_list|(
name|joinCond
operator|.
name|getChildCount
argument_list|()
operator|-
name|childrenBegin
argument_list|)
decl_stmt|;
name|ArrayList
argument_list|<
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|>
name|rightAlias
init|=
operator|new
name|ArrayList
argument_list|<
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|>
argument_list|(
name|joinCond
operator|.
name|getChildCount
argument_list|()
operator|-
name|childrenBegin
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|ci
init|=
literal|0
init|;
name|ci
operator|<
name|joinCond
operator|.
name|getChildCount
argument_list|()
operator|-
name|childrenBegin
condition|;
name|ci
operator|++
control|)
block|{
name|ArrayList
argument_list|<
name|String
argument_list|>
name|left
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
name|ArrayList
argument_list|<
name|String
argument_list|>
name|right
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
name|leftAlias
operator|.
name|add
argument_list|(
name|left
argument_list|)
expr_stmt|;
name|rightAlias
operator|.
name|add
argument_list|(
name|right
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|int
name|ci
init|=
name|childrenBegin
init|;
name|ci
operator|<
name|joinCond
operator|.
name|getChildCount
argument_list|()
condition|;
name|ci
operator|++
control|)
block|{
name|parseJoinCondPopulateAlias
argument_list|(
name|joinTree
argument_list|,
operator|(
name|ASTNode
operator|)
name|joinCond
operator|.
name|getChild
argument_list|(
name|ci
argument_list|)
argument_list|,
name|leftAlias
operator|.
name|get
argument_list|(
name|ci
operator|-
name|childrenBegin
argument_list|)
argument_list|,
name|rightAlias
operator|.
name|get
argument_list|(
name|ci
operator|-
name|childrenBegin
argument_list|)
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
name|boolean
name|leftAliasNull
init|=
literal|true
decl_stmt|;
for|for
control|(
name|ArrayList
argument_list|<
name|String
argument_list|>
name|left
range|:
name|leftAlias
control|)
block|{
if|if
condition|(
name|left
operator|.
name|size
argument_list|()
operator|!=
literal|0
condition|)
block|{
name|leftAliasNull
operator|=
literal|false
expr_stmt|;
break|break;
block|}
block|}
name|boolean
name|rightAliasNull
init|=
literal|true
decl_stmt|;
for|for
control|(
name|ArrayList
argument_list|<
name|String
argument_list|>
name|right
range|:
name|rightAlias
control|)
block|{
if|if
condition|(
name|right
operator|.
name|size
argument_list|()
operator|!=
literal|0
condition|)
block|{
name|rightAliasNull
operator|=
literal|false
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|leftAliasNull
operator|&&
operator|!
name|rightAliasNull
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|INVALID_JOIN_CONDITION_1
operator|.
name|getMsg
argument_list|(
name|joinCond
argument_list|)
argument_list|)
throw|;
block|}
if|if
condition|(
operator|!
name|leftAliasNull
condition|)
block|{
if|if
condition|(
name|type
operator|.
name|equals
argument_list|(
name|JoinType
operator|.
name|LEFTOUTER
argument_list|)
operator|||
name|type
operator|.
name|equals
argument_list|(
name|JoinType
operator|.
name|FULLOUTER
argument_list|)
condition|)
block|{
if|if
condition|(
name|conf
operator|.
name|getBoolVar
argument_list|(
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVEOUTERJOINSUPPORTSFILTERS
argument_list|)
condition|)
block|{
name|joinTree
operator|.
name|getFilters
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|add
argument_list|(
name|joinCond
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|LOG
operator|.
name|warn
argument_list|(
name|ErrorMsg
operator|.
name|OUTERJOIN_USES_FILTERS
argument_list|)
expr_stmt|;
name|joinTree
operator|.
name|getFiltersForPushing
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|add
argument_list|(
name|joinCond
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|joinTree
operator|.
name|getFiltersForPushing
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|add
argument_list|(
name|joinCond
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|type
operator|.
name|equals
argument_list|(
name|JoinType
operator|.
name|RIGHTOUTER
argument_list|)
operator|||
name|type
operator|.
name|equals
argument_list|(
name|JoinType
operator|.
name|FULLOUTER
argument_list|)
condition|)
block|{
if|if
condition|(
name|conf
operator|.
name|getBoolVar
argument_list|(
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVEOUTERJOINSUPPORTSFILTERS
argument_list|)
condition|)
block|{
name|joinTree
operator|.
name|getFilters
argument_list|()
operator|.
name|get
argument_list|(
literal|1
argument_list|)
operator|.
name|add
argument_list|(
name|joinCond
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|LOG
operator|.
name|warn
argument_list|(
name|ErrorMsg
operator|.
name|OUTERJOIN_USES_FILTERS
argument_list|)
expr_stmt|;
name|joinTree
operator|.
name|getFiltersForPushing
argument_list|()
operator|.
name|get
argument_list|(
literal|1
argument_list|)
operator|.
name|add
argument_list|(
name|joinCond
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|joinTree
operator|.
name|getFiltersForPushing
argument_list|()
operator|.
name|get
argument_list|(
literal|1
argument_list|)
operator|.
name|add
argument_list|(
name|joinCond
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
block|}
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"nls"
argument_list|)
specifier|public
parameter_list|<
name|T
extends|extends
name|Serializable
parameter_list|>
name|Operator
argument_list|<
name|T
argument_list|>
name|putOpInsertMap
parameter_list|(
name|Operator
argument_list|<
name|T
argument_list|>
name|op
parameter_list|,
name|RowResolver
name|rr
parameter_list|)
block|{
name|OpParseContext
name|ctx
init|=
operator|new
name|OpParseContext
argument_list|(
name|rr
argument_list|)
decl_stmt|;
name|opParseCtx
operator|.
name|put
argument_list|(
name|op
argument_list|,
name|ctx
argument_list|)
expr_stmt|;
name|op
operator|.
name|augmentPlan
argument_list|()
expr_stmt|;
return|return
name|op
return|;
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"nls"
argument_list|)
specifier|private
name|Operator
name|genHavingPlan
parameter_list|(
name|String
name|dest
parameter_list|,
name|QB
name|qb
parameter_list|,
name|Operator
name|input
parameter_list|)
throws|throws
name|SemanticException
block|{
name|ASTNode
name|havingExpr
init|=
name|qb
operator|.
name|getParseInfo
argument_list|()
operator|.
name|getHavingForClause
argument_list|(
name|dest
argument_list|)
decl_stmt|;
name|OpParseContext
name|inputCtx
init|=
name|opParseCtx
operator|.
name|get
argument_list|(
name|input
argument_list|)
decl_stmt|;
name|RowResolver
name|inputRR
init|=
name|inputCtx
operator|.
name|getRowResolver
argument_list|()
decl_stmt|;
name|Map
argument_list|<
name|ASTNode
argument_list|,
name|String
argument_list|>
name|exprToColumnAlias
init|=
name|qb
operator|.
name|getParseInfo
argument_list|()
operator|.
name|getAllExprToColumnAlias
argument_list|()
decl_stmt|;
for|for
control|(
name|ASTNode
name|astNode
range|:
name|exprToColumnAlias
operator|.
name|keySet
argument_list|()
control|)
block|{
if|if
condition|(
name|inputRR
operator|.
name|getExpression
argument_list|(
name|astNode
argument_list|)
operator|!=
literal|null
condition|)
block|{
name|inputRR
operator|.
name|put
argument_list|(
literal|""
argument_list|,
name|exprToColumnAlias
operator|.
name|get
argument_list|(
name|astNode
argument_list|)
argument_list|,
name|inputRR
operator|.
name|getExpression
argument_list|(
name|astNode
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|ASTNode
name|condn
init|=
operator|(
name|ASTNode
operator|)
name|havingExpr
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|Operator
name|output
init|=
name|putOpInsertMap
argument_list|(
name|OperatorFactory
operator|.
name|getAndMakeChild
argument_list|(
operator|new
name|FilterDesc
argument_list|(
name|genExprNodeDesc
argument_list|(
name|condn
argument_list|,
name|inputRR
argument_list|)
argument_list|,
literal|false
argument_list|)
argument_list|,
operator|new
name|RowSchema
argument_list|(
name|inputRR
operator|.
name|getColumnInfos
argument_list|()
argument_list|)
argument_list|,
name|input
argument_list|)
argument_list|,
name|inputRR
argument_list|)
decl_stmt|;
return|return
name|output
return|;
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"nls"
argument_list|)
specifier|private
name|Operator
name|genFilterPlan
parameter_list|(
name|String
name|dest
parameter_list|,
name|QB
name|qb
parameter_list|,
name|Operator
name|input
parameter_list|)
throws|throws
name|SemanticException
block|{
name|ASTNode
name|whereExpr
init|=
name|qb
operator|.
name|getParseInfo
argument_list|()
operator|.
name|getWhrForClause
argument_list|(
name|dest
argument_list|)
decl_stmt|;
return|return
name|genFilterPlan
argument_list|(
name|qb
argument_list|,
operator|(
name|ASTNode
operator|)
name|whereExpr
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
argument_list|,
name|input
argument_list|)
return|;
block|}
comment|/**    * create a filter plan. The condition and the inputs are specified.    *    * @param qb    *          current query block    * @param condn    *          The condition to be resolved    * @param input    *          the input operator    */
annotation|@
name|SuppressWarnings
argument_list|(
literal|"nls"
argument_list|)
specifier|private
name|Operator
name|genFilterPlan
parameter_list|(
name|QB
name|qb
parameter_list|,
name|ASTNode
name|condn
parameter_list|,
name|Operator
name|input
parameter_list|)
throws|throws
name|SemanticException
block|{
name|OpParseContext
name|inputCtx
init|=
name|opParseCtx
operator|.
name|get
argument_list|(
name|input
argument_list|)
decl_stmt|;
name|RowResolver
name|inputRR
init|=
name|inputCtx
operator|.
name|getRowResolver
argument_list|()
decl_stmt|;
name|Operator
name|output
init|=
name|putOpInsertMap
argument_list|(
name|OperatorFactory
operator|.
name|getAndMakeChild
argument_list|(
operator|new
name|FilterDesc
argument_list|(
name|genExprNodeDesc
argument_list|(
name|condn
argument_list|,
name|inputRR
argument_list|)
argument_list|,
literal|false
argument_list|)
argument_list|,
operator|new
name|RowSchema
argument_list|(
name|inputRR
operator|.
name|getColumnInfos
argument_list|()
argument_list|)
argument_list|,
name|input
argument_list|)
argument_list|,
name|inputRR
argument_list|)
decl_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Created Filter Plan for "
operator|+
name|qb
operator|.
name|getId
argument_list|()
operator|+
literal|" row schema: "
operator|+
name|inputRR
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|output
return|;
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"nls"
argument_list|)
specifier|private
name|Integer
name|genColListRegex
parameter_list|(
name|String
name|colRegex
parameter_list|,
name|String
name|tabAlias
parameter_list|,
name|ASTNode
name|sel
parameter_list|,
name|ArrayList
argument_list|<
name|ExprNodeDesc
argument_list|>
name|col_list
parameter_list|,
name|RowResolver
name|input
parameter_list|,
name|Integer
name|pos
parameter_list|,
name|RowResolver
name|output
parameter_list|,
name|List
argument_list|<
name|String
argument_list|>
name|aliases
parameter_list|)
throws|throws
name|SemanticException
block|{
comment|// The table alias should exist
if|if
condition|(
name|tabAlias
operator|!=
literal|null
operator|&&
operator|!
name|input
operator|.
name|hasTableAlias
argument_list|(
name|tabAlias
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|INVALID_TABLE_ALIAS
operator|.
name|getMsg
argument_list|(
name|sel
argument_list|)
argument_list|)
throw|;
block|}
comment|// TODO: Have to put in the support for AS clause
name|Pattern
name|regex
init|=
literal|null
decl_stmt|;
try|try
block|{
name|regex
operator|=
name|Pattern
operator|.
name|compile
argument_list|(
name|colRegex
argument_list|,
name|Pattern
operator|.
name|CASE_INSENSITIVE
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|PatternSyntaxException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|INVALID_COLUMN
operator|.
name|getMsg
argument_list|(
name|sel
argument_list|,
name|e
operator|.
name|getMessage
argument_list|()
argument_list|)
argument_list|)
throw|;
block|}
name|StringBuilder
name|replacementText
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|int
name|matched
init|=
literal|0
decl_stmt|;
comment|// add empty string to the list of aliases. Some operators (ex. GroupBy) add
comment|// ColumnInfos for table alias "".
if|if
condition|(
operator|!
name|aliases
operator|.
name|contains
argument_list|(
literal|""
argument_list|)
condition|)
block|{
name|aliases
operator|.
name|add
argument_list|(
literal|""
argument_list|)
expr_stmt|;
block|}
comment|// For expr "*", aliases should be iterated in the order they are specified
comment|// in the query.
for|for
control|(
name|String
name|alias
range|:
name|aliases
control|)
block|{
name|HashMap
argument_list|<
name|String
argument_list|,
name|ColumnInfo
argument_list|>
name|fMap
init|=
name|input
operator|.
name|getFieldMap
argument_list|(
name|alias
argument_list|)
decl_stmt|;
if|if
condition|(
name|fMap
operator|==
literal|null
condition|)
block|{
continue|continue;
block|}
comment|// For the tab.* case, add all the columns to the fieldList
comment|// from the input schema
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|ColumnInfo
argument_list|>
name|entry
range|:
name|fMap
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|ColumnInfo
name|colInfo
init|=
name|entry
operator|.
name|getValue
argument_list|()
decl_stmt|;
name|String
name|name
init|=
name|colInfo
operator|.
name|getInternalName
argument_list|()
decl_stmt|;
name|String
index|[]
name|tmp
init|=
name|input
operator|.
name|reverseLookup
argument_list|(
name|name
argument_list|)
decl_stmt|;
comment|// Skip the colinfos which are not for this particular alias
if|if
condition|(
name|tabAlias
operator|!=
literal|null
operator|&&
operator|!
name|tmp
index|[
literal|0
index|]
operator|.
name|equalsIgnoreCase
argument_list|(
name|tabAlias
argument_list|)
condition|)
block|{
continue|continue;
block|}
if|if
condition|(
name|colInfo
operator|.
name|getIsVirtualCol
argument_list|()
operator|&&
name|colInfo
operator|.
name|isHiddenVirtualCol
argument_list|()
condition|)
block|{
continue|continue;
block|}
comment|// Not matching the regex?
if|if
condition|(
operator|!
name|regex
operator|.
name|matcher
argument_list|(
name|tmp
index|[
literal|1
index|]
argument_list|)
operator|.
name|matches
argument_list|()
condition|)
block|{
continue|continue;
block|}
name|ExprNodeColumnDesc
name|expr
init|=
operator|new
name|ExprNodeColumnDesc
argument_list|(
name|colInfo
operator|.
name|getType
argument_list|()
argument_list|,
name|name
argument_list|,
name|colInfo
operator|.
name|getTabAlias
argument_list|()
argument_list|,
name|colInfo
operator|.
name|getIsVirtualCol
argument_list|()
argument_list|)
decl_stmt|;
name|col_list
operator|.
name|add
argument_list|(
name|expr
argument_list|)
expr_stmt|;
name|output
operator|.
name|put
argument_list|(
name|tmp
index|[
literal|0
index|]
argument_list|,
name|tmp
index|[
literal|1
index|]
argument_list|,
operator|new
name|ColumnInfo
argument_list|(
name|getColumnInternalName
argument_list|(
name|pos
argument_list|)
argument_list|,
name|colInfo
operator|.
name|getType
argument_list|()
argument_list|,
name|colInfo
operator|.
name|getTabAlias
argument_list|()
argument_list|,
name|colInfo
operator|.
name|getIsVirtualCol
argument_list|()
argument_list|,
name|colInfo
operator|.
name|isHiddenVirtualCol
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|pos
operator|=
name|Integer
operator|.
name|valueOf
argument_list|(
name|pos
operator|.
name|intValue
argument_list|()
operator|+
literal|1
argument_list|)
expr_stmt|;
name|matched
operator|++
expr_stmt|;
if|if
condition|(
name|unparseTranslator
operator|.
name|isEnabled
argument_list|()
condition|)
block|{
if|if
condition|(
name|replacementText
operator|.
name|length
argument_list|()
operator|>
literal|0
condition|)
block|{
name|replacementText
operator|.
name|append
argument_list|(
literal|", "
argument_list|)
expr_stmt|;
block|}
name|replacementText
operator|.
name|append
argument_list|(
name|HiveUtils
operator|.
name|unparseIdentifier
argument_list|(
name|tmp
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|replacementText
operator|.
name|append
argument_list|(
literal|"."
argument_list|)
expr_stmt|;
name|replacementText
operator|.
name|append
argument_list|(
name|HiveUtils
operator|.
name|unparseIdentifier
argument_list|(
name|tmp
index|[
literal|1
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|matched
operator|==
literal|0
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|INVALID_COLUMN
operator|.
name|getMsg
argument_list|(
name|sel
argument_list|)
argument_list|)
throw|;
block|}
if|if
condition|(
name|unparseTranslator
operator|.
name|isEnabled
argument_list|()
condition|)
block|{
name|unparseTranslator
operator|.
name|addTranslation
argument_list|(
name|sel
argument_list|,
name|replacementText
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|pos
return|;
block|}
specifier|public
specifier|static
name|String
name|getColumnInternalName
parameter_list|(
name|int
name|pos
parameter_list|)
block|{
return|return
name|HiveConf
operator|.
name|getColumnInternalName
argument_list|(
name|pos
argument_list|)
return|;
block|}
specifier|private
name|String
name|getScriptProgName
parameter_list|(
name|String
name|cmd
parameter_list|)
block|{
name|int
name|end
init|=
name|cmd
operator|.
name|indexOf
argument_list|(
literal|" "
argument_list|)
decl_stmt|;
return|return
operator|(
name|end
operator|==
operator|-
literal|1
operator|)
condition|?
name|cmd
else|:
name|cmd
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|end
argument_list|)
return|;
block|}
specifier|private
name|String
name|getScriptArgs
parameter_list|(
name|String
name|cmd
parameter_list|)
block|{
name|int
name|end
init|=
name|cmd
operator|.
name|indexOf
argument_list|(
literal|" "
argument_list|)
decl_stmt|;
return|return
operator|(
name|end
operator|==
operator|-
literal|1
operator|)
condition|?
literal|""
else|:
name|cmd
operator|.
name|substring
argument_list|(
name|end
argument_list|,
name|cmd
operator|.
name|length
argument_list|()
argument_list|)
return|;
block|}
specifier|private
specifier|static
name|int
name|getPositionFromInternalName
parameter_list|(
name|String
name|internalName
parameter_list|)
block|{
return|return
name|HiveConf
operator|.
name|getPositionFromInternalName
argument_list|(
name|internalName
argument_list|)
return|;
block|}
specifier|private
name|String
name|fetchFilesNotInLocalFilesystem
parameter_list|(
name|String
name|cmd
parameter_list|)
block|{
name|SessionState
name|ss
init|=
name|SessionState
operator|.
name|get
argument_list|()
decl_stmt|;
name|String
name|progName
init|=
name|getScriptProgName
argument_list|(
name|cmd
argument_list|)
decl_stmt|;
if|if
condition|(
name|progName
operator|.
name|matches
argument_list|(
literal|"("
operator|+
name|SessionState
operator|.
name|getMatchingSchemaAsRegex
argument_list|()
operator|+
literal|")://.*"
argument_list|)
condition|)
block|{
name|String
name|filePath
init|=
name|ss
operator|.
name|add_resource
argument_list|(
name|ResourceType
operator|.
name|FILE
argument_list|,
name|progName
argument_list|,
literal|true
argument_list|)
decl_stmt|;
if|if
condition|(
name|filePath
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Could not download the resource: "
operator|+
name|progName
argument_list|)
throw|;
block|}
name|Path
name|p
init|=
operator|new
name|Path
argument_list|(
name|filePath
argument_list|)
decl_stmt|;
name|String
name|fileName
init|=
name|p
operator|.
name|getName
argument_list|()
decl_stmt|;
name|String
name|scriptArgs
init|=
name|getScriptArgs
argument_list|(
name|cmd
argument_list|)
decl_stmt|;
name|String
name|finalCmd
init|=
name|fileName
operator|+
name|scriptArgs
decl_stmt|;
return|return
name|finalCmd
return|;
block|}
return|return
name|cmd
return|;
block|}
specifier|private
name|TableDesc
name|getTableDescFromSerDe
parameter_list|(
name|ASTNode
name|child
parameter_list|,
name|String
name|cols
parameter_list|,
name|String
name|colTypes
parameter_list|,
name|boolean
name|defaultCols
parameter_list|)
throws|throws
name|SemanticException
block|{
if|if
condition|(
name|child
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_SERDENAME
condition|)
block|{
name|String
name|serdeName
init|=
name|unescapeSQLString
argument_list|(
name|child
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getText
argument_list|()
argument_list|)
decl_stmt|;
name|Class
argument_list|<
name|?
extends|extends
name|Deserializer
argument_list|>
name|serdeClass
init|=
literal|null
decl_stmt|;
try|try
block|{
name|serdeClass
operator|=
operator|(
name|Class
argument_list|<
name|?
extends|extends
name|Deserializer
argument_list|>
operator|)
name|Class
operator|.
name|forName
argument_list|(
name|serdeName
argument_list|,
literal|true
argument_list|,
name|JavaUtils
operator|.
name|getClassLoader
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|ClassNotFoundException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|e
argument_list|)
throw|;
block|}
name|TableDesc
name|tblDesc
init|=
name|PlanUtils
operator|.
name|getTableDesc
argument_list|(
name|serdeClass
argument_list|,
name|Integer
operator|.
name|toString
argument_list|(
name|Utilities
operator|.
name|tabCode
argument_list|)
argument_list|,
name|cols
argument_list|,
name|colTypes
argument_list|,
name|defaultCols
argument_list|)
decl_stmt|;
comment|// copy all the properties
if|if
condition|(
name|child
operator|.
name|getChildCount
argument_list|()
operator|==
literal|2
condition|)
block|{
name|ASTNode
name|prop
init|=
call|(
name|ASTNode
call|)
argument_list|(
operator|(
name|ASTNode
operator|)
name|child
operator|.
name|getChild
argument_list|(
literal|1
argument_list|)
argument_list|)
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|propChild
init|=
literal|0
init|;
name|propChild
operator|<
name|prop
operator|.
name|getChildCount
argument_list|()
condition|;
name|propChild
operator|++
control|)
block|{
name|String
name|key
init|=
name|unescapeSQLString
argument_list|(
name|prop
operator|.
name|getChild
argument_list|(
name|propChild
argument_list|)
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getText
argument_list|()
argument_list|)
decl_stmt|;
name|String
name|value
init|=
name|unescapeSQLString
argument_list|(
name|prop
operator|.
name|getChild
argument_list|(
name|propChild
argument_list|)
operator|.
name|getChild
argument_list|(
literal|1
argument_list|)
operator|.
name|getText
argument_list|()
argument_list|)
decl_stmt|;
name|tblDesc
operator|.
name|getProperties
argument_list|()
operator|.
name|setProperty
argument_list|(
name|key
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|tblDesc
return|;
block|}
elseif|else
if|if
condition|(
name|child
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_SERDEPROPS
condition|)
block|{
name|TableDesc
name|tblDesc
init|=
name|PlanUtils
operator|.
name|getDefaultTableDesc
argument_list|(
name|Integer
operator|.
name|toString
argument_list|(
name|Utilities
operator|.
name|ctrlaCode
argument_list|)
argument_list|,
name|cols
argument_list|,
name|colTypes
argument_list|,
name|defaultCols
argument_list|)
decl_stmt|;
name|int
name|numChildRowFormat
init|=
name|child
operator|.
name|getChildCount
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|numC
init|=
literal|0
init|;
name|numC
operator|<
name|numChildRowFormat
condition|;
name|numC
operator|++
control|)
block|{
name|ASTNode
name|rowChild
init|=
operator|(
name|ASTNode
operator|)
name|child
operator|.
name|getChild
argument_list|(
name|numC
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|rowChild
operator|.
name|getToken
argument_list|()
operator|.
name|getType
argument_list|()
condition|)
block|{
case|case
name|HiveParser
operator|.
name|TOK_TABLEROWFORMATFIELD
case|:
name|String
name|fieldDelim
init|=
name|unescapeSQLString
argument_list|(
name|rowChild
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getText
argument_list|()
argument_list|)
decl_stmt|;
name|tblDesc
operator|.
name|getProperties
argument_list|()
operator|.
name|setProperty
argument_list|(
name|Constants
operator|.
name|FIELD_DELIM
argument_list|,
name|fieldDelim
argument_list|)
expr_stmt|;
name|tblDesc
operator|.
name|getProperties
argument_list|()
operator|.
name|setProperty
argument_list|(
name|Constants
operator|.
name|SERIALIZATION_FORMAT
argument_list|,
name|fieldDelim
argument_list|)
expr_stmt|;
if|if
condition|(
name|rowChild
operator|.
name|getChildCount
argument_list|()
operator|>=
literal|2
condition|)
block|{
name|String
name|fieldEscape
init|=
name|unescapeSQLString
argument_list|(
name|rowChild
operator|.
name|getChild
argument_list|(
literal|1
argument_list|)
operator|.
name|getText
argument_list|()
argument_list|)
decl_stmt|;
name|tblDesc
operator|.
name|getProperties
argument_list|()
operator|.
name|setProperty
argument_list|(
name|Constants
operator|.
name|ESCAPE_CHAR
argument_list|,
name|fieldEscape
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|HiveParser
operator|.
name|TOK_TABLEROWFORMATCOLLITEMS
case|:
name|tblDesc
operator|.
name|getProperties
argument_list|()
operator|.
name|setProperty
argument_list|(
name|Constants
operator|.
name|COLLECTION_DELIM
argument_list|,
name|unescapeSQLString
argument_list|(
name|rowChild
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getText
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|HiveParser
operator|.
name|TOK_TABLEROWFORMATMAPKEYS
case|:
name|tblDesc
operator|.
name|getProperties
argument_list|()
operator|.
name|setProperty
argument_list|(
name|Constants
operator|.
name|MAPKEY_DELIM
argument_list|,
name|unescapeSQLString
argument_list|(
name|rowChild
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getText
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|HiveParser
operator|.
name|TOK_TABLEROWFORMATLINES
case|:
name|String
name|lineDelim
init|=
name|unescapeSQLString
argument_list|(
name|rowChild
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getText
argument_list|()
argument_list|)
decl_stmt|;
name|tblDesc
operator|.
name|getProperties
argument_list|()
operator|.
name|setProperty
argument_list|(
name|Constants
operator|.
name|LINE_DELIM
argument_list|,
name|lineDelim
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|lineDelim
operator|.
name|equals
argument_list|(
literal|"\n"
argument_list|)
operator|&&
operator|!
name|lineDelim
operator|.
name|equals
argument_list|(
literal|"10"
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|generateErrorMessage
argument_list|(
name|rowChild
argument_list|,
name|ErrorMsg
operator|.
name|LINES_TERMINATED_BY_NON_NEWLINE
operator|.
name|getMsg
argument_list|()
argument_list|)
argument_list|)
throw|;
block|}
break|break;
default|default:
assert|assert
literal|false
assert|;
block|}
block|}
return|return
name|tblDesc
return|;
block|}
comment|// should never come here
return|return
literal|null
return|;
block|}
specifier|private
name|void
name|failIfColAliasExists
parameter_list|(
name|Set
argument_list|<
name|String
argument_list|>
name|nameSet
parameter_list|,
name|String
name|name
parameter_list|)
throws|throws
name|SemanticException
block|{
if|if
condition|(
name|nameSet
operator|.
name|contains
argument_list|(
name|name
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|COLUMN_ALIAS_ALREADY_EXISTS
operator|.
name|getMsg
argument_list|(
name|name
argument_list|)
argument_list|)
throw|;
block|}
name|nameSet
operator|.
name|add
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"nls"
argument_list|)
specifier|private
name|Operator
name|genScriptPlan
parameter_list|(
name|ASTNode
name|trfm
parameter_list|,
name|QB
name|qb
parameter_list|,
name|Operator
name|input
parameter_list|)
throws|throws
name|SemanticException
block|{
comment|// If there is no "AS" clause, the output schema will be "key,value"
name|ArrayList
argument_list|<
name|ColumnInfo
argument_list|>
name|outputCols
init|=
operator|new
name|ArrayList
argument_list|<
name|ColumnInfo
argument_list|>
argument_list|()
decl_stmt|;
name|int
name|inputSerDeNum
init|=
literal|1
decl_stmt|,
name|inputRecordWriterNum
init|=
literal|2
decl_stmt|;
name|int
name|outputSerDeNum
init|=
literal|4
decl_stmt|,
name|outputRecordReaderNum
init|=
literal|5
decl_stmt|;
name|int
name|outputColsNum
init|=
literal|6
decl_stmt|;
name|boolean
name|outputColNames
init|=
literal|false
decl_stmt|,
name|outputColSchemas
init|=
literal|false
decl_stmt|;
name|int
name|execPos
init|=
literal|3
decl_stmt|;
name|boolean
name|defaultOutputCols
init|=
literal|false
decl_stmt|;
comment|// Go over all the children
if|if
condition|(
name|trfm
operator|.
name|getChildCount
argument_list|()
operator|>
name|outputColsNum
condition|)
block|{
name|ASTNode
name|outCols
init|=
operator|(
name|ASTNode
operator|)
name|trfm
operator|.
name|getChild
argument_list|(
name|outputColsNum
argument_list|)
decl_stmt|;
if|if
condition|(
name|outCols
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_ALIASLIST
condition|)
block|{
name|outputColNames
operator|=
literal|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|outCols
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_TABCOLLIST
condition|)
block|{
name|outputColSchemas
operator|=
literal|true
expr_stmt|;
block|}
block|}
comment|// If column type is not specified, use a string
if|if
condition|(
operator|!
name|outputColNames
operator|&&
operator|!
name|outputColSchemas
condition|)
block|{
name|String
name|intName
init|=
name|getColumnInternalName
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|ColumnInfo
name|colInfo
init|=
operator|new
name|ColumnInfo
argument_list|(
name|intName
argument_list|,
name|TypeInfoFactory
operator|.
name|stringTypeInfo
argument_list|,
literal|null
argument_list|,
literal|false
argument_list|)
decl_stmt|;
name|colInfo
operator|.
name|setAlias
argument_list|(
literal|"key"
argument_list|)
expr_stmt|;
name|outputCols
operator|.
name|add
argument_list|(
name|colInfo
argument_list|)
expr_stmt|;
name|intName
operator|=
name|getColumnInternalName
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|colInfo
operator|=
operator|new
name|ColumnInfo
argument_list|(
name|intName
argument_list|,
name|TypeInfoFactory
operator|.
name|stringTypeInfo
argument_list|,
literal|null
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|colInfo
operator|.
name|setAlias
argument_list|(
literal|"value"
argument_list|)
expr_stmt|;
name|outputCols
operator|.
name|add
argument_list|(
name|colInfo
argument_list|)
expr_stmt|;
name|defaultOutputCols
operator|=
literal|true
expr_stmt|;
block|}
else|else
block|{
name|ASTNode
name|collist
init|=
operator|(
name|ASTNode
operator|)
name|trfm
operator|.
name|getChild
argument_list|(
name|outputColsNum
argument_list|)
decl_stmt|;
name|int
name|ccount
init|=
name|collist
operator|.
name|getChildCount
argument_list|()
decl_stmt|;
name|Set
argument_list|<
name|String
argument_list|>
name|colAliasNamesDuplicateCheck
init|=
operator|new
name|HashSet
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
if|if
condition|(
name|outputColNames
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|ccount
condition|;
operator|++
name|i
control|)
block|{
name|String
name|colAlias
init|=
name|unescapeIdentifier
argument_list|(
operator|(
operator|(
name|ASTNode
operator|)
name|collist
operator|.
name|getChild
argument_list|(
name|i
argument_list|)
operator|)
operator|.
name|getText
argument_list|()
argument_list|)
decl_stmt|;
name|failIfColAliasExists
argument_list|(
name|colAliasNamesDuplicateCheck
argument_list|,
name|colAlias
argument_list|)
expr_stmt|;
name|String
name|intName
init|=
name|getColumnInternalName
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|ColumnInfo
name|colInfo
init|=
operator|new
name|ColumnInfo
argument_list|(
name|intName
argument_list|,
name|TypeInfoFactory
operator|.
name|stringTypeInfo
argument_list|,
literal|null
argument_list|,
literal|false
argument_list|)
decl_stmt|;
name|colInfo
operator|.
name|setAlias
argument_list|(
name|colAlias
argument_list|)
expr_stmt|;
name|outputCols
operator|.
name|add
argument_list|(
name|colInfo
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|ccount
condition|;
operator|++
name|i
control|)
block|{
name|ASTNode
name|child
init|=
operator|(
name|ASTNode
operator|)
name|collist
operator|.
name|getChild
argument_list|(
name|i
argument_list|)
decl_stmt|;
assert|assert
name|child
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_TABCOL
assert|;
name|String
name|colAlias
init|=
name|unescapeIdentifier
argument_list|(
operator|(
operator|(
name|ASTNode
operator|)
name|child
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|)
operator|.
name|getText
argument_list|()
argument_list|)
decl_stmt|;
name|failIfColAliasExists
argument_list|(
name|colAliasNamesDuplicateCheck
argument_list|,
name|colAlias
argument_list|)
expr_stmt|;
name|String
name|intName
init|=
name|getColumnInternalName
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|ColumnInfo
name|colInfo
init|=
operator|new
name|ColumnInfo
argument_list|(
name|intName
argument_list|,
name|TypeInfoUtils
operator|.
name|getTypeInfoFromTypeString
argument_list|(
name|getTypeStringFromAST
argument_list|(
operator|(
name|ASTNode
operator|)
name|child
operator|.
name|getChild
argument_list|(
literal|1
argument_list|)
argument_list|)
argument_list|)
argument_list|,
literal|null
argument_list|,
literal|false
argument_list|)
decl_stmt|;
name|colInfo
operator|.
name|setAlias
argument_list|(
name|colAlias
argument_list|)
expr_stmt|;
name|outputCols
operator|.
name|add
argument_list|(
name|colInfo
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|RowResolver
name|out_rwsch
init|=
operator|new
name|RowResolver
argument_list|()
decl_stmt|;
name|StringBuilder
name|columns
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|StringBuilder
name|columnTypes
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|outputCols
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|i
operator|!=
literal|0
condition|)
block|{
name|columns
operator|.
name|append
argument_list|(
literal|","
argument_list|)
expr_stmt|;
name|columnTypes
operator|.
name|append
argument_list|(
literal|","
argument_list|)
expr_stmt|;
block|}
name|columns
operator|.
name|append
argument_list|(
name|outputCols
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|getInternalName
argument_list|()
argument_list|)
expr_stmt|;
name|columnTypes
operator|.
name|append
argument_list|(
name|outputCols
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|getType
argument_list|()
operator|.
name|getTypeName
argument_list|()
argument_list|)
expr_stmt|;
name|out_rwsch
operator|.
name|put
argument_list|(
name|qb
operator|.
name|getParseInfo
argument_list|()
operator|.
name|getAlias
argument_list|()
argument_list|,
name|outputCols
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|getAlias
argument_list|()
argument_list|,
name|outputCols
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|StringBuilder
name|inpColumns
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|StringBuilder
name|inpColumnTypes
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|ArrayList
argument_list|<
name|ColumnInfo
argument_list|>
name|inputSchema
init|=
name|opParseCtx
operator|.
name|get
argument_list|(
name|input
argument_list|)
operator|.
name|getRowResolver
argument_list|()
operator|.
name|getColumnInfos
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|inputSchema
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|i
operator|!=
literal|0
condition|)
block|{
name|inpColumns
operator|.
name|append
argument_list|(
literal|","
argument_list|)
expr_stmt|;
name|inpColumnTypes
operator|.
name|append
argument_list|(
literal|","
argument_list|)
expr_stmt|;
block|}
name|inpColumns
operator|.
name|append
argument_list|(
name|inputSchema
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|getInternalName
argument_list|()
argument_list|)
expr_stmt|;
name|inpColumnTypes
operator|.
name|append
argument_list|(
name|inputSchema
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|getType
argument_list|()
operator|.
name|getTypeName
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|TableDesc
name|outInfo
decl_stmt|;
name|TableDesc
name|errInfo
decl_stmt|;
name|TableDesc
name|inInfo
decl_stmt|;
name|String
name|defaultSerdeName
init|=
name|conf
operator|.
name|getVar
argument_list|(
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVESCRIPTSERDE
argument_list|)
decl_stmt|;
name|Class
argument_list|<
name|?
extends|extends
name|Deserializer
argument_list|>
name|serde
decl_stmt|;
try|try
block|{
name|serde
operator|=
operator|(
name|Class
argument_list|<
name|?
extends|extends
name|Deserializer
argument_list|>
operator|)
name|Class
operator|.
name|forName
argument_list|(
name|defaultSerdeName
argument_list|,
literal|true
argument_list|,
name|JavaUtils
operator|.
name|getClassLoader
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|ClassNotFoundException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|e
argument_list|)
throw|;
block|}
comment|// Input and Output Serdes
if|if
condition|(
name|trfm
operator|.
name|getChild
argument_list|(
name|inputSerDeNum
argument_list|)
operator|.
name|getChildCount
argument_list|()
operator|>
literal|0
condition|)
block|{
name|inInfo
operator|=
name|getTableDescFromSerDe
argument_list|(
call|(
name|ASTNode
call|)
argument_list|(
operator|(
operator|(
name|ASTNode
operator|)
name|trfm
operator|.
name|getChild
argument_list|(
name|inputSerDeNum
argument_list|)
operator|)
argument_list|)
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
argument_list|,
name|inpColumns
operator|.
name|toString
argument_list|()
argument_list|,
name|inpColumnTypes
operator|.
name|toString
argument_list|()
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|inInfo
operator|=
name|PlanUtils
operator|.
name|getTableDesc
argument_list|(
name|serde
argument_list|,
name|Integer
operator|.
name|toString
argument_list|(
name|Utilities
operator|.
name|tabCode
argument_list|)
argument_list|,
name|inpColumns
operator|.
name|toString
argument_list|()
argument_list|,
name|inpColumnTypes
operator|.
name|toString
argument_list|()
argument_list|,
literal|false
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|trfm
operator|.
name|getChild
argument_list|(
name|outputSerDeNum
argument_list|)
operator|.
name|getChildCount
argument_list|()
operator|>
literal|0
condition|)
block|{
name|outInfo
operator|=
name|getTableDescFromSerDe
argument_list|(
call|(
name|ASTNode
call|)
argument_list|(
operator|(
operator|(
name|ASTNode
operator|)
name|trfm
operator|.
name|getChild
argument_list|(
name|outputSerDeNum
argument_list|)
operator|)
argument_list|)
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
argument_list|,
name|columns
operator|.
name|toString
argument_list|()
argument_list|,
name|columnTypes
operator|.
name|toString
argument_list|()
argument_list|,
literal|false
argument_list|)
expr_stmt|;
comment|// This is for backward compatibility. If the user did not specify the
comment|// output column list, we assume that there are 2 columns: key and value.
comment|// However, if the script outputs: col1, col2, col3 seperated by TAB, the
comment|// requirement is: key is col and value is (col2 TAB col3)
block|}
else|else
block|{
name|outInfo
operator|=
name|PlanUtils
operator|.
name|getTableDesc
argument_list|(
name|serde
argument_list|,
name|Integer
operator|.
name|toString
argument_list|(
name|Utilities
operator|.
name|tabCode
argument_list|)
argument_list|,
name|columns
operator|.
name|toString
argument_list|()
argument_list|,
name|columnTypes
operator|.
name|toString
argument_list|()
argument_list|,
name|defaultOutputCols
argument_list|)
expr_stmt|;
block|}
comment|// Error stream always uses the default serde with a single column
name|errInfo
operator|=
name|PlanUtils
operator|.
name|getTableDesc
argument_list|(
name|serde
argument_list|,
name|Integer
operator|.
name|toString
argument_list|(
name|Utilities
operator|.
name|tabCode
argument_list|)
argument_list|,
literal|"KEY"
argument_list|)
expr_stmt|;
comment|// Output record readers
name|Class
argument_list|<
name|?
extends|extends
name|RecordReader
argument_list|>
name|outRecordReader
init|=
name|getRecordReader
argument_list|(
operator|(
name|ASTNode
operator|)
name|trfm
operator|.
name|getChild
argument_list|(
name|outputRecordReaderNum
argument_list|)
argument_list|)
decl_stmt|;
name|Class
argument_list|<
name|?
extends|extends
name|RecordWriter
argument_list|>
name|inRecordWriter
init|=
name|getRecordWriter
argument_list|(
operator|(
name|ASTNode
operator|)
name|trfm
operator|.
name|getChild
argument_list|(
name|inputRecordWriterNum
argument_list|)
argument_list|)
decl_stmt|;
name|Class
argument_list|<
name|?
extends|extends
name|RecordReader
argument_list|>
name|errRecordReader
init|=
name|getDefaultRecordReader
argument_list|()
decl_stmt|;
name|Operator
name|output
init|=
name|putOpInsertMap
argument_list|(
name|OperatorFactory
operator|.
name|getAndMakeChild
argument_list|(
operator|new
name|ScriptDesc
argument_list|(
name|fetchFilesNotInLocalFilesystem
argument_list|(
name|stripQuotes
argument_list|(
name|trfm
operator|.
name|getChild
argument_list|(
name|execPos
argument_list|)
operator|.
name|getText
argument_list|()
argument_list|)
argument_list|)
argument_list|,
name|inInfo
argument_list|,
name|inRecordWriter
argument_list|,
name|outInfo
argument_list|,
name|outRecordReader
argument_list|,
name|errRecordReader
argument_list|,
name|errInfo
argument_list|)
argument_list|,
operator|new
name|RowSchema
argument_list|(
name|out_rwsch
operator|.
name|getColumnInfos
argument_list|()
argument_list|)
argument_list|,
name|input
argument_list|)
argument_list|,
name|out_rwsch
argument_list|)
decl_stmt|;
return|return
name|output
return|;
block|}
specifier|private
name|Class
argument_list|<
name|?
extends|extends
name|RecordReader
argument_list|>
name|getRecordReader
parameter_list|(
name|ASTNode
name|node
parameter_list|)
throws|throws
name|SemanticException
block|{
name|String
name|name
decl_stmt|;
if|if
condition|(
name|node
operator|.
name|getChildCount
argument_list|()
operator|==
literal|0
condition|)
block|{
name|name
operator|=
name|conf
operator|.
name|getVar
argument_list|(
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVESCRIPTRECORDREADER
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|name
operator|=
name|unescapeSQLString
argument_list|(
name|node
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getText
argument_list|()
argument_list|)
expr_stmt|;
block|}
try|try
block|{
return|return
operator|(
name|Class
argument_list|<
name|?
extends|extends
name|RecordReader
argument_list|>
operator|)
name|Class
operator|.
name|forName
argument_list|(
name|name
argument_list|,
literal|true
argument_list|,
name|JavaUtils
operator|.
name|getClassLoader
argument_list|()
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|ClassNotFoundException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
specifier|private
name|Class
argument_list|<
name|?
extends|extends
name|RecordReader
argument_list|>
name|getDefaultRecordReader
parameter_list|()
throws|throws
name|SemanticException
block|{
name|String
name|name
decl_stmt|;
name|name
operator|=
name|conf
operator|.
name|getVar
argument_list|(
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVESCRIPTRECORDREADER
argument_list|)
expr_stmt|;
try|try
block|{
return|return
operator|(
name|Class
argument_list|<
name|?
extends|extends
name|RecordReader
argument_list|>
operator|)
name|Class
operator|.
name|forName
argument_list|(
name|name
argument_list|,
literal|true
argument_list|,
name|JavaUtils
operator|.
name|getClassLoader
argument_list|()
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|ClassNotFoundException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
specifier|private
name|Class
argument_list|<
name|?
extends|extends
name|RecordWriter
argument_list|>
name|getRecordWriter
parameter_list|(
name|ASTNode
name|node
parameter_list|)
throws|throws
name|SemanticException
block|{
name|String
name|name
decl_stmt|;
if|if
condition|(
name|node
operator|.
name|getChildCount
argument_list|()
operator|==
literal|0
condition|)
block|{
name|name
operator|=
name|conf
operator|.
name|getVar
argument_list|(
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVESCRIPTRECORDWRITER
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|name
operator|=
name|unescapeSQLString
argument_list|(
name|node
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getText
argument_list|()
argument_list|)
expr_stmt|;
block|}
try|try
block|{
return|return
operator|(
name|Class
argument_list|<
name|?
extends|extends
name|RecordWriter
argument_list|>
operator|)
name|Class
operator|.
name|forName
argument_list|(
name|name
argument_list|,
literal|true
argument_list|,
name|JavaUtils
operator|.
name|getClassLoader
argument_list|()
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|ClassNotFoundException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
comment|/**    * This function is a wrapper of parseInfo.getGroupByForClause which    * automatically translates SELECT DISTINCT a,b,c to SELECT a,b,c GROUP BY    * a,b,c.    */
specifier|static
name|List
argument_list|<
name|ASTNode
argument_list|>
name|getGroupByForClause
parameter_list|(
name|QBParseInfo
name|parseInfo
parameter_list|,
name|String
name|dest
parameter_list|)
block|{
if|if
condition|(
name|parseInfo
operator|.
name|getSelForClause
argument_list|(
name|dest
argument_list|)
operator|.
name|getToken
argument_list|()
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_SELECTDI
condition|)
block|{
name|ASTNode
name|selectExprs
init|=
name|parseInfo
operator|.
name|getSelForClause
argument_list|(
name|dest
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|ASTNode
argument_list|>
name|result
init|=
operator|new
name|ArrayList
argument_list|<
name|ASTNode
argument_list|>
argument_list|(
name|selectExprs
operator|==
literal|null
condition|?
literal|0
else|:
name|selectExprs
operator|.
name|getChildCount
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|selectExprs
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|selectExprs
operator|.
name|getChildCount
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
operator|(
operator|(
name|ASTNode
operator|)
name|selectExprs
operator|.
name|getChild
argument_list|(
name|i
argument_list|)
operator|)
operator|.
name|getToken
argument_list|()
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_HINTLIST
condition|)
block|{
continue|continue;
block|}
comment|// table.column AS alias
name|ASTNode
name|grpbyExpr
init|=
operator|(
name|ASTNode
operator|)
name|selectExprs
operator|.
name|getChild
argument_list|(
name|i
argument_list|)
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|result
operator|.
name|add
argument_list|(
name|grpbyExpr
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|result
return|;
block|}
else|else
block|{
name|ASTNode
name|grpByExprs
init|=
name|parseInfo
operator|.
name|getGroupByForClause
argument_list|(
name|dest
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|ASTNode
argument_list|>
name|result
init|=
operator|new
name|ArrayList
argument_list|<
name|ASTNode
argument_list|>
argument_list|(
name|grpByExprs
operator|==
literal|null
condition|?
literal|0
else|:
name|grpByExprs
operator|.
name|getChildCount
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|grpByExprs
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|grpByExprs
operator|.
name|getChildCount
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|ASTNode
name|grpbyExpr
init|=
operator|(
name|ASTNode
operator|)
name|grpByExprs
operator|.
name|getChild
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|result
operator|.
name|add
argument_list|(
name|grpbyExpr
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|result
return|;
block|}
block|}
specifier|private
specifier|static
name|String
index|[]
name|getColAlias
parameter_list|(
name|ASTNode
name|selExpr
parameter_list|,
name|String
name|defaultName
parameter_list|,
name|RowResolver
name|inputRR
parameter_list|)
block|{
name|String
name|colAlias
init|=
literal|null
decl_stmt|;
name|String
name|tabAlias
init|=
literal|null
decl_stmt|;
name|String
index|[]
name|colRef
init|=
operator|new
name|String
index|[
literal|2
index|]
decl_stmt|;
if|if
condition|(
name|selExpr
operator|.
name|getChildCount
argument_list|()
operator|==
literal|2
condition|)
block|{
comment|// return zz for "xx + yy AS zz"
name|colAlias
operator|=
name|unescapeIdentifier
argument_list|(
name|selExpr
operator|.
name|getChild
argument_list|(
literal|1
argument_list|)
operator|.
name|getText
argument_list|()
argument_list|)
expr_stmt|;
name|colRef
index|[
literal|0
index|]
operator|=
name|tabAlias
expr_stmt|;
name|colRef
index|[
literal|1
index|]
operator|=
name|colAlias
expr_stmt|;
return|return
name|colRef
return|;
block|}
name|ASTNode
name|root
init|=
operator|(
name|ASTNode
operator|)
name|selExpr
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|root
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_TABLE_OR_COL
condition|)
block|{
name|colAlias
operator|=
name|root
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getText
argument_list|()
expr_stmt|;
name|colRef
index|[
literal|0
index|]
operator|=
name|tabAlias
expr_stmt|;
name|colRef
index|[
literal|1
index|]
operator|=
name|colAlias
expr_stmt|;
return|return
name|colRef
return|;
block|}
if|if
condition|(
name|root
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|DOT
condition|)
block|{
name|ASTNode
name|tab
init|=
operator|(
name|ASTNode
operator|)
name|root
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|tab
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_TABLE_OR_COL
condition|)
block|{
name|String
name|t
init|=
name|unescapeIdentifier
argument_list|(
name|tab
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getText
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|inputRR
operator|.
name|hasTableAlias
argument_list|(
name|t
argument_list|)
condition|)
block|{
name|tabAlias
operator|=
name|t
expr_stmt|;
block|}
block|}
comment|// Return zz for "xx.zz" and "xx.yy.zz"
name|ASTNode
name|col
init|=
operator|(
name|ASTNode
operator|)
name|root
operator|.
name|getChild
argument_list|(
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|col
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|Identifier
condition|)
block|{
name|colAlias
operator|=
name|unescapeIdentifier
argument_list|(
name|col
operator|.
name|getText
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|colAlias
operator|==
literal|null
condition|)
block|{
comment|// Return defaultName if selExpr is not a simple xx.yy.zz
name|colAlias
operator|=
name|defaultName
expr_stmt|;
block|}
name|colRef
index|[
literal|0
index|]
operator|=
name|tabAlias
expr_stmt|;
name|colRef
index|[
literal|1
index|]
operator|=
name|colAlias
expr_stmt|;
return|return
name|colRef
return|;
block|}
comment|/**    * Returns whether the pattern is a regex expression (instead of a normal    * string). Normal string is a string with all alphabets/digits and "_".    */
specifier|private
specifier|static
name|boolean
name|isRegex
parameter_list|(
name|String
name|pattern
parameter_list|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|pattern
operator|.
name|length
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|Character
operator|.
name|isLetterOrDigit
argument_list|(
name|pattern
operator|.
name|charAt
argument_list|(
name|i
argument_list|)
argument_list|)
operator|&&
name|pattern
operator|.
name|charAt
argument_list|(
name|i
argument_list|)
operator|!=
literal|'_'
condition|)
block|{
return|return
literal|true
return|;
block|}
block|}
return|return
literal|false
return|;
block|}
specifier|private
name|Operator
argument_list|<
name|?
argument_list|>
name|genSelectPlan
parameter_list|(
name|String
name|dest
parameter_list|,
name|QB
name|qb
parameter_list|,
name|Operator
argument_list|<
name|?
argument_list|>
name|input
parameter_list|)
throws|throws
name|SemanticException
block|{
name|ASTNode
name|selExprList
init|=
name|qb
operator|.
name|getParseInfo
argument_list|()
operator|.
name|getSelForClause
argument_list|(
name|dest
argument_list|)
decl_stmt|;
name|Operator
argument_list|<
name|?
argument_list|>
name|op
init|=
name|genSelectPlan
argument_list|(
name|selExprList
argument_list|,
name|qb
argument_list|,
name|input
argument_list|)
decl_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Created Select Plan for clause: "
operator|+
name|dest
argument_list|)
expr_stmt|;
block|}
return|return
name|op
return|;
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"nls"
argument_list|)
specifier|private
name|Operator
argument_list|<
name|?
argument_list|>
name|genSelectPlan
parameter_list|(
name|ASTNode
name|selExprList
parameter_list|,
name|QB
name|qb
parameter_list|,
name|Operator
argument_list|<
name|?
argument_list|>
name|input
parameter_list|)
throws|throws
name|SemanticException
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"tree: "
operator|+
name|selExprList
operator|.
name|toStringTree
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|ArrayList
argument_list|<
name|ExprNodeDesc
argument_list|>
name|col_list
init|=
operator|new
name|ArrayList
argument_list|<
name|ExprNodeDesc
argument_list|>
argument_list|()
decl_stmt|;
name|RowResolver
name|out_rwsch
init|=
operator|new
name|RowResolver
argument_list|()
decl_stmt|;
name|ASTNode
name|trfm
init|=
literal|null
decl_stmt|;
name|String
name|alias
init|=
name|qb
operator|.
name|getParseInfo
argument_list|()
operator|.
name|getAlias
argument_list|()
decl_stmt|;
name|Integer
name|pos
init|=
name|Integer
operator|.
name|valueOf
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|RowResolver
name|inputRR
init|=
name|opParseCtx
operator|.
name|get
argument_list|(
name|input
argument_list|)
operator|.
name|getRowResolver
argument_list|()
decl_stmt|;
comment|// SELECT * or SELECT TRANSFORM(*)
name|boolean
name|selectStar
init|=
literal|false
decl_stmt|;
name|int
name|posn
init|=
literal|0
decl_stmt|;
name|boolean
name|hintPresent
init|=
operator|(
name|selExprList
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_HINTLIST
operator|)
decl_stmt|;
if|if
condition|(
name|hintPresent
condition|)
block|{
name|posn
operator|++
expr_stmt|;
block|}
name|boolean
name|isInTransform
init|=
operator|(
name|selExprList
operator|.
name|getChild
argument_list|(
name|posn
argument_list|)
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_TRANSFORM
operator|)
decl_stmt|;
if|if
condition|(
name|isInTransform
condition|)
block|{
name|globalLimitCtx
operator|.
name|setHasTransformOrUDTF
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|trfm
operator|=
operator|(
name|ASTNode
operator|)
name|selExprList
operator|.
name|getChild
argument_list|(
name|posn
argument_list|)
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
comment|// Detect queries of the form SELECT udtf(col) AS ...
comment|// by looking for a function as the first child, and then checking to see
comment|// if the function is a Generic UDTF. It's not as clean as TRANSFORM due to
comment|// the lack of a special token.
name|boolean
name|isUDTF
init|=
literal|false
decl_stmt|;
name|String
name|udtfTableAlias
init|=
literal|null
decl_stmt|;
name|ArrayList
argument_list|<
name|String
argument_list|>
name|udtfColAliases
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
name|ASTNode
name|udtfExpr
init|=
operator|(
name|ASTNode
operator|)
name|selExprList
operator|.
name|getChild
argument_list|(
name|posn
argument_list|)
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|GenericUDTF
name|genericUDTF
init|=
literal|null
decl_stmt|;
name|int
name|udtfExprType
init|=
name|udtfExpr
operator|.
name|getType
argument_list|()
decl_stmt|;
if|if
condition|(
name|udtfExprType
operator|==
name|HiveParser
operator|.
name|TOK_FUNCTION
operator|||
name|udtfExprType
operator|==
name|HiveParser
operator|.
name|TOK_FUNCTIONSTAR
condition|)
block|{
name|String
name|funcName
init|=
name|TypeCheckProcFactory
operator|.
name|DefaultExprProcessor
operator|.
name|getFunctionText
argument_list|(
name|udtfExpr
argument_list|,
literal|true
argument_list|)
decl_stmt|;
name|FunctionInfo
name|fi
init|=
name|FunctionRegistry
operator|.
name|getFunctionInfo
argument_list|(
name|funcName
argument_list|)
decl_stmt|;
if|if
condition|(
name|fi
operator|!=
literal|null
condition|)
block|{
name|genericUDTF
operator|=
name|fi
operator|.
name|getGenericUDTF
argument_list|()
expr_stmt|;
block|}
name|isUDTF
operator|=
operator|(
name|genericUDTF
operator|!=
literal|null
operator|)
expr_stmt|;
if|if
condition|(
name|isUDTF
condition|)
block|{
name|globalLimitCtx
operator|.
name|setHasTransformOrUDTF
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|isUDTF
operator|&&
operator|!
name|fi
operator|.
name|isNative
argument_list|()
condition|)
block|{
name|unparseTranslator
operator|.
name|addIdentifierTranslation
argument_list|(
operator|(
name|ASTNode
operator|)
name|udtfExpr
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|isUDTF
condition|)
block|{
comment|// Only support a single expression when it's a UDTF
if|if
condition|(
name|selExprList
operator|.
name|getChildCount
argument_list|()
operator|>
literal|1
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|generateErrorMessage
argument_list|(
operator|(
name|ASTNode
operator|)
name|selExprList
operator|.
name|getChild
argument_list|(
literal|1
argument_list|)
argument_list|,
name|ErrorMsg
operator|.
name|UDTF_MULTIPLE_EXPR
operator|.
name|getMsg
argument_list|()
argument_list|)
argument_list|)
throw|;
block|}
comment|// Require an AS for UDTFs for column aliases
name|ASTNode
name|selExpr
init|=
operator|(
name|ASTNode
operator|)
name|selExprList
operator|.
name|getChild
argument_list|(
name|posn
argument_list|)
decl_stmt|;
if|if
condition|(
name|selExpr
operator|.
name|getChildCount
argument_list|()
operator|<
literal|2
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|generateErrorMessage
argument_list|(
name|udtfExpr
argument_list|,
name|ErrorMsg
operator|.
name|UDTF_REQUIRE_AS
operator|.
name|getMsg
argument_list|()
argument_list|)
argument_list|)
throw|;
block|}
comment|// Get the column / table aliases from the expression. Start from 1 as
comment|// 0 is the TOK_FUNCTION
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<
name|selExpr
operator|.
name|getChildCount
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|ASTNode
name|selExprChild
init|=
operator|(
name|ASTNode
operator|)
name|selExpr
operator|.
name|getChild
argument_list|(
name|i
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|selExprChild
operator|.
name|getType
argument_list|()
condition|)
block|{
case|case
name|HiveParser
operator|.
name|Identifier
case|:
name|udtfColAliases
operator|.
name|add
argument_list|(
name|unescapeIdentifier
argument_list|(
name|selExprChild
operator|.
name|getText
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|unparseTranslator
operator|.
name|addIdentifierTranslation
argument_list|(
name|selExprChild
argument_list|)
expr_stmt|;
break|break;
case|case
name|HiveParser
operator|.
name|TOK_TABALIAS
case|:
assert|assert
operator|(
name|selExprChild
operator|.
name|getChildCount
argument_list|()
operator|==
literal|1
operator|)
assert|;
name|udtfTableAlias
operator|=
name|unescapeIdentifier
argument_list|(
name|selExprChild
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getText
argument_list|()
argument_list|)
expr_stmt|;
name|qb
operator|.
name|addAlias
argument_list|(
name|udtfTableAlias
argument_list|)
expr_stmt|;
name|unparseTranslator
operator|.
name|addIdentifierTranslation
argument_list|(
operator|(
name|ASTNode
operator|)
name|selExprChild
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
assert|assert
operator|(
literal|false
operator|)
assert|;
block|}
block|}
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"UDTF table alias is "
operator|+
name|udtfTableAlias
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"UDTF col aliases are "
operator|+
name|udtfColAliases
argument_list|)
expr_stmt|;
block|}
block|}
comment|// The list of expressions after SELECT or SELECT TRANSFORM.
name|ASTNode
name|exprList
decl_stmt|;
if|if
condition|(
name|isInTransform
condition|)
block|{
name|exprList
operator|=
operator|(
name|ASTNode
operator|)
name|trfm
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|isUDTF
condition|)
block|{
name|exprList
operator|=
name|udtfExpr
expr_stmt|;
block|}
else|else
block|{
name|exprList
operator|=
name|selExprList
expr_stmt|;
block|}
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"genSelectPlan: input = "
operator|+
name|inputRR
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// For UDTF's, skip the function name to get the expressions
name|int
name|startPosn
init|=
name|isUDTF
condition|?
name|posn
operator|+
literal|1
else|:
name|posn
decl_stmt|;
if|if
condition|(
name|isInTransform
condition|)
block|{
name|startPosn
operator|=
literal|0
expr_stmt|;
block|}
comment|// Iterate over all expression (either after SELECT, or in SELECT TRANSFORM)
for|for
control|(
name|int
name|i
init|=
name|startPosn
init|;
name|i
operator|<
name|exprList
operator|.
name|getChildCount
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
comment|// child can be EXPR AS ALIAS, or EXPR.
name|ASTNode
name|child
init|=
operator|(
name|ASTNode
operator|)
name|exprList
operator|.
name|getChild
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|boolean
name|hasAsClause
init|=
operator|(
operator|!
name|isInTransform
operator|)
operator|&&
operator|(
name|child
operator|.
name|getChildCount
argument_list|()
operator|==
literal|2
operator|)
decl_stmt|;
comment|// EXPR AS (ALIAS,...) parses, but is only allowed for UDTF's
comment|// This check is not needed and invalid when there is a transform b/c the
comment|// AST's are slightly different.
if|if
condition|(
operator|!
name|isInTransform
operator|&&
operator|!
name|isUDTF
operator|&&
name|child
operator|.
name|getChildCount
argument_list|()
operator|>
literal|2
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|generateErrorMessage
argument_list|(
operator|(
name|ASTNode
operator|)
name|child
operator|.
name|getChild
argument_list|(
literal|2
argument_list|)
argument_list|,
name|ErrorMsg
operator|.
name|INVALID_AS
operator|.
name|getMsg
argument_list|()
argument_list|)
argument_list|)
throw|;
block|}
comment|// The real expression
name|ASTNode
name|expr
decl_stmt|;
name|String
name|tabAlias
decl_stmt|;
name|String
name|colAlias
decl_stmt|;
if|if
condition|(
name|isInTransform
operator|||
name|isUDTF
condition|)
block|{
name|tabAlias
operator|=
literal|null
expr_stmt|;
name|colAlias
operator|=
literal|"_C"
operator|+
name|i
expr_stmt|;
name|expr
operator|=
name|child
expr_stmt|;
block|}
else|else
block|{
name|String
index|[]
name|colRef
init|=
name|getColAlias
argument_list|(
name|child
argument_list|,
literal|"_C"
operator|+
name|i
argument_list|,
name|inputRR
argument_list|)
decl_stmt|;
name|tabAlias
operator|=
name|colRef
index|[
literal|0
index|]
expr_stmt|;
name|colAlias
operator|=
name|colRef
index|[
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|hasAsClause
condition|)
block|{
name|unparseTranslator
operator|.
name|addIdentifierTranslation
argument_list|(
operator|(
name|ASTNode
operator|)
name|child
operator|.
name|getChild
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// Get rid of TOK_SELEXPR
name|expr
operator|=
operator|(
name|ASTNode
operator|)
name|child
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|expr
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_ALLCOLREF
condition|)
block|{
name|pos
operator|=
name|genColListRegex
argument_list|(
literal|".*"
argument_list|,
name|expr
operator|.
name|getChildCount
argument_list|()
operator|==
literal|0
condition|?
literal|null
else|:
name|getUnescapedName
argument_list|(
operator|(
name|ASTNode
operator|)
name|expr
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
argument_list|)
operator|.
name|toLowerCase
argument_list|()
argument_list|,
name|expr
argument_list|,
name|col_list
argument_list|,
name|inputRR
argument_list|,
name|pos
argument_list|,
name|out_rwsch
argument_list|,
name|qb
operator|.
name|getAliases
argument_list|()
argument_list|)
expr_stmt|;
name|selectStar
operator|=
literal|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|expr
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_TABLE_OR_COL
operator|&&
operator|!
name|hasAsClause
operator|&&
operator|!
name|inputRR
operator|.
name|getIsExprResolver
argument_list|()
operator|&&
name|isRegex
argument_list|(
name|unescapeIdentifier
argument_list|(
name|expr
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getText
argument_list|()
argument_list|)
argument_list|)
condition|)
block|{
comment|// In case the expression is a regex COL.
comment|// This can only happen without AS clause
comment|// We don't allow this for ExprResolver - the Group By case
name|pos
operator|=
name|genColListRegex
argument_list|(
name|unescapeIdentifier
argument_list|(
name|expr
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getText
argument_list|()
argument_list|)
argument_list|,
literal|null
argument_list|,
name|expr
argument_list|,
name|col_list
argument_list|,
name|inputRR
argument_list|,
name|pos
argument_list|,
name|out_rwsch
argument_list|,
name|qb
operator|.
name|getAliases
argument_list|()
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|expr
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|DOT
operator|&&
name|expr
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_TABLE_OR_COL
operator|&&
name|inputRR
operator|.
name|hasTableAlias
argument_list|(
name|unescapeIdentifier
argument_list|(
name|expr
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getText
argument_list|()
operator|.
name|toLowerCase
argument_list|()
argument_list|)
argument_list|)
operator|&&
operator|!
name|hasAsClause
operator|&&
operator|!
name|inputRR
operator|.
name|getIsExprResolver
argument_list|()
operator|&&
name|isRegex
argument_list|(
name|unescapeIdentifier
argument_list|(
name|expr
operator|.
name|getChild
argument_list|(
literal|1
argument_list|)
operator|.
name|getText
argument_list|()
argument_list|)
argument_list|)
condition|)
block|{
comment|// In case the expression is TABLE.COL (col can be regex).
comment|// This can only happen without AS clause
comment|// We don't allow this for ExprResolver - the Group By case
name|pos
operator|=
name|genColListRegex
argument_list|(
name|unescapeIdentifier
argument_list|(
name|expr
operator|.
name|getChild
argument_list|(
literal|1
argument_list|)
operator|.
name|getText
argument_list|()
argument_list|)
argument_list|,
name|unescapeIdentifier
argument_list|(
name|expr
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getText
argument_list|()
operator|.
name|toLowerCase
argument_list|()
argument_list|)
argument_list|,
name|expr
argument_list|,
name|col_list
argument_list|,
name|inputRR
argument_list|,
name|pos
argument_list|,
name|out_rwsch
argument_list|,
name|qb
operator|.
name|getAliases
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// Case when this is an expression
name|TypeCheckCtx
name|tcCtx
init|=
operator|new
name|TypeCheckCtx
argument_list|(
name|inputRR
argument_list|)
decl_stmt|;
comment|// We allow stateful functions in the SELECT list (but nowhere else)
name|tcCtx
operator|.
name|setAllowStatefulFunctions
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|ExprNodeDesc
name|exp
init|=
name|genExprNodeDesc
argument_list|(
name|expr
argument_list|,
name|inputRR
argument_list|,
name|tcCtx
argument_list|)
decl_stmt|;
name|col_list
operator|.
name|add
argument_list|(
name|exp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|StringUtils
operator|.
name|isEmpty
argument_list|(
name|alias
argument_list|)
operator|&&
operator|(
name|out_rwsch
operator|.
name|get
argument_list|(
literal|null
argument_list|,
name|colAlias
argument_list|)
operator|!=
literal|null
operator|)
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|AMBIGUOUS_COLUMN
operator|.
name|getMsg
argument_list|(
name|colAlias
argument_list|)
argument_list|)
throw|;
block|}
name|out_rwsch
operator|.
name|put
argument_list|(
name|tabAlias
argument_list|,
name|colAlias
argument_list|,
operator|new
name|ColumnInfo
argument_list|(
name|getColumnInternalName
argument_list|(
name|pos
argument_list|)
argument_list|,
name|exp
operator|.
name|getTypeInfo
argument_list|()
argument_list|,
name|tabAlias
argument_list|,
literal|false
argument_list|)
argument_list|)
expr_stmt|;
name|pos
operator|=
name|Integer
operator|.
name|valueOf
argument_list|(
name|pos
operator|.
name|intValue
argument_list|()
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
name|selectStar
operator|=
name|selectStar
operator|&&
name|exprList
operator|.
name|getChildCount
argument_list|()
operator|==
name|posn
operator|+
literal|1
expr_stmt|;
name|ArrayList
argument_list|<
name|String
argument_list|>
name|columnNames
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|ExprNodeDesc
argument_list|>
name|colExprMap
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|ExprNodeDesc
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|col_list
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
comment|// Replace NULL with CAST(NULL AS STRING)
if|if
condition|(
name|col_list
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|instanceof
name|ExprNodeNullDesc
condition|)
block|{
name|col_list
operator|.
name|set
argument_list|(
name|i
argument_list|,
operator|new
name|ExprNodeConstantDesc
argument_list|(
name|TypeInfoFactory
operator|.
name|stringTypeInfo
argument_list|,
literal|null
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|String
name|outputCol
init|=
name|getColumnInternalName
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|colExprMap
operator|.
name|put
argument_list|(
name|outputCol
argument_list|,
name|col_list
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|columnNames
operator|.
name|add
argument_list|(
name|outputCol
argument_list|)
expr_stmt|;
block|}
name|Operator
name|output
init|=
name|putOpInsertMap
argument_list|(
name|OperatorFactory
operator|.
name|getAndMakeChild
argument_list|(
operator|new
name|SelectDesc
argument_list|(
name|col_list
argument_list|,
name|columnNames
argument_list|,
name|selectStar
argument_list|)
argument_list|,
operator|new
name|RowSchema
argument_list|(
name|out_rwsch
operator|.
name|getColumnInfos
argument_list|()
argument_list|)
argument_list|,
name|input
argument_list|)
argument_list|,
name|out_rwsch
argument_list|)
decl_stmt|;
name|output
operator|.
name|setColumnExprMap
argument_list|(
name|colExprMap
argument_list|)
expr_stmt|;
if|if
condition|(
name|isInTransform
condition|)
block|{
name|output
operator|=
name|genScriptPlan
argument_list|(
name|trfm
argument_list|,
name|qb
argument_list|,
name|output
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|isUDTF
condition|)
block|{
name|output
operator|=
name|genUDTFPlan
argument_list|(
name|genericUDTF
argument_list|,
name|udtfTableAlias
argument_list|,
name|udtfColAliases
argument_list|,
name|qb
argument_list|,
name|output
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Created Select Plan row schema: "
operator|+
name|out_rwsch
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|output
return|;
block|}
comment|/**    * Class to store GenericUDAF related information.    */
specifier|static
class|class
name|GenericUDAFInfo
block|{
name|ArrayList
argument_list|<
name|ExprNodeDesc
argument_list|>
name|convertedParameters
decl_stmt|;
name|GenericUDAFEvaluator
name|genericUDAFEvaluator
decl_stmt|;
name|TypeInfo
name|returnType
decl_stmt|;
block|}
comment|/**    * Convert exprNodeDesc array to Typeinfo array.    */
specifier|static
name|ArrayList
argument_list|<
name|TypeInfo
argument_list|>
name|getTypeInfo
parameter_list|(
name|ArrayList
argument_list|<
name|ExprNodeDesc
argument_list|>
name|exprs
parameter_list|)
block|{
name|ArrayList
argument_list|<
name|TypeInfo
argument_list|>
name|result
init|=
operator|new
name|ArrayList
argument_list|<
name|TypeInfo
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|ExprNodeDesc
name|expr
range|:
name|exprs
control|)
block|{
name|result
operator|.
name|add
argument_list|(
name|expr
operator|.
name|getTypeInfo
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
comment|/**    * Convert exprNodeDesc array to Typeinfo array.    */
specifier|static
name|ObjectInspector
index|[]
name|getStandardObjectInspector
parameter_list|(
name|ArrayList
argument_list|<
name|TypeInfo
argument_list|>
name|exprs
parameter_list|)
block|{
name|ObjectInspector
index|[]
name|result
init|=
operator|new
name|ObjectInspector
index|[
name|exprs
operator|.
name|size
argument_list|()
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|exprs
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|result
index|[
name|i
index|]
operator|=
name|TypeInfoUtils
operator|.
name|getStandardWritableObjectInspectorFromTypeInfo
argument_list|(
name|exprs
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
comment|/**    * Returns the GenericUDAFEvaluator for the aggregation. This is called once    * for each GroupBy aggregation.    */
specifier|static
name|GenericUDAFEvaluator
name|getGenericUDAFEvaluator
parameter_list|(
name|String
name|aggName
parameter_list|,
name|ArrayList
argument_list|<
name|ExprNodeDesc
argument_list|>
name|aggParameters
parameter_list|,
name|ASTNode
name|aggTree
parameter_list|,
name|boolean
name|isDistinct
parameter_list|,
name|boolean
name|isAllColumns
parameter_list|)
throws|throws
name|SemanticException
block|{
name|ArrayList
argument_list|<
name|TypeInfo
argument_list|>
name|originalParameterTypeInfos
init|=
name|getTypeInfo
argument_list|(
name|aggParameters
argument_list|)
decl_stmt|;
name|GenericUDAFEvaluator
name|result
init|=
name|FunctionRegistry
operator|.
name|getGenericUDAFEvaluator
argument_list|(
name|aggName
argument_list|,
name|originalParameterTypeInfos
argument_list|,
name|isDistinct
argument_list|,
name|isAllColumns
argument_list|)
decl_stmt|;
if|if
condition|(
literal|null
operator|==
name|result
condition|)
block|{
name|String
name|reason
init|=
literal|"Looking for UDAF Evaluator\""
operator|+
name|aggName
operator|+
literal|"\" with parameters "
operator|+
name|originalParameterTypeInfos
decl_stmt|;
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|INVALID_FUNCTION_SIGNATURE
operator|.
name|getMsg
argument_list|(
operator|(
name|ASTNode
operator|)
name|aggTree
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
argument_list|,
name|reason
argument_list|)
argument_list|)
throw|;
block|}
return|return
name|result
return|;
block|}
comment|/**    * Returns the GenericUDAFInfo struct for the aggregation.    *    * @param aggName    *          The name of the UDAF.    * @param aggParameters    *          The exprNodeDesc of the original parameters    * @param aggTree    *          The ASTNode node of the UDAF in the query.    * @return GenericUDAFInfo    * @throws SemanticException    *           when the UDAF is not found or has problems.    */
specifier|static
name|GenericUDAFInfo
name|getGenericUDAFInfo
parameter_list|(
name|GenericUDAFEvaluator
name|evaluator
parameter_list|,
name|GenericUDAFEvaluator
operator|.
name|Mode
name|emode
parameter_list|,
name|ArrayList
argument_list|<
name|ExprNodeDesc
argument_list|>
name|aggParameters
parameter_list|)
throws|throws
name|SemanticException
block|{
name|GenericUDAFInfo
name|r
init|=
operator|new
name|GenericUDAFInfo
argument_list|()
decl_stmt|;
comment|// set r.genericUDAFEvaluator
name|r
operator|.
name|genericUDAFEvaluator
operator|=
name|evaluator
expr_stmt|;
comment|// set r.returnType
name|ObjectInspector
name|returnOI
init|=
literal|null
decl_stmt|;
try|try
block|{
name|ObjectInspector
index|[]
name|aggObjectInspectors
init|=
name|getStandardObjectInspector
argument_list|(
name|getTypeInfo
argument_list|(
name|aggParameters
argument_list|)
argument_list|)
decl_stmt|;
name|returnOI
operator|=
name|r
operator|.
name|genericUDAFEvaluator
operator|.
name|init
argument_list|(
name|emode
argument_list|,
name|aggObjectInspectors
argument_list|)
expr_stmt|;
name|r
operator|.
name|returnType
operator|=
name|TypeInfoUtils
operator|.
name|getTypeInfoFromObjectInspector
argument_list|(
name|returnOI
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|HiveException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|e
argument_list|)
throw|;
block|}
comment|// set r.convertedParameters
comment|// TODO: type conversion
name|r
operator|.
name|convertedParameters
operator|=
name|aggParameters
expr_stmt|;
return|return
name|r
return|;
block|}
specifier|private
specifier|static
name|GenericUDAFEvaluator
operator|.
name|Mode
name|groupByDescModeToUDAFMode
parameter_list|(
name|GroupByDesc
operator|.
name|Mode
name|mode
parameter_list|,
name|boolean
name|isDistinct
parameter_list|)
block|{
switch|switch
condition|(
name|mode
condition|)
block|{
case|case
name|COMPLETE
case|:
return|return
name|GenericUDAFEvaluator
operator|.
name|Mode
operator|.
name|COMPLETE
return|;
case|case
name|PARTIAL1
case|:
return|return
name|GenericUDAFEvaluator
operator|.
name|Mode
operator|.
name|PARTIAL1
return|;
case|case
name|PARTIAL2
case|:
return|return
name|GenericUDAFEvaluator
operator|.
name|Mode
operator|.
name|PARTIAL2
return|;
case|case
name|PARTIALS
case|:
return|return
name|isDistinct
condition|?
name|GenericUDAFEvaluator
operator|.
name|Mode
operator|.
name|PARTIAL1
else|:
name|GenericUDAFEvaluator
operator|.
name|Mode
operator|.
name|PARTIAL2
return|;
case|case
name|FINAL
case|:
return|return
name|GenericUDAFEvaluator
operator|.
name|Mode
operator|.
name|FINAL
return|;
case|case
name|HASH
case|:
return|return
name|GenericUDAFEvaluator
operator|.
name|Mode
operator|.
name|PARTIAL1
return|;
case|case
name|MERGEPARTIAL
case|:
return|return
name|isDistinct
condition|?
name|GenericUDAFEvaluator
operator|.
name|Mode
operator|.
name|COMPLETE
else|:
name|GenericUDAFEvaluator
operator|.
name|Mode
operator|.
name|FINAL
return|;
default|default:
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"internal error in groupByDescModeToUDAFMode"
argument_list|)
throw|;
block|}
block|}
comment|/**    * Generate the GroupByOperator for the Query Block (parseInfo.getXXX(dest)).    * The new GroupByOperator will be a child of the reduceSinkOperatorInfo.    *    * @param mode    *          The mode of the aggregation (PARTIAL1 or COMPLETE)    * @param genericUDAFEvaluators    *          If not null, this function will store the mapping from Aggregation    *          StringTree to the genericUDAFEvaluator in this parameter, so it    *          can be used in the next-stage GroupBy aggregations.    * @return the new GroupByOperator    */
annotation|@
name|SuppressWarnings
argument_list|(
literal|"nls"
argument_list|)
specifier|private
name|Operator
name|genGroupByPlanGroupByOperator
parameter_list|(
name|QBParseInfo
name|parseInfo
parameter_list|,
name|String
name|dest
parameter_list|,
name|Operator
name|reduceSinkOperatorInfo
parameter_list|,
name|GroupByDesc
operator|.
name|Mode
name|mode
parameter_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|GenericUDAFEvaluator
argument_list|>
name|genericUDAFEvaluators
parameter_list|)
throws|throws
name|SemanticException
block|{
name|RowResolver
name|groupByInputRowResolver
init|=
name|opParseCtx
operator|.
name|get
argument_list|(
name|reduceSinkOperatorInfo
argument_list|)
operator|.
name|getRowResolver
argument_list|()
decl_stmt|;
name|RowResolver
name|groupByOutputRowResolver
init|=
operator|new
name|RowResolver
argument_list|()
decl_stmt|;
name|groupByOutputRowResolver
operator|.
name|setIsExprResolver
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|ArrayList
argument_list|<
name|ExprNodeDesc
argument_list|>
name|groupByKeys
init|=
operator|new
name|ArrayList
argument_list|<
name|ExprNodeDesc
argument_list|>
argument_list|()
decl_stmt|;
name|ArrayList
argument_list|<
name|AggregationDesc
argument_list|>
name|aggregations
init|=
operator|new
name|ArrayList
argument_list|<
name|AggregationDesc
argument_list|>
argument_list|()
decl_stmt|;
name|ArrayList
argument_list|<
name|String
argument_list|>
name|outputColumnNames
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|ExprNodeDesc
argument_list|>
name|colExprMap
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|ExprNodeDesc
argument_list|>
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|ASTNode
argument_list|>
name|grpByExprs
init|=
name|getGroupByForClause
argument_list|(
name|parseInfo
argument_list|,
name|dest
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|grpByExprs
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|ASTNode
name|grpbyExpr
init|=
name|grpByExprs
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|ColumnInfo
name|exprInfo
init|=
name|groupByInputRowResolver
operator|.
name|getExpression
argument_list|(
name|grpbyExpr
argument_list|)
decl_stmt|;
if|if
condition|(
name|exprInfo
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|INVALID_COLUMN
operator|.
name|getMsg
argument_list|(
name|grpbyExpr
argument_list|)
argument_list|)
throw|;
block|}
name|groupByKeys
operator|.
name|add
argument_list|(
operator|new
name|ExprNodeColumnDesc
argument_list|(
name|exprInfo
operator|.
name|getType
argument_list|()
argument_list|,
name|exprInfo
operator|.
name|getInternalName
argument_list|()
argument_list|,
literal|""
argument_list|,
literal|false
argument_list|)
argument_list|)
expr_stmt|;
name|String
name|field
init|=
name|getColumnInternalName
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|outputColumnNames
operator|.
name|add
argument_list|(
name|field
argument_list|)
expr_stmt|;
name|groupByOutputRowResolver
operator|.
name|putExpression
argument_list|(
name|grpbyExpr
argument_list|,
operator|new
name|ColumnInfo
argument_list|(
name|field
argument_list|,
name|exprInfo
operator|.
name|getType
argument_list|()
argument_list|,
literal|null
argument_list|,
literal|false
argument_list|)
argument_list|)
expr_stmt|;
name|colExprMap
operator|.
name|put
argument_list|(
name|field
argument_list|,
name|groupByKeys
operator|.
name|get
argument_list|(
name|groupByKeys
operator|.
name|size
argument_list|()
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// For each aggregation
name|HashMap
argument_list|<
name|String
argument_list|,
name|ASTNode
argument_list|>
name|aggregationTrees
init|=
name|parseInfo
operator|.
name|getAggregationExprsForClause
argument_list|(
name|dest
argument_list|)
decl_stmt|;
assert|assert
operator|(
name|aggregationTrees
operator|!=
literal|null
operator|)
assert|;
comment|// get the last colName for the reduce KEY
comment|// it represents the column name corresponding to distinct aggr, if any
name|String
name|lastKeyColName
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|reduceSinkOperatorInfo
operator|.
name|getConf
argument_list|()
operator|instanceof
name|ReduceSinkDesc
condition|)
block|{
name|List
argument_list|<
name|String
argument_list|>
name|inputKeyCols
init|=
operator|(
operator|(
name|ReduceSinkDesc
operator|)
name|reduceSinkOperatorInfo
operator|.
name|getConf
argument_list|()
operator|)
operator|.
name|getOutputKeyColumnNames
argument_list|()
decl_stmt|;
if|if
condition|(
name|inputKeyCols
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
name|lastKeyColName
operator|=
name|inputKeyCols
operator|.
name|get
argument_list|(
name|inputKeyCols
operator|.
name|size
argument_list|()
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
name|int
name|numDistinctUDFs
init|=
literal|0
decl_stmt|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|ASTNode
argument_list|>
name|entry
range|:
name|aggregationTrees
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|ASTNode
name|value
init|=
name|entry
operator|.
name|getValue
argument_list|()
decl_stmt|;
comment|// This is the GenericUDAF name
name|String
name|aggName
init|=
name|value
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getText
argument_list|()
decl_stmt|;
name|boolean
name|isDistinct
init|=
name|value
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_FUNCTIONDI
decl_stmt|;
name|boolean
name|isAllColumns
init|=
name|value
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_FUNCTIONSTAR
decl_stmt|;
comment|// Convert children to aggParameters
name|ArrayList
argument_list|<
name|ExprNodeDesc
argument_list|>
name|aggParameters
init|=
operator|new
name|ArrayList
argument_list|<
name|ExprNodeDesc
argument_list|>
argument_list|()
decl_stmt|;
comment|// 0 is the function name
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<
name|value
operator|.
name|getChildCount
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|ASTNode
name|paraExpr
init|=
operator|(
name|ASTNode
operator|)
name|value
operator|.
name|getChild
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|ColumnInfo
name|paraExprInfo
init|=
name|groupByInputRowResolver
operator|.
name|getExpression
argument_list|(
name|paraExpr
argument_list|)
decl_stmt|;
if|if
condition|(
name|paraExprInfo
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|INVALID_COLUMN
operator|.
name|getMsg
argument_list|(
name|paraExpr
argument_list|)
argument_list|)
throw|;
block|}
name|String
name|paraExpression
init|=
name|paraExprInfo
operator|.
name|getInternalName
argument_list|()
decl_stmt|;
assert|assert
operator|(
name|paraExpression
operator|!=
literal|null
operator|)
assert|;
if|if
condition|(
name|isDistinct
operator|&&
name|lastKeyColName
operator|!=
literal|null
condition|)
block|{
comment|// if aggr is distinct, the parameter is name is constructed as
comment|// KEY.lastKeyColName:<tag>._colx
name|paraExpression
operator|=
name|Utilities
operator|.
name|ReduceField
operator|.
name|KEY
operator|.
name|name
argument_list|()
operator|+
literal|"."
operator|+
name|lastKeyColName
operator|+
literal|":"
operator|+
name|numDistinctUDFs
operator|+
literal|"."
operator|+
name|getColumnInternalName
argument_list|(
name|i
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
name|aggParameters
operator|.
name|add
argument_list|(
operator|new
name|ExprNodeColumnDesc
argument_list|(
name|paraExprInfo
operator|.
name|getType
argument_list|()
argument_list|,
name|paraExpression
argument_list|,
name|paraExprInfo
operator|.
name|getTabAlias
argument_list|()
argument_list|,
name|paraExprInfo
operator|.
name|getIsVirtualCol
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|isDistinct
condition|)
block|{
name|numDistinctUDFs
operator|++
expr_stmt|;
block|}
name|Mode
name|amode
init|=
name|groupByDescModeToUDAFMode
argument_list|(
name|mode
argument_list|,
name|isDistinct
argument_list|)
decl_stmt|;
name|GenericUDAFEvaluator
name|genericUDAFEvaluator
init|=
name|getGenericUDAFEvaluator
argument_list|(
name|aggName
argument_list|,
name|aggParameters
argument_list|,
name|value
argument_list|,
name|isDistinct
argument_list|,
name|isAllColumns
argument_list|)
decl_stmt|;
assert|assert
operator|(
name|genericUDAFEvaluator
operator|!=
literal|null
operator|)
assert|;
name|GenericUDAFInfo
name|udaf
init|=
name|getGenericUDAFInfo
argument_list|(
name|genericUDAFEvaluator
argument_list|,
name|amode
argument_list|,
name|aggParameters
argument_list|)
decl_stmt|;
name|aggregations
operator|.
name|add
argument_list|(
operator|new
name|AggregationDesc
argument_list|(
name|aggName
operator|.
name|toLowerCase
argument_list|()
argument_list|,
name|udaf
operator|.
name|genericUDAFEvaluator
argument_list|,
name|udaf
operator|.
name|convertedParameters
argument_list|,
name|isDistinct
argument_list|,
name|amode
argument_list|)
argument_list|)
expr_stmt|;
name|String
name|field
init|=
name|getColumnInternalName
argument_list|(
name|groupByKeys
operator|.
name|size
argument_list|()
operator|+
name|aggregations
operator|.
name|size
argument_list|()
operator|-
literal|1
argument_list|)
decl_stmt|;
name|outputColumnNames
operator|.
name|add
argument_list|(
name|field
argument_list|)
expr_stmt|;
name|groupByOutputRowResolver
operator|.
name|putExpression
argument_list|(
name|value
argument_list|,
operator|new
name|ColumnInfo
argument_list|(
name|field
argument_list|,
name|udaf
operator|.
name|returnType
argument_list|,
literal|""
argument_list|,
literal|false
argument_list|)
argument_list|)
expr_stmt|;
comment|// Save the evaluator so that it can be used by the next-stage
comment|// GroupByOperators
if|if
condition|(
name|genericUDAFEvaluators
operator|!=
literal|null
condition|)
block|{
name|genericUDAFEvaluators
operator|.
name|put
argument_list|(
name|entry
operator|.
name|getKey
argument_list|()
argument_list|,
name|genericUDAFEvaluator
argument_list|)
expr_stmt|;
block|}
block|}
name|float
name|groupByMemoryUsage
init|=
name|HiveConf
operator|.
name|getFloatVar
argument_list|(
name|conf
argument_list|,
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVEMAPAGGRHASHMEMORY
argument_list|)
decl_stmt|;
name|float
name|memoryThreshold
init|=
name|HiveConf
operator|.
name|getFloatVar
argument_list|(
name|conf
argument_list|,
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVEMAPAGGRMEMORYTHRESHOLD
argument_list|)
decl_stmt|;
name|Operator
name|op
init|=
name|putOpInsertMap
argument_list|(
name|OperatorFactory
operator|.
name|getAndMakeChild
argument_list|(
operator|new
name|GroupByDesc
argument_list|(
name|mode
argument_list|,
name|outputColumnNames
argument_list|,
name|groupByKeys
argument_list|,
name|aggregations
argument_list|,
literal|false
argument_list|,
name|groupByMemoryUsage
argument_list|,
name|memoryThreshold
argument_list|)
argument_list|,
operator|new
name|RowSchema
argument_list|(
name|groupByOutputRowResolver
operator|.
name|getColumnInfos
argument_list|()
argument_list|)
argument_list|,
name|reduceSinkOperatorInfo
argument_list|)
argument_list|,
name|groupByOutputRowResolver
argument_list|)
decl_stmt|;
name|op
operator|.
name|setColumnExprMap
argument_list|(
name|colExprMap
argument_list|)
expr_stmt|;
return|return
name|op
return|;
block|}
comment|/**    * Generate the GroupByOperator for the Query Block (parseInfo.getXXX(dest)).    * The new GroupByOperator will be a child of the reduceSinkOperatorInfo.    *    * @param mode    *          The mode of the aggregation (MERGEPARTIAL, PARTIAL2)    * @param genericUDAFEvaluators    *          The mapping from Aggregation StringTree to the    *          genericUDAFEvaluator.    * @param distPartAggr    *          partial aggregation for distincts    * @return the new GroupByOperator    */
annotation|@
name|SuppressWarnings
argument_list|(
literal|"nls"
argument_list|)
specifier|private
name|Operator
name|genGroupByPlanGroupByOperator1
parameter_list|(
name|QBParseInfo
name|parseInfo
parameter_list|,
name|String
name|dest
parameter_list|,
name|Operator
name|reduceSinkOperatorInfo
parameter_list|,
name|GroupByDesc
operator|.
name|Mode
name|mode
parameter_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|GenericUDAFEvaluator
argument_list|>
name|genericUDAFEvaluators
parameter_list|,
name|boolean
name|distPartAgg
parameter_list|)
throws|throws
name|SemanticException
block|{
name|ArrayList
argument_list|<
name|String
argument_list|>
name|outputColumnNames
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
name|RowResolver
name|groupByInputRowResolver
init|=
name|opParseCtx
operator|.
name|get
argument_list|(
name|reduceSinkOperatorInfo
argument_list|)
operator|.
name|getRowResolver
argument_list|()
decl_stmt|;
name|RowResolver
name|groupByOutputRowResolver
init|=
operator|new
name|RowResolver
argument_list|()
decl_stmt|;
name|groupByOutputRowResolver
operator|.
name|setIsExprResolver
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|ArrayList
argument_list|<
name|ExprNodeDesc
argument_list|>
name|groupByKeys
init|=
operator|new
name|ArrayList
argument_list|<
name|ExprNodeDesc
argument_list|>
argument_list|()
decl_stmt|;
name|ArrayList
argument_list|<
name|AggregationDesc
argument_list|>
name|aggregations
init|=
operator|new
name|ArrayList
argument_list|<
name|AggregationDesc
argument_list|>
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|ASTNode
argument_list|>
name|grpByExprs
init|=
name|getGroupByForClause
argument_list|(
name|parseInfo
argument_list|,
name|dest
argument_list|)
decl_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|ExprNodeDesc
argument_list|>
name|colExprMap
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|ExprNodeDesc
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|grpByExprs
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|ASTNode
name|grpbyExpr
init|=
name|grpByExprs
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|ColumnInfo
name|exprInfo
init|=
name|groupByInputRowResolver
operator|.
name|getExpression
argument_list|(
name|grpbyExpr
argument_list|)
decl_stmt|;
if|if
condition|(
name|exprInfo
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|INVALID_COLUMN
operator|.
name|getMsg
argument_list|(
name|grpbyExpr
argument_list|)
argument_list|)
throw|;
block|}
name|groupByKeys
operator|.
name|add
argument_list|(
operator|new
name|ExprNodeColumnDesc
argument_list|(
name|exprInfo
operator|.
name|getType
argument_list|()
argument_list|,
name|exprInfo
operator|.
name|getInternalName
argument_list|()
argument_list|,
name|exprInfo
operator|.
name|getTabAlias
argument_list|()
argument_list|,
name|exprInfo
operator|.
name|getIsVirtualCol
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|String
name|field
init|=
name|getColumnInternalName
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|outputColumnNames
operator|.
name|add
argument_list|(
name|field
argument_list|)
expr_stmt|;
name|groupByOutputRowResolver
operator|.
name|putExpression
argument_list|(
name|grpbyExpr
argument_list|,
operator|new
name|ColumnInfo
argument_list|(
name|field
argument_list|,
name|exprInfo
operator|.
name|getType
argument_list|()
argument_list|,
literal|""
argument_list|,
literal|false
argument_list|)
argument_list|)
expr_stmt|;
name|colExprMap
operator|.
name|put
argument_list|(
name|field
argument_list|,
name|groupByKeys
operator|.
name|get
argument_list|(
name|groupByKeys
operator|.
name|size
argument_list|()
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|HashMap
argument_list|<
name|String
argument_list|,
name|ASTNode
argument_list|>
name|aggregationTrees
init|=
name|parseInfo
operator|.
name|getAggregationExprsForClause
argument_list|(
name|dest
argument_list|)
decl_stmt|;
comment|// get the last colName for the reduce KEY
comment|// it represents the column name corresponding to distinct aggr, if any
name|String
name|lastKeyColName
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|reduceSinkOperatorInfo
operator|.
name|getConf
argument_list|()
operator|instanceof
name|ReduceSinkDesc
condition|)
block|{
name|List
argument_list|<
name|String
argument_list|>
name|inputKeyCols
init|=
operator|(
operator|(
name|ReduceSinkDesc
operator|)
name|reduceSinkOperatorInfo
operator|.
name|getConf
argument_list|()
operator|)
operator|.
name|getOutputKeyColumnNames
argument_list|()
decl_stmt|;
if|if
condition|(
name|inputKeyCols
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
name|lastKeyColName
operator|=
name|inputKeyCols
operator|.
name|get
argument_list|(
name|inputKeyCols
operator|.
name|size
argument_list|()
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
name|int
name|numDistinctUDFs
init|=
literal|0
decl_stmt|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|ASTNode
argument_list|>
name|entry
range|:
name|aggregationTrees
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|ASTNode
name|value
init|=
name|entry
operator|.
name|getValue
argument_list|()
decl_stmt|;
name|String
name|aggName
init|=
name|value
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getText
argument_list|()
decl_stmt|;
name|ArrayList
argument_list|<
name|ExprNodeDesc
argument_list|>
name|aggParameters
init|=
operator|new
name|ArrayList
argument_list|<
name|ExprNodeDesc
argument_list|>
argument_list|()
decl_stmt|;
name|boolean
name|isDistinct
init|=
operator|(
name|value
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_FUNCTIONDI
operator|)
decl_stmt|;
comment|// If the function is distinct, partial aggregartion has not been done on
comment|// the client side.
comment|// If distPartAgg is set, the client is letting us know that partial
comment|// aggregation has not been done.
comment|// For eg: select a, count(b+c), count(distinct d+e) group by a
comment|// For count(b+c), if partial aggregation has been performed, then we
comment|// directly look for count(b+c).
comment|// Otherwise, we look for b+c.
comment|// For distincts, partial aggregation is never performed on the client
comment|// side, so always look for the parameters: d+e
name|boolean
name|partialAggDone
init|=
operator|!
operator|(
name|distPartAgg
operator|||
name|isDistinct
operator|)
decl_stmt|;
if|if
condition|(
operator|!
name|partialAggDone
condition|)
block|{
comment|// 0 is the function name
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<
name|value
operator|.
name|getChildCount
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|ASTNode
name|paraExpr
init|=
operator|(
name|ASTNode
operator|)
name|value
operator|.
name|getChild
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|ColumnInfo
name|paraExprInfo
init|=
name|groupByInputRowResolver
operator|.
name|getExpression
argument_list|(
name|paraExpr
argument_list|)
decl_stmt|;
if|if
condition|(
name|paraExprInfo
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|INVALID_COLUMN
operator|.
name|getMsg
argument_list|(
name|paraExpr
argument_list|)
argument_list|)
throw|;
block|}
name|String
name|paraExpression
init|=
name|paraExprInfo
operator|.
name|getInternalName
argument_list|()
decl_stmt|;
assert|assert
operator|(
name|paraExpression
operator|!=
literal|null
operator|)
assert|;
if|if
condition|(
name|isDistinct
operator|&&
name|lastKeyColName
operator|!=
literal|null
condition|)
block|{
comment|// if aggr is distinct, the parameter is name is constructed as
comment|// KEY.lastKeyColName:<tag>._colx
name|paraExpression
operator|=
name|Utilities
operator|.
name|ReduceField
operator|.
name|KEY
operator|.
name|name
argument_list|()
operator|+
literal|"."
operator|+
name|lastKeyColName
operator|+
literal|":"
operator|+
name|numDistinctUDFs
operator|+
literal|"."
operator|+
name|getColumnInternalName
argument_list|(
name|i
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
name|aggParameters
operator|.
name|add
argument_list|(
operator|new
name|ExprNodeColumnDesc
argument_list|(
name|paraExprInfo
operator|.
name|getType
argument_list|()
argument_list|,
name|paraExpression
argument_list|,
name|paraExprInfo
operator|.
name|getTabAlias
argument_list|()
argument_list|,
name|paraExprInfo
operator|.
name|getIsVirtualCol
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|ColumnInfo
name|paraExprInfo
init|=
name|groupByInputRowResolver
operator|.
name|getExpression
argument_list|(
name|value
argument_list|)
decl_stmt|;
if|if
condition|(
name|paraExprInfo
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|INVALID_COLUMN
operator|.
name|getMsg
argument_list|(
name|value
argument_list|)
argument_list|)
throw|;
block|}
name|String
name|paraExpression
init|=
name|paraExprInfo
operator|.
name|getInternalName
argument_list|()
decl_stmt|;
assert|assert
operator|(
name|paraExpression
operator|!=
literal|null
operator|)
assert|;
name|aggParameters
operator|.
name|add
argument_list|(
operator|new
name|ExprNodeColumnDesc
argument_list|(
name|paraExprInfo
operator|.
name|getType
argument_list|()
argument_list|,
name|paraExpression
argument_list|,
name|paraExprInfo
operator|.
name|getTabAlias
argument_list|()
argument_list|,
name|paraExprInfo
operator|.
name|getIsVirtualCol
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|isDistinct
condition|)
block|{
name|numDistinctUDFs
operator|++
expr_stmt|;
block|}
name|boolean
name|isAllColumns
init|=
name|value
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_FUNCTIONSTAR
decl_stmt|;
name|Mode
name|amode
init|=
name|groupByDescModeToUDAFMode
argument_list|(
name|mode
argument_list|,
name|isDistinct
argument_list|)
decl_stmt|;
name|GenericUDAFEvaluator
name|genericUDAFEvaluator
init|=
literal|null
decl_stmt|;
comment|// For distincts, partial aggregations have not been done
if|if
condition|(
name|distPartAgg
condition|)
block|{
name|genericUDAFEvaluator
operator|=
name|getGenericUDAFEvaluator
argument_list|(
name|aggName
argument_list|,
name|aggParameters
argument_list|,
name|value
argument_list|,
name|isDistinct
argument_list|,
name|isAllColumns
argument_list|)
expr_stmt|;
assert|assert
operator|(
name|genericUDAFEvaluator
operator|!=
literal|null
operator|)
assert|;
name|genericUDAFEvaluators
operator|.
name|put
argument_list|(
name|entry
operator|.
name|getKey
argument_list|()
argument_list|,
name|genericUDAFEvaluator
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|genericUDAFEvaluator
operator|=
name|genericUDAFEvaluators
operator|.
name|get
argument_list|(
name|entry
operator|.
name|getKey
argument_list|()
argument_list|)
expr_stmt|;
assert|assert
operator|(
name|genericUDAFEvaluator
operator|!=
literal|null
operator|)
assert|;
block|}
name|GenericUDAFInfo
name|udaf
init|=
name|getGenericUDAFInfo
argument_list|(
name|genericUDAFEvaluator
argument_list|,
name|amode
argument_list|,
name|aggParameters
argument_list|)
decl_stmt|;
name|aggregations
operator|.
name|add
argument_list|(
operator|new
name|AggregationDesc
argument_list|(
name|aggName
operator|.
name|toLowerCase
argument_list|()
argument_list|,
name|udaf
operator|.
name|genericUDAFEvaluator
argument_list|,
name|udaf
operator|.
name|convertedParameters
argument_list|,
operator|(
name|mode
operator|!=
name|GroupByDesc
operator|.
name|Mode
operator|.
name|FINAL
operator|&&
name|isDistinct
operator|)
argument_list|,
name|amode
argument_list|)
argument_list|)
expr_stmt|;
name|String
name|field
init|=
name|getColumnInternalName
argument_list|(
name|groupByKeys
operator|.
name|size
argument_list|()
operator|+
name|aggregations
operator|.
name|size
argument_list|()
operator|-
literal|1
argument_list|)
decl_stmt|;
name|outputColumnNames
operator|.
name|add
argument_list|(
name|field
argument_list|)
expr_stmt|;
name|groupByOutputRowResolver
operator|.
name|putExpression
argument_list|(
name|value
argument_list|,
operator|new
name|ColumnInfo
argument_list|(
name|field
argument_list|,
name|udaf
operator|.
name|returnType
argument_list|,
literal|""
argument_list|,
literal|false
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|float
name|groupByMemoryUsage
init|=
name|HiveConf
operator|.
name|getFloatVar
argument_list|(
name|conf
argument_list|,
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVEMAPAGGRHASHMEMORY
argument_list|)
decl_stmt|;
name|float
name|memoryThreshold
init|=
name|HiveConf
operator|.
name|getFloatVar
argument_list|(
name|conf
argument_list|,
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVEMAPAGGRMEMORYTHRESHOLD
argument_list|)
decl_stmt|;
name|Operator
name|op
init|=
name|putOpInsertMap
argument_list|(
name|OperatorFactory
operator|.
name|getAndMakeChild
argument_list|(
operator|new
name|GroupByDesc
argument_list|(
name|mode
argument_list|,
name|outputColumnNames
argument_list|,
name|groupByKeys
argument_list|,
name|aggregations
argument_list|,
name|distPartAgg
argument_list|,
name|groupByMemoryUsage
argument_list|,
name|memoryThreshold
argument_list|)
argument_list|,
operator|new
name|RowSchema
argument_list|(
name|groupByOutputRowResolver
operator|.
name|getColumnInfos
argument_list|()
argument_list|)
argument_list|,
name|reduceSinkOperatorInfo
argument_list|)
argument_list|,
name|groupByOutputRowResolver
argument_list|)
decl_stmt|;
name|op
operator|.
name|setColumnExprMap
argument_list|(
name|colExprMap
argument_list|)
expr_stmt|;
return|return
name|op
return|;
block|}
comment|/**    * Generate the map-side GroupByOperator for the Query Block    * (qb.getParseInfo().getXXX(dest)). The new GroupByOperator will be a child    * of the inputOperatorInfo.    *    * @param mode    *          The mode of the aggregation (HASH)    * @param genericUDAFEvaluators    *          If not null, this function will store the mapping from Aggregation    *          StringTree to the genericUDAFEvaluator in this parameter, so it    *          can be used in the next-stage GroupBy aggregations.    * @return the new GroupByOperator    */
annotation|@
name|SuppressWarnings
argument_list|(
literal|"nls"
argument_list|)
specifier|private
name|Operator
name|genGroupByPlanMapGroupByOperator
parameter_list|(
name|QB
name|qb
parameter_list|,
name|String
name|dest
parameter_list|,
name|Operator
name|inputOperatorInfo
parameter_list|,
name|GroupByDesc
operator|.
name|Mode
name|mode
parameter_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|GenericUDAFEvaluator
argument_list|>
name|genericUDAFEvaluators
parameter_list|)
throws|throws
name|SemanticException
block|{
name|RowResolver
name|groupByInputRowResolver
init|=
name|opParseCtx
operator|.
name|get
argument_list|(
name|inputOperatorInfo
argument_list|)
operator|.
name|getRowResolver
argument_list|()
decl_stmt|;
name|QBParseInfo
name|parseInfo
init|=
name|qb
operator|.
name|getParseInfo
argument_list|()
decl_stmt|;
name|RowResolver
name|groupByOutputRowResolver
init|=
operator|new
name|RowResolver
argument_list|()
decl_stmt|;
name|groupByOutputRowResolver
operator|.
name|setIsExprResolver
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|ArrayList
argument_list|<
name|ExprNodeDesc
argument_list|>
name|groupByKeys
init|=
operator|new
name|ArrayList
argument_list|<
name|ExprNodeDesc
argument_list|>
argument_list|()
decl_stmt|;
name|ArrayList
argument_list|<
name|String
argument_list|>
name|outputColumnNames
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
name|ArrayList
argument_list|<
name|AggregationDesc
argument_list|>
name|aggregations
init|=
operator|new
name|ArrayList
argument_list|<
name|AggregationDesc
argument_list|>
argument_list|()
decl_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|ExprNodeDesc
argument_list|>
name|colExprMap
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|ExprNodeDesc
argument_list|>
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|ASTNode
argument_list|>
name|grpByExprs
init|=
name|getGroupByForClause
argument_list|(
name|parseInfo
argument_list|,
name|dest
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|grpByExprs
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|ASTNode
name|grpbyExpr
init|=
name|grpByExprs
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|ExprNodeDesc
name|grpByExprNode
init|=
name|genExprNodeDesc
argument_list|(
name|grpbyExpr
argument_list|,
name|groupByInputRowResolver
argument_list|)
decl_stmt|;
name|groupByKeys
operator|.
name|add
argument_list|(
name|grpByExprNode
argument_list|)
expr_stmt|;
name|String
name|field
init|=
name|getColumnInternalName
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|outputColumnNames
operator|.
name|add
argument_list|(
name|field
argument_list|)
expr_stmt|;
name|groupByOutputRowResolver
operator|.
name|putExpression
argument_list|(
name|grpbyExpr
argument_list|,
operator|new
name|ColumnInfo
argument_list|(
name|field
argument_list|,
name|grpByExprNode
operator|.
name|getTypeInfo
argument_list|()
argument_list|,
literal|""
argument_list|,
literal|false
argument_list|)
argument_list|)
expr_stmt|;
name|colExprMap
operator|.
name|put
argument_list|(
name|field
argument_list|,
name|groupByKeys
operator|.
name|get
argument_list|(
name|groupByKeys
operator|.
name|size
argument_list|()
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// If there is a distinctFuncExp, add all parameters to the reduceKeys.
if|if
condition|(
operator|!
name|parseInfo
operator|.
name|getDistinctFuncExprsForClause
argument_list|(
name|dest
argument_list|)
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|List
argument_list|<
name|ASTNode
argument_list|>
name|list
init|=
name|parseInfo
operator|.
name|getDistinctFuncExprsForClause
argument_list|(
name|dest
argument_list|)
decl_stmt|;
name|int
name|numDistn
init|=
literal|0
decl_stmt|;
for|for
control|(
name|ASTNode
name|value
range|:
name|list
control|)
block|{
comment|// 0 is function name
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<
name|value
operator|.
name|getChildCount
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|ASTNode
name|parameter
init|=
operator|(
name|ASTNode
operator|)
name|value
operator|.
name|getChild
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|groupByOutputRowResolver
operator|.
name|getExpression
argument_list|(
name|parameter
argument_list|)
operator|==
literal|null
condition|)
block|{
name|ExprNodeDesc
name|distExprNode
init|=
name|genExprNodeDesc
argument_list|(
name|parameter
argument_list|,
name|groupByInputRowResolver
argument_list|)
decl_stmt|;
name|groupByKeys
operator|.
name|add
argument_list|(
name|distExprNode
argument_list|)
expr_stmt|;
name|numDistn
operator|++
expr_stmt|;
name|String
name|field
init|=
name|getColumnInternalName
argument_list|(
name|grpByExprs
operator|.
name|size
argument_list|()
operator|+
name|numDistn
operator|-
literal|1
argument_list|)
decl_stmt|;
name|outputColumnNames
operator|.
name|add
argument_list|(
name|field
argument_list|)
expr_stmt|;
name|groupByOutputRowResolver
operator|.
name|putExpression
argument_list|(
name|parameter
argument_list|,
operator|new
name|ColumnInfo
argument_list|(
name|field
argument_list|,
name|distExprNode
operator|.
name|getTypeInfo
argument_list|()
argument_list|,
literal|""
argument_list|,
literal|false
argument_list|)
argument_list|)
expr_stmt|;
name|colExprMap
operator|.
name|put
argument_list|(
name|field
argument_list|,
name|groupByKeys
operator|.
name|get
argument_list|(
name|groupByKeys
operator|.
name|size
argument_list|()
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
comment|// For each aggregation
name|HashMap
argument_list|<
name|String
argument_list|,
name|ASTNode
argument_list|>
name|aggregationTrees
init|=
name|parseInfo
operator|.
name|getAggregationExprsForClause
argument_list|(
name|dest
argument_list|)
decl_stmt|;
assert|assert
operator|(
name|aggregationTrees
operator|!=
literal|null
operator|)
assert|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|ASTNode
argument_list|>
name|entry
range|:
name|aggregationTrees
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|ASTNode
name|value
init|=
name|entry
operator|.
name|getValue
argument_list|()
decl_stmt|;
name|String
name|aggName
init|=
name|unescapeIdentifier
argument_list|(
name|value
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getText
argument_list|()
argument_list|)
decl_stmt|;
name|ArrayList
argument_list|<
name|ExprNodeDesc
argument_list|>
name|aggParameters
init|=
operator|new
name|ArrayList
argument_list|<
name|ExprNodeDesc
argument_list|>
argument_list|()
decl_stmt|;
operator|new
name|ArrayList
argument_list|<
name|Class
argument_list|<
name|?
argument_list|>
argument_list|>
argument_list|()
expr_stmt|;
comment|// 0 is the function name
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<
name|value
operator|.
name|getChildCount
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|ASTNode
name|paraExpr
init|=
operator|(
name|ASTNode
operator|)
name|value
operator|.
name|getChild
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|ExprNodeDesc
name|paraExprNode
init|=
name|genExprNodeDesc
argument_list|(
name|paraExpr
argument_list|,
name|groupByInputRowResolver
argument_list|)
decl_stmt|;
name|aggParameters
operator|.
name|add
argument_list|(
name|paraExprNode
argument_list|)
expr_stmt|;
block|}
name|boolean
name|isDistinct
init|=
name|value
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_FUNCTIONDI
decl_stmt|;
name|boolean
name|isAllColumns
init|=
name|value
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_FUNCTIONSTAR
decl_stmt|;
name|Mode
name|amode
init|=
name|groupByDescModeToUDAFMode
argument_list|(
name|mode
argument_list|,
name|isDistinct
argument_list|)
decl_stmt|;
name|GenericUDAFEvaluator
name|genericUDAFEvaluator
init|=
name|getGenericUDAFEvaluator
argument_list|(
name|aggName
argument_list|,
name|aggParameters
argument_list|,
name|value
argument_list|,
name|isDistinct
argument_list|,
name|isAllColumns
argument_list|)
decl_stmt|;
assert|assert
operator|(
name|genericUDAFEvaluator
operator|!=
literal|null
operator|)
assert|;
name|GenericUDAFInfo
name|udaf
init|=
name|getGenericUDAFInfo
argument_list|(
name|genericUDAFEvaluator
argument_list|,
name|amode
argument_list|,
name|aggParameters
argument_list|)
decl_stmt|;
name|aggregations
operator|.
name|add
argument_list|(
operator|new
name|AggregationDesc
argument_list|(
name|aggName
operator|.
name|toLowerCase
argument_list|()
argument_list|,
name|udaf
operator|.
name|genericUDAFEvaluator
argument_list|,
name|udaf
operator|.
name|convertedParameters
argument_list|,
name|isDistinct
argument_list|,
name|amode
argument_list|)
argument_list|)
expr_stmt|;
name|String
name|field
init|=
name|getColumnInternalName
argument_list|(
name|groupByKeys
operator|.
name|size
argument_list|()
operator|+
name|aggregations
operator|.
name|size
argument_list|()
operator|-
literal|1
argument_list|)
decl_stmt|;
name|outputColumnNames
operator|.
name|add
argument_list|(
name|field
argument_list|)
expr_stmt|;
name|groupByOutputRowResolver
operator|.
name|putExpression
argument_list|(
name|value
argument_list|,
operator|new
name|ColumnInfo
argument_list|(
name|field
argument_list|,
name|udaf
operator|.
name|returnType
argument_list|,
literal|""
argument_list|,
literal|false
argument_list|)
argument_list|)
expr_stmt|;
comment|// Save the evaluator so that it can be used by the next-stage
comment|// GroupByOperators
if|if
condition|(
name|genericUDAFEvaluators
operator|!=
literal|null
condition|)
block|{
name|genericUDAFEvaluators
operator|.
name|put
argument_list|(
name|entry
operator|.
name|getKey
argument_list|()
argument_list|,
name|genericUDAFEvaluator
argument_list|)
expr_stmt|;
block|}
block|}
name|float
name|groupByMemoryUsage
init|=
name|HiveConf
operator|.
name|getFloatVar
argument_list|(
name|conf
argument_list|,
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVEMAPAGGRHASHMEMORY
argument_list|)
decl_stmt|;
name|float
name|memoryThreshold
init|=
name|HiveConf
operator|.
name|getFloatVar
argument_list|(
name|conf
argument_list|,
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVEMAPAGGRMEMORYTHRESHOLD
argument_list|)
decl_stmt|;
name|Operator
name|op
init|=
name|putOpInsertMap
argument_list|(
name|OperatorFactory
operator|.
name|getAndMakeChild
argument_list|(
operator|new
name|GroupByDesc
argument_list|(
name|mode
argument_list|,
name|outputColumnNames
argument_list|,
name|groupByKeys
argument_list|,
name|aggregations
argument_list|,
literal|false
argument_list|,
name|groupByMemoryUsage
argument_list|,
name|memoryThreshold
argument_list|)
argument_list|,
operator|new
name|RowSchema
argument_list|(
name|groupByOutputRowResolver
operator|.
name|getColumnInfos
argument_list|()
argument_list|)
argument_list|,
name|inputOperatorInfo
argument_list|)
argument_list|,
name|groupByOutputRowResolver
argument_list|)
decl_stmt|;
name|op
operator|.
name|setColumnExprMap
argument_list|(
name|colExprMap
argument_list|)
expr_stmt|;
return|return
name|op
return|;
block|}
comment|/**    * Generate the ReduceSinkOperator for the Group By Query Block    * (qb.getPartInfo().getXXX(dest)). The new ReduceSinkOperator will be a child    * of inputOperatorInfo.    *    * It will put all Group By keys and the distinct field (if any) in the    * map-reduce sort key, and all other fields in the map-reduce value.    *    * @param numPartitionFields    *          the number of fields for map-reduce partitioning. This is usually    *          the number of fields in the Group By keys.    * @return the new ReduceSinkOperator.    * @throws SemanticException    */
annotation|@
name|SuppressWarnings
argument_list|(
literal|"nls"
argument_list|)
specifier|private
name|Operator
name|genGroupByPlanReduceSinkOperator
parameter_list|(
name|QB
name|qb
parameter_list|,
name|String
name|dest
parameter_list|,
name|Operator
name|inputOperatorInfo
parameter_list|,
name|int
name|numPartitionFields
parameter_list|,
name|int
name|numReducers
parameter_list|,
name|boolean
name|mapAggrDone
parameter_list|)
throws|throws
name|SemanticException
block|{
name|RowResolver
name|reduceSinkInputRowResolver
init|=
name|opParseCtx
operator|.
name|get
argument_list|(
name|inputOperatorInfo
argument_list|)
operator|.
name|getRowResolver
argument_list|()
decl_stmt|;
name|QBParseInfo
name|parseInfo
init|=
name|qb
operator|.
name|getParseInfo
argument_list|()
decl_stmt|;
name|RowResolver
name|reduceSinkOutputRowResolver
init|=
operator|new
name|RowResolver
argument_list|()
decl_stmt|;
name|reduceSinkOutputRowResolver
operator|.
name|setIsExprResolver
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|ExprNodeDesc
argument_list|>
name|colExprMap
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|ExprNodeDesc
argument_list|>
argument_list|()
decl_stmt|;
name|ArrayList
argument_list|<
name|ExprNodeDesc
argument_list|>
name|reduceKeys
init|=
operator|new
name|ArrayList
argument_list|<
name|ExprNodeDesc
argument_list|>
argument_list|()
decl_stmt|;
comment|// Pre-compute group-by keys and store in reduceKeys
name|List
argument_list|<
name|String
argument_list|>
name|outputKeyColumnNames
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|outputValueColumnNames
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|ASTNode
argument_list|>
name|grpByExprs
init|=
name|getGroupByForClause
argument_list|(
name|parseInfo
argument_list|,
name|dest
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|grpByExprs
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|ASTNode
name|grpbyExpr
init|=
name|grpByExprs
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|ExprNodeDesc
name|inputExpr
init|=
name|genExprNodeDesc
argument_list|(
name|grpbyExpr
argument_list|,
name|reduceSinkInputRowResolver
argument_list|)
decl_stmt|;
name|reduceKeys
operator|.
name|add
argument_list|(
name|inputExpr
argument_list|)
expr_stmt|;
if|if
condition|(
name|reduceSinkOutputRowResolver
operator|.
name|getExpression
argument_list|(
name|grpbyExpr
argument_list|)
operator|==
literal|null
condition|)
block|{
name|outputKeyColumnNames
operator|.
name|add
argument_list|(
name|getColumnInternalName
argument_list|(
name|reduceKeys
operator|.
name|size
argument_list|()
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|String
name|field
init|=
name|Utilities
operator|.
name|ReduceField
operator|.
name|KEY
operator|.
name|toString
argument_list|()
operator|+
literal|"."
operator|+
name|getColumnInternalName
argument_list|(
name|reduceKeys
operator|.
name|size
argument_list|()
operator|-
literal|1
argument_list|)
decl_stmt|;
name|ColumnInfo
name|colInfo
init|=
operator|new
name|ColumnInfo
argument_list|(
name|field
argument_list|,
name|reduceKeys
operator|.
name|get
argument_list|(
name|reduceKeys
operator|.
name|size
argument_list|()
operator|-
literal|1
argument_list|)
operator|.
name|getTypeInfo
argument_list|()
argument_list|,
literal|null
argument_list|,
literal|false
argument_list|)
decl_stmt|;
name|reduceSinkOutputRowResolver
operator|.
name|putExpression
argument_list|(
name|grpbyExpr
argument_list|,
name|colInfo
argument_list|)
expr_stmt|;
name|colExprMap
operator|.
name|put
argument_list|(
name|colInfo
operator|.
name|getInternalName
argument_list|()
argument_list|,
name|inputExpr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|DUPLICATE_GROUPBY_KEY
operator|.
name|getMsg
argument_list|(
name|grpbyExpr
argument_list|)
argument_list|)
throw|;
block|}
block|}
name|List
argument_list|<
name|List
argument_list|<
name|Integer
argument_list|>
argument_list|>
name|distinctColIndices
init|=
operator|new
name|ArrayList
argument_list|<
name|List
argument_list|<
name|Integer
argument_list|>
argument_list|>
argument_list|()
decl_stmt|;
comment|// If there is a distinctFuncExp, add all parameters to the reduceKeys.
if|if
condition|(
operator|!
name|parseInfo
operator|.
name|getDistinctFuncExprsForClause
argument_list|(
name|dest
argument_list|)
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|List
argument_list|<
name|ASTNode
argument_list|>
name|distFuncs
init|=
name|parseInfo
operator|.
name|getDistinctFuncExprsForClause
argument_list|(
name|dest
argument_list|)
decl_stmt|;
name|String
name|colName
init|=
name|getColumnInternalName
argument_list|(
name|reduceKeys
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
name|outputKeyColumnNames
operator|.
name|add
argument_list|(
name|colName
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|distFuncs
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|ASTNode
name|value
init|=
name|distFuncs
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|int
name|numExprs
init|=
literal|0
decl_stmt|;
name|List
argument_list|<
name|Integer
argument_list|>
name|distinctIndices
init|=
operator|new
name|ArrayList
argument_list|<
name|Integer
argument_list|>
argument_list|()
decl_stmt|;
comment|// 0 is function name
for|for
control|(
name|int
name|j
init|=
literal|1
init|;
name|j
operator|<
name|value
operator|.
name|getChildCount
argument_list|()
condition|;
name|j
operator|++
control|)
block|{
name|ASTNode
name|parameter
init|=
operator|(
name|ASTNode
operator|)
name|value
operator|.
name|getChild
argument_list|(
name|j
argument_list|)
decl_stmt|;
name|ExprNodeDesc
name|expr
init|=
name|genExprNodeDesc
argument_list|(
name|parameter
argument_list|,
name|reduceSinkInputRowResolver
argument_list|)
decl_stmt|;
comment|// see if expr is already present in reduceKeys.
comment|// get index of expr in reduceKeys
name|int
name|ri
decl_stmt|;
for|for
control|(
name|ri
operator|=
literal|0
init|;
name|ri
operator|<
name|reduceKeys
operator|.
name|size
argument_list|()
condition|;
name|ri
operator|++
control|)
block|{
if|if
condition|(
name|reduceKeys
operator|.
name|get
argument_list|(
name|ri
argument_list|)
operator|.
name|getExprString
argument_list|()
operator|.
name|equals
argument_list|(
name|expr
operator|.
name|getExprString
argument_list|()
argument_list|)
condition|)
block|{
break|break;
block|}
block|}
comment|// add the expr to reduceKeys if it is not present
if|if
condition|(
name|ri
operator|==
name|reduceKeys
operator|.
name|size
argument_list|()
condition|)
block|{
name|reduceKeys
operator|.
name|add
argument_list|(
name|expr
argument_list|)
expr_stmt|;
block|}
comment|// add the index of expr in reduceKeys to distinctIndices
name|distinctIndices
operator|.
name|add
argument_list|(
name|ri
argument_list|)
expr_stmt|;
name|String
name|name
init|=
name|getColumnInternalName
argument_list|(
name|numExprs
argument_list|)
decl_stmt|;
name|String
name|field
init|=
name|Utilities
operator|.
name|ReduceField
operator|.
name|KEY
operator|.
name|toString
argument_list|()
operator|+
literal|"."
operator|+
name|colName
operator|+
literal|":"
operator|+
name|i
operator|+
literal|"."
operator|+
name|name
decl_stmt|;
name|ColumnInfo
name|colInfo
init|=
operator|new
name|ColumnInfo
argument_list|(
name|field
argument_list|,
name|expr
operator|.
name|getTypeInfo
argument_list|()
argument_list|,
literal|null
argument_list|,
literal|false
argument_list|)
decl_stmt|;
name|reduceSinkOutputRowResolver
operator|.
name|putExpression
argument_list|(
name|parameter
argument_list|,
name|colInfo
argument_list|)
expr_stmt|;
name|numExprs
operator|++
expr_stmt|;
block|}
name|distinctColIndices
operator|.
name|add
argument_list|(
name|distinctIndices
argument_list|)
expr_stmt|;
block|}
block|}
name|ArrayList
argument_list|<
name|ExprNodeDesc
argument_list|>
name|reduceValues
init|=
operator|new
name|ArrayList
argument_list|<
name|ExprNodeDesc
argument_list|>
argument_list|()
decl_stmt|;
name|HashMap
argument_list|<
name|String
argument_list|,
name|ASTNode
argument_list|>
name|aggregationTrees
init|=
name|parseInfo
operator|.
name|getAggregationExprsForClause
argument_list|(
name|dest
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|mapAggrDone
condition|)
block|{
comment|// Put parameters to aggregations in reduceValues
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|ASTNode
argument_list|>
name|entry
range|:
name|aggregationTrees
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|ASTNode
name|value
init|=
name|entry
operator|.
name|getValue
argument_list|()
decl_stmt|;
comment|// 0 is function name
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<
name|value
operator|.
name|getChildCount
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|ASTNode
name|parameter
init|=
operator|(
name|ASTNode
operator|)
name|value
operator|.
name|getChild
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|reduceSinkOutputRowResolver
operator|.
name|getExpression
argument_list|(
name|parameter
argument_list|)
operator|==
literal|null
condition|)
block|{
name|reduceValues
operator|.
name|add
argument_list|(
name|genExprNodeDesc
argument_list|(
name|parameter
argument_list|,
name|reduceSinkInputRowResolver
argument_list|)
argument_list|)
expr_stmt|;
name|outputValueColumnNames
operator|.
name|add
argument_list|(
name|getColumnInternalName
argument_list|(
name|reduceValues
operator|.
name|size
argument_list|()
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|String
name|field
init|=
name|Utilities
operator|.
name|ReduceField
operator|.
name|VALUE
operator|.
name|toString
argument_list|()
operator|+
literal|"."
operator|+
name|getColumnInternalName
argument_list|(
name|reduceValues
operator|.
name|size
argument_list|()
operator|-
literal|1
argument_list|)
decl_stmt|;
name|reduceSinkOutputRowResolver
operator|.
name|putExpression
argument_list|(
name|parameter
argument_list|,
operator|new
name|ColumnInfo
argument_list|(
name|field
argument_list|,
name|reduceValues
operator|.
name|get
argument_list|(
name|reduceValues
operator|.
name|size
argument_list|()
operator|-
literal|1
argument_list|)
operator|.
name|getTypeInfo
argument_list|()
argument_list|,
literal|null
argument_list|,
literal|false
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
else|else
block|{
comment|// Put partial aggregation results in reduceValues
name|int
name|inputField
init|=
name|reduceKeys
operator|.
name|size
argument_list|()
decl_stmt|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|ASTNode
argument_list|>
name|entry
range|:
name|aggregationTrees
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|TypeInfo
name|type
init|=
name|reduceSinkInputRowResolver
operator|.
name|getColumnInfos
argument_list|()
operator|.
name|get
argument_list|(
name|inputField
argument_list|)
operator|.
name|getType
argument_list|()
decl_stmt|;
name|reduceValues
operator|.
name|add
argument_list|(
operator|new
name|ExprNodeColumnDesc
argument_list|(
name|type
argument_list|,
name|getColumnInternalName
argument_list|(
name|inputField
argument_list|)
argument_list|,
literal|""
argument_list|,
literal|false
argument_list|)
argument_list|)
expr_stmt|;
name|inputField
operator|++
expr_stmt|;
name|outputValueColumnNames
operator|.
name|add
argument_list|(
name|getColumnInternalName
argument_list|(
name|reduceValues
operator|.
name|size
argument_list|()
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|String
name|field
init|=
name|Utilities
operator|.
name|ReduceField
operator|.
name|VALUE
operator|.
name|toString
argument_list|()
operator|+
literal|"."
operator|+
name|getColumnInternalName
argument_list|(
name|reduceValues
operator|.
name|size
argument_list|()
operator|-
literal|1
argument_list|)
decl_stmt|;
name|reduceSinkOutputRowResolver
operator|.
name|putExpression
argument_list|(
name|entry
operator|.
name|getValue
argument_list|()
argument_list|,
operator|new
name|ColumnInfo
argument_list|(
name|field
argument_list|,
name|type
argument_list|,
literal|null
argument_list|,
literal|false
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|ReduceSinkOperator
name|rsOp
init|=
operator|(
name|ReduceSinkOperator
operator|)
name|putOpInsertMap
argument_list|(
name|OperatorFactory
operator|.
name|getAndMakeChild
argument_list|(
name|PlanUtils
operator|.
name|getReduceSinkDesc
argument_list|(
name|reduceKeys
argument_list|,
name|grpByExprs
operator|.
name|size
argument_list|()
argument_list|,
name|reduceValues
argument_list|,
name|distinctColIndices
argument_list|,
name|outputKeyColumnNames
argument_list|,
name|outputValueColumnNames
argument_list|,
literal|true
argument_list|,
operator|-
literal|1
argument_list|,
name|numPartitionFields
argument_list|,
name|numReducers
argument_list|)
argument_list|,
operator|new
name|RowSchema
argument_list|(
name|reduceSinkOutputRowResolver
operator|.
name|getColumnInfos
argument_list|()
argument_list|)
argument_list|,
name|inputOperatorInfo
argument_list|)
argument_list|,
name|reduceSinkOutputRowResolver
argument_list|)
decl_stmt|;
name|rsOp
operator|.
name|setColumnExprMap
argument_list|(
name|colExprMap
argument_list|)
expr_stmt|;
return|return
name|rsOp
return|;
block|}
comment|/**    * Generate the second ReduceSinkOperator for the Group By Plan    * (parseInfo.getXXX(dest)). The new ReduceSinkOperator will be a child of    * groupByOperatorInfo.    *    * The second ReduceSinkOperator will put the group by keys in the map-reduce    * sort key, and put the partial aggregation results in the map-reduce value.    *    * @param numPartitionFields    *          the number of fields in the map-reduce partition key. This should    *          always be the same as the number of Group By keys. We should be    *          able to remove this parameter since in this phase there is no    *          distinct any more.    * @return the new ReduceSinkOperator.    * @throws SemanticException    */
annotation|@
name|SuppressWarnings
argument_list|(
literal|"nls"
argument_list|)
specifier|private
name|Operator
name|genGroupByPlanReduceSinkOperator2MR
parameter_list|(
name|QBParseInfo
name|parseInfo
parameter_list|,
name|String
name|dest
parameter_list|,
name|Operator
name|groupByOperatorInfo
parameter_list|,
name|int
name|numPartitionFields
parameter_list|,
name|int
name|numReducers
parameter_list|)
throws|throws
name|SemanticException
block|{
name|RowResolver
name|reduceSinkInputRowResolver2
init|=
name|opParseCtx
operator|.
name|get
argument_list|(
name|groupByOperatorInfo
argument_list|)
operator|.
name|getRowResolver
argument_list|()
decl_stmt|;
name|RowResolver
name|reduceSinkOutputRowResolver2
init|=
operator|new
name|RowResolver
argument_list|()
decl_stmt|;
name|reduceSinkOutputRowResolver2
operator|.
name|setIsExprResolver
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|ExprNodeDesc
argument_list|>
name|colExprMap
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|ExprNodeDesc
argument_list|>
argument_list|()
decl_stmt|;
name|ArrayList
argument_list|<
name|ExprNodeDesc
argument_list|>
name|reduceKeys
init|=
operator|new
name|ArrayList
argument_list|<
name|ExprNodeDesc
argument_list|>
argument_list|()
decl_stmt|;
name|ArrayList
argument_list|<
name|String
argument_list|>
name|outputColumnNames
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
comment|// Get group-by keys and store in reduceKeys
name|List
argument_list|<
name|ASTNode
argument_list|>
name|grpByExprs
init|=
name|getGroupByForClause
argument_list|(
name|parseInfo
argument_list|,
name|dest
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|grpByExprs
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|ASTNode
name|grpbyExpr
init|=
name|grpByExprs
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|String
name|field
init|=
name|getColumnInternalName
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|outputColumnNames
operator|.
name|add
argument_list|(
name|field
argument_list|)
expr_stmt|;
name|TypeInfo
name|typeInfo
init|=
name|reduceSinkInputRowResolver2
operator|.
name|getExpression
argument_list|(
name|grpbyExpr
argument_list|)
operator|.
name|getType
argument_list|()
decl_stmt|;
name|ExprNodeColumnDesc
name|inputExpr
init|=
operator|new
name|ExprNodeColumnDesc
argument_list|(
name|typeInfo
argument_list|,
name|field
argument_list|,
literal|""
argument_list|,
literal|false
argument_list|)
decl_stmt|;
name|reduceKeys
operator|.
name|add
argument_list|(
name|inputExpr
argument_list|)
expr_stmt|;
name|ColumnInfo
name|colInfo
init|=
operator|new
name|ColumnInfo
argument_list|(
name|Utilities
operator|.
name|ReduceField
operator|.
name|KEY
operator|.
name|toString
argument_list|()
operator|+
literal|"."
operator|+
name|field
argument_list|,
name|typeInfo
argument_list|,
literal|""
argument_list|,
literal|false
argument_list|)
decl_stmt|;
name|reduceSinkOutputRowResolver2
operator|.
name|putExpression
argument_list|(
name|grpbyExpr
argument_list|,
name|colInfo
argument_list|)
expr_stmt|;
name|colExprMap
operator|.
name|put
argument_list|(
name|colInfo
operator|.
name|getInternalName
argument_list|()
argument_list|,
name|inputExpr
argument_list|)
expr_stmt|;
block|}
comment|// Get partial aggregation results and store in reduceValues
name|ArrayList
argument_list|<
name|ExprNodeDesc
argument_list|>
name|reduceValues
init|=
operator|new
name|ArrayList
argument_list|<
name|ExprNodeDesc
argument_list|>
argument_list|()
decl_stmt|;
name|int
name|inputField
init|=
name|reduceKeys
operator|.
name|size
argument_list|()
decl_stmt|;
name|HashMap
argument_list|<
name|String
argument_list|,
name|ASTNode
argument_list|>
name|aggregationTrees
init|=
name|parseInfo
operator|.
name|getAggregationExprsForClause
argument_list|(
name|dest
argument_list|)
decl_stmt|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|ASTNode
argument_list|>
name|entry
range|:
name|aggregationTrees
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|String
name|field
init|=
name|getColumnInternalName
argument_list|(
name|inputField
argument_list|)
decl_stmt|;
name|ASTNode
name|t
init|=
name|entry
operator|.
name|getValue
argument_list|()
decl_stmt|;
name|TypeInfo
name|typeInfo
init|=
name|reduceSinkInputRowResolver2
operator|.
name|getExpression
argument_list|(
name|t
argument_list|)
operator|.
name|getType
argument_list|()
decl_stmt|;
name|reduceValues
operator|.
name|add
argument_list|(
operator|new
name|ExprNodeColumnDesc
argument_list|(
name|typeInfo
argument_list|,
name|field
argument_list|,
literal|""
argument_list|,
literal|false
argument_list|)
argument_list|)
expr_stmt|;
name|inputField
operator|++
expr_stmt|;
name|String
name|col
init|=
name|getColumnInternalName
argument_list|(
name|reduceValues
operator|.
name|size
argument_list|()
operator|-
literal|1
argument_list|)
decl_stmt|;
name|outputColumnNames
operator|.
name|add
argument_list|(
name|col
argument_list|)
expr_stmt|;
name|reduceSinkOutputRowResolver2
operator|.
name|putExpression
argument_list|(
name|t
argument_list|,
operator|new
name|ColumnInfo
argument_list|(
name|Utilities
operator|.
name|ReduceField
operator|.
name|VALUE
operator|.
name|toString
argument_list|()
operator|+
literal|"."
operator|+
name|col
argument_list|,
name|typeInfo
argument_list|,
literal|""
argument_list|,
literal|false
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|ReduceSinkOperator
name|rsOp
init|=
operator|(
name|ReduceSinkOperator
operator|)
name|putOpInsertMap
argument_list|(
name|OperatorFactory
operator|.
name|getAndMakeChild
argument_list|(
name|PlanUtils
operator|.
name|getReduceSinkDesc
argument_list|(
name|reduceKeys
argument_list|,
name|reduceValues
argument_list|,
name|outputColumnNames
argument_list|,
literal|true
argument_list|,
operator|-
literal|1
argument_list|,
name|numPartitionFields
argument_list|,
name|numReducers
argument_list|)
argument_list|,
operator|new
name|RowSchema
argument_list|(
name|reduceSinkOutputRowResolver2
operator|.
name|getColumnInfos
argument_list|()
argument_list|)
argument_list|,
name|groupByOperatorInfo
argument_list|)
argument_list|,
name|reduceSinkOutputRowResolver2
argument_list|)
decl_stmt|;
name|rsOp
operator|.
name|setColumnExprMap
argument_list|(
name|colExprMap
argument_list|)
expr_stmt|;
return|return
name|rsOp
return|;
block|}
comment|/**    * Generate the second GroupByOperator for the Group By Plan    * (parseInfo.getXXX(dest)). The new GroupByOperator will do the second    * aggregation based on the partial aggregation results.    *    * @param mode    *          the mode of aggregation (FINAL)    * @param genericUDAFEvaluators    *          The mapping from Aggregation StringTree to the    *          genericUDAFEvaluator.    * @return the new GroupByOperator    * @throws SemanticException    */
annotation|@
name|SuppressWarnings
argument_list|(
literal|"nls"
argument_list|)
specifier|private
name|Operator
name|genGroupByPlanGroupByOperator2MR
parameter_list|(
name|QBParseInfo
name|parseInfo
parameter_list|,
name|String
name|dest
parameter_list|,
name|Operator
name|reduceSinkOperatorInfo2
parameter_list|,
name|GroupByDesc
operator|.
name|Mode
name|mode
parameter_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|GenericUDAFEvaluator
argument_list|>
name|genericUDAFEvaluators
parameter_list|)
throws|throws
name|SemanticException
block|{
name|RowResolver
name|groupByInputRowResolver2
init|=
name|opParseCtx
operator|.
name|get
argument_list|(
name|reduceSinkOperatorInfo2
argument_list|)
operator|.
name|getRowResolver
argument_list|()
decl_stmt|;
name|RowResolver
name|groupByOutputRowResolver2
init|=
operator|new
name|RowResolver
argument_list|()
decl_stmt|;
name|groupByOutputRowResolver2
operator|.
name|setIsExprResolver
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|ArrayList
argument_list|<
name|ExprNodeDesc
argument_list|>
name|groupByKeys
init|=
operator|new
name|ArrayList
argument_list|<
name|ExprNodeDesc
argument_list|>
argument_list|()
decl_stmt|;
name|ArrayList
argument_list|<
name|AggregationDesc
argument_list|>
name|aggregations
init|=
operator|new
name|ArrayList
argument_list|<
name|AggregationDesc
argument_list|>
argument_list|()
decl_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|ExprNodeDesc
argument_list|>
name|colExprMap
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|ExprNodeDesc
argument_list|>
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|ASTNode
argument_list|>
name|grpByExprs
init|=
name|getGroupByForClause
argument_list|(
name|parseInfo
argument_list|,
name|dest
argument_list|)
decl_stmt|;
name|ArrayList
argument_list|<
name|String
argument_list|>
name|outputColumnNames
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|grpByExprs
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|ASTNode
name|grpbyExpr
init|=
name|grpByExprs
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|ColumnInfo
name|exprInfo
init|=
name|groupByInputRowResolver2
operator|.
name|getExpression
argument_list|(
name|grpbyExpr
argument_list|)
decl_stmt|;
if|if
condition|(
name|exprInfo
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|INVALID_COLUMN
operator|.
name|getMsg
argument_list|(
name|grpbyExpr
argument_list|)
argument_list|)
throw|;
block|}
name|String
name|expression
init|=
name|exprInfo
operator|.
name|getInternalName
argument_list|()
decl_stmt|;
name|groupByKeys
operator|.
name|add
argument_list|(
operator|new
name|ExprNodeColumnDesc
argument_list|(
name|exprInfo
operator|.
name|getType
argument_list|()
argument_list|,
name|expression
argument_list|,
name|exprInfo
operator|.
name|getTabAlias
argument_list|()
argument_list|,
name|exprInfo
operator|.
name|getIsVirtualCol
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|String
name|field
init|=
name|getColumnInternalName
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|outputColumnNames
operator|.
name|add
argument_list|(
name|field
argument_list|)
expr_stmt|;
name|groupByOutputRowResolver2
operator|.
name|putExpression
argument_list|(
name|grpbyExpr
argument_list|,
operator|new
name|ColumnInfo
argument_list|(
name|field
argument_list|,
name|exprInfo
operator|.
name|getType
argument_list|()
argument_list|,
literal|""
argument_list|,
literal|false
argument_list|)
argument_list|)
expr_stmt|;
name|colExprMap
operator|.
name|put
argument_list|(
name|field
argument_list|,
name|groupByKeys
operator|.
name|get
argument_list|(
name|groupByKeys
operator|.
name|size
argument_list|()
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|HashMap
argument_list|<
name|String
argument_list|,
name|ASTNode
argument_list|>
name|aggregationTrees
init|=
name|parseInfo
operator|.
name|getAggregationExprsForClause
argument_list|(
name|dest
argument_list|)
decl_stmt|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|ASTNode
argument_list|>
name|entry
range|:
name|aggregationTrees
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|ArrayList
argument_list|<
name|ExprNodeDesc
argument_list|>
name|aggParameters
init|=
operator|new
name|ArrayList
argument_list|<
name|ExprNodeDesc
argument_list|>
argument_list|()
decl_stmt|;
name|ASTNode
name|value
init|=
name|entry
operator|.
name|getValue
argument_list|()
decl_stmt|;
name|ColumnInfo
name|paraExprInfo
init|=
name|groupByInputRowResolver2
operator|.
name|getExpression
argument_list|(
name|value
argument_list|)
decl_stmt|;
if|if
condition|(
name|paraExprInfo
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|INVALID_COLUMN
operator|.
name|getMsg
argument_list|(
name|value
argument_list|)
argument_list|)
throw|;
block|}
name|String
name|paraExpression
init|=
name|paraExprInfo
operator|.
name|getInternalName
argument_list|()
decl_stmt|;
assert|assert
operator|(
name|paraExpression
operator|!=
literal|null
operator|)
assert|;
name|aggParameters
operator|.
name|add
argument_list|(
operator|new
name|ExprNodeColumnDesc
argument_list|(
name|paraExprInfo
operator|.
name|getType
argument_list|()
argument_list|,
name|paraExpression
argument_list|,
name|paraExprInfo
operator|.
name|getTabAlias
argument_list|()
argument_list|,
name|paraExprInfo
operator|.
name|getIsVirtualCol
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|String
name|aggName
init|=
name|value
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getText
argument_list|()
decl_stmt|;
name|boolean
name|isDistinct
init|=
name|value
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_FUNCTIONDI
decl_stmt|;
name|boolean
name|isStar
init|=
name|value
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_FUNCTIONSTAR
decl_stmt|;
name|Mode
name|amode
init|=
name|groupByDescModeToUDAFMode
argument_list|(
name|mode
argument_list|,
name|isDistinct
argument_list|)
decl_stmt|;
name|GenericUDAFEvaluator
name|genericUDAFEvaluator
init|=
name|genericUDAFEvaluators
operator|.
name|get
argument_list|(
name|entry
operator|.
name|getKey
argument_list|()
argument_list|)
decl_stmt|;
assert|assert
operator|(
name|genericUDAFEvaluator
operator|!=
literal|null
operator|)
assert|;
name|GenericUDAFInfo
name|udaf
init|=
name|getGenericUDAFInfo
argument_list|(
name|genericUDAFEvaluator
argument_list|,
name|amode
argument_list|,
name|aggParameters
argument_list|)
decl_stmt|;
name|aggregations
operator|.
name|add
argument_list|(
operator|new
name|AggregationDesc
argument_list|(
name|aggName
operator|.
name|toLowerCase
argument_list|()
argument_list|,
name|udaf
operator|.
name|genericUDAFEvaluator
argument_list|,
name|udaf
operator|.
name|convertedParameters
argument_list|,
operator|(
name|mode
operator|!=
name|GroupByDesc
operator|.
name|Mode
operator|.
name|FINAL
operator|&&
name|value
operator|.
name|getToken
argument_list|()
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_FUNCTIONDI
operator|)
argument_list|,
name|amode
argument_list|)
argument_list|)
expr_stmt|;
name|String
name|field
init|=
name|getColumnInternalName
argument_list|(
name|groupByKeys
operator|.
name|size
argument_list|()
operator|+
name|aggregations
operator|.
name|size
argument_list|()
operator|-
literal|1
argument_list|)
decl_stmt|;
name|outputColumnNames
operator|.
name|add
argument_list|(
name|field
argument_list|)
expr_stmt|;
name|groupByOutputRowResolver2
operator|.
name|putExpression
argument_list|(
name|value
argument_list|,
operator|new
name|ColumnInfo
argument_list|(
name|field
argument_list|,
name|udaf
operator|.
name|returnType
argument_list|,
literal|""
argument_list|,
literal|false
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|float
name|groupByMemoryUsage
init|=
name|HiveConf
operator|.
name|getFloatVar
argument_list|(
name|conf
argument_list|,
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVEMAPAGGRHASHMEMORY
argument_list|)
decl_stmt|;
name|float
name|memoryThreshold
init|=
name|HiveConf
operator|.
name|getFloatVar
argument_list|(
name|conf
argument_list|,
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVEMAPAGGRMEMORYTHRESHOLD
argument_list|)
decl_stmt|;
name|Operator
name|op
init|=
name|putOpInsertMap
argument_list|(
name|OperatorFactory
operator|.
name|getAndMakeChild
argument_list|(
operator|new
name|GroupByDesc
argument_list|(
name|mode
argument_list|,
name|outputColumnNames
argument_list|,
name|groupByKeys
argument_list|,
name|aggregations
argument_list|,
literal|false
argument_list|,
name|groupByMemoryUsage
argument_list|,
name|memoryThreshold
argument_list|)
argument_list|,
operator|new
name|RowSchema
argument_list|(
name|groupByOutputRowResolver2
operator|.
name|getColumnInfos
argument_list|()
argument_list|)
argument_list|,
name|reduceSinkOperatorInfo2
argument_list|)
argument_list|,
name|groupByOutputRowResolver2
argument_list|)
decl_stmt|;
name|op
operator|.
name|setColumnExprMap
argument_list|(
name|colExprMap
argument_list|)
expr_stmt|;
return|return
name|op
return|;
block|}
comment|/**    * Generate a Group-By plan using a single map-reduce job (3 operators will be    * inserted):    *    * ReduceSink ( keys = (K1_EXP, K2_EXP, DISTINCT_EXP), values = (A1_EXP,    * A2_EXP) ) SortGroupBy (keys = (KEY.0,KEY.1), aggregations =    * (count_distinct(KEY.2), sum(VALUE.0), count(VALUE.1))) Select (final    * selects).    *    * @param dest    * @param qb    * @param input    * @return    * @throws SemanticException    *    *           Generate a Group-By plan using 1 map-reduce job. Spray by the    *           group by key, and sort by the distinct key (if any), and compute    *           aggregates * The aggregation evaluation functions are as    *           follows: Partitioning Key: grouping key    *    *           Sorting Key: grouping key if no DISTINCT grouping + distinct key    *           if DISTINCT    *    *           Reducer: iterate/merge (mode = COMPLETE)    **/
annotation|@
name|SuppressWarnings
argument_list|(
block|{
literal|"nls"
block|}
argument_list|)
specifier|private
name|Operator
name|genGroupByPlan1MR
parameter_list|(
name|String
name|dest
parameter_list|,
name|QB
name|qb
parameter_list|,
name|Operator
name|input
parameter_list|)
throws|throws
name|SemanticException
block|{
name|QBParseInfo
name|parseInfo
init|=
name|qb
operator|.
name|getParseInfo
argument_list|()
decl_stmt|;
name|int
name|numReducers
init|=
operator|-
literal|1
decl_stmt|;
name|List
argument_list|<
name|ASTNode
argument_list|>
name|grpByExprs
init|=
name|getGroupByForClause
argument_list|(
name|parseInfo
argument_list|,
name|dest
argument_list|)
decl_stmt|;
if|if
condition|(
name|grpByExprs
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|numReducers
operator|=
literal|1
expr_stmt|;
block|}
comment|// ////// 1. Generate ReduceSinkOperator
name|Operator
name|reduceSinkOperatorInfo
init|=
name|genGroupByPlanReduceSinkOperator
argument_list|(
name|qb
argument_list|,
name|dest
argument_list|,
name|input
argument_list|,
name|grpByExprs
operator|.
name|size
argument_list|()
argument_list|,
name|numReducers
argument_list|,
literal|false
argument_list|)
decl_stmt|;
comment|// ////// 2. Generate GroupbyOperator
name|Operator
name|groupByOperatorInfo
init|=
name|genGroupByPlanGroupByOperator
argument_list|(
name|parseInfo
argument_list|,
name|dest
argument_list|,
name|reduceSinkOperatorInfo
argument_list|,
name|GroupByDesc
operator|.
name|Mode
operator|.
name|COMPLETE
argument_list|,
literal|null
argument_list|)
decl_stmt|;
return|return
name|groupByOperatorInfo
return|;
block|}
specifier|static
name|ArrayList
argument_list|<
name|GenericUDAFEvaluator
argument_list|>
name|getUDAFEvaluators
parameter_list|(
name|ArrayList
argument_list|<
name|AggregationDesc
argument_list|>
name|aggs
parameter_list|)
block|{
name|ArrayList
argument_list|<
name|GenericUDAFEvaluator
argument_list|>
name|result
init|=
operator|new
name|ArrayList
argument_list|<
name|GenericUDAFEvaluator
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|aggs
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|result
operator|.
name|add
argument_list|(
name|aggs
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|getGenericUDAFEvaluator
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
comment|/**    * Generate a Multi Group-By plan using a 2 map-reduce jobs.    *    * @param dest    * @param qb    * @param input    * @return    * @throws SemanticException    *    *           Generate a Group-By plan using a 2 map-reduce jobs. Spray by the    *           distinct key in hope of getting a uniform distribution, and    *           compute partial aggregates by the grouping key. Evaluate partial    *           aggregates first, and spray by the grouping key to compute actual    *           aggregates in the second phase. The agggregation evaluation    *           functions are as follows: Partitioning Key: distinct key    *    *           Sorting Key: distinct key    *    *           Reducer: iterate/terminatePartial (mode = PARTIAL1)    *    *           STAGE 2    *    *           Partitioning Key: grouping key    *    *           Sorting Key: grouping key    *    *           Reducer: merge/terminate (mode = FINAL)    */
annotation|@
name|SuppressWarnings
argument_list|(
literal|"nls"
argument_list|)
specifier|private
name|Operator
name|genGroupByPlan2MRMultiGroupBy
parameter_list|(
name|String
name|dest
parameter_list|,
name|QB
name|qb
parameter_list|,
name|Operator
name|input
parameter_list|)
throws|throws
name|SemanticException
block|{
comment|// ////// Generate GroupbyOperator for a map-side partial aggregation
name|Map
argument_list|<
name|String
argument_list|,
name|GenericUDAFEvaluator
argument_list|>
name|genericUDAFEvaluators
init|=
operator|new
name|LinkedHashMap
argument_list|<
name|String
argument_list|,
name|GenericUDAFEvaluator
argument_list|>
argument_list|()
decl_stmt|;
name|QBParseInfo
name|parseInfo
init|=
name|qb
operator|.
name|getParseInfo
argument_list|()
decl_stmt|;
comment|// ////// 2. Generate GroupbyOperator
name|Operator
name|groupByOperatorInfo
init|=
name|genGroupByPlanGroupByOperator1
argument_list|(
name|parseInfo
argument_list|,
name|dest
argument_list|,
name|input
argument_list|,
name|GroupByDesc
operator|.
name|Mode
operator|.
name|HASH
argument_list|,
name|genericUDAFEvaluators
argument_list|,
literal|true
argument_list|)
decl_stmt|;
name|int
name|numReducers
init|=
operator|-
literal|1
decl_stmt|;
name|List
argument_list|<
name|ASTNode
argument_list|>
name|grpByExprs
init|=
name|getGroupByForClause
argument_list|(
name|parseInfo
argument_list|,
name|dest
argument_list|)
decl_stmt|;
comment|// ////// 3. Generate ReduceSinkOperator2
name|Operator
name|reduceSinkOperatorInfo2
init|=
name|genGroupByPlanReduceSinkOperator2MR
argument_list|(
name|parseInfo
argument_list|,
name|dest
argument_list|,
name|groupByOperatorInfo
argument_list|,
name|grpByExprs
operator|.
name|size
argument_list|()
argument_list|,
name|numReducers
argument_list|)
decl_stmt|;
comment|// ////// 4. Generate GroupbyOperator2
name|Operator
name|groupByOperatorInfo2
init|=
name|genGroupByPlanGroupByOperator2MR
argument_list|(
name|parseInfo
argument_list|,
name|dest
argument_list|,
name|reduceSinkOperatorInfo2
argument_list|,
name|GroupByDesc
operator|.
name|Mode
operator|.
name|FINAL
argument_list|,
name|genericUDAFEvaluators
argument_list|)
decl_stmt|;
return|return
name|groupByOperatorInfo2
return|;
block|}
comment|/**    * Generate a Multi Group-By plan using a single map-reduce job.    *    * @param dest    * @param qb    * @param input    * @return    * @throws SemanticException    *    *           Generate a Group-By plan using single map-reduce job, if there is    *           common group by key. Spray by the    *           common group by key set and compute    *           aggregates in the reduce. The agggregation evaluation    *           functions are as follows:    *    *           Partitioning Key: common group by key set    *    *           Sorting Key: group by keys, distinct keys    *    *           Reducer: iterate/terminate  (mode = COMPLETE)    *    */
specifier|private
name|Operator
argument_list|<
name|?
argument_list|>
name|genGroupByPlan1MRMultiGroupBy
parameter_list|(
name|String
name|dest
parameter_list|,
name|QB
name|qb
parameter_list|,
name|Operator
argument_list|<
name|?
argument_list|>
name|input
parameter_list|)
throws|throws
name|SemanticException
block|{
name|QBParseInfo
name|parseInfo
init|=
name|qb
operator|.
name|getParseInfo
argument_list|()
decl_stmt|;
comment|// //////  Generate GroupbyOperator
name|Operator
argument_list|<
name|?
argument_list|>
name|groupByOperatorInfo
init|=
name|genGroupByPlanGroupByOperator
argument_list|(
name|parseInfo
argument_list|,
name|dest
argument_list|,
name|input
argument_list|,
name|GroupByDesc
operator|.
name|Mode
operator|.
name|COMPLETE
argument_list|,
literal|null
argument_list|)
decl_stmt|;
return|return
name|groupByOperatorInfo
return|;
block|}
comment|/**    * Generate a Group-By plan using a 2 map-reduce jobs (5 operators will be    * inserted):    *    * ReduceSink ( keys = (K1_EXP, K2_EXP, DISTINCT_EXP), values = (A1_EXP,    * A2_EXP) ) NOTE: If DISTINCT_EXP is null, partition by rand() SortGroupBy    * (keys = (KEY.0,KEY.1), aggregations = (count_distinct(KEY.2), sum(VALUE.0),    * count(VALUE.1))) ReduceSink ( keys = (0,1), values=(2,3,4)) SortGroupBy    * (keys = (KEY.0,KEY.1), aggregations = (sum(VALUE.0), sum(VALUE.1),    * sum(VALUE.2))) Select (final selects).    *    * @param dest    * @param qb    * @param input    * @return    * @throws SemanticException    *    *           Generate a Group-By plan using a 2 map-reduce jobs. Spray by the    *           grouping key and distinct key (or a random number, if no distinct    *           is present) in hope of getting a uniform distribution, and    *           compute partial aggregates grouped by the reduction key (grouping    *           key + distinct key). Evaluate partial aggregates first, and spray    *           by the grouping key to compute actual aggregates in the second    *           phase. The agggregation evaluation functions are as follows:    *           Partitioning Key: random() if no DISTINCT grouping + distinct key    *           if DISTINCT    *    *           Sorting Key: grouping key if no DISTINCT grouping + distinct key    *           if DISTINCT    *    *           Reducer: iterate/terminatePartial (mode = PARTIAL1)    *    *           STAGE 2    *    *           Partitioning Key: grouping key    *    *           Sorting Key: grouping key if no DISTINCT grouping + distinct key    *           if DISTINCT    *    *           Reducer: merge/terminate (mode = FINAL)    */
annotation|@
name|SuppressWarnings
argument_list|(
literal|"nls"
argument_list|)
specifier|private
name|Operator
name|genGroupByPlan2MR
parameter_list|(
name|String
name|dest
parameter_list|,
name|QB
name|qb
parameter_list|,
name|Operator
name|input
parameter_list|)
throws|throws
name|SemanticException
block|{
name|QBParseInfo
name|parseInfo
init|=
name|qb
operator|.
name|getParseInfo
argument_list|()
decl_stmt|;
comment|// ////// 1. Generate ReduceSinkOperator
comment|// There is a special case when we want the rows to be randomly distributed
comment|// to
comment|// reducers for load balancing problem. That happens when there is no
comment|// DISTINCT
comment|// operator. We set the numPartitionColumns to -1 for this purpose. This is
comment|// captured by WritableComparableHiveObject.hashCode() function.
name|Operator
name|reduceSinkOperatorInfo
init|=
name|genGroupByPlanReduceSinkOperator
argument_list|(
name|qb
argument_list|,
name|dest
argument_list|,
name|input
argument_list|,
operator|(
name|parseInfo
operator|.
name|getDistinctFuncExprsForClause
argument_list|(
name|dest
argument_list|)
operator|.
name|isEmpty
argument_list|()
condition|?
operator|-
literal|1
else|:
name|Integer
operator|.
name|MAX_VALUE
operator|)
argument_list|,
operator|-
literal|1
argument_list|,
literal|false
argument_list|)
decl_stmt|;
comment|// ////// 2. Generate GroupbyOperator
name|Map
argument_list|<
name|String
argument_list|,
name|GenericUDAFEvaluator
argument_list|>
name|genericUDAFEvaluators
init|=
operator|new
name|LinkedHashMap
argument_list|<
name|String
argument_list|,
name|GenericUDAFEvaluator
argument_list|>
argument_list|()
decl_stmt|;
name|GroupByOperator
name|groupByOperatorInfo
init|=
operator|(
name|GroupByOperator
operator|)
name|genGroupByPlanGroupByOperator
argument_list|(
name|parseInfo
argument_list|,
name|dest
argument_list|,
name|reduceSinkOperatorInfo
argument_list|,
name|GroupByDesc
operator|.
name|Mode
operator|.
name|PARTIAL1
argument_list|,
name|genericUDAFEvaluators
argument_list|)
decl_stmt|;
name|int
name|numReducers
init|=
operator|-
literal|1
decl_stmt|;
name|List
argument_list|<
name|ASTNode
argument_list|>
name|grpByExprs
init|=
name|getGroupByForClause
argument_list|(
name|parseInfo
argument_list|,
name|dest
argument_list|)
decl_stmt|;
if|if
condition|(
name|grpByExprs
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|numReducers
operator|=
literal|1
expr_stmt|;
block|}
comment|// ////// 3. Generate ReduceSinkOperator2
name|Operator
name|reduceSinkOperatorInfo2
init|=
name|genGroupByPlanReduceSinkOperator2MR
argument_list|(
name|parseInfo
argument_list|,
name|dest
argument_list|,
name|groupByOperatorInfo
argument_list|,
name|grpByExprs
operator|.
name|size
argument_list|()
argument_list|,
name|numReducers
argument_list|)
decl_stmt|;
comment|// ////// 4. Generate GroupbyOperator2
name|Operator
name|groupByOperatorInfo2
init|=
name|genGroupByPlanGroupByOperator2MR
argument_list|(
name|parseInfo
argument_list|,
name|dest
argument_list|,
name|reduceSinkOperatorInfo2
argument_list|,
name|GroupByDesc
operator|.
name|Mode
operator|.
name|FINAL
argument_list|,
name|genericUDAFEvaluators
argument_list|)
decl_stmt|;
return|return
name|groupByOperatorInfo2
return|;
block|}
specifier|private
name|boolean
name|optimizeMapAggrGroupBy
parameter_list|(
name|String
name|dest
parameter_list|,
name|QB
name|qb
parameter_list|)
block|{
name|List
argument_list|<
name|ASTNode
argument_list|>
name|grpByExprs
init|=
name|getGroupByForClause
argument_list|(
name|qb
operator|.
name|getParseInfo
argument_list|()
argument_list|,
name|dest
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|grpByExprs
operator|!=
literal|null
operator|)
operator|&&
operator|!
name|grpByExprs
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return
literal|false
return|;
block|}
if|if
condition|(
operator|!
name|qb
operator|.
name|getParseInfo
argument_list|()
operator|.
name|getDistinctFuncExprsForClause
argument_list|(
name|dest
argument_list|)
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return
literal|false
return|;
block|}
return|return
literal|true
return|;
block|}
comment|/**    * Generate a Group-By plan using 1 map-reduce job. First perform a map-side    * partial aggregation (to reduce the amount of data), at this point of time,    * we may turn off map-side partial aggregation based on its performance. Then    * spray by the group by key, and sort by the distinct key (if any), and    * compute aggregates based on actual aggregates    *    * The agggregation evaluation functions are as follows: Mapper:    * iterate/terminatePartial (mode = HASH)    *    * Partitioning Key: grouping key    *    * Sorting Key: grouping key if no DISTINCT grouping + distinct key if    * DISTINCT    *    * Reducer: iterate/terminate if DISTINCT merge/terminate if NO DISTINCT (mode    * = MERGEPARTIAL)    */
annotation|@
name|SuppressWarnings
argument_list|(
literal|"nls"
argument_list|)
specifier|private
name|Operator
name|genGroupByPlanMapAggr1MR
parameter_list|(
name|String
name|dest
parameter_list|,
name|QB
name|qb
parameter_list|,
name|Operator
name|inputOperatorInfo
parameter_list|)
throws|throws
name|SemanticException
block|{
name|QBParseInfo
name|parseInfo
init|=
name|qb
operator|.
name|getParseInfo
argument_list|()
decl_stmt|;
comment|// ////// Generate GroupbyOperator for a map-side partial aggregation
name|Map
argument_list|<
name|String
argument_list|,
name|GenericUDAFEvaluator
argument_list|>
name|genericUDAFEvaluators
init|=
operator|new
name|LinkedHashMap
argument_list|<
name|String
argument_list|,
name|GenericUDAFEvaluator
argument_list|>
argument_list|()
decl_stmt|;
name|GroupByOperator
name|groupByOperatorInfo
init|=
operator|(
name|GroupByOperator
operator|)
name|genGroupByPlanMapGroupByOperator
argument_list|(
name|qb
argument_list|,
name|dest
argument_list|,
name|inputOperatorInfo
argument_list|,
name|GroupByDesc
operator|.
name|Mode
operator|.
name|HASH
argument_list|,
name|genericUDAFEvaluators
argument_list|)
decl_stmt|;
name|groupOpToInputTables
operator|.
name|put
argument_list|(
name|groupByOperatorInfo
argument_list|,
name|opParseCtx
operator|.
name|get
argument_list|(
name|inputOperatorInfo
argument_list|)
operator|.
name|getRowResolver
argument_list|()
operator|.
name|getTableNames
argument_list|()
argument_list|)
expr_stmt|;
name|int
name|numReducers
init|=
operator|-
literal|1
decl_stmt|;
comment|// Optimize the scenario when there are no grouping keys - only 1 reducer is
comment|// needed
name|List
argument_list|<
name|ASTNode
argument_list|>
name|grpByExprs
init|=
name|getGroupByForClause
argument_list|(
name|parseInfo
argument_list|,
name|dest
argument_list|)
decl_stmt|;
if|if
condition|(
name|grpByExprs
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|numReducers
operator|=
literal|1
expr_stmt|;
block|}
comment|// ////// Generate ReduceSink Operator
name|Operator
name|reduceSinkOperatorInfo
init|=
name|genGroupByPlanReduceSinkOperator
argument_list|(
name|qb
argument_list|,
name|dest
argument_list|,
name|groupByOperatorInfo
argument_list|,
name|grpByExprs
operator|.
name|size
argument_list|()
argument_list|,
name|numReducers
argument_list|,
literal|true
argument_list|)
decl_stmt|;
comment|// This is a 1-stage map-reduce processing of the groupby. Tha map-side
comment|// aggregates was just used to
comment|// reduce output data. In case of distincts, partial results are not used,
comment|// and so iterate is again
comment|// invoked on the reducer. In case of non-distincts, partial results are
comment|// used, and merge is invoked
comment|// on the reducer.
return|return
name|genGroupByPlanGroupByOperator1
argument_list|(
name|parseInfo
argument_list|,
name|dest
argument_list|,
name|reduceSinkOperatorInfo
argument_list|,
name|GroupByDesc
operator|.
name|Mode
operator|.
name|MERGEPARTIAL
argument_list|,
name|genericUDAFEvaluators
argument_list|,
literal|false
argument_list|)
return|;
block|}
comment|/**    * Generate a Group-By plan using a 2 map-reduce jobs. However, only 1    * group-by plan is generated if the query involves no grouping key and no    * distincts. In that case, the plan is same as generated by    * genGroupByPlanMapAggr1MR. Otherwise, the following plan is generated: First    * perform a map side partial aggregation (to reduce the amount of data). Then    * spray by the grouping key and distinct key (or a random number, if no    * distinct is present) in hope of getting a uniform distribution, and compute    * partial aggregates grouped by the reduction key (grouping key + distinct    * key). Evaluate partial aggregates first, and spray by the grouping key to    * compute actual aggregates in the second phase. The agggregation evaluation    * functions are as follows: Mapper: iterate/terminatePartial (mode = HASH)    *    * Partitioning Key: random() if no DISTINCT grouping + distinct key if    * DISTINCT    *    * Sorting Key: grouping key if no DISTINCT grouping + distinct key if    * DISTINCT    *    * Reducer: iterate/terminatePartial if DISTINCT merge/terminatePartial if NO    * DISTINCT (mode = MERGEPARTIAL)    *    * STAGE 2    *    * Partitioining Key: grouping key    *    * Sorting Key: grouping key if no DISTINCT grouping + distinct key if    * DISTINCT    *    * Reducer: merge/terminate (mode = FINAL)    */
annotation|@
name|SuppressWarnings
argument_list|(
literal|"nls"
argument_list|)
specifier|private
name|Operator
name|genGroupByPlanMapAggr2MR
parameter_list|(
name|String
name|dest
parameter_list|,
name|QB
name|qb
parameter_list|,
name|Operator
name|inputOperatorInfo
parameter_list|)
throws|throws
name|SemanticException
block|{
name|QBParseInfo
name|parseInfo
init|=
name|qb
operator|.
name|getParseInfo
argument_list|()
decl_stmt|;
comment|// ////// Generate GroupbyOperator for a map-side partial aggregation
name|Map
argument_list|<
name|String
argument_list|,
name|GenericUDAFEvaluator
argument_list|>
name|genericUDAFEvaluators
init|=
operator|new
name|LinkedHashMap
argument_list|<
name|String
argument_list|,
name|GenericUDAFEvaluator
argument_list|>
argument_list|()
decl_stmt|;
name|GroupByOperator
name|groupByOperatorInfo
init|=
operator|(
name|GroupByOperator
operator|)
name|genGroupByPlanMapGroupByOperator
argument_list|(
name|qb
argument_list|,
name|dest
argument_list|,
name|inputOperatorInfo
argument_list|,
name|GroupByDesc
operator|.
name|Mode
operator|.
name|HASH
argument_list|,
name|genericUDAFEvaluators
argument_list|)
decl_stmt|;
name|groupOpToInputTables
operator|.
name|put
argument_list|(
name|groupByOperatorInfo
argument_list|,
name|opParseCtx
operator|.
name|get
argument_list|(
name|inputOperatorInfo
argument_list|)
operator|.
name|getRowResolver
argument_list|()
operator|.
name|getTableNames
argument_list|()
argument_list|)
expr_stmt|;
comment|// Optimize the scenario when there are no grouping keys and no distinct - 2
comment|// map-reduce jobs are not needed
comment|// For eg: select count(1) from T where t.ds = ....
if|if
condition|(
operator|!
name|optimizeMapAggrGroupBy
argument_list|(
name|dest
argument_list|,
name|qb
argument_list|)
condition|)
block|{
comment|// ////// Generate ReduceSink Operator
name|Operator
name|reduceSinkOperatorInfo
init|=
name|genGroupByPlanReduceSinkOperator
argument_list|(
name|qb
argument_list|,
name|dest
argument_list|,
name|groupByOperatorInfo
argument_list|,
operator|(
name|parseInfo
operator|.
name|getDistinctFuncExprsForClause
argument_list|(
name|dest
argument_list|)
operator|.
name|isEmpty
argument_list|()
condition|?
operator|-
literal|1
else|:
name|Integer
operator|.
name|MAX_VALUE
operator|)
argument_list|,
operator|-
literal|1
argument_list|,
literal|true
argument_list|)
decl_stmt|;
comment|// ////// Generate GroupbyOperator for a partial aggregation
name|Operator
name|groupByOperatorInfo2
init|=
name|genGroupByPlanGroupByOperator1
argument_list|(
name|parseInfo
argument_list|,
name|dest
argument_list|,
name|reduceSinkOperatorInfo
argument_list|,
name|GroupByDesc
operator|.
name|Mode
operator|.
name|PARTIALS
argument_list|,
name|genericUDAFEvaluators
argument_list|,
literal|false
argument_list|)
decl_stmt|;
name|int
name|numReducers
init|=
operator|-
literal|1
decl_stmt|;
name|List
argument_list|<
name|ASTNode
argument_list|>
name|grpByExprs
init|=
name|getGroupByForClause
argument_list|(
name|parseInfo
argument_list|,
name|dest
argument_list|)
decl_stmt|;
if|if
condition|(
name|grpByExprs
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|numReducers
operator|=
literal|1
expr_stmt|;
block|}
comment|// ////// Generate ReduceSinkOperator2
name|Operator
name|reduceSinkOperatorInfo2
init|=
name|genGroupByPlanReduceSinkOperator2MR
argument_list|(
name|parseInfo
argument_list|,
name|dest
argument_list|,
name|groupByOperatorInfo2
argument_list|,
name|grpByExprs
operator|.
name|size
argument_list|()
argument_list|,
name|numReducers
argument_list|)
decl_stmt|;
comment|// ////// Generate GroupbyOperator3
return|return
name|genGroupByPlanGroupByOperator2MR
argument_list|(
name|parseInfo
argument_list|,
name|dest
argument_list|,
name|reduceSinkOperatorInfo2
argument_list|,
name|GroupByDesc
operator|.
name|Mode
operator|.
name|FINAL
argument_list|,
name|genericUDAFEvaluators
argument_list|)
return|;
block|}
else|else
block|{
comment|// ////// Generate ReduceSink Operator
name|Operator
name|reduceSinkOperatorInfo
init|=
name|genGroupByPlanReduceSinkOperator
argument_list|(
name|qb
argument_list|,
name|dest
argument_list|,
name|groupByOperatorInfo
argument_list|,
name|getGroupByForClause
argument_list|(
name|parseInfo
argument_list|,
name|dest
argument_list|)
operator|.
name|size
argument_list|()
argument_list|,
literal|1
argument_list|,
literal|true
argument_list|)
decl_stmt|;
return|return
name|genGroupByPlanGroupByOperator2MR
argument_list|(
name|parseInfo
argument_list|,
name|dest
argument_list|,
name|reduceSinkOperatorInfo
argument_list|,
name|GroupByDesc
operator|.
name|Mode
operator|.
name|FINAL
argument_list|,
name|genericUDAFEvaluators
argument_list|)
return|;
block|}
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"nls"
argument_list|)
specifier|private
name|Operator
name|genConversionOps
parameter_list|(
name|String
name|dest
parameter_list|,
name|QB
name|qb
parameter_list|,
name|Operator
name|input
parameter_list|)
throws|throws
name|SemanticException
block|{
name|Integer
name|dest_type
init|=
name|qb
operator|.
name|getMetaData
argument_list|()
operator|.
name|getDestTypeForAlias
argument_list|(
name|dest
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|dest_type
operator|.
name|intValue
argument_list|()
condition|)
block|{
case|case
name|QBMetaData
operator|.
name|DEST_TABLE
case|:
block|{
name|qb
operator|.
name|getMetaData
argument_list|()
operator|.
name|getDestTableForAlias
argument_list|(
name|dest
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|QBMetaData
operator|.
name|DEST_PARTITION
case|:
block|{
name|qb
operator|.
name|getMetaData
argument_list|()
operator|.
name|getDestPartitionForAlias
argument_list|(
name|dest
argument_list|)
operator|.
name|getTable
argument_list|()
expr_stmt|;
break|break;
block|}
default|default:
block|{
return|return
name|input
return|;
block|}
block|}
return|return
name|input
return|;
block|}
specifier|private
name|int
name|getReducersBucketing
parameter_list|(
name|int
name|totalFiles
parameter_list|,
name|int
name|maxReducers
parameter_list|)
block|{
name|int
name|numFiles
init|=
name|totalFiles
operator|/
name|maxReducers
decl_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
if|if
condition|(
name|totalFiles
operator|%
name|numFiles
operator|==
literal|0
condition|)
block|{
return|return
name|totalFiles
operator|/
name|numFiles
return|;
block|}
name|numFiles
operator|++
expr_stmt|;
block|}
block|}
specifier|private
specifier|static
class|class
name|SortBucketRSCtx
block|{
name|ArrayList
argument_list|<
name|ExprNodeDesc
argument_list|>
name|partnCols
decl_stmt|;
name|boolean
name|multiFileSpray
decl_stmt|;
name|int
name|numFiles
decl_stmt|;
name|int
name|totalFiles
decl_stmt|;
specifier|public
name|SortBucketRSCtx
parameter_list|()
block|{
name|partnCols
operator|=
literal|null
expr_stmt|;
name|multiFileSpray
operator|=
literal|false
expr_stmt|;
name|numFiles
operator|=
literal|1
expr_stmt|;
name|totalFiles
operator|=
literal|1
expr_stmt|;
block|}
comment|/**      * @return the partnCols      */
specifier|public
name|ArrayList
argument_list|<
name|ExprNodeDesc
argument_list|>
name|getPartnCols
parameter_list|()
block|{
return|return
name|partnCols
return|;
block|}
comment|/**      * @param partnCols the partnCols to set      */
specifier|public
name|void
name|setPartnCols
parameter_list|(
name|ArrayList
argument_list|<
name|ExprNodeDesc
argument_list|>
name|partnCols
parameter_list|)
block|{
name|this
operator|.
name|partnCols
operator|=
name|partnCols
expr_stmt|;
block|}
comment|/**      * @return the multiFileSpray      */
specifier|public
name|boolean
name|isMultiFileSpray
parameter_list|()
block|{
return|return
name|multiFileSpray
return|;
block|}
comment|/**      * @param multiFileSpray the multiFileSpray to set      */
specifier|public
name|void
name|setMultiFileSpray
parameter_list|(
name|boolean
name|multiFileSpray
parameter_list|)
block|{
name|this
operator|.
name|multiFileSpray
operator|=
name|multiFileSpray
expr_stmt|;
block|}
comment|/**      * @return the numFiles      */
specifier|public
name|int
name|getNumFiles
parameter_list|()
block|{
return|return
name|numFiles
return|;
block|}
comment|/**      * @param numFiles the numFiles to set      */
specifier|public
name|void
name|setNumFiles
parameter_list|(
name|int
name|numFiles
parameter_list|)
block|{
name|this
operator|.
name|numFiles
operator|=
name|numFiles
expr_stmt|;
block|}
comment|/**      * @return the totalFiles      */
specifier|public
name|int
name|getTotalFiles
parameter_list|()
block|{
return|return
name|totalFiles
return|;
block|}
comment|/**      * @param totalFiles the totalFiles to set      */
specifier|public
name|void
name|setTotalFiles
parameter_list|(
name|int
name|totalFiles
parameter_list|)
block|{
name|this
operator|.
name|totalFiles
operator|=
name|totalFiles
expr_stmt|;
block|}
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"nls"
argument_list|)
specifier|private
name|Operator
name|genBucketingSortingDest
parameter_list|(
name|String
name|dest
parameter_list|,
name|Operator
name|input
parameter_list|,
name|QB
name|qb
parameter_list|,
name|TableDesc
name|table_desc
parameter_list|,
name|Table
name|dest_tab
parameter_list|,
name|SortBucketRSCtx
name|ctx
parameter_list|)
throws|throws
name|SemanticException
block|{
comment|// If the table is bucketed, and bucketing is enforced, do the following:
comment|// If the number of buckets is smaller than the number of maximum reducers,
comment|// create those many reducers.
comment|// If not, create a multiFileSink instead of FileSink - the multiFileSink will
comment|// spray the data into multiple buckets. That way, we can support a very large
comment|// number of buckets without needing a very large number of reducers.
name|boolean
name|enforceBucketing
init|=
literal|false
decl_stmt|;
name|boolean
name|enforceSorting
init|=
literal|false
decl_stmt|;
name|ArrayList
argument_list|<
name|ExprNodeDesc
argument_list|>
name|partnCols
init|=
operator|new
name|ArrayList
argument_list|<
name|ExprNodeDesc
argument_list|>
argument_list|()
decl_stmt|;
name|ArrayList
argument_list|<
name|ExprNodeDesc
argument_list|>
name|partnColsNoConvert
init|=
operator|new
name|ArrayList
argument_list|<
name|ExprNodeDesc
argument_list|>
argument_list|()
decl_stmt|;
name|ArrayList
argument_list|<
name|ExprNodeDesc
argument_list|>
name|sortCols
init|=
operator|new
name|ArrayList
argument_list|<
name|ExprNodeDesc
argument_list|>
argument_list|()
decl_stmt|;
name|boolean
name|multiFileSpray
init|=
literal|false
decl_stmt|;
name|int
name|numFiles
init|=
literal|1
decl_stmt|;
name|int
name|totalFiles
init|=
literal|1
decl_stmt|;
if|if
condition|(
operator|(
name|dest_tab
operator|.
name|getNumBuckets
argument_list|()
operator|>
literal|0
operator|)
operator|&&
operator|(
name|conf
operator|.
name|getBoolVar
argument_list|(
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVEENFORCEBUCKETING
argument_list|)
operator|)
condition|)
block|{
name|enforceBucketing
operator|=
literal|true
expr_stmt|;
name|partnCols
operator|=
name|getParitionColsFromBucketCols
argument_list|(
name|dest
argument_list|,
name|qb
argument_list|,
name|dest_tab
argument_list|,
name|table_desc
argument_list|,
name|input
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|partnColsNoConvert
operator|=
name|getParitionColsFromBucketCols
argument_list|(
name|dest
argument_list|,
name|qb
argument_list|,
name|dest_tab
argument_list|,
name|table_desc
argument_list|,
name|input
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|dest_tab
operator|.
name|getSortCols
argument_list|()
operator|!=
literal|null
operator|)
operator|&&
operator|(
name|dest_tab
operator|.
name|getSortCols
argument_list|()
operator|.
name|size
argument_list|()
operator|>
literal|0
operator|)
operator|&&
operator|(
name|conf
operator|.
name|getBoolVar
argument_list|(
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVEENFORCESORTING
argument_list|)
operator|)
condition|)
block|{
name|enforceSorting
operator|=
literal|true
expr_stmt|;
name|sortCols
operator|=
name|getSortCols
argument_list|(
name|dest
argument_list|,
name|qb
argument_list|,
name|dest_tab
argument_list|,
name|table_desc
argument_list|,
name|input
argument_list|,
literal|true
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|enforceBucketing
condition|)
block|{
name|partnCols
operator|=
name|sortCols
expr_stmt|;
name|partnColsNoConvert
operator|=
name|getSortCols
argument_list|(
name|dest
argument_list|,
name|qb
argument_list|,
name|dest_tab
argument_list|,
name|table_desc
argument_list|,
name|input
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|enforceBucketing
operator|||
name|enforceSorting
condition|)
block|{
name|int
name|maxReducers
init|=
name|conf
operator|.
name|getIntVar
argument_list|(
name|HiveConf
operator|.
name|ConfVars
operator|.
name|MAXREDUCERS
argument_list|)
decl_stmt|;
name|int
name|numBuckets
init|=
name|dest_tab
operator|.
name|getNumBuckets
argument_list|()
decl_stmt|;
if|if
condition|(
name|numBuckets
operator|>
name|maxReducers
condition|)
block|{
name|multiFileSpray
operator|=
literal|true
expr_stmt|;
name|totalFiles
operator|=
name|numBuckets
expr_stmt|;
if|if
condition|(
name|totalFiles
operator|%
name|maxReducers
operator|==
literal|0
condition|)
block|{
name|numFiles
operator|=
name|totalFiles
operator|/
name|maxReducers
expr_stmt|;
block|}
else|else
block|{
comment|// find the number of reducers such that it is a divisor of totalFiles
name|maxReducers
operator|=
name|getReducersBucketing
argument_list|(
name|totalFiles
argument_list|,
name|maxReducers
argument_list|)
expr_stmt|;
name|numFiles
operator|=
name|totalFiles
operator|/
name|maxReducers
expr_stmt|;
block|}
block|}
else|else
block|{
name|maxReducers
operator|=
name|numBuckets
expr_stmt|;
block|}
name|input
operator|=
name|genReduceSinkPlanForSortingBucketing
argument_list|(
name|dest_tab
argument_list|,
name|input
argument_list|,
name|sortCols
argument_list|,
name|partnCols
argument_list|,
name|maxReducers
argument_list|)
expr_stmt|;
name|ctx
operator|.
name|setMultiFileSpray
argument_list|(
name|multiFileSpray
argument_list|)
expr_stmt|;
name|ctx
operator|.
name|setNumFiles
argument_list|(
name|numFiles
argument_list|)
expr_stmt|;
name|ctx
operator|.
name|setPartnCols
argument_list|(
name|partnColsNoConvert
argument_list|)
expr_stmt|;
name|ctx
operator|.
name|setTotalFiles
argument_list|(
name|totalFiles
argument_list|)
expr_stmt|;
comment|//disable "merge mapfiles" and "merge mapred files".
name|HiveConf
operator|.
name|setBoolVar
argument_list|(
name|conf
argument_list|,
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVEMERGEMAPFILES
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|HiveConf
operator|.
name|setBoolVar
argument_list|(
name|conf
argument_list|,
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVEMERGEMAPREDFILES
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
return|return
name|input
return|;
block|}
comment|/**    * Check for HOLD_DDLTIME hint.    * @param qb    * @return true if HOLD_DDLTIME is set, false otherwise.    */
specifier|private
name|boolean
name|checkHoldDDLTime
parameter_list|(
name|QB
name|qb
parameter_list|)
block|{
name|ASTNode
name|hints
init|=
name|qb
operator|.
name|getParseInfo
argument_list|()
operator|.
name|getHints
argument_list|()
decl_stmt|;
if|if
condition|(
name|hints
operator|==
literal|null
condition|)
block|{
return|return
literal|false
return|;
block|}
for|for
control|(
name|int
name|pos
init|=
literal|0
init|;
name|pos
operator|<
name|hints
operator|.
name|getChildCount
argument_list|()
condition|;
name|pos
operator|++
control|)
block|{
name|ASTNode
name|hint
init|=
operator|(
name|ASTNode
operator|)
name|hints
operator|.
name|getChild
argument_list|(
name|pos
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
operator|(
name|ASTNode
operator|)
name|hint
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|)
operator|.
name|getToken
argument_list|()
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_HOLD_DDLTIME
condition|)
block|{
return|return
literal|true
return|;
block|}
block|}
return|return
literal|false
return|;
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"nls"
argument_list|)
specifier|private
name|Operator
name|genFileSinkPlan
parameter_list|(
name|String
name|dest
parameter_list|,
name|QB
name|qb
parameter_list|,
name|Operator
name|input
parameter_list|)
throws|throws
name|SemanticException
block|{
name|RowResolver
name|inputRR
init|=
name|opParseCtx
operator|.
name|get
argument_list|(
name|input
argument_list|)
operator|.
name|getRowResolver
argument_list|()
decl_stmt|;
name|QBMetaData
name|qbm
init|=
name|qb
operator|.
name|getMetaData
argument_list|()
decl_stmt|;
name|Integer
name|dest_type
init|=
name|qbm
operator|.
name|getDestTypeForAlias
argument_list|(
name|dest
argument_list|)
decl_stmt|;
name|Table
name|dest_tab
init|=
literal|null
decl_stmt|;
comment|// destination table if any
name|Partition
name|dest_part
init|=
literal|null
decl_stmt|;
comment|// destination partition if any
name|String
name|queryTmpdir
init|=
literal|null
decl_stmt|;
comment|// the intermediate destination directory
name|Path
name|dest_path
init|=
literal|null
decl_stmt|;
comment|// the final destination directory
name|TableDesc
name|table_desc
init|=
literal|null
decl_stmt|;
name|int
name|currentTableId
init|=
literal|0
decl_stmt|;
name|boolean
name|isLocal
init|=
literal|false
decl_stmt|;
name|SortBucketRSCtx
name|rsCtx
init|=
operator|new
name|SortBucketRSCtx
argument_list|()
decl_stmt|;
name|DynamicPartitionCtx
name|dpCtx
init|=
literal|null
decl_stmt|;
name|LoadTableDesc
name|ltd
init|=
literal|null
decl_stmt|;
name|boolean
name|holdDDLTime
init|=
name|checkHoldDDLTime
argument_list|(
name|qb
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|dest_type
operator|.
name|intValue
argument_list|()
condition|)
block|{
case|case
name|QBMetaData
operator|.
name|DEST_TABLE
case|:
block|{
name|dest_tab
operator|=
name|qbm
operator|.
name|getDestTableForAlias
argument_list|(
name|dest
argument_list|)
expr_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|partSpec
init|=
name|qbm
operator|.
name|getPartSpecForAlias
argument_list|(
name|dest
argument_list|)
decl_stmt|;
name|dest_path
operator|=
name|dest_tab
operator|.
name|getPath
argument_list|()
expr_stmt|;
comment|// check for partition
name|List
argument_list|<
name|FieldSchema
argument_list|>
name|parts
init|=
name|dest_tab
operator|.
name|getPartitionKeys
argument_list|()
decl_stmt|;
if|if
condition|(
name|parts
operator|!=
literal|null
operator|&&
name|parts
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
comment|// table is partitioned
if|if
condition|(
name|partSpec
operator|==
literal|null
operator|||
name|partSpec
operator|.
name|size
argument_list|()
operator|==
literal|0
condition|)
block|{
comment|// user did NOT specify partition
throw|throw
operator|new
name|SemanticException
argument_list|(
name|generateErrorMessage
argument_list|(
name|qb
operator|.
name|getParseInfo
argument_list|()
operator|.
name|getDestForClause
argument_list|(
name|dest
argument_list|)
argument_list|,
name|ErrorMsg
operator|.
name|NEED_PARTITION_ERROR
operator|.
name|getMsg
argument_list|()
argument_list|)
argument_list|)
throw|;
block|}
comment|// the HOLD_DDLTIIME hint should not be used with dynamic partition since the
comment|// newly generated partitions should always update their DDLTIME
if|if
condition|(
name|holdDDLTime
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|generateErrorMessage
argument_list|(
name|qb
operator|.
name|getParseInfo
argument_list|()
operator|.
name|getDestForClause
argument_list|(
name|dest
argument_list|)
argument_list|,
name|ErrorMsg
operator|.
name|HOLD_DDLTIME_ON_NONEXIST_PARTITIONS
operator|.
name|getMsg
argument_list|()
argument_list|)
argument_list|)
throw|;
block|}
name|dpCtx
operator|=
name|qbm
operator|.
name|getDPCtx
argument_list|(
name|dest
argument_list|)
expr_stmt|;
if|if
condition|(
name|dpCtx
operator|==
literal|null
condition|)
block|{
name|Utilities
operator|.
name|validatePartSpec
argument_list|(
name|dest_tab
argument_list|,
name|partSpec
argument_list|)
expr_stmt|;
name|dpCtx
operator|=
operator|new
name|DynamicPartitionCtx
argument_list|(
name|dest_tab
argument_list|,
name|partSpec
argument_list|,
name|conf
operator|.
name|getVar
argument_list|(
name|HiveConf
operator|.
name|ConfVars
operator|.
name|DEFAULTPARTITIONNAME
argument_list|)
argument_list|,
name|conf
operator|.
name|getIntVar
argument_list|(
name|HiveConf
operator|.
name|ConfVars
operator|.
name|DYNAMICPARTITIONMAXPARTSPERNODE
argument_list|)
argument_list|)
expr_stmt|;
name|qbm
operator|.
name|setDPCtx
argument_list|(
name|dest
argument_list|,
name|dpCtx
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|HiveConf
operator|.
name|getBoolVar
argument_list|(
name|conf
argument_list|,
name|HiveConf
operator|.
name|ConfVars
operator|.
name|DYNAMICPARTITIONING
argument_list|)
condition|)
block|{
comment|// allow DP
if|if
condition|(
name|dpCtx
operator|.
name|getNumDPCols
argument_list|()
operator|>
literal|0
operator|&&
operator|(
name|HiveConf
operator|.
name|getBoolVar
argument_list|(
name|conf
argument_list|,
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVEMERGEMAPFILES
argument_list|)
operator|||
name|HiveConf
operator|.
name|getBoolVar
argument_list|(
name|conf
argument_list|,
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVEMERGEMAPREDFILES
argument_list|)
operator|)
operator|&&
name|Utilities
operator|.
name|supportCombineFileInputFormat
argument_list|()
operator|==
literal|false
condition|)
block|{
comment|// Do not support merge for Hadoop versions (pre-0.20) that do not
comment|// support CombineHiveInputFormat
name|HiveConf
operator|.
name|setBoolVar
argument_list|(
name|conf
argument_list|,
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVEMERGEMAPFILES
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|HiveConf
operator|.
name|setBoolVar
argument_list|(
name|conf
argument_list|,
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVEMERGEMAPREDFILES
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
comment|// turn on hive.task.progress to update # of partitions created to the JT
name|HiveConf
operator|.
name|setBoolVar
argument_list|(
name|conf
argument_list|,
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVEJOBPROGRESS
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// QBMetaData.DEST_PARTITION capture the all-SP case
throw|throw
operator|new
name|SemanticException
argument_list|(
name|generateErrorMessage
argument_list|(
name|qb
operator|.
name|getParseInfo
argument_list|()
operator|.
name|getDestForClause
argument_list|(
name|dest
argument_list|)
argument_list|,
name|ErrorMsg
operator|.
name|DYNAMIC_PARTITION_DISABLED
operator|.
name|getMsg
argument_list|()
argument_list|)
argument_list|)
throw|;
block|}
if|if
condition|(
name|dpCtx
operator|.
name|getSPPath
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|dest_path
operator|=
operator|new
name|Path
argument_list|(
name|dest_tab
operator|.
name|getPath
argument_list|()
argument_list|,
name|dpCtx
operator|.
name|getSPPath
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|dest_tab
operator|.
name|getNumBuckets
argument_list|()
operator|>
literal|0
operator|)
operator|&&
operator|(
name|conf
operator|.
name|getBoolVar
argument_list|(
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVEENFORCEBUCKETING
argument_list|)
operator|)
condition|)
block|{
name|dpCtx
operator|.
name|setNumBuckets
argument_list|(
name|dest_tab
operator|.
name|getNumBuckets
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
name|boolean
name|isNonNativeTable
init|=
name|dest_tab
operator|.
name|isNonNative
argument_list|()
decl_stmt|;
if|if
condition|(
name|isNonNativeTable
condition|)
block|{
name|queryTmpdir
operator|=
name|dest_path
operator|.
name|toUri
argument_list|()
operator|.
name|getPath
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|queryTmpdir
operator|=
name|ctx
operator|.
name|getExternalTmpFileURI
argument_list|(
name|dest_path
operator|.
name|toUri
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|dpCtx
operator|!=
literal|null
condition|)
block|{
comment|// set the root of the temporay path where dynamic partition columns will populate
name|dpCtx
operator|.
name|setRootPath
argument_list|(
name|queryTmpdir
argument_list|)
expr_stmt|;
block|}
comment|// this table_desc does not contain the partitioning columns
name|table_desc
operator|=
name|Utilities
operator|.
name|getTableDesc
argument_list|(
name|dest_tab
argument_list|)
expr_stmt|;
comment|// Add sorting/bucketing if needed
name|input
operator|=
name|genBucketingSortingDest
argument_list|(
name|dest
argument_list|,
name|input
argument_list|,
name|qb
argument_list|,
name|table_desc
argument_list|,
name|dest_tab
argument_list|,
name|rsCtx
argument_list|)
expr_stmt|;
name|idToTableNameMap
operator|.
name|put
argument_list|(
name|String
operator|.
name|valueOf
argument_list|(
name|destTableId
argument_list|)
argument_list|,
name|dest_tab
operator|.
name|getTableName
argument_list|()
argument_list|)
expr_stmt|;
name|currentTableId
operator|=
name|destTableId
expr_stmt|;
name|destTableId
operator|++
expr_stmt|;
comment|// Create the work for moving the table
comment|// NOTE: specify Dynamic partitions in dest_tab for WriteEntity
if|if
condition|(
operator|!
name|isNonNativeTable
condition|)
block|{
name|ltd
operator|=
operator|new
name|LoadTableDesc
argument_list|(
name|queryTmpdir
argument_list|,
name|ctx
operator|.
name|getExternalTmpFileURI
argument_list|(
name|dest_path
operator|.
name|toUri
argument_list|()
argument_list|)
argument_list|,
name|table_desc
argument_list|,
name|dpCtx
argument_list|)
expr_stmt|;
name|ltd
operator|.
name|setReplace
argument_list|(
operator|!
name|qb
operator|.
name|getParseInfo
argument_list|()
operator|.
name|isInsertIntoTable
argument_list|(
name|dest_tab
operator|.
name|getTableName
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|holdDDLTime
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"this query will not update transient_lastDdlTime!"
argument_list|)
expr_stmt|;
name|ltd
operator|.
name|setHoldDDLTime
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
name|loadTableWork
operator|.
name|add
argument_list|(
name|ltd
argument_list|)
expr_stmt|;
block|}
comment|// Here only register the whole table for post-exec hook if no DP present
comment|// in the case of DP, we will register WriteEntity in MoveTask when the
comment|// list of dynamically created partitions are known.
if|if
condition|(
operator|(
name|dpCtx
operator|==
literal|null
operator|||
name|dpCtx
operator|.
name|getNumDPCols
argument_list|()
operator|==
literal|0
operator|)
operator|&&
operator|!
name|outputs
operator|.
name|add
argument_list|(
operator|new
name|WriteEntity
argument_list|(
name|dest_tab
argument_list|)
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|OUTPUT_SPECIFIED_MULTIPLE_TIMES
operator|.
name|getMsg
argument_list|(
name|dest_tab
operator|.
name|getTableName
argument_list|()
argument_list|)
argument_list|)
throw|;
block|}
if|if
condition|(
operator|(
name|dpCtx
operator|!=
literal|null
operator|)
operator|&&
operator|(
name|dpCtx
operator|.
name|getNumDPCols
argument_list|()
operator|>=
literal|0
operator|)
condition|)
block|{
comment|// No static partition specified
if|if
condition|(
name|dpCtx
operator|.
name|getNumSPCols
argument_list|()
operator|==
literal|0
condition|)
block|{
name|outputs
operator|.
name|add
argument_list|(
operator|new
name|WriteEntity
argument_list|(
name|dest_tab
argument_list|,
literal|false
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// part of the partition specified
comment|// Create a DummyPartition in this case. Since, the metastore does not store partial
comment|// partitions currently, we need to store dummy partitions
else|else
block|{
try|try
block|{
name|String
name|ppath
init|=
name|dpCtx
operator|.
name|getSPPath
argument_list|()
decl_stmt|;
name|ppath
operator|=
name|ppath
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|ppath
operator|.
name|length
argument_list|()
operator|-
literal|1
argument_list|)
expr_stmt|;
name|DummyPartition
name|p
init|=
operator|new
name|DummyPartition
argument_list|(
name|dest_tab
argument_list|,
name|dest_tab
operator|.
name|getDbName
argument_list|()
operator|+
literal|"@"
operator|+
name|dest_tab
operator|.
name|getTableName
argument_list|()
operator|+
literal|"@"
operator|+
name|ppath
argument_list|)
decl_stmt|;
name|outputs
operator|.
name|add
argument_list|(
operator|new
name|WriteEntity
argument_list|(
name|p
argument_list|,
literal|false
argument_list|)
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|HiveException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|e
operator|.
name|getMessage
argument_list|()
argument_list|)
throw|;
block|}
block|}
block|}
break|break;
block|}
case|case
name|QBMetaData
operator|.
name|DEST_PARTITION
case|:
block|{
name|dest_part
operator|=
name|qbm
operator|.
name|getDestPartitionForAlias
argument_list|(
name|dest
argument_list|)
expr_stmt|;
name|dest_tab
operator|=
name|dest_part
operator|.
name|getTable
argument_list|()
expr_stmt|;
name|Path
name|tabPath
init|=
name|dest_tab
operator|.
name|getPath
argument_list|()
decl_stmt|;
name|Path
name|partPath
init|=
name|dest_part
operator|.
name|getPartitionPath
argument_list|()
decl_stmt|;
comment|// if the table is in a different dfs than the partition,
comment|// replace the partition's dfs with the table's dfs.
name|dest_path
operator|=
operator|new
name|Path
argument_list|(
name|tabPath
operator|.
name|toUri
argument_list|()
operator|.
name|getScheme
argument_list|()
argument_list|,
name|tabPath
operator|.
name|toUri
argument_list|()
operator|.
name|getAuthority
argument_list|()
argument_list|,
name|partPath
operator|.
name|toUri
argument_list|()
operator|.
name|getPath
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
literal|"har"
operator|.
name|equalsIgnoreCase
argument_list|(
name|dest_path
operator|.
name|toUri
argument_list|()
operator|.
name|getScheme
argument_list|()
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|OVERWRITE_ARCHIVED_PART
operator|.
name|getMsg
argument_list|(
name|qb
operator|.
name|getParseInfo
argument_list|()
operator|.
name|getDestForClause
argument_list|(
name|dest
argument_list|)
argument_list|)
argument_list|)
throw|;
block|}
name|queryTmpdir
operator|=
name|ctx
operator|.
name|getExternalTmpFileURI
argument_list|(
name|dest_path
operator|.
name|toUri
argument_list|()
argument_list|)
expr_stmt|;
name|table_desc
operator|=
name|Utilities
operator|.
name|getTableDesc
argument_list|(
name|dest_tab
argument_list|)
expr_stmt|;
comment|// Add sorting/bucketing if needed
name|input
operator|=
name|genBucketingSortingDest
argument_list|(
name|dest
argument_list|,
name|input
argument_list|,
name|qb
argument_list|,
name|table_desc
argument_list|,
name|dest_tab
argument_list|,
name|rsCtx
argument_list|)
expr_stmt|;
name|idToTableNameMap
operator|.
name|put
argument_list|(
name|String
operator|.
name|valueOf
argument_list|(
name|destTableId
argument_list|)
argument_list|,
name|dest_tab
operator|.
name|getTableName
argument_list|()
argument_list|)
expr_stmt|;
name|currentTableId
operator|=
name|destTableId
expr_stmt|;
name|destTableId
operator|++
expr_stmt|;
name|ltd
operator|=
operator|new
name|LoadTableDesc
argument_list|(
name|queryTmpdir
argument_list|,
name|ctx
operator|.
name|getExternalTmpFileURI
argument_list|(
name|dest_path
operator|.
name|toUri
argument_list|()
argument_list|)
argument_list|,
name|table_desc
argument_list|,
name|dest_part
operator|.
name|getSpec
argument_list|()
argument_list|)
expr_stmt|;
name|ltd
operator|.
name|setReplace
argument_list|(
operator|!
name|qb
operator|.
name|getParseInfo
argument_list|()
operator|.
name|isInsertIntoTable
argument_list|(
name|dest_tab
operator|.
name|getTableName
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|holdDDLTime
condition|)
block|{
try|try
block|{
name|Partition
name|part
init|=
name|db
operator|.
name|getPartition
argument_list|(
name|dest_tab
argument_list|,
name|dest_part
operator|.
name|getSpec
argument_list|()
argument_list|,
literal|false
argument_list|)
decl_stmt|;
if|if
condition|(
name|part
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|generateErrorMessage
argument_list|(
name|qb
operator|.
name|getParseInfo
argument_list|()
operator|.
name|getDestForClause
argument_list|(
name|dest
argument_list|)
argument_list|,
name|ErrorMsg
operator|.
name|HOLD_DDLTIME_ON_NONEXIST_PARTITIONS
operator|.
name|getMsg
argument_list|()
argument_list|)
argument_list|)
throw|;
block|}
block|}
catch|catch
parameter_list|(
name|HiveException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|e
argument_list|)
throw|;
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"this query will not update transient_lastDdlTime!"
argument_list|)
expr_stmt|;
name|ltd
operator|.
name|setHoldDDLTime
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
name|loadTableWork
operator|.
name|add
argument_list|(
name|ltd
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|outputs
operator|.
name|add
argument_list|(
operator|new
name|WriteEntity
argument_list|(
name|dest_part
argument_list|)
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|OUTPUT_SPECIFIED_MULTIPLE_TIMES
operator|.
name|getMsg
argument_list|(
name|dest_tab
operator|.
name|getTableName
argument_list|()
operator|+
literal|"@"
operator|+
name|dest_part
operator|.
name|getName
argument_list|()
argument_list|)
argument_list|)
throw|;
block|}
break|break;
block|}
case|case
name|QBMetaData
operator|.
name|DEST_LOCAL_FILE
case|:
name|isLocal
operator|=
literal|true
expr_stmt|;
comment|// fall through
case|case
name|QBMetaData
operator|.
name|DEST_DFS_FILE
case|:
block|{
name|dest_path
operator|=
operator|new
name|Path
argument_list|(
name|qbm
operator|.
name|getDestFileForAlias
argument_list|(
name|dest
argument_list|)
argument_list|)
expr_stmt|;
name|String
name|destStr
init|=
name|dest_path
operator|.
name|toString
argument_list|()
decl_stmt|;
if|if
condition|(
name|isLocal
condition|)
block|{
comment|// for local directory - we always write to map-red intermediate
comment|// store and then copy to local fs
name|queryTmpdir
operator|=
name|ctx
operator|.
name|getMRTmpFileURI
argument_list|()
expr_stmt|;
block|}
else|else
block|{
comment|// otherwise write to the file system implied by the directory
comment|// no copy is required. we may want to revisit this policy in future
try|try
block|{
name|Path
name|qPath
init|=
name|FileUtils
operator|.
name|makeQualified
argument_list|(
name|dest_path
argument_list|,
name|conf
argument_list|)
decl_stmt|;
name|queryTmpdir
operator|=
name|ctx
operator|.
name|getExternalTmpFileURI
argument_list|(
name|qPath
operator|.
name|toUri
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
literal|"Error creating temporary folder on: "
operator|+
name|dest_path
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
name|String
name|cols
init|=
literal|""
decl_stmt|;
name|String
name|colTypes
init|=
literal|""
decl_stmt|;
name|ArrayList
argument_list|<
name|ColumnInfo
argument_list|>
name|colInfos
init|=
name|inputRR
operator|.
name|getColumnInfos
argument_list|()
decl_stmt|;
comment|// CTAS case: the file output format and serde are defined by the create
comment|// table command
comment|// rather than taking the default value
name|List
argument_list|<
name|FieldSchema
argument_list|>
name|field_schemas
init|=
literal|null
decl_stmt|;
name|CreateTableDesc
name|tblDesc
init|=
name|qb
operator|.
name|getTableDesc
argument_list|()
decl_stmt|;
if|if
condition|(
name|tblDesc
operator|!=
literal|null
condition|)
block|{
name|field_schemas
operator|=
operator|new
name|ArrayList
argument_list|<
name|FieldSchema
argument_list|>
argument_list|()
expr_stmt|;
block|}
name|boolean
name|first
init|=
literal|true
decl_stmt|;
for|for
control|(
name|ColumnInfo
name|colInfo
range|:
name|colInfos
control|)
block|{
name|String
index|[]
name|nm
init|=
name|inputRR
operator|.
name|reverseLookup
argument_list|(
name|colInfo
operator|.
name|getInternalName
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|nm
index|[
literal|1
index|]
operator|!=
literal|null
condition|)
block|{
comment|// non-null column alias
name|colInfo
operator|.
name|setAlias
argument_list|(
name|nm
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|field_schemas
operator|!=
literal|null
condition|)
block|{
name|FieldSchema
name|col
init|=
operator|new
name|FieldSchema
argument_list|()
decl_stmt|;
if|if
condition|(
name|nm
index|[
literal|1
index|]
operator|!=
literal|null
condition|)
block|{
name|col
operator|.
name|setName
argument_list|(
name|unescapeIdentifier
argument_list|(
name|colInfo
operator|.
name|getAlias
argument_list|()
argument_list|)
operator|.
name|toLowerCase
argument_list|()
argument_list|)
expr_stmt|;
comment|// remove ``
block|}
else|else
block|{
name|col
operator|.
name|setName
argument_list|(
name|colInfo
operator|.
name|getInternalName
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|col
operator|.
name|setType
argument_list|(
name|colInfo
operator|.
name|getType
argument_list|()
operator|.
name|getTypeName
argument_list|()
argument_list|)
expr_stmt|;
name|field_schemas
operator|.
name|add
argument_list|(
name|col
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|first
condition|)
block|{
name|cols
operator|=
name|cols
operator|.
name|concat
argument_list|(
literal|","
argument_list|)
expr_stmt|;
name|colTypes
operator|=
name|colTypes
operator|.
name|concat
argument_list|(
literal|":"
argument_list|)
expr_stmt|;
block|}
name|first
operator|=
literal|false
expr_stmt|;
name|cols
operator|=
name|cols
operator|.
name|concat
argument_list|(
name|colInfo
operator|.
name|getInternalName
argument_list|()
argument_list|)
expr_stmt|;
comment|// Replace VOID type with string when the output is a temp table or
comment|// local files.
comment|// A VOID type can be generated under the query:
comment|//
comment|// select NULL from tt;
comment|// or
comment|// insert overwrite local directory "abc" select NULL from tt;
comment|//
comment|// where there is no column type to which the NULL value should be
comment|// converted.
comment|//
name|String
name|tName
init|=
name|colInfo
operator|.
name|getType
argument_list|()
operator|.
name|getTypeName
argument_list|()
decl_stmt|;
if|if
condition|(
name|tName
operator|.
name|equals
argument_list|(
name|Constants
operator|.
name|VOID_TYPE_NAME
argument_list|)
condition|)
block|{
name|colTypes
operator|=
name|colTypes
operator|.
name|concat
argument_list|(
name|Constants
operator|.
name|STRING_TYPE_NAME
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|colTypes
operator|=
name|colTypes
operator|.
name|concat
argument_list|(
name|tName
argument_list|)
expr_stmt|;
block|}
block|}
comment|// update the create table descriptor with the resulting schema.
if|if
condition|(
name|tblDesc
operator|!=
literal|null
condition|)
block|{
name|tblDesc
operator|.
name|setCols
argument_list|(
operator|new
name|ArrayList
argument_list|<
name|FieldSchema
argument_list|>
argument_list|(
name|field_schemas
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|ctx
operator|.
name|isMRTmpFileURI
argument_list|(
name|destStr
argument_list|)
condition|)
block|{
name|idToTableNameMap
operator|.
name|put
argument_list|(
name|String
operator|.
name|valueOf
argument_list|(
name|destTableId
argument_list|)
argument_list|,
name|destStr
argument_list|)
expr_stmt|;
name|currentTableId
operator|=
name|destTableId
expr_stmt|;
name|destTableId
operator|++
expr_stmt|;
block|}
name|boolean
name|isDfsDir
init|=
operator|(
name|dest_type
operator|.
name|intValue
argument_list|()
operator|==
name|QBMetaData
operator|.
name|DEST_DFS_FILE
operator|)
decl_stmt|;
name|loadFileWork
operator|.
name|add
argument_list|(
operator|new
name|LoadFileDesc
argument_list|(
name|queryTmpdir
argument_list|,
name|destStr
argument_list|,
name|isDfsDir
argument_list|,
name|cols
argument_list|,
name|colTypes
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|tblDesc
operator|==
literal|null
condition|)
block|{
if|if
condition|(
name|qb
operator|.
name|getIsQuery
argument_list|()
condition|)
block|{
name|String
name|fileFormat
init|=
name|HiveConf
operator|.
name|getVar
argument_list|(
name|conf
argument_list|,
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVEQUERYRESULTFILEFORMAT
argument_list|)
decl_stmt|;
name|table_desc
operator|=
name|PlanUtils
operator|.
name|getDefaultQueryOutputTableDesc
argument_list|(
name|cols
argument_list|,
name|colTypes
argument_list|,
name|fileFormat
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|table_desc
operator|=
name|PlanUtils
operator|.
name|getDefaultTableDesc
argument_list|(
name|Integer
operator|.
name|toString
argument_list|(
name|Utilities
operator|.
name|ctrlaCode
argument_list|)
argument_list|,
name|cols
argument_list|,
name|colTypes
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|table_desc
operator|=
name|PlanUtils
operator|.
name|getTableDesc
argument_list|(
name|tblDesc
argument_list|,
name|cols
argument_list|,
name|colTypes
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|outputs
operator|.
name|add
argument_list|(
operator|new
name|WriteEntity
argument_list|(
name|destStr
argument_list|,
operator|!
name|isDfsDir
argument_list|)
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|OUTPUT_SPECIFIED_MULTIPLE_TIMES
operator|.
name|getMsg
argument_list|(
name|destStr
argument_list|)
argument_list|)
throw|;
block|}
break|break;
block|}
default|default:
throw|throw
operator|new
name|SemanticException
argument_list|(
literal|"Unknown destination type: "
operator|+
name|dest_type
argument_list|)
throw|;
block|}
name|input
operator|=
name|genConversionSelectOperator
argument_list|(
name|dest
argument_list|,
name|qb
argument_list|,
name|input
argument_list|,
name|table_desc
argument_list|,
name|dpCtx
argument_list|)
expr_stmt|;
name|inputRR
operator|=
name|opParseCtx
operator|.
name|get
argument_list|(
name|input
argument_list|)
operator|.
name|getRowResolver
argument_list|()
expr_stmt|;
name|ArrayList
argument_list|<
name|ColumnInfo
argument_list|>
name|vecCol
init|=
operator|new
name|ArrayList
argument_list|<
name|ColumnInfo
argument_list|>
argument_list|()
decl_stmt|;
try|try
block|{
name|StructObjectInspector
name|rowObjectInspector
init|=
operator|(
name|StructObjectInspector
operator|)
name|table_desc
operator|.
name|getDeserializer
argument_list|()
operator|.
name|getObjectInspector
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|?
extends|extends
name|StructField
argument_list|>
name|fields
init|=
name|rowObjectInspector
operator|.
name|getAllStructFieldRefs
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|fields
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|vecCol
operator|.
name|add
argument_list|(
operator|new
name|ColumnInfo
argument_list|(
name|fields
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|getFieldName
argument_list|()
argument_list|,
name|TypeInfoUtils
operator|.
name|getTypeInfoFromObjectInspector
argument_list|(
name|fields
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|getFieldObjectInspector
argument_list|()
argument_list|)
argument_list|,
literal|""
argument_list|,
literal|false
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|e
operator|.
name|getMessage
argument_list|()
argument_list|)
throw|;
block|}
name|RowSchema
name|fsRS
init|=
operator|new
name|RowSchema
argument_list|(
name|vecCol
argument_list|)
decl_stmt|;
name|FileSinkDesc
name|fileSinkDesc
init|=
operator|new
name|FileSinkDesc
argument_list|(
name|queryTmpdir
argument_list|,
name|table_desc
argument_list|,
name|conf
operator|.
name|getBoolVar
argument_list|(
name|HiveConf
operator|.
name|ConfVars
operator|.
name|COMPRESSRESULT
argument_list|)
argument_list|,
name|currentTableId
argument_list|,
name|rsCtx
operator|.
name|isMultiFileSpray
argument_list|()
argument_list|,
name|rsCtx
operator|.
name|getNumFiles
argument_list|()
argument_list|,
name|rsCtx
operator|.
name|getTotalFiles
argument_list|()
argument_list|,
name|rsCtx
operator|.
name|getPartnCols
argument_list|()
argument_list|,
name|dpCtx
argument_list|)
decl_stmt|;
comment|// set the stats publishing/aggregating key prefix
comment|// the same as directory name. The directory name
comment|// can be changed in the optimizer  but the key should not be changed
comment|// it should be the same as the MoveWork's sourceDir.
name|fileSinkDesc
operator|.
name|setStatsAggPrefix
argument_list|(
name|fileSinkDesc
operator|.
name|getDirName
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|dest_part
operator|!=
literal|null
condition|)
block|{
try|try
block|{
name|String
name|staticSpec
init|=
name|Warehouse
operator|.
name|makePartPath
argument_list|(
name|dest_part
operator|.
name|getSpec
argument_list|()
argument_list|)
decl_stmt|;
name|fileSinkDesc
operator|.
name|setStaticSpec
argument_list|(
name|staticSpec
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|MetaException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
elseif|else
if|if
condition|(
name|dpCtx
operator|!=
literal|null
condition|)
block|{
name|fileSinkDesc
operator|.
name|setStaticSpec
argument_list|(
name|dpCtx
operator|.
name|getSPPath
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|Operator
name|output
init|=
name|putOpInsertMap
argument_list|(
name|OperatorFactory
operator|.
name|getAndMakeChild
argument_list|(
name|fileSinkDesc
argument_list|,
name|fsRS
argument_list|,
name|input
argument_list|)
argument_list|,
name|inputRR
argument_list|)
decl_stmt|;
if|if
condition|(
name|ltd
operator|!=
literal|null
operator|&&
name|SessionState
operator|.
name|get
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|SessionState
operator|.
name|get
argument_list|()
operator|.
name|getLineageState
argument_list|()
operator|.
name|mapDirToFop
argument_list|(
name|ltd
operator|.
name|getSourceDir
argument_list|()
argument_list|,
operator|(
name|FileSinkOperator
operator|)
name|output
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Created FileSink Plan for clause: "
operator|+
name|dest
operator|+
literal|"dest_path: "
operator|+
name|dest_path
operator|+
literal|" row schema: "
operator|+
name|inputRR
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|output
return|;
block|}
comment|/**    * Generate the conversion SelectOperator that converts the columns into the    * types that are expected by the table_desc.    */
name|Operator
name|genConversionSelectOperator
parameter_list|(
name|String
name|dest
parameter_list|,
name|QB
name|qb
parameter_list|,
name|Operator
name|input
parameter_list|,
name|TableDesc
name|table_desc
parameter_list|,
name|DynamicPartitionCtx
name|dpCtx
parameter_list|)
throws|throws
name|SemanticException
block|{
name|StructObjectInspector
name|oi
init|=
literal|null
decl_stmt|;
try|try
block|{
name|Deserializer
name|deserializer
init|=
name|table_desc
operator|.
name|getDeserializerClass
argument_list|()
operator|.
name|newInstance
argument_list|()
decl_stmt|;
name|deserializer
operator|.
name|initialize
argument_list|(
name|conf
argument_list|,
name|table_desc
operator|.
name|getProperties
argument_list|()
argument_list|)
expr_stmt|;
name|oi
operator|=
operator|(
name|StructObjectInspector
operator|)
name|deserializer
operator|.
name|getObjectInspector
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|e
argument_list|)
throw|;
block|}
comment|// Check column number
name|List
argument_list|<
name|?
extends|extends
name|StructField
argument_list|>
name|tableFields
init|=
name|oi
operator|.
name|getAllStructFieldRefs
argument_list|()
decl_stmt|;
name|boolean
name|dynPart
init|=
name|HiveConf
operator|.
name|getBoolVar
argument_list|(
name|conf
argument_list|,
name|HiveConf
operator|.
name|ConfVars
operator|.
name|DYNAMICPARTITIONING
argument_list|)
decl_stmt|;
name|ArrayList
argument_list|<
name|ColumnInfo
argument_list|>
name|rowFields
init|=
name|opParseCtx
operator|.
name|get
argument_list|(
name|input
argument_list|)
operator|.
name|getRowResolver
argument_list|()
operator|.
name|getColumnInfos
argument_list|()
decl_stmt|;
name|int
name|inColumnCnt
init|=
name|rowFields
operator|.
name|size
argument_list|()
decl_stmt|;
name|int
name|outColumnCnt
init|=
name|tableFields
operator|.
name|size
argument_list|()
decl_stmt|;
if|if
condition|(
name|dynPart
operator|&&
name|dpCtx
operator|!=
literal|null
condition|)
block|{
name|outColumnCnt
operator|+=
name|dpCtx
operator|.
name|getNumDPCols
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|inColumnCnt
operator|!=
name|outColumnCnt
condition|)
block|{
name|String
name|reason
init|=
literal|"Table "
operator|+
name|dest
operator|+
literal|" has "
operator|+
name|outColumnCnt
operator|+
literal|" columns, but query has "
operator|+
name|inColumnCnt
operator|+
literal|" columns."
decl_stmt|;
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|TARGET_TABLE_COLUMN_MISMATCH
operator|.
name|getMsg
argument_list|(
name|qb
operator|.
name|getParseInfo
argument_list|()
operator|.
name|getDestForClause
argument_list|(
name|dest
argument_list|)
argument_list|,
name|reason
argument_list|)
argument_list|)
throw|;
block|}
elseif|else
if|if
condition|(
name|dynPart
operator|&&
name|dpCtx
operator|!=
literal|null
condition|)
block|{
comment|// create the mapping from input ExprNode to dest table DP column
name|dpCtx
operator|.
name|mapInputToDP
argument_list|(
name|rowFields
operator|.
name|subList
argument_list|(
name|tableFields
operator|.
name|size
argument_list|()
argument_list|,
name|rowFields
operator|.
name|size
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// Check column types
name|boolean
name|converted
init|=
literal|false
decl_stmt|;
name|int
name|columnNumber
init|=
name|tableFields
operator|.
name|size
argument_list|()
decl_stmt|;
name|ArrayList
argument_list|<
name|ExprNodeDesc
argument_list|>
name|expressions
init|=
operator|new
name|ArrayList
argument_list|<
name|ExprNodeDesc
argument_list|>
argument_list|(
name|columnNumber
argument_list|)
decl_stmt|;
comment|// MetadataTypedColumnsetSerDe does not need type conversions because it
comment|// does the conversion to String by itself.
name|boolean
name|isMetaDataSerDe
init|=
name|table_desc
operator|.
name|getDeserializerClass
argument_list|()
operator|.
name|equals
argument_list|(
name|MetadataTypedColumnsetSerDe
operator|.
name|class
argument_list|)
decl_stmt|;
name|boolean
name|isLazySimpleSerDe
init|=
name|table_desc
operator|.
name|getDeserializerClass
argument_list|()
operator|.
name|equals
argument_list|(
name|LazySimpleSerDe
operator|.
name|class
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|isMetaDataSerDe
condition|)
block|{
comment|// here only deals with non-partition columns. We deal with partition columns next
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|columnNumber
condition|;
name|i
operator|++
control|)
block|{
name|ObjectInspector
name|tableFieldOI
init|=
name|tableFields
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|getFieldObjectInspector
argument_list|()
decl_stmt|;
name|TypeInfo
name|tableFieldTypeInfo
init|=
name|TypeInfoUtils
operator|.
name|getTypeInfoFromObjectInspector
argument_list|(
name|tableFieldOI
argument_list|)
decl_stmt|;
name|TypeInfo
name|rowFieldTypeInfo
init|=
name|rowFields
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|getType
argument_list|()
decl_stmt|;
name|ExprNodeDesc
name|column
init|=
operator|new
name|ExprNodeColumnDesc
argument_list|(
name|rowFieldTypeInfo
argument_list|,
name|rowFields
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|getInternalName
argument_list|()
argument_list|,
literal|""
argument_list|,
literal|false
argument_list|)
decl_stmt|;
comment|// LazySimpleSerDe can convert any types to String type using
comment|// JSON-format.
if|if
condition|(
operator|!
name|tableFieldTypeInfo
operator|.
name|equals
argument_list|(
name|rowFieldTypeInfo
argument_list|)
operator|&&
operator|!
operator|(
name|isLazySimpleSerDe
operator|&&
name|tableFieldTypeInfo
operator|.
name|getCategory
argument_list|()
operator|.
name|equals
argument_list|(
name|Category
operator|.
name|PRIMITIVE
argument_list|)
operator|&&
name|tableFieldTypeInfo
operator|.
name|equals
argument_list|(
name|TypeInfoFactory
operator|.
name|stringTypeInfo
argument_list|)
operator|)
condition|)
block|{
comment|// need to do some conversions here
name|converted
operator|=
literal|true
expr_stmt|;
if|if
condition|(
name|tableFieldTypeInfo
operator|.
name|getCategory
argument_list|()
operator|!=
name|Category
operator|.
name|PRIMITIVE
condition|)
block|{
comment|// cannot convert to complex types
name|column
operator|=
literal|null
expr_stmt|;
block|}
else|else
block|{
name|column
operator|=
name|TypeCheckProcFactory
operator|.
name|DefaultExprProcessor
operator|.
name|getFuncExprNodeDesc
argument_list|(
name|tableFieldTypeInfo
operator|.
name|getTypeName
argument_list|()
argument_list|,
name|column
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|column
operator|==
literal|null
condition|)
block|{
name|String
name|reason
init|=
literal|"Cannot convert column "
operator|+
name|i
operator|+
literal|" from "
operator|+
name|rowFieldTypeInfo
operator|+
literal|" to "
operator|+
name|tableFieldTypeInfo
operator|+
literal|"."
decl_stmt|;
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|TARGET_TABLE_COLUMN_MISMATCH
operator|.
name|getMsg
argument_list|(
name|qb
operator|.
name|getParseInfo
argument_list|()
operator|.
name|getDestForClause
argument_list|(
name|dest
argument_list|)
argument_list|,
name|reason
argument_list|)
argument_list|)
throw|;
block|}
block|}
name|expressions
operator|.
name|add
argument_list|(
name|column
argument_list|)
expr_stmt|;
block|}
block|}
comment|// deal with dynamic partition columns: convert ExprNodeDesc type to String??
if|if
condition|(
name|dynPart
operator|&&
name|dpCtx
operator|!=
literal|null
operator|&&
name|dpCtx
operator|.
name|getNumDPCols
argument_list|()
operator|>
literal|0
condition|)
block|{
comment|// DP columns starts with tableFields.size()
for|for
control|(
name|int
name|i
init|=
name|tableFields
operator|.
name|size
argument_list|()
init|;
name|i
operator|<
name|rowFields
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|TypeInfo
name|rowFieldTypeInfo
init|=
name|rowFields
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|getType
argument_list|()
decl_stmt|;
name|ExprNodeDesc
name|column
init|=
operator|new
name|ExprNodeColumnDesc
argument_list|(
name|rowFieldTypeInfo
argument_list|,
name|rowFields
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|getInternalName
argument_list|()
argument_list|,
literal|""
argument_list|,
literal|false
argument_list|)
decl_stmt|;
name|expressions
operator|.
name|add
argument_list|(
name|column
argument_list|)
expr_stmt|;
block|}
comment|// converted = true; // [TODO]: should we check& convert type to String and set it to true?
block|}
if|if
condition|(
name|converted
condition|)
block|{
comment|// add the select operator
name|RowResolver
name|rowResolver
init|=
operator|new
name|RowResolver
argument_list|()
decl_stmt|;
name|ArrayList
argument_list|<
name|String
argument_list|>
name|colName
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|expressions
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|String
name|name
init|=
name|getColumnInternalName
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|rowResolver
operator|.
name|put
argument_list|(
literal|""
argument_list|,
name|name
argument_list|,
operator|new
name|ColumnInfo
argument_list|(
name|name
argument_list|,
name|expressions
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|getTypeInfo
argument_list|()
argument_list|,
literal|""
argument_list|,
literal|false
argument_list|)
argument_list|)
expr_stmt|;
name|colName
operator|.
name|add
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
name|Operator
name|output
init|=
name|putOpInsertMap
argument_list|(
name|OperatorFactory
operator|.
name|getAndMakeChild
argument_list|(
operator|new
name|SelectDesc
argument_list|(
name|expressions
argument_list|,
name|colName
argument_list|)
argument_list|,
operator|new
name|RowSchema
argument_list|(
name|rowResolver
operator|.
name|getColumnInfos
argument_list|()
argument_list|)
argument_list|,
name|input
argument_list|)
argument_list|,
name|rowResolver
argument_list|)
decl_stmt|;
return|return
name|output
return|;
block|}
else|else
block|{
comment|// not converted
return|return
name|input
return|;
block|}
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"nls"
argument_list|)
specifier|private
name|Operator
name|genLimitPlan
parameter_list|(
name|String
name|dest
parameter_list|,
name|QB
name|qb
parameter_list|,
name|Operator
name|input
parameter_list|,
name|int
name|limit
parameter_list|)
throws|throws
name|SemanticException
block|{
comment|// A map-only job can be optimized - instead of converting it to a
comment|// map-reduce job, we can have another map
comment|// job to do the same to avoid the cost of sorting in the map-reduce phase.
comment|// A better approach would be to
comment|// write into a local file and then have a map-only job.
comment|// Add the limit operator to get the value fields
name|RowResolver
name|inputRR
init|=
name|opParseCtx
operator|.
name|get
argument_list|(
name|input
argument_list|)
operator|.
name|getRowResolver
argument_list|()
decl_stmt|;
name|LimitDesc
name|limitDesc
init|=
operator|new
name|LimitDesc
argument_list|(
name|limit
argument_list|)
decl_stmt|;
name|globalLimitCtx
operator|.
name|setLastReduceLimitDesc
argument_list|(
name|limitDesc
argument_list|)
expr_stmt|;
name|Operator
name|limitMap
init|=
name|putOpInsertMap
argument_list|(
name|OperatorFactory
operator|.
name|getAndMakeChild
argument_list|(
name|limitDesc
argument_list|,
operator|new
name|RowSchema
argument_list|(
name|inputRR
operator|.
name|getColumnInfos
argument_list|()
argument_list|)
argument_list|,
name|input
argument_list|)
argument_list|,
name|inputRR
argument_list|)
decl_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Created LimitOperator Plan for clause: "
operator|+
name|dest
operator|+
literal|" row schema: "
operator|+
name|inputRR
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|limitMap
return|;
block|}
specifier|private
name|Operator
name|genUDTFPlan
parameter_list|(
name|GenericUDTF
name|genericUDTF
parameter_list|,
name|String
name|outputTableAlias
parameter_list|,
name|ArrayList
argument_list|<
name|String
argument_list|>
name|colAliases
parameter_list|,
name|QB
name|qb
parameter_list|,
name|Operator
name|input
parameter_list|)
throws|throws
name|SemanticException
block|{
comment|// No GROUP BY / DISTRIBUTE BY / SORT BY / CLUSTER BY
name|QBParseInfo
name|qbp
init|=
name|qb
operator|.
name|getParseInfo
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|qbp
operator|.
name|getDestToGroupBy
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|UDTF_NO_GROUP_BY
operator|.
name|getMsg
argument_list|()
argument_list|)
throw|;
block|}
if|if
condition|(
operator|!
name|qbp
operator|.
name|getDestToDistributeBy
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|UDTF_NO_DISTRIBUTE_BY
operator|.
name|getMsg
argument_list|()
argument_list|)
throw|;
block|}
if|if
condition|(
operator|!
name|qbp
operator|.
name|getDestToSortBy
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|UDTF_NO_SORT_BY
operator|.
name|getMsg
argument_list|()
argument_list|)
throw|;
block|}
if|if
condition|(
operator|!
name|qbp
operator|.
name|getDestToClusterBy
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|UDTF_NO_CLUSTER_BY
operator|.
name|getMsg
argument_list|()
argument_list|)
throw|;
block|}
if|if
condition|(
operator|!
name|qbp
operator|.
name|getAliasToLateralViews
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|UDTF_LATERAL_VIEW
operator|.
name|getMsg
argument_list|()
argument_list|)
throw|;
block|}
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Table alias: "
operator|+
name|outputTableAlias
operator|+
literal|" Col aliases: "
operator|+
name|colAliases
argument_list|)
expr_stmt|;
block|}
comment|// Use the RowResolver from the input operator to generate a input
comment|// ObjectInspector that can be used to initialize the UDTF. Then, the
comment|// resulting output object inspector can be used to make the RowResolver
comment|// for the UDTF operator
name|RowResolver
name|selectRR
init|=
name|opParseCtx
operator|.
name|get
argument_list|(
name|input
argument_list|)
operator|.
name|getRowResolver
argument_list|()
decl_stmt|;
name|ArrayList
argument_list|<
name|ColumnInfo
argument_list|>
name|inputCols
init|=
name|selectRR
operator|.
name|getColumnInfos
argument_list|()
decl_stmt|;
comment|// Create the object inspector for the input columns and initialize the UDTF
name|ArrayList
argument_list|<
name|String
argument_list|>
name|colNames
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
name|ObjectInspector
index|[]
name|colOIs
init|=
operator|new
name|ObjectInspector
index|[
name|inputCols
operator|.
name|size
argument_list|()
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|inputCols
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|colNames
operator|.
name|add
argument_list|(
name|inputCols
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|getInternalName
argument_list|()
argument_list|)
expr_stmt|;
name|colOIs
index|[
name|i
index|]
operator|=
name|TypeInfoUtils
operator|.
name|getStandardWritableObjectInspectorFromTypeInfo
argument_list|(
name|inputCols
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|getType
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|StructObjectInspector
name|outputOI
init|=
name|genericUDTF
operator|.
name|initialize
argument_list|(
name|colOIs
argument_list|)
decl_stmt|;
comment|// Make sure that the number of column aliases in the AS clause matches
comment|// the number of columns output by the UDTF
name|int
name|numUdtfCols
init|=
name|outputOI
operator|.
name|getAllStructFieldRefs
argument_list|()
operator|.
name|size
argument_list|()
decl_stmt|;
name|int
name|numSuppliedAliases
init|=
name|colAliases
operator|.
name|size
argument_list|()
decl_stmt|;
if|if
condition|(
name|numUdtfCols
operator|!=
name|numSuppliedAliases
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|UDTF_ALIAS_MISMATCH
operator|.
name|getMsg
argument_list|(
literal|"expected "
operator|+
name|numUdtfCols
operator|+
literal|" aliases "
operator|+
literal|"but got "
operator|+
name|numSuppliedAliases
argument_list|)
argument_list|)
throw|;
block|}
comment|// Generate the output column info's / row resolver using internal names.
name|ArrayList
argument_list|<
name|ColumnInfo
argument_list|>
name|udtfCols
init|=
operator|new
name|ArrayList
argument_list|<
name|ColumnInfo
argument_list|>
argument_list|()
decl_stmt|;
name|Iterator
argument_list|<
name|String
argument_list|>
name|colAliasesIter
init|=
name|colAliases
operator|.
name|iterator
argument_list|()
decl_stmt|;
for|for
control|(
name|StructField
name|sf
range|:
name|outputOI
operator|.
name|getAllStructFieldRefs
argument_list|()
control|)
block|{
name|String
name|colAlias
init|=
name|colAliasesIter
operator|.
name|next
argument_list|()
decl_stmt|;
assert|assert
operator|(
name|colAlias
operator|!=
literal|null
operator|)
assert|;
comment|// Since the UDTF operator feeds into a LVJ operator that will rename
comment|// all the internal names, we can just use field name from the UDTF's OI
comment|// as the internal name
name|ColumnInfo
name|col
init|=
operator|new
name|ColumnInfo
argument_list|(
name|sf
operator|.
name|getFieldName
argument_list|()
argument_list|,
name|TypeInfoUtils
operator|.
name|getTypeInfoFromObjectInspector
argument_list|(
name|sf
operator|.
name|getFieldObjectInspector
argument_list|()
argument_list|)
argument_list|,
name|outputTableAlias
argument_list|,
literal|false
argument_list|)
decl_stmt|;
name|udtfCols
operator|.
name|add
argument_list|(
name|col
argument_list|)
expr_stmt|;
block|}
comment|// Create the row resolver for this operator from the output columns
name|RowResolver
name|out_rwsch
init|=
operator|new
name|RowResolver
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|udtfCols
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|out_rwsch
operator|.
name|put
argument_list|(
name|outputTableAlias
argument_list|,
name|colAliases
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|,
name|udtfCols
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// Add the UDTFOperator to the operator DAG
name|Operator
argument_list|<
name|?
argument_list|>
name|udtf
init|=
name|putOpInsertMap
argument_list|(
name|OperatorFactory
operator|.
name|getAndMakeChild
argument_list|(
operator|new
name|UDTFDesc
argument_list|(
name|genericUDTF
argument_list|)
argument_list|,
operator|new
name|RowSchema
argument_list|(
name|out_rwsch
operator|.
name|getColumnInfos
argument_list|()
argument_list|)
argument_list|,
name|input
argument_list|)
argument_list|,
name|out_rwsch
argument_list|)
decl_stmt|;
return|return
name|udtf
return|;
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"nls"
argument_list|)
specifier|private
name|Operator
name|genLimitMapRedPlan
parameter_list|(
name|String
name|dest
parameter_list|,
name|QB
name|qb
parameter_list|,
name|Operator
name|input
parameter_list|,
name|int
name|limit
parameter_list|,
name|boolean
name|extraMRStep
parameter_list|)
throws|throws
name|SemanticException
block|{
comment|// A map-only job can be optimized - instead of converting it to a
comment|// map-reduce job, we can have another map
comment|// job to do the same to avoid the cost of sorting in the map-reduce phase.
comment|// A better approach would be to
comment|// write into a local file and then have a map-only job.
comment|// Add the limit operator to get the value fields
name|Operator
name|curr
init|=
name|genLimitPlan
argument_list|(
name|dest
argument_list|,
name|qb
argument_list|,
name|input
argument_list|,
name|limit
argument_list|)
decl_stmt|;
comment|// the client requested that an extra map-reduce step be performed
if|if
condition|(
operator|!
name|extraMRStep
condition|)
block|{
return|return
name|curr
return|;
block|}
comment|// Create a reduceSink operator followed by another limit
name|curr
operator|=
name|genReduceSinkPlan
argument_list|(
name|dest
argument_list|,
name|qb
argument_list|,
name|curr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
name|genLimitPlan
argument_list|(
name|dest
argument_list|,
name|qb
argument_list|,
name|curr
argument_list|,
name|limit
argument_list|)
return|;
block|}
specifier|private
name|ArrayList
argument_list|<
name|ExprNodeDesc
argument_list|>
name|getParitionColsFromBucketCols
parameter_list|(
name|String
name|dest
parameter_list|,
name|QB
name|qb
parameter_list|,
name|Table
name|tab
parameter_list|,
name|TableDesc
name|table_desc
parameter_list|,
name|Operator
name|input
parameter_list|,
name|boolean
name|convert
parameter_list|)
throws|throws
name|SemanticException
block|{
name|List
argument_list|<
name|String
argument_list|>
name|tabBucketCols
init|=
name|tab
operator|.
name|getBucketCols
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|FieldSchema
argument_list|>
name|tabCols
init|=
name|tab
operator|.
name|getCols
argument_list|()
decl_stmt|;
comment|// Partition by the bucketing column
name|List
argument_list|<
name|Integer
argument_list|>
name|posns
init|=
operator|new
name|ArrayList
argument_list|<
name|Integer
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|String
name|bucketCol
range|:
name|tabBucketCols
control|)
block|{
name|int
name|pos
init|=
literal|0
decl_stmt|;
for|for
control|(
name|FieldSchema
name|tabCol
range|:
name|tabCols
control|)
block|{
if|if
condition|(
name|bucketCol
operator|.
name|equals
argument_list|(
name|tabCol
operator|.
name|getName
argument_list|()
argument_list|)
condition|)
block|{
name|posns
operator|.
name|add
argument_list|(
name|pos
argument_list|)
expr_stmt|;
break|break;
block|}
name|pos
operator|++
expr_stmt|;
block|}
block|}
return|return
name|genConvertCol
argument_list|(
name|dest
argument_list|,
name|qb
argument_list|,
name|tab
argument_list|,
name|table_desc
argument_list|,
name|input
argument_list|,
name|posns
argument_list|,
name|convert
argument_list|)
return|;
block|}
specifier|private
name|ArrayList
argument_list|<
name|ExprNodeDesc
argument_list|>
name|genConvertCol
parameter_list|(
name|String
name|dest
parameter_list|,
name|QB
name|qb
parameter_list|,
name|Table
name|tab
parameter_list|,
name|TableDesc
name|table_desc
parameter_list|,
name|Operator
name|input
parameter_list|,
name|List
argument_list|<
name|Integer
argument_list|>
name|posns
parameter_list|,
name|boolean
name|convert
parameter_list|)
throws|throws
name|SemanticException
block|{
name|StructObjectInspector
name|oi
init|=
literal|null
decl_stmt|;
try|try
block|{
name|Deserializer
name|deserializer
init|=
name|table_desc
operator|.
name|getDeserializerClass
argument_list|()
operator|.
name|newInstance
argument_list|()
decl_stmt|;
name|deserializer
operator|.
name|initialize
argument_list|(
name|conf
argument_list|,
name|table_desc
operator|.
name|getProperties
argument_list|()
argument_list|)
expr_stmt|;
name|oi
operator|=
operator|(
name|StructObjectInspector
operator|)
name|deserializer
operator|.
name|getObjectInspector
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|e
argument_list|)
throw|;
block|}
name|List
argument_list|<
name|?
extends|extends
name|StructField
argument_list|>
name|tableFields
init|=
name|oi
operator|.
name|getAllStructFieldRefs
argument_list|()
decl_stmt|;
name|ArrayList
argument_list|<
name|ColumnInfo
argument_list|>
name|rowFields
init|=
name|opParseCtx
operator|.
name|get
argument_list|(
name|input
argument_list|)
operator|.
name|getRowResolver
argument_list|()
operator|.
name|getColumnInfos
argument_list|()
decl_stmt|;
comment|// Check column type
name|int
name|columnNumber
init|=
name|posns
operator|.
name|size
argument_list|()
decl_stmt|;
name|ArrayList
argument_list|<
name|ExprNodeDesc
argument_list|>
name|expressions
init|=
operator|new
name|ArrayList
argument_list|<
name|ExprNodeDesc
argument_list|>
argument_list|(
name|columnNumber
argument_list|)
decl_stmt|;
for|for
control|(
name|Integer
name|posn
range|:
name|posns
control|)
block|{
name|ObjectInspector
name|tableFieldOI
init|=
name|tableFields
operator|.
name|get
argument_list|(
name|posn
argument_list|)
operator|.
name|getFieldObjectInspector
argument_list|()
decl_stmt|;
name|TypeInfo
name|tableFieldTypeInfo
init|=
name|TypeInfoUtils
operator|.
name|getTypeInfoFromObjectInspector
argument_list|(
name|tableFieldOI
argument_list|)
decl_stmt|;
name|TypeInfo
name|rowFieldTypeInfo
init|=
name|rowFields
operator|.
name|get
argument_list|(
name|posn
argument_list|)
operator|.
name|getType
argument_list|()
decl_stmt|;
name|ExprNodeDesc
name|column
init|=
operator|new
name|ExprNodeColumnDesc
argument_list|(
name|rowFieldTypeInfo
argument_list|,
name|rowFields
operator|.
name|get
argument_list|(
name|posn
argument_list|)
operator|.
name|getInternalName
argument_list|()
argument_list|,
name|rowFields
operator|.
name|get
argument_list|(
name|posn
argument_list|)
operator|.
name|getTabAlias
argument_list|()
argument_list|,
name|rowFields
operator|.
name|get
argument_list|(
name|posn
argument_list|)
operator|.
name|getIsVirtualCol
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|convert
operator|&&
operator|!
name|tableFieldTypeInfo
operator|.
name|equals
argument_list|(
name|rowFieldTypeInfo
argument_list|)
condition|)
block|{
comment|// need to do some conversions here
if|if
condition|(
name|tableFieldTypeInfo
operator|.
name|getCategory
argument_list|()
operator|!=
name|Category
operator|.
name|PRIMITIVE
condition|)
block|{
comment|// cannot convert to complex types
name|column
operator|=
literal|null
expr_stmt|;
block|}
else|else
block|{
name|column
operator|=
name|TypeCheckProcFactory
operator|.
name|DefaultExprProcessor
operator|.
name|getFuncExprNodeDesc
argument_list|(
name|tableFieldTypeInfo
operator|.
name|getTypeName
argument_list|()
argument_list|,
name|column
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|column
operator|==
literal|null
condition|)
block|{
name|String
name|reason
init|=
literal|"Cannot convert column "
operator|+
name|posn
operator|+
literal|" from "
operator|+
name|rowFieldTypeInfo
operator|+
literal|" to "
operator|+
name|tableFieldTypeInfo
operator|+
literal|"."
decl_stmt|;
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|TARGET_TABLE_COLUMN_MISMATCH
operator|.
name|getMsg
argument_list|(
name|qb
operator|.
name|getParseInfo
argument_list|()
operator|.
name|getDestForClause
argument_list|(
name|dest
argument_list|)
argument_list|,
name|reason
argument_list|)
argument_list|)
throw|;
block|}
block|}
name|expressions
operator|.
name|add
argument_list|(
name|column
argument_list|)
expr_stmt|;
block|}
return|return
name|expressions
return|;
block|}
specifier|private
name|ArrayList
argument_list|<
name|ExprNodeDesc
argument_list|>
name|getSortCols
parameter_list|(
name|String
name|dest
parameter_list|,
name|QB
name|qb
parameter_list|,
name|Table
name|tab
parameter_list|,
name|TableDesc
name|table_desc
parameter_list|,
name|Operator
name|input
parameter_list|,
name|boolean
name|convert
parameter_list|)
throws|throws
name|SemanticException
block|{
name|RowResolver
name|inputRR
init|=
name|opParseCtx
operator|.
name|get
argument_list|(
name|input
argument_list|)
operator|.
name|getRowResolver
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|Order
argument_list|>
name|tabSortCols
init|=
name|tab
operator|.
name|getSortCols
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|FieldSchema
argument_list|>
name|tabCols
init|=
name|tab
operator|.
name|getCols
argument_list|()
decl_stmt|;
comment|// Partition by the bucketing column
name|List
argument_list|<
name|Integer
argument_list|>
name|posns
init|=
operator|new
name|ArrayList
argument_list|<
name|Integer
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|Order
name|sortCol
range|:
name|tabSortCols
control|)
block|{
name|int
name|pos
init|=
literal|0
decl_stmt|;
for|for
control|(
name|FieldSchema
name|tabCol
range|:
name|tabCols
control|)
block|{
if|if
condition|(
name|sortCol
operator|.
name|getCol
argument_list|()
operator|.
name|equals
argument_list|(
name|tabCol
operator|.
name|getName
argument_list|()
argument_list|)
condition|)
block|{
name|ColumnInfo
name|colInfo
init|=
name|inputRR
operator|.
name|getColumnInfos
argument_list|()
operator|.
name|get
argument_list|(
name|pos
argument_list|)
decl_stmt|;
name|posns
operator|.
name|add
argument_list|(
name|pos
argument_list|)
expr_stmt|;
break|break;
block|}
name|pos
operator|++
expr_stmt|;
block|}
block|}
return|return
name|genConvertCol
argument_list|(
name|dest
argument_list|,
name|qb
argument_list|,
name|tab
argument_list|,
name|table_desc
argument_list|,
name|input
argument_list|,
name|posns
argument_list|,
name|convert
argument_list|)
return|;
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"nls"
argument_list|)
specifier|private
name|Operator
name|genReduceSinkPlanForSortingBucketing
parameter_list|(
name|Table
name|tab
parameter_list|,
name|Operator
name|input
parameter_list|,
name|ArrayList
argument_list|<
name|ExprNodeDesc
argument_list|>
name|sortCols
parameter_list|,
name|ArrayList
argument_list|<
name|ExprNodeDesc
argument_list|>
name|partitionCols
parameter_list|,
name|int
name|numReducers
parameter_list|)
throws|throws
name|SemanticException
block|{
name|RowResolver
name|inputRR
init|=
name|opParseCtx
operator|.
name|get
argument_list|(
name|input
argument_list|)
operator|.
name|getRowResolver
argument_list|()
decl_stmt|;
comment|// For the generation of the values expression just get the inputs
comment|// signature and generate field expressions for those
name|Map
argument_list|<
name|String
argument_list|,
name|ExprNodeDesc
argument_list|>
name|colExprMap
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|ExprNodeDesc
argument_list|>
argument_list|()
decl_stmt|;
name|ArrayList
argument_list|<
name|ExprNodeDesc
argument_list|>
name|valueCols
init|=
operator|new
name|ArrayList
argument_list|<
name|ExprNodeDesc
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|ColumnInfo
name|colInfo
range|:
name|inputRR
operator|.
name|getColumnInfos
argument_list|()
control|)
block|{
name|valueCols
operator|.
name|add
argument_list|(
operator|new
name|ExprNodeColumnDesc
argument_list|(
name|colInfo
operator|.
name|getType
argument_list|()
argument_list|,
name|colInfo
operator|.
name|getInternalName
argument_list|()
argument_list|,
name|colInfo
operator|.
name|getTabAlias
argument_list|()
argument_list|,
name|colInfo
operator|.
name|getIsVirtualCol
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|colExprMap
operator|.
name|put
argument_list|(
name|colInfo
operator|.
name|getInternalName
argument_list|()
argument_list|,
name|valueCols
operator|.
name|get
argument_list|(
name|valueCols
operator|.
name|size
argument_list|()
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|ArrayList
argument_list|<
name|String
argument_list|>
name|outputColumns
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|valueCols
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|outputColumns
operator|.
name|add
argument_list|(
name|getColumnInternalName
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|StringBuilder
name|order
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|sortCols
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|order
operator|.
name|append
argument_list|(
literal|"+"
argument_list|)
expr_stmt|;
block|}
name|Operator
name|interim
init|=
name|putOpInsertMap
argument_list|(
name|OperatorFactory
operator|.
name|getAndMakeChild
argument_list|(
name|PlanUtils
operator|.
name|getReduceSinkDesc
argument_list|(
name|sortCols
argument_list|,
name|valueCols
argument_list|,
name|outputColumns
argument_list|,
literal|false
argument_list|,
operator|-
literal|1
argument_list|,
name|partitionCols
argument_list|,
name|order
operator|.
name|toString
argument_list|()
argument_list|,
name|numReducers
argument_list|)
argument_list|,
operator|new
name|RowSchema
argument_list|(
name|inputRR
operator|.
name|getColumnInfos
argument_list|()
argument_list|)
argument_list|,
name|input
argument_list|)
argument_list|,
name|inputRR
argument_list|)
decl_stmt|;
name|interim
operator|.
name|setColumnExprMap
argument_list|(
name|colExprMap
argument_list|)
expr_stmt|;
comment|// Add the extract operator to get the value fields
name|RowResolver
name|out_rwsch
init|=
operator|new
name|RowResolver
argument_list|()
decl_stmt|;
name|RowResolver
name|interim_rwsch
init|=
name|inputRR
decl_stmt|;
name|Integer
name|pos
init|=
name|Integer
operator|.
name|valueOf
argument_list|(
literal|0
argument_list|)
decl_stmt|;
for|for
control|(
name|ColumnInfo
name|colInfo
range|:
name|interim_rwsch
operator|.
name|getColumnInfos
argument_list|()
control|)
block|{
name|String
index|[]
name|info
init|=
name|interim_rwsch
operator|.
name|reverseLookup
argument_list|(
name|colInfo
operator|.
name|getInternalName
argument_list|()
argument_list|)
decl_stmt|;
name|out_rwsch
operator|.
name|put
argument_list|(
name|info
index|[
literal|0
index|]
argument_list|,
name|info
index|[
literal|1
index|]
argument_list|,
operator|new
name|ColumnInfo
argument_list|(
name|getColumnInternalName
argument_list|(
name|pos
argument_list|)
argument_list|,
name|colInfo
operator|.
name|getType
argument_list|()
argument_list|,
name|info
index|[
literal|0
index|]
argument_list|,
name|colInfo
operator|.
name|getIsVirtualCol
argument_list|()
argument_list|,
name|colInfo
operator|.
name|isHiddenVirtualCol
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|pos
operator|=
name|Integer
operator|.
name|valueOf
argument_list|(
name|pos
operator|.
name|intValue
argument_list|()
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
name|Operator
name|output
init|=
name|putOpInsertMap
argument_list|(
name|OperatorFactory
operator|.
name|getAndMakeChild
argument_list|(
operator|new
name|ExtractDesc
argument_list|(
operator|new
name|ExprNodeColumnDesc
argument_list|(
name|TypeInfoFactory
operator|.
name|stringTypeInfo
argument_list|,
name|Utilities
operator|.
name|ReduceField
operator|.
name|VALUE
operator|.
name|toString
argument_list|()
argument_list|,
literal|""
argument_list|,
literal|false
argument_list|)
argument_list|)
argument_list|,
operator|new
name|RowSchema
argument_list|(
name|out_rwsch
operator|.
name|getColumnInfos
argument_list|()
argument_list|)
argument_list|,
name|interim
argument_list|)
argument_list|,
name|out_rwsch
argument_list|)
decl_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Created ReduceSink Plan for table: "
operator|+
name|tab
operator|.
name|getTableName
argument_list|()
operator|+
literal|" row schema: "
operator|+
name|out_rwsch
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|output
return|;
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"nls"
argument_list|)
specifier|private
name|Operator
name|genReduceSinkPlan
parameter_list|(
name|String
name|dest
parameter_list|,
name|QB
name|qb
parameter_list|,
name|Operator
name|input
parameter_list|,
name|int
name|numReducers
parameter_list|)
throws|throws
name|SemanticException
block|{
name|RowResolver
name|inputRR
init|=
name|opParseCtx
operator|.
name|get
argument_list|(
name|input
argument_list|)
operator|.
name|getRowResolver
argument_list|()
decl_stmt|;
comment|// First generate the expression for the partition and sort keys
comment|// The cluster by clause / distribute by clause has the aliases for
comment|// partition function
name|ASTNode
name|partitionExprs
init|=
name|qb
operator|.
name|getParseInfo
argument_list|()
operator|.
name|getClusterByForClause
argument_list|(
name|dest
argument_list|)
decl_stmt|;
if|if
condition|(
name|partitionExprs
operator|==
literal|null
condition|)
block|{
name|partitionExprs
operator|=
name|qb
operator|.
name|getParseInfo
argument_list|()
operator|.
name|getDistributeByForClause
argument_list|(
name|dest
argument_list|)
expr_stmt|;
block|}
name|ArrayList
argument_list|<
name|ExprNodeDesc
argument_list|>
name|partitionCols
init|=
operator|new
name|ArrayList
argument_list|<
name|ExprNodeDesc
argument_list|>
argument_list|()
decl_stmt|;
if|if
condition|(
name|partitionExprs
operator|!=
literal|null
condition|)
block|{
name|int
name|ccount
init|=
name|partitionExprs
operator|.
name|getChildCount
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|ccount
condition|;
operator|++
name|i
control|)
block|{
name|ASTNode
name|cl
init|=
operator|(
name|ASTNode
operator|)
name|partitionExprs
operator|.
name|getChild
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|partitionCols
operator|.
name|add
argument_list|(
name|genExprNodeDesc
argument_list|(
name|cl
argument_list|,
name|inputRR
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|ASTNode
name|sortExprs
init|=
name|qb
operator|.
name|getParseInfo
argument_list|()
operator|.
name|getClusterByForClause
argument_list|(
name|dest
argument_list|)
decl_stmt|;
if|if
condition|(
name|sortExprs
operator|==
literal|null
condition|)
block|{
name|sortExprs
operator|=
name|qb
operator|.
name|getParseInfo
argument_list|()
operator|.
name|getSortByForClause
argument_list|(
name|dest
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sortExprs
operator|==
literal|null
condition|)
block|{
name|sortExprs
operator|=
name|qb
operator|.
name|getParseInfo
argument_list|()
operator|.
name|getOrderByForClause
argument_list|(
name|dest
argument_list|)
expr_stmt|;
if|if
condition|(
name|sortExprs
operator|!=
literal|null
condition|)
block|{
assert|assert
name|numReducers
operator|==
literal|1
assert|;
comment|// in strict mode, in the presence of order by, limit must be specified
name|Integer
name|limit
init|=
name|qb
operator|.
name|getParseInfo
argument_list|()
operator|.
name|getDestLimit
argument_list|(
name|dest
argument_list|)
decl_stmt|;
if|if
condition|(
name|conf
operator|.
name|getVar
argument_list|(
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVEMAPREDMODE
argument_list|)
operator|.
name|equalsIgnoreCase
argument_list|(
literal|"strict"
argument_list|)
operator|&&
name|limit
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|generateErrorMessage
argument_list|(
name|sortExprs
argument_list|,
name|ErrorMsg
operator|.
name|NO_LIMIT_WITH_ORDERBY
operator|.
name|getMsg
argument_list|()
argument_list|)
argument_list|)
throw|;
block|}
block|}
block|}
name|ArrayList
argument_list|<
name|ExprNodeDesc
argument_list|>
name|sortCols
init|=
operator|new
name|ArrayList
argument_list|<
name|ExprNodeDesc
argument_list|>
argument_list|()
decl_stmt|;
name|StringBuilder
name|order
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
if|if
condition|(
name|sortExprs
operator|!=
literal|null
condition|)
block|{
name|int
name|ccount
init|=
name|sortExprs
operator|.
name|getChildCount
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|ccount
condition|;
operator|++
name|i
control|)
block|{
name|ASTNode
name|cl
init|=
operator|(
name|ASTNode
operator|)
name|sortExprs
operator|.
name|getChild
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|cl
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_TABSORTCOLNAMEASC
condition|)
block|{
comment|// SortBy ASC
name|order
operator|.
name|append
argument_list|(
literal|"+"
argument_list|)
expr_stmt|;
name|cl
operator|=
operator|(
name|ASTNode
operator|)
name|cl
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cl
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_TABSORTCOLNAMEDESC
condition|)
block|{
comment|// SortBy DESC
name|order
operator|.
name|append
argument_list|(
literal|"-"
argument_list|)
expr_stmt|;
name|cl
operator|=
operator|(
name|ASTNode
operator|)
name|cl
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// ClusterBy
name|order
operator|.
name|append
argument_list|(
literal|"+"
argument_list|)
expr_stmt|;
block|}
name|ExprNodeDesc
name|exprNode
init|=
name|genExprNodeDesc
argument_list|(
name|cl
argument_list|,
name|inputRR
argument_list|)
decl_stmt|;
name|sortCols
operator|.
name|add
argument_list|(
name|exprNode
argument_list|)
expr_stmt|;
block|}
block|}
comment|// For the generation of the values expression just get the inputs
comment|// signature and generate field expressions for those
name|Map
argument_list|<
name|String
argument_list|,
name|ExprNodeDesc
argument_list|>
name|colExprMap
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|ExprNodeDesc
argument_list|>
argument_list|()
decl_stmt|;
name|ArrayList
argument_list|<
name|ExprNodeDesc
argument_list|>
name|valueCols
init|=
operator|new
name|ArrayList
argument_list|<
name|ExprNodeDesc
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|ColumnInfo
name|colInfo
range|:
name|inputRR
operator|.
name|getColumnInfos
argument_list|()
control|)
block|{
name|valueCols
operator|.
name|add
argument_list|(
operator|new
name|ExprNodeColumnDesc
argument_list|(
name|colInfo
operator|.
name|getType
argument_list|()
argument_list|,
name|colInfo
operator|.
name|getInternalName
argument_list|()
argument_list|,
name|colInfo
operator|.
name|getTabAlias
argument_list|()
argument_list|,
name|colInfo
operator|.
name|getIsVirtualCol
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|colExprMap
operator|.
name|put
argument_list|(
name|colInfo
operator|.
name|getInternalName
argument_list|()
argument_list|,
name|valueCols
operator|.
name|get
argument_list|(
name|valueCols
operator|.
name|size
argument_list|()
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|ArrayList
argument_list|<
name|String
argument_list|>
name|outputColumns
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|valueCols
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|outputColumns
operator|.
name|add
argument_list|(
name|getColumnInternalName
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|Operator
name|interim
init|=
name|putOpInsertMap
argument_list|(
name|OperatorFactory
operator|.
name|getAndMakeChild
argument_list|(
name|PlanUtils
operator|.
name|getReduceSinkDesc
argument_list|(
name|sortCols
argument_list|,
name|valueCols
argument_list|,
name|outputColumns
argument_list|,
literal|false
argument_list|,
operator|-
literal|1
argument_list|,
name|partitionCols
argument_list|,
name|order
operator|.
name|toString
argument_list|()
argument_list|,
name|numReducers
argument_list|)
argument_list|,
operator|new
name|RowSchema
argument_list|(
name|inputRR
operator|.
name|getColumnInfos
argument_list|()
argument_list|)
argument_list|,
name|input
argument_list|)
argument_list|,
name|inputRR
argument_list|)
decl_stmt|;
name|interim
operator|.
name|setColumnExprMap
argument_list|(
name|colExprMap
argument_list|)
expr_stmt|;
comment|// Add the extract operator to get the value fields
name|RowResolver
name|out_rwsch
init|=
operator|new
name|RowResolver
argument_list|()
decl_stmt|;
name|RowResolver
name|interim_rwsch
init|=
name|inputRR
decl_stmt|;
name|Integer
name|pos
init|=
name|Integer
operator|.
name|valueOf
argument_list|(
literal|0
argument_list|)
decl_stmt|;
for|for
control|(
name|ColumnInfo
name|colInfo
range|:
name|interim_rwsch
operator|.
name|getColumnInfos
argument_list|()
control|)
block|{
name|String
index|[]
name|info
init|=
name|interim_rwsch
operator|.
name|reverseLookup
argument_list|(
name|colInfo
operator|.
name|getInternalName
argument_list|()
argument_list|)
decl_stmt|;
name|out_rwsch
operator|.
name|put
argument_list|(
name|info
index|[
literal|0
index|]
argument_list|,
name|info
index|[
literal|1
index|]
argument_list|,
operator|new
name|ColumnInfo
argument_list|(
name|getColumnInternalName
argument_list|(
name|pos
argument_list|)
argument_list|,
name|colInfo
operator|.
name|getType
argument_list|()
argument_list|,
name|info
index|[
literal|0
index|]
argument_list|,
name|colInfo
operator|.
name|getIsVirtualCol
argument_list|()
argument_list|,
name|colInfo
operator|.
name|isHiddenVirtualCol
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|pos
operator|=
name|Integer
operator|.
name|valueOf
argument_list|(
name|pos
operator|.
name|intValue
argument_list|()
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
name|Operator
name|output
init|=
name|putOpInsertMap
argument_list|(
name|OperatorFactory
operator|.
name|getAndMakeChild
argument_list|(
operator|new
name|ExtractDesc
argument_list|(
operator|new
name|ExprNodeColumnDesc
argument_list|(
name|TypeInfoFactory
operator|.
name|stringTypeInfo
argument_list|,
name|Utilities
operator|.
name|ReduceField
operator|.
name|VALUE
operator|.
name|toString
argument_list|()
argument_list|,
literal|""
argument_list|,
literal|false
argument_list|)
argument_list|)
argument_list|,
operator|new
name|RowSchema
argument_list|(
name|out_rwsch
operator|.
name|getColumnInfos
argument_list|()
argument_list|)
argument_list|,
name|interim
argument_list|)
argument_list|,
name|out_rwsch
argument_list|)
decl_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Created ReduceSink Plan for clause: "
operator|+
name|dest
operator|+
literal|" row schema: "
operator|+
name|out_rwsch
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|output
return|;
block|}
specifier|private
name|Operator
name|genJoinOperatorChildren
parameter_list|(
name|QBJoinTree
name|join
parameter_list|,
name|Operator
name|left
parameter_list|,
name|Operator
index|[]
name|right
parameter_list|,
name|HashSet
argument_list|<
name|Integer
argument_list|>
name|omitOpts
parameter_list|)
throws|throws
name|SemanticException
block|{
name|RowResolver
name|outputRS
init|=
operator|new
name|RowResolver
argument_list|()
decl_stmt|;
name|ArrayList
argument_list|<
name|String
argument_list|>
name|outputColumnNames
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
comment|// all children are base classes
name|Operator
argument_list|<
name|?
argument_list|>
index|[]
name|rightOps
init|=
operator|new
name|Operator
index|[
name|right
operator|.
name|length
index|]
decl_stmt|;
name|int
name|outputPos
init|=
literal|0
decl_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|Byte
argument_list|>
name|reversedExprs
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|Byte
argument_list|>
argument_list|()
decl_stmt|;
name|HashMap
argument_list|<
name|Byte
argument_list|,
name|List
argument_list|<
name|ExprNodeDesc
argument_list|>
argument_list|>
name|exprMap
init|=
operator|new
name|HashMap
argument_list|<
name|Byte
argument_list|,
name|List
argument_list|<
name|ExprNodeDesc
argument_list|>
argument_list|>
argument_list|()
decl_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|ExprNodeDesc
argument_list|>
name|colExprMap
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|ExprNodeDesc
argument_list|>
argument_list|()
decl_stmt|;
name|HashMap
argument_list|<
name|Integer
argument_list|,
name|Set
argument_list|<
name|String
argument_list|>
argument_list|>
name|posToAliasMap
init|=
operator|new
name|HashMap
argument_list|<
name|Integer
argument_list|,
name|Set
argument_list|<
name|String
argument_list|>
argument_list|>
argument_list|()
decl_stmt|;
name|HashMap
argument_list|<
name|Byte
argument_list|,
name|List
argument_list|<
name|ExprNodeDesc
argument_list|>
argument_list|>
name|filterMap
init|=
operator|new
name|HashMap
argument_list|<
name|Byte
argument_list|,
name|List
argument_list|<
name|ExprNodeDesc
argument_list|>
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|pos
init|=
literal|0
init|;
name|pos
operator|<
name|right
operator|.
name|length
condition|;
operator|++
name|pos
control|)
block|{
name|Operator
name|input
init|=
name|right
index|[
name|pos
index|]
decl_stmt|;
if|if
condition|(
name|input
operator|==
literal|null
condition|)
block|{
name|input
operator|=
name|left
expr_stmt|;
block|}
name|ArrayList
argument_list|<
name|ExprNodeDesc
argument_list|>
name|keyDesc
init|=
operator|new
name|ArrayList
argument_list|<
name|ExprNodeDesc
argument_list|>
argument_list|()
decl_stmt|;
name|ArrayList
argument_list|<
name|ExprNodeDesc
argument_list|>
name|filterDesc
init|=
operator|new
name|ArrayList
argument_list|<
name|ExprNodeDesc
argument_list|>
argument_list|()
decl_stmt|;
name|Byte
name|tag
init|=
name|Byte
operator|.
name|valueOf
argument_list|(
call|(
name|byte
call|)
argument_list|(
operator|(
call|(
name|ReduceSinkDesc
call|)
argument_list|(
name|input
operator|.
name|getConf
argument_list|()
argument_list|)
operator|)
operator|.
name|getTag
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
comment|// check whether this input operator produces output
if|if
condition|(
name|omitOpts
operator|==
literal|null
operator|||
operator|!
name|omitOpts
operator|.
name|contains
argument_list|(
name|pos
argument_list|)
condition|)
block|{
comment|// prepare output descriptors for the input opt
name|RowResolver
name|inputRS
init|=
name|opParseCtx
operator|.
name|get
argument_list|(
name|input
argument_list|)
operator|.
name|getRowResolver
argument_list|()
decl_stmt|;
name|Iterator
argument_list|<
name|String
argument_list|>
name|keysIter
init|=
name|inputRS
operator|.
name|getTableNames
argument_list|()
operator|.
name|iterator
argument_list|()
decl_stmt|;
name|Set
argument_list|<
name|String
argument_list|>
name|aliases
init|=
name|posToAliasMap
operator|.
name|get
argument_list|(
name|pos
argument_list|)
decl_stmt|;
if|if
condition|(
name|aliases
operator|==
literal|null
condition|)
block|{
name|aliases
operator|=
operator|new
name|HashSet
argument_list|<
name|String
argument_list|>
argument_list|()
expr_stmt|;
name|posToAliasMap
operator|.
name|put
argument_list|(
name|pos
argument_list|,
name|aliases
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|keysIter
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|String
name|key
init|=
name|keysIter
operator|.
name|next
argument_list|()
decl_stmt|;
name|aliases
operator|.
name|add
argument_list|(
name|key
argument_list|)
expr_stmt|;
name|HashMap
argument_list|<
name|String
argument_list|,
name|ColumnInfo
argument_list|>
name|map
init|=
name|inputRS
operator|.
name|getFieldMap
argument_list|(
name|key
argument_list|)
decl_stmt|;
name|Iterator
argument_list|<
name|String
argument_list|>
name|fNamesIter
init|=
name|map
operator|.
name|keySet
argument_list|()
operator|.
name|iterator
argument_list|()
decl_stmt|;
while|while
condition|(
name|fNamesIter
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|String
name|field
init|=
name|fNamesIter
operator|.
name|next
argument_list|()
decl_stmt|;
name|ColumnInfo
name|valueInfo
init|=
name|inputRS
operator|.
name|get
argument_list|(
name|key
argument_list|,
name|field
argument_list|)
decl_stmt|;
name|keyDesc
operator|.
name|add
argument_list|(
operator|new
name|ExprNodeColumnDesc
argument_list|(
name|valueInfo
operator|.
name|getType
argument_list|()
argument_list|,
name|valueInfo
operator|.
name|getInternalName
argument_list|()
argument_list|,
name|valueInfo
operator|.
name|getTabAlias
argument_list|()
argument_list|,
name|valueInfo
operator|.
name|getIsVirtualCol
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|outputRS
operator|.
name|get
argument_list|(
name|key
argument_list|,
name|field
argument_list|)
operator|==
literal|null
condition|)
block|{
name|String
name|colName
init|=
name|getColumnInternalName
argument_list|(
name|outputPos
argument_list|)
decl_stmt|;
name|outputPos
operator|++
expr_stmt|;
name|outputColumnNames
operator|.
name|add
argument_list|(
name|colName
argument_list|)
expr_stmt|;
name|colExprMap
operator|.
name|put
argument_list|(
name|colName
argument_list|,
name|keyDesc
operator|.
name|get
argument_list|(
name|keyDesc
operator|.
name|size
argument_list|()
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|outputRS
operator|.
name|put
argument_list|(
name|key
argument_list|,
name|field
argument_list|,
operator|new
name|ColumnInfo
argument_list|(
name|colName
argument_list|,
name|valueInfo
operator|.
name|getType
argument_list|()
argument_list|,
name|key
argument_list|,
name|valueInfo
operator|.
name|getIsVirtualCol
argument_list|()
argument_list|,
name|valueInfo
operator|.
name|isHiddenVirtualCol
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|reversedExprs
operator|.
name|put
argument_list|(
name|colName
argument_list|,
name|tag
argument_list|)
expr_stmt|;
block|}
block|}
block|}
for|for
control|(
name|ASTNode
name|cond
range|:
name|join
operator|.
name|getFilters
argument_list|()
operator|.
name|get
argument_list|(
name|tag
argument_list|)
control|)
block|{
name|filterDesc
operator|.
name|add
argument_list|(
name|genExprNodeDesc
argument_list|(
name|cond
argument_list|,
name|inputRS
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|exprMap
operator|.
name|put
argument_list|(
name|tag
argument_list|,
name|keyDesc
argument_list|)
expr_stmt|;
name|filterMap
operator|.
name|put
argument_list|(
name|tag
argument_list|,
name|filterDesc
argument_list|)
expr_stmt|;
name|rightOps
index|[
name|pos
index|]
operator|=
name|input
expr_stmt|;
block|}
name|JoinCondDesc
index|[]
name|joinCondns
init|=
operator|new
name|JoinCondDesc
index|[
name|join
operator|.
name|getJoinCond
argument_list|()
operator|.
name|length
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|join
operator|.
name|getJoinCond
argument_list|()
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|JoinCond
name|condn
init|=
name|join
operator|.
name|getJoinCond
argument_list|()
index|[
name|i
index|]
decl_stmt|;
name|joinCondns
index|[
name|i
index|]
operator|=
operator|new
name|JoinCondDesc
argument_list|(
name|condn
argument_list|)
expr_stmt|;
block|}
name|JoinDesc
name|desc
init|=
operator|new
name|JoinDesc
argument_list|(
name|exprMap
argument_list|,
name|outputColumnNames
argument_list|,
name|join
operator|.
name|getNoOuterJoin
argument_list|()
argument_list|,
name|joinCondns
argument_list|,
name|filterMap
argument_list|)
decl_stmt|;
name|desc
operator|.
name|setReversedExprs
argument_list|(
name|reversedExprs
argument_list|)
expr_stmt|;
name|JoinOperator
name|joinOp
init|=
operator|(
name|JoinOperator
operator|)
name|OperatorFactory
operator|.
name|getAndMakeChild
argument_list|(
name|desc
argument_list|,
operator|new
name|RowSchema
argument_list|(
name|outputRS
operator|.
name|getColumnInfos
argument_list|()
argument_list|)
argument_list|,
name|rightOps
argument_list|)
decl_stmt|;
name|joinOp
operator|.
name|setColumnExprMap
argument_list|(
name|colExprMap
argument_list|)
expr_stmt|;
name|joinOp
operator|.
name|setPosToAliasMap
argument_list|(
name|posToAliasMap
argument_list|)
expr_stmt|;
return|return
name|putOpInsertMap
argument_list|(
name|joinOp
argument_list|,
name|outputRS
argument_list|)
return|;
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"nls"
argument_list|)
specifier|private
name|Operator
name|genJoinReduceSinkChild
parameter_list|(
name|QB
name|qb
parameter_list|,
name|QBJoinTree
name|joinTree
parameter_list|,
name|Operator
name|child
parameter_list|,
name|String
name|srcName
parameter_list|,
name|int
name|pos
parameter_list|)
throws|throws
name|SemanticException
block|{
name|RowResolver
name|inputRS
init|=
name|opParseCtx
operator|.
name|get
argument_list|(
name|child
argument_list|)
operator|.
name|getRowResolver
argument_list|()
decl_stmt|;
name|RowResolver
name|outputRS
init|=
operator|new
name|RowResolver
argument_list|()
decl_stmt|;
name|ArrayList
argument_list|<
name|String
argument_list|>
name|outputColumns
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
name|ArrayList
argument_list|<
name|ExprNodeDesc
argument_list|>
name|reduceKeys
init|=
operator|new
name|ArrayList
argument_list|<
name|ExprNodeDesc
argument_list|>
argument_list|()
decl_stmt|;
comment|// Compute join keys and store in reduceKeys
name|ArrayList
argument_list|<
name|ASTNode
argument_list|>
name|exprs
init|=
name|joinTree
operator|.
name|getExpressions
argument_list|()
operator|.
name|get
argument_list|(
name|pos
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|exprs
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|ASTNode
name|expr
init|=
name|exprs
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|reduceKeys
operator|.
name|add
argument_list|(
name|genExprNodeDesc
argument_list|(
name|expr
argument_list|,
name|inputRS
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// Walk over the input row resolver and copy in the output
name|ArrayList
argument_list|<
name|ExprNodeDesc
argument_list|>
name|reduceValues
init|=
operator|new
name|ArrayList
argument_list|<
name|ExprNodeDesc
argument_list|>
argument_list|()
decl_stmt|;
name|Iterator
argument_list|<
name|String
argument_list|>
name|tblNamesIter
init|=
name|inputRS
operator|.
name|getTableNames
argument_list|()
operator|.
name|iterator
argument_list|()
decl_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|ExprNodeDesc
argument_list|>
name|colExprMap
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|ExprNodeDesc
argument_list|>
argument_list|()
decl_stmt|;
while|while
condition|(
name|tblNamesIter
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|String
name|src
init|=
name|tblNamesIter
operator|.
name|next
argument_list|()
decl_stmt|;
name|HashMap
argument_list|<
name|String
argument_list|,
name|ColumnInfo
argument_list|>
name|fMap
init|=
name|inputRS
operator|.
name|getFieldMap
argument_list|(
name|src
argument_list|)
decl_stmt|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|ColumnInfo
argument_list|>
name|entry
range|:
name|fMap
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|String
name|field
init|=
name|entry
operator|.
name|getKey
argument_list|()
decl_stmt|;
name|ColumnInfo
name|valueInfo
init|=
name|entry
operator|.
name|getValue
argument_list|()
decl_stmt|;
name|ExprNodeColumnDesc
name|inputExpr
init|=
operator|new
name|ExprNodeColumnDesc
argument_list|(
name|valueInfo
operator|.
name|getType
argument_list|()
argument_list|,
name|valueInfo
operator|.
name|getInternalName
argument_list|()
argument_list|,
name|valueInfo
operator|.
name|getTabAlias
argument_list|()
argument_list|,
name|valueInfo
operator|.
name|getIsVirtualCol
argument_list|()
argument_list|)
decl_stmt|;
name|reduceValues
operator|.
name|add
argument_list|(
name|inputExpr
argument_list|)
expr_stmt|;
if|if
condition|(
name|outputRS
operator|.
name|get
argument_list|(
name|src
argument_list|,
name|field
argument_list|)
operator|==
literal|null
condition|)
block|{
name|String
name|col
init|=
name|getColumnInternalName
argument_list|(
name|reduceValues
operator|.
name|size
argument_list|()
operator|-
literal|1
argument_list|)
decl_stmt|;
name|outputColumns
operator|.
name|add
argument_list|(
name|col
argument_list|)
expr_stmt|;
name|ColumnInfo
name|newColInfo
init|=
operator|new
name|ColumnInfo
argument_list|(
name|Utilities
operator|.
name|ReduceField
operator|.
name|VALUE
operator|.
name|toString
argument_list|()
operator|+
literal|"."
operator|+
name|col
argument_list|,
name|valueInfo
operator|.
name|getType
argument_list|()
argument_list|,
name|src
argument_list|,
name|valueInfo
operator|.
name|getIsVirtualCol
argument_list|()
argument_list|,
name|valueInfo
operator|.
name|isHiddenVirtualCol
argument_list|()
argument_list|)
decl_stmt|;
name|colExprMap
operator|.
name|put
argument_list|(
name|newColInfo
operator|.
name|getInternalName
argument_list|()
argument_list|,
name|inputExpr
argument_list|)
expr_stmt|;
name|outputRS
operator|.
name|put
argument_list|(
name|src
argument_list|,
name|field
argument_list|,
name|newColInfo
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|int
name|numReds
init|=
operator|-
literal|1
decl_stmt|;
comment|// Use only 1 reducer in case of cartesian product
if|if
condition|(
name|reduceKeys
operator|.
name|size
argument_list|()
operator|==
literal|0
condition|)
block|{
name|numReds
operator|=
literal|1
expr_stmt|;
comment|// Cartesian product is not supported in strict mode
if|if
condition|(
name|conf
operator|.
name|getVar
argument_list|(
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVEMAPREDMODE
argument_list|)
operator|.
name|equalsIgnoreCase
argument_list|(
literal|"strict"
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|NO_CARTESIAN_PRODUCT
operator|.
name|getMsg
argument_list|()
argument_list|)
throw|;
block|}
block|}
name|ReduceSinkOperator
name|rsOp
init|=
operator|(
name|ReduceSinkOperator
operator|)
name|putOpInsertMap
argument_list|(
name|OperatorFactory
operator|.
name|getAndMakeChild
argument_list|(
name|PlanUtils
operator|.
name|getReduceSinkDesc
argument_list|(
name|reduceKeys
argument_list|,
name|reduceValues
argument_list|,
name|outputColumns
argument_list|,
literal|false
argument_list|,
name|joinTree
operator|.
name|getNextTag
argument_list|()
argument_list|,
name|reduceKeys
operator|.
name|size
argument_list|()
argument_list|,
name|numReds
argument_list|)
argument_list|,
operator|new
name|RowSchema
argument_list|(
name|outputRS
operator|.
name|getColumnInfos
argument_list|()
argument_list|)
argument_list|,
name|child
argument_list|)
argument_list|,
name|outputRS
argument_list|)
decl_stmt|;
name|rsOp
operator|.
name|setColumnExprMap
argument_list|(
name|colExprMap
argument_list|)
expr_stmt|;
return|return
name|rsOp
return|;
block|}
specifier|private
name|Operator
name|genJoinOperator
parameter_list|(
name|QB
name|qb
parameter_list|,
name|QBJoinTree
name|joinTree
parameter_list|,
name|HashMap
argument_list|<
name|String
argument_list|,
name|Operator
argument_list|>
name|map
parameter_list|)
throws|throws
name|SemanticException
block|{
name|QBJoinTree
name|leftChild
init|=
name|joinTree
operator|.
name|getJoinSrc
argument_list|()
decl_stmt|;
name|Operator
name|joinSrcOp
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|leftChild
operator|!=
literal|null
condition|)
block|{
name|Operator
name|joinOp
init|=
name|genJoinOperator
argument_list|(
name|qb
argument_list|,
name|leftChild
argument_list|,
name|map
argument_list|)
decl_stmt|;
name|ArrayList
argument_list|<
name|ASTNode
argument_list|>
name|filter
init|=
name|joinTree
operator|.
name|getFiltersForPushing
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
for|for
control|(
name|ASTNode
name|cond
range|:
name|filter
control|)
block|{
name|joinOp
operator|=
name|genFilterPlan
argument_list|(
name|qb
argument_list|,
name|cond
argument_list|,
name|joinOp
argument_list|)
expr_stmt|;
block|}
name|joinSrcOp
operator|=
name|genJoinReduceSinkChild
argument_list|(
name|qb
argument_list|,
name|joinTree
argument_list|,
name|joinOp
argument_list|,
literal|null
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|Operator
index|[]
name|srcOps
init|=
operator|new
name|Operator
index|[
name|joinTree
operator|.
name|getBaseSrc
argument_list|()
operator|.
name|length
index|]
decl_stmt|;
name|HashSet
argument_list|<
name|Integer
argument_list|>
name|omitOpts
init|=
literal|null
decl_stmt|;
comment|// set of input to the join that should be
comment|// omitted by the output
name|int
name|pos
init|=
literal|0
decl_stmt|;
for|for
control|(
name|String
name|src
range|:
name|joinTree
operator|.
name|getBaseSrc
argument_list|()
control|)
block|{
if|if
condition|(
name|src
operator|!=
literal|null
condition|)
block|{
name|Operator
name|srcOp
init|=
name|map
operator|.
name|get
argument_list|(
name|src
operator|.
name|toLowerCase
argument_list|()
argument_list|)
decl_stmt|;
comment|// for left-semi join, generate an additional selection& group-by
comment|// operator before ReduceSink
name|ArrayList
argument_list|<
name|ASTNode
argument_list|>
name|fields
init|=
name|joinTree
operator|.
name|getRHSSemijoinColumns
argument_list|(
name|src
argument_list|)
decl_stmt|;
if|if
condition|(
name|fields
operator|!=
literal|null
condition|)
block|{
comment|// the RHS table columns should be not be output from the join
if|if
condition|(
name|omitOpts
operator|==
literal|null
condition|)
block|{
name|omitOpts
operator|=
operator|new
name|HashSet
argument_list|<
name|Integer
argument_list|>
argument_list|()
expr_stmt|;
block|}
name|omitOpts
operator|.
name|add
argument_list|(
name|pos
argument_list|)
expr_stmt|;
comment|// generate a selection operator for group-by keys only
name|srcOp
operator|=
name|insertSelectForSemijoin
argument_list|(
name|fields
argument_list|,
name|srcOp
argument_list|)
expr_stmt|;
comment|// generate a groupby operator (HASH mode) for a map-side partial
comment|// aggregation for semijoin
name|srcOp
operator|=
name|genMapGroupByForSemijoin
argument_list|(
name|qb
argument_list|,
name|fields
argument_list|,
name|srcOp
argument_list|,
name|GroupByDesc
operator|.
name|Mode
operator|.
name|HASH
argument_list|)
expr_stmt|;
block|}
comment|// generate a ReduceSink operator for the join
name|srcOps
index|[
name|pos
index|]
operator|=
name|genJoinReduceSinkChild
argument_list|(
name|qb
argument_list|,
name|joinTree
argument_list|,
name|srcOp
argument_list|,
name|src
argument_list|,
name|pos
argument_list|)
expr_stmt|;
name|pos
operator|++
expr_stmt|;
block|}
else|else
block|{
assert|assert
name|pos
operator|==
literal|0
assert|;
name|srcOps
index|[
name|pos
operator|++
index|]
operator|=
literal|null
expr_stmt|;
block|}
block|}
comment|// Type checking and implicit type conversion for join keys
name|genJoinOperatorTypeCheck
argument_list|(
name|joinSrcOp
argument_list|,
name|srcOps
argument_list|)
expr_stmt|;
name|JoinOperator
name|joinOp
init|=
operator|(
name|JoinOperator
operator|)
name|genJoinOperatorChildren
argument_list|(
name|joinTree
argument_list|,
name|joinSrcOp
argument_list|,
name|srcOps
argument_list|,
name|omitOpts
argument_list|)
decl_stmt|;
name|joinContext
operator|.
name|put
argument_list|(
name|joinOp
argument_list|,
name|joinTree
argument_list|)
expr_stmt|;
return|return
name|joinOp
return|;
block|}
comment|/**    * Construct a selection operator for semijoin that filter out all fields    * other than the group by keys.    *    * @param fields    *          list of fields need to be output    * @param input    *          input operator    * @return the selection operator.    * @throws SemanticException    */
specifier|private
name|Operator
name|insertSelectForSemijoin
parameter_list|(
name|ArrayList
argument_list|<
name|ASTNode
argument_list|>
name|fields
parameter_list|,
name|Operator
name|input
parameter_list|)
throws|throws
name|SemanticException
block|{
name|RowResolver
name|inputRR
init|=
name|opParseCtx
operator|.
name|get
argument_list|(
name|input
argument_list|)
operator|.
name|getRowResolver
argument_list|()
decl_stmt|;
name|ArrayList
argument_list|<
name|ExprNodeDesc
argument_list|>
name|colList
init|=
operator|new
name|ArrayList
argument_list|<
name|ExprNodeDesc
argument_list|>
argument_list|()
decl_stmt|;
name|ArrayList
argument_list|<
name|String
argument_list|>
name|columnNames
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
comment|// construct the list of columns that need to be projected
for|for
control|(
name|ASTNode
name|field
range|:
name|fields
control|)
block|{
name|ExprNodeColumnDesc
name|exprNode
init|=
operator|(
name|ExprNodeColumnDesc
operator|)
name|genExprNodeDesc
argument_list|(
name|field
argument_list|,
name|inputRR
argument_list|)
decl_stmt|;
name|colList
operator|.
name|add
argument_list|(
name|exprNode
argument_list|)
expr_stmt|;
name|columnNames
operator|.
name|add
argument_list|(
name|exprNode
operator|.
name|getColumn
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// create selection operator
name|Operator
name|output
init|=
name|putOpInsertMap
argument_list|(
name|OperatorFactory
operator|.
name|getAndMakeChild
argument_list|(
operator|new
name|SelectDesc
argument_list|(
name|colList
argument_list|,
name|columnNames
argument_list|,
literal|false
argument_list|)
argument_list|,
operator|new
name|RowSchema
argument_list|(
name|inputRR
operator|.
name|getColumnInfos
argument_list|()
argument_list|)
argument_list|,
name|input
argument_list|)
argument_list|,
name|inputRR
argument_list|)
decl_stmt|;
name|output
operator|.
name|setColumnExprMap
argument_list|(
name|input
operator|.
name|getColumnExprMap
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|output
return|;
block|}
specifier|private
name|Operator
name|genMapGroupByForSemijoin
parameter_list|(
name|QB
name|qb
parameter_list|,
name|ArrayList
argument_list|<
name|ASTNode
argument_list|>
name|fields
parameter_list|,
comment|// the
comment|// ASTNode
comment|// of
comment|// the
comment|// join
comment|// key
comment|// "tab.col"
name|Operator
name|inputOperatorInfo
parameter_list|,
name|GroupByDesc
operator|.
name|Mode
name|mode
parameter_list|)
throws|throws
name|SemanticException
block|{
name|RowResolver
name|groupByInputRowResolver
init|=
name|opParseCtx
operator|.
name|get
argument_list|(
name|inputOperatorInfo
argument_list|)
operator|.
name|getRowResolver
argument_list|()
decl_stmt|;
name|RowResolver
name|groupByOutputRowResolver
init|=
operator|new
name|RowResolver
argument_list|()
decl_stmt|;
name|ArrayList
argument_list|<
name|ExprNodeDesc
argument_list|>
name|groupByKeys
init|=
operator|new
name|ArrayList
argument_list|<
name|ExprNodeDesc
argument_list|>
argument_list|()
decl_stmt|;
name|ArrayList
argument_list|<
name|String
argument_list|>
name|outputColumnNames
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
name|ArrayList
argument_list|<
name|AggregationDesc
argument_list|>
name|aggregations
init|=
operator|new
name|ArrayList
argument_list|<
name|AggregationDesc
argument_list|>
argument_list|()
decl_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|ExprNodeDesc
argument_list|>
name|colExprMap
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|ExprNodeDesc
argument_list|>
argument_list|()
decl_stmt|;
name|qb
operator|.
name|getParseInfo
argument_list|()
expr_stmt|;
name|groupByOutputRowResolver
operator|.
name|setIsExprResolver
argument_list|(
literal|true
argument_list|)
expr_stmt|;
comment|// join keys should only
comment|// be columns but not be
comment|// expressions
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|fields
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
comment|// get the group by keys to ColumnInfo
name|ASTNode
name|colName
init|=
name|fields
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|ExprNodeDesc
name|grpByExprNode
init|=
name|genExprNodeDesc
argument_list|(
name|colName
argument_list|,
name|groupByInputRowResolver
argument_list|)
decl_stmt|;
name|groupByKeys
operator|.
name|add
argument_list|(
name|grpByExprNode
argument_list|)
expr_stmt|;
comment|// generate output column names
name|String
name|field
init|=
name|getColumnInternalName
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|outputColumnNames
operator|.
name|add
argument_list|(
name|field
argument_list|)
expr_stmt|;
name|ColumnInfo
name|colInfo2
init|=
operator|new
name|ColumnInfo
argument_list|(
name|field
argument_list|,
name|grpByExprNode
operator|.
name|getTypeInfo
argument_list|()
argument_list|,
literal|""
argument_list|,
literal|false
argument_list|)
decl_stmt|;
name|groupByOutputRowResolver
operator|.
name|putExpression
argument_list|(
name|colName
argument_list|,
name|colInfo2
argument_list|)
expr_stmt|;
comment|// establish mapping from the output column to the input column
name|colExprMap
operator|.
name|put
argument_list|(
name|field
argument_list|,
name|grpByExprNode
argument_list|)
expr_stmt|;
block|}
comment|// Generate group-by operator
name|float
name|groupByMemoryUsage
init|=
name|HiveConf
operator|.
name|getFloatVar
argument_list|(
name|conf
argument_list|,
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVEMAPAGGRHASHMEMORY
argument_list|)
decl_stmt|;
name|float
name|memoryThreshold
init|=
name|HiveConf
operator|.
name|getFloatVar
argument_list|(
name|conf
argument_list|,
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVEMAPAGGRMEMORYTHRESHOLD
argument_list|)
decl_stmt|;
name|Operator
name|op
init|=
name|putOpInsertMap
argument_list|(
name|OperatorFactory
operator|.
name|getAndMakeChild
argument_list|(
operator|new
name|GroupByDesc
argument_list|(
name|mode
argument_list|,
name|outputColumnNames
argument_list|,
name|groupByKeys
argument_list|,
name|aggregations
argument_list|,
literal|false
argument_list|,
name|groupByMemoryUsage
argument_list|,
name|memoryThreshold
argument_list|)
argument_list|,
operator|new
name|RowSchema
argument_list|(
name|groupByOutputRowResolver
operator|.
name|getColumnInfos
argument_list|()
argument_list|)
argument_list|,
name|inputOperatorInfo
argument_list|)
argument_list|,
name|groupByOutputRowResolver
argument_list|)
decl_stmt|;
name|op
operator|.
name|setColumnExprMap
argument_list|(
name|colExprMap
argument_list|)
expr_stmt|;
return|return
name|op
return|;
block|}
specifier|private
name|void
name|genJoinOperatorTypeCheck
parameter_list|(
name|Operator
name|left
parameter_list|,
name|Operator
index|[]
name|right
parameter_list|)
throws|throws
name|SemanticException
block|{
comment|// keys[i] -> ArrayList<exprNodeDesc> for the i-th join operator key list
name|ArrayList
argument_list|<
name|ArrayList
argument_list|<
name|ExprNodeDesc
argument_list|>
argument_list|>
name|keys
init|=
operator|new
name|ArrayList
argument_list|<
name|ArrayList
argument_list|<
name|ExprNodeDesc
argument_list|>
argument_list|>
argument_list|()
decl_stmt|;
name|int
name|keyLength
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|right
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|Operator
name|oi
init|=
operator|(
name|i
operator|==
literal|0
operator|&&
name|right
index|[
name|i
index|]
operator|==
literal|null
condition|?
name|left
else|:
name|right
index|[
name|i
index|]
operator|)
decl_stmt|;
name|ReduceSinkDesc
name|now
init|=
operator|(
call|(
name|ReduceSinkOperator
call|)
argument_list|(
name|oi
argument_list|)
operator|)
operator|.
name|getConf
argument_list|()
decl_stmt|;
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
name|keyLength
operator|=
name|now
operator|.
name|getKeyCols
argument_list|()
operator|.
name|size
argument_list|()
expr_stmt|;
block|}
else|else
block|{
assert|assert
operator|(
name|keyLength
operator|==
name|now
operator|.
name|getKeyCols
argument_list|()
operator|.
name|size
argument_list|()
operator|)
assert|;
block|}
name|keys
operator|.
name|add
argument_list|(
name|now
operator|.
name|getKeyCols
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// implicit type conversion hierarchy
for|for
control|(
name|int
name|k
init|=
literal|0
init|;
name|k
operator|<
name|keyLength
condition|;
name|k
operator|++
control|)
block|{
comment|// Find the common class for type conversion
name|TypeInfo
name|commonType
init|=
name|keys
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|get
argument_list|(
name|k
argument_list|)
operator|.
name|getTypeInfo
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<
name|right
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|TypeInfo
name|a
init|=
name|commonType
decl_stmt|;
name|TypeInfo
name|b
init|=
name|keys
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|get
argument_list|(
name|k
argument_list|)
operator|.
name|getTypeInfo
argument_list|()
decl_stmt|;
name|commonType
operator|=
name|FunctionRegistry
operator|.
name|getCommonClassForComparison
argument_list|(
name|a
argument_list|,
name|b
argument_list|)
expr_stmt|;
if|if
condition|(
name|commonType
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
literal|"Cannot do equality join on different types: "
operator|+
name|a
operator|.
name|getTypeName
argument_list|()
operator|+
literal|" and "
operator|+
name|b
operator|.
name|getTypeName
argument_list|()
argument_list|)
throw|;
block|}
block|}
comment|// Add implicit type conversion if necessary
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|right
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|commonType
operator|.
name|equals
argument_list|(
name|keys
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|get
argument_list|(
name|k
argument_list|)
operator|.
name|getTypeInfo
argument_list|()
argument_list|)
condition|)
block|{
name|keys
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|set
argument_list|(
name|k
argument_list|,
name|TypeCheckProcFactory
operator|.
name|DefaultExprProcessor
operator|.
name|getFuncExprNodeDesc
argument_list|(
name|commonType
operator|.
name|getTypeName
argument_list|()
argument_list|,
name|keys
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|get
argument_list|(
name|k
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|// regenerate keySerializationInfo because the ReduceSinkOperator's
comment|// output key types might have changed.
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|right
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|Operator
name|oi
init|=
operator|(
name|i
operator|==
literal|0
operator|&&
name|right
index|[
name|i
index|]
operator|==
literal|null
condition|?
name|left
else|:
name|right
index|[
name|i
index|]
operator|)
decl_stmt|;
name|ReduceSinkDesc
name|now
init|=
operator|(
call|(
name|ReduceSinkOperator
call|)
argument_list|(
name|oi
argument_list|)
operator|)
operator|.
name|getConf
argument_list|()
decl_stmt|;
name|now
operator|.
name|setKeySerializeInfo
argument_list|(
name|PlanUtils
operator|.
name|getReduceKeyTableDesc
argument_list|(
name|PlanUtils
operator|.
name|getFieldSchemasFromColumnList
argument_list|(
name|now
operator|.
name|getKeyCols
argument_list|()
argument_list|,
literal|"joinkey"
argument_list|)
argument_list|,
name|now
operator|.
name|getOrder
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
name|Operator
name|genJoinPlan
parameter_list|(
name|QB
name|qb
parameter_list|,
name|HashMap
argument_list|<
name|String
argument_list|,
name|Operator
argument_list|>
name|map
parameter_list|)
throws|throws
name|SemanticException
block|{
name|QBJoinTree
name|joinTree
init|=
name|qb
operator|.
name|getQbJoinTree
argument_list|()
decl_stmt|;
name|Operator
name|joinOp
init|=
name|genJoinOperator
argument_list|(
name|qb
argument_list|,
name|joinTree
argument_list|,
name|map
argument_list|)
decl_stmt|;
return|return
name|joinOp
return|;
block|}
comment|/**    * Extract the filters from the join condition and push them on top of the    * source operators. This procedure traverses the query tree recursively,    */
specifier|private
name|void
name|pushJoinFilters
parameter_list|(
name|QB
name|qb
parameter_list|,
name|QBJoinTree
name|joinTree
parameter_list|,
name|HashMap
argument_list|<
name|String
argument_list|,
name|Operator
argument_list|>
name|map
parameter_list|)
throws|throws
name|SemanticException
block|{
if|if
condition|(
name|joinTree
operator|.
name|getJoinSrc
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|pushJoinFilters
argument_list|(
name|qb
argument_list|,
name|joinTree
operator|.
name|getJoinSrc
argument_list|()
argument_list|,
name|map
argument_list|)
expr_stmt|;
block|}
name|ArrayList
argument_list|<
name|ArrayList
argument_list|<
name|ASTNode
argument_list|>
argument_list|>
name|filters
init|=
name|joinTree
operator|.
name|getFiltersForPushing
argument_list|()
decl_stmt|;
name|int
name|pos
init|=
literal|0
decl_stmt|;
for|for
control|(
name|String
name|src
range|:
name|joinTree
operator|.
name|getBaseSrc
argument_list|()
control|)
block|{
if|if
condition|(
name|src
operator|!=
literal|null
condition|)
block|{
name|Operator
name|srcOp
init|=
name|map
operator|.
name|get
argument_list|(
name|src
argument_list|)
decl_stmt|;
name|ArrayList
argument_list|<
name|ASTNode
argument_list|>
name|filter
init|=
name|filters
operator|.
name|get
argument_list|(
name|pos
argument_list|)
decl_stmt|;
for|for
control|(
name|ASTNode
name|cond
range|:
name|filter
control|)
block|{
name|srcOp
operator|=
name|genFilterPlan
argument_list|(
name|qb
argument_list|,
name|cond
argument_list|,
name|srcOp
argument_list|)
expr_stmt|;
block|}
name|map
operator|.
name|put
argument_list|(
name|src
argument_list|,
name|srcOp
argument_list|)
expr_stmt|;
block|}
name|pos
operator|++
expr_stmt|;
block|}
block|}
specifier|private
name|List
argument_list|<
name|String
argument_list|>
name|getMapSideJoinTables
parameter_list|(
name|QB
name|qb
parameter_list|)
block|{
name|List
argument_list|<
name|String
argument_list|>
name|cols
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
name|ASTNode
name|hints
init|=
name|qb
operator|.
name|getParseInfo
argument_list|()
operator|.
name|getHints
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|pos
init|=
literal|0
init|;
name|pos
operator|<
name|hints
operator|.
name|getChildCount
argument_list|()
condition|;
name|pos
operator|++
control|)
block|{
name|ASTNode
name|hint
init|=
operator|(
name|ASTNode
operator|)
name|hints
operator|.
name|getChild
argument_list|(
name|pos
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
operator|(
name|ASTNode
operator|)
name|hint
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|)
operator|.
name|getToken
argument_list|()
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_MAPJOIN
condition|)
block|{
name|ASTNode
name|hintTblNames
init|=
operator|(
name|ASTNode
operator|)
name|hint
operator|.
name|getChild
argument_list|(
literal|1
argument_list|)
decl_stmt|;
name|int
name|numCh
init|=
name|hintTblNames
operator|.
name|getChildCount
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|tblPos
init|=
literal|0
init|;
name|tblPos
operator|<
name|numCh
condition|;
name|tblPos
operator|++
control|)
block|{
name|String
name|tblName
init|=
operator|(
operator|(
name|ASTNode
operator|)
name|hintTblNames
operator|.
name|getChild
argument_list|(
name|tblPos
argument_list|)
operator|)
operator|.
name|getText
argument_list|()
operator|.
name|toLowerCase
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|cols
operator|.
name|contains
argument_list|(
name|tblName
argument_list|)
condition|)
block|{
name|cols
operator|.
name|add
argument_list|(
name|tblName
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
return|return
name|cols
return|;
block|}
specifier|private
name|QBJoinTree
name|genUniqueJoinTree
parameter_list|(
name|QB
name|qb
parameter_list|,
name|ASTNode
name|joinParseTree
parameter_list|)
throws|throws
name|SemanticException
block|{
name|QBJoinTree
name|joinTree
init|=
operator|new
name|QBJoinTree
argument_list|()
decl_stmt|;
name|joinTree
operator|.
name|setNoOuterJoin
argument_list|(
literal|false
argument_list|)
expr_stmt|;
name|joinTree
operator|.
name|setExpressions
argument_list|(
operator|new
name|ArrayList
argument_list|<
name|ArrayList
argument_list|<
name|ASTNode
argument_list|>
argument_list|>
argument_list|()
argument_list|)
expr_stmt|;
name|joinTree
operator|.
name|setFilters
argument_list|(
operator|new
name|ArrayList
argument_list|<
name|ArrayList
argument_list|<
name|ASTNode
argument_list|>
argument_list|>
argument_list|()
argument_list|)
expr_stmt|;
name|joinTree
operator|.
name|setFiltersForPushing
argument_list|(
operator|new
name|ArrayList
argument_list|<
name|ArrayList
argument_list|<
name|ASTNode
argument_list|>
argument_list|>
argument_list|()
argument_list|)
expr_stmt|;
comment|// Create joinTree structures to fill them up later
name|ArrayList
argument_list|<
name|String
argument_list|>
name|rightAliases
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
name|ArrayList
argument_list|<
name|String
argument_list|>
name|leftAliases
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
name|ArrayList
argument_list|<
name|String
argument_list|>
name|baseSrc
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
name|ArrayList
argument_list|<
name|Boolean
argument_list|>
name|preserved
init|=
operator|new
name|ArrayList
argument_list|<
name|Boolean
argument_list|>
argument_list|()
decl_stmt|;
name|boolean
name|lastPreserved
init|=
literal|false
decl_stmt|;
name|int
name|cols
init|=
operator|-
literal|1
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|joinParseTree
operator|.
name|getChildCount
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|ASTNode
name|child
init|=
operator|(
name|ASTNode
operator|)
name|joinParseTree
operator|.
name|getChild
argument_list|(
name|i
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|child
operator|.
name|getToken
argument_list|()
operator|.
name|getType
argument_list|()
condition|)
block|{
case|case
name|HiveParser
operator|.
name|TOK_TABREF
case|:
comment|// Handle a table - populate aliases appropriately:
comment|// leftAliases should contain the first table, rightAliases should
comment|// contain all other tables and baseSrc should contain all tables
name|String
name|tableName
init|=
name|getUnescapedName
argument_list|(
operator|(
name|ASTNode
operator|)
name|child
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|String
name|alias
init|=
name|child
operator|.
name|getChildCount
argument_list|()
operator|==
literal|1
condition|?
name|tableName
else|:
name|unescapeIdentifier
argument_list|(
name|child
operator|.
name|getChild
argument_list|(
name|child
operator|.
name|getChildCount
argument_list|()
operator|-
literal|1
argument_list|)
operator|.
name|getText
argument_list|()
operator|.
name|toLowerCase
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
name|leftAliases
operator|.
name|add
argument_list|(
name|alias
argument_list|)
expr_stmt|;
name|joinTree
operator|.
name|setLeftAlias
argument_list|(
name|alias
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|rightAliases
operator|.
name|add
argument_list|(
name|alias
argument_list|)
expr_stmt|;
block|}
name|baseSrc
operator|.
name|add
argument_list|(
name|alias
argument_list|)
expr_stmt|;
name|preserved
operator|.
name|add
argument_list|(
name|lastPreserved
argument_list|)
expr_stmt|;
name|lastPreserved
operator|=
literal|false
expr_stmt|;
break|break;
case|case
name|HiveParser
operator|.
name|TOK_EXPLIST
case|:
if|if
condition|(
name|cols
operator|==
operator|-
literal|1
operator|&&
name|child
operator|.
name|getChildCount
argument_list|()
operator|!=
literal|0
condition|)
block|{
name|cols
operator|=
name|child
operator|.
name|getChildCount
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|child
operator|.
name|getChildCount
argument_list|()
operator|!=
name|cols
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
literal|"Tables with different or invalid "
operator|+
literal|"number of keys in UNIQUEJOIN"
argument_list|)
throw|;
block|}
name|ArrayList
argument_list|<
name|ASTNode
argument_list|>
name|expressions
init|=
operator|new
name|ArrayList
argument_list|<
name|ASTNode
argument_list|>
argument_list|()
decl_stmt|;
name|ArrayList
argument_list|<
name|ASTNode
argument_list|>
name|filt
init|=
operator|new
name|ArrayList
argument_list|<
name|ASTNode
argument_list|>
argument_list|()
decl_stmt|;
name|ArrayList
argument_list|<
name|ASTNode
argument_list|>
name|filters
init|=
operator|new
name|ArrayList
argument_list|<
name|ASTNode
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|Node
name|exp
range|:
name|child
operator|.
name|getChildren
argument_list|()
control|)
block|{
name|expressions
operator|.
name|add
argument_list|(
operator|(
name|ASTNode
operator|)
name|exp
argument_list|)
expr_stmt|;
block|}
name|joinTree
operator|.
name|getExpressions
argument_list|()
operator|.
name|add
argument_list|(
name|expressions
argument_list|)
expr_stmt|;
name|joinTree
operator|.
name|getFilters
argument_list|()
operator|.
name|add
argument_list|(
name|filt
argument_list|)
expr_stmt|;
name|joinTree
operator|.
name|getFiltersForPushing
argument_list|()
operator|.
name|add
argument_list|(
name|filters
argument_list|)
expr_stmt|;
break|break;
case|case
name|HiveParser
operator|.
name|KW_PRESERVE
case|:
name|lastPreserved
operator|=
literal|true
expr_stmt|;
break|break;
case|case
name|HiveParser
operator|.
name|TOK_SUBQUERY
case|:
throw|throw
operator|new
name|SemanticException
argument_list|(
literal|"Subqueries are not supported in UNIQUEJOIN"
argument_list|)
throw|;
default|default:
throw|throw
operator|new
name|SemanticException
argument_list|(
literal|"Unexpected UNIQUEJOIN structure"
argument_list|)
throw|;
block|}
block|}
name|joinTree
operator|.
name|setBaseSrc
argument_list|(
name|baseSrc
operator|.
name|toArray
argument_list|(
operator|new
name|String
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|joinTree
operator|.
name|setLeftAliases
argument_list|(
name|leftAliases
operator|.
name|toArray
argument_list|(
operator|new
name|String
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|joinTree
operator|.
name|setRightAliases
argument_list|(
name|rightAliases
operator|.
name|toArray
argument_list|(
operator|new
name|String
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|JoinCond
index|[]
name|condn
init|=
operator|new
name|JoinCond
index|[
name|preserved
operator|.
name|size
argument_list|()
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|condn
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|condn
index|[
name|i
index|]
operator|=
operator|new
name|JoinCond
argument_list|(
name|preserved
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|joinTree
operator|.
name|setJoinCond
argument_list|(
name|condn
argument_list|)
expr_stmt|;
if|if
condition|(
name|qb
operator|.
name|getParseInfo
argument_list|()
operator|.
name|getHints
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|parseStreamTables
argument_list|(
name|joinTree
argument_list|,
name|qb
argument_list|)
expr_stmt|;
block|}
return|return
name|joinTree
return|;
block|}
specifier|private
name|QBJoinTree
name|genJoinTree
parameter_list|(
name|QB
name|qb
parameter_list|,
name|ASTNode
name|joinParseTree
parameter_list|)
throws|throws
name|SemanticException
block|{
name|QBJoinTree
name|joinTree
init|=
operator|new
name|QBJoinTree
argument_list|()
decl_stmt|;
name|JoinCond
index|[]
name|condn
init|=
operator|new
name|JoinCond
index|[
literal|1
index|]
decl_stmt|;
switch|switch
condition|(
name|joinParseTree
operator|.
name|getToken
argument_list|()
operator|.
name|getType
argument_list|()
condition|)
block|{
case|case
name|HiveParser
operator|.
name|TOK_LEFTOUTERJOIN
case|:
name|joinTree
operator|.
name|setNoOuterJoin
argument_list|(
literal|false
argument_list|)
expr_stmt|;
name|condn
index|[
literal|0
index|]
operator|=
operator|new
name|JoinCond
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|,
name|JoinType
operator|.
name|LEFTOUTER
argument_list|)
expr_stmt|;
break|break;
case|case
name|HiveParser
operator|.
name|TOK_RIGHTOUTERJOIN
case|:
name|joinTree
operator|.
name|setNoOuterJoin
argument_list|(
literal|false
argument_list|)
expr_stmt|;
name|condn
index|[
literal|0
index|]
operator|=
operator|new
name|JoinCond
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|,
name|JoinType
operator|.
name|RIGHTOUTER
argument_list|)
expr_stmt|;
break|break;
case|case
name|HiveParser
operator|.
name|TOK_FULLOUTERJOIN
case|:
name|joinTree
operator|.
name|setNoOuterJoin
argument_list|(
literal|false
argument_list|)
expr_stmt|;
name|condn
index|[
literal|0
index|]
operator|=
operator|new
name|JoinCond
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|,
name|JoinType
operator|.
name|FULLOUTER
argument_list|)
expr_stmt|;
break|break;
case|case
name|HiveParser
operator|.
name|TOK_LEFTSEMIJOIN
case|:
name|joinTree
operator|.
name|setNoSemiJoin
argument_list|(
literal|false
argument_list|)
expr_stmt|;
name|condn
index|[
literal|0
index|]
operator|=
operator|new
name|JoinCond
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|,
name|JoinType
operator|.
name|LEFTSEMI
argument_list|)
expr_stmt|;
break|break;
default|default:
name|condn
index|[
literal|0
index|]
operator|=
operator|new
name|JoinCond
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|,
name|JoinType
operator|.
name|INNER
argument_list|)
expr_stmt|;
name|joinTree
operator|.
name|setNoOuterJoin
argument_list|(
literal|true
argument_list|)
expr_stmt|;
break|break;
block|}
name|joinTree
operator|.
name|setJoinCond
argument_list|(
name|condn
argument_list|)
expr_stmt|;
name|ASTNode
name|left
init|=
operator|(
name|ASTNode
operator|)
name|joinParseTree
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|ASTNode
name|right
init|=
operator|(
name|ASTNode
operator|)
name|joinParseTree
operator|.
name|getChild
argument_list|(
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|left
operator|.
name|getToken
argument_list|()
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_TABREF
operator|)
operator|||
operator|(
name|left
operator|.
name|getToken
argument_list|()
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_SUBQUERY
operator|)
condition|)
block|{
name|String
name|table_name
init|=
name|getUnescapedName
argument_list|(
operator|(
name|ASTNode
operator|)
name|left
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|String
name|alias
init|=
name|left
operator|.
name|getChildCount
argument_list|()
operator|==
literal|1
condition|?
name|table_name
else|:
name|unescapeIdentifier
argument_list|(
name|left
operator|.
name|getChild
argument_list|(
name|left
operator|.
name|getChildCount
argument_list|()
operator|-
literal|1
argument_list|)
operator|.
name|getText
argument_list|()
operator|.
name|toLowerCase
argument_list|()
argument_list|)
decl_stmt|;
name|joinTree
operator|.
name|setLeftAlias
argument_list|(
name|alias
argument_list|)
expr_stmt|;
name|String
index|[]
name|leftAliases
init|=
operator|new
name|String
index|[
literal|1
index|]
decl_stmt|;
name|leftAliases
index|[
literal|0
index|]
operator|=
name|alias
expr_stmt|;
name|joinTree
operator|.
name|setLeftAliases
argument_list|(
name|leftAliases
argument_list|)
expr_stmt|;
name|String
index|[]
name|children
init|=
operator|new
name|String
index|[
literal|2
index|]
decl_stmt|;
name|children
index|[
literal|0
index|]
operator|=
name|alias
expr_stmt|;
name|joinTree
operator|.
name|setBaseSrc
argument_list|(
name|children
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|isJoinToken
argument_list|(
name|left
argument_list|)
condition|)
block|{
name|QBJoinTree
name|leftTree
init|=
name|genJoinTree
argument_list|(
name|qb
argument_list|,
name|left
argument_list|)
decl_stmt|;
name|joinTree
operator|.
name|setJoinSrc
argument_list|(
name|leftTree
argument_list|)
expr_stmt|;
name|String
index|[]
name|leftChildAliases
init|=
name|leftTree
operator|.
name|getLeftAliases
argument_list|()
decl_stmt|;
name|String
name|leftAliases
index|[]
init|=
operator|new
name|String
index|[
name|leftChildAliases
operator|.
name|length
operator|+
literal|1
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|leftChildAliases
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|leftAliases
index|[
name|i
index|]
operator|=
name|leftChildAliases
index|[
name|i
index|]
expr_stmt|;
block|}
name|leftAliases
index|[
name|leftChildAliases
operator|.
name|length
index|]
operator|=
name|leftTree
operator|.
name|getRightAliases
argument_list|()
index|[
literal|0
index|]
expr_stmt|;
name|joinTree
operator|.
name|setLeftAliases
argument_list|(
name|leftAliases
argument_list|)
expr_stmt|;
block|}
else|else
block|{
assert|assert
operator|(
literal|false
operator|)
assert|;
block|}
if|if
condition|(
operator|(
name|right
operator|.
name|getToken
argument_list|()
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_TABREF
operator|)
operator|||
operator|(
name|right
operator|.
name|getToken
argument_list|()
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_SUBQUERY
operator|)
condition|)
block|{
name|String
name|tableName
init|=
name|getUnescapedName
argument_list|(
operator|(
name|ASTNode
operator|)
name|right
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|String
name|alias
init|=
name|right
operator|.
name|getChildCount
argument_list|()
operator|==
literal|1
condition|?
name|tableName
else|:
name|unescapeIdentifier
argument_list|(
name|right
operator|.
name|getChild
argument_list|(
name|right
operator|.
name|getChildCount
argument_list|()
operator|-
literal|1
argument_list|)
operator|.
name|getText
argument_list|()
operator|.
name|toLowerCase
argument_list|()
argument_list|)
decl_stmt|;
name|String
index|[]
name|rightAliases
init|=
operator|new
name|String
index|[
literal|1
index|]
decl_stmt|;
name|rightAliases
index|[
literal|0
index|]
operator|=
name|alias
expr_stmt|;
name|joinTree
operator|.
name|setRightAliases
argument_list|(
name|rightAliases
argument_list|)
expr_stmt|;
name|String
index|[]
name|children
init|=
name|joinTree
operator|.
name|getBaseSrc
argument_list|()
decl_stmt|;
if|if
condition|(
name|children
operator|==
literal|null
condition|)
block|{
name|children
operator|=
operator|new
name|String
index|[
literal|2
index|]
expr_stmt|;
block|}
name|children
index|[
literal|1
index|]
operator|=
name|alias
expr_stmt|;
name|joinTree
operator|.
name|setBaseSrc
argument_list|(
name|children
argument_list|)
expr_stmt|;
comment|// remember rhs table for semijoin
if|if
condition|(
name|joinTree
operator|.
name|getNoSemiJoin
argument_list|()
operator|==
literal|false
condition|)
block|{
name|joinTree
operator|.
name|addRHSSemijoin
argument_list|(
name|alias
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
assert|assert
literal|false
assert|;
block|}
name|ArrayList
argument_list|<
name|ArrayList
argument_list|<
name|ASTNode
argument_list|>
argument_list|>
name|expressions
init|=
operator|new
name|ArrayList
argument_list|<
name|ArrayList
argument_list|<
name|ASTNode
argument_list|>
argument_list|>
argument_list|()
decl_stmt|;
name|expressions
operator|.
name|add
argument_list|(
operator|new
name|ArrayList
argument_list|<
name|ASTNode
argument_list|>
argument_list|()
argument_list|)
expr_stmt|;
name|expressions
operator|.
name|add
argument_list|(
operator|new
name|ArrayList
argument_list|<
name|ASTNode
argument_list|>
argument_list|()
argument_list|)
expr_stmt|;
name|joinTree
operator|.
name|setExpressions
argument_list|(
name|expressions
argument_list|)
expr_stmt|;
name|ArrayList
argument_list|<
name|ArrayList
argument_list|<
name|ASTNode
argument_list|>
argument_list|>
name|filters
init|=
operator|new
name|ArrayList
argument_list|<
name|ArrayList
argument_list|<
name|ASTNode
argument_list|>
argument_list|>
argument_list|()
decl_stmt|;
name|filters
operator|.
name|add
argument_list|(
operator|new
name|ArrayList
argument_list|<
name|ASTNode
argument_list|>
argument_list|()
argument_list|)
expr_stmt|;
name|filters
operator|.
name|add
argument_list|(
operator|new
name|ArrayList
argument_list|<
name|ASTNode
argument_list|>
argument_list|()
argument_list|)
expr_stmt|;
name|joinTree
operator|.
name|setFilters
argument_list|(
name|filters
argument_list|)
expr_stmt|;
name|ArrayList
argument_list|<
name|ArrayList
argument_list|<
name|ASTNode
argument_list|>
argument_list|>
name|filtersForPushing
init|=
operator|new
name|ArrayList
argument_list|<
name|ArrayList
argument_list|<
name|ASTNode
argument_list|>
argument_list|>
argument_list|()
decl_stmt|;
name|filtersForPushing
operator|.
name|add
argument_list|(
operator|new
name|ArrayList
argument_list|<
name|ASTNode
argument_list|>
argument_list|()
argument_list|)
expr_stmt|;
name|filtersForPushing
operator|.
name|add
argument_list|(
operator|new
name|ArrayList
argument_list|<
name|ASTNode
argument_list|>
argument_list|()
argument_list|)
expr_stmt|;
name|joinTree
operator|.
name|setFiltersForPushing
argument_list|(
name|filtersForPushing
argument_list|)
expr_stmt|;
name|ASTNode
name|joinCond
init|=
operator|(
name|ASTNode
operator|)
name|joinParseTree
operator|.
name|getChild
argument_list|(
literal|2
argument_list|)
decl_stmt|;
name|ArrayList
argument_list|<
name|String
argument_list|>
name|leftSrc
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
name|parseJoinCondition
argument_list|(
name|joinTree
argument_list|,
name|joinCond
argument_list|,
name|leftSrc
argument_list|)
expr_stmt|;
if|if
condition|(
name|leftSrc
operator|.
name|size
argument_list|()
operator|==
literal|1
condition|)
block|{
name|joinTree
operator|.
name|setLeftAlias
argument_list|(
name|leftSrc
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// check the hints to see if the user has specified a map-side join. This
comment|// will be removed later on, once the cost-based
comment|// infrastructure is in place
if|if
condition|(
name|qb
operator|.
name|getParseInfo
argument_list|()
operator|.
name|getHints
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|List
argument_list|<
name|String
argument_list|>
name|mapSideTables
init|=
name|getMapSideJoinTables
argument_list|(
name|qb
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|mapAliases
init|=
name|joinTree
operator|.
name|getMapAliases
argument_list|()
decl_stmt|;
for|for
control|(
name|String
name|mapTbl
range|:
name|mapSideTables
control|)
block|{
name|boolean
name|mapTable
init|=
literal|false
decl_stmt|;
for|for
control|(
name|String
name|leftAlias
range|:
name|joinTree
operator|.
name|getLeftAliases
argument_list|()
control|)
block|{
if|if
condition|(
name|mapTbl
operator|.
name|equalsIgnoreCase
argument_list|(
name|leftAlias
argument_list|)
condition|)
block|{
name|mapTable
operator|=
literal|true
expr_stmt|;
block|}
block|}
for|for
control|(
name|String
name|rightAlias
range|:
name|joinTree
operator|.
name|getRightAliases
argument_list|()
control|)
block|{
if|if
condition|(
name|mapTbl
operator|.
name|equalsIgnoreCase
argument_list|(
name|rightAlias
argument_list|)
condition|)
block|{
name|mapTable
operator|=
literal|true
expr_stmt|;
block|}
block|}
if|if
condition|(
name|mapTable
condition|)
block|{
if|if
condition|(
name|mapAliases
operator|==
literal|null
condition|)
block|{
name|mapAliases
operator|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
expr_stmt|;
block|}
name|mapAliases
operator|.
name|add
argument_list|(
name|mapTbl
argument_list|)
expr_stmt|;
name|joinTree
operator|.
name|setMapSideJoin
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
block|}
name|joinTree
operator|.
name|setMapAliases
argument_list|(
name|mapAliases
argument_list|)
expr_stmt|;
name|parseStreamTables
argument_list|(
name|joinTree
argument_list|,
name|qb
argument_list|)
expr_stmt|;
block|}
return|return
name|joinTree
return|;
block|}
specifier|private
name|void
name|parseStreamTables
parameter_list|(
name|QBJoinTree
name|joinTree
parameter_list|,
name|QB
name|qb
parameter_list|)
block|{
name|List
argument_list|<
name|String
argument_list|>
name|streamAliases
init|=
name|joinTree
operator|.
name|getStreamAliases
argument_list|()
decl_stmt|;
for|for
control|(
name|Node
name|hintNode
range|:
name|qb
operator|.
name|getParseInfo
argument_list|()
operator|.
name|getHints
argument_list|()
operator|.
name|getChildren
argument_list|()
control|)
block|{
name|ASTNode
name|hint
init|=
operator|(
name|ASTNode
operator|)
name|hintNode
decl_stmt|;
if|if
condition|(
name|hint
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_STREAMTABLE
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|hint
operator|.
name|getChild
argument_list|(
literal|1
argument_list|)
operator|.
name|getChildCount
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|streamAliases
operator|==
literal|null
condition|)
block|{
name|streamAliases
operator|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
expr_stmt|;
block|}
name|streamAliases
operator|.
name|add
argument_list|(
name|hint
operator|.
name|getChild
argument_list|(
literal|1
argument_list|)
operator|.
name|getChild
argument_list|(
name|i
argument_list|)
operator|.
name|getText
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|joinTree
operator|.
name|setStreamAliases
argument_list|(
name|streamAliases
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|mergeJoins
parameter_list|(
name|QB
name|qb
parameter_list|,
name|QBJoinTree
name|parent
parameter_list|,
name|QBJoinTree
name|node
parameter_list|,
name|QBJoinTree
name|target
parameter_list|,
name|int
name|pos
parameter_list|)
block|{
name|String
index|[]
name|nodeRightAliases
init|=
name|node
operator|.
name|getRightAliases
argument_list|()
decl_stmt|;
name|String
index|[]
name|trgtRightAliases
init|=
name|target
operator|.
name|getRightAliases
argument_list|()
decl_stmt|;
name|String
index|[]
name|rightAliases
init|=
operator|new
name|String
index|[
name|nodeRightAliases
operator|.
name|length
operator|+
name|trgtRightAliases
operator|.
name|length
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|trgtRightAliases
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|rightAliases
index|[
name|i
index|]
operator|=
name|trgtRightAliases
index|[
name|i
index|]
expr_stmt|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|nodeRightAliases
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|rightAliases
index|[
name|i
operator|+
name|trgtRightAliases
operator|.
name|length
index|]
operator|=
name|nodeRightAliases
index|[
name|i
index|]
expr_stmt|;
block|}
name|target
operator|.
name|setRightAliases
argument_list|(
name|rightAliases
argument_list|)
expr_stmt|;
name|String
index|[]
name|nodeBaseSrc
init|=
name|node
operator|.
name|getBaseSrc
argument_list|()
decl_stmt|;
name|String
index|[]
name|trgtBaseSrc
init|=
name|target
operator|.
name|getBaseSrc
argument_list|()
decl_stmt|;
name|String
index|[]
name|baseSrc
init|=
operator|new
name|String
index|[
name|nodeBaseSrc
operator|.
name|length
operator|+
name|trgtBaseSrc
operator|.
name|length
operator|-
literal|1
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|trgtBaseSrc
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|baseSrc
index|[
name|i
index|]
operator|=
name|trgtBaseSrc
index|[
name|i
index|]
expr_stmt|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<
name|nodeBaseSrc
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|baseSrc
index|[
name|i
operator|+
name|trgtBaseSrc
operator|.
name|length
operator|-
literal|1
index|]
operator|=
name|nodeBaseSrc
index|[
name|i
index|]
expr_stmt|;
block|}
name|target
operator|.
name|setBaseSrc
argument_list|(
name|baseSrc
argument_list|)
expr_stmt|;
name|ArrayList
argument_list|<
name|ArrayList
argument_list|<
name|ASTNode
argument_list|>
argument_list|>
name|expr
init|=
name|target
operator|.
name|getExpressions
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|nodeRightAliases
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|expr
operator|.
name|add
argument_list|(
name|node
operator|.
name|getExpressions
argument_list|()
operator|.
name|get
argument_list|(
name|i
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|ArrayList
argument_list|<
name|ArrayList
argument_list|<
name|ASTNode
argument_list|>
argument_list|>
name|filters
init|=
name|target
operator|.
name|getFilters
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|nodeRightAliases
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|filters
operator|.
name|add
argument_list|(
name|node
operator|.
name|getFilters
argument_list|()
operator|.
name|get
argument_list|(
name|i
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|ArrayList
argument_list|<
name|ArrayList
argument_list|<
name|ASTNode
argument_list|>
argument_list|>
name|filter
init|=
name|target
operator|.
name|getFiltersForPushing
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|nodeRightAliases
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|filter
operator|.
name|add
argument_list|(
name|node
operator|.
name|getFiltersForPushing
argument_list|()
operator|.
name|get
argument_list|(
name|i
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|node
operator|.
name|getFiltersForPushing
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|size
argument_list|()
operator|!=
literal|0
condition|)
block|{
name|ArrayList
argument_list|<
name|ASTNode
argument_list|>
name|filterPos
init|=
name|filter
operator|.
name|get
argument_list|(
name|pos
argument_list|)
decl_stmt|;
name|filterPos
operator|.
name|addAll
argument_list|(
name|node
operator|.
name|getFiltersForPushing
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|qb
operator|.
name|getQbJoinTree
argument_list|()
operator|==
name|node
condition|)
block|{
name|qb
operator|.
name|setQbJoinTree
argument_list|(
name|node
operator|.
name|getJoinSrc
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|parent
operator|.
name|setJoinSrc
argument_list|(
name|node
operator|.
name|getJoinSrc
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|node
operator|.
name|getNoOuterJoin
argument_list|()
operator|&&
name|target
operator|.
name|getNoOuterJoin
argument_list|()
condition|)
block|{
name|target
operator|.
name|setNoOuterJoin
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|target
operator|.
name|setNoOuterJoin
argument_list|(
literal|false
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|node
operator|.
name|getNoSemiJoin
argument_list|()
operator|&&
name|target
operator|.
name|getNoSemiJoin
argument_list|()
condition|)
block|{
name|target
operator|.
name|setNoSemiJoin
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|target
operator|.
name|setNoSemiJoin
argument_list|(
literal|false
argument_list|)
expr_stmt|;
block|}
name|target
operator|.
name|mergeRHSSemijoin
argument_list|(
name|node
argument_list|)
expr_stmt|;
name|JoinCond
index|[]
name|nodeCondns
init|=
name|node
operator|.
name|getJoinCond
argument_list|()
decl_stmt|;
name|int
name|nodeCondnsSize
init|=
name|nodeCondns
operator|.
name|length
decl_stmt|;
name|JoinCond
index|[]
name|targetCondns
init|=
name|target
operator|.
name|getJoinCond
argument_list|()
decl_stmt|;
name|int
name|targetCondnsSize
init|=
name|targetCondns
operator|.
name|length
decl_stmt|;
name|JoinCond
index|[]
name|newCondns
init|=
operator|new
name|JoinCond
index|[
name|nodeCondnsSize
operator|+
name|targetCondnsSize
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|targetCondnsSize
condition|;
name|i
operator|++
control|)
block|{
name|newCondns
index|[
name|i
index|]
operator|=
name|targetCondns
index|[
name|i
index|]
expr_stmt|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|nodeCondnsSize
condition|;
name|i
operator|++
control|)
block|{
name|JoinCond
name|nodeCondn
init|=
name|nodeCondns
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|nodeCondn
operator|.
name|getLeft
argument_list|()
operator|==
literal|0
condition|)
block|{
name|nodeCondn
operator|.
name|setLeft
argument_list|(
name|pos
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|nodeCondn
operator|.
name|setLeft
argument_list|(
name|nodeCondn
operator|.
name|getLeft
argument_list|()
operator|+
name|targetCondnsSize
argument_list|)
expr_stmt|;
block|}
name|nodeCondn
operator|.
name|setRight
argument_list|(
name|nodeCondn
operator|.
name|getRight
argument_list|()
operator|+
name|targetCondnsSize
argument_list|)
expr_stmt|;
name|newCondns
index|[
name|targetCondnsSize
operator|+
name|i
index|]
operator|=
name|nodeCondn
expr_stmt|;
block|}
name|target
operator|.
name|setJoinCond
argument_list|(
name|newCondns
argument_list|)
expr_stmt|;
if|if
condition|(
name|target
operator|.
name|isMapSideJoin
argument_list|()
condition|)
block|{
assert|assert
name|node
operator|.
name|isMapSideJoin
argument_list|()
assert|;
name|List
argument_list|<
name|String
argument_list|>
name|mapAliases
init|=
name|target
operator|.
name|getMapAliases
argument_list|()
decl_stmt|;
for|for
control|(
name|String
name|mapTbl
range|:
name|node
operator|.
name|getMapAliases
argument_list|()
control|)
block|{
if|if
condition|(
operator|!
name|mapAliases
operator|.
name|contains
argument_list|(
name|mapTbl
argument_list|)
condition|)
block|{
name|mapAliases
operator|.
name|add
argument_list|(
name|mapTbl
argument_list|)
expr_stmt|;
block|}
block|}
name|target
operator|.
name|setMapAliases
argument_list|(
name|mapAliases
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
name|int
name|findMergePos
parameter_list|(
name|QBJoinTree
name|node
parameter_list|,
name|QBJoinTree
name|target
parameter_list|)
block|{
name|int
name|res
init|=
operator|-
literal|1
decl_stmt|;
name|String
name|leftAlias
init|=
name|node
operator|.
name|getLeftAlias
argument_list|()
decl_stmt|;
if|if
condition|(
name|leftAlias
operator|==
literal|null
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
name|ArrayList
argument_list|<
name|ASTNode
argument_list|>
name|nodeCondn
init|=
name|node
operator|.
name|getExpressions
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|ArrayList
argument_list|<
name|ASTNode
argument_list|>
name|targetCondn
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|leftAlias
operator|.
name|equals
argument_list|(
name|target
operator|.
name|getLeftAlias
argument_list|()
argument_list|)
condition|)
block|{
name|targetCondn
operator|=
name|target
operator|.
name|getExpressions
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|res
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|target
operator|.
name|getRightAliases
argument_list|()
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|leftAlias
operator|.
name|equals
argument_list|(
name|target
operator|.
name|getRightAliases
argument_list|()
index|[
name|i
index|]
argument_list|)
condition|)
block|{
name|targetCondn
operator|=
name|target
operator|.
name|getExpressions
argument_list|()
operator|.
name|get
argument_list|(
name|i
operator|+
literal|1
argument_list|)
expr_stmt|;
name|res
operator|=
name|i
operator|+
literal|1
expr_stmt|;
break|break;
block|}
block|}
block|}
if|if
condition|(
operator|(
name|targetCondn
operator|==
literal|null
operator|)
operator|||
operator|(
name|nodeCondn
operator|.
name|size
argument_list|()
operator|!=
name|targetCondn
operator|.
name|size
argument_list|()
operator|)
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|nodeCondn
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|nodeCondn
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|toStringTree
argument_list|()
operator|.
name|equals
argument_list|(
name|targetCondn
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|toStringTree
argument_list|()
argument_list|)
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
block|}
return|return
name|res
return|;
block|}
specifier|private
name|boolean
name|mergeJoinNodes
parameter_list|(
name|QB
name|qb
parameter_list|,
name|QBJoinTree
name|parent
parameter_list|,
name|QBJoinTree
name|node
parameter_list|,
name|QBJoinTree
name|target
parameter_list|)
block|{
if|if
condition|(
name|target
operator|==
literal|null
condition|)
block|{
return|return
literal|false
return|;
block|}
name|int
name|res
init|=
name|findMergePos
argument_list|(
name|node
argument_list|,
name|target
argument_list|)
decl_stmt|;
if|if
condition|(
name|res
operator|!=
operator|-
literal|1
condition|)
block|{
name|mergeJoins
argument_list|(
name|qb
argument_list|,
name|parent
argument_list|,
name|node
argument_list|,
name|target
argument_list|,
name|res
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
return|return
name|mergeJoinNodes
argument_list|(
name|qb
argument_list|,
name|parent
argument_list|,
name|node
argument_list|,
name|target
operator|.
name|getJoinSrc
argument_list|()
argument_list|)
return|;
block|}
specifier|private
name|void
name|mergeJoinTree
parameter_list|(
name|QB
name|qb
parameter_list|)
block|{
name|QBJoinTree
name|root
init|=
name|qb
operator|.
name|getQbJoinTree
argument_list|()
decl_stmt|;
name|QBJoinTree
name|parent
init|=
literal|null
decl_stmt|;
while|while
condition|(
name|root
operator|!=
literal|null
condition|)
block|{
name|boolean
name|merged
init|=
name|mergeJoinNodes
argument_list|(
name|qb
argument_list|,
name|parent
argument_list|,
name|root
argument_list|,
name|root
operator|.
name|getJoinSrc
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|parent
operator|==
literal|null
condition|)
block|{
if|if
condition|(
name|merged
condition|)
block|{
name|root
operator|=
name|qb
operator|.
name|getQbJoinTree
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|parent
operator|=
name|root
expr_stmt|;
name|root
operator|=
name|root
operator|.
name|getJoinSrc
argument_list|()
expr_stmt|;
block|}
block|}
else|else
block|{
name|parent
operator|=
name|parent
operator|.
name|getJoinSrc
argument_list|()
expr_stmt|;
name|root
operator|=
name|parent
operator|.
name|getJoinSrc
argument_list|()
expr_stmt|;
block|}
block|}
block|}
specifier|private
name|Operator
name|insertSelectAllPlanForGroupBy
parameter_list|(
name|String
name|dest
parameter_list|,
name|Operator
name|input
parameter_list|)
throws|throws
name|SemanticException
block|{
name|OpParseContext
name|inputCtx
init|=
name|opParseCtx
operator|.
name|get
argument_list|(
name|input
argument_list|)
decl_stmt|;
name|RowResolver
name|inputRR
init|=
name|inputCtx
operator|.
name|getRowResolver
argument_list|()
decl_stmt|;
name|ArrayList
argument_list|<
name|ColumnInfo
argument_list|>
name|columns
init|=
name|inputRR
operator|.
name|getColumnInfos
argument_list|()
decl_stmt|;
name|ArrayList
argument_list|<
name|ExprNodeDesc
argument_list|>
name|colList
init|=
operator|new
name|ArrayList
argument_list|<
name|ExprNodeDesc
argument_list|>
argument_list|()
decl_stmt|;
name|ArrayList
argument_list|<
name|String
argument_list|>
name|columnNames
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|columns
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|ColumnInfo
name|col
init|=
name|columns
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|colList
operator|.
name|add
argument_list|(
operator|new
name|ExprNodeColumnDesc
argument_list|(
name|col
operator|.
name|getType
argument_list|()
argument_list|,
name|col
operator|.
name|getInternalName
argument_list|()
argument_list|,
name|col
operator|.
name|getTabAlias
argument_list|()
argument_list|,
name|col
operator|.
name|getIsVirtualCol
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|columnNames
operator|.
name|add
argument_list|(
name|col
operator|.
name|getInternalName
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|Operator
name|output
init|=
name|putOpInsertMap
argument_list|(
name|OperatorFactory
operator|.
name|getAndMakeChild
argument_list|(
operator|new
name|SelectDesc
argument_list|(
name|colList
argument_list|,
name|columnNames
argument_list|,
literal|true
argument_list|)
argument_list|,
operator|new
name|RowSchema
argument_list|(
name|inputRR
operator|.
name|getColumnInfos
argument_list|()
argument_list|)
argument_list|,
name|input
argument_list|)
argument_list|,
name|inputRR
argument_list|)
decl_stmt|;
name|output
operator|.
name|setColumnExprMap
argument_list|(
name|input
operator|.
name|getColumnExprMap
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|output
return|;
block|}
comment|// Return the common distinct expression
comment|// There should be more than 1 destination, with group bys in all of them.
specifier|private
name|List
argument_list|<
name|ASTNode
argument_list|>
name|getCommonDistinctExprs
parameter_list|(
name|QB
name|qb
parameter_list|,
name|Operator
name|input
parameter_list|)
block|{
name|RowResolver
name|inputRR
init|=
name|opParseCtx
operator|.
name|get
argument_list|(
name|input
argument_list|)
operator|.
name|getRowResolver
argument_list|()
decl_stmt|;
name|QBParseInfo
name|qbp
init|=
name|qb
operator|.
name|getParseInfo
argument_list|()
decl_stmt|;
name|TreeSet
argument_list|<
name|String
argument_list|>
name|ks
init|=
operator|new
name|TreeSet
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
name|ks
operator|.
name|addAll
argument_list|(
name|qbp
operator|.
name|getClauseNames
argument_list|()
argument_list|)
expr_stmt|;
comment|// Go over all the destination tables
if|if
condition|(
name|ks
operator|.
name|size
argument_list|()
operator|<=
literal|1
condition|)
block|{
return|return
literal|null
return|;
block|}
name|List
argument_list|<
name|ExprNodeDesc
argument_list|>
name|oldList
init|=
literal|null
decl_stmt|;
name|List
argument_list|<
name|ASTNode
argument_list|>
name|oldASTList
init|=
literal|null
decl_stmt|;
for|for
control|(
name|String
name|dest
range|:
name|ks
control|)
block|{
comment|// If a filter is present, common processing is not possible
if|if
condition|(
name|qbp
operator|.
name|getWhrForClause
argument_list|(
name|dest
argument_list|)
operator|!=
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
if|if
condition|(
name|qbp
operator|.
name|getAggregationExprsForClause
argument_list|(
name|dest
argument_list|)
operator|.
name|size
argument_list|()
operator|==
literal|0
operator|&&
name|getGroupByForClause
argument_list|(
name|qbp
argument_list|,
name|dest
argument_list|)
operator|.
name|size
argument_list|()
operator|==
literal|0
condition|)
block|{
return|return
literal|null
return|;
block|}
comment|// All distinct expressions must be the same
name|List
argument_list|<
name|ASTNode
argument_list|>
name|list
init|=
name|qbp
operator|.
name|getDistinctFuncExprsForClause
argument_list|(
name|dest
argument_list|)
decl_stmt|;
if|if
condition|(
name|list
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return
literal|null
return|;
block|}
name|List
argument_list|<
name|ExprNodeDesc
argument_list|>
name|currDestList
init|=
operator|new
name|ArrayList
argument_list|<
name|ExprNodeDesc
argument_list|>
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|ASTNode
argument_list|>
name|currASTList
init|=
operator|new
name|ArrayList
argument_list|<
name|ASTNode
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|ASTNode
name|value
range|:
name|list
control|)
block|{
try|try
block|{
comment|// 0 is function name
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<
name|value
operator|.
name|getChildCount
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|ASTNode
name|parameter
init|=
operator|(
name|ASTNode
operator|)
name|value
operator|.
name|getChild
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|currDestList
operator|.
name|add
argument_list|(
name|genExprNodeDesc
argument_list|(
name|parameter
argument_list|,
name|inputRR
argument_list|)
argument_list|)
expr_stmt|;
name|currASTList
operator|.
name|add
argument_list|(
name|parameter
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|SemanticException
name|e
parameter_list|)
block|{
return|return
literal|null
return|;
block|}
if|if
condition|(
name|oldList
operator|==
literal|null
condition|)
block|{
name|oldList
operator|=
name|currDestList
expr_stmt|;
name|oldASTList
operator|=
name|currASTList
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|oldList
operator|.
name|size
argument_list|()
operator|!=
name|currDestList
operator|.
name|size
argument_list|()
condition|)
block|{
return|return
literal|null
return|;
block|}
for|for
control|(
name|int
name|pos
init|=
literal|0
init|;
name|pos
operator|<
name|oldList
operator|.
name|size
argument_list|()
condition|;
name|pos
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|oldList
operator|.
name|get
argument_list|(
name|pos
argument_list|)
operator|.
name|isSame
argument_list|(
name|currDestList
operator|.
name|get
argument_list|(
name|pos
argument_list|)
argument_list|)
condition|)
block|{
return|return
literal|null
return|;
block|}
block|}
block|}
block|}
block|}
return|return
name|oldASTList
return|;
block|}
specifier|private
name|Operator
name|createCommonReduceSink
parameter_list|(
name|QB
name|qb
parameter_list|,
name|Operator
name|input
parameter_list|)
throws|throws
name|SemanticException
block|{
comment|// Go over all the tables and extract the common distinct key
name|List
argument_list|<
name|ASTNode
argument_list|>
name|distExprs
init|=
name|getCommonDistinctExprs
argument_list|(
name|qb
argument_list|,
name|input
argument_list|)
decl_stmt|;
name|QBParseInfo
name|qbp
init|=
name|qb
operator|.
name|getParseInfo
argument_list|()
decl_stmt|;
name|TreeSet
argument_list|<
name|String
argument_list|>
name|ks
init|=
operator|new
name|TreeSet
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
name|ks
operator|.
name|addAll
argument_list|(
name|qbp
operator|.
name|getClauseNames
argument_list|()
argument_list|)
expr_stmt|;
comment|// Pass the entire row
name|RowResolver
name|inputRR
init|=
name|opParseCtx
operator|.
name|get
argument_list|(
name|input
argument_list|)
operator|.
name|getRowResolver
argument_list|()
decl_stmt|;
name|RowResolver
name|reduceSinkOutputRowResolver
init|=
operator|new
name|RowResolver
argument_list|()
decl_stmt|;
name|reduceSinkOutputRowResolver
operator|.
name|setIsExprResolver
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|ArrayList
argument_list|<
name|ExprNodeDesc
argument_list|>
name|reduceKeys
init|=
operator|new
name|ArrayList
argument_list|<
name|ExprNodeDesc
argument_list|>
argument_list|()
decl_stmt|;
name|ArrayList
argument_list|<
name|ExprNodeDesc
argument_list|>
name|reduceValues
init|=
operator|new
name|ArrayList
argument_list|<
name|ExprNodeDesc
argument_list|>
argument_list|()
decl_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|ExprNodeDesc
argument_list|>
name|colExprMap
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|ExprNodeDesc
argument_list|>
argument_list|()
decl_stmt|;
comment|// Pre-compute distinct group-by keys and store in reduceKeys
name|List
argument_list|<
name|String
argument_list|>
name|outputColumnNames
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|ASTNode
name|distn
range|:
name|distExprs
control|)
block|{
name|ExprNodeDesc
name|distExpr
init|=
name|genExprNodeDesc
argument_list|(
name|distn
argument_list|,
name|inputRR
argument_list|)
decl_stmt|;
name|reduceKeys
operator|.
name|add
argument_list|(
name|distExpr
argument_list|)
expr_stmt|;
if|if
condition|(
name|reduceSinkOutputRowResolver
operator|.
name|getExpression
argument_list|(
name|distn
argument_list|)
operator|==
literal|null
condition|)
block|{
name|outputColumnNames
operator|.
name|add
argument_list|(
name|getColumnInternalName
argument_list|(
name|reduceKeys
operator|.
name|size
argument_list|()
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|String
name|field
init|=
name|Utilities
operator|.
name|ReduceField
operator|.
name|KEY
operator|.
name|toString
argument_list|()
operator|+
literal|"."
operator|+
name|getColumnInternalName
argument_list|(
name|reduceKeys
operator|.
name|size
argument_list|()
operator|-
literal|1
argument_list|)
decl_stmt|;
name|ColumnInfo
name|colInfo
init|=
operator|new
name|ColumnInfo
argument_list|(
name|field
argument_list|,
name|reduceKeys
operator|.
name|get
argument_list|(
name|reduceKeys
operator|.
name|size
argument_list|()
operator|-
literal|1
argument_list|)
operator|.
name|getTypeInfo
argument_list|()
argument_list|,
literal|""
argument_list|,
literal|false
argument_list|)
decl_stmt|;
name|reduceSinkOutputRowResolver
operator|.
name|putExpression
argument_list|(
name|distn
argument_list|,
name|colInfo
argument_list|)
expr_stmt|;
name|colExprMap
operator|.
name|put
argument_list|(
name|colInfo
operator|.
name|getInternalName
argument_list|()
argument_list|,
name|distExpr
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Go over all the grouping keys and aggregations
for|for
control|(
name|String
name|dest
range|:
name|ks
control|)
block|{
name|List
argument_list|<
name|ASTNode
argument_list|>
name|grpByExprs
init|=
name|getGroupByForClause
argument_list|(
name|qbp
argument_list|,
name|dest
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|grpByExprs
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|ASTNode
name|grpbyExpr
init|=
name|grpByExprs
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|reduceSinkOutputRowResolver
operator|.
name|getExpression
argument_list|(
name|grpbyExpr
argument_list|)
operator|==
literal|null
condition|)
block|{
name|ExprNodeDesc
name|grpByExprNode
init|=
name|genExprNodeDesc
argument_list|(
name|grpbyExpr
argument_list|,
name|inputRR
argument_list|)
decl_stmt|;
name|reduceValues
operator|.
name|add
argument_list|(
name|grpByExprNode
argument_list|)
expr_stmt|;
name|String
name|field
init|=
name|Utilities
operator|.
name|ReduceField
operator|.
name|VALUE
operator|.
name|toString
argument_list|()
operator|+
literal|"."
operator|+
name|getColumnInternalName
argument_list|(
name|reduceValues
operator|.
name|size
argument_list|()
operator|-
literal|1
argument_list|)
decl_stmt|;
name|ColumnInfo
name|colInfo
init|=
operator|new
name|ColumnInfo
argument_list|(
name|field
argument_list|,
name|reduceValues
operator|.
name|get
argument_list|(
name|reduceValues
operator|.
name|size
argument_list|()
operator|-
literal|1
argument_list|)
operator|.
name|getTypeInfo
argument_list|()
argument_list|,
literal|""
argument_list|,
literal|false
argument_list|)
decl_stmt|;
name|reduceSinkOutputRowResolver
operator|.
name|putExpression
argument_list|(
name|grpbyExpr
argument_list|,
name|colInfo
argument_list|)
expr_stmt|;
name|outputColumnNames
operator|.
name|add
argument_list|(
name|getColumnInternalName
argument_list|(
name|reduceValues
operator|.
name|size
argument_list|()
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|// For each aggregation
name|HashMap
argument_list|<
name|String
argument_list|,
name|ASTNode
argument_list|>
name|aggregationTrees
init|=
name|qbp
operator|.
name|getAggregationExprsForClause
argument_list|(
name|dest
argument_list|)
decl_stmt|;
assert|assert
operator|(
name|aggregationTrees
operator|!=
literal|null
operator|)
assert|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|ASTNode
argument_list|>
name|entry
range|:
name|aggregationTrees
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|ASTNode
name|value
init|=
name|entry
operator|.
name|getValue
argument_list|()
decl_stmt|;
name|value
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getText
argument_list|()
expr_stmt|;
comment|// 0 is the function name
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<
name|value
operator|.
name|getChildCount
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|ASTNode
name|paraExpr
init|=
operator|(
name|ASTNode
operator|)
name|value
operator|.
name|getChild
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|reduceSinkOutputRowResolver
operator|.
name|getExpression
argument_list|(
name|paraExpr
argument_list|)
operator|==
literal|null
condition|)
block|{
name|ExprNodeDesc
name|paraExprNode
init|=
name|genExprNodeDesc
argument_list|(
name|paraExpr
argument_list|,
name|inputRR
argument_list|)
decl_stmt|;
name|reduceValues
operator|.
name|add
argument_list|(
name|paraExprNode
argument_list|)
expr_stmt|;
name|String
name|field
init|=
name|Utilities
operator|.
name|ReduceField
operator|.
name|VALUE
operator|.
name|toString
argument_list|()
operator|+
literal|"."
operator|+
name|getColumnInternalName
argument_list|(
name|reduceValues
operator|.
name|size
argument_list|()
operator|-
literal|1
argument_list|)
decl_stmt|;
name|ColumnInfo
name|colInfo
init|=
operator|new
name|ColumnInfo
argument_list|(
name|field
argument_list|,
name|reduceValues
operator|.
name|get
argument_list|(
name|reduceValues
operator|.
name|size
argument_list|()
operator|-
literal|1
argument_list|)
operator|.
name|getTypeInfo
argument_list|()
argument_list|,
literal|""
argument_list|,
literal|false
argument_list|)
decl_stmt|;
name|reduceSinkOutputRowResolver
operator|.
name|putExpression
argument_list|(
name|paraExpr
argument_list|,
name|colInfo
argument_list|)
expr_stmt|;
name|outputColumnNames
operator|.
name|add
argument_list|(
name|getColumnInternalName
argument_list|(
name|reduceValues
operator|.
name|size
argument_list|()
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
name|ReduceSinkOperator
name|rsOp
init|=
operator|(
name|ReduceSinkOperator
operator|)
name|putOpInsertMap
argument_list|(
name|OperatorFactory
operator|.
name|getAndMakeChild
argument_list|(
name|PlanUtils
operator|.
name|getReduceSinkDesc
argument_list|(
name|reduceKeys
argument_list|,
name|reduceValues
argument_list|,
name|outputColumnNames
argument_list|,
literal|true
argument_list|,
operator|-
literal|1
argument_list|,
name|reduceKeys
operator|.
name|size
argument_list|()
argument_list|,
operator|-
literal|1
argument_list|)
argument_list|,
operator|new
name|RowSchema
argument_list|(
name|reduceSinkOutputRowResolver
operator|.
name|getColumnInfos
argument_list|()
argument_list|)
argument_list|,
name|input
argument_list|)
argument_list|,
name|reduceSinkOutputRowResolver
argument_list|)
decl_stmt|;
name|rsOp
operator|.
name|setColumnExprMap
argument_list|(
name|colExprMap
argument_list|)
expr_stmt|;
return|return
name|rsOp
return|;
block|}
comment|// see if there are any distinct expressions
specifier|private
name|boolean
name|distinctExprsExists
parameter_list|(
name|QB
name|qb
parameter_list|)
block|{
name|QBParseInfo
name|qbp
init|=
name|qb
operator|.
name|getParseInfo
argument_list|()
decl_stmt|;
name|TreeSet
argument_list|<
name|String
argument_list|>
name|ks
init|=
operator|new
name|TreeSet
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
name|ks
operator|.
name|addAll
argument_list|(
name|qbp
operator|.
name|getClauseNames
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|String
name|dest
range|:
name|ks
control|)
block|{
name|List
argument_list|<
name|ASTNode
argument_list|>
name|list
init|=
name|qbp
operator|.
name|getDistinctFuncExprsForClause
argument_list|(
name|dest
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|list
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return
literal|true
return|;
block|}
block|}
return|return
literal|false
return|;
block|}
comment|// return the common group by key set.
comment|// Null if there are no common group by keys.
specifier|private
name|List
argument_list|<
name|ASTNode
argument_list|>
name|getCommonGroupbyKeys
parameter_list|(
name|QB
name|qb
parameter_list|,
name|Operator
name|input
parameter_list|)
block|{
name|RowResolver
name|inputRR
init|=
name|opParseCtx
operator|.
name|get
argument_list|(
name|input
argument_list|)
operator|.
name|getRowResolver
argument_list|()
decl_stmt|;
name|QBParseInfo
name|qbp
init|=
name|qb
operator|.
name|getParseInfo
argument_list|()
decl_stmt|;
name|Set
argument_list|<
name|String
argument_list|>
name|ks
init|=
name|qbp
operator|.
name|getClauseNames
argument_list|()
decl_stmt|;
comment|// Go over all the destination tables
if|if
condition|(
name|ks
operator|.
name|size
argument_list|()
operator|<=
literal|1
condition|)
block|{
return|return
literal|null
return|;
block|}
name|List
argument_list|<
name|ASTNode
argument_list|>
name|oldList
init|=
literal|null
decl_stmt|;
for|for
control|(
name|String
name|dest
range|:
name|ks
control|)
block|{
comment|// If a filter is present, common processing is not possible
if|if
condition|(
name|qbp
operator|.
name|getWhrForClause
argument_list|(
name|dest
argument_list|)
operator|!=
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
comment|//  if one of the sub-queries does not involve an aggregation, common
comment|// processing is not possible
name|List
argument_list|<
name|ASTNode
argument_list|>
name|list
init|=
name|getGroupByForClause
argument_list|(
name|qbp
argument_list|,
name|dest
argument_list|)
decl_stmt|;
if|if
condition|(
name|list
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return
literal|null
return|;
block|}
if|if
condition|(
name|oldList
operator|==
literal|null
condition|)
block|{
name|oldList
operator|=
operator|new
name|ArrayList
argument_list|<
name|ASTNode
argument_list|>
argument_list|()
expr_stmt|;
name|oldList
operator|.
name|addAll
argument_list|(
name|list
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|int
name|pos
init|=
literal|0
decl_stmt|;
for|for
control|(
name|pos
operator|=
literal|0
init|;
name|pos
operator|<
name|oldList
operator|.
name|size
argument_list|()
condition|;
name|pos
operator|++
control|)
block|{
if|if
condition|(
name|pos
operator|<
name|list
operator|.
name|size
argument_list|()
condition|)
block|{
if|if
condition|(
operator|!
name|oldList
operator|.
name|get
argument_list|(
name|pos
argument_list|)
operator|.
name|toStringTree
argument_list|()
operator|.
name|equals
argument_list|(
name|list
operator|.
name|get
argument_list|(
name|pos
argument_list|)
operator|.
name|toStringTree
argument_list|()
argument_list|)
condition|)
block|{
break|break;
block|}
block|}
else|else
block|{
break|break;
block|}
block|}
name|oldList
operator|=
name|oldList
operator|.
name|subList
argument_list|(
literal|0
argument_list|,
name|pos
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|oldList
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return
literal|null
return|;
block|}
block|}
return|return
name|oldList
return|;
block|}
comment|/**    * Generates reduce sink for multigroupby query for non null common groupby set    *    *All groupby keys and distinct exprs are added to reduce keys. And rows are    *partitioned on common groupby key set.    *    * @param qb    * @param input    * @return    * @throws SemanticException    */
specifier|private
name|Operator
name|createCommonReduceSink1
parameter_list|(
name|QB
name|qb
parameter_list|,
name|Operator
name|input
parameter_list|)
throws|throws
name|SemanticException
block|{
comment|// Go over all the tables and get common groupby key
name|List
argument_list|<
name|ASTNode
argument_list|>
name|cmonGbyExprs
init|=
name|getCommonGroupbyKeys
argument_list|(
name|qb
argument_list|,
name|input
argument_list|)
decl_stmt|;
name|QBParseInfo
name|qbp
init|=
name|qb
operator|.
name|getParseInfo
argument_list|()
decl_stmt|;
name|TreeSet
argument_list|<
name|String
argument_list|>
name|ks
init|=
operator|new
name|TreeSet
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
name|ks
operator|.
name|addAll
argument_list|(
name|qbp
operator|.
name|getClauseNames
argument_list|()
argument_list|)
expr_stmt|;
comment|// Pass the entire row
name|RowResolver
name|inputRR
init|=
name|opParseCtx
operator|.
name|get
argument_list|(
name|input
argument_list|)
operator|.
name|getRowResolver
argument_list|()
decl_stmt|;
name|RowResolver
name|reduceSinkOutputRowResolver
init|=
operator|new
name|RowResolver
argument_list|()
decl_stmt|;
name|reduceSinkOutputRowResolver
operator|.
name|setIsExprResolver
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|ArrayList
argument_list|<
name|ExprNodeDesc
argument_list|>
name|reduceKeys
init|=
operator|new
name|ArrayList
argument_list|<
name|ExprNodeDesc
argument_list|>
argument_list|()
decl_stmt|;
name|ArrayList
argument_list|<
name|ExprNodeDesc
argument_list|>
name|reducePartKeys
init|=
operator|new
name|ArrayList
argument_list|<
name|ExprNodeDesc
argument_list|>
argument_list|()
decl_stmt|;
name|ArrayList
argument_list|<
name|ExprNodeDesc
argument_list|>
name|reduceValues
init|=
operator|new
name|ArrayList
argument_list|<
name|ExprNodeDesc
argument_list|>
argument_list|()
decl_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|ExprNodeDesc
argument_list|>
name|colExprMap
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|ExprNodeDesc
argument_list|>
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|outputColumnNames
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|String
name|dest
range|:
name|ks
control|)
block|{
name|List
argument_list|<
name|ASTNode
argument_list|>
name|grpByExprs
init|=
name|getGroupByForClause
argument_list|(
name|qbp
argument_list|,
name|dest
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|grpByExprs
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|ASTNode
name|grpbyExpr
init|=
name|grpByExprs
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|reduceSinkOutputRowResolver
operator|.
name|getExpression
argument_list|(
name|grpbyExpr
argument_list|)
operator|==
literal|null
condition|)
block|{
name|ExprNodeDesc
name|grpByExprNode
init|=
name|genExprNodeDesc
argument_list|(
name|grpbyExpr
argument_list|,
name|inputRR
argument_list|)
decl_stmt|;
name|reduceKeys
operator|.
name|add
argument_list|(
name|grpByExprNode
argument_list|)
expr_stmt|;
name|String
name|field
init|=
name|Utilities
operator|.
name|ReduceField
operator|.
name|KEY
operator|.
name|toString
argument_list|()
operator|+
literal|"."
operator|+
name|getColumnInternalName
argument_list|(
name|reduceKeys
operator|.
name|size
argument_list|()
operator|-
literal|1
argument_list|)
decl_stmt|;
name|ColumnInfo
name|colInfo
init|=
operator|new
name|ColumnInfo
argument_list|(
name|field
argument_list|,
name|reduceKeys
operator|.
name|get
argument_list|(
name|reduceKeys
operator|.
name|size
argument_list|()
operator|-
literal|1
argument_list|)
operator|.
name|getTypeInfo
argument_list|()
argument_list|,
literal|""
argument_list|,
literal|false
argument_list|)
decl_stmt|;
name|reduceSinkOutputRowResolver
operator|.
name|putExpression
argument_list|(
name|grpbyExpr
argument_list|,
name|colInfo
argument_list|)
expr_stmt|;
name|outputColumnNames
operator|.
name|add
argument_list|(
name|getColumnInternalName
argument_list|(
name|reduceKeys
operator|.
name|size
argument_list|()
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|colExprMap
operator|.
name|put
argument_list|(
name|colInfo
operator|.
name|getInternalName
argument_list|()
argument_list|,
name|grpByExprNode
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|// Add distinct group-by exprs to reduceKeys
name|List
argument_list|<
name|ASTNode
argument_list|>
name|distExprs
init|=
name|getCommonDistinctExprs
argument_list|(
name|qb
argument_list|,
name|input
argument_list|)
decl_stmt|;
if|if
condition|(
name|distExprs
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|ASTNode
name|distn
range|:
name|distExprs
control|)
block|{
if|if
condition|(
name|reduceSinkOutputRowResolver
operator|.
name|getExpression
argument_list|(
name|distn
argument_list|)
operator|==
literal|null
condition|)
block|{
name|ExprNodeDesc
name|distExpr
init|=
name|genExprNodeDesc
argument_list|(
name|distn
argument_list|,
name|inputRR
argument_list|)
decl_stmt|;
name|reduceKeys
operator|.
name|add
argument_list|(
name|distExpr
argument_list|)
expr_stmt|;
name|String
name|field
init|=
name|Utilities
operator|.
name|ReduceField
operator|.
name|KEY
operator|.
name|toString
argument_list|()
operator|+
literal|"."
operator|+
name|getColumnInternalName
argument_list|(
name|reduceKeys
operator|.
name|size
argument_list|()
operator|-
literal|1
argument_list|)
decl_stmt|;
name|ColumnInfo
name|colInfo
init|=
operator|new
name|ColumnInfo
argument_list|(
name|field
argument_list|,
name|reduceKeys
operator|.
name|get
argument_list|(
name|reduceKeys
operator|.
name|size
argument_list|()
operator|-
literal|1
argument_list|)
operator|.
name|getTypeInfo
argument_list|()
argument_list|,
literal|""
argument_list|,
literal|false
argument_list|)
decl_stmt|;
name|reduceSinkOutputRowResolver
operator|.
name|putExpression
argument_list|(
name|distn
argument_list|,
name|colInfo
argument_list|)
expr_stmt|;
name|outputColumnNames
operator|.
name|add
argument_list|(
name|getColumnInternalName
argument_list|(
name|reduceKeys
operator|.
name|size
argument_list|()
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|colExprMap
operator|.
name|put
argument_list|(
name|colInfo
operator|.
name|getInternalName
argument_list|()
argument_list|,
name|distExpr
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|// Add common groupby keys to partition keys
for|for
control|(
name|ASTNode
name|gby
range|:
name|cmonGbyExprs
control|)
block|{
name|ExprNodeDesc
name|distExpr
init|=
name|genExprNodeDesc
argument_list|(
name|gby
argument_list|,
name|inputRR
argument_list|)
decl_stmt|;
name|reducePartKeys
operator|.
name|add
argument_list|(
name|distExpr
argument_list|)
expr_stmt|;
block|}
comment|// Go over all the aggregations
for|for
control|(
name|String
name|dest
range|:
name|ks
control|)
block|{
comment|// For each aggregation
name|HashMap
argument_list|<
name|String
argument_list|,
name|ASTNode
argument_list|>
name|aggregationTrees
init|=
name|qbp
operator|.
name|getAggregationExprsForClause
argument_list|(
name|dest
argument_list|)
decl_stmt|;
assert|assert
operator|(
name|aggregationTrees
operator|!=
literal|null
operator|)
assert|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|ASTNode
argument_list|>
name|entry
range|:
name|aggregationTrees
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|ASTNode
name|value
init|=
name|entry
operator|.
name|getValue
argument_list|()
decl_stmt|;
name|value
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getText
argument_list|()
expr_stmt|;
comment|// 0 is the function name
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<
name|value
operator|.
name|getChildCount
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|ASTNode
name|paraExpr
init|=
operator|(
name|ASTNode
operator|)
name|value
operator|.
name|getChild
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|reduceSinkOutputRowResolver
operator|.
name|getExpression
argument_list|(
name|paraExpr
argument_list|)
operator|==
literal|null
condition|)
block|{
name|ExprNodeDesc
name|paraExprNode
init|=
name|genExprNodeDesc
argument_list|(
name|paraExpr
argument_list|,
name|inputRR
argument_list|)
decl_stmt|;
name|reduceValues
operator|.
name|add
argument_list|(
name|paraExprNode
argument_list|)
expr_stmt|;
name|String
name|field
init|=
name|Utilities
operator|.
name|ReduceField
operator|.
name|VALUE
operator|.
name|toString
argument_list|()
operator|+
literal|"."
operator|+
name|getColumnInternalName
argument_list|(
name|reduceValues
operator|.
name|size
argument_list|()
operator|-
literal|1
argument_list|)
decl_stmt|;
name|ColumnInfo
name|colInfo
init|=
operator|new
name|ColumnInfo
argument_list|(
name|field
argument_list|,
name|reduceValues
operator|.
name|get
argument_list|(
name|reduceValues
operator|.
name|size
argument_list|()
operator|-
literal|1
argument_list|)
operator|.
name|getTypeInfo
argument_list|()
argument_list|,
literal|""
argument_list|,
literal|false
argument_list|)
decl_stmt|;
name|reduceSinkOutputRowResolver
operator|.
name|putExpression
argument_list|(
name|paraExpr
argument_list|,
name|colInfo
argument_list|)
expr_stmt|;
name|outputColumnNames
operator|.
name|add
argument_list|(
name|getColumnInternalName
argument_list|(
name|reduceValues
operator|.
name|size
argument_list|()
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
name|StringBuilder
name|order
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|reduceKeys
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|order
operator|.
name|append
argument_list|(
literal|"+"
argument_list|)
expr_stmt|;
block|}
name|ReduceSinkOperator
name|rsOp
init|=
operator|(
name|ReduceSinkOperator
operator|)
name|putOpInsertMap
argument_list|(
name|OperatorFactory
operator|.
name|getAndMakeChild
argument_list|(
name|PlanUtils
operator|.
name|getReduceSinkDesc
argument_list|(
name|reduceKeys
argument_list|,
name|reduceValues
argument_list|,
name|outputColumnNames
argument_list|,
literal|true
argument_list|,
operator|-
literal|1
argument_list|,
name|reducePartKeys
argument_list|,
name|order
operator|.
name|toString
argument_list|()
argument_list|,
operator|-
literal|1
argument_list|)
argument_list|,
operator|new
name|RowSchema
argument_list|(
name|reduceSinkOutputRowResolver
operator|.
name|getColumnInfos
argument_list|()
argument_list|)
argument_list|,
name|input
argument_list|)
argument_list|,
name|reduceSinkOutputRowResolver
argument_list|)
decl_stmt|;
name|rsOp
operator|.
name|setColumnExprMap
argument_list|(
name|colExprMap
argument_list|)
expr_stmt|;
return|return
name|rsOp
return|;
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"nls"
argument_list|)
specifier|private
name|Operator
name|genBodyPlan
parameter_list|(
name|QB
name|qb
parameter_list|,
name|Operator
name|input
parameter_list|)
throws|throws
name|SemanticException
block|{
name|QBParseInfo
name|qbp
init|=
name|qb
operator|.
name|getParseInfo
argument_list|()
decl_stmt|;
name|TreeSet
argument_list|<
name|String
argument_list|>
name|ks
init|=
operator|new
name|TreeSet
argument_list|<
name|String
argument_list|>
argument_list|(
name|qbp
operator|.
name|getClauseNames
argument_list|()
argument_list|)
decl_stmt|;
comment|// For multi-group by with the same distinct, we ignore all user hints
comment|// currently. It doesnt matter whether he has asked to do
comment|// map-side aggregation or not. Map side aggregation is turned off
name|List
argument_list|<
name|ASTNode
argument_list|>
name|commonDistinctExprs
init|=
name|getCommonDistinctExprs
argument_list|(
name|qb
argument_list|,
name|input
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|ASTNode
argument_list|>
name|commonGbyKeys
init|=
name|getCommonGroupbyKeys
argument_list|(
name|qb
argument_list|,
name|input
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|warn
argument_list|(
literal|"Common Gby keys:"
operator|+
name|commonGbyKeys
argument_list|)
expr_stmt|;
name|boolean
name|optimizeMultiGroupBy
init|=
name|commonDistinctExprs
operator|!=
literal|null
decl_stmt|;
comment|// Generate single MR job for multigroupby query if query has non-null common
comment|// groupby key set and there are zero or one common distinct expression.
name|boolean
name|singlemrMultiGroupBy
init|=
name|conf
operator|.
name|getBoolVar
argument_list|(
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVEMULTIGROUPBYSINGLEMR
argument_list|)
operator|&&
name|commonGbyKeys
operator|!=
literal|null
operator|&&
operator|!
name|commonGbyKeys
operator|.
name|isEmpty
argument_list|()
operator|&&
operator|(
operator|!
name|distinctExprsExists
argument_list|(
name|qb
argument_list|)
operator|||
name|commonDistinctExprs
operator|!=
literal|null
operator|)
decl_stmt|;
name|Operator
name|curr
init|=
name|input
decl_stmt|;
comment|// If there are multiple group-bys, map-side aggregation is turned off,
comment|// and there are no filters.
comment|// if there is a common groupby key set, spray by the common groupby key set
comment|// and generate single mr job
if|if
condition|(
name|singlemrMultiGroupBy
condition|)
block|{
name|curr
operator|=
name|createCommonReduceSink1
argument_list|(
name|qb
argument_list|,
name|input
argument_list|)
expr_stmt|;
name|RowResolver
name|currRR
init|=
name|opParseCtx
operator|.
name|get
argument_list|(
name|curr
argument_list|)
operator|.
name|getRowResolver
argument_list|()
decl_stmt|;
comment|// create a forward operator
name|input
operator|=
name|putOpInsertMap
argument_list|(
name|OperatorFactory
operator|.
name|getAndMakeChild
argument_list|(
operator|new
name|ForwardDesc
argument_list|()
argument_list|,
operator|new
name|RowSchema
argument_list|(
name|currRR
operator|.
name|getColumnInfos
argument_list|()
argument_list|)
argument_list|,
name|curr
argument_list|)
argument_list|,
name|currRR
argument_list|)
expr_stmt|;
for|for
control|(
name|String
name|dest
range|:
name|ks
control|)
block|{
name|curr
operator|=
name|input
expr_stmt|;
name|curr
operator|=
name|genGroupByPlan1MRMultiGroupBy
argument_list|(
name|dest
argument_list|,
name|qb
argument_list|,
name|curr
argument_list|)
expr_stmt|;
name|curr
operator|=
name|genSelectPlan
argument_list|(
name|dest
argument_list|,
name|qb
argument_list|,
name|curr
argument_list|)
expr_stmt|;
name|Integer
name|limit
init|=
name|qbp
operator|.
name|getDestLimit
argument_list|(
name|dest
argument_list|)
decl_stmt|;
if|if
condition|(
name|limit
operator|!=
literal|null
condition|)
block|{
name|curr
operator|=
name|genLimitMapRedPlan
argument_list|(
name|dest
argument_list|,
name|qb
argument_list|,
name|curr
argument_list|,
name|limit
operator|.
name|intValue
argument_list|()
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|qb
operator|.
name|getParseInfo
argument_list|()
operator|.
name|setOuterQueryLimit
argument_list|(
name|limit
operator|.
name|intValue
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|curr
operator|=
name|genFileSinkPlan
argument_list|(
name|dest
argument_list|,
name|qb
argument_list|,
name|curr
argument_list|)
expr_stmt|;
block|}
block|}
comment|// and if there is a single distinct, optimize that. Spray initially by the
comment|// distinct key,
comment|// no computation at the mapper. Have multiple group by operators at the
comment|// reducer - and then
comment|// proceed
elseif|else
if|if
condition|(
name|optimizeMultiGroupBy
condition|)
block|{
name|curr
operator|=
name|createCommonReduceSink
argument_list|(
name|qb
argument_list|,
name|input
argument_list|)
expr_stmt|;
name|RowResolver
name|currRR
init|=
name|opParseCtx
operator|.
name|get
argument_list|(
name|curr
argument_list|)
operator|.
name|getRowResolver
argument_list|()
decl_stmt|;
comment|// create a forward operator
name|input
operator|=
name|putOpInsertMap
argument_list|(
name|OperatorFactory
operator|.
name|getAndMakeChild
argument_list|(
operator|new
name|ForwardDesc
argument_list|()
argument_list|,
operator|new
name|RowSchema
argument_list|(
name|currRR
operator|.
name|getColumnInfos
argument_list|()
argument_list|)
argument_list|,
name|curr
argument_list|)
argument_list|,
name|currRR
argument_list|)
expr_stmt|;
for|for
control|(
name|String
name|dest
range|:
name|ks
control|)
block|{
name|curr
operator|=
name|input
expr_stmt|;
name|curr
operator|=
name|genGroupByPlan2MRMultiGroupBy
argument_list|(
name|dest
argument_list|,
name|qb
argument_list|,
name|curr
argument_list|)
expr_stmt|;
name|curr
operator|=
name|genSelectPlan
argument_list|(
name|dest
argument_list|,
name|qb
argument_list|,
name|curr
argument_list|)
expr_stmt|;
name|Integer
name|limit
init|=
name|qbp
operator|.
name|getDestLimit
argument_list|(
name|dest
argument_list|)
decl_stmt|;
if|if
condition|(
name|limit
operator|!=
literal|null
condition|)
block|{
name|curr
operator|=
name|genLimitMapRedPlan
argument_list|(
name|dest
argument_list|,
name|qb
argument_list|,
name|curr
argument_list|,
name|limit
operator|.
name|intValue
argument_list|()
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|qb
operator|.
name|getParseInfo
argument_list|()
operator|.
name|setOuterQueryLimit
argument_list|(
name|limit
operator|.
name|intValue
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|curr
operator|=
name|genFileSinkPlan
argument_list|(
name|dest
argument_list|,
name|qb
argument_list|,
name|curr
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// Go over all the destination tables
for|for
control|(
name|String
name|dest
range|:
name|ks
control|)
block|{
name|curr
operator|=
name|input
expr_stmt|;
if|if
condition|(
name|qbp
operator|.
name|getWhrForClause
argument_list|(
name|dest
argument_list|)
operator|!=
literal|null
condition|)
block|{
name|curr
operator|=
name|genFilterPlan
argument_list|(
name|dest
argument_list|,
name|qb
argument_list|,
name|curr
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|qbp
operator|.
name|getAggregationExprsForClause
argument_list|(
name|dest
argument_list|)
operator|.
name|size
argument_list|()
operator|!=
literal|0
operator|||
name|getGroupByForClause
argument_list|(
name|qbp
argument_list|,
name|dest
argument_list|)
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
comment|//multiple distincts is not supported with skew in data
if|if
condition|(
name|conf
operator|.
name|getBoolVar
argument_list|(
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVEGROUPBYSKEW
argument_list|)
operator|&&
name|qbp
operator|.
name|getDistinctFuncExprsForClause
argument_list|(
name|dest
argument_list|)
operator|.
name|size
argument_list|()
operator|>
literal|1
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|UNSUPPORTED_MULTIPLE_DISTINCTS
operator|.
name|getMsg
argument_list|()
argument_list|)
throw|;
block|}
comment|// insert a select operator here used by the ColumnPruner to reduce
comment|// the data to shuffle
name|curr
operator|=
name|insertSelectAllPlanForGroupBy
argument_list|(
name|dest
argument_list|,
name|curr
argument_list|)
expr_stmt|;
if|if
condition|(
name|conf
operator|.
name|getBoolVar
argument_list|(
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVEMAPSIDEAGGREGATE
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|conf
operator|.
name|getBoolVar
argument_list|(
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVEGROUPBYSKEW
argument_list|)
condition|)
block|{
name|curr
operator|=
name|genGroupByPlanMapAggr1MR
argument_list|(
name|dest
argument_list|,
name|qb
argument_list|,
name|curr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|curr
operator|=
name|genGroupByPlanMapAggr2MR
argument_list|(
name|dest
argument_list|,
name|qb
argument_list|,
name|curr
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|conf
operator|.
name|getBoolVar
argument_list|(
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVEGROUPBYSKEW
argument_list|)
condition|)
block|{
name|curr
operator|=
name|genGroupByPlan2MR
argument_list|(
name|dest
argument_list|,
name|qb
argument_list|,
name|curr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|curr
operator|=
name|genGroupByPlan1MR
argument_list|(
name|dest
argument_list|,
name|qb
argument_list|,
name|curr
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Insert HAVING plan here
if|if
condition|(
name|qbp
operator|.
name|getHavingForClause
argument_list|(
name|dest
argument_list|)
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|getGroupByForClause
argument_list|(
name|qbp
argument_list|,
name|dest
argument_list|)
operator|.
name|size
argument_list|()
operator|==
literal|0
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
literal|"HAVING specified without GROUP BY"
argument_list|)
throw|;
block|}
name|curr
operator|=
name|genHavingPlan
argument_list|(
name|dest
argument_list|,
name|qb
argument_list|,
name|curr
argument_list|)
expr_stmt|;
block|}
name|curr
operator|=
name|genSelectPlan
argument_list|(
name|dest
argument_list|,
name|qb
argument_list|,
name|curr
argument_list|)
expr_stmt|;
name|Integer
name|limit
init|=
name|qbp
operator|.
name|getDestLimit
argument_list|(
name|dest
argument_list|)
decl_stmt|;
if|if
condition|(
name|qbp
operator|.
name|getClusterByForClause
argument_list|(
name|dest
argument_list|)
operator|!=
literal|null
operator|||
name|qbp
operator|.
name|getDistributeByForClause
argument_list|(
name|dest
argument_list|)
operator|!=
literal|null
operator|||
name|qbp
operator|.
name|getOrderByForClause
argument_list|(
name|dest
argument_list|)
operator|!=
literal|null
operator|||
name|qbp
operator|.
name|getSortByForClause
argument_list|(
name|dest
argument_list|)
operator|!=
literal|null
condition|)
block|{
name|int
name|numReducers
init|=
operator|-
literal|1
decl_stmt|;
comment|// Use only 1 reducer if order by is present
if|if
condition|(
name|qbp
operator|.
name|getOrderByForClause
argument_list|(
name|dest
argument_list|)
operator|!=
literal|null
condition|)
block|{
name|numReducers
operator|=
literal|1
expr_stmt|;
block|}
name|curr
operator|=
name|genReduceSinkPlan
argument_list|(
name|dest
argument_list|,
name|qb
argument_list|,
name|curr
argument_list|,
name|numReducers
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|qbp
operator|.
name|getIsSubQ
argument_list|()
condition|)
block|{
if|if
condition|(
name|limit
operator|!=
literal|null
condition|)
block|{
comment|// In case of order by, only 1 reducer is used, so no need of
comment|// another shuffle
name|curr
operator|=
name|genLimitMapRedPlan
argument_list|(
name|dest
argument_list|,
name|qb
argument_list|,
name|curr
argument_list|,
name|limit
operator|.
name|intValue
argument_list|()
argument_list|,
name|qbp
operator|.
name|getOrderByForClause
argument_list|(
name|dest
argument_list|)
operator|!=
literal|null
condition|?
literal|false
else|:
literal|true
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|curr
operator|=
name|genConversionOps
argument_list|(
name|dest
argument_list|,
name|qb
argument_list|,
name|curr
argument_list|)
expr_stmt|;
comment|// exact limit can be taken care of by the fetch operator
if|if
condition|(
name|limit
operator|!=
literal|null
condition|)
block|{
name|boolean
name|extraMRStep
init|=
literal|true
decl_stmt|;
if|if
condition|(
name|qb
operator|.
name|getIsQuery
argument_list|()
operator|&&
name|qbp
operator|.
name|getClusterByForClause
argument_list|(
name|dest
argument_list|)
operator|==
literal|null
operator|&&
name|qbp
operator|.
name|getSortByForClause
argument_list|(
name|dest
argument_list|)
operator|==
literal|null
condition|)
block|{
name|extraMRStep
operator|=
literal|false
expr_stmt|;
block|}
name|curr
operator|=
name|genLimitMapRedPlan
argument_list|(
name|dest
argument_list|,
name|qb
argument_list|,
name|curr
argument_list|,
name|limit
operator|.
name|intValue
argument_list|()
argument_list|,
name|extraMRStep
argument_list|)
expr_stmt|;
name|qb
operator|.
name|getParseInfo
argument_list|()
operator|.
name|setOuterQueryLimit
argument_list|(
name|limit
operator|.
name|intValue
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|curr
operator|=
name|genFileSinkPlan
argument_list|(
name|dest
argument_list|,
name|qb
argument_list|,
name|curr
argument_list|)
expr_stmt|;
block|}
comment|// change curr ops row resolver's tab aliases to query alias if it
comment|// exists
if|if
condition|(
name|qb
operator|.
name|getParseInfo
argument_list|()
operator|.
name|getAlias
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|RowResolver
name|rr
init|=
name|opParseCtx
operator|.
name|get
argument_list|(
name|curr
argument_list|)
operator|.
name|getRowResolver
argument_list|()
decl_stmt|;
name|RowResolver
name|newRR
init|=
operator|new
name|RowResolver
argument_list|()
decl_stmt|;
name|String
name|alias
init|=
name|qb
operator|.
name|getParseInfo
argument_list|()
operator|.
name|getAlias
argument_list|()
decl_stmt|;
for|for
control|(
name|ColumnInfo
name|colInfo
range|:
name|rr
operator|.
name|getColumnInfos
argument_list|()
control|)
block|{
name|String
name|name
init|=
name|colInfo
operator|.
name|getInternalName
argument_list|()
decl_stmt|;
name|String
index|[]
name|tmp
init|=
name|rr
operator|.
name|reverseLookup
argument_list|(
name|name
argument_list|)
decl_stmt|;
name|newRR
operator|.
name|put
argument_list|(
name|alias
argument_list|,
name|tmp
index|[
literal|1
index|]
argument_list|,
name|colInfo
argument_list|)
expr_stmt|;
block|}
name|opParseCtx
operator|.
name|get
argument_list|(
name|curr
argument_list|)
operator|.
name|setRowResolver
argument_list|(
name|newRR
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Created Body Plan for Query Block "
operator|+
name|qb
operator|.
name|getId
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|curr
return|;
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"nls"
argument_list|)
specifier|private
name|Operator
name|genUnionPlan
parameter_list|(
name|String
name|unionalias
parameter_list|,
name|String
name|leftalias
parameter_list|,
name|Operator
name|leftOp
parameter_list|,
name|String
name|rightalias
parameter_list|,
name|Operator
name|rightOp
parameter_list|)
throws|throws
name|SemanticException
block|{
comment|// Currently, the unions are not merged - each union has only 2 parents. So,
comment|// a n-way union will lead to (n-1) union operators.
comment|// This can be easily merged into 1 union
name|RowResolver
name|leftRR
init|=
name|opParseCtx
operator|.
name|get
argument_list|(
name|leftOp
argument_list|)
operator|.
name|getRowResolver
argument_list|()
decl_stmt|;
name|RowResolver
name|rightRR
init|=
name|opParseCtx
operator|.
name|get
argument_list|(
name|rightOp
argument_list|)
operator|.
name|getRowResolver
argument_list|()
decl_stmt|;
name|HashMap
argument_list|<
name|String
argument_list|,
name|ColumnInfo
argument_list|>
name|leftmap
init|=
name|leftRR
operator|.
name|getFieldMap
argument_list|(
name|leftalias
argument_list|)
decl_stmt|;
name|HashMap
argument_list|<
name|String
argument_list|,
name|ColumnInfo
argument_list|>
name|rightmap
init|=
name|rightRR
operator|.
name|getFieldMap
argument_list|(
name|rightalias
argument_list|)
decl_stmt|;
comment|// make sure the schemas of both sides are the same
name|ASTNode
name|tabref
init|=
name|qb
operator|.
name|getAliases
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|?
literal|null
else|:
name|qb
operator|.
name|getParseInfo
argument_list|()
operator|.
name|getSrcForAlias
argument_list|(
name|qb
operator|.
name|getAliases
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|leftmap
operator|.
name|size
argument_list|()
operator|!=
name|rightmap
operator|.
name|size
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
literal|"Schema of both sides of union should match."
argument_list|)
throw|;
block|}
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|ColumnInfo
argument_list|>
name|lEntry
range|:
name|leftmap
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|String
name|field
init|=
name|lEntry
operator|.
name|getKey
argument_list|()
decl_stmt|;
name|ColumnInfo
name|lInfo
init|=
name|lEntry
operator|.
name|getValue
argument_list|()
decl_stmt|;
name|ColumnInfo
name|rInfo
init|=
name|rightmap
operator|.
name|get
argument_list|(
name|field
argument_list|)
decl_stmt|;
if|if
condition|(
name|rInfo
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|generateErrorMessage
argument_list|(
name|tabref
argument_list|,
literal|"Schema of both sides of union should match. "
operator|+
name|rightalias
operator|+
literal|" does not have the field "
operator|+
name|field
argument_list|)
argument_list|)
throw|;
block|}
if|if
condition|(
name|lInfo
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|generateErrorMessage
argument_list|(
name|tabref
argument_list|,
literal|"Schema of both sides of union should match. "
operator|+
name|leftalias
operator|+
literal|" does not have the field "
operator|+
name|field
argument_list|)
argument_list|)
throw|;
block|}
if|if
condition|(
operator|!
name|lInfo
operator|.
name|getInternalName
argument_list|()
operator|.
name|equals
argument_list|(
name|rInfo
operator|.
name|getInternalName
argument_list|()
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|generateErrorMessage
argument_list|(
name|tabref
argument_list|,
literal|"Schema of both sides of union should match: field "
operator|+
name|field
operator|+
literal|":"
operator|+
literal|" appears on the left side of the UNION at column position: "
operator|+
name|getPositionFromInternalName
argument_list|(
name|lInfo
operator|.
name|getInternalName
argument_list|()
argument_list|)
operator|+
literal|", and on the right side of the UNION at column position: "
operator|+
name|getPositionFromInternalName
argument_list|(
name|rInfo
operator|.
name|getInternalName
argument_list|()
argument_list|)
operator|+
literal|". Column positions should match for a UNION"
argument_list|)
argument_list|)
throw|;
block|}
comment|//try widening coversion, otherwise fail union
name|TypeInfo
name|commonTypeInfo
init|=
name|FunctionRegistry
operator|.
name|getCommonClassForComparison
argument_list|(
name|lInfo
operator|.
name|getType
argument_list|()
argument_list|,
name|rInfo
operator|.
name|getType
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|commonTypeInfo
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|generateErrorMessage
argument_list|(
name|tabref
argument_list|,
literal|"Schema of both sides of union should match: Column "
operator|+
name|field
operator|+
literal|" is of type "
operator|+
name|lInfo
operator|.
name|getType
argument_list|()
operator|.
name|getTypeName
argument_list|()
operator|+
literal|" on first table and type "
operator|+
name|rInfo
operator|.
name|getType
argument_list|()
operator|.
name|getTypeName
argument_list|()
operator|+
literal|" on second table"
argument_list|)
argument_list|)
throw|;
block|}
block|}
comment|// construct the forward operator
name|RowResolver
name|unionoutRR
init|=
operator|new
name|RowResolver
argument_list|()
decl_stmt|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|ColumnInfo
argument_list|>
name|lEntry
range|:
name|leftmap
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|String
name|field
init|=
name|lEntry
operator|.
name|getKey
argument_list|()
decl_stmt|;
name|ColumnInfo
name|lInfo
init|=
name|lEntry
operator|.
name|getValue
argument_list|()
decl_stmt|;
name|ColumnInfo
name|rInfo
init|=
name|rightmap
operator|.
name|get
argument_list|(
name|field
argument_list|)
decl_stmt|;
name|lInfo
operator|.
name|setType
argument_list|(
name|FunctionRegistry
operator|.
name|getCommonClassForComparison
argument_list|(
name|lInfo
operator|.
name|getType
argument_list|()
argument_list|,
name|rInfo
operator|.
name|getType
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|unionoutRR
operator|.
name|put
argument_list|(
name|unionalias
argument_list|,
name|field
argument_list|,
name|lInfo
argument_list|)
expr_stmt|;
block|}
comment|// If one of the children is a union, merge with it
comment|// else create a new one
if|if
condition|(
operator|(
name|leftOp
operator|instanceof
name|UnionOperator
operator|)
operator|||
operator|(
name|rightOp
operator|instanceof
name|UnionOperator
operator|)
condition|)
block|{
if|if
condition|(
name|leftOp
operator|instanceof
name|UnionOperator
condition|)
block|{
comment|// make left a child of right
name|List
argument_list|<
name|Operator
argument_list|<
name|?
extends|extends
name|Serializable
argument_list|>
argument_list|>
name|child
init|=
operator|new
name|ArrayList
argument_list|<
name|Operator
argument_list|<
name|?
extends|extends
name|Serializable
argument_list|>
argument_list|>
argument_list|()
decl_stmt|;
name|child
operator|.
name|add
argument_list|(
name|leftOp
argument_list|)
expr_stmt|;
name|rightOp
operator|.
name|setChildOperators
argument_list|(
name|child
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|Operator
argument_list|<
name|?
extends|extends
name|Serializable
argument_list|>
argument_list|>
name|parent
init|=
name|leftOp
operator|.
name|getParentOperators
argument_list|()
decl_stmt|;
name|parent
operator|.
name|add
argument_list|(
name|rightOp
argument_list|)
expr_stmt|;
name|UnionDesc
name|uDesc
init|=
operator|(
operator|(
name|UnionOperator
operator|)
name|leftOp
operator|)
operator|.
name|getConf
argument_list|()
decl_stmt|;
name|uDesc
operator|.
name|setNumInputs
argument_list|(
name|uDesc
operator|.
name|getNumInputs
argument_list|()
operator|+
literal|1
argument_list|)
expr_stmt|;
return|return
name|putOpInsertMap
argument_list|(
name|leftOp
argument_list|,
name|unionoutRR
argument_list|)
return|;
block|}
else|else
block|{
comment|// make right a child of left
name|List
argument_list|<
name|Operator
argument_list|<
name|?
extends|extends
name|Serializable
argument_list|>
argument_list|>
name|child
init|=
operator|new
name|ArrayList
argument_list|<
name|Operator
argument_list|<
name|?
extends|extends
name|Serializable
argument_list|>
argument_list|>
argument_list|()
decl_stmt|;
name|child
operator|.
name|add
argument_list|(
name|rightOp
argument_list|)
expr_stmt|;
name|leftOp
operator|.
name|setChildOperators
argument_list|(
name|child
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|Operator
argument_list|<
name|?
extends|extends
name|Serializable
argument_list|>
argument_list|>
name|parent
init|=
name|rightOp
operator|.
name|getParentOperators
argument_list|()
decl_stmt|;
name|parent
operator|.
name|add
argument_list|(
name|leftOp
argument_list|)
expr_stmt|;
name|UnionDesc
name|uDesc
init|=
operator|(
operator|(
name|UnionOperator
operator|)
name|rightOp
operator|)
operator|.
name|getConf
argument_list|()
decl_stmt|;
name|uDesc
operator|.
name|setNumInputs
argument_list|(
name|uDesc
operator|.
name|getNumInputs
argument_list|()
operator|+
literal|1
argument_list|)
expr_stmt|;
return|return
name|putOpInsertMap
argument_list|(
name|rightOp
argument_list|,
name|unionoutRR
argument_list|)
return|;
block|}
block|}
comment|// Create a new union operator
name|Operator
argument_list|<
name|?
extends|extends
name|Serializable
argument_list|>
name|unionforward
init|=
name|OperatorFactory
operator|.
name|getAndMakeChild
argument_list|(
operator|new
name|UnionDesc
argument_list|()
argument_list|,
operator|new
name|RowSchema
argument_list|(
name|unionoutRR
operator|.
name|getColumnInfos
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
comment|// set union operator as child of each of leftOp and rightOp
name|List
argument_list|<
name|Operator
argument_list|<
name|?
extends|extends
name|Serializable
argument_list|>
argument_list|>
name|child
init|=
operator|new
name|ArrayList
argument_list|<
name|Operator
argument_list|<
name|?
extends|extends
name|Serializable
argument_list|>
argument_list|>
argument_list|()
decl_stmt|;
name|child
operator|.
name|add
argument_list|(
name|unionforward
argument_list|)
expr_stmt|;
name|rightOp
operator|.
name|setChildOperators
argument_list|(
name|child
argument_list|)
expr_stmt|;
name|child
operator|=
operator|new
name|ArrayList
argument_list|<
name|Operator
argument_list|<
name|?
extends|extends
name|Serializable
argument_list|>
argument_list|>
argument_list|()
expr_stmt|;
name|child
operator|.
name|add
argument_list|(
name|unionforward
argument_list|)
expr_stmt|;
name|leftOp
operator|.
name|setChildOperators
argument_list|(
name|child
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|Operator
argument_list|<
name|?
extends|extends
name|Serializable
argument_list|>
argument_list|>
name|parent
init|=
operator|new
name|ArrayList
argument_list|<
name|Operator
argument_list|<
name|?
extends|extends
name|Serializable
argument_list|>
argument_list|>
argument_list|()
decl_stmt|;
name|parent
operator|.
name|add
argument_list|(
name|leftOp
argument_list|)
expr_stmt|;
name|parent
operator|.
name|add
argument_list|(
name|rightOp
argument_list|)
expr_stmt|;
name|unionforward
operator|.
name|setParentOperators
argument_list|(
name|parent
argument_list|)
expr_stmt|;
comment|// create operator info list to return
return|return
name|putOpInsertMap
argument_list|(
name|unionforward
argument_list|,
name|unionoutRR
argument_list|)
return|;
block|}
comment|/**    * Generates the sampling predicate from the TABLESAMPLE clause information.    * This function uses the bucket column list to decide the expression inputs    * to the predicate hash function in case useBucketCols is set to true,    * otherwise the expression list stored in the TableSample is used. The bucket    * columns of the table are used to generate this predicate in case no    * expressions are provided on the TABLESAMPLE clause and the table has    * clustering columns defined in it's metadata. The predicate created has the    * following structure:    *    * ((hash(expressions)& Integer.MAX_VALUE) % denominator) == numerator    *    * @param ts    *          TABLESAMPLE clause information    * @param bucketCols    *          The clustering columns of the table    * @param useBucketCols    *          Flag to indicate whether the bucketCols should be used as input to    *          the hash function    * @param alias    *          The alias used for the table in the row resolver    * @param rwsch    *          The row resolver used to resolve column references    * @param qbm    *          The metadata information for the query block which is used to    *          resolve unaliased columns    * @param planExpr    *          The plan tree for the expression. If the user specified this, the    *          parse expressions are not used    * @return exprNodeDesc    * @exception SemanticException    */
specifier|private
name|ExprNodeDesc
name|genSamplePredicate
parameter_list|(
name|TableSample
name|ts
parameter_list|,
name|List
argument_list|<
name|String
argument_list|>
name|bucketCols
parameter_list|,
name|boolean
name|useBucketCols
parameter_list|,
name|String
name|alias
parameter_list|,
name|RowResolver
name|rwsch
parameter_list|,
name|QBMetaData
name|qbm
parameter_list|,
name|ExprNodeDesc
name|planExpr
parameter_list|)
throws|throws
name|SemanticException
block|{
name|ExprNodeDesc
name|numeratorExpr
init|=
operator|new
name|ExprNodeConstantDesc
argument_list|(
name|TypeInfoFactory
operator|.
name|intTypeInfo
argument_list|,
name|Integer
operator|.
name|valueOf
argument_list|(
name|ts
operator|.
name|getNumerator
argument_list|()
operator|-
literal|1
argument_list|)
argument_list|)
decl_stmt|;
name|ExprNodeDesc
name|denominatorExpr
init|=
operator|new
name|ExprNodeConstantDesc
argument_list|(
name|TypeInfoFactory
operator|.
name|intTypeInfo
argument_list|,
name|Integer
operator|.
name|valueOf
argument_list|(
name|ts
operator|.
name|getDenominator
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
name|ExprNodeDesc
name|intMaxExpr
init|=
operator|new
name|ExprNodeConstantDesc
argument_list|(
name|TypeInfoFactory
operator|.
name|intTypeInfo
argument_list|,
name|Integer
operator|.
name|valueOf
argument_list|(
name|Integer
operator|.
name|MAX_VALUE
argument_list|)
argument_list|)
decl_stmt|;
name|ArrayList
argument_list|<
name|ExprNodeDesc
argument_list|>
name|args
init|=
operator|new
name|ArrayList
argument_list|<
name|ExprNodeDesc
argument_list|>
argument_list|()
decl_stmt|;
if|if
condition|(
name|planExpr
operator|!=
literal|null
condition|)
block|{
name|args
operator|.
name|add
argument_list|(
name|planExpr
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|useBucketCols
condition|)
block|{
for|for
control|(
name|String
name|col
range|:
name|bucketCols
control|)
block|{
name|ColumnInfo
name|ci
init|=
name|rwsch
operator|.
name|get
argument_list|(
name|alias
argument_list|,
name|col
argument_list|)
decl_stmt|;
comment|// TODO: change type to the one in the table schema
name|args
operator|.
name|add
argument_list|(
operator|new
name|ExprNodeColumnDesc
argument_list|(
name|ci
operator|.
name|getType
argument_list|()
argument_list|,
name|ci
operator|.
name|getInternalName
argument_list|()
argument_list|,
name|ci
operator|.
name|getTabAlias
argument_list|()
argument_list|,
name|ci
operator|.
name|getIsVirtualCol
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
for|for
control|(
name|ASTNode
name|expr
range|:
name|ts
operator|.
name|getExprs
argument_list|()
control|)
block|{
name|args
operator|.
name|add
argument_list|(
name|genExprNodeDesc
argument_list|(
name|expr
argument_list|,
name|rwsch
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|ExprNodeDesc
name|equalsExpr
init|=
literal|null
decl_stmt|;
block|{
name|ExprNodeDesc
name|hashfnExpr
init|=
operator|new
name|ExprNodeGenericFuncDesc
argument_list|(
name|TypeInfoFactory
operator|.
name|intTypeInfo
argument_list|,
operator|new
name|GenericUDFHash
argument_list|()
argument_list|,
name|args
argument_list|)
decl_stmt|;
assert|assert
operator|(
name|hashfnExpr
operator|!=
literal|null
operator|)
assert|;
name|LOG
operator|.
name|info
argument_list|(
literal|"hashfnExpr = "
operator|+
name|hashfnExpr
argument_list|)
expr_stmt|;
name|ExprNodeDesc
name|andExpr
init|=
name|TypeCheckProcFactory
operator|.
name|DefaultExprProcessor
operator|.
name|getFuncExprNodeDesc
argument_list|(
literal|"&"
argument_list|,
name|hashfnExpr
argument_list|,
name|intMaxExpr
argument_list|)
decl_stmt|;
assert|assert
operator|(
name|andExpr
operator|!=
literal|null
operator|)
assert|;
name|LOG
operator|.
name|info
argument_list|(
literal|"andExpr = "
operator|+
name|andExpr
argument_list|)
expr_stmt|;
name|ExprNodeDesc
name|modExpr
init|=
name|TypeCheckProcFactory
operator|.
name|DefaultExprProcessor
operator|.
name|getFuncExprNodeDesc
argument_list|(
literal|"%"
argument_list|,
name|andExpr
argument_list|,
name|denominatorExpr
argument_list|)
decl_stmt|;
assert|assert
operator|(
name|modExpr
operator|!=
literal|null
operator|)
assert|;
name|LOG
operator|.
name|info
argument_list|(
literal|"modExpr = "
operator|+
name|modExpr
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"numeratorExpr = "
operator|+
name|numeratorExpr
argument_list|)
expr_stmt|;
name|equalsExpr
operator|=
name|TypeCheckProcFactory
operator|.
name|DefaultExprProcessor
operator|.
name|getFuncExprNodeDesc
argument_list|(
literal|"=="
argument_list|,
name|modExpr
argument_list|,
name|numeratorExpr
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"equalsExpr = "
operator|+
name|equalsExpr
argument_list|)
expr_stmt|;
assert|assert
operator|(
name|equalsExpr
operator|!=
literal|null
operator|)
assert|;
block|}
return|return
name|equalsExpr
return|;
block|}
specifier|private
name|String
name|getAliasId
parameter_list|(
name|String
name|alias
parameter_list|,
name|QB
name|qb
parameter_list|)
block|{
return|return
operator|(
name|qb
operator|.
name|getId
argument_list|()
operator|==
literal|null
condition|?
name|alias
else|:
name|qb
operator|.
name|getId
argument_list|()
operator|+
literal|":"
operator|+
name|alias
operator|)
return|;
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"nls"
argument_list|)
specifier|private
name|Operator
name|genTablePlan
parameter_list|(
name|String
name|alias
parameter_list|,
name|QB
name|qb
parameter_list|)
throws|throws
name|SemanticException
block|{
name|String
name|alias_id
init|=
name|getAliasId
argument_list|(
name|alias
argument_list|,
name|qb
argument_list|)
decl_stmt|;
name|Table
name|tab
init|=
name|qb
operator|.
name|getMetaData
argument_list|()
operator|.
name|getSrcForAlias
argument_list|(
name|alias
argument_list|)
decl_stmt|;
name|RowResolver
name|rwsch
decl_stmt|;
comment|// is the table already present
name|Operator
argument_list|<
name|?
extends|extends
name|Serializable
argument_list|>
name|top
init|=
name|topOps
operator|.
name|get
argument_list|(
name|alias_id
argument_list|)
decl_stmt|;
name|Operator
argument_list|<
name|?
extends|extends
name|Serializable
argument_list|>
name|dummySel
init|=
name|topSelOps
operator|.
name|get
argument_list|(
name|alias_id
argument_list|)
decl_stmt|;
if|if
condition|(
name|dummySel
operator|!=
literal|null
condition|)
block|{
name|top
operator|=
name|dummySel
expr_stmt|;
block|}
if|if
condition|(
name|top
operator|==
literal|null
condition|)
block|{
name|rwsch
operator|=
operator|new
name|RowResolver
argument_list|()
expr_stmt|;
try|try
block|{
name|StructObjectInspector
name|rowObjectInspector
init|=
operator|(
name|StructObjectInspector
operator|)
name|tab
operator|.
name|getDeserializer
argument_list|()
operator|.
name|getObjectInspector
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|?
extends|extends
name|StructField
argument_list|>
name|fields
init|=
name|rowObjectInspector
operator|.
name|getAllStructFieldRefs
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|fields
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|rwsch
operator|.
name|put
argument_list|(
name|alias
argument_list|,
name|fields
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|getFieldName
argument_list|()
argument_list|,
operator|new
name|ColumnInfo
argument_list|(
name|fields
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|getFieldName
argument_list|()
argument_list|,
name|TypeInfoUtils
operator|.
name|getTypeInfoFromObjectInspector
argument_list|(
name|fields
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|getFieldObjectInspector
argument_list|()
argument_list|)
argument_list|,
name|alias
argument_list|,
literal|false
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|SerDeException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
name|e
argument_list|)
throw|;
block|}
comment|// Hack!! - refactor once the metadata APIs with types are ready
comment|// Finally add the partitioning columns
for|for
control|(
name|FieldSchema
name|part_col
range|:
name|tab
operator|.
name|getPartCols
argument_list|()
control|)
block|{
name|LOG
operator|.
name|trace
argument_list|(
literal|"Adding partition col: "
operator|+
name|part_col
argument_list|)
expr_stmt|;
comment|// TODO: use the right type by calling part_col.getType() instead of
comment|// String.class
name|rwsch
operator|.
name|put
argument_list|(
name|alias
argument_list|,
name|part_col
operator|.
name|getName
argument_list|()
argument_list|,
operator|new
name|ColumnInfo
argument_list|(
name|part_col
operator|.
name|getName
argument_list|()
argument_list|,
name|TypeInfoFactory
operator|.
name|stringTypeInfo
argument_list|,
name|alias
argument_list|,
literal|true
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|//put all virutal columns in RowResolver.
name|Iterator
argument_list|<
name|VirtualColumn
argument_list|>
name|vcs
init|=
name|VirtualColumn
operator|.
name|getRegistry
argument_list|(
name|conf
argument_list|)
operator|.
name|iterator
argument_list|()
decl_stmt|;
comment|//use a list for easy cumtomize
name|List
argument_list|<
name|VirtualColumn
argument_list|>
name|vcList
init|=
operator|new
name|ArrayList
argument_list|<
name|VirtualColumn
argument_list|>
argument_list|()
decl_stmt|;
while|while
condition|(
name|vcs
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|VirtualColumn
name|vc
init|=
name|vcs
operator|.
name|next
argument_list|()
decl_stmt|;
name|rwsch
operator|.
name|put
argument_list|(
name|alias
argument_list|,
name|vc
operator|.
name|getName
argument_list|()
argument_list|,
operator|new
name|ColumnInfo
argument_list|(
name|vc
operator|.
name|getName
argument_list|()
argument_list|,
name|vc
operator|.
name|getTypeInfo
argument_list|()
argument_list|,
name|alias
argument_list|,
literal|true
argument_list|,
name|vc
operator|.
name|getIsHidden
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|vcList
operator|.
name|add
argument_list|(
name|vc
argument_list|)
expr_stmt|;
block|}
comment|// Create the root of the operator tree
name|TableScanDesc
name|tsDesc
init|=
operator|new
name|TableScanDesc
argument_list|(
name|alias
argument_list|,
name|vcList
argument_list|)
decl_stmt|;
name|setupStats
argument_list|(
name|tsDesc
argument_list|,
name|qb
operator|.
name|getParseInfo
argument_list|()
argument_list|,
name|tab
argument_list|,
name|alias
argument_list|,
name|rwsch
argument_list|)
expr_stmt|;
name|top
operator|=
name|putOpInsertMap
argument_list|(
name|OperatorFactory
operator|.
name|get
argument_list|(
name|tsDesc
argument_list|,
operator|new
name|RowSchema
argument_list|(
name|rwsch
operator|.
name|getColumnInfos
argument_list|()
argument_list|)
argument_list|)
argument_list|,
name|rwsch
argument_list|)
expr_stmt|;
comment|// Add this to the list of top operators - we always start from a table
comment|// scan
name|topOps
operator|.
name|put
argument_list|(
name|alias_id
argument_list|,
name|top
argument_list|)
expr_stmt|;
comment|// Add a mapping from the table scan operator to Table
name|topToTable
operator|.
name|put
argument_list|(
operator|(
name|TableScanOperator
operator|)
name|top
argument_list|,
name|tab
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|rwsch
operator|=
name|opParseCtx
operator|.
name|get
argument_list|(
name|top
argument_list|)
operator|.
name|getRowResolver
argument_list|()
expr_stmt|;
name|top
operator|.
name|setChildOperators
argument_list|(
literal|null
argument_list|)
expr_stmt|;
block|}
comment|// check if this table is sampled and needs more than input pruning
name|Operator
argument_list|<
name|?
extends|extends
name|Serializable
argument_list|>
name|tableOp
init|=
name|top
decl_stmt|;
name|TableSample
name|ts
init|=
name|qb
operator|.
name|getParseInfo
argument_list|()
operator|.
name|getTabSample
argument_list|(
name|alias
argument_list|)
decl_stmt|;
if|if
condition|(
name|ts
operator|!=
literal|null
condition|)
block|{
name|int
name|num
init|=
name|ts
operator|.
name|getNumerator
argument_list|()
decl_stmt|;
name|int
name|den
init|=
name|ts
operator|.
name|getDenominator
argument_list|()
decl_stmt|;
name|ArrayList
argument_list|<
name|ASTNode
argument_list|>
name|sampleExprs
init|=
name|ts
operator|.
name|getExprs
argument_list|()
decl_stmt|;
comment|// TODO: Do the type checking of the expressions
name|List
argument_list|<
name|String
argument_list|>
name|tabBucketCols
init|=
name|tab
operator|.
name|getBucketCols
argument_list|()
decl_stmt|;
name|int
name|numBuckets
init|=
name|tab
operator|.
name|getNumBuckets
argument_list|()
decl_stmt|;
comment|// If there are no sample cols and no bucket cols then throw an error
if|if
condition|(
name|tabBucketCols
operator|.
name|size
argument_list|()
operator|==
literal|0
operator|&&
name|sampleExprs
operator|.
name|size
argument_list|()
operator|==
literal|0
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|NON_BUCKETED_TABLE
operator|.
name|getMsg
argument_list|()
operator|+
literal|" "
operator|+
name|tab
operator|.
name|getTableName
argument_list|()
argument_list|)
throw|;
block|}
if|if
condition|(
name|num
operator|>
name|den
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|BUCKETED_NUMBERATOR_BIGGER_DENOMINATOR
operator|.
name|getMsg
argument_list|()
operator|+
literal|" "
operator|+
name|tab
operator|.
name|getTableName
argument_list|()
argument_list|)
throw|;
block|}
comment|// check if a predicate is needed
comment|// predicate is needed if either input pruning is not enough
comment|// or if input pruning is not possible
comment|// check if the sample columns are the same as the table bucket columns
name|boolean
name|colsEqual
init|=
literal|true
decl_stmt|;
if|if
condition|(
operator|(
name|sampleExprs
operator|.
name|size
argument_list|()
operator|!=
name|tabBucketCols
operator|.
name|size
argument_list|()
operator|)
operator|&&
operator|(
name|sampleExprs
operator|.
name|size
argument_list|()
operator|!=
literal|0
operator|)
condition|)
block|{
name|colsEqual
operator|=
literal|false
expr_stmt|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|sampleExprs
operator|.
name|size
argument_list|()
operator|&&
name|colsEqual
condition|;
name|i
operator|++
control|)
block|{
name|boolean
name|colFound
init|=
literal|false
decl_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|tabBucketCols
operator|.
name|size
argument_list|()
operator|&&
operator|!
name|colFound
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|sampleExprs
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|getToken
argument_list|()
operator|.
name|getType
argument_list|()
operator|!=
name|HiveParser
operator|.
name|TOK_TABLE_OR_COL
condition|)
block|{
break|break;
block|}
if|if
condition|(
operator|(
operator|(
name|ASTNode
operator|)
name|sampleExprs
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|)
operator|.
name|getText
argument_list|()
operator|.
name|equalsIgnoreCase
argument_list|(
name|tabBucketCols
operator|.
name|get
argument_list|(
name|j
argument_list|)
argument_list|)
condition|)
block|{
name|colFound
operator|=
literal|true
expr_stmt|;
block|}
block|}
name|colsEqual
operator|=
operator|(
name|colsEqual
operator|&&
name|colFound
operator|)
expr_stmt|;
block|}
comment|// Check if input can be pruned
name|ts
operator|.
name|setInputPruning
argument_list|(
operator|(
name|sampleExprs
operator|==
literal|null
operator|||
name|sampleExprs
operator|.
name|size
argument_list|()
operator|==
literal|0
operator|||
name|colsEqual
operator|)
argument_list|)
expr_stmt|;
comment|// check if input pruning is enough
if|if
condition|(
operator|(
name|sampleExprs
operator|==
literal|null
operator|||
name|sampleExprs
operator|.
name|size
argument_list|()
operator|==
literal|0
operator|||
name|colsEqual
operator|)
operator|&&
operator|(
name|num
operator|==
name|den
operator|||
operator|(
name|den
operator|%
name|numBuckets
operator|==
literal|0
operator|||
name|numBuckets
operator|%
name|den
operator|==
literal|0
operator|)
operator|)
condition|)
block|{
comment|// input pruning is enough; add the filter for the optimizer to use it
comment|// later
name|LOG
operator|.
name|info
argument_list|(
literal|"No need for sample filter"
argument_list|)
expr_stmt|;
name|ExprNodeDesc
name|samplePredicate
init|=
name|genSamplePredicate
argument_list|(
name|ts
argument_list|,
name|tabBucketCols
argument_list|,
name|colsEqual
argument_list|,
name|alias
argument_list|,
name|rwsch
argument_list|,
name|qb
operator|.
name|getMetaData
argument_list|()
argument_list|,
literal|null
argument_list|)
decl_stmt|;
name|tableOp
operator|=
name|OperatorFactory
operator|.
name|getAndMakeChild
argument_list|(
operator|new
name|FilterDesc
argument_list|(
name|samplePredicate
argument_list|,
literal|true
argument_list|,
operator|new
name|sampleDesc
argument_list|(
name|ts
operator|.
name|getNumerator
argument_list|()
argument_list|,
name|ts
operator|.
name|getDenominator
argument_list|()
argument_list|,
name|tabBucketCols
argument_list|,
literal|true
argument_list|)
argument_list|)
argument_list|,
operator|new
name|RowSchema
argument_list|(
name|rwsch
operator|.
name|getColumnInfos
argument_list|()
argument_list|)
argument_list|,
name|top
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// need to add filter
comment|// create tableOp to be filterDesc and set as child to 'top'
name|LOG
operator|.
name|info
argument_list|(
literal|"Need sample filter"
argument_list|)
expr_stmt|;
name|ExprNodeDesc
name|samplePredicate
init|=
name|genSamplePredicate
argument_list|(
name|ts
argument_list|,
name|tabBucketCols
argument_list|,
name|colsEqual
argument_list|,
name|alias
argument_list|,
name|rwsch
argument_list|,
name|qb
operator|.
name|getMetaData
argument_list|()
argument_list|,
literal|null
argument_list|)
decl_stmt|;
name|tableOp
operator|=
name|OperatorFactory
operator|.
name|getAndMakeChild
argument_list|(
operator|new
name|FilterDesc
argument_list|(
name|samplePredicate
argument_list|,
literal|true
argument_list|)
argument_list|,
operator|new
name|RowSchema
argument_list|(
name|rwsch
operator|.
name|getColumnInfos
argument_list|()
argument_list|)
argument_list|,
name|top
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|boolean
name|testMode
init|=
name|conf
operator|.
name|getBoolVar
argument_list|(
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVETESTMODE
argument_list|)
decl_stmt|;
if|if
condition|(
name|testMode
condition|)
block|{
name|String
name|tabName
init|=
name|tab
operator|.
name|getTableName
argument_list|()
decl_stmt|;
comment|// has the user explicitly asked not to sample this table
name|String
name|unSampleTblList
init|=
name|conf
operator|.
name|getVar
argument_list|(
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVETESTMODENOSAMPLE
argument_list|)
decl_stmt|;
name|String
index|[]
name|unSampleTbls
init|=
name|unSampleTblList
operator|.
name|split
argument_list|(
literal|","
argument_list|)
decl_stmt|;
name|boolean
name|unsample
init|=
literal|false
decl_stmt|;
for|for
control|(
name|String
name|unSampleTbl
range|:
name|unSampleTbls
control|)
block|{
if|if
condition|(
name|tabName
operator|.
name|equalsIgnoreCase
argument_list|(
name|unSampleTbl
argument_list|)
condition|)
block|{
name|unsample
operator|=
literal|true
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|unsample
condition|)
block|{
name|int
name|numBuckets
init|=
name|tab
operator|.
name|getNumBuckets
argument_list|()
decl_stmt|;
comment|// If the input table is bucketed, choose the first bucket
if|if
condition|(
name|numBuckets
operator|>
literal|0
condition|)
block|{
name|TableSample
name|tsSample
init|=
operator|new
name|TableSample
argument_list|(
literal|1
argument_list|,
name|numBuckets
argument_list|)
decl_stmt|;
name|tsSample
operator|.
name|setInputPruning
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|qb
operator|.
name|getParseInfo
argument_list|()
operator|.
name|setTabSample
argument_list|(
name|alias
argument_list|,
name|tsSample
argument_list|)
expr_stmt|;
name|ExprNodeDesc
name|samplePred
init|=
name|genSamplePredicate
argument_list|(
name|tsSample
argument_list|,
name|tab
operator|.
name|getBucketCols
argument_list|()
argument_list|,
literal|true
argument_list|,
name|alias
argument_list|,
name|rwsch
argument_list|,
name|qb
operator|.
name|getMetaData
argument_list|()
argument_list|,
literal|null
argument_list|)
decl_stmt|;
name|tableOp
operator|=
name|OperatorFactory
operator|.
name|getAndMakeChild
argument_list|(
operator|new
name|FilterDesc
argument_list|(
name|samplePred
argument_list|,
literal|true
argument_list|,
operator|new
name|sampleDesc
argument_list|(
name|tsSample
operator|.
name|getNumerator
argument_list|()
argument_list|,
name|tsSample
operator|.
name|getDenominator
argument_list|()
argument_list|,
name|tab
operator|.
name|getBucketCols
argument_list|()
argument_list|,
literal|true
argument_list|)
argument_list|)
argument_list|,
operator|new
name|RowSchema
argument_list|(
name|rwsch
operator|.
name|getColumnInfos
argument_list|()
argument_list|)
argument_list|,
name|top
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"No need for sample filter"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// The table is not bucketed, add a dummy filter :: rand()
name|int
name|freq
init|=
name|conf
operator|.
name|getIntVar
argument_list|(
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVETESTMODESAMPLEFREQ
argument_list|)
decl_stmt|;
name|TableSample
name|tsSample
init|=
operator|new
name|TableSample
argument_list|(
literal|1
argument_list|,
name|freq
argument_list|)
decl_stmt|;
name|tsSample
operator|.
name|setInputPruning
argument_list|(
literal|false
argument_list|)
expr_stmt|;
name|qb
operator|.
name|getParseInfo
argument_list|()
operator|.
name|setTabSample
argument_list|(
name|alias
argument_list|,
name|tsSample
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Need sample filter"
argument_list|)
expr_stmt|;
name|ExprNodeDesc
name|randFunc
init|=
name|TypeCheckProcFactory
operator|.
name|DefaultExprProcessor
operator|.
name|getFuncExprNodeDesc
argument_list|(
literal|"rand"
argument_list|,
operator|new
name|ExprNodeConstantDesc
argument_list|(
name|Integer
operator|.
name|valueOf
argument_list|(
literal|460476415
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|ExprNodeDesc
name|samplePred
init|=
name|genSamplePredicate
argument_list|(
name|tsSample
argument_list|,
literal|null
argument_list|,
literal|false
argument_list|,
name|alias
argument_list|,
name|rwsch
argument_list|,
name|qb
operator|.
name|getMetaData
argument_list|()
argument_list|,
name|randFunc
argument_list|)
decl_stmt|;
name|tableOp
operator|=
name|OperatorFactory
operator|.
name|getAndMakeChild
argument_list|(
operator|new
name|FilterDesc
argument_list|(
name|samplePred
argument_list|,
literal|true
argument_list|)
argument_list|,
operator|new
name|RowSchema
argument_list|(
name|rwsch
operator|.
name|getColumnInfos
argument_list|()
argument_list|)
argument_list|,
name|top
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
name|Operator
name|output
init|=
name|putOpInsertMap
argument_list|(
name|tableOp
argument_list|,
name|rwsch
argument_list|)
decl_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Created Table Plan for "
operator|+
name|alias
operator|+
literal|" "
operator|+
name|tableOp
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|output
return|;
block|}
specifier|private
name|void
name|setupStats
parameter_list|(
name|TableScanDesc
name|tsDesc
parameter_list|,
name|QBParseInfo
name|qbp
parameter_list|,
name|Table
name|tab
parameter_list|,
name|String
name|alias
parameter_list|,
name|RowResolver
name|rwsch
parameter_list|)
throws|throws
name|SemanticException
block|{
if|if
condition|(
operator|!
name|qbp
operator|.
name|isAnalyzeCommand
argument_list|()
condition|)
block|{
name|tsDesc
operator|.
name|setGatherStats
argument_list|(
literal|false
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|tsDesc
operator|.
name|setGatherStats
argument_list|(
literal|true
argument_list|)
expr_stmt|;
comment|// append additional virtual columns for storing statistics
name|Iterator
argument_list|<
name|VirtualColumn
argument_list|>
name|vcs
init|=
name|VirtualColumn
operator|.
name|getStatsRegistry
argument_list|(
name|conf
argument_list|)
operator|.
name|iterator
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|VirtualColumn
argument_list|>
name|vcList
init|=
operator|new
name|ArrayList
argument_list|<
name|VirtualColumn
argument_list|>
argument_list|()
decl_stmt|;
while|while
condition|(
name|vcs
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|VirtualColumn
name|vc
init|=
name|vcs
operator|.
name|next
argument_list|()
decl_stmt|;
name|rwsch
operator|.
name|put
argument_list|(
name|alias
argument_list|,
name|vc
operator|.
name|getName
argument_list|()
argument_list|,
operator|new
name|ColumnInfo
argument_list|(
name|vc
operator|.
name|getName
argument_list|()
argument_list|,
name|vc
operator|.
name|getTypeInfo
argument_list|()
argument_list|,
name|alias
argument_list|,
literal|true
argument_list|,
name|vc
operator|.
name|getIsHidden
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|vcList
operator|.
name|add
argument_list|(
name|vc
argument_list|)
expr_stmt|;
block|}
name|tsDesc
operator|.
name|addVirtualCols
argument_list|(
name|vcList
argument_list|)
expr_stmt|;
name|String
name|tblName
init|=
name|tab
operator|.
name|getTableName
argument_list|()
decl_stmt|;
name|tableSpec
name|tblSpec
init|=
name|qbp
operator|.
name|getTableSpec
argument_list|(
name|alias
argument_list|)
decl_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|partSpec
init|=
name|tblSpec
operator|.
name|getPartSpec
argument_list|()
decl_stmt|;
if|if
condition|(
name|partSpec
operator|!=
literal|null
condition|)
block|{
name|List
argument_list|<
name|String
argument_list|>
name|cols
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
name|cols
operator|.
name|addAll
argument_list|(
name|partSpec
operator|.
name|keySet
argument_list|()
argument_list|)
expr_stmt|;
name|tsDesc
operator|.
name|setPartColumns
argument_list|(
name|cols
argument_list|)
expr_stmt|;
block|}
comment|// Theoretically the key prefix could be any unique string shared
comment|// between TableScanOperator (when publishing) and StatsTask (when aggregating).
comment|// Here we use
comment|//       table_name + partitionSec
comment|// as the prefix for easy of read during explain and debugging.
comment|// Currently, partition spec can only be static partition.
name|String
name|k
init|=
name|tblName
operator|+
name|Path
operator|.
name|SEPARATOR
decl_stmt|;
name|tsDesc
operator|.
name|setStatsAggPrefix
argument_list|(
name|k
argument_list|)
expr_stmt|;
comment|// set up WritenEntity for replication
name|outputs
operator|.
name|add
argument_list|(
operator|new
name|WriteEntity
argument_list|(
name|tab
argument_list|,
literal|true
argument_list|)
argument_list|)
expr_stmt|;
comment|// add WriteEntity for each matching partition
if|if
condition|(
name|tab
operator|.
name|isPartitioned
argument_list|()
condition|)
block|{
if|if
condition|(
name|partSpec
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|NEED_PARTITION_SPECIFICATION
operator|.
name|getMsg
argument_list|()
argument_list|)
throw|;
block|}
name|List
argument_list|<
name|Partition
argument_list|>
name|partitions
init|=
name|qbp
operator|.
name|getTableSpec
argument_list|()
operator|.
name|partitions
decl_stmt|;
if|if
condition|(
name|partitions
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|Partition
name|partn
range|:
name|partitions
control|)
block|{
comment|// inputs.add(new ReadEntity(partn)); // is this needed at all?
name|outputs
operator|.
name|add
argument_list|(
operator|new
name|WriteEntity
argument_list|(
name|partn
argument_list|,
literal|true
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
specifier|private
name|Operator
name|genPlan
parameter_list|(
name|QBExpr
name|qbexpr
parameter_list|)
throws|throws
name|SemanticException
block|{
if|if
condition|(
name|qbexpr
operator|.
name|getOpcode
argument_list|()
operator|==
name|QBExpr
operator|.
name|Opcode
operator|.
name|NULLOP
condition|)
block|{
return|return
name|genPlan
argument_list|(
name|qbexpr
operator|.
name|getQB
argument_list|()
argument_list|)
return|;
block|}
if|if
condition|(
name|qbexpr
operator|.
name|getOpcode
argument_list|()
operator|==
name|QBExpr
operator|.
name|Opcode
operator|.
name|UNION
condition|)
block|{
name|Operator
name|qbexpr1Ops
init|=
name|genPlan
argument_list|(
name|qbexpr
operator|.
name|getQBExpr1
argument_list|()
argument_list|)
decl_stmt|;
name|Operator
name|qbexpr2Ops
init|=
name|genPlan
argument_list|(
name|qbexpr
operator|.
name|getQBExpr2
argument_list|()
argument_list|)
decl_stmt|;
return|return
name|genUnionPlan
argument_list|(
name|qbexpr
operator|.
name|getAlias
argument_list|()
argument_list|,
name|qbexpr
operator|.
name|getQBExpr1
argument_list|()
operator|.
name|getAlias
argument_list|()
argument_list|,
name|qbexpr1Ops
argument_list|,
name|qbexpr
operator|.
name|getQBExpr2
argument_list|()
operator|.
name|getAlias
argument_list|()
argument_list|,
name|qbexpr2Ops
argument_list|)
return|;
block|}
return|return
literal|null
return|;
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"nls"
argument_list|)
specifier|public
name|Operator
name|genPlan
parameter_list|(
name|QB
name|qb
parameter_list|)
throws|throws
name|SemanticException
block|{
comment|// First generate all the opInfos for the elements in the from clause
name|HashMap
argument_list|<
name|String
argument_list|,
name|Operator
argument_list|>
name|aliasToOpInfo
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|Operator
argument_list|>
argument_list|()
decl_stmt|;
comment|// Recurse over the subqueries to fill the subquery part of the plan
for|for
control|(
name|String
name|alias
range|:
name|qb
operator|.
name|getSubqAliases
argument_list|()
control|)
block|{
name|QBExpr
name|qbexpr
init|=
name|qb
operator|.
name|getSubqForAlias
argument_list|(
name|alias
argument_list|)
decl_stmt|;
name|aliasToOpInfo
operator|.
name|put
argument_list|(
name|alias
argument_list|,
name|genPlan
argument_list|(
name|qbexpr
argument_list|)
argument_list|)
expr_stmt|;
name|qbexpr
operator|.
name|setAlias
argument_list|(
name|alias
argument_list|)
expr_stmt|;
block|}
comment|// Recurse over all the source tables
for|for
control|(
name|String
name|alias
range|:
name|qb
operator|.
name|getTabAliases
argument_list|()
control|)
block|{
name|Operator
name|op
init|=
name|genTablePlan
argument_list|(
name|alias
argument_list|,
name|qb
argument_list|)
decl_stmt|;
name|aliasToOpInfo
operator|.
name|put
argument_list|(
name|alias
argument_list|,
name|op
argument_list|)
expr_stmt|;
block|}
comment|// For all the source tables that have a lateral view, attach the
comment|// appropriate operators to the TS
name|genLateralViewPlans
argument_list|(
name|aliasToOpInfo
argument_list|,
name|qb
argument_list|)
expr_stmt|;
name|Operator
name|srcOpInfo
init|=
literal|null
decl_stmt|;
comment|// process join
if|if
condition|(
name|qb
operator|.
name|getParseInfo
argument_list|()
operator|.
name|getJoinExpr
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|ASTNode
name|joinExpr
init|=
name|qb
operator|.
name|getParseInfo
argument_list|()
operator|.
name|getJoinExpr
argument_list|()
decl_stmt|;
if|if
condition|(
name|joinExpr
operator|.
name|getToken
argument_list|()
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_UNIQUEJOIN
condition|)
block|{
name|QBJoinTree
name|joinTree
init|=
name|genUniqueJoinTree
argument_list|(
name|qb
argument_list|,
name|joinExpr
argument_list|)
decl_stmt|;
name|qb
operator|.
name|setQbJoinTree
argument_list|(
name|joinTree
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|QBJoinTree
name|joinTree
init|=
name|genJoinTree
argument_list|(
name|qb
argument_list|,
name|joinExpr
argument_list|)
decl_stmt|;
name|qb
operator|.
name|setQbJoinTree
argument_list|(
name|joinTree
argument_list|)
expr_stmt|;
name|mergeJoinTree
argument_list|(
name|qb
argument_list|)
expr_stmt|;
block|}
comment|// if any filters are present in the join tree, push them on top of the
comment|// table
name|pushJoinFilters
argument_list|(
name|qb
argument_list|,
name|qb
operator|.
name|getQbJoinTree
argument_list|()
argument_list|,
name|aliasToOpInfo
argument_list|)
expr_stmt|;
name|srcOpInfo
operator|=
name|genJoinPlan
argument_list|(
name|qb
argument_list|,
name|aliasToOpInfo
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// Now if there are more than 1 sources then we have a join case
comment|// later we can extend this to the union all case as well
name|srcOpInfo
operator|=
name|aliasToOpInfo
operator|.
name|values
argument_list|()
operator|.
name|iterator
argument_list|()
operator|.
name|next
argument_list|()
expr_stmt|;
block|}
name|Operator
name|bodyOpInfo
init|=
name|genBodyPlan
argument_list|(
name|qb
argument_list|,
name|srcOpInfo
argument_list|)
decl_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Created Plan for Query Block "
operator|+
name|qb
operator|.
name|getId
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|this
operator|.
name|qb
operator|=
name|qb
expr_stmt|;
return|return
name|bodyOpInfo
return|;
block|}
comment|/**    * Generates the operator DAG needed to implement lateral views and attaches    * it to the TS operator.    *    * @param aliasToOpInfo    *          A mapping from a table alias to the TS operator. This function    *          replaces the operator mapping as necessary    * @param qb    * @throws SemanticException    */
name|void
name|genLateralViewPlans
parameter_list|(
name|HashMap
argument_list|<
name|String
argument_list|,
name|Operator
argument_list|>
name|aliasToOpInfo
parameter_list|,
name|QB
name|qb
parameter_list|)
throws|throws
name|SemanticException
block|{
name|Map
argument_list|<
name|String
argument_list|,
name|ArrayList
argument_list|<
name|ASTNode
argument_list|>
argument_list|>
name|aliasToLateralViews
init|=
name|qb
operator|.
name|getParseInfo
argument_list|()
operator|.
name|getAliasToLateralViews
argument_list|()
decl_stmt|;
for|for
control|(
name|Entry
argument_list|<
name|String
argument_list|,
name|Operator
argument_list|>
name|e
range|:
name|aliasToOpInfo
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|String
name|alias
init|=
name|e
operator|.
name|getKey
argument_list|()
decl_stmt|;
comment|// See if the alias has a lateral view. If so, chain the lateral view
comment|// operator on
name|ArrayList
argument_list|<
name|ASTNode
argument_list|>
name|lateralViews
init|=
name|aliasToLateralViews
operator|.
name|get
argument_list|(
name|alias
argument_list|)
decl_stmt|;
if|if
condition|(
name|lateralViews
operator|!=
literal|null
condition|)
block|{
name|Operator
name|op
init|=
name|e
operator|.
name|getValue
argument_list|()
decl_stmt|;
for|for
control|(
name|ASTNode
name|lateralViewTree
range|:
name|aliasToLateralViews
operator|.
name|get
argument_list|(
name|alias
argument_list|)
control|)
block|{
comment|// There are 2 paths from the TS operator (or a previous LVJ operator)
comment|// to the same LateralViewJoinOperator.
comment|// TS -> SelectOperator(*) -> LateralViewJoinOperator
comment|// TS -> SelectOperator (gets cols for UDTF) -> UDTFOperator0
comment|// -> LateralViewJoinOperator
comment|//
name|RowResolver
name|lvForwardRR
init|=
operator|new
name|RowResolver
argument_list|()
decl_stmt|;
name|RowResolver
name|source
init|=
name|opParseCtx
operator|.
name|get
argument_list|(
name|op
argument_list|)
operator|.
name|getRowResolver
argument_list|()
decl_stmt|;
for|for
control|(
name|ColumnInfo
name|col
range|:
name|source
operator|.
name|getColumnInfos
argument_list|()
control|)
block|{
if|if
condition|(
name|col
operator|.
name|getIsVirtualCol
argument_list|()
operator|&&
name|col
operator|.
name|isHiddenVirtualCol
argument_list|()
condition|)
block|{
continue|continue;
block|}
name|String
index|[]
name|tabCol
init|=
name|source
operator|.
name|reverseLookup
argument_list|(
name|col
operator|.
name|getInternalName
argument_list|()
argument_list|)
decl_stmt|;
name|lvForwardRR
operator|.
name|put
argument_list|(
name|tabCol
index|[
literal|0
index|]
argument_list|,
name|tabCol
index|[
literal|1
index|]
argument_list|,
name|col
argument_list|)
expr_stmt|;
block|}
name|Operator
name|lvForward
init|=
name|putOpInsertMap
argument_list|(
name|OperatorFactory
operator|.
name|getAndMakeChild
argument_list|(
operator|new
name|LateralViewForwardDesc
argument_list|()
argument_list|,
operator|new
name|RowSchema
argument_list|(
name|lvForwardRR
operator|.
name|getColumnInfos
argument_list|()
argument_list|)
argument_list|,
name|op
argument_list|)
argument_list|,
name|lvForwardRR
argument_list|)
decl_stmt|;
comment|// The order in which the two paths are added is important. The
comment|// lateral view join operator depends on having the select operator
comment|// give it the row first.
comment|// Get the all path by making a select(*).
name|RowResolver
name|allPathRR
init|=
name|opParseCtx
operator|.
name|get
argument_list|(
name|lvForward
argument_list|)
operator|.
name|getRowResolver
argument_list|()
decl_stmt|;
comment|//Operator allPath = op;
name|Operator
name|allPath
init|=
name|putOpInsertMap
argument_list|(
name|OperatorFactory
operator|.
name|getAndMakeChild
argument_list|(
operator|new
name|SelectDesc
argument_list|(
literal|true
argument_list|)
argument_list|,
operator|new
name|RowSchema
argument_list|(
name|allPathRR
operator|.
name|getColumnInfos
argument_list|()
argument_list|)
argument_list|,
name|lvForward
argument_list|)
argument_list|,
name|allPathRR
argument_list|)
decl_stmt|;
comment|// Get the UDTF Path
name|QB
name|blankQb
init|=
operator|new
name|QB
argument_list|(
literal|null
argument_list|,
literal|null
argument_list|,
literal|false
argument_list|)
decl_stmt|;
name|Operator
name|udtfPath
init|=
name|genSelectPlan
argument_list|(
operator|(
name|ASTNode
operator|)
name|lateralViewTree
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
argument_list|,
name|blankQb
argument_list|,
name|lvForward
argument_list|)
decl_stmt|;
comment|// add udtf aliases to QB
for|for
control|(
name|String
name|udtfAlias
range|:
name|blankQb
operator|.
name|getAliases
argument_list|()
control|)
block|{
name|qb
operator|.
name|addAlias
argument_list|(
name|udtfAlias
argument_list|)
expr_stmt|;
block|}
name|RowResolver
name|udtfPathRR
init|=
name|opParseCtx
operator|.
name|get
argument_list|(
name|udtfPath
argument_list|)
operator|.
name|getRowResolver
argument_list|()
decl_stmt|;
comment|// Merge the two into the lateral view join
comment|// The cols of the merged result will be the combination of both the
comment|// cols of the UDTF path and the cols of the all path. The internal
comment|// names have to be changed to avoid conflicts
name|RowResolver
name|lateralViewRR
init|=
operator|new
name|RowResolver
argument_list|()
decl_stmt|;
name|ArrayList
argument_list|<
name|String
argument_list|>
name|outputInternalColNames
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
name|LVmergeRowResolvers
argument_list|(
name|allPathRR
argument_list|,
name|lateralViewRR
argument_list|,
name|outputInternalColNames
argument_list|)
expr_stmt|;
name|LVmergeRowResolvers
argument_list|(
name|udtfPathRR
argument_list|,
name|lateralViewRR
argument_list|,
name|outputInternalColNames
argument_list|)
expr_stmt|;
comment|// For PPD, we need a column to expression map so that during the walk,
comment|// the processor knows how to transform the internal col names.
comment|// Following steps are dependant on the fact that we called
comment|// LVmerge.. in the above order
name|Map
argument_list|<
name|String
argument_list|,
name|ExprNodeDesc
argument_list|>
name|colExprMap
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|ExprNodeDesc
argument_list|>
argument_list|()
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
for|for
control|(
name|ColumnInfo
name|c
range|:
name|allPathRR
operator|.
name|getColumnInfos
argument_list|()
control|)
block|{
name|String
name|internalName
init|=
name|getColumnInternalName
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|i
operator|++
expr_stmt|;
name|colExprMap
operator|.
name|put
argument_list|(
name|internalName
argument_list|,
operator|new
name|ExprNodeColumnDesc
argument_list|(
name|c
operator|.
name|getType
argument_list|()
argument_list|,
name|c
operator|.
name|getInternalName
argument_list|()
argument_list|,
name|c
operator|.
name|getTabAlias
argument_list|()
argument_list|,
name|c
operator|.
name|getIsVirtualCol
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|Operator
name|lateralViewJoin
init|=
name|putOpInsertMap
argument_list|(
name|OperatorFactory
operator|.
name|getAndMakeChild
argument_list|(
operator|new
name|LateralViewJoinDesc
argument_list|(
name|outputInternalColNames
argument_list|)
argument_list|,
operator|new
name|RowSchema
argument_list|(
name|lateralViewRR
operator|.
name|getColumnInfos
argument_list|()
argument_list|)
argument_list|,
name|allPath
argument_list|,
name|udtfPath
argument_list|)
argument_list|,
name|lateralViewRR
argument_list|)
decl_stmt|;
name|lateralViewJoin
operator|.
name|setColumnExprMap
argument_list|(
name|colExprMap
argument_list|)
expr_stmt|;
name|op
operator|=
name|lateralViewJoin
expr_stmt|;
block|}
name|e
operator|.
name|setValue
argument_list|(
name|op
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**    * A helper function that gets all the columns and respective aliases in the    * source and puts them into dest. It renames the internal names of the    * columns based on getColumnInternalName(position).    *    * Note that this helper method relies on RowResolver.getColumnInfos()    * returning the columns in the same order as they will be passed in the    * operator DAG.    *    * @param source    * @param dest    * @param outputColNames    *          - a list to which the new internal column names will be added, in    *          the same order as in the dest row resolver    */
specifier|private
name|void
name|LVmergeRowResolvers
parameter_list|(
name|RowResolver
name|source
parameter_list|,
name|RowResolver
name|dest
parameter_list|,
name|ArrayList
argument_list|<
name|String
argument_list|>
name|outputInternalColNames
parameter_list|)
block|{
for|for
control|(
name|ColumnInfo
name|c
range|:
name|source
operator|.
name|getColumnInfos
argument_list|()
control|)
block|{
name|String
name|internalName
init|=
name|getColumnInternalName
argument_list|(
name|outputInternalColNames
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
name|outputInternalColNames
operator|.
name|add
argument_list|(
name|internalName
argument_list|)
expr_stmt|;
name|ColumnInfo
name|newCol
init|=
operator|new
name|ColumnInfo
argument_list|(
name|internalName
argument_list|,
name|c
operator|.
name|getType
argument_list|()
argument_list|,
name|c
operator|.
name|getTabAlias
argument_list|()
argument_list|,
name|c
operator|.
name|getIsVirtualCol
argument_list|()
argument_list|)
decl_stmt|;
name|String
index|[]
name|tableCol
init|=
name|source
operator|.
name|reverseLookup
argument_list|(
name|c
operator|.
name|getInternalName
argument_list|()
argument_list|)
decl_stmt|;
name|String
name|tableAlias
init|=
name|tableCol
index|[
literal|0
index|]
decl_stmt|;
name|String
name|colAlias
init|=
name|tableCol
index|[
literal|1
index|]
decl_stmt|;
name|dest
operator|.
name|put
argument_list|(
name|tableAlias
argument_list|,
name|colAlias
argument_list|,
name|newCol
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Recursively check the limit number in all sub queries    * @param qbParseInfo    * @return if there is one and only one limit for all subqueries, return the limit    * if there is no limit, return 0    * otherwise, return null    */
specifier|private
name|Integer
name|checkQbpForGlobalLimit
parameter_list|(
name|QB
name|localQb
parameter_list|)
block|{
name|QBParseInfo
name|qbParseInfo
init|=
name|localQb
operator|.
name|getParseInfo
argument_list|()
decl_stmt|;
if|if
condition|(
name|localQb
operator|.
name|getNumSelDi
argument_list|()
operator|==
literal|0
operator|&&
name|qbParseInfo
operator|.
name|getDestToClusterBy
argument_list|()
operator|.
name|isEmpty
argument_list|()
operator|&&
name|qbParseInfo
operator|.
name|getDestToDistributeBy
argument_list|()
operator|.
name|isEmpty
argument_list|()
operator|&&
name|qbParseInfo
operator|.
name|getDestToOrderBy
argument_list|()
operator|.
name|isEmpty
argument_list|()
operator|&&
name|qbParseInfo
operator|.
name|getDestToSortBy
argument_list|()
operator|.
name|isEmpty
argument_list|()
operator|&&
name|qbParseInfo
operator|.
name|getDestToAggregationExprs
argument_list|()
operator|.
name|size
argument_list|()
operator|<=
literal|1
operator|&&
name|qbParseInfo
operator|.
name|getDestToDistinctFuncExprs
argument_list|()
operator|.
name|size
argument_list|()
operator|<=
literal|1
operator|&&
name|qbParseInfo
operator|.
name|getNameToSample
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
if|if
condition|(
operator|(
name|qbParseInfo
operator|.
name|getDestToAggregationExprs
argument_list|()
operator|.
name|size
argument_list|()
operator|<
literal|1
operator|||
name|qbParseInfo
operator|.
name|getDestToAggregationExprs
argument_list|()
operator|.
name|values
argument_list|()
operator|.
name|iterator
argument_list|()
operator|.
name|next
argument_list|()
operator|.
name|isEmpty
argument_list|()
operator|)
operator|&&
operator|(
name|qbParseInfo
operator|.
name|getDestToDistinctFuncExprs
argument_list|()
operator|.
name|size
argument_list|()
operator|<
literal|1
operator|||
name|qbParseInfo
operator|.
name|getDestToDistinctFuncExprs
argument_list|()
operator|.
name|values
argument_list|()
operator|.
name|iterator
argument_list|()
operator|.
name|next
argument_list|()
operator|.
name|isEmpty
argument_list|()
operator|)
operator|&&
name|qbParseInfo
operator|.
name|getDestToLimit
argument_list|()
operator|.
name|size
argument_list|()
operator|<=
literal|1
condition|)
block|{
name|Integer
name|retValue
decl_stmt|;
if|if
condition|(
name|qbParseInfo
operator|.
name|getDestToLimit
argument_list|()
operator|.
name|size
argument_list|()
operator|==
literal|0
condition|)
block|{
name|retValue
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|retValue
operator|=
name|qbParseInfo
operator|.
name|getDestToLimit
argument_list|()
operator|.
name|values
argument_list|()
operator|.
name|iterator
argument_list|()
operator|.
name|next
argument_list|()
operator|.
name|intValue
argument_list|()
expr_stmt|;
block|}
for|for
control|(
name|String
name|alias
range|:
name|localQb
operator|.
name|getSubqAliases
argument_list|()
control|)
block|{
name|Integer
name|limit
init|=
name|checkQbpForGlobalLimit
argument_list|(
name|localQb
operator|.
name|getSubqForAlias
argument_list|(
name|alias
argument_list|)
operator|.
name|getQB
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|limit
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
elseif|else
if|if
condition|(
name|retValue
operator|>
literal|0
operator|&&
name|limit
operator|>
literal|0
condition|)
block|{
comment|// Any query has more than one LIMITs shown in the query is not
comment|// qualified to this optimization
return|return
literal|null
return|;
block|}
elseif|else
if|if
condition|(
name|limit
operator|>
literal|0
condition|)
block|{
name|retValue
operator|=
name|limit
expr_stmt|;
block|}
block|}
return|return
name|retValue
return|;
block|}
block|}
return|return
literal|null
return|;
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"nls"
argument_list|)
specifier|private
name|void
name|genMapRedTasks
parameter_list|(
name|QB
name|qb
parameter_list|)
throws|throws
name|SemanticException
block|{
name|FetchWork
name|fetch
init|=
literal|null
decl_stmt|;
name|List
argument_list|<
name|Task
argument_list|<
name|?
extends|extends
name|Serializable
argument_list|>
argument_list|>
name|mvTask
init|=
operator|new
name|ArrayList
argument_list|<
name|Task
argument_list|<
name|?
extends|extends
name|Serializable
argument_list|>
argument_list|>
argument_list|()
decl_stmt|;
name|FetchTask
name|fetchTask
init|=
literal|null
decl_stmt|;
name|QBParseInfo
name|qbParseInfo
init|=
name|qb
operator|.
name|getParseInfo
argument_list|()
decl_stmt|;
comment|// Does this query need reduce job
if|if
condition|(
name|qb
operator|.
name|isSelectStarQuery
argument_list|()
operator|&&
name|qbParseInfo
operator|.
name|getDestToClusterBy
argument_list|()
operator|.
name|isEmpty
argument_list|()
operator|&&
name|qbParseInfo
operator|.
name|getDestToDistributeBy
argument_list|()
operator|.
name|isEmpty
argument_list|()
operator|&&
name|qbParseInfo
operator|.
name|getDestToOrderBy
argument_list|()
operator|.
name|isEmpty
argument_list|()
operator|&&
name|qbParseInfo
operator|.
name|getDestToSortBy
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|boolean
name|noMapRed
init|=
literal|false
decl_stmt|;
name|Iterator
argument_list|<
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|Table
argument_list|>
argument_list|>
name|iter
init|=
name|qb
operator|.
name|getMetaData
argument_list|()
operator|.
name|getAliasToTable
argument_list|()
operator|.
name|entrySet
argument_list|()
operator|.
name|iterator
argument_list|()
decl_stmt|;
name|Table
name|tab
init|=
operator|(
name|iter
operator|.
name|next
argument_list|()
operator|)
operator|.
name|getValue
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|tab
operator|.
name|isPartitioned
argument_list|()
condition|)
block|{
if|if
condition|(
name|qbParseInfo
operator|.
name|getDestToWhereExpr
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|fetch
operator|=
operator|new
name|FetchWork
argument_list|(
name|tab
operator|.
name|getPath
argument_list|()
operator|.
name|toString
argument_list|()
argument_list|,
name|Utilities
operator|.
name|getTableDesc
argument_list|(
name|tab
argument_list|)
argument_list|,
name|qb
operator|.
name|getParseInfo
argument_list|()
operator|.
name|getOuterQueryLimit
argument_list|()
argument_list|)
expr_stmt|;
name|noMapRed
operator|=
literal|true
expr_stmt|;
name|inputs
operator|.
name|add
argument_list|(
operator|new
name|ReadEntity
argument_list|(
name|tab
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|topOps
operator|.
name|size
argument_list|()
operator|==
literal|1
condition|)
block|{
name|TableScanOperator
name|ts
init|=
operator|(
name|TableScanOperator
operator|)
name|topOps
operator|.
name|values
argument_list|()
operator|.
name|toArray
argument_list|()
index|[
literal|0
index|]
decl_stmt|;
comment|// check if the pruner only contains partition columns
if|if
condition|(
name|PartitionPruner
operator|.
name|onlyContainsPartnCols
argument_list|(
name|topToTable
operator|.
name|get
argument_list|(
name|ts
argument_list|)
argument_list|,
name|opToPartPruner
operator|.
name|get
argument_list|(
name|ts
argument_list|)
argument_list|)
condition|)
block|{
name|PrunedPartitionList
name|partsList
init|=
literal|null
decl_stmt|;
try|try
block|{
name|partsList
operator|=
name|opToPartList
operator|.
name|get
argument_list|(
name|ts
argument_list|)
expr_stmt|;
if|if
condition|(
name|partsList
operator|==
literal|null
condition|)
block|{
name|partsList
operator|=
name|PartitionPruner
operator|.
name|prune
argument_list|(
name|topToTable
operator|.
name|get
argument_list|(
name|ts
argument_list|)
argument_list|,
name|opToPartPruner
operator|.
name|get
argument_list|(
name|ts
argument_list|)
argument_list|,
name|conf
argument_list|,
operator|(
name|String
operator|)
name|topOps
operator|.
name|keySet
argument_list|()
operator|.
name|toArray
argument_list|()
index|[
literal|0
index|]
argument_list|,
name|prunedPartitions
argument_list|)
expr_stmt|;
name|opToPartList
operator|.
name|put
argument_list|(
name|ts
argument_list|,
name|partsList
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|HiveException
name|e
parameter_list|)
block|{
comment|// Has to use full name to make sure it does not conflict with
comment|// org.apache.commons.lang.StringUtils
name|LOG
operator|.
name|error
argument_list|(
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|StringUtils
operator|.
name|stringifyException
argument_list|(
name|e
argument_list|)
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|SemanticException
argument_list|(
name|e
operator|.
name|getMessage
argument_list|()
argument_list|,
name|e
argument_list|)
throw|;
block|}
comment|// If there is any unknown partition, create a map-reduce job for
comment|// the filter to prune correctly
if|if
condition|(
operator|(
name|partsList
operator|.
name|getUnknownPartns
argument_list|()
operator|.
name|size
argument_list|()
operator|==
literal|0
operator|)
condition|)
block|{
name|List
argument_list|<
name|String
argument_list|>
name|listP
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|PartitionDesc
argument_list|>
name|partP
init|=
operator|new
name|ArrayList
argument_list|<
name|PartitionDesc
argument_list|>
argument_list|()
decl_stmt|;
name|Set
argument_list|<
name|Partition
argument_list|>
name|parts
init|=
name|partsList
operator|.
name|getConfirmedPartns
argument_list|()
decl_stmt|;
name|Iterator
argument_list|<
name|Partition
argument_list|>
name|iterParts
init|=
name|parts
operator|.
name|iterator
argument_list|()
decl_stmt|;
while|while
condition|(
name|iterParts
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|Partition
name|part
init|=
name|iterParts
operator|.
name|next
argument_list|()
decl_stmt|;
name|listP
operator|.
name|add
argument_list|(
name|part
operator|.
name|getPartitionPath
argument_list|()
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
try|try
block|{
name|partP
operator|.
name|add
argument_list|(
name|Utilities
operator|.
name|getPartitionDesc
argument_list|(
name|part
argument_list|)
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|HiveException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|e
operator|.
name|getMessage
argument_list|()
argument_list|,
name|e
argument_list|)
throw|;
block|}
name|inputs
operator|.
name|add
argument_list|(
operator|new
name|ReadEntity
argument_list|(
name|part
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|fetch
operator|=
operator|new
name|FetchWork
argument_list|(
name|listP
argument_list|,
name|partP
argument_list|,
name|qb
operator|.
name|getParseInfo
argument_list|()
operator|.
name|getOuterQueryLimit
argument_list|()
argument_list|)
expr_stmt|;
name|noMapRed
operator|=
literal|true
expr_stmt|;
block|}
block|}
block|}
block|}
if|if
condition|(
name|noMapRed
condition|)
block|{
if|if
condition|(
name|fetch
operator|.
name|getTblDesc
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|PlanUtils
operator|.
name|configureTableJobPropertiesForStorageHandler
argument_list|(
name|fetch
operator|.
name|getTblDesc
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|fetchTask
operator|=
operator|(
name|FetchTask
operator|)
name|TaskFactory
operator|.
name|get
argument_list|(
name|fetch
argument_list|,
name|conf
argument_list|)
expr_stmt|;
name|setFetchTask
argument_list|(
name|fetchTask
argument_list|)
expr_stmt|;
comment|// remove root tasks if any
name|rootTasks
operator|.
name|clear
argument_list|()
expr_stmt|;
return|return;
block|}
block|}
comment|// determine the query qualifies reduce input size for LIMIT
comment|// The query only qualifies when there are only one top operator
comment|// and there is no transformer or UDTF and no block sampling
comment|// is used.
if|if
condition|(
name|HiveConf
operator|.
name|getBoolVar
argument_list|(
name|conf
argument_list|,
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVELIMITOPTENABLE
argument_list|)
operator|&&
name|ctx
operator|.
name|getTryCount
argument_list|()
operator|==
literal|0
operator|&&
name|topOps
operator|.
name|size
argument_list|()
operator|==
literal|1
operator|&&
operator|!
name|globalLimitCtx
operator|.
name|ifHasTransformOrUDTF
argument_list|()
operator|&&
name|nameToSplitSample
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
comment|// Here we recursively check:
comment|// 1. whether there are exact one LIMIT in the query
comment|// 2. whether there is no aggregation, group-by, distinct, sort by,
comment|//    distributed by, or table sampling in any of the sub-query.
comment|// The query only qualifies if both conditions are satisfied.
comment|//
comment|// Example qualified queries:
comment|//    CREATE TABLE ... AS SELECT col1, col2 FROM tbl LIMIT ..
comment|//    INSERT OVERWRITE TABLE ... SELECT col1, hash(col2), split(col1)
comment|//                               FROM ... LIMIT...
comment|//    SELECT * FROM (SELECT col1 as col2 (SELECT * FROM ...) t1 LIMIT ...) t2);
comment|//
name|Integer
name|tempGlobalLimit
init|=
name|checkQbpForGlobalLimit
argument_list|(
name|qb
argument_list|)
decl_stmt|;
comment|// query qualify for the optimization
if|if
condition|(
name|tempGlobalLimit
operator|!=
literal|null
operator|&&
name|tempGlobalLimit
operator|!=
literal|0
condition|)
block|{
name|TableScanOperator
name|ts
init|=
operator|(
name|TableScanOperator
operator|)
name|topOps
operator|.
name|values
argument_list|()
operator|.
name|toArray
argument_list|()
index|[
literal|0
index|]
decl_stmt|;
name|Table
name|tab
init|=
name|topToTable
operator|.
name|get
argument_list|(
name|ts
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|tab
operator|.
name|isPartitioned
argument_list|()
condition|)
block|{
if|if
condition|(
name|qbParseInfo
operator|.
name|getDestToWhereExpr
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|globalLimitCtx
operator|.
name|enableOpt
argument_list|(
name|tempGlobalLimit
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// check if the pruner only contains partition columns
if|if
condition|(
name|PartitionPruner
operator|.
name|onlyContainsPartnCols
argument_list|(
name|tab
argument_list|,
name|opToPartPruner
operator|.
name|get
argument_list|(
name|ts
argument_list|)
argument_list|)
condition|)
block|{
name|PrunedPartitionList
name|partsList
init|=
literal|null
decl_stmt|;
try|try
block|{
name|partsList
operator|=
name|opToPartList
operator|.
name|get
argument_list|(
name|ts
argument_list|)
expr_stmt|;
if|if
condition|(
name|partsList
operator|==
literal|null
condition|)
block|{
name|partsList
operator|=
name|PartitionPruner
operator|.
name|prune
argument_list|(
name|tab
argument_list|,
name|opToPartPruner
operator|.
name|get
argument_list|(
name|ts
argument_list|)
argument_list|,
name|conf
argument_list|,
operator|(
name|String
operator|)
name|topOps
operator|.
name|keySet
argument_list|()
operator|.
name|toArray
argument_list|()
index|[
literal|0
index|]
argument_list|,
name|prunedPartitions
argument_list|)
expr_stmt|;
name|opToPartList
operator|.
name|put
argument_list|(
name|ts
argument_list|,
name|partsList
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|HiveException
name|e
parameter_list|)
block|{
comment|// Has to use full name to make sure it does not conflict with
comment|// org.apache.commons.lang.StringUtils
name|LOG
operator|.
name|error
argument_list|(
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|StringUtils
operator|.
name|stringifyException
argument_list|(
name|e
argument_list|)
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|SemanticException
argument_list|(
name|e
operator|.
name|getMessage
argument_list|()
argument_list|,
name|e
argument_list|)
throw|;
block|}
comment|// If there is any unknown partition, create a map-reduce job for
comment|// the filter to prune correctly
if|if
condition|(
operator|(
name|partsList
operator|.
name|getUnknownPartns
argument_list|()
operator|.
name|size
argument_list|()
operator|==
literal|0
operator|)
condition|)
block|{
name|globalLimitCtx
operator|.
name|enableOpt
argument_list|(
name|tempGlobalLimit
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|globalLimitCtx
operator|.
name|isEnable
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Qualify the optimize that reduces input size for 'limit' for limit "
operator|+
name|globalLimitCtx
operator|.
name|getGlobalLimit
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|// In case of a select, use a fetch task instead of a move task
if|if
condition|(
name|qb
operator|.
name|getIsQuery
argument_list|()
condition|)
block|{
if|if
condition|(
operator|(
operator|!
name|loadTableWork
operator|.
name|isEmpty
argument_list|()
operator|)
operator|||
operator|(
name|loadFileWork
operator|.
name|size
argument_list|()
operator|!=
literal|1
operator|)
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|GENERIC_ERROR
operator|.
name|getMsg
argument_list|()
argument_list|)
throw|;
block|}
name|String
name|cols
init|=
name|loadFileWork
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|getColumns
argument_list|()
decl_stmt|;
name|String
name|colTypes
init|=
name|loadFileWork
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|getColumnTypes
argument_list|()
decl_stmt|;
name|String
name|resFileFormat
init|=
name|HiveConf
operator|.
name|getVar
argument_list|(
name|conf
argument_list|,
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVEQUERYRESULTFILEFORMAT
argument_list|)
decl_stmt|;
name|TableDesc
name|resultTab
init|=
name|PlanUtils
operator|.
name|getDefaultQueryOutputTableDesc
argument_list|(
name|cols
argument_list|,
name|colTypes
argument_list|,
name|resFileFormat
argument_list|)
decl_stmt|;
name|fetch
operator|=
operator|new
name|FetchWork
argument_list|(
operator|new
name|Path
argument_list|(
name|loadFileWork
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|getSourceDir
argument_list|()
argument_list|)
operator|.
name|toString
argument_list|()
argument_list|,
name|resultTab
argument_list|,
name|qb
operator|.
name|getParseInfo
argument_list|()
operator|.
name|getOuterQueryLimit
argument_list|()
argument_list|)
expr_stmt|;
name|fetchTask
operator|=
operator|(
name|FetchTask
operator|)
name|TaskFactory
operator|.
name|get
argument_list|(
name|fetch
argument_list|,
name|conf
argument_list|)
expr_stmt|;
name|setFetchTask
argument_list|(
name|fetchTask
argument_list|)
expr_stmt|;
comment|// For the FetchTask, the limit optimiztion requires we fetch all the rows
comment|// in memory and count how many rows we get. It's not practical if the
comment|// limit factor is too big
name|int
name|fetchLimit
init|=
name|HiveConf
operator|.
name|getIntVar
argument_list|(
name|conf
argument_list|,
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVELIMITOPTMAXFETCH
argument_list|)
decl_stmt|;
if|if
condition|(
name|globalLimitCtx
operator|.
name|isEnable
argument_list|()
operator|&&
name|globalLimitCtx
operator|.
name|getGlobalLimit
argument_list|()
operator|>
name|fetchLimit
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"For FetchTask, LIMIT "
operator|+
name|globalLimitCtx
operator|.
name|getGlobalLimit
argument_list|()
operator|+
literal|"> "
operator|+
name|fetchLimit
operator|+
literal|". Doesn't qualify limit optimiztion."
argument_list|)
expr_stmt|;
name|globalLimitCtx
operator|.
name|disableOpt
argument_list|()
expr_stmt|;
block|}
block|}
else|else
block|{
for|for
control|(
name|LoadTableDesc
name|ltd
range|:
name|loadTableWork
control|)
block|{
name|Task
argument_list|<
name|MoveWork
argument_list|>
name|tsk
init|=
name|TaskFactory
operator|.
name|get
argument_list|(
operator|new
name|MoveWork
argument_list|(
literal|null
argument_list|,
literal|null
argument_list|,
name|ltd
argument_list|,
literal|null
argument_list|,
literal|false
argument_list|)
argument_list|,
name|conf
argument_list|)
decl_stmt|;
name|mvTask
operator|.
name|add
argument_list|(
name|tsk
argument_list|)
expr_stmt|;
block|}
name|boolean
name|oneLoadFile
init|=
literal|true
decl_stmt|;
for|for
control|(
name|LoadFileDesc
name|lfd
range|:
name|loadFileWork
control|)
block|{
if|if
condition|(
name|qb
operator|.
name|isCTAS
argument_list|()
condition|)
block|{
assert|assert
operator|(
name|oneLoadFile
operator|)
assert|;
comment|// should not have more than 1 load file for
comment|// CTAS
comment|// make the movetask's destination directory the table's destination.
name|String
name|location
init|=
name|qb
operator|.
name|getTableDesc
argument_list|()
operator|.
name|getLocation
argument_list|()
decl_stmt|;
if|if
condition|(
name|location
operator|==
literal|null
condition|)
block|{
comment|// get the table's default location
name|Table
name|dumpTable
decl_stmt|;
name|Path
name|targetPath
decl_stmt|;
try|try
block|{
name|dumpTable
operator|=
name|db
operator|.
name|newTable
argument_list|(
name|qb
operator|.
name|getTableDesc
argument_list|()
operator|.
name|getTableName
argument_list|()
argument_list|)
expr_stmt|;
name|Warehouse
name|wh
init|=
operator|new
name|Warehouse
argument_list|(
name|conf
argument_list|)
decl_stmt|;
name|targetPath
operator|=
name|wh
operator|.
name|getTablePath
argument_list|(
name|db
operator|.
name|getDatabase
argument_list|(
name|dumpTable
operator|.
name|getDbName
argument_list|()
argument_list|)
argument_list|,
name|dumpTable
operator|.
name|getTableName
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|HiveException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|e
argument_list|)
throw|;
block|}
catch|catch
parameter_list|(
name|MetaException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|e
argument_list|)
throw|;
block|}
name|location
operator|=
name|targetPath
operator|.
name|toString
argument_list|()
expr_stmt|;
block|}
name|lfd
operator|.
name|setTargetDir
argument_list|(
name|location
argument_list|)
expr_stmt|;
name|oneLoadFile
operator|=
literal|false
expr_stmt|;
block|}
name|mvTask
operator|.
name|add
argument_list|(
name|TaskFactory
operator|.
name|get
argument_list|(
operator|new
name|MoveWork
argument_list|(
literal|null
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
name|lfd
argument_list|,
literal|false
argument_list|)
argument_list|,
name|conf
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|// generate map reduce plans
name|ParseContext
name|tempParseContext
init|=
name|getParseContext
argument_list|()
decl_stmt|;
name|GenMRProcContext
name|procCtx
init|=
operator|new
name|GenMRProcContext
argument_list|(
name|conf
argument_list|,
operator|new
name|HashMap
argument_list|<
name|Operator
argument_list|<
name|?
extends|extends
name|Serializable
argument_list|>
argument_list|,
name|Task
argument_list|<
name|?
extends|extends
name|Serializable
argument_list|>
argument_list|>
argument_list|()
condition|,
operator|new
name|ArrayList
argument_list|<
name|Operator
argument_list|<
name|?
extends|extends
name|Serializable
argument_list|>
argument_list|>
argument_list|()
condition|,
name|tempParseContext
condition|,
name|mvTask
condition|,
name|rootTasks
condition|,
operator|new
name|LinkedHashMap
argument_list|<
name|Operator
argument_list|<
name|?
extends|extends
name|Serializable
argument_list|>
argument_list|,
name|GenMapRedCtx
argument_list|>
argument_list|()
condition|,
name|inputs
condition|,
name|outputs
argument_list|)
decl_stmt|;
comment|// create a walker which walks the tree in a DFS manner while maintaining
comment|// the operator stack.
comment|// The dispatcher generates the plan from the operator tree
name|Map
argument_list|<
name|Rule
argument_list|,
name|NodeProcessor
argument_list|>
name|opRules
init|=
operator|new
name|LinkedHashMap
argument_list|<
name|Rule
argument_list|,
name|NodeProcessor
argument_list|>
argument_list|()
decl_stmt|;
name|opRules
operator|.
name|put
argument_list|(
operator|new
name|RuleRegExp
argument_list|(
operator|new
name|String
argument_list|(
literal|"R1"
argument_list|)
argument_list|,
literal|"TS%"
argument_list|)
argument_list|,
operator|new
name|GenMRTableScan1
argument_list|()
argument_list|)
expr_stmt|;
name|opRules
operator|.
name|put
argument_list|(
operator|new
name|RuleRegExp
argument_list|(
operator|new
name|String
argument_list|(
literal|"R2"
argument_list|)
argument_list|,
literal|"TS%.*RS%"
argument_list|)
argument_list|,
operator|new
name|GenMRRedSink1
argument_list|()
argument_list|)
expr_stmt|;
name|opRules
operator|.
name|put
argument_list|(
operator|new
name|RuleRegExp
argument_list|(
operator|new
name|String
argument_list|(
literal|"R3"
argument_list|)
argument_list|,
literal|"RS%.*RS%"
argument_list|)
argument_list|,
operator|new
name|GenMRRedSink2
argument_list|()
argument_list|)
expr_stmt|;
name|opRules
operator|.
name|put
argument_list|(
operator|new
name|RuleRegExp
argument_list|(
operator|new
name|String
argument_list|(
literal|"R4"
argument_list|)
argument_list|,
literal|"FS%"
argument_list|)
argument_list|,
operator|new
name|GenMRFileSink1
argument_list|()
argument_list|)
expr_stmt|;
name|opRules
operator|.
name|put
argument_list|(
operator|new
name|RuleRegExp
argument_list|(
operator|new
name|String
argument_list|(
literal|"R5"
argument_list|)
argument_list|,
literal|"UNION%"
argument_list|)
argument_list|,
operator|new
name|GenMRUnion1
argument_list|()
argument_list|)
expr_stmt|;
name|opRules
operator|.
name|put
argument_list|(
operator|new
name|RuleRegExp
argument_list|(
operator|new
name|String
argument_list|(
literal|"R6"
argument_list|)
argument_list|,
literal|"UNION%.*RS%"
argument_list|)
argument_list|,
operator|new
name|GenMRRedSink3
argument_list|()
argument_list|)
expr_stmt|;
name|opRules
operator|.
name|put
argument_list|(
operator|new
name|RuleRegExp
argument_list|(
operator|new
name|String
argument_list|(
literal|"R6"
argument_list|)
argument_list|,
literal|"MAPJOIN%.*RS%"
argument_list|)
argument_list|,
operator|new
name|GenMRRedSink4
argument_list|()
argument_list|)
expr_stmt|;
name|opRules
operator|.
name|put
argument_list|(
operator|new
name|RuleRegExp
argument_list|(
operator|new
name|String
argument_list|(
literal|"R7"
argument_list|)
argument_list|,
literal|"TS%.*MAPJOIN%"
argument_list|)
argument_list|,
name|MapJoinFactory
operator|.
name|getTableScanMapJoin
argument_list|()
argument_list|)
expr_stmt|;
name|opRules
operator|.
name|put
argument_list|(
operator|new
name|RuleRegExp
argument_list|(
operator|new
name|String
argument_list|(
literal|"R8"
argument_list|)
argument_list|,
literal|"RS%.*MAPJOIN%"
argument_list|)
argument_list|,
name|MapJoinFactory
operator|.
name|getReduceSinkMapJoin
argument_list|()
argument_list|)
expr_stmt|;
name|opRules
operator|.
name|put
argument_list|(
operator|new
name|RuleRegExp
argument_list|(
operator|new
name|String
argument_list|(
literal|"R9"
argument_list|)
argument_list|,
literal|"UNION%.*MAPJOIN%"
argument_list|)
argument_list|,
name|MapJoinFactory
operator|.
name|getUnionMapJoin
argument_list|()
argument_list|)
expr_stmt|;
name|opRules
operator|.
name|put
argument_list|(
operator|new
name|RuleRegExp
argument_list|(
operator|new
name|String
argument_list|(
literal|"R10"
argument_list|)
argument_list|,
literal|"MAPJOIN%.*MAPJOIN%"
argument_list|)
argument_list|,
name|MapJoinFactory
operator|.
name|getMapJoinMapJoin
argument_list|()
argument_list|)
expr_stmt|;
name|opRules
operator|.
name|put
argument_list|(
operator|new
name|RuleRegExp
argument_list|(
operator|new
name|String
argument_list|(
literal|"R11"
argument_list|)
argument_list|,
literal|"MAPJOIN%SEL%"
argument_list|)
argument_list|,
name|MapJoinFactory
operator|.
name|getMapJoin
argument_list|()
argument_list|)
expr_stmt|;
comment|// The dispatcher fires the processor corresponding to the closest matching
comment|// rule and passes the context along
name|Dispatcher
name|disp
init|=
operator|new
name|DefaultRuleDispatcher
argument_list|(
operator|new
name|GenMROperator
argument_list|()
argument_list|,
name|opRules
argument_list|,
name|procCtx
argument_list|)
decl_stmt|;
name|GraphWalker
name|ogw
init|=
operator|new
name|GenMapRedWalker
argument_list|(
name|disp
argument_list|)
decl_stmt|;
name|ArrayList
argument_list|<
name|Node
argument_list|>
name|topNodes
init|=
operator|new
name|ArrayList
argument_list|<
name|Node
argument_list|>
argument_list|()
decl_stmt|;
name|topNodes
operator|.
name|addAll
argument_list|(
name|topOps
operator|.
name|values
argument_list|()
argument_list|)
expr_stmt|;
name|ogw
operator|.
name|startWalking
argument_list|(
name|topNodes
argument_list|,
literal|null
argument_list|)
expr_stmt|;
comment|// reduce sink does not have any kids - since the plan by now has been
comment|// broken up into multiple
comment|// tasks, iterate over all tasks.
comment|// For each task, go over all operators recursively
for|for
control|(
name|Task
argument_list|<
name|?
extends|extends
name|Serializable
argument_list|>
name|rootTask
range|:
name|rootTasks
control|)
block|{
name|breakTaskTree
argument_list|(
name|rootTask
argument_list|)
expr_stmt|;
block|}
comment|// For each task, set the key descriptor for the reducer
for|for
control|(
name|Task
argument_list|<
name|?
extends|extends
name|Serializable
argument_list|>
name|rootTask
range|:
name|rootTasks
control|)
block|{
name|setKeyDescTaskTree
argument_list|(
name|rootTask
argument_list|)
expr_stmt|;
block|}
name|PhysicalContext
name|physicalContext
init|=
operator|new
name|PhysicalContext
argument_list|(
name|conf
argument_list|,
name|getParseContext
argument_list|()
argument_list|,
name|ctx
argument_list|,
name|rootTasks
argument_list|,
name|fetchTask
argument_list|)
decl_stmt|;
name|PhysicalOptimizer
name|physicalOptimizer
init|=
operator|new
name|PhysicalOptimizer
argument_list|(
name|physicalContext
argument_list|,
name|conf
argument_list|)
decl_stmt|;
name|physicalOptimizer
operator|.
name|optimize
argument_list|()
expr_stmt|;
comment|// For each operator, generate the counters if needed
if|if
condition|(
name|HiveConf
operator|.
name|getBoolVar
argument_list|(
name|conf
argument_list|,
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVEJOBPROGRESS
argument_list|)
condition|)
block|{
for|for
control|(
name|Task
argument_list|<
name|?
extends|extends
name|Serializable
argument_list|>
name|rootTask
range|:
name|rootTasks
control|)
block|{
name|generateCountersTask
argument_list|(
name|rootTask
argument_list|)
expr_stmt|;
block|}
block|}
name|decideExecMode
argument_list|(
name|rootTasks
argument_list|,
name|ctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|qb
operator|.
name|isCTAS
argument_list|()
condition|)
block|{
comment|// generate a DDL task and make it a dependent task of the leaf
name|CreateTableDesc
name|crtTblDesc
init|=
name|qb
operator|.
name|getTableDesc
argument_list|()
decl_stmt|;
name|validateCreateTable
argument_list|(
name|crtTblDesc
argument_list|)
expr_stmt|;
comment|// Clear the output for CTAS since we don't need the output from the
comment|// mapredWork, the
comment|// DDLWork at the tail of the chain will have the output
name|getOutputs
argument_list|()
operator|.
name|clear
argument_list|()
expr_stmt|;
name|Task
argument_list|<
name|?
extends|extends
name|Serializable
argument_list|>
name|crtTblTask
init|=
name|TaskFactory
operator|.
name|get
argument_list|(
operator|new
name|DDLWork
argument_list|(
name|getInputs
argument_list|()
argument_list|,
name|getOutputs
argument_list|()
argument_list|,
name|crtTblDesc
argument_list|)
argument_list|,
name|conf
argument_list|)
decl_stmt|;
comment|// find all leaf tasks and make the DDLTask as a dependent task of all of
comment|// them
name|HashSet
argument_list|<
name|Task
argument_list|<
name|?
extends|extends
name|Serializable
argument_list|>
argument_list|>
name|leaves
init|=
operator|new
name|HashSet
argument_list|<
name|Task
argument_list|<
name|?
extends|extends
name|Serializable
argument_list|>
argument_list|>
argument_list|()
decl_stmt|;
name|getLeafTasks
argument_list|(
name|rootTasks
argument_list|,
name|leaves
argument_list|)
expr_stmt|;
assert|assert
operator|(
name|leaves
operator|.
name|size
argument_list|()
operator|>
literal|0
operator|)
assert|;
for|for
control|(
name|Task
argument_list|<
name|?
extends|extends
name|Serializable
argument_list|>
name|task
range|:
name|leaves
control|)
block|{
name|task
operator|.
name|addDependentTask
argument_list|(
name|crtTblTask
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|globalLimitCtx
operator|.
name|isEnable
argument_list|()
operator|&&
name|fetchTask
operator|!=
literal|null
condition|)
block|{
name|int
name|fetchLimit
init|=
name|HiveConf
operator|.
name|getIntVar
argument_list|(
name|conf
argument_list|,
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVELIMITOPTMAXFETCH
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"set least row check for FetchTask: "
operator|+
name|globalLimitCtx
operator|.
name|getGlobalLimit
argument_list|()
argument_list|)
expr_stmt|;
name|fetchTask
operator|.
name|getWork
argument_list|()
operator|.
name|setLeastNumRows
argument_list|(
name|globalLimitCtx
operator|.
name|getGlobalLimit
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|globalLimitCtx
operator|.
name|isEnable
argument_list|()
operator|&&
name|globalLimitCtx
operator|.
name|getLastReduceLimitDesc
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"set least row check for LimitDesc: "
operator|+
name|globalLimitCtx
operator|.
name|getGlobalLimit
argument_list|()
argument_list|)
expr_stmt|;
name|globalLimitCtx
operator|.
name|getLastReduceLimitDesc
argument_list|()
operator|.
name|setLeastRows
argument_list|(
name|globalLimitCtx
operator|.
name|getGlobalLimit
argument_list|()
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|ExecDriver
argument_list|>
name|mrTasks
init|=
name|Utilities
operator|.
name|getMRTasks
argument_list|(
name|rootTasks
argument_list|)
decl_stmt|;
for|for
control|(
name|ExecDriver
name|tsk
range|:
name|mrTasks
control|)
block|{
name|tsk
operator|.
name|setRetryCmdWhenFail
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**    * Find all leaf tasks of the list of root tasks.    */
specifier|private
name|void
name|getLeafTasks
parameter_list|(
name|List
argument_list|<
name|Task
argument_list|<
name|?
extends|extends
name|Serializable
argument_list|>
argument_list|>
name|rootTasks
parameter_list|,
name|HashSet
argument_list|<
name|Task
argument_list|<
name|?
extends|extends
name|Serializable
argument_list|>
argument_list|>
name|leaves
parameter_list|)
block|{
for|for
control|(
name|Task
argument_list|<
name|?
extends|extends
name|Serializable
argument_list|>
name|root
range|:
name|rootTasks
control|)
block|{
name|getLeafTasks
argument_list|(
name|root
argument_list|,
name|leaves
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|getLeafTasks
parameter_list|(
name|Task
argument_list|<
name|?
extends|extends
name|Serializable
argument_list|>
name|task
parameter_list|,
name|HashSet
argument_list|<
name|Task
argument_list|<
name|?
extends|extends
name|Serializable
argument_list|>
argument_list|>
name|leaves
parameter_list|)
block|{
if|if
condition|(
name|task
operator|.
name|getDependentTasks
argument_list|()
operator|==
literal|null
condition|)
block|{
if|if
condition|(
operator|!
name|leaves
operator|.
name|contains
argument_list|(
name|task
argument_list|)
condition|)
block|{
name|leaves
operator|.
name|add
argument_list|(
name|task
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|getLeafTasks
argument_list|(
name|task
operator|.
name|getDependentTasks
argument_list|()
argument_list|,
name|leaves
argument_list|)
expr_stmt|;
block|}
block|}
comment|// loop over all the tasks recursviely
specifier|private
name|void
name|generateCountersTask
parameter_list|(
name|Task
argument_list|<
name|?
extends|extends
name|Serializable
argument_list|>
name|task
parameter_list|)
block|{
if|if
condition|(
name|task
operator|instanceof
name|ExecDriver
condition|)
block|{
name|HashMap
argument_list|<
name|String
argument_list|,
name|Operator
argument_list|<
name|?
extends|extends
name|Serializable
argument_list|>
argument_list|>
name|opMap
init|=
operator|(
operator|(
name|MapredWork
operator|)
name|task
operator|.
name|getWork
argument_list|()
operator|)
operator|.
name|getAliasToWork
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|opMap
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
for|for
control|(
name|Operator
argument_list|<
name|?
extends|extends
name|Serializable
argument_list|>
name|op
range|:
name|opMap
operator|.
name|values
argument_list|()
control|)
block|{
name|generateCountersOperator
argument_list|(
name|op
argument_list|)
expr_stmt|;
block|}
block|}
name|Operator
argument_list|<
name|?
extends|extends
name|Serializable
argument_list|>
name|reducer
init|=
operator|(
operator|(
name|MapredWork
operator|)
name|task
operator|.
name|getWork
argument_list|()
operator|)
operator|.
name|getReducer
argument_list|()
decl_stmt|;
if|if
condition|(
name|reducer
operator|!=
literal|null
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Generating counters for operator "
operator|+
name|reducer
argument_list|)
expr_stmt|;
name|generateCountersOperator
argument_list|(
name|reducer
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|task
operator|instanceof
name|ConditionalTask
condition|)
block|{
name|List
argument_list|<
name|Task
argument_list|<
name|?
extends|extends
name|Serializable
argument_list|>
argument_list|>
name|listTasks
init|=
operator|(
operator|(
name|ConditionalTask
operator|)
name|task
operator|)
operator|.
name|getListTasks
argument_list|()
decl_stmt|;
for|for
control|(
name|Task
argument_list|<
name|?
extends|extends
name|Serializable
argument_list|>
name|tsk
range|:
name|listTasks
control|)
block|{
name|generateCountersTask
argument_list|(
name|tsk
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Start the counters from scratch - a hack for hadoop 17.
name|Operator
operator|.
name|resetLastEnumUsed
argument_list|()
expr_stmt|;
if|if
condition|(
name|task
operator|.
name|getChildTasks
argument_list|()
operator|==
literal|null
condition|)
block|{
return|return;
block|}
for|for
control|(
name|Task
argument_list|<
name|?
extends|extends
name|Serializable
argument_list|>
name|childTask
range|:
name|task
operator|.
name|getChildTasks
argument_list|()
control|)
block|{
name|generateCountersTask
argument_list|(
name|childTask
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|generateCountersOperator
parameter_list|(
name|Operator
argument_list|<
name|?
extends|extends
name|Serializable
argument_list|>
name|op
parameter_list|)
block|{
name|op
operator|.
name|assignCounterNameToEnum
argument_list|()
expr_stmt|;
if|if
condition|(
name|op
operator|.
name|getChildOperators
argument_list|()
operator|==
literal|null
condition|)
block|{
return|return;
block|}
for|for
control|(
name|Operator
argument_list|<
name|?
extends|extends
name|Serializable
argument_list|>
name|child
range|:
name|op
operator|.
name|getChildOperators
argument_list|()
control|)
block|{
name|generateCountersOperator
argument_list|(
name|child
argument_list|)
expr_stmt|;
block|}
block|}
comment|// loop over all the tasks recursviely
specifier|private
name|void
name|breakTaskTree
parameter_list|(
name|Task
argument_list|<
name|?
extends|extends
name|Serializable
argument_list|>
name|task
parameter_list|)
block|{
if|if
condition|(
name|task
operator|instanceof
name|ExecDriver
condition|)
block|{
name|HashMap
argument_list|<
name|String
argument_list|,
name|Operator
argument_list|<
name|?
extends|extends
name|Serializable
argument_list|>
argument_list|>
name|opMap
init|=
operator|(
operator|(
name|MapredWork
operator|)
name|task
operator|.
name|getWork
argument_list|()
operator|)
operator|.
name|getAliasToWork
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|opMap
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
for|for
control|(
name|Operator
argument_list|<
name|?
extends|extends
name|Serializable
argument_list|>
name|op
range|:
name|opMap
operator|.
name|values
argument_list|()
control|)
block|{
name|breakOperatorTree
argument_list|(
name|op
argument_list|)
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|task
operator|instanceof
name|ConditionalTask
condition|)
block|{
name|List
argument_list|<
name|Task
argument_list|<
name|?
extends|extends
name|Serializable
argument_list|>
argument_list|>
name|listTasks
init|=
operator|(
operator|(
name|ConditionalTask
operator|)
name|task
operator|)
operator|.
name|getListTasks
argument_list|()
decl_stmt|;
for|for
control|(
name|Task
argument_list|<
name|?
extends|extends
name|Serializable
argument_list|>
name|tsk
range|:
name|listTasks
control|)
block|{
name|breakTaskTree
argument_list|(
name|tsk
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|task
operator|.
name|getChildTasks
argument_list|()
operator|==
literal|null
condition|)
block|{
return|return;
block|}
for|for
control|(
name|Task
argument_list|<
name|?
extends|extends
name|Serializable
argument_list|>
name|childTask
range|:
name|task
operator|.
name|getChildTasks
argument_list|()
control|)
block|{
name|breakTaskTree
argument_list|(
name|childTask
argument_list|)
expr_stmt|;
block|}
block|}
comment|// loop over all the operators recursviely
specifier|private
name|void
name|breakOperatorTree
parameter_list|(
name|Operator
argument_list|<
name|?
extends|extends
name|Serializable
argument_list|>
name|topOp
parameter_list|)
block|{
if|if
condition|(
name|topOp
operator|instanceof
name|ReduceSinkOperator
condition|)
block|{
name|topOp
operator|.
name|setChildOperators
argument_list|(
literal|null
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|topOp
operator|.
name|getChildOperators
argument_list|()
operator|==
literal|null
condition|)
block|{
return|return;
block|}
for|for
control|(
name|Operator
argument_list|<
name|?
extends|extends
name|Serializable
argument_list|>
name|op
range|:
name|topOp
operator|.
name|getChildOperators
argument_list|()
control|)
block|{
name|breakOperatorTree
argument_list|(
name|op
argument_list|)
expr_stmt|;
block|}
block|}
comment|// loop over all the tasks recursviely
specifier|private
name|void
name|setKeyDescTaskTree
parameter_list|(
name|Task
argument_list|<
name|?
extends|extends
name|Serializable
argument_list|>
name|task
parameter_list|)
block|{
if|if
condition|(
name|task
operator|instanceof
name|ExecDriver
condition|)
block|{
name|MapredWork
name|work
init|=
operator|(
name|MapredWork
operator|)
name|task
operator|.
name|getWork
argument_list|()
decl_stmt|;
name|work
operator|.
name|deriveExplainAttributes
argument_list|()
expr_stmt|;
name|HashMap
argument_list|<
name|String
argument_list|,
name|Operator
argument_list|<
name|?
extends|extends
name|Serializable
argument_list|>
argument_list|>
name|opMap
init|=
name|work
operator|.
name|getAliasToWork
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|opMap
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
for|for
control|(
name|Operator
argument_list|<
name|?
extends|extends
name|Serializable
argument_list|>
name|op
range|:
name|opMap
operator|.
name|values
argument_list|()
control|)
block|{
name|GenMapRedUtils
operator|.
name|setKeyAndValueDesc
argument_list|(
name|work
argument_list|,
name|op
argument_list|)
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|task
operator|instanceof
name|ConditionalTask
condition|)
block|{
name|List
argument_list|<
name|Task
argument_list|<
name|?
extends|extends
name|Serializable
argument_list|>
argument_list|>
name|listTasks
init|=
operator|(
operator|(
name|ConditionalTask
operator|)
name|task
operator|)
operator|.
name|getListTasks
argument_list|()
decl_stmt|;
for|for
control|(
name|Task
argument_list|<
name|?
extends|extends
name|Serializable
argument_list|>
name|tsk
range|:
name|listTasks
control|)
block|{
name|setKeyDescTaskTree
argument_list|(
name|tsk
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|task
operator|.
name|getChildTasks
argument_list|()
operator|==
literal|null
condition|)
block|{
return|return;
block|}
for|for
control|(
name|Task
argument_list|<
name|?
extends|extends
name|Serializable
argument_list|>
name|childTask
range|:
name|task
operator|.
name|getChildTasks
argument_list|()
control|)
block|{
name|setKeyDescTaskTree
argument_list|(
name|childTask
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"nls"
argument_list|)
specifier|public
name|Phase1Ctx
name|initPhase1Ctx
parameter_list|()
block|{
name|Phase1Ctx
name|ctx_1
init|=
operator|new
name|Phase1Ctx
argument_list|()
decl_stmt|;
name|ctx_1
operator|.
name|nextNum
operator|=
literal|0
expr_stmt|;
name|ctx_1
operator|.
name|dest
operator|=
literal|"reduce"
expr_stmt|;
return|return
name|ctx_1
return|;
block|}
annotation|@
name|Override
annotation|@
name|SuppressWarnings
argument_list|(
literal|"nls"
argument_list|)
specifier|public
name|void
name|analyzeInternal
parameter_list|(
name|ASTNode
name|ast
parameter_list|)
throws|throws
name|SemanticException
block|{
name|reset
argument_list|()
expr_stmt|;
name|QB
name|qb
init|=
operator|new
name|QB
argument_list|(
literal|null
argument_list|,
literal|null
argument_list|,
literal|false
argument_list|)
decl_stmt|;
name|this
operator|.
name|qb
operator|=
name|qb
expr_stmt|;
name|this
operator|.
name|ast
operator|=
name|ast
expr_stmt|;
name|ASTNode
name|child
init|=
name|ast
decl_stmt|;
name|viewsExpanded
operator|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Starting Semantic Analysis"
argument_list|)
expr_stmt|;
comment|// analyze create table command
if|if
condition|(
name|ast
operator|.
name|getToken
argument_list|()
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_CREATETABLE
condition|)
block|{
comment|// if it is not CTAS, we don't need to go further and just return
if|if
condition|(
operator|(
name|child
operator|=
name|analyzeCreateTable
argument_list|(
name|ast
argument_list|,
name|qb
argument_list|)
operator|)
operator|==
literal|null
condition|)
block|{
return|return;
block|}
block|}
else|else
block|{
name|SessionState
operator|.
name|get
argument_list|()
operator|.
name|setCommandType
argument_list|(
name|HiveOperation
operator|.
name|QUERY
argument_list|)
expr_stmt|;
block|}
comment|// analyze create view command
if|if
condition|(
name|ast
operator|.
name|getToken
argument_list|()
operator|.
name|getType
argument_list|()
operator|==
name|HiveParser
operator|.
name|TOK_CREATEVIEW
condition|)
block|{
name|child
operator|=
name|analyzeCreateView
argument_list|(
name|ast
argument_list|,
name|qb
argument_list|)
expr_stmt|;
name|SessionState
operator|.
name|get
argument_list|()
operator|.
name|setCommandType
argument_list|(
name|HiveOperation
operator|.
name|CREATEVIEW
argument_list|)
expr_stmt|;
if|if
condition|(
name|child
operator|==
literal|null
condition|)
block|{
return|return;
block|}
name|viewSelect
operator|=
name|child
expr_stmt|;
comment|// prevent view from referencing itself
name|viewsExpanded
operator|.
name|add
argument_list|(
name|db
operator|.
name|getCurrentDatabase
argument_list|()
operator|+
literal|"."
operator|+
name|createVwDesc
operator|.
name|getViewName
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// continue analyzing from the child ASTNode.
name|doPhase1
argument_list|(
name|child
argument_list|,
name|qb
argument_list|,
name|initPhase1Ctx
argument_list|()
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Completed phase 1 of Semantic Analysis"
argument_list|)
expr_stmt|;
name|getMetaData
argument_list|(
name|qb
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Completed getting MetaData in Semantic Analysis"
argument_list|)
expr_stmt|;
comment|// Save the result schema derived from the sink operator produced
comment|// by genPlan.  This has the correct column names, which clients
comment|// such as JDBC would prefer instead of the c0, c1 we'll end
comment|// up with later.
name|Operator
name|sinkOp
init|=
name|genPlan
argument_list|(
name|qb
argument_list|)
decl_stmt|;
name|resultSchema
operator|=
name|convertRowSchemaToViewSchema
argument_list|(
name|opParseCtx
operator|.
name|get
argument_list|(
name|sinkOp
argument_list|)
operator|.
name|getRowResolver
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|createVwDesc
operator|!=
literal|null
condition|)
block|{
name|saveViewDefinition
argument_list|()
expr_stmt|;
comment|// Since we're only creating a view (not executing it), we
comment|// don't need to optimize or translate the plan (and in fact, those
comment|// procedures can interfere with the view creation). So
comment|// skip the rest of this method.
name|ctx
operator|.
name|setResDir
argument_list|(
literal|null
argument_list|)
expr_stmt|;
name|ctx
operator|.
name|setResFile
argument_list|(
literal|null
argument_list|)
expr_stmt|;
return|return;
block|}
name|ParseContext
name|pCtx
init|=
operator|new
name|ParseContext
argument_list|(
name|conf
argument_list|,
name|qb
argument_list|,
name|child
argument_list|,
name|opToPartPruner
argument_list|,
name|opToPartList
argument_list|,
name|topOps
argument_list|,
name|topSelOps
argument_list|,
name|opParseCtx
argument_list|,
name|joinContext
argument_list|,
name|topToTable
argument_list|,
name|loadTableWork
argument_list|,
name|loadFileWork
argument_list|,
name|ctx
argument_list|,
name|idToTableNameMap
argument_list|,
name|destTableId
argument_list|,
name|uCtx
argument_list|,
name|listMapJoinOpsNoReducer
argument_list|,
name|groupOpToInputTables
argument_list|,
name|prunedPartitions
argument_list|,
name|opToSamplePruner
argument_list|,
name|globalLimitCtx
argument_list|,
name|nameToSplitSample
argument_list|,
name|inputs
argument_list|,
name|rootTasks
argument_list|)
decl_stmt|;
name|Optimizer
name|optm
init|=
operator|new
name|Optimizer
argument_list|()
decl_stmt|;
name|optm
operator|.
name|setPctx
argument_list|(
name|pCtx
argument_list|)
expr_stmt|;
name|optm
operator|.
name|initialize
argument_list|(
name|conf
argument_list|)
expr_stmt|;
name|pCtx
operator|=
name|optm
operator|.
name|optimize
argument_list|()
expr_stmt|;
name|init
argument_list|(
name|pCtx
argument_list|)
expr_stmt|;
name|qb
operator|=
name|pCtx
operator|.
name|getQB
argument_list|()
expr_stmt|;
comment|// At this point we have the complete operator tree
comment|// from which we want to find the reduce operator
name|genMapRedTasks
argument_list|(
name|qb
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Completed plan generation"
argument_list|)
expr_stmt|;
return|return;
block|}
annotation|@
name|Override
specifier|public
name|List
argument_list|<
name|FieldSchema
argument_list|>
name|getResultSchema
parameter_list|()
block|{
return|return
name|resultSchema
return|;
block|}
specifier|private
name|void
name|saveViewDefinition
parameter_list|()
throws|throws
name|SemanticException
block|{
comment|// Make a copy of the statement's result schema, since we may
comment|// modify it below as part of imposing view column names.
name|List
argument_list|<
name|FieldSchema
argument_list|>
name|derivedSchema
init|=
operator|new
name|ArrayList
argument_list|<
name|FieldSchema
argument_list|>
argument_list|(
name|resultSchema
argument_list|)
decl_stmt|;
name|validateColumnNameUniqueness
argument_list|(
name|derivedSchema
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|FieldSchema
argument_list|>
name|imposedSchema
init|=
name|createVwDesc
operator|.
name|getSchema
argument_list|()
decl_stmt|;
if|if
condition|(
name|imposedSchema
operator|!=
literal|null
condition|)
block|{
name|int
name|explicitColCount
init|=
name|imposedSchema
operator|.
name|size
argument_list|()
decl_stmt|;
name|int
name|derivedColCount
init|=
name|derivedSchema
operator|.
name|size
argument_list|()
decl_stmt|;
if|if
condition|(
name|explicitColCount
operator|!=
name|derivedColCount
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|generateErrorMessage
argument_list|(
name|viewSelect
argument_list|,
name|ErrorMsg
operator|.
name|VIEW_COL_MISMATCH
operator|.
name|getMsg
argument_list|()
argument_list|)
argument_list|)
throw|;
block|}
block|}
comment|// Preserve the original view definition as specified by the user.
name|String
name|originalText
init|=
name|ctx
operator|.
name|getTokenRewriteStream
argument_list|()
operator|.
name|toString
argument_list|(
name|viewSelect
operator|.
name|getTokenStartIndex
argument_list|()
argument_list|,
name|viewSelect
operator|.
name|getTokenStopIndex
argument_list|()
argument_list|)
decl_stmt|;
name|createVwDesc
operator|.
name|setViewOriginalText
argument_list|(
name|originalText
argument_list|)
expr_stmt|;
comment|// Now expand the view definition with extras such as explicit column
comment|// references; this expanded form is what we'll re-parse when the view is
comment|// referenced later.
name|unparseTranslator
operator|.
name|applyTranslations
argument_list|(
name|ctx
operator|.
name|getTokenRewriteStream
argument_list|()
argument_list|)
expr_stmt|;
name|String
name|expandedText
init|=
name|ctx
operator|.
name|getTokenRewriteStream
argument_list|()
operator|.
name|toString
argument_list|(
name|viewSelect
operator|.
name|getTokenStartIndex
argument_list|()
argument_list|,
name|viewSelect
operator|.
name|getTokenStopIndex
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|imposedSchema
operator|!=
literal|null
condition|)
block|{
comment|// Merge the names from the imposed schema into the types
comment|// from the derived schema.
name|StringBuilder
name|sb
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|"SELECT "
argument_list|)
expr_stmt|;
name|int
name|n
init|=
name|derivedSchema
operator|.
name|size
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|i
operator|>
literal|0
condition|)
block|{
name|sb
operator|.
name|append
argument_list|(
literal|", "
argument_list|)
expr_stmt|;
block|}
name|FieldSchema
name|fieldSchema
init|=
name|derivedSchema
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
comment|// Modify a copy, not the original
name|fieldSchema
operator|=
operator|new
name|FieldSchema
argument_list|(
name|fieldSchema
argument_list|)
expr_stmt|;
name|derivedSchema
operator|.
name|set
argument_list|(
name|i
argument_list|,
name|fieldSchema
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
name|HiveUtils
operator|.
name|unparseIdentifier
argument_list|(
name|fieldSchema
operator|.
name|getName
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|" AS "
argument_list|)
expr_stmt|;
name|String
name|imposedName
init|=
name|imposedSchema
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|getName
argument_list|()
decl_stmt|;
name|sb
operator|.
name|append
argument_list|(
name|HiveUtils
operator|.
name|unparseIdentifier
argument_list|(
name|imposedName
argument_list|)
argument_list|)
expr_stmt|;
name|fieldSchema
operator|.
name|setName
argument_list|(
name|imposedName
argument_list|)
expr_stmt|;
comment|// We don't currently allow imposition of a type
name|fieldSchema
operator|.
name|setComment
argument_list|(
name|imposedSchema
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|getComment
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|sb
operator|.
name|append
argument_list|(
literal|" FROM ("
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
name|expandedText
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|") "
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
name|HiveUtils
operator|.
name|unparseIdentifier
argument_list|(
name|createVwDesc
operator|.
name|getViewName
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|expandedText
operator|=
name|sb
operator|.
name|toString
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|createVwDesc
operator|.
name|getPartColNames
argument_list|()
operator|!=
literal|null
condition|)
block|{
comment|// Make sure all partitioning columns referenced actually
comment|// exist and are in the correct order at the end
comment|// of the list of columns produced by the view.  Also move the field
comment|// schema descriptors from derivedSchema to the partitioning key
comment|// descriptor.
name|List
argument_list|<
name|String
argument_list|>
name|partColNames
init|=
name|createVwDesc
operator|.
name|getPartColNames
argument_list|()
decl_stmt|;
if|if
condition|(
name|partColNames
operator|.
name|size
argument_list|()
operator|>
name|derivedSchema
operator|.
name|size
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|VIEW_PARTITION_MISMATCH
operator|.
name|getMsg
argument_list|()
argument_list|)
throw|;
block|}
comment|// Get the partition columns from the end of derivedSchema.
name|List
argument_list|<
name|FieldSchema
argument_list|>
name|partitionColumns
init|=
name|derivedSchema
operator|.
name|subList
argument_list|(
name|derivedSchema
operator|.
name|size
argument_list|()
operator|-
name|partColNames
operator|.
name|size
argument_list|()
argument_list|,
name|derivedSchema
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
comment|// Verify that the names match the PARTITIONED ON clause.
name|Iterator
argument_list|<
name|String
argument_list|>
name|colNameIter
init|=
name|partColNames
operator|.
name|iterator
argument_list|()
decl_stmt|;
name|Iterator
argument_list|<
name|FieldSchema
argument_list|>
name|schemaIter
init|=
name|partitionColumns
operator|.
name|iterator
argument_list|()
decl_stmt|;
while|while
condition|(
name|colNameIter
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|String
name|colName
init|=
name|colNameIter
operator|.
name|next
argument_list|()
decl_stmt|;
name|FieldSchema
name|fieldSchema
init|=
name|schemaIter
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|fieldSchema
operator|.
name|getName
argument_list|()
operator|.
name|equals
argument_list|(
name|colName
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|VIEW_PARTITION_MISMATCH
operator|.
name|getMsg
argument_list|()
argument_list|)
throw|;
block|}
block|}
comment|// Boundary case:  require at least one non-partitioned column
comment|// for consistency with tables.
if|if
condition|(
name|partColNames
operator|.
name|size
argument_list|()
operator|==
name|derivedSchema
operator|.
name|size
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|VIEW_PARTITION_TOTAL
operator|.
name|getMsg
argument_list|()
argument_list|)
throw|;
block|}
comment|// Now make a copy.
name|createVwDesc
operator|.
name|setPartCols
argument_list|(
operator|new
name|ArrayList
argument_list|<
name|FieldSchema
argument_list|>
argument_list|(
name|partitionColumns
argument_list|)
argument_list|)
expr_stmt|;
comment|// Finally, remove the partition columns from the end of derivedSchema.
comment|// (Clearing the subList writes through to the underlying
comment|// derivedSchema ArrayList.)
name|partitionColumns
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
name|createVwDesc
operator|.
name|setSchema
argument_list|(
name|derivedSchema
argument_list|)
expr_stmt|;
name|createVwDesc
operator|.
name|setViewExpandedText
argument_list|(
name|expandedText
argument_list|)
expr_stmt|;
block|}
specifier|private
name|List
argument_list|<
name|FieldSchema
argument_list|>
name|convertRowSchemaToViewSchema
parameter_list|(
name|RowResolver
name|rr
parameter_list|)
block|{
name|List
argument_list|<
name|FieldSchema
argument_list|>
name|fieldSchemas
init|=
operator|new
name|ArrayList
argument_list|<
name|FieldSchema
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|ColumnInfo
name|colInfo
range|:
name|rr
operator|.
name|getColumnInfos
argument_list|()
control|)
block|{
if|if
condition|(
name|colInfo
operator|.
name|isHiddenVirtualCol
argument_list|()
condition|)
block|{
continue|continue;
block|}
name|String
name|colName
init|=
name|rr
operator|.
name|reverseLookup
argument_list|(
name|colInfo
operator|.
name|getInternalName
argument_list|()
argument_list|)
index|[
literal|1
index|]
decl_stmt|;
name|fieldSchemas
operator|.
name|add
argument_list|(
operator|new
name|FieldSchema
argument_list|(
name|colName
argument_list|,
name|colInfo
operator|.
name|getType
argument_list|()
operator|.
name|getTypeName
argument_list|()
argument_list|,
literal|null
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|fieldSchemas
return|;
block|}
comment|/**    * Generates an expression node descriptor for the expression passed in the    * arguments. This function uses the row resolver and the metadata information    * that are passed as arguments to resolve the column names to internal names.    *    * @param expr    *          The expression    * @param input    *          The row resolver    * @return exprNodeDesc    * @throws SemanticException    */
specifier|public
name|ExprNodeDesc
name|genExprNodeDesc
parameter_list|(
name|ASTNode
name|expr
parameter_list|,
name|RowResolver
name|input
parameter_list|)
throws|throws
name|SemanticException
block|{
comment|// Since the user didn't supply a customized type-checking context,
comment|// use default settings.
name|TypeCheckCtx
name|tcCtx
init|=
operator|new
name|TypeCheckCtx
argument_list|(
name|input
argument_list|)
decl_stmt|;
return|return
name|genExprNodeDesc
argument_list|(
name|expr
argument_list|,
name|input
argument_list|,
name|tcCtx
argument_list|)
return|;
block|}
comment|/**    * Generates an expression node descriptor for the expression passed in the    * arguments. This function uses the row resolver and the metadata information    * that are passed as arguments to resolve the column names to internal names.    *    * @param expr    *          The expression    * @param input    *          The row resolver    * @param tcCtx    *          Customized type-checking context    * @return exprNodeDesc    * @throws SemanticException    */
annotation|@
name|SuppressWarnings
argument_list|(
literal|"nls"
argument_list|)
specifier|public
name|ExprNodeDesc
name|genExprNodeDesc
parameter_list|(
name|ASTNode
name|expr
parameter_list|,
name|RowResolver
name|input
parameter_list|,
name|TypeCheckCtx
name|tcCtx
parameter_list|)
throws|throws
name|SemanticException
block|{
comment|// We recursively create the exprNodeDesc. Base cases: when we encounter
comment|// a column ref, we convert that into an exprNodeColumnDesc; when we
comment|// encounter
comment|// a constant, we convert that into an exprNodeConstantDesc. For others we
comment|// just
comment|// build the exprNodeFuncDesc with recursively built children.
comment|// If the current subExpression is pre-calculated, as in Group-By etc.
name|ColumnInfo
name|colInfo
init|=
name|input
operator|.
name|getExpression
argument_list|(
name|expr
argument_list|)
decl_stmt|;
if|if
condition|(
name|colInfo
operator|!=
literal|null
condition|)
block|{
name|ASTNode
name|source
init|=
name|input
operator|.
name|getExpressionSource
argument_list|(
name|expr
argument_list|)
decl_stmt|;
if|if
condition|(
name|source
operator|!=
literal|null
condition|)
block|{
name|unparseTranslator
operator|.
name|addCopyTranslation
argument_list|(
name|expr
argument_list|,
name|source
argument_list|)
expr_stmt|;
block|}
return|return
operator|new
name|ExprNodeColumnDesc
argument_list|(
name|colInfo
operator|.
name|getType
argument_list|()
argument_list|,
name|colInfo
operator|.
name|getInternalName
argument_list|()
argument_list|,
name|colInfo
operator|.
name|getTabAlias
argument_list|()
argument_list|,
name|colInfo
operator|.
name|getIsVirtualCol
argument_list|()
argument_list|)
return|;
block|}
comment|// Create the walker and  the rules dispatcher.
name|tcCtx
operator|.
name|setUnparseTranslator
argument_list|(
name|unparseTranslator
argument_list|)
expr_stmt|;
name|HashMap
argument_list|<
name|Node
argument_list|,
name|Object
argument_list|>
name|nodeOutputs
init|=
name|TypeCheckProcFactory
operator|.
name|genExprNode
argument_list|(
name|expr
argument_list|,
name|tcCtx
argument_list|)
decl_stmt|;
name|ExprNodeDesc
name|desc
init|=
operator|(
name|ExprNodeDesc
operator|)
name|nodeOutputs
operator|.
name|get
argument_list|(
name|expr
argument_list|)
decl_stmt|;
if|if
condition|(
name|desc
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|tcCtx
operator|.
name|getError
argument_list|()
argument_list|)
throw|;
block|}
if|if
condition|(
operator|!
name|unparseTranslator
operator|.
name|isEnabled
argument_list|()
condition|)
block|{
comment|// Not creating a view, so no need to track view expansions.
return|return
name|desc
return|;
block|}
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|Node
argument_list|,
name|Object
argument_list|>
name|entry
range|:
name|nodeOutputs
operator|.
name|entrySet
argument_list|()
control|)
block|{
if|if
condition|(
operator|!
operator|(
name|entry
operator|.
name|getKey
argument_list|()
operator|instanceof
name|ASTNode
operator|)
condition|)
block|{
continue|continue;
block|}
if|if
condition|(
operator|!
operator|(
name|entry
operator|.
name|getValue
argument_list|()
operator|instanceof
name|ExprNodeColumnDesc
operator|)
condition|)
block|{
continue|continue;
block|}
name|ASTNode
name|node
init|=
operator|(
name|ASTNode
operator|)
name|entry
operator|.
name|getKey
argument_list|()
decl_stmt|;
name|ExprNodeColumnDesc
name|columnDesc
init|=
operator|(
name|ExprNodeColumnDesc
operator|)
name|entry
operator|.
name|getValue
argument_list|()
decl_stmt|;
if|if
condition|(
operator|(
name|columnDesc
operator|.
name|getTabAlias
argument_list|()
operator|==
literal|null
operator|)
operator|||
operator|(
name|columnDesc
operator|.
name|getTabAlias
argument_list|()
operator|.
name|length
argument_list|()
operator|==
literal|0
operator|)
condition|)
block|{
comment|// These aren't real column refs; instead, they are special
comment|// internal expressions used in the representation of aggregation.
continue|continue;
block|}
name|String
index|[]
name|tmp
init|=
name|input
operator|.
name|reverseLookup
argument_list|(
name|columnDesc
operator|.
name|getColumn
argument_list|()
argument_list|)
decl_stmt|;
name|StringBuilder
name|replacementText
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|replacementText
operator|.
name|append
argument_list|(
name|HiveUtils
operator|.
name|unparseIdentifier
argument_list|(
name|tmp
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|replacementText
operator|.
name|append
argument_list|(
literal|"."
argument_list|)
expr_stmt|;
name|replacementText
operator|.
name|append
argument_list|(
name|HiveUtils
operator|.
name|unparseIdentifier
argument_list|(
name|tmp
index|[
literal|1
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|unparseTranslator
operator|.
name|addTranslation
argument_list|(
name|node
argument_list|,
name|replacementText
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|desc
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|validate
parameter_list|()
throws|throws
name|SemanticException
block|{
comment|// Validate inputs and outputs have right protectmode to execute the query
for|for
control|(
name|ReadEntity
name|readEntity
range|:
name|getInputs
argument_list|()
control|)
block|{
name|ReadEntity
operator|.
name|Type
name|type
init|=
name|readEntity
operator|.
name|getType
argument_list|()
decl_stmt|;
if|if
condition|(
name|type
operator|!=
name|ReadEntity
operator|.
name|Type
operator|.
name|TABLE
operator|&&
name|type
operator|!=
name|ReadEntity
operator|.
name|Type
operator|.
name|PARTITION
condition|)
block|{
comment|// In current implementation it will never happen, but we leave it
comment|// here to make the logic complete.
continue|continue;
block|}
name|Table
name|tbl
init|=
name|readEntity
operator|.
name|getTable
argument_list|()
decl_stmt|;
name|Partition
name|p
init|=
name|readEntity
operator|.
name|getPartition
argument_list|()
decl_stmt|;
if|if
condition|(
name|tbl
operator|.
name|isOffline
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|OFFLINE_TABLE_OR_PARTITION
operator|.
name|getMsg
argument_list|(
literal|"Table "
operator|+
name|tbl
operator|.
name|getTableName
argument_list|()
argument_list|)
argument_list|)
throw|;
block|}
if|if
condition|(
name|type
operator|==
name|ReadEntity
operator|.
name|Type
operator|.
name|PARTITION
operator|&&
name|p
operator|!=
literal|null
operator|&&
name|p
operator|.
name|isOffline
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|OFFLINE_TABLE_OR_PARTITION
operator|.
name|getMsg
argument_list|(
literal|"Table "
operator|+
name|tbl
operator|.
name|getTableName
argument_list|()
operator|+
literal|" Partition "
operator|+
name|p
operator|.
name|getName
argument_list|()
argument_list|)
argument_list|)
throw|;
block|}
block|}
for|for
control|(
name|WriteEntity
name|writeEntity
range|:
name|getOutputs
argument_list|()
control|)
block|{
name|WriteEntity
operator|.
name|Type
name|type
init|=
name|writeEntity
operator|.
name|getType
argument_list|()
decl_stmt|;
if|if
condition|(
name|type
operator|!=
name|WriteEntity
operator|.
name|Type
operator|.
name|TABLE
operator|&&
name|type
operator|!=
name|WriteEntity
operator|.
name|Type
operator|.
name|PARTITION
condition|)
block|{
continue|continue;
block|}
name|Table
name|tbl
decl_stmt|;
name|Partition
name|p
decl_stmt|;
if|if
condition|(
name|type
operator|==
name|WriteEntity
operator|.
name|Type
operator|.
name|PARTITION
condition|)
block|{
name|Partition
name|inputPartition
init|=
name|writeEntity
operator|.
name|getPartition
argument_list|()
decl_stmt|;
comment|// If it is a partition, Partition's metastore is not fetched. We
comment|// need to fetch it.
try|try
block|{
name|p
operator|=
name|Hive
operator|.
name|get
argument_list|()
operator|.
name|getPartition
argument_list|(
name|inputPartition
operator|.
name|getTable
argument_list|()
argument_list|,
name|inputPartition
operator|.
name|getSpec
argument_list|()
argument_list|,
literal|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|!=
literal|null
condition|)
block|{
name|tbl
operator|=
name|p
operator|.
name|getTable
argument_list|()
expr_stmt|;
block|}
else|else
block|{
comment|// if p is null, we assume that we insert to a new partition
name|tbl
operator|=
name|inputPartition
operator|.
name|getTable
argument_list|()
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|HiveException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|e
argument_list|)
throw|;
block|}
if|if
condition|(
name|type
operator|==
name|WriteEntity
operator|.
name|Type
operator|.
name|PARTITION
operator|&&
name|p
operator|!=
literal|null
operator|&&
name|p
operator|.
name|isOffline
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|OFFLINE_TABLE_OR_PARTITION
operator|.
name|getMsg
argument_list|(
literal|" Table "
operator|+
name|tbl
operator|.
name|getTableName
argument_list|()
operator|+
literal|" Partition "
operator|+
name|p
operator|.
name|getName
argument_list|()
argument_list|)
argument_list|)
throw|;
block|}
block|}
else|else
block|{
name|tbl
operator|=
name|writeEntity
operator|.
name|getTable
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|tbl
operator|.
name|isOffline
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|OFFLINE_TABLE_OR_PARTITION
operator|.
name|getMsg
argument_list|(
literal|"Table "
operator|+
name|tbl
operator|.
name|getTableName
argument_list|()
argument_list|)
argument_list|)
throw|;
block|}
block|}
name|boolean
name|reworkMapredWork
init|=
name|HiveConf
operator|.
name|getBoolVar
argument_list|(
name|this
operator|.
name|conf
argument_list|,
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVE_REWORK_MAPREDWORK
argument_list|)
decl_stmt|;
comment|// validate all tasks
for|for
control|(
name|Task
argument_list|<
name|?
extends|extends
name|Serializable
argument_list|>
name|rootTask
range|:
name|rootTasks
control|)
block|{
name|validate
argument_list|(
name|rootTask
argument_list|,
name|reworkMapredWork
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|validate
parameter_list|(
name|Task
argument_list|<
name|?
extends|extends
name|Serializable
argument_list|>
name|task
parameter_list|,
name|boolean
name|reworkMapredWork
parameter_list|)
throws|throws
name|SemanticException
block|{
name|Utilities
operator|.
name|reworkMapRedWork
argument_list|(
name|task
argument_list|,
name|reworkMapredWork
argument_list|,
name|conf
argument_list|)
expr_stmt|;
if|if
condition|(
name|task
operator|.
name|getChildTasks
argument_list|()
operator|==
literal|null
condition|)
block|{
return|return;
block|}
for|for
control|(
name|Task
argument_list|<
name|?
extends|extends
name|Serializable
argument_list|>
name|childTask
range|:
name|task
operator|.
name|getChildTasks
argument_list|()
control|)
block|{
name|validate
argument_list|(
name|childTask
argument_list|,
name|reworkMapredWork
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Get the row resolver given an operator.    */
specifier|public
name|RowResolver
name|getRowResolver
parameter_list|(
name|Operator
name|opt
parameter_list|)
block|{
return|return
name|opParseCtx
operator|.
name|get
argument_list|(
name|opt
argument_list|)
operator|.
name|getRowResolver
argument_list|()
return|;
block|}
comment|/**    * Add default properties for table property. If a default parameter exists    * in the tblProp, the value in tblProp will be kept.    * @param table property map    * @return Modified table property map    */
specifier|private
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|addDefaultProperties
parameter_list|(
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|tblProp
parameter_list|)
block|{
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|retValue
decl_stmt|;
if|if
condition|(
name|tblProp
operator|==
literal|null
condition|)
block|{
name|retValue
operator|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|retValue
operator|=
name|tblProp
expr_stmt|;
block|}
name|String
name|paraString
init|=
name|HiveConf
operator|.
name|getVar
argument_list|(
name|conf
argument_list|,
name|ConfVars
operator|.
name|NEWTABLEDEFAULTPARA
argument_list|)
decl_stmt|;
if|if
condition|(
name|paraString
operator|!=
literal|null
operator|&&
operator|!
name|paraString
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
for|for
control|(
name|String
name|keyValuePair
range|:
name|paraString
operator|.
name|split
argument_list|(
literal|","
argument_list|)
control|)
block|{
name|String
index|[]
name|keyValue
init|=
name|keyValuePair
operator|.
name|split
argument_list|(
literal|"="
argument_list|,
literal|2
argument_list|)
decl_stmt|;
if|if
condition|(
name|keyValue
operator|.
name|length
operator|!=
literal|2
condition|)
block|{
continue|continue;
block|}
if|if
condition|(
operator|!
name|retValue
operator|.
name|containsKey
argument_list|(
name|keyValue
index|[
literal|0
index|]
argument_list|)
condition|)
block|{
name|retValue
operator|.
name|put
argument_list|(
name|keyValue
index|[
literal|0
index|]
argument_list|,
name|keyValue
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
name|retValue
return|;
block|}
comment|/**    * Analyze the create table command. If it is a regular create-table or    * create-table-like statements, we create a DDLWork and return true. If it is    * a create-table-as-select, we get the necessary info such as the SerDe and    * Storage Format and put it in QB, and return false, indicating the rest of    * the semantic analyzer need to deal with the select statement with respect    * to the SerDe and Storage Format.    */
specifier|private
name|ASTNode
name|analyzeCreateTable
parameter_list|(
name|ASTNode
name|ast
parameter_list|,
name|QB
name|qb
parameter_list|)
throws|throws
name|SemanticException
block|{
name|String
name|tableName
init|=
name|getUnescapedName
argument_list|(
operator|(
name|ASTNode
operator|)
name|ast
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|String
name|likeTableName
init|=
literal|null
decl_stmt|;
name|List
argument_list|<
name|FieldSchema
argument_list|>
name|cols
init|=
operator|new
name|ArrayList
argument_list|<
name|FieldSchema
argument_list|>
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|FieldSchema
argument_list|>
name|partCols
init|=
operator|new
name|ArrayList
argument_list|<
name|FieldSchema
argument_list|>
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|bucketCols
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|Order
argument_list|>
name|sortCols
init|=
operator|new
name|ArrayList
argument_list|<
name|Order
argument_list|>
argument_list|()
decl_stmt|;
name|int
name|numBuckets
init|=
operator|-
literal|1
decl_stmt|;
name|String
name|comment
init|=
literal|null
decl_stmt|;
name|String
name|location
init|=
literal|null
decl_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|tblProps
init|=
literal|null
decl_stmt|;
name|boolean
name|ifNotExists
init|=
literal|false
decl_stmt|;
name|boolean
name|isExt
init|=
literal|false
decl_stmt|;
name|ASTNode
name|selectStmt
init|=
literal|null
decl_stmt|;
specifier|final
name|int
name|CREATE_TABLE
init|=
literal|0
decl_stmt|;
comment|// regular CREATE TABLE
specifier|final
name|int
name|CTLT
init|=
literal|1
decl_stmt|;
comment|// CREATE TABLE LIKE ... (CTLT)
specifier|final
name|int
name|CTAS
init|=
literal|2
decl_stmt|;
comment|// CREATE TABLE AS SELECT ... (CTAS)
name|int
name|command_type
init|=
name|CREATE_TABLE
decl_stmt|;
name|RowFormatParams
name|rowFormatParams
init|=
operator|new
name|RowFormatParams
argument_list|()
decl_stmt|;
name|StorageFormat
name|storageFormat
init|=
operator|new
name|StorageFormat
argument_list|()
decl_stmt|;
name|AnalyzeCreateCommonVars
name|shared
init|=
operator|new
name|AnalyzeCreateCommonVars
argument_list|()
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Creating table "
operator|+
name|tableName
operator|+
literal|" position="
operator|+
name|ast
operator|.
name|getCharPositionInLine
argument_list|()
argument_list|)
expr_stmt|;
name|int
name|numCh
init|=
name|ast
operator|.
name|getChildCount
argument_list|()
decl_stmt|;
comment|/*      * Check the 1st-level children and do simple semantic checks: 1) CTLT and      * CTAS should not coexists. 2) CTLT or CTAS should not coexists with column      * list (target table schema). 3) CTAS does not support partitioning (for      * now).      */
for|for
control|(
name|int
name|num
init|=
literal|1
init|;
name|num
operator|<
name|numCh
condition|;
name|num
operator|++
control|)
block|{
name|ASTNode
name|child
init|=
operator|(
name|ASTNode
operator|)
name|ast
operator|.
name|getChild
argument_list|(
name|num
argument_list|)
decl_stmt|;
if|if
condition|(
name|storageFormat
operator|.
name|fillStorageFormat
argument_list|(
name|child
argument_list|,
name|shared
argument_list|)
condition|)
block|{
continue|continue;
block|}
switch|switch
condition|(
name|child
operator|.
name|getToken
argument_list|()
operator|.
name|getType
argument_list|()
condition|)
block|{
case|case
name|HiveParser
operator|.
name|TOK_IFNOTEXISTS
case|:
name|ifNotExists
operator|=
literal|true
expr_stmt|;
break|break;
case|case
name|HiveParser
operator|.
name|KW_EXTERNAL
case|:
name|isExt
operator|=
literal|true
expr_stmt|;
break|break;
case|case
name|HiveParser
operator|.
name|TOK_LIKETABLE
case|:
if|if
condition|(
name|child
operator|.
name|getChildCount
argument_list|()
operator|>
literal|0
condition|)
block|{
name|likeTableName
operator|=
name|getUnescapedName
argument_list|(
operator|(
name|ASTNode
operator|)
name|child
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|likeTableName
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|command_type
operator|==
name|CTAS
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|CTAS_CTLT_COEXISTENCE
operator|.
name|getMsg
argument_list|()
argument_list|)
throw|;
block|}
if|if
condition|(
name|cols
operator|.
name|size
argument_list|()
operator|!=
literal|0
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|CTLT_COLLST_COEXISTENCE
operator|.
name|getMsg
argument_list|()
argument_list|)
throw|;
block|}
block|}
name|command_type
operator|=
name|CTLT
expr_stmt|;
block|}
break|break;
case|case
name|HiveParser
operator|.
name|TOK_QUERY
case|:
comment|// CTAS
if|if
condition|(
name|command_type
operator|==
name|CTLT
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|CTAS_CTLT_COEXISTENCE
operator|.
name|getMsg
argument_list|()
argument_list|)
throw|;
block|}
if|if
condition|(
name|cols
operator|.
name|size
argument_list|()
operator|!=
literal|0
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|CTAS_COLLST_COEXISTENCE
operator|.
name|getMsg
argument_list|()
argument_list|)
throw|;
block|}
if|if
condition|(
name|partCols
operator|.
name|size
argument_list|()
operator|!=
literal|0
operator|||
name|bucketCols
operator|.
name|size
argument_list|()
operator|!=
literal|0
condition|)
block|{
name|boolean
name|dynPart
init|=
name|HiveConf
operator|.
name|getBoolVar
argument_list|(
name|conf
argument_list|,
name|HiveConf
operator|.
name|ConfVars
operator|.
name|DYNAMICPARTITIONING
argument_list|)
decl_stmt|;
if|if
condition|(
name|dynPart
operator|==
literal|false
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|CTAS_PARCOL_COEXISTENCE
operator|.
name|getMsg
argument_list|()
argument_list|)
throw|;
block|}
else|else
block|{
comment|// TODO: support dynamic partition for CTAS
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|CTAS_PARCOL_COEXISTENCE
operator|.
name|getMsg
argument_list|()
argument_list|)
throw|;
block|}
block|}
if|if
condition|(
name|isExt
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|CTAS_EXTTBL_COEXISTENCE
operator|.
name|getMsg
argument_list|()
argument_list|)
throw|;
block|}
name|command_type
operator|=
name|CTAS
expr_stmt|;
name|selectStmt
operator|=
name|child
expr_stmt|;
break|break;
case|case
name|HiveParser
operator|.
name|TOK_TABCOLLIST
case|:
name|cols
operator|=
name|getColumns
argument_list|(
name|child
argument_list|)
expr_stmt|;
break|break;
case|case
name|HiveParser
operator|.
name|TOK_TABLECOMMENT
case|:
name|comment
operator|=
name|unescapeSQLString
argument_list|(
name|child
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getText
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|HiveParser
operator|.
name|TOK_TABLEPARTCOLS
case|:
name|partCols
operator|=
name|getColumns
argument_list|(
operator|(
name|ASTNode
operator|)
name|child
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
argument_list|,
literal|false
argument_list|)
expr_stmt|;
break|break;
case|case
name|HiveParser
operator|.
name|TOK_TABLEBUCKETS
case|:
name|bucketCols
operator|=
name|getColumnNames
argument_list|(
operator|(
name|ASTNode
operator|)
name|child
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|child
operator|.
name|getChildCount
argument_list|()
operator|==
literal|2
condition|)
block|{
name|numBuckets
operator|=
operator|(
name|Integer
operator|.
name|valueOf
argument_list|(
name|child
operator|.
name|getChild
argument_list|(
literal|1
argument_list|)
operator|.
name|getText
argument_list|()
argument_list|)
operator|)
operator|.
name|intValue
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|sortCols
operator|=
name|getColumnNamesOrder
argument_list|(
operator|(
name|ASTNode
operator|)
name|child
operator|.
name|getChild
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|numBuckets
operator|=
operator|(
name|Integer
operator|.
name|valueOf
argument_list|(
name|child
operator|.
name|getChild
argument_list|(
literal|2
argument_list|)
operator|.
name|getText
argument_list|()
argument_list|)
operator|)
operator|.
name|intValue
argument_list|()
expr_stmt|;
block|}
break|break;
case|case
name|HiveParser
operator|.
name|TOK_TABLEROWFORMAT
case|:
name|rowFormatParams
operator|.
name|analyzeRowFormat
argument_list|(
name|shared
argument_list|,
name|child
argument_list|)
expr_stmt|;
break|break;
case|case
name|HiveParser
operator|.
name|TOK_TABLELOCATION
case|:
name|location
operator|=
name|unescapeSQLString
argument_list|(
name|child
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getText
argument_list|()
argument_list|)
expr_stmt|;
name|location
operator|=
name|EximUtil
operator|.
name|relativeToAbsolutePath
argument_list|(
name|conf
argument_list|,
name|location
argument_list|)
expr_stmt|;
break|break;
case|case
name|HiveParser
operator|.
name|TOK_TABLEPROPERTIES
case|:
name|tblProps
operator|=
name|DDLSemanticAnalyzer
operator|.
name|getProps
argument_list|(
operator|(
name|ASTNode
operator|)
name|child
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|HiveParser
operator|.
name|TOK_TABLESERIALIZER
case|:
name|child
operator|=
operator|(
name|ASTNode
operator|)
name|child
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|shared
operator|.
name|serde
operator|=
name|unescapeSQLString
argument_list|(
name|child
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getText
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|child
operator|.
name|getChildCount
argument_list|()
operator|==
literal|2
condition|)
block|{
name|readProps
argument_list|(
call|(
name|ASTNode
call|)
argument_list|(
name|child
operator|.
name|getChild
argument_list|(
literal|1
argument_list|)
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
argument_list|)
argument_list|,
name|shared
operator|.
name|serdeProps
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|HiveParser
operator|.
name|TOK_FILEFORMAT_GENERIC
case|:
name|handleGenericFileFormat
argument_list|(
name|child
argument_list|)
expr_stmt|;
break|break;
default|default:
assert|assert
literal|false
assert|;
block|}
block|}
name|storageFormat
operator|.
name|fillDefaultStorageFormat
argument_list|(
name|shared
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|command_type
operator|==
name|CTAS
operator|)
operator|&&
operator|(
name|storageFormat
operator|.
name|storageHandler
operator|!=
literal|null
operator|)
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|CREATE_NON_NATIVE_AS
operator|.
name|getMsg
argument_list|()
argument_list|)
throw|;
block|}
comment|// check for existence of table
if|if
condition|(
name|ifNotExists
condition|)
block|{
try|try
block|{
name|List
argument_list|<
name|String
argument_list|>
name|tables
init|=
name|db
operator|.
name|getTablesByPattern
argument_list|(
name|tableName
argument_list|)
decl_stmt|;
if|if
condition|(
name|tables
operator|!=
literal|null
operator|&&
name|tables
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
comment|// table exists
return|return
literal|null
return|;
block|}
block|}
catch|catch
parameter_list|(
name|HiveException
name|e
parameter_list|)
block|{
name|e
operator|.
name|printStackTrace
argument_list|()
expr_stmt|;
block|}
block|}
comment|// Handle different types of CREATE TABLE command
name|CreateTableDesc
name|crtTblDesc
init|=
literal|null
decl_stmt|;
switch|switch
condition|(
name|command_type
condition|)
block|{
case|case
name|CREATE_TABLE
case|:
comment|// REGULAR CREATE TABLE DDL
name|tblProps
operator|=
name|addDefaultProperties
argument_list|(
name|tblProps
argument_list|)
expr_stmt|;
name|crtTblDesc
operator|=
operator|new
name|CreateTableDesc
argument_list|(
name|tableName
argument_list|,
name|isExt
argument_list|,
name|cols
argument_list|,
name|partCols
argument_list|,
name|bucketCols
argument_list|,
name|sortCols
argument_list|,
name|numBuckets
argument_list|,
name|rowFormatParams
operator|.
name|fieldDelim
argument_list|,
name|rowFormatParams
operator|.
name|fieldEscape
argument_list|,
name|rowFormatParams
operator|.
name|collItemDelim
argument_list|,
name|rowFormatParams
operator|.
name|mapKeyDelim
argument_list|,
name|rowFormatParams
operator|.
name|lineDelim
argument_list|,
name|comment
argument_list|,
name|storageFormat
operator|.
name|inputFormat
argument_list|,
name|storageFormat
operator|.
name|outputFormat
argument_list|,
name|location
argument_list|,
name|shared
operator|.
name|serde
argument_list|,
name|storageFormat
operator|.
name|storageHandler
argument_list|,
name|shared
operator|.
name|serdeProps
argument_list|,
name|tblProps
argument_list|,
name|ifNotExists
argument_list|)
expr_stmt|;
name|validateCreateTable
argument_list|(
name|crtTblDesc
argument_list|)
expr_stmt|;
comment|// outputs is empty, which means this create table happens in the current
comment|// database.
name|SessionState
operator|.
name|get
argument_list|()
operator|.
name|setCommandType
argument_list|(
name|HiveOperation
operator|.
name|CREATETABLE
argument_list|)
expr_stmt|;
name|rootTasks
operator|.
name|add
argument_list|(
name|TaskFactory
operator|.
name|get
argument_list|(
operator|new
name|DDLWork
argument_list|(
name|getInputs
argument_list|()
argument_list|,
name|getOutputs
argument_list|()
argument_list|,
name|crtTblDesc
argument_list|)
argument_list|,
name|conf
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|CTLT
case|:
comment|// create table like<tbl_name>
name|CreateTableLikeDesc
name|crtTblLikeDesc
init|=
operator|new
name|CreateTableLikeDesc
argument_list|(
name|tableName
argument_list|,
name|isExt
argument_list|,
name|storageFormat
operator|.
name|inputFormat
argument_list|,
name|storageFormat
operator|.
name|outputFormat
argument_list|,
name|location
argument_list|,
name|shared
operator|.
name|serde
argument_list|,
name|shared
operator|.
name|serdeProps
argument_list|,
name|ifNotExists
argument_list|,
name|likeTableName
argument_list|)
decl_stmt|;
name|SessionState
operator|.
name|get
argument_list|()
operator|.
name|setCommandType
argument_list|(
name|HiveOperation
operator|.
name|CREATETABLE
argument_list|)
expr_stmt|;
name|rootTasks
operator|.
name|add
argument_list|(
name|TaskFactory
operator|.
name|get
argument_list|(
operator|new
name|DDLWork
argument_list|(
name|getInputs
argument_list|()
argument_list|,
name|getOutputs
argument_list|()
argument_list|,
name|crtTblLikeDesc
argument_list|)
argument_list|,
name|conf
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|CTAS
case|:
comment|// create table as select
comment|// Verify that the table does not already exist
try|try
block|{
name|Table
name|dumpTable
init|=
name|db
operator|.
name|newTable
argument_list|(
name|tableName
argument_list|)
decl_stmt|;
if|if
condition|(
literal|null
operator|!=
name|db
operator|.
name|getTable
argument_list|(
name|dumpTable
operator|.
name|getDbName
argument_list|()
argument_list|,
name|dumpTable
operator|.
name|getTableName
argument_list|()
argument_list|,
literal|false
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|TABLE_ALREADY_EXISTS
operator|.
name|getMsg
argument_list|(
name|tableName
argument_list|)
argument_list|)
throw|;
block|}
block|}
catch|catch
parameter_list|(
name|HiveException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|e
argument_list|)
throw|;
block|}
name|tblProps
operator|=
name|addDefaultProperties
argument_list|(
name|tblProps
argument_list|)
expr_stmt|;
name|crtTblDesc
operator|=
operator|new
name|CreateTableDesc
argument_list|(
name|tableName
argument_list|,
name|isExt
argument_list|,
name|cols
argument_list|,
name|partCols
argument_list|,
name|bucketCols
argument_list|,
name|sortCols
argument_list|,
name|numBuckets
argument_list|,
name|rowFormatParams
operator|.
name|fieldDelim
argument_list|,
name|rowFormatParams
operator|.
name|fieldEscape
argument_list|,
name|rowFormatParams
operator|.
name|collItemDelim
argument_list|,
name|rowFormatParams
operator|.
name|mapKeyDelim
argument_list|,
name|rowFormatParams
operator|.
name|lineDelim
argument_list|,
name|comment
argument_list|,
name|storageFormat
operator|.
name|inputFormat
argument_list|,
name|storageFormat
operator|.
name|outputFormat
argument_list|,
name|location
argument_list|,
name|shared
operator|.
name|serde
argument_list|,
name|storageFormat
operator|.
name|storageHandler
argument_list|,
name|shared
operator|.
name|serdeProps
argument_list|,
name|tblProps
argument_list|,
name|ifNotExists
argument_list|)
expr_stmt|;
name|qb
operator|.
name|setTableDesc
argument_list|(
name|crtTblDesc
argument_list|)
expr_stmt|;
name|SessionState
operator|.
name|get
argument_list|()
operator|.
name|setCommandType
argument_list|(
name|HiveOperation
operator|.
name|CREATETABLE_AS_SELECT
argument_list|)
expr_stmt|;
return|return
name|selectStmt
return|;
default|default:
throw|throw
operator|new
name|SemanticException
argument_list|(
literal|"Unrecognized command."
argument_list|)
throw|;
block|}
return|return
literal|null
return|;
block|}
specifier|private
name|ASTNode
name|analyzeCreateView
parameter_list|(
name|ASTNode
name|ast
parameter_list|,
name|QB
name|qb
parameter_list|)
throws|throws
name|SemanticException
block|{
name|String
name|tableName
init|=
name|getUnescapedName
argument_list|(
operator|(
name|ASTNode
operator|)
name|ast
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|FieldSchema
argument_list|>
name|cols
init|=
literal|null
decl_stmt|;
name|boolean
name|ifNotExists
init|=
literal|false
decl_stmt|;
name|boolean
name|orReplace
init|=
literal|false
decl_stmt|;
name|String
name|comment
init|=
literal|null
decl_stmt|;
name|ASTNode
name|selectStmt
init|=
literal|null
decl_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|tblProps
init|=
literal|null
decl_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|partColNames
init|=
literal|null
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Creating view "
operator|+
name|tableName
operator|+
literal|" position="
operator|+
name|ast
operator|.
name|getCharPositionInLine
argument_list|()
argument_list|)
expr_stmt|;
name|int
name|numCh
init|=
name|ast
operator|.
name|getChildCount
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|num
init|=
literal|1
init|;
name|num
operator|<
name|numCh
condition|;
name|num
operator|++
control|)
block|{
name|ASTNode
name|child
init|=
operator|(
name|ASTNode
operator|)
name|ast
operator|.
name|getChild
argument_list|(
name|num
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|child
operator|.
name|getToken
argument_list|()
operator|.
name|getType
argument_list|()
condition|)
block|{
case|case
name|HiveParser
operator|.
name|TOK_IFNOTEXISTS
case|:
name|ifNotExists
operator|=
literal|true
expr_stmt|;
break|break;
case|case
name|HiveParser
operator|.
name|TOK_ORREPLACE
case|:
name|orReplace
operator|=
literal|true
expr_stmt|;
break|break;
case|case
name|HiveParser
operator|.
name|TOK_QUERY
case|:
name|selectStmt
operator|=
name|child
expr_stmt|;
break|break;
case|case
name|HiveParser
operator|.
name|TOK_TABCOLNAME
case|:
name|cols
operator|=
name|getColumns
argument_list|(
name|child
argument_list|)
expr_stmt|;
break|break;
case|case
name|HiveParser
operator|.
name|TOK_TABLECOMMENT
case|:
name|comment
operator|=
name|unescapeSQLString
argument_list|(
name|child
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
operator|.
name|getText
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|HiveParser
operator|.
name|TOK_TABLEPROPERTIES
case|:
name|tblProps
operator|=
name|DDLSemanticAnalyzer
operator|.
name|getProps
argument_list|(
operator|(
name|ASTNode
operator|)
name|child
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|HiveParser
operator|.
name|TOK_VIEWPARTCOLS
case|:
name|partColNames
operator|=
name|getColumnNames
argument_list|(
operator|(
name|ASTNode
operator|)
name|child
operator|.
name|getChild
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
assert|assert
literal|false
assert|;
block|}
block|}
if|if
condition|(
name|ifNotExists
operator|&&
name|orReplace
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
literal|"Can't combine IF NOT EXISTS and OR REPLACE."
argument_list|)
throw|;
block|}
name|createVwDesc
operator|=
operator|new
name|CreateViewDesc
argument_list|(
name|tableName
argument_list|,
name|cols
argument_list|,
name|comment
argument_list|,
name|tblProps
argument_list|,
name|partColNames
argument_list|,
name|ifNotExists
argument_list|,
name|orReplace
argument_list|)
expr_stmt|;
name|unparseTranslator
operator|.
name|enable
argument_list|()
expr_stmt|;
name|rootTasks
operator|.
name|add
argument_list|(
name|TaskFactory
operator|.
name|get
argument_list|(
operator|new
name|DDLWork
argument_list|(
name|getInputs
argument_list|()
argument_list|,
name|getOutputs
argument_list|()
argument_list|,
name|createVwDesc
argument_list|)
argument_list|,
name|conf
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|selectStmt
return|;
block|}
specifier|private
name|List
argument_list|<
name|String
argument_list|>
name|validateColumnNameUniqueness
parameter_list|(
name|List
argument_list|<
name|FieldSchema
argument_list|>
name|fieldSchemas
parameter_list|)
throws|throws
name|SemanticException
block|{
comment|// no duplicate column names
comment|// currently, it is a simple n*n algorithm - this can be optimized later if
comment|// need be
comment|// but it should not be a major bottleneck as the number of columns are
comment|// anyway not so big
name|Iterator
argument_list|<
name|FieldSchema
argument_list|>
name|iterCols
init|=
name|fieldSchemas
operator|.
name|iterator
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|colNames
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
while|while
condition|(
name|iterCols
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|String
name|colName
init|=
name|iterCols
operator|.
name|next
argument_list|()
operator|.
name|getName
argument_list|()
decl_stmt|;
name|Iterator
argument_list|<
name|String
argument_list|>
name|iter
init|=
name|colNames
operator|.
name|iterator
argument_list|()
decl_stmt|;
while|while
condition|(
name|iter
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|String
name|oldColName
init|=
name|iter
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
name|colName
operator|.
name|equalsIgnoreCase
argument_list|(
name|oldColName
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|DUPLICATE_COLUMN_NAMES
operator|.
name|getMsg
argument_list|(
name|oldColName
argument_list|)
argument_list|)
throw|;
block|}
block|}
name|colNames
operator|.
name|add
argument_list|(
name|colName
argument_list|)
expr_stmt|;
block|}
return|return
name|colNames
return|;
block|}
specifier|private
name|void
name|validateCreateTable
parameter_list|(
name|CreateTableDesc
name|crtTblDesc
parameter_list|)
throws|throws
name|SemanticException
block|{
if|if
condition|(
operator|(
name|crtTblDesc
operator|.
name|getCols
argument_list|()
operator|==
literal|null
operator|)
operator|||
operator|(
name|crtTblDesc
operator|.
name|getCols
argument_list|()
operator|.
name|size
argument_list|()
operator|==
literal|0
operator|)
condition|)
block|{
comment|// for now make sure that serde exists
if|if
condition|(
name|StringUtils
operator|.
name|isEmpty
argument_list|(
name|crtTblDesc
operator|.
name|getSerName
argument_list|()
argument_list|)
operator|||
operator|!
name|SerDeUtils
operator|.
name|shouldGetColsFromSerDe
argument_list|(
name|crtTblDesc
operator|.
name|getSerName
argument_list|()
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|INVALID_TBL_DDL_SERDE
operator|.
name|getMsg
argument_list|()
argument_list|)
throw|;
block|}
return|return;
block|}
if|if
condition|(
name|crtTblDesc
operator|.
name|getStorageHandler
argument_list|()
operator|==
literal|null
condition|)
block|{
try|try
block|{
name|Class
argument_list|<
name|?
argument_list|>
name|origin
init|=
name|Class
operator|.
name|forName
argument_list|(
name|crtTblDesc
operator|.
name|getOutputFormat
argument_list|()
argument_list|,
literal|true
argument_list|,
name|JavaUtils
operator|.
name|getClassLoader
argument_list|()
argument_list|)
decl_stmt|;
name|Class
argument_list|<
name|?
extends|extends
name|HiveOutputFormat
argument_list|>
name|replaced
init|=
name|HiveFileFormatUtils
operator|.
name|getOutputFormatSubstitute
argument_list|(
name|origin
argument_list|)
decl_stmt|;
if|if
condition|(
name|replaced
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|INVALID_OUTPUT_FORMAT_TYPE
operator|.
name|getMsg
argument_list|()
argument_list|)
throw|;
block|}
block|}
catch|catch
parameter_list|(
name|ClassNotFoundException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|INVALID_OUTPUT_FORMAT_TYPE
operator|.
name|getMsg
argument_list|()
argument_list|)
throw|;
block|}
block|}
name|List
argument_list|<
name|String
argument_list|>
name|colNames
init|=
name|validateColumnNameUniqueness
argument_list|(
name|crtTblDesc
operator|.
name|getCols
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|crtTblDesc
operator|.
name|getBucketCols
argument_list|()
operator|!=
literal|null
condition|)
block|{
comment|// all columns in cluster and sort are valid columns
name|Iterator
argument_list|<
name|String
argument_list|>
name|bucketCols
init|=
name|crtTblDesc
operator|.
name|getBucketCols
argument_list|()
operator|.
name|iterator
argument_list|()
decl_stmt|;
while|while
condition|(
name|bucketCols
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|String
name|bucketCol
init|=
name|bucketCols
operator|.
name|next
argument_list|()
decl_stmt|;
name|boolean
name|found
init|=
literal|false
decl_stmt|;
name|Iterator
argument_list|<
name|String
argument_list|>
name|colNamesIter
init|=
name|colNames
operator|.
name|iterator
argument_list|()
decl_stmt|;
while|while
condition|(
name|colNamesIter
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|String
name|colName
init|=
name|colNamesIter
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
name|bucketCol
operator|.
name|equalsIgnoreCase
argument_list|(
name|colName
argument_list|)
condition|)
block|{
name|found
operator|=
literal|true
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|found
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|INVALID_COLUMN
operator|.
name|getMsg
argument_list|()
argument_list|)
throw|;
block|}
block|}
block|}
if|if
condition|(
name|crtTblDesc
operator|.
name|getSortCols
argument_list|()
operator|!=
literal|null
condition|)
block|{
comment|// all columns in cluster and sort are valid columns
name|Iterator
argument_list|<
name|Order
argument_list|>
name|sortCols
init|=
name|crtTblDesc
operator|.
name|getSortCols
argument_list|()
operator|.
name|iterator
argument_list|()
decl_stmt|;
while|while
condition|(
name|sortCols
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|String
name|sortCol
init|=
name|sortCols
operator|.
name|next
argument_list|()
operator|.
name|getCol
argument_list|()
decl_stmt|;
name|boolean
name|found
init|=
literal|false
decl_stmt|;
name|Iterator
argument_list|<
name|String
argument_list|>
name|colNamesIter
init|=
name|colNames
operator|.
name|iterator
argument_list|()
decl_stmt|;
while|while
condition|(
name|colNamesIter
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|String
name|colName
init|=
name|colNamesIter
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
name|sortCol
operator|.
name|equalsIgnoreCase
argument_list|(
name|colName
argument_list|)
condition|)
block|{
name|found
operator|=
literal|true
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|found
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|INVALID_COLUMN
operator|.
name|getMsg
argument_list|()
argument_list|)
throw|;
block|}
block|}
block|}
if|if
condition|(
name|crtTblDesc
operator|.
name|getPartCols
argument_list|()
operator|!=
literal|null
condition|)
block|{
comment|// there is no overlap between columns and partitioning columns
name|Iterator
argument_list|<
name|FieldSchema
argument_list|>
name|partColsIter
init|=
name|crtTblDesc
operator|.
name|getPartCols
argument_list|()
operator|.
name|iterator
argument_list|()
decl_stmt|;
while|while
condition|(
name|partColsIter
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|String
name|partCol
init|=
name|partColsIter
operator|.
name|next
argument_list|()
operator|.
name|getName
argument_list|()
decl_stmt|;
name|Iterator
argument_list|<
name|String
argument_list|>
name|colNamesIter
init|=
name|colNames
operator|.
name|iterator
argument_list|()
decl_stmt|;
while|while
condition|(
name|colNamesIter
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|String
name|colName
init|=
name|unescapeIdentifier
argument_list|(
name|colNamesIter
operator|.
name|next
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|partCol
operator|.
name|equalsIgnoreCase
argument_list|(
name|colName
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|ErrorMsg
operator|.
name|COLUMN_REPEATED_IN_PARTITIONING_COLS
operator|.
name|getMsg
argument_list|()
argument_list|)
throw|;
block|}
block|}
block|}
block|}
block|}
specifier|private
name|void
name|decideExecMode
parameter_list|(
name|List
argument_list|<
name|Task
argument_list|<
name|?
extends|extends
name|Serializable
argument_list|>
argument_list|>
name|rootTasks
parameter_list|,
name|Context
name|ctx
parameter_list|)
throws|throws
name|SemanticException
block|{
comment|// bypass for explain queries for now
if|if
condition|(
name|ctx
operator|.
name|getExplain
argument_list|()
condition|)
block|{
return|return;
block|}
comment|// user has told us to run in local mode or doesn't want auto-local mode
if|if
condition|(
name|ctx
operator|.
name|isLocalOnlyExecutionMode
argument_list|()
operator|||
operator|!
name|conf
operator|.
name|getBoolVar
argument_list|(
name|HiveConf
operator|.
name|ConfVars
operator|.
name|LOCALMODEAUTO
argument_list|)
condition|)
block|{
return|return;
block|}
specifier|final
name|Context
name|lCtx
init|=
name|ctx
decl_stmt|;
name|PathFilter
name|p
init|=
operator|new
name|PathFilter
argument_list|()
block|{
specifier|public
name|boolean
name|accept
parameter_list|(
name|Path
name|file
parameter_list|)
block|{
return|return
operator|!
name|lCtx
operator|.
name|isMRTmpFileURI
argument_list|(
name|file
operator|.
name|toUri
argument_list|()
operator|.
name|getPath
argument_list|()
argument_list|)
return|;
block|}
block|}
decl_stmt|;
name|List
argument_list|<
name|ExecDriver
argument_list|>
name|mrtasks
init|=
name|Utilities
operator|.
name|getMRTasks
argument_list|(
name|rootTasks
argument_list|)
decl_stmt|;
comment|// map-reduce jobs will be run locally based on data size
comment|// first find out if any of the jobs needs to run non-locally
name|boolean
name|hasNonLocalJob
init|=
literal|false
decl_stmt|;
for|for
control|(
name|ExecDriver
name|mrtask
range|:
name|mrtasks
control|)
block|{
try|try
block|{
name|ContentSummary
name|inputSummary
init|=
name|Utilities
operator|.
name|getInputSummary
argument_list|(
name|ctx
argument_list|,
operator|(
name|MapredWork
operator|)
name|mrtask
operator|.
name|getWork
argument_list|()
argument_list|,
name|p
argument_list|)
decl_stmt|;
name|int
name|numReducers
init|=
name|getNumberOfReducers
argument_list|(
name|mrtask
operator|.
name|getWork
argument_list|()
argument_list|,
name|conf
argument_list|)
decl_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Task: "
operator|+
name|mrtask
operator|.
name|getId
argument_list|()
operator|+
literal|", Summary: "
operator|+
name|inputSummary
operator|.
name|getLength
argument_list|()
operator|+
literal|","
operator|+
name|inputSummary
operator|.
name|getFileCount
argument_list|()
operator|+
literal|","
operator|+
name|numReducers
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|MapRedTask
operator|.
name|isEligibleForLocalMode
argument_list|(
name|conf
argument_list|,
name|numReducers
argument_list|,
name|inputSummary
operator|.
name|getLength
argument_list|()
argument_list|,
name|inputSummary
operator|.
name|getFileCount
argument_list|()
argument_list|)
operator|!=
literal|null
condition|)
block|{
name|hasNonLocalJob
operator|=
literal|true
expr_stmt|;
break|break;
block|}
else|else
block|{
name|mrtask
operator|.
name|setLocalMode
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|SemanticException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
if|if
condition|(
operator|!
name|hasNonLocalJob
condition|)
block|{
comment|// none of the mapred tasks needs to be run locally. That means that the
comment|// query can be executed entirely in local mode. Save the current tracker
comment|// value and restore it when done
name|ctx
operator|.
name|setOriginalTracker
argument_list|(
name|conf
operator|.
name|getVar
argument_list|(
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HADOOPJT
argument_list|)
argument_list|)
expr_stmt|;
name|conf
operator|.
name|setVar
argument_list|(
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HADOOPJT
argument_list|,
literal|"local"
argument_list|)
expr_stmt|;
name|console
operator|.
name|printInfo
argument_list|(
literal|"Automatically selecting local only mode for query"
argument_list|)
expr_stmt|;
comment|// If all the tasks can be run locally, we can use local disk for
comment|// storing intermediate data.
comment|/**        * This code is commented out pending further testing/development        * for (Task<? extends Serializable> t: rootTasks)        * t.localizeMRTmpFiles(ctx);        */
block|}
block|}
comment|/**    * Make a best guess at trying to find the number of reducers    */
specifier|private
specifier|static
name|int
name|getNumberOfReducers
parameter_list|(
name|MapredWork
name|mrwork
parameter_list|,
name|HiveConf
name|conf
parameter_list|)
block|{
if|if
condition|(
name|mrwork
operator|.
name|getReducer
argument_list|()
operator|==
literal|null
condition|)
block|{
return|return
literal|0
return|;
block|}
if|if
condition|(
name|mrwork
operator|.
name|getNumReduceTasks
argument_list|()
operator|>=
literal|0
condition|)
block|{
return|return
name|mrwork
operator|.
name|getNumReduceTasks
argument_list|()
return|;
block|}
return|return
name|conf
operator|.
name|getIntVar
argument_list|(
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HADOOPNUMREDUCERS
argument_list|)
return|;
block|}
block|}
end_class

end_unit

