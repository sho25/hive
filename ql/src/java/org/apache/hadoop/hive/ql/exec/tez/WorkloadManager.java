begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|tez
package|;
end_package

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Lists
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ExecutionException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|VisibleForTesting
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Sets
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Lists
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|util
operator|.
name|concurrent
operator|.
name|FutureCallback
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|util
operator|.
name|concurrent
operator|.
name|Futures
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ListenableFuture
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|util
operator|.
name|concurrent
operator|.
name|SettableFuture
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ThreadFactoryBuilder
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Comparator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|IdentityHashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|LinkedList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ConcurrentHashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ExecutorService
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|Executors
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|Future
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ScheduledExecutorService
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|TimeUnit
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicLong
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|locks
operator|.
name|Condition
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|locks
operator|.
name|ReentrantLock
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|lang
operator|.
name|StringUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|conf
operator|.
name|HiveConf
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|conf
operator|.
name|HiveConf
operator|.
name|ConfVars
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|llap
operator|.
name|tezplugins
operator|.
name|LlapTaskSchedulerService
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|metastore
operator|.
name|api
operator|.
name|WMFullResourcePlan
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|metastore
operator|.
name|api
operator|.
name|WMPool
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|metastore
operator|.
name|api
operator|.
name|WMPoolTrigger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|metastore
operator|.
name|api
operator|.
name|WMTrigger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|tez
operator|.
name|AmPluginNode
operator|.
name|AmPluginInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|tez
operator|.
name|UserPoolMapping
operator|.
name|MappingInput
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|metadata
operator|.
name|HiveException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|session
operator|.
name|KillQuery
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|session
operator|.
name|SessionState
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|wm
operator|.
name|ExecutionTrigger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|wm
operator|.
name|SessionTriggerProvider
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|wm
operator|.
name|Trigger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|wm
operator|.
name|TriggerActionHandler
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hive
operator|.
name|common
operator|.
name|util
operator|.
name|Ref
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|tez
operator|.
name|dag
operator|.
name|api
operator|.
name|TezConfiguration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_comment
comment|/** Workload management entry point for HS2.  * Note on how this class operates.  * There are tons of things that could be happening in parallel that are a real pain to sync.  * Therefore, it uses an actor-ish model where the master thread, in processCurrentEvents method,  * processes a bunch of events that have accumulated since the previous iteration, repeatedly  * and quickly, doing physical work via async calls or via worker threads.  * That way the bulk of the state (pools, etc.) does not require any sync, and we mostly have  * a consistent view of the conflicting events when we process things. However, that also means  * none of that state can be accessed directly - most changes that touch pool state, or interact  * with background operations like init, need to go thru eventstate; see e.g. returnAfterUse.  */
end_comment

begin_class
specifier|public
class|class
name|WorkloadManager
extends|extends
name|TezSessionPoolSession
operator|.
name|AbstractTriggerValidator
implements|implements
name|TezSessionPoolSession
operator|.
name|Manager
implements|,
name|SessionExpirationTracker
operator|.
name|RestartImpl
implements|,
name|WorkloadManagerMxBean
block|{
specifier|private
specifier|static
specifier|final
name|Logger
name|LOG
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|WorkloadManager
operator|.
name|class
argument_list|)
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|char
name|POOL_SEPARATOR
init|=
literal|'.'
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|String
name|POOL_SEPARATOR_STR
init|=
literal|""
operator|+
name|POOL_SEPARATOR
decl_stmt|;
comment|// Various final services, configs, etc.
specifier|private
specifier|final
name|HiveConf
name|conf
decl_stmt|;
specifier|private
specifier|final
name|TezSessionPool
argument_list|<
name|WmTezSession
argument_list|>
name|tezAmPool
decl_stmt|;
specifier|private
specifier|final
name|SessionExpirationTracker
name|expirationTracker
decl_stmt|;
specifier|private
specifier|final
name|RestrictedConfigChecker
name|restrictedConfig
decl_stmt|;
specifier|private
specifier|final
name|QueryAllocationManager
name|allocationManager
decl_stmt|;
specifier|private
specifier|final
name|String
name|yarnQueue
decl_stmt|;
specifier|private
specifier|final
name|int
name|amRegistryTimeoutMs
decl_stmt|;
comment|// Note: it's not clear that we need to track this - unlike PoolManager we don't have non-pool
comment|//       sessions, so the pool itself could internally track the sessions it gave out, since
comment|//       calling close on an unopened session is probably harmless.
specifier|private
specifier|final
name|IdentityHashMap
argument_list|<
name|TezSessionPoolSession
argument_list|,
name|Boolean
argument_list|>
name|openSessions
init|=
operator|new
name|IdentityHashMap
argument_list|<>
argument_list|()
decl_stmt|;
comment|// We index the get requests to make sure there are no ordering artifacts when we requeue.
specifier|private
specifier|final
name|AtomicLong
name|getRequestVersion
init|=
operator|new
name|AtomicLong
argument_list|(
name|Long
operator|.
name|MIN_VALUE
argument_list|)
decl_stmt|;
comment|// The below group of fields (pools, etc.) can only be modified by the master thread.
specifier|private
name|Map
argument_list|<
name|String
argument_list|,
name|PoolState
argument_list|>
name|pools
decl_stmt|;
specifier|private
name|String
name|rpName
decl_stmt|,
name|defaultPool
decl_stmt|;
comment|// For information only.
specifier|private
name|int
name|totalQueryParallelism
decl_stmt|;
comment|/**    * The queries being killed. This is used to sync between the background kill finishing and the    * query finishing and user returning the sessions, which can happen in separate iterations    * of the master thread processing, yet need to be aware of each other.    */
specifier|private
name|Map
argument_list|<
name|WmTezSession
argument_list|,
name|KillQueryContext
argument_list|>
name|killQueryInProgress
init|=
operator|new
name|IdentityHashMap
argument_list|<>
argument_list|()
decl_stmt|;
comment|// Used to make sure that waiting getSessions don't block update.
specifier|private
name|UserPoolMapping
name|userPoolMapping
decl_stmt|;
comment|// End of master thread state
comment|// Note: we could use RW lock to allow concurrent calls for different sessions, however all
comment|//       those calls do is add elements to lists and maps; and we'd need to sync those separately
comment|//       separately, plus have an object to notify because RW lock does not support conditions
comment|//       in any sensible way. So, for now the lock is going to be epic.
specifier|private
specifier|final
name|ReentrantLock
name|currentLock
init|=
operator|new
name|ReentrantLock
argument_list|()
decl_stmt|;
specifier|private
specifier|final
name|Condition
name|hasChangesCondition
init|=
name|currentLock
operator|.
name|newCondition
argument_list|()
decl_stmt|;
comment|// The processing thread will switch between these two objects.
specifier|private
specifier|final
name|EventState
name|one
init|=
operator|new
name|EventState
argument_list|()
decl_stmt|,
name|two
init|=
operator|new
name|EventState
argument_list|()
decl_stmt|;
specifier|private
name|boolean
name|hasChanges
init|=
literal|false
decl_stmt|;
specifier|private
name|EventState
name|current
init|=
name|one
decl_stmt|;
specifier|private
specifier|final
name|WmThreadSyncWork
name|syncWork
init|=
operator|new
name|WmThreadSyncWork
argument_list|()
decl_stmt|;
comment|// End sync stuff.
specifier|private
name|PerPoolTriggerValidatorRunnable
name|triggerValidatorRunnable
decl_stmt|;
specifier|private
name|Map
argument_list|<
name|String
argument_list|,
name|SessionTriggerProvider
argument_list|>
name|perPoolProviders
init|=
operator|new
name|ConcurrentHashMap
argument_list|<>
argument_list|()
decl_stmt|;
specifier|private
name|SessionTriggerProvider
name|sessionTriggerProvider
decl_stmt|;
specifier|private
name|TriggerActionHandler
name|triggerActionHandler
decl_stmt|;
comment|// The master thread and various workers.
comment|/** The master thread the processes the events from EventState. */
annotation|@
name|VisibleForTesting
specifier|protected
specifier|final
name|Thread
name|wmThread
decl_stmt|;
comment|/** Used by the master thread to offload calls blocking on smth other than fast locks. */
specifier|private
specifier|final
name|ExecutorService
name|workPool
decl_stmt|;
comment|/** Used to schedule timeouts for some async operations. */
specifier|private
specifier|final
name|ScheduledExecutorService
name|timeoutPool
decl_stmt|;
comment|// The initial plan initalization future, to wait for the plan to apply during setup.
specifier|private
name|ListenableFuture
argument_list|<
name|Boolean
argument_list|>
name|initRpFuture
decl_stmt|;
specifier|private
name|LlapPluginEndpointClientImpl
name|amComm
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|FutureCallback
argument_list|<
name|Object
argument_list|>
name|FATAL_ERROR_CALLBACK
init|=
operator|new
name|FutureCallback
argument_list|<
name|Object
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|void
name|onSuccess
parameter_list|(
name|Object
name|result
parameter_list|)
block|{     }
annotation|@
name|Override
specifier|public
name|void
name|onFailure
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{
comment|// TODO: shut down HS2?
name|LOG
operator|.
name|error
argument_list|(
literal|"Workload management fatal error"
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
block|}
decl_stmt|;
specifier|private
specifier|static
specifier|volatile
name|WorkloadManager
name|INSTANCE
decl_stmt|;
specifier|public
specifier|static
name|WorkloadManager
name|getInstance
parameter_list|()
block|{
return|return
name|INSTANCE
return|;
block|}
comment|/** Called once, when HS2 initializes. */
specifier|public
specifier|static
name|WorkloadManager
name|create
parameter_list|(
name|String
name|yarnQueue
parameter_list|,
name|HiveConf
name|conf
parameter_list|,
name|WMFullResourcePlan
name|plan
parameter_list|)
block|{
assert|assert
name|INSTANCE
operator|==
literal|null
assert|;
comment|// We could derive the expected number of AMs to pass in.
name|LlapPluginEndpointClientImpl
name|amComm
init|=
operator|new
name|LlapPluginEndpointClientImpl
argument_list|(
name|conf
argument_list|,
literal|null
argument_list|,
operator|-
literal|1
argument_list|)
decl_stmt|;
name|QueryAllocationManager
name|qam
init|=
operator|new
name|GuaranteedTasksAllocator
argument_list|(
name|conf
argument_list|,
name|amComm
argument_list|)
decl_stmt|;
return|return
operator|(
name|INSTANCE
operator|=
operator|new
name|WorkloadManager
argument_list|(
name|amComm
argument_list|,
name|yarnQueue
argument_list|,
name|conf
argument_list|,
name|qam
argument_list|,
name|plan
argument_list|)
operator|)
return|;
block|}
annotation|@
name|VisibleForTesting
name|WorkloadManager
parameter_list|(
name|LlapPluginEndpointClientImpl
name|amComm
parameter_list|,
name|String
name|yarnQueue
parameter_list|,
name|HiveConf
name|conf
parameter_list|,
name|QueryAllocationManager
name|qam
parameter_list|,
name|WMFullResourcePlan
name|plan
parameter_list|)
block|{
name|this
operator|.
name|yarnQueue
operator|=
name|yarnQueue
expr_stmt|;
name|this
operator|.
name|conf
operator|=
name|conf
expr_stmt|;
name|this
operator|.
name|totalQueryParallelism
operator|=
name|determineQueryParallelism
argument_list|(
name|plan
argument_list|)
expr_stmt|;
name|this
operator|.
name|initRpFuture
operator|=
name|this
operator|.
name|updateResourcePlanAsync
argument_list|(
name|plan
argument_list|)
expr_stmt|;
name|this
operator|.
name|amComm
operator|=
name|amComm
expr_stmt|;
if|if
condition|(
name|this
operator|.
name|amComm
operator|!=
literal|null
condition|)
block|{
name|this
operator|.
name|amComm
operator|.
name|init
argument_list|(
name|conf
argument_list|)
expr_stmt|;
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"Initializing with "
operator|+
name|totalQueryParallelism
operator|+
literal|" total query parallelism"
argument_list|)
expr_stmt|;
name|this
operator|.
name|amRegistryTimeoutMs
operator|=
operator|(
name|int
operator|)
name|HiveConf
operator|.
name|getTimeVar
argument_list|(
name|conf
argument_list|,
name|ConfVars
operator|.
name|HIVE_SERVER2_TEZ_WM_AM_REGISTRY_TIMEOUT
argument_list|,
name|TimeUnit
operator|.
name|MILLISECONDS
argument_list|)
expr_stmt|;
name|tezAmPool
operator|=
operator|new
name|TezSessionPool
argument_list|<>
argument_list|(
name|conf
argument_list|,
name|totalQueryParallelism
argument_list|,
literal|true
argument_list|,
name|oldSession
lambda|->
name|createSession
argument_list|(
name|oldSession
operator|==
literal|null
condition|?
literal|null
else|:
name|oldSession
operator|.
name|getConf
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|restrictedConfig
operator|=
operator|new
name|RestrictedConfigChecker
argument_list|(
name|conf
argument_list|)
expr_stmt|;
name|allocationManager
operator|=
name|qam
expr_stmt|;
comment|// Only creates the expiration tracker if expiration is configured.
name|expirationTracker
operator|=
name|SessionExpirationTracker
operator|.
name|create
argument_list|(
name|conf
argument_list|,
name|this
argument_list|)
expr_stmt|;
name|workPool
operator|=
name|Executors
operator|.
name|newFixedThreadPool
argument_list|(
name|HiveConf
operator|.
name|getIntVar
argument_list|(
name|conf
argument_list|,
name|ConfVars
operator|.
name|HIVE_SERVER2_TEZ_WM_WORKER_THREADS
argument_list|)
argument_list|,
operator|new
name|ThreadFactoryBuilder
argument_list|()
operator|.
name|setDaemon
argument_list|(
literal|true
argument_list|)
operator|.
name|setNameFormat
argument_list|(
literal|"Workload management worker %d"
argument_list|)
operator|.
name|build
argument_list|()
argument_list|)
expr_stmt|;
name|timeoutPool
operator|=
name|Executors
operator|.
name|newSingleThreadScheduledExecutor
argument_list|(
operator|new
name|ThreadFactoryBuilder
argument_list|()
operator|.
name|setDaemon
argument_list|(
literal|true
argument_list|)
operator|.
name|setNameFormat
argument_list|(
literal|"Workload management timeout thread"
argument_list|)
operator|.
name|build
argument_list|()
argument_list|)
expr_stmt|;
name|wmThread
operator|=
operator|new
name|Thread
argument_list|(
parameter_list|()
lambda|->
name|runWmThread
argument_list|()
argument_list|,
literal|"Workload management master"
argument_list|)
expr_stmt|;
name|wmThread
operator|.
name|setDaemon
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
specifier|private
specifier|static
name|int
name|determineQueryParallelism
parameter_list|(
name|WMFullResourcePlan
name|plan
parameter_list|)
block|{
name|int
name|result
init|=
literal|0
decl_stmt|;
for|for
control|(
name|WMPool
name|pool
range|:
name|plan
operator|.
name|getPools
argument_list|()
control|)
block|{
name|result
operator|+=
name|pool
operator|.
name|getQueryParallelism
argument_list|()
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
specifier|public
name|void
name|start
parameter_list|()
throws|throws
name|Exception
block|{
name|tezAmPool
operator|.
name|start
argument_list|()
expr_stmt|;
if|if
condition|(
name|expirationTracker
operator|!=
literal|null
condition|)
block|{
name|expirationTracker
operator|.
name|start
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|amComm
operator|!=
literal|null
condition|)
block|{
name|amComm
operator|.
name|start
argument_list|()
expr_stmt|;
block|}
name|allocationManager
operator|.
name|start
argument_list|()
expr_stmt|;
name|wmThread
operator|.
name|start
argument_list|()
expr_stmt|;
name|initRpFuture
operator|.
name|get
argument_list|()
expr_stmt|;
comment|// Wait for the initial resource plan to be applied.
specifier|final
name|long
name|triggerValidationIntervalMs
init|=
name|HiveConf
operator|.
name|getTimeVar
argument_list|(
name|conf
argument_list|,
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVE_TRIGGER_VALIDATION_INTERVAL_MS
argument_list|,
name|TimeUnit
operator|.
name|MILLISECONDS
argument_list|)
decl_stmt|;
name|TriggerActionHandler
name|triggerActionHandler
init|=
operator|new
name|KillMoveTriggerActionHandler
argument_list|(
name|this
argument_list|)
decl_stmt|;
name|triggerValidatorRunnable
operator|=
operator|new
name|PerPoolTriggerValidatorRunnable
argument_list|(
name|perPoolProviders
argument_list|,
name|triggerActionHandler
argument_list|,
name|triggerValidationIntervalMs
argument_list|)
expr_stmt|;
name|startTriggerValidator
argument_list|(
name|triggerValidationIntervalMs
argument_list|)
expr_stmt|;
block|}
specifier|public
name|void
name|stop
parameter_list|()
throws|throws
name|Exception
block|{
name|List
argument_list|<
name|TezSessionPoolSession
argument_list|>
name|sessionsToClose
init|=
literal|null
decl_stmt|;
synchronized|synchronized
init|(
name|openSessions
init|)
block|{
name|sessionsToClose
operator|=
operator|new
name|ArrayList
argument_list|<
name|TezSessionPoolSession
argument_list|>
argument_list|(
name|openSessions
operator|.
name|keySet
argument_list|()
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|TezSessionState
name|sessionState
range|:
name|sessionsToClose
control|)
block|{
name|sessionState
operator|.
name|close
argument_list|(
literal|false
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|expirationTracker
operator|!=
literal|null
condition|)
block|{
name|expirationTracker
operator|.
name|stop
argument_list|()
expr_stmt|;
block|}
name|allocationManager
operator|.
name|stop
argument_list|()
expr_stmt|;
if|if
condition|(
name|wmThread
operator|!=
literal|null
condition|)
block|{
name|wmThread
operator|.
name|interrupt
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|amComm
operator|!=
literal|null
condition|)
block|{
name|amComm
operator|.
name|stop
argument_list|()
expr_stmt|;
block|}
name|workPool
operator|.
name|shutdownNow
argument_list|()
expr_stmt|;
name|timeoutPool
operator|.
name|shutdownNow
argument_list|()
expr_stmt|;
if|if
condition|(
name|triggerValidatorRunnable
operator|!=
literal|null
condition|)
block|{
name|stopTriggerValidator
argument_list|()
expr_stmt|;
block|}
name|INSTANCE
operator|=
literal|null
expr_stmt|;
block|}
specifier|private
name|void
name|updateSessionTriggerProvidersOnMasterThread
parameter_list|()
block|{
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|PoolState
argument_list|>
name|entry
range|:
name|pools
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|String
name|poolName
init|=
name|entry
operator|.
name|getKey
argument_list|()
decl_stmt|;
name|PoolState
name|poolState
init|=
name|entry
operator|.
name|getValue
argument_list|()
decl_stmt|;
specifier|final
name|List
argument_list|<
name|Trigger
argument_list|>
name|triggers
init|=
name|Collections
operator|.
name|unmodifiableList
argument_list|(
name|poolState
operator|.
name|getTriggers
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|List
argument_list|<
name|TezSessionState
argument_list|>
name|sessionStates
init|=
name|Collections
operator|.
name|unmodifiableList
argument_list|(
name|poolState
operator|.
name|getSessions
argument_list|()
argument_list|)
decl_stmt|;
name|SessionTriggerProvider
name|sessionTriggerProvider
init|=
name|perPoolProviders
operator|.
name|get
argument_list|(
name|poolName
argument_list|)
decl_stmt|;
if|if
condition|(
name|sessionTriggerProvider
operator|!=
literal|null
condition|)
block|{
name|perPoolProviders
operator|.
name|get
argument_list|(
name|poolName
argument_list|)
operator|.
name|setTriggers
argument_list|(
name|triggers
argument_list|)
expr_stmt|;
name|perPoolProviders
operator|.
name|get
argument_list|(
name|poolName
argument_list|)
operator|.
name|setSessions
argument_list|(
name|sessionStates
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|perPoolProviders
operator|.
name|put
argument_list|(
name|poolName
argument_list|,
operator|new
name|SessionTriggerProvider
argument_list|(
name|sessionStates
argument_list|,
name|triggers
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
annotation|@
name|VisibleForTesting
name|Map
argument_list|<
name|String
argument_list|,
name|SessionTriggerProvider
argument_list|>
name|getAllSessionTriggerProviders
parameter_list|()
block|{
return|return
name|perPoolProviders
return|;
block|}
comment|/** Represent a single iteration of work for the master thread. */
specifier|private
specifier|final
specifier|static
class|class
name|EventState
block|{
specifier|private
specifier|final
name|Set
argument_list|<
name|WmTezSession
argument_list|>
name|toReturn
init|=
name|Sets
operator|.
name|newIdentityHashSet
argument_list|()
decl_stmt|,
name|toDestroy
init|=
name|Sets
operator|.
name|newIdentityHashSet
argument_list|()
decl_stmt|;
specifier|private
specifier|final
name|Map
argument_list|<
name|WmTezSession
argument_list|,
name|Boolean
argument_list|>
name|killQueryResults
init|=
operator|new
name|IdentityHashMap
argument_list|<>
argument_list|()
decl_stmt|;
specifier|private
specifier|final
name|LinkedList
argument_list|<
name|SessionInitContext
argument_list|>
name|initResults
init|=
operator|new
name|LinkedList
argument_list|<>
argument_list|()
decl_stmt|;
specifier|private
specifier|final
name|IdentityHashMap
argument_list|<
name|WmTezSession
argument_list|,
name|SettableFuture
argument_list|<
name|WmTezSession
argument_list|>
argument_list|>
name|toReopen
init|=
operator|new
name|IdentityHashMap
argument_list|<>
argument_list|()
decl_stmt|;
specifier|private
specifier|final
name|IdentityHashMap
argument_list|<
name|WmTezSession
argument_list|,
name|Integer
argument_list|>
name|updateErrors
init|=
operator|new
name|IdentityHashMap
argument_list|<>
argument_list|()
decl_stmt|;
specifier|private
specifier|final
name|LinkedList
argument_list|<
name|GetRequest
argument_list|>
name|getRequests
init|=
operator|new
name|LinkedList
argument_list|<>
argument_list|()
decl_stmt|;
specifier|private
specifier|final
name|IdentityHashMap
argument_list|<
name|WmTezSession
argument_list|,
name|GetRequest
argument_list|>
name|toReuse
init|=
operator|new
name|IdentityHashMap
argument_list|<>
argument_list|()
decl_stmt|;
specifier|private
name|WMFullResourcePlan
name|resourcePlanToApply
init|=
literal|null
decl_stmt|;
specifier|private
name|boolean
name|hasClusterStateChanged
init|=
literal|false
decl_stmt|;
specifier|private
name|SettableFuture
argument_list|<
name|Boolean
argument_list|>
name|testEvent
decl_stmt|,
name|applyRpFuture
decl_stmt|;
specifier|private
name|SettableFuture
argument_list|<
name|List
argument_list|<
name|String
argument_list|>
argument_list|>
name|dumpStateFuture
decl_stmt|;
specifier|private
specifier|final
name|List
argument_list|<
name|MoveSession
argument_list|>
name|moveSessions
init|=
operator|new
name|LinkedList
argument_list|<>
argument_list|()
decl_stmt|;
block|}
specifier|private
specifier|final
specifier|static
class|class
name|MoveSession
block|{
specifier|private
specifier|final
name|WmTezSession
name|srcSession
decl_stmt|;
specifier|private
specifier|final
name|String
name|destPool
decl_stmt|;
specifier|private
specifier|final
name|SettableFuture
argument_list|<
name|Boolean
argument_list|>
name|future
decl_stmt|;
specifier|public
name|MoveSession
parameter_list|(
specifier|final
name|WmTezSession
name|srcSession
parameter_list|,
specifier|final
name|String
name|destPool
parameter_list|)
block|{
name|this
operator|.
name|srcSession
operator|=
name|srcSession
expr_stmt|;
name|this
operator|.
name|destPool
operator|=
name|destPool
expr_stmt|;
name|this
operator|.
name|future
operator|=
name|SettableFuture
operator|.
name|create
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
name|srcSession
operator|.
name|getSessionId
argument_list|()
operator|+
literal|" moving from "
operator|+
name|srcSession
operator|.
name|getPoolName
argument_list|()
operator|+
literal|" to "
operator|+
name|destPool
return|;
block|}
block|}
comment|/**    * The work delegated from the master thread that doesn't have an async implementation    * (mostly opening and closing the sessions).    */
specifier|private
specifier|final
specifier|static
class|class
name|WmThreadSyncWork
block|{
specifier|private
name|List
argument_list|<
name|WmTezSession
argument_list|>
name|toRestartInUse
init|=
operator|new
name|LinkedList
argument_list|<>
argument_list|()
decl_stmt|,
name|toDestroyNoRestart
init|=
operator|new
name|LinkedList
argument_list|<>
argument_list|()
decl_stmt|;
specifier|private
name|Map
argument_list|<
name|WmTezSession
argument_list|,
name|KillQueryContext
argument_list|>
name|toKillQuery
init|=
operator|new
name|IdentityHashMap
argument_list|<>
argument_list|()
decl_stmt|;
block|}
specifier|private
name|void
name|runWmThread
parameter_list|()
block|{
while|while
condition|(
literal|true
condition|)
block|{
name|EventState
name|currentEvents
init|=
literal|null
decl_stmt|;
name|currentLock
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
while|while
condition|(
operator|!
name|hasChanges
condition|)
block|{
try|try
block|{
name|hasChangesCondition
operator|.
name|await
argument_list|(
literal|1
argument_list|,
name|TimeUnit
operator|.
name|SECONDS
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"WM thread was interrupted and will now exit"
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
name|hasChanges
operator|=
literal|false
expr_stmt|;
name|currentEvents
operator|=
name|current
expr_stmt|;
name|current
operator|=
operator|(
name|currentEvents
operator|==
name|one
operator|)
condition|?
name|two
else|:
name|one
expr_stmt|;
block|}
finally|finally
block|{
name|currentLock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
try|try
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Processing current events"
argument_list|)
expr_stmt|;
name|processCurrentEvents
argument_list|(
name|currentEvents
argument_list|,
name|syncWork
argument_list|)
expr_stmt|;
name|scheduleWork
argument_list|(
name|syncWork
argument_list|)
expr_stmt|;
name|updateSessionTriggerProvidersOnMasterThread
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|ex
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"WM thread was interrupted and will now exit"
argument_list|)
expr_stmt|;
return|return;
block|}
catch|catch
parameter_list|(
name|Exception
decl||
name|AssertionError
name|ex
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"WM thread encountered an error but will attempt to continue"
argument_list|,
name|ex
argument_list|)
expr_stmt|;
if|if
condition|(
name|currentEvents
operator|.
name|testEvent
operator|!=
literal|null
condition|)
block|{
name|currentEvents
operator|.
name|testEvent
operator|.
name|setException
argument_list|(
name|ex
argument_list|)
expr_stmt|;
name|currentEvents
operator|.
name|testEvent
operator|=
literal|null
expr_stmt|;
block|}
if|if
condition|(
name|currentEvents
operator|.
name|applyRpFuture
operator|!=
literal|null
condition|)
block|{
name|currentEvents
operator|.
name|applyRpFuture
operator|.
name|setException
argument_list|(
name|ex
argument_list|)
expr_stmt|;
name|currentEvents
operator|.
name|applyRpFuture
operator|=
literal|null
expr_stmt|;
block|}
comment|// TODO: we either have to kill HS2 or, as the non-actor model would implicitly,
comment|//       hope for the best and continue on other threads. Do the latter for now.
continue|continue;
block|}
block|}
block|}
specifier|private
name|void
name|scheduleWork
parameter_list|(
name|WmThreadSyncWork
name|context
parameter_list|)
block|{
comment|// Do the work that cannot be done via async calls.
comment|// 1. Kill queries.
for|for
control|(
name|KillQueryContext
name|killCtx
range|:
name|context
operator|.
name|toKillQuery
operator|.
name|values
argument_list|()
control|)
block|{
specifier|final
name|WmTezSession
name|toKill
init|=
name|killCtx
operator|.
name|session
decl_stmt|;
specifier|final
name|String
name|reason
init|=
name|killCtx
operator|.
name|reason
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Killing query for {}"
argument_list|,
name|toKill
argument_list|)
expr_stmt|;
name|workPool
operator|.
name|submit
argument_list|(
parameter_list|()
lambda|->
block|{
comment|// Note: we get query ID here, rather than in the caller, where it would be more correct
comment|//       because we know which exact query we intend to kill. This is valid because we
comment|//       are not expecting query ID to change - we never reuse the session for which a
comment|//       query is being killed until both the kill, and the user, return it.
name|String
name|queryId
init|=
name|toKill
operator|.
name|getQueryId
argument_list|()
decl_stmt|;
name|KillQuery
name|kq
init|=
name|toKill
operator|.
name|getKillQuery
argument_list|()
decl_stmt|;
try|try
block|{
if|if
condition|(
name|kq
operator|!=
literal|null
operator|&&
name|queryId
operator|!=
literal|null
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Invoking KillQuery for "
operator|+
name|queryId
operator|+
literal|": "
operator|+
name|reason
argument_list|)
expr_stmt|;
try|try
block|{
name|kq
operator|.
name|killQuery
argument_list|(
name|queryId
argument_list|,
name|reason
argument_list|)
expr_stmt|;
name|addKillQueryResult
argument_list|(
name|toKill
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Killed "
operator|+
name|queryId
argument_list|)
expr_stmt|;
return|return;
block|}
catch|catch
parameter_list|(
name|HiveException
name|ex
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Failed to kill "
operator|+
name|queryId
operator|+
literal|"; will try to restart AM instead"
argument_list|,
name|ex
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Will queue restart for {}; queryId {}, killQuery {}"
argument_list|,
name|toKill
argument_list|,
name|queryId
argument_list|,
name|kq
argument_list|)
expr_stmt|;
block|}
block|}
finally|finally
block|{
name|toKill
operator|.
name|setQueryId
argument_list|(
literal|null
argument_list|)
expr_stmt|;
block|}
comment|// We cannot restart in place because the user might receive a failure and return the
comment|// session to the master thread without the "irrelevant" flag set. In fact, the query might
comment|// have succeeded in the gap and the session might already be returned. Queue restart thru
comment|// the master thread.
name|addKillQueryResult
argument_list|(
name|toKill
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
argument_list|)
expr_stmt|;
block|}
name|context
operator|.
name|toKillQuery
operator|.
name|clear
argument_list|()
expr_stmt|;
comment|// 2. Restart pool sessions.
for|for
control|(
specifier|final
name|WmTezSession
name|toRestart
range|:
name|context
operator|.
name|toRestartInUse
control|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Replacing {} with a new session"
argument_list|,
name|toRestart
argument_list|)
expr_stmt|;
name|toRestart
operator|.
name|setQueryId
argument_list|(
literal|null
argument_list|)
expr_stmt|;
name|workPool
operator|.
name|submit
argument_list|(
parameter_list|()
lambda|->
block|{
try|try
block|{
comment|// Note: sessions in toRestart are always in use, so they cannot expire in parallel.
name|tezAmPool
operator|.
name|replaceSession
argument_list|(
name|toRestart
argument_list|,
literal|false
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|ex
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Failed to restart an old session; ignoring"
argument_list|,
name|ex
argument_list|)
expr_stmt|;
block|}
block|}
argument_list|)
expr_stmt|;
block|}
name|context
operator|.
name|toRestartInUse
operator|.
name|clear
argument_list|()
expr_stmt|;
comment|// 3. Destroy the sessions that we don't need anymore.
for|for
control|(
specifier|final
name|WmTezSession
name|toDestroy
range|:
name|context
operator|.
name|toDestroyNoRestart
control|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Closing {} without restart"
argument_list|,
name|toDestroy
argument_list|)
expr_stmt|;
name|workPool
operator|.
name|submit
argument_list|(
parameter_list|()
lambda|->
block|{
try|try
block|{
name|toDestroy
operator|.
name|close
argument_list|(
literal|false
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|ex
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Failed to close an old session; ignoring "
operator|+
name|ex
operator|.
name|getMessage
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
argument_list|)
expr_stmt|;
block|}
name|context
operator|.
name|toDestroyNoRestart
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
comment|/**    * This is the main method of the master thread the processes one set of events.    * Be mindful of the fact that events can be queued while we are processing events, so    * in addition to making sure we keep the current set consistent (e.g. no need to handle    * update errors for a session that should already be destroyed), this needs to guard itself    * against the future iterations - e.g. what happens if we kill a query due to plan change,    * but the DAG finished before the kill happens and the user queues a "return" event? Etc.    * DO NOT block for a long time in this method.    * @param e Input events.    * @param syncWork Output tasks that cannot be called via async methods.    */
specifier|private
name|void
name|processCurrentEvents
parameter_list|(
name|EventState
name|e
parameter_list|,
name|WmThreadSyncWork
name|syncWork
parameter_list|)
throws|throws
name|Exception
block|{
comment|// The order of processing is as follows. We'd reclaim or kill all the sessions that we can
comment|// reclaim from various user actions and errors, then apply the new plan if any,
comment|// then give out all we can give out (restart, get and reopen callers) and rebalance the
comment|// resource allocations in all the affected pools.
comment|// For every session, we'd check all the concurrent things happening to it.
comment|// TODO: also account for Tez-internal session restarts;
comment|//       AM reg info changes; add notifications, ignore errors, and update alloc.
name|HashSet
argument_list|<
name|String
argument_list|>
name|poolsToRedistribute
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|()
decl_stmt|;
comment|// 0. Handle initialization results.
for|for
control|(
name|SessionInitContext
name|sw
range|:
name|e
operator|.
name|initResults
control|)
block|{
name|handleInitResultOnMasterThread
argument_list|(
name|sw
argument_list|,
name|syncWork
argument_list|,
name|poolsToRedistribute
argument_list|)
expr_stmt|;
block|}
name|e
operator|.
name|initResults
operator|.
name|clear
argument_list|()
expr_stmt|;
comment|// 1. Handle kill query results - part 1, just put them in place. We will resolve what
comment|//    to do with the sessions after we go thru all the concurrent user actions.
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|WmTezSession
argument_list|,
name|Boolean
argument_list|>
name|entry
range|:
name|e
operator|.
name|killQueryResults
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|WmTezSession
name|killQuerySession
init|=
name|entry
operator|.
name|getKey
argument_list|()
decl_stmt|;
name|boolean
name|killResult
init|=
name|entry
operator|.
name|getValue
argument_list|()
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Processing KillQuery {} for {}"
argument_list|,
name|killResult
condition|?
literal|"success"
else|:
literal|"failure"
argument_list|,
name|killQuerySession
argument_list|)
expr_stmt|;
comment|// Note: do not cancel any user actions here; user actions actually interact with kills.
name|KillQueryContext
name|killCtx
init|=
name|killQueryInProgress
operator|.
name|get
argument_list|(
name|killQuerySession
argument_list|)
decl_stmt|;
if|if
condition|(
name|killCtx
operator|==
literal|null
condition|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Internal error - cannot find the context for killing {}"
argument_list|,
name|killQuerySession
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|killCtx
operator|.
name|handleKillQueryCallback
argument_list|(
operator|!
name|killResult
argument_list|)
expr_stmt|;
block|}
name|e
operator|.
name|killQueryResults
operator|.
name|clear
argument_list|()
expr_stmt|;
comment|// 2. Handle sessions that are being destroyed by users. Destroy implies return.
for|for
control|(
name|WmTezSession
name|sessionToDestroy
range|:
name|e
operator|.
name|toDestroy
control|)
block|{
if|if
condition|(
name|e
operator|.
name|toReturn
operator|.
name|remove
argument_list|(
name|sessionToDestroy
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"The session was both destroyed and returned by the user; destroying"
argument_list|)
expr_stmt|;
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"Destroying {}"
argument_list|,
name|sessionToDestroy
argument_list|)
expr_stmt|;
name|RemoveSessionResult
name|rr
init|=
name|handleReturnedInUseSessionOnMasterThread
argument_list|(
name|e
argument_list|,
name|sessionToDestroy
argument_list|,
name|poolsToRedistribute
argument_list|,
literal|false
argument_list|)
decl_stmt|;
if|if
condition|(
name|rr
operator|==
name|RemoveSessionResult
operator|.
name|OK
operator|||
name|rr
operator|==
name|RemoveSessionResult
operator|.
name|NOT_FOUND
condition|)
block|{
comment|// Restart even if there's an internal error.
name|syncWork
operator|.
name|toRestartInUse
operator|.
name|add
argument_list|(
name|sessionToDestroy
argument_list|)
expr_stmt|;
block|}
block|}
name|e
operator|.
name|toDestroy
operator|.
name|clear
argument_list|()
expr_stmt|;
comment|// 3. Now handle actual returns. Sessions may be returned to the pool or may trigger expires.
for|for
control|(
name|WmTezSession
name|sessionToReturn
range|:
name|e
operator|.
name|toReturn
control|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Returning {}"
argument_list|,
name|sessionToReturn
argument_list|)
expr_stmt|;
name|RemoveSessionResult
name|rr
init|=
name|handleReturnedInUseSessionOnMasterThread
argument_list|(
name|e
argument_list|,
name|sessionToReturn
argument_list|,
name|poolsToRedistribute
argument_list|,
literal|true
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|rr
condition|)
block|{
case|case
name|OK
case|:
name|boolean
name|wasReturned
init|=
name|tezAmPool
operator|.
name|returnSessionAsync
argument_list|(
name|sessionToReturn
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|wasReturned
condition|)
block|{
name|syncWork
operator|.
name|toDestroyNoRestart
operator|.
name|add
argument_list|(
name|sessionToReturn
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|NOT_FOUND
case|:
name|syncWork
operator|.
name|toRestartInUse
operator|.
name|add
argument_list|(
name|sessionToReturn
argument_list|)
expr_stmt|;
comment|// Restart if there's an internal error.
break|break;
case|case
name|IGNORE
case|:
break|break;
default|default:
throw|throw
operator|new
name|AssertionError
argument_list|(
literal|"Unknown state "
operator|+
name|rr
argument_list|)
throw|;
block|}
block|}
name|e
operator|.
name|toReturn
operator|.
name|clear
argument_list|()
expr_stmt|;
comment|// 4. Reopen is essentially just destroy + get a new session for a session in use.
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|WmTezSession
argument_list|,
name|SettableFuture
argument_list|<
name|WmTezSession
argument_list|>
argument_list|>
name|entry
range|:
name|e
operator|.
name|toReopen
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Reopening {}"
argument_list|,
name|entry
operator|.
name|getKey
argument_list|()
argument_list|)
expr_stmt|;
name|handeReopenRequestOnMasterThread
argument_list|(
name|e
argument_list|,
name|entry
operator|.
name|getKey
argument_list|()
argument_list|,
name|entry
operator|.
name|getValue
argument_list|()
argument_list|,
name|poolsToRedistribute
argument_list|,
name|syncWork
argument_list|)
expr_stmt|;
block|}
name|e
operator|.
name|toReopen
operator|.
name|clear
argument_list|()
expr_stmt|;
comment|// 5. All the sessions in use that were not destroyed or returned with a failed update now die.
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|WmTezSession
argument_list|,
name|Integer
argument_list|>
name|entry
range|:
name|e
operator|.
name|updateErrors
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|WmTezSession
name|sessionWithUpdateError
init|=
name|entry
operator|.
name|getKey
argument_list|()
decl_stmt|;
name|int
name|failedEndpointVersion
init|=
name|entry
operator|.
name|getValue
argument_list|()
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Update failed for {}"
argument_list|,
name|sessionWithUpdateError
argument_list|)
expr_stmt|;
name|handleUpdateErrorOnMasterThread
argument_list|(
name|sessionWithUpdateError
argument_list|,
name|failedEndpointVersion
argument_list|,
name|e
operator|.
name|toReuse
argument_list|,
name|syncWork
argument_list|,
name|poolsToRedistribute
argument_list|)
expr_stmt|;
block|}
name|e
operator|.
name|updateErrors
operator|.
name|clear
argument_list|()
expr_stmt|;
comment|// 6. Now apply a resource plan if any. This is expected to be pretty rare.
name|boolean
name|hasRequeues
init|=
literal|false
decl_stmt|;
if|if
condition|(
name|e
operator|.
name|resourcePlanToApply
operator|!=
literal|null
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Applying new resource plan"
argument_list|)
expr_stmt|;
name|int
name|getReqCount
init|=
name|e
operator|.
name|getRequests
operator|.
name|size
argument_list|()
decl_stmt|;
name|applyNewResourcePlanOnMasterThread
argument_list|(
name|e
argument_list|,
name|syncWork
argument_list|,
name|poolsToRedistribute
argument_list|)
expr_stmt|;
name|hasRequeues
operator|=
name|getReqCount
operator|!=
name|e
operator|.
name|getRequests
operator|.
name|size
argument_list|()
expr_stmt|;
block|}
name|e
operator|.
name|resourcePlanToApply
operator|=
literal|null
expr_stmt|;
comment|// 7. Handle any move session requests. The way move session works right now is
comment|// a) sessions get moved to destination pool if there is capacity in destination pool
comment|// b) if there is no capacity in destination pool, the session gets killed (since we cannot pause a query)
comment|// TODO: in future this the process of killing can be delayed until the point where a session is actually required.
comment|// We could consider delaying the move (when destination capacity is full) until there is claim in src pool.
comment|// May be change command to support ... DELAYED MOVE TO etl ... which will run under src cluster fraction as long
comment|// as possible
for|for
control|(
name|MoveSession
name|moveSession
range|:
name|e
operator|.
name|moveSessions
control|)
block|{
name|handleMoveSessionOnMasterThread
argument_list|(
name|moveSession
argument_list|,
name|syncWork
argument_list|,
name|poolsToRedistribute
argument_list|,
name|e
operator|.
name|toReuse
argument_list|)
expr_stmt|;
block|}
name|e
operator|.
name|moveSessions
operator|.
name|clear
argument_list|()
expr_stmt|;
comment|// 8. Handle all the get/reuse requests. We won't actually give out anything here, but merely
comment|//    map all the requests and place them in an appropriate order in pool queues. The only
comment|//    exception is the reuse without queue contention; can be granted immediately. If we can't
comment|//    reuse the session immediately, we will convert the reuse to a normal get, because we
comment|//    want query level fairness, and don't want the get in queue to hold up a session.
name|GetRequest
name|req
decl_stmt|;
while|while
condition|(
operator|(
name|req
operator|=
name|e
operator|.
name|getRequests
operator|.
name|pollFirst
argument_list|()
operator|)
operator|!=
literal|null
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Processing a new get request from "
operator|+
name|req
operator|.
name|mappingInput
argument_list|)
expr_stmt|;
name|queueGetRequestOnMasterThread
argument_list|(
name|req
argument_list|,
name|poolsToRedistribute
argument_list|,
name|syncWork
argument_list|)
expr_stmt|;
block|}
name|e
operator|.
name|toReuse
operator|.
name|clear
argument_list|()
expr_stmt|;
comment|// 9. Resolve all the kill query requests in flight. Nothing below can affect them.
name|Iterator
argument_list|<
name|KillQueryContext
argument_list|>
name|iter
init|=
name|killQueryInProgress
operator|.
name|values
argument_list|()
operator|.
name|iterator
argument_list|()
decl_stmt|;
while|while
condition|(
name|iter
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|KillQueryContext
name|ctx
init|=
name|iter
operator|.
name|next
argument_list|()
decl_stmt|;
name|KillQueryResult
name|kr
init|=
name|ctx
operator|.
name|process
argument_list|()
decl_stmt|;
switch|switch
condition|(
name|kr
condition|)
block|{
case|case
name|IN_PROGRESS
case|:
continue|continue;
comment|// Either the user or the kill is not done yet.
case|case
name|OK
case|:
block|{
name|iter
operator|.
name|remove
argument_list|()
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Kill query succeeded; returning to the pool: {}"
argument_list|,
name|ctx
operator|.
name|session
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|tezAmPool
operator|.
name|returnSessionAsync
argument_list|(
name|ctx
operator|.
name|session
argument_list|)
condition|)
block|{
name|syncWork
operator|.
name|toDestroyNoRestart
operator|.
name|add
argument_list|(
name|ctx
operator|.
name|session
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
case|case
name|RESTART_REQUIRED
case|:
block|{
name|iter
operator|.
name|remove
argument_list|()
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Kill query failed; restarting: {}"
argument_list|,
name|ctx
operator|.
name|session
argument_list|)
expr_stmt|;
comment|// Note: we assume here the session, before we resolve killQuery result here, is still
comment|//       "in use". That is because all the user ops above like return, reopen, etc.
comment|//       don't actually return/reopen/... when kill query is in progress.
name|syncWork
operator|.
name|toRestartInUse
operator|.
name|add
argument_list|(
name|ctx
operator|.
name|session
argument_list|)
expr_stmt|;
break|break;
block|}
default|default:
throw|throw
operator|new
name|AssertionError
argument_list|(
literal|"Unknown state "
operator|+
name|kr
argument_list|)
throw|;
block|}
block|}
comment|// 10. If there was a cluster state change, make sure we redistribute all the pools.
if|if
condition|(
name|e
operator|.
name|hasClusterStateChanged
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Processing a cluster state change"
argument_list|)
expr_stmt|;
name|poolsToRedistribute
operator|.
name|addAll
argument_list|(
name|pools
operator|.
name|keySet
argument_list|()
argument_list|)
expr_stmt|;
name|e
operator|.
name|hasClusterStateChanged
operator|=
literal|false
expr_stmt|;
block|}
comment|// 11. Finally, for all the pools that have changes, promote queued queries and rebalance.
for|for
control|(
name|String
name|poolName
range|:
name|poolsToRedistribute
control|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Processing changes for pool "
operator|+
name|poolName
operator|+
literal|": "
operator|+
name|pools
operator|.
name|get
argument_list|(
name|poolName
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|processPoolChangesOnMasterThread
argument_list|(
name|poolName
argument_list|,
name|syncWork
argument_list|,
name|hasRequeues
argument_list|)
expr_stmt|;
block|}
comment|// 12. Save state for future iterations.
for|for
control|(
name|KillQueryContext
name|killCtx
range|:
name|syncWork
operator|.
name|toKillQuery
operator|.
name|values
argument_list|()
control|)
block|{
if|if
condition|(
name|killQueryInProgress
operator|.
name|put
argument_list|(
name|killCtx
operator|.
name|session
argument_list|,
name|killCtx
argument_list|)
operator|!=
literal|null
condition|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"One query killed several times - internal error {}"
argument_list|,
name|killCtx
operator|.
name|session
argument_list|)
expr_stmt|;
block|}
block|}
comment|// 13. Notify tests and global async ops.
if|if
condition|(
name|e
operator|.
name|dumpStateFuture
operator|!=
literal|null
condition|)
block|{
name|List
argument_list|<
name|String
argument_list|>
name|result
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|result
operator|.
name|add
argument_list|(
literal|"RESOURCE PLAN "
operator|+
name|rpName
operator|+
literal|"; default pool "
operator|+
name|defaultPool
argument_list|)
expr_stmt|;
for|for
control|(
name|PoolState
name|ps
range|:
name|pools
operator|.
name|values
argument_list|()
control|)
block|{
name|dumpPoolState
argument_list|(
name|ps
argument_list|,
name|result
argument_list|)
expr_stmt|;
block|}
name|e
operator|.
name|dumpStateFuture
operator|.
name|set
argument_list|(
name|result
argument_list|)
expr_stmt|;
name|e
operator|.
name|dumpStateFuture
operator|=
literal|null
expr_stmt|;
block|}
if|if
condition|(
name|e
operator|.
name|testEvent
operator|!=
literal|null
condition|)
block|{
name|e
operator|.
name|testEvent
operator|.
name|set
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|e
operator|.
name|testEvent
operator|=
literal|null
expr_stmt|;
block|}
if|if
condition|(
name|e
operator|.
name|applyRpFuture
operator|!=
literal|null
condition|)
block|{
name|e
operator|.
name|applyRpFuture
operator|.
name|set
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|e
operator|.
name|applyRpFuture
operator|=
literal|null
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|dumpPoolState
parameter_list|(
name|PoolState
name|ps
parameter_list|,
name|List
argument_list|<
name|String
argument_list|>
name|set
parameter_list|)
block|{
name|StringBuilder
name|sb
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|"POOL "
argument_list|)
operator|.
name|append
argument_list|(
name|ps
operator|.
name|fullName
argument_list|)
operator|.
name|append
argument_list|(
literal|": qp "
argument_list|)
operator|.
name|append
argument_list|(
name|ps
operator|.
name|queryParallelism
argument_list|)
operator|.
name|append
argument_list|(
literal|", %% "
argument_list|)
operator|.
name|append
argument_list|(
name|ps
operator|.
name|finalFraction
argument_list|)
operator|.
name|append
argument_list|(
literal|", sessions: "
argument_list|)
operator|.
name|append
argument_list|(
name|ps
operator|.
name|sessions
operator|.
name|size
argument_list|()
argument_list|)
operator|.
name|append
argument_list|(
literal|", initializing: "
argument_list|)
operator|.
name|append
argument_list|(
name|ps
operator|.
name|initializingSessions
operator|.
name|size
argument_list|()
argument_list|)
operator|.
name|append
argument_list|(
literal|", queued: "
argument_list|)
operator|.
name|append
argument_list|(
name|ps
operator|.
name|queue
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|set
operator|.
name|add
argument_list|(
name|sb
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|sb
operator|.
name|setLength
argument_list|(
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|WmTezSession
name|session
range|:
name|ps
operator|.
name|sessions
control|)
block|{
name|sb
operator|.
name|append
argument_list|(
literal|"RUNNING: "
argument_list|)
operator|.
name|append
argument_list|(
name|session
operator|.
name|getClusterFraction
argument_list|()
argument_list|)
operator|.
name|append
argument_list|(
literal|" ("
argument_list|)
operator|.
name|append
argument_list|(
name|session
operator|.
name|getAllocationState
argument_list|()
argument_list|)
operator|.
name|append
argument_list|(
literal|") => "
argument_list|)
operator|.
name|append
argument_list|(
name|session
operator|.
name|getSessionId
argument_list|()
argument_list|)
expr_stmt|;
name|set
operator|.
name|add
argument_list|(
name|sb
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|sb
operator|.
name|setLength
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|SessionInitContext
name|session
range|:
name|ps
operator|.
name|initializingSessions
control|)
block|{
name|sb
operator|.
name|append
argument_list|(
literal|"INITIALIZING: state "
argument_list|)
operator|.
name|append
argument_list|(
name|session
operator|.
name|state
argument_list|)
expr_stmt|;
name|set
operator|.
name|add
argument_list|(
name|sb
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|sb
operator|.
name|setLength
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|GetRequest
name|session
range|:
name|ps
operator|.
name|queue
control|)
block|{
name|sb
operator|.
name|append
argument_list|(
literal|"QUEUED: from "
argument_list|)
operator|.
name|append
argument_list|(
name|session
operator|.
name|mappingInput
argument_list|)
expr_stmt|;
name|set
operator|.
name|add
argument_list|(
name|sb
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|sb
operator|.
name|setLength
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|handleMoveSessionOnMasterThread
parameter_list|(
name|MoveSession
name|moveSession
parameter_list|,
name|WmThreadSyncWork
name|syncWork
parameter_list|,
name|Set
argument_list|<
name|String
argument_list|>
name|poolsToRedistribute
parameter_list|,
name|Map
argument_list|<
name|WmTezSession
argument_list|,
name|GetRequest
argument_list|>
name|toReuse
parameter_list|)
block|{
name|String
name|destPoolName
init|=
name|moveSession
operator|.
name|destPool
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Handling move session event: {}"
argument_list|,
name|moveSession
argument_list|)
expr_stmt|;
if|if
condition|(
name|validMove
argument_list|(
name|moveSession
operator|.
name|srcSession
argument_list|,
name|destPoolName
argument_list|)
condition|)
block|{
comment|// remove from src pool
name|RemoveSessionResult
name|rr
init|=
name|checkAndRemoveSessionFromItsPool
argument_list|(
name|moveSession
operator|.
name|srcSession
argument_list|,
name|poolsToRedistribute
argument_list|,
literal|true
argument_list|)
decl_stmt|;
if|if
condition|(
name|rr
operator|==
name|RemoveSessionResult
operator|.
name|OK
condition|)
block|{
comment|// check if there is capacity in dest pool, if so move else kill the session
if|if
condition|(
name|capacityAvailable
argument_list|(
name|destPoolName
argument_list|)
condition|)
block|{
comment|// add to destination pool
name|Boolean
name|added
init|=
name|checkAndAddSessionToAnotherPool
argument_list|(
name|moveSession
operator|.
name|srcSession
argument_list|,
name|destPoolName
argument_list|,
name|poolsToRedistribute
argument_list|)
decl_stmt|;
if|if
condition|(
name|added
operator|!=
literal|null
operator|&&
name|added
condition|)
block|{
name|moveSession
operator|.
name|future
operator|.
name|set
argument_list|(
literal|true
argument_list|)
expr_stmt|;
return|return;
block|}
else|else
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Failed to move session: {}. Session is not added to destination."
argument_list|,
name|moveSession
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|WmTezSession
name|session
init|=
name|moveSession
operator|.
name|srcSession
decl_stmt|;
name|resetRemovedSessionToKill
argument_list|(
name|session
argument_list|,
name|toReuse
argument_list|)
expr_stmt|;
name|syncWork
operator|.
name|toKillQuery
operator|.
name|put
argument_list|(
name|session
argument_list|,
operator|new
name|KillQueryContext
argument_list|(
name|session
argument_list|,
literal|"Destination pool "
operator|+
name|destPoolName
operator|+
literal|" is full. Killing query."
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Failed to move session: {}. Session is not removed from its pool."
argument_list|,
name|moveSession
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Validation failed for move session: {}. Invalid move or session/pool got removed."
argument_list|,
name|moveSession
argument_list|)
expr_stmt|;
block|}
name|moveSession
operator|.
name|future
operator|.
name|set
argument_list|(
literal|false
argument_list|)
expr_stmt|;
block|}
specifier|private
name|Boolean
name|capacityAvailable
parameter_list|(
specifier|final
name|String
name|destPoolName
parameter_list|)
block|{
name|PoolState
name|destPool
init|=
name|pools
operator|.
name|get
argument_list|(
name|destPoolName
argument_list|)
decl_stmt|;
return|return
name|destPool
operator|.
name|getTotalActiveSessions
argument_list|()
operator|<
name|destPool
operator|.
name|queryParallelism
return|;
block|}
specifier|private
name|boolean
name|validMove
parameter_list|(
specifier|final
name|WmTezSession
name|srcSession
parameter_list|,
specifier|final
name|String
name|destPool
parameter_list|)
block|{
return|return
name|srcSession
operator|!=
literal|null
operator|&&
name|destPool
operator|!=
literal|null
operator|&&
operator|!
name|srcSession
operator|.
name|isIrrelevantForWm
argument_list|()
operator|&&
name|srcSession
operator|.
name|getPoolName
argument_list|()
operator|!=
literal|null
operator|&&
name|pools
operator|.
name|containsKey
argument_list|(
name|srcSession
operator|.
name|getPoolName
argument_list|()
argument_list|)
operator|&&
name|pools
operator|.
name|containsKey
argument_list|(
name|destPool
argument_list|)
operator|&&
operator|!
name|srcSession
operator|.
name|getPoolName
argument_list|()
operator|.
name|equalsIgnoreCase
argument_list|(
name|destPool
argument_list|)
return|;
block|}
comment|// ========= Master thread methods
specifier|private
name|void
name|handleInitResultOnMasterThread
parameter_list|(
name|SessionInitContext
name|sw
parameter_list|,
name|WmThreadSyncWork
name|syncWork
parameter_list|,
name|HashSet
argument_list|<
name|String
argument_list|>
name|poolsToRedistribute
parameter_list|)
block|{
comment|// For the failures, the users have been notified, we just need to clean up. There's no
comment|// session here (or it's unused), so no conflicts are possible. We just remove it.
comment|// For successes, the user has also been notified, so various requests are also possible;
comment|// however, to start, we'd just put the session into the sessions list and go from there.
name|WmTezSession
name|session
init|=
literal|null
decl_stmt|;
name|sw
operator|.
name|lock
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
if|if
condition|(
name|sw
operator|.
name|state
operator|==
name|SessionInitState
operator|.
name|CANCELED
condition|)
block|{
comment|// We have processed this on the previous run, after it has already queued the message.
return|return;
block|}
assert|assert
name|sw
operator|.
name|state
operator|==
name|SessionInitState
operator|.
name|DONE
assert|;
name|session
operator|=
name|sw
operator|.
name|session
expr_stmt|;
name|sw
operator|.
name|session
operator|=
literal|null
expr_stmt|;
block|}
finally|finally
block|{
name|sw
operator|.
name|lock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"Processing "
operator|+
operator|(
operator|(
name|session
operator|==
literal|null
operator|)
condition|?
literal|"failed"
else|:
literal|"successful"
operator|)
operator|+
literal|" initialization result for pool "
operator|+
name|sw
operator|.
name|poolName
argument_list|)
expr_stmt|;
comment|// We could not have removed the pool for this session, or we would have CANCELED the init.
name|PoolState
name|pool
init|=
name|pools
operator|.
name|get
argument_list|(
name|sw
operator|.
name|poolName
argument_list|)
decl_stmt|;
if|if
condition|(
name|pool
operator|==
literal|null
operator|||
operator|!
name|pool
operator|.
name|initializingSessions
operator|.
name|remove
argument_list|(
name|sw
argument_list|)
condition|)
block|{
comment|// Query parallelism might be fubar.
name|LOG
operator|.
name|error
argument_list|(
literal|"Cannot remove initializing session from the pool "
operator|+
name|sw
operator|.
name|poolName
operator|+
literal|" - internal error"
argument_list|)
expr_stmt|;
block|}
name|poolsToRedistribute
operator|.
name|add
argument_list|(
name|sw
operator|.
name|poolName
argument_list|)
expr_stmt|;
if|if
condition|(
name|session
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|pool
operator|!=
literal|null
condition|)
block|{
name|pool
operator|.
name|sessions
operator|.
name|add
argument_list|(
name|session
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Cannot add new session to the pool "
operator|+
name|sw
operator|.
name|poolName
operator|+
literal|" because it was removed unexpectedly - internal error "
operator|+
name|session
argument_list|)
expr_stmt|;
name|syncWork
operator|.
name|toRestartInUse
operator|.
name|add
argument_list|(
name|session
argument_list|)
expr_stmt|;
block|}
block|}
block|}
specifier|private
name|RemoveSessionResult
name|handleReturnedInUseSessionOnMasterThread
parameter_list|(
name|EventState
name|e
parameter_list|,
name|WmTezSession
name|session
parameter_list|,
name|HashSet
argument_list|<
name|String
argument_list|>
name|poolsToRedistribute
parameter_list|,
name|boolean
name|isReturn
parameter_list|)
block|{
comment|// This handles the common logic for destroy and return - everything except
comment|// the invalid combination of destroy and return themselves, as well as the actual
comment|// statement that destroys or returns it.
if|if
condition|(
name|e
operator|.
name|updateErrors
operator|.
name|remove
argument_list|(
name|session
argument_list|)
operator|!=
literal|null
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Ignoring an update error for a session being destroyed or returned"
argument_list|)
expr_stmt|;
block|}
name|SettableFuture
argument_list|<
name|WmTezSession
argument_list|>
name|future
init|=
name|e
operator|.
name|toReopen
operator|.
name|remove
argument_list|(
name|session
argument_list|)
decl_stmt|;
if|if
condition|(
name|future
operator|!=
literal|null
condition|)
block|{
name|future
operator|.
name|setException
argument_list|(
operator|new
name|AssertionError
argument_list|(
literal|"Invalid reopen attempt"
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|GetRequest
name|reuseRequest
init|=
name|e
operator|.
name|toReuse
operator|.
name|remove
argument_list|(
name|session
argument_list|)
decl_stmt|;
if|if
condition|(
name|reuseRequest
operator|!=
literal|null
condition|)
block|{
name|reuseRequest
operator|.
name|future
operator|.
name|setException
argument_list|(
operator|new
name|AssertionError
argument_list|(
literal|"Invalid reuse attempt"
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|session
operator|.
name|setQueryId
argument_list|(
literal|null
argument_list|)
expr_stmt|;
return|return
name|checkAndRemoveSessionFromItsPool
argument_list|(
name|session
argument_list|,
name|poolsToRedistribute
argument_list|,
name|isReturn
argument_list|)
return|;
block|}
specifier|private
name|void
name|handeReopenRequestOnMasterThread
parameter_list|(
name|EventState
name|e
parameter_list|,
name|WmTezSession
name|session
parameter_list|,
name|SettableFuture
argument_list|<
name|WmTezSession
argument_list|>
name|future
parameter_list|,
name|HashSet
argument_list|<
name|String
argument_list|>
name|poolsToRedistribute
parameter_list|,
name|WmThreadSyncWork
name|syncWork
parameter_list|)
throws|throws
name|Exception
block|{
if|if
condition|(
name|e
operator|.
name|updateErrors
operator|.
name|remove
argument_list|(
name|session
argument_list|)
operator|!=
literal|null
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Ignoring an update error for a session being reopened"
argument_list|)
expr_stmt|;
block|}
name|GetRequest
name|reuseRequest
init|=
name|e
operator|.
name|toReuse
operator|.
name|remove
argument_list|(
name|session
argument_list|)
decl_stmt|;
if|if
condition|(
name|reuseRequest
operator|!=
literal|null
condition|)
block|{
name|reuseRequest
operator|.
name|future
operator|.
name|setException
argument_list|(
operator|new
name|AssertionError
argument_list|(
literal|"Invalid reuse attempt"
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// In order to expedite things in a general case, we are not actually going to reopen
comment|// anything. Instead, we will try to give out an existing session from the pool, and restart
comment|// the problematic one in background.
name|String
name|poolName
init|=
name|session
operator|.
name|getPoolName
argument_list|()
decl_stmt|;
name|RemoveSessionResult
name|rr
init|=
name|checkAndRemoveSessionFromItsPool
argument_list|(
name|session
argument_list|,
name|poolsToRedistribute
argument_list|,
literal|false
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|rr
condition|)
block|{
case|case
name|OK
case|:
comment|// If pool didn't exist, checkAndRemoveSessionFromItsPool wouldn't have returned OK.
name|PoolState
name|pool
init|=
name|pools
operator|.
name|get
argument_list|(
name|poolName
argument_list|)
decl_stmt|;
name|SessionInitContext
name|sw
init|=
operator|new
name|SessionInitContext
argument_list|(
name|future
argument_list|,
name|poolName
argument_list|,
name|session
operator|.
name|getQueryId
argument_list|()
argument_list|)
decl_stmt|;
comment|// We have just removed the session from the same pool, so don't check concurrency here.
name|pool
operator|.
name|initializingSessions
operator|.
name|add
argument_list|(
name|sw
argument_list|)
expr_stmt|;
name|ListenableFuture
argument_list|<
name|WmTezSession
argument_list|>
name|getFuture
init|=
name|tezAmPool
operator|.
name|getSessionAsync
argument_list|()
decl_stmt|;
name|Futures
operator|.
name|addCallback
argument_list|(
name|getFuture
argument_list|,
name|sw
argument_list|)
expr_stmt|;
name|syncWork
operator|.
name|toRestartInUse
operator|.
name|add
argument_list|(
name|session
argument_list|)
expr_stmt|;
return|return;
case|case
name|IGNORE
case|:
comment|// Reopen implies the use of the reopened session for the same query that we gave it out
comment|// for; so, as we would have failed an active query, fail the user before it's started.
name|future
operator|.
name|setException
argument_list|(
operator|new
name|RuntimeException
argument_list|(
literal|"WM killed this session during reopen: "
operator|+
name|session
operator|.
name|getReasonForKill
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
return|return;
comment|// No longer relevant for WM.
case|case
name|NOT_FOUND
case|:
comment|// If we fail to remove, it's probably an internal error. We'd try to handle it the same way
comment|// as above - by restarting the session. We'd fail the caller to avoid exceeding parallelism.
name|future
operator|.
name|setException
argument_list|(
operator|new
name|RuntimeException
argument_list|(
literal|"Reopen failed due to an internal error"
argument_list|)
argument_list|)
expr_stmt|;
name|syncWork
operator|.
name|toRestartInUse
operator|.
name|add
argument_list|(
name|session
argument_list|)
expr_stmt|;
return|return;
default|default:
throw|throw
operator|new
name|AssertionError
argument_list|(
literal|"Unknown state "
operator|+
name|rr
argument_list|)
throw|;
block|}
block|}
specifier|private
name|void
name|handleUpdateErrorOnMasterThread
parameter_list|(
name|WmTezSession
name|session
parameter_list|,
name|int
name|failedEndpointVersion
parameter_list|,
name|IdentityHashMap
argument_list|<
name|WmTezSession
argument_list|,
name|GetRequest
argument_list|>
name|toReuse
parameter_list|,
name|WmThreadSyncWork
name|syncWork
parameter_list|,
name|HashSet
argument_list|<
name|String
argument_list|>
name|poolsToRedistribute
parameter_list|)
block|{
comment|// First, check if the registry has been updated since the error, and skip the error if
comment|// we have received new, valid registry info (TODO: externally, add a grace period for this?).
name|Ref
argument_list|<
name|Integer
argument_list|>
name|endpointVersion
init|=
operator|new
name|Ref
argument_list|<>
argument_list|(
operator|-
literal|1
argument_list|)
decl_stmt|;
name|AmPluginInfo
name|info
init|=
name|session
operator|.
name|getAmPluginInfo
argument_list|(
name|endpointVersion
argument_list|)
decl_stmt|;
if|if
condition|(
name|info
operator|!=
literal|null
operator|&&
name|endpointVersion
operator|.
name|value
operator|>
name|failedEndpointVersion
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Ignoring an update error; endpoint information has been updated to {}"
argument_list|,
name|info
argument_list|)
expr_stmt|;
return|return;
block|}
name|GetRequest
name|reuseRequest
init|=
name|toReuse
operator|.
name|remove
argument_list|(
name|session
argument_list|)
decl_stmt|;
if|if
condition|(
name|reuseRequest
operator|!=
literal|null
condition|)
block|{
comment|// This session is bad, so don't allow reuse; just convert it to normal get.
name|reuseRequest
operator|.
name|sessionToReuse
operator|=
literal|null
expr_stmt|;
block|}
comment|// TODO: we should communicate this to the user more explicitly (use kill query API, or
comment|//       add an option for bg kill checking to TezTask/monitor?
comment|// We are assuming the update-error AM is bad and just try to kill it.
name|RemoveSessionResult
name|rr
init|=
name|checkAndRemoveSessionFromItsPool
argument_list|(
name|session
argument_list|,
name|poolsToRedistribute
argument_list|,
literal|null
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|rr
condition|)
block|{
case|case
name|OK
case|:
case|case
name|NOT_FOUND
case|:
comment|// Regardless whether it was removed successfully or after failing to remove, restart it.
comment|// Since we just restart this from under the user, mark it so we handle it properly when
comment|// the user tries to actually use this session and fails, proceeding to return/destroy it.
name|session
operator|.
name|setIsIrrelevantForWm
argument_list|(
literal|"Failed to update resource allocation"
argument_list|)
expr_stmt|;
comment|// We assume AM might be bad so we will not try to kill the query here; just scrap the AM.
comment|// TODO: propagate this error to TezJobMonitor somehow? Without using killQuery
name|syncWork
operator|.
name|toRestartInUse
operator|.
name|add
argument_list|(
name|session
argument_list|)
expr_stmt|;
break|break;
case|case
name|IGNORE
case|:
return|return;
comment|// An update error for some session that was actually already killed by us.
default|default:
throw|throw
operator|new
name|AssertionError
argument_list|(
literal|"Unknown state "
operator|+
name|rr
argument_list|)
throw|;
block|}
block|}
specifier|private
name|void
name|applyNewResourcePlanOnMasterThread
parameter_list|(
name|EventState
name|e
parameter_list|,
name|WmThreadSyncWork
name|syncWork
parameter_list|,
name|HashSet
argument_list|<
name|String
argument_list|>
name|poolsToRedistribute
parameter_list|)
block|{
name|int
name|totalQueryParallelism
init|=
literal|0
decl_stmt|;
comment|// FIXME: Add Triggers from metastore to poolstate
comment|// Note: we assume here that plan has been validated beforehand, so we don't verify
comment|//       that fractions or query parallelism add up, etc.
name|this
operator|.
name|rpName
operator|=
name|e
operator|.
name|resourcePlanToApply
operator|.
name|getPlan
argument_list|()
operator|.
name|getName
argument_list|()
expr_stmt|;
name|this
operator|.
name|defaultPool
operator|=
name|e
operator|.
name|resourcePlanToApply
operator|.
name|getPlan
argument_list|()
operator|.
name|getDefaultPoolPath
argument_list|()
expr_stmt|;
name|this
operator|.
name|userPoolMapping
operator|=
operator|new
name|UserPoolMapping
argument_list|(
name|e
operator|.
name|resourcePlanToApply
operator|.
name|getMappings
argument_list|()
argument_list|,
name|defaultPool
argument_list|)
expr_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|PoolState
argument_list|>
name|oldPools
init|=
name|pools
decl_stmt|;
name|pools
operator|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
expr_stmt|;
comment|// For simplicity, to always have parents while storing pools in a flat structure, we'll
comment|// first distribute them by levels, then add level by level.
name|ArrayList
argument_list|<
name|List
argument_list|<
name|WMPool
argument_list|>
argument_list|>
name|poolsByLevel
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|WMPool
name|pool
range|:
name|e
operator|.
name|resourcePlanToApply
operator|.
name|getPools
argument_list|()
control|)
block|{
name|String
name|fullName
init|=
name|pool
operator|.
name|getPoolPath
argument_list|()
decl_stmt|;
name|int
name|ix
init|=
name|StringUtils
operator|.
name|countMatches
argument_list|(
name|fullName
argument_list|,
name|POOL_SEPARATOR_STR
argument_list|)
decl_stmt|;
while|while
condition|(
name|poolsByLevel
operator|.
name|size
argument_list|()
operator|<=
name|ix
condition|)
block|{
name|poolsByLevel
operator|.
name|add
argument_list|(
operator|new
name|LinkedList
argument_list|<
name|WMPool
argument_list|>
argument_list|()
argument_list|)
expr_stmt|;
comment|// We expect all the levels to have items.
block|}
name|poolsByLevel
operator|.
name|get
argument_list|(
name|ix
argument_list|)
operator|.
name|add
argument_list|(
name|pool
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|int
name|level
init|=
literal|0
init|;
name|level
operator|<
name|poolsByLevel
operator|.
name|size
argument_list|()
condition|;
operator|++
name|level
control|)
block|{
name|List
argument_list|<
name|WMPool
argument_list|>
name|poolsOnLevel
init|=
name|poolsByLevel
operator|.
name|get
argument_list|(
name|level
argument_list|)
decl_stmt|;
for|for
control|(
name|WMPool
name|pool
range|:
name|poolsOnLevel
control|)
block|{
name|String
name|fullName
init|=
name|pool
operator|.
name|getPoolPath
argument_list|()
decl_stmt|;
name|int
name|qp
init|=
name|pool
operator|.
name|getQueryParallelism
argument_list|()
decl_stmt|;
name|double
name|fraction
init|=
name|pool
operator|.
name|getAllocFraction
argument_list|()
decl_stmt|;
if|if
condition|(
name|level
operator|>
literal|0
condition|)
block|{
name|String
name|parentName
init|=
name|fullName
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|fullName
operator|.
name|lastIndexOf
argument_list|(
name|POOL_SEPARATOR
argument_list|)
argument_list|)
decl_stmt|;
name|PoolState
name|parent
init|=
name|pools
operator|.
name|get
argument_list|(
name|parentName
argument_list|)
decl_stmt|;
name|fraction
operator|=
name|parent
operator|.
name|finalFraction
operator|*
name|fraction
expr_stmt|;
name|parent
operator|.
name|finalFractionRemaining
operator|-=
name|fraction
expr_stmt|;
block|}
name|PoolState
name|state
init|=
name|oldPools
operator|==
literal|null
condition|?
literal|null
else|:
name|oldPools
operator|.
name|remove
argument_list|(
name|fullName
argument_list|)
decl_stmt|;
if|if
condition|(
name|state
operator|==
literal|null
condition|)
block|{
name|state
operator|=
operator|new
name|PoolState
argument_list|(
name|fullName
argument_list|,
name|qp
argument_list|,
name|fraction
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// This will also take care of the queries if query parallelism changed.
name|state
operator|.
name|update
argument_list|(
name|qp
argument_list|,
name|fraction
argument_list|,
name|syncWork
operator|.
name|toKillQuery
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|poolsToRedistribute
operator|.
name|add
argument_list|(
name|fullName
argument_list|)
expr_stmt|;
block|}
name|state
operator|.
name|setTriggers
argument_list|(
operator|new
name|LinkedList
argument_list|<
name|Trigger
argument_list|>
argument_list|()
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Adding Hive pool: "
operator|+
name|state
argument_list|)
expr_stmt|;
name|pools
operator|.
name|put
argument_list|(
name|fullName
argument_list|,
name|state
argument_list|)
expr_stmt|;
name|totalQueryParallelism
operator|+=
name|qp
expr_stmt|;
block|}
block|}
if|if
condition|(
name|e
operator|.
name|resourcePlanToApply
operator|.
name|isSetTriggers
argument_list|()
operator|&&
name|e
operator|.
name|resourcePlanToApply
operator|.
name|isSetPoolTriggers
argument_list|()
condition|)
block|{
name|Map
argument_list|<
name|String
argument_list|,
name|Trigger
argument_list|>
name|triggers
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|WMTrigger
name|trigger
range|:
name|e
operator|.
name|resourcePlanToApply
operator|.
name|getTriggers
argument_list|()
control|)
block|{
name|ExecutionTrigger
name|execTrigger
init|=
name|ExecutionTrigger
operator|.
name|fromWMTrigger
argument_list|(
name|trigger
argument_list|)
decl_stmt|;
name|triggers
operator|.
name|put
argument_list|(
name|trigger
operator|.
name|getTriggerName
argument_list|()
argument_list|,
name|execTrigger
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|WMPoolTrigger
name|poolTrigger
range|:
name|e
operator|.
name|resourcePlanToApply
operator|.
name|getPoolTriggers
argument_list|()
control|)
block|{
name|PoolState
name|pool
init|=
name|pools
operator|.
name|get
argument_list|(
name|poolTrigger
operator|.
name|getPool
argument_list|()
argument_list|)
decl_stmt|;
name|Trigger
name|trigger
init|=
name|triggers
operator|.
name|get
argument_list|(
name|poolTrigger
operator|.
name|getTrigger
argument_list|()
argument_list|)
decl_stmt|;
name|pool
operator|.
name|triggers
operator|.
name|add
argument_list|(
name|trigger
argument_list|)
expr_stmt|;
name|poolsToRedistribute
operator|.
name|add
argument_list|(
name|pool
operator|.
name|fullName
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Adding pool "
operator|+
name|pool
operator|.
name|fullName
operator|+
literal|" trigger "
operator|+
name|trigger
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|oldPools
operator|!=
literal|null
operator|&&
operator|!
name|oldPools
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
comment|// Looks like some pools were removed; kill running queries, re-queue the queued ones.
for|for
control|(
name|PoolState
name|oldPool
range|:
name|oldPools
operator|.
name|values
argument_list|()
control|)
block|{
name|oldPool
operator|.
name|destroy
argument_list|(
name|syncWork
operator|.
name|toKillQuery
argument_list|,
name|e
operator|.
name|getRequests
argument_list|,
name|e
operator|.
name|toReuse
argument_list|)
expr_stmt|;
block|}
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"Updating with "
operator|+
name|totalQueryParallelism
operator|+
literal|" total query parallelism"
argument_list|)
expr_stmt|;
name|int
name|deltaSessions
init|=
name|totalQueryParallelism
operator|-
name|this
operator|.
name|totalQueryParallelism
decl_stmt|;
name|this
operator|.
name|totalQueryParallelism
operator|=
name|totalQueryParallelism
expr_stmt|;
if|if
condition|(
name|deltaSessions
operator|==
literal|0
condition|)
return|return;
comment|// Nothing to do.
if|if
condition|(
name|deltaSessions
operator|<
literal|0
condition|)
block|{
comment|// First, see if we have sessions that we were planning to restart/kill; get rid of those.
name|deltaSessions
operator|=
name|transferSessionsToDestroy
argument_list|(
name|syncWork
operator|.
name|toKillQuery
operator|.
name|keySet
argument_list|()
argument_list|,
name|syncWork
operator|.
name|toDestroyNoRestart
argument_list|,
name|deltaSessions
argument_list|)
expr_stmt|;
name|deltaSessions
operator|=
name|transferSessionsToDestroy
argument_list|(
name|syncWork
operator|.
name|toRestartInUse
argument_list|,
name|syncWork
operator|.
name|toDestroyNoRestart
argument_list|,
name|deltaSessions
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|deltaSessions
operator|!=
literal|0
condition|)
block|{
name|failOnFutureFailure
argument_list|(
name|tezAmPool
operator|.
name|resizeAsync
argument_list|(
name|deltaSessions
argument_list|,
name|syncWork
operator|.
name|toDestroyNoRestart
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
specifier|static
name|int
name|transferSessionsToDestroy
parameter_list|(
name|Collection
argument_list|<
name|WmTezSession
argument_list|>
name|source
parameter_list|,
name|List
argument_list|<
name|WmTezSession
argument_list|>
name|toDestroy
parameter_list|,
name|int
name|deltaSessions
parameter_list|)
block|{
comment|// We were going to kill some queries and reuse the sessions, or maybe restart and put the new
comment|// ones back into the AM pool. However, the AM pool has shrunk, so we will close them instead.
if|if
condition|(
name|deltaSessions
operator|>=
literal|0
condition|)
return|return
name|deltaSessions
return|;
name|int
name|toTransfer
init|=
name|Math
operator|.
name|min
argument_list|(
operator|-
name|deltaSessions
argument_list|,
name|source
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
name|Iterator
argument_list|<
name|WmTezSession
argument_list|>
name|iter
init|=
name|source
operator|.
name|iterator
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|toTransfer
condition|;
operator|++
name|i
control|)
block|{
name|WmTezSession
name|session
init|=
name|iter
operator|.
name|next
argument_list|()
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Will destroy {} instead of restarting"
argument_list|,
name|session
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|session
operator|.
name|isIrrelevantForWm
argument_list|()
condition|)
block|{
name|session
operator|.
name|setIsIrrelevantForWm
argument_list|(
literal|"Killed due to workload management plan change"
argument_list|)
expr_stmt|;
block|}
name|toDestroy
operator|.
name|add
argument_list|(
name|session
argument_list|)
expr_stmt|;
name|iter
operator|.
name|remove
argument_list|()
expr_stmt|;
block|}
return|return
name|deltaSessions
operator|+
name|toTransfer
return|;
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
specifier|private
name|void
name|failOnFutureFailure
parameter_list|(
name|ListenableFuture
argument_list|<
name|?
argument_list|>
name|future
parameter_list|)
block|{
name|Futures
operator|.
name|addCallback
argument_list|(
name|future
argument_list|,
name|FATAL_ERROR_CALLBACK
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|queueGetRequestOnMasterThread
parameter_list|(
name|GetRequest
name|req
parameter_list|,
name|HashSet
argument_list|<
name|String
argument_list|>
name|poolsToRedistribute
parameter_list|,
name|WmThreadSyncWork
name|syncWork
parameter_list|)
block|{
name|String
name|poolName
init|=
name|userPoolMapping
operator|.
name|mapSessionToPoolName
argument_list|(
name|req
operator|.
name|mappingInput
argument_list|)
decl_stmt|;
if|if
condition|(
name|poolName
operator|==
literal|null
condition|)
block|{
name|req
operator|.
name|future
operator|.
name|setException
argument_list|(
operator|new
name|NoPoolMappingException
argument_list|(
literal|"Cannot find any pool mapping for "
operator|+
name|req
operator|.
name|mappingInput
argument_list|)
argument_list|)
expr_stmt|;
name|returnSessionOnFailedReuse
argument_list|(
name|req
argument_list|,
name|syncWork
argument_list|,
name|poolsToRedistribute
argument_list|)
expr_stmt|;
return|return;
block|}
name|PoolState
name|pool
init|=
name|pools
operator|.
name|get
argument_list|(
name|poolName
argument_list|)
decl_stmt|;
if|if
condition|(
name|pool
operator|==
literal|null
condition|)
block|{
name|req
operator|.
name|future
operator|.
name|setException
argument_list|(
operator|new
name|AssertionError
argument_list|(
name|poolName
operator|+
literal|" not found (internal error)."
argument_list|)
argument_list|)
expr_stmt|;
name|returnSessionOnFailedReuse
argument_list|(
name|req
argument_list|,
name|syncWork
argument_list|,
name|poolsToRedistribute
argument_list|)
expr_stmt|;
return|return;
block|}
name|PoolState
name|oldPool
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|req
operator|.
name|sessionToReuse
operator|!=
literal|null
condition|)
block|{
comment|// Given that we are trying to reuse, this session MUST be in some pool.sessions.
comment|// Kills that could have removed it must have cleared sessionToReuse.
name|String
name|oldPoolName
init|=
name|req
operator|.
name|sessionToReuse
operator|.
name|getPoolName
argument_list|()
decl_stmt|;
name|oldPool
operator|=
name|pools
operator|.
name|get
argument_list|(
name|oldPoolName
argument_list|)
expr_stmt|;
name|RemoveSessionResult
name|rr
init|=
name|checkAndRemoveSessionFromItsPool
argument_list|(
name|req
operator|.
name|sessionToReuse
argument_list|,
name|poolsToRedistribute
argument_list|,
literal|true
argument_list|)
decl_stmt|;
if|if
condition|(
name|rr
operator|!=
name|RemoveSessionResult
operator|.
name|OK
condition|)
block|{
comment|// Abandon the reuse attempt.
name|returnSessionOnFailedReuse
argument_list|(
name|req
argument_list|,
name|syncWork
argument_list|,
literal|null
argument_list|)
expr_stmt|;
name|req
operator|.
name|sessionToReuse
operator|=
literal|null
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|pool
operator|.
name|getTotalActiveSessions
argument_list|()
operator|+
name|pool
operator|.
name|queue
operator|.
name|size
argument_list|()
operator|>=
name|pool
operator|.
name|queryParallelism
condition|)
block|{
comment|// One cannot simply reuse the session if there are other queries waiting; to maintain
comment|// fairness, we'll try to take a query slot instantly, and if that fails we'll return
comment|// this session back to the pool and give the user a new session later.
name|returnSessionOnFailedReuse
argument_list|(
name|req
argument_list|,
name|syncWork
argument_list|,
literal|null
argument_list|)
expr_stmt|;
name|req
operator|.
name|sessionToReuse
operator|=
literal|null
expr_stmt|;
block|}
block|}
if|if
condition|(
name|req
operator|.
name|sessionToReuse
operator|!=
literal|null
condition|)
block|{
comment|// If we can immediately reuse a session, there's nothing to wait for - just return.
name|req
operator|.
name|sessionToReuse
operator|.
name|setPoolName
argument_list|(
name|poolName
argument_list|)
expr_stmt|;
name|req
operator|.
name|sessionToReuse
operator|.
name|setQueueName
argument_list|(
name|yarnQueue
argument_list|)
expr_stmt|;
name|req
operator|.
name|sessionToReuse
operator|.
name|setQueryId
argument_list|(
name|req
operator|.
name|queryId
argument_list|)
expr_stmt|;
name|pool
operator|.
name|sessions
operator|.
name|add
argument_list|(
name|req
operator|.
name|sessionToReuse
argument_list|)
expr_stmt|;
if|if
condition|(
name|pool
operator|!=
name|oldPool
condition|)
block|{
name|poolsToRedistribute
operator|.
name|add
argument_list|(
name|poolName
argument_list|)
expr_stmt|;
block|}
name|req
operator|.
name|future
operator|.
name|set
argument_list|(
name|req
operator|.
name|sessionToReuse
argument_list|)
expr_stmt|;
return|return;
block|}
comment|// Otherwise, queue the session and make sure we update this pool.
name|pool
operator|.
name|queue
operator|.
name|addLast
argument_list|(
name|req
argument_list|)
expr_stmt|;
name|poolsToRedistribute
operator|.
name|add
argument_list|(
name|poolName
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|processPoolChangesOnMasterThread
parameter_list|(
name|String
name|poolName
parameter_list|,
name|WmThreadSyncWork
name|context
parameter_list|,
name|boolean
name|hasRequeues
parameter_list|)
throws|throws
name|Exception
block|{
name|PoolState
name|pool
init|=
name|pools
operator|.
name|get
argument_list|(
name|poolName
argument_list|)
decl_stmt|;
if|if
condition|(
name|pool
operator|==
literal|null
condition|)
return|return;
comment|// Might be from before the new resource plan.
comment|// 1. First, start the queries from the queue.
name|int
name|queriesToStart
init|=
name|Math
operator|.
name|min
argument_list|(
name|pool
operator|.
name|queue
operator|.
name|size
argument_list|()
argument_list|,
name|pool
operator|.
name|queryParallelism
operator|-
name|pool
operator|.
name|getTotalActiveSessions
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|queriesToStart
operator|>
literal|0
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Starting {} queries in pool {}"
argument_list|,
name|queriesToStart
argument_list|,
name|pool
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|hasRequeues
condition|)
block|{
comment|// Sort the queue - we may have put items here out of order.
name|Collections
operator|.
name|sort
argument_list|(
name|pool
operator|.
name|queue
argument_list|,
name|GetRequest
operator|.
name|ORDER_COMPARATOR
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|queriesToStart
condition|;
operator|++
name|i
control|)
block|{
name|GetRequest
name|queueReq
init|=
name|pool
operator|.
name|queue
operator|.
name|pollFirst
argument_list|()
decl_stmt|;
assert|assert
name|queueReq
operator|.
name|sessionToReuse
operator|==
literal|null
assert|;
comment|// Note that in theory, we are guaranteed to have a session waiting for us here, but
comment|// the expiration, failures, etc. may cause one to be missing pending restart.
comment|// See SessionInitContext javadoc.
name|SessionInitContext
name|sw
init|=
operator|new
name|SessionInitContext
argument_list|(
name|queueReq
operator|.
name|future
argument_list|,
name|poolName
argument_list|,
name|queueReq
operator|.
name|queryId
argument_list|)
decl_stmt|;
name|ListenableFuture
argument_list|<
name|WmTezSession
argument_list|>
name|getFuture
init|=
name|tezAmPool
operator|.
name|getSessionAsync
argument_list|()
decl_stmt|;
name|Futures
operator|.
name|addCallback
argument_list|(
name|getFuture
argument_list|,
name|sw
argument_list|)
expr_stmt|;
comment|// It is possible that all the async methods returned on the same thread because the
comment|// session with registry data and stuff was available in the pool.
comment|// If this happens, we'll take the session out here and "cancel" the init so we skip
comment|// processing the message that the successful init has queued for us.
name|boolean
name|isDone
init|=
name|sw
operator|.
name|extractSessionAndCancelIfDone
argument_list|(
name|pool
operator|.
name|sessions
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|isDone
condition|)
block|{
name|pool
operator|.
name|initializingSessions
operator|.
name|add
argument_list|(
name|sw
argument_list|)
expr_stmt|;
block|}
comment|// The user has already been notified of completion by SessionInitContext.
block|}
comment|// 2. Then, update pool allocations.
name|double
name|totalAlloc
init|=
name|pool
operator|.
name|updateAllocationPercentages
argument_list|()
decl_stmt|;
comment|// We are calling this here because we expect the method to be completely async. We also don't
comment|// want this call itself to go on a thread because we want the percent-to-physics conversion
comment|// logic to be consistent between all the separate calls in one master thread processing round.
comment|// Note: If allocation manager does not have cluster state, it won't update anything. When the
comment|//       cluster state changes, it will notify us, and we'd update the queries again.
name|allocationManager
operator|.
name|updateSessionsAsync
argument_list|(
name|totalAlloc
argument_list|,
name|pool
operator|.
name|sessions
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|returnSessionOnFailedReuse
parameter_list|(
name|GetRequest
name|req
parameter_list|,
name|WmThreadSyncWork
name|syncWork
parameter_list|,
name|HashSet
argument_list|<
name|String
argument_list|>
name|poolsToRedistribute
parameter_list|)
block|{
name|WmTezSession
name|session
init|=
name|req
operator|.
name|sessionToReuse
decl_stmt|;
if|if
condition|(
name|session
operator|==
literal|null
condition|)
return|return;
name|req
operator|.
name|sessionToReuse
operator|=
literal|null
expr_stmt|;
name|session
operator|.
name|setQueryId
argument_list|(
literal|null
argument_list|)
expr_stmt|;
if|if
condition|(
name|poolsToRedistribute
operator|!=
literal|null
condition|)
block|{
name|RemoveSessionResult
name|rr
init|=
name|checkAndRemoveSessionFromItsPool
argument_list|(
name|session
argument_list|,
name|poolsToRedistribute
argument_list|,
literal|true
argument_list|)
decl_stmt|;
comment|// The session cannot have been killed just now; this happens after all the kills in
comment|// the current iteration, so we would have cleared sessionToReuse when killing this.
name|boolean
name|isOk
init|=
operator|(
name|rr
operator|==
name|RemoveSessionResult
operator|.
name|OK
operator|)
decl_stmt|;
assert|assert
name|isOk
operator|||
name|rr
operator|==
name|RemoveSessionResult
operator|.
name|IGNORE
assert|;
if|if
condition|(
operator|!
name|isOk
condition|)
return|return;
block|}
if|if
condition|(
operator|!
name|tezAmPool
operator|.
name|returnSessionAsync
argument_list|(
name|session
argument_list|)
condition|)
block|{
name|syncWork
operator|.
name|toDestroyNoRestart
operator|.
name|add
argument_list|(
name|session
argument_list|)
expr_stmt|;
block|}
block|}
comment|/** The result of trying to remove a presumably-active session from a pool on a user request. */
specifier|private
specifier|static
enum|enum
name|RemoveSessionResult
block|{
name|OK
block|,
comment|// Normal case - an active session was removed from the pool.
name|IGNORE
block|,
comment|// Session was restarted out of bounds, any user-side handling should be ignored.
comment|// Or, session is being killed, need to coordinate between that and the user.
comment|// These two cases don't need to be distinguished for now.
name|NOT_FOUND
comment|// The session is active but not found in the pool - internal error.
block|}
comment|/**    * Checks if the session is still relevant for WM and if yes, removes it from its thread.    * @param isSessionOk Whether the user thinks the session being returned in some way is ok;    *                    true means it is (return, reuse); false mean it isn't (reopen, destroy);    *                    null means this is not a user call.    * @return true if the session was removed; false if the session was already processed by WM    *         thread (so we are dealing with an outdated request); null if the session should be    *         in WM but wasn't found in the requisite pool (internal error?).    */
specifier|private
name|RemoveSessionResult
name|checkAndRemoveSessionFromItsPool
parameter_list|(
name|WmTezSession
name|session
parameter_list|,
name|Set
argument_list|<
name|String
argument_list|>
name|poolsToRedistribute
parameter_list|,
name|Boolean
name|isSessionOk
parameter_list|)
block|{
comment|// It is possible for some request to be queued after a main thread has decided to kill this
comment|// session; on the next iteration, we'd be processing that request with an irrelevant session.
if|if
condition|(
name|session
operator|.
name|isIrrelevantForWm
argument_list|()
condition|)
block|{
return|return
name|RemoveSessionResult
operator|.
name|IGNORE
return|;
block|}
if|if
condition|(
name|killQueryInProgress
operator|.
name|containsKey
argument_list|(
name|session
argument_list|)
condition|)
block|{
if|if
condition|(
name|isSessionOk
operator|!=
literal|null
condition|)
block|{
name|killQueryInProgress
operator|.
name|get
argument_list|(
name|session
argument_list|)
operator|.
name|handleUserCallback
argument_list|(
operator|!
name|isSessionOk
argument_list|)
expr_stmt|;
block|}
return|return
name|RemoveSessionResult
operator|.
name|IGNORE
return|;
block|}
comment|// If we did not kill this session we expect everything to be present.
name|String
name|poolName
init|=
name|session
operator|.
name|getPoolName
argument_list|()
decl_stmt|;
if|if
condition|(
name|poolName
operator|!=
literal|null
condition|)
block|{
name|poolsToRedistribute
operator|.
name|add
argument_list|(
name|poolName
argument_list|)
expr_stmt|;
name|PoolState
name|pool
init|=
name|pools
operator|.
name|get
argument_list|(
name|poolName
argument_list|)
decl_stmt|;
name|session
operator|.
name|clearWm
argument_list|()
expr_stmt|;
if|if
condition|(
name|pool
operator|!=
literal|null
operator|&&
name|pool
operator|.
name|sessions
operator|.
name|remove
argument_list|(
name|session
argument_list|)
condition|)
block|{
return|return
name|RemoveSessionResult
operator|.
name|OK
return|;
block|}
block|}
name|LOG
operator|.
name|error
argument_list|(
literal|"Session was not in the pool (internal error) "
operator|+
name|poolName
operator|+
literal|": "
operator|+
name|session
argument_list|)
expr_stmt|;
return|return
name|RemoveSessionResult
operator|.
name|NOT_FOUND
return|;
block|}
specifier|private
name|Boolean
name|checkAndAddSessionToAnotherPool
parameter_list|(
name|WmTezSession
name|session
parameter_list|,
name|String
name|destPoolName
parameter_list|,
name|Set
argument_list|<
name|String
argument_list|>
name|poolsToRedistribute
parameter_list|)
block|{
if|if
condition|(
name|session
operator|.
name|isIrrelevantForWm
argument_list|()
condition|)
block|{
comment|// This is called only during move session handling, removing session already checks this.
comment|// So this is not expected as remove failing will not even invoke this method
name|LOG
operator|.
name|error
argument_list|(
literal|"Unexpected during add session to another pool. If remove failed this should not have been called."
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
name|PoolState
name|destPool
init|=
name|pools
operator|.
name|get
argument_list|(
name|destPoolName
argument_list|)
decl_stmt|;
if|if
condition|(
name|destPool
operator|!=
literal|null
operator|&&
name|destPool
operator|.
name|sessions
operator|.
name|add
argument_list|(
name|session
argument_list|)
condition|)
block|{
name|session
operator|.
name|setPoolName
argument_list|(
name|destPoolName
argument_list|)
expr_stmt|;
name|poolsToRedistribute
operator|.
name|add
argument_list|(
name|destPoolName
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
name|LOG
operator|.
name|error
argument_list|(
literal|"Session {} was not not added to pool {}"
argument_list|,
name|session
argument_list|,
name|destPoolName
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
comment|// ===== EVENT METHODS
specifier|public
name|ListenableFuture
argument_list|<
name|Boolean
argument_list|>
name|updateResourcePlanAsync
parameter_list|(
name|WMFullResourcePlan
name|plan
parameter_list|)
block|{
name|SettableFuture
argument_list|<
name|Boolean
argument_list|>
name|applyRpFuture
init|=
name|SettableFuture
operator|.
name|create
argument_list|()
decl_stmt|;
name|currentLock
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
comment|// TODO: if there's versioning/etc., it will come in here. For now we rely on external
comment|//       locking or ordering of calls. This should potentially return a Future for that.
if|if
condition|(
name|current
operator|.
name|resourcePlanToApply
operator|!=
literal|null
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Several resource plans are being applied at the same time; using the latest"
argument_list|)
expr_stmt|;
name|current
operator|.
name|applyRpFuture
operator|.
name|setException
argument_list|(
operator|new
name|HiveException
argument_list|(
literal|"Another plan was applied in parallel"
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|current
operator|.
name|resourcePlanToApply
operator|=
name|plan
expr_stmt|;
name|current
operator|.
name|applyRpFuture
operator|=
name|applyRpFuture
expr_stmt|;
name|notifyWmThreadUnderLock
argument_list|()
expr_stmt|;
block|}
finally|finally
block|{
name|currentLock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
return|return
name|applyRpFuture
return|;
block|}
specifier|public
name|Future
argument_list|<
name|Boolean
argument_list|>
name|applyMoveSessionAsync
parameter_list|(
name|WmTezSession
name|srcSession
parameter_list|,
name|String
name|destPoolName
parameter_list|)
block|{
name|currentLock
operator|.
name|lock
argument_list|()
expr_stmt|;
name|MoveSession
name|moveSession
decl_stmt|;
try|try
block|{
name|moveSession
operator|=
operator|new
name|MoveSession
argument_list|(
name|srcSession
argument_list|,
name|destPoolName
argument_list|)
expr_stmt|;
name|current
operator|.
name|moveSessions
operator|.
name|add
argument_list|(
name|moveSession
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Queued move session: {}"
argument_list|,
name|moveSession
argument_list|)
expr_stmt|;
name|notifyWmThreadUnderLock
argument_list|()
expr_stmt|;
block|}
finally|finally
block|{
name|currentLock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
return|return
name|moveSession
operator|.
name|future
return|;
block|}
specifier|private
specifier|final
specifier|static
class|class
name|GetRequest
block|{
specifier|public
specifier|static
specifier|final
name|Comparator
argument_list|<
name|GetRequest
argument_list|>
name|ORDER_COMPARATOR
init|=
operator|new
name|Comparator
argument_list|<
name|GetRequest
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|int
name|compare
parameter_list|(
name|GetRequest
name|o1
parameter_list|,
name|GetRequest
name|o2
parameter_list|)
block|{
if|if
condition|(
name|o1
operator|.
name|order
operator|==
name|o2
operator|.
name|order
condition|)
return|return
literal|0
return|;
return|return
name|o1
operator|.
name|order
operator|<
name|o2
operator|.
name|order
condition|?
operator|-
literal|1
else|:
literal|1
return|;
block|}
block|}
decl_stmt|;
specifier|private
specifier|final
name|long
name|order
decl_stmt|;
specifier|private
specifier|final
name|MappingInput
name|mappingInput
decl_stmt|;
specifier|private
specifier|final
name|SettableFuture
argument_list|<
name|WmTezSession
argument_list|>
name|future
decl_stmt|;
specifier|private
name|WmTezSession
name|sessionToReuse
decl_stmt|;
specifier|private
specifier|final
name|String
name|queryId
decl_stmt|;
specifier|private
name|GetRequest
parameter_list|(
name|MappingInput
name|mappingInput
parameter_list|,
name|String
name|queryId
parameter_list|,
name|SettableFuture
argument_list|<
name|WmTezSession
argument_list|>
name|future
parameter_list|,
name|WmTezSession
name|sessionToReuse
parameter_list|,
name|long
name|order
parameter_list|)
block|{
assert|assert
name|mappingInput
operator|!=
literal|null
assert|;
name|this
operator|.
name|mappingInput
operator|=
name|mappingInput
expr_stmt|;
name|this
operator|.
name|queryId
operator|=
name|queryId
expr_stmt|;
name|this
operator|.
name|future
operator|=
name|future
expr_stmt|;
name|this
operator|.
name|sessionToReuse
operator|=
name|sessionToReuse
expr_stmt|;
name|this
operator|.
name|order
operator|=
name|order
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
literal|"[#"
operator|+
name|order
operator|+
literal|", "
operator|+
name|mappingInput
operator|+
literal|", reuse "
operator|+
name|sessionToReuse
operator|+
literal|"]"
return|;
block|}
block|}
specifier|public
name|TezSessionState
name|getSession
parameter_list|(
name|TezSessionState
name|session
parameter_list|,
name|MappingInput
name|input
parameter_list|,
name|HiveConf
name|conf
parameter_list|)
throws|throws
name|Exception
block|{
comment|// Note: not actually used for pool sessions; verify some things like doAs are not set.
name|validateConfig
argument_list|(
name|conf
argument_list|)
expr_stmt|;
name|String
name|queryId
init|=
name|HiveConf
operator|.
name|getVar
argument_list|(
name|conf
argument_list|,
name|HiveConf
operator|.
name|ConfVars
operator|.
name|HIVEQUERYID
argument_list|)
decl_stmt|;
name|SettableFuture
argument_list|<
name|WmTezSession
argument_list|>
name|future
init|=
name|SettableFuture
operator|.
name|create
argument_list|()
decl_stmt|;
name|WmTezSession
name|wmSession
init|=
name|checkSessionForReuse
argument_list|(
name|session
argument_list|)
decl_stmt|;
name|GetRequest
name|req
init|=
operator|new
name|GetRequest
argument_list|(
name|input
argument_list|,
name|queryId
argument_list|,
name|future
argument_list|,
name|wmSession
argument_list|,
name|getRequestVersion
operator|.
name|incrementAndGet
argument_list|()
argument_list|)
decl_stmt|;
name|currentLock
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
name|current
operator|.
name|getRequests
operator|.
name|add
argument_list|(
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|req
operator|.
name|sessionToReuse
operator|!=
literal|null
condition|)
block|{
comment|// Note: we assume reuse is only possible for the same user and config.
name|current
operator|.
name|toReuse
operator|.
name|put
argument_list|(
name|wmSession
argument_list|,
name|req
argument_list|)
expr_stmt|;
block|}
name|notifyWmThreadUnderLock
argument_list|()
expr_stmt|;
block|}
finally|finally
block|{
name|currentLock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
return|return
name|future
operator|.
name|get
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|destroy
parameter_list|(
name|TezSessionState
name|session
parameter_list|)
throws|throws
name|Exception
block|{
name|WmTezSession
name|wmTezSession
init|=
name|ensureOwnedSession
argument_list|(
name|session
argument_list|)
decl_stmt|;
name|resetGlobalTezSession
argument_list|(
name|wmTezSession
argument_list|)
expr_stmt|;
name|currentLock
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
name|current
operator|.
name|toDestroy
operator|.
name|add
argument_list|(
name|wmTezSession
argument_list|)
expr_stmt|;
name|notifyWmThreadUnderLock
argument_list|()
expr_stmt|;
block|}
finally|finally
block|{
name|currentLock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|resetGlobalTezSession
parameter_list|(
name|WmTezSession
name|wmTezSession
parameter_list|)
block|{
comment|// This has to be done synchronously to avoid the caller getting this session again.
comment|// Ideally we'd get rid of this thread-local nonsense.
name|SessionState
name|sessionState
init|=
name|SessionState
operator|.
name|get
argument_list|()
decl_stmt|;
if|if
condition|(
name|sessionState
operator|!=
literal|null
operator|&&
name|sessionState
operator|.
name|getTezSession
argument_list|()
operator|==
name|wmTezSession
condition|)
block|{
name|sessionState
operator|.
name|setTezSession
argument_list|(
literal|null
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|void
name|returnAfterUse
parameter_list|(
name|TezSessionPoolSession
name|session
parameter_list|)
throws|throws
name|Exception
block|{
name|WmTezSession
name|wmTezSession
init|=
name|ensureOwnedSession
argument_list|(
name|session
argument_list|)
decl_stmt|;
name|resetGlobalTezSession
argument_list|(
name|wmTezSession
argument_list|)
expr_stmt|;
name|currentLock
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
name|current
operator|.
name|toReturn
operator|.
name|add
argument_list|(
name|wmTezSession
argument_list|)
expr_stmt|;
name|notifyWmThreadUnderLock
argument_list|()
expr_stmt|;
block|}
finally|finally
block|{
name|currentLock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|// TODO: use this
specifier|public
name|void
name|nofityOfClusterStateChange
parameter_list|()
block|{
name|currentLock
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
name|current
operator|.
name|hasClusterStateChanged
operator|=
literal|true
expr_stmt|;
name|notifyWmThreadUnderLock
argument_list|()
expr_stmt|;
block|}
finally|finally
block|{
name|currentLock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
name|void
name|addUpdateError
parameter_list|(
name|WmTezSession
name|wmTezSession
parameter_list|,
name|int
name|endpointVersion
parameter_list|)
block|{
name|currentLock
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
name|Integer
name|existing
init|=
name|current
operator|.
name|updateErrors
operator|.
name|get
argument_list|(
name|wmTezSession
argument_list|)
decl_stmt|;
comment|// Only store the latest error, if there are multiple.
if|if
condition|(
name|existing
operator|!=
literal|null
operator|&&
name|existing
operator|>=
name|endpointVersion
condition|)
return|return;
name|current
operator|.
name|updateErrors
operator|.
name|put
argument_list|(
name|wmTezSession
argument_list|,
name|endpointVersion
argument_list|)
expr_stmt|;
name|notifyWmThreadUnderLock
argument_list|()
expr_stmt|;
block|}
finally|finally
block|{
name|currentLock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|List
argument_list|<
name|String
argument_list|>
name|getWmStateDescription
parameter_list|()
block|{
name|Future
argument_list|<
name|List
argument_list|<
name|String
argument_list|>
argument_list|>
name|future
init|=
literal|null
decl_stmt|;
name|currentLock
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
if|if
condition|(
name|current
operator|.
name|dumpStateFuture
operator|!=
literal|null
condition|)
block|{
name|future
operator|=
name|current
operator|.
name|dumpStateFuture
expr_stmt|;
block|}
else|else
block|{
name|future
operator|=
name|current
operator|.
name|dumpStateFuture
operator|=
name|SettableFuture
operator|.
name|create
argument_list|()
expr_stmt|;
name|notifyWmThreadUnderLock
argument_list|()
expr_stmt|;
block|}
block|}
finally|finally
block|{
name|currentLock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
try|try
block|{
return|return
name|future
operator|.
name|get
argument_list|()
return|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
decl||
name|ExecutionException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Error getting description"
argument_list|,
name|e
argument_list|)
expr_stmt|;
return|return
name|Lists
operator|.
name|newArrayList
argument_list|(
literal|"Error: "
operator|+
name|e
operator|.
name|toString
argument_list|()
argument_list|)
return|;
block|}
block|}
specifier|private
name|void
name|addKillQueryResult
parameter_list|(
name|WmTezSession
name|toKill
parameter_list|,
name|boolean
name|success
parameter_list|)
block|{
name|currentLock
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
name|current
operator|.
name|killQueryResults
operator|.
name|put
argument_list|(
name|toKill
argument_list|,
name|success
argument_list|)
expr_stmt|;
name|notifyWmThreadUnderLock
argument_list|()
expr_stmt|;
block|}
finally|finally
block|{
name|currentLock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
annotation|@
name|VisibleForTesting
comment|/**    * Adds a test event that's processed at the end of WM iteration.    * This allows tests to wait for an iteration to finish without messing with the threading    * logic (that is prone to races if we e.g. remember the state before and wait for it to change,    * self-deadlocking when triggering things explicitly and calling a blocking API, and hanging    * forever if we wait for "another iteration"). If addTestEvent is called after all the other    * calls of interest, it is guaranteed that the events from those calls will be processed    * fully when the future is triggered.    */
name|Future
argument_list|<
name|Boolean
argument_list|>
name|addTestEvent
parameter_list|()
block|{
name|SettableFuture
argument_list|<
name|Boolean
argument_list|>
name|testEvent
init|=
name|SettableFuture
operator|.
name|create
argument_list|()
decl_stmt|;
name|currentLock
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
name|current
operator|.
name|testEvent
operator|=
name|testEvent
expr_stmt|;
name|notifyWmThreadUnderLock
argument_list|()
expr_stmt|;
block|}
finally|finally
block|{
name|currentLock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
return|return
name|testEvent
return|;
block|}
specifier|public
name|void
name|notifyInitializationCompleted
parameter_list|(
name|SessionInitContext
name|initCtx
parameter_list|)
block|{
name|currentLock
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
name|current
operator|.
name|initResults
operator|.
name|add
argument_list|(
name|initCtx
argument_list|)
expr_stmt|;
name|notifyWmThreadUnderLock
argument_list|()
expr_stmt|;
block|}
finally|finally
block|{
name|currentLock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|TezSessionState
name|reopen
parameter_list|(
name|TezSessionState
name|session
parameter_list|,
name|Configuration
name|conf
parameter_list|,
name|String
index|[]
name|additionalFiles
parameter_list|)
throws|throws
name|Exception
block|{
name|WmTezSession
name|wmTezSession
init|=
name|ensureOwnedSession
argument_list|(
name|session
argument_list|)
decl_stmt|;
name|HiveConf
name|sessionConf
init|=
name|wmTezSession
operator|.
name|getConf
argument_list|()
decl_stmt|;
if|if
condition|(
name|sessionConf
operator|==
literal|null
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Session configuration is null for "
operator|+
name|wmTezSession
argument_list|)
expr_stmt|;
name|sessionConf
operator|=
operator|new
name|HiveConf
argument_list|(
name|conf
argument_list|,
name|WorkloadManager
operator|.
name|class
argument_list|)
expr_stmt|;
block|}
comment|// TODO: ideally, we should handle reopen the same way no matter what. However, the cases
comment|//       with additional files will have to wait until HIVE-17827 is unfucked, because it's
comment|//       difficult to determine how the additionalFiles are to be propagated/reused between
comment|//       two sessions. Once the update logic is encapsulated in the session we can remove this.
if|if
condition|(
name|additionalFiles
operator|!=
literal|null
operator|&&
name|additionalFiles
operator|.
name|length
operator|>
literal|0
condition|)
block|{
name|TezSessionPoolManager
operator|.
name|reopenInternal
argument_list|(
name|session
argument_list|,
name|additionalFiles
argument_list|)
expr_stmt|;
return|return
name|session
return|;
block|}
name|SettableFuture
argument_list|<
name|WmTezSession
argument_list|>
name|future
init|=
name|SettableFuture
operator|.
name|create
argument_list|()
decl_stmt|;
name|currentLock
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
if|if
condition|(
name|current
operator|.
name|toReopen
operator|.
name|containsKey
argument_list|(
name|wmTezSession
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|AssertionError
argument_list|(
literal|"The session is being reopened more than once "
operator|+
name|session
argument_list|)
throw|;
block|}
name|current
operator|.
name|toReopen
operator|.
name|put
argument_list|(
name|wmTezSession
argument_list|,
name|future
argument_list|)
expr_stmt|;
name|notifyWmThreadUnderLock
argument_list|()
expr_stmt|;
block|}
finally|finally
block|{
name|currentLock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
return|return
name|future
operator|.
name|get
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|closeAndReopenExpiredSession
parameter_list|(
name|TezSessionPoolSession
name|session
parameter_list|)
throws|throws
name|Exception
block|{
comment|// By definition, this session is not in use and can no longer be in use, so it only
comment|// affects the session pool. We can handle this inline.
name|tezAmPool
operator|.
name|replaceSession
argument_list|(
name|ensureOwnedSession
argument_list|(
name|session
argument_list|)
argument_list|,
literal|false
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
comment|// ======= VARIOUS UTILITY METHOD
specifier|private
name|void
name|notifyWmThreadUnderLock
parameter_list|()
block|{
if|if
condition|(
name|hasChanges
condition|)
return|return;
name|hasChanges
operator|=
literal|true
expr_stmt|;
name|hasChangesCondition
operator|.
name|signalAll
argument_list|()
expr_stmt|;
block|}
specifier|private
name|WmTezSession
name|checkSessionForReuse
parameter_list|(
name|TezSessionState
name|session
parameter_list|)
throws|throws
name|Exception
block|{
if|if
condition|(
name|session
operator|==
literal|null
condition|)
return|return
literal|null
return|;
name|WmTezSession
name|result
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|session
operator|instanceof
name|WmTezSession
condition|)
block|{
name|result
operator|=
operator|(
name|WmTezSession
operator|)
name|session
expr_stmt|;
if|if
condition|(
name|result
operator|.
name|isOwnedBy
argument_list|(
name|this
argument_list|)
condition|)
block|{
return|return
name|result
return|;
block|}
comment|// This should never happen, at least for now. Throw?
name|LOG
operator|.
name|warn
argument_list|(
literal|"Attempting to reuse a session not belonging to us: "
operator|+
name|result
argument_list|)
expr_stmt|;
name|result
operator|.
name|returnToSessionManager
argument_list|()
expr_stmt|;
return|return
literal|null
return|;
block|}
name|LOG
operator|.
name|warn
argument_list|(
literal|"Attempting to reuse a non-WM session for workload management:"
operator|+
name|session
argument_list|)
expr_stmt|;
if|if
condition|(
name|session
operator|instanceof
name|TezSessionPoolSession
condition|)
block|{
name|session
operator|.
name|returnToSessionManager
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|session
operator|.
name|close
argument_list|(
literal|false
argument_list|)
expr_stmt|;
comment|// This is a non-pool session, get rid of it.
block|}
return|return
literal|null
return|;
block|}
specifier|private
name|void
name|validateConfig
parameter_list|(
name|HiveConf
name|conf
parameter_list|)
throws|throws
name|HiveException
block|{
name|String
name|queueName
init|=
name|conf
operator|.
name|get
argument_list|(
name|TezConfiguration
operator|.
name|TEZ_QUEUE_NAME
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|queueName
operator|!=
literal|null
operator|)
operator|&&
operator|!
name|queueName
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Ignoring "
operator|+
name|TezConfiguration
operator|.
name|TEZ_QUEUE_NAME
operator|+
literal|"="
operator|+
name|queueName
argument_list|)
expr_stmt|;
name|conf
operator|.
name|set
argument_list|(
name|TezConfiguration
operator|.
name|TEZ_QUEUE_NAME
argument_list|,
name|yarnQueue
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|conf
operator|.
name|getBoolVar
argument_list|(
name|ConfVars
operator|.
name|HIVE_SERVER2_ENABLE_DOAS
argument_list|)
condition|)
block|{
comment|// Should this also just be ignored? Throw for now, doAs unlike queue is often set by admin.
throw|throw
operator|new
name|HiveException
argument_list|(
name|ConfVars
operator|.
name|HIVE_SERVER2_ENABLE_DOAS
operator|.
name|varname
operator|+
literal|" is not supported"
argument_list|)
throw|;
block|}
if|if
condition|(
name|restrictedConfig
operator|!=
literal|null
condition|)
block|{
name|restrictedConfig
operator|.
name|validate
argument_list|(
name|conf
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
name|WmTezSession
name|createSession
parameter_list|(
name|HiveConf
name|conf
parameter_list|)
block|{
name|WmTezSession
name|session
init|=
name|createSessionObject
argument_list|(
name|TezSessionState
operator|.
name|makeSessionId
argument_list|()
argument_list|,
name|conf
argument_list|)
decl_stmt|;
name|session
operator|.
name|setQueueName
argument_list|(
name|yarnQueue
argument_list|)
expr_stmt|;
name|session
operator|.
name|setDefault
argument_list|()
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Created new interactive session object "
operator|+
name|session
operator|.
name|getSessionId
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|session
return|;
block|}
annotation|@
name|VisibleForTesting
specifier|protected
name|WmTezSession
name|createSessionObject
parameter_list|(
name|String
name|sessionId
parameter_list|,
name|HiveConf
name|conf
parameter_list|)
block|{
name|conf
operator|=
operator|(
name|conf
operator|==
literal|null
operator|)
condition|?
operator|new
name|HiveConf
argument_list|(
name|this
operator|.
name|conf
argument_list|)
else|:
name|conf
expr_stmt|;
name|conf
operator|.
name|set
argument_list|(
name|LlapTaskSchedulerService
operator|.
name|LLAP_PLUGIN_ENDPOINT_ENABLED
argument_list|,
literal|"true"
argument_list|)
expr_stmt|;
return|return
operator|new
name|WmTezSession
argument_list|(
name|sessionId
argument_list|,
name|this
argument_list|,
name|expirationTracker
argument_list|,
name|conf
argument_list|)
return|;
block|}
specifier|private
name|WmTezSession
name|ensureOwnedSession
parameter_list|(
name|TezSessionState
name|oldSession
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|oldSession
operator|instanceof
name|WmTezSession
operator|)
operator|||
operator|!
operator|(
operator|(
name|WmTezSession
operator|)
name|oldSession
operator|)
operator|.
name|isOwnedBy
argument_list|(
name|this
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|AssertionError
argument_list|(
literal|"Not a WM session "
operator|+
name|oldSession
argument_list|)
throw|;
block|}
name|WmTezSession
name|session
init|=
operator|(
name|WmTezSession
operator|)
name|oldSession
decl_stmt|;
return|return
name|session
return|;
block|}
comment|/** Called by TezSessionPoolSession when opened. */
annotation|@
name|Override
specifier|public
name|void
name|registerOpenSession
parameter_list|(
name|TezSessionPoolSession
name|session
parameter_list|)
block|{
synchronized|synchronized
init|(
name|openSessions
init|)
block|{
name|openSessions
operator|.
name|put
argument_list|(
name|session
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
block|}
comment|/** Called by TezSessionPoolSession when closed. */
annotation|@
name|Override
specifier|public
name|void
name|unregisterOpenSession
parameter_list|(
name|TezSessionPoolSession
name|session
parameter_list|)
block|{
synchronized|synchronized
init|(
name|openSessions
init|)
block|{
name|openSessions
operator|.
name|remove
argument_list|(
name|session
argument_list|)
expr_stmt|;
block|}
name|tezAmPool
operator|.
name|notifyClosed
argument_list|(
name|session
argument_list|)
expr_stmt|;
block|}
annotation|@
name|VisibleForTesting
specifier|public
name|SessionExpirationTracker
name|getExpirationTracker
parameter_list|()
block|{
return|return
name|expirationTracker
return|;
block|}
annotation|@
name|VisibleForTesting
name|int
name|getNumSessions
parameter_list|()
block|{
return|return
name|tezAmPool
operator|.
name|getInitialSize
argument_list|()
return|;
block|}
specifier|protected
specifier|final
name|HiveConf
name|getConf
parameter_list|()
block|{
return|return
name|conf
return|;
block|}
specifier|public
name|List
argument_list|<
name|String
argument_list|>
name|getTriggerCounterNames
parameter_list|(
specifier|final
name|TezSessionState
name|session
parameter_list|)
block|{
if|if
condition|(
name|session
operator|instanceof
name|WmTezSession
condition|)
block|{
name|WmTezSession
name|wmTezSession
init|=
operator|(
name|WmTezSession
operator|)
name|session
decl_stmt|;
name|String
name|poolName
init|=
name|wmTezSession
operator|.
name|getPoolName
argument_list|()
decl_stmt|;
name|PoolState
name|poolState
init|=
name|pools
operator|.
name|get
argument_list|(
name|poolName
argument_list|)
decl_stmt|;
if|if
condition|(
name|poolState
operator|!=
literal|null
condition|)
block|{
name|List
argument_list|<
name|String
argument_list|>
name|counterNames
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|Trigger
argument_list|>
name|triggers
init|=
name|poolState
operator|.
name|getTriggers
argument_list|()
decl_stmt|;
if|if
condition|(
name|triggers
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|Trigger
name|trigger
range|:
name|triggers
control|)
block|{
name|counterNames
operator|.
name|add
argument_list|(
name|trigger
operator|.
name|getExpression
argument_list|()
operator|.
name|getCounterLimit
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|counterNames
return|;
block|}
block|}
return|return
literal|null
return|;
block|}
annotation|@
name|Override
name|Runnable
name|getTriggerValidatorRunnable
parameter_list|()
block|{
return|return
name|triggerValidatorRunnable
return|;
block|}
comment|/**    * State of a single pool.    * Unless otherwise specified, the members are only modified by the master thread.    */
specifier|private
specifier|static
class|class
name|PoolState
block|{
comment|// Add stuff here as WM is implemented.
specifier|private
specifier|final
name|LinkedList
argument_list|<
name|SessionInitContext
argument_list|>
name|initializingSessions
init|=
operator|new
name|LinkedList
argument_list|<>
argument_list|()
decl_stmt|;
comment|// Note: the list is expected to be a few items; if it's longer we may want an IHM.
specifier|private
specifier|final
name|LinkedList
argument_list|<
name|WmTezSession
argument_list|>
name|sessions
init|=
operator|new
name|LinkedList
argument_list|<>
argument_list|()
decl_stmt|;
specifier|private
specifier|final
name|LinkedList
argument_list|<
name|GetRequest
argument_list|>
name|queue
init|=
operator|new
name|LinkedList
argument_list|<>
argument_list|()
decl_stmt|;
specifier|private
specifier|final
name|String
name|fullName
decl_stmt|;
specifier|private
name|double
name|finalFraction
decl_stmt|;
specifier|private
name|double
name|finalFractionRemaining
decl_stmt|;
specifier|private
name|int
name|queryParallelism
init|=
operator|-
literal|1
decl_stmt|;
specifier|private
name|List
argument_list|<
name|Trigger
argument_list|>
name|triggers
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
specifier|public
name|PoolState
parameter_list|(
name|String
name|fullName
parameter_list|,
name|int
name|queryParallelism
parameter_list|,
name|double
name|fraction
parameter_list|)
block|{
name|this
operator|.
name|fullName
operator|=
name|fullName
expr_stmt|;
name|update
argument_list|(
name|queryParallelism
argument_list|,
name|fraction
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
specifier|public
name|int
name|getTotalActiveSessions
parameter_list|()
block|{
return|return
name|sessions
operator|.
name|size
argument_list|()
operator|+
name|initializingSessions
operator|.
name|size
argument_list|()
return|;
block|}
specifier|public
name|void
name|update
parameter_list|(
name|int
name|queryParallelism
parameter_list|,
name|double
name|fraction
parameter_list|,
name|Map
argument_list|<
name|WmTezSession
argument_list|,
name|KillQueryContext
argument_list|>
name|toKill
parameter_list|,
name|EventState
name|e
parameter_list|)
block|{
name|this
operator|.
name|finalFraction
operator|=
name|this
operator|.
name|finalFractionRemaining
operator|=
name|fraction
expr_stmt|;
name|this
operator|.
name|queryParallelism
operator|=
name|queryParallelism
expr_stmt|;
comment|// TODO: two possible improvements
comment|//       1) Right now we kill all the queries here; we could just kill -qpDelta.
comment|//       2) After the queries are killed queued queries would take their place.
comment|//          If we could somehow restart queries we could instead put them at the front
comment|//          of the queue (esp. in conjunction with (1)) and rerun them.
if|if
condition|(
name|queryParallelism
operator|<
name|getTotalActiveSessions
argument_list|()
condition|)
block|{
name|extractAllSessionsToKill
argument_list|(
literal|"The query pool was resized by administrator"
argument_list|,
name|e
operator|.
name|toReuse
argument_list|,
name|toKill
argument_list|)
expr_stmt|;
block|}
comment|// We will requeue, and not kill, the queries that are not running yet.
comment|// Insert them all before the get requests from this iteration.
name|GetRequest
name|req
decl_stmt|;
while|while
condition|(
operator|(
name|req
operator|=
name|queue
operator|.
name|pollLast
argument_list|()
operator|)
operator|!=
literal|null
condition|)
block|{
name|e
operator|.
name|getRequests
operator|.
name|addFirst
argument_list|(
name|req
argument_list|)
expr_stmt|;
block|}
block|}
specifier|public
name|void
name|destroy
parameter_list|(
name|Map
argument_list|<
name|WmTezSession
argument_list|,
name|KillQueryContext
argument_list|>
name|toKill
parameter_list|,
name|LinkedList
argument_list|<
name|GetRequest
argument_list|>
name|globalQueue
parameter_list|,
name|IdentityHashMap
argument_list|<
name|WmTezSession
argument_list|,
name|GetRequest
argument_list|>
name|toReuse
parameter_list|)
block|{
name|extractAllSessionsToKill
argument_list|(
literal|"The query pool was removed by administrator"
argument_list|,
name|toReuse
argument_list|,
name|toKill
argument_list|)
expr_stmt|;
comment|// All the pending get requests should just be requeued elsewhere.
comment|// Note that we never queue session reuse so sessionToReuse would be null.
name|globalQueue
operator|.
name|addAll
argument_list|(
literal|0
argument_list|,
name|queue
argument_list|)
expr_stmt|;
name|queue
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
specifier|public
name|double
name|updateAllocationPercentages
parameter_list|()
block|{
comment|// TODO: real implementation involving in-the-pool policy interface, etc.
name|double
name|allocation
init|=
name|finalFractionRemaining
operator|/
operator|(
name|sessions
operator|.
name|size
argument_list|()
operator|+
name|initializingSessions
operator|.
name|size
argument_list|()
operator|)
decl_stmt|;
for|for
control|(
name|WmTezSession
name|session
range|:
name|sessions
control|)
block|{
name|session
operator|.
name|setClusterFraction
argument_list|(
name|allocation
argument_list|)
expr_stmt|;
block|}
comment|// Do not give out the capacity of the initializing sessions to the running ones;
comment|// we expect init to be fast.
return|return
name|finalFractionRemaining
operator|-
name|allocation
operator|*
name|initializingSessions
operator|.
name|size
argument_list|()
return|;
block|}
specifier|public
name|LinkedList
argument_list|<
name|WmTezSession
argument_list|>
name|getSessions
parameter_list|()
block|{
return|return
name|sessions
return|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
literal|"["
operator|+
name|fullName
operator|+
literal|", query parallelism "
operator|+
name|queryParallelism
operator|+
literal|", fraction of the cluster "
operator|+
name|finalFraction
operator|+
literal|", fraction used by child pools "
operator|+
operator|(
name|finalFraction
operator|-
name|finalFractionRemaining
operator|)
operator|+
literal|", active sessions "
operator|+
name|sessions
operator|.
name|size
argument_list|()
operator|+
literal|", initializing sessions "
operator|+
name|initializingSessions
operator|.
name|size
argument_list|()
operator|+
literal|"]"
return|;
block|}
specifier|private
name|void
name|extractAllSessionsToKill
parameter_list|(
name|String
name|killReason
parameter_list|,
name|IdentityHashMap
argument_list|<
name|WmTezSession
argument_list|,
name|GetRequest
argument_list|>
name|toReuse
parameter_list|,
name|Map
argument_list|<
name|WmTezSession
argument_list|,
name|KillQueryContext
argument_list|>
name|toKill
parameter_list|)
block|{
for|for
control|(
name|WmTezSession
name|sessionToKill
range|:
name|sessions
control|)
block|{
name|resetRemovedSessionToKill
argument_list|(
name|sessionToKill
argument_list|,
name|toReuse
argument_list|)
expr_stmt|;
name|toKill
operator|.
name|put
argument_list|(
name|sessionToKill
argument_list|,
operator|new
name|KillQueryContext
argument_list|(
name|sessionToKill
argument_list|,
name|killReason
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|sessions
operator|.
name|clear
argument_list|()
expr_stmt|;
for|for
control|(
name|SessionInitContext
name|initCtx
range|:
name|initializingSessions
control|)
block|{
comment|// It is possible that the background init thread has finished in parallel, queued
comment|// the message for us but also returned the session to the user.
name|WmTezSession
name|sessionToKill
init|=
name|initCtx
operator|.
name|cancelAndExtractSessionIfDone
argument_list|(
name|killReason
argument_list|)
decl_stmt|;
if|if
condition|(
name|sessionToKill
operator|==
literal|null
condition|)
block|{
continue|continue;
comment|// Async op in progress; the callback will take care of this.
block|}
name|resetRemovedSessionToKill
argument_list|(
name|sessionToKill
argument_list|,
name|toReuse
argument_list|)
expr_stmt|;
name|toKill
operator|.
name|put
argument_list|(
name|sessionToKill
argument_list|,
operator|new
name|KillQueryContext
argument_list|(
name|sessionToKill
argument_list|,
name|killReason
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|initializingSessions
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
specifier|public
name|void
name|setTriggers
parameter_list|(
specifier|final
name|LinkedList
argument_list|<
name|Trigger
argument_list|>
name|triggers
parameter_list|)
block|{
name|this
operator|.
name|triggers
operator|=
name|triggers
expr_stmt|;
block|}
specifier|public
name|List
argument_list|<
name|Trigger
argument_list|>
name|getTriggers
parameter_list|()
block|{
return|return
name|triggers
return|;
block|}
block|}
specifier|private
enum|enum
name|SessionInitState
block|{
name|GETTING
block|,
comment|// We are getting a session from TezSessionPool
name|WAITING_FOR_REGISTRY
block|,
comment|// We have the session but it doesn't have registry info yet.
name|DONE
block|,
comment|// We have the session with registry info, or we have failed.
name|CANCELED
comment|// The master thread has CANCELED this and will never look at it again.
block|}
comment|/**    * The class that serves as a synchronization point, and future callback,    * for async session initialization, as well as parallel cancellation.    */
specifier|private
specifier|final
class|class
name|SessionInitContext
implements|implements
name|FutureCallback
argument_list|<
name|WmTezSession
argument_list|>
block|{
specifier|private
specifier|final
name|String
name|poolName
decl_stmt|,
name|queryId
decl_stmt|;
specifier|private
specifier|final
name|ReentrantLock
name|lock
init|=
operator|new
name|ReentrantLock
argument_list|()
decl_stmt|;
specifier|private
name|WmTezSession
name|session
decl_stmt|;
specifier|private
name|SettableFuture
argument_list|<
name|WmTezSession
argument_list|>
name|future
decl_stmt|;
specifier|private
name|SessionInitState
name|state
decl_stmt|;
specifier|private
name|String
name|cancelReason
decl_stmt|;
specifier|public
name|SessionInitContext
parameter_list|(
name|SettableFuture
argument_list|<
name|WmTezSession
argument_list|>
name|future
parameter_list|,
name|String
name|poolName
parameter_list|,
name|String
name|queryId
parameter_list|)
block|{
name|this
operator|.
name|state
operator|=
name|SessionInitState
operator|.
name|GETTING
expr_stmt|;
name|this
operator|.
name|future
operator|=
name|future
expr_stmt|;
name|this
operator|.
name|poolName
operator|=
name|poolName
expr_stmt|;
name|this
operator|.
name|queryId
operator|=
name|queryId
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|onSuccess
parameter_list|(
name|WmTezSession
name|session
parameter_list|)
block|{
name|SessionInitState
name|oldState
decl_stmt|;
name|SettableFuture
argument_list|<
name|WmTezSession
argument_list|>
name|future
init|=
literal|null
decl_stmt|;
name|lock
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
name|oldState
operator|=
name|state
expr_stmt|;
switch|switch
condition|(
name|oldState
condition|)
block|{
case|case
name|GETTING
case|:
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Received a session from AM pool {}"
argument_list|,
name|session
argument_list|)
expr_stmt|;
assert|assert
name|this
operator|.
name|state
operator|==
name|SessionInitState
operator|.
name|GETTING
assert|;
name|session
operator|.
name|setPoolName
argument_list|(
name|poolName
argument_list|)
expr_stmt|;
name|session
operator|.
name|setQueueName
argument_list|(
name|yarnQueue
argument_list|)
expr_stmt|;
name|session
operator|.
name|setQueryId
argument_list|(
name|queryId
argument_list|)
expr_stmt|;
name|this
operator|.
name|session
operator|=
name|session
expr_stmt|;
name|this
operator|.
name|state
operator|=
name|SessionInitState
operator|.
name|WAITING_FOR_REGISTRY
expr_stmt|;
break|break;
block|}
case|case
name|WAITING_FOR_REGISTRY
case|:
block|{
assert|assert
name|this
operator|.
name|session
operator|!=
literal|null
assert|;
name|this
operator|.
name|state
operator|=
name|SessionInitState
operator|.
name|DONE
expr_stmt|;
assert|assert
name|session
operator|==
name|this
operator|.
name|session
assert|;
name|future
operator|=
name|this
operator|.
name|future
expr_stmt|;
name|this
operator|.
name|future
operator|=
literal|null
expr_stmt|;
break|break;
block|}
case|case
name|CANCELED
case|:
block|{
name|future
operator|=
name|this
operator|.
name|future
expr_stmt|;
name|this
operator|.
name|session
operator|=
literal|null
expr_stmt|;
name|this
operator|.
name|future
operator|=
literal|null
expr_stmt|;
break|break;
block|}
default|default:
block|{
name|future
operator|=
name|this
operator|.
name|future
expr_stmt|;
name|this
operator|.
name|future
operator|=
literal|null
expr_stmt|;
break|break;
block|}
block|}
block|}
finally|finally
block|{
name|lock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
switch|switch
condition|(
name|oldState
condition|)
block|{
case|case
name|GETTING
case|:
block|{
name|ListenableFuture
argument_list|<
name|WmTezSession
argument_list|>
name|waitFuture
init|=
name|session
operator|.
name|waitForAmRegistryAsync
argument_list|(
name|amRegistryTimeoutMs
argument_list|,
name|timeoutPool
argument_list|)
decl_stmt|;
name|Futures
operator|.
name|addCallback
argument_list|(
name|waitFuture
argument_list|,
name|this
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|WAITING_FOR_REGISTRY
case|:
block|{
comment|// Notify the master thread and the user.
name|future
operator|.
name|set
argument_list|(
name|session
argument_list|)
expr_stmt|;
name|notifyInitializationCompleted
argument_list|(
name|this
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|CANCELED
case|:
block|{
comment|// Return session to the pool; we can do it directly here.
name|future
operator|.
name|setException
argument_list|(
operator|new
name|HiveException
argument_list|(
literal|"The query was killed by workload management: "
operator|+
name|cancelReason
argument_list|)
argument_list|)
expr_stmt|;
name|session
operator|.
name|setPoolName
argument_list|(
literal|null
argument_list|)
expr_stmt|;
name|session
operator|.
name|setClusterFraction
argument_list|(
literal|0f
argument_list|)
expr_stmt|;
name|session
operator|.
name|setQueryId
argument_list|(
literal|null
argument_list|)
expr_stmt|;
name|tezAmPool
operator|.
name|returnSession
argument_list|(
name|session
argument_list|)
expr_stmt|;
break|break;
block|}
default|default:
block|{
name|AssertionError
name|error
init|=
operator|new
name|AssertionError
argument_list|(
literal|"Unexpected state "
operator|+
name|state
argument_list|)
decl_stmt|;
name|future
operator|.
name|setException
argument_list|(
name|error
argument_list|)
expr_stmt|;
throw|throw
name|error
throw|;
block|}
block|}
block|}
annotation|@
name|Override
specifier|public
name|void
name|onFailure
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{
name|SettableFuture
argument_list|<
name|WmTezSession
argument_list|>
name|future
decl_stmt|;
name|WmTezSession
name|session
decl_stmt|;
name|boolean
name|wasCanceled
init|=
literal|false
decl_stmt|;
name|lock
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
name|wasCanceled
operator|=
operator|(
name|state
operator|==
name|SessionInitState
operator|.
name|CANCELED
operator|)
expr_stmt|;
name|session
operator|=
name|this
operator|.
name|session
expr_stmt|;
name|future
operator|=
name|this
operator|.
name|future
expr_stmt|;
name|this
operator|.
name|future
operator|=
literal|null
expr_stmt|;
name|this
operator|.
name|session
operator|=
literal|null
expr_stmt|;
if|if
condition|(
operator|!
name|wasCanceled
condition|)
block|{
name|this
operator|.
name|state
operator|=
name|SessionInitState
operator|.
name|DONE
expr_stmt|;
block|}
block|}
finally|finally
block|{
name|lock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
name|future
operator|.
name|setException
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|wasCanceled
condition|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Queueing the initialization failure with "
operator|+
name|session
argument_list|)
expr_stmt|;
block|}
name|notifyInitializationCompleted
argument_list|(
name|this
argument_list|)
expr_stmt|;
comment|// Report failure to the main thread.
block|}
if|if
condition|(
name|session
operator|!=
literal|null
condition|)
block|{
name|session
operator|.
name|clearWm
argument_list|()
expr_stmt|;
name|session
operator|.
name|setQueryId
argument_list|(
literal|null
argument_list|)
expr_stmt|;
comment|// We can just restart the session if we have received one.
try|try
block|{
name|tezAmPool
operator|.
name|replaceSession
argument_list|(
name|session
argument_list|,
literal|false
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Failed to restart a failed session"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/** Cancel the async operation (even if it's done), and return the session if done. */
specifier|public
name|WmTezSession
name|cancelAndExtractSessionIfDone
parameter_list|(
name|String
name|cancelReason
parameter_list|)
block|{
name|lock
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
name|SessionInitState
name|state
init|=
name|this
operator|.
name|state
decl_stmt|;
name|this
operator|.
name|state
operator|=
name|SessionInitState
operator|.
name|CANCELED
expr_stmt|;
name|this
operator|.
name|cancelReason
operator|=
name|cancelReason
expr_stmt|;
if|if
condition|(
name|state
operator|==
name|SessionInitState
operator|.
name|DONE
condition|)
block|{
name|WmTezSession
name|result
init|=
name|this
operator|.
name|session
decl_stmt|;
name|this
operator|.
name|session
operator|=
literal|null
expr_stmt|;
return|return
name|result
return|;
block|}
else|else
block|{
comment|// In the states where a background operation is in progress, wait for the callback.
comment|// Also, ignore any duplicate calls; also don't kill failed ones - handled elsewhere.
if|if
condition|(
name|state
operator|==
name|SessionInitState
operator|.
name|CANCELED
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Duplicate call to extract "
operator|+
name|session
argument_list|)
expr_stmt|;
block|}
return|return
literal|null
return|;
block|}
block|}
finally|finally
block|{
name|lock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|/** Extracts the session and cancel the operation, both only if done. */
specifier|public
name|boolean
name|extractSessionAndCancelIfDone
parameter_list|(
name|List
argument_list|<
name|WmTezSession
argument_list|>
name|results
parameter_list|)
block|{
name|lock
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
if|if
condition|(
name|state
operator|!=
name|SessionInitState
operator|.
name|DONE
condition|)
return|return
literal|false
return|;
name|this
operator|.
name|state
operator|=
name|SessionInitState
operator|.
name|CANCELED
expr_stmt|;
if|if
condition|(
name|this
operator|.
name|session
operator|!=
literal|null
condition|)
block|{
name|results
operator|.
name|add
argument_list|(
name|this
operator|.
name|session
argument_list|)
expr_stmt|;
block|}
comment|// Otherwise we have failed; the callback has taken care of the failure.
name|this
operator|.
name|session
operator|=
literal|null
expr_stmt|;
return|return
literal|true
return|;
block|}
finally|finally
block|{
name|lock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
literal|"[state="
operator|+
name|state
operator|+
literal|", session="
operator|+
name|session
operator|+
literal|"]"
return|;
block|}
block|}
name|boolean
name|isManaged
parameter_list|(
name|MappingInput
name|input
parameter_list|)
block|{
comment|// This is always replaced atomically, so we don't care about concurrency here.
return|return
name|userPoolMapping
operator|.
name|mapSessionToPoolName
argument_list|(
name|input
argument_list|)
operator|!=
literal|null
return|;
block|}
specifier|private
specifier|static
enum|enum
name|KillQueryResult
block|{
name|OK
block|,
name|RESTART_REQUIRED
block|,
name|IN_PROGRESS
block|}
comment|/**    * When we kill a query without killing a session, we need two things to come back before reuse.    * First of all, kill query itself should come back, and second the user should handle it    * and let go of the session (or, the query could finish and it could give the session back    * even before we try to kill the query). We also need to handle cases where the user doesn't    * like the session even before we kill it, or the kill fails and the user is happily computing    * away. This class is to collect and make sense of the state around all this.    */
specifier|private
specifier|static
specifier|final
class|class
name|KillQueryContext
block|{
specifier|private
specifier|final
name|String
name|reason
decl_stmt|;
specifier|private
specifier|final
name|WmTezSession
name|session
decl_stmt|;
comment|// Note: all the fields are only modified by master thread.
specifier|private
name|boolean
name|isUserDone
init|=
literal|false
decl_stmt|,
name|isKillDone
init|=
literal|false
decl_stmt|,
name|hasKillFailed
init|=
literal|false
decl_stmt|,
name|hasUserFailed
init|=
literal|false
decl_stmt|;
specifier|public
name|KillQueryContext
parameter_list|(
name|WmTezSession
name|session
parameter_list|,
name|String
name|reason
parameter_list|)
block|{
name|this
operator|.
name|session
operator|=
name|session
expr_stmt|;
name|this
operator|.
name|reason
operator|=
name|reason
expr_stmt|;
block|}
specifier|private
name|void
name|handleKillQueryCallback
parameter_list|(
name|boolean
name|hasFailed
parameter_list|)
block|{
name|isKillDone
operator|=
literal|true
expr_stmt|;
name|hasKillFailed
operator|=
name|hasFailed
expr_stmt|;
block|}
specifier|private
name|void
name|handleUserCallback
parameter_list|(
name|boolean
name|hasFailed
parameter_list|)
block|{
if|if
condition|(
name|isUserDone
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Duplicate user call for a session being killed; ignoring"
argument_list|)
expr_stmt|;
return|return;
block|}
name|isUserDone
operator|=
literal|true
expr_stmt|;
name|hasUserFailed
operator|=
name|hasFailed
expr_stmt|;
block|}
specifier|private
name|KillQueryResult
name|process
parameter_list|()
block|{
if|if
condition|(
operator|!
name|isUserDone
operator|&&
name|hasKillFailed
condition|)
block|{
comment|// The user has not returned and the kill has failed.
comment|// We are going to brute force kill the AM; whatever user does is now irrelevant.
name|session
operator|.
name|setIsIrrelevantForWm
argument_list|(
name|reason
argument_list|)
expr_stmt|;
return|return
name|KillQueryResult
operator|.
name|RESTART_REQUIRED
return|;
block|}
if|if
condition|(
operator|!
name|isUserDone
operator|||
operator|!
name|isKillDone
condition|)
return|return
name|KillQueryResult
operator|.
name|IN_PROGRESS
return|;
comment|// Someone is not done.
comment|// Both user and the kill have returned.
if|if
condition|(
name|hasUserFailed
operator|&&
name|hasKillFailed
condition|)
block|{
comment|// If the kill failed and the user also thinks the session is invalid, restart it.
name|session
operator|.
name|setIsIrrelevantForWm
argument_list|(
name|reason
argument_list|)
expr_stmt|;
return|return
name|KillQueryResult
operator|.
name|RESTART_REQUIRED
return|;
block|}
comment|// Otherwise, we can reuse the session. Either the kill has failed but the user managed to
comment|// return early (in fact, can it fail because the query has completed earlier?), or the user
comment|// has failed because the query was killed from under it.
return|return
name|KillQueryResult
operator|.
name|OK
return|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
literal|"KillQueryContext [isUserDone="
operator|+
name|isUserDone
operator|+
literal|", isKillDone="
operator|+
name|isKillDone
operator|+
literal|", hasKillFailed="
operator|+
name|hasKillFailed
operator|+
literal|", hasUserFailed="
operator|+
name|hasUserFailed
operator|+
literal|", session="
operator|+
name|session
operator|+
literal|", reason="
operator|+
name|reason
operator|+
literal|"]"
return|;
block|}
block|}
specifier|private
specifier|static
name|void
name|resetRemovedSessionToKill
parameter_list|(
name|WmTezSession
name|sessionToKill
parameter_list|,
name|Map
argument_list|<
name|WmTezSession
argument_list|,
name|GetRequest
argument_list|>
name|toReuse
parameter_list|)
block|{
name|sessionToKill
operator|.
name|clearWm
argument_list|()
expr_stmt|;
name|GetRequest
name|req
init|=
name|toReuse
operator|.
name|remove
argument_list|(
name|sessionToKill
argument_list|)
decl_stmt|;
if|if
condition|(
name|req
operator|!=
literal|null
condition|)
block|{
name|req
operator|.
name|sessionToReuse
operator|=
literal|null
expr_stmt|;
block|}
block|}
annotation|@
name|VisibleForTesting
name|TezSessionPool
argument_list|<
name|WmTezSession
argument_list|>
name|getTezAmPool
parameter_list|()
block|{
return|return
name|tezAmPool
return|;
block|}
specifier|public
specifier|final
specifier|static
class|class
name|NoPoolMappingException
extends|extends
name|Exception
block|{
specifier|public
name|NoPoolMappingException
parameter_list|(
name|String
name|message
parameter_list|)
block|{
name|super
argument_list|(
name|message
argument_list|)
expr_stmt|;
block|}
specifier|private
specifier|static
specifier|final
name|long
name|serialVersionUID
init|=
literal|346375346724L
decl_stmt|;
block|}
block|}
end_class

end_unit

