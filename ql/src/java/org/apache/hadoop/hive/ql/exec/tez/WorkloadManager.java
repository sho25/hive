begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|tez
package|;
end_package

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|exec
operator|.
name|tez
operator|.
name|UserPoolMapping
operator|.
name|MappingInput
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|wm
operator|.
name|ExpressionFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|wm
operator|.
name|Trigger
operator|.
name|Action
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|wm
operator|.
name|ExecutionTrigger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|metastore
operator|.
name|api
operator|.
name|WMPoolTrigger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|metastore
operator|.
name|api
operator|.
name|WMTrigger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|lang3
operator|.
name|StringUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|metastore
operator|.
name|api
operator|.
name|WMPool
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|metastore
operator|.
name|api
operator|.
name|WMFullResourcePlan
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|session
operator|.
name|SessionState
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|VisibleForTesting
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Sets
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|util
operator|.
name|concurrent
operator|.
name|FutureCallback
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|util
operator|.
name|concurrent
operator|.
name|Futures
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ListenableFuture
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|util
operator|.
name|concurrent
operator|.
name|SettableFuture
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Comparator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|IdentityHashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|LinkedList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ExecutorService
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|Executors
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|Future
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ScheduledExecutorService
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ThreadFactory
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|TimeUnit
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicInteger
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicLong
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|locks
operator|.
name|Condition
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|locks
operator|.
name|ReentrantLock
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|conf
operator|.
name|HiveConf
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|conf
operator|.
name|HiveConf
operator|.
name|ConfVars
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|metadata
operator|.
name|HiveException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|wm
operator|.
name|SessionTriggerProvider
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|wm
operator|.
name|Trigger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hive
operator|.
name|ql
operator|.
name|wm
operator|.
name|TriggerActionHandler
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|tez
operator|.
name|dag
operator|.
name|api
operator|.
name|TezConfiguration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_comment
comment|/** Workload management entry point for HS2. */
end_comment

begin_class
specifier|public
class|class
name|WorkloadManager
extends|extends
name|TezSessionPoolSession
operator|.
name|AbstractTriggerValidator
implements|implements
name|TezSessionPoolSession
operator|.
name|Manager
implements|,
name|SessionExpirationTracker
operator|.
name|RestartImpl
block|{
specifier|private
specifier|static
specifier|final
name|Logger
name|LOG
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|WorkloadManager
operator|.
name|class
argument_list|)
decl_stmt|;
comment|// TODO: this is a temporary setting that will go away, so it's not in HiveConf.
specifier|public
specifier|static
specifier|final
name|String
name|TEST_WM_CONFIG
init|=
literal|"hive.test.workload.management"
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|char
name|POOL_SEPARATOR
init|=
literal|'.'
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|String
name|POOL_SEPARATOR_STR
init|=
literal|""
operator|+
name|POOL_SEPARATOR
decl_stmt|;
specifier|private
specifier|final
name|HiveConf
name|conf
decl_stmt|;
specifier|private
specifier|final
name|TezSessionPool
argument_list|<
name|WmTezSession
argument_list|>
name|tezAmPool
decl_stmt|;
specifier|private
specifier|final
name|SessionExpirationTracker
name|expirationTracker
decl_stmt|;
specifier|private
specifier|final
name|RestrictedConfigChecker
name|restrictedConfig
decl_stmt|;
specifier|private
specifier|final
name|QueryAllocationManager
name|allocationManager
decl_stmt|;
specifier|private
specifier|final
name|String
name|yarnQueue
decl_stmt|;
comment|// Note: it's not clear that we need to track this - unlike PoolManager we don't have non-pool
comment|//       sessions, so the pool itself could internally track the sessions it gave out, since
comment|//       calling close on an unopened session is probably harmless.
specifier|private
specifier|final
name|IdentityHashMap
argument_list|<
name|TezSessionPoolSession
argument_list|,
name|Boolean
argument_list|>
name|openSessions
init|=
operator|new
name|IdentityHashMap
argument_list|<>
argument_list|()
decl_stmt|;
specifier|private
specifier|final
name|int
name|amRegistryTimeoutMs
decl_stmt|;
comment|// Note: pools can only be modified by the master thread.
specifier|private
name|HashMap
argument_list|<
name|String
argument_list|,
name|PoolState
argument_list|>
name|pools
decl_stmt|;
comment|// Used to make sure that waiting getSessions don't block update.
specifier|private
name|UserPoolMapping
name|userPoolMapping
decl_stmt|;
specifier|private
name|int
name|totalQueryParallelism
decl_stmt|;
comment|// We index the get requests to make sure there are no ordering artifacts when we requeue.
specifier|private
specifier|final
name|AtomicLong
name|getRequestVersion
init|=
operator|new
name|AtomicLong
argument_list|(
name|Long
operator|.
name|MIN_VALUE
argument_list|)
decl_stmt|;
specifier|private
name|SessionTriggerProvider
name|sessionTriggerProvider
decl_stmt|;
specifier|private
name|TriggerActionHandler
name|triggerActionHandler
decl_stmt|;
specifier|private
name|TriggerValidatorRunnable
name|triggerValidatorRunnable
decl_stmt|;
comment|// Note: we could use RW lock to allow concurrent calls for different sessions, however all
comment|//       those calls do is add elements to lists and maps; and we'd need to sync those separately
comment|//       separately, plus have an object to notify because RW lock does not support conditions
comment|//       in any sensible way. So, for now the lock is going to be epic.
specifier|private
specifier|final
name|ReentrantLock
name|currentLock
init|=
operator|new
name|ReentrantLock
argument_list|()
decl_stmt|;
specifier|private
specifier|final
name|Condition
name|hasChangesCondition
init|=
name|currentLock
operator|.
name|newCondition
argument_list|()
decl_stmt|;
comment|// The processing thread will switch between these two objects.
specifier|private
specifier|final
name|EventState
name|one
init|=
operator|new
name|EventState
argument_list|()
decl_stmt|,
name|two
init|=
operator|new
name|EventState
argument_list|()
decl_stmt|;
specifier|private
name|boolean
name|hasChanges
init|=
literal|false
decl_stmt|;
specifier|private
name|EventState
name|current
init|=
name|one
decl_stmt|;
comment|/** The master thread the processes the events from EventState. */
annotation|@
name|VisibleForTesting
specifier|protected
specifier|final
name|Thread
name|wmThread
decl_stmt|;
comment|/** Used by the master thread to offload calls blocking on smth other than fast locks. */
specifier|private
specifier|final
name|ExecutorService
name|workPool
decl_stmt|;
comment|/** Used to schedule timeouts for some async operations. */
specifier|private
specifier|final
name|ScheduledExecutorService
name|timeoutPool
decl_stmt|;
specifier|private
specifier|final
name|WmThreadSyncWork
name|syncWork
init|=
operator|new
name|WmThreadSyncWork
argument_list|()
decl_stmt|;
specifier|private
name|ListenableFuture
argument_list|<
name|Boolean
argument_list|>
name|initRpFuture
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|FutureCallback
argument_list|<
name|Object
argument_list|>
name|FATAL_ERROR_CALLBACK
init|=
operator|new
name|FutureCallback
argument_list|<
name|Object
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|void
name|onSuccess
parameter_list|(
name|Object
name|result
parameter_list|)
block|{     }
annotation|@
name|Override
specifier|public
name|void
name|onFailure
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{
comment|// TODO: shut down HS2?
name|LOG
operator|.
name|error
argument_list|(
literal|"Workload management fatal error"
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
block|}
decl_stmt|;
comment|// TODO: this is temporary before HiveServerEnvironment is merged.
specifier|private
specifier|static
specifier|volatile
name|WorkloadManager
name|INSTANCE
decl_stmt|;
specifier|public
specifier|static
name|WorkloadManager
name|getInstance
parameter_list|()
block|{
return|return
name|INSTANCE
return|;
block|}
specifier|public
specifier|static
name|boolean
name|isInUse
parameter_list|(
name|Configuration
name|conf
parameter_list|)
block|{
return|return
name|INSTANCE
operator|!=
literal|null
operator|&&
name|conf
operator|.
name|getBoolean
argument_list|(
name|TEST_WM_CONFIG
argument_list|,
literal|false
argument_list|)
return|;
block|}
comment|/** Called once, when HS2 initializes. */
specifier|public
specifier|static
name|WorkloadManager
name|create
parameter_list|(
name|String
name|yarnQueue
parameter_list|,
name|HiveConf
name|conf
parameter_list|,
name|WMFullResourcePlan
name|plan
parameter_list|)
block|{
assert|assert
name|INSTANCE
operator|==
literal|null
assert|;
comment|// We could derive the expected number of AMs to pass in.
name|LlapPluginEndpointClient
name|amComm
init|=
operator|new
name|LlapPluginEndpointClientImpl
argument_list|(
name|conf
argument_list|,
literal|null
argument_list|,
operator|-
literal|1
argument_list|)
decl_stmt|;
name|QueryAllocationManager
name|qam
init|=
operator|new
name|GuaranteedTasksAllocator
argument_list|(
name|conf
argument_list|,
name|amComm
argument_list|)
decl_stmt|;
return|return
operator|(
name|INSTANCE
operator|=
operator|new
name|WorkloadManager
argument_list|(
name|yarnQueue
argument_list|,
name|conf
argument_list|,
name|qam
argument_list|,
name|plan
argument_list|)
operator|)
return|;
block|}
annotation|@
name|VisibleForTesting
name|WorkloadManager
parameter_list|(
name|String
name|yarnQueue
parameter_list|,
name|HiveConf
name|conf
parameter_list|,
name|QueryAllocationManager
name|qam
parameter_list|,
name|WMFullResourcePlan
name|plan
parameter_list|)
block|{
name|this
operator|.
name|yarnQueue
operator|=
name|yarnQueue
expr_stmt|;
name|this
operator|.
name|conf
operator|=
name|conf
expr_stmt|;
name|this
operator|.
name|totalQueryParallelism
operator|=
name|determineQueryParallelism
argument_list|(
name|plan
argument_list|)
expr_stmt|;
name|this
operator|.
name|initRpFuture
operator|=
name|this
operator|.
name|updateResourcePlanAsync
argument_list|(
name|plan
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Initializing with "
operator|+
name|totalQueryParallelism
operator|+
literal|" total query parallelism"
argument_list|)
expr_stmt|;
name|this
operator|.
name|amRegistryTimeoutMs
operator|=
operator|(
name|int
operator|)
name|HiveConf
operator|.
name|getTimeVar
argument_list|(
name|conf
argument_list|,
name|ConfVars
operator|.
name|HIVE_SERVER2_TEZ_WM_AM_REGISTRY_TIMEOUT
argument_list|,
name|TimeUnit
operator|.
name|MILLISECONDS
argument_list|)
expr_stmt|;
name|tezAmPool
operator|=
operator|new
name|TezSessionPool
argument_list|<>
argument_list|(
name|conf
argument_list|,
name|totalQueryParallelism
argument_list|,
literal|true
argument_list|,
operator|new
name|TezSessionPool
operator|.
name|SessionObjectFactory
argument_list|<
name|WmTezSession
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|WmTezSession
name|create
parameter_list|(
name|WmTezSession
name|oldSession
parameter_list|)
block|{
return|return
name|createSession
argument_list|(
name|oldSession
operator|==
literal|null
condition|?
literal|null
else|:
name|oldSession
operator|.
name|getConf
argument_list|()
argument_list|)
return|;
block|}
block|}
argument_list|)
expr_stmt|;
name|restrictedConfig
operator|=
operator|new
name|RestrictedConfigChecker
argument_list|(
name|conf
argument_list|)
expr_stmt|;
name|allocationManager
operator|=
name|qam
expr_stmt|;
comment|// Only creates the expiration tracker if expiration is configured.
name|expirationTracker
operator|=
name|SessionExpirationTracker
operator|.
name|create
argument_list|(
name|conf
argument_list|,
name|this
argument_list|)
expr_stmt|;
name|ThreadFactory
name|workerFactory
init|=
operator|new
name|ThreadFactory
argument_list|()
block|{
specifier|private
specifier|final
name|AtomicInteger
name|threadNumber
init|=
operator|new
name|AtomicInteger
argument_list|(
operator|-
literal|1
argument_list|)
decl_stmt|;
annotation|@
name|Override
specifier|public
name|Thread
name|newThread
parameter_list|(
name|Runnable
name|r
parameter_list|)
block|{
name|Thread
name|t
init|=
operator|new
name|Thread
argument_list|(
name|r
argument_list|,
literal|"Workload management worker "
operator|+
name|threadNumber
operator|.
name|incrementAndGet
argument_list|()
argument_list|)
decl_stmt|;
name|t
operator|.
name|setDaemon
argument_list|(
literal|true
argument_list|)
expr_stmt|;
return|return
name|t
return|;
block|}
block|}
decl_stmt|;
name|workPool
operator|=
name|Executors
operator|.
name|newFixedThreadPool
argument_list|(
name|HiveConf
operator|.
name|getIntVar
argument_list|(
name|conf
argument_list|,
name|ConfVars
operator|.
name|HIVE_SERVER2_TEZ_WM_WORKER_THREADS
argument_list|)
argument_list|,
name|workerFactory
argument_list|)
expr_stmt|;
name|ThreadFactory
name|timeoutFactory
init|=
operator|new
name|ThreadFactory
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|Thread
name|newThread
parameter_list|(
name|Runnable
name|r
parameter_list|)
block|{
name|Thread
name|t
init|=
operator|new
name|Thread
argument_list|(
name|r
argument_list|,
literal|"Workload management timeout thread"
argument_list|)
decl_stmt|;
name|t
operator|.
name|setDaemon
argument_list|(
literal|true
argument_list|)
expr_stmt|;
return|return
name|t
return|;
block|}
block|}
decl_stmt|;
name|timeoutPool
operator|=
name|Executors
operator|.
name|newScheduledThreadPool
argument_list|(
literal|1
argument_list|,
name|timeoutFactory
argument_list|)
expr_stmt|;
name|wmThread
operator|=
operator|new
name|Thread
argument_list|(
operator|new
name|Runnable
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|void
name|run
parameter_list|()
block|{
name|runWmThread
argument_list|()
expr_stmt|;
block|}
block|}
argument_list|,
literal|"Workload management master"
argument_list|)
expr_stmt|;
name|wmThread
operator|.
name|setDaemon
argument_list|(
literal|true
argument_list|)
expr_stmt|;
comment|// TODO: add support for per pool action handler and triggers fetcher (+atomic update to active triggers)
name|sessionTriggerProvider
operator|=
operator|new
name|SessionTriggerProvider
argument_list|()
expr_stmt|;
name|triggerActionHandler
operator|=
operator|new
name|TriggerViolationActionHandler
argument_list|()
expr_stmt|;
name|triggerValidatorRunnable
operator|=
operator|new
name|TriggerValidatorRunnable
argument_list|(
name|getSessionTriggerProvider
argument_list|()
argument_list|,
name|getTriggerActionHandler
argument_list|()
argument_list|)
expr_stmt|;
name|startTriggerValidator
argument_list|(
name|conf
argument_list|)
expr_stmt|;
block|}
specifier|private
name|int
name|determineQueryParallelism
parameter_list|(
name|WMFullResourcePlan
name|plan
parameter_list|)
block|{
name|int
name|result
init|=
literal|0
decl_stmt|;
for|for
control|(
name|WMPool
name|pool
range|:
name|plan
operator|.
name|getPools
argument_list|()
control|)
block|{
name|result
operator|+=
name|pool
operator|.
name|getQueryParallelism
argument_list|()
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
specifier|public
name|void
name|start
parameter_list|()
throws|throws
name|Exception
block|{
name|tezAmPool
operator|.
name|start
argument_list|()
expr_stmt|;
if|if
condition|(
name|expirationTracker
operator|!=
literal|null
condition|)
block|{
name|expirationTracker
operator|.
name|start
argument_list|()
expr_stmt|;
block|}
name|allocationManager
operator|.
name|start
argument_list|()
expr_stmt|;
name|wmThread
operator|.
name|start
argument_list|()
expr_stmt|;
name|initRpFuture
operator|.
name|get
argument_list|()
expr_stmt|;
comment|// Wait for the initial resource plan to be applied.
block|}
specifier|public
name|void
name|stop
parameter_list|()
throws|throws
name|Exception
block|{
name|List
argument_list|<
name|TezSessionPoolSession
argument_list|>
name|sessionsToClose
init|=
literal|null
decl_stmt|;
synchronized|synchronized
init|(
name|openSessions
init|)
block|{
name|sessionsToClose
operator|=
operator|new
name|ArrayList
argument_list|<
name|TezSessionPoolSession
argument_list|>
argument_list|(
name|openSessions
operator|.
name|keySet
argument_list|()
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|TezSessionState
name|sessionState
range|:
name|sessionsToClose
control|)
block|{
name|sessionState
operator|.
name|close
argument_list|(
literal|false
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|expirationTracker
operator|!=
literal|null
condition|)
block|{
name|expirationTracker
operator|.
name|stop
argument_list|()
expr_stmt|;
block|}
name|allocationManager
operator|.
name|stop
argument_list|()
expr_stmt|;
if|if
condition|(
name|wmThread
operator|!=
literal|null
condition|)
block|{
name|wmThread
operator|.
name|interrupt
argument_list|()
expr_stmt|;
block|}
name|workPool
operator|.
name|shutdownNow
argument_list|()
expr_stmt|;
name|timeoutPool
operator|.
name|shutdownNow
argument_list|()
expr_stmt|;
name|INSTANCE
operator|=
literal|null
expr_stmt|;
block|}
comment|/** Represent a single iteration of work for the master thread. */
specifier|private
specifier|final
specifier|static
class|class
name|EventState
block|{
specifier|private
specifier|final
name|Set
argument_list|<
name|WmTezSession
argument_list|>
name|toReturn
init|=
name|Sets
operator|.
name|newIdentityHashSet
argument_list|()
decl_stmt|,
name|toDestroy
init|=
name|Sets
operator|.
name|newIdentityHashSet
argument_list|()
decl_stmt|,
name|updateErrors
init|=
name|Sets
operator|.
name|newIdentityHashSet
argument_list|()
decl_stmt|;
specifier|private
specifier|final
name|LinkedList
argument_list|<
name|SessionInitContext
argument_list|>
name|initResults
init|=
operator|new
name|LinkedList
argument_list|<>
argument_list|()
decl_stmt|;
specifier|private
specifier|final
name|IdentityHashMap
argument_list|<
name|WmTezSession
argument_list|,
name|SettableFuture
argument_list|<
name|WmTezSession
argument_list|>
argument_list|>
name|toReopen
init|=
operator|new
name|IdentityHashMap
argument_list|<>
argument_list|()
decl_stmt|;
specifier|private
specifier|final
name|LinkedList
argument_list|<
name|GetRequest
argument_list|>
name|getRequests
init|=
operator|new
name|LinkedList
argument_list|<>
argument_list|()
decl_stmt|;
specifier|private
specifier|final
name|IdentityHashMap
argument_list|<
name|WmTezSession
argument_list|,
name|GetRequest
argument_list|>
name|toReuse
init|=
operator|new
name|IdentityHashMap
argument_list|<>
argument_list|()
decl_stmt|;
specifier|private
name|WMFullResourcePlan
name|resourcePlanToApply
init|=
literal|null
decl_stmt|;
specifier|private
name|boolean
name|hasClusterStateChanged
init|=
literal|false
decl_stmt|;
specifier|private
name|SettableFuture
argument_list|<
name|Boolean
argument_list|>
name|testEvent
decl_stmt|,
name|applyRpFuture
decl_stmt|;
block|}
comment|/**    * The work delegated from the master thread that doesn't have an async implementation    * (mostly opening and closing the sessions).    */
specifier|private
specifier|final
specifier|static
class|class
name|WmThreadSyncWork
block|{
specifier|private
name|LinkedList
argument_list|<
name|WmTezSession
argument_list|>
name|toRestartInUse
init|=
operator|new
name|LinkedList
argument_list|<>
argument_list|()
decl_stmt|,
name|toDestroyNoRestart
init|=
operator|new
name|LinkedList
argument_list|<>
argument_list|()
decl_stmt|;
block|}
specifier|private
name|void
name|runWmThread
parameter_list|()
block|{
while|while
condition|(
literal|true
condition|)
block|{
name|EventState
name|currentEvents
init|=
literal|null
decl_stmt|;
name|currentLock
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
while|while
condition|(
operator|!
name|hasChanges
condition|)
block|{
try|try
block|{
name|hasChangesCondition
operator|.
name|await
argument_list|(
literal|1
argument_list|,
name|TimeUnit
operator|.
name|SECONDS
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"WM thread was interrupted and will now exit"
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
name|hasChanges
operator|=
literal|false
expr_stmt|;
name|currentEvents
operator|=
name|current
expr_stmt|;
name|current
operator|=
operator|(
name|currentEvents
operator|==
name|one
operator|)
condition|?
name|two
else|:
name|one
expr_stmt|;
block|}
finally|finally
block|{
name|currentLock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
try|try
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Processing current events"
argument_list|)
expr_stmt|;
name|processCurrentEvents
argument_list|(
name|currentEvents
argument_list|,
name|syncWork
argument_list|)
expr_stmt|;
name|scheduleWork
argument_list|(
name|syncWork
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|ex
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"WM thread was interrupted and will now exit"
argument_list|)
expr_stmt|;
return|return;
block|}
catch|catch
parameter_list|(
name|Exception
decl||
name|AssertionError
name|ex
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"WM thread encountered an error but will attempt to continue"
argument_list|,
name|ex
argument_list|)
expr_stmt|;
if|if
condition|(
name|currentEvents
operator|.
name|testEvent
operator|!=
literal|null
condition|)
block|{
name|currentEvents
operator|.
name|testEvent
operator|.
name|setException
argument_list|(
name|ex
argument_list|)
expr_stmt|;
name|currentEvents
operator|.
name|testEvent
operator|=
literal|null
expr_stmt|;
block|}
if|if
condition|(
name|currentEvents
operator|.
name|applyRpFuture
operator|!=
literal|null
condition|)
block|{
name|currentEvents
operator|.
name|applyRpFuture
operator|.
name|setException
argument_list|(
name|ex
argument_list|)
expr_stmt|;
name|currentEvents
operator|.
name|applyRpFuture
operator|=
literal|null
expr_stmt|;
block|}
comment|// TODO: we either have to kill HS2 or, as the non-actor model would implicitly,
comment|//       hope for the best and continue on other threads. Do the latter for now.
continue|continue;
block|}
block|}
block|}
specifier|private
name|void
name|scheduleWork
parameter_list|(
name|WmThreadSyncWork
name|context
parameter_list|)
block|{
comment|// Do the work that cannot be done via async calls.
comment|// 1. Restart pool sessions.
for|for
control|(
specifier|final
name|WmTezSession
name|toRestart
range|:
name|context
operator|.
name|toRestartInUse
control|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Replacing "
operator|+
name|toRestart
operator|+
literal|" with a new session"
argument_list|)
expr_stmt|;
name|workPool
operator|.
name|submit
argument_list|(
parameter_list|()
lambda|->
block|{
try|try
block|{
comment|// Note: sessions in toRestart are always in use, so they cannot expire in parallel.
name|tezAmPool
operator|.
name|replaceSession
argument_list|(
name|toRestart
argument_list|,
literal|false
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|ex
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Failed to restart an old session; ignoring "
operator|+
name|ex
operator|.
name|getMessage
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
argument_list|)
expr_stmt|;
block|}
name|context
operator|.
name|toRestartInUse
operator|.
name|clear
argument_list|()
expr_stmt|;
comment|// 2. Destroy the sessions that we don't need anymore.
for|for
control|(
specifier|final
name|WmTezSession
name|toDestroy
range|:
name|context
operator|.
name|toDestroyNoRestart
control|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Closing "
operator|+
name|toDestroy
operator|+
literal|" without restart"
argument_list|)
expr_stmt|;
name|workPool
operator|.
name|submit
argument_list|(
parameter_list|()
lambda|->
block|{
try|try
block|{
name|toDestroy
operator|.
name|close
argument_list|(
literal|false
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|ex
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Failed to close an old session; ignoring "
operator|+
name|ex
operator|.
name|getMessage
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
argument_list|)
expr_stmt|;
block|}
name|context
operator|.
name|toDestroyNoRestart
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
specifier|private
name|void
name|processCurrentEvents
parameter_list|(
name|EventState
name|e
parameter_list|,
name|WmThreadSyncWork
name|syncWork
parameter_list|)
throws|throws
name|Exception
block|{
comment|// The order of processing is as follows. We'd reclaim or kill all the sessions that we can
comment|// reclaim from various user actions and errors, then apply the new plan if any,
comment|// then give out all we can give out (restart, get and reopen callers) and rebalance the
comment|// resource allocations in all the affected pools.
comment|// For every session, we'd check all the concurrent things happening to it.
comment|// TODO: also account for Tez-internal session restarts;
comment|//       AM reg info changes; add notifications, ignore errors, and update alloc.
name|HashSet
argument_list|<
name|String
argument_list|>
name|poolsToRedistribute
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|()
decl_stmt|;
comment|// 0. Handle initialization results.
for|for
control|(
name|SessionInitContext
name|sw
range|:
name|e
operator|.
name|initResults
control|)
block|{
name|handleInitResultOnMasterThread
argument_list|(
name|sw
argument_list|,
name|syncWork
argument_list|,
name|poolsToRedistribute
argument_list|)
expr_stmt|;
block|}
name|e
operator|.
name|initResults
operator|.
name|clear
argument_list|()
expr_stmt|;
comment|// 1. Handle sessions that are being destroyed by users. Destroy implies return.
for|for
control|(
name|WmTezSession
name|sessionToDestroy
range|:
name|e
operator|.
name|toDestroy
control|)
block|{
if|if
condition|(
name|e
operator|.
name|toReturn
operator|.
name|remove
argument_list|(
name|sessionToDestroy
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"The session was both destroyed and returned by the user; destroying"
argument_list|)
expr_stmt|;
block|}
name|LOG
operator|.
name|debug
argument_list|(
literal|"Destroying {}"
argument_list|,
name|sessionToDestroy
argument_list|)
expr_stmt|;
name|Boolean
name|shouldReturn
init|=
name|handleReturnedInUseSessionOnMasterThread
argument_list|(
name|e
argument_list|,
name|sessionToDestroy
argument_list|,
name|poolsToRedistribute
argument_list|)
decl_stmt|;
if|if
condition|(
name|shouldReturn
operator|==
literal|null
operator|||
name|shouldReturn
condition|)
block|{
comment|// Restart if this session is still relevant, even if there's an internal error.
name|syncWork
operator|.
name|toRestartInUse
operator|.
name|add
argument_list|(
name|sessionToDestroy
argument_list|)
expr_stmt|;
block|}
block|}
name|e
operator|.
name|toDestroy
operator|.
name|clear
argument_list|()
expr_stmt|;
comment|// 2. Now handle actual returns. Sessions may be returned to the pool or may trigger expires.
for|for
control|(
name|WmTezSession
name|sessionToReturn
range|:
name|e
operator|.
name|toReturn
control|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Returning {}"
argument_list|,
name|sessionToReturn
argument_list|)
expr_stmt|;
name|Boolean
name|shouldReturn
init|=
name|handleReturnedInUseSessionOnMasterThread
argument_list|(
name|e
argument_list|,
name|sessionToReturn
argument_list|,
name|poolsToRedistribute
argument_list|)
decl_stmt|;
if|if
condition|(
name|shouldReturn
operator|==
literal|null
condition|)
block|{
comment|// Restart if there's an internal error.
name|syncWork
operator|.
name|toRestartInUse
operator|.
name|add
argument_list|(
name|sessionToReturn
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|!
name|shouldReturn
condition|)
continue|continue;
name|boolean
name|wasReturned
init|=
name|tezAmPool
operator|.
name|returnSessionAsync
argument_list|(
name|sessionToReturn
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|wasReturned
condition|)
block|{
name|syncWork
operator|.
name|toDestroyNoRestart
operator|.
name|add
argument_list|(
name|sessionToReturn
argument_list|)
expr_stmt|;
block|}
block|}
name|e
operator|.
name|toReturn
operator|.
name|clear
argument_list|()
expr_stmt|;
comment|// 3. Reopen is essentially just destroy + get a new session for a session in use.
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|WmTezSession
argument_list|,
name|SettableFuture
argument_list|<
name|WmTezSession
argument_list|>
argument_list|>
name|entry
range|:
name|e
operator|.
name|toReopen
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Reopening {}"
argument_list|,
name|entry
operator|.
name|getKey
argument_list|()
argument_list|)
expr_stmt|;
name|handeReopenRequestOnMasterThread
argument_list|(
name|e
argument_list|,
name|entry
operator|.
name|getKey
argument_list|()
argument_list|,
name|entry
operator|.
name|getValue
argument_list|()
argument_list|,
name|poolsToRedistribute
argument_list|,
name|syncWork
argument_list|)
expr_stmt|;
block|}
name|e
operator|.
name|toReopen
operator|.
name|clear
argument_list|()
expr_stmt|;
comment|// 4. All the sessions in use that were not destroyed or returned with a failed update now die.
for|for
control|(
name|WmTezSession
name|sessionWithUpdateError
range|:
name|e
operator|.
name|updateErrors
control|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Update failed for {}"
argument_list|,
name|sessionWithUpdateError
argument_list|)
expr_stmt|;
name|handleUpdateErrorOnMasterThread
argument_list|(
name|sessionWithUpdateError
argument_list|,
name|e
argument_list|,
name|syncWork
argument_list|,
name|poolsToRedistribute
argument_list|)
expr_stmt|;
block|}
name|e
operator|.
name|updateErrors
operator|.
name|clear
argument_list|()
expr_stmt|;
comment|// 5. Now apply a resource plan if any. This is expected to be pretty rare.
name|boolean
name|hasRequeues
init|=
literal|false
decl_stmt|;
if|if
condition|(
name|e
operator|.
name|resourcePlanToApply
operator|!=
literal|null
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Applying new resource plan"
argument_list|)
expr_stmt|;
name|int
name|getReqCount
init|=
name|e
operator|.
name|getRequests
operator|.
name|size
argument_list|()
decl_stmt|;
name|applyNewResourcePlanOnMasterThread
argument_list|(
name|e
argument_list|,
name|syncWork
argument_list|,
name|poolsToRedistribute
argument_list|)
expr_stmt|;
name|hasRequeues
operator|=
name|getReqCount
operator|!=
name|e
operator|.
name|getRequests
operator|.
name|size
argument_list|()
expr_stmt|;
block|}
name|e
operator|.
name|resourcePlanToApply
operator|=
literal|null
expr_stmt|;
comment|// 6. Handle all the get/reuse requests. We won't actually give out anything here, but merely
comment|//    map all the requests and place them in an appropriate order in pool queues. The only
comment|//    exception is the reuse without queue contention; can be granted immediately. If we can't
comment|//    reuse the session immediately, we will convert the reuse to a normal get, because we
comment|//    want query level fairness, and don't want the get in queue to hold up a session.
name|GetRequest
name|req
decl_stmt|;
while|while
condition|(
operator|(
name|req
operator|=
name|e
operator|.
name|getRequests
operator|.
name|pollFirst
argument_list|()
operator|)
operator|!=
literal|null
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Processing a new get request from "
operator|+
name|req
operator|.
name|mappingInput
argument_list|)
expr_stmt|;
name|queueGetRequestOnMasterThread
argument_list|(
name|req
argument_list|,
name|poolsToRedistribute
argument_list|,
name|syncWork
argument_list|)
expr_stmt|;
block|}
name|e
operator|.
name|toReuse
operator|.
name|clear
argument_list|()
expr_stmt|;
comment|// 7. If there was a cluster state change, make sure we redistribute all the pools.
if|if
condition|(
name|e
operator|.
name|hasClusterStateChanged
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Processing a cluster state change"
argument_list|)
expr_stmt|;
name|poolsToRedistribute
operator|.
name|addAll
argument_list|(
name|pools
operator|.
name|keySet
argument_list|()
argument_list|)
expr_stmt|;
name|e
operator|.
name|hasClusterStateChanged
operator|=
literal|false
expr_stmt|;
block|}
comment|// 8. Finally, for all the pools that have changes, promote queued queries and rebalance.
for|for
control|(
name|String
name|poolName
range|:
name|poolsToRedistribute
control|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Processing changes for pool "
operator|+
name|poolName
operator|+
literal|": "
operator|+
name|pools
operator|.
name|get
argument_list|(
name|poolName
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|processPoolChangesOnMasterThread
argument_list|(
name|poolName
argument_list|,
name|syncWork
argument_list|,
name|hasRequeues
argument_list|)
expr_stmt|;
block|}
comment|// 9. Notify tests and global async ops.
if|if
condition|(
name|e
operator|.
name|testEvent
operator|!=
literal|null
condition|)
block|{
name|e
operator|.
name|testEvent
operator|.
name|set
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|e
operator|.
name|testEvent
operator|=
literal|null
expr_stmt|;
block|}
if|if
condition|(
name|e
operator|.
name|applyRpFuture
operator|!=
literal|null
condition|)
block|{
name|e
operator|.
name|applyRpFuture
operator|.
name|set
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|e
operator|.
name|applyRpFuture
operator|=
literal|null
expr_stmt|;
block|}
block|}
comment|// ========= Master thread methods
specifier|private
name|void
name|handleInitResultOnMasterThread
parameter_list|(
name|SessionInitContext
name|sw
parameter_list|,
name|WmThreadSyncWork
name|syncWork
parameter_list|,
name|HashSet
argument_list|<
name|String
argument_list|>
name|poolsToRedistribute
parameter_list|)
block|{
comment|// For the failures, the users have been notified, we just need to clean up. There's no
comment|// session here (or it's unused), so no conflicts are possible. We just remove it.
comment|// For successes, the user has also been notified, so various requests are also possible;
comment|// however, to start, we'd just put the session into the sessions list and go from there.
name|WmTezSession
name|session
init|=
literal|null
decl_stmt|;
name|sw
operator|.
name|lock
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
if|if
condition|(
name|sw
operator|.
name|state
operator|==
name|SessionInitState
operator|.
name|CANCELED
condition|)
block|{
comment|// We have processed this on the previous run, after it has already queued the message.
return|return;
block|}
assert|assert
name|sw
operator|.
name|state
operator|==
name|SessionInitState
operator|.
name|DONE
assert|;
name|session
operator|=
name|sw
operator|.
name|session
expr_stmt|;
name|sw
operator|.
name|session
operator|=
literal|null
expr_stmt|;
block|}
finally|finally
block|{
name|sw
operator|.
name|lock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
name|LOG
operator|.
name|debug
argument_list|(
literal|"Processing "
operator|+
operator|(
operator|(
name|session
operator|==
literal|null
operator|)
condition|?
literal|"failed"
else|:
literal|"successful"
operator|)
operator|+
literal|" initialization result for pool "
operator|+
name|sw
operator|.
name|poolName
argument_list|)
expr_stmt|;
comment|// We could not have removed the pool for this session, or we would have CANCELED the init.
name|PoolState
name|pool
init|=
name|pools
operator|.
name|get
argument_list|(
name|sw
operator|.
name|poolName
argument_list|)
decl_stmt|;
if|if
condition|(
name|pool
operator|==
literal|null
operator|||
operator|!
name|pool
operator|.
name|initializingSessions
operator|.
name|remove
argument_list|(
name|sw
argument_list|)
condition|)
block|{
comment|// Query parallelism might be fubar.
name|LOG
operator|.
name|error
argument_list|(
literal|"Cannot remove initializing session from the pool "
operator|+
name|sw
operator|.
name|poolName
operator|+
literal|" - internal error"
argument_list|)
expr_stmt|;
block|}
name|poolsToRedistribute
operator|.
name|add
argument_list|(
name|sw
operator|.
name|poolName
argument_list|)
expr_stmt|;
if|if
condition|(
name|session
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|pool
operator|!=
literal|null
condition|)
block|{
name|pool
operator|.
name|sessions
operator|.
name|add
argument_list|(
name|session
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Cannot add new session to the pool "
operator|+
name|sw
operator|.
name|poolName
operator|+
literal|" because it was removed unexpectedly - internal error "
operator|+
name|session
argument_list|)
expr_stmt|;
name|syncWork
operator|.
name|toRestartInUse
operator|.
name|add
argument_list|(
name|session
argument_list|)
expr_stmt|;
block|}
block|}
block|}
specifier|private
name|Boolean
name|handleReturnedInUseSessionOnMasterThread
parameter_list|(
name|EventState
name|e
parameter_list|,
name|WmTezSession
name|session
parameter_list|,
name|HashSet
argument_list|<
name|String
argument_list|>
name|poolsToRedistribute
parameter_list|)
block|{
comment|// This handles the common logic for destroy and return - everything except
comment|// the invalid combination of destroy and return themselves, as well as the actual
comment|// statement that destroys or returns it.
if|if
condition|(
name|e
operator|.
name|updateErrors
operator|.
name|remove
argument_list|(
name|session
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Ignoring an update error for a session being destroyed or returned"
argument_list|)
expr_stmt|;
block|}
name|SettableFuture
argument_list|<
name|WmTezSession
argument_list|>
name|future
init|=
name|e
operator|.
name|toReopen
operator|.
name|remove
argument_list|(
name|session
argument_list|)
decl_stmt|;
if|if
condition|(
name|future
operator|!=
literal|null
condition|)
block|{
name|future
operator|.
name|setException
argument_list|(
operator|new
name|AssertionError
argument_list|(
literal|"Invalid reopen attempt"
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|GetRequest
name|reuseRequest
init|=
name|e
operator|.
name|toReuse
operator|.
name|remove
argument_list|(
name|session
argument_list|)
decl_stmt|;
if|if
condition|(
name|reuseRequest
operator|!=
literal|null
condition|)
block|{
name|reuseRequest
operator|.
name|future
operator|.
name|setException
argument_list|(
operator|new
name|AssertionError
argument_list|(
literal|"Invalid reuse attempt"
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|checkAndRemoveSessionFromItsPool
argument_list|(
name|session
argument_list|,
name|poolsToRedistribute
argument_list|)
return|;
block|}
specifier|private
name|void
name|handeReopenRequestOnMasterThread
parameter_list|(
name|EventState
name|e
parameter_list|,
name|WmTezSession
name|session
parameter_list|,
name|SettableFuture
argument_list|<
name|WmTezSession
argument_list|>
name|future
parameter_list|,
name|HashSet
argument_list|<
name|String
argument_list|>
name|poolsToRedistribute
parameter_list|,
name|WmThreadSyncWork
name|syncWork
parameter_list|)
throws|throws
name|Exception
block|{
if|if
condition|(
name|e
operator|.
name|updateErrors
operator|.
name|remove
argument_list|(
name|session
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Ignoring an update error for a session being reopened"
argument_list|)
expr_stmt|;
block|}
name|GetRequest
name|reuseRequest
init|=
name|e
operator|.
name|toReuse
operator|.
name|remove
argument_list|(
name|session
argument_list|)
decl_stmt|;
if|if
condition|(
name|reuseRequest
operator|!=
literal|null
condition|)
block|{
name|reuseRequest
operator|.
name|future
operator|.
name|setException
argument_list|(
operator|new
name|AssertionError
argument_list|(
literal|"Invalid reuse attempt"
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// In order to expedite things in a general case, we are not actually going to reopen
comment|// anything. Instead, we will try to give out an existing session from the pool, and restart
comment|// the problematic one in background.
name|String
name|poolName
init|=
name|session
operator|.
name|getPoolName
argument_list|()
decl_stmt|;
name|Boolean
name|isRemoved
init|=
name|checkAndRemoveSessionFromItsPool
argument_list|(
name|session
argument_list|,
name|poolsToRedistribute
argument_list|)
decl_stmt|;
comment|// If we fail to remove, it's probably an internal error. We'd try to handle it the same way
comment|// as above - by restarting the session. We'd fail the caller to avoid exceeding parallelism.
if|if
condition|(
name|isRemoved
operator|==
literal|null
condition|)
block|{
name|future
operator|.
name|setException
argument_list|(
operator|new
name|RuntimeException
argument_list|(
literal|"Reopen failed due to an internal error"
argument_list|)
argument_list|)
expr_stmt|;
name|syncWork
operator|.
name|toRestartInUse
operator|.
name|add
argument_list|(
name|session
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
operator|!
name|isRemoved
condition|)
block|{
name|future
operator|.
name|setException
argument_list|(
operator|new
name|RuntimeException
argument_list|(
literal|"WM killed this session during reopen: "
operator|+
name|session
operator|.
name|getReasonForKill
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
return|return;
comment|// No longer relevant for WM - bail.
block|}
comment|// If pool didn't exist, removeSessionFromItsPool would have returned null.
name|PoolState
name|pool
init|=
name|pools
operator|.
name|get
argument_list|(
name|poolName
argument_list|)
decl_stmt|;
name|SessionInitContext
name|sw
init|=
operator|new
name|SessionInitContext
argument_list|(
name|future
argument_list|,
name|poolName
argument_list|)
decl_stmt|;
comment|// We have just removed the session from the same pool, so don't check concurrency here.
name|pool
operator|.
name|initializingSessions
operator|.
name|add
argument_list|(
name|sw
argument_list|)
expr_stmt|;
name|ListenableFuture
argument_list|<
name|WmTezSession
argument_list|>
name|getFuture
init|=
name|tezAmPool
operator|.
name|getSessionAsync
argument_list|()
decl_stmt|;
name|Futures
operator|.
name|addCallback
argument_list|(
name|getFuture
argument_list|,
name|sw
argument_list|)
expr_stmt|;
name|syncWork
operator|.
name|toRestartInUse
operator|.
name|add
argument_list|(
name|session
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|handleUpdateErrorOnMasterThread
parameter_list|(
name|WmTezSession
name|sessionWithUpdateError
parameter_list|,
name|EventState
name|e
parameter_list|,
name|WmThreadSyncWork
name|syncWork
parameter_list|,
name|HashSet
argument_list|<
name|String
argument_list|>
name|poolsToRedistribute
parameter_list|)
block|{
name|GetRequest
name|reuseRequest
init|=
name|e
operator|.
name|toReuse
operator|.
name|remove
argument_list|(
name|sessionWithUpdateError
argument_list|)
decl_stmt|;
if|if
condition|(
name|reuseRequest
operator|!=
literal|null
condition|)
block|{
comment|// This session is bad, so don't allow reuse; just convert it to normal get.
name|reuseRequest
operator|.
name|sessionToReuse
operator|=
literal|null
expr_stmt|;
block|}
comment|// TODO: we should communicate this to the user more explicitly (use kill query API, or
comment|//       add an option for bg kill checking to TezTask/monitor?
comment|// We are assuming the update-error AM is bad and just try to kill it.
name|Boolean
name|isRemoved
init|=
name|checkAndRemoveSessionFromItsPool
argument_list|(
name|sessionWithUpdateError
argument_list|,
name|poolsToRedistribute
argument_list|)
decl_stmt|;
if|if
condition|(
name|isRemoved
operator|!=
literal|null
operator|&&
operator|!
name|isRemoved
condition|)
block|{
comment|// An update error for some session that was actually already killed by us.
return|return;
block|}
comment|// Regardless whether it was removed successfully or after failing to remove, restart it.
comment|// Since we just restart this from under the user, mark it so we handle it properly when
comment|// the user tries to actually use this session and fails, proceeding to return/destroy it.
comment|// TODO: propagate this error to TezJobMonitor somehow, after we add the use of KillQuery.
name|sessionWithUpdateError
operator|.
name|setIsIrrelevantForWm
argument_list|(
literal|"Failed to update resource allocation"
argument_list|)
expr_stmt|;
name|syncWork
operator|.
name|toRestartInUse
operator|.
name|add
argument_list|(
name|sessionWithUpdateError
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|applyNewResourcePlanOnMasterThread
parameter_list|(
name|EventState
name|e
parameter_list|,
name|WmThreadSyncWork
name|syncWork
parameter_list|,
name|HashSet
argument_list|<
name|String
argument_list|>
name|poolsToRedistribute
parameter_list|)
block|{
name|int
name|totalQueryParallelism
init|=
literal|0
decl_stmt|;
comment|// FIXME: Add Triggers from metastore to poolstate
comment|// Note: we assume here that plan has been validated beforehand, so we don't verify
comment|//       that fractions or query parallelism add up, etc.
name|this
operator|.
name|userPoolMapping
operator|=
operator|new
name|UserPoolMapping
argument_list|(
name|e
operator|.
name|resourcePlanToApply
operator|.
name|getMappings
argument_list|()
argument_list|,
name|e
operator|.
name|resourcePlanToApply
operator|.
name|getPlan
argument_list|()
operator|.
name|getDefaultPoolPath
argument_list|()
argument_list|)
expr_stmt|;
name|HashMap
argument_list|<
name|String
argument_list|,
name|PoolState
argument_list|>
name|oldPools
init|=
name|pools
decl_stmt|;
name|pools
operator|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
expr_stmt|;
comment|// For simplicity, to always have parents while storing pools in a flat structure, we'll
comment|// first distribute them by levels, then add level by level.
name|ArrayList
argument_list|<
name|List
argument_list|<
name|WMPool
argument_list|>
argument_list|>
name|poolsByLevel
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|WMPool
name|pool
range|:
name|e
operator|.
name|resourcePlanToApply
operator|.
name|getPools
argument_list|()
control|)
block|{
name|String
name|fullName
init|=
name|pool
operator|.
name|getPoolPath
argument_list|()
decl_stmt|;
name|int
name|ix
init|=
name|StringUtils
operator|.
name|countMatches
argument_list|(
name|fullName
argument_list|,
name|POOL_SEPARATOR_STR
argument_list|)
decl_stmt|;
while|while
condition|(
name|poolsByLevel
operator|.
name|size
argument_list|()
operator|<=
name|ix
condition|)
block|{
name|poolsByLevel
operator|.
name|add
argument_list|(
operator|new
name|LinkedList
argument_list|<
name|WMPool
argument_list|>
argument_list|()
argument_list|)
expr_stmt|;
comment|// We expect all the levels to have items.
block|}
name|poolsByLevel
operator|.
name|get
argument_list|(
name|ix
argument_list|)
operator|.
name|add
argument_list|(
name|pool
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|int
name|level
init|=
literal|0
init|;
name|level
operator|<
name|poolsByLevel
operator|.
name|size
argument_list|()
condition|;
operator|++
name|level
control|)
block|{
name|List
argument_list|<
name|WMPool
argument_list|>
name|poolsOnLevel
init|=
name|poolsByLevel
operator|.
name|get
argument_list|(
name|level
argument_list|)
decl_stmt|;
for|for
control|(
name|WMPool
name|pool
range|:
name|poolsOnLevel
control|)
block|{
name|String
name|fullName
init|=
name|pool
operator|.
name|getPoolPath
argument_list|()
decl_stmt|;
name|int
name|qp
init|=
name|pool
operator|.
name|getQueryParallelism
argument_list|()
decl_stmt|;
name|double
name|fraction
init|=
name|pool
operator|.
name|getAllocFraction
argument_list|()
decl_stmt|;
if|if
condition|(
name|level
operator|>
literal|0
condition|)
block|{
name|String
name|parentName
init|=
name|fullName
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|fullName
operator|.
name|lastIndexOf
argument_list|(
name|POOL_SEPARATOR
argument_list|)
argument_list|)
decl_stmt|;
name|PoolState
name|parent
init|=
name|pools
operator|.
name|get
argument_list|(
name|parentName
argument_list|)
decl_stmt|;
name|fraction
operator|=
name|parent
operator|.
name|finalFraction
operator|*
name|fraction
expr_stmt|;
name|parent
operator|.
name|finalFractionRemaining
operator|-=
name|fraction
expr_stmt|;
block|}
name|PoolState
name|state
init|=
name|oldPools
operator|==
literal|null
condition|?
literal|null
else|:
name|oldPools
operator|.
name|remove
argument_list|(
name|fullName
argument_list|)
decl_stmt|;
if|if
condition|(
name|state
operator|==
literal|null
condition|)
block|{
name|state
operator|=
operator|new
name|PoolState
argument_list|(
name|fullName
argument_list|,
name|qp
argument_list|,
name|fraction
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// This will also take care of the queries if query parallelism changed.
name|state
operator|.
name|update
argument_list|(
name|qp
argument_list|,
name|fraction
argument_list|,
name|syncWork
operator|.
name|toRestartInUse
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|poolsToRedistribute
operator|.
name|add
argument_list|(
name|fullName
argument_list|)
expr_stmt|;
block|}
name|state
operator|.
name|setTriggers
argument_list|(
operator|new
name|LinkedList
argument_list|<
name|Trigger
argument_list|>
argument_list|()
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Adding Hive pool: "
operator|+
name|state
argument_list|)
expr_stmt|;
name|pools
operator|.
name|put
argument_list|(
name|fullName
argument_list|,
name|state
argument_list|)
expr_stmt|;
name|totalQueryParallelism
operator|+=
name|qp
expr_stmt|;
block|}
block|}
if|if
condition|(
name|e
operator|.
name|resourcePlanToApply
operator|.
name|isSetTriggers
argument_list|()
operator|&&
name|e
operator|.
name|resourcePlanToApply
operator|.
name|isSetPoolTriggers
argument_list|()
condition|)
block|{
name|Map
argument_list|<
name|String
argument_list|,
name|Trigger
argument_list|>
name|triggers
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|WMTrigger
name|trigger
range|:
name|e
operator|.
name|resourcePlanToApply
operator|.
name|getTriggers
argument_list|()
control|)
block|{
comment|// TODO: parse trigger.getActionExpression() correctly; right now the Action enum is invalid.
name|ExecutionTrigger
name|execTrigger
init|=
operator|new
name|ExecutionTrigger
argument_list|(
name|trigger
operator|.
name|getTriggerName
argument_list|()
argument_list|,
name|ExpressionFactory
operator|.
name|fromString
argument_list|(
name|trigger
operator|.
name|getTriggerExpression
argument_list|()
argument_list|)
argument_list|,
name|Action
operator|.
name|KILL_QUERY
argument_list|)
decl_stmt|;
name|triggers
operator|.
name|put
argument_list|(
name|trigger
operator|.
name|getTriggerName
argument_list|()
argument_list|,
name|execTrigger
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|WMPoolTrigger
name|poolTrigger
range|:
name|e
operator|.
name|resourcePlanToApply
operator|.
name|getPoolTriggers
argument_list|()
control|)
block|{
name|PoolState
name|pool
init|=
name|pools
operator|.
name|get
argument_list|(
name|poolTrigger
operator|.
name|getPool
argument_list|()
argument_list|)
decl_stmt|;
name|Trigger
name|trigger
init|=
name|triggers
operator|.
name|get
argument_list|(
name|poolTrigger
operator|.
name|getTrigger
argument_list|()
argument_list|)
decl_stmt|;
name|pool
operator|.
name|triggers
operator|.
name|add
argument_list|(
name|trigger
argument_list|)
expr_stmt|;
name|poolsToRedistribute
operator|.
name|add
argument_list|(
name|pool
operator|.
name|fullName
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Adding pool "
operator|+
name|pool
operator|.
name|fullName
operator|+
literal|" trigger "
operator|+
name|trigger
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|oldPools
operator|!=
literal|null
operator|&&
operator|!
name|oldPools
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
comment|// Looks like some pools were removed; kill running queries, re-queue the queued ones.
for|for
control|(
name|PoolState
name|oldPool
range|:
name|oldPools
operator|.
name|values
argument_list|()
control|)
block|{
name|oldPool
operator|.
name|destroy
argument_list|(
name|syncWork
operator|.
name|toRestartInUse
argument_list|,
name|e
operator|.
name|getRequests
argument_list|,
name|e
operator|.
name|toReuse
argument_list|)
expr_stmt|;
block|}
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"Updating with "
operator|+
name|totalQueryParallelism
operator|+
literal|" total query parallelism"
argument_list|)
expr_stmt|;
name|int
name|deltaSessions
init|=
name|totalQueryParallelism
operator|-
name|this
operator|.
name|totalQueryParallelism
decl_stmt|;
name|this
operator|.
name|totalQueryParallelism
operator|=
name|totalQueryParallelism
expr_stmt|;
if|if
condition|(
name|deltaSessions
operator|==
literal|0
condition|)
return|return;
comment|// Nothing to do.
if|if
condition|(
name|deltaSessions
operator|<
literal|0
condition|)
block|{
comment|// First, see if we have unused sessions that we were planning to restart; get rid of those.
name|int
name|toTransfer
init|=
name|Math
operator|.
name|min
argument_list|(
operator|-
name|deltaSessions
argument_list|,
name|syncWork
operator|.
name|toRestartInUse
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|toTransfer
condition|;
operator|++
name|i
control|)
block|{
name|syncWork
operator|.
name|toDestroyNoRestart
operator|.
name|add
argument_list|(
name|syncWork
operator|.
name|toRestartInUse
operator|.
name|pollFirst
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|deltaSessions
operator|+=
name|toTransfer
expr_stmt|;
block|}
if|if
condition|(
name|deltaSessions
operator|!=
literal|0
condition|)
block|{
name|failOnFutureFailure
argument_list|(
name|tezAmPool
operator|.
name|resizeAsync
argument_list|(
name|deltaSessions
argument_list|,
name|syncWork
operator|.
name|toDestroyNoRestart
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
specifier|private
name|void
name|failOnFutureFailure
parameter_list|(
name|ListenableFuture
argument_list|<
name|?
argument_list|>
name|future
parameter_list|)
block|{
name|Futures
operator|.
name|addCallback
argument_list|(
name|future
argument_list|,
name|FATAL_ERROR_CALLBACK
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|queueGetRequestOnMasterThread
parameter_list|(
name|GetRequest
name|req
parameter_list|,
name|HashSet
argument_list|<
name|String
argument_list|>
name|poolsToRedistribute
parameter_list|,
name|WmThreadSyncWork
name|syncWork
parameter_list|)
block|{
name|String
name|poolName
init|=
name|userPoolMapping
operator|.
name|mapSessionToPoolName
argument_list|(
name|req
operator|.
name|mappingInput
argument_list|)
decl_stmt|;
if|if
condition|(
name|poolName
operator|==
literal|null
condition|)
block|{
name|req
operator|.
name|future
operator|.
name|setException
argument_list|(
operator|new
name|NoPoolMappingException
argument_list|(
literal|"Cannot find any pool mapping for "
operator|+
name|req
operator|.
name|mappingInput
argument_list|)
argument_list|)
expr_stmt|;
name|returnSessionOnFailedReuse
argument_list|(
name|req
argument_list|,
name|syncWork
argument_list|,
name|poolsToRedistribute
argument_list|)
expr_stmt|;
return|return;
block|}
name|PoolState
name|pool
init|=
name|pools
operator|.
name|get
argument_list|(
name|poolName
argument_list|)
decl_stmt|;
if|if
condition|(
name|pool
operator|==
literal|null
condition|)
block|{
name|req
operator|.
name|future
operator|.
name|setException
argument_list|(
operator|new
name|AssertionError
argument_list|(
name|poolName
operator|+
literal|" not found (internal error)."
argument_list|)
argument_list|)
expr_stmt|;
name|returnSessionOnFailedReuse
argument_list|(
name|req
argument_list|,
name|syncWork
argument_list|,
name|poolsToRedistribute
argument_list|)
expr_stmt|;
return|return;
block|}
name|PoolState
name|oldPool
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|req
operator|.
name|sessionToReuse
operator|!=
literal|null
condition|)
block|{
comment|// Given that we are trying to reuse, this session MUST be in some pool.sessions.
comment|// Kills that could have removed it must have cleared sessionToReuse.
name|String
name|oldPoolName
init|=
name|req
operator|.
name|sessionToReuse
operator|.
name|getPoolName
argument_list|()
decl_stmt|;
name|oldPool
operator|=
name|pools
operator|.
name|get
argument_list|(
name|oldPoolName
argument_list|)
expr_stmt|;
name|Boolean
name|isRemoved
init|=
name|checkAndRemoveSessionFromItsPool
argument_list|(
name|req
operator|.
name|sessionToReuse
argument_list|,
name|poolsToRedistribute
argument_list|)
decl_stmt|;
if|if
condition|(
name|isRemoved
operator|==
literal|null
operator|||
operator|!
name|isRemoved
condition|)
block|{
comment|// This is probably an internal error... abandon the reuse attempt.
name|returnSessionOnFailedReuse
argument_list|(
name|req
argument_list|,
name|syncWork
argument_list|,
literal|null
argument_list|)
expr_stmt|;
name|req
operator|.
name|sessionToReuse
operator|=
literal|null
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|pool
operator|.
name|getTotalActiveSessions
argument_list|()
operator|+
name|pool
operator|.
name|queue
operator|.
name|size
argument_list|()
operator|>=
name|pool
operator|.
name|queryParallelism
condition|)
block|{
comment|// One cannot simply reuse the session if there are other queries waiting; to maintain
comment|// fairness, we'll try to take a query slot instantly, and if that fails we'll return
comment|// this session back to the pool and give the user a new session later.
name|returnSessionOnFailedReuse
argument_list|(
name|req
argument_list|,
name|syncWork
argument_list|,
literal|null
argument_list|)
expr_stmt|;
name|req
operator|.
name|sessionToReuse
operator|=
literal|null
expr_stmt|;
block|}
block|}
if|if
condition|(
name|req
operator|.
name|sessionToReuse
operator|!=
literal|null
condition|)
block|{
comment|// If we can immediately reuse a session, there's nothing to wait for - just return.
name|req
operator|.
name|sessionToReuse
operator|.
name|setPoolName
argument_list|(
name|poolName
argument_list|)
expr_stmt|;
name|req
operator|.
name|sessionToReuse
operator|.
name|setQueueName
argument_list|(
name|yarnQueue
argument_list|)
expr_stmt|;
name|pool
operator|.
name|sessions
operator|.
name|add
argument_list|(
name|req
operator|.
name|sessionToReuse
argument_list|)
expr_stmt|;
if|if
condition|(
name|pool
operator|!=
name|oldPool
condition|)
block|{
name|poolsToRedistribute
operator|.
name|add
argument_list|(
name|poolName
argument_list|)
expr_stmt|;
block|}
name|req
operator|.
name|future
operator|.
name|set
argument_list|(
name|req
operator|.
name|sessionToReuse
argument_list|)
expr_stmt|;
return|return;
block|}
comment|// Otherwise, queue the session and make sure we update this pool.
name|pool
operator|.
name|queue
operator|.
name|addLast
argument_list|(
name|req
argument_list|)
expr_stmt|;
name|poolsToRedistribute
operator|.
name|add
argument_list|(
name|poolName
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|processPoolChangesOnMasterThread
parameter_list|(
name|String
name|poolName
parameter_list|,
name|WmThreadSyncWork
name|context
parameter_list|,
name|boolean
name|hasRequeues
parameter_list|)
throws|throws
name|Exception
block|{
name|PoolState
name|pool
init|=
name|pools
operator|.
name|get
argument_list|(
name|poolName
argument_list|)
decl_stmt|;
if|if
condition|(
name|pool
operator|==
literal|null
condition|)
return|return;
comment|// Might be from before the new resource plan.
comment|// 1. First, start the queries from the queue.
name|int
name|queriesToStart
init|=
name|Math
operator|.
name|min
argument_list|(
name|pool
operator|.
name|queue
operator|.
name|size
argument_list|()
argument_list|,
name|pool
operator|.
name|queryParallelism
operator|-
name|pool
operator|.
name|getTotalActiveSessions
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|queriesToStart
operator|>
literal|0
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Starting {} queries in pool {}"
argument_list|,
name|queriesToStart
argument_list|,
name|pool
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|hasRequeues
condition|)
block|{
comment|// Sort the queue - we may have put items here out of order.
name|Collections
operator|.
name|sort
argument_list|(
name|pool
operator|.
name|queue
argument_list|,
name|GetRequest
operator|.
name|ORDER_COMPARATOR
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|queriesToStart
condition|;
operator|++
name|i
control|)
block|{
name|GetRequest
name|queueReq
init|=
name|pool
operator|.
name|queue
operator|.
name|pollFirst
argument_list|()
decl_stmt|;
assert|assert
name|queueReq
operator|.
name|sessionToReuse
operator|==
literal|null
assert|;
comment|// Note that in theory, we are guaranteed to have a session waiting for us here, but
comment|// the expiration, failures, etc. may cause one to be missing pending restart.
comment|// See SessionInitContext javadoc.
name|SessionInitContext
name|sw
init|=
operator|new
name|SessionInitContext
argument_list|(
name|queueReq
operator|.
name|future
argument_list|,
name|poolName
argument_list|)
decl_stmt|;
name|ListenableFuture
argument_list|<
name|WmTezSession
argument_list|>
name|getFuture
init|=
name|tezAmPool
operator|.
name|getSessionAsync
argument_list|()
decl_stmt|;
name|Futures
operator|.
name|addCallback
argument_list|(
name|getFuture
argument_list|,
name|sw
argument_list|)
expr_stmt|;
comment|// It is possible that all the async methods returned on the same thread because the
comment|// session with registry data and stuff was available in the pool.
comment|// If this happens, we'll take the session out here and "cancel" the init so we skip
comment|// processing the message that the successful init has queued for us.
name|boolean
name|isDone
init|=
name|sw
operator|.
name|extractSessionAndCancelIfDone
argument_list|(
name|pool
operator|.
name|sessions
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|isDone
condition|)
block|{
name|pool
operator|.
name|initializingSessions
operator|.
name|add
argument_list|(
name|sw
argument_list|)
expr_stmt|;
block|}
comment|// The user has already been notified of completion by SessionInitContext.
block|}
comment|// 2. Then, update pool allocations.
name|double
name|totalAlloc
init|=
name|pool
operator|.
name|updateAllocationPercentages
argument_list|()
decl_stmt|;
comment|// We are calling this here because we expect the method to be completely async. We also don't
comment|// want this call itself to go on a thread because we want the percent-to-physics conversion
comment|// logic to be consistent between all the separate calls in one master thread processing round.
comment|// Note: If allocation manager does not have cluster state, it won't update anything. When the
comment|//       cluster state changes, it will notify us, and we'd update the queries again.
name|allocationManager
operator|.
name|updateSessionsAsync
argument_list|(
name|totalAlloc
argument_list|,
name|pool
operator|.
name|sessions
argument_list|)
expr_stmt|;
comment|// 3. Update triggers for this pool.
comment|//    TODO: need to merge with per-pool enforcement, it will only work for one pool for now.
if|if
condition|(
name|sessionTriggerProvider
operator|!=
literal|null
condition|)
block|{
name|sessionTriggerProvider
operator|.
name|setOpenSessions
argument_list|(
name|Collections
operator|.
expr|<
name|TezSessionState
operator|>
name|unmodifiableList
argument_list|(
name|pool
operator|.
name|sessions
argument_list|)
argument_list|)
expr_stmt|;
name|sessionTriggerProvider
operator|.
name|setActiveTriggers
argument_list|(
name|Collections
operator|.
name|unmodifiableList
argument_list|(
name|pool
operator|.
name|triggers
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|returnSessionOnFailedReuse
parameter_list|(
name|GetRequest
name|req
parameter_list|,
name|WmThreadSyncWork
name|syncWork
parameter_list|,
name|HashSet
argument_list|<
name|String
argument_list|>
name|poolsToRedistribute
parameter_list|)
block|{
if|if
condition|(
name|req
operator|.
name|sessionToReuse
operator|==
literal|null
condition|)
return|return;
if|if
condition|(
name|poolsToRedistribute
operator|!=
literal|null
condition|)
block|{
name|Boolean
name|isRemoved
init|=
name|checkAndRemoveSessionFromItsPool
argument_list|(
name|req
operator|.
name|sessionToReuse
argument_list|,
name|poolsToRedistribute
argument_list|)
decl_stmt|;
comment|// The session cannot have been killed; this happens after all the kills in the current
comment|// iteration, so we would have cleared sessionToReuse when killing this.
assert|assert
name|isRemoved
operator|==
literal|null
operator|||
name|isRemoved
assert|;
block|}
if|if
condition|(
operator|!
name|tezAmPool
operator|.
name|returnSessionAsync
argument_list|(
name|req
operator|.
name|sessionToReuse
argument_list|)
condition|)
block|{
name|syncWork
operator|.
name|toDestroyNoRestart
operator|.
name|add
argument_list|(
name|req
operator|.
name|sessionToReuse
argument_list|)
expr_stmt|;
block|}
name|req
operator|.
name|sessionToReuse
operator|=
literal|null
expr_stmt|;
block|}
comment|/**    * Checks if the session is still relevant for WM and if yes, removes it from its thread.    * @return true if the session was removed; false if the session was already processed by WM    *         thread (so we are dealing with an outdated request); null if the session should be    *         in WM but wasn't found in the requisite pool (internal error?).    */
specifier|private
name|Boolean
name|checkAndRemoveSessionFromItsPool
parameter_list|(
name|WmTezSession
name|session
parameter_list|,
name|HashSet
argument_list|<
name|String
argument_list|>
name|poolsToRedistribute
parameter_list|)
block|{
comment|// It is possible for some request to be queued after a main thread has decided to kill this
comment|// session; on the next iteration, we'd be processing that request with an irrelevant session.
if|if
condition|(
name|session
operator|.
name|isIrrelevantForWm
argument_list|()
condition|)
block|{
return|return
literal|false
return|;
block|}
comment|// If we did not kill this session we expect everything to be present.
name|String
name|poolName
init|=
name|session
operator|.
name|getPoolName
argument_list|()
decl_stmt|;
name|session
operator|.
name|clearWm
argument_list|()
expr_stmt|;
if|if
condition|(
name|poolName
operator|!=
literal|null
condition|)
block|{
name|poolsToRedistribute
operator|.
name|add
argument_list|(
name|poolName
argument_list|)
expr_stmt|;
name|PoolState
name|pool
init|=
name|pools
operator|.
name|get
argument_list|(
name|poolName
argument_list|)
decl_stmt|;
if|if
condition|(
name|pool
operator|!=
literal|null
operator|&&
name|pool
operator|.
name|sessions
operator|.
name|remove
argument_list|(
name|session
argument_list|)
condition|)
return|return
literal|true
return|;
block|}
name|LOG
operator|.
name|error
argument_list|(
literal|"Session was not in the pool (internal error) "
operator|+
name|poolName
operator|+
literal|": "
operator|+
name|session
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
comment|// ===== EVENT METHODS
specifier|public
name|ListenableFuture
argument_list|<
name|Boolean
argument_list|>
name|updateResourcePlanAsync
parameter_list|(
name|WMFullResourcePlan
name|plan
parameter_list|)
block|{
name|SettableFuture
argument_list|<
name|Boolean
argument_list|>
name|applyRpFuture
init|=
name|SettableFuture
operator|.
name|create
argument_list|()
decl_stmt|;
name|currentLock
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
comment|// TODO: if there's versioning/etc., it will come in here. For now we rely on external
comment|//       locking or ordering of calls. This should potentially return a Future for that.
if|if
condition|(
name|current
operator|.
name|resourcePlanToApply
operator|!=
literal|null
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Several resource plans are being applied at the same time; using the latest"
argument_list|)
expr_stmt|;
name|current
operator|.
name|applyRpFuture
operator|.
name|setException
argument_list|(
operator|new
name|HiveException
argument_list|(
literal|"Another plan was applied in parallel"
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|current
operator|.
name|resourcePlanToApply
operator|=
name|plan
expr_stmt|;
name|current
operator|.
name|applyRpFuture
operator|=
name|applyRpFuture
expr_stmt|;
name|notifyWmThreadUnderLock
argument_list|()
expr_stmt|;
block|}
finally|finally
block|{
name|currentLock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
return|return
name|applyRpFuture
return|;
block|}
specifier|private
specifier|final
specifier|static
class|class
name|GetRequest
block|{
specifier|public
specifier|static
specifier|final
name|Comparator
argument_list|<
name|GetRequest
argument_list|>
name|ORDER_COMPARATOR
init|=
operator|new
name|Comparator
argument_list|<
name|GetRequest
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|int
name|compare
parameter_list|(
name|GetRequest
name|o1
parameter_list|,
name|GetRequest
name|o2
parameter_list|)
block|{
if|if
condition|(
name|o1
operator|.
name|order
operator|==
name|o2
operator|.
name|order
condition|)
return|return
literal|0
return|;
return|return
name|o1
operator|.
name|order
operator|<
name|o2
operator|.
name|order
condition|?
operator|-
literal|1
else|:
literal|1
return|;
block|}
block|}
decl_stmt|;
specifier|private
specifier|final
name|long
name|order
decl_stmt|;
specifier|private
specifier|final
name|MappingInput
name|mappingInput
decl_stmt|;
specifier|private
specifier|final
name|SettableFuture
argument_list|<
name|WmTezSession
argument_list|>
name|future
decl_stmt|;
specifier|private
name|WmTezSession
name|sessionToReuse
decl_stmt|;
specifier|private
name|GetRequest
parameter_list|(
name|MappingInput
name|mappingInput
parameter_list|,
name|SettableFuture
argument_list|<
name|WmTezSession
argument_list|>
name|future
parameter_list|,
name|WmTezSession
name|sessionToReuse
parameter_list|,
name|long
name|order
parameter_list|)
block|{
assert|assert
name|mappingInput
operator|!=
literal|null
assert|;
name|this
operator|.
name|mappingInput
operator|=
name|mappingInput
expr_stmt|;
name|this
operator|.
name|future
operator|=
name|future
expr_stmt|;
name|this
operator|.
name|sessionToReuse
operator|=
name|sessionToReuse
expr_stmt|;
name|this
operator|.
name|order
operator|=
name|order
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
literal|"[#"
operator|+
name|order
operator|+
literal|", "
operator|+
name|mappingInput
operator|+
literal|", reuse "
operator|+
name|sessionToReuse
operator|+
literal|"]"
return|;
block|}
block|}
specifier|public
name|TezSessionState
name|getSession
parameter_list|(
name|TezSessionState
name|session
parameter_list|,
name|MappingInput
name|input
parameter_list|,
name|HiveConf
name|conf
parameter_list|)
throws|throws
name|Exception
block|{
comment|// Note: not actually used for pool sessions; verify some things like doAs are not set.
name|validateConfig
argument_list|(
name|conf
argument_list|)
expr_stmt|;
name|SettableFuture
argument_list|<
name|WmTezSession
argument_list|>
name|future
init|=
name|SettableFuture
operator|.
name|create
argument_list|()
decl_stmt|;
name|WmTezSession
name|wmSession
init|=
name|checkSessionForReuse
argument_list|(
name|session
argument_list|)
decl_stmt|;
name|GetRequest
name|req
init|=
operator|new
name|GetRequest
argument_list|(
name|input
argument_list|,
name|future
argument_list|,
name|wmSession
argument_list|,
name|getRequestVersion
operator|.
name|incrementAndGet
argument_list|()
argument_list|)
decl_stmt|;
name|currentLock
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
name|current
operator|.
name|getRequests
operator|.
name|add
argument_list|(
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|req
operator|.
name|sessionToReuse
operator|!=
literal|null
condition|)
block|{
comment|// Note: we assume reuse is only possible for the same user and config.
name|current
operator|.
name|toReuse
operator|.
name|put
argument_list|(
name|wmSession
argument_list|,
name|req
argument_list|)
expr_stmt|;
block|}
name|notifyWmThreadUnderLock
argument_list|()
expr_stmt|;
block|}
finally|finally
block|{
name|currentLock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
return|return
name|future
operator|.
name|get
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|destroy
parameter_list|(
name|TezSessionState
name|session
parameter_list|)
throws|throws
name|Exception
block|{
name|WmTezSession
name|wmTezSession
init|=
name|ensureOwnedSession
argument_list|(
name|session
argument_list|)
decl_stmt|;
name|resetGlobalTezSession
argument_list|(
name|wmTezSession
argument_list|)
expr_stmt|;
name|currentLock
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
name|current
operator|.
name|toDestroy
operator|.
name|add
argument_list|(
name|wmTezSession
argument_list|)
expr_stmt|;
name|notifyWmThreadUnderLock
argument_list|()
expr_stmt|;
block|}
finally|finally
block|{
name|currentLock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|resetGlobalTezSession
parameter_list|(
name|WmTezSession
name|wmTezSession
parameter_list|)
block|{
comment|// This has to be done synchronously to avoid the caller getting this session again.
comment|// Ideally we'd get rid of this thread-local nonsense.
name|SessionState
name|sessionState
init|=
name|SessionState
operator|.
name|get
argument_list|()
decl_stmt|;
if|if
condition|(
name|sessionState
operator|!=
literal|null
operator|&&
name|sessionState
operator|.
name|getTezSession
argument_list|()
operator|==
name|wmTezSession
condition|)
block|{
name|sessionState
operator|.
name|setTezSession
argument_list|(
literal|null
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|void
name|returnAfterUse
parameter_list|(
name|TezSessionPoolSession
name|session
parameter_list|)
throws|throws
name|Exception
block|{
name|WmTezSession
name|wmTezSession
init|=
name|ensureOwnedSession
argument_list|(
name|session
argument_list|)
decl_stmt|;
name|resetGlobalTezSession
argument_list|(
name|wmTezSession
argument_list|)
expr_stmt|;
name|currentLock
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
name|current
operator|.
name|toReturn
operator|.
name|add
argument_list|(
name|wmTezSession
argument_list|)
expr_stmt|;
name|notifyWmThreadUnderLock
argument_list|()
expr_stmt|;
block|}
finally|finally
block|{
name|currentLock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|// TODO: use this
specifier|public
name|void
name|nofityOfClusterStateChange
parameter_list|()
block|{
name|currentLock
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
name|current
operator|.
name|hasClusterStateChanged
operator|=
literal|true
expr_stmt|;
name|notifyWmThreadUnderLock
argument_list|()
expr_stmt|;
block|}
finally|finally
block|{
name|currentLock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
specifier|public
name|void
name|addUpdateError
parameter_list|(
name|WmTezSession
name|wmTezSession
parameter_list|)
block|{
name|currentLock
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
name|current
operator|.
name|updateErrors
operator|.
name|add
argument_list|(
name|wmTezSession
argument_list|)
expr_stmt|;
name|notifyWmThreadUnderLock
argument_list|()
expr_stmt|;
block|}
finally|finally
block|{
name|currentLock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
annotation|@
name|VisibleForTesting
comment|/**    * Adds a test event that's processed at the end of WM iteration.    * This allows tests to wait for an iteration to finish without messing with the threading    * logic (that is prone to races if we e.g. remember the state before and wait for it to change,    * self-deadlocking when triggering things explicitly and calling a blocking API, and hanging    * forever if we wait for "another iteration"). If addTestEvent is called after all the other    * calls of interest, it is guaranteed that the events from those calls will be processed    * fully when the future is triggered.    */
name|Future
argument_list|<
name|Boolean
argument_list|>
name|addTestEvent
parameter_list|()
block|{
name|SettableFuture
argument_list|<
name|Boolean
argument_list|>
name|testEvent
init|=
name|SettableFuture
operator|.
name|create
argument_list|()
decl_stmt|;
name|currentLock
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
name|current
operator|.
name|testEvent
operator|=
name|testEvent
expr_stmt|;
name|notifyWmThreadUnderLock
argument_list|()
expr_stmt|;
block|}
finally|finally
block|{
name|currentLock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
return|return
name|testEvent
return|;
block|}
specifier|public
name|void
name|notifyInitializationCompleted
parameter_list|(
name|SessionInitContext
name|initCtx
parameter_list|)
block|{
name|currentLock
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
name|current
operator|.
name|initResults
operator|.
name|add
argument_list|(
name|initCtx
argument_list|)
expr_stmt|;
name|notifyWmThreadUnderLock
argument_list|()
expr_stmt|;
block|}
finally|finally
block|{
name|currentLock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|TezSessionState
name|reopen
parameter_list|(
name|TezSessionState
name|session
parameter_list|,
name|Configuration
name|conf
parameter_list|,
name|String
index|[]
name|additionalFiles
parameter_list|)
throws|throws
name|Exception
block|{
name|WmTezSession
name|wmTezSession
init|=
name|ensureOwnedSession
argument_list|(
name|session
argument_list|)
decl_stmt|;
name|HiveConf
name|sessionConf
init|=
name|wmTezSession
operator|.
name|getConf
argument_list|()
decl_stmt|;
if|if
condition|(
name|sessionConf
operator|==
literal|null
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Session configuration is null for "
operator|+
name|wmTezSession
argument_list|)
expr_stmt|;
name|sessionConf
operator|=
operator|new
name|HiveConf
argument_list|(
name|conf
argument_list|,
name|WorkloadManager
operator|.
name|class
argument_list|)
expr_stmt|;
block|}
comment|// TODO: ideally, we should handle reopen the same way no matter what. However, the cases
comment|//       with additional files will have to wait until HIVE-17827 is unfucked, because it's
comment|//       difficult to determine how the additionalFiles are to be propagated/reused between
comment|//       two sessions. Once the update logic is encapsulated in the session we can remove this.
if|if
condition|(
name|additionalFiles
operator|!=
literal|null
operator|&&
name|additionalFiles
operator|.
name|length
operator|>
literal|0
condition|)
block|{
name|TezSessionPoolManager
operator|.
name|reopenInternal
argument_list|(
name|session
argument_list|,
name|additionalFiles
argument_list|)
expr_stmt|;
return|return
name|session
return|;
block|}
name|SettableFuture
argument_list|<
name|WmTezSession
argument_list|>
name|future
init|=
name|SettableFuture
operator|.
name|create
argument_list|()
decl_stmt|;
name|currentLock
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
if|if
condition|(
name|current
operator|.
name|toReopen
operator|.
name|containsKey
argument_list|(
name|wmTezSession
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|AssertionError
argument_list|(
literal|"The session is being reopened more than once "
operator|+
name|session
argument_list|)
throw|;
block|}
name|current
operator|.
name|toReopen
operator|.
name|put
argument_list|(
name|wmTezSession
argument_list|,
name|future
argument_list|)
expr_stmt|;
name|notifyWmThreadUnderLock
argument_list|()
expr_stmt|;
block|}
finally|finally
block|{
name|currentLock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
return|return
name|future
operator|.
name|get
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|closeAndReopenExpiredSession
parameter_list|(
name|TezSessionPoolSession
name|session
parameter_list|)
throws|throws
name|Exception
block|{
comment|// By definition, this session is not in use and can no longer be in use, so it only
comment|// affects the session pool. We can handle this inline.
name|tezAmPool
operator|.
name|replaceSession
argument_list|(
name|ensureOwnedSession
argument_list|(
name|session
argument_list|)
argument_list|,
literal|false
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
comment|// ======= VARIOUS UTILITY METHOD
specifier|private
name|void
name|notifyWmThreadUnderLock
parameter_list|()
block|{
if|if
condition|(
name|hasChanges
condition|)
return|return;
name|hasChanges
operator|=
literal|true
expr_stmt|;
name|hasChangesCondition
operator|.
name|signalAll
argument_list|()
expr_stmt|;
block|}
specifier|private
name|WmTezSession
name|checkSessionForReuse
parameter_list|(
name|TezSessionState
name|session
parameter_list|)
throws|throws
name|Exception
block|{
if|if
condition|(
name|session
operator|==
literal|null
condition|)
return|return
literal|null
return|;
name|WmTezSession
name|result
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|session
operator|instanceof
name|WmTezSession
condition|)
block|{
name|result
operator|=
operator|(
name|WmTezSession
operator|)
name|session
expr_stmt|;
if|if
condition|(
name|result
operator|.
name|isOwnedBy
argument_list|(
name|this
argument_list|)
condition|)
block|{
return|return
name|result
return|;
block|}
comment|// This should never happen, at least for now. Throw?
name|LOG
operator|.
name|warn
argument_list|(
literal|"Attempting to reuse a session not belonging to us: "
operator|+
name|result
argument_list|)
expr_stmt|;
name|result
operator|.
name|returnToSessionManager
argument_list|()
expr_stmt|;
return|return
literal|null
return|;
block|}
name|LOG
operator|.
name|warn
argument_list|(
literal|"Attempting to reuse a non-WM session for workload management:"
operator|+
name|session
argument_list|)
expr_stmt|;
if|if
condition|(
name|session
operator|instanceof
name|TezSessionPoolSession
condition|)
block|{
name|session
operator|.
name|returnToSessionManager
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|session
operator|.
name|close
argument_list|(
literal|false
argument_list|)
expr_stmt|;
comment|// This is a non-pool session, get rid of it.
block|}
return|return
literal|null
return|;
block|}
specifier|private
name|void
name|validateConfig
parameter_list|(
name|HiveConf
name|conf
parameter_list|)
throws|throws
name|HiveException
block|{
name|String
name|queueName
init|=
name|conf
operator|.
name|get
argument_list|(
name|TezConfiguration
operator|.
name|TEZ_QUEUE_NAME
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|queueName
operator|!=
literal|null
operator|)
operator|&&
operator|!
name|queueName
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Ignoring "
operator|+
name|TezConfiguration
operator|.
name|TEZ_QUEUE_NAME
operator|+
literal|"="
operator|+
name|queueName
argument_list|)
expr_stmt|;
name|conf
operator|.
name|set
argument_list|(
name|TezConfiguration
operator|.
name|TEZ_QUEUE_NAME
argument_list|,
name|yarnQueue
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|conf
operator|.
name|getBoolVar
argument_list|(
name|ConfVars
operator|.
name|HIVE_SERVER2_ENABLE_DOAS
argument_list|)
condition|)
block|{
comment|// Should this also just be ignored? Throw for now, doAs unlike queue is often set by admin.
throw|throw
operator|new
name|HiveException
argument_list|(
name|ConfVars
operator|.
name|HIVE_SERVER2_ENABLE_DOAS
operator|.
name|varname
operator|+
literal|" is not supported"
argument_list|)
throw|;
block|}
if|if
condition|(
name|restrictedConfig
operator|!=
literal|null
condition|)
block|{
name|restrictedConfig
operator|.
name|validate
argument_list|(
name|conf
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
name|WmTezSession
name|createSession
parameter_list|(
name|HiveConf
name|conf
parameter_list|)
block|{
name|WmTezSession
name|session
init|=
name|createSessionObject
argument_list|(
name|TezSessionState
operator|.
name|makeSessionId
argument_list|()
argument_list|,
name|conf
argument_list|)
decl_stmt|;
name|session
operator|.
name|setQueueName
argument_list|(
name|yarnQueue
argument_list|)
expr_stmt|;
name|session
operator|.
name|setDefault
argument_list|()
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Created new interactive session object "
operator|+
name|session
operator|.
name|getSessionId
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|session
return|;
block|}
annotation|@
name|VisibleForTesting
specifier|protected
name|WmTezSession
name|createSessionObject
parameter_list|(
name|String
name|sessionId
parameter_list|,
name|HiveConf
name|conf
parameter_list|)
block|{
name|conf
operator|=
operator|(
name|conf
operator|==
literal|null
operator|)
condition|?
operator|new
name|HiveConf
argument_list|(
name|this
operator|.
name|conf
argument_list|)
else|:
name|conf
expr_stmt|;
return|return
operator|new
name|WmTezSession
argument_list|(
name|sessionId
argument_list|,
name|this
argument_list|,
name|expirationTracker
argument_list|,
name|conf
argument_list|)
return|;
block|}
specifier|private
name|WmTezSession
name|ensureOwnedSession
parameter_list|(
name|TezSessionState
name|oldSession
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|oldSession
operator|instanceof
name|WmTezSession
operator|)
operator|||
operator|!
operator|(
operator|(
name|WmTezSession
operator|)
name|oldSession
operator|)
operator|.
name|isOwnedBy
argument_list|(
name|this
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|AssertionError
argument_list|(
literal|"Not a WM session "
operator|+
name|oldSession
argument_list|)
throw|;
block|}
name|WmTezSession
name|session
init|=
operator|(
name|WmTezSession
operator|)
name|oldSession
decl_stmt|;
return|return
name|session
return|;
block|}
comment|/** Called by TezSessionPoolSession when opened. */
annotation|@
name|Override
specifier|public
name|void
name|registerOpenSession
parameter_list|(
name|TezSessionPoolSession
name|session
parameter_list|)
block|{
synchronized|synchronized
init|(
name|openSessions
init|)
block|{
name|openSessions
operator|.
name|put
argument_list|(
name|session
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
block|}
comment|/** Called by TezSessionPoolSession when closed. */
annotation|@
name|Override
specifier|public
name|void
name|unregisterOpenSession
parameter_list|(
name|TezSessionPoolSession
name|session
parameter_list|)
block|{
synchronized|synchronized
init|(
name|openSessions
init|)
block|{
name|openSessions
operator|.
name|remove
argument_list|(
name|session
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|VisibleForTesting
specifier|public
name|SessionExpirationTracker
name|getExpirationTracker
parameter_list|()
block|{
return|return
name|expirationTracker
return|;
block|}
annotation|@
name|VisibleForTesting
name|int
name|getNumSessions
parameter_list|()
block|{
return|return
name|tezAmPool
operator|.
name|getInitialSize
argument_list|()
return|;
block|}
specifier|protected
specifier|final
name|HiveConf
name|getConf
parameter_list|()
block|{
return|return
name|conf
return|;
block|}
specifier|public
name|List
argument_list|<
name|String
argument_list|>
name|getTriggerCounterNames
parameter_list|()
block|{
name|List
argument_list|<
name|Trigger
argument_list|>
name|activeTriggers
init|=
name|sessionTriggerProvider
operator|.
name|getActiveTriggers
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|counterNames
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|Trigger
name|trigger
range|:
name|activeTriggers
control|)
block|{
name|counterNames
operator|.
name|add
argument_list|(
name|trigger
operator|.
name|getExpression
argument_list|()
operator|.
name|getCounterLimit
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|counterNames
return|;
block|}
annotation|@
name|Override
name|SessionTriggerProvider
name|getSessionTriggerProvider
parameter_list|()
block|{
return|return
name|sessionTriggerProvider
return|;
block|}
annotation|@
name|Override
name|TriggerActionHandler
name|getTriggerActionHandler
parameter_list|()
block|{
return|return
name|triggerActionHandler
return|;
block|}
annotation|@
name|Override
name|TriggerValidatorRunnable
name|getTriggerValidatorRunnable
parameter_list|()
block|{
return|return
name|triggerValidatorRunnable
return|;
block|}
comment|/**    * State of a single pool.    * Unless otherwise specified, the members are only modified by the master thread.    */
specifier|private
specifier|static
class|class
name|PoolState
block|{
comment|// Add stuff here as WM is implemented.
specifier|private
specifier|final
name|LinkedList
argument_list|<
name|SessionInitContext
argument_list|>
name|initializingSessions
init|=
operator|new
name|LinkedList
argument_list|<>
argument_list|()
decl_stmt|;
comment|// Note: the list is expected to be a few items; if it's longer we may want an IHM.
specifier|private
specifier|final
name|LinkedList
argument_list|<
name|WmTezSession
argument_list|>
name|sessions
init|=
operator|new
name|LinkedList
argument_list|<>
argument_list|()
decl_stmt|;
specifier|private
specifier|final
name|LinkedList
argument_list|<
name|GetRequest
argument_list|>
name|queue
init|=
operator|new
name|LinkedList
argument_list|<>
argument_list|()
decl_stmt|;
specifier|private
specifier|final
name|String
name|fullName
decl_stmt|;
specifier|private
name|double
name|finalFraction
decl_stmt|;
specifier|private
name|double
name|finalFractionRemaining
decl_stmt|;
specifier|private
name|int
name|queryParallelism
init|=
operator|-
literal|1
decl_stmt|;
specifier|private
name|List
argument_list|<
name|Trigger
argument_list|>
name|triggers
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
specifier|public
name|PoolState
parameter_list|(
name|String
name|fullName
parameter_list|,
name|int
name|queryParallelism
parameter_list|,
name|double
name|fraction
parameter_list|)
block|{
name|this
operator|.
name|fullName
operator|=
name|fullName
expr_stmt|;
name|update
argument_list|(
name|queryParallelism
argument_list|,
name|fraction
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
specifier|public
name|int
name|getTotalActiveSessions
parameter_list|()
block|{
return|return
name|sessions
operator|.
name|size
argument_list|()
operator|+
name|initializingSessions
operator|.
name|size
argument_list|()
return|;
block|}
specifier|public
name|void
name|update
parameter_list|(
name|int
name|queryParallelism
parameter_list|,
name|double
name|fraction
parameter_list|,
name|List
argument_list|<
name|WmTezSession
argument_list|>
name|toKill
parameter_list|,
name|EventState
name|e
parameter_list|)
block|{
name|this
operator|.
name|finalFraction
operator|=
name|this
operator|.
name|finalFractionRemaining
operator|=
name|fraction
expr_stmt|;
name|this
operator|.
name|queryParallelism
operator|=
name|queryParallelism
expr_stmt|;
comment|// TODO: two possible improvements
comment|//       1) Right now we kill all the queries here; we could just kill -qpDelta.
comment|//       2) After the queries are killed queued queries would take their place.
comment|//          If we could somehow restart queries we could instead put them at the front
comment|//          of the queue (esp. in conjunction with (1)) and rerun them.
if|if
condition|(
name|queryParallelism
operator|<
name|getTotalActiveSessions
argument_list|()
condition|)
block|{
name|extractAllSessionsToKill
argument_list|(
literal|"The query pool was resized by administrator"
argument_list|,
name|e
operator|.
name|toReuse
argument_list|,
name|toKill
argument_list|)
expr_stmt|;
block|}
comment|// We will requeue, and not kill, the queries that are not running yet.
comment|// Insert them all before the get requests from this iteration.
name|GetRequest
name|req
decl_stmt|;
while|while
condition|(
operator|(
name|req
operator|=
name|queue
operator|.
name|pollLast
argument_list|()
operator|)
operator|!=
literal|null
condition|)
block|{
name|e
operator|.
name|getRequests
operator|.
name|addFirst
argument_list|(
name|req
argument_list|)
expr_stmt|;
block|}
block|}
specifier|public
name|void
name|destroy
parameter_list|(
name|List
argument_list|<
name|WmTezSession
argument_list|>
name|toKill
parameter_list|,
name|LinkedList
argument_list|<
name|GetRequest
argument_list|>
name|globalQueue
parameter_list|,
name|IdentityHashMap
argument_list|<
name|WmTezSession
argument_list|,
name|GetRequest
argument_list|>
name|toReuse
parameter_list|)
block|{
name|extractAllSessionsToKill
argument_list|(
literal|"The query pool was removed by administrator"
argument_list|,
name|toReuse
argument_list|,
name|toKill
argument_list|)
expr_stmt|;
comment|// All the pending get requests should just be requeued elsewhere.
comment|// Note that we never queue session reuse so sessionToReuse would be null.
name|globalQueue
operator|.
name|addAll
argument_list|(
literal|0
argument_list|,
name|queue
argument_list|)
expr_stmt|;
name|queue
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
specifier|public
name|double
name|updateAllocationPercentages
parameter_list|()
block|{
comment|// TODO: real implementation involving in-the-pool policy interface, etc.
name|double
name|allocation
init|=
name|finalFractionRemaining
operator|/
operator|(
name|sessions
operator|.
name|size
argument_list|()
operator|+
name|initializingSessions
operator|.
name|size
argument_list|()
operator|)
decl_stmt|;
for|for
control|(
name|WmTezSession
name|session
range|:
name|sessions
control|)
block|{
name|session
operator|.
name|setClusterFraction
argument_list|(
name|allocation
argument_list|)
expr_stmt|;
block|}
comment|// Do not give out the capacity of the initializing sessions to the running ones;
comment|// we expect init to be fast.
return|return
name|finalFractionRemaining
operator|-
name|allocation
operator|*
name|initializingSessions
operator|.
name|size
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
literal|"["
operator|+
name|fullName
operator|+
literal|", query parallelism "
operator|+
name|queryParallelism
operator|+
literal|", fraction of the cluster "
operator|+
name|finalFraction
operator|+
literal|", fraction used by child pools "
operator|+
operator|(
name|finalFraction
operator|-
name|finalFractionRemaining
operator|)
operator|+
literal|", active sessions "
operator|+
name|sessions
operator|.
name|size
argument_list|()
operator|+
literal|", initializing sessions "
operator|+
name|initializingSessions
operator|.
name|size
argument_list|()
operator|+
literal|"]"
return|;
block|}
specifier|private
name|void
name|extractAllSessionsToKill
parameter_list|(
name|String
name|killReason
parameter_list|,
name|IdentityHashMap
argument_list|<
name|WmTezSession
argument_list|,
name|GetRequest
argument_list|>
name|toReuse
parameter_list|,
name|List
argument_list|<
name|WmTezSession
argument_list|>
name|toKill
parameter_list|)
block|{
for|for
control|(
name|WmTezSession
name|sessionToKill
range|:
name|sessions
control|)
block|{
name|resetRemovedSession
argument_list|(
name|sessionToKill
argument_list|,
name|killReason
argument_list|,
name|toReuse
argument_list|)
expr_stmt|;
name|toKill
operator|.
name|add
argument_list|(
name|sessionToKill
argument_list|)
expr_stmt|;
block|}
name|sessions
operator|.
name|clear
argument_list|()
expr_stmt|;
for|for
control|(
name|SessionInitContext
name|initCtx
range|:
name|initializingSessions
control|)
block|{
comment|// It is possible that the background init thread has finished in parallel, queued
comment|// the message for us but also returned the session to the user.
name|WmTezSession
name|sessionToKill
init|=
name|initCtx
operator|.
name|cancelAndExtractSessionIfDone
argument_list|(
name|killReason
argument_list|)
decl_stmt|;
if|if
condition|(
name|sessionToKill
operator|==
literal|null
condition|)
block|{
continue|continue;
comment|// Async op in progress; the callback will take care of this.
block|}
name|resetRemovedSession
argument_list|(
name|sessionToKill
argument_list|,
name|killReason
argument_list|,
name|toReuse
argument_list|)
expr_stmt|;
name|toKill
operator|.
name|add
argument_list|(
name|sessionToKill
argument_list|)
expr_stmt|;
block|}
name|initializingSessions
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
specifier|private
name|void
name|resetRemovedSession
parameter_list|(
name|WmTezSession
name|sessionToKill
parameter_list|,
name|String
name|killReason
parameter_list|,
name|IdentityHashMap
argument_list|<
name|WmTezSession
argument_list|,
name|GetRequest
argument_list|>
name|toReuse
parameter_list|)
block|{
assert|assert
name|killReason
operator|!=
literal|null
assert|;
name|sessionToKill
operator|.
name|setIsIrrelevantForWm
argument_list|(
name|killReason
argument_list|)
expr_stmt|;
name|sessionToKill
operator|.
name|clearWm
argument_list|()
expr_stmt|;
name|GetRequest
name|req
init|=
name|toReuse
operator|.
name|remove
argument_list|(
name|sessionToKill
argument_list|)
decl_stmt|;
if|if
condition|(
name|req
operator|!=
literal|null
condition|)
block|{
name|req
operator|.
name|sessionToReuse
operator|=
literal|null
expr_stmt|;
block|}
block|}
specifier|public
name|void
name|setTriggers
parameter_list|(
specifier|final
name|LinkedList
argument_list|<
name|Trigger
argument_list|>
name|triggers
parameter_list|)
block|{
name|this
operator|.
name|triggers
operator|=
name|triggers
expr_stmt|;
block|}
specifier|public
name|List
argument_list|<
name|Trigger
argument_list|>
name|getTriggers
parameter_list|()
block|{
return|return
name|triggers
return|;
block|}
block|}
specifier|private
enum|enum
name|SessionInitState
block|{
name|GETTING
block|,
comment|// We are getting a session from TezSessionPool
name|WAITING_FOR_REGISTRY
block|,
comment|// We have the session but it doesn't have registry info yet.
name|DONE
block|,
comment|// We have the session with registry info, or we have failed.
name|CANCELED
comment|// The master thread has CANCELED this and will never look at it again.
block|}
comment|/**    * The class that serves as a synchronization point, and future callback,    * for async session initialization, as well as parallel cancellation.    */
specifier|private
specifier|final
class|class
name|SessionInitContext
implements|implements
name|FutureCallback
argument_list|<
name|WmTezSession
argument_list|>
block|{
specifier|private
specifier|final
name|String
name|poolName
decl_stmt|;
specifier|private
specifier|final
name|ReentrantLock
name|lock
init|=
operator|new
name|ReentrantLock
argument_list|()
decl_stmt|;
specifier|private
name|WmTezSession
name|session
decl_stmt|;
specifier|private
name|SettableFuture
argument_list|<
name|WmTezSession
argument_list|>
name|future
decl_stmt|;
specifier|private
name|SessionInitState
name|state
decl_stmt|;
specifier|private
name|String
name|cancelReason
decl_stmt|;
specifier|public
name|SessionInitContext
parameter_list|(
name|SettableFuture
argument_list|<
name|WmTezSession
argument_list|>
name|future
parameter_list|,
name|String
name|poolName
parameter_list|)
block|{
name|this
operator|.
name|state
operator|=
name|SessionInitState
operator|.
name|GETTING
expr_stmt|;
name|this
operator|.
name|future
operator|=
name|future
expr_stmt|;
name|this
operator|.
name|poolName
operator|=
name|poolName
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|onSuccess
parameter_list|(
name|WmTezSession
name|session
parameter_list|)
block|{
name|SessionInitState
name|oldState
decl_stmt|;
name|SettableFuture
argument_list|<
name|WmTezSession
argument_list|>
name|future
init|=
literal|null
decl_stmt|;
name|lock
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
name|oldState
operator|=
name|state
expr_stmt|;
switch|switch
condition|(
name|oldState
condition|)
block|{
case|case
name|GETTING
case|:
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Received a session from AM pool {}"
argument_list|,
name|session
argument_list|)
expr_stmt|;
assert|assert
name|this
operator|.
name|state
operator|==
name|SessionInitState
operator|.
name|GETTING
assert|;
name|session
operator|.
name|setPoolName
argument_list|(
name|poolName
argument_list|)
expr_stmt|;
name|session
operator|.
name|setQueueName
argument_list|(
name|yarnQueue
argument_list|)
expr_stmt|;
name|this
operator|.
name|session
operator|=
name|session
expr_stmt|;
name|this
operator|.
name|state
operator|=
name|SessionInitState
operator|.
name|WAITING_FOR_REGISTRY
expr_stmt|;
break|break;
block|}
case|case
name|WAITING_FOR_REGISTRY
case|:
block|{
assert|assert
name|this
operator|.
name|session
operator|!=
literal|null
assert|;
name|this
operator|.
name|state
operator|=
name|SessionInitState
operator|.
name|DONE
expr_stmt|;
assert|assert
name|session
operator|==
name|this
operator|.
name|session
assert|;
name|future
operator|=
name|this
operator|.
name|future
expr_stmt|;
name|this
operator|.
name|future
operator|=
literal|null
expr_stmt|;
break|break;
block|}
case|case
name|CANCELED
case|:
block|{
name|future
operator|=
name|this
operator|.
name|future
expr_stmt|;
name|this
operator|.
name|session
operator|=
literal|null
expr_stmt|;
name|this
operator|.
name|future
operator|=
literal|null
expr_stmt|;
break|break;
block|}
default|default:
block|{
name|future
operator|=
name|this
operator|.
name|future
expr_stmt|;
name|this
operator|.
name|future
operator|=
literal|null
expr_stmt|;
break|break;
block|}
block|}
block|}
finally|finally
block|{
name|lock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
switch|switch
condition|(
name|oldState
condition|)
block|{
case|case
name|GETTING
case|:
block|{
name|ListenableFuture
argument_list|<
name|WmTezSession
argument_list|>
name|waitFuture
init|=
name|session
operator|.
name|waitForAmRegistryAsync
argument_list|(
name|amRegistryTimeoutMs
argument_list|,
name|timeoutPool
argument_list|)
decl_stmt|;
name|Futures
operator|.
name|addCallback
argument_list|(
name|waitFuture
argument_list|,
name|this
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|WAITING_FOR_REGISTRY
case|:
block|{
comment|// Notify the master thread and the user.
name|future
operator|.
name|set
argument_list|(
name|session
argument_list|)
expr_stmt|;
name|notifyInitializationCompleted
argument_list|(
name|this
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|CANCELED
case|:
block|{
comment|// Return session to the pool; we can do it directly here.
name|future
operator|.
name|setException
argument_list|(
operator|new
name|HiveException
argument_list|(
literal|"The query was killed by workload management: "
operator|+
name|cancelReason
argument_list|)
argument_list|)
expr_stmt|;
name|session
operator|.
name|setPoolName
argument_list|(
literal|null
argument_list|)
expr_stmt|;
name|session
operator|.
name|setClusterFraction
argument_list|(
literal|0f
argument_list|)
expr_stmt|;
name|tezAmPool
operator|.
name|returnSession
argument_list|(
name|session
argument_list|)
expr_stmt|;
break|break;
block|}
default|default:
block|{
name|AssertionError
name|error
init|=
operator|new
name|AssertionError
argument_list|(
literal|"Unexpected state "
operator|+
name|state
argument_list|)
decl_stmt|;
name|future
operator|.
name|setException
argument_list|(
name|error
argument_list|)
expr_stmt|;
throw|throw
name|error
throw|;
block|}
block|}
block|}
annotation|@
name|Override
specifier|public
name|void
name|onFailure
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{
name|SettableFuture
argument_list|<
name|WmTezSession
argument_list|>
name|future
decl_stmt|;
name|WmTezSession
name|session
decl_stmt|;
name|boolean
name|wasCANCELED
init|=
literal|false
decl_stmt|;
name|lock
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
name|wasCANCELED
operator|=
operator|(
name|state
operator|==
name|SessionInitState
operator|.
name|CANCELED
operator|)
expr_stmt|;
name|session
operator|=
name|this
operator|.
name|session
expr_stmt|;
name|future
operator|=
name|this
operator|.
name|future
expr_stmt|;
name|this
operator|.
name|future
operator|=
literal|null
expr_stmt|;
name|this
operator|.
name|session
operator|=
literal|null
expr_stmt|;
if|if
condition|(
operator|!
name|wasCANCELED
condition|)
block|{
name|this
operator|.
name|state
operator|=
name|SessionInitState
operator|.
name|DONE
expr_stmt|;
block|}
block|}
finally|finally
block|{
name|lock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
name|future
operator|.
name|setException
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|wasCANCELED
condition|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Queueing the initialization failure with "
operator|+
name|session
argument_list|)
expr_stmt|;
block|}
name|notifyInitializationCompleted
argument_list|(
name|this
argument_list|)
expr_stmt|;
comment|// Report failure to the main thread.
block|}
if|if
condition|(
name|session
operator|!=
literal|null
condition|)
block|{
name|session
operator|.
name|clearWm
argument_list|()
expr_stmt|;
comment|// We can just restart the session if we have received one.
try|try
block|{
name|tezAmPool
operator|.
name|replaceSession
argument_list|(
name|session
argument_list|,
literal|false
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Failed to restart a failed session"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/** Cancel the async operation (even if it's done), and return the session if done. */
specifier|public
name|WmTezSession
name|cancelAndExtractSessionIfDone
parameter_list|(
name|String
name|cancelReason
parameter_list|)
block|{
name|lock
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
name|SessionInitState
name|state
init|=
name|this
operator|.
name|state
decl_stmt|;
name|this
operator|.
name|state
operator|=
name|SessionInitState
operator|.
name|CANCELED
expr_stmt|;
name|this
operator|.
name|cancelReason
operator|=
name|cancelReason
expr_stmt|;
if|if
condition|(
name|state
operator|==
name|SessionInitState
operator|.
name|DONE
condition|)
block|{
name|WmTezSession
name|result
init|=
name|this
operator|.
name|session
decl_stmt|;
name|this
operator|.
name|session
operator|=
literal|null
expr_stmt|;
return|return
name|result
return|;
block|}
else|else
block|{
comment|// In the states where a background operation is in progress, wait for the callback.
comment|// Also, ignore any duplicate calls; also don't kill failed ones - handled elsewhere.
if|if
condition|(
name|state
operator|==
name|SessionInitState
operator|.
name|CANCELED
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Duplicate call to extract "
operator|+
name|session
argument_list|)
expr_stmt|;
block|}
return|return
literal|null
return|;
block|}
block|}
finally|finally
block|{
name|lock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|/** Extracts the session and cancel the operation, both only if done. */
specifier|public
name|boolean
name|extractSessionAndCancelIfDone
parameter_list|(
name|List
argument_list|<
name|WmTezSession
argument_list|>
name|results
parameter_list|)
block|{
name|lock
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
if|if
condition|(
name|state
operator|!=
name|SessionInitState
operator|.
name|DONE
condition|)
return|return
literal|false
return|;
name|this
operator|.
name|state
operator|=
name|SessionInitState
operator|.
name|CANCELED
expr_stmt|;
if|if
condition|(
name|this
operator|.
name|session
operator|!=
literal|null
condition|)
block|{
name|results
operator|.
name|add
argument_list|(
name|this
operator|.
name|session
argument_list|)
expr_stmt|;
block|}
comment|// Otherwise we have failed; the callback has taken care of the failure.
name|this
operator|.
name|session
operator|=
literal|null
expr_stmt|;
return|return
literal|true
return|;
block|}
finally|finally
block|{
name|lock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
block|}
name|boolean
name|isManaged
parameter_list|(
name|MappingInput
name|input
parameter_list|)
block|{
comment|// This is always replaced atomically, so we don't care about concurrency here.
return|return
name|userPoolMapping
operator|.
name|mapSessionToPoolName
argument_list|(
name|input
argument_list|)
operator|!=
literal|null
return|;
block|}
annotation|@
name|VisibleForTesting
name|TezSessionPool
argument_list|<
name|WmTezSession
argument_list|>
name|getTezAmPool
parameter_list|()
block|{
return|return
name|tezAmPool
return|;
block|}
specifier|public
specifier|final
specifier|static
class|class
name|NoPoolMappingException
extends|extends
name|Exception
block|{
specifier|public
name|NoPoolMappingException
parameter_list|(
name|String
name|message
parameter_list|)
block|{
name|super
argument_list|(
name|message
argument_list|)
expr_stmt|;
block|}
specifier|private
specifier|static
specifier|final
name|long
name|serialVersionUID
init|=
literal|346375346724L
decl_stmt|;
block|}
block|}
end_class

end_unit

